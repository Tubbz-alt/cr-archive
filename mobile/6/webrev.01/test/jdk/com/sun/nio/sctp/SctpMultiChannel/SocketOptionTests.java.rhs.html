<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/com/sun/nio/sctp/SctpMultiChannel/SocketOptionTests.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 4927640
 26  * @summary Tests the SCTP protocol implementation
 27  * @author chegar
 28  */
 29 
 30 import java.io.IOException;
 31 import java.net.InetSocketAddress;
 32 import java.net.SocketAddress;
 33 import java.util.Iterator;
 34 import java.util.Set;
 35 import java.util.List;
 36 import java.util.Arrays;
 37 import java.nio.ByteBuffer;
 38 import java.nio.channels.ClosedChannelException;
 39 import com.sun.nio.sctp.AbstractNotificationHandler;
 40 import com.sun.nio.sctp.Association;
 41 import com.sun.nio.sctp.AssociationChangeNotification;
 42 import com.sun.nio.sctp.AssociationChangeNotification.AssocChangeEvent;
 43 import com.sun.nio.sctp.HandlerResult;
 44 import com.sun.nio.sctp.MessageInfo;
 45 import com.sun.nio.sctp.SctpChannel;
 46 import com.sun.nio.sctp.SctpMultiChannel;
 47 import com.sun.nio.sctp.SctpServerChannel;
 48 import com.sun.nio.sctp.SctpSocketOption;
 49 import java.security.AccessController;
 50 import java.security.PrivilegedAction;
 51 import static com.sun.nio.sctp.SctpStandardSocketOptions.*;
 52 import static java.lang.System.out;
 53 
 54 public class SocketOptionTests {
 55     final String osName = AccessController.doPrivileged(
 56                     (PrivilegedAction&lt;String&gt;)() -&gt; System.getProperty(&quot;os.name&quot;));
 57 
 58     &lt;T&gt; void checkOption(SctpMultiChannel smc, SctpSocketOption&lt;T&gt; name,
 59             T expectedValue) throws IOException {
 60         T value = smc.getOption(name, null);
 61         check(value.equals(expectedValue), name + &quot;: value (&quot; + value +
 62                 &quot;) not as expected (&quot; + expectedValue + &quot;)&quot;);
 63        }
 64 
 65     &lt;T&gt; void optionalSupport(SctpMultiChannel smc, SctpSocketOption&lt;T&gt; name,
 66             T value) {
 67         try {
 68             smc.setOption(name, value, null);
 69             checkOption(smc, name, value);
 70         } catch (IOException e) {
 71             /* Informational only, not all options have native support */
 72             out.println(name + &quot; not supported. &quot; + e);
 73         }
 74     }
 75 
 76     void test(String[] args) {
 77         if (!Util.isSCTPSupported()) {
 78             out.println(&quot;SCTP protocol is not supported&quot;);
 79             out.println(&quot;Test cannot be run&quot;);
 80             return;
 81         }
 82 
 83         try {
 84             SctpMultiChannel smc = SctpMultiChannel.open();
 85 
 86             /* check supported options */
 87             Set&lt;SctpSocketOption&lt;?&gt;&gt; options = smc.supportedOptions();
 88             List&lt;? extends SctpSocketOption&lt;?&gt;&gt; expected = Arrays.&lt;SctpSocketOption&lt;?&gt;&gt;asList(
 89                     SCTP_DISABLE_FRAGMENTS, SCTP_EXPLICIT_COMPLETE,
 90                     SCTP_FRAGMENT_INTERLEAVE, SCTP_INIT_MAXSTREAMS,
 91                     SCTP_NODELAY, SCTP_PRIMARY_ADDR, SCTP_SET_PEER_PRIMARY_ADDR,
 92                     SO_SNDBUF, SO_RCVBUF, SO_LINGER);
 93 
 94             for (SctpSocketOption opt: expected) {
 95                 if (!options.contains(opt))
 96                     fail(opt.name() + &quot; should be supported&quot;);
 97             }
 98 
 99             InitMaxStreams streams = InitMaxStreams.create(1024, 1024);
100             smc.setOption(SCTP_INIT_MAXSTREAMS, streams, null);
101             checkOption(smc, SCTP_INIT_MAXSTREAMS, streams);
102             streams = smc.getOption(SCTP_INIT_MAXSTREAMS, null);
103             check(streams.maxInStreams() == 1024, &quot;Max in streams: value: &quot;
104                     + streams.maxInStreams() + &quot;, expected 1024 &quot;);
105             check(streams.maxOutStreams() == 1024, &quot;Max out streams: value: &quot;
106                     + streams.maxOutStreams() + &quot;, expected 1024 &quot;);
107 
108             optionalSupport(smc, SCTP_DISABLE_FRAGMENTS, true);
109             optionalSupport(smc, SCTP_EXPLICIT_COMPLETE, true);
110             optionalSupport(smc, SCTP_FRAGMENT_INTERLEAVE, 1);
111 
112             smc.setOption(SCTP_NODELAY, true, null);
113             checkOption(smc, SCTP_NODELAY, true);
114             smc.setOption(SO_SNDBUF, 16*1024, null);
115             smc.setOption(SO_RCVBUF, 16*1024, null);
116 
117             checkOption(smc, SO_LINGER, -1);  /* default should be negative */
118 
<a name="2" id="anc2"></a><span class="line-modified">119             smc.setOption(SO_LINGER, 2000, null);</span>
<span class="line-modified">120             checkOption(smc, SO_LINGER, 2000);</span>



121 
122             /* SCTP_PRIMARY_ADDR */
123             sctpPrimaryAddr();
124 
125             /* NullPointerException */
126             try {
127                 smc.setOption(null, &quot;value&quot;, null);
128                 fail(&quot;NullPointerException not thrown for setOption&quot;);
129             } catch (NullPointerException unused) {
130                 pass();
131             }
132             try {
133                smc.getOption(null, null);
134                fail(&quot;NullPointerException not thrown for getOption&quot;);
135             } catch (NullPointerException unused) {
136                pass();
137             }
138 
139             /* ClosedChannelException */
140             smc.close();
141             try {
142                smc.setOption(SCTP_INIT_MAXSTREAMS, streams, null);
143                fail(&quot;ClosedChannelException not thrown&quot;);
144             } catch (ClosedChannelException unused) {
145                 pass();
146             }
147         } catch (IOException ioe) {
148             unexpected(ioe);
149         }
150     }
151 
152     /* SCTP_PRIMARY_ADDR */
153     void sctpPrimaryAddr() throws IOException {
154         ByteBuffer buffer = ByteBuffer.allocate(Util.SMALL_BUFFER);
155 
156         System.out.println(&quot;TESTING SCTP_PRIMARY_ADDR&quot;);
157 
158         /* create listening channel */
159         SctpServerChannel ssc = SctpServerChannel.open().bind(null);
160         Set&lt;SocketAddress&gt; addrs = ssc.getAllLocalAddresses();
161         if (addrs.isEmpty())
162             debug(&quot;addrs should not be empty&quot;);
163 
164         InetSocketAddress serverAddr = (InetSocketAddress) addrs.iterator().next();
165 
166         /* setup an association implicitly by sending a small message */
167         int streamNumber = 0;
168         debug(&quot;sending to &quot; + serverAddr + &quot; on stream number: &quot; + streamNumber);
169         MessageInfo info = MessageInfo.createOutgoing(serverAddr, streamNumber);
170         buffer.put(Util.SMALL_MESSAGE.getBytes(&quot;ISO-8859-1&quot;));
171         buffer.flip();
172 
173         debug(&quot;sending small message: &quot; + buffer);
174         SctpMultiChannel smc = SctpMultiChannel.open();
175         int sent = smc.send(buffer, info);
176 
177         /* Receive the COMM_UP */
178         buffer.clear();
179         SOTNotificationHandler handler = new SOTNotificationHandler();
180         info = smc.receive(buffer, null, handler);
181         check(handler.receivedCommUp(), &quot;COMM_UP no received&quot;);
182         Set&lt;Association&gt; associations = smc.associations();
183         check(!associations.isEmpty(),&quot;There should be some associations&quot;);
184         Association assoc = associations.iterator().next();
185 
186         SctpChannel peerChannel = ssc.accept();
187         ssc.close();
188         Set&lt;SocketAddress&gt; remoteAddresses = smc.getRemoteAddresses(assoc);
189         debug(&quot;Remote Addresses: &quot;);
190         for (Iterator&lt;SocketAddress&gt; it = remoteAddresses.iterator(); it.hasNext(); ) {
191             InetSocketAddress addr = (InetSocketAddress)it.next();
192             debug(&quot;\t&quot; + addr);
193         }
194 
<a name="3" id="anc3"></a><span class="line-modified">195         SocketAddress primaryAddr = smc.getOption(SCTP_PRIMARY_ADDR, assoc);</span>
<span class="line-modified">196         System.out.println(&quot;SCTP_PRIMARY_ADDR returned: &quot; + primaryAddr);</span>
<span class="line-modified">197         /* Verify that this is one of the remote addresses */</span>
<span class="line-modified">198         check(remoteAddresses.contains(primaryAddr), &quot;SCTP_PRIMARY_ADDR returned bogus address!&quot;);</span>
<span class="line-modified">199 </span>
<span class="line-modified">200         for (Iterator&lt;SocketAddress&gt; it = remoteAddresses.iterator(); it.hasNext(); ) {</span>
<span class="line-modified">201             InetSocketAddress addrToSet = (InetSocketAddress) it.next();</span>
<span class="line-modified">202             System.out.println(&quot;SCTP_PRIMARY_ADDR try set to: &quot; + addrToSet);</span>
<span class="line-modified">203             smc.setOption(SCTP_PRIMARY_ADDR, addrToSet, assoc);</span>
<span class="line-modified">204             System.out.println(&quot;SCTP_PRIMARY_ADDR set to    : &quot; + addrToSet);</span>
<span class="line-modified">205             primaryAddr = smc.getOption(SCTP_PRIMARY_ADDR, assoc);</span>
<span class="line-modified">206             System.out.println(&quot;SCTP_PRIMARY_ADDR returned  : &quot; + primaryAddr);</span>
<span class="line-modified">207             check(addrToSet.equals(primaryAddr), &quot;SCTP_PRIMARY_ADDR not set correctly&quot;);</span>









208         }
209         smc.close();
210         peerChannel.close();
211     }
212 
213     class SOTNotificationHandler extends AbstractNotificationHandler&lt;Object&gt;
214     {
215         boolean receivedCommUp;  // false
216 
217         boolean receivedCommUp() {
218             return receivedCommUp;
219         }
220 
221         @Override
222         public HandlerResult handleNotification(
223                 AssociationChangeNotification notification, Object attachment) {
224             AssocChangeEvent event = notification.event();
225             debug(&quot;AssociationChangeNotification&quot;);
226             debug(&quot;  Association: &quot; + notification.association());
227             debug(&quot;  Event: &quot; + event);
228 
229             if (event.equals(AssocChangeEvent.COMM_UP))
230                 receivedCommUp = true;
231 
232             return HandlerResult.RETURN;
233         }
234     }
235 
236             //--------------------- Infrastructure ---------------------------
237     boolean debug = true;
238     volatile int passed = 0, failed = 0;
239     void pass() {passed++;}
240     void fail() {failed++; Thread.dumpStack();}
241     void fail(String msg) {System.err.println(msg); fail();}
242     void unexpected(Throwable t) {failed++; t.printStackTrace();}
243     void check(boolean cond) {if (cond) pass(); else fail();}
244     void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
245     void debug(String message) {if(debug) { System.out.println(message); }  }
246     public static void main(String[] args) throws Throwable {
247         Class&lt;?&gt; k = new Object(){}.getClass().getEnclosingClass();
248         try {k.getMethod(&quot;instanceMain&quot;,String[].class)
249                 .invoke( k.newInstance(), (Object) args);}
250         catch (Throwable e) {throw e.getCause();}}
251     public void instanceMain(String[] args) throws Throwable {
252         try {test(args);} catch (Throwable t) {unexpected(t);}
253         System.out.printf(&quot;%nPassed = %d, failed = %d%n%n&quot;, passed, failed);
254         if (failed &gt; 0) throw new AssertionError(&quot;Some tests failed&quot;);}
255 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
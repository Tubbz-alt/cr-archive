<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/pkcs11/PKCS11Test.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 // common infrastructure for SunPKCS11 tests
 26 
 27 import java.io.BufferedReader;
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.File;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.InputStreamReader;
 33 import java.io.StringReader;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.security.AlgorithmParameters;
 39 import java.security.InvalidAlgorithmParameterException;
 40 import java.security.KeyPairGenerator;
 41 import java.security.NoSuchProviderException;
 42 import java.security.Policy;
 43 import java.security.Provider;
 44 import java.security.ProviderException;
 45 import java.security.Security;
 46 import java.security.spec.ECGenParameterSpec;
 47 import java.security.spec.ECParameterSpec;
 48 import java.util.ArrayList;
 49 import java.util.Arrays;
 50 import java.util.HashMap;
 51 import java.util.Iterator;
 52 import java.util.List;
 53 import java.util.Map;
 54 import java.util.Optional;
 55 import java.util.Properties;
 56 import java.util.ServiceConfigurationError;
 57 import java.util.ServiceLoader;
 58 import java.util.Set;
 59 
 60 import jdk.test.lib.artifacts.Artifact;
 61 import jdk.test.lib.artifacts.ArtifactResolver;
 62 import jdk.test.lib.artifacts.ArtifactResolverException;
 63 
 64 public abstract class PKCS11Test {
 65 
 66     private boolean enableSM = false;
 67 
 68     static final Properties props = System.getProperties();
 69 
 70     static final String PKCS11 = &quot;PKCS11&quot;;
 71 
 72     // directory of the test source
 73     static final String BASE = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 74 
 75     static final char SEP = File.separatorChar;
 76 
 77     private static final String DEFAULT_POLICY =
 78             BASE + SEP + &quot;..&quot; + SEP + &quot;policy&quot;;
 79 
 80     // directory corresponding to BASE in the /closed hierarchy
 81     static final String CLOSED_BASE;
 82 
 83     static {
 84         // hack
 85         String absBase = new File(BASE).getAbsolutePath();
 86         int k = absBase.indexOf(SEP + &quot;test&quot; + SEP + &quot;jdk&quot; + SEP);
 87         if (k &lt; 0) k = 0;
 88         String p1 = absBase.substring(0, k);
 89         String p2 = absBase.substring(k);
 90         CLOSED_BASE = p1 + &quot;/../closed&quot; + p2;
 91 
 92         // set it as a system property to make it available in policy file
 93         System.setProperty(&quot;closed.base&quot;, CLOSED_BASE);
 94     }
 95 
 96     // NSS version info
 97     public static enum ECCState { None, Basic, Extended };
 98     static double nss_version = -1;
 99     static ECCState nss_ecc_status = ECCState.Extended;
100 
101     // The NSS library we need to search for in getNSSLibDir()
102     // Default is &quot;libsoftokn3.so&quot;, listed as &quot;softokn3&quot;
103     // The other is &quot;libnss3.so&quot;, listed as &quot;nss3&quot;.
104     static String nss_library = &quot;softokn3&quot;;
105 
106     // NSS versions of each library.  It is simplier to keep nss_version
107     // for quick checking for generic testing than many if-else statements.
108     static double softoken3_version = -1;
109     static double nss3_version = -1;
110     static Provider pkcs11;
111 
112     // Goes through ServiceLoader instead of Provider.getInstance() since it
113     // works on all platforms
114     static {
115         ServiceLoader sl = ServiceLoader.load(java.security.Provider.class);
116         Iterator&lt;Provider&gt; iter = sl.iterator();
117         Provider p = null;
118         boolean found = false;
119         while (iter.hasNext()) {
120             try {
121                 p = iter.next();
122                 if (p.getName().equals(&quot;SunPKCS11&quot;)) {
123                     found = true;
124                     break;
125                 }
126             } catch (Exception | ServiceConfigurationError e) {
127                 // ignore and move on to the next one
128             }
129         }
130         // Nothing found through ServiceLoader; fall back to reflection
131         if (!found) {
132             try {
133                 Class clazz = Class.forName(&quot;sun.security.pkcs11.SunPKCS11&quot;);
134                 p = (Provider) clazz.newInstance();
135             } catch (Exception ex) {
136                 ex.printStackTrace();
137             }
138         }
139         pkcs11 = p;
140     }
141 
<a name="2" id="anc2"></a><span class="line-removed">142     /*</span>
<span class="line-removed">143      * Use Solaris SPARC 11.2 or later to avoid an intermittent failure</span>
<span class="line-removed">144      * when running SunPKCS11-Solaris (8044554)</span>
<span class="line-removed">145      */</span>
<span class="line-removed">146     static boolean isBadSolarisSparc(Provider p) {</span>
<span class="line-removed">147         if (&quot;SunPKCS11-Solaris&quot;.equals(p.getName()) &amp;&amp; badSolarisSparc) {</span>
<span class="line-removed">148             System.out.println(&quot;SunPKCS11-Solaris provider requires &quot; +</span>
<span class="line-removed">149                 &quot;Solaris SPARC 11.2 or later, skipping&quot;);</span>
<span class="line-removed">150             return true;</span>
<span class="line-removed">151         }</span>
<span class="line-removed">152         return false;</span>
<span class="line-removed">153     }</span>
<span class="line-removed">154 </span>
155     // Return a SunPKCS11 provider configured with the specified config file
156     static Provider getSunPKCS11(String config) throws Exception {
157         if (pkcs11 == null) {
158             throw new NoSuchProviderException(&quot;No PKCS11 provider available&quot;);
159         }
160         return pkcs11.configure(config);
161     }
162 
163     public abstract void main(Provider p) throws Exception;
164 
165     protected boolean skipTest(Provider p) {
166         return false;
167     }
168 
169     private void premain(Provider p) throws Exception {
170         if (skipTest(p)) {
171             return;
172         }
173 
174         // set a security manager and policy before a test case runs,
175         // and disable them after the test case finished
176         try {
177             if (enableSM) {
178                 System.setSecurityManager(new SecurityManager());
179             }
180             long start = System.currentTimeMillis();
181             System.out.printf(
182                     &quot;Running test with provider %s (security manager %s) ...%n&quot;,
183                         p.getName(), enableSM ? &quot;enabled&quot; : &quot;disabled&quot;);
184             main(p);
185             long stop = System.currentTimeMillis();
186             System.out.println(&quot;Completed test with provider &quot; + p.getName() +
187                 &quot; (&quot; + (stop - start) + &quot; ms).&quot;);
188         } finally {
189             if (enableSM) {
190                 System.setSecurityManager(null);
191             }
192         }
193     }
194 
195     public static void main(PKCS11Test test) throws Exception {
196         main(test, null);
197     }
198 
199     public static void main(PKCS11Test test, String[] args) throws Exception {
200         if (args != null) {
201             if (args.length &gt; 0) {
202                 if (&quot;sm&quot;.equals(args[0])) {
203                     test.enableSM = true;
204                 } else {
205                     throw new RuntimeException(&quot;Unknown Command, use &#39;sm&#39; as &quot;
206                             + &quot;first arguemtn to enable security manager&quot;);
207                 }
208             }
209             if (test.enableSM) {
210                 System.setProperty(&quot;java.security.policy&quot;,
211                         (args.length &gt; 1) ? BASE + SEP + args[1]
212                                 : DEFAULT_POLICY);
213             }
214         }
215 
216         Provider[] oldProviders = Security.getProviders();
217         try {
218             System.out.println(&quot;Beginning test run &quot; + test.getClass().getName() + &quot;...&quot;);
219             testDefault(test);
220             testNSS(test);
221             testDeimos(test);
222         } finally {
223             // NOTE: Do not place a &#39;return&#39; in any finally block
224             // as it will suppress exceptions and hide test failures.
225             Provider[] newProviders = Security.getProviders();
226             boolean found = true;
227             // Do not restore providers if nothing changed. This is especailly
228             // useful for ./Provider/Login.sh, where a SecurityManager exists.
229             if (oldProviders.length == newProviders.length) {
230                 found = false;
231                 for (int i = 0; i&lt;oldProviders.length; i++) {
232                     if (oldProviders[i] != newProviders[i]) {
233                         found = true;
234                         break;
235                     }
236                 }
237             }
238             if (found) {
239                 for (Provider p: newProviders) {
240                     Security.removeProvider(p.getName());
241                 }
242                 for (Provider p: oldProviders) {
243                     Security.addProvider(p);
244                 }
245             }
246         }
247     }
248 
249     public static void testDeimos(PKCS11Test test) throws Exception {
250         if (new File(&quot;/opt/SUNWconn/lib/libpkcs11.so&quot;).isFile() == false ||
251             &quot;true&quot;.equals(System.getProperty(&quot;NO_DEIMOS&quot;))) {
252             return;
253         }
254         String base = getBase();
255         String p11config = base + SEP + &quot;nss&quot; + SEP + &quot;p11-deimos.txt&quot;;
256         Provider p = getSunPKCS11(p11config);
257         test.premain(p);
258     }
259 
260     public static void testDefault(PKCS11Test test) throws Exception {
261         // run test for default configured PKCS11 providers (if any)
262 
263         if (&quot;true&quot;.equals(System.getProperty(&quot;NO_DEFAULT&quot;))) {
264             return;
265         }
266 
267         Provider[] providers = Security.getProviders();
268         for (int i = 0; i &lt; providers.length; i++) {
269             Provider p = providers[i];
270             if (p.getName().startsWith(&quot;SunPKCS11-&quot;)) {
271                 test.premain(p);
272             }
273         }
274     }
275 
276     private static String PKCS11_BASE;
277     static {
278         try {
279             PKCS11_BASE = getBase();
280         } catch (Exception e) {
281             // ignore
282         }
283     }
284 
285     private final static String PKCS11_REL_PATH = &quot;sun/security/pkcs11&quot;;
286 
287     public static String getBase() throws Exception {
288         if (PKCS11_BASE != null) {
289             return PKCS11_BASE;
290         }
291         File cwd = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).getCanonicalFile();
292         while (true) {
293             File file = new File(cwd, &quot;TEST.ROOT&quot;);
294             if (file.isFile()) {
295                 break;
296             }
297             cwd = cwd.getParentFile();
298             if (cwd == null) {
299                 throw new Exception(&quot;Test root directory not found&quot;);
300             }
301         }
302         PKCS11_BASE = new File(cwd, PKCS11_REL_PATH.replace(&#39;/&#39;, SEP)).getAbsolutePath();
303         return PKCS11_BASE;
304     }
305 
306     public static String getNSSLibDir() throws Exception {
307         return getNSSLibDir(nss_library);
308     }
309 
310     static String getNSSLibDir(String library) throws Exception {
311         Path libPath = getNSSLibPath(library);
312         if (libPath == null) {
313             return null;
314         }
315 
316         String libDir = String.valueOf(libPath.getParent()) + File.separatorChar;
317         System.out.println(&quot;nssLibDir: &quot; + libDir);
318         System.setProperty(&quot;pkcs11test.nss.libdir&quot;, libDir);
319         return libDir;
320     }
321 
322     private static Path getNSSLibPath() throws Exception {
323         return getNSSLibPath(nss_library);
324     }
325 
326     static Path getNSSLibPath(String library) throws Exception {
327         String osid = getOsId();
328         String[] nssLibDirs = getNssLibPaths(osid);
329         if (nssLibDirs == null) {
330             System.out.println(&quot;Warning: unsupported OS: &quot; + osid
331                     + &quot;, please initialize NSS librarys location firstly, skipping test&quot;);
332             return null;
333         }
334         if (nssLibDirs.length == 0) {
335             System.out.println(&quot;Warning: NSS not supported on this platform, skipping test&quot;);
336             return null;
337         }
338 
339         Path nssLibPath = null;
340         for (String dir : nssLibDirs) {
341             Path libPath = Paths.get(dir).resolve(System.mapLibraryName(library));
342             if (Files.exists(libPath)) {
343                 nssLibPath = libPath;
344                 break;
345             }
346         }
347         if (nssLibPath == null) {
348             System.out.println(&quot;Warning: can&#39;t find NSS librarys on this machine, skipping test&quot;);
349             return null;
350         }
351         return nssLibPath;
352     }
353 
354     private static String getOsId() {
355         String osName = props.getProperty(&quot;os.name&quot;);
356         if (osName.startsWith(&quot;Win&quot;)) {
357             osName = &quot;Windows&quot;;
358         } else if (osName.equals(&quot;Mac OS X&quot;)) {
359             osName = &quot;MacOSX&quot;;
360         }
361         String osid = osName + &quot;-&quot; + props.getProperty(&quot;os.arch&quot;) + &quot;-&quot;
362                 + props.getProperty(&quot;sun.arch.data.model&quot;);
363         return osid;
364     }
365 
366     static boolean isBadNSSVersion(Provider p) {
367         double nssVersion = getNSSVersion();
368         if (isNSS(p) &amp;&amp; nssVersion &gt;= 3.11 &amp;&amp; nssVersion &lt; 3.12) {
369             System.out.println(&quot;NSS 3.11 has a DER issue that recent &quot; +
370                     &quot;version do not, skipping&quot;);
371             return true;
372         }
373         return false;
374     }
375 
376     protected static void safeReload(String lib) throws Exception {
377         try {
378             System.load(lib);
379         } catch (UnsatisfiedLinkError e) {
380             if (e.getMessage().contains(&quot;already loaded&quot;)) {
381                 return;
382             }
383         }
384     }
385 
386     static boolean loadNSPR(String libdir) throws Exception {
387         // load NSS softoken dependencies in advance to avoid resolver issues
388         String dir = libdir.endsWith(File.separator)
389                      ? libdir
390                      : libdir + File.separator;
391         safeReload(dir + System.mapLibraryName(&quot;nspr4&quot;));
392         safeReload(dir + System.mapLibraryName(&quot;plc4&quot;));
393         safeReload(dir + System.mapLibraryName(&quot;plds4&quot;));
394         safeReload(dir + System.mapLibraryName(&quot;sqlite3&quot;));
395         safeReload(dir + System.mapLibraryName(&quot;nssutil3&quot;));
396         return true;
397     }
398 
399     // Check the provider being used is NSS
400     public static boolean isNSS(Provider p) {
401         return p.getName().toUpperCase().equals(&quot;SUNPKCS11-NSS&quot;);
402     }
403 
404     static double getNSSVersion() {
405         if (nss_version == -1)
406             getNSSInfo();
407         return nss_version;
408     }
409 
410     static ECCState getNSSECC() {
411         if (nss_version == -1)
412             getNSSInfo();
413         return nss_ecc_status;
414     }
415 
416     public static double getLibsoftokn3Version() {
417         if (softoken3_version == -1)
418             return getNSSInfo(&quot;softokn3&quot;);
419         return softoken3_version;
420     }
421 
422     public static double getLibnss3Version() {
423         if (nss3_version == -1)
424             return getNSSInfo(&quot;nss3&quot;);
425         return nss3_version;
426     }
427 
428     /* Read the library to find out the verison */
429     static void getNSSInfo() {
430         getNSSInfo(nss_library);
431     }
432 
433     // Try to parse the version for the specified library.
434     // Assuming the library contains either of the following patterns:
435     // $Header: NSS &lt;version&gt;
436     // Version: NSS &lt;version&gt;
437     // Here, &lt;version&gt; stands for NSS version.
438     static double getNSSInfo(String library) {
439         // look for two types of headers in NSS libraries
440         String nssHeader1 = &quot;$Header: NSS&quot;;
441         String nssHeader2 = &quot;Version: NSS&quot;;
442         boolean found = false;
443         String s = null;
444         int i = 0;
445         Path libfile = null;
446 
447         if (library.compareTo(&quot;softokn3&quot;) == 0 &amp;&amp; softoken3_version &gt; -1)
448             return softoken3_version;
449         if (library.compareTo(&quot;nss3&quot;) == 0 &amp;&amp; nss3_version &gt; -1)
450             return nss3_version;
451 
452         try {
453             libfile = getNSSLibPath();
454             if (libfile == null) {
455                 return 0.0;
456             }
457             try (InputStream is = Files.newInputStream(libfile)) {
458                 byte[] data = new byte[1000];
459                 int read = 0;
460 
461                 while (is.available() &gt; 0) {
462                     if (read == 0) {
463                         read = is.read(data, 0, 1000);
464                     } else {
465                         // Prepend last 100 bytes in case the header was split
466                         // between the reads.
467                         System.arraycopy(data, 900, data, 0, 100);
468                         read = 100 + is.read(data, 100, 900);
469                     }
470 
471                     s = new String(data, 0, read, StandardCharsets.US_ASCII);
472                     i = s.indexOf(nssHeader1);
473                     if (i &gt; 0 || (i = s.indexOf(nssHeader2)) &gt; 0) {
474                         found = true;
475                         // If the nssHeader is before 920 we can break, otherwise
476                         // we may not have the whole header so do another read.  If
477                         // no bytes are in the stream, that is ok, found is true.
478                         if (i &lt; 920) {
479                             break;
480                         }
481                     }
482                 }
483             }
484         } catch (Exception e) {
485             e.printStackTrace();
486         }
487 
488         if (!found) {
489             System.out.println(&quot;lib&quot; + library +
490                     &quot; version not found, set to 0.0: &quot; + libfile);
491             nss_version = 0.0;
492             return nss_version;
493         }
494 
495         // the index after whitespace after nssHeader
496         int afterheader = s.indexOf(&quot;NSS&quot;, i) + 4;
497         String version = String.valueOf(s.charAt(afterheader));
498         for (char c = s.charAt(++afterheader);
499                 c == &#39;.&#39; || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
500                 c = s.charAt(++afterheader)) {
501             version += c;
502         }
503 
504         // If a &quot;dot dot&quot; release, strip the extra dots for double parsing
505         String[] dot = version.split(&quot;\\.&quot;);
506         if (dot.length &gt; 2) {
507             version = dot[0]+&quot;.&quot;+dot[1];
508             for (int j = 2; dot.length &gt; j; j++) {
509                 version += dot[j];
510             }
511         }
512 
513         // Convert to double for easier version value checking
514         try {
515             nss_version = Double.parseDouble(version);
516         } catch (NumberFormatException e) {
517             System.out.println(&quot;===== Content start =====&quot;);
518             System.out.println(s);
519             System.out.println(&quot;===== Content end =====&quot;);
520             System.out.println(&quot;Failed to parse lib&quot; + library +
521                     &quot; version. Set to 0.0&quot;);
522             e.printStackTrace();
523         }
524 
525         System.out.print(&quot;lib&quot; + library + &quot; version = &quot;+version+&quot;.  &quot;);
526 
527         // Check for ECC
528         if (s.indexOf(&quot;Basic&quot;) &gt; 0) {
529             nss_ecc_status = ECCState.Basic;
530             System.out.println(&quot;ECC Basic.&quot;);
531         } else if (s.indexOf(&quot;Extended&quot;) &gt; 0) {
532             nss_ecc_status = ECCState.Extended;
533             System.out.println(&quot;ECC Extended.&quot;);
534         } else {
535             System.out.println(&quot;ECC None.&quot;);
536         }
537 
538         if (library.compareTo(&quot;softokn3&quot;) == 0) {
539             softoken3_version = nss_version;
540         } else if (library.compareTo(&quot;nss3&quot;) == 0) {
541             nss3_version = nss_version;
542         }
543 
544         return nss_version;
545     }
546 
547     // Used to set the nss_library file to search for libsoftokn3.so
548     public static void useNSS() {
549         nss_library = &quot;nss3&quot;;
550     }
551 
552     public static void testNSS(PKCS11Test test) throws Exception {
553         String libdir = getNSSLibDir();
554         if (libdir == null) {
555             return;
556         }
557         String base = getBase();
558 
559         if (loadNSPR(libdir) == false) {
560             return;
561         }
562 
563         String libfile = libdir + System.mapLibraryName(nss_library);
564 
565         String customDBdir = System.getProperty(&quot;CUSTOM_DB_DIR&quot;);
566         String dbdir = (customDBdir != null) ?
567                                 customDBdir :
568                                 base + SEP + &quot;nss&quot; + SEP + &quot;db&quot;;
569         // NSS always wants forward slashes for the config path
570         dbdir = dbdir.replace(&#39;\\&#39;, &#39;/&#39;);
571 
572         String customConfig = System.getProperty(&quot;CUSTOM_P11_CONFIG&quot;);
573         String customConfigName = System.getProperty(&quot;CUSTOM_P11_CONFIG_NAME&quot;, &quot;p11-nss.txt&quot;);
574         String p11config = (customConfig != null) ?
575                                 customConfig :
576                                 base + SEP + &quot;nss&quot; + SEP + customConfigName;
577 
578         System.setProperty(&quot;pkcs11test.nss.lib&quot;, libfile);
579         System.setProperty(&quot;pkcs11test.nss.db&quot;, dbdir);
580         Provider p = getSunPKCS11(p11config);
581         test.premain(p);
582     }
583 
584     // Generate a vector of supported elliptic curves of a given provider
585     static List&lt;ECParameterSpec&gt; getKnownCurves(Provider p) throws Exception {
586         int index;
587         int begin;
588         int end;
589         String curve;
590 
591         List&lt;ECParameterSpec&gt; results = new ArrayList&lt;&gt;();
592         // Get Curves to test from SunEC.
593         String kcProp = Security.getProvider(&quot;SunEC&quot;).
594                 getProperty(&quot;AlgorithmParameters.EC SupportedCurves&quot;);
595 
596         if (kcProp == null) {
597             throw new RuntimeException(
598             &quot;\&quot;AlgorithmParameters.EC SupportedCurves property\&quot; not found&quot;);
599         }
600 
601         System.out.println(&quot;Finding supported curves using list from SunEC\n&quot;);
602         index = 0;
603         for (;;) {
604             // Each set of curve names is enclosed with brackets.
605             begin = kcProp.indexOf(&#39;[&#39;, index);
606             end = kcProp.indexOf(&#39;]&#39;, index);
607             if (begin == -1 || end == -1) {
608                 break;
609             }
610 
611             /*
612              * Each name is separated by a comma.
613              * Just get the first name in the set.
614              */
615             index = end + 1;
616             begin++;
617             end = kcProp.indexOf(&#39;,&#39;, begin);
618             if (end == -1) {
619                 // Only one name in the set.
620                 end = index -1;
621             }
622 
623             curve = kcProp.substring(begin, end);
624             getSupportedECParameterSpec(curve, p)
625                 .ifPresent(spec -&gt; results.add(spec));
626         }
627 
628         if (results.size() == 0) {
629             throw new RuntimeException(&quot;No supported EC curves found&quot;);
630         }
631 
632         return results;
633     }
634 
635     static Optional&lt;ECParameterSpec&gt; getSupportedECParameterSpec(String curve,
636             Provider p) throws Exception {
637         ECParameterSpec e = getECParameterSpec(p, curve);
638         System.out.print(&quot;\t &quot;+ curve + &quot;: &quot;);
639         try {
640             KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;, p);
641             kpg.initialize(e);
642             kpg.generateKeyPair();
643             System.out.println(&quot;Supported&quot;);
644             return Optional.of(e);
645         } catch (ProviderException ex) {
646             System.out.println(&quot;Unsupported: PKCS11: &quot; +
647                     ex.getCause().getMessage());
648             return Optional.empty();
649         } catch (InvalidAlgorithmParameterException ex) {
650             System.out.println(&quot;Unsupported: Key Length: &quot; +
651                     ex.getMessage());
652             return Optional.empty();
653         }
654     }
655 
656     private static ECParameterSpec getECParameterSpec(Provider p, String name)
657             throws Exception {
658 
659         AlgorithmParameters parameters =
660             AlgorithmParameters.getInstance(&quot;EC&quot;, p);
661 
662         parameters.init(new ECGenParameterSpec(name));
663 
664         return parameters.getParameterSpec(ECParameterSpec.class);
665     }
666 
667     // Check support for a curve with a provided Vector of EC support
668     boolean checkSupport(List&lt;ECParameterSpec&gt; supportedEC,
669             ECParameterSpec curve) {
670         for (ECParameterSpec ec: supportedEC) {
671             if (ec.equals(curve)) {
672                 return true;
673             }
674         }
675         return false;
676     }
677 
678     private static Map&lt;String,String[]&gt; osMap;
679 
680     // Location of the NSS libraries on each supported platform
681     private static Map&lt;String, String[]&gt; getOsMap() {
682         if (osMap != null) {
683             return osMap;
684         }
685 
686         osMap = new HashMap&lt;&gt;();
<a name="3" id="anc3"></a><span class="line-removed">687         osMap.put(&quot;SunOS-sparc-32&quot;, new String[] { &quot;/usr/lib/mps/&quot; });</span>
<span class="line-removed">688         osMap.put(&quot;SunOS-sparcv9-64&quot;, new String[] { &quot;/usr/lib/mps/64/&quot; });</span>
<span class="line-removed">689         osMap.put(&quot;SunOS-x86-32&quot;, new String[] { &quot;/usr/lib/mps/&quot; });</span>
<span class="line-removed">690         osMap.put(&quot;SunOS-amd64-64&quot;, new String[] { &quot;/usr/lib/mps/64/&quot; });</span>
691         osMap.put(&quot;Linux-i386-32&quot;, new String[] {
692                 &quot;/usr/lib/i386-linux-gnu/&quot;,
693                 &quot;/usr/lib32/&quot;,
694                 &quot;/usr/lib/&quot; });
695         osMap.put(&quot;Linux-amd64-64&quot;, new String[] {
696                 &quot;/usr/lib/x86_64-linux-gnu/&quot;,
697                 &quot;/usr/lib/x86_64-linux-gnu/nss/&quot;,
698                 &quot;/usr/lib64/&quot; });
699         osMap.put(&quot;Linux-ppc64-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
700         osMap.put(&quot;Linux-ppc64le-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
701         osMap.put(&quot;Linux-s390x-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
702         osMap.put(&quot;Windows-x86-32&quot;, new String[] {});
703         osMap.put(&quot;Windows-amd64-64&quot;, new String[] {});
704         osMap.put(&quot;MacOSX-x86_64-64&quot;, new String[] {});
705         osMap.put(&quot;Linux-arm-32&quot;, new String[] {
706                 &quot;/usr/lib/arm-linux-gnueabi/nss/&quot;,
707                 &quot;/usr/lib/arm-linux-gnueabihf/nss/&quot; });
708         osMap.put(&quot;Linux-aarch64-64&quot;, new String[] {
709                 &quot;/usr/lib/aarch64-linux-gnu/&quot;,
710                 &quot;/usr/lib/aarch64-linux-gnu/nss/&quot; });
711         return osMap;
712     }
713 
714     private static String[] getNssLibPaths(String osId) {
715         String[] preferablePaths = getPreferableNssLibPaths(osId);
716         if (preferablePaths.length != 0) {
717             return preferablePaths;
718         } else {
719             return getOsMap().get(osId);
720         }
721     }
722 
723     private static String[] getPreferableNssLibPaths(String osId) {
724         List&lt;String&gt; nssLibPaths = new ArrayList&lt;&gt;();
725 
726         String customNssLibPaths = System.getProperty(&quot;test.nss.lib.paths&quot;);
727         if (customNssLibPaths == null) {
728             // If custom local NSS lib path is not provided,
729             // try to download NSS libs from artifactory
730             String path = fetchNssLib(osId);
731             if (path != null) {
732                 nssLibPaths.add(path);
733             }
734         } else {
735             String[] paths = customNssLibPaths.split(&quot;,&quot;);
736             for (String path : paths) {
737                 if (!path.endsWith(File.separator)) {
738                     nssLibPaths.add(path + File.separator);
739                 } else {
740                     nssLibPaths.add(path);
741                 }
742             }
743         }
744 
745         return nssLibPaths.toArray(new String[nssLibPaths.size()]);
746     }
747 
748     private final static char[] hexDigits = &quot;0123456789abcdef&quot;.toCharArray();
749 
<a name="4" id="anc4"></a><span class="line-removed">750     private static final String distro = distro();</span>
<span class="line-removed">751 </span>
<span class="line-removed">752     static final boolean badSolarisSparc =</span>
<span class="line-removed">753             System.getProperty(&quot;os.name&quot;).equals(&quot;SunOS&quot;) &amp;&amp;</span>
<span class="line-removed">754             System.getProperty(&quot;os.arch&quot;).equals(&quot;sparcv9&quot;) &amp;&amp;</span>
<span class="line-removed">755             System.getProperty(&quot;os.version&quot;).compareTo(&quot;5.11&quot;) &lt;= 0 &amp;&amp;</span>
<span class="line-removed">756             getDistro().compareTo(&quot;11.2&quot;) &lt; 0;</span>
<span class="line-removed">757 </span>
758     public static String toString(byte[] b) {
759         if (b == null) {
760             return &quot;(null)&quot;;
761         }
762         StringBuilder sb = new StringBuilder(b.length * 3);
763         for (int i = 0; i &lt; b.length; i++) {
764             int k = b[i] &amp; 0xff;
765             if (i != 0) {
766                 sb.append(&#39;:&#39;);
767             }
768             sb.append(hexDigits[k &gt;&gt;&gt; 4]);
769             sb.append(hexDigits[k &amp; 0xf]);
770         }
771         return sb.toString();
772     }
773 
774     public static byte[] parse(String s) {
775         if (s.equals(&quot;(null)&quot;)) {
776             return null;
777         }
778         try {
779             int n = s.length();
780             ByteArrayOutputStream out = new ByteArrayOutputStream(n / 3);
781             StringReader r = new StringReader(s);
782             while (true) {
783                 int b1 = nextNibble(r);
784                 if (b1 &lt; 0) {
785                     break;
786                 }
787                 int b2 = nextNibble(r);
788                 if (b2 &lt; 0) {
789                     throw new RuntimeException(&quot;Invalid string &quot; + s);
790                 }
791                 int b = (b1 &lt;&lt; 4) | b2;
792                 out.write(b);
793             }
794             return out.toByteArray();
795         } catch (IOException e) {
796             throw new RuntimeException(e);
797         }
798     }
799 
800     private static int nextNibble(StringReader r) throws IOException {
801         while (true) {
802             int ch = r.read();
803             if (ch == -1) {
804                 return -1;
805             } else if ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) {
806                 return ch - &#39;0&#39;;
807             } else if ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;f&#39;)) {
808                 return ch - &#39;a&#39; + 10;
809             } else if ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;F&#39;)) {
810                 return ch - &#39;A&#39; + 10;
811             }
812         }
813     }
814 
815     &lt;T&gt; T[] concat(T[] a, T[] b) {
816         if ((b == null) || (b.length == 0)) {
817             return a;
818         }
819         T[] r = Arrays.copyOf(a, a.length + b.length);
820         System.arraycopy(b, 0, r, a.length, b.length);
821         return r;
822     }
823 
824     /**
825      * Returns supported algorithms of specified type.
826      */
827     static List&lt;String&gt; getSupportedAlgorithms(String type, String alg,
828             Provider p) {
829         // prepare a list of supported algorithms
830         List&lt;String&gt; algorithms = new ArrayList&lt;&gt;();
831         Set&lt;Provider.Service&gt; services = p.getServices();
832         for (Provider.Service service : services) {
833             if (service.getType().equals(type)
834                     &amp;&amp; service.getAlgorithm().startsWith(alg)) {
835                 algorithms.add(service.getAlgorithm());
836             }
837         }
838         return algorithms;
839     }
840 
<a name="5" id="anc5"></a><span class="line-removed">841     /**</span>
<span class="line-removed">842      * Get the identifier for the operating system distribution</span>
<span class="line-removed">843      */</span>
<span class="line-removed">844     static String getDistro() {</span>
<span class="line-removed">845         return distro;</span>
<span class="line-removed">846     }</span>
<span class="line-removed">847 </span>
<span class="line-removed">848     private static String distro() {</span>
<span class="line-removed">849         if (props.getProperty(&quot;os.name&quot;).equals(&quot;SunOS&quot;)) {</span>
<span class="line-removed">850             try (BufferedReader in =</span>
<span class="line-removed">851                          new BufferedReader(new InputStreamReader(</span>
<span class="line-removed">852                                  Runtime.getRuntime().exec(&quot;uname -v&quot;).getInputStream()))) {</span>
<span class="line-removed">853 </span>
<span class="line-removed">854                 return in.readLine();</span>
<span class="line-removed">855             } catch (Exception e) {</span>
<span class="line-removed">856                 throw new RuntimeException(&quot;Failed to determine distro.&quot;, e);</span>
<span class="line-removed">857             }</span>
<span class="line-removed">858         } else {</span>
<span class="line-removed">859             // Not used outside Solaris</span>
<span class="line-removed">860             return null;</span>
<span class="line-removed">861         }</span>
<span class="line-removed">862     }</span>
<span class="line-removed">863 </span>
864     static byte[] generateData(int length) {
865         byte data[] = new byte[length];
866         for (int i=0; i&lt;data.length; i++) {
867             data[i] = (byte) (i % 256);
868         }
869         return data;
870     }
871 
872     private static String fetchNssLib(String osId) {
873         switch (osId) {
874         case &quot;Windows-x86-32&quot;:
875             return fetchNssLib(WINDOWS_X86.class);
876 
877         case &quot;Windows-amd64-64&quot;:
878             return fetchNssLib(WINDOWS_X64.class);
879 
880         case &quot;MacOSX-x86_64-64&quot;:
881             return fetchNssLib(MACOSX_X64.class);
882 
883         case &quot;Linux-amd64-64&quot;:
884             return fetchNssLib(LINUX_X64.class);
885 
886         default:
887             return null;
888         }
889     }
890 
891     private static String fetchNssLib(Class&lt;?&gt; clazz) {
892         String path = null;
893         try {
894             path = ArtifactResolver.resolve(clazz).entrySet().stream()
895                     .findAny().get().getValue() + File.separator + &quot;nsslib&quot;
896                     + File.separator;
897         } catch (ArtifactResolverException e) {
898             Throwable cause = e.getCause();
899             if (cause == null) {
900                 System.out.println(&quot;Cannot resolve artifact, &quot;
901                         + &quot;please check if JIB jar is present in classpath.&quot;);
902             } else {
903                 throw new RuntimeException(&quot;Fetch artifact failed: &quot; + clazz
904                         + &quot;\nPlease make sure the artifact is available.&quot;);
905             }
906         }
907         Policy.setPolicy(null); // Clear the policy created by JIB if any
908         return path;
909     }
910 
911     @Artifact(
912             organization = &quot;jpg.tests.jdk.nsslib&quot;,
913             name = &quot;nsslib-windows_x64&quot;,
914             revision = &quot;3.46-VS2017&quot;,
915             extension = &quot;zip&quot;)
916     private static class WINDOWS_X64 { }
917 
918     @Artifact(
919             organization = &quot;jpg.tests.jdk.nsslib&quot;,
920             name = &quot;nsslib-windows_x86&quot;,
921             revision = &quot;3.46-VS2017&quot;,
922             extension = &quot;zip&quot;)
923     private static class WINDOWS_X86 { }
924 
925     @Artifact(
926             organization = &quot;jpg.tests.jdk.nsslib&quot;,
927             name = &quot;nsslib-macosx_x64&quot;,
928             revision = &quot;3.46&quot;,
929             extension = &quot;zip&quot;)
930     private static class MACOSX_X64 { }
931 
932     @Artifact(
933             organization = &quot;jpg.tests.jdk.nsslib&quot;,
934             name = &quot;nsslib-linux_x64&quot;,
935             revision = &quot;3.46&quot;,
936             extension = &quot;zip&quot;)
937     private static class LINUX_X64 { }
938 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
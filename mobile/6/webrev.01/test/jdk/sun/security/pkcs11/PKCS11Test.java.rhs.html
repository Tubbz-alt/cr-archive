<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/sun/security/pkcs11/PKCS11Test.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 // common infrastructure for SunPKCS11 tests
 26 
 27 import java.io.BufferedReader;
 28 import java.io.ByteArrayOutputStream;
 29 import java.io.File;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.InputStreamReader;
 33 import java.io.StringReader;
 34 import java.nio.charset.StandardCharsets;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.security.AlgorithmParameters;
 39 import java.security.InvalidAlgorithmParameterException;
 40 import java.security.KeyPairGenerator;
 41 import java.security.NoSuchProviderException;
 42 import java.security.Policy;
 43 import java.security.Provider;
 44 import java.security.ProviderException;
 45 import java.security.Security;
 46 import java.security.spec.ECGenParameterSpec;
 47 import java.security.spec.ECParameterSpec;
 48 import java.util.ArrayList;
 49 import java.util.Arrays;
 50 import java.util.HashMap;
 51 import java.util.Iterator;
 52 import java.util.List;
 53 import java.util.Map;
 54 import java.util.Optional;
 55 import java.util.Properties;
 56 import java.util.ServiceConfigurationError;
 57 import java.util.ServiceLoader;
 58 import java.util.Set;
 59 
 60 import jdk.test.lib.artifacts.Artifact;
 61 import jdk.test.lib.artifacts.ArtifactResolver;
 62 import jdk.test.lib.artifacts.ArtifactResolverException;
 63 
 64 public abstract class PKCS11Test {
 65 
 66     private boolean enableSM = false;
 67 
 68     static final Properties props = System.getProperties();
 69 
 70     static final String PKCS11 = &quot;PKCS11&quot;;
 71 
 72     // directory of the test source
 73     static final String BASE = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 74 
 75     static final char SEP = File.separatorChar;
 76 
 77     private static final String DEFAULT_POLICY =
 78             BASE + SEP + &quot;..&quot; + SEP + &quot;policy&quot;;
 79 
 80     // directory corresponding to BASE in the /closed hierarchy
 81     static final String CLOSED_BASE;
 82 
 83     static {
 84         // hack
 85         String absBase = new File(BASE).getAbsolutePath();
 86         int k = absBase.indexOf(SEP + &quot;test&quot; + SEP + &quot;jdk&quot; + SEP);
 87         if (k &lt; 0) k = 0;
 88         String p1 = absBase.substring(0, k);
 89         String p2 = absBase.substring(k);
 90         CLOSED_BASE = p1 + &quot;/../closed&quot; + p2;
 91 
 92         // set it as a system property to make it available in policy file
 93         System.setProperty(&quot;closed.base&quot;, CLOSED_BASE);
 94     }
 95 
 96     // NSS version info
 97     public static enum ECCState { None, Basic, Extended };
 98     static double nss_version = -1;
 99     static ECCState nss_ecc_status = ECCState.Extended;
100 
101     // The NSS library we need to search for in getNSSLibDir()
102     // Default is &quot;libsoftokn3.so&quot;, listed as &quot;softokn3&quot;
103     // The other is &quot;libnss3.so&quot;, listed as &quot;nss3&quot;.
104     static String nss_library = &quot;softokn3&quot;;
105 
106     // NSS versions of each library.  It is simplier to keep nss_version
107     // for quick checking for generic testing than many if-else statements.
108     static double softoken3_version = -1;
109     static double nss3_version = -1;
110     static Provider pkcs11;
111 
112     // Goes through ServiceLoader instead of Provider.getInstance() since it
113     // works on all platforms
114     static {
115         ServiceLoader sl = ServiceLoader.load(java.security.Provider.class);
116         Iterator&lt;Provider&gt; iter = sl.iterator();
117         Provider p = null;
118         boolean found = false;
119         while (iter.hasNext()) {
120             try {
121                 p = iter.next();
122                 if (p.getName().equals(&quot;SunPKCS11&quot;)) {
123                     found = true;
124                     break;
125                 }
126             } catch (Exception | ServiceConfigurationError e) {
127                 // ignore and move on to the next one
128             }
129         }
130         // Nothing found through ServiceLoader; fall back to reflection
131         if (!found) {
132             try {
133                 Class clazz = Class.forName(&quot;sun.security.pkcs11.SunPKCS11&quot;);
134                 p = (Provider) clazz.newInstance();
135             } catch (Exception ex) {
136                 ex.printStackTrace();
137             }
138         }
139         pkcs11 = p;
140     }
141 
<a name="2" id="anc2"></a>












142     // Return a SunPKCS11 provider configured with the specified config file
143     static Provider getSunPKCS11(String config) throws Exception {
144         if (pkcs11 == null) {
145             throw new NoSuchProviderException(&quot;No PKCS11 provider available&quot;);
146         }
147         return pkcs11.configure(config);
148     }
149 
150     public abstract void main(Provider p) throws Exception;
151 
152     protected boolean skipTest(Provider p) {
153         return false;
154     }
155 
156     private void premain(Provider p) throws Exception {
157         if (skipTest(p)) {
158             return;
159         }
160 
161         // set a security manager and policy before a test case runs,
162         // and disable them after the test case finished
163         try {
164             if (enableSM) {
165                 System.setSecurityManager(new SecurityManager());
166             }
167             long start = System.currentTimeMillis();
168             System.out.printf(
169                     &quot;Running test with provider %s (security manager %s) ...%n&quot;,
170                         p.getName(), enableSM ? &quot;enabled&quot; : &quot;disabled&quot;);
171             main(p);
172             long stop = System.currentTimeMillis();
173             System.out.println(&quot;Completed test with provider &quot; + p.getName() +
174                 &quot; (&quot; + (stop - start) + &quot; ms).&quot;);
175         } finally {
176             if (enableSM) {
177                 System.setSecurityManager(null);
178             }
179         }
180     }
181 
182     public static void main(PKCS11Test test) throws Exception {
183         main(test, null);
184     }
185 
186     public static void main(PKCS11Test test, String[] args) throws Exception {
187         if (args != null) {
188             if (args.length &gt; 0) {
189                 if (&quot;sm&quot;.equals(args[0])) {
190                     test.enableSM = true;
191                 } else {
192                     throw new RuntimeException(&quot;Unknown Command, use &#39;sm&#39; as &quot;
193                             + &quot;first arguemtn to enable security manager&quot;);
194                 }
195             }
196             if (test.enableSM) {
197                 System.setProperty(&quot;java.security.policy&quot;,
198                         (args.length &gt; 1) ? BASE + SEP + args[1]
199                                 : DEFAULT_POLICY);
200             }
201         }
202 
203         Provider[] oldProviders = Security.getProviders();
204         try {
205             System.out.println(&quot;Beginning test run &quot; + test.getClass().getName() + &quot;...&quot;);
206             testDefault(test);
207             testNSS(test);
208             testDeimos(test);
209         } finally {
210             // NOTE: Do not place a &#39;return&#39; in any finally block
211             // as it will suppress exceptions and hide test failures.
212             Provider[] newProviders = Security.getProviders();
213             boolean found = true;
214             // Do not restore providers if nothing changed. This is especailly
215             // useful for ./Provider/Login.sh, where a SecurityManager exists.
216             if (oldProviders.length == newProviders.length) {
217                 found = false;
218                 for (int i = 0; i&lt;oldProviders.length; i++) {
219                     if (oldProviders[i] != newProviders[i]) {
220                         found = true;
221                         break;
222                     }
223                 }
224             }
225             if (found) {
226                 for (Provider p: newProviders) {
227                     Security.removeProvider(p.getName());
228                 }
229                 for (Provider p: oldProviders) {
230                     Security.addProvider(p);
231                 }
232             }
233         }
234     }
235 
236     public static void testDeimos(PKCS11Test test) throws Exception {
237         if (new File(&quot;/opt/SUNWconn/lib/libpkcs11.so&quot;).isFile() == false ||
238             &quot;true&quot;.equals(System.getProperty(&quot;NO_DEIMOS&quot;))) {
239             return;
240         }
241         String base = getBase();
242         String p11config = base + SEP + &quot;nss&quot; + SEP + &quot;p11-deimos.txt&quot;;
243         Provider p = getSunPKCS11(p11config);
244         test.premain(p);
245     }
246 
247     public static void testDefault(PKCS11Test test) throws Exception {
248         // run test for default configured PKCS11 providers (if any)
249 
250         if (&quot;true&quot;.equals(System.getProperty(&quot;NO_DEFAULT&quot;))) {
251             return;
252         }
253 
254         Provider[] providers = Security.getProviders();
255         for (int i = 0; i &lt; providers.length; i++) {
256             Provider p = providers[i];
257             if (p.getName().startsWith(&quot;SunPKCS11-&quot;)) {
258                 test.premain(p);
259             }
260         }
261     }
262 
263     private static String PKCS11_BASE;
264     static {
265         try {
266             PKCS11_BASE = getBase();
267         } catch (Exception e) {
268             // ignore
269         }
270     }
271 
272     private final static String PKCS11_REL_PATH = &quot;sun/security/pkcs11&quot;;
273 
274     public static String getBase() throws Exception {
275         if (PKCS11_BASE != null) {
276             return PKCS11_BASE;
277         }
278         File cwd = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;)).getCanonicalFile();
279         while (true) {
280             File file = new File(cwd, &quot;TEST.ROOT&quot;);
281             if (file.isFile()) {
282                 break;
283             }
284             cwd = cwd.getParentFile();
285             if (cwd == null) {
286                 throw new Exception(&quot;Test root directory not found&quot;);
287             }
288         }
289         PKCS11_BASE = new File(cwd, PKCS11_REL_PATH.replace(&#39;/&#39;, SEP)).getAbsolutePath();
290         return PKCS11_BASE;
291     }
292 
293     public static String getNSSLibDir() throws Exception {
294         return getNSSLibDir(nss_library);
295     }
296 
297     static String getNSSLibDir(String library) throws Exception {
298         Path libPath = getNSSLibPath(library);
299         if (libPath == null) {
300             return null;
301         }
302 
303         String libDir = String.valueOf(libPath.getParent()) + File.separatorChar;
304         System.out.println(&quot;nssLibDir: &quot; + libDir);
305         System.setProperty(&quot;pkcs11test.nss.libdir&quot;, libDir);
306         return libDir;
307     }
308 
309     private static Path getNSSLibPath() throws Exception {
310         return getNSSLibPath(nss_library);
311     }
312 
313     static Path getNSSLibPath(String library) throws Exception {
314         String osid = getOsId();
315         String[] nssLibDirs = getNssLibPaths(osid);
316         if (nssLibDirs == null) {
317             System.out.println(&quot;Warning: unsupported OS: &quot; + osid
318                     + &quot;, please initialize NSS librarys location firstly, skipping test&quot;);
319             return null;
320         }
321         if (nssLibDirs.length == 0) {
322             System.out.println(&quot;Warning: NSS not supported on this platform, skipping test&quot;);
323             return null;
324         }
325 
326         Path nssLibPath = null;
327         for (String dir : nssLibDirs) {
328             Path libPath = Paths.get(dir).resolve(System.mapLibraryName(library));
329             if (Files.exists(libPath)) {
330                 nssLibPath = libPath;
331                 break;
332             }
333         }
334         if (nssLibPath == null) {
335             System.out.println(&quot;Warning: can&#39;t find NSS librarys on this machine, skipping test&quot;);
336             return null;
337         }
338         return nssLibPath;
339     }
340 
341     private static String getOsId() {
342         String osName = props.getProperty(&quot;os.name&quot;);
343         if (osName.startsWith(&quot;Win&quot;)) {
344             osName = &quot;Windows&quot;;
345         } else if (osName.equals(&quot;Mac OS X&quot;)) {
346             osName = &quot;MacOSX&quot;;
347         }
348         String osid = osName + &quot;-&quot; + props.getProperty(&quot;os.arch&quot;) + &quot;-&quot;
349                 + props.getProperty(&quot;sun.arch.data.model&quot;);
350         return osid;
351     }
352 
353     static boolean isBadNSSVersion(Provider p) {
354         double nssVersion = getNSSVersion();
355         if (isNSS(p) &amp;&amp; nssVersion &gt;= 3.11 &amp;&amp; nssVersion &lt; 3.12) {
356             System.out.println(&quot;NSS 3.11 has a DER issue that recent &quot; +
357                     &quot;version do not, skipping&quot;);
358             return true;
359         }
360         return false;
361     }
362 
363     protected static void safeReload(String lib) throws Exception {
364         try {
365             System.load(lib);
366         } catch (UnsatisfiedLinkError e) {
367             if (e.getMessage().contains(&quot;already loaded&quot;)) {
368                 return;
369             }
370         }
371     }
372 
373     static boolean loadNSPR(String libdir) throws Exception {
374         // load NSS softoken dependencies in advance to avoid resolver issues
375         String dir = libdir.endsWith(File.separator)
376                      ? libdir
377                      : libdir + File.separator;
378         safeReload(dir + System.mapLibraryName(&quot;nspr4&quot;));
379         safeReload(dir + System.mapLibraryName(&quot;plc4&quot;));
380         safeReload(dir + System.mapLibraryName(&quot;plds4&quot;));
381         safeReload(dir + System.mapLibraryName(&quot;sqlite3&quot;));
382         safeReload(dir + System.mapLibraryName(&quot;nssutil3&quot;));
383         return true;
384     }
385 
386     // Check the provider being used is NSS
387     public static boolean isNSS(Provider p) {
388         return p.getName().toUpperCase().equals(&quot;SUNPKCS11-NSS&quot;);
389     }
390 
391     static double getNSSVersion() {
392         if (nss_version == -1)
393             getNSSInfo();
394         return nss_version;
395     }
396 
397     static ECCState getNSSECC() {
398         if (nss_version == -1)
399             getNSSInfo();
400         return nss_ecc_status;
401     }
402 
403     public static double getLibsoftokn3Version() {
404         if (softoken3_version == -1)
405             return getNSSInfo(&quot;softokn3&quot;);
406         return softoken3_version;
407     }
408 
409     public static double getLibnss3Version() {
410         if (nss3_version == -1)
411             return getNSSInfo(&quot;nss3&quot;);
412         return nss3_version;
413     }
414 
415     /* Read the library to find out the verison */
416     static void getNSSInfo() {
417         getNSSInfo(nss_library);
418     }
419 
420     // Try to parse the version for the specified library.
421     // Assuming the library contains either of the following patterns:
422     // $Header: NSS &lt;version&gt;
423     // Version: NSS &lt;version&gt;
424     // Here, &lt;version&gt; stands for NSS version.
425     static double getNSSInfo(String library) {
426         // look for two types of headers in NSS libraries
427         String nssHeader1 = &quot;$Header: NSS&quot;;
428         String nssHeader2 = &quot;Version: NSS&quot;;
429         boolean found = false;
430         String s = null;
431         int i = 0;
432         Path libfile = null;
433 
434         if (library.compareTo(&quot;softokn3&quot;) == 0 &amp;&amp; softoken3_version &gt; -1)
435             return softoken3_version;
436         if (library.compareTo(&quot;nss3&quot;) == 0 &amp;&amp; nss3_version &gt; -1)
437             return nss3_version;
438 
439         try {
440             libfile = getNSSLibPath();
441             if (libfile == null) {
442                 return 0.0;
443             }
444             try (InputStream is = Files.newInputStream(libfile)) {
445                 byte[] data = new byte[1000];
446                 int read = 0;
447 
448                 while (is.available() &gt; 0) {
449                     if (read == 0) {
450                         read = is.read(data, 0, 1000);
451                     } else {
452                         // Prepend last 100 bytes in case the header was split
453                         // between the reads.
454                         System.arraycopy(data, 900, data, 0, 100);
455                         read = 100 + is.read(data, 100, 900);
456                     }
457 
458                     s = new String(data, 0, read, StandardCharsets.US_ASCII);
459                     i = s.indexOf(nssHeader1);
460                     if (i &gt; 0 || (i = s.indexOf(nssHeader2)) &gt; 0) {
461                         found = true;
462                         // If the nssHeader is before 920 we can break, otherwise
463                         // we may not have the whole header so do another read.  If
464                         // no bytes are in the stream, that is ok, found is true.
465                         if (i &lt; 920) {
466                             break;
467                         }
468                     }
469                 }
470             }
471         } catch (Exception e) {
472             e.printStackTrace();
473         }
474 
475         if (!found) {
476             System.out.println(&quot;lib&quot; + library +
477                     &quot; version not found, set to 0.0: &quot; + libfile);
478             nss_version = 0.0;
479             return nss_version;
480         }
481 
482         // the index after whitespace after nssHeader
483         int afterheader = s.indexOf(&quot;NSS&quot;, i) + 4;
484         String version = String.valueOf(s.charAt(afterheader));
485         for (char c = s.charAt(++afterheader);
486                 c == &#39;.&#39; || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
487                 c = s.charAt(++afterheader)) {
488             version += c;
489         }
490 
491         // If a &quot;dot dot&quot; release, strip the extra dots for double parsing
492         String[] dot = version.split(&quot;\\.&quot;);
493         if (dot.length &gt; 2) {
494             version = dot[0]+&quot;.&quot;+dot[1];
495             for (int j = 2; dot.length &gt; j; j++) {
496                 version += dot[j];
497             }
498         }
499 
500         // Convert to double for easier version value checking
501         try {
502             nss_version = Double.parseDouble(version);
503         } catch (NumberFormatException e) {
504             System.out.println(&quot;===== Content start =====&quot;);
505             System.out.println(s);
506             System.out.println(&quot;===== Content end =====&quot;);
507             System.out.println(&quot;Failed to parse lib&quot; + library +
508                     &quot; version. Set to 0.0&quot;);
509             e.printStackTrace();
510         }
511 
512         System.out.print(&quot;lib&quot; + library + &quot; version = &quot;+version+&quot;.  &quot;);
513 
514         // Check for ECC
515         if (s.indexOf(&quot;Basic&quot;) &gt; 0) {
516             nss_ecc_status = ECCState.Basic;
517             System.out.println(&quot;ECC Basic.&quot;);
518         } else if (s.indexOf(&quot;Extended&quot;) &gt; 0) {
519             nss_ecc_status = ECCState.Extended;
520             System.out.println(&quot;ECC Extended.&quot;);
521         } else {
522             System.out.println(&quot;ECC None.&quot;);
523         }
524 
525         if (library.compareTo(&quot;softokn3&quot;) == 0) {
526             softoken3_version = nss_version;
527         } else if (library.compareTo(&quot;nss3&quot;) == 0) {
528             nss3_version = nss_version;
529         }
530 
531         return nss_version;
532     }
533 
534     // Used to set the nss_library file to search for libsoftokn3.so
535     public static void useNSS() {
536         nss_library = &quot;nss3&quot;;
537     }
538 
539     public static void testNSS(PKCS11Test test) throws Exception {
540         String libdir = getNSSLibDir();
541         if (libdir == null) {
542             return;
543         }
544         String base = getBase();
545 
546         if (loadNSPR(libdir) == false) {
547             return;
548         }
549 
550         String libfile = libdir + System.mapLibraryName(nss_library);
551 
552         String customDBdir = System.getProperty(&quot;CUSTOM_DB_DIR&quot;);
553         String dbdir = (customDBdir != null) ?
554                                 customDBdir :
555                                 base + SEP + &quot;nss&quot; + SEP + &quot;db&quot;;
556         // NSS always wants forward slashes for the config path
557         dbdir = dbdir.replace(&#39;\\&#39;, &#39;/&#39;);
558 
559         String customConfig = System.getProperty(&quot;CUSTOM_P11_CONFIG&quot;);
560         String customConfigName = System.getProperty(&quot;CUSTOM_P11_CONFIG_NAME&quot;, &quot;p11-nss.txt&quot;);
561         String p11config = (customConfig != null) ?
562                                 customConfig :
563                                 base + SEP + &quot;nss&quot; + SEP + customConfigName;
564 
565         System.setProperty(&quot;pkcs11test.nss.lib&quot;, libfile);
566         System.setProperty(&quot;pkcs11test.nss.db&quot;, dbdir);
567         Provider p = getSunPKCS11(p11config);
568         test.premain(p);
569     }
570 
571     // Generate a vector of supported elliptic curves of a given provider
572     static List&lt;ECParameterSpec&gt; getKnownCurves(Provider p) throws Exception {
573         int index;
574         int begin;
575         int end;
576         String curve;
577 
578         List&lt;ECParameterSpec&gt; results = new ArrayList&lt;&gt;();
579         // Get Curves to test from SunEC.
580         String kcProp = Security.getProvider(&quot;SunEC&quot;).
581                 getProperty(&quot;AlgorithmParameters.EC SupportedCurves&quot;);
582 
583         if (kcProp == null) {
584             throw new RuntimeException(
585             &quot;\&quot;AlgorithmParameters.EC SupportedCurves property\&quot; not found&quot;);
586         }
587 
588         System.out.println(&quot;Finding supported curves using list from SunEC\n&quot;);
589         index = 0;
590         for (;;) {
591             // Each set of curve names is enclosed with brackets.
592             begin = kcProp.indexOf(&#39;[&#39;, index);
593             end = kcProp.indexOf(&#39;]&#39;, index);
594             if (begin == -1 || end == -1) {
595                 break;
596             }
597 
598             /*
599              * Each name is separated by a comma.
600              * Just get the first name in the set.
601              */
602             index = end + 1;
603             begin++;
604             end = kcProp.indexOf(&#39;,&#39;, begin);
605             if (end == -1) {
606                 // Only one name in the set.
607                 end = index -1;
608             }
609 
610             curve = kcProp.substring(begin, end);
611             getSupportedECParameterSpec(curve, p)
612                 .ifPresent(spec -&gt; results.add(spec));
613         }
614 
615         if (results.size() == 0) {
616             throw new RuntimeException(&quot;No supported EC curves found&quot;);
617         }
618 
619         return results;
620     }
621 
622     static Optional&lt;ECParameterSpec&gt; getSupportedECParameterSpec(String curve,
623             Provider p) throws Exception {
624         ECParameterSpec e = getECParameterSpec(p, curve);
625         System.out.print(&quot;\t &quot;+ curve + &quot;: &quot;);
626         try {
627             KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;EC&quot;, p);
628             kpg.initialize(e);
629             kpg.generateKeyPair();
630             System.out.println(&quot;Supported&quot;);
631             return Optional.of(e);
632         } catch (ProviderException ex) {
633             System.out.println(&quot;Unsupported: PKCS11: &quot; +
634                     ex.getCause().getMessage());
635             return Optional.empty();
636         } catch (InvalidAlgorithmParameterException ex) {
637             System.out.println(&quot;Unsupported: Key Length: &quot; +
638                     ex.getMessage());
639             return Optional.empty();
640         }
641     }
642 
643     private static ECParameterSpec getECParameterSpec(Provider p, String name)
644             throws Exception {
645 
646         AlgorithmParameters parameters =
647             AlgorithmParameters.getInstance(&quot;EC&quot;, p);
648 
649         parameters.init(new ECGenParameterSpec(name));
650 
651         return parameters.getParameterSpec(ECParameterSpec.class);
652     }
653 
654     // Check support for a curve with a provided Vector of EC support
655     boolean checkSupport(List&lt;ECParameterSpec&gt; supportedEC,
656             ECParameterSpec curve) {
657         for (ECParameterSpec ec: supportedEC) {
658             if (ec.equals(curve)) {
659                 return true;
660             }
661         }
662         return false;
663     }
664 
665     private static Map&lt;String,String[]&gt; osMap;
666 
667     // Location of the NSS libraries on each supported platform
668     private static Map&lt;String, String[]&gt; getOsMap() {
669         if (osMap != null) {
670             return osMap;
671         }
672 
673         osMap = new HashMap&lt;&gt;();
<a name="3" id="anc3"></a>



674         osMap.put(&quot;Linux-i386-32&quot;, new String[] {
675                 &quot;/usr/lib/i386-linux-gnu/&quot;,
676                 &quot;/usr/lib32/&quot;,
677                 &quot;/usr/lib/&quot; });
678         osMap.put(&quot;Linux-amd64-64&quot;, new String[] {
679                 &quot;/usr/lib/x86_64-linux-gnu/&quot;,
680                 &quot;/usr/lib/x86_64-linux-gnu/nss/&quot;,
681                 &quot;/usr/lib64/&quot; });
682         osMap.put(&quot;Linux-ppc64-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
683         osMap.put(&quot;Linux-ppc64le-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
684         osMap.put(&quot;Linux-s390x-64&quot;, new String[] { &quot;/usr/lib64/&quot; });
685         osMap.put(&quot;Windows-x86-32&quot;, new String[] {});
686         osMap.put(&quot;Windows-amd64-64&quot;, new String[] {});
687         osMap.put(&quot;MacOSX-x86_64-64&quot;, new String[] {});
688         osMap.put(&quot;Linux-arm-32&quot;, new String[] {
689                 &quot;/usr/lib/arm-linux-gnueabi/nss/&quot;,
690                 &quot;/usr/lib/arm-linux-gnueabihf/nss/&quot; });
691         osMap.put(&quot;Linux-aarch64-64&quot;, new String[] {
692                 &quot;/usr/lib/aarch64-linux-gnu/&quot;,
693                 &quot;/usr/lib/aarch64-linux-gnu/nss/&quot; });
694         return osMap;
695     }
696 
697     private static String[] getNssLibPaths(String osId) {
698         String[] preferablePaths = getPreferableNssLibPaths(osId);
699         if (preferablePaths.length != 0) {
700             return preferablePaths;
701         } else {
702             return getOsMap().get(osId);
703         }
704     }
705 
706     private static String[] getPreferableNssLibPaths(String osId) {
707         List&lt;String&gt; nssLibPaths = new ArrayList&lt;&gt;();
708 
709         String customNssLibPaths = System.getProperty(&quot;test.nss.lib.paths&quot;);
710         if (customNssLibPaths == null) {
711             // If custom local NSS lib path is not provided,
712             // try to download NSS libs from artifactory
713             String path = fetchNssLib(osId);
714             if (path != null) {
715                 nssLibPaths.add(path);
716             }
717         } else {
718             String[] paths = customNssLibPaths.split(&quot;,&quot;);
719             for (String path : paths) {
720                 if (!path.endsWith(File.separator)) {
721                     nssLibPaths.add(path + File.separator);
722                 } else {
723                     nssLibPaths.add(path);
724                 }
725             }
726         }
727 
728         return nssLibPaths.toArray(new String[nssLibPaths.size()]);
729     }
730 
731     private final static char[] hexDigits = &quot;0123456789abcdef&quot;.toCharArray();
732 
<a name="4" id="anc4"></a>







733     public static String toString(byte[] b) {
734         if (b == null) {
735             return &quot;(null)&quot;;
736         }
737         StringBuilder sb = new StringBuilder(b.length * 3);
738         for (int i = 0; i &lt; b.length; i++) {
739             int k = b[i] &amp; 0xff;
740             if (i != 0) {
741                 sb.append(&#39;:&#39;);
742             }
743             sb.append(hexDigits[k &gt;&gt;&gt; 4]);
744             sb.append(hexDigits[k &amp; 0xf]);
745         }
746         return sb.toString();
747     }
748 
749     public static byte[] parse(String s) {
750         if (s.equals(&quot;(null)&quot;)) {
751             return null;
752         }
753         try {
754             int n = s.length();
755             ByteArrayOutputStream out = new ByteArrayOutputStream(n / 3);
756             StringReader r = new StringReader(s);
757             while (true) {
758                 int b1 = nextNibble(r);
759                 if (b1 &lt; 0) {
760                     break;
761                 }
762                 int b2 = nextNibble(r);
763                 if (b2 &lt; 0) {
764                     throw new RuntimeException(&quot;Invalid string &quot; + s);
765                 }
766                 int b = (b1 &lt;&lt; 4) | b2;
767                 out.write(b);
768             }
769             return out.toByteArray();
770         } catch (IOException e) {
771             throw new RuntimeException(e);
772         }
773     }
774 
775     private static int nextNibble(StringReader r) throws IOException {
776         while (true) {
777             int ch = r.read();
778             if (ch == -1) {
779                 return -1;
780             } else if ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) {
781                 return ch - &#39;0&#39;;
782             } else if ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;f&#39;)) {
783                 return ch - &#39;a&#39; + 10;
784             } else if ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;F&#39;)) {
785                 return ch - &#39;A&#39; + 10;
786             }
787         }
788     }
789 
790     &lt;T&gt; T[] concat(T[] a, T[] b) {
791         if ((b == null) || (b.length == 0)) {
792             return a;
793         }
794         T[] r = Arrays.copyOf(a, a.length + b.length);
795         System.arraycopy(b, 0, r, a.length, b.length);
796         return r;
797     }
798 
799     /**
800      * Returns supported algorithms of specified type.
801      */
802     static List&lt;String&gt; getSupportedAlgorithms(String type, String alg,
803             Provider p) {
804         // prepare a list of supported algorithms
805         List&lt;String&gt; algorithms = new ArrayList&lt;&gt;();
806         Set&lt;Provider.Service&gt; services = p.getServices();
807         for (Provider.Service service : services) {
808             if (service.getType().equals(type)
809                     &amp;&amp; service.getAlgorithm().startsWith(alg)) {
810                 algorithms.add(service.getAlgorithm());
811             }
812         }
813         return algorithms;
814     }
815 
<a name="5" id="anc5"></a>






















816     static byte[] generateData(int length) {
817         byte data[] = new byte[length];
818         for (int i=0; i&lt;data.length; i++) {
819             data[i] = (byte) (i % 256);
820         }
821         return data;
822     }
823 
824     private static String fetchNssLib(String osId) {
825         switch (osId) {
826         case &quot;Windows-x86-32&quot;:
827             return fetchNssLib(WINDOWS_X86.class);
828 
829         case &quot;Windows-amd64-64&quot;:
830             return fetchNssLib(WINDOWS_X64.class);
831 
832         case &quot;MacOSX-x86_64-64&quot;:
833             return fetchNssLib(MACOSX_X64.class);
834 
835         case &quot;Linux-amd64-64&quot;:
836             return fetchNssLib(LINUX_X64.class);
837 
838         default:
839             return null;
840         }
841     }
842 
843     private static String fetchNssLib(Class&lt;?&gt; clazz) {
844         String path = null;
845         try {
846             path = ArtifactResolver.resolve(clazz).entrySet().stream()
847                     .findAny().get().getValue() + File.separator + &quot;nsslib&quot;
848                     + File.separator;
849         } catch (ArtifactResolverException e) {
850             Throwable cause = e.getCause();
851             if (cause == null) {
852                 System.out.println(&quot;Cannot resolve artifact, &quot;
853                         + &quot;please check if JIB jar is present in classpath.&quot;);
854             } else {
855                 throw new RuntimeException(&quot;Fetch artifact failed: &quot; + clazz
856                         + &quot;\nPlease make sure the artifact is available.&quot;);
857             }
858         }
859         Policy.setPolicy(null); // Clear the policy created by JIB if any
860         return path;
861     }
862 
863     @Artifact(
864             organization = &quot;jpg.tests.jdk.nsslib&quot;,
865             name = &quot;nsslib-windows_x64&quot;,
866             revision = &quot;3.46-VS2017&quot;,
867             extension = &quot;zip&quot;)
868     private static class WINDOWS_X64 { }
869 
870     @Artifact(
871             organization = &quot;jpg.tests.jdk.nsslib&quot;,
872             name = &quot;nsslib-windows_x86&quot;,
873             revision = &quot;3.46-VS2017&quot;,
874             extension = &quot;zip&quot;)
875     private static class WINDOWS_X86 { }
876 
877     @Artifact(
878             organization = &quot;jpg.tests.jdk.nsslib&quot;,
879             name = &quot;nsslib-macosx_x64&quot;,
880             revision = &quot;3.46&quot;,
881             extension = &quot;zip&quot;)
882     private static class MACOSX_X64 { }
883 
884     @Artifact(
885             organization = &quot;jpg.tests.jdk.nsslib&quot;,
886             name = &quot;nsslib-linux_x64&quot;,
887             revision = &quot;3.46&quot;,
888             extension = &quot;zip&quot;)
889     private static class LINUX_X64 { }
890 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
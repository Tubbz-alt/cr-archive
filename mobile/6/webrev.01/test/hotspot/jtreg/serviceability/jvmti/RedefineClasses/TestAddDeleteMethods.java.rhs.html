<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/serviceability/jvmti/RedefineClasses/TestAddDeleteMethods.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8192936
<a name="2" id="anc2"></a>
 27  * @summary RI does not follow the JVMTI RedefineClasses spec; need to disallow adding and deleting methods
 28  * @library /test/lib
 29  * @modules java.base/jdk.internal.misc
 30  * @modules java.compiler
 31  *          java.instrument
 32  *          jdk.jartool/sun.tools.jar
 33  * @run main RedefineClassHelper
 34  * @run main/othervm -javaagent:redefineagent.jar TestAddDeleteMethods AllowAddDelete=no
 35  * @run main/othervm -javaagent:redefineagent.jar -XX:+AllowRedefinitionToAddDeleteMethods TestAddDeleteMethods AllowAddDelete=yes
 36  */
 37 
 38 import static jdk.test.lib.Asserts.assertEquals;
 39 import java.lang.Runnable;
 40 
 41 // package access top-level class to avoid problem with RedefineClassHelper
 42 // and nested types.
 43 class A implements Runnable {
 44     private        void foo()       { System.out.println(&quot; OLD foo called&quot;); }
 45     public         void publicFoo() { System.out.println(&quot; OLD publicFoo called&quot;); }
 46     private final  void finalFoo()  { System.out.println(&quot; OLD finalFoo called&quot;);  }
 47     private static void staticFoo() { System.out.println(&quot; OLD staticFoo called&quot;); }
 48     public         void run()       { foo(); publicFoo(); finalFoo(); staticFoo(); }
 49 }
 50 
 51 class B implements Runnable {
 52     public         void run() { }
 53 }
 54 
 55 public class TestAddDeleteMethods {
 56     static private boolean allowAddDeleteMethods = false;
 57 
 58     static private A a;
 59     static private B b;
 60 
 61     // This redefinition is expected to always succeed.
 62     public static String newA =
 63         &quot;class A implements Runnable {&quot; +
 64             &quot;private        void foo()       { System.out.println(\&quot; NEW foo called\&quot;); }&quot; +
 65             &quot;public         void publicFoo() { System.out.println(\&quot; NEW publicFoo called\&quot;); }&quot; +
 66             &quot;private final  void finalFoo()  { System.out.println(\&quot; NEW finalFoo called\&quot;);  }&quot; +
 67             &quot;private static void staticFoo() { System.out.println(\&quot; NEW staticFoo called\&quot;); }&quot; +
 68             &quot;public         void run()       { foo(); publicFoo(); finalFoo(); staticFoo(); }&quot; +
 69         &quot;}&quot;;
 70 
 71     // This redefinition is expected to always fail.
 72     public static String ADeleteFoo =
 73         &quot;class A implements Runnable {&quot; +
 74             &quot;public         void publicFoo() { System.out.println(\&quot; NEW publicFoo called\&quot;); }&quot; +
 75             &quot;private final  void finalFoo()  { System.out.println(\&quot; NEW finalFoo called\&quot;);  }&quot; +
 76             &quot;private static void staticFoo() { System.out.println(\&quot; NEW staticFoo called\&quot;); }&quot; +
 77             &quot;public         void run()       { publicFoo(); finalFoo(); staticFoo(); }&quot; +
 78         &quot;}&quot;;
 79 
 80     // This redefinition is expected to always fail.
 81     public static String ADeletePublicFoo =
 82         &quot;class A implements Runnable {&quot; +
 83             &quot;private        void foo()       { System.out.println(\&quot; NEW foo called\&quot;); }&quot; +
 84             &quot;private final  void finalFoo()  { System.out.println(\&quot; NEW finalFoo called\&quot;);  }&quot; +
 85             &quot;private static void staticFoo() { System.out.println(\&quot; NEW staticFoo called\&quot;); }&quot; +
 86             &quot;public         void run()       { foo(); finalFoo(); staticFoo(); }&quot; +
 87         &quot;}&quot;;
 88 
 89     // This redefinition is expected to succeed with option -XX:+AllowRedefinitionToAddDeleteMethods.
 90     public static String ADeleteFinalFoo =
 91         &quot;class A implements Runnable {&quot; +
 92             &quot;private        void foo()       { System.out.println(\&quot; NEW foo called\&quot;); }&quot; +
 93             &quot;public         void publicFoo() { System.out.println(\&quot; NEW publicFoo called\&quot;); }&quot; +
 94             &quot;private static void staticFoo() { System.out.println(\&quot; NEW staticFoo called\&quot;); }&quot; +
 95             &quot;public         void run()       { foo(); publicFoo(); staticFoo(); }&quot; +
 96         &quot;}&quot;;
 97 
 98     // This redefinition is expected to succeed with option -XX:+AllowRedefinitionToAddDeleteMethods.
 99     // With compatibility option redefinition ADeleteFinalFoo already deleted finalFoo method.
100     // So, this redefinition will add it back which is expected to work.
101     public static String ADeleteStaticFoo =
102         &quot;class A implements Runnable {&quot; +
103             &quot;private        void foo()       { System.out.println(\&quot; NEW foo called\&quot;); }&quot; +
104             &quot;public         void publicFoo() { System.out.println(\&quot; NEW publicFoo called\&quot;); }&quot; +
105             &quot;private final  void finalFoo()  { System.out.println(\&quot; NEW finalFoo called\&quot;);  }&quot; +
106             &quot;public         void run()       { foo(); publicFoo(); finalFoo(); }&quot; +
107         &quot;}&quot;;
108 
109     // This redefinition is expected to always fail.
110     public static String BAddBar =
111         &quot;class B implements Runnable {&quot; +
112             &quot;private        void bar()       { System.out.println(\&quot; bar called\&quot;); }&quot; +
113             &quot;public         void run()       { bar(); }&quot; +
114         &quot;}&quot;;
115 
116     // This redefinition is expected to always fail.
117     public static String BAddPublicBar =
118         &quot;class B implements Runnable {&quot; +
119             &quot;public         void publicBar() { System.out.println(\&quot; publicBar called\&quot;); }&quot; +
120             &quot;public         void run()       { publicBar(); }&quot; +
121         &quot;}&quot;;
122 
123     // This redefinition is expected to succeed with option -XX:+AllowRedefinitionToAddDeleteMethods.
124     public static String BAddFinalBar =
125         &quot;class B implements Runnable {&quot; +
126             &quot;private final  void finalBar()  { System.out.println(\&quot; finalBar called\&quot;); }&quot; +
127             &quot;public         void run()       { finalBar(); }&quot; +
128         &quot;}&quot;;
129 
130     // This redefinition is expected to succeed with option -XX:+AllowRedefinitionToAddDeleteMethods.
131     // With compatibility option redefinition BAddFinalBar added finalBar method.
132     // So, this redefinition will deleate it back which is expected to work.
133     public static String BAddStaticBar =
134         &quot;class B implements Runnable {&quot; +
135             &quot;private static void staticBar() { System.out.println(\&quot; staticBar called\&quot;); }&quot; +
136             &quot;public         void run()       { staticBar(); }&quot; +
137         &quot;}&quot;;
138 
139     static private final String ExpMsgPrefix = &quot;attempted to &quot;;
140     static private final String ExpMsgPostfix = &quot; a method&quot;;
141 
142     static private void log(String msg) { System.out.println(msg); }
143 
144     public static void test(Runnable obj, String newBytes, String expSuffix, String methodName,
145                             boolean expectedRedefToPass) throws Exception {
146         String expectedMessage = ExpMsgPrefix + expSuffix + ExpMsgPostfix;
147         Class klass = obj.getClass();
148         String className = klass.getName();
149         String expResult = expectedRedefToPass ? &quot;PASS&quot; : &quot;FAIL&quot;;
150 
151         log(&quot;&quot;);
152         log(&quot;## Test &quot; + expSuffix + &quot; method \&#39;&quot; + methodName + &quot;\&#39; in class &quot; + className +
153             &quot;; redefinition expected to &quot; + expResult);
154 
155         try {
156             RedefineClassHelper.redefineClass(klass, newBytes);
157 
158             if (expectedRedefToPass) {
159                 log(&quot; Did not get UOE at redefinition as expected&quot;);
160             } else {
161                 throw new RuntimeException(&quot;Failed, expected UOE&quot;);
162             }
163             obj.run();
164             log(&quot;&quot;);
165         } catch (UnsupportedOperationException uoe) {
166             String message = uoe.getMessage();
167 
168             if (expectedRedefToPass) {
169                 throw new RuntimeException(&quot;Failed, unexpected UOE: &quot; + message);
170             } else {
171                 log(&quot; Got expected UOE: &quot; + message);
172                 if (!message.endsWith(expectedMessage)) {
173                     throw new RuntimeException(&quot;Expected UOE error message to end with: &quot; + expectedMessage);
174                 }
175             }
176         }
177     }
178 
179     static {
180         a = new A();
181         b = new B();
182     }
183 
184     public static void main(String[] args) throws Exception {
185         if (args.length &gt; 0 &amp;&amp; args[0].equals(&quot;AllowAddDelete=yes&quot;)) {
186             allowAddDeleteMethods = true;
187         }
188 
189         log(&quot;## Test original class A&quot;);
190         a.run();
191         log(&quot;&quot;);
192 
193         log(&quot;## Test with modified method bodies in class A; redefinition expected to pass: true&quot;);
194         RedefineClassHelper.redefineClass(A.class, newA);
195         a.run();
196 
197         test(a, ADeleteFoo,       &quot;delete&quot;, &quot;foo&quot;,       false);
198         test(a, ADeletePublicFoo, &quot;delete&quot;, &quot;publicFoo&quot;, false);
199         test(a, ADeleteFinalFoo,  &quot;delete&quot;, &quot;finalFoo&quot;,  allowAddDeleteMethods);
200         test(a, ADeleteStaticFoo, &quot;delete&quot;, &quot;staticFoo&quot;, allowAddDeleteMethods);
201 
202         test(b, BAddBar,          &quot;add&quot;, &quot;bar&quot;,       false);
203         test(b, BAddPublicBar,    &quot;add&quot;, &quot;publicBar&quot;, false);
204         test(b, BAddFinalBar,     &quot;add&quot;, &quot;finalBar&quot;,  allowAddDeleteMethods);
205         test(b, BAddStaticBar,    &quot;add&quot;, &quot;staticBar&quot;, allowAddDeleteMethods);
206     }
207 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
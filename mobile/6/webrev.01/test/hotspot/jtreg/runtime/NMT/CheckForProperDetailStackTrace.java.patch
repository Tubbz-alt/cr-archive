diff a/test/hotspot/jtreg/runtime/NMT/CheckForProperDetailStackTrace.java b/test/hotspot/jtreg/runtime/NMT/CheckForProperDetailStackTrace.java
--- a/test/hotspot/jtreg/runtime/NMT/CheckForProperDetailStackTrace.java
+++ b/test/hotspot/jtreg/runtime/NMT/CheckForProperDetailStackTrace.java
@@ -67,11 +67,11 @@
         ".*Hashtable.*allocate_new_entry.*\n" +
         ".*ModuleEntryTable.*locked_create_entry.*\n" +
         ".*Modules.*define_module.*\n" +
         ".*JVM_DefineModule.*\n";
 
-    /* The stack trace we look for on AIX, Solaris and Windows slowdebug builds.
+    /* The stack trace we look for on AIX and Windows slowdebug builds.
        ALWAYSINLINE is only a hint and is ignored for AllocateHeap on the
        aforementioned platforms. When that happens allocate_new_entry is
        inlined instead.
     */
     private static String stackTraceAllocateHeap =
@@ -96,14 +96,14 @@
         // We should never see either of these frames because they are supposed to be skipped.
         output.shouldNotContain("NativeCallStack::NativeCallStack");
         output.shouldNotContain("os::get_native_stack");
 
         // AllocateHeap shouldn't be in the output because it is supposed to always be inlined.
-        // We check for that here, but allow it for Aix, Solaris and Windows slowdebug builds
+        // We check for that here, but allow it for Aix and Windows slowdebug builds
         // because the compiler ends up not inlining AllocateHeap.
         Boolean okToHaveAllocateHeap = Platform.isSlowDebugBuild() &&
-                                       (Platform.isAix() || Platform.isSolaris() || Platform.isWindows());
+                                       (Platform.isAix() || Platform.isWindows());
         if (!okToHaveAllocateHeap) {
             output.shouldNotContain("AllocateHeap");
         }
 
         // See if we have any stack trace symbols in the output

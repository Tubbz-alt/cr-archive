<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../CompressedOops/UseCompressedOops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../NMT/CheckForProperDetailStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/ErrorHandling/TimeoutInErrorHandlingTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 import jdk.test.lib.process.ProcessTools;
 33 
 34 /*
 35  * @test
 36  * @bug 8166944
 37  * @summary Hanging Error Reporting steps may lead to torn error logs
 38  * @modules java.base/jdk.internal.misc
 39  * @library /test/lib
 40  * @requires (vm.debug == true) &amp; (os.family != &quot;windows&quot;)
 41  * @run driver TimeoutInErrorHandlingTest
 42  * @author Thomas Stuefe (SAP)
 43  */
 44 
 45 public class TimeoutInErrorHandlingTest {
 46 
 47     public static final boolean verbose = System.getProperty(&quot;verbose&quot;) != null;
 48     // 16 seconds for hs_err generation timeout = 4 seconds per step timeout
 49     public static final int ERROR_LOG_TIMEOUT = 16;
 50 
 51     public static void main(String[] args) throws Exception {
<span class="line-removed"> 52 </span>
<span class="line-removed"> 53         int error_log_timeout = ERROR_LOG_TIMEOUT;</span>
<span class="line-removed"> 54         if (&quot;SunOS&quot;.equals(System.getProperty(&quot;os.name&quot;))) {</span>
<span class="line-removed"> 55             // Give Solaris machines 3X as much time:</span>
<span class="line-removed"> 56             error_log_timeout *= 3;</span>
<span class="line-removed"> 57         }</span>
<span class="line-removed"> 58 </span>
 59         /* Start the VM and let it crash. Specify TestUnresponsiveErrorHandler which will
 60          * let five subsequent error reporting steps hang. The Timeout handling triggered
 61          * by the WatcherThread should kick in and interrupt those steps. In theory, the
 62          * text &quot;timeout occurred during error reporting in step ..&quot; (the little timeouts)
 63          * should occur in the error log up to four times, followed by the final big timeout
 64          * &quot;------ Timeout during error reporting after xx s. ------&quot;
 65          *
 66          * Note that there are a number of uncertainties which make writing a 100% foolproof
 67          * test challenging. The time the error reporting thread takes to react to the
 68          * timeout triggers is unknown. So it is difficult to predict how many little timeouts
 69          * will be visible before the big timeout kicks in. Also, once the big timeout hits,
 70          * error reporting thread and Watcherthread will race. The former writes his last
 71          * message to the error logs and flushes, the latter waits 200ms and then exits the
 72          * process without further synchronization with the error reporting thread.
 73          *
 74          * Because of all this and the desire to write a bullet proof test which does
 75          * not fail sporadically, we will not test for the final timeout message nor for all
 76          * of the optimally expected little timeout messages. We just test for two of the
 77          * little timeout messages to see that repeated timeout handling is basically working.
 78          */
 79 
 80         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
 81             &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
 82             &quot;-Xmx100M&quot;,
 83             &quot;-XX:ErrorHandlerTest=14&quot;,
 84             &quot;-XX:+TestUnresponsiveErrorHandler&quot;,
<span class="line-modified"> 85             &quot;-XX:ErrorLogTimeout=&quot; + error_log_timeout,</span>
 86             &quot;-XX:-CreateCoredumpOnCrash&quot;,
 87             &quot;-version&quot;);
 88 
 89         OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());
 90 
 91         if (verbose) {
 92             System.err.println(&quot;&lt;begin cmd output&gt;&quot;);
 93             System.err.println(output_detail.getOutput());
 94             System.err.println(&quot;&lt;end cmd output&gt;&quot;);
 95         }
 96 
 97         // we should have crashed with a SIGSEGV
 98         output_detail.shouldMatch(&quot;# A fatal error has been detected by the Java Runtime Environment:.*&quot;);
 99         output_detail.shouldMatch(&quot;# +(?:SIGSEGV|SIGBUS|EXCEPTION_ACCESS_VIOLATION).*&quot;);
100 
101         // VM should have been aborted by WatcherThread
102         output_detail.shouldMatch(&quot;.*timer expired, abort.*&quot;);
103 
104         // extract hs-err file
105         String hs_err_file = output_detail.firstMatch(&quot;# *(\\S*hs_err_pid\\d+\\.log)&quot;, 1);
</pre>
</td>
<td>
<hr />
<pre>
 32 import jdk.test.lib.process.ProcessTools;
 33 
 34 /*
 35  * @test
 36  * @bug 8166944
 37  * @summary Hanging Error Reporting steps may lead to torn error logs
 38  * @modules java.base/jdk.internal.misc
 39  * @library /test/lib
 40  * @requires (vm.debug == true) &amp; (os.family != &quot;windows&quot;)
 41  * @run driver TimeoutInErrorHandlingTest
 42  * @author Thomas Stuefe (SAP)
 43  */
 44 
 45 public class TimeoutInErrorHandlingTest {
 46 
 47     public static final boolean verbose = System.getProperty(&quot;verbose&quot;) != null;
 48     // 16 seconds for hs_err generation timeout = 4 seconds per step timeout
 49     public static final int ERROR_LOG_TIMEOUT = 16;
 50 
 51     public static void main(String[] args) throws Exception {







 52         /* Start the VM and let it crash. Specify TestUnresponsiveErrorHandler which will
 53          * let five subsequent error reporting steps hang. The Timeout handling triggered
 54          * by the WatcherThread should kick in and interrupt those steps. In theory, the
 55          * text &quot;timeout occurred during error reporting in step ..&quot; (the little timeouts)
 56          * should occur in the error log up to four times, followed by the final big timeout
 57          * &quot;------ Timeout during error reporting after xx s. ------&quot;
 58          *
 59          * Note that there are a number of uncertainties which make writing a 100% foolproof
 60          * test challenging. The time the error reporting thread takes to react to the
 61          * timeout triggers is unknown. So it is difficult to predict how many little timeouts
 62          * will be visible before the big timeout kicks in. Also, once the big timeout hits,
 63          * error reporting thread and Watcherthread will race. The former writes his last
 64          * message to the error logs and flushes, the latter waits 200ms and then exits the
 65          * process without further synchronization with the error reporting thread.
 66          *
 67          * Because of all this and the desire to write a bullet proof test which does
 68          * not fail sporadically, we will not test for the final timeout message nor for all
 69          * of the optimally expected little timeout messages. We just test for two of the
 70          * little timeout messages to see that repeated timeout handling is basically working.
 71          */
 72 
 73         ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
 74             &quot;-XX:+UnlockDiagnosticVMOptions&quot;,
 75             &quot;-Xmx100M&quot;,
 76             &quot;-XX:ErrorHandlerTest=14&quot;,
 77             &quot;-XX:+TestUnresponsiveErrorHandler&quot;,
<span class="line-modified"> 78             &quot;-XX:ErrorLogTimeout=&quot; + ERROR_LOG_TIMEOUT,</span>
 79             &quot;-XX:-CreateCoredumpOnCrash&quot;,
 80             &quot;-version&quot;);
 81 
 82         OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());
 83 
 84         if (verbose) {
 85             System.err.println(&quot;&lt;begin cmd output&gt;&quot;);
 86             System.err.println(output_detail.getOutput());
 87             System.err.println(&quot;&lt;end cmd output&gt;&quot;);
 88         }
 89 
 90         // we should have crashed with a SIGSEGV
 91         output_detail.shouldMatch(&quot;# A fatal error has been detected by the Java Runtime Environment:.*&quot;);
 92         output_detail.shouldMatch(&quot;# +(?:SIGSEGV|SIGBUS|EXCEPTION_ACCESS_VIOLATION).*&quot;);
 93 
 94         // VM should have been aborted by WatcherThread
 95         output_detail.shouldMatch(&quot;.*timer expired, abort.*&quot;);
 96 
 97         // extract hs-err file
 98         String hs_err_file = output_detail.firstMatch(&quot;# *(\\S*hs_err_pid\\d+\\.log)&quot;, 1);
</pre>
</td>
</tr>
</table>
<center><a href="../CompressedOops/UseCompressedOops.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../NMT/CheckForProperDetailStackTrace.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.security.jgss/share/classes/sun/security/krb5/Config.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  *
  28  *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
  29  *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
  30  */
  31 package sun.security.krb5;
  32 
  33 import java.io.*;
  34 import java.nio.file.DirectoryStream;
  35 import java.nio.file.Files;
  36 import java.nio.file.Paths;
  37 import java.nio.file.Path;
  38 import java.security.PrivilegedAction;
  39 import java.util.*;
  40 import java.net.InetAddress;
  41 import java.net.UnknownHostException;
  42 import java.security.AccessController;
  43 import java.security.PrivilegedExceptionAction;
  44 import java.util.regex.Matcher;
  45 import java.util.regex.Pattern;
  46 
  47 import sun.net.dns.ResolverConfiguration;
  48 import sun.security.action.GetPropertyAction;
  49 import sun.security.krb5.internal.crypto.EType;
  50 import sun.security.krb5.internal.Krb5;
  51 import sun.security.util.SecurityProperties;
  52 
  53 /**
  54  * This class maintains key-value pairs of Kerberos configurable constants
  55  * from configuration file or from user specified system properties.
  56  */
  57 
  58 public class Config {
  59 
  60     /**
  61      * {@systemProperty sun.security.krb5.disableReferrals} property
  62      * indicating whether or not cross-realm referrals (RFC 6806) are
  63      * enabled.
  64      */
  65     public static final boolean DISABLE_REFERRALS;
  66 
  67     /**
  68      * {@systemProperty sun.security.krb5.maxReferrals} property
  69      * indicating the maximum number of cross-realm referral
  70      * hops allowed.
  71      */
  72     public static final int MAX_REFERRALS;
  73 
  74     static {
  75         String disableReferralsProp =
  76                 SecurityProperties.privilegedGetOverridable(
  77                         &quot;sun.security.krb5.disableReferrals&quot;);
  78         if (disableReferralsProp != null) {
  79             DISABLE_REFERRALS = &quot;true&quot;.equalsIgnoreCase(disableReferralsProp);
  80         } else {
  81             DISABLE_REFERRALS = false;
  82         }
  83 
  84         int maxReferralsValue = 5;
  85         String maxReferralsProp =
  86                 SecurityProperties.privilegedGetOverridable(
  87                         &quot;sun.security.krb5.maxReferrals&quot;);
  88         try {
  89             maxReferralsValue = Integer.parseInt(maxReferralsProp);
  90         } catch (NumberFormatException e) {
  91         }
  92         MAX_REFERRALS = maxReferralsValue;
  93     }
  94 
  95     /*
  96      * Only allow a single instance of Config.
  97      */
  98     private static Config singleton = null;
  99 
 100     /*
 101      * Hashtable used to store configuration information.
 102      */
 103     private Hashtable&lt;String,Object&gt; stanzaTable = new Hashtable&lt;&gt;();
 104 
 105     private static boolean DEBUG = sun.security.krb5.internal.Krb5.DEBUG;
 106 
 107     // these are used for hexdecimal calculation.
 108     private static final int BASE16_0 = 1;
 109     private static final int BASE16_1 = 16;
 110     private static final int BASE16_2 = 16 * 16;
 111     private static final int BASE16_3 = 16 * 16 * 16;
 112 
 113     /**
 114      * Specified by system properties. Must be both null or non-null.
 115      */
 116     private final String defaultRealm;
 117     private final String defaultKDC;
 118 
 119     // used for native interface
 120     private static native String getWindowsDirectory(boolean isSystem);
 121 
 122 
 123     /**
 124      * Gets an instance of Config class. One and only one instance (the
 125      * singleton) is returned.
 126      *
 127      * @exception KrbException if error occurs when constructing a Config
 128      * instance. Possible causes would be either of java.security.krb5.realm or
 129      * java.security.krb5.kdc not specified, error reading configuration file.
 130      */
 131     public static synchronized Config getInstance() throws KrbException {
 132         if (singleton == null) {
 133             singleton = new Config();
 134         }
 135         return singleton;
 136     }
 137 
 138     /**
 139      * Refresh and reload the Configuration. This could involve,
 140      * for example reading the Configuration file again or getting
 141      * the java.security.krb5.* system properties again. This method
 142      * also tries its best to update static fields in other classes
 143      * that depend on the configuration.
 144      *
 145      * @exception KrbException if error occurs when constructing a Config
 146      * instance. Possible causes would be either of java.security.krb5.realm or
 147      * java.security.krb5.kdc not specified, error reading configuration file.
 148      */
 149 
 150     public static void refresh() throws KrbException {
 151         synchronized (Config.class) {
 152             singleton = new Config();
 153         }
 154         KdcComm.initStatic();
 155         EType.initStatic();
 156         Checksum.initStatic();
 157         KrbAsReqBuilder.ReferralsState.initStatic();
 158     }
 159 
 160 
 161     private static boolean isMacosLionOrBetter() {
 162         // split the &quot;10.x.y&quot; version number
 163         String osname = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
 164         if (!osname.contains(&quot;OS X&quot;)) {
 165             return false;
 166         }
 167 
 168         String osVersion = GetPropertyAction.privilegedGetProperty(&quot;os.version&quot;);
 169         String[] fragments = osVersion.split(&quot;\\.&quot;);
 170 
 171         // sanity check the &quot;10.&quot; part of the version
 172         if (!fragments[0].equals(&quot;10&quot;)) return false;
 173         if (fragments.length &lt; 2) return false;
 174 
 175         // check if Mac OS X 10.7(.y)
 176         try {
 177             int minorVers = Integer.parseInt(fragments[1]);
 178             if (minorVers &gt;= 7) return true;
 179         } catch (NumberFormatException e) {
 180             // was not an integer
 181         }
 182 
 183         return false;
 184     }
 185 
 186     /**
 187      * Private constructor - can not be instantiated externally.
 188      */
 189     private Config() throws KrbException {
 190         /*
 191          * If either one system property is specified, we throw exception.
 192          */
 193         String tmp = GetPropertyAction
 194                 .privilegedGetProperty(&quot;java.security.krb5.kdc&quot;);
 195         if (tmp != null) {
 196             // The user can specify a list of kdc hosts separated by &quot;:&quot;
 197             defaultKDC = tmp.replace(&#39;:&#39;, &#39; &#39;);
 198         } else {
 199             defaultKDC = null;
 200         }
 201         defaultRealm = GetPropertyAction
 202                 .privilegedGetProperty(&quot;java.security.krb5.realm&quot;);
 203         if ((defaultKDC == null &amp;&amp; defaultRealm != null) ||
 204             (defaultRealm == null &amp;&amp; defaultKDC != null)) {
 205             throw new KrbException
 206                 (&quot;System property java.security.krb5.kdc and &quot; +
 207                  &quot;java.security.krb5.realm both must be set or &quot; +
 208                  &quot;neither must be set.&quot;);
 209         }
 210 
 211         // Always read the Kerberos configuration file
 212         try {
 213             List&lt;String&gt; configFile;
 214             String fileName = getJavaFileName();
 215             if (fileName != null) {
 216                 configFile = loadConfigFile(fileName);
 217                 stanzaTable = parseStanzaTable(configFile);
 218                 if (DEBUG) {
 219                     System.out.println(&quot;Loaded from Java config&quot;);
 220                 }
 221             } else {
 222                 boolean found = false;
 223                 if (isMacosLionOrBetter()) {
 224                     try {
 225                         stanzaTable = SCDynamicStoreConfig.getConfig();
 226                         if (DEBUG) {
 227                             System.out.println(&quot;Loaded from SCDynamicStoreConfig&quot;);
 228                         }
 229                         found = true;
 230                     } catch (IOException ioe) {
 231                         // OK. Will go on with file
 232                     }
 233                 }
 234                 if (!found) {
 235                     fileName = getNativeFileName();
 236                     configFile = loadConfigFile(fileName);
 237                     stanzaTable = parseStanzaTable(configFile);
 238                     if (DEBUG) {
 239                         System.out.println(&quot;Loaded from native config&quot;);
 240                     }
 241                 }
 242             }
 243         } catch (IOException ioe) {
 244             if (DEBUG) {
 245                 System.out.println(&quot;Exception thrown in loading config:&quot;);
 246                 ioe.printStackTrace(System.out);
 247             }
 248             throw new KrbException(&quot;krb5.conf loading failed&quot;);
 249         }
 250     }
 251 
 252     /**
 253      * Gets the last-defined string value for the specified keys.
 254      * @param keys the keys, as an array from section name, sub-section names
 255      * (if any), to value name.
 256      * @return the value. When there are multiple values for the same key,
 257      * returns the first one. {@code null} is returned if not all the keys are
 258      * defined. For example, {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;)} will
 259      * return null if &quot;forwardable&quot; is not defined in [libdefaults], and
 260      * {@code get(&quot;realms&quot;, &quot;R&quot;, &quot;kdc&quot;)} will return null if &quot;R&quot; is not
 261      * defined in [realms] or &quot;kdc&quot; is not defined for &quot;R&quot;.
 262      * @throws IllegalArgumentException if any of the keys is illegal, either
 263      * because a key not the last one is not a (sub)section name or the last
 264      * key is still a section name. For example, {@code get(&quot;libdefaults&quot;)}
 265      * throws this exception because [libdefaults] is a section name instead of
 266      * a value name, and {@code get(&quot;libdefaults&quot;, &quot;forwardable&quot;, &quot;tail&quot;)}
 267      * also throws this exception because &quot;forwardable&quot; is already a value name
 268      * and has no sub-key at all (given &quot;forwardable&quot; is defined, otherwise,
 269      * this method has no knowledge if it&#39;s a value name or a section name),
 270      */
 271     public String get(String... keys) {
 272         Vector&lt;String&gt; v = getString0(keys);
 273         if (v == null) return null;
 274         return v.firstElement();
 275     }
 276 
 277     /**
 278      * Gets the boolean value for the specified keys. Returns TRUE if the
 279      * string value is &quot;yes&quot;, or &quot;true&quot;, FALSE if &quot;no&quot;, or &quot;false&quot;, or null
 280      * if otherwise or not defined. The comparision is case-insensitive.
 281      *
 282      * @param keys the keys, see {@link #get(String...)}
 283      * @return the boolean value, or null if there is no value defined or the
 284      * value does not look like a boolean value.
 285      * @throws IllegalArgumentException see {@link #get(String...)}
 286      */
 287     public Boolean getBooleanObject(String... keys) {
 288         String s = get(keys);
 289         if (s == null) {
 290             return null;
 291         }
 292         switch (s.toLowerCase(Locale.US)) {
 293             case &quot;yes&quot;: case &quot;true&quot;:
 294                 return Boolean.TRUE;
 295             case &quot;no&quot;: case &quot;false&quot;:
 296                 return Boolean.FALSE;
 297             default:
 298                 return null;
 299         }
 300     }
 301 
 302     /**
 303      * Gets all values (at least one) for the specified keys separated by
 304      * a whitespace, or null if there is no such keys.
 305      * The values can either be provided on a single line, or on multiple lines
 306      * using the same key. When provided on a single line, the value can be
 307      * comma or space separated.
 308      * @throws IllegalArgumentException if any of the keys is illegal
 309      *         (See {@link #get})
 310      */
 311     public String getAll(String... keys) {
 312         Vector&lt;String&gt; v = getString0(keys);
 313         if (v == null) return null;
 314         StringBuilder sb = new StringBuilder();
 315         boolean first = true;
 316         for (String s: v) {
 317             s = s.replaceAll(&quot;[\\s,]+&quot;, &quot; &quot;);
 318             if (first) {
 319                 sb.append(s);
 320                 first = false;
 321             } else {
 322                 sb.append(&#39; &#39;).append(s);
 323             }
 324         }
 325         return sb.toString();
 326     }
 327 
 328     /**
 329      * Returns true if keys exists, can be final string(s) or a sub-section
 330      * @throws IllegalArgumentException if any of the keys is illegal
 331      *         (See {@link #get})
 332      */
 333     public boolean exists(String... keys) {
 334         return get0(keys) != null;
 335     }
 336 
 337     // Returns final string value(s) for given keys.
 338     @SuppressWarnings(&quot;unchecked&quot;)
 339     private Vector&lt;String&gt; getString0(String... keys) {
 340         try {
 341             return (Vector&lt;String&gt;)get0(keys);
 342         } catch (ClassCastException cce) {
 343             throw new IllegalArgumentException(cce);
 344         }
 345     }
 346 
 347     // Internal method. Returns the value for keys, which can be a sub-section
 348     // (as a Hashtable) or final string value(s) (as a Vector). This is the
 349     // only method (except for toString) that reads stanzaTable directly.
 350     @SuppressWarnings(&quot;unchecked&quot;)
 351     private Object get0(String... keys) {
 352         Object current = stanzaTable;
 353         try {
 354             for (String key: keys) {
 355                 current = ((Hashtable&lt;String,Object&gt;)current).get(key);
 356                 if (current == null) return null;
 357             }
 358             return current;
 359         } catch (ClassCastException cce) {
 360             throw new IllegalArgumentException(cce);
 361         }
 362     }
 363 
 364     /**
 365      * Translates a duration value into seconds.
 366      *
 367      * The format can be one of &quot;h:m[:s]&quot;, &quot;NdNhNmNs&quot;, and &quot;N&quot;. See
 368      * http://web.mit.edu/kerberos/krb5-devel/doc/basic/date_format.html#duration
 369      * for definitions.
 370      *
 371      * @param s the string duration
 372      * @return time in seconds
 373      * @throws KrbException if format is illegal
 374      */
 375     public static int duration(String s) throws KrbException {
 376 
 377         if (s.isEmpty()) {
 378             throw new KrbException(&quot;Duration cannot be empty&quot;);
 379         }
 380 
 381         // N
 382         if (s.matches(&quot;\\d+&quot;)) {
 383             return Integer.parseInt(s);
 384         }
 385 
 386         // h:m[:s]
 387         Matcher m = Pattern.compile(&quot;(\\d+):(\\d+)(:(\\d+))?&quot;).matcher(s);
 388         if (m.matches()) {
 389             int hr = Integer.parseInt(m.group(1));
 390             int min = Integer.parseInt(m.group(2));
 391             if (min &gt;= 60) {
 392                 throw new KrbException(&quot;Illegal duration format &quot; + s);
 393             }
 394             int result = hr * 3600 + min * 60;
 395             if (m.group(4) != null) {
 396                 int sec = Integer.parseInt(m.group(4));
 397                 if (sec &gt;= 60) {
 398                     throw new KrbException(&quot;Illegal duration format &quot; + s);
 399                 }
 400                 result += sec;
 401             }
 402             return result;
 403         }
 404 
 405         // NdNhNmNs
 406         // 120m allowed. Maybe 1h120m is not good, but still allowed
 407         m = Pattern.compile(
 408                     &quot;((\\d+)d)?\\s*((\\d+)h)?\\s*((\\d+)m)?\\s*((\\d+)s)?&quot;,
 409                 Pattern.CASE_INSENSITIVE).matcher(s);
 410         if (m.matches()) {
 411             int result = 0;
 412             if (m.group(2) != null) {
 413                 result += 86400 * Integer.parseInt(m.group(2));
 414             }
 415             if (m.group(4) != null) {
 416                 result += 3600 * Integer.parseInt(m.group(4));
 417             }
 418             if (m.group(6) != null) {
 419                 result += 60 * Integer.parseInt(m.group(6));
 420             }
 421             if (m.group(8) != null) {
 422                 result += Integer.parseInt(m.group(8));
 423             }
 424             return result;
 425         }
 426 
 427         throw new KrbException(&quot;Illegal duration format &quot; + s);
 428     }
 429 
 430     /**
 431      * Gets the int value for the specified keys.
 432      * @param keys the keys
 433      * @return the int value, Integer.MIN_VALUE is returned if it cannot be
 434      * found or the value is not a legal integer.
 435      * @throws IllegalArgumentException if any of the keys is illegal
 436      * @see #get(java.lang.String[])
 437      */
 438     public int getIntValue(String... keys) {
 439         String result = get(keys);
 440         int value = Integer.MIN_VALUE;
 441         if (result != null) {
 442             try {
 443                 value = parseIntValue(result);
 444             } catch (NumberFormatException e) {
 445                 if (DEBUG) {
 446                     System.out.println(&quot;Exception in getting value of &quot; +
 447                                        Arrays.toString(keys) + &quot;: &quot; +
 448                                        e.getMessage());
 449                     System.out.println(&quot;Setting &quot; + Arrays.toString(keys) +
 450                                        &quot; to minimum value&quot;);
 451                 }
 452                 value = Integer.MIN_VALUE;
 453             }
 454         }
 455         return value;
 456     }
 457 
 458     /**
 459      * Parses a string to an integer. The convertible strings include the
 460      * string representations of positive integers, negative integers, and
 461      * hex decimal integers.  Valid inputs are, e.g., -1234, +1234,
 462      * 0x40000.
 463      *
 464      * @param input the String to be converted to an Integer.
 465      * @return an numeric value represented by the string
 466      * @exception NumberFormatException if the String does not contain a
 467      * parsable integer.
 468      */
 469     private int parseIntValue(String input) throws NumberFormatException {
 470         int value = 0;
 471         if (input.startsWith(&quot;+&quot;)) {
 472             String temp = input.substring(1);
 473             return Integer.parseInt(temp);
 474         } else if (input.startsWith(&quot;0x&quot;)) {
 475             String temp = input.substring(2);
 476             char[] chars = temp.toCharArray();
 477             if (chars.length &gt; 8) {
 478                 throw new NumberFormatException();
 479             } else {
 480                 for (int i = 0; i &lt; chars.length; i++) {
 481                     int index = chars.length - i - 1;
 482                     switch (chars[i]) {
 483                     case &#39;0&#39;:
 484                         value += 0;
 485                         break;
 486                     case &#39;1&#39;:
 487                         value += 1 * getBase(index);
 488                         break;
 489                     case &#39;2&#39;:
 490                         value += 2 * getBase(index);
 491                         break;
 492                     case &#39;3&#39;:
 493                         value += 3 * getBase(index);
 494                         break;
 495                     case &#39;4&#39;:
 496                         value += 4 * getBase(index);
 497                         break;
 498                     case &#39;5&#39;:
 499                         value += 5 * getBase(index);
 500                         break;
 501                     case &#39;6&#39;:
 502                         value += 6 * getBase(index);
 503                         break;
 504                     case &#39;7&#39;:
 505                         value += 7 * getBase(index);
 506                         break;
 507                     case &#39;8&#39;:
 508                         value += 8 * getBase(index);
 509                         break;
 510                     case &#39;9&#39;:
 511                         value += 9 * getBase(index);
 512                         break;
 513                     case &#39;a&#39;:
 514                     case &#39;A&#39;:
 515                         value += 10 * getBase(index);
 516                         break;
 517                     case &#39;b&#39;:
 518                     case &#39;B&#39;:
 519                         value += 11 * getBase(index);
 520                         break;
 521                     case &#39;c&#39;:
 522                     case &#39;C&#39;:
 523                         value += 12 * getBase(index);
 524                         break;
 525                     case &#39;d&#39;:
 526                     case &#39;D&#39;:
 527                         value += 13 * getBase(index);
 528                         break;
 529                     case &#39;e&#39;:
 530                     case &#39;E&#39;:
 531                         value += 14 * getBase(index);
 532                         break;
 533                     case &#39;f&#39;:
 534                     case &#39;F&#39;:
 535                         value += 15 * getBase(index);
 536                         break;
 537                     default:
 538                         throw new NumberFormatException(&quot;Invalid numerical format&quot;);
 539                     }
 540                 }
 541             }
 542             if (value &lt; 0) {
 543                 throw new NumberFormatException(&quot;Data overflow.&quot;);
 544             }
 545         } else {
 546             value = Integer.parseInt(input);
 547         }
 548         return value;
 549     }
 550 
 551     private int getBase(int i) {
 552         int result = 16;
 553         switch (i) {
 554         case 0:
 555             result = BASE16_0;
 556             break;
 557         case 1:
 558             result = BASE16_1;
 559             break;
 560         case 2:
 561             result = BASE16_2;
 562             break;
 563         case 3:
 564             result = BASE16_3;
 565             break;
 566         default:
 567             for (int j = 1; j &lt; i; j++) {
 568                 result *= 16;
 569             }
 570         }
 571         return result;
 572     }
 573 
 574     /**
 575      * Reads the lines of the configuration file. All include and includedir
 576      * directives are resolved by calling this method recursively.
 577      *
 578      * @param file the krb5.conf file, must be absolute
 579      * @param content the lines. Comment and empty lines are removed,
 580      *                all lines trimmed, include and includedir
 581      *                directives resolved, unknown directives ignored
 582      * @param dups a set of Paths to check for possible infinite loop
 583      * @throws IOException if there is an I/O error
 584      */
 585     private static Void readConfigFileLines(
 586             Path file, List&lt;String&gt; content, Set&lt;Path&gt; dups)
 587             throws IOException {
 588 
 589         if (DEBUG) {
 590             System.out.println(&quot;Loading krb5 profile at &quot; + file);
 591         }
 592         if (!file.isAbsolute()) {
 593             throw new IOException(&quot;Profile path not absolute&quot;);
 594         }
 595 
 596         if (!dups.add(file)) {
 597             throw new IOException(&quot;Profile path included more than once&quot;);
 598         }
 599 
 600         List&lt;String&gt; lines = Files.readAllLines(file);
 601 
 602         boolean inDirectives = true;
 603         for (String line: lines) {
 604             line = line.trim();
 605             if (line.isEmpty() || line.startsWith(&quot;#&quot;) || line.startsWith(&quot;;&quot;)) {
 606                 continue;
 607             }
 608             if (inDirectives) {
 609                 if (line.charAt(0) == &#39;[&#39;) {
 610                     inDirectives = false;
 611                     content.add(line);
 612                 } else if (line.startsWith(&quot;includedir &quot;)) {
 613                     Path dir = Paths.get(
 614                             line.substring(&quot;includedir &quot;.length()).trim());
 615                     try (DirectoryStream&lt;Path&gt; files =
 616                                  Files.newDirectoryStream(dir)) {
 617                         for (Path p: files) {
 618                             if (Files.isDirectory(p)) continue;
 619                             String name = p.getFileName().toString();
 620                             if (name.matches(&quot;[a-zA-Z0-9_-]+&quot;) ||
 621                                     (!name.startsWith(&quot;.&quot;) &amp;&amp;
 622                                             name.endsWith(&quot;.conf&quot;))) {
 623                                 // if dir is absolute, so is p
 624                                 readConfigFileLines(p, content, dups);
 625                             }
 626                         }
 627                     }
 628                 } else if (line.startsWith(&quot;include &quot;)) {
 629                     readConfigFileLines(
 630                             Paths.get(line.substring(&quot;include &quot;.length()).trim()),
 631                             content, dups);
 632                 } else {
 633                     // Unsupported directives
 634                     if (DEBUG) {
 635                         System.out.println(&quot;Unknown directive: &quot; + line);
 636                     }
 637                 }
 638             } else {
 639                 content.add(line);
 640             }
 641         }
 642         return null;
 643     }
 644 
 645     /**
 646      * Reads the configuration file and return normalized lines.
 647      * If the original file is:
 648      *
 649      *     [realms]
 650      *     EXAMPLE.COM =
 651      *     {
 652      *         kdc = kerberos.example.com
 653      *         ...
 654      *     }
 655      *     ...
 656      *
 657      * The result will be (no indentations):
 658      *
 659      *     {
 660      *         realms = {
 661      *             EXAMPLE.COM = {
 662      *                 kdc = kerberos.example.com
 663      *                 ...
 664      *             }
 665      *         }
 666      *         ...
 667      *     }
 668      *
 669      * @param fileName the configuration file
 670      * @return normalized lines
 671      */
 672     private List&lt;String&gt; loadConfigFile(final String fileName)
 673             throws IOException, KrbException {
 674 
 675         List&lt;String&gt; result = new ArrayList&lt;&gt;();
 676         List&lt;String&gt; raw = new ArrayList&lt;&gt;();
 677         Set&lt;Path&gt; dupsCheck = new HashSet&lt;&gt;();
 678 
 679         try {
 680             Path fullp = AccessController.doPrivileged((PrivilegedAction&lt;Path&gt;)
 681                         () -&gt; Paths.get(fileName).toAbsolutePath(),
 682                     null,
 683                     new PropertyPermission(&quot;user.dir&quot;, &quot;read&quot;));
 684             AccessController.doPrivileged(
 685                     new PrivilegedExceptionAction&lt;Void&gt;() {
 686                         @Override
 687                         public Void run() throws IOException {
 688                             Path path = Paths.get(fileName);
 689                             if (!Files.exists(path)) {
 690                                 // This is OK. There are other ways to get
 691                                 // Kerberos 5 settings
 692                                 return null;
 693                             } else {
 694                                 return readConfigFileLines(
 695                                         fullp, raw, dupsCheck);
 696                             }
 697                         }
 698                     },
 699                     null,
 700                     // include/includedir can go anywhere
 701                     new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;));
 702         } catch (java.security.PrivilegedActionException pe) {
 703             throw (IOException)pe.getException();
 704         }
 705         String previous = null;
 706         for (String line: raw) {
 707             if (line.startsWith(&quot;[&quot;)) {
 708                 if (!line.endsWith(&quot;]&quot;)) {
 709                     throw new KrbException(&quot;Illegal config content:&quot;
 710                             + line);
 711                 }
 712                 if (previous != null) {
 713                     result.add(previous);
 714                     result.add(&quot;}&quot;);
 715                 }
 716                 String title = line.substring(
 717                         1, line.length()-1).trim();
 718                 if (title.isEmpty()) {
 719                     throw new KrbException(&quot;Illegal config content:&quot;
 720                             + line);
 721                 }
 722                 previous = title + &quot; = {&quot;;
 723             } else if (line.startsWith(&quot;{&quot;)) {
 724                 if (previous == null) {
 725                     throw new KrbException(
 726                         &quot;Config file should not start with \&quot;{\&quot;&quot;);
 727                 }
 728                 previous += &quot; {&quot;;
 729                 if (line.length() &gt; 1) {
 730                     // { and content on the same line
 731                     result.add(previous);
 732                     previous = line.substring(1).trim();
 733                 }
 734             } else {
 735                 if (previous == null) {
 736                     // This won&#39;t happen, because before a section
 737                     // all directives have been resolved
 738                     throw new KrbException(
 739                         &quot;Config file must starts with a section&quot;);
 740                 }
 741                 result.add(previous);
 742                 previous = line;
 743             }
 744         }
 745         if (previous != null) {
 746             result.add(previous);
 747             result.add(&quot;}&quot;);
 748         }
 749         return result;
 750     }
 751 
 752     /**
 753      * Parses the input lines to a hashtable. The key would be section names
 754      * (libdefaults, realms, domain_realms, etc), and the value would be
 755      * another hashtable which contains the key-value pairs inside the section.
 756      * The value of this sub-hashtable can be another hashtable containing
 757      * another sub-sub-section or a non-empty vector of strings for final values
 758      * (even if there is only one value defined).
 759      * &lt;p&gt;
 760      * For top-level sections with duplicates names, their contents are merged.
 761      * For sub-sections the former overwrites the latter. For final values,
 762      * they are stored in a vector in their appearing order. Please note these
 763      * values must appear in the same sub-section. Otherwise, the sub-section
 764      * appears first should have already overridden the others.
 765      * &lt;p&gt;
 766      * As a corner case, if the same name is used as both a section name and a
 767      * value name, the first appearance decides the type. That is to say, if the
 768      * first one is for a section, all latter appearances are ignored. If it&#39;s
 769      * a value, latter appearances as sections are ignored, but those as values
 770      * are added to the vector.
 771      * &lt;p&gt;
 772      * The behavior described above is compatible to other krb5 implementations
 773      * but it&#39;s not decumented publicly anywhere. the best practice is not to
 774      * assume any kind of override functionality and only specify values for
 775      * a particular key in one place.
 776      *
 777      * @param v the normalized input as return by loadConfigFile
 778      * @throws KrbException if there is a file format error
 779      */
 780     @SuppressWarnings(&quot;unchecked&quot;)
 781     private Hashtable&lt;String,Object&gt; parseStanzaTable(List&lt;String&gt; v)
 782             throws KrbException {
 783         Hashtable&lt;String,Object&gt; current = stanzaTable;
 784         for (String line: v) {
 785             // There are only 3 kinds of lines
 786             // 1. a = b
 787             // 2. a = {
 788             // 3. }
 789             if (line.equals(&quot;}&quot;)) {
 790                 // Go back to parent, see below
 791                 current = (Hashtable&lt;String,Object&gt;)current.remove(&quot; PARENT &quot;);
 792                 if (current == null) {
 793                     throw new KrbException(&quot;Unmatched close brace&quot;);
 794                 }
 795             } else {
 796                 int pos = line.indexOf(&#39;=&#39;);
 797                 if (pos &lt; 0) {
 798                     throw new KrbException(&quot;Illegal config content:&quot; + line);
 799                 }
 800                 String key = line.substring(0, pos).trim();
 801                 String value = unquote(line.substring(pos + 1));
 802                 if (value.equals(&quot;{&quot;)) {
 803                     Hashtable&lt;String,Object&gt; subTable;
 804                     if (current == stanzaTable) {
 805                         key = key.toLowerCase(Locale.US);
 806                     }
 807                     // When there are dup names for sections
 808                     if (current.containsKey(key)) {
 809                         if (current == stanzaTable) {   // top-level, merge
 810                             // The value at top-level must be another Hashtable
 811                             subTable = (Hashtable&lt;String,Object&gt;)current.get(key);
 812                         } else {                        // otherwise, ignored
 813                             // read and ignore it (do not put into current)
 814                             subTable = new Hashtable&lt;&gt;();
 815                         }
 816                     } else {
 817                         subTable = new Hashtable&lt;&gt;();
 818                         current.put(key, subTable);
 819                     }
 820                     // A special entry for its parent. Put whitespaces around,
 821                     // so will never be confused with a normal key
 822                     subTable.put(&quot; PARENT &quot;, current);
 823                     current = subTable;
 824                 } else {
 825                     Vector&lt;String&gt; values;
 826                     if (current.containsKey(key)) {
 827                         Object obj = current.get(key);
 828                         if (obj instanceof Vector) {
 829                             // String values are merged
 830                             values = (Vector&lt;String&gt;)obj;
 831                             values.add(value);
 832                         } else {
 833                             // If a key shows as section first and then a value,
 834                             // ignore the value.
 835                         }
 836                     } else {
 837                         values = new Vector&lt;String&gt;();
 838                         values.add(value);
 839                         current.put(key, values);
 840                     }
 841                 }
 842             }
 843         }
 844         if (current != stanzaTable) {
 845             throw new KrbException(&quot;Not closed&quot;);
 846         }
 847         return current;
 848     }
 849 
 850     /**
 851      * Gets the default Java configuration file name.
 852      *
 853      * If the system property &quot;java.security.krb5.conf&quot; is defined, we&#39;ll
 854      * use its value, no matter if the file exists or not. Otherwise, we
 855      * will look at $JAVA_HOME/conf/security directory with &quot;krb5.conf&quot; name,
 856      * and return it if the file exists.
 857      *
 858      * The method returns null if it cannot find a Java config file.
 859      */
 860     private String getJavaFileName() {
 861         String name = GetPropertyAction
 862                 .privilegedGetProperty(&quot;java.security.krb5.conf&quot;);
 863         if (name == null) {
 864             name = GetPropertyAction.privilegedGetProperty(&quot;java.home&quot;)
 865                     + File.separator + &quot;conf&quot; + File.separator + &quot;security&quot;
 866                     + File.separator + &quot;krb5.conf&quot;;
 867             if (!fileExists(name)) {
 868                 name = null;
 869             }
 870         }
 871         if (DEBUG) {
 872             System.out.println(&quot;Java config name: &quot; + name);
 873         }
 874         return name;
 875     }
 876 
 877     /**
 878      * Gets the default native configuration file name.
 879      *
 880      * Depending on the OS type, the method returns the default native
 881      * kerberos config file name, which is at windows directory with
 882      * the name of &quot;krb5.ini&quot; for Windows, /etc/krb5/krb5.conf for Solaris,
 883      * /etc/krb5.conf otherwise. Mac OSX X has a different file name.
 884      *
 885      * Note: When the Terminal Service is started in Windows (from 2003),
 886      * there are two kinds of Windows directories: A system one (say,
 887      * C:\Windows), and a user-private one (say, C:\Users\Me\Windows).
 888      * We will first look for krb5.ini in the user-private one. If not
 889      * found, try the system one instead.
 890      *
 891      * This method will always return a non-null non-empty file name,
 892      * even if that file does not exist.
 893      */
 894     private String getNativeFileName() {
 895         String name = null;
 896         String osname = GetPropertyAction.privilegedGetProperty(&quot;os.name&quot;);
 897         if (osname.startsWith(&quot;Windows&quot;)) {
 898             try {
 899                 Credentials.ensureLoaded();
 900             } catch (Exception e) {
 901                 // ignore exceptions
 902             }
 903             if (Credentials.alreadyLoaded) {
 904                 String path = getWindowsDirectory(false);
 905                 if (path != null) {
 906                     if (path.endsWith(&quot;\\&quot;)) {
 907                         path = path + &quot;krb5.ini&quot;;
 908                     } else {
 909                         path = path + &quot;\\krb5.ini&quot;;
 910                     }
 911                     if (fileExists(path)) {
 912                         name = path;
 913                     }
 914                 }
 915                 if (name == null) {
 916                     path = getWindowsDirectory(true);
 917                     if (path != null) {
 918                         if (path.endsWith(&quot;\\&quot;)) {
 919                             path = path + &quot;krb5.ini&quot;;
 920                         } else {
 921                             path = path + &quot;\\krb5.ini&quot;;
 922                         }
 923                         name = path;
 924                     }
 925                 }
 926             }
 927             if (name == null) {
 928                 name = &quot;c:\\winnt\\krb5.ini&quot;;
 929             }
 930         } else if (osname.contains(&quot;OS X&quot;)) {
 931             name = findMacosConfigFile();
 932         } else {
 933             name =  &quot;/etc/krb5.conf&quot;;
 934         }
 935         if (DEBUG) {
 936             System.out.println(&quot;Native config name: &quot; + name);
 937         }
 938         return name;
 939     }
 940 
 941     private String findMacosConfigFile() {
 942         String userHome = GetPropertyAction.privilegedGetProperty(&quot;user.home&quot;);
 943         final String PREF_FILE = &quot;/Library/Preferences/edu.mit.Kerberos&quot;;
 944         String userPrefs = userHome + PREF_FILE;
 945 
 946         if (fileExists(userPrefs)) {
 947             return userPrefs;
 948         }
 949 
 950         if (fileExists(PREF_FILE)) {
 951             return PREF_FILE;
 952         }
 953 
 954         return &quot;/etc/krb5.conf&quot;;
 955     }
 956 
 957     private static String unquote(String s) {
 958         s = s.trim();
 959         if (s.length() &gt;= 2 &amp;&amp;
 960                 ((s.charAt(0) == &#39;&quot;&#39; &amp;&amp; s.charAt(s.length()-1) == &#39;&quot;&#39;) ||
 961                  (s.charAt(0) == &#39;\&#39;&#39; &amp;&amp; s.charAt(s.length()-1) == &#39;\&#39;&#39;))) {
 962             s = s.substring(1, s.length()-1).trim();
 963         }
 964         return s;
 965     }
 966 
 967     /**
 968      * For testing purpose. This method lists all information being parsed from
 969      * the configuration file to the hashtable.
 970      */
 971     public void listTable() {
 972         System.out.println(this);
 973     }
 974 
 975     /**
 976      * Returns all etypes specified in krb5.conf for the given configName,
 977      * or all the builtin defaults. This result is always non-empty.
 978      * If no etypes are found, an exception is thrown.
 979      */
 980     public int[] defaultEtype(String configName) throws KrbException {
 981         String default_enctypes;
 982         default_enctypes = get(&quot;libdefaults&quot;, configName);
 983         int[] etype;
 984         if (default_enctypes == null) {
 985             if (DEBUG) {
 986                 System.out.println(&quot;Using builtin default etypes for &quot; +
 987                     configName);
 988             }
 989             etype = EType.getBuiltInDefaults();
 990         } else {
 991             String delim = &quot; &quot;;
 992             StringTokenizer st;
 993             for (int j = 0; j &lt; default_enctypes.length(); j++) {
 994                 if (default_enctypes.substring(j, j + 1).equals(&quot;,&quot;)) {
 995                     // only two delimiters are allowed to use
 996                     // according to Kerberos DCE doc.
 997                     delim = &quot;,&quot;;
 998                     break;
 999                 }
1000             }
1001             st = new StringTokenizer(default_enctypes, delim);
1002             int len = st.countTokens();
1003             ArrayList&lt;Integer&gt; ls = new ArrayList&lt;&gt;(len);
1004             int type;
1005             for (int i = 0; i &lt; len; i++) {
1006                 type = Config.getType(st.nextToken());
1007                 if (type != -1 &amp;&amp; EType.isSupported(type)) {
1008                     ls.add(type);
1009                 }
1010             }
1011             if (ls.isEmpty()) {
1012                 throw new KrbException(&quot;no supported default etypes for &quot;
1013                         + configName);
1014             } else {
1015                 etype = new int[ls.size()];
1016                 for (int i = 0; i &lt; etype.length; i++) {
1017                     etype[i] = ls.get(i);
1018                 }
1019             }
1020         }
1021 
1022         if (DEBUG) {
1023             System.out.print(&quot;default etypes for &quot; + configName + &quot;:&quot;);
1024             for (int i = 0; i &lt; etype.length; i++) {
1025                 System.out.print(&quot; &quot; + etype[i]);
1026             }
1027             System.out.println(&quot;.&quot;);
1028         }
1029         return etype;
1030     }
1031 
1032 
1033     /**
1034      * Get the etype and checksum value for the specified encryption and
1035      * checksum type.
1036      *
1037      */
1038     /*
1039      * This method converts the string representation of encryption type and
1040      * checksum type to int value that can be later used by EType and
1041      * Checksum classes.
1042      */
1043     public static int getType(String input) {
1044         int result = -1;
1045         if (input == null) {
1046             return result;
1047         }
1048         if (input.startsWith(&quot;d&quot;) || (input.startsWith(&quot;D&quot;))) {
1049             if (input.equalsIgnoreCase(&quot;des-cbc-crc&quot;)) {
1050                 result = EncryptedData.ETYPE_DES_CBC_CRC;
1051             } else if (input.equalsIgnoreCase(&quot;des-cbc-md5&quot;)) {
1052                 result = EncryptedData.ETYPE_DES_CBC_MD5;
1053             } else if (input.equalsIgnoreCase(&quot;des-mac&quot;)) {
1054                 result = Checksum.CKSUMTYPE_DES_MAC;
1055             } else if (input.equalsIgnoreCase(&quot;des-mac-k&quot;)) {
1056                 result = Checksum.CKSUMTYPE_DES_MAC_K;
1057             } else if (input.equalsIgnoreCase(&quot;des-cbc-md4&quot;)) {
1058                 result = EncryptedData.ETYPE_DES_CBC_MD4;
1059             } else if (input.equalsIgnoreCase(&quot;des3-cbc-sha1&quot;) ||
1060                 input.equalsIgnoreCase(&quot;des3-hmac-sha1&quot;) ||
1061                 input.equalsIgnoreCase(&quot;des3-cbc-sha1-kd&quot;) ||
1062                 input.equalsIgnoreCase(&quot;des3-cbc-hmac-sha1-kd&quot;)) {
1063                 result = EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD;
1064             }
1065         } else if (input.startsWith(&quot;a&quot;) || (input.startsWith(&quot;A&quot;))) {
1066             // AES
1067             if (input.equalsIgnoreCase(&quot;aes128-cts&quot;) ||
1068                     input.equalsIgnoreCase(&quot;aes128-sha1&quot;) ||
1069                     input.equalsIgnoreCase(&quot;aes128-cts-hmac-sha1-96&quot;)) {
1070                 result = EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96;
1071             } else if (input.equalsIgnoreCase(&quot;aes256-cts&quot;) ||
1072                     input.equalsIgnoreCase(&quot;aes256-sha1&quot;) ||
1073                     input.equalsIgnoreCase(&quot;aes256-cts-hmac-sha1-96&quot;)) {
1074                 result = EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96;
1075             } else if (input.equalsIgnoreCase(&quot;aes128-sha2&quot;) ||
1076                     input.equalsIgnoreCase(&quot;aes128-cts-hmac-sha256-128&quot;)) {
1077                 result = EncryptedData.ETYPE_AES128_CTS_HMAC_SHA256_128;
1078             } else if (input.equalsIgnoreCase(&quot;aes256-sha2&quot;) ||
1079                     input.equalsIgnoreCase(&quot;aes256-cts-hmac-sha384-192&quot;)) {
1080                 result = EncryptedData.ETYPE_AES256_CTS_HMAC_SHA384_192;
1081             // ARCFOUR-HMAC
1082             } else if (input.equalsIgnoreCase(&quot;arcfour-hmac&quot;) ||
1083                    input.equalsIgnoreCase(&quot;arcfour-hmac-md5&quot;)) {
1084                 result = EncryptedData.ETYPE_ARCFOUR_HMAC;
1085             }
1086         // RC4-HMAC
1087         } else if (input.equalsIgnoreCase(&quot;rc4-hmac&quot;)) {
1088             result = EncryptedData.ETYPE_ARCFOUR_HMAC;
1089         } else if (input.equalsIgnoreCase(&quot;CRC32&quot;)) {
1090             result = Checksum.CKSUMTYPE_CRC32;
1091         } else if (input.startsWith(&quot;r&quot;) || (input.startsWith(&quot;R&quot;))) {
1092             if (input.equalsIgnoreCase(&quot;rsa-md5&quot;)) {
1093                 result = Checksum.CKSUMTYPE_RSA_MD5;
1094             } else if (input.equalsIgnoreCase(&quot;rsa-md5-des&quot;)) {
1095                 result = Checksum.CKSUMTYPE_RSA_MD5_DES;
1096             }
1097         } else if (input.equalsIgnoreCase(&quot;hmac-sha1-des3-kd&quot;)) {
1098             result = Checksum.CKSUMTYPE_HMAC_SHA1_DES3_KD;
1099         } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes128&quot;)) {
1100             result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES128;
1101         } else if (input.equalsIgnoreCase(&quot;hmac-sha1-96-aes256&quot;)) {
1102             result = Checksum.CKSUMTYPE_HMAC_SHA1_96_AES256;
1103         } else if (input.equalsIgnoreCase(&quot;hmac-sha256-128-aes128&quot;)) {
1104             result = Checksum.CKSUMTYPE_HMAC_SHA256_128_AES128;
1105         } else if (input.equalsIgnoreCase(&quot;hmac-sha384-192-aes256&quot;)) {
1106             result = Checksum.CKSUMTYPE_HMAC_SHA384_192_AES256;
1107         } else if (input.equalsIgnoreCase(&quot;hmac-md5-rc4&quot;) ||
1108                 input.equalsIgnoreCase(&quot;hmac-md5-arcfour&quot;) ||
1109                 input.equalsIgnoreCase(&quot;hmac-md5-enc&quot;)) {
1110             result = Checksum.CKSUMTYPE_HMAC_MD5_ARCFOUR;
1111         } else if (input.equalsIgnoreCase(&quot;NULL&quot;)) {
1112             result = EncryptedData.ETYPE_NULL;
1113         }
1114 
1115         return result;
1116     }
1117 
1118     /**
1119      * Resets the default kdc realm.
1120      * We do not need to synchronize these methods since assignments are atomic
1121      *
1122      * This method was useless. Kept here in case some class still calls it.
1123      */
1124     public void resetDefaultRealm(String realm) {
1125         if (DEBUG) {
1126             System.out.println(&quot;&gt;&gt;&gt; Config try resetting default kdc &quot; + realm);
1127         }
1128     }
1129 
1130     /**
1131      * Check to use addresses in tickets
1132      * use addresses if &quot;no_addresses&quot; or &quot;noaddresses&quot; is set to false
1133      */
1134     public boolean useAddresses() {
1135         return getBooleanObject(&quot;libdefaults&quot;, &quot;no_addresses&quot;) == Boolean.FALSE ||
1136                 getBooleanObject(&quot;libdefaults&quot;, &quot;noaddresses&quot;) == Boolean.FALSE;
1137     }
1138 
1139     /**
1140      * Check if need to use DNS to locate Kerberos services for name. If not
1141      * defined, check dns_fallback, whose default value is true.
1142      */
1143     private boolean useDNS(String name, boolean defaultValue) {
1144         Boolean value = getBooleanObject(&quot;libdefaults&quot;, name);
1145         if (value != null) {
1146             return value.booleanValue();
1147         }
1148         value = getBooleanObject(&quot;libdefaults&quot;, &quot;dns_fallback&quot;);
1149         if (value != null) {
1150             return value.booleanValue();
1151         }
1152         return defaultValue;
1153     }
1154 
1155     /**
1156      * Check if need to use DNS to locate the KDC
1157      */
1158     private boolean useDNS_KDC() {
1159         return useDNS(&quot;dns_lookup_kdc&quot;, true);
1160     }
1161 
1162     /*
1163      * Check if need to use DNS to locate the Realm
1164      */
1165     private boolean useDNS_Realm() {
1166         return useDNS(&quot;dns_lookup_realm&quot;, false);
1167     }
1168 
1169     /**
1170      * Gets default realm.
1171      * @throws KrbException where no realm can be located
1172      * @return the default realm, always non null
1173      */
1174     public String getDefaultRealm() throws KrbException {
1175         if (defaultRealm != null) {
1176             return defaultRealm;
1177         }
1178         Exception cause = null;
1179         String realm = get(&quot;libdefaults&quot;, &quot;default_realm&quot;);
1180         if ((realm == null) &amp;&amp; useDNS_Realm()) {
1181             // use DNS to locate Kerberos realm
1182             try {
1183                 realm = getRealmFromDNS();
1184             } catch (KrbException ke) {
1185                 cause = ke;
1186             }
1187         }
1188         if (realm == null) {
1189             realm = java.security.AccessController.doPrivileged(
1190                     new java.security.PrivilegedAction&lt;String&gt;() {
1191                 @Override
1192                 public String run() {
1193                     String osname = System.getProperty(&quot;os.name&quot;);
1194                     if (osname.startsWith(&quot;Windows&quot;)) {
1195                         return System.getenv(&quot;USERDNSDOMAIN&quot;);
1196                     }
1197                     return null;
1198                 }
1199             });
1200         }
1201         if (realm == null) {
1202             KrbException ke = new KrbException(&quot;Cannot locate default realm&quot;);
1203             if (cause != null) {
1204                 ke.initCause(cause);
1205             }
1206             throw ke;
1207         }
1208         return realm;
1209     }
1210 
1211     /**
1212      * Returns a list of KDC&#39;s with each KDC separated by a space
1213      *
1214      * @param realm the realm for which the KDC list is desired
1215      * @throws KrbException if there&#39;s no way to find KDC for the realm
1216      * @return the list of KDCs separated by a space, always non null
1217      */
1218     public String getKDCList(String realm) throws KrbException {
1219         if (realm == null) {
1220             realm = getDefaultRealm();
1221         }
1222         if (realm.equalsIgnoreCase(defaultRealm)) {
1223             return defaultKDC;
1224         }
1225         Exception cause = null;
1226         String kdcs = getAll(&quot;realms&quot;, realm, &quot;kdc&quot;);
1227         if ((kdcs == null) &amp;&amp; useDNS_KDC()) {
1228             // use DNS to locate KDC
1229             try {
1230                 kdcs = getKDCFromDNS(realm);
1231             } catch (KrbException ke) {
1232                 cause = ke;
1233             }
1234         }
1235         if (kdcs == null) {
1236             kdcs = java.security.AccessController.doPrivileged(
1237                     new java.security.PrivilegedAction&lt;String&gt;() {
1238                 @Override
1239                 public String run() {
1240                     String osname = System.getProperty(&quot;os.name&quot;);
1241                     if (osname.startsWith(&quot;Windows&quot;)) {
1242                         String logonServer = System.getenv(&quot;LOGONSERVER&quot;);
1243                         if (logonServer != null
1244                                 &amp;&amp; logonServer.startsWith(&quot;\\\\&quot;)) {
1245                             logonServer = logonServer.substring(2);
1246                         }
1247                         return logonServer;
1248                     }
1249                     return null;
1250                 }
1251             });
1252         }
1253         if (kdcs == null) {
1254             if (defaultKDC != null) {
1255                 return defaultKDC;
1256             }
1257             KrbException ke = new KrbException(&quot;Cannot locate KDC&quot;);
1258             if (cause != null) {
1259                 ke.initCause(cause);
1260             }
1261             throw ke;
1262         }
1263         return kdcs;
1264     }
1265 
1266     /**
1267      * Locate Kerberos realm using DNS
1268      *
1269      * @return the Kerberos realm
1270      */
1271     private String getRealmFromDNS() throws KrbException {
1272         // use DNS to locate Kerberos realm
1273         String realm = null;
1274         String hostName = null;
1275         try {
1276             hostName = InetAddress.getLocalHost().getCanonicalHostName();
1277         } catch (UnknownHostException e) {
1278             KrbException ke = new KrbException(Krb5.KRB_ERR_GENERIC,
1279                 &quot;Unable to locate Kerberos realm: &quot; + e.getMessage());
1280             ke.initCause(e);
1281             throw (ke);
1282         }
1283         // get the domain realm mapping from the configuration
1284         String mapRealm = PrincipalName.mapHostToRealm(hostName);
1285         if (mapRealm == null) {
1286             // No match. Try search and/or domain in /etc/resolv.conf
1287             List&lt;String&gt; srchlist = ResolverConfiguration.open().searchlist();
1288             for (String domain: srchlist) {
1289                 realm = checkRealm(domain);
1290                 if (realm != null) {
1291                     break;
1292                 }
1293             }
1294         } else {
1295             realm = checkRealm(mapRealm);
1296         }
1297         if (realm == null) {
1298             throw new KrbException(Krb5.KRB_ERR_GENERIC,
1299                                 &quot;Unable to locate Kerberos realm&quot;);
1300         }
1301         return realm;
1302     }
1303 
1304     /**
1305      * Check if the provided realm is the correct realm
1306      * @return the realm if correct, or null otherwise
1307      */
1308     private static String checkRealm(String mapRealm) {
1309         if (DEBUG) {
1310             System.out.println(&quot;getRealmFromDNS: trying &quot; + mapRealm);
1311         }
1312         String[] records = null;
1313         String newRealm = mapRealm;
1314         while ((records == null) &amp;&amp; (newRealm != null)) {
1315             // locate DNS TXT record
1316             records = KrbServiceLocator.getKerberosService(newRealm);
1317             newRealm = Realm.parseRealmComponent(newRealm);
1318             // if no DNS TXT records found, try again using sub-realm
1319         }
1320         if (records != null) {
1321             for (int i = 0; i &lt; records.length; i++) {
1322                 if (records[i].equalsIgnoreCase(mapRealm)) {
1323                     return records[i];
1324                 }
1325             }
1326         }
1327         return null;
1328     }
1329 
1330     /**
1331      * Locate KDC using DNS
1332      *
1333      * @param realm the realm for which the master KDC is desired
1334      * @return the KDC
1335      */
1336     private String getKDCFromDNS(String realm) throws KrbException {
1337         // use DNS to locate KDC
1338         String kdcs = &quot;&quot;;
1339         String[] srvs = null;
1340         // locate DNS SRV record using UDP
1341         if (DEBUG) {
1342             System.out.println(&quot;getKDCFromDNS using UDP&quot;);
1343         }
1344         srvs = KrbServiceLocator.getKerberosService(realm, &quot;_udp&quot;);
1345         if (srvs == null) {
1346             // locate DNS SRV record using TCP
1347             if (DEBUG) {
1348                 System.out.println(&quot;getKDCFromDNS using TCP&quot;);
1349             }
1350             srvs = KrbServiceLocator.getKerberosService(realm, &quot;_tcp&quot;);
1351         }
1352         if (srvs == null) {
1353             // no DNS SRV records
1354             throw new KrbException(Krb5.KRB_ERR_GENERIC,
1355                 &quot;Unable to locate KDC for realm &quot; + realm);
1356         }
1357         if (srvs.length == 0) {
1358             return null;
1359         }
1360         for (int i = 0; i &lt; srvs.length; i++) {
1361             kdcs += srvs[i].trim() + &quot; &quot;;
1362         }
1363         kdcs = kdcs.trim();
1364         if (kdcs.equals(&quot;&quot;)) {
1365             return null;
1366         }
1367         return kdcs;
1368     }
1369 
1370     private boolean fileExists(String name) {
1371         return java.security.AccessController.doPrivileged(
1372                                 new FileExistsAction(name));
1373     }
1374 
1375     static class FileExistsAction
1376         implements java.security.PrivilegedAction&lt;Boolean&gt; {
1377 
1378         private String fileName;
1379 
1380         public FileExistsAction(String fileName) {
1381             this.fileName = fileName;
1382         }
1383 
1384         public Boolean run() {
1385             return new File(fileName).exists();
1386         }
1387     }
1388 
1389     // Shows the content of the Config object for debug purpose.
1390     //
1391     // {
1392     //      libdefaults = {
1393     //          default_realm = R
1394     //      }
1395     //      realms = {
1396     //          R = {
1397     //              kdc = [k1,k2]
1398     //          }
1399     //      }
1400     // }
1401 
1402     @Override
1403     public String toString() {
1404         StringBuffer sb = new StringBuffer();
1405         toStringInternal(&quot;&quot;, stanzaTable, sb);
1406         return sb.toString();
1407     }
1408     private static void toStringInternal(String prefix, Object obj,
1409             StringBuffer sb) {
1410         if (obj instanceof String) {
1411             // A string value, just print it
1412             sb.append(obj).append(&#39;\n&#39;);
1413         } else if (obj instanceof Hashtable) {
1414             // A table, start a new sub-section...
1415             Hashtable&lt;?, ?&gt; tab = (Hashtable&lt;?, ?&gt;)obj;
1416             sb.append(&quot;{\n&quot;);
1417             for (Object o: tab.keySet()) {
1418                 // ...indent, print &quot;key = &quot;, and
1419                 sb.append(prefix).append(&quot;    &quot;).append(o).append(&quot; = &quot;);
1420                 // ...go recursively into value
1421                 toStringInternal(prefix + &quot;    &quot;, tab.get(o), sb);
1422             }
1423             sb.append(prefix).append(&quot;}\n&quot;);
1424         } else if (obj instanceof Vector) {
1425             // A vector of strings, print them inside [ and ]
1426             Vector&lt;?&gt; v = (Vector&lt;?&gt;)obj;
1427             sb.append(&quot;[&quot;);
1428             boolean first = true;
1429             for (Object o: v.toArray()) {
1430                 if (!first) sb.append(&quot;,&quot;);
1431                 sb.append(o);
1432                 first = false;
1433             }
1434             sb.append(&quot;]\n&quot;);
1435         }
1436     }
1437 }
    </pre>
  </body>
</html>
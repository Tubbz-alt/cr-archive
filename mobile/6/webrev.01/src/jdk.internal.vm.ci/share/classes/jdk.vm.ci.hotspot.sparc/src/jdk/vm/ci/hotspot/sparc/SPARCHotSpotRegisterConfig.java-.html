<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot.sparc/src/jdk/vm/ci/hotspot/sparc/SPARCHotSpotRegisterConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 package jdk.vm.ci.hotspot.sparc;
 24 
 25 import static jdk.vm.ci.meta.JavaKind.Void;
 26 import static jdk.vm.ci.meta.Value.ILLEGAL;
 27 import static jdk.vm.ci.sparc.SPARC.REGISTER_SAFE_AREA_SIZE;
 28 import static jdk.vm.ci.sparc.SPARC.d0;
 29 import static jdk.vm.ci.sparc.SPARC.d10;
 30 import static jdk.vm.ci.sparc.SPARC.d12;
 31 import static jdk.vm.ci.sparc.SPARC.d14;
 32 import static jdk.vm.ci.sparc.SPARC.d16;
 33 import static jdk.vm.ci.sparc.SPARC.d18;
 34 import static jdk.vm.ci.sparc.SPARC.d2;
 35 import static jdk.vm.ci.sparc.SPARC.d20;
 36 import static jdk.vm.ci.sparc.SPARC.d22;
 37 import static jdk.vm.ci.sparc.SPARC.d24;
 38 import static jdk.vm.ci.sparc.SPARC.d26;
 39 import static jdk.vm.ci.sparc.SPARC.d28;
 40 import static jdk.vm.ci.sparc.SPARC.d30;
 41 import static jdk.vm.ci.sparc.SPARC.d4;
 42 import static jdk.vm.ci.sparc.SPARC.d6;
 43 import static jdk.vm.ci.sparc.SPARC.d8;
 44 import static jdk.vm.ci.sparc.SPARC.f0;
 45 import static jdk.vm.ci.sparc.SPARC.f1;
 46 import static jdk.vm.ci.sparc.SPARC.f11;
 47 import static jdk.vm.ci.sparc.SPARC.f13;
 48 import static jdk.vm.ci.sparc.SPARC.f15;
 49 import static jdk.vm.ci.sparc.SPARC.f17;
 50 import static jdk.vm.ci.sparc.SPARC.f19;
 51 import static jdk.vm.ci.sparc.SPARC.f2;
 52 import static jdk.vm.ci.sparc.SPARC.f21;
 53 import static jdk.vm.ci.sparc.SPARC.f23;
 54 import static jdk.vm.ci.sparc.SPARC.f25;
 55 import static jdk.vm.ci.sparc.SPARC.f27;
 56 import static jdk.vm.ci.sparc.SPARC.f29;
 57 import static jdk.vm.ci.sparc.SPARC.f3;
 58 import static jdk.vm.ci.sparc.SPARC.f31;
 59 import static jdk.vm.ci.sparc.SPARC.f4;
 60 import static jdk.vm.ci.sparc.SPARC.f5;
 61 import static jdk.vm.ci.sparc.SPARC.f6;
 62 import static jdk.vm.ci.sparc.SPARC.f7;
 63 import static jdk.vm.ci.sparc.SPARC.f9;
 64 import static jdk.vm.ci.sparc.SPARC.g0;
 65 import static jdk.vm.ci.sparc.SPARC.g2;
 66 import static jdk.vm.ci.sparc.SPARC.g6;
 67 import static jdk.vm.ci.sparc.SPARC.i0;
 68 import static jdk.vm.ci.sparc.SPARC.i1;
 69 import static jdk.vm.ci.sparc.SPARC.i2;
 70 import static jdk.vm.ci.sparc.SPARC.i3;
 71 import static jdk.vm.ci.sparc.SPARC.i4;
 72 import static jdk.vm.ci.sparc.SPARC.i5;
 73 import static jdk.vm.ci.sparc.SPARC.i6;
 74 import static jdk.vm.ci.sparc.SPARC.i7;
 75 import static jdk.vm.ci.sparc.SPARC.l0;
 76 import static jdk.vm.ci.sparc.SPARC.l1;
 77 import static jdk.vm.ci.sparc.SPARC.l2;
 78 import static jdk.vm.ci.sparc.SPARC.l3;
 79 import static jdk.vm.ci.sparc.SPARC.l4;
 80 import static jdk.vm.ci.sparc.SPARC.l5;
 81 import static jdk.vm.ci.sparc.SPARC.l6;
 82 import static jdk.vm.ci.sparc.SPARC.l7;
 83 import static jdk.vm.ci.sparc.SPARC.o0;
 84 import static jdk.vm.ci.sparc.SPARC.o1;
 85 import static jdk.vm.ci.sparc.SPARC.o2;
 86 import static jdk.vm.ci.sparc.SPARC.o3;
 87 import static jdk.vm.ci.sparc.SPARC.o4;
 88 import static jdk.vm.ci.sparc.SPARC.o5;
 89 import static jdk.vm.ci.sparc.SPARC.sp;
 90 
 91 import java.util.ArrayList;
 92 import java.util.HashSet;
 93 import java.util.List;
 94 
 95 import jdk.vm.ci.code.Architecture;
 96 import jdk.vm.ci.code.CallingConvention;
 97 import jdk.vm.ci.code.CallingConvention.Type;
 98 import jdk.vm.ci.code.Register;
 99 import jdk.vm.ci.code.RegisterArray;
100 import jdk.vm.ci.code.RegisterAttributes;
101 import jdk.vm.ci.code.RegisterConfig;
102 import jdk.vm.ci.code.StackSlot;
103 import jdk.vm.ci.code.TargetDescription;
104 import jdk.vm.ci.code.ValueKindFactory;
105 import jdk.vm.ci.common.JVMCIError;
106 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
107 import jdk.vm.ci.meta.AllocatableValue;
108 import jdk.vm.ci.meta.JavaKind;
109 import jdk.vm.ci.meta.JavaType;
110 import jdk.vm.ci.meta.PlatformKind;
111 import jdk.vm.ci.meta.ValueKind;
112 import jdk.vm.ci.sparc.SPARC;
113 
114 public class SPARCHotSpotRegisterConfig implements RegisterConfig {
115 
116     private final TargetDescription target;
117 
118     private final RegisterArray allocatable;
119 
120     private final RegisterAttributes[] attributesMap;
121 
122     @Override
123     public RegisterArray getAllocatableRegisters() {
124         return allocatable;
125     }
126 
127     @Override
128     public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {
129         ArrayList&lt;Register&gt; list = new ArrayList&lt;&gt;();
130         for (Register reg : registers) {
131             if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {
132                 list.add(reg);
133             }
134         }
135         return new RegisterArray(list);
136     }
137 
138     @Override
139     public RegisterAttributes[] getAttributesMap() {
140         return attributesMap.clone();
141     }
142 
143     private final RegisterArray cpuCallerParameterRegisters = new RegisterArray(o0, o1, o2, o3, o4, o5);
144     private final RegisterArray cpuCalleeParameterRegisters = new RegisterArray(i0, i1, i2, i3, i4, i5);
145 
146     private final RegisterArray fpuFloatJavaParameterRegisters = new RegisterArray(f0, f1, f2, f3, f4, f5, f6, f7);
147     private final RegisterArray fpuDoubleJavaParameterRegisters = new RegisterArray(d0, null, d2, null, d4, null, d6, null);
148 
149     // @formatter:off
150     private final RegisterArray fpuFloatNativeParameterRegisters = new RegisterArray(
151                     f1,   f3,  f5,  f7,  f9, f11, f13, f15,
152                     f17, f19, f21, f23, f25, f27, f29, f31);
153 
154     private final RegisterArray fpuDoubleNativeParameterRegisters = new RegisterArray(
155                      d0,  d2,  d4,  d6,  d8, d10, d12, d14,
156                     d16, d18, d20, d22, d24, d26, d28, d30);
157 
158     private final RegisterArray callerSaveRegisters;
159 
160     /**
161      * This lists all L and I registers which are saved in the register window.
162      */
163     private final RegisterArray windowSaveRegisters = new RegisterArray(
164                     l0, l1, l2, l3, l4, l5, l6, l7,
165                     i0, i1, i2, i3, i4, i5, i6, i7);
166     // @formatter:on
167 
168     private static final RegisterArray reservedRegisters = new RegisterArray(sp, g0, g2);
169 
170     private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {
171         RegisterArray allRegisters = arch.getAvailableValueRegisters();
172         Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];
173         List&lt;Register&gt; reservedRegistersList = reservedRegisters.asList();
174 
175         int idx = 0;
176         for (Register reg : allRegisters) {
177             if (reservedRegistersList.contains(reg)) {
178                 // skip reserved registers
179                 continue;
180             }
181             if (reserveForHeapBase &amp;&amp; reg.equals(g6)) {
182                 // skip heap base register
183                 continue;
184             }
185 
186             registers[idx++] = reg;
187         }
188 
189         assert idx == registers.length;
190         return new RegisterArray(registers);
191     }
192 
193     public SPARCHotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops) {
194         this(target, initAllocatable(target.arch, useCompressedOops));
195     }
196 
197     public SPARCHotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {
198         this.target = target;
199         this.allocatable = allocatable;
200         HashSet&lt;Register&gt; callerSaveSet = new HashSet&lt;&gt;(target.arch.getAvailableValueRegisters().asList());
201         for (Register cs : windowSaveRegisters) {
202             callerSaveSet.remove(cs);
203         }
204         this.callerSaveRegisters = new RegisterArray(callerSaveSet);
205         attributesMap = RegisterAttributes.createMap(this, SPARC.allRegisters);
206     }
207 
208     @Override
209     public RegisterArray getCallerSaveRegisters() {
210         return callerSaveRegisters;
211     }
212 
213     @Override
214     public RegisterArray getCalleeSaveRegisters() {
215         return null;
216     }
217 
218     @Override
219     public boolean areAllAllocatableRegistersCallerSaved() {
220         return false;
221     }
222 
223     @Override
224     public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory&lt;?&gt; valueKindFactory) {
225         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
226         if (type == HotSpotCallingConventionType.JavaCall || type == HotSpotCallingConventionType.NativeCall) {
227             return callingConvention(cpuCallerParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
228         }
229         if (type == HotSpotCallingConventionType.JavaCallee) {
230             return callingConvention(cpuCalleeParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);
231         }
232         throw JVMCIError.shouldNotReachHere();
233     }
234 
235     @Override
236     public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {
237         HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;
238         switch (kind) {
239             case Boolean:
240             case Byte:
241             case Short:
242             case Char:
243             case Int:
244             case Long:
245             case Object:
246                 return hotspotType == HotSpotCallingConventionType.JavaCallee ? cpuCalleeParameterRegisters : cpuCallerParameterRegisters;
247             case Double:
248             case Float:
249                 return fpuFloatJavaParameterRegisters;
250             default:
251                 throw JVMCIError.shouldNotReachHere(&quot;Unknown JavaKind &quot; + kind);
252         }
253     }
254 
255     private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,
256                     ValueKindFactory&lt;?&gt; valueKindFactory) {
257         AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];
258 
259         int currentGeneral = 0;
260         int currentFloating = 0;
261         int currentStackOffset = 0;
262         boolean isNative = type == HotSpotCallingConventionType.NativeCall;
263 
264         for (int i = 0; i &lt; parameterTypes.length; i++) {
265             final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();
266             if (isNative) {
267                 RegisterArray registerSet;
268                 switch (kind) {
269                     case Byte:
270                     case Boolean:
271                     case Short:
272                     case Char:
273                     case Int:
274                     case Long:
275                     case Object:
276                         registerSet = generalParameterRegisters;
277                         break;
278                     case Double:
279                         registerSet = fpuDoubleNativeParameterRegisters;
280                         break;
281                     case Float:
282                         registerSet = fpuFloatNativeParameterRegisters;
283                         break;
284                     default:
285                         throw JVMCIError.shouldNotReachHere();
286                 }
287                 if (i &lt; registerSet.size()) {
288                     locations[i] = registerSet.get(i).asValue(valueKindFactory.getValueKind(kind));
289                     currentStackOffset += target.arch.getWordSize();
290                 }
291             } else {
292                 switch (kind) {
293                     case Byte:
294                     case Boolean:
295                     case Short:
296                     case Char:
297                     case Int:
298                     case Long:
299                     case Object:
300                         if (currentGeneral &lt; generalParameterRegisters.size()) {
301                             Register register = generalParameterRegisters.get(currentGeneral++);
302                             locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
303                         }
304                         break;
305                     case Double:
306                         if (currentFloating &lt; fpuFloatJavaParameterRegisters.size()) {
307                             if (currentFloating % 2 != 0) {
308                                 // Make register number even to be a double reg
309                                 currentFloating++;
310                             }
311                             Register register = fpuDoubleJavaParameterRegisters.get(currentFloating);
312                             currentFloating += 2; // Only every second is a double register
313                             locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
314                         }
315                         break;
316                     case Float:
317                         if (currentFloating &lt; fpuFloatJavaParameterRegisters.size()) {
318                             Register register = fpuFloatJavaParameterRegisters.get(currentFloating++);
319                             locations[i] = register.asValue(valueKindFactory.getValueKind(kind));
320                         }
321                         break;
322                     default:
323                         throw JVMCIError.shouldNotReachHere();
324                 }
325             }
326 
327             if (locations[i] == null) {
328                 ValueKind&lt;?&gt; valueKind = valueKindFactory.getValueKind(kind);
329                 int typeSize = valueKind.getPlatformKind().getSizeInBytes();
330                 if (isNative) {
331                     currentStackOffset += target.arch.getWordSize() - typeSize;
332                 }
333                 currentStackOffset = roundUp(currentStackOffset, typeSize);
334                 int slotOffset = currentStackOffset + REGISTER_SAFE_AREA_SIZE;
335                 locations[i] = StackSlot.get(valueKind, slotOffset, !type.out);
336                 currentStackOffset += typeSize;
337             }
338         }
339 
340         JavaKind returnKind = returnType == null ? Void : returnType.getJavaKind();
341         AllocatableValue returnLocation = returnKind == Void ? ILLEGAL : getReturnRegister(returnKind, type).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));
342         return new CallingConvention(currentStackOffset, returnLocation, locations);
343     }
344 
345     private static int roundUp(int number, int mod) {
346         return ((number + mod - 1) / mod) * mod;
347     }
348 
349     @Override
350     public Register getReturnRegister(JavaKind kind) {
351         return getReturnRegister(kind, HotSpotCallingConventionType.JavaCallee);
352     }
353 
354     private static Register getReturnRegister(JavaKind kind, HotSpotCallingConventionType type) {
355         switch (kind) {
356             case Boolean:
357             case Byte:
358             case Char:
359             case Short:
360             case Int:
361             case Long:
362             case Object:
363                 return type == HotSpotCallingConventionType.JavaCallee ? i0 : o0;
364             case Float:
365                 return f0;
366             case Double:
367                 return d0;
368             case Void:
369             case Illegal:
370                 return null;
371             default:
372                 throw new UnsupportedOperationException(&quot;no return register for type &quot; + kind);
373         }
374     }
375 
376     @Override
377     public Register getFrameRegister() {
378         return sp;
379     }
380 
381     @Override
382     public String toString() {
383         return String.format(&quot;Allocatable: &quot; + getAllocatableRegisters() + &quot;%n&quot; + &quot;CallerSave:  &quot; + getCallerSaveRegisters() + &quot;%n&quot;);
384     }
385 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/Linker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package jdk.tools.jaotc;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.File;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.nio.file.Files;
 33 import java.nio.file.Path;
 34 import java.nio.file.Paths;
 35 import java.util.List;
 36 import java.util.stream.Stream;
 37 
 38 final class Linker {
 39 
 40     private final Options options;
 41     private String objectFileName;
 42     private String libraryFileName;
 43     private String linkerCmd;
 44 
 45     String objFile() {
 46         return objectFileName;
 47     }
 48 
 49     String libFile() {
 50         return libraryFileName;
 51     }
 52 
 53     private static Stream&lt;String&gt; getLines(InputStream stream) {
 54         return new BufferedReader(new InputStreamReader(stream)).lines();
 55     }
 56 
 57     private static String getString(InputStream stream) {
 58         Stream&lt;String&gt; lines = getLines(stream);
 59         StringBuilder sb = new StringBuilder();
 60         lines.iterator().forEachRemaining(e -&gt; sb.append(e));
 61         return sb.toString();
 62     }
 63 
 64     Linker(Main main) throws Exception {
 65         this.options = main.options;
 66         String name = options.outputName;
 67         objectFileName = name;
 68         libraryFileName = name;
 69 
 70         if (options.linkerpath != null &amp;&amp; !(new File(options.linkerpath).exists())) {
 71             throw new InternalError(&quot;Invalid linker path: &quot; + options.linkerpath);
 72         }
 73         String linkerPath;
 74         String linkerCheck;
 75 
 76         switch (options.osName) {
 77             case &quot;Linux&quot;:
 78                 if (name.endsWith(&quot;.so&quot;)) {
 79                     objectFileName = name.substring(0, name.length() - &quot;.so&quot;.length());
 80                 }
 81                 objectFileName = objectFileName + &quot;.o&quot;;
 82                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
 83                 linkerCmd = linkerPath + &quot; -shared -z noexecstack -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
 84                 linkerCheck = linkerPath + &quot; -v&quot;;
 85                 break;
<a name="2" id="anc2"></a><span class="line-removed"> 86             case &quot;SunOS&quot;:</span>
<span class="line-removed"> 87                 if (name.endsWith(&quot;.so&quot;)) {</span>
<span class="line-removed"> 88                     objectFileName = name.substring(0, name.length() - &quot;.so&quot;.length());</span>
<span class="line-removed"> 89                 }</span>
<span class="line-removed"> 90                 objectFileName = objectFileName + &quot;.o&quot;;</span>
<span class="line-removed"> 91                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;</span>
<span class="line-removed"> 92                 linkerCmd = linkerPath + &quot; -shared -o &quot; + libraryFileName + &quot; &quot; + objectFileName;</span>
<span class="line-removed"> 93                 linkerCheck = linkerPath + &quot; -V&quot;;</span>
<span class="line-removed"> 94                 break;</span>
 95             case &quot;Mac OS X&quot;:
 96                 if (name.endsWith(&quot;.dylib&quot;)) {
 97                     objectFileName = name.substring(0, name.length() - &quot;.dylib&quot;.length());
 98                 }
 99                 objectFileName = objectFileName + &quot;.o&quot;;
100                 linkerPath = (options.linkerpath != null) ? options.linkerpath : &quot;ld&quot;;
101                 linkerCmd = linkerPath + &quot; -dylib -o &quot; + libraryFileName + &quot; &quot; + objectFileName;
102                 linkerCheck = linkerPath + &quot; -v&quot;;
103                 break;
104             default:
105                 if (options.osName.startsWith(&quot;Windows&quot;)) {
106                     if (name.endsWith(&quot;.dll&quot;)) {
107                         objectFileName = name.substring(0, name.length() - &quot;.dll&quot;.length());
108                     }
109                     objectFileName = objectFileName + &quot;.obj&quot;;
110                     linkerPath = (options.linkerpath != null) ? options.linkerpath : getWindowsLinkPath();
111                     if (linkerPath == null) {
112                         throw new InternalError(&quot;Can&#39;t locate Microsoft Visual Studio amd64 link.exe&quot;);
113                     }
114                     linkerCmd = linkerPath + &quot; /DLL /OPT:NOREF /NOLOGO /NOENTRY&quot; + &quot; /OUT:&quot; + libraryFileName + &quot; &quot; + objectFileName;
115                     linkerCheck = null; // link.exe presence is verified already
116                     break;
117                 } else {
118                     throw new InternalError(&quot;Unsupported platform: &quot; + options.osName);
119                 }
120         }
121 
122         // Check linker presence on platforms by printing its version
123         if (linkerCheck != null) {
124             Process p = Runtime.getRuntime().exec(linkerCheck);
125             final int exitCode = p.waitFor();
126             if (exitCode != 0) {
127                 throw new InternalError(getString(p.getErrorStream()));
128             }
129         }
130     }
131 
132     void link() throws Exception {
133         Process p = Runtime.getRuntime().exec(linkerCmd);
134         final int exitCode = p.waitFor();
135         if (exitCode != 0) {
136             String errorMessage = getString(p.getErrorStream());
137             if (errorMessage.isEmpty()) {
138                 errorMessage = getString(p.getInputStream());
139             }
140             throw new InternalError(errorMessage);
141         }
142         File objFile = new File(objectFileName);
143         boolean keepObjFile = Boolean.parseBoolean(System.getProperty(&quot;aot.keep.objFile&quot;, &quot;false&quot;));
144         if (objFile.exists() &amp;&amp; !keepObjFile) {
145             if (!objFile.delete()) {
146                 throw new InternalError(&quot;Failed to delete &quot; + objectFileName + &quot; file&quot;);
147             }
148         }
149         // Make non-executable for all.
150         File libFile = new File(libraryFileName);
151         if (libFile.exists() &amp;&amp; !options.osName.startsWith(&quot;Windows&quot;)) {
152             if (!libFile.setExecutable(false, false)) {
153                 throw new InternalError(&quot;Failed to change attribute for &quot; + libraryFileName + &quot; file&quot;);
154             }
155         }
156 
157     }
158 
159     /**
160      * Search for Visual Studio link.exe Search Order is: VS2017+, VS2013, VS2015, VS2012.
161      */
162     private static String getWindowsLinkPath() throws Exception {
163         try {
164             Path vc141NewerLinker = getVC141AndNewerLinker();
165             if (vc141NewerLinker != null) {
166                 return vc141NewerLinker.toString();
167             }
168         } catch (Exception e) {
169             e.printStackTrace();
170         }
171 
172         String link = &quot;\\VC\\bin\\amd64\\link.exe&quot;;
173 
174         /**
175          * First try searching the paths pointed to by the VS environment variables.
176          */
177         for (VSVERSIONS vs : VSVERSIONS.values()) {
178             String vspath = System.getenv(vs.getEnvVariable());
179             if (vspath != null) {
180                 File commonTools = new File(vspath);
181                 File vsRoot = commonTools.getParentFile().getParentFile();
182                 File linkPath = new File(vsRoot, link);
183                 if (linkPath.exists()) {
184                     return linkPath.getPath();
185                 }
186             }
187         }
188 
189         /**
190          * If we didn&#39;t find via the VS environment variables, try the well known paths
191          */
192         for (VSVERSIONS vs : VSVERSIONS.values()) {
193             String wkp = vs.getWellKnownPath();
194             if (new File(wkp).exists()) {
195                 return wkp;
196             }
197         }
198 
199         return null;
200     }
201 
202     private static Path getVC141AndNewerLinker() throws Exception {
203         String programFilesX86 = System.getenv(&quot;ProgramFiles(x86)&quot;);
204         if (programFilesX86 == null) {
205             throw new InternalError(&quot;Could not read the ProgramFiles(x86) environment variable&quot;);
206         }
207         Path vswhere = Paths.get(programFilesX86 + &quot;\\Microsoft Visual Studio\\Installer\\vswhere.exe&quot;);
208         if (!Files.exists(vswhere)) {
209             return null;
210         }
211 
212         ProcessBuilder processBuilder = new ProcessBuilder(vswhere.toString(), &quot;-requires&quot;,
213                         &quot;Microsoft.VisualStudio.Component.VC.Tools.x86.x64&quot;, &quot;-property&quot;, &quot;installationPath&quot;, &quot;-latest&quot;);
214         processBuilder.redirectOutput(ProcessBuilder.Redirect.PIPE);
215         processBuilder.redirectError(ProcessBuilder.Redirect.PIPE);
216         Process process = processBuilder.start();
217         final int exitCode = process.waitFor();
218         if (exitCode != 0) {
219             String errorMessage = getString(process.getErrorStream());
220             if (errorMessage.isEmpty()) {
221                 errorMessage = getString(process.getInputStream());
222             }
223             throw new InternalError(errorMessage);
224         }
225 
226         String installationPath = getLines(process.getInputStream()).findFirst().orElseThrow(() -&gt; new InternalError(&quot;Unexpected empty output from vswhere&quot;));
227         Path vcToolsVersionFilePath = Paths.get(installationPath, &quot;VC\\Auxiliary\\Build\\Microsoft.VCToolsVersion.default.txt&quot;);
228         List&lt;String&gt; vcToolsVersionFileLines = Files.readAllLines(vcToolsVersionFilePath);
229         if (vcToolsVersionFileLines.isEmpty()) {
230             throw new InternalError(vcToolsVersionFilePath.toString() + &quot; is empty&quot;);
231         }
232         String vcToolsVersion = vcToolsVersionFileLines.get(0);
233         Path linkPath = Paths.get(installationPath, &quot;VC\\Tools\\MSVC&quot;, vcToolsVersion, &quot;bin\\Hostx64\\x64\\link.exe&quot;);
234         if (!Files.exists(linkPath)) {
235             throw new InternalError(&quot;Linker at path &quot; + linkPath.toString() + &quot; does not exist&quot;);
236         }
237 
238         return linkPath;
239     }
240 
241     // @formatter:off (workaround for Eclipse formatting bug)
242     enum VSVERSIONS {
243         VS2013(&quot;VS120COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\bin\\amd64\\link.exe&quot;),
244         VS2015(&quot;VS140COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\link.exe&quot;),
245         VS2012(&quot;VS110COMNTOOLS&quot;, &quot;C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\bin\\amd64\\link.exe&quot;);
246 
247         private final String envvariable;
248         private final String wkp;
249 
250         VSVERSIONS(String envvariable, String wellknownpath) {
251             this.envvariable = envvariable;
252             this.wkp = wellknownpath;
253         }
254 
255         String getEnvVariable() {
256             return envvariable;
257         }
258 
259         String getWellKnownPath() {
260             return wkp;
261         }
262     }
263     // @formatter:on
264 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
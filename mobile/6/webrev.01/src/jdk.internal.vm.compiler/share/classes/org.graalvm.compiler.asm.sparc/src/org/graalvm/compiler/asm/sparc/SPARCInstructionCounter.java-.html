<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc/src/org/graalvm/compiler/asm/sparc/SPARCInstructionCounter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.asm.sparc;
 26 
 27 import java.util.TreeMap;
 28 
 29 import org.graalvm.compiler.asm.Assembler.InstructionCounter;
 30 
 31 public class SPARCInstructionCounter implements InstructionCounter {
 32     // Use a treemap to keep the order in the output
 33     private static final TreeMap&lt;String, SPARCInstructionMatch&gt; INSTRUCTION_MATCHER = new TreeMap&lt;&gt;();
 34 
 35     static {
 36         // @formatter:off
 37         INSTRUCTION_MATCHER.put(&quot;nop&quot;, new SPARCInstructionMatch(0xFFFF_FFFF, 0x0100_0000));
 38         INSTRUCTION_MATCHER.put(&quot;st&quot;, new OP3LowBitsMatcher(0b11, 0x4, 0x5, 0x6, 0x7, 0xe, 0xf));
 39         INSTRUCTION_MATCHER.put(&quot;ld&quot;, new OP3LowBitsMatcher(0b11, 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd));
 40         INSTRUCTION_MATCHER.put(&quot;all&quot;, new SPARCInstructionMatch(0x0, 0x0));
 41         // @formatter:on
 42     }
 43 
 44     private final SPARCAssembler asm;
 45 
 46     public SPARCInstructionCounter(SPARCAssembler asm) {
 47         super();
 48         this.asm = asm;
 49     }
 50 
 51     @Override
 52     public int[] countInstructions(String[] instructionTypes, int beginPc, int endPc) {
 53         SPARCInstructionMatch[] matchers = new SPARCInstructionMatch[instructionTypes.length];
 54         for (int i = 0; i &lt; instructionTypes.length; i++) {
 55             String typeName = instructionTypes[i];
 56             matchers[i] = INSTRUCTION_MATCHER.get(typeName);
 57             if (matchers[i] == null) {
 58                 throw new IllegalArgumentException(String.format(&quot;Unknown instruction class %s, supported types are: %s&quot;, typeName, INSTRUCTION_MATCHER.keySet()));
 59             }
 60         }
 61         return countBetween(matchers, beginPc, endPc);
 62     }
 63 
 64     private int[] countBetween(SPARCInstructionMatch[] matchers, int startPc, int endPc) {
 65         int[] counts = new int[matchers.length];
 66         for (int p = startPc; p &lt; endPc; p += 4) {
 67             int instr = asm.getInt(p);
 68             for (int i = 0; i &lt; matchers.length; i++) {
 69                 SPARCInstructionMatch matcher = matchers[i];
 70                 if (matcher.matches(instr)) {
 71                     counts[i]++;
 72                 }
 73             }
 74         }
 75         return counts;
 76     }
 77 
 78     @Override
 79     public String[] getSupportedInstructionTypes() {
 80         return INSTRUCTION_MATCHER.keySet().toArray(new String[0]);
 81     }
 82 
 83     /**
 84      * Tests the lower 3 bits of the op3 field.
 85      */
 86     private static class OP3LowBitsMatcher extends SPARCInstructionMatch {
 87         private final int[] op3b03;
 88         private final int op;
 89 
 90         OP3LowBitsMatcher(int op, int... op3b03) {
 91             super(0, 0);
 92             this.op = op;
 93             this.op3b03 = op3b03;
 94         }
 95 
 96         @Override
 97         public boolean matches(int instruction) {
 98             if (instruction &gt;&gt;&gt; 30 != op) {
 99                 return false;
100             }
101             int op3lo = (instruction &gt;&gt; 19) &amp; ((1 &lt;&lt; 4) - 1);
102             for (int op3Part : op3b03) {
103                 if (op3Part == op3lo) {
104                     return true;
105                 }
106             }
107             return false;
108         }
109     }
110 
111     private static class SPARCInstructionMatch {
112         private final int mask;
113         private final int[] patterns;
114 
115         SPARCInstructionMatch(int mask, int... patterns) {
116             super();
117             this.mask = mask;
118             this.patterns = patterns;
119         }
120 
121         public boolean matches(int instruction) {
122             for (int pattern : patterns) {
123                 if ((instruction &amp; mask) == pattern) {
124                     return true;
125                 }
126             }
127             return false;
128         }
129     }
130 }
    </pre>
  </body>
</html>
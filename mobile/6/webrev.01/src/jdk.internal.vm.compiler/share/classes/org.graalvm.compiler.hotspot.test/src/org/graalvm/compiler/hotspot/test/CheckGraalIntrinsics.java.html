<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CheckGraalIntrinsics.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import java.lang.reflect.Method;
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.Collection;
 31 import java.util.Collections;
 32 import java.util.Formatter;
 33 import java.util.List;
 34 import java.util.ServiceLoader;
 35 import java.util.Set;
 36 import java.util.TreeSet;
 37 import java.util.stream.Collectors;
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicMap;
 40 import jdk.internal.vm.compiler.collections.MapCursor;
 41 import org.graalvm.compiler.api.test.Graal;
 42 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 43 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 44 import org.graalvm.compiler.hotspot.meta.HotSpotGraphBuilderPlugins;
 45 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 46 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 47 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 48 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 49 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Binding;
 50 import org.graalvm.compiler.runtime.RuntimeProvider;
 51 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 52 import org.graalvm.compiler.test.GraalTest;
 53 import org.junit.Test;
 54 
 55 import jdk.vm.ci.aarch64.AArch64;
 56 import jdk.vm.ci.amd64.AMD64;
 57 import jdk.vm.ci.code.Architecture;
 58 import jdk.vm.ci.hotspot.HotSpotVMConfigStore;
 59 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
 60 import jdk.vm.ci.meta.MetaAccessProvider;
 61 import jdk.vm.ci.meta.MetaUtil;
 62 import jdk.vm.ci.meta.MethodHandleAccessProvider.IntrinsicMethod;
 63 import jdk.vm.ci.meta.ResolvedJavaMethod;
 64 
 65 /**
 66  * Checks the intrinsics implemented by Graal against the set of intrinsics declared by HotSpot. The
 67  * purpose of this test is to detect when new intrinsics are added to HotSpot and process them
 68  * appropriately in Graal. This will be achieved by working through {@link #toBeInvestigated} and
 69  * either implementing the intrinsic or moving it to {@link #ignore} .
 70  */
 71 public class CheckGraalIntrinsics extends GraalTest {
 72 
 73     public static boolean match(String type, Binding binding, VMIntrinsicMethod intrinsic) {
 74         if (intrinsic.name.equals(binding.name)) {
 75             if (intrinsic.descriptor.startsWith(binding.argumentsDescriptor)) {
 76                 if (type.equals(intrinsic.declaringClass)) {
 77                     return true;
 78                 }
 79             }
 80         }
 81         return false;
 82     }
 83 
 84     public static InvocationPlugin findPlugin(EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings, VMIntrinsicMethod intrinsic) {
 85         MapCursor&lt;String, List&lt;Binding&gt;&gt; cursor = bindings.getEntries();
 86         while (cursor.advance()) {
 87             // Match format of VMIntrinsicMethod.declaringClass
 88             String type = MetaUtil.internalNameToJava(cursor.getKey(), true, false).replace(&#39;.&#39;, &#39;/&#39;);
 89             for (Binding binding : cursor.getValue()) {
 90                 if (match(type, binding, intrinsic)) {
 91                     return binding.plugin;
 92                 }
 93             }
 94         }
 95         return null;
 96     }
 97 
 98     public static ResolvedJavaMethod resolveIntrinsic(MetaAccessProvider metaAccess, VMIntrinsicMethod intrinsic) throws ClassNotFoundException {
 99         Class&lt;?&gt; c;
100         try {
101             c = Class.forName(intrinsic.declaringClass.replace(&#39;/&#39;, &#39;.&#39;), false, CheckGraalIntrinsics.class.getClassLoader());
102         } catch (ClassNotFoundException ex) {
103             try {
104                 Class.forName(&quot;javax.naming.Reference&quot;);
105             } catch (ClassNotFoundException coreNamingMissing) {
106                 // if core JDK classes aren&#39;t found, we are probably running in a
107                 // JDK9 java.base environment and then missing class is OK
108                 return null;
109             }
110             throw ex;
111         }
112         for (Method javaMethod : c.getDeclaredMethods()) {
113             if (javaMethod.getName().equals(intrinsic.name)) {
114                 ResolvedJavaMethod method = metaAccess.lookupJavaMethod(javaMethod);
115                 if (intrinsic.descriptor.equals(&quot;*&quot;)) {
116                     // Signature polymorphic method - name match is enough
117                     return method;
118                 } else {
119                     if (method.getSignature().toMethodDescriptor().equals(intrinsic.descriptor)) {
120                         return method;
121                     }
122                 }
123             }
124         }
125         return null;
126     }
127 
128     /**
129      * The HotSpot intrinsics that:
130      * &lt;ul&gt;
131      * &lt;li&gt;will never implemented by Graal (comments must explain why)&lt;/li&gt;
132      * &lt;li&gt;are implemented without {@link InvocationPlugin}s, or&lt;/li&gt;
133      * &lt;li&gt;whose {@link InvocationPlugin} registration is guarded by a condition that is false in
134      * the current VM context.&lt;/li&gt;
135      * &lt;/ul&gt;
136      */
137     public final Set&lt;String&gt; ignore = new TreeSet&lt;&gt;();
138 
139     /**
140      * The HotSpot intrinsics whose {@link InvocationPlugin} registration is guarded by a condition
141      * too complex to duplicate here.
142      * &lt;/ul&gt;
143      */
144     public final Set&lt;String&gt; complexGuard = new TreeSet&lt;&gt;();
145 
146     /**
147      * The HotSpot intrinsics implemented downstream.
148      * &lt;/ul&gt;
149      */
150     public final Set&lt;String&gt; downstream = new TreeSet&lt;&gt;();
151 
152     /**
153      * The HotSpot intrinsics yet to be implemented or moved to {@link #ignore}.
154      */
155     public final Set&lt;String&gt; toBeInvestigated = new TreeSet&lt;&gt;();
156 
157     private static Collection&lt;String&gt; add(Collection&lt;String&gt; c, String... elements) {
158         String[] sorted = elements.clone();
159         Arrays.sort(sorted);
160         if (!Arrays.equals(elements, sorted)) {
161             int width = 2 + Arrays.asList(elements).stream().map(String::length).reduce(0, Integer::max);
162             Formatter fmt = new Formatter();
163             fmt.format(&quot;%-&quot; + width + &quot;s | sorted%n&quot;, &quot;original&quot;);
164             fmt.format(&quot;%s%n&quot;, new String(new char[width * 2 + 2]).replace(&#39;\0&#39;, &#39;=&#39;));
165             for (int i = 0; i &lt; elements.length; i++) {
166                 fmt.format(&quot;%-&quot; + width + &quot;s | %s%n&quot;, elements[i], sorted[i]);
167             }
168             fail(&quot;Elements not sorted alphabetically:%n%s&quot;, fmt);
169         }
170         c.addAll(Arrays.asList(elements));
171         return c;
172     }
173 
174     public final HotSpotGraalRuntimeProvider rt = (HotSpotGraalRuntimeProvider) Graal.getRequiredCapability(RuntimeProvider.class);
175     public final Architecture arch = rt.getHostBackend().getTarget().arch;
176     public final GraalHotSpotVMConfig config = rt.getVMConfig();
177 
178     public CheckGraalIntrinsics() {
179         // These are dead
180         add(ignore,
181                         &quot;java/lang/Math.atan2(DD)D&quot;,
182                         &quot;jdk/internal/misc/Unsafe.park(ZJ)V&quot;,
183                         &quot;jdk/internal/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;,
184                         &quot;sun/misc/Unsafe.park(ZJ)V&quot;,
185                         &quot;sun/misc/Unsafe.prefetchRead(Ljava/lang/Object;J)V&quot;,
186                         &quot;sun/misc/Unsafe.prefetchReadStatic(Ljava/lang/Object;J)V&quot;,
187                         &quot;sun/misc/Unsafe.prefetchWrite(Ljava/lang/Object;J)V&quot;,
188                         &quot;sun/misc/Unsafe.prefetchWriteStatic(Ljava/lang/Object;J)V&quot;,
189                         &quot;sun/misc/Unsafe.unpark(Ljava/lang/Object;)V&quot;);
190 
191         // These only exist to assist escape analysis in C2
192         add(ignore,
193                         &quot;java/lang/Throwable.fillInStackTrace()Ljava/lang/Throwable;&quot;);
194 
195         // These are only used for the security handling during stack walking
196         add(ignore,
197                         &quot;java/lang/reflect/Method.invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);
198 
199         // These are marker intrinsic ids only
200         add(ignore,
201                         &quot;java/lang/invoke/MethodHandle.&lt;compiledLambdaForm&gt;*&quot;,
202                         &quot;java/lang/invoke/MethodHandle.invoke*&quot;);
203 
204         // These are implemented through lowering
205         add(ignore,
206                         &quot;java/lang/ref/Reference.get()Ljava/lang/Object;&quot;);
207 
208         // These are only used by C1
209         add(ignore,
210                         &quot;java/nio/Buffer.checkIndex(I)I&quot;);
211 
212         // These do general compiler optimizations and convert min/max to cmov instructions. We are
213         // ignoring them as cmovs are not necessarily beneficial.
214         add(ignore,
215                         &quot;java/lang/Math.max(II)I&quot;,
216                         &quot;java/lang/Math.min(II)I&quot;);
217 
218         // These are known to be implemented down stream
219         add(downstream,
220                         &quot;java/lang/Integer.toString(I)Ljava/lang/String;&quot;,
221                         &quot;java/lang/String.&lt;init&gt;(Ljava/lang/String;)V&quot;,
222                         &quot;java/lang/StringBuffer.&lt;init&gt;()V&quot;,
223                         &quot;java/lang/StringBuffer.&lt;init&gt;(I)V&quot;,
224                         &quot;java/lang/StringBuffer.&lt;init&gt;(Ljava/lang/String;)V&quot;,
225                         &quot;java/lang/StringBuffer.append(C)Ljava/lang/StringBuffer;&quot;,
226                         &quot;java/lang/StringBuffer.append(I)Ljava/lang/StringBuffer;&quot;,
227                         &quot;java/lang/StringBuffer.append(Ljava/lang/String;)Ljava/lang/StringBuffer;&quot;,
228                         &quot;java/lang/StringBuffer.toString()Ljava/lang/String;&quot;,
229                         &quot;java/lang/StringBuilder.&lt;init&gt;()V&quot;,
230                         &quot;java/lang/StringBuilder.&lt;init&gt;(I)V&quot;,
231                         &quot;java/lang/StringBuilder.&lt;init&gt;(Ljava/lang/String;)V&quot;,
232                         &quot;java/lang/StringBuilder.append(C)Ljava/lang/StringBuilder;&quot;,
233                         &quot;java/lang/StringBuilder.append(I)Ljava/lang/StringBuilder;&quot;,
234                         &quot;java/lang/StringBuilder.append(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;,
235                         &quot;java/lang/StringBuilder.toString()Ljava/lang/String;&quot;,
236                         &quot;java/util/Arrays.copyOf([Ljava/lang/Object;ILjava/lang/Class;)[Ljava/lang/Object;&quot;,
237                         &quot;java/util/Arrays.copyOfRange([Ljava/lang/Object;IILjava/lang/Class;)[Ljava/lang/Object;&quot;);
238 
239         add(complexGuard,
240                         &quot;java/lang/Integer.bitCount(I)I&quot;,
241                         &quot;java/lang/Integer.numberOfLeadingZeros(I)I&quot;,
242                         &quot;java/lang/Integer.numberOfTrailingZeros(I)I&quot;,
243                         &quot;java/lang/Long.bitCount(J)I&quot;,
244                         &quot;java/lang/Long.numberOfLeadingZeros(J)I&quot;,
245                         &quot;java/lang/Long.numberOfTrailingZeros(J)I&quot;);
246 
247         // Relevant for Java flight recorder
248         add(toBeInvestigated,
249                         &quot;oracle/jrockit/jfr/Timing.counterTime()J&quot;,
250                         &quot;oracle/jrockit/jfr/VMJFR.classID0(Ljava/lang/Class;)J&quot;,
251                         &quot;oracle/jrockit/jfr/VMJFR.threadID()I&quot;);
252 
253         add(toBeInvestigated,
254                         // Similar to addExact
255                         &quot;java/lang/Math.negateExact(I)I&quot;,
256                         // Similar to addExact
257                         &quot;java/lang/Math.negateExact(J)J&quot;,
258                         // HotSpot MacroAssembler-based intrinsic
259                         &quot;java/lang/String.indexOf(Ljava/lang/String;)I&quot;,
260                         // Can share most implementation parts with with
261                         // Unsafe.allocateUninitializedArray0
262                         &quot;java/lang/reflect/Array.newArray(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
263                         // HotSpot MacroAssembler-based intrinsic
264                         &quot;sun/nio/cs/ISO_8859_1$Encoder.encodeISOArray([CI[BII)I&quot;,
265                         // We have implemented implCompressMultiBlock0 on JDK9+. Does it worth
266                         // backporting as corresponding HotSpot stubs are only generated on SPARC?
267                         &quot;sun/security/provider/DigestBase.implCompressMultiBlock([BII)I&quot;);
268 
269         // See JDK-8207146.
270         String oopName = isJDK12OrHigher() ? &quot;Reference&quot; : &quot;Object&quot;;
271 
272         if (isJDK9OrHigher()) {
273             // Relevant for Java flight recorder
274             add(toBeInvestigated,
275                             &quot;jdk/jfr/internal/JVM.counterTime()J&quot;,
276                             &quot;jdk/jfr/internal/JVM.getBufferWriter()Ljava/lang/Object;&quot;,
277                             &quot;jdk/jfr/internal/JVM.getClassId(Ljava/lang/Class;)J&quot;);
278 
279             add(toBeInvestigated,
280                             // Just check if the argument is a compile time constant
281                             &quot;java/lang/invoke/MethodHandleImpl.isCompileConstant(Ljava/lang/Object;)Z&quot;,
282                             // Only used as a marker for vectorization?
283                             &quot;java/util/stream/Streams$RangeIntSpliterator.forEachRemaining(Ljava/util/function/IntConsumer;)V&quot;,
284                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
285                             &quot;java/util/zip/Adler32.updateByteBuffer(IJII)I&quot;,
286                             // Only implemented on non-AMD64 platforms (some logic and runtime call)
287                             &quot;java/util/zip/Adler32.updateBytes(I[BII)I&quot;,
288                             // Emits a slow and a fast path and some dispatching logic
289                             &quot;jdk/internal/misc/Unsafe.allocateUninitializedArray0(Ljava/lang/Class;I)Ljava/lang/Object;&quot;,
290 
291                             // Control flow, deopts, and a cast
292                             &quot;jdk/internal/util/Preconditions.checkIndex(IILjava/util/function/BiFunction;)I&quot;,
293                             // HotSpot MacroAssembler-based intrinsic
294                             &quot;sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray([CI[BII)I&quot;);
295 
296             /*
297              * Per default, all these operations are mapped to some generic method for which we
298              * already have compiler intrinsics. Performance-wise it would be better to support them
299              * explicitly as the more generic method might be more restrictive and therefore slower
300              * than necessary.
301              */
302 
303             add(toBeInvestigated,
304                             // Mapped to compareAndExchange*
305                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteAcquire(Ljava/lang/Object;JBB)B&quot;,
306                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByteRelease(Ljava/lang/Object;JBB)B&quot;,
307                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntAcquire(Ljava/lang/Object;JII)I&quot;,
308                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeIntRelease(Ljava/lang/Object;JII)I&quot;,
309                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongAcquire(Ljava/lang/Object;JJJ)J&quot;,
310                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeLongRelease(Ljava/lang/Object;JJJ)J&quot;,
311                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
312                             &quot;jdk/internal/misc/Unsafe.compareAndExchange&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;,
313                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortAcquire(Ljava/lang/Object;JSS)S&quot;,
314                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShortRelease(Ljava/lang/Object;JSS)S&quot;,
315 
316                             // Mapped to compareAndSet*
317                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
318                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteAcquire(Ljava/lang/Object;JBB)Z&quot;,
319                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetBytePlain(Ljava/lang/Object;JBB)Z&quot;,
320                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetByteRelease(Ljava/lang/Object;JBB)Z&quot;,
321                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetInt(Ljava/lang/Object;JII)Z&quot;,
322                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntAcquire(Ljava/lang/Object;JII)Z&quot;,
323                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntPlain(Ljava/lang/Object;JII)Z&quot;,
324                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetIntRelease(Ljava/lang/Object;JII)Z&quot;,
325                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLong(Ljava/lang/Object;JJJ)Z&quot;,
326                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongAcquire(Ljava/lang/Object;JJJ)Z&quot;,
327                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongPlain(Ljava/lang/Object;JJJ)Z&quot;,
328                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetLongRelease(Ljava/lang/Object;JJJ)Z&quot;,
329                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
330                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Acquire(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
331                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Plain(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
332                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSet&quot; + oopName + &quot;Release(Ljava/lang/Object;JLjava/lang/Object;Ljava/lang/Object;)Z&quot;,
333                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
334                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortAcquire(Ljava/lang/Object;JSS)Z&quot;,
335                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortPlain(Ljava/lang/Object;JSS)Z&quot;,
336                             &quot;jdk/internal/misc/Unsafe.weakCompareAndSetShortRelease(Ljava/lang/Object;JSS)Z&quot;);
337 
338             // Compact string support - HotSpot MacroAssembler-based intrinsic or complex C2 logic.
339             add(toBeInvestigated,
340                             &quot;java/lang/StringCoding.hasNegatives([BII)Z&quot;,
341                             &quot;java/lang/StringCoding.implEncodeISOArray([BI[BII)I&quot;);
342             add(ignore,
343                             // handled through an intrinsic for String.equals itself
344                             &quot;java/lang/StringLatin1.equals([B[B)Z&quot;,
345 
346                             // handled by an intrinsic for StringLatin1.indexOf([BI[BII)I
347                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
348 
349                             // handled through an intrinsic for String.equals itself
350                             &quot;java/lang/StringUTF16.equals([B[B)Z&quot;,
351 
352                             // handled by an intrinsic for StringUTF16.indexOfUnsafe
353                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
354                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
355 
356                             // handled by an intrinsic for StringUTF16.indexOfCharUnsafe
357                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
358 
359                             // handled by an intrinsic for StringUTF16.indexOfLatin1Unsafe
360                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
361                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;);
362 
363             if (!config.useAESCTRIntrinsics) {
364                 add(ignore,
365                                 &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;);
366             }
367             if (!config.useGHASHIntrinsics()) {
368                 add(ignore,
369                                 &quot;com/sun/crypto/provider/GHASH.processBlocks([BII[J[J)V&quot;);
370             }
371             if (!config.useFMAIntrinsics) {
372                 add(ignore,
373                                 &quot;java/lang/Math.fma(DDD)D&quot;,
374                                 &quot;java/lang/Math.fma(FFF)F&quot;);
375             }
376         }
377 
378         if (isJDK10OrHigher()) {
379             add(toBeInvestigated,
380                             &quot;java/lang/Math.multiplyHigh(JJ)J&quot;);
381         }
382 
383         if (isJDK11OrHigher()) {
384             // Relevant for Java flight recorder
385             add(toBeInvestigated,
386                             &quot;java/lang/CharacterDataLatin1.isDigit(I)Z&quot;,
387                             &quot;java/lang/CharacterDataLatin1.isLowerCase(I)Z&quot;,
388                             &quot;java/lang/CharacterDataLatin1.isUpperCase(I)Z&quot;,
389                             &quot;java/lang/CharacterDataLatin1.isWhitespace(I)Z&quot;,
390                             &quot;jdk/jfr/internal/JVM.getEventWriter()Ljava/lang/Object;&quot;);
391             if (!config.useBase64Intrinsics()) {
392                 add(ignore,
393                                 &quot;java/util/Base64$Encoder.encodeBlock([BII[BIZ)V&quot;);
394             }
395         }
396 
397         if (isJDK13OrHigher()) {
398             add(toBeInvestigated,
399                             &quot;java/lang/Math.abs(I)I&quot;,
400                             &quot;java/lang/Math.abs(J)J&quot;,
401                             &quot;java/lang/Math.max(DD)D&quot;,
402                             &quot;java/lang/Math.max(FF)F&quot;,
403                             &quot;java/lang/Math.min(DD)D&quot;,
404                             &quot;java/lang/Math.min(FF)F&quot;);
405             add(toBeInvestigated,
406                             &quot;jdk/internal/misc/Unsafe.writeback0(J)V&quot;,
407                             &quot;jdk/internal/misc/Unsafe.writebackPostSync0()V&quot;,
408                             &quot;jdk/internal/misc/Unsafe.writebackPreSync0()V&quot;);
409         }
410 
411         if (isJDK14OrHigher()) {
412             add(toBeInvestigated,
413                             &quot;com/sun/crypto/provider/ElectronicCodeBook.implECBDecrypt([BII[BI)I&quot;,
414                             &quot;com/sun/crypto/provider/ElectronicCodeBook.implECBEncrypt([BII[BI)I&quot;,
415                             &quot;java/math/BigInteger.shiftLeftImplWorker([I[IIII)V&quot;,
416                             &quot;java/math/BigInteger.shiftRightImplWorker([I[IIII)V&quot;);
417         }
418 
419         if (!config.inlineNotify()) {
420             add(ignore, &quot;java/lang/Object.notify()V&quot;);
421         }
422         if (!config.inlineNotifyAll()) {
423             add(ignore, &quot;java/lang/Object.notifyAll()V&quot;);
424         }
425 
426         if (!(arch instanceof AMD64)) {
427             // Can we implement these on non-AMD64 platforms? C2 seems to.
428             add(toBeInvestigated,
429                             &quot;com/sun/crypto/provider/CounterMode.implCrypt([BII[BI)I&quot;,
430                             &quot;java/lang/String.compareTo(Ljava/lang/String;)I&quot;,
431                             &quot;java/lang/StringLatin1.indexOf([B[B)I&quot;,
432                             &quot;java/lang/StringLatin1.inflate([BI[BII)V&quot;,
433                             &quot;java/lang/StringLatin1.inflate([BI[CII)V&quot;,
434                             &quot;java/lang/StringUTF16.compress([BI[BII)I&quot;,
435                             &quot;java/lang/StringUTF16.compress([CI[BII)I&quot;,
436                             &quot;java/lang/StringUTF16.indexOf([BI[BII)I&quot;,
437                             &quot;java/lang/StringUTF16.indexOf([B[B)I&quot;,
438                             &quot;java/lang/StringUTF16.indexOfChar([BIII)I&quot;,
439                             &quot;java/lang/StringUTF16.indexOfLatin1([BI[BII)I&quot;,
440                             &quot;java/lang/StringUTF16.indexOfLatin1([B[B)I&quot;,
441                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeByte(Ljava/lang/Object;JBB)B&quot;,
442                             &quot;jdk/internal/misc/Unsafe.compareAndExchangeShort(Ljava/lang/Object;JSS)S&quot;,
443                             &quot;jdk/internal/misc/Unsafe.compareAndSetByte(Ljava/lang/Object;JBB)Z&quot;,
444                             &quot;jdk/internal/misc/Unsafe.compareAndSetShort(Ljava/lang/Object;JSS)Z&quot;,
445                             &quot;jdk/internal/misc/Unsafe.getAndAddByte(Ljava/lang/Object;JB)B&quot;,
446                             &quot;jdk/internal/misc/Unsafe.getAndAddShort(Ljava/lang/Object;JS)S&quot;,
447                             &quot;jdk/internal/misc/Unsafe.getAndSetByte(Ljava/lang/Object;JB)B&quot;,
448                             &quot;jdk/internal/misc/Unsafe.getAndSetShort(Ljava/lang/Object;JS)S&quot;,
449                             &quot;sun/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
450                             &quot;sun/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
451                             &quot;sun/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
452                             &quot;sun/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
453                             &quot;sun/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
454 
455             if (isJDK9OrHigher()) {
456                 if (!(arch instanceof AArch64)) {
457                     add(toBeInvestigated,
458                                     &quot;java/lang/StringLatin1.compareTo([B[B)I&quot;,
459                                     &quot;java/lang/StringLatin1.compareToUTF16([B[B)I&quot;,
460                                     &quot;java/lang/StringUTF16.compareTo([B[B)I&quot;,
461                                     &quot;java/lang/StringUTF16.compareToLatin1([B[B)I&quot;,
462                                     &quot;jdk/internal/misc/Unsafe.getAndAddInt(Ljava/lang/Object;JI)I&quot;,
463                                     &quot;jdk/internal/misc/Unsafe.getAndAddLong(Ljava/lang/Object;JJ)J&quot;,
464                                     &quot;jdk/internal/misc/Unsafe.getAndSetInt(Ljava/lang/Object;JI)I&quot;,
465                                     &quot;jdk/internal/misc/Unsafe.getAndSetLong(Ljava/lang/Object;JJ)J&quot;,
466                                     &quot;jdk/internal/misc/Unsafe.getAndSet&quot; + oopName + &quot;(Ljava/lang/Object;JLjava/lang/Object;)Ljava/lang/Object;&quot;);
467                 }
468                 add(toBeInvestigated,
469                                 &quot;java/lang/Thread.onSpinWait()V&quot;,
470                                 &quot;java/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;,
471                                 &quot;jdk/internal/misc/Unsafe.getCharUnaligned(Ljava/lang/Object;J)C&quot;,
472                                 &quot;jdk/internal/misc/Unsafe.getIntUnaligned(Ljava/lang/Object;J)I&quot;,
473                                 &quot;jdk/internal/misc/Unsafe.getLongUnaligned(Ljava/lang/Object;J)J&quot;,
474                                 &quot;jdk/internal/misc/Unsafe.getShortUnaligned(Ljava/lang/Object;J)S&quot;,
475                                 &quot;jdk/internal/misc/Unsafe.putCharUnaligned(Ljava/lang/Object;JC)V&quot;,
476                                 &quot;jdk/internal/misc/Unsafe.putIntUnaligned(Ljava/lang/Object;JI)V&quot;,
477                                 &quot;jdk/internal/misc/Unsafe.putLongUnaligned(Ljava/lang/Object;JJ)V&quot;,
478                                 &quot;jdk/internal/misc/Unsafe.putShortUnaligned(Ljava/lang/Object;JS)V&quot;);
479             }
480             if (isJDK10OrHigher()) {
481                 add(toBeInvestigated,
482                                 &quot;jdk/internal/util/ArraysSupport.vectorizedMismatch(Ljava/lang/Object;JLjava/lang/Object;JII)I&quot;);
483             }
484         }
485 
486         /*
487          * The intrinsics down here are known to be implemented but they are not always enabled on
488          * the HotSpot side (e.g., because they require certain CPU features). So, we are ignoring
489          * them if the HotSpot config tells us that they can&#39;t be used.
490          */
491 
492         // CRC32 intrinsics
493         if (!config.useCRC32Intrinsics) {
494             add(ignore, &quot;java/util/zip/CRC32.update(II)I&quot;);
495             if (isJDK9OrHigher()) {
496                 add(ignore,
497                                 &quot;java/util/zip/CRC32.updateByteBuffer0(IJII)I&quot;,
498                                 &quot;java/util/zip/CRC32.updateBytes0(I[BII)I&quot;);
499             } else {
500                 add(ignore,
501                                 &quot;java/util/zip/CRC32.updateByteBuffer(IJII)I&quot;,
502                                 &quot;java/util/zip/CRC32.updateBytes(I[BII)I&quot;);
503             }
504         }
505 
506         // CRC32C intrinsics
507         if (!config.useCRC32CIntrinsics) {
508             add(ignore,
509                             &quot;java/util/zip/CRC32C.updateBytes(I[BII)I&quot;,
510                             &quot;java/util/zip/CRC32C.updateDirectByteBuffer(IJII)I&quot;);
511         }
512 
513         String cbcEncryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
514         String cbcDecryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
515         String aesEncryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
516         String aesDecryptName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
517 
518         // AES intrinsics
519         if (!config.useAESIntrinsics) {
520             add(ignore,
521                             &quot;com/sun/crypto/provider/AESCrypt.&quot; + aesDecryptName + &quot;([BI[BI)V&quot;,
522                             &quot;com/sun/crypto/provider/AESCrypt.&quot; + aesEncryptName + &quot;([BI[BI)V&quot;,
523                             &quot;com/sun/crypto/provider/CipherBlockChaining.&quot; + cbcDecryptName + &quot;([BII[BI)I&quot;,
524                             &quot;com/sun/crypto/provider/CipherBlockChaining.&quot; + cbcEncryptName + &quot;([BII[BI)I&quot;);
525         }
526 
527         // BigInteger intrinsics
528         if (!config.useMultiplyToLenIntrinsic()) {
529             if (isJDK9OrHigher()) {
530                 add(ignore, &quot;java/math/BigInteger.implMultiplyToLen([II[II[I)[I&quot;);
531             } else {
532                 add(ignore, &quot;java/math/BigInteger.multiplyToLen([II[II[I)[I&quot;);
533             }
534         }
535         if (!config.useMulAddIntrinsic()) {
536             add(ignore, &quot;java/math/BigInteger.implMulAdd([I[IIII)I&quot;);
537         }
538         if (!config.useMontgomeryMultiplyIntrinsic()) {
539             add(ignore, &quot;java/math/BigInteger.implMontgomeryMultiply([I[I[IIJ[I)[I&quot;);
540         }
541         if (!config.useMontgomerySquareIntrinsic()) {
542             add(ignore, &quot;java/math/BigInteger.implMontgomerySquare([I[IIJ[I)[I&quot;);
543         }
544         if (!config.useSquareToLenIntrinsic()) {
545             add(ignore, &quot;java/math/BigInteger.implSquareToLen([II[II)[I&quot;);
546         }
547         // DigestBase intrinsics
548         if (HotSpotGraphBuilderPlugins.isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp;
549                         !(config.useSHA1Intrinsics() || config.useSHA256Intrinsics() || config.useSHA512Intrinsics())) {
550             add(ignore, &quot;sun/security/provider/DigestBase.implCompressMultiBlock0([BII)I&quot;);
551         }
552         // SHA intrinsics
553         String shaCompressName = HotSpotGraphBuilderPlugins.lookupIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress0&quot;, &quot;implCompress&quot;);
554         if (!config.useSHA1Intrinsics()) {
555             add(ignore, &quot;sun/security/provider/SHA.&quot; + shaCompressName + &quot;([BI)V&quot;);
556         }
557         if (!config.useSHA256Intrinsics()) {
558             add(ignore, &quot;sun/security/provider/SHA2.&quot; + shaCompressName + &quot;([BI)V&quot;);
559         }
560         if (!config.useSHA512Intrinsics()) {
561             add(ignore, &quot;sun/security/provider/SHA5.&quot; + shaCompressName + &quot;([BI)V&quot;);
562         }
563     }
564 
565     private static boolean isJDK9OrHigher() {
566         return JavaVersionUtil.JAVA_SPEC &gt;= 9;
567     }
568 
569     private static boolean isJDK10OrHigher() {
570         return JavaVersionUtil.JAVA_SPEC &gt;= 10;
571     }
572 
573     private static boolean isJDK11OrHigher() {
574         return JavaVersionUtil.JAVA_SPEC &gt;= 11;
575     }
576 
577     private static boolean isJDK12OrHigher() {
578         return JavaVersionUtil.JAVA_SPEC &gt;= 12;
579     }
580 
581     private static boolean isJDK13OrHigher() {
582         return JavaVersionUtil.JAVA_SPEC &gt;= 13;
583     }
584 
585     private static boolean isJDK14OrHigher() {
586         return JavaVersionUtil.JAVA_SPEC &gt;= 14;
587     }
588 
589     public interface Refiner {
590         void refine(CheckGraalIntrinsics checker);
591     }
592 
593     @Test
594     @SuppressWarnings(&quot;try&quot;)
595     public void test() throws ClassNotFoundException {
596         HotSpotProviders providers = rt.getHostBackend().getProviders();
597         Plugins graphBuilderPlugins = providers.getGraphBuilderPlugins();
598         InvocationPlugins invocationPlugins = graphBuilderPlugins.getInvocationPlugins();
599 
600         HotSpotVMConfigStore store = config.getStore();
601         List&lt;VMIntrinsicMethod&gt; intrinsics = store.getIntrinsics();
602 
603         for (Refiner refiner : ServiceLoader.load(Refiner.class)) {
604             refiner.refine(this);
605         }
606 
607         List&lt;String&gt; missing = new ArrayList&lt;&gt;();
608         List&lt;String&gt; mischaracterizedAsToBeInvestigated = new ArrayList&lt;&gt;();
609         List&lt;String&gt; mischaracterizedAsIgnored = new ArrayList&lt;&gt;();
610         EconomicMap&lt;String, List&lt;Binding&gt;&gt; bindings = invocationPlugins.getBindings(true);
611         for (VMIntrinsicMethod intrinsic : intrinsics) {
612             InvocationPlugin plugin = findPlugin(bindings, intrinsic);
613             String m = String.format(&quot;%s.%s%s&quot;, intrinsic.declaringClass, intrinsic.name, intrinsic.descriptor);
614             if (plugin == null) {
615                 ResolvedJavaMethod method = resolveIntrinsic(providers.getMetaAccess(), intrinsic);
616                 if (method != null) {
617                     IntrinsicMethod intrinsicMethod = providers.getConstantReflection().getMethodHandleAccess().lookupMethodHandleIntrinsic(method);
618                     if (intrinsicMethod != null) {
619                         continue;
620                     }
621                 }
622                 if (!toBeInvestigated.contains(m) &amp;&amp; !ignore.contains(m) &amp;&amp; !complexGuard.contains(m) &amp;&amp; !downstream.contains(m)) {
623                     missing.add(m);
624                 }
625             } else {
626                 if (toBeInvestigated.contains(m)) {
627                     mischaracterizedAsToBeInvestigated.add(m);
628                 } else if (ignore.contains(m)) {
629                     mischaracterizedAsIgnored.add(m);
630                 }
631             }
632         }
633 
634         Formatter errorMsgBuf = new Formatter();
635         if (!missing.isEmpty()) {
636             Collections.sort(missing);
637             String missingString = missing.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
638             errorMsgBuf.format(&quot;missing Graal intrinsics for:%n    %s%n&quot;, missingString);
639         }
640         if (!mischaracterizedAsToBeInvestigated.isEmpty()) {
641             Collections.sort(mischaracterizedAsToBeInvestigated);
642             String missingString = mischaracterizedAsToBeInvestigated.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
643             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as toBeInvestigated:%n    %s%n&quot;, missingString);
644         }
645         if (!mischaracterizedAsIgnored.isEmpty()) {
646             Collections.sort(mischaracterizedAsIgnored);
647             String missingString = mischaracterizedAsIgnored.stream().collect(Collectors.joining(String.format(&quot;%n    &quot;)));
648             errorMsgBuf.format(&quot;found plugins for intrinsics characterized as IGNORED:%n    %s%n&quot;, missingString);
649         }
650         String errorMsg = errorMsgBuf.toString();
651         if (!errorMsg.isEmpty()) {
652             fail(errorMsg);
653         }
654     }
655 }
    </pre>
  </body>
</html>
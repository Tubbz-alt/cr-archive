<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.sparc.test/src/org/graalvm/compiler/asm/sparc/test/SPARCAssemblerTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.asm.sparc.test;
 26 
 27 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.BPCC;
 28 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.BPR;
 29 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.BR;
 30 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.CBCOND;
 31 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.Annul.ANNUL;
 32 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.BranchPredict.PREDICT_NOT_TAKEN;
 33 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.CC.Xcc;
 34 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.ConditionFlag.CarryClear;
 35 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.ConditionFlag.Equal;
 36 import static org.graalvm.compiler.asm.sparc.SPARCAssembler.RCondition.Rc_z;
 37 import static jdk.vm.ci.sparc.SPARC.g0;
 38 
 39 import java.util.EnumSet;
 40 import java.util.function.Consumer;
 41 
 42 import jdk.vm.ci.code.Architecture;
 43 import jdk.vm.ci.code.BailoutException;
 44 import jdk.vm.ci.code.TargetDescription;
 45 import jdk.vm.ci.sparc.SPARC;
 46 
 47 import org.junit.Assert;
 48 import org.junit.Before;
 49 import org.junit.Test;
 50 
 51 import org.graalvm.compiler.asm.Label;
 52 import org.graalvm.compiler.asm.sparc.SPARCAssembler;
 53 import org.graalvm.compiler.asm.sparc.SPARCAssembler.ControlTransferOp;
 54 import org.graalvm.compiler.asm.sparc.SPARCAssembler.SPARCOp;
 55 import org.graalvm.compiler.asm.sparc.SPARCMacroAssembler;
 56 import org.graalvm.compiler.test.GraalTest;
 57 
 58 public class SPARCAssemblerTest extends GraalTest {
 59     private SPARCMacroAssembler masm;
 60 
 61     private static EnumSet&lt;SPARC.CPUFeature&gt; computeFeatures() {
 62         EnumSet&lt;SPARC.CPUFeature&gt; features = EnumSet.noneOf(SPARC.CPUFeature.class);
 63         features.add(SPARC.CPUFeature.CBCOND);
 64         return features;
 65     }
 66 
 67     private static TargetDescription createTarget() {
 68         final int stackFrameAlignment = 16;
 69         final int implicitNullCheckLimit = 4096;
 70         final boolean inlineObjects = true;
 71         Architecture arch = new SPARC(computeFeatures());
 72         return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);
 73     }
 74 
 75     @Before
 76     public void setup() {
 77         TargetDescription target = createTarget();
 78         masm = new SPARCMacroAssembler(target);
 79     }
 80 
 81     @Test
 82     public void testPatchCbcod() {
 83         testControlTransferOp(l -&gt; CBCOND.emit(masm, CarryClear, false, g0, 3, l), -512, 511);
 84     }
 85 
 86     @Test
 87     public void testPatchBpcc() {
 88         int maxDisp = 1 &lt;&lt; 18;
 89         testControlTransferOp(l -&gt; BPCC.emit(masm, Xcc, Equal, ANNUL, PREDICT_NOT_TAKEN, l), -maxDisp,
 90                         maxDisp - 1);
 91     }
 92 
 93     @Test
 94     public void testPatchBpr() {
 95         int maxDisp = 1 &lt;&lt; 15;
 96         testControlTransferOp(l -&gt; BPR.emit(masm, Rc_z, ANNUL, PREDICT_NOT_TAKEN, g0, l), -maxDisp,
 97                         maxDisp - 1);
 98     }
 99 
100     @Test
101     public void testPatchBr() {
102         int maxDisp = 1 &lt;&lt; 21;
103         testControlTransferOp(l -&gt; BR.emit(masm, Equal, ANNUL, l), -maxDisp,
104                         maxDisp - 1);
105     }
106 
107     @Test(expected = BailoutException.class)
108     public void testControlTransferInvalidDisp() {
109         int cbcondInstruction = 0x12f83f60;
110         CBCOND.setDisp(cbcondInstruction, 0x2ff);
111     }
112 
113     public void testControlTransferOp(Consumer&lt;Label&gt; opCreator, int minDisp, int maxDisp) {
114         doTestControlTransferOp(opCreator, minDisp, maxDisp);
115         try {
116             doTestControlTransferOp(opCreator, minDisp - 1, maxDisp);
117             fail(&quot;minDisp out of bound must not assemble correctly&quot;);
118         } catch (BailoutException e) {
119             // ignored
120         }
121         try {
122             doTestControlTransferOp(opCreator, minDisp, maxDisp + 1);
123             fail(&quot;maxDisp out of bound must not assemble correctly&quot;);
124         } catch (BailoutException e) {
125             // ignored
126         }
127     }
128 
129     /**
130      * Assembles the control transfer op and then verifies the expected disp value against the disp
131      * field provided by the disassembler.
132      */
133     public void doTestControlTransferOp(Consumer&lt;Label&gt; opCreator, int minDisp, int maxDisp) {
134         Label lBack = new Label();
135         Label lForward = new Label();
136         masm.bind(lBack);
137         for (int i = 0; i &lt; -minDisp; i++) {
138             masm.nop();
139         }
140         int backPos = masm.position();
141         opCreator.accept(lBack);
142         masm.nop(); // Nop required to separate the two control transfer instructions
143         int forwardPos = masm.position();
144         opCreator.accept(lForward);
145         for (int i = 0; i &lt; maxDisp - 1; i++) {
146             masm.nop();
147         }
148         masm.bind(lForward);
149 
150         int condBack = masm.getInt(backPos);
151         SPARCOp backOp = SPARCAssembler.getSPARCOp(condBack);
152         int dispBack = ((ControlTransferOp) backOp).getDisp(condBack);
153         Assert.assertEquals(minDisp, dispBack);
154 
155         int condFwd = masm.getInt(forwardPos);
156         SPARCOp fwdOp = SPARCAssembler.getSPARCOp(condFwd);
157         int dispFwd = ((ControlTransferOp) fwdOp).getDisp(condFwd);
158         Assert.assertEquals(maxDisp, dispFwd);
159     }
160 }
    </pre>
  </body>
</html>
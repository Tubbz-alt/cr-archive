<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libjava/TimeZone_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="ProcessImpl_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="UnixFileSystem_md.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libjava/TimeZone_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;strings.h&gt;
 29 #include &lt;time.h&gt;
 30 #include &lt;limits.h&gt;
 31 #include &lt;errno.h&gt;
 32 #include &lt;stddef.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;sys/types.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;dirent.h&gt;
 37 #include &lt;unistd.h&gt;
<span class="line-removed"> 38 #if defined(__solaris__)</span>
<span class="line-removed"> 39 #include &lt;libscf.h&gt;</span>
<span class="line-removed"> 40 #endif</span>
 41 
 42 #include &quot;jvm.h&quot;
 43 #include &quot;TimeZone_md.h&quot;
 44 
 45 static char *isFileIdentical(char* buf, size_t size, char *pathname);
 46 
 47 #define SKIP_SPACE(p)   while (*p == &#39; &#39; || *p == &#39;\t&#39;) p++;
 48 
 49 #define RESTARTABLE(_cmd, _result) do { \
 50   do { \
 51     _result = _cmd; \
 52   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 53 } while(0)
 54 
<span class="line-removed"> 55 #if !defined(__solaris__) || defined(__sparcv9) || defined(amd64)</span>
 56 #define fileopen        fopen
 57 #define filegets        fgets
 58 #define fileclose       fclose
<span class="line-removed"> 59 #endif</span>
 60 
 61 #if defined(_ALLBSD_SOURCE)
 62 #define stat64 stat
 63 #define lstat64 lstat
 64 #define fstat64 fstat
 65 #endif
 66 
 67 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
 68 static const char *ETC_TIMEZONE_FILE = &quot;/etc/timezone&quot;;
 69 static const char *ZONEINFO_DIR = &quot;/usr/share/zoneinfo&quot;;
 70 static const char *DEFAULT_ZONEINFO_FILE = &quot;/etc/localtime&quot;;
 71 #else
 72 static const char *SYS_INIT_FILE = &quot;/etc/default/init&quot;;
 73 static const char *ZONEINFO_DIR = &quot;/usr/share/lib/zoneinfo&quot;;
 74 static const char *DEFAULT_ZONEINFO_FILE = &quot;/usr/share/lib/zoneinfo/localtime&quot;;
 75 #endif /* defined(__linux__) || defined(_ALLBSD_SOURCE) */
 76 
 77 static const char popularZones[][4] = {&quot;UTC&quot;, &quot;GMT&quot;};
 78 
 79 #if defined(_AIX)
 80 static const char *ETC_ENVIRONMENT_FILE = &quot;/etc/environment&quot;;
 81 #endif
 82 
<span class="line-modified"> 83 #if defined(__linux__) || defined(MACOSX) || defined(__solaris__)</span>
 84 
 85 /*
 86  * Returns a pointer to the zone ID portion of the given zoneinfo file
 87  * name, or NULL if the given string doesn&#39;t contain &quot;zoneinfo/&quot;.
 88  */
 89 static char *
 90 getZoneName(char *str)
 91 {
 92     static const char *zidir = &quot;zoneinfo/&quot;;
 93 
 94     char *pos = strstr((const char *)str, zidir);
 95     if (pos == NULL) {
 96         return NULL;
 97     }
 98     return pos + strlen(zidir);
 99 }
100 
101 /*
102  * Returns a path name created from the given &#39;dir&#39; and &#39;name&#39; under
103  * UNIX. This function allocates memory for the pathname calling
</pre>
<hr />
<pre>
147     }
148 
149     dirp = opendir(dir);
150     if (dirp == NULL) {
151         return NULL;
152     }
153 
154     while ((dp = readdir(dirp)) != NULL) {
155         /*
156          * Skip &#39;.&#39; and &#39;..&#39; (and possibly other .* files)
157          */
158         if (dp-&gt;d_name[0] == &#39;.&#39;) {
159             continue;
160         }
161 
162         /*
163          * Skip &quot;ROC&quot;, &quot;posixrules&quot;, and &quot;localtime&quot;.
164          */
165         if ((strcmp(dp-&gt;d_name, &quot;ROC&quot;) == 0)
166             || (strcmp(dp-&gt;d_name, &quot;posixrules&quot;) == 0)
<span class="line-removed">167 #if defined(__solaris__)</span>
<span class="line-removed">168             /*</span>
<span class="line-removed">169              * Skip the &quot;src&quot; and &quot;tab&quot; directories on Solaris.</span>
<span class="line-removed">170              */</span>
<span class="line-removed">171             || (strcmp(dp-&gt;d_name, &quot;src&quot;) == 0)</span>
<span class="line-removed">172             || (strcmp(dp-&gt;d_name, &quot;tab&quot;) == 0)</span>
<span class="line-removed">173 #endif</span>
174             || (strcmp(dp-&gt;d_name, &quot;localtime&quot;) == 0)) {
175             continue;
176         }
177 
178         pathname = getPathName(dir, dp-&gt;d_name);
179         if (pathname == NULL) {
180             break;
181         }
182 
183         tz = isFileIdentical(buf, size, pathname);
184         free((void *) pathname);
185         pathname = NULL;
186         if (tz != NULL) {
187            break;
188         }
189     }
190 
191     if (dirp != NULL) {
192         (void) closedir(dirp);
193     }
</pre>
<hr />
<pre>
225         if (fd == -1) {
226             goto freedata;
227         }
228         RESTARTABLE(read(fd, dbuf, size), res);
229         if (res != (ssize_t) size) {
230             goto freedata;
231         }
232         if (memcmp(buf, dbuf, size) == 0) {
233             possibleMatch = getZoneName(pathname);
234             if (possibleMatch != NULL) {
235                 possibleMatch = strdup(possibleMatch);
236             }
237         }
238         freedata:
239         free((void *) dbuf);
240         (void) close(fd);
241     }
242     return possibleMatch;
243 }
244 
<span class="line-removed">245 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-removed">246 </span>
247 /*
248  * Performs Linux specific mapping and returns a zone ID
249  * if found. Otherwise, NULL is returned.
250  */
251 static char *
252 getPlatformTimeZoneID()
253 {
254     struct stat64 statbuf;
255     char *tz = NULL;
256     FILE *fp;
257     int fd;
258     char *buf;
259     size_t size;
260     int res;
261 
262 #if defined(__linux__)
263     /*
264      * Try reading the /etc/timezone file for Debian distros. There&#39;s
265      * no spec of the file format available. This parsing assumes that
266      * there&#39;s one line of an Olson tzid followed by a &#39;\n&#39;, no
</pre>
<hr />
<pre>
336     size = (size_t) statbuf.st_size;
337     buf = (char *) malloc(size);
338     if (buf == NULL) {
339         (void) close(fd);
340         return NULL;
341     }
342 
343     RESTARTABLE(read(fd, buf, size), res);
344     if (res != (ssize_t) size) {
345         (void) close(fd);
346         free((void *) buf);
347         return NULL;
348     }
349     (void) close(fd);
350 
351     tz = findZoneinfoFile(buf, size, ZONEINFO_DIR);
352     free((void *) buf);
353     return tz;
354 }
355 
<span class="line-removed">356 #elif defined(__solaris__)</span>
<span class="line-removed">357 </span>
<span class="line-removed">358 #if !defined(__sparcv9) &amp;&amp; !defined(amd64)</span>
<span class="line-removed">359 </span>
<span class="line-removed">360 /*</span>
<span class="line-removed">361  * Those file* functions mimic the UNIX stream io functions. This is</span>
<span class="line-removed">362  * because of the limitation of the number of open files on Solaris</span>
<span class="line-removed">363  * (32-bit mode only) due to the System V ABI.</span>
<span class="line-removed">364  */</span>
<span class="line-removed">365 </span>
<span class="line-removed">366 #define BUFFER_SIZE     4096</span>
<span class="line-removed">367 </span>
<span class="line-removed">368 static struct iobuffer {</span>
<span class="line-removed">369     int     magic;      /* -1 to distinguish from the real FILE */</span>
<span class="line-removed">370     int     fd;         /* file descriptor */</span>
<span class="line-removed">371     char    *buffer;    /* pointer to buffer */</span>
<span class="line-removed">372     char    *ptr;       /* current read pointer */</span>
<span class="line-removed">373     char    *endptr;    /* end pointer */</span>
<span class="line-removed">374 };</span>
<span class="line-removed">375 </span>
<span class="line-removed">376 static int</span>
<span class="line-removed">377 fileclose(FILE *stream)</span>
<span class="line-removed">378 {</span>
<span class="line-removed">379     struct iobuffer *iop = (struct iobuffer *) stream;</span>
<span class="line-removed">380 </span>
<span class="line-removed">381     if (iop-&gt;magic != -1) {</span>
<span class="line-removed">382         return fclose(stream);</span>
<span class="line-removed">383     }</span>
<span class="line-removed">384 </span>
<span class="line-removed">385     if (iop == NULL) {</span>
<span class="line-removed">386         return 0;</span>
<span class="line-removed">387     }</span>
<span class="line-removed">388     close(iop-&gt;fd);</span>
<span class="line-removed">389     free((void *)iop-&gt;buffer);</span>
<span class="line-removed">390     free((void *)iop);</span>
<span class="line-removed">391     return 0;</span>
<span class="line-removed">392 }</span>
<span class="line-removed">393 </span>
<span class="line-removed">394 static FILE *</span>
<span class="line-removed">395 fileopen(const char *fname, const char *fmode)</span>
<span class="line-removed">396 {</span>
<span class="line-removed">397     FILE *fp;</span>
<span class="line-removed">398     int fd;</span>
<span class="line-removed">399     struct iobuffer *iop;</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     if ((fp = fopen(fname, fmode)) != NULL) {</span>
<span class="line-removed">402         return fp;</span>
<span class="line-removed">403     }</span>
<span class="line-removed">404 </span>
<span class="line-removed">405     /*</span>
<span class="line-removed">406      * It assumes read open.</span>
<span class="line-removed">407      */</span>
<span class="line-removed">408     RESTARTABLE(open(fname, O_RDONLY), fd);</span>
<span class="line-removed">409     if (fd == -1) {</span>
<span class="line-removed">410         return NULL;</span>
<span class="line-removed">411     }</span>
<span class="line-removed">412 </span>
<span class="line-removed">413     /*</span>
<span class="line-removed">414      * Allocate struct iobuffer and its buffer</span>
<span class="line-removed">415      */</span>
<span class="line-removed">416     iop = malloc(sizeof(struct iobuffer));</span>
<span class="line-removed">417     if (iop == NULL) {</span>
<span class="line-removed">418         (void) close(fd);</span>
<span class="line-removed">419         errno = ENOMEM;</span>
<span class="line-removed">420         return NULL;</span>
<span class="line-removed">421     }</span>
<span class="line-removed">422     iop-&gt;magic = -1;</span>
<span class="line-removed">423     iop-&gt;fd = fd;</span>
<span class="line-removed">424     iop-&gt;buffer = malloc(BUFFER_SIZE);</span>
<span class="line-removed">425     if (iop-&gt;buffer == NULL) {</span>
<span class="line-removed">426         (void) close(fd);</span>
<span class="line-removed">427         free((void *) iop);</span>
<span class="line-removed">428         errno = ENOMEM;</span>
<span class="line-removed">429         return NULL;</span>
<span class="line-removed">430     }</span>
<span class="line-removed">431     iop-&gt;ptr = iop-&gt;buffer;</span>
<span class="line-removed">432     iop-&gt;endptr = iop-&gt;buffer;</span>
<span class="line-removed">433     return (FILE *)iop;</span>
<span class="line-removed">434 }</span>
<span class="line-removed">435 </span>
<span class="line-removed">436 /*</span>
<span class="line-removed">437  * This implementation assumes that n is large enough and the line</span>
<span class="line-removed">438  * separator is &#39;\n&#39;.</span>
<span class="line-removed">439  */</span>
<span class="line-removed">440 static char *</span>
<span class="line-removed">441 filegets(char *s, int n, FILE *stream)</span>
<span class="line-removed">442 {</span>
<span class="line-removed">443     struct iobuffer *iop = (struct iobuffer *) stream;</span>
<span class="line-removed">444     char *p;</span>
<span class="line-removed">445 </span>
<span class="line-removed">446     if (iop-&gt;magic != -1) {</span>
<span class="line-removed">447         return fgets(s, n, stream);</span>
<span class="line-removed">448     }</span>
<span class="line-removed">449 </span>
<span class="line-removed">450     p = s;</span>
<span class="line-removed">451     for (;;) {</span>
<span class="line-removed">452         char c;</span>
<span class="line-removed">453 </span>
<span class="line-removed">454         if (iop-&gt;ptr == iop-&gt;endptr) {</span>
<span class="line-removed">455             ssize_t len;</span>
<span class="line-removed">456 </span>
<span class="line-removed">457             RESTARTABLE(read(iop-&gt;fd, (void *)iop-&gt;buffer, BUFFER_SIZE), len);</span>
<span class="line-removed">458             if (len == -1) {</span>
<span class="line-removed">459                 return NULL;</span>
<span class="line-removed">460             }</span>
<span class="line-removed">461             if (len == 0) {</span>
<span class="line-removed">462                 *p = 0;</span>
<span class="line-removed">463                 if (s == p) {</span>
<span class="line-removed">464                     return NULL;</span>
<span class="line-removed">465                 }</span>
<span class="line-removed">466                 return s;</span>
<span class="line-removed">467             }</span>
<span class="line-removed">468             iop-&gt;ptr = iop-&gt;buffer;</span>
<span class="line-removed">469             iop-&gt;endptr = iop-&gt;buffer + len;</span>
<span class="line-removed">470         }</span>
<span class="line-removed">471         c = *iop-&gt;ptr++;</span>
<span class="line-removed">472         *p++ = c;</span>
<span class="line-removed">473         if ((p - s) == (n - 1)) {</span>
<span class="line-removed">474             *p = 0;</span>
<span class="line-removed">475             return s;</span>
<span class="line-removed">476         }</span>
<span class="line-removed">477         if (c == &#39;\n&#39;) {</span>
<span class="line-removed">478             *p = 0;</span>
<span class="line-removed">479             return s;</span>
<span class="line-removed">480         }</span>
<span class="line-removed">481     }</span>
<span class="line-removed">482     /*NOTREACHED*/</span>
<span class="line-removed">483 }</span>
<span class="line-removed">484 #endif /* !defined(__sparcv9) &amp;&amp; !defined(amd64) */</span>
<span class="line-removed">485 </span>
<span class="line-removed">486 /*</span>
<span class="line-removed">487  * Performs Solaris dependent mapping. Returns a zone ID if</span>
<span class="line-removed">488  * found. Otherwise, NULL is returned.  Solaris libc looks up</span>
<span class="line-removed">489  * &quot;/etc/default/init&quot; to get the default TZ value if TZ is not defined</span>
<span class="line-removed">490  * as an environment variable.</span>
<span class="line-removed">491  */</span>
<span class="line-removed">492 static char *</span>
<span class="line-removed">493 getPlatformTimeZoneID()</span>
<span class="line-removed">494 {</span>
<span class="line-removed">495     char *tz = NULL;</span>
<span class="line-removed">496     FILE *fp;</span>
<span class="line-removed">497 </span>
<span class="line-removed">498     /*</span>
<span class="line-removed">499      * Try the TZ entry in /etc/default/init.</span>
<span class="line-removed">500      */</span>
<span class="line-removed">501     if ((fp = fileopen(SYS_INIT_FILE, &quot;r&quot;)) != NULL) {</span>
<span class="line-removed">502         char line[256];</span>
<span class="line-removed">503         char quote = &#39;\0&#39;;</span>
<span class="line-removed">504 </span>
<span class="line-removed">505         while (filegets(line, sizeof(line), fp) != NULL) {</span>
<span class="line-removed">506             char *p = line;</span>
<span class="line-removed">507             char *s;</span>
<span class="line-removed">508             char c;</span>
<span class="line-removed">509 </span>
<span class="line-removed">510             /* quick check for comment lines */</span>
<span class="line-removed">511             if (*p == &#39;#&#39;) {</span>
<span class="line-removed">512                 continue;</span>
<span class="line-removed">513             }</span>
<span class="line-removed">514             if (strncmp(p, &quot;TZ=&quot;, 3) == 0) {</span>
<span class="line-removed">515                 p += 3;</span>
<span class="line-removed">516                 SKIP_SPACE(p);</span>
<span class="line-removed">517                 c = *p;</span>
<span class="line-removed">518                 if (c == &#39;&quot;&#39; || c == &#39;\&#39;&#39;) {</span>
<span class="line-removed">519                     quote = c;</span>
<span class="line-removed">520                     p++;</span>
<span class="line-removed">521                 }</span>
<span class="line-removed">522 </span>
<span class="line-removed">523                 /*</span>
<span class="line-removed">524                  * PSARC/2001/383: quoted string support</span>
<span class="line-removed">525                  */</span>
<span class="line-removed">526                 for (s = p; (c = *s) != &#39;\0&#39; &amp;&amp; c != &#39;\n&#39;; s++) {</span>
<span class="line-removed">527                     /* No &#39;\\&#39; is supported here. */</span>
<span class="line-removed">528                     if (c == quote) {</span>
<span class="line-removed">529                         quote = &#39;\0&#39;;</span>
<span class="line-removed">530                         break;</span>
<span class="line-removed">531                     }</span>
<span class="line-removed">532                     if (c == &#39; &#39; &amp;&amp; quote == &#39;\0&#39;) {</span>
<span class="line-removed">533                         break;</span>
<span class="line-removed">534                     }</span>
<span class="line-removed">535                 }</span>
<span class="line-removed">536                 if (quote != &#39;\0&#39;) {</span>
<span class="line-removed">537                     jio_fprintf(stderr, &quot;ZoneInfo: unterminated time zone name in /etc/TIMEZONE\n&quot;);</span>
<span class="line-removed">538                 }</span>
<span class="line-removed">539                 *s = &#39;\0&#39;;</span>
<span class="line-removed">540                 tz = strdup(p);</span>
<span class="line-removed">541                 break;</span>
<span class="line-removed">542             }</span>
<span class="line-removed">543         }</span>
<span class="line-removed">544         (void) fileclose(fp);</span>
<span class="line-removed">545     }</span>
<span class="line-removed">546     return tz;</span>
<span class="line-removed">547 }</span>
<span class="line-removed">548 </span>
<span class="line-removed">549 #define TIMEZONE_FMRI   &quot;svc:/system/timezone:default&quot;</span>
<span class="line-removed">550 #define TIMEZONE_PG     &quot;timezone&quot;</span>
<span class="line-removed">551 #define LOCALTIME_PROP  &quot;localtime&quot;</span>
<span class="line-removed">552 </span>
<span class="line-removed">553 static void</span>
<span class="line-removed">554 cleanupScf(scf_handle_t *h,</span>
<span class="line-removed">555            scf_snapshot_t *snap,</span>
<span class="line-removed">556            scf_instance_t *inst,</span>
<span class="line-removed">557            scf_propertygroup_t *pg,</span>
<span class="line-removed">558            scf_property_t *prop,</span>
<span class="line-removed">559            scf_value_t *val,</span>
<span class="line-removed">560            char *buf) {</span>
<span class="line-removed">561     if (buf != NULL) {</span>
<span class="line-removed">562         free(buf);</span>
<span class="line-removed">563     }</span>
<span class="line-removed">564     if (snap != NULL) {</span>
<span class="line-removed">565         scf_snapshot_destroy(snap);</span>
<span class="line-removed">566     }</span>
<span class="line-removed">567     if (val != NULL) {</span>
<span class="line-removed">568         scf_value_destroy(val);</span>
<span class="line-removed">569     }</span>
<span class="line-removed">570     if (prop != NULL) {</span>
<span class="line-removed">571         scf_property_destroy(prop);</span>
<span class="line-removed">572     }</span>
<span class="line-removed">573     if (pg != NULL) {</span>
<span class="line-removed">574         scf_pg_destroy(pg);</span>
<span class="line-removed">575     }</span>
<span class="line-removed">576     if (inst != NULL) {</span>
<span class="line-removed">577         scf_instance_destroy(inst);</span>
<span class="line-removed">578     }</span>
<span class="line-removed">579     if (h != NULL) {</span>
<span class="line-removed">580         scf_handle_destroy(h);</span>
<span class="line-removed">581     }</span>
<span class="line-removed">582 }</span>
<span class="line-removed">583 </span>
<span class="line-removed">584 /*</span>
<span class="line-removed">585  * Returns a zone ID of Solaris when the TZ value is &quot;localtime&quot;.</span>
<span class="line-removed">586  * First, it tries scf. If scf fails, it looks for the same file as</span>
<span class="line-removed">587  * /usr/share/lib/zoneinfo/localtime under /usr/share/lib/zoneinfo/.</span>
<span class="line-removed">588  */</span>
<span class="line-removed">589 static char *</span>
<span class="line-removed">590 getSolarisDefaultZoneID() {</span>
<span class="line-removed">591     char *tz = NULL;</span>
<span class="line-removed">592     struct stat64 statbuf;</span>
<span class="line-removed">593     size_t size;</span>
<span class="line-removed">594     char *buf;</span>
<span class="line-removed">595     int fd;</span>
<span class="line-removed">596     int res;</span>
<span class="line-removed">597     /* scf specific variables */</span>
<span class="line-removed">598     scf_handle_t *h = NULL;</span>
<span class="line-removed">599     scf_snapshot_t *snap = NULL;</span>
<span class="line-removed">600     scf_instance_t *inst = NULL;</span>
<span class="line-removed">601     scf_propertygroup_t *pg = NULL;</span>
<span class="line-removed">602     scf_property_t *prop = NULL;</span>
<span class="line-removed">603     scf_value_t *val = NULL;</span>
<span class="line-removed">604 </span>
<span class="line-removed">605     if ((h = scf_handle_create(SCF_VERSION)) != NULL</span>
<span class="line-removed">606         &amp;&amp; scf_handle_bind(h) == 0</span>
<span class="line-removed">607         &amp;&amp; (inst = scf_instance_create(h)) != NULL</span>
<span class="line-removed">608         &amp;&amp; (snap = scf_snapshot_create(h)) != NULL</span>
<span class="line-removed">609         &amp;&amp; (pg = scf_pg_create(h)) != NULL</span>
<span class="line-removed">610         &amp;&amp; (prop = scf_property_create(h)) != NULL</span>
<span class="line-removed">611         &amp;&amp; (val = scf_value_create(h)) != NULL</span>
<span class="line-removed">612         &amp;&amp; scf_handle_decode_fmri(h, TIMEZONE_FMRI, NULL, NULL, inst,</span>
<span class="line-removed">613                                   NULL, NULL, SCF_DECODE_FMRI_REQUIRE_INSTANCE) == 0</span>
<span class="line-removed">614         &amp;&amp; scf_instance_get_snapshot(inst, &quot;running&quot;, snap) == 0</span>
<span class="line-removed">615         &amp;&amp; scf_instance_get_pg_composed(inst, snap, TIMEZONE_PG, pg) == 0</span>
<span class="line-removed">616         &amp;&amp; scf_pg_get_property(pg, LOCALTIME_PROP, prop) == 0</span>
<span class="line-removed">617         &amp;&amp; scf_property_get_value(prop, val) == 0) {</span>
<span class="line-removed">618         ssize_t len;</span>
<span class="line-removed">619 </span>
<span class="line-removed">620         /* Gets the length of the zone ID string */</span>
<span class="line-removed">621         len = scf_value_get_astring(val, NULL, 0);</span>
<span class="line-removed">622         if (len != -1) {</span>
<span class="line-removed">623             tz = malloc(++len); /* +1 for a null byte */</span>
<span class="line-removed">624             if (tz != NULL &amp;&amp; scf_value_get_astring(val, tz, len) != -1) {</span>
<span class="line-removed">625                 cleanupScf(h, snap, inst, pg, prop, val, NULL);</span>
<span class="line-removed">626                 return tz;</span>
<span class="line-removed">627             }</span>
<span class="line-removed">628         }</span>
<span class="line-removed">629     }</span>
<span class="line-removed">630     cleanupScf(h, snap, inst, pg, prop, val, tz);</span>
<span class="line-removed">631 </span>
<span class="line-removed">632     RESTARTABLE(stat64(DEFAULT_ZONEINFO_FILE, &amp;statbuf), res);</span>
<span class="line-removed">633     if (res == -1) {</span>
<span class="line-removed">634         return NULL;</span>
<span class="line-removed">635     }</span>
<span class="line-removed">636     size = (size_t) statbuf.st_size;</span>
<span class="line-removed">637     buf = malloc(size);</span>
<span class="line-removed">638     if (buf == NULL) {</span>
<span class="line-removed">639         return NULL;</span>
<span class="line-removed">640     }</span>
<span class="line-removed">641     RESTARTABLE(open(DEFAULT_ZONEINFO_FILE, O_RDONLY), fd);</span>
<span class="line-removed">642     if (fd == -1) {</span>
<span class="line-removed">643         free((void *) buf);</span>
<span class="line-removed">644         return NULL;</span>
<span class="line-removed">645     }</span>
<span class="line-removed">646 </span>
<span class="line-removed">647     RESTARTABLE(read(fd, buf, size), res);</span>
<span class="line-removed">648     if (res != (ssize_t) size) {</span>
<span class="line-removed">649         (void) close(fd);</span>
<span class="line-removed">650         free((void *) buf);</span>
<span class="line-removed">651         return NULL;</span>
<span class="line-removed">652     }</span>
<span class="line-removed">653     (void) close(fd);</span>
<span class="line-removed">654     tz = findZoneinfoFile(buf, size, ZONEINFO_DIR);</span>
<span class="line-removed">655     free((void *) buf);</span>
<span class="line-removed">656     return tz;</span>
<span class="line-removed">657 }</span>
<span class="line-removed">658 </span>
<span class="line-removed">659 #endif /* defined(__solaris__) */</span>
<span class="line-removed">660 </span>
661 #elif defined(_AIX)
662 
663 static char *
664 getPlatformTimeZoneID()
665 {
666     FILE *fp;
667     char *tz = NULL;
668     char *tz_key = &quot;TZ=&quot;;
669     char line[256];
670     size_t tz_key_len = strlen(tz_key);
671 
672     if ((fp = fopen(ETC_ENVIRONMENT_FILE, &quot;r&quot;)) != NULL) {
673         while (fgets(line, sizeof(line), fp) != NULL) {
674             char *p = strchr(line, &#39;\n&#39;);
675             if (p != NULL) {
676                 *p = &#39;\0&#39;;
677             }
678             if (0 == strncmp(line, tz_key, tz_key_len)) {
679                 tz = strdup(line + tz_key_len);
680                 break;
</pre>
<hr />
<pre>
807 
808     if (tz != NULL) {
809         /* Ignore preceding &#39;:&#39; */
810         if (*tz == &#39;:&#39;) {
811             tz++;
812         }
813 #if defined(__linux__)
814         /* Ignore &quot;posix/&quot; prefix on Linux. */
815         if (strncmp(tz, &quot;posix/&quot;, 6) == 0) {
816             tz += 6;
817         }
818 #endif
819 
820 #if defined(_AIX)
821         /* On AIX do the platform to Java mapping. */
822         javatz = mapPlatformToJavaTimezone(java_home_dir, tz);
823         if (freetz != NULL) {
824             free((void *) freetz);
825         }
826 #else
<span class="line-removed">827 #if defined(__solaris__)</span>
<span class="line-removed">828         /* Solaris might use localtime, so handle it here. */</span>
<span class="line-removed">829         if (strcmp(tz, &quot;localtime&quot;) == 0) {</span>
<span class="line-removed">830             javatz = getSolarisDefaultZoneID();</span>
<span class="line-removed">831             if (freetz != NULL) {</span>
<span class="line-removed">832                 free((void *) freetz);</span>
<span class="line-removed">833             }</span>
<span class="line-removed">834         } else</span>
<span class="line-removed">835 #endif</span>
836         if (freetz == NULL) {
837             /* strdup if we are still working on getenv result. */
838             javatz = strdup(tz);
839         } else if (freetz != tz) {
840             /* strdup and free the old buffer, if we moved the pointer. */
841             javatz = strdup(tz);
842             free((void *) freetz);
843         } else {
844             /* we are good if we already work on a freshly allocated buffer. */
845             javatz = tz;
846         }
847 #endif
848     }
849 
850     return javatz;
851 }
852 
853 /**
854  * Returns a GMT-offset-based zone ID. (e.g., &quot;GMT-08:00&quot;)
855  */
</pre>
<hr />
<pre>
873         return strdup(&quot;GMT&quot;);
874     }
875     if (offset &gt; 0) {
876         sign = &#39;+&#39;;
877     } else {
878         offset = -offset;
879         sign = &#39;-&#39;;
880     }
881     sprintf(buf, (const char *)&quot;GMT%c%02d:%02d&quot;,
882             sign, (int)(offset/3600), (int)((offset%3600)/60));
883     return strdup(buf);
884 }
885 
886 #else
887 
888 char *
889 getGMTOffsetID()
890 {
891     time_t offset;
892     char sign, buf[32];
<span class="line-removed">893 #if defined(__solaris__)</span>
<span class="line-removed">894     struct tm localtm;</span>
<span class="line-removed">895     time_t currenttime;</span>
<span class="line-removed">896 </span>
<span class="line-removed">897     currenttime = time(NULL);</span>
<span class="line-removed">898     if (localtime_r(&amp;currenttime, &amp;localtm) == NULL) {</span>
<span class="line-removed">899         return strdup(&quot;GMT&quot;);</span>
<span class="line-removed">900     }</span>
<span class="line-removed">901 </span>
<span class="line-removed">902     offset = localtm.tm_isdst ? altzone : timezone;</span>
<span class="line-removed">903 #else</span>
904     offset = timezone;
<span class="line-removed">905 #endif</span>
906 
907     if (offset == 0) {
908         return strdup(&quot;GMT&quot;);
909     }
910 
911     /* Note that the time offset direction is opposite. */
912     if (offset &gt; 0) {
913         sign = &#39;-&#39;;
914     } else {
915         offset = -offset;
916         sign = &#39;+&#39;;
917     }
918     sprintf(buf, (const char *)&quot;GMT%c%02d:%02d&quot;,
919             sign, (int)(offset/3600), (int)((offset%3600)/60));
920     return strdup(buf);
921 }
922 #endif /* MACOSX */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;stdlib.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;strings.h&gt;
 29 #include &lt;time.h&gt;
 30 #include &lt;limits.h&gt;
 31 #include &lt;errno.h&gt;
 32 #include &lt;stddef.h&gt;
 33 #include &lt;sys/stat.h&gt;
 34 #include &lt;sys/types.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;dirent.h&gt;
 37 #include &lt;unistd.h&gt;



 38 
 39 #include &quot;jvm.h&quot;
 40 #include &quot;TimeZone_md.h&quot;
 41 
 42 static char *isFileIdentical(char* buf, size_t size, char *pathname);
 43 
 44 #define SKIP_SPACE(p)   while (*p == &#39; &#39; || *p == &#39;\t&#39;) p++;
 45 
 46 #define RESTARTABLE(_cmd, _result) do { \
 47   do { \
 48     _result = _cmd; \
 49   } while((_result == -1) &amp;&amp; (errno == EINTR)); \
 50 } while(0)
 51 

 52 #define fileopen        fopen
 53 #define filegets        fgets
 54 #define fileclose       fclose

 55 
 56 #if defined(_ALLBSD_SOURCE)
 57 #define stat64 stat
 58 #define lstat64 lstat
 59 #define fstat64 fstat
 60 #endif
 61 
 62 #if defined(__linux__) || defined(_ALLBSD_SOURCE)
 63 static const char *ETC_TIMEZONE_FILE = &quot;/etc/timezone&quot;;
 64 static const char *ZONEINFO_DIR = &quot;/usr/share/zoneinfo&quot;;
 65 static const char *DEFAULT_ZONEINFO_FILE = &quot;/etc/localtime&quot;;
 66 #else
 67 static const char *SYS_INIT_FILE = &quot;/etc/default/init&quot;;
 68 static const char *ZONEINFO_DIR = &quot;/usr/share/lib/zoneinfo&quot;;
 69 static const char *DEFAULT_ZONEINFO_FILE = &quot;/usr/share/lib/zoneinfo/localtime&quot;;
 70 #endif /* defined(__linux__) || defined(_ALLBSD_SOURCE) */
 71 
 72 static const char popularZones[][4] = {&quot;UTC&quot;, &quot;GMT&quot;};
 73 
 74 #if defined(_AIX)
 75 static const char *ETC_ENVIRONMENT_FILE = &quot;/etc/environment&quot;;
 76 #endif
 77 
<span class="line-modified"> 78 #if defined(__linux__) || defined(MACOSX)</span>
 79 
 80 /*
 81  * Returns a pointer to the zone ID portion of the given zoneinfo file
 82  * name, or NULL if the given string doesn&#39;t contain &quot;zoneinfo/&quot;.
 83  */
 84 static char *
 85 getZoneName(char *str)
 86 {
 87     static const char *zidir = &quot;zoneinfo/&quot;;
 88 
 89     char *pos = strstr((const char *)str, zidir);
 90     if (pos == NULL) {
 91         return NULL;
 92     }
 93     return pos + strlen(zidir);
 94 }
 95 
 96 /*
 97  * Returns a path name created from the given &#39;dir&#39; and &#39;name&#39; under
 98  * UNIX. This function allocates memory for the pathname calling
</pre>
<hr />
<pre>
142     }
143 
144     dirp = opendir(dir);
145     if (dirp == NULL) {
146         return NULL;
147     }
148 
149     while ((dp = readdir(dirp)) != NULL) {
150         /*
151          * Skip &#39;.&#39; and &#39;..&#39; (and possibly other .* files)
152          */
153         if (dp-&gt;d_name[0] == &#39;.&#39;) {
154             continue;
155         }
156 
157         /*
158          * Skip &quot;ROC&quot;, &quot;posixrules&quot;, and &quot;localtime&quot;.
159          */
160         if ((strcmp(dp-&gt;d_name, &quot;ROC&quot;) == 0)
161             || (strcmp(dp-&gt;d_name, &quot;posixrules&quot;) == 0)







162             || (strcmp(dp-&gt;d_name, &quot;localtime&quot;) == 0)) {
163             continue;
164         }
165 
166         pathname = getPathName(dir, dp-&gt;d_name);
167         if (pathname == NULL) {
168             break;
169         }
170 
171         tz = isFileIdentical(buf, size, pathname);
172         free((void *) pathname);
173         pathname = NULL;
174         if (tz != NULL) {
175            break;
176         }
177     }
178 
179     if (dirp != NULL) {
180         (void) closedir(dirp);
181     }
</pre>
<hr />
<pre>
213         if (fd == -1) {
214             goto freedata;
215         }
216         RESTARTABLE(read(fd, dbuf, size), res);
217         if (res != (ssize_t) size) {
218             goto freedata;
219         }
220         if (memcmp(buf, dbuf, size) == 0) {
221             possibleMatch = getZoneName(pathname);
222             if (possibleMatch != NULL) {
223                 possibleMatch = strdup(possibleMatch);
224             }
225         }
226         freedata:
227         free((void *) dbuf);
228         (void) close(fd);
229     }
230     return possibleMatch;
231 }
232 


233 /*
234  * Performs Linux specific mapping and returns a zone ID
235  * if found. Otherwise, NULL is returned.
236  */
237 static char *
238 getPlatformTimeZoneID()
239 {
240     struct stat64 statbuf;
241     char *tz = NULL;
242     FILE *fp;
243     int fd;
244     char *buf;
245     size_t size;
246     int res;
247 
248 #if defined(__linux__)
249     /*
250      * Try reading the /etc/timezone file for Debian distros. There&#39;s
251      * no spec of the file format available. This parsing assumes that
252      * there&#39;s one line of an Olson tzid followed by a &#39;\n&#39;, no
</pre>
<hr />
<pre>
322     size = (size_t) statbuf.st_size;
323     buf = (char *) malloc(size);
324     if (buf == NULL) {
325         (void) close(fd);
326         return NULL;
327     }
328 
329     RESTARTABLE(read(fd, buf, size), res);
330     if (res != (ssize_t) size) {
331         (void) close(fd);
332         free((void *) buf);
333         return NULL;
334     }
335     (void) close(fd);
336 
337     tz = findZoneinfoFile(buf, size, ZONEINFO_DIR);
338     free((void *) buf);
339     return tz;
340 }
341 

















































































































































































































































































































342 #elif defined(_AIX)
343 
344 static char *
345 getPlatformTimeZoneID()
346 {
347     FILE *fp;
348     char *tz = NULL;
349     char *tz_key = &quot;TZ=&quot;;
350     char line[256];
351     size_t tz_key_len = strlen(tz_key);
352 
353     if ((fp = fopen(ETC_ENVIRONMENT_FILE, &quot;r&quot;)) != NULL) {
354         while (fgets(line, sizeof(line), fp) != NULL) {
355             char *p = strchr(line, &#39;\n&#39;);
356             if (p != NULL) {
357                 *p = &#39;\0&#39;;
358             }
359             if (0 == strncmp(line, tz_key, tz_key_len)) {
360                 tz = strdup(line + tz_key_len);
361                 break;
</pre>
<hr />
<pre>
488 
489     if (tz != NULL) {
490         /* Ignore preceding &#39;:&#39; */
491         if (*tz == &#39;:&#39;) {
492             tz++;
493         }
494 #if defined(__linux__)
495         /* Ignore &quot;posix/&quot; prefix on Linux. */
496         if (strncmp(tz, &quot;posix/&quot;, 6) == 0) {
497             tz += 6;
498         }
499 #endif
500 
501 #if defined(_AIX)
502         /* On AIX do the platform to Java mapping. */
503         javatz = mapPlatformToJavaTimezone(java_home_dir, tz);
504         if (freetz != NULL) {
505             free((void *) freetz);
506         }
507 #else









508         if (freetz == NULL) {
509             /* strdup if we are still working on getenv result. */
510             javatz = strdup(tz);
511         } else if (freetz != tz) {
512             /* strdup and free the old buffer, if we moved the pointer. */
513             javatz = strdup(tz);
514             free((void *) freetz);
515         } else {
516             /* we are good if we already work on a freshly allocated buffer. */
517             javatz = tz;
518         }
519 #endif
520     }
521 
522     return javatz;
523 }
524 
525 /**
526  * Returns a GMT-offset-based zone ID. (e.g., &quot;GMT-08:00&quot;)
527  */
</pre>
<hr />
<pre>
545         return strdup(&quot;GMT&quot;);
546     }
547     if (offset &gt; 0) {
548         sign = &#39;+&#39;;
549     } else {
550         offset = -offset;
551         sign = &#39;-&#39;;
552     }
553     sprintf(buf, (const char *)&quot;GMT%c%02d:%02d&quot;,
554             sign, (int)(offset/3600), (int)((offset%3600)/60));
555     return strdup(buf);
556 }
557 
558 #else
559 
560 char *
561 getGMTOffsetID()
562 {
563     time_t offset;
564     char sign, buf[32];











565     offset = timezone;

566 
567     if (offset == 0) {
568         return strdup(&quot;GMT&quot;);
569     }
570 
571     /* Note that the time offset direction is opposite. */
572     if (offset &gt; 0) {
573         sign = &#39;-&#39;;
574     } else {
575         offset = -offset;
576         sign = &#39;+&#39;;
577     }
578     sprintf(buf, (const char *)&quot;GMT%c%02d:%02d&quot;,
579             sign, (int)(offset/3600), (int)((offset%3600)/60));
580     return strdup(buf);
581 }
582 #endif /* MACOSX */
</pre>
</td>
</tr>
</table>
<center><a href="ProcessImpl_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="UnixFileSystem_md.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
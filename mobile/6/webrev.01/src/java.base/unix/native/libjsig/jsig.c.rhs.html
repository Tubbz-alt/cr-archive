<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/unix/native/libjsig/jsig.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.  Oracle designates this
  9  * particular file as subject to the &quot;Classpath&quot; exception as provided
 10  * by Oracle in the LICENSE file that accompanied this code.
 11  *
 12  * This code is distributed in the hope that it will be useful, but WITHOUT
 13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
 24  * questions.
 25  *
 26  */
 27 
 28 /* This is a special library that should be loaded before libc &amp;
 29  * libthread to interpose the signal handler installation functions:
 30  * sigaction(), signal(), sigset().
 31  * Used for signal-chaining. See RFE 4381843.
 32  */
 33 
 34 #include &quot;jni.h&quot;
 35 
<a name="2" id="anc2"></a>









 36 #include &lt;dlfcn.h&gt;
 37 #include &lt;errno.h&gt;
 38 #include &lt;pthread.h&gt;
 39 #include &lt;signal.h&gt;
 40 #include &lt;stdio.h&gt;
 41 #include &lt;stdlib.h&gt;
 42 #include &lt;string.h&gt;
 43 
 44 #if (__STDC_VERSION__ &gt;= 199901L)
 45   #include &lt;stdbool.h&gt;
 46 #else
 47   #define bool int
 48   #define true 1
 49   #define false 0
 50 #endif
 51 
<a name="3" id="anc3"></a>





 52 #define MAX_SIGNALS NSIG
 53 
 54 static struct sigaction sact[MAX_SIGNALS]; /* saved signal handlers */
<a name="4" id="anc4"></a>
 55 
 56 static sigset_t jvmsigs; /* Signals used by jvm. */
 57 
 58 #ifdef MACOSX
 59 static __thread bool reentry = false; /* prevent reentry deadlock (per-thread) */
 60 #endif
 61 
 62 /* Used to synchronize the installation of signal handlers. */
 63 static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
 64 static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
 65 static pthread_t tid;
 66 
 67 typedef void (*sa_handler_t)(int);
 68 typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);
 69 typedef sa_handler_t (*signal_function_t)(int, sa_handler_t);
 70 typedef int (*sigaction_t)(int, const struct sigaction *, struct sigaction *);
 71 
 72 static signal_function_t os_signal = 0; /* os&#39;s version of signal()/sigset() */
 73 static sigaction_t os_sigaction = 0; /* os&#39;s version of sigaction() */
 74 
 75 static bool jvm_signal_installing = false;
 76 static bool jvm_signal_installed = false;
 77 
 78 
<a name="5" id="anc5"></a>













 79 static void signal_lock() {
 80   pthread_mutex_lock(&amp;mutex);
 81   /* When the jvm is installing its set of signal handlers, threads
 82    * other than the jvm thread should wait. */
 83   if (jvm_signal_installing) {
 84     /* tid is not initialized until jvm_signal_installing is set to true. */
 85     if (pthread_equal(tid, pthread_self()) == 0) {
 86       do {
 87         pthread_cond_wait(&amp;cond, &amp;mutex);
 88       } while (jvm_signal_installing);
 89     }
 90   }
 91 }
 92 
 93 static void signal_unlock() {
 94   pthread_mutex_unlock(&amp;mutex);
 95 }
 96 
 97 static sa_handler_t call_os_signal(int sig, sa_handler_t disp,
 98                                    bool is_sigset) {
 99   sa_handler_t res;
100 
101   if (os_signal == NULL) {
102     if (!is_sigset) {
103       os_signal = (signal_function_t)dlsym(RTLD_NEXT, &quot;signal&quot;);
104     } else {
105       os_signal = (signal_function_t)dlsym(RTLD_NEXT, &quot;sigset&quot;);
106     }
107     if (os_signal == NULL) {
108       printf(&quot;%s\n&quot;, dlerror());
109       exit(0);
110     }
111   }
112 
113 #ifdef MACOSX
114   /* On macosx, the OS implementation of signal calls sigaction.
115    * Make sure we do not deadlock with ourself. (See JDK-8072147). */
116   reentry = true;
117 #endif
118 
119   res = (*os_signal)(sig, disp);
120 
121 #ifdef MACOSX
122   reentry = false;
123 #endif
124 
125   return res;
126 }
127 
128 static void save_signal_handler(int sig, sa_handler_t disp, bool is_sigset) {
129   sigset_t set;
130 
131   sact[sig].sa_handler = disp;
132   sigemptyset(&amp;set);
133   sact[sig].sa_mask = set;
<a name="6" id="anc6"></a><span class="line-modified">134   sact[sig].sa_flags = 0;</span>











135 }
136 
137 static sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {
138   sa_handler_t oldhandler;
139   bool sigused;
140   bool sigblocked;
141 
142   signal_lock();
<a name="7" id="anc7"></a>
143 
144   sigused = sigismember(&amp;jvmsigs, sig);
145   if (jvm_signal_installed &amp;&amp; sigused) {
146     /* jvm has installed its signal handler for this signal. */
147     /* Save the handler. Don&#39;t really install it. */
148     if (is_sigset) {
149       sigblocked = sigismember(&amp;(sact[sig].sa_mask), sig);
150     }
151     oldhandler = sact[sig].sa_handler;
152     save_signal_handler(sig, disp, is_sigset);
153 
<a name="8" id="anc8"></a>






154     signal_unlock();
155     return oldhandler;
156   } else if (jvm_signal_installing) {
157     /* jvm is installing its signal handlers. Install the new
158      * handlers and save the old ones. jvm uses sigaction().
159      * Leave the piece here just in case. */
160     oldhandler = call_os_signal(sig, disp, is_sigset);
161     save_signal_handler(sig, oldhandler, is_sigset);
162 
163     /* Record the signals used by jvm */
164     sigaddset(&amp;jvmsigs, sig);
165 
166     signal_unlock();
167     return oldhandler;
168   } else {
169     /* jvm has no relation with this signal (yet). Install the
170      * the handler. */
171     oldhandler = call_os_signal(sig, disp, is_sigset);
172 
173     signal_unlock();
174     return oldhandler;
175   }
176 }
177 
178 JNIEXPORT sa_handler_t signal(int sig, sa_handler_t disp) {
179   if (sig &lt; 0 || sig &gt;= MAX_SIGNALS) {
180     errno = EINVAL;
181     return SIG_ERR;
182   }
183 
184   return set_signal(sig, disp, false);
185 }
186 
187 JNIEXPORT sa_handler_t sigset(int sig, sa_handler_t disp) {
188 #ifdef _ALLBSD_SOURCE
189   printf(&quot;sigset() is not supported by BSD&quot;);
190   exit(0);
191 #else
192   if (sig &lt; 0 || sig &gt;= MAX_SIGNALS) {
193     errno = EINVAL;
194     return (sa_handler_t)-1;
195   }
196 
197   return set_signal(sig, disp, true);
198 #endif
199 }
200 
201 static int call_os_sigaction(int sig, const struct sigaction  *act,
202                              struct sigaction *oact) {
203   if (os_sigaction == NULL) {
204     os_sigaction = (sigaction_t)dlsym(RTLD_NEXT, &quot;sigaction&quot;);
205     if (os_sigaction == NULL) {
206       printf(&quot;%s\n&quot;, dlerror());
207       exit(0);
208     }
209   }
210   return (*os_sigaction)(sig, act, oact);
211 }
212 
213 JNIEXPORT int sigaction(int sig, const struct sigaction *act, struct sigaction *oact) {
214   int res;
215   bool sigused;
216   struct sigaction oldAct;
217 
218   if (sig &lt; 0 || sig &gt;= MAX_SIGNALS) {
219     errno = EINVAL;
220     return -1;
221   }
222 
223 #ifdef MACOSX
224   if (reentry) {
225     return call_os_sigaction(sig, act, oact);
226   }
227 #endif
228 
229   signal_lock();
230 
<a name="9" id="anc9"></a>
231   sigused = sigismember(&amp;jvmsigs, sig);
232   if (jvm_signal_installed &amp;&amp; sigused) {
233     /* jvm has installed its signal handler for this signal. */
234     /* Save the handler. Don&#39;t really install it. */
235     if (oact != NULL) {
236       *oact = sact[sig];
237     }
238     if (act != NULL) {
239       sact[sig] = *act;
240     }
241 
242     signal_unlock();
243     return 0;
244   } else if (jvm_signal_installing) {
245     /* jvm is installing its signal handlers. Install the new
246      * handlers and save the old ones. */
247     res = call_os_sigaction(sig, act, &amp;oldAct);
248     sact[sig] = oldAct;
249     if (oact != NULL) {
250       *oact = oldAct;
251     }
252 
253     /* Record the signals used by jvm. */
254     sigaddset(&amp;jvmsigs, sig);
255 
256     signal_unlock();
257     return res;
258   } else {
259     /* jvm has no relation with this signal (yet). Install the
260      * the handler. */
261     res = call_os_sigaction(sig, act, oact);
262 
263     signal_unlock();
264     return res;
265   }
266 }
267 
268 /* The three functions for the jvm to call into. */
269 JNIEXPORT void JVM_begin_signal_setting() {
270   signal_lock();
271   sigemptyset(&amp;jvmsigs);
272   jvm_signal_installing = true;
273   tid = pthread_self();
274   signal_unlock();
275 }
276 
277 JNIEXPORT void JVM_end_signal_setting() {
278   signal_lock();
279   jvm_signal_installed = true;
280   jvm_signal_installing = false;
281   pthread_cond_broadcast(&amp;cond);
282   signal_unlock();
283 }
284 
285 JNIEXPORT struct sigaction *JVM_get_signal_action(int sig) {
<a name="10" id="anc10"></a>
286   /* Does race condition make sense here? */
287   if (sigismember(&amp;jvmsigs, sig)) {
288     return &amp;sact[sig];
289   }
290   return NULL;
291 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
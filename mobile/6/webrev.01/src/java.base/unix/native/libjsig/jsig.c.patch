diff a/src/java.base/unix/native/libjsig/jsig.c b/src/java.base/unix/native/libjsig/jsig.c
--- a/src/java.base/unix/native/libjsig/jsig.c
+++ b/src/java.base/unix/native/libjsig/jsig.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2012, 2015 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -31,20 +31,10 @@
  * Used for signal-chaining. See RFE 4381843.
  */
 
 #include "jni.h"
 
-#ifdef SOLARIS
-/* Our redeclarations of the system functions must not have a less
- * restrictive linker scoping, so we have to declare them as JNIEXPORT
- * before including signal.h */
-#include "sys/signal.h"
-JNIEXPORT void (*signal(int sig, void (*disp)(int)))(int);
-JNIEXPORT void (*sigset(int sig, void (*disp)(int)))(int);
-JNIEXPORT int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
-#endif
-
 #include <dlfcn.h>
 #include <errno.h>
 #include <pthread.h>
 #include <signal.h>
 #include <stdio.h>
@@ -57,20 +47,13 @@
   #define bool int
   #define true 1
   #define false 0
 #endif
 
-#ifdef SOLARIS
-#define MAX_SIGNALS (SIGRTMAX+1)
-
-/* On solaris, MAX_SIGNALS is a macro, not a constant, so we must allocate sact dynamically. */
-static struct sigaction *sact = (struct sigaction *)NULL; /* saved signal handlers */
-#else
 #define MAX_SIGNALS NSIG
 
 static struct sigaction sact[MAX_SIGNALS]; /* saved signal handlers */
-#endif
 
 static sigset_t jvmsigs; /* Signals used by jvm. */
 
 #ifdef MACOSX
 static __thread bool reentry = false; /* prevent reentry deadlock (per-thread) */
@@ -91,24 +74,10 @@
 
 static bool jvm_signal_installing = false;
 static bool jvm_signal_installed = false;
 
 
-/* assume called within signal_lock */
-static void allocate_sact() {
-#ifdef SOLARIS
-  if (sact == NULL) {
-    sact = (struct sigaction *)malloc((MAX_SIGNALS) * (size_t)sizeof(struct sigaction));
-    if (sact == NULL) {
-      printf("%s\n", "libjsig.so unable to allocate memory");
-      exit(0);
-    }
-    memset(sact, 0, (MAX_SIGNALS) * (size_t)sizeof(struct sigaction));
-  }
-#endif
-}
-
 static void signal_lock() {
   pthread_mutex_lock(&mutex);
   /* When the jvm is installing its set of signal handlers, threads
    * other than the jvm thread should wait. */
   if (jvm_signal_installing) {
@@ -160,31 +129,19 @@
   sigset_t set;
 
   sact[sig].sa_handler = disp;
   sigemptyset(&set);
   sact[sig].sa_mask = set;
-  if (!is_sigset) {
-#ifdef SOLARIS
-    sact[sig].sa_flags = SA_NODEFER;
-    if (sig != SIGILL && sig != SIGTRAP && sig != SIGPWR) {
-      sact[sig].sa_flags |= SA_RESETHAND;
-    }
-#else
-    sact[sig].sa_flags = 0;
-#endif
-  } else {
-    sact[sig].sa_flags = 0;
-  }
+  sact[sig].sa_flags = 0;
 }
 
 static sa_handler_t set_signal(int sig, sa_handler_t disp, bool is_sigset) {
   sa_handler_t oldhandler;
   bool sigused;
   bool sigblocked;
 
   signal_lock();
-  allocate_sact();
 
   sigused = sigismember(&jvmsigs, sig);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
@@ -192,17 +149,10 @@
       sigblocked = sigismember(&(sact[sig].sa_mask), sig);
     }
     oldhandler = sact[sig].sa_handler;
     save_signal_handler(sig, disp, is_sigset);
 
-#ifdef SOLARIS
-    if (is_sigset && sigblocked) {
-      /* We won't honor the SIG_HOLD request to change the signal mask */
-      oldhandler = SIG_HOLD;
-    }
-#endif
-
     signal_unlock();
     return oldhandler;
   } else if (jvm_signal_installing) {
     /* jvm is installing its signal handlers. Install the new
      * handlers and save the old ones. jvm uses sigaction().
@@ -276,11 +226,10 @@
   }
 #endif
 
   signal_lock();
 
-  allocate_sact();
   sigused = sigismember(&jvmsigs, sig);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
     if (oact != NULL) {
@@ -332,11 +281,10 @@
   pthread_cond_broadcast(&cond);
   signal_unlock();
 }
 
 JNIEXPORT struct sigaction *JVM_get_signal_action(int sig) {
-  allocate_sact();
   /* Does race condition make sense here? */
   if (sigismember(&jvmsigs, sig)) {
     return &sact[sig];
   }
   return NULL;

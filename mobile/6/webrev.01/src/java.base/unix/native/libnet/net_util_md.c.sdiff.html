<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="SdpSupport.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnet/net_util_md.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;dlfcn.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;netinet/tcp.h&gt; // defines TCP_NODELAY
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 #include &lt;sys/time.h&gt;
  33 
  34 #if defined(__linux__)
  35 #include &lt;arpa/inet.h&gt;
  36 #include &lt;net/route.h&gt;
  37 #include &lt;sys/utsname.h&gt;
  38 #endif
  39 
<span class="line-removed">  40 #if defined(__solaris__)</span>
<span class="line-removed">  41 #include &lt;inet/nd.h&gt;</span>
<span class="line-removed">  42 #include &lt;limits.h&gt;</span>
<span class="line-removed">  43 #include &lt;stropts.h&gt;</span>
<span class="line-removed">  44 #include &lt;sys/filio.h&gt;</span>
<span class="line-removed">  45 #include &lt;sys/sockio.h&gt;</span>
<span class="line-removed">  46 #endif</span>
<span class="line-removed">  47 </span>
  48 #if defined(MACOSX)
  49 #include &lt;sys/sysctl.h&gt;
  50 #endif
  51 
  52 #include &quot;jvm.h&quot;
  53 #include &quot;net_util.h&quot;
  54 
  55 #include &quot;java_net_SocketOptions.h&quot;
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  59 #define IPV6_FLOWINFO_SEND      33
  60 #endif
  61 
<span class="line-removed">  62 #if defined(__solaris__) &amp;&amp; !defined(MAXINT)</span>
<span class="line-removed">  63 #define MAXINT INT_MAX</span>
<span class="line-removed">  64 #endif</span>
<span class="line-removed">  65 </span>
<span class="line-removed">  66 /*</span>
<span class="line-removed">  67  * EXCLBIND socket options only on Solaris</span>
<span class="line-removed">  68  */</span>
<span class="line-removed">  69 #if defined(__solaris__) &amp;&amp; !defined(TCP_EXCLBIND)</span>
<span class="line-removed">  70 #define TCP_EXCLBIND            0x21</span>
<span class="line-removed">  71 #endif</span>
<span class="line-removed">  72 #if defined(__solaris__) &amp;&amp; !defined(UDP_EXCLBIND)</span>
<span class="line-removed">  73 #define UDP_EXCLBIND            0x0101</span>
<span class="line-removed">  74 #endif</span>
<span class="line-removed">  75 </span>
  76 #define RESTARTABLE(_cmd, _result) do { \
  77     do { \
  78         _result = _cmd; \
  79     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
  80 } while(0)
  81 
  82 int NET_SocketAvailable(int s, int *pbytes) {
  83     int result;
  84     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
  85     return result;
  86 }
  87 
<span class="line-removed">  88 #ifdef __solaris__</span>
<span class="line-removed">  89 static int init_tcp_max_buf, init_udp_max_buf;</span>
<span class="line-removed">  90 static int tcp_max_buf;</span>
<span class="line-removed">  91 static int udp_max_buf;</span>
<span class="line-removed">  92 static int useExclBind = 0;</span>
<span class="line-removed">  93 </span>
<span class="line-removed">  94 /*</span>
<span class="line-removed">  95  * Get the specified parameter from the specified driver. The value</span>
<span class="line-removed">  96  * of the parameter is assumed to be an &#39;int&#39;. If the parameter</span>
<span class="line-removed">  97  * cannot be obtained return -1</span>
<span class="line-removed">  98  */</span>
<span class="line-removed">  99 int net_getParam(char *driver, char *param)</span>
<span class="line-removed"> 100 {</span>
<span class="line-removed"> 101     struct strioctl stri;</span>
<span class="line-removed"> 102     char buf [64];</span>
<span class="line-removed"> 103     int s;</span>
<span class="line-removed"> 104     int value;</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106     s = open (driver, O_RDWR);</span>
<span class="line-removed"> 107     if (s &lt; 0) {</span>
<span class="line-removed"> 108         return -1;</span>
<span class="line-removed"> 109     }</span>
<span class="line-removed"> 110     strncpy (buf, param, sizeof(buf));</span>
<span class="line-removed"> 111     stri.ic_cmd = ND_GET;</span>
<span class="line-removed"> 112     stri.ic_timout = 0;</span>
<span class="line-removed"> 113     stri.ic_dp = buf;</span>
<span class="line-removed"> 114     stri.ic_len = sizeof(buf);</span>
<span class="line-removed"> 115     if (ioctl (s, I_STR, &amp;stri) &lt; 0) {</span>
<span class="line-removed"> 116         value = -1;</span>
<span class="line-removed"> 117     } else {</span>
<span class="line-removed"> 118         value = atoi(buf);</span>
<span class="line-removed"> 119     }</span>
<span class="line-removed"> 120     close (s);</span>
<span class="line-removed"> 121     return value;</span>
<span class="line-removed"> 122 }</span>
<span class="line-removed"> 123 </span>
<span class="line-removed"> 124 /*</span>
<span class="line-removed"> 125  * Iterative way to find the max value that SO_SNDBUF or SO_RCVBUF</span>
<span class="line-removed"> 126  * for Solaris versions that do not support the ioctl() in net_getParam().</span>
<span class="line-removed"> 127  * Ugly, but only called once (for each sotype).</span>
<span class="line-removed"> 128  *</span>
<span class="line-removed"> 129  * As an optimization, we make a guess using the default values for Solaris</span>
<span class="line-removed"> 130  * assuming they haven&#39;t been modified with ndd.</span>
<span class="line-removed"> 131  */</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133 #define MAX_TCP_GUESS 1024 * 1024</span>
<span class="line-removed"> 134 #define MAX_UDP_GUESS 2 * 1024 * 1024</span>
<span class="line-removed"> 135 </span>
<span class="line-removed"> 136 #define FAIL_IF_NOT_ENOBUFS if (errno != ENOBUFS) return -1</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138 static int findMaxBuf(int fd, int opt, int sotype) {</span>
<span class="line-removed"> 139     int a = 0;</span>
<span class="line-removed"> 140     int b = MAXINT;</span>
<span class="line-removed"> 141     int initial_guess;</span>
<span class="line-removed"> 142     int limit = -1;</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     if (sotype == SOCK_DGRAM) {</span>
<span class="line-removed"> 145         initial_guess = MAX_UDP_GUESS;</span>
<span class="line-removed"> 146     } else {</span>
<span class="line-removed"> 147         initial_guess = MAX_TCP_GUESS;</span>
<span class="line-removed"> 148     }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150     if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess, sizeof(int)) == 0) {</span>
<span class="line-removed"> 151         initial_guess++;</span>
<span class="line-removed"> 152         if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess,sizeof(int)) &lt; 0) {</span>
<span class="line-removed"> 153             FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 154             return initial_guess - 1;</span>
<span class="line-removed"> 155         }</span>
<span class="line-removed"> 156         a = initial_guess;</span>
<span class="line-removed"> 157     } else {</span>
<span class="line-removed"> 158         FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 159         b = initial_guess - 1;</span>
<span class="line-removed"> 160     }</span>
<span class="line-removed"> 161     do {</span>
<span class="line-removed"> 162         int mid = a + (b-a)/2;</span>
<span class="line-removed"> 163         if (setsockopt(fd, SOL_SOCKET, opt, &amp;mid, sizeof(int)) == 0) {</span>
<span class="line-removed"> 164             limit = mid;</span>
<span class="line-removed"> 165             a = mid + 1;</span>
<span class="line-removed"> 166         } else {</span>
<span class="line-removed"> 167             FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 168             b = mid - 1;</span>
<span class="line-removed"> 169         }</span>
<span class="line-removed"> 170     } while (b &gt;= a);</span>
<span class="line-removed"> 171 </span>
<span class="line-removed"> 172     return limit;</span>
<span class="line-removed"> 173 }</span>
<span class="line-removed"> 174 #endif</span>
<span class="line-removed"> 175 </span>
 176 void
 177 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 178                    const char *defaultDetail) {
 179     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
 180 }
 181 
 182 void
 183 NET_ThrowCurrent(JNIEnv *env, char *msg) {
 184     NET_ThrowNew(env, errno, msg);
 185 }
 186 
 187 void
 188 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
 189     char fullMsg[512];
 190     if (!msg) {
 191         msg = &quot;no further information&quot;;
 192     }
 193     switch(errorNumber) {
 194     case EBADF:
 195         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
</pre>
<hr />
<pre>
 266      */
 267 #ifdef __linux__
 268     {
 269         FILE *fP = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;);
 270         char buf[255];
 271         char *bufP;
 272 
 273         if (fP == NULL) {
 274             close(fd);
 275             return JNI_FALSE;
 276         }
 277         bufP = fgets(buf, sizeof(buf), fP);
 278         fclose(fP);
 279         if (bufP == NULL) {
 280             close(fd);
 281             return JNI_FALSE;
 282         }
 283     }
 284 #endif
 285 
<span class="line-removed"> 286     /**</span>
<span class="line-removed"> 287      * On Solaris 8 it&#39;s possible to create INET6 sockets even</span>
<span class="line-removed"> 288      * though IPv6 is not enabled on all interfaces. Thus we</span>
<span class="line-removed"> 289      * query the number of IPv6 addresses to verify that IPv6</span>
<span class="line-removed"> 290      * has been configured on at least one interface.</span>
<span class="line-removed"> 291      *</span>
<span class="line-removed"> 292      * On Linux it doesn&#39;t matter - if IPv6 is built-in the</span>
<span class="line-removed"> 293      * kernel then IPv6 addresses will be bound automatically</span>
<span class="line-removed"> 294      * to all interfaces.</span>
<span class="line-removed"> 295      */</span>
<span class="line-removed"> 296 #ifdef __solaris__</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298 #ifdef SIOCGLIFNUM</span>
<span class="line-removed"> 299     {</span>
<span class="line-removed"> 300         struct lifnum numifs;</span>
<span class="line-removed"> 301 </span>
<span class="line-removed"> 302         numifs.lifn_family = AF_INET6;</span>
<span class="line-removed"> 303         numifs.lifn_flags = 0;</span>
<span class="line-removed"> 304         if (ioctl(fd, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed"> 305             /**</span>
<span class="line-removed"> 306              * SIOCGLIFNUM failed - assume IPv6 not configured</span>
<span class="line-removed"> 307              */</span>
<span class="line-removed"> 308             close(fd);</span>
<span class="line-removed"> 309             return JNI_FALSE;</span>
<span class="line-removed"> 310         }</span>
<span class="line-removed"> 311         /**</span>
<span class="line-removed"> 312          * If no IPv6 addresses then return false. If count &gt; 0</span>
<span class="line-removed"> 313          * it&#39;s possible that all IPv6 addresses are &quot;down&quot; but</span>
<span class="line-removed"> 314          * that&#39;s okay as they may be brought &quot;up&quot; while the</span>
<span class="line-removed"> 315          * VM is running.</span>
<span class="line-removed"> 316          */</span>
<span class="line-removed"> 317         if (numifs.lifn_count == 0) {</span>
<span class="line-removed"> 318             close(fd);</span>
<span class="line-removed"> 319             return JNI_FALSE;</span>
<span class="line-removed"> 320         }</span>
<span class="line-removed"> 321     }</span>
<span class="line-removed"> 322 #else</span>
<span class="line-removed"> 323     /* SIOCGLIFNUM not defined in build environment ??? */</span>
<span class="line-removed"> 324     close(fd);</span>
<span class="line-removed"> 325     return JNI_FALSE;</span>
<span class="line-removed"> 326 #endif</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328 #endif /* __solaris */</span>
<span class="line-removed"> 329 </span>
 330     /*
 331      *  OK we may have the stack available in the kernel,
 332      *  we should also check if the APIs are available.
 333      */
 334     ipv6_fn = JVM_FindLibraryEntry(RTLD_DEFAULT, &quot;inet_pton&quot;);
 335     close(fd);
 336     if (ipv6_fn == NULL ) {
 337         return JNI_FALSE;
 338     } else {
 339         return JNI_TRUE;
 340     }
 341 }
 342 #endif /* DONT_ENABLE_IPV6 */
 343 
 344 jint reuseport_supported()
 345 {
 346     /* Do a simple dummy call, and try to figure out from that */
 347     int one = 1;
 348     int rv, s;
 349     s = socket(PF_INET, SOCK_STREAM, 0);
</pre>
<hr />
<pre>
 386         }
 387         free(buf);
 388     }
 389 }
 390 
 391 #if defined(_AIX)
 392 
 393 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 394 extern void aix_close_init();
 395 
 396 void platformInit () {
 397     aix_close_init();
 398 }
 399 
 400 #else
 401 
 402 void platformInit () {}
 403 
 404 #endif
 405 
<span class="line-removed"> 406 void parseExclusiveBindProperty(JNIEnv *env) {</span>
<span class="line-removed"> 407 #ifdef __solaris__</span>
<span class="line-removed"> 408     jstring s, flagSet;</span>
<span class="line-removed"> 409     jclass iCls;</span>
<span class="line-removed"> 410     jmethodID mid;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412     s = (*env)-&gt;NewStringUTF(env, &quot;sun.net.useExclusiveBind&quot;);</span>
<span class="line-removed"> 413     CHECK_NULL(s);</span>
<span class="line-removed"> 414     iCls = (*env)-&gt;FindClass(env, &quot;java/lang/System&quot;);</span>
<span class="line-removed"> 415     CHECK_NULL(iCls);</span>
<span class="line-removed"> 416     mid = (*env)-&gt;GetStaticMethodID(env, iCls, &quot;getProperty&quot;,</span>
<span class="line-removed"> 417                 &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span>
<span class="line-removed"> 418     CHECK_NULL(mid);</span>
<span class="line-removed"> 419     flagSet = (*env)-&gt;CallStaticObjectMethod(env, iCls, mid, s);</span>
<span class="line-removed"> 420     if (flagSet != NULL) {</span>
<span class="line-removed"> 421         useExclBind = 1;</span>
<span class="line-removed"> 422     }</span>
<span class="line-removed"> 423 #endif</span>
<span class="line-removed"> 424 }</span>
<span class="line-removed"> 425 </span>
 426 JNIEXPORT jint JNICALL
 427 NET_EnableFastTcpLoopback(int fd) {
 428     return 0;
 429 }
 430 
 431 /**
 432  * See net_util.h for documentation
 433  */
 434 JNIEXPORT int JNICALL
 435 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
 436                           SOCKETADDRESS *sa, int *len,
 437                           jboolean v4MappedAddress)
 438 {
 439     jint family = getInetAddress_family(env, iaObj);
 440     JNU_CHECK_EXCEPTION_RETURN(env, -1);
 441     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
 442 
 443     if (ipv6_available() &amp;&amp;
 444         !(family == java_net_InetAddress_IPv4 &amp;&amp;
 445           v4MappedAddress == JNI_FALSE))
</pre>
<hr />
<pre>
 571         { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },
 572         { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },
 573         { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },
 574     };
 575 
 576     int i;
 577 
 578     if (ipv6_available()) {
 579         switch (cmd) {
 580             // Different multicast options if IPv6 is enabled
 581             case java_net_SocketOptions_IP_MULTICAST_IF:
 582             case java_net_SocketOptions_IP_MULTICAST_IF2:
 583                 *level = IPPROTO_IPV6;
 584                 *optname = IPV6_MULTICAST_IF;
 585                 return 0;
 586 
 587             case java_net_SocketOptions_IP_MULTICAST_LOOP:
 588                 *level = IPPROTO_IPV6;
 589                 *optname = IPV6_MULTICAST_LOOP;
 590                 return 0;
<span class="line-modified"> 591 #if (defined(__solaris__) || defined(MACOSX))</span>
 592             // Map IP_TOS request to IPV6_TCLASS
 593             case java_net_SocketOptions_IP_TOS:
 594                 *level = IPPROTO_IPV6;
 595                 *optname = IPV6_TCLASS;
 596                 return 0;
 597 #endif
 598         }
 599     }
 600 
 601     /*
 602      * Map the Java level option to the native level
 603      */
 604     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 605         if (cmd == opts[i].cmd) {
 606             *level = opts[i].level;
 607             *optname = opts[i].optname;
 608             return 0;
 609         }
 610     }
 611 
</pre>
<hr />
<pre>
 720                            (void *)&amp;optval, sizeof(optval)) &lt; 0) {
 721                 return -1;
 722             }
 723            /*
 724             * Let&#39;s also set the IPV6_TCLASS flag.
 725             * Linux appears to allow both IP_TOS and IPV6_TCLASS to be set
 726             * This helps in mixed environments where IPv4 and IPv6 sockets
 727             * are connecting.
 728             */
 729            if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS,
 730                            arg, len) &lt; 0) {
 731                 return -1;
 732             }
 733         }
 734 #endif
 735 
 736         iptos = (int *)arg;
 737         *iptos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
 738     }
 739 
<span class="line-removed"> 740     /*</span>
<span class="line-removed"> 741      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris we may need to clamp</span>
<span class="line-removed"> 742      * the value when it exceeds the system limit.</span>
<span class="line-removed"> 743      */</span>
<span class="line-removed"> 744 #ifdef __solaris__</span>
<span class="line-removed"> 745     if (level == SOL_SOCKET) {</span>
<span class="line-removed"> 746         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {</span>
<span class="line-removed"> 747             int sotype=0;</span>
<span class="line-removed"> 748             socklen_t arglen;</span>
<span class="line-removed"> 749             int *bufsize, maxbuf;</span>
<span class="line-removed"> 750             int ret;</span>
<span class="line-removed"> 751 </span>
<span class="line-removed"> 752             /* Attempt with the original size */</span>
<span class="line-removed"> 753             ret = setsockopt(fd, level, opt, arg, len);</span>
<span class="line-removed"> 754             if ((ret == 0) || (ret == -1 &amp;&amp; errno != ENOBUFS))</span>
<span class="line-removed"> 755                 return ret;</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757             /* Exceeded system limit so clamp and retry */</span>
<span class="line-removed"> 758 </span>
<span class="line-removed"> 759             arglen = sizeof(sotype);</span>
<span class="line-removed"> 760             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype,</span>
<span class="line-removed"> 761                            &amp;arglen) &lt; 0) {</span>
<span class="line-removed"> 762                 return -1;</span>
<span class="line-removed"> 763             }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765             /*</span>
<span class="line-removed"> 766              * We try to get tcp_maxbuf (and udp_max_buf) using</span>
<span class="line-removed"> 767              * an ioctl() that isn&#39;t available on all versions of Solaris.</span>
<span class="line-removed"> 768              * If that fails, we use the search algorithm in findMaxBuf()</span>
<span class="line-removed"> 769              */</span>
<span class="line-removed"> 770             if (!init_tcp_max_buf &amp;&amp; sotype == SOCK_STREAM) {</span>
<span class="line-removed"> 771                 tcp_max_buf = net_getParam(&quot;/dev/tcp&quot;, &quot;tcp_max_buf&quot;);</span>
<span class="line-removed"> 772                 if (tcp_max_buf == -1) {</span>
<span class="line-removed"> 773                     tcp_max_buf = findMaxBuf(fd, opt, SOCK_STREAM);</span>
<span class="line-removed"> 774                     if (tcp_max_buf == -1) {</span>
<span class="line-removed"> 775                         return -1;</span>
<span class="line-removed"> 776                     }</span>
<span class="line-removed"> 777                 }</span>
<span class="line-removed"> 778                 init_tcp_max_buf = 1;</span>
<span class="line-removed"> 779             } else if (!init_udp_max_buf &amp;&amp; sotype == SOCK_DGRAM) {</span>
<span class="line-removed"> 780                 udp_max_buf = net_getParam(&quot;/dev/udp&quot;, &quot;udp_max_buf&quot;);</span>
<span class="line-removed"> 781                 if (udp_max_buf == -1) {</span>
<span class="line-removed"> 782                     udp_max_buf = findMaxBuf(fd, opt, SOCK_DGRAM);</span>
<span class="line-removed"> 783                     if (udp_max_buf == -1) {</span>
<span class="line-removed"> 784                         return -1;</span>
<span class="line-removed"> 785                     }</span>
<span class="line-removed"> 786                 }</span>
<span class="line-removed"> 787                 init_udp_max_buf = 1;</span>
<span class="line-removed"> 788             }</span>
<span class="line-removed"> 789 </span>
<span class="line-removed"> 790             maxbuf = (sotype == SOCK_STREAM) ? tcp_max_buf : udp_max_buf;</span>
<span class="line-removed"> 791             bufsize = (int *)arg;</span>
<span class="line-removed"> 792             if (*bufsize &gt; maxbuf) {</span>
<span class="line-removed"> 793                 *bufsize = maxbuf;</span>
<span class="line-removed"> 794             }</span>
<span class="line-removed"> 795         }</span>
<span class="line-removed"> 796     }</span>
<span class="line-removed"> 797 #endif</span>
<span class="line-removed"> 798 </span>
 799 #ifdef _AIX
 800     if (level == SOL_SOCKET) {
 801         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
 802             /*
 803              * Just try to set the requested size. If it fails we will leave the
 804              * socket option as is. Setting the buffer size means only a hint in
 805              * the jse2/java software layer, see javadoc. In the previous
 806              * solution the buffer has always been truncated to a length of
 807              * 0x100000 Byte, even if the technical limit has not been reached.
 808              * This kind of absolute truncation was unexpected in the jck tests.
 809              */
 810             int ret = setsockopt(fd, level, opt, arg, len);
 811             if ((ret == 0) || (ret == -1 &amp;&amp; errno == ENOBUFS)) {
 812                 // Accept failure because of insufficient buffer memory resources.
 813                 return 0;
 814             } else {
 815                 // Deliver all other kinds of errors.
 816                 return ret;
 817             }
 818         }
</pre>
<hr />
<pre>
 891         arglen = sizeof(sotype);
 892         if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) &lt; 0) {
 893             return -1;
 894         }
 895 
 896         if (sotype == SOCK_DGRAM) {
 897             setsockopt(fd, level, SO_REUSEPORT, arg, len);
 898         }
 899     }
 900 #endif
 901 
 902     return setsockopt(fd, level, opt, arg, len);
 903 }
 904 
 905 /*
 906  * Wrapper for bind system call - performs any necessary pre/post
 907  * processing to deal with OS specific issues :-
 908  *
 909  * Linux allows a socket to bind to 127.0.0.255 which must be
 910  * caught.
<span class="line-removed"> 911  *</span>
<span class="line-removed"> 912  * On Solaris with IPv6 enabled we must use an exclusive</span>
<span class="line-removed"> 913  * bind to guarantee a unique port number across the IPv4 and</span>
<span class="line-removed"> 914  * IPv6 port spaces.</span>
<span class="line-removed"> 915  *</span>
 916  */
 917 int
 918 NET_Bind(int fd, SOCKETADDRESS *sa, int len)
 919 {
<span class="line-removed"> 920 #if defined(__solaris__)</span>
<span class="line-removed"> 921     int level = -1;</span>
<span class="line-removed"> 922     int exclbind = -1;</span>
<span class="line-removed"> 923 #endif</span>
 924     int rv;
 925     int arg, alen;
 926 
 927 #ifdef __linux__
 928     /*
 929      * ## get bugId for this issue - goes back to 1.2.2 port ##
 930      * ## When IPv6 is enabled this will be an IPv4-mapped
 931      * ## with family set to AF_INET6
 932      */
 933     if (sa-&gt;sa.sa_family == AF_INET) {
 934         if ((ntohl(sa-&gt;sa4.sin_addr.s_addr) &amp; 0x7f0000ff) == 0x7f0000ff) {
 935             errno = EADDRNOTAVAIL;
 936             return -1;
 937         }
 938     }
 939 #endif
 940 
<span class="line-removed"> 941 #if defined(__solaris__)</span>
<span class="line-removed"> 942     /*</span>
<span class="line-removed"> 943      * Solaris has separate IPv4 and IPv6 port spaces so we</span>
<span class="line-removed"> 944      * use an exclusive bind when SO_REUSEADDR is not used to</span>
<span class="line-removed"> 945      * give the illusion of a unified port space.</span>
<span class="line-removed"> 946      * This also avoids problems with IPv6 sockets connecting</span>
<span class="line-removed"> 947      * to IPv4 mapped addresses whereby the socket conversion</span>
<span class="line-removed"> 948      * results in a late bind that fails because the</span>
<span class="line-removed"> 949      * corresponding IPv4 port is in use.</span>
<span class="line-removed"> 950      */</span>
<span class="line-removed"> 951     alen = sizeof(arg);</span>
<span class="line-removed"> 952 </span>
<span class="line-removed"> 953     if (useExclBind ||</span>
<span class="line-removed"> 954         getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;arg, &amp;alen) == 0)</span>
<span class="line-removed"> 955     {</span>
<span class="line-removed"> 956         if (useExclBind || arg == 0) {</span>
<span class="line-removed"> 957             /*</span>
<span class="line-removed"> 958              * SO_REUSEADDR is disabled or sun.net.useExclusiveBind</span>
<span class="line-removed"> 959              * property is true so enable TCP_EXCLBIND or</span>
<span class="line-removed"> 960              * UDP_EXCLBIND</span>
<span class="line-removed"> 961              */</span>
<span class="line-removed"> 962             alen = sizeof(arg);</span>
<span class="line-removed"> 963             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&amp;arg, &amp;alen) == 0)</span>
<span class="line-removed"> 964             {</span>
<span class="line-removed"> 965                 if (arg == SOCK_STREAM) {</span>
<span class="line-removed"> 966                     level = IPPROTO_TCP;</span>
<span class="line-removed"> 967                     exclbind = TCP_EXCLBIND;</span>
<span class="line-removed"> 968                 } else {</span>
<span class="line-removed"> 969                     level = IPPROTO_UDP;</span>
<span class="line-removed"> 970                     exclbind = UDP_EXCLBIND;</span>
<span class="line-removed"> 971                 }</span>
<span class="line-removed"> 972             }</span>
<span class="line-removed"> 973 </span>
<span class="line-removed"> 974             arg = 1;</span>
<span class="line-removed"> 975             setsockopt(fd, level, exclbind, (char *)&amp;arg, sizeof(arg));</span>
<span class="line-removed"> 976         }</span>
<span class="line-removed"> 977     }</span>
<span class="line-removed"> 978 </span>
<span class="line-removed"> 979 #endif</span>
<span class="line-removed"> 980 </span>
 981     rv = bind(fd, &amp;sa-&gt;sa, len);
 982 
<span class="line-removed"> 983 #if defined(__solaris__)</span>
<span class="line-removed"> 984     if (rv &lt; 0) {</span>
<span class="line-removed"> 985         int en = errno;</span>
<span class="line-removed"> 986         /* Restore *_EXCLBIND if the bind fails */</span>
<span class="line-removed"> 987         if (exclbind != -1) {</span>
<span class="line-removed"> 988             int arg = 0;</span>
<span class="line-removed"> 989             setsockopt(fd, level, exclbind, (char *)&amp;arg,</span>
<span class="line-removed"> 990                        sizeof(arg));</span>
<span class="line-removed"> 991         }</span>
<span class="line-removed"> 992         errno = en;</span>
<span class="line-removed"> 993     }</span>
<span class="line-removed"> 994 #endif</span>
<span class="line-removed"> 995 </span>
 996     return rv;
 997 }
 998 
 999 /**
1000  * Wrapper for poll with timeout on a single file descriptor.
1001  *
1002  * flags (defined in net_util_md.h can be any combination of
1003  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
1004  *
1005  * The function will return when either the socket is ready for one
1006  * of the specified operations or the timeout expired.
1007  *
1008  * It returns the time left from the timeout (possibly 0), or -1 if it expired.
1009  */
1010 
1011 jint
1012 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
1013 {
1014     jlong prevNanoTime = JVM_NanoTime(env, 0);
1015     jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;dlfcn.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;netinet/tcp.h&gt; // defines TCP_NODELAY
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 #include &lt;sys/time.h&gt;
  33 
  34 #if defined(__linux__)
  35 #include &lt;arpa/inet.h&gt;
  36 #include &lt;net/route.h&gt;
  37 #include &lt;sys/utsname.h&gt;
  38 #endif
  39 








  40 #if defined(MACOSX)
  41 #include &lt;sys/sysctl.h&gt;
  42 #endif
  43 
  44 #include &quot;jvm.h&quot;
  45 #include &quot;net_util.h&quot;
  46 
  47 #include &quot;java_net_SocketOptions.h&quot;
  48 #include &quot;java_net_InetAddress.h&quot;
  49 
  50 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  51 #define IPV6_FLOWINFO_SEND      33
  52 #endif
  53 














  54 #define RESTARTABLE(_cmd, _result) do { \
  55     do { \
  56         _result = _cmd; \
  57     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
  58 } while(0)
  59 
  60 int NET_SocketAvailable(int s, int *pbytes) {
  61     int result;
  62     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
  63     return result;
  64 }
  65 
























































































  66 void
  67 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
  68                    const char *defaultDetail) {
  69     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
  70 }
  71 
  72 void
  73 NET_ThrowCurrent(JNIEnv *env, char *msg) {
  74     NET_ThrowNew(env, errno, msg);
  75 }
  76 
  77 void
  78 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
  79     char fullMsg[512];
  80     if (!msg) {
  81         msg = &quot;no further information&quot;;
  82     }
  83     switch(errorNumber) {
  84     case EBADF:
  85         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
</pre>
<hr />
<pre>
 156      */
 157 #ifdef __linux__
 158     {
 159         FILE *fP = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;);
 160         char buf[255];
 161         char *bufP;
 162 
 163         if (fP == NULL) {
 164             close(fd);
 165             return JNI_FALSE;
 166         }
 167         bufP = fgets(buf, sizeof(buf), fP);
 168         fclose(fP);
 169         if (bufP == NULL) {
 170             close(fd);
 171             return JNI_FALSE;
 172         }
 173     }
 174 #endif
 175 












































 176     /*
 177      *  OK we may have the stack available in the kernel,
 178      *  we should also check if the APIs are available.
 179      */
 180     ipv6_fn = JVM_FindLibraryEntry(RTLD_DEFAULT, &quot;inet_pton&quot;);
 181     close(fd);
 182     if (ipv6_fn == NULL ) {
 183         return JNI_FALSE;
 184     } else {
 185         return JNI_TRUE;
 186     }
 187 }
 188 #endif /* DONT_ENABLE_IPV6 */
 189 
 190 jint reuseport_supported()
 191 {
 192     /* Do a simple dummy call, and try to figure out from that */
 193     int one = 1;
 194     int rv, s;
 195     s = socket(PF_INET, SOCK_STREAM, 0);
</pre>
<hr />
<pre>
 232         }
 233         free(buf);
 234     }
 235 }
 236 
 237 #if defined(_AIX)
 238 
 239 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 240 extern void aix_close_init();
 241 
 242 void platformInit () {
 243     aix_close_init();
 244 }
 245 
 246 #else
 247 
 248 void platformInit () {}
 249 
 250 #endif
 251 




















 252 JNIEXPORT jint JNICALL
 253 NET_EnableFastTcpLoopback(int fd) {
 254     return 0;
 255 }
 256 
 257 /**
 258  * See net_util.h for documentation
 259  */
 260 JNIEXPORT int JNICALL
 261 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
 262                           SOCKETADDRESS *sa, int *len,
 263                           jboolean v4MappedAddress)
 264 {
 265     jint family = getInetAddress_family(env, iaObj);
 266     JNU_CHECK_EXCEPTION_RETURN(env, -1);
 267     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
 268 
 269     if (ipv6_available() &amp;&amp;
 270         !(family == java_net_InetAddress_IPv4 &amp;&amp;
 271           v4MappedAddress == JNI_FALSE))
</pre>
<hr />
<pre>
 397         { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },
 398         { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },
 399         { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },
 400     };
 401 
 402     int i;
 403 
 404     if (ipv6_available()) {
 405         switch (cmd) {
 406             // Different multicast options if IPv6 is enabled
 407             case java_net_SocketOptions_IP_MULTICAST_IF:
 408             case java_net_SocketOptions_IP_MULTICAST_IF2:
 409                 *level = IPPROTO_IPV6;
 410                 *optname = IPV6_MULTICAST_IF;
 411                 return 0;
 412 
 413             case java_net_SocketOptions_IP_MULTICAST_LOOP:
 414                 *level = IPPROTO_IPV6;
 415                 *optname = IPV6_MULTICAST_LOOP;
 416                 return 0;
<span class="line-modified"> 417 #if defined(MACOSX)</span>
 418             // Map IP_TOS request to IPV6_TCLASS
 419             case java_net_SocketOptions_IP_TOS:
 420                 *level = IPPROTO_IPV6;
 421                 *optname = IPV6_TCLASS;
 422                 return 0;
 423 #endif
 424         }
 425     }
 426 
 427     /*
 428      * Map the Java level option to the native level
 429      */
 430     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 431         if (cmd == opts[i].cmd) {
 432             *level = opts[i].level;
 433             *optname = opts[i].optname;
 434             return 0;
 435         }
 436     }
 437 
</pre>
<hr />
<pre>
 546                            (void *)&amp;optval, sizeof(optval)) &lt; 0) {
 547                 return -1;
 548             }
 549            /*
 550             * Let&#39;s also set the IPV6_TCLASS flag.
 551             * Linux appears to allow both IP_TOS and IPV6_TCLASS to be set
 552             * This helps in mixed environments where IPv4 and IPv6 sockets
 553             * are connecting.
 554             */
 555            if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS,
 556                            arg, len) &lt; 0) {
 557                 return -1;
 558             }
 559         }
 560 #endif
 561 
 562         iptos = (int *)arg;
 563         *iptos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
 564     }
 565 



























































 566 #ifdef _AIX
 567     if (level == SOL_SOCKET) {
 568         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
 569             /*
 570              * Just try to set the requested size. If it fails we will leave the
 571              * socket option as is. Setting the buffer size means only a hint in
 572              * the jse2/java software layer, see javadoc. In the previous
 573              * solution the buffer has always been truncated to a length of
 574              * 0x100000 Byte, even if the technical limit has not been reached.
 575              * This kind of absolute truncation was unexpected in the jck tests.
 576              */
 577             int ret = setsockopt(fd, level, opt, arg, len);
 578             if ((ret == 0) || (ret == -1 &amp;&amp; errno == ENOBUFS)) {
 579                 // Accept failure because of insufficient buffer memory resources.
 580                 return 0;
 581             } else {
 582                 // Deliver all other kinds of errors.
 583                 return ret;
 584             }
 585         }
</pre>
<hr />
<pre>
 658         arglen = sizeof(sotype);
 659         if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) &lt; 0) {
 660             return -1;
 661         }
 662 
 663         if (sotype == SOCK_DGRAM) {
 664             setsockopt(fd, level, SO_REUSEPORT, arg, len);
 665         }
 666     }
 667 #endif
 668 
 669     return setsockopt(fd, level, opt, arg, len);
 670 }
 671 
 672 /*
 673  * Wrapper for bind system call - performs any necessary pre/post
 674  * processing to deal with OS specific issues :-
 675  *
 676  * Linux allows a socket to bind to 127.0.0.255 which must be
 677  * caught.





 678  */
 679 int
 680 NET_Bind(int fd, SOCKETADDRESS *sa, int len)
 681 {




 682     int rv;
 683     int arg, alen;
 684 
 685 #ifdef __linux__
 686     /*
 687      * ## get bugId for this issue - goes back to 1.2.2 port ##
 688      * ## When IPv6 is enabled this will be an IPv4-mapped
 689      * ## with family set to AF_INET6
 690      */
 691     if (sa-&gt;sa.sa_family == AF_INET) {
 692         if ((ntohl(sa-&gt;sa4.sin_addr.s_addr) &amp; 0x7f0000ff) == 0x7f0000ff) {
 693             errno = EADDRNOTAVAIL;
 694             return -1;
 695         }
 696     }
 697 #endif
 698 








































 699     rv = bind(fd, &amp;sa-&gt;sa, len);
 700 













 701     return rv;
 702 }
 703 
 704 /**
 705  * Wrapper for poll with timeout on a single file descriptor.
 706  *
 707  * flags (defined in net_util_md.h can be any combination of
 708  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
 709  *
 710  * The function will return when either the socket is ready for one
 711  * of the specified operations or the timeout expired.
 712  *
 713  * It returns the time left from the timeout (possibly 0), or -1 if it expired.
 714  */
 715 
 716 jint
 717 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
 718 {
 719     jlong prevNanoTime = JVM_NanoTime(env, 0);
 720     jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;
</pre>
</td>
</tr>
</table>
<center><a href="SdpSupport.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="net_util_md.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
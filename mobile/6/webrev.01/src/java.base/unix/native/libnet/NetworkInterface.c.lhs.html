<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/unix/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #ifndef TARGET_IOS
  29 #include &lt;net/if_arp.h&gt;
  30 #endif
  31 #include &lt;stdlib.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/ioctl.h&gt;
  34 
  35 #if defined(_AIX)
  36 #include &lt;netinet/in6_var.h&gt;
  37 #include &lt;sys/ndd_var.h&gt;
  38 #include &lt;sys/kinfo.h&gt;
  39 #include &lt;strings.h&gt;
  40 #endif
  41 
<a name="1" id="anc1"></a><span class="line-removed">  42 #if defined(__solaris__)</span>
<span class="line-removed">  43 #include &lt;stropts.h&gt;</span>
<span class="line-removed">  44 #include &lt;sys/dlpi.h&gt;</span>
<span class="line-removed">  45 #include &lt;sys/sockio.h&gt;</span>
<span class="line-removed">  46 #endif</span>
<span class="line-removed">  47 </span>
  48 #if defined(_ALLBSD_SOURCE)
  49 #include &lt;net/ethernet.h&gt;
  50 #include &lt;net/if_dl.h&gt;
  51 #include &lt;ifaddrs.h&gt;
  52 #endif
  53 
  54 #include &quot;net_util.h&quot;
  55 
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__)
  59     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
<a name="2" id="anc2"></a><span class="line-removed">  60 #elif defined(__solaris__)</span>
<span class="line-removed">  61     #ifndef SIOCGLIFHWADDR</span>
<span class="line-removed">  62         #define SIOCGLIFHWADDR _IOWR(&#39;i&#39;, 192, struct lifreq)</span>
<span class="line-removed">  63     #endif</span>
<span class="line-removed">  64     #define DEV_PREFIX &quot;/dev/&quot;</span>
  65 #endif
  66 
  67 #ifdef LIFNAMSIZ
  68     #define IFNAMESIZE LIFNAMSIZ
  69 #else
  70     #define IFNAMESIZE IFNAMSIZ
  71 #endif
  72 
  73 #define CHECKED_MALLOC3(_pointer, _type, _size) \
  74     do { \
  75         _pointer = (_type)malloc(_size); \
  76         if (_pointer == NULL) { \
  77             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failed&quot;); \
  78             return ifs; /* return untouched list */ \
  79         } \
  80     } while(0)
  81 
  82 typedef struct _netaddr  {
  83     struct sockaddr *addr;
  84     struct sockaddr *brdcast;
  85     short mask;
  86     int family; /* to make searches simple */
  87     struct _netaddr *next;
  88 } netaddr;
  89 
  90 typedef struct _netif {
  91     char *name;
  92     int index;
  93     char virtual;
  94     netaddr *addr;
  95     struct _netif *childs;
  96     struct _netif *next;
  97 } netif;
  98 
  99 /************************************************************************
 100  * NetworkInterface
 101  */
 102 
 103 #include &quot;java_net_NetworkInterface.h&quot;
 104 
 105 /************************************************************************
 106  * NetworkInterface
 107  */
 108 jclass ni_class;
 109 jfieldID ni_nameID;
 110 jfieldID ni_indexID;
 111 jfieldID ni_descID;
 112 jfieldID ni_addrsID;
 113 jfieldID ni_bindsID;
 114 jfieldID ni_virutalID;
 115 jfieldID ni_childsID;
 116 jfieldID ni_parentID;
 117 jfieldID ni_defaultIndexID;
 118 jmethodID ni_ctrID;
 119 
 120 static jclass ni_ibcls;
 121 static jmethodID ni_ibctrID;
 122 static jfieldID ni_ibaddressID;
 123 static jfieldID ni_ib4broadcastID;
 124 static jfieldID ni_ib4maskID;
 125 
 126 /** Private methods declarations **/
 127 static jobject createNetworkInterface(JNIEnv *env, netif *ifs);
 128 static int     getFlags0(JNIEnv *env, jstring  ifname);
 129 
 130 static netif  *enumInterfaces(JNIEnv *env);
 131 static netif  *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs);
 132 static netif  *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs);
 133 
 134 static netif  *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 135                      struct sockaddr *ifr_addrP,
 136                      struct sockaddr *ifr_broadaddrP,
 137                      int family, short prefix);
 138 static void    freeif(netif *ifs);
 139 
 140 static int     openSocket(JNIEnv *env, int proto);
 141 static int     openSocketWithFallback(JNIEnv *env, const char *ifname);
 142 
 143 static short   translateIPv4AddressToPrefix(struct sockaddr_in *addr);
 144 static short   translateIPv6AddressToPrefix(struct sockaddr_in6 *addr);
 145 
 146 static int     getIndex(int sock, const char *ifname);
 147 static int     getFlags(int sock, const char *ifname, int *flags);
 148 static int     getMacAddress(JNIEnv *env, const char *ifname,
 149                              const struct in_addr *addr, unsigned char *buf);
 150 static int     getMTU(JNIEnv *env, int sock, const char *ifname);
 151 
<a name="3" id="anc3"></a><span class="line-removed"> 152 #if defined(__solaris__)</span>
<span class="line-removed"> 153 static int     getMacFromDevice(JNIEnv *env, const char *ifname,</span>
<span class="line-removed"> 154                                 unsigned char *retbuf);</span>
<span class="line-removed"> 155 #endif</span>
<span class="line-removed"> 156 </span>
 157 /******************* Java entry points *****************************/
 158 
 159 /*
 160  * Class:     java_net_NetworkInterface
 161  * Method:    init
 162  * Signature: ()V
 163  */
 164 JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init
 165   (JNIEnv *env, jclass cls)
 166 {
 167     ni_class = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 168     CHECK_NULL(ni_class);
 169     ni_class = (*env)-&gt;NewGlobalRef(env, ni_class);
 170     CHECK_NULL(ni_class);
 171     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 172     CHECK_NULL(ni_nameID);
 173     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 174     CHECK_NULL(ni_indexID);
 175     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;,
 176                                     &quot;[Ljava/net/InetAddress;&quot;);
 177     CHECK_NULL(ni_addrsID);
 178     ni_bindsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;bindings&quot;,
 179                                     &quot;[Ljava/net/InterfaceAddress;&quot;);
 180     CHECK_NULL(ni_bindsID);
 181     ni_descID = (*env)-&gt;GetFieldID(env, ni_class, &quot;displayName&quot;,
 182                                    &quot;Ljava/lang/String;&quot;);
 183     CHECK_NULL(ni_descID);
 184     ni_virutalID = (*env)-&gt;GetFieldID(env, ni_class, &quot;virtual&quot;, &quot;Z&quot;);
 185     CHECK_NULL(ni_virutalID);
 186     ni_childsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;childs&quot;,
 187                                      &quot;[Ljava/net/NetworkInterface;&quot;);
 188     CHECK_NULL(ni_childsID);
 189     ni_parentID = (*env)-&gt;GetFieldID(env, ni_class, &quot;parent&quot;,
 190                                      &quot;Ljava/net/NetworkInterface;&quot;);
 191     CHECK_NULL(ni_parentID);
 192     ni_ctrID = (*env)-&gt;GetMethodID(env, ni_class, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 193     CHECK_NULL(ni_ctrID);
 194     ni_ibcls = (*env)-&gt;FindClass(env, &quot;java/net/InterfaceAddress&quot;);
 195     CHECK_NULL(ni_ibcls);
 196     ni_ibcls = (*env)-&gt;NewGlobalRef(env, ni_ibcls);
 197     CHECK_NULL(ni_ibcls);
 198     ni_ibctrID = (*env)-&gt;GetMethodID(env, ni_ibcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 199     CHECK_NULL(ni_ibctrID);
 200     ni_ibaddressID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;address&quot;,
 201                                         &quot;Ljava/net/InetAddress;&quot;);
 202     CHECK_NULL(ni_ibaddressID);
 203     ni_ib4broadcastID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;broadcast&quot;,
 204                                            &quot;Ljava/net/Inet4Address;&quot;);
 205     CHECK_NULL(ni_ib4broadcastID);
 206     ni_ib4maskID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;maskLength&quot;, &quot;S&quot;);
 207     CHECK_NULL(ni_ib4maskID);
 208     ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, ni_class, &quot;defaultIndex&quot;,
 209                                                  &quot;I&quot;);
 210     CHECK_NULL(ni_defaultIndexID);
 211     initInetAddressIDs(env);
 212 }
 213 
 214 /*
 215  * Class:     java_net_NetworkInterface
 216  * Method:    getByName0
 217  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 218  */
 219 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0
 220   (JNIEnv *env, jclass cls, jstring name)
 221 {
 222     netif *ifs, *curr;
 223     jboolean isCopy;
 224     const char* name_utf;
 225     char *colonP;
 226     char searchName[IFNAMESIZE];
 227     jobject obj = NULL;
 228 
 229     if (name != NULL) {
 230         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 231     } else {
 232         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 233         return NULL;
 234     }
 235 
 236     if (name_utf == NULL) {
 237         if (!(*env)-&gt;ExceptionCheck(env))
 238             JNU_ThrowOutOfMemoryError(env, NULL);
 239         return NULL;
 240     }
 241 
 242     ifs = enumInterfaces(env);
 243     if (ifs == NULL) {
 244         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 245         return NULL;
 246     }
 247 
 248     // search the list of interfaces based on name,
 249     // if it is virtual sub interface search with parent first.
 250     strncpy(searchName, name_utf, IFNAMESIZE);
 251     searchName[IFNAMESIZE - 1] = &#39;\0&#39;;
 252     colonP = strchr(searchName, &#39;:&#39;);
 253     if (colonP != NULL) {
 254         *colonP = &#39;\0&#39;;
 255     }
 256     curr = ifs;
 257     while (curr != NULL) {
 258         if (strcmp(searchName, curr-&gt;name) == 0) {
 259             break;
 260         }
 261         curr = curr-&gt;next;
 262     }
 263 
 264     // search the child list
 265     if (colonP != NULL &amp;&amp; curr != NULL) {
 266         curr = curr-&gt;childs;
 267         while (curr != NULL) {
 268             if (strcmp(name_utf, curr-&gt;name) == 0) {
 269                 break;
 270             }
 271             curr = curr-&gt;next;
 272         }
 273     }
 274 
 275     // if found create a NetworkInterface
 276     if (curr != NULL) {
 277         obj = createNetworkInterface(env, curr);
 278     }
 279 
 280     // release the UTF string and interface list
 281     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 282     freeif(ifs);
 283 
 284     return obj;
 285 }
 286 
 287 /*
 288  * Class:     java_net_NetworkInterface
 289  * Method:    getByIndex0
 290  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 291  */
 292 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0
 293   (JNIEnv *env, jclass cls, jint index)
 294 {
 295     netif *ifs, *curr;
 296     jobject obj = NULL;
 297 
 298     if (index &lt;= 0) {
 299         return NULL;
 300     }
 301 
 302     ifs = enumInterfaces(env);
 303     if (ifs == NULL) {
 304         return NULL;
 305     }
 306 
 307     // search the list of interfaces based on index
 308     curr = ifs;
 309     while (curr != NULL) {
 310         if (index == curr-&gt;index) {
 311             break;
 312         }
 313         curr = curr-&gt;next;
 314     }
 315 
 316     // if found create a NetworkInterface
 317     if (curr != NULL) {
 318         obj = createNetworkInterface(env, curr);
 319     }
 320 
 321     // release the interface list
 322     freeif(ifs);
 323 
 324     return obj;
 325 }
 326 
 327 // Return the interface in ifs that iaObj is bound to, if any - otherwise NULL
 328 static netif* find_bound_interface(JNIEnv *env, netif* ifs, jobject iaObj, int family) {
 329     netif* curr = ifs;
 330     while (curr != NULL) {
 331         netaddr *addrP = curr-&gt;addr;
 332 
 333         // iterate through each address on the interface
 334         while (addrP != NULL) {
 335 
 336             if (family == addrP-&gt;family) {
 337                 if (family == AF_INET) {
 338                     int address1 = htonl(
 339                         ((struct sockaddr_in *)addrP-&gt;addr)-&gt;sin_addr.s_addr);
 340                     int address2 = getInetAddress_addr(env, iaObj);
 341                     if ((*env)-&gt;ExceptionCheck(env)) {
 342                         return NULL;
 343                     }
 344                     if (address1 == address2) {
 345                         return curr;
 346                     }
 347                 } else if (family == AF_INET6) {
 348                     jbyte *bytes = (jbyte *)&amp;(
 349                         ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr);
 350                     jbyte caddr[16];
 351                     int i;
 352                     unsigned int scopeid;
 353                     getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 354                     scopeid = (unsigned int)getInet6Address_scopeid(env, iaObj);
 355                     if (scopeid != 0 &amp;&amp; scopeid != ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id)
 356                         break;
 357                     i = 0;
 358                     while (i &lt; 16) {
 359                         if (caddr[i] != bytes[i]) {
 360                             break;
 361                         }
 362                         i++;
 363                     }
 364                     if (i &gt;= 16) {
 365                         return curr;
 366                     }
 367                 }
 368             }
 369 
 370             addrP = addrP-&gt;next;
 371         }
 372         curr = curr-&gt;next;
 373     }
 374 
 375     return NULL;
 376 }
 377 
 378 /*
 379  * Class:     java_net_NetworkInterface
 380  * Method:    boundInetAddress0
 381  * Signature: (Ljava/net/InetAddress;)boundInetAddress;
 382  */
 383 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0
 384     (JNIEnv *env, jclass cls, jobject iaObj)
 385 {
 386     netif *ifs = NULL;
 387     jboolean bound = JNI_FALSE;
 388     int sock;
 389 
 390     int family = getInetAddress_family(env, iaObj);
 391     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 392 
 393     if (family == java_net_InetAddress_IPv4) {
 394         family = AF_INET;
 395     } else if (family == java_net_InetAddress_IPv6) {
 396         family = AF_INET6;
 397     } else {
 398         return JNI_FALSE; // Invalid family
 399     }
 400 
 401     if (family == AF_INET) {
 402         sock = openSocket(env, AF_INET);
 403         if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {
 404             return JNI_FALSE;
 405         }
 406 
 407         // enumerate IPv4 addresses
 408         if (sock &gt;= 0) {
 409             ifs = enumIPv4Interfaces(env, sock, ifs);
 410             close(sock);
 411 
 412             if ((*env)-&gt;ExceptionOccurred(env)) {
 413                 goto cleanup;
 414             }
 415         }
 416         if (find_bound_interface(env, ifs, iaObj, family) != NULL)
 417             bound = JNI_TRUE;
 418     } else if (ipv6_available()) {
 419         // If IPv6 is available then enumerate IPv6 addresses.
 420         // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 421         // so we have to call ipv6_available()
 422         sock = openSocket(env, AF_INET6);
 423         if (sock &lt; 0) {
 424             return JNI_FALSE;
 425         }
 426 
 427         ifs = enumIPv6Interfaces(env, sock, ifs);
 428         close(sock);
 429 
 430         if ((*env)-&gt;ExceptionOccurred(env)) {
 431             goto cleanup;
 432         }
 433 
 434         if (find_bound_interface(env, ifs, iaObj, family) != NULL)
 435             bound = JNI_TRUE;
 436     }
 437 
 438 cleanup:
 439     freeif(ifs);
 440 
 441     return bound;
 442 }
 443 
 444 /*
 445  * Class:     java_net_NetworkInterface
 446  * Method:    getByInetAddress0
 447  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
 448  */
 449 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
 450   (JNIEnv *env, jclass cls, jobject iaObj)
 451 {
 452     netif *ifs, *curr;
 453     jobject obj = NULL;
 454     int family = getInetAddress_family(env, iaObj);
 455     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 456 
 457     if (family == java_net_InetAddress_IPv4) {
 458         family = AF_INET;
 459     } else if (family == java_net_InetAddress_IPv6) {
 460         family = AF_INET6;
 461     } else {
 462         return NULL; // Invalid family
 463     }
 464     ifs = enumInterfaces(env);
 465     if (ifs == NULL) {
 466         return NULL;
 467     }
 468 
 469     curr = find_bound_interface(env, ifs, iaObj, family);
 470 
 471     // if found create a NetworkInterface
 472     if (curr != NULL) {
 473         obj = createNetworkInterface(env, curr);
 474     }
 475 
 476     // release the interface list
 477     freeif(ifs);
 478 
 479     return obj;
 480 }
 481 
 482 /*
 483  * Class:     java_net_NetworkInterface
 484  * Method:    getAll
 485  * Signature: ()[Ljava/net/NetworkInterface;
 486  */
 487 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 488   (JNIEnv *env, jclass cls)
 489 {
 490     netif *ifs, *curr;
 491     jobjectArray netIFArr;
 492     jint arr_index, ifCount;
 493 
 494     ifs = enumInterfaces(env);
 495     if (ifs == NULL) {
 496         return NULL;
 497     }
 498 
 499     // count the interfaces
 500     ifCount = 0;
 501     curr = ifs;
 502     while (curr != NULL) {
 503         ifCount++;
 504         curr = curr-&gt;next;
 505     }
 506 
 507     // allocate a NetworkInterface array
 508     netIFArr = (*env)-&gt;NewObjectArray(env, ifCount, cls, NULL);
 509     if (netIFArr == NULL) {
 510         freeif(ifs);
 511         return NULL;
 512     }
 513 
 514     // iterate through the interfaces, create a NetworkInterface instance
 515     // for each array element and populate the object
 516     curr = ifs;
 517     arr_index = 0;
 518     while (curr != NULL) {
 519         jobject netifObj;
 520 
 521         netifObj = createNetworkInterface(env, curr);
 522         if (netifObj == NULL) {
 523             freeif(ifs);
 524             return NULL;
 525         }
 526 
 527         // put the NetworkInterface into the array
 528         (*env)-&gt;SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);
 529 
 530         curr = curr-&gt;next;
 531     }
 532 
 533     // release the interface list
 534     freeif(ifs);
 535 
 536     return netIFArr;
 537 }
 538 
 539 /*
 540  * Class:     java_net_NetworkInterface
 541  * Method:    isUp0
 542  * Signature: (Ljava/lang/String;I)Z
 543  */
 544 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0
 545   (JNIEnv *env, jclass cls, jstring name, jint index)
 546 {
 547     int ret = getFlags0(env, name);
 548     return ((ret &amp; IFF_UP) &amp;&amp; (ret &amp; IFF_RUNNING)) ? JNI_TRUE :  JNI_FALSE;
 549 }
 550 
 551 /*
 552  * Class:     java_net_NetworkInterface
 553  * Method:    isP2P0
 554  * Signature: (Ljava/lang/String;I)Z
 555  */
 556 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0
 557   (JNIEnv *env, jclass cls, jstring name, jint index)
 558 {
 559     int ret = getFlags0(env, name);
 560     return (ret &amp; IFF_POINTOPOINT) ? JNI_TRUE :  JNI_FALSE;
 561 }
 562 
 563 /*
 564  * Class:     java_net_NetworkInterface
 565  * Method:    isLoopback0
 566  * Signature: (Ljava/lang/String;I)Z
 567  */
 568 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0
 569   (JNIEnv *env, jclass cls, jstring name, jint index)
 570 {
 571     int ret = getFlags0(env, name);
 572     return (ret &amp; IFF_LOOPBACK) ? JNI_TRUE :  JNI_FALSE;
 573 }
 574 
 575 /*
 576  * Class:     java_net_NetworkInterface
 577  * Method:    supportsMulticast0
 578  * Signature: (Ljava/lang/String;I)Z
 579  */
 580 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0
 581   (JNIEnv *env, jclass cls, jstring name, jint index)
 582 {
 583     int ret = getFlags0(env, name);
 584     return (ret &amp; IFF_MULTICAST) ? JNI_TRUE :  JNI_FALSE;
 585 }
 586 
 587 /*
 588  * Class:     java_net_NetworkInterface
 589  * Method:    getMacAddr0
 590  * Signature: ([bLjava/lang/String;I)[b
 591  */
 592 JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0
 593   (JNIEnv *env, jclass cls, jbyteArray addrArray, jstring name, jint index)
 594 {
 595     jint addr;
 596     jbyte caddr[4];
 597     struct in_addr iaddr;
 598     jbyteArray ret = NULL;
 599     unsigned char mac[16];
 600     int len;
 601     jboolean isCopy;
 602     const char *name_utf;
 603 
 604     if (name != NULL) {
 605         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 606     } else {
 607         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 608         return NULL;
 609     }
 610 
 611     if (name_utf == NULL) {
 612         if (!(*env)-&gt;ExceptionCheck(env))
 613             JNU_ThrowOutOfMemoryError(env, NULL);
 614         return NULL;
 615     }
 616 
 617     if (!IS_NULL(addrArray)) {
 618         (*env)-&gt;GetByteArrayRegion(env, addrArray, 0, 4, caddr);
 619         addr = ((caddr[0]&lt;&lt;24) &amp; 0xff000000);
 620         addr |= ((caddr[1] &lt;&lt;16) &amp; 0xff0000);
 621         addr |= ((caddr[2] &lt;&lt;8) &amp; 0xff00);
 622         addr |= (caddr[3] &amp; 0xff);
 623         iaddr.s_addr = htonl(addr);
 624         len = getMacAddress(env, name_utf, &amp;iaddr, mac);
 625     } else {
 626         len = getMacAddress(env, name_utf, NULL, mac);
 627     }
 628 
 629     if (len &gt; 0) {
 630         ret = (*env)-&gt;NewByteArray(env, len);
 631         if (!IS_NULL(ret)) {
 632             (*env)-&gt;SetByteArrayRegion(env, ret, 0, len, (jbyte *)(mac));
 633         }
 634     }
 635 
 636     // release the UTF string and interface list
 637     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 638 
 639     return ret;
 640 }
 641 
 642 /*
 643  * Class:       java_net_NetworkInterface
 644  * Method:      getMTU0
 645  * Signature:   ([bLjava/lang/String;I)I
 646  */
 647 JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0
 648   (JNIEnv *env, jclass cls, jstring name, jint index)
 649 {
 650     jboolean isCopy;
 651     int sock, ret = -1;
 652     const char* name_utf = NULL;
 653 
 654     if (name != NULL) {
 655         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 656     } else {
 657         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 658         return ret;
 659     }
 660 
 661     if (name_utf == NULL) {
 662         if (!(*env)-&gt;ExceptionCheck(env))
 663             JNU_ThrowOutOfMemoryError(env, NULL);
 664         return ret;
 665     }
 666 
 667     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 668         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 669         return JNI_FALSE;
 670     }
 671 
 672     ret = getMTU(env, sock, name_utf);
 673 
 674     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 675 
 676     close(sock);
 677     return ret;
 678 }
 679 
 680 /*** Private methods definitions ****/
 681 
 682 static int getFlags0(JNIEnv *env, jstring name) {
 683     jboolean isCopy;
 684     int ret, sock, flags = 0;
 685     const char *name_utf;
 686 
 687     if (name != NULL) {
 688         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 689     } else {
 690         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 691         return -1;
 692     }
 693 
 694     if (name_utf == NULL) {
 695         if (!(*env)-&gt;ExceptionCheck(env))
 696             JNU_ThrowOutOfMemoryError(env, NULL);
 697         return -1;
 698     }
 699     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 700         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 701         return -1;
 702     }
 703 
 704     ret = getFlags(sock, name_utf, &amp;flags);
 705 
 706     close(sock);
 707     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 708 
 709     if (ret &lt; 0) {
 710         JNU_ThrowByNameWithMessageAndLastError
 711             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getFlags() failed&quot;);
 712         return -1;
 713     }
 714 
 715     return flags;
 716 }
 717 
 718 /*
 719  * Creates a NetworkInterface object, populates the name, the index, and
 720  * populates the InetAddress array based on the IP addresses for this
 721  * interface.
 722  */
 723 static jobject createNetworkInterface(JNIEnv *env, netif *ifs) {
 724     jobject netifObj;
 725     jobject name;
 726     jobjectArray addrArr;
 727     jobjectArray bindArr;
 728     jobjectArray childArr;
 729     netaddr *addrs;
 730     jint addr_index, addr_count, bind_index;
 731     jint child_count, child_index;
 732     netaddr *addrP;
 733     netif *childP;
 734     jobject tmp;
 735 
 736     // create a NetworkInterface object and populate it
 737     netifObj = (*env)-&gt;NewObject(env, ni_class, ni_ctrID);
 738     CHECK_NULL_RETURN(netifObj, NULL);
 739     name = (*env)-&gt;NewStringUTF(env, ifs-&gt;name);
 740     CHECK_NULL_RETURN(name, NULL);
 741     (*env)-&gt;SetObjectField(env, netifObj, ni_nameID, name);
 742     (*env)-&gt;SetObjectField(env, netifObj, ni_descID, name);
 743     (*env)-&gt;SetIntField(env, netifObj, ni_indexID, ifs-&gt;index);
 744     (*env)-&gt;SetBooleanField(env, netifObj, ni_virutalID,
 745                             ifs-&gt;virtual ? JNI_TRUE : JNI_FALSE);
 746 
 747     // count the number of addresses on this interface
 748     addr_count = 0;
 749     addrP = ifs-&gt;addr;
 750     while (addrP != NULL) {
 751         addr_count++;
 752         addrP = addrP-&gt;next;
 753     }
 754 
 755     // create the array of InetAddresses
 756     addrArr = (*env)-&gt;NewObjectArray(env, addr_count, ia_class, NULL);
 757     if (addrArr == NULL) {
 758         return NULL;
 759     }
 760 
 761     bindArr = (*env)-&gt;NewObjectArray(env, addr_count, ni_ibcls, NULL);
 762     if (bindArr == NULL) {
 763        return NULL;
 764     }
 765     addrP = ifs-&gt;addr;
 766     addr_index = 0;
 767     bind_index = 0;
 768     while (addrP != NULL) {
 769         jobject iaObj = NULL;
 770         jobject ibObj = NULL;
 771 
 772         if (addrP-&gt;family == AF_INET) {
 773             iaObj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 774             if (iaObj) {
 775                 setInetAddress_addr(env, iaObj, htonl(
 776                     ((struct sockaddr_in*)addrP-&gt;addr)-&gt;sin_addr.s_addr));
 777                 JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 778             } else {
 779                 return NULL;
 780             }
 781             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 782             if (ibObj) {
 783                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 784                 if (addrP-&gt;brdcast) {
 785                     jobject ia2Obj = NULL;
 786                     ia2Obj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 787                     if (ia2Obj) {
 788                         setInetAddress_addr(env, ia2Obj, htonl(
 789                             ((struct sockaddr_in*)addrP-&gt;brdcast)-&gt;sin_addr.s_addr));
 790                         JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 791                         (*env)-&gt;SetObjectField(env, ibObj, ni_ib4broadcastID, ia2Obj);
 792                     } else {
 793                         return NULL;
 794                     }
 795                 }
 796                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 797                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 798             } else {
 799                 return NULL;
 800             }
 801         }
 802         if (addrP-&gt;family == AF_INET6) {
 803             int scope=0;
 804             iaObj = (*env)-&gt;NewObject(env, ia6_class, ia6_ctrID);
 805             if (iaObj) {
 806                 jboolean ret = setInet6Address_ipaddress(env, iaObj,
 807                     (char *)&amp;(((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr));
 808                 if (ret == JNI_FALSE) {
 809                     return NULL;
 810                 }
 811 
 812                 scope = ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id;
 813 
 814                 if (scope != 0) { /* zero is default value, no need to set */
 815                     setInet6Address_scopeid(env, iaObj, scope);
 816                     setInet6Address_scopeifname(env, iaObj, netifObj);
 817                 }
 818             } else {
 819                 return NULL;
 820             }
 821             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 822             if (ibObj) {
 823                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 824                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 825                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 826             } else {
 827                 return NULL;
 828             }
 829         }
 830 
 831         (*env)-&gt;SetObjectArrayElement(env, addrArr, addr_index++, iaObj);
 832         addrP = addrP-&gt;next;
 833     }
 834 
 835     // see if there is any virtual interface attached to this one.
 836     child_count = 0;
 837     childP = ifs-&gt;childs;
 838     while (childP) {
 839         child_count++;
 840         childP = childP-&gt;next;
 841     }
 842 
 843     childArr = (*env)-&gt;NewObjectArray(env, child_count, ni_class, NULL);
 844     if (childArr == NULL) {
 845         return NULL;
 846     }
 847 
 848     // create the NetworkInterface instances for the sub-interfaces as well
 849     child_index = 0;
 850     childP = ifs-&gt;childs;
 851     while(childP) {
 852         tmp = createNetworkInterface(env, childP);
 853         if (tmp == NULL) {
 854             return NULL;
 855         }
 856         (*env)-&gt;SetObjectField(env, tmp, ni_parentID, netifObj);
 857         (*env)-&gt;SetObjectArrayElement(env, childArr, child_index++, tmp);
 858         childP = childP-&gt;next;
 859     }
 860     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
 861     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindArr);
 862     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
 863 
 864     // return the NetworkInterface
 865     return netifObj;
 866 }
 867 
 868 /*
 869  * Enumerates all interfaces
 870  */
 871 static netif *enumInterfaces(JNIEnv *env) {
 872     netif *ifs = NULL;
 873     int sock;
 874 
 875     sock = openSocket(env, AF_INET);
 876     if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {
 877         return NULL;
 878     }
 879 
 880     // enumerate IPv4 addresses
 881     if (sock &gt;= 0) {
 882         ifs = enumIPv4Interfaces(env, sock, ifs);
 883         close(sock);
 884 
 885         if ((*env)-&gt;ExceptionOccurred(env)) {
 886             freeif(ifs);
 887             return NULL;
 888         }
 889     }
 890 
 891     // If IPv6 is available then enumerate IPv6 addresses.
 892     // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 893     // so we have to call ipv6_available()
 894     if (ipv6_available()) {
 895         sock = openSocket(env, AF_INET6);
 896         if (sock &lt; 0) {
 897             freeif(ifs);
 898             return NULL;
 899         }
 900 
 901         ifs = enumIPv6Interfaces(env, sock, ifs);
 902         close(sock);
 903 
 904         if ((*env)-&gt;ExceptionOccurred(env)) {
 905             freeif(ifs);
 906             return NULL;
 907         }
 908     }
 909 
 910     return ifs;
 911 }
 912 
 913 /*
 914  * Frees an interface list (including any attached addresses).
 915  */
 916 static void freeif(netif *ifs) {
 917     netif *currif = ifs;
 918     netif *child = NULL;
 919 
 920     while (currif != NULL) {
 921         netaddr *addrP = currif-&gt;addr;
 922         while (addrP != NULL) {
 923             netaddr *next = addrP-&gt;next;
 924             free(addrP);
 925             addrP = next;
 926         }
 927 
 928         // don&#39;t forget to free the sub-interfaces
 929         if (currif-&gt;childs != NULL) {
 930             freeif(currif-&gt;childs);
 931         }
 932 
 933         ifs = currif-&gt;next;
 934         free(currif);
 935         currif = ifs;
 936     }
 937 }
 938 
 939 static netif *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 940                     struct sockaddr *ifr_addrP,
 941                     struct sockaddr *ifr_broadaddrP,
 942                     int family, short prefix)
 943 {
 944     netif *currif = ifs, *parent;
 945     netaddr *addrP;
 946     char name[IFNAMESIZE], vname[IFNAMESIZE];
 947     char *name_colonP;
 948     int isVirtual = 0;
 949     int addr_size;
 950 
 951     // If the interface name is a logical interface then we remove the unit
 952     // number so that we have the physical interface (eg: hme0:1 -&gt; hme0).
 953     // NetworkInterface currently doesn&#39;t have any concept of physical vs.
 954     // logical interfaces.
 955     strncpy(name, if_name, IFNAMESIZE);
 956     name[IFNAMESIZE - 1] = &#39;\0&#39;;
 957     *vname = 0;
 958 
 959     // Create and populate the netaddr node. If allocation fails
 960     // return an un-updated list.
 961 
 962     // Allocate for addr and brdcast at once
 963 
 964     addr_size = (family == AF_INET) ? sizeof(struct sockaddr_in)
 965                                     : sizeof(struct sockaddr_in6);
 966 
 967     CHECKED_MALLOC3(addrP, netaddr *, sizeof(netaddr) + 2 * addr_size);
 968     addrP-&gt;addr = (struct sockaddr *)((char *)addrP + sizeof(netaddr));
 969     memcpy(addrP-&gt;addr, ifr_addrP, addr_size);
 970 
 971     addrP-&gt;family = family;
 972     addrP-&gt;mask = prefix;
 973     addrP-&gt;next = 0;
 974 
 975     // for IPv4 add broadcast address
 976     if (family == AF_INET &amp;&amp; ifr_broadaddrP != NULL) {
 977         addrP-&gt;brdcast = (struct sockaddr *)
 978                              ((char *)addrP + sizeof(netaddr) + addr_size);
 979         memcpy(addrP-&gt;brdcast, ifr_broadaddrP, addr_size);
 980     } else {
 981         addrP-&gt;brdcast = NULL;
 982     }
 983 
 984     // Deal with virtual interface with colon notation e.g. eth0:1
 985     name_colonP = strchr(name, &#39;:&#39;);
 986     if (name_colonP != NULL) {
 987         int flags = 0;
 988         // This is a virtual interface. If we are able to access the parent
 989         // we need to create a new entry if it doesn&#39;t exist yet *and* update
 990         // the &#39;parent&#39; interface with the new records.
 991         *name_colonP = 0;
 992         if (getFlags(sock, name, &amp;flags) &lt; 0 || flags &lt; 0) {
 993             // failed to access parent interface do not create parent.
 994             // We are a virtual interface with no parent.
 995             isVirtual = 1;
 996             *name_colonP = &#39;:&#39;;
 997         } else {
 998             // Got access to parent, so create it if necessary.
 999             // Save original name to vname and truncate name by &#39;:&#39;
1000             memcpy(vname, name, sizeof(vname));
1001             vname[name_colonP - name] = &#39;:&#39;;
1002         }
1003     }
1004 
1005     // Check if this is a &quot;new&quot; interface. Use the interface name for
1006     // matching because index isn&#39;t supported on Solaris 2.6 &amp; 7.
1007     while (currif != NULL) {
1008         if (strcmp(name, currif-&gt;name) == 0) {
1009             break;
1010         }
1011         currif = currif-&gt;next;
1012     }
1013 
1014     // If &quot;new&quot; then create a netif structure and insert it into the list.
1015     if (currif == NULL) {
1016          CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
1017          currif-&gt;name = (char *)currif + sizeof(netif);
1018          strncpy(currif-&gt;name, name, IFNAMESIZE);
1019          currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
1020          currif-&gt;index = getIndex(sock, name);
1021          currif-&gt;addr = NULL;
1022          currif-&gt;childs = NULL;
1023          currif-&gt;virtual = isVirtual;
1024          currif-&gt;next = ifs;
1025          ifs = currif;
1026     }
1027 
1028     // Finally insert the address on the interface
1029     addrP-&gt;next = currif-&gt;addr;
1030     currif-&gt;addr = addrP;
1031 
1032     parent = currif;
1033 
1034     // Deal with the virtual interface now.
1035     if (vname[0]) {
1036         netaddr *tmpaddr;
1037 
1038         currif = parent-&gt;childs;
1039 
1040         while (currif != NULL) {
1041             if (strcmp(vname, currif-&gt;name) == 0) {
1042                 break;
1043             }
1044             currif = currif-&gt;next;
1045         }
1046 
1047         if (currif == NULL) {
1048             CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
1049             currif-&gt;name = (char *)currif + sizeof(netif);
1050             strncpy(currif-&gt;name, vname, IFNAMESIZE);
1051             currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
1052             currif-&gt;index = getIndex(sock, vname);
1053             currif-&gt;addr = NULL; // Need to duplicate the addr entry?
1054             currif-&gt;virtual = 1;
1055             currif-&gt;childs = NULL;
1056             currif-&gt;next = parent-&gt;childs;
1057             parent-&gt;childs = currif;
1058         }
1059 
1060         CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);
1061         memcpy(tmpaddr, addrP, sizeof(netaddr));
1062         if (addrP-&gt;addr != NULL) {
1063             tmpaddr-&gt;addr = (struct sockaddr *)
1064                 ((char*)tmpaddr + sizeof(netaddr));
1065             memcpy(tmpaddr-&gt;addr, addrP-&gt;addr, addr_size);
1066         }
1067 
1068         if (addrP-&gt;brdcast != NULL) {
1069             tmpaddr-&gt;brdcast = (struct sockaddr *)
1070                 ((char *)tmpaddr + sizeof(netaddr) + addr_size);
1071             memcpy(tmpaddr-&gt;brdcast, addrP-&gt;brdcast, addr_size);
1072         }
1073 
1074         tmpaddr-&gt;next = currif-&gt;addr;
1075         currif-&gt;addr = tmpaddr;
1076     }
1077 
1078     return ifs;
1079 }
1080 
1081 /*
1082  * Determines the prefix value for an AF_INET subnet address.
1083  */
1084 static short translateIPv4AddressToPrefix(struct sockaddr_in *addr) {
1085     short prefix = 0;
1086     unsigned int mask;
1087     if (addr == NULL) {
1088         return 0;
1089     }
1090     mask = ntohl(addr-&gt;sin_addr.s_addr);
1091     while (mask) {
1092         mask &lt;&lt;= 1;
1093         prefix++;
1094     }
1095     return prefix;
1096 }
1097 
1098 /*
1099  * Determines the prefix value for an AF_INET6 subnet address.
1100  */
1101 static short translateIPv6AddressToPrefix(struct sockaddr_in6 *addr) {
1102     short prefix = 0;
1103     u_char *addrBytes;
1104     if (addr == NULL) {
1105         return 0;
1106     }
1107     addrBytes = (u_char *)&amp;(addr-&gt;sin6_addr);
1108     unsigned int byte, bit;
1109 
1110     for (byte = 0; byte &lt; sizeof(struct in6_addr); byte++, prefix += 8) {
1111         if (addrBytes[byte] != 0xff) {
1112             break;
1113         }
1114     }
1115     if (byte != sizeof(struct in6_addr)) {
1116         for (bit = 7; bit != 0; bit--, prefix++) {
1117             if (!(addrBytes[byte] &amp; (1 &lt;&lt; bit))) {
1118                 break;
1119             }
1120         }
1121         for (; bit != 0; bit--) {
1122             if (addrBytes[byte] &amp; (1 &lt;&lt; bit)) {
1123                 prefix = 0;
1124                 break;
1125             }
1126         }
1127         if (prefix &gt; 0) {
1128             byte++;
1129             for (; byte &lt; sizeof(struct in6_addr); byte++) {
1130                 if (addrBytes[byte]) {
1131                     prefix = 0;
1132                 }
1133             }
1134         }
1135     }
1136 
1137     return prefix;
1138 }
1139 
1140 /*
1141  * Opens a socket for further ioct calls. proto is one of AF_INET or AF_INET6.
1142  */
1143 static int openSocket(JNIEnv *env, int proto) {
1144     int sock;
1145 
1146     if ((sock = socket(proto, SOCK_DGRAM, 0)) &lt; 0) {
1147         // If we lack support for this address family or protocol,
1148         // don&#39;t throw an exception.
1149         if (errno != EPROTONOSUPPORT &amp;&amp; errno != EAFNOSUPPORT) {
1150             JNU_ThrowByNameWithMessageAndLastError
1151                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Socket creation failed&quot;);
1152         }
1153         return -1;
1154     }
1155 
1156     return sock;
1157 }
1158 
1159 /** Linux **/
1160 #if defined(__linux__)
1161 
1162 /*
1163  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1164  * if it fails return AF_INET6 socket.
1165  */
1166 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1167     int sock;
1168 
1169     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1170         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1171             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1172                 JNU_ThrowByNameWithMessageAndLastError
1173                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1174                 return -1;
1175             }
1176         } else { // errno is not NOSUPPORT
1177             JNU_ThrowByNameWithMessageAndLastError
1178                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1179             return -1;
1180         }
1181     }
1182 
1183     // Linux starting from 2.6.? kernel allows ioctl call with either IPv4 or
1184     // IPv6 socket regardless of type of address of an interface.
1185     return sock;
1186 }
1187 
1188 /*
1189  * Enumerates and returns all IPv4 interfaces on Linux.
1190  */
1191 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1192     struct ifconf ifc;
1193     struct ifreq *ifreqP;
1194     char *buf = NULL;
1195     unsigned i;
1196 
1197     // do a dummy SIOCGIFCONF to determine the buffer size
1198     // SIOCGIFCOUNT doesn&#39;t work
1199     ifc.ifc_buf = NULL;
1200     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1201         JNU_ThrowByNameWithMessageAndLastError
1202             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1203         return ifs;
1204     }
1205 
1206     // call SIOCGIFCONF to enumerate the interfaces
1207     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1208     ifc.ifc_buf = buf;
1209     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1210         JNU_ThrowByNameWithMessageAndLastError
1211             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1212         free(buf);
1213         return ifs;
1214     }
1215 
1216     // iterate through each interface
1217     ifreqP = ifc.ifc_req;
1218     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1219         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1220         short prefix = 0;
1221 
1222         // ignore non IPv4 addresses
1223         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1224             continue;
1225         }
1226 
1227         // save socket address
1228         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1229 
1230         // determine broadcast address, if applicable
1231         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1232             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1233 
1234             // restore socket address to ifreqP
1235             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1236 
1237             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1238                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1239                        sizeof(struct sockaddr));
1240                 broadaddrP = &amp;broadaddr;
1241             }
1242         }
1243 
1244         // restore socket address to ifreqP
1245         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1246 
1247         // determine netmask
1248         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1249             prefix = translateIPv4AddressToPrefix(
1250                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_netmask));
1251         }
1252 
1253         // add interface to the list
1254         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1255                     &amp;addr, broadaddrP, AF_INET, prefix);
1256 
1257         // in case of exception, free interface list and buffer and return NULL
1258         if ((*env)-&gt;ExceptionOccurred(env)) {
1259             free(buf);
1260             freeif(ifs);
1261             return NULL;
1262         }
1263     }
1264 
1265     // free buffer
1266     free(buf);
1267     return ifs;
1268 }
1269 
1270 /*
1271  * Enumerates and returns all IPv6 interfaces on Linux.
1272  */
1273 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1274     FILE *f;
1275     char devname[21], addr6p[8][5];
1276     int prefix, scope, dad_status, if_idx;
1277 
1278     if ((f = fopen(_PATH_PROCNET_IFINET6, &quot;r&quot;)) != NULL) {
1279         while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,
1280                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1281                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],
1282                       &amp;if_idx, &amp;prefix, &amp;scope, &amp;dad_status, devname) != EOF) {
1283 
1284             char addr6[40];
1285             struct sockaddr_in6 addr;
1286 
1287             sprintf(addr6, &quot;%s:%s:%s:%s:%s:%s:%s:%s&quot;,
1288                     addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1289                     addr6p[4], addr6p[5], addr6p[6], addr6p[7]);
1290 
1291             memset(&amp;addr, 0, sizeof(struct sockaddr_in6));
1292             inet_pton(AF_INET6, addr6, (void*)addr.sin6_addr.s6_addr);
1293 
1294             // set scope ID to interface index
1295             addr.sin6_scope_id = if_idx;
1296 
1297             // add interface to the list
1298             ifs = addif(env, sock, devname, ifs, (struct sockaddr *)&amp;addr,
1299                         NULL, AF_INET6, (short)prefix);
1300 
1301             // if an exception occurred then return the list as is
1302             if ((*env)-&gt;ExceptionOccurred(env)) {
1303                 break;
1304             }
1305        }
1306        fclose(f);
1307     }
1308     return ifs;
1309 }
1310 
1311 /*
1312  * Try to get the interface index.
1313  */
1314 static int getIndex(int sock, const char *name) {
1315     struct ifreq if2;
1316     memset((char *)&amp;if2, 0, sizeof(if2));
1317     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
1318 
1319     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
1320         return -1;
1321     }
1322 
1323     return if2.ifr_ifindex;
1324 }
1325 
1326 /*
1327  * Gets the Hardware address (usually MAC address) for the named interface.
1328  * On return puts the data in buf, and returns the length, in byte, of the
1329  * MAC address. Returns -1 if there is no hardware address on that interface.
1330  */
1331 static int getMacAddress
1332   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1333    unsigned char *buf)
1334 {
1335     struct ifreq ifr;
1336     int i, sock;
1337 
1338     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {
1339         return -1;
1340     }
1341 
1342     memset((char *)&amp;ifr, 0, sizeof(ifr));
1343     strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
1344     if (ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; 0) {
1345         JNU_ThrowByNameWithMessageAndLastError
1346             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFHWADDR) failed&quot;);
1347         close(sock);
1348         return -1;
1349     }
1350 
1351     close(sock);
1352     memcpy(buf, &amp;ifr.ifr_hwaddr.sa_data, IFHWADDRLEN);
1353 
1354     // all bytes to 0 means no hardware address
1355     for (i = 0; i &lt; IFHWADDRLEN; i++) {
1356         if (buf[i] != 0)
1357             return IFHWADDRLEN;
1358     }
1359 
1360     return -1;
1361 }
1362 
1363 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1364     struct ifreq if2;
1365     memset((char *)&amp;if2, 0, sizeof(if2));
1366     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1367 
1368     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1369         JNU_ThrowByNameWithMessageAndLastError
1370             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1371         return -1;
1372     }
1373 
1374     return if2.ifr_mtu;
1375 }
1376 
1377 static int getFlags(int sock, const char *ifname, int *flags) {
1378     struct ifreq if2;
1379     memset((char *)&amp;if2, 0, sizeof(if2));
1380     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1381 
1382     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1383         return -1;
1384     }
1385 
1386     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1387         *flags = (if2.ifr_flags &amp; 0xffff);
1388     } else {
1389         *flags = if2.ifr_flags;
1390     }
1391     return 0;
1392 }
1393 
1394 #endif /* __linux__ */
1395 
1396 /** AIX **/
1397 #if defined(_AIX)
1398 
1399 /* seems getkerninfo is guarded by _KERNEL in the system headers */
1400 /* see net/proto_uipc.h */
1401 int getkerninfo(int, char *, int *, int32long64_t);
1402 
1403 /*
1404  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1405  * if it fails return AF_INET6 socket.
1406  */
1407 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1408     int sock;
1409 
1410     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1411         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1412             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1413                 JNU_ThrowByNameWithMessageAndLastError
1414                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1415                 return -1;
1416             }
1417         } else { // errno is not NOSUPPORT
1418             JNU_ThrowByNameWithMessageAndLastError
1419                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1420             return -1;
1421         }
1422     }
1423 
1424     return sock;
1425 }
1426 
1427 /*
1428  * Enumerates and returns all IPv4 interfaces on AIX.
1429  */
1430 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1431     struct ifconf ifc;
1432     struct ifreq *ifreqP;
1433     char *buf = NULL;
1434     unsigned i;
1435 
1436     // call SIOCGSIZIFCONF to get the size of SIOCGIFCONF buffer
1437     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1438         JNU_ThrowByNameWithMessageAndLastError
1439             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1440         return ifs;
1441     }
1442 
1443     // call CSIOCGIFCONF instead of SIOCGIFCONF where interface
1444     // records will always have sizeof(struct ifreq) length.
1445     // Be aware that only IPv4 data is complete this way.
1446     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1447     ifc.ifc_buf = buf;
1448     if (ioctl(sock, CSIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1449         JNU_ThrowByNameWithMessageAndLastError
1450             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(CSIOCGIFCONF) failed&quot;);
1451         free(buf);
1452         return ifs;
1453     }
1454 
1455     // iterate through each interface
1456     ifreqP = ifc.ifc_req;
1457     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1458         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1459         short prefix = 0;
1460 
1461         // ignore non IPv4 addresses
1462         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1463             continue;
1464         }
1465 
1466         // save socket address
1467         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1468 
1469         // determine broadcast address, if applicable
1470         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1471             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1472 
1473             // restore socket address to ifreqP
1474             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1475 
1476             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1477                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1478                        sizeof(struct sockaddr));
1479                 broadaddrP = &amp;broadaddr;
1480             }
1481         }
1482 
1483         // restore socket address to ifreqP
1484         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1485 
1486         // determine netmask
1487         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1488             prefix = translateIPv4AddressToPrefix(
1489                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_addr));
1490         }
1491 
1492         // add interface to the list
1493         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1494                     &amp;addr, broadaddrP, AF_INET, prefix);
1495 
1496         // in case of exception, free interface list and buffer and return NULL
1497         if ((*env)-&gt;ExceptionOccurred(env)) {
1498             free(buf);
1499             freeif(ifs);
1500             return NULL;
1501         }
1502     }
1503 
1504     // free buffer
1505     free(buf);
1506     return ifs;
1507 }
1508 
1509 /*
1510  * Enumerates and returns all IPv6 interfaces on AIX.
1511  */
1512 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1513     struct ifconf ifc;
1514     struct ifreq *ifreqP;
1515     char *buf, *cp, *cplimit;
1516 
1517     // call SIOCGSIZIFCONF to get size for SIOCGIFCONF buffer
1518     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1519         JNU_ThrowByNameWithMessageAndLastError
1520             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1521         return ifs;
1522     }
1523 
1524     // call SIOCGIFCONF to enumerate the interfaces
1525     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1526     ifc.ifc_buf = buf;
1527     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1528         JNU_ThrowByNameWithMessageAndLastError
1529             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1530         free(buf);
1531         return ifs;
1532     }
1533 
1534     // iterate through each interface
1535     ifreqP = ifc.ifc_req;
1536     cp = (char *)ifc.ifc_req;
1537     cplimit = cp + ifc.ifc_len;
1538 
1539     for (; cp &lt; cplimit;
1540          cp += (sizeof(ifreqP-&gt;ifr_name) +
1541                 MAX((ifreqP-&gt;ifr_addr).sa_len, sizeof(ifreqP-&gt;ifr_addr))))
1542     {
1543         ifreqP = (struct ifreq *)cp;
1544         short prefix = 0;
1545 
1546         // ignore non IPv6 addresses
1547         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET6) {
1548             continue;
1549         }
1550 
1551         // determine netmask
1552         struct in6_ifreq if6;
1553         memset((char *)&amp;if6, 0, sizeof(if6));
1554         strncpy(if6.ifr_name, ifreqP-&gt;ifr_name, sizeof(if6.ifr_name) - 1);
1555         memcpy(&amp;(if6.ifr_Addr), &amp;(ifreqP-&gt;ifr_addr),
1556                sizeof(struct sockaddr_in6));
1557         if (ioctl(sock, SIOCGIFNETMASK6, (char *)&amp;if6) &gt;= 0) {
1558             prefix = translateIPv6AddressToPrefix(&amp;(if6.ifr_Addr));
1559         }
1560 
1561         // set scope ID to interface index
1562         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;ifr_addr))-&gt;sin6_scope_id =
1563             getIndex(sock, ifreqP-&gt;ifr_name);
1564 
1565         // add interface to the list
1566         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1567                     (struct sockaddr *)&amp;(ifreqP-&gt;ifr_addr),
1568                     NULL, AF_INET6, prefix);
1569 
1570         // if an exception occurred then free the list
1571         if ((*env)-&gt;ExceptionOccurred(env)) {
1572             free(buf);
1573             freeif(ifs);
1574             return NULL;
1575         }
1576     }
1577 
1578     // free buffer
1579     free(buf);
1580     return ifs;
1581 }
1582 
1583 /*
1584  * Try to get the interface index.
1585  */
1586 static int getIndex(int sock, const char *name) {
1587     int index = if_nametoindex(name);
1588     return (index == 0) ? -1 : index;
1589 }
1590 
1591 /*
1592  * Gets the Hardware address (usually MAC address) for the named interface.
1593  * On return puts the data in buf, and returns the length, in byte, of the
1594  * MAC address. Returns -1 if there is no hardware address on that interface.
1595  */
1596 static int getMacAddress
1597   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1598    unsigned char *buf)
1599 {
1600     int size;
1601     struct kinfo_ndd *nddp;
1602     void *end;
1603 
1604     size = getkerninfo(KINFO_NDD, 0, 0, 0);
1605     if (size == 0) {
1606         return -1;
1607     }
1608 
1609     if (size &lt; 0) {
1610         perror(&quot;getkerninfo 1&quot;);
1611         return -1;
1612     }
1613 
1614     nddp = (struct kinfo_ndd *)malloc(size);
1615 
1616     if (!nddp) {
1617         JNU_ThrowOutOfMemoryError(env,
1618             &quot;Network interface getMacAddress native buffer allocation failed&quot;);
1619         return -1;
1620     }
1621 
1622     if (getkerninfo(KINFO_NDD, (char*) nddp, &amp;size, 0) &lt; 0) {
1623         perror(&quot;getkerninfo 2&quot;);
1624         free(nddp);
1625         return -1;
1626     }
1627 
1628     end = (void *)nddp + size;
1629     while ((void *)nddp &lt; end) {
1630         if (!strcmp(nddp-&gt;ndd_alias, ifname) ||
1631                  !strcmp(nddp-&gt;ndd_name, ifname)) {
1632             bcopy(nddp-&gt;ndd_addr, buf, 6);
1633             free(nddp);
1634             return 6;
1635         } else {
1636             nddp++;
1637         }
1638     }
1639 
1640     free(nddp);
1641     return -1;
1642 }
1643 
1644 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1645     struct ifreq if2;
1646     memset((char *)&amp;if2, 0, sizeof(if2));
1647     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1648 
1649     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1650         JNU_ThrowByNameWithMessageAndLastError
1651             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1652         return -1;
1653     }
1654 
1655     return if2.ifr_mtu;
1656 }
1657 
1658 static int getFlags(int sock, const char *ifname, int *flags) {
1659     struct ifreq if2;
1660     memset((char *)&amp;if2, 0, sizeof(if2));
1661     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1662 
1663     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1664         return -1;
1665     }
1666 
1667     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1668         *flags = (if2.ifr_flags &amp; 0xffff);
1669     } else {
1670         *flags = if2.ifr_flags;
1671     }
1672     return 0;
1673 }
1674 
1675 #endif /* _AIX */
1676 
<a name="4" id="anc4"></a><span class="line-removed">1677 /** Solaris **/</span>
<span class="line-removed">1678 #if defined(__solaris__)</span>
<span class="line-removed">1679 </span>
<span class="line-removed">1680 /*</span>
<span class="line-removed">1681  * Opens a socket for further ioctl calls. Tries AF_INET socket first and</span>
<span class="line-removed">1682  * if it fails return AF_INET6 socket.</span>
<span class="line-removed">1683  */</span>
<span class="line-removed">1684 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {</span>
<span class="line-removed">1685     int sock, alreadyV6 = 0;</span>
<span class="line-removed">1686     struct lifreq if2;</span>
<span class="line-removed">1687 </span>
<span class="line-removed">1688     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1689         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
<span class="line-removed">1690             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1691                 JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1692                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);</span>
<span class="line-removed">1693                 return -1;</span>
<span class="line-removed">1694             }</span>
<span class="line-removed">1695             alreadyV6 = 1;</span>
<span class="line-removed">1696         } else { // errno is not NOSUPPORT</span>
<span class="line-removed">1697             JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1698                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);</span>
<span class="line-removed">1699             return -1;</span>
<span class="line-removed">1700         }</span>
<span class="line-removed">1701     }</span>
<span class="line-removed">1702 </span>
<span class="line-removed">1703     // Solaris requires that we have an IPv6 socket to query an  interface</span>
<span class="line-removed">1704     // without an IPv4 address - check it here. POSIX 1 require the kernel to</span>
<span class="line-removed">1705     // return ENOTTY if the call is inappropriate for a device e.g. the NETMASK</span>
<span class="line-removed">1706     // for a device having IPv6 only address but not all devices follow the</span>
<span class="line-removed">1707     // standard so fall back on any error. It&#39;s not an ecologically friendly</span>
<span class="line-removed">1708     // gesture but more reliable.</span>
<span class="line-removed">1709     if (!alreadyV6) {</span>
<span class="line-removed">1710         memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1711         strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1712         if (ioctl(sock, SIOCGLIFNETMASK, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">1713             close(sock);</span>
<span class="line-removed">1714             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1715                 JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1716                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);</span>
<span class="line-removed">1717                 return -1;</span>
<span class="line-removed">1718             }</span>
<span class="line-removed">1719         }</span>
<span class="line-removed">1720     }</span>
<span class="line-removed">1721 </span>
<span class="line-removed">1722     return sock;</span>
<span class="line-removed">1723 }</span>
<span class="line-removed">1724 </span>
<span class="line-removed">1725 /*</span>
<span class="line-removed">1726  * Enumerates and returns all IPv4 interfaces on Solaris.</span>
<span class="line-removed">1727  */</span>
<span class="line-removed">1728 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {</span>
<span class="line-removed">1729     struct lifconf ifc;</span>
<span class="line-removed">1730     struct lifreq *ifreqP;</span>
<span class="line-removed">1731     struct lifnum numifs;</span>
<span class="line-removed">1732     char *buf = NULL;</span>
<span class="line-removed">1733     unsigned i;</span>
<span class="line-removed">1734 </span>
<span class="line-removed">1735     // call SIOCGLIFNUM to get the interface count</span>
<span class="line-removed">1736     numifs.lifn_family = AF_INET;</span>
<span class="line-removed">1737     numifs.lifn_flags = 0;</span>
<span class="line-removed">1738     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed">1739         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1740             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);</span>
<span class="line-removed">1741         return ifs;</span>
<span class="line-removed">1742     }</span>
<span class="line-removed">1743 </span>
<span class="line-removed">1744     // call SIOCGLIFCONF to enumerate the interfaces</span>
<span class="line-removed">1745     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);</span>
<span class="line-removed">1746     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);</span>
<span class="line-removed">1747     ifc.lifc_buf = buf;</span>
<span class="line-removed">1748     ifc.lifc_family = AF_INET;</span>
<span class="line-removed">1749     ifc.lifc_flags = 0;</span>
<span class="line-removed">1750     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {</span>
<span class="line-removed">1751         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1752             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);</span>
<span class="line-removed">1753         free(buf);</span>
<span class="line-removed">1754         return ifs;</span>
<span class="line-removed">1755     }</span>
<span class="line-removed">1756 </span>
<span class="line-removed">1757     // iterate through each interface</span>
<span class="line-removed">1758     ifreqP = ifc.lifc_req;</span>
<span class="line-removed">1759     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {</span>
<span class="line-removed">1760         struct sockaddr addr, *broadaddrP = NULL;</span>
<span class="line-removed">1761 </span>
<span class="line-removed">1762         // ignore non IPv4 addresses</span>
<span class="line-removed">1763         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET) {</span>
<span class="line-removed">1764             continue;</span>
<span class="line-removed">1765         }</span>
<span class="line-removed">1766 </span>
<span class="line-removed">1767         // save socket address</span>
<span class="line-removed">1768         memcpy(&amp;addr, &amp;(ifreqP-&gt;lifr_addr), sizeof(struct sockaddr));</span>
<span class="line-removed">1769 </span>
<span class="line-removed">1770         // determine broadcast address, if applicable</span>
<span class="line-removed">1771         if ((ioctl(sock, SIOCGLIFFLAGS, ifreqP) == 0) &amp;&amp;</span>
<span class="line-removed">1772             ifreqP-&gt;lifr_flags &amp; IFF_BROADCAST) {</span>
<span class="line-removed">1773 </span>
<span class="line-removed">1774             // restore socket address to ifreqP</span>
<span class="line-removed">1775             memcpy(&amp;(ifreqP-&gt;lifr_addr), &amp;addr, sizeof(struct sockaddr));</span>
<span class="line-removed">1776 </span>
<span class="line-removed">1777             // query broadcast address and set pointer to it</span>
<span class="line-removed">1778             if (ioctl(sock, SIOCGLIFBRDADDR, ifreqP) == 0) {</span>
<span class="line-removed">1779                 broadaddrP = (struct sockaddr *)&amp;(ifreqP-&gt;lifr_broadaddr);</span>
<span class="line-removed">1780             }</span>
<span class="line-removed">1781         }</span>
<span class="line-removed">1782 </span>
<span class="line-removed">1783         // add to the list</span>
<span class="line-removed">1784         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,</span>
<span class="line-removed">1785                     &amp;addr, broadaddrP, AF_INET, (short)ifreqP-&gt;lifr_addrlen);</span>
<span class="line-removed">1786 </span>
<span class="line-removed">1787         // if an exception occurred we return immediately</span>
<span class="line-removed">1788         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-removed">1789             free(buf);</span>
<span class="line-removed">1790             return ifs;</span>
<span class="line-removed">1791         }</span>
<span class="line-removed">1792    }</span>
<span class="line-removed">1793 </span>
<span class="line-removed">1794     // free buffer</span>
<span class="line-removed">1795     free(buf);</span>
<span class="line-removed">1796     return ifs;</span>
<span class="line-removed">1797 }</span>
<span class="line-removed">1798 </span>
<span class="line-removed">1799 /*</span>
<span class="line-removed">1800  * Enumerates and returns all IPv6 interfaces on Solaris.</span>
<span class="line-removed">1801  */</span>
<span class="line-removed">1802 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {</span>
<span class="line-removed">1803     struct lifconf ifc;</span>
<span class="line-removed">1804     struct lifreq *ifreqP;</span>
<span class="line-removed">1805     struct lifnum numifs;</span>
<span class="line-removed">1806     char *buf = NULL;</span>
<span class="line-removed">1807     unsigned i;</span>
<span class="line-removed">1808 </span>
<span class="line-removed">1809     // call SIOCGLIFNUM to get the interface count</span>
<span class="line-removed">1810     numifs.lifn_family = AF_INET6;</span>
<span class="line-removed">1811     numifs.lifn_flags = 0;</span>
<span class="line-removed">1812     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed">1813         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1814             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);</span>
<span class="line-removed">1815         return ifs;</span>
<span class="line-removed">1816     }</span>
<span class="line-removed">1817 </span>
<span class="line-removed">1818     // call SIOCGLIFCONF to enumerate the interfaces</span>
<span class="line-removed">1819     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);</span>
<span class="line-removed">1820     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);</span>
<span class="line-removed">1821     ifc.lifc_buf = buf;</span>
<span class="line-removed">1822     ifc.lifc_family = AF_INET6;</span>
<span class="line-removed">1823     ifc.lifc_flags = 0;</span>
<span class="line-removed">1824     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {</span>
<span class="line-removed">1825         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1826             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);</span>
<span class="line-removed">1827         free(buf);</span>
<span class="line-removed">1828         return ifs;</span>
<span class="line-removed">1829     }</span>
<span class="line-removed">1830 </span>
<span class="line-removed">1831     // iterate through each interface</span>
<span class="line-removed">1832     ifreqP = ifc.lifc_req;</span>
<span class="line-removed">1833     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {</span>
<span class="line-removed">1834 </span>
<span class="line-removed">1835         // ignore non IPv6 addresses</span>
<span class="line-removed">1836         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET6) {</span>
<span class="line-removed">1837             continue;</span>
<span class="line-removed">1838         }</span>
<span class="line-removed">1839 </span>
<span class="line-removed">1840         // set scope ID to interface index</span>
<span class="line-removed">1841         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;lifr_addr))-&gt;sin6_scope_id =</span>
<span class="line-removed">1842             getIndex(sock, ifreqP-&gt;lifr_name);</span>
<span class="line-removed">1843 </span>
<span class="line-removed">1844         // add to the list</span>
<span class="line-removed">1845         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,</span>
<span class="line-removed">1846                     (struct sockaddr *)&amp;(ifreqP-&gt;lifr_addr),</span>
<span class="line-removed">1847                     NULL, AF_INET6, (short)ifreqP-&gt;lifr_addrlen);</span>
<span class="line-removed">1848 </span>
<span class="line-removed">1849         // if an exception occurred we return immediately</span>
<span class="line-removed">1850         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-removed">1851             free(buf);</span>
<span class="line-removed">1852             return ifs;</span>
<span class="line-removed">1853         }</span>
<span class="line-removed">1854     }</span>
<span class="line-removed">1855 </span>
<span class="line-removed">1856     // free buffer</span>
<span class="line-removed">1857     free(buf);</span>
<span class="line-removed">1858     return ifs;</span>
<span class="line-removed">1859 }</span>
<span class="line-removed">1860 </span>
<span class="line-removed">1861 /*</span>
<span class="line-removed">1862  * Try to get the interface index.</span>
<span class="line-removed">1863  * (Not supported on Solaris 2.6 or 7)</span>
<span class="line-removed">1864  */</span>
<span class="line-removed">1865 static int getIndex(int sock, const char *name) {</span>
<span class="line-removed">1866     struct lifreq if2;</span>
<span class="line-removed">1867     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1868     strncpy(if2.lifr_name, name, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1869 </span>
<span class="line-removed">1870     if (ioctl(sock, SIOCGLIFINDEX, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">1871         return -1;</span>
<span class="line-removed">1872     }</span>
<span class="line-removed">1873 </span>
<span class="line-removed">1874     return if2.lifr_index;</span>
<span class="line-removed">1875 }</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877 /*</span>
<span class="line-removed">1878  * Solaris specific DLPI code to get hardware address from a device.</span>
<span class="line-removed">1879  * Unfortunately, at least up to Solaris X, you have to have special</span>
<span class="line-removed">1880  * privileges (i.e. be root).</span>
<span class="line-removed">1881  */</span>
<span class="line-removed">1882 static int getMacFromDevice</span>
<span class="line-removed">1883   (JNIEnv *env, const char *ifname, unsigned char *retbuf)</span>
<span class="line-removed">1884 {</span>
<span class="line-removed">1885     char style1dev[MAXPATHLEN];</span>
<span class="line-removed">1886     int fd;</span>
<span class="line-removed">1887     dl_phys_addr_req_t dlpareq;</span>
<span class="line-removed">1888     dl_phys_addr_ack_t *dlpaack;</span>
<span class="line-removed">1889     dl_error_ack_t     *dlerack;</span>
<span class="line-removed">1890     struct strbuf msg;</span>
<span class="line-removed">1891     char buf[128];</span>
<span class="line-removed">1892     int flags = 0;</span>
<span class="line-removed">1893 </span>
<span class="line-removed">1894     // Device is in /dev.  e.g.: /dev/bge0</span>
<span class="line-removed">1895     strcpy(style1dev, DEV_PREFIX);</span>
<span class="line-removed">1896     strcat(style1dev, ifname);</span>
<span class="line-removed">1897     if ((fd = open(style1dev, O_RDWR)) &lt; 0) {</span>
<span class="line-removed">1898         // Can&#39;t open it. We probably are missing the privilege.</span>
<span class="line-removed">1899         // We&#39;ll have to try something else</span>
<span class="line-removed">1900         return 0;</span>
<span class="line-removed">1901     }</span>
<span class="line-removed">1902 </span>
<span class="line-removed">1903     dlpareq.dl_primitive = DL_PHYS_ADDR_REQ;</span>
<span class="line-removed">1904     dlpareq.dl_addr_type = DL_CURR_PHYS_ADDR;</span>
<span class="line-removed">1905 </span>
<span class="line-removed">1906     msg.buf = (char *)&amp;dlpareq;</span>
<span class="line-removed">1907     msg.len = DL_PHYS_ADDR_REQ_SIZE;</span>
<span class="line-removed">1908 </span>
<span class="line-removed">1909     if (putmsg(fd, &amp;msg, NULL, 0) &lt; 0) {</span>
<span class="line-removed">1910         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1911             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;putmsg() failed&quot;);</span>
<span class="line-removed">1912         return -1;</span>
<span class="line-removed">1913     }</span>
<span class="line-removed">1914 </span>
<span class="line-removed">1915     dlpaack = (dl_phys_addr_ack_t *)buf;</span>
<span class="line-removed">1916 </span>
<span class="line-removed">1917     msg.buf = (char *)buf;</span>
<span class="line-removed">1918     msg.len = 0;</span>
<span class="line-removed">1919     msg.maxlen = sizeof (buf);</span>
<span class="line-removed">1920     if (getmsg(fd, &amp;msg, NULL, &amp;flags) &lt; 0) {</span>
<span class="line-removed">1921         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1922             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getmsg() failed&quot;);</span>
<span class="line-removed">1923         return -1;</span>
<span class="line-removed">1924     }</span>
<span class="line-removed">1925 </span>
<span class="line-removed">1926     if (dlpaack-&gt;dl_primitive == DL_ERROR_ACK) {</span>
<span class="line-removed">1927         dlerack = (dl_error_ack_t *)buf;</span>
<span class="line-removed">1928         if (dlerack-&gt;dl_error_primitive != DL_PHYS_ADDR_REQ) {</span>
<span class="line-removed">1929             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,</span>
<span class="line-removed">1930                            &quot;Couldn&#39;t obtain physical address\n&quot;);</span>
<span class="line-removed">1931             return -1;</span>
<span class="line-removed">1932         }</span>
<span class="line-removed">1933         if (dlerack-&gt;dl_errno == DL_UNSUPPORTED) {</span>
<span class="line-removed">1934             // fallback to lookup in the ARP table</span>
<span class="line-removed">1935             return 0;</span>
<span class="line-removed">1936         }</span>
<span class="line-removed">1937     }</span>
<span class="line-removed">1938 </span>
<span class="line-removed">1939     if (msg.len &lt; DL_PHYS_ADDR_ACK_SIZE || dlpaack-&gt;dl_primitive != DL_PHYS_ADDR_ACK) {</span>
<span class="line-removed">1940         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,</span>
<span class="line-removed">1941                         &quot;Couldn&#39;t obtain phys addr\n&quot;);</span>
<span class="line-removed">1942         return -1;</span>
<span class="line-removed">1943     }</span>
<span class="line-removed">1944 </span>
<span class="line-removed">1945     memcpy(retbuf, &amp;buf[dlpaack-&gt;dl_addr_offset], dlpaack-&gt;dl_addr_length);</span>
<span class="line-removed">1946     return dlpaack-&gt;dl_addr_length;</span>
<span class="line-removed">1947 }</span>
<span class="line-removed">1948 </span>
<span class="line-removed">1949 /*</span>
<span class="line-removed">1950  * Gets the Hardware address (usually MAC address) for the named interface.</span>
<span class="line-removed">1951  * On return puts the data in buf, and returns the length, in byte, of the</span>
<span class="line-removed">1952  * MAC address. Returns -1 if there is no hardware address on that interface.</span>
<span class="line-removed">1953  */</span>
<span class="line-removed">1954 static int getMacAddress</span>
<span class="line-removed">1955   (JNIEnv *env, const char *ifname, const struct in_addr *addr,</span>
<span class="line-removed">1956    unsigned char *buf)</span>
<span class="line-removed">1957 {</span>
<span class="line-removed">1958     struct lifreq if2;</span>
<span class="line-removed">1959     int len, i, sock;</span>
<span class="line-removed">1960 </span>
<span class="line-removed">1961     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {</span>
<span class="line-removed">1962         return -1;</span>
<span class="line-removed">1963     }</span>
<span class="line-removed">1964 </span>
<span class="line-removed">1965     // First, try the new (S11) SIOCGLIFHWADDR ioctl(). If that fails</span>
<span class="line-removed">1966     // try the old way.</span>
<span class="line-removed">1967     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1968     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1969 </span>
<span class="line-removed">1970     if (ioctl(sock, SIOCGLIFHWADDR, &amp;if2) != -1) {</span>
<span class="line-removed">1971         struct sockaddr_dl *sp;</span>
<span class="line-removed">1972         sp = (struct sockaddr_dl *)&amp;if2.lifr_addr;</span>
<span class="line-removed">1973         memcpy(buf, &amp;sp-&gt;sdl_data[0], sp-&gt;sdl_alen);</span>
<span class="line-removed">1974         close(sock);</span>
<span class="line-removed">1975         return sp-&gt;sdl_alen;</span>
<span class="line-removed">1976     }</span>
<span class="line-removed">1977 </span>
<span class="line-removed">1978     // On Solaris we have to use DLPI, but it will only work if we have</span>
<span class="line-removed">1979     // privileged access (i.e. root). If that fails, we try a lookup</span>
<span class="line-removed">1980     // in the ARP table, which requires an IPv4 address.</span>
<span class="line-removed">1981     if (((len = getMacFromDevice(env, ifname, buf)) == 0) &amp;&amp; (addr != NULL)) {</span>
<span class="line-removed">1982         struct arpreq arpreq;</span>
<span class="line-removed">1983         struct sockaddr_in *sin;</span>
<span class="line-removed">1984         struct sockaddr_in ipAddr;</span>
<span class="line-removed">1985 </span>
<span class="line-removed">1986         len = 6; //???</span>
<span class="line-removed">1987 </span>
<span class="line-removed">1988         sin = (struct sockaddr_in *)&amp;arpreq.arp_pa;</span>
<span class="line-removed">1989         memset((char *)&amp;arpreq, 0, sizeof(struct arpreq));</span>
<span class="line-removed">1990         ipAddr.sin_port = 0;</span>
<span class="line-removed">1991         ipAddr.sin_family = AF_INET;</span>
<span class="line-removed">1992         memcpy(&amp;ipAddr.sin_addr, addr, sizeof(struct in_addr));</span>
<span class="line-removed">1993         memcpy(&amp;arpreq.arp_pa, &amp;ipAddr, sizeof(struct sockaddr_in));</span>
<span class="line-removed">1994         arpreq.arp_flags= ATF_PUBL;</span>
<span class="line-removed">1995 </span>
<span class="line-removed">1996         if (ioctl(sock, SIOCGARP, &amp;arpreq) &lt; 0) {</span>
<span class="line-removed">1997             close(sock);</span>
<span class="line-removed">1998             return -1;</span>
<span class="line-removed">1999         }</span>
<span class="line-removed">2000 </span>
<span class="line-removed">2001         memcpy(buf, &amp;arpreq.arp_ha.sa_data[0], len);</span>
<span class="line-removed">2002     }</span>
<span class="line-removed">2003     close(sock);</span>
<span class="line-removed">2004 </span>
<span class="line-removed">2005     // all bytes to 0 means no hardware address</span>
<span class="line-removed">2006     for (i = 0; i &lt; len; i++) {</span>
<span class="line-removed">2007         if (buf[i] != 0)</span>
<span class="line-removed">2008             return len;</span>
<span class="line-removed">2009     }</span>
<span class="line-removed">2010 </span>
<span class="line-removed">2011     return -1;</span>
<span class="line-removed">2012 }</span>
<span class="line-removed">2013 </span>
<span class="line-removed">2014 static int getMTU(JNIEnv *env, int sock, const char *ifname) {</span>
<span class="line-removed">2015     struct lifreq if2;</span>
<span class="line-removed">2016     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">2017     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">2018 </span>
<span class="line-removed">2019     if (ioctl(sock, SIOCGLIFMTU, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">2020         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">2021             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFMTU) failed&quot;);</span>
<span class="line-removed">2022         return -1;</span>
<span class="line-removed">2023     }</span>
<span class="line-removed">2024 </span>
<span class="line-removed">2025     return if2.lifr_mtu;</span>
<span class="line-removed">2026 }</span>
<span class="line-removed">2027 </span>
<span class="line-removed">2028 static int getFlags(int sock, const char *ifname, int *flags) {</span>
<span class="line-removed">2029     struct lifreq if2;</span>
<span class="line-removed">2030     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">2031     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">2032 </span>
<span class="line-removed">2033     if (ioctl(sock, SIOCGLIFFLAGS, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">2034         return -1;</span>
<span class="line-removed">2035     }</span>
<span class="line-removed">2036 </span>
<span class="line-removed">2037     *flags = if2.lifr_flags;</span>
<span class="line-removed">2038     return 0;</span>
<span class="line-removed">2039 }</span>
<span class="line-removed">2040 </span>
<span class="line-removed">2041 #endif /* __solaris__ */</span>
<span class="line-removed">2042 </span>
2043 /** BSD **/
2044 #if defined(_ALLBSD_SOURCE)
2045 
2046 /*
2047  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
2048  * if it fails return AF_INET6 socket.
2049  */
2050 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
2051     int sock;
2052 
2053     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
2054         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
2055             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
2056                 JNU_ThrowByNameWithMessageAndLastError
2057                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
2058                 return -1;
2059             }
2060         } else { // errno is not NOSUPPORT
2061             JNU_ThrowByNameWithMessageAndLastError
2062                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
2063             return -1;
2064         }
2065     }
2066 
2067     return sock;
2068 }
2069 
2070 /*
2071  * Enumerates and returns all IPv4 interfaces on BSD.
2072  */
2073 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
2074     struct ifaddrs *ifa, *origifa;
2075 
2076     if (getifaddrs(&amp;origifa) != 0) {
2077         JNU_ThrowByNameWithMessageAndLastError
2078             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
2079         return ifs;
2080     }
2081 
2082     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
2083         struct sockaddr *broadaddrP = NULL;
2084 
2085         // ignore non IPv4 addresses
2086         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET)
2087             continue;
2088 
2089         // set ifa_broadaddr, if there is one
2090         if ((ifa-&gt;ifa_flags &amp; IFF_POINTOPOINT) == 0 &amp;&amp;
2091             ifa-&gt;ifa_flags &amp; IFF_BROADCAST) {
2092             broadaddrP = ifa-&gt;ifa_dstaddr;
2093         }
2094 
2095         // add interface to the list
2096         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr,
2097                     broadaddrP, AF_INET,
2098                     translateIPv4AddressToPrefix((struct sockaddr_in *)
2099                                                  ifa-&gt;ifa_netmask));
2100 
2101         // if an exception occurred then free the list
2102         if ((*env)-&gt;ExceptionOccurred(env)) {
2103             freeifaddrs(origifa);
2104             freeif(ifs);
2105             return NULL;
2106         }
2107     }
2108 
2109     // free ifaddrs buffer
2110     freeifaddrs(origifa);
2111     return ifs;
2112 }
2113 
2114 /*
2115  * Enumerates and returns all IPv6 interfaces on BSD.
2116  */
2117 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
2118     struct ifaddrs *ifa, *origifa;
2119 
2120     if (getifaddrs(&amp;origifa) != 0) {
2121         JNU_ThrowByNameWithMessageAndLastError
2122             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
2123         return ifs;
2124     }
2125 
2126     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
2127         // ignore non IPv6 addresses
2128         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6)
2129             continue;
2130 
2131         // set scope ID to interface index
2132         ((struct sockaddr_in6 *)ifa-&gt;ifa_addr)-&gt;sin6_scope_id =
2133             getIndex(sock, ifa-&gt;ifa_name);
2134 
2135         // add interface to the list
2136         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr, NULL,
2137                     AF_INET6,
2138                     translateIPv6AddressToPrefix((struct sockaddr_in6 *)
2139                                                  ifa-&gt;ifa_netmask));
2140 
2141         // if an exception occurred then free the list
2142         if ((*env)-&gt;ExceptionOccurred(env)) {
2143             freeifaddrs(origifa);
2144             freeif(ifs);
2145             return NULL;
2146         }
2147     }
2148 
2149     // free ifaddrs buffer
2150     freeifaddrs(origifa);
2151     return ifs;
2152 }
2153 
2154 /*
2155  * Try to get the interface index.
2156  */
2157 static int getIndex(int sock, const char *name) {
2158 #if !defined(__FreeBSD__)
2159     int index = if_nametoindex(name);
2160     return (index == 0) ? -1 : index;
2161 #else
2162     struct ifreq if2;
2163     memset((char *)&amp;if2, 0, sizeof(if2));
2164     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
2165 
2166     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
2167         return -1;
2168     }
2169 
2170     return if2.ifr_index;
2171 #endif
2172 }
2173 
2174 /*
2175  * Gets the Hardware address (usually MAC address) for the named interface.
2176  * On return puts the data in buf, and returns the length, in byte, of the
2177  * MAC address. Returns -1 if there is no hardware address on that interface.
2178  */
2179 static int getMacAddress
2180   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
2181    unsigned char *buf)
2182 {
2183     struct ifaddrs *ifa0, *ifa;
2184     struct sockaddr *saddr;
2185     int i;
2186 
2187     // grab the interface list
2188     if (!getifaddrs(&amp;ifa0)) {
2189         // cycle through the interfaces
2190         for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa-&gt;ifa_next, i++) {
2191             saddr = ifa-&gt;ifa_addr;
2192             if (saddr != NULL) {
2193                 // link layer contains the MAC address
2194                 if (saddr-&gt;sa_family == AF_LINK &amp;&amp; !strcmp(ifname, ifa-&gt;ifa_name)) {
2195                     struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
2196                     // check the address has the correct length
2197                     if (sadl-&gt;sdl_alen == ETHER_ADDR_LEN) {
2198                         memcpy(buf, (sadl-&gt;sdl_data + sadl-&gt;sdl_nlen), ETHER_ADDR_LEN);
2199                         freeifaddrs(ifa0);
2200                         return ETHER_ADDR_LEN;
2201                     }
2202                 }
2203             }
2204         }
2205         freeifaddrs(ifa0);
2206     }
2207 
2208     return -1;
2209 }
2210 
2211 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
2212     struct ifreq if2;
2213     memset((char *)&amp;if2, 0, sizeof(if2));
2214     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
2215 
2216     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
2217         JNU_ThrowByNameWithMessageAndLastError
2218             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
2219         return -1;
2220     }
2221 
2222     return if2.ifr_mtu;
2223 }
2224 
2225 static int getFlags(int sock, const char *ifname, int *flags) {
2226     struct ifreq if2;
2227     memset((char *)&amp;if2, 0, sizeof(if2));
2228     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
2229 
2230     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
2231         return -1;
2232     }
2233 
2234     if (sizeof(if2.ifr_flags) == sizeof(short)) {
2235         *flags = (if2.ifr_flags &amp; 0xffff);
2236     } else {
2237         *flags = if2.ifr_flags;
2238     }
2239     return 0;
2240 }
2241 #endif /* _ALLBSD_SOURCE */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
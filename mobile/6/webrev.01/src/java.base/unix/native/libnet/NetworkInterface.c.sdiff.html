<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/unix/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Inet6AddressImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/unix/native/libnet/NetworkInterface.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #ifndef TARGET_IOS
  29 #include &lt;net/if_arp.h&gt;
  30 #endif
  31 #include &lt;stdlib.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/ioctl.h&gt;
  34 
  35 #if defined(_AIX)
  36 #include &lt;netinet/in6_var.h&gt;
  37 #include &lt;sys/ndd_var.h&gt;
  38 #include &lt;sys/kinfo.h&gt;
  39 #include &lt;strings.h&gt;
  40 #endif
  41 
<span class="line-removed">  42 #if defined(__solaris__)</span>
<span class="line-removed">  43 #include &lt;stropts.h&gt;</span>
<span class="line-removed">  44 #include &lt;sys/dlpi.h&gt;</span>
<span class="line-removed">  45 #include &lt;sys/sockio.h&gt;</span>
<span class="line-removed">  46 #endif</span>
<span class="line-removed">  47 </span>
  48 #if defined(_ALLBSD_SOURCE)
  49 #include &lt;net/ethernet.h&gt;
  50 #include &lt;net/if_dl.h&gt;
  51 #include &lt;ifaddrs.h&gt;
  52 #endif
  53 
  54 #include &quot;net_util.h&quot;
  55 
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__)
  59     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
<span class="line-removed">  60 #elif defined(__solaris__)</span>
<span class="line-removed">  61     #ifndef SIOCGLIFHWADDR</span>
<span class="line-removed">  62         #define SIOCGLIFHWADDR _IOWR(&#39;i&#39;, 192, struct lifreq)</span>
<span class="line-removed">  63     #endif</span>
<span class="line-removed">  64     #define DEV_PREFIX &quot;/dev/&quot;</span>
  65 #endif
  66 
  67 #ifdef LIFNAMSIZ
  68     #define IFNAMESIZE LIFNAMSIZ
  69 #else
  70     #define IFNAMESIZE IFNAMSIZ
  71 #endif
  72 
  73 #define CHECKED_MALLOC3(_pointer, _type, _size) \
  74     do { \
  75         _pointer = (_type)malloc(_size); \
  76         if (_pointer == NULL) { \
  77             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failed&quot;); \
  78             return ifs; /* return untouched list */ \
  79         } \
  80     } while(0)
  81 
  82 typedef struct _netaddr  {
  83     struct sockaddr *addr;
  84     struct sockaddr *brdcast;
</pre>
<hr />
<pre>
 132 static netif  *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs);
 133 
 134 static netif  *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 135                      struct sockaddr *ifr_addrP,
 136                      struct sockaddr *ifr_broadaddrP,
 137                      int family, short prefix);
 138 static void    freeif(netif *ifs);
 139 
 140 static int     openSocket(JNIEnv *env, int proto);
 141 static int     openSocketWithFallback(JNIEnv *env, const char *ifname);
 142 
 143 static short   translateIPv4AddressToPrefix(struct sockaddr_in *addr);
 144 static short   translateIPv6AddressToPrefix(struct sockaddr_in6 *addr);
 145 
 146 static int     getIndex(int sock, const char *ifname);
 147 static int     getFlags(int sock, const char *ifname, int *flags);
 148 static int     getMacAddress(JNIEnv *env, const char *ifname,
 149                              const struct in_addr *addr, unsigned char *buf);
 150 static int     getMTU(JNIEnv *env, int sock, const char *ifname);
 151 
<span class="line-removed"> 152 #if defined(__solaris__)</span>
<span class="line-removed"> 153 static int     getMacFromDevice(JNIEnv *env, const char *ifname,</span>
<span class="line-removed"> 154                                 unsigned char *retbuf);</span>
<span class="line-removed"> 155 #endif</span>
<span class="line-removed"> 156 </span>
 157 /******************* Java entry points *****************************/
 158 
 159 /*
 160  * Class:     java_net_NetworkInterface
 161  * Method:    init
 162  * Signature: ()V
 163  */
 164 JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init
 165   (JNIEnv *env, jclass cls)
 166 {
 167     ni_class = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 168     CHECK_NULL(ni_class);
 169     ni_class = (*env)-&gt;NewGlobalRef(env, ni_class);
 170     CHECK_NULL(ni_class);
 171     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 172     CHECK_NULL(ni_nameID);
 173     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 174     CHECK_NULL(ni_indexID);
 175     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;,
 176                                     &quot;[Ljava/net/InetAddress;&quot;);
</pre>
<hr />
<pre>
1657 
1658 static int getFlags(int sock, const char *ifname, int *flags) {
1659     struct ifreq if2;
1660     memset((char *)&amp;if2, 0, sizeof(if2));
1661     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1662 
1663     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1664         return -1;
1665     }
1666 
1667     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1668         *flags = (if2.ifr_flags &amp; 0xffff);
1669     } else {
1670         *flags = if2.ifr_flags;
1671     }
1672     return 0;
1673 }
1674 
1675 #endif /* _AIX */
1676 
<span class="line-removed">1677 /** Solaris **/</span>
<span class="line-removed">1678 #if defined(__solaris__)</span>
<span class="line-removed">1679 </span>
<span class="line-removed">1680 /*</span>
<span class="line-removed">1681  * Opens a socket for further ioctl calls. Tries AF_INET socket first and</span>
<span class="line-removed">1682  * if it fails return AF_INET6 socket.</span>
<span class="line-removed">1683  */</span>
<span class="line-removed">1684 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {</span>
<span class="line-removed">1685     int sock, alreadyV6 = 0;</span>
<span class="line-removed">1686     struct lifreq if2;</span>
<span class="line-removed">1687 </span>
<span class="line-removed">1688     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1689         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {</span>
<span class="line-removed">1690             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1691                 JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1692                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);</span>
<span class="line-removed">1693                 return -1;</span>
<span class="line-removed">1694             }</span>
<span class="line-removed">1695             alreadyV6 = 1;</span>
<span class="line-removed">1696         } else { // errno is not NOSUPPORT</span>
<span class="line-removed">1697             JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1698                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);</span>
<span class="line-removed">1699             return -1;</span>
<span class="line-removed">1700         }</span>
<span class="line-removed">1701     }</span>
<span class="line-removed">1702 </span>
<span class="line-removed">1703     // Solaris requires that we have an IPv6 socket to query an  interface</span>
<span class="line-removed">1704     // without an IPv4 address - check it here. POSIX 1 require the kernel to</span>
<span class="line-removed">1705     // return ENOTTY if the call is inappropriate for a device e.g. the NETMASK</span>
<span class="line-removed">1706     // for a device having IPv6 only address but not all devices follow the</span>
<span class="line-removed">1707     // standard so fall back on any error. It&#39;s not an ecologically friendly</span>
<span class="line-removed">1708     // gesture but more reliable.</span>
<span class="line-removed">1709     if (!alreadyV6) {</span>
<span class="line-removed">1710         memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1711         strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1712         if (ioctl(sock, SIOCGLIFNETMASK, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">1713             close(sock);</span>
<span class="line-removed">1714             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {</span>
<span class="line-removed">1715                 JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1716                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);</span>
<span class="line-removed">1717                 return -1;</span>
<span class="line-removed">1718             }</span>
<span class="line-removed">1719         }</span>
<span class="line-removed">1720     }</span>
<span class="line-removed">1721 </span>
<span class="line-removed">1722     return sock;</span>
<span class="line-removed">1723 }</span>
<span class="line-removed">1724 </span>
<span class="line-removed">1725 /*</span>
<span class="line-removed">1726  * Enumerates and returns all IPv4 interfaces on Solaris.</span>
<span class="line-removed">1727  */</span>
<span class="line-removed">1728 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {</span>
<span class="line-removed">1729     struct lifconf ifc;</span>
<span class="line-removed">1730     struct lifreq *ifreqP;</span>
<span class="line-removed">1731     struct lifnum numifs;</span>
<span class="line-removed">1732     char *buf = NULL;</span>
<span class="line-removed">1733     unsigned i;</span>
<span class="line-removed">1734 </span>
<span class="line-removed">1735     // call SIOCGLIFNUM to get the interface count</span>
<span class="line-removed">1736     numifs.lifn_family = AF_INET;</span>
<span class="line-removed">1737     numifs.lifn_flags = 0;</span>
<span class="line-removed">1738     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed">1739         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1740             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);</span>
<span class="line-removed">1741         return ifs;</span>
<span class="line-removed">1742     }</span>
<span class="line-removed">1743 </span>
<span class="line-removed">1744     // call SIOCGLIFCONF to enumerate the interfaces</span>
<span class="line-removed">1745     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);</span>
<span class="line-removed">1746     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);</span>
<span class="line-removed">1747     ifc.lifc_buf = buf;</span>
<span class="line-removed">1748     ifc.lifc_family = AF_INET;</span>
<span class="line-removed">1749     ifc.lifc_flags = 0;</span>
<span class="line-removed">1750     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {</span>
<span class="line-removed">1751         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1752             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);</span>
<span class="line-removed">1753         free(buf);</span>
<span class="line-removed">1754         return ifs;</span>
<span class="line-removed">1755     }</span>
<span class="line-removed">1756 </span>
<span class="line-removed">1757     // iterate through each interface</span>
<span class="line-removed">1758     ifreqP = ifc.lifc_req;</span>
<span class="line-removed">1759     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {</span>
<span class="line-removed">1760         struct sockaddr addr, *broadaddrP = NULL;</span>
<span class="line-removed">1761 </span>
<span class="line-removed">1762         // ignore non IPv4 addresses</span>
<span class="line-removed">1763         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET) {</span>
<span class="line-removed">1764             continue;</span>
<span class="line-removed">1765         }</span>
<span class="line-removed">1766 </span>
<span class="line-removed">1767         // save socket address</span>
<span class="line-removed">1768         memcpy(&amp;addr, &amp;(ifreqP-&gt;lifr_addr), sizeof(struct sockaddr));</span>
<span class="line-removed">1769 </span>
<span class="line-removed">1770         // determine broadcast address, if applicable</span>
<span class="line-removed">1771         if ((ioctl(sock, SIOCGLIFFLAGS, ifreqP) == 0) &amp;&amp;</span>
<span class="line-removed">1772             ifreqP-&gt;lifr_flags &amp; IFF_BROADCAST) {</span>
<span class="line-removed">1773 </span>
<span class="line-removed">1774             // restore socket address to ifreqP</span>
<span class="line-removed">1775             memcpy(&amp;(ifreqP-&gt;lifr_addr), &amp;addr, sizeof(struct sockaddr));</span>
<span class="line-removed">1776 </span>
<span class="line-removed">1777             // query broadcast address and set pointer to it</span>
<span class="line-removed">1778             if (ioctl(sock, SIOCGLIFBRDADDR, ifreqP) == 0) {</span>
<span class="line-removed">1779                 broadaddrP = (struct sockaddr *)&amp;(ifreqP-&gt;lifr_broadaddr);</span>
<span class="line-removed">1780             }</span>
<span class="line-removed">1781         }</span>
<span class="line-removed">1782 </span>
<span class="line-removed">1783         // add to the list</span>
<span class="line-removed">1784         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,</span>
<span class="line-removed">1785                     &amp;addr, broadaddrP, AF_INET, (short)ifreqP-&gt;lifr_addrlen);</span>
<span class="line-removed">1786 </span>
<span class="line-removed">1787         // if an exception occurred we return immediately</span>
<span class="line-removed">1788         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-removed">1789             free(buf);</span>
<span class="line-removed">1790             return ifs;</span>
<span class="line-removed">1791         }</span>
<span class="line-removed">1792    }</span>
<span class="line-removed">1793 </span>
<span class="line-removed">1794     // free buffer</span>
<span class="line-removed">1795     free(buf);</span>
<span class="line-removed">1796     return ifs;</span>
<span class="line-removed">1797 }</span>
<span class="line-removed">1798 </span>
<span class="line-removed">1799 /*</span>
<span class="line-removed">1800  * Enumerates and returns all IPv6 interfaces on Solaris.</span>
<span class="line-removed">1801  */</span>
<span class="line-removed">1802 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {</span>
<span class="line-removed">1803     struct lifconf ifc;</span>
<span class="line-removed">1804     struct lifreq *ifreqP;</span>
<span class="line-removed">1805     struct lifnum numifs;</span>
<span class="line-removed">1806     char *buf = NULL;</span>
<span class="line-removed">1807     unsigned i;</span>
<span class="line-removed">1808 </span>
<span class="line-removed">1809     // call SIOCGLIFNUM to get the interface count</span>
<span class="line-removed">1810     numifs.lifn_family = AF_INET6;</span>
<span class="line-removed">1811     numifs.lifn_flags = 0;</span>
<span class="line-removed">1812     if (ioctl(sock, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed">1813         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1814             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFNUM) failed&quot;);</span>
<span class="line-removed">1815         return ifs;</span>
<span class="line-removed">1816     }</span>
<span class="line-removed">1817 </span>
<span class="line-removed">1818     // call SIOCGLIFCONF to enumerate the interfaces</span>
<span class="line-removed">1819     ifc.lifc_len = numifs.lifn_count * sizeof(struct lifreq);</span>
<span class="line-removed">1820     CHECKED_MALLOC3(buf, char *, ifc.lifc_len);</span>
<span class="line-removed">1821     ifc.lifc_buf = buf;</span>
<span class="line-removed">1822     ifc.lifc_family = AF_INET6;</span>
<span class="line-removed">1823     ifc.lifc_flags = 0;</span>
<span class="line-removed">1824     if (ioctl(sock, SIOCGLIFCONF, (char *)&amp;ifc) &lt; 0) {</span>
<span class="line-removed">1825         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1826             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFCONF) failed&quot;);</span>
<span class="line-removed">1827         free(buf);</span>
<span class="line-removed">1828         return ifs;</span>
<span class="line-removed">1829     }</span>
<span class="line-removed">1830 </span>
<span class="line-removed">1831     // iterate through each interface</span>
<span class="line-removed">1832     ifreqP = ifc.lifc_req;</span>
<span class="line-removed">1833     for (i = 0; i &lt; numifs.lifn_count; i++, ifreqP++) {</span>
<span class="line-removed">1834 </span>
<span class="line-removed">1835         // ignore non IPv6 addresses</span>
<span class="line-removed">1836         if (ifreqP-&gt;lifr_addr.ss_family != AF_INET6) {</span>
<span class="line-removed">1837             continue;</span>
<span class="line-removed">1838         }</span>
<span class="line-removed">1839 </span>
<span class="line-removed">1840         // set scope ID to interface index</span>
<span class="line-removed">1841         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;lifr_addr))-&gt;sin6_scope_id =</span>
<span class="line-removed">1842             getIndex(sock, ifreqP-&gt;lifr_name);</span>
<span class="line-removed">1843 </span>
<span class="line-removed">1844         // add to the list</span>
<span class="line-removed">1845         ifs = addif(env, sock, ifreqP-&gt;lifr_name, ifs,</span>
<span class="line-removed">1846                     (struct sockaddr *)&amp;(ifreqP-&gt;lifr_addr),</span>
<span class="line-removed">1847                     NULL, AF_INET6, (short)ifreqP-&gt;lifr_addrlen);</span>
<span class="line-removed">1848 </span>
<span class="line-removed">1849         // if an exception occurred we return immediately</span>
<span class="line-removed">1850         if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-removed">1851             free(buf);</span>
<span class="line-removed">1852             return ifs;</span>
<span class="line-removed">1853         }</span>
<span class="line-removed">1854     }</span>
<span class="line-removed">1855 </span>
<span class="line-removed">1856     // free buffer</span>
<span class="line-removed">1857     free(buf);</span>
<span class="line-removed">1858     return ifs;</span>
<span class="line-removed">1859 }</span>
<span class="line-removed">1860 </span>
<span class="line-removed">1861 /*</span>
<span class="line-removed">1862  * Try to get the interface index.</span>
<span class="line-removed">1863  * (Not supported on Solaris 2.6 or 7)</span>
<span class="line-removed">1864  */</span>
<span class="line-removed">1865 static int getIndex(int sock, const char *name) {</span>
<span class="line-removed">1866     struct lifreq if2;</span>
<span class="line-removed">1867     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1868     strncpy(if2.lifr_name, name, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1869 </span>
<span class="line-removed">1870     if (ioctl(sock, SIOCGLIFINDEX, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">1871         return -1;</span>
<span class="line-removed">1872     }</span>
<span class="line-removed">1873 </span>
<span class="line-removed">1874     return if2.lifr_index;</span>
<span class="line-removed">1875 }</span>
<span class="line-removed">1876 </span>
<span class="line-removed">1877 /*</span>
<span class="line-removed">1878  * Solaris specific DLPI code to get hardware address from a device.</span>
<span class="line-removed">1879  * Unfortunately, at least up to Solaris X, you have to have special</span>
<span class="line-removed">1880  * privileges (i.e. be root).</span>
<span class="line-removed">1881  */</span>
<span class="line-removed">1882 static int getMacFromDevice</span>
<span class="line-removed">1883   (JNIEnv *env, const char *ifname, unsigned char *retbuf)</span>
<span class="line-removed">1884 {</span>
<span class="line-removed">1885     char style1dev[MAXPATHLEN];</span>
<span class="line-removed">1886     int fd;</span>
<span class="line-removed">1887     dl_phys_addr_req_t dlpareq;</span>
<span class="line-removed">1888     dl_phys_addr_ack_t *dlpaack;</span>
<span class="line-removed">1889     dl_error_ack_t     *dlerack;</span>
<span class="line-removed">1890     struct strbuf msg;</span>
<span class="line-removed">1891     char buf[128];</span>
<span class="line-removed">1892     int flags = 0;</span>
<span class="line-removed">1893 </span>
<span class="line-removed">1894     // Device is in /dev.  e.g.: /dev/bge0</span>
<span class="line-removed">1895     strcpy(style1dev, DEV_PREFIX);</span>
<span class="line-removed">1896     strcat(style1dev, ifname);</span>
<span class="line-removed">1897     if ((fd = open(style1dev, O_RDWR)) &lt; 0) {</span>
<span class="line-removed">1898         // Can&#39;t open it. We probably are missing the privilege.</span>
<span class="line-removed">1899         // We&#39;ll have to try something else</span>
<span class="line-removed">1900         return 0;</span>
<span class="line-removed">1901     }</span>
<span class="line-removed">1902 </span>
<span class="line-removed">1903     dlpareq.dl_primitive = DL_PHYS_ADDR_REQ;</span>
<span class="line-removed">1904     dlpareq.dl_addr_type = DL_CURR_PHYS_ADDR;</span>
<span class="line-removed">1905 </span>
<span class="line-removed">1906     msg.buf = (char *)&amp;dlpareq;</span>
<span class="line-removed">1907     msg.len = DL_PHYS_ADDR_REQ_SIZE;</span>
<span class="line-removed">1908 </span>
<span class="line-removed">1909     if (putmsg(fd, &amp;msg, NULL, 0) &lt; 0) {</span>
<span class="line-removed">1910         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1911             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;putmsg() failed&quot;);</span>
<span class="line-removed">1912         return -1;</span>
<span class="line-removed">1913     }</span>
<span class="line-removed">1914 </span>
<span class="line-removed">1915     dlpaack = (dl_phys_addr_ack_t *)buf;</span>
<span class="line-removed">1916 </span>
<span class="line-removed">1917     msg.buf = (char *)buf;</span>
<span class="line-removed">1918     msg.len = 0;</span>
<span class="line-removed">1919     msg.maxlen = sizeof (buf);</span>
<span class="line-removed">1920     if (getmsg(fd, &amp;msg, NULL, &amp;flags) &lt; 0) {</span>
<span class="line-removed">1921         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">1922             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getmsg() failed&quot;);</span>
<span class="line-removed">1923         return -1;</span>
<span class="line-removed">1924     }</span>
<span class="line-removed">1925 </span>
<span class="line-removed">1926     if (dlpaack-&gt;dl_primitive == DL_ERROR_ACK) {</span>
<span class="line-removed">1927         dlerack = (dl_error_ack_t *)buf;</span>
<span class="line-removed">1928         if (dlerack-&gt;dl_error_primitive != DL_PHYS_ADDR_REQ) {</span>
<span class="line-removed">1929             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,</span>
<span class="line-removed">1930                            &quot;Couldn&#39;t obtain physical address\n&quot;);</span>
<span class="line-removed">1931             return -1;</span>
<span class="line-removed">1932         }</span>
<span class="line-removed">1933         if (dlerack-&gt;dl_errno == DL_UNSUPPORTED) {</span>
<span class="line-removed">1934             // fallback to lookup in the ARP table</span>
<span class="line-removed">1935             return 0;</span>
<span class="line-removed">1936         }</span>
<span class="line-removed">1937     }</span>
<span class="line-removed">1938 </span>
<span class="line-removed">1939     if (msg.len &lt; DL_PHYS_ADDR_ACK_SIZE || dlpaack-&gt;dl_primitive != DL_PHYS_ADDR_ACK) {</span>
<span class="line-removed">1940         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;,</span>
<span class="line-removed">1941                         &quot;Couldn&#39;t obtain phys addr\n&quot;);</span>
<span class="line-removed">1942         return -1;</span>
<span class="line-removed">1943     }</span>
<span class="line-removed">1944 </span>
<span class="line-removed">1945     memcpy(retbuf, &amp;buf[dlpaack-&gt;dl_addr_offset], dlpaack-&gt;dl_addr_length);</span>
<span class="line-removed">1946     return dlpaack-&gt;dl_addr_length;</span>
<span class="line-removed">1947 }</span>
<span class="line-removed">1948 </span>
<span class="line-removed">1949 /*</span>
<span class="line-removed">1950  * Gets the Hardware address (usually MAC address) for the named interface.</span>
<span class="line-removed">1951  * On return puts the data in buf, and returns the length, in byte, of the</span>
<span class="line-removed">1952  * MAC address. Returns -1 if there is no hardware address on that interface.</span>
<span class="line-removed">1953  */</span>
<span class="line-removed">1954 static int getMacAddress</span>
<span class="line-removed">1955   (JNIEnv *env, const char *ifname, const struct in_addr *addr,</span>
<span class="line-removed">1956    unsigned char *buf)</span>
<span class="line-removed">1957 {</span>
<span class="line-removed">1958     struct lifreq if2;</span>
<span class="line-removed">1959     int len, i, sock;</span>
<span class="line-removed">1960 </span>
<span class="line-removed">1961     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {</span>
<span class="line-removed">1962         return -1;</span>
<span class="line-removed">1963     }</span>
<span class="line-removed">1964 </span>
<span class="line-removed">1965     // First, try the new (S11) SIOCGLIFHWADDR ioctl(). If that fails</span>
<span class="line-removed">1966     // try the old way.</span>
<span class="line-removed">1967     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">1968     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">1969 </span>
<span class="line-removed">1970     if (ioctl(sock, SIOCGLIFHWADDR, &amp;if2) != -1) {</span>
<span class="line-removed">1971         struct sockaddr_dl *sp;</span>
<span class="line-removed">1972         sp = (struct sockaddr_dl *)&amp;if2.lifr_addr;</span>
<span class="line-removed">1973         memcpy(buf, &amp;sp-&gt;sdl_data[0], sp-&gt;sdl_alen);</span>
<span class="line-removed">1974         close(sock);</span>
<span class="line-removed">1975         return sp-&gt;sdl_alen;</span>
<span class="line-removed">1976     }</span>
<span class="line-removed">1977 </span>
<span class="line-removed">1978     // On Solaris we have to use DLPI, but it will only work if we have</span>
<span class="line-removed">1979     // privileged access (i.e. root). If that fails, we try a lookup</span>
<span class="line-removed">1980     // in the ARP table, which requires an IPv4 address.</span>
<span class="line-removed">1981     if (((len = getMacFromDevice(env, ifname, buf)) == 0) &amp;&amp; (addr != NULL)) {</span>
<span class="line-removed">1982         struct arpreq arpreq;</span>
<span class="line-removed">1983         struct sockaddr_in *sin;</span>
<span class="line-removed">1984         struct sockaddr_in ipAddr;</span>
<span class="line-removed">1985 </span>
<span class="line-removed">1986         len = 6; //???</span>
<span class="line-removed">1987 </span>
<span class="line-removed">1988         sin = (struct sockaddr_in *)&amp;arpreq.arp_pa;</span>
<span class="line-removed">1989         memset((char *)&amp;arpreq, 0, sizeof(struct arpreq));</span>
<span class="line-removed">1990         ipAddr.sin_port = 0;</span>
<span class="line-removed">1991         ipAddr.sin_family = AF_INET;</span>
<span class="line-removed">1992         memcpy(&amp;ipAddr.sin_addr, addr, sizeof(struct in_addr));</span>
<span class="line-removed">1993         memcpy(&amp;arpreq.arp_pa, &amp;ipAddr, sizeof(struct sockaddr_in));</span>
<span class="line-removed">1994         arpreq.arp_flags= ATF_PUBL;</span>
<span class="line-removed">1995 </span>
<span class="line-removed">1996         if (ioctl(sock, SIOCGARP, &amp;arpreq) &lt; 0) {</span>
<span class="line-removed">1997             close(sock);</span>
<span class="line-removed">1998             return -1;</span>
<span class="line-removed">1999         }</span>
<span class="line-removed">2000 </span>
<span class="line-removed">2001         memcpy(buf, &amp;arpreq.arp_ha.sa_data[0], len);</span>
<span class="line-removed">2002     }</span>
<span class="line-removed">2003     close(sock);</span>
<span class="line-removed">2004 </span>
<span class="line-removed">2005     // all bytes to 0 means no hardware address</span>
<span class="line-removed">2006     for (i = 0; i &lt; len; i++) {</span>
<span class="line-removed">2007         if (buf[i] != 0)</span>
<span class="line-removed">2008             return len;</span>
<span class="line-removed">2009     }</span>
<span class="line-removed">2010 </span>
<span class="line-removed">2011     return -1;</span>
<span class="line-removed">2012 }</span>
<span class="line-removed">2013 </span>
<span class="line-removed">2014 static int getMTU(JNIEnv *env, int sock, const char *ifname) {</span>
<span class="line-removed">2015     struct lifreq if2;</span>
<span class="line-removed">2016     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">2017     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">2018 </span>
<span class="line-removed">2019     if (ioctl(sock, SIOCGLIFMTU, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">2020         JNU_ThrowByNameWithMessageAndLastError</span>
<span class="line-removed">2021             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGLIFMTU) failed&quot;);</span>
<span class="line-removed">2022         return -1;</span>
<span class="line-removed">2023     }</span>
<span class="line-removed">2024 </span>
<span class="line-removed">2025     return if2.lifr_mtu;</span>
<span class="line-removed">2026 }</span>
<span class="line-removed">2027 </span>
<span class="line-removed">2028 static int getFlags(int sock, const char *ifname, int *flags) {</span>
<span class="line-removed">2029     struct lifreq if2;</span>
<span class="line-removed">2030     memset((char *)&amp;if2, 0, sizeof(if2));</span>
<span class="line-removed">2031     strncpy(if2.lifr_name, ifname, sizeof(if2.lifr_name) - 1);</span>
<span class="line-removed">2032 </span>
<span class="line-removed">2033     if (ioctl(sock, SIOCGLIFFLAGS, (char *)&amp;if2) &lt; 0) {</span>
<span class="line-removed">2034         return -1;</span>
<span class="line-removed">2035     }</span>
<span class="line-removed">2036 </span>
<span class="line-removed">2037     *flags = if2.lifr_flags;</span>
<span class="line-removed">2038     return 0;</span>
<span class="line-removed">2039 }</span>
<span class="line-removed">2040 </span>
<span class="line-removed">2041 #endif /* __solaris__ */</span>
<span class="line-removed">2042 </span>
2043 /** BSD **/
2044 #if defined(_ALLBSD_SOURCE)
2045 
2046 /*
2047  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
2048  * if it fails return AF_INET6 socket.
2049  */
2050 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
2051     int sock;
2052 
2053     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
2054         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
2055             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
2056                 JNU_ThrowByNameWithMessageAndLastError
2057                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
2058                 return -1;
2059             }
2060         } else { // errno is not NOSUPPORT
2061             JNU_ThrowByNameWithMessageAndLastError
2062                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #ifndef TARGET_IOS
  29 #include &lt;net/if_arp.h&gt;
  30 #endif
  31 #include &lt;stdlib.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/ioctl.h&gt;
  34 
  35 #if defined(_AIX)
  36 #include &lt;netinet/in6_var.h&gt;
  37 #include &lt;sys/ndd_var.h&gt;
  38 #include &lt;sys/kinfo.h&gt;
  39 #include &lt;strings.h&gt;
  40 #endif
  41 






  42 #if defined(_ALLBSD_SOURCE)
  43 #include &lt;net/ethernet.h&gt;
  44 #include &lt;net/if_dl.h&gt;
  45 #include &lt;ifaddrs.h&gt;
  46 #endif
  47 
  48 #include &quot;net_util.h&quot;
  49 
  50 #include &quot;java_net_InetAddress.h&quot;
  51 
  52 #if defined(__linux__)
  53     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;





  54 #endif
  55 
  56 #ifdef LIFNAMSIZ
  57     #define IFNAMESIZE LIFNAMSIZ
  58 #else
  59     #define IFNAMESIZE IFNAMSIZ
  60 #endif
  61 
  62 #define CHECKED_MALLOC3(_pointer, _type, _size) \
  63     do { \
  64         _pointer = (_type)malloc(_size); \
  65         if (_pointer == NULL) { \
  66             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failed&quot;); \
  67             return ifs; /* return untouched list */ \
  68         } \
  69     } while(0)
  70 
  71 typedef struct _netaddr  {
  72     struct sockaddr *addr;
  73     struct sockaddr *brdcast;
</pre>
<hr />
<pre>
 121 static netif  *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs);
 122 
 123 static netif  *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 124                      struct sockaddr *ifr_addrP,
 125                      struct sockaddr *ifr_broadaddrP,
 126                      int family, short prefix);
 127 static void    freeif(netif *ifs);
 128 
 129 static int     openSocket(JNIEnv *env, int proto);
 130 static int     openSocketWithFallback(JNIEnv *env, const char *ifname);
 131 
 132 static short   translateIPv4AddressToPrefix(struct sockaddr_in *addr);
 133 static short   translateIPv6AddressToPrefix(struct sockaddr_in6 *addr);
 134 
 135 static int     getIndex(int sock, const char *ifname);
 136 static int     getFlags(int sock, const char *ifname, int *flags);
 137 static int     getMacAddress(JNIEnv *env, const char *ifname,
 138                              const struct in_addr *addr, unsigned char *buf);
 139 static int     getMTU(JNIEnv *env, int sock, const char *ifname);
 140 





 141 /******************* Java entry points *****************************/
 142 
 143 /*
 144  * Class:     java_net_NetworkInterface
 145  * Method:    init
 146  * Signature: ()V
 147  */
 148 JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init
 149   (JNIEnv *env, jclass cls)
 150 {
 151     ni_class = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 152     CHECK_NULL(ni_class);
 153     ni_class = (*env)-&gt;NewGlobalRef(env, ni_class);
 154     CHECK_NULL(ni_class);
 155     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 156     CHECK_NULL(ni_nameID);
 157     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 158     CHECK_NULL(ni_indexID);
 159     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;,
 160                                     &quot;[Ljava/net/InetAddress;&quot;);
</pre>
<hr />
<pre>
1641 
1642 static int getFlags(int sock, const char *ifname, int *flags) {
1643     struct ifreq if2;
1644     memset((char *)&amp;if2, 0, sizeof(if2));
1645     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1646 
1647     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1648         return -1;
1649     }
1650 
1651     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1652         *flags = (if2.ifr_flags &amp; 0xffff);
1653     } else {
1654         *flags = if2.ifr_flags;
1655     }
1656     return 0;
1657 }
1658 
1659 #endif /* _AIX */
1660 














































































































































































































































































































































































1661 /** BSD **/
1662 #if defined(_ALLBSD_SOURCE)
1663 
1664 /*
1665  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1666  * if it fails return AF_INET6 socket.
1667  */
1668 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1669     int sock;
1670 
1671     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1672         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1673             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1674                 JNU_ThrowByNameWithMessageAndLastError
1675                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1676                 return -1;
1677             }
1678         } else { // errno is not NOSUPPORT
1679             JNU_ThrowByNameWithMessageAndLastError
1680                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="Inet6AddressImpl.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PlainDatagramSocketImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/unix/native/libnet/net_util_md.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;dlfcn.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #include &lt;netinet/tcp.h&gt; // defines TCP_NODELAY
  29 #include &lt;stdlib.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;sys/ioctl.h&gt;
  32 #include &lt;sys/time.h&gt;
  33 
  34 #if defined(__linux__)
  35 #include &lt;arpa/inet.h&gt;
  36 #include &lt;net/route.h&gt;
  37 #include &lt;sys/utsname.h&gt;
  38 #endif
  39 
<a name="2" id="anc2"></a><span class="line-removed">  40 #if defined(__solaris__)</span>
<span class="line-removed">  41 #include &lt;inet/nd.h&gt;</span>
<span class="line-removed">  42 #include &lt;limits.h&gt;</span>
<span class="line-removed">  43 #include &lt;stropts.h&gt;</span>
<span class="line-removed">  44 #include &lt;sys/filio.h&gt;</span>
<span class="line-removed">  45 #include &lt;sys/sockio.h&gt;</span>
<span class="line-removed">  46 #endif</span>
<span class="line-removed">  47 </span>
  48 #if defined(MACOSX)
  49 #include &lt;sys/sysctl.h&gt;
  50 #endif
  51 
  52 #include &quot;jvm.h&quot;
  53 #include &quot;net_util.h&quot;
  54 
  55 #include &quot;java_net_SocketOptions.h&quot;
  56 #include &quot;java_net_InetAddress.h&quot;
  57 
  58 #if defined(__linux__) &amp;&amp; !defined(IPV6_FLOWINFO_SEND)
  59 #define IPV6_FLOWINFO_SEND      33
  60 #endif
  61 
<a name="3" id="anc3"></a><span class="line-removed">  62 #if defined(__solaris__) &amp;&amp; !defined(MAXINT)</span>
<span class="line-removed">  63 #define MAXINT INT_MAX</span>
<span class="line-removed">  64 #endif</span>
<span class="line-removed">  65 </span>
<span class="line-removed">  66 /*</span>
<span class="line-removed">  67  * EXCLBIND socket options only on Solaris</span>
<span class="line-removed">  68  */</span>
<span class="line-removed">  69 #if defined(__solaris__) &amp;&amp; !defined(TCP_EXCLBIND)</span>
<span class="line-removed">  70 #define TCP_EXCLBIND            0x21</span>
<span class="line-removed">  71 #endif</span>
<span class="line-removed">  72 #if defined(__solaris__) &amp;&amp; !defined(UDP_EXCLBIND)</span>
<span class="line-removed">  73 #define UDP_EXCLBIND            0x0101</span>
<span class="line-removed">  74 #endif</span>
<span class="line-removed">  75 </span>
  76 #define RESTARTABLE(_cmd, _result) do { \
  77     do { \
  78         _result = _cmd; \
  79     } while((_result == -1) &amp;&amp; (errno == EINTR)); \
  80 } while(0)
  81 
  82 int NET_SocketAvailable(int s, int *pbytes) {
  83     int result;
  84     RESTARTABLE(ioctl(s, FIONREAD, pbytes), result);
  85     return result;
  86 }
  87 
<a name="4" id="anc4"></a><span class="line-removed">  88 #ifdef __solaris__</span>
<span class="line-removed">  89 static int init_tcp_max_buf, init_udp_max_buf;</span>
<span class="line-removed">  90 static int tcp_max_buf;</span>
<span class="line-removed">  91 static int udp_max_buf;</span>
<span class="line-removed">  92 static int useExclBind = 0;</span>
<span class="line-removed">  93 </span>
<span class="line-removed">  94 /*</span>
<span class="line-removed">  95  * Get the specified parameter from the specified driver. The value</span>
<span class="line-removed">  96  * of the parameter is assumed to be an &#39;int&#39;. If the parameter</span>
<span class="line-removed">  97  * cannot be obtained return -1</span>
<span class="line-removed">  98  */</span>
<span class="line-removed">  99 int net_getParam(char *driver, char *param)</span>
<span class="line-removed"> 100 {</span>
<span class="line-removed"> 101     struct strioctl stri;</span>
<span class="line-removed"> 102     char buf [64];</span>
<span class="line-removed"> 103     int s;</span>
<span class="line-removed"> 104     int value;</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106     s = open (driver, O_RDWR);</span>
<span class="line-removed"> 107     if (s &lt; 0) {</span>
<span class="line-removed"> 108         return -1;</span>
<span class="line-removed"> 109     }</span>
<span class="line-removed"> 110     strncpy (buf, param, sizeof(buf));</span>
<span class="line-removed"> 111     stri.ic_cmd = ND_GET;</span>
<span class="line-removed"> 112     stri.ic_timout = 0;</span>
<span class="line-removed"> 113     stri.ic_dp = buf;</span>
<span class="line-removed"> 114     stri.ic_len = sizeof(buf);</span>
<span class="line-removed"> 115     if (ioctl (s, I_STR, &amp;stri) &lt; 0) {</span>
<span class="line-removed"> 116         value = -1;</span>
<span class="line-removed"> 117     } else {</span>
<span class="line-removed"> 118         value = atoi(buf);</span>
<span class="line-removed"> 119     }</span>
<span class="line-removed"> 120     close (s);</span>
<span class="line-removed"> 121     return value;</span>
<span class="line-removed"> 122 }</span>
<span class="line-removed"> 123 </span>
<span class="line-removed"> 124 /*</span>
<span class="line-removed"> 125  * Iterative way to find the max value that SO_SNDBUF or SO_RCVBUF</span>
<span class="line-removed"> 126  * for Solaris versions that do not support the ioctl() in net_getParam().</span>
<span class="line-removed"> 127  * Ugly, but only called once (for each sotype).</span>
<span class="line-removed"> 128  *</span>
<span class="line-removed"> 129  * As an optimization, we make a guess using the default values for Solaris</span>
<span class="line-removed"> 130  * assuming they haven&#39;t been modified with ndd.</span>
<span class="line-removed"> 131  */</span>
<span class="line-removed"> 132 </span>
<span class="line-removed"> 133 #define MAX_TCP_GUESS 1024 * 1024</span>
<span class="line-removed"> 134 #define MAX_UDP_GUESS 2 * 1024 * 1024</span>
<span class="line-removed"> 135 </span>
<span class="line-removed"> 136 #define FAIL_IF_NOT_ENOBUFS if (errno != ENOBUFS) return -1</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138 static int findMaxBuf(int fd, int opt, int sotype) {</span>
<span class="line-removed"> 139     int a = 0;</span>
<span class="line-removed"> 140     int b = MAXINT;</span>
<span class="line-removed"> 141     int initial_guess;</span>
<span class="line-removed"> 142     int limit = -1;</span>
<span class="line-removed"> 143 </span>
<span class="line-removed"> 144     if (sotype == SOCK_DGRAM) {</span>
<span class="line-removed"> 145         initial_guess = MAX_UDP_GUESS;</span>
<span class="line-removed"> 146     } else {</span>
<span class="line-removed"> 147         initial_guess = MAX_TCP_GUESS;</span>
<span class="line-removed"> 148     }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150     if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess, sizeof(int)) == 0) {</span>
<span class="line-removed"> 151         initial_guess++;</span>
<span class="line-removed"> 152         if (setsockopt(fd, SOL_SOCKET, opt, &amp;initial_guess,sizeof(int)) &lt; 0) {</span>
<span class="line-removed"> 153             FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 154             return initial_guess - 1;</span>
<span class="line-removed"> 155         }</span>
<span class="line-removed"> 156         a = initial_guess;</span>
<span class="line-removed"> 157     } else {</span>
<span class="line-removed"> 158         FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 159         b = initial_guess - 1;</span>
<span class="line-removed"> 160     }</span>
<span class="line-removed"> 161     do {</span>
<span class="line-removed"> 162         int mid = a + (b-a)/2;</span>
<span class="line-removed"> 163         if (setsockopt(fd, SOL_SOCKET, opt, &amp;mid, sizeof(int)) == 0) {</span>
<span class="line-removed"> 164             limit = mid;</span>
<span class="line-removed"> 165             a = mid + 1;</span>
<span class="line-removed"> 166         } else {</span>
<span class="line-removed"> 167             FAIL_IF_NOT_ENOBUFS;</span>
<span class="line-removed"> 168             b = mid - 1;</span>
<span class="line-removed"> 169         }</span>
<span class="line-removed"> 170     } while (b &gt;= a);</span>
<span class="line-removed"> 171 </span>
<span class="line-removed"> 172     return limit;</span>
<span class="line-removed"> 173 }</span>
<span class="line-removed"> 174 #endif</span>
<span class="line-removed"> 175 </span>
 176 void
 177 NET_ThrowByNameWithLastError(JNIEnv *env, const char *name,
 178                    const char *defaultDetail) {
 179     JNU_ThrowByNameWithMessageAndLastError(env, name, defaultDetail);
 180 }
 181 
 182 void
 183 NET_ThrowCurrent(JNIEnv *env, char *msg) {
 184     NET_ThrowNew(env, errno, msg);
 185 }
 186 
 187 void
 188 NET_ThrowNew(JNIEnv *env, int errorNumber, char *msg) {
 189     char fullMsg[512];
 190     if (!msg) {
 191         msg = &quot;no further information&quot;;
 192     }
 193     switch(errorNumber) {
 194     case EBADF:
 195         jio_snprintf(fullMsg, sizeof(fullMsg), &quot;socket closed: %s&quot;, msg);
 196         JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, fullMsg);
 197         break;
 198     case EINTR:
 199         JNU_ThrowByName(env, JNU_JAVAIOPKG &quot;InterruptedIOException&quot;, msg);
 200         break;
 201     default:
 202         errno = errorNumber;
 203         JNU_ThrowByNameWithLastError(env, JNU_JAVANETPKG &quot;SocketException&quot;, msg);
 204         break;
 205     }
 206 }
 207 
 208 
 209 jfieldID
 210 NET_GetFileDescriptorID(JNIEnv *env)
 211 {
 212     jclass cls = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;);
 213     CHECK_NULL_RETURN(cls, NULL);
 214     return (*env)-&gt;GetFieldID(env, cls, &quot;fd&quot;, &quot;I&quot;);
 215 }
 216 
 217 jint  IPv4_supported()
 218 {
 219     int fd = socket(AF_INET, SOCK_STREAM, 0) ;
 220     if (fd &lt; 0) {
 221         return JNI_FALSE;
 222     }
 223     close(fd);
 224     return JNI_TRUE;
 225 }
 226 
 227 #if defined(DONT_ENABLE_IPV6)
 228 jint  IPv6_supported()
 229 {
 230     return JNI_FALSE;
 231 }
 232 
 233 #else /* !DONT_ENABLE_IPV6 */
 234 
 235 jint  IPv6_supported()
 236 {
 237     int fd;
 238     void *ipv6_fn;
 239     SOCKETADDRESS sa;
 240     socklen_t sa_len = sizeof(SOCKETADDRESS);
 241 
 242     fd = socket(AF_INET6, SOCK_STREAM, 0) ;
 243     if (fd &lt; 0) {
 244         /*
 245          *  TODO: We really cant tell since it may be an unrelated error
 246          *  for now we will assume that AF_INET6 is not available
 247          */
 248         return JNI_FALSE;
 249     }
 250 
 251     /*
 252      * If fd 0 is a socket it means we may have been launched from inetd or
 253      * xinetd. If it&#39;s a socket then check the family - if it&#39;s an
 254      * IPv4 socket then we need to disable IPv6.
 255      */
 256     if (getsockname(0, &amp;sa.sa, &amp;sa_len) == 0) {
 257         if (sa.sa.sa_family == AF_INET) {
 258             close(fd);
 259             return JNI_FALSE;
 260         }
 261     }
 262 
 263     /**
 264      * Linux - check if any interface has an IPv6 address.
 265      * Don&#39;t need to parse the line - we just need an indication.
 266      */
 267 #ifdef __linux__
 268     {
 269         FILE *fP = fopen(&quot;/proc/net/if_inet6&quot;, &quot;r&quot;);
 270         char buf[255];
 271         char *bufP;
 272 
 273         if (fP == NULL) {
 274             close(fd);
 275             return JNI_FALSE;
 276         }
 277         bufP = fgets(buf, sizeof(buf), fP);
 278         fclose(fP);
 279         if (bufP == NULL) {
 280             close(fd);
 281             return JNI_FALSE;
 282         }
 283     }
 284 #endif
 285 
<a name="5" id="anc5"></a><span class="line-removed"> 286     /**</span>
<span class="line-removed"> 287      * On Solaris 8 it&#39;s possible to create INET6 sockets even</span>
<span class="line-removed"> 288      * though IPv6 is not enabled on all interfaces. Thus we</span>
<span class="line-removed"> 289      * query the number of IPv6 addresses to verify that IPv6</span>
<span class="line-removed"> 290      * has been configured on at least one interface.</span>
<span class="line-removed"> 291      *</span>
<span class="line-removed"> 292      * On Linux it doesn&#39;t matter - if IPv6 is built-in the</span>
<span class="line-removed"> 293      * kernel then IPv6 addresses will be bound automatically</span>
<span class="line-removed"> 294      * to all interfaces.</span>
<span class="line-removed"> 295      */</span>
<span class="line-removed"> 296 #ifdef __solaris__</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298 #ifdef SIOCGLIFNUM</span>
<span class="line-removed"> 299     {</span>
<span class="line-removed"> 300         struct lifnum numifs;</span>
<span class="line-removed"> 301 </span>
<span class="line-removed"> 302         numifs.lifn_family = AF_INET6;</span>
<span class="line-removed"> 303         numifs.lifn_flags = 0;</span>
<span class="line-removed"> 304         if (ioctl(fd, SIOCGLIFNUM, (char *)&amp;numifs) &lt; 0) {</span>
<span class="line-removed"> 305             /**</span>
<span class="line-removed"> 306              * SIOCGLIFNUM failed - assume IPv6 not configured</span>
<span class="line-removed"> 307              */</span>
<span class="line-removed"> 308             close(fd);</span>
<span class="line-removed"> 309             return JNI_FALSE;</span>
<span class="line-removed"> 310         }</span>
<span class="line-removed"> 311         /**</span>
<span class="line-removed"> 312          * If no IPv6 addresses then return false. If count &gt; 0</span>
<span class="line-removed"> 313          * it&#39;s possible that all IPv6 addresses are &quot;down&quot; but</span>
<span class="line-removed"> 314          * that&#39;s okay as they may be brought &quot;up&quot; while the</span>
<span class="line-removed"> 315          * VM is running.</span>
<span class="line-removed"> 316          */</span>
<span class="line-removed"> 317         if (numifs.lifn_count == 0) {</span>
<span class="line-removed"> 318             close(fd);</span>
<span class="line-removed"> 319             return JNI_FALSE;</span>
<span class="line-removed"> 320         }</span>
<span class="line-removed"> 321     }</span>
<span class="line-removed"> 322 #else</span>
<span class="line-removed"> 323     /* SIOCGLIFNUM not defined in build environment ??? */</span>
<span class="line-removed"> 324     close(fd);</span>
<span class="line-removed"> 325     return JNI_FALSE;</span>
<span class="line-removed"> 326 #endif</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328 #endif /* __solaris */</span>
<span class="line-removed"> 329 </span>
 330     /*
 331      *  OK we may have the stack available in the kernel,
 332      *  we should also check if the APIs are available.
 333      */
 334     ipv6_fn = JVM_FindLibraryEntry(RTLD_DEFAULT, &quot;inet_pton&quot;);
 335     close(fd);
 336     if (ipv6_fn == NULL ) {
 337         return JNI_FALSE;
 338     } else {
 339         return JNI_TRUE;
 340     }
 341 }
 342 #endif /* DONT_ENABLE_IPV6 */
 343 
 344 jint reuseport_supported()
 345 {
 346     /* Do a simple dummy call, and try to figure out from that */
 347     int one = 1;
 348     int rv, s;
 349     s = socket(PF_INET, SOCK_STREAM, 0);
 350     if (s &lt; 0) {
 351         return JNI_FALSE;
 352     }
 353     rv = setsockopt(s, SOL_SOCKET, SO_REUSEPORT, (void *)&amp;one, sizeof(one));
 354     if (rv != 0) {
 355         rv = JNI_FALSE;
 356     } else {
 357         rv = JNI_TRUE;
 358     }
 359     close(s);
 360     return rv;
 361 }
 362 
 363 void NET_ThrowUnknownHostExceptionWithGaiError(JNIEnv *env,
 364                                                const char* hostname,
 365                                                int gai_error)
 366 {
 367     int size;
 368     char *buf;
 369     const char *format = &quot;%s: %s&quot;;
 370     const char *error_string = gai_strerror(gai_error);
 371     if (error_string == NULL)
 372         error_string = &quot;unknown error&quot;;
 373 
 374     size = strlen(format) + strlen(hostname) + strlen(error_string) + 2;
 375     buf = (char *) malloc(size);
 376     if (buf) {
 377         jstring s;
 378         sprintf(buf, format, hostname, error_string);
 379         s = JNU_NewStringPlatform(env, buf);
 380         if (s != NULL) {
 381             jobject x = JNU_NewObjectByName(env,
 382                                             &quot;java/net/UnknownHostException&quot;,
 383                                             &quot;(Ljava/lang/String;)V&quot;, s);
 384             if (x != NULL)
 385                 (*env)-&gt;Throw(env, x);
 386         }
 387         free(buf);
 388     }
 389 }
 390 
 391 #if defined(_AIX)
 392 
 393 /* Initialize stubs for blocking I/O workarounds (see src/solaris/native/java/net/linux_close.c) */
 394 extern void aix_close_init();
 395 
 396 void platformInit () {
 397     aix_close_init();
 398 }
 399 
 400 #else
 401 
 402 void platformInit () {}
 403 
 404 #endif
 405 
<a name="6" id="anc6"></a><span class="line-removed"> 406 void parseExclusiveBindProperty(JNIEnv *env) {</span>
<span class="line-removed"> 407 #ifdef __solaris__</span>
<span class="line-removed"> 408     jstring s, flagSet;</span>
<span class="line-removed"> 409     jclass iCls;</span>
<span class="line-removed"> 410     jmethodID mid;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412     s = (*env)-&gt;NewStringUTF(env, &quot;sun.net.useExclusiveBind&quot;);</span>
<span class="line-removed"> 413     CHECK_NULL(s);</span>
<span class="line-removed"> 414     iCls = (*env)-&gt;FindClass(env, &quot;java/lang/System&quot;);</span>
<span class="line-removed"> 415     CHECK_NULL(iCls);</span>
<span class="line-removed"> 416     mid = (*env)-&gt;GetStaticMethodID(env, iCls, &quot;getProperty&quot;,</span>
<span class="line-removed"> 417                 &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span>
<span class="line-removed"> 418     CHECK_NULL(mid);</span>
<span class="line-removed"> 419     flagSet = (*env)-&gt;CallStaticObjectMethod(env, iCls, mid, s);</span>
<span class="line-removed"> 420     if (flagSet != NULL) {</span>
<span class="line-removed"> 421         useExclBind = 1;</span>
<span class="line-removed"> 422     }</span>
<span class="line-removed"> 423 #endif</span>
<span class="line-removed"> 424 }</span>
<span class="line-removed"> 425 </span>
 426 JNIEXPORT jint JNICALL
 427 NET_EnableFastTcpLoopback(int fd) {
 428     return 0;
 429 }
 430 
 431 /**
 432  * See net_util.h for documentation
 433  */
 434 JNIEXPORT int JNICALL
 435 NET_InetAddressToSockaddr(JNIEnv *env, jobject iaObj, int port,
 436                           SOCKETADDRESS *sa, int *len,
 437                           jboolean v4MappedAddress)
 438 {
 439     jint family = getInetAddress_family(env, iaObj);
 440     JNU_CHECK_EXCEPTION_RETURN(env, -1);
 441     memset((char *)sa, 0, sizeof(SOCKETADDRESS));
 442 
 443     if (ipv6_available() &amp;&amp;
 444         !(family == java_net_InetAddress_IPv4 &amp;&amp;
 445           v4MappedAddress == JNI_FALSE))
 446     {
 447         jbyte caddr[16];
 448         jint address;
 449 
 450         if (family == java_net_InetAddress_IPv4) {
 451             // convert to IPv4-mapped address
 452             memset((char *)caddr, 0, 16);
 453             address = getInetAddress_addr(env, iaObj);
 454             JNU_CHECK_EXCEPTION_RETURN(env, -1);
 455             if (address == INADDR_ANY) {
 456                 /* we would always prefer IPv6 wildcard address
 457                  * caddr[10] = 0xff;
 458                  * caddr[11] = 0xff; */
 459             } else {
 460                 caddr[10] = 0xff;
 461                 caddr[11] = 0xff;
 462                 caddr[12] = ((address &gt;&gt; 24) &amp; 0xff);
 463                 caddr[13] = ((address &gt;&gt; 16) &amp; 0xff);
 464                 caddr[14] = ((address &gt;&gt; 8) &amp; 0xff);
 465                 caddr[15] = (address &amp; 0xff);
 466             }
 467         } else {
 468             getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 469         }
 470         sa-&gt;sa6.sin6_port = htons(port);
 471         memcpy((void *)&amp;sa-&gt;sa6.sin6_addr, caddr, sizeof(struct in6_addr));
 472         sa-&gt;sa6.sin6_family = AF_INET6;
 473         if (len != NULL) {
 474             *len = sizeof(struct sockaddr_in6);
 475         }
 476 
 477         /* handle scope_id */
 478         if (family != java_net_InetAddress_IPv4) {
 479             if (ia6_scopeidID) {
 480                 sa-&gt;sa6.sin6_scope_id = getInet6Address_scopeid(env, iaObj);
 481             }
 482         }
 483     } else {
 484         jint address;
 485         if (family != java_net_InetAddress_IPv4) {
 486             JNU_ThrowByName(env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Protocol family unavailable&quot;);
 487             return -1;
 488         }
 489         address = getInetAddress_addr(env, iaObj);
 490         JNU_CHECK_EXCEPTION_RETURN(env, -1);
 491         sa-&gt;sa4.sin_port = htons(port);
 492         sa-&gt;sa4.sin_addr.s_addr = htonl(address);
 493         sa-&gt;sa4.sin_family = AF_INET;
 494         if (len != NULL) {
 495             *len = sizeof(struct sockaddr_in);
 496         }
 497     }
 498     return 0;
 499 }
 500 
 501 void
 502 NET_SetTrafficClass(SOCKETADDRESS *sa, int trafficClass) {
 503     if (sa-&gt;sa.sa_family == AF_INET6) {
 504         sa-&gt;sa6.sin6_flowinfo = htonl((trafficClass &amp; 0xff) &lt;&lt; 20);
 505     }
 506 }
 507 
 508 int
 509 NET_IsIPv4Mapped(jbyte* caddr) {
 510     int i;
 511     for (i = 0; i &lt; 10; i++) {
 512         if (caddr[i] != 0x00) {
 513             return 0; /* false */
 514         }
 515     }
 516 
 517     if (((caddr[10] &amp; 0xff) == 0xff) &amp;&amp; ((caddr[11] &amp; 0xff) == 0xff)) {
 518         return 1; /* true */
 519     }
 520     return 0; /* false */
 521 }
 522 
 523 int
 524 NET_IPv4MappedToIPv4(jbyte* caddr) {
 525     return ((caddr[12] &amp; 0xff) &lt;&lt; 24) | ((caddr[13] &amp; 0xff) &lt;&lt; 16) | ((caddr[14] &amp; 0xff) &lt;&lt; 8)
 526         | (caddr[15] &amp; 0xff);
 527 }
 528 
 529 int
 530 NET_IsEqual(jbyte* caddr1, jbyte* caddr2) {
 531     int i;
 532     for (i = 0; i &lt; 16; i++) {
 533         if (caddr1[i] != caddr2[i]) {
 534             return 0; /* false */
 535         }
 536     }
 537     return 1;
 538 }
 539 
 540 int NET_IsZeroAddr(jbyte* caddr) {
 541     int i;
 542     for (i = 0; i &lt; 16; i++) {
 543         if (caddr[i] != 0) {
 544             return 0;
 545         }
 546     }
 547     return 1;
 548 }
 549 
 550 /*
 551  * Map the Java level socket option to the platform specific
 552  * level and option name.
 553  */
 554 int
 555 NET_MapSocketOption(jint cmd, int *level, int *optname) {
 556     static struct {
 557         jint cmd;
 558         int level;
 559         int optname;
 560     } const opts[] = {
 561         { java_net_SocketOptions_TCP_NODELAY,           IPPROTO_TCP,    TCP_NODELAY },
 562         { java_net_SocketOptions_SO_OOBINLINE,          SOL_SOCKET,     SO_OOBINLINE },
 563         { java_net_SocketOptions_SO_LINGER,             SOL_SOCKET,     SO_LINGER },
 564         { java_net_SocketOptions_SO_SNDBUF,             SOL_SOCKET,     SO_SNDBUF },
 565         { java_net_SocketOptions_SO_RCVBUF,             SOL_SOCKET,     SO_RCVBUF },
 566         { java_net_SocketOptions_SO_KEEPALIVE,          SOL_SOCKET,     SO_KEEPALIVE },
 567         { java_net_SocketOptions_SO_REUSEADDR,          SOL_SOCKET,     SO_REUSEADDR },
 568         { java_net_SocketOptions_SO_REUSEPORT,          SOL_SOCKET,     SO_REUSEPORT },
 569         { java_net_SocketOptions_SO_BROADCAST,          SOL_SOCKET,     SO_BROADCAST },
 570         { java_net_SocketOptions_IP_TOS,                IPPROTO_IP,     IP_TOS },
 571         { java_net_SocketOptions_IP_MULTICAST_IF,       IPPROTO_IP,     IP_MULTICAST_IF },
 572         { java_net_SocketOptions_IP_MULTICAST_IF2,      IPPROTO_IP,     IP_MULTICAST_IF },
 573         { java_net_SocketOptions_IP_MULTICAST_LOOP,     IPPROTO_IP,     IP_MULTICAST_LOOP },
 574     };
 575 
 576     int i;
 577 
 578     if (ipv6_available()) {
 579         switch (cmd) {
 580             // Different multicast options if IPv6 is enabled
 581             case java_net_SocketOptions_IP_MULTICAST_IF:
 582             case java_net_SocketOptions_IP_MULTICAST_IF2:
 583                 *level = IPPROTO_IPV6;
 584                 *optname = IPV6_MULTICAST_IF;
 585                 return 0;
 586 
 587             case java_net_SocketOptions_IP_MULTICAST_LOOP:
 588                 *level = IPPROTO_IPV6;
 589                 *optname = IPV6_MULTICAST_LOOP;
 590                 return 0;
<a name="7" id="anc7"></a><span class="line-modified"> 591 #if (defined(__solaris__) || defined(MACOSX))</span>
 592             // Map IP_TOS request to IPV6_TCLASS
 593             case java_net_SocketOptions_IP_TOS:
 594                 *level = IPPROTO_IPV6;
 595                 *optname = IPV6_TCLASS;
 596                 return 0;
 597 #endif
 598         }
 599     }
 600 
 601     /*
 602      * Map the Java level option to the native level
 603      */
 604     for (i=0; i&lt;(int)(sizeof(opts) / sizeof(opts[0])); i++) {
 605         if (cmd == opts[i].cmd) {
 606             *level = opts[i].level;
 607             *optname = opts[i].optname;
 608             return 0;
 609         }
 610     }
 611 
 612     /* not found */
 613     return -1;
 614 }
 615 
 616 /*
 617  * Wrapper for getsockopt system routine - does any necessary
 618  * pre/post processing to deal with OS specific oddities :-
 619  *
 620  * On Linux the SO_SNDBUF/SO_RCVBUF values must be post-processed
 621  * to compensate for an incorrect value returned by the kernel.
 622  */
 623 int
 624 NET_GetSockOpt(int fd, int level, int opt, void *result,
 625                int *len)
 626 {
 627     int rv;
 628     socklen_t socklen = *len;
 629 
 630     rv = getsockopt(fd, level, opt, result, &amp;socklen);
 631     *len = socklen;
 632 
 633     if (rv &lt; 0) {
 634         return rv;
 635     }
 636 
 637 #ifdef __linux__
 638     /*
 639      * On Linux SO_SNDBUF/SO_RCVBUF aren&#39;t symmetric. This
 640      * stems from additional socket structures in the send
 641      * and receive buffers.
 642      */
 643     if ((level == SOL_SOCKET) &amp;&amp; ((opt == SO_SNDBUF)
 644                                   || (opt == SO_RCVBUF))) {
 645         int n = *((int *)result);
 646         n /= 2;
 647         *((int *)result) = n;
 648     }
 649 #endif
 650 
 651 /* Workaround for Mac OS treating linger value as
 652  *  signed integer
 653  */
 654 #ifdef MACOSX
 655     if (level == SOL_SOCKET &amp;&amp; opt == SO_LINGER) {
 656         struct linger* to_cast = (struct linger*)result;
 657         to_cast-&gt;l_linger = (unsigned short)to_cast-&gt;l_linger;
 658     }
 659 #endif
 660     return rv;
 661 }
 662 
 663 /*
 664  * Wrapper for setsockopt system routine - performs any
 665  * necessary pre/post processing to deal with OS specific
 666  * issue :-
 667  *
 668  * On Solaris need to limit the suggested value for SO_SNDBUF
 669  * and SO_RCVBUF to the kernel configured limit
 670  *
 671  * For IP_TOS socket option need to mask off bits as this
 672  * aren&#39;t automatically masked by the kernel and results in
 673  * an error.
 674  */
 675 int
 676 NET_SetSockOpt(int fd, int level, int  opt, const void *arg,
 677                int len)
 678 {
 679 
 680 #ifndef IPTOS_TOS_MASK
 681 #define IPTOS_TOS_MASK 0x1e
 682 #endif
 683 #ifndef IPTOS_PREC_MASK
 684 #define IPTOS_PREC_MASK 0xe0
 685 #endif
 686 
 687 #if defined(_ALLBSD_SOURCE)
 688 #if defined(KIPC_MAXSOCKBUF)
 689     int mib[3];
 690     size_t rlen;
 691 #endif
 692 
 693     int *bufsize;
 694 
 695 #ifdef __APPLE__
 696     static int maxsockbuf = -1;
 697 #else
 698     static long maxsockbuf = -1;
 699 #endif
 700 #endif
 701 
 702     /*
 703      * IPPROTO/IP_TOS :-
 704      * 1. IPv6 on Solaris/Mac OS:
 705      *    Set the TOS OR Traffic Class value to cater for
 706      *    IPv6 and IPv4 scenarios.
 707      * 2. IPv6 on Linux: By default Linux ignores flowinfo
 708      *    field so enable IPV6_FLOWINFO_SEND so that flowinfo
 709      *    will be examined. We also set the IPv4 TOS option in this case.
 710      * 3. IPv4: set socket option based on ToS and Precedence
 711      *    fields (otherwise get invalid argument)
 712      */
 713     if (level == IPPROTO_IP &amp;&amp; opt == IP_TOS) {
 714         int *iptos;
 715 
 716 #if defined(__linux__)
 717         if (ipv6_available()) {
 718             int optval = 1;
 719             if (setsockopt(fd, IPPROTO_IPV6, IPV6_FLOWINFO_SEND,
 720                            (void *)&amp;optval, sizeof(optval)) &lt; 0) {
 721                 return -1;
 722             }
 723            /*
 724             * Let&#39;s also set the IPV6_TCLASS flag.
 725             * Linux appears to allow both IP_TOS and IPV6_TCLASS to be set
 726             * This helps in mixed environments where IPv4 and IPv6 sockets
 727             * are connecting.
 728             */
 729            if (setsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS,
 730                            arg, len) &lt; 0) {
 731                 return -1;
 732             }
 733         }
 734 #endif
 735 
 736         iptos = (int *)arg;
 737         *iptos &amp;= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
 738     }
 739 
<a name="8" id="anc8"></a><span class="line-removed"> 740     /*</span>
<span class="line-removed"> 741      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris we may need to clamp</span>
<span class="line-removed"> 742      * the value when it exceeds the system limit.</span>
<span class="line-removed"> 743      */</span>
<span class="line-removed"> 744 #ifdef __solaris__</span>
<span class="line-removed"> 745     if (level == SOL_SOCKET) {</span>
<span class="line-removed"> 746         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {</span>
<span class="line-removed"> 747             int sotype=0;</span>
<span class="line-removed"> 748             socklen_t arglen;</span>
<span class="line-removed"> 749             int *bufsize, maxbuf;</span>
<span class="line-removed"> 750             int ret;</span>
<span class="line-removed"> 751 </span>
<span class="line-removed"> 752             /* Attempt with the original size */</span>
<span class="line-removed"> 753             ret = setsockopt(fd, level, opt, arg, len);</span>
<span class="line-removed"> 754             if ((ret == 0) || (ret == -1 &amp;&amp; errno != ENOBUFS))</span>
<span class="line-removed"> 755                 return ret;</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757             /* Exceeded system limit so clamp and retry */</span>
<span class="line-removed"> 758 </span>
<span class="line-removed"> 759             arglen = sizeof(sotype);</span>
<span class="line-removed"> 760             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype,</span>
<span class="line-removed"> 761                            &amp;arglen) &lt; 0) {</span>
<span class="line-removed"> 762                 return -1;</span>
<span class="line-removed"> 763             }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765             /*</span>
<span class="line-removed"> 766              * We try to get tcp_maxbuf (and udp_max_buf) using</span>
<span class="line-removed"> 767              * an ioctl() that isn&#39;t available on all versions of Solaris.</span>
<span class="line-removed"> 768              * If that fails, we use the search algorithm in findMaxBuf()</span>
<span class="line-removed"> 769              */</span>
<span class="line-removed"> 770             if (!init_tcp_max_buf &amp;&amp; sotype == SOCK_STREAM) {</span>
<span class="line-removed"> 771                 tcp_max_buf = net_getParam(&quot;/dev/tcp&quot;, &quot;tcp_max_buf&quot;);</span>
<span class="line-removed"> 772                 if (tcp_max_buf == -1) {</span>
<span class="line-removed"> 773                     tcp_max_buf = findMaxBuf(fd, opt, SOCK_STREAM);</span>
<span class="line-removed"> 774                     if (tcp_max_buf == -1) {</span>
<span class="line-removed"> 775                         return -1;</span>
<span class="line-removed"> 776                     }</span>
<span class="line-removed"> 777                 }</span>
<span class="line-removed"> 778                 init_tcp_max_buf = 1;</span>
<span class="line-removed"> 779             } else if (!init_udp_max_buf &amp;&amp; sotype == SOCK_DGRAM) {</span>
<span class="line-removed"> 780                 udp_max_buf = net_getParam(&quot;/dev/udp&quot;, &quot;udp_max_buf&quot;);</span>
<span class="line-removed"> 781                 if (udp_max_buf == -1) {</span>
<span class="line-removed"> 782                     udp_max_buf = findMaxBuf(fd, opt, SOCK_DGRAM);</span>
<span class="line-removed"> 783                     if (udp_max_buf == -1) {</span>
<span class="line-removed"> 784                         return -1;</span>
<span class="line-removed"> 785                     }</span>
<span class="line-removed"> 786                 }</span>
<span class="line-removed"> 787                 init_udp_max_buf = 1;</span>
<span class="line-removed"> 788             }</span>
<span class="line-removed"> 789 </span>
<span class="line-removed"> 790             maxbuf = (sotype == SOCK_STREAM) ? tcp_max_buf : udp_max_buf;</span>
<span class="line-removed"> 791             bufsize = (int *)arg;</span>
<span class="line-removed"> 792             if (*bufsize &gt; maxbuf) {</span>
<span class="line-removed"> 793                 *bufsize = maxbuf;</span>
<span class="line-removed"> 794             }</span>
<span class="line-removed"> 795         }</span>
<span class="line-removed"> 796     }</span>
<span class="line-removed"> 797 #endif</span>
<span class="line-removed"> 798 </span>
 799 #ifdef _AIX
 800     if (level == SOL_SOCKET) {
 801         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
 802             /*
 803              * Just try to set the requested size. If it fails we will leave the
 804              * socket option as is. Setting the buffer size means only a hint in
 805              * the jse2/java software layer, see javadoc. In the previous
 806              * solution the buffer has always been truncated to a length of
 807              * 0x100000 Byte, even if the technical limit has not been reached.
 808              * This kind of absolute truncation was unexpected in the jck tests.
 809              */
 810             int ret = setsockopt(fd, level, opt, arg, len);
 811             if ((ret == 0) || (ret == -1 &amp;&amp; errno == ENOBUFS)) {
 812                 // Accept failure because of insufficient buffer memory resources.
 813                 return 0;
 814             } else {
 815                 // Deliver all other kinds of errors.
 816                 return ret;
 817             }
 818         }
 819     }
 820 #endif
 821 
 822     /*
 823      * On Linux the receive buffer is used for both socket
 824      * structures and the packet payload. The implication
 825      * is that if SO_RCVBUF is too small then small packets
 826      * must be discarded.
 827      */
 828 #ifdef __linux__
 829     if (level == SOL_SOCKET &amp;&amp; opt == SO_RCVBUF) {
 830         int *bufsize = (int *)arg;
 831         if (*bufsize &lt; 1024) {
 832             *bufsize = 1024;
 833         }
 834     }
 835 #endif
 836 
 837 #if defined(_ALLBSD_SOURCE)
 838     /*
 839      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
 840      * ensure that value is &lt;= kern.ipc.maxsockbuf as otherwise we get
 841      * an ENOBUFS error.
 842      */
 843     if (level == SOL_SOCKET) {
 844         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
 845 #ifdef KIPC_MAXSOCKBUF
 846             if (maxsockbuf == -1) {
 847                mib[0] = CTL_KERN;
 848                mib[1] = KERN_IPC;
 849                mib[2] = KIPC_MAXSOCKBUF;
 850                rlen = sizeof(maxsockbuf);
 851                if (sysctl(mib, 3, &amp;maxsockbuf, &amp;rlen, NULL, 0) == -1)
 852                    maxsockbuf = 1024;
 853 
 854 #if 1
 855                /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
 856                   problem.  It should be removed when kern.ipc.maxsockbuf
 857                   will be real value. */
 858                maxsockbuf = (maxsockbuf/5)*4;
 859 #endif
 860            }
 861 #elif defined(__OpenBSD__)
 862            maxsockbuf = SB_MAX;
 863 #else
 864            maxsockbuf = 64 * 1024;      /* XXX: NetBSD */
 865 #endif
 866 
 867            bufsize = (int *)arg;
 868            if (*bufsize &gt; maxsockbuf) {
 869                *bufsize = maxsockbuf;
 870            }
 871 
 872            if (opt == SO_RCVBUF &amp;&amp; *bufsize &lt; 1024) {
 873                 *bufsize = 1024;
 874            }
 875 
 876         }
 877     }
 878 #endif
 879 
 880 #if defined(_ALLBSD_SOURCE) || defined(_AIX)
 881     /*
 882      * On Solaris, SO_REUSEADDR will allow multiple datagram
 883      * sockets to bind to the same port. The network jck tests check
 884      * for this &quot;feature&quot;, so we need to emulate it by turning on
 885      * SO_REUSEPORT as well for that combination.
 886      */
 887     if (level == SOL_SOCKET &amp;&amp; opt == SO_REUSEADDR) {
 888         int sotype;
 889         socklen_t arglen;
 890 
 891         arglen = sizeof(sotype);
 892         if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&amp;sotype, &amp;arglen) &lt; 0) {
 893             return -1;
 894         }
 895 
 896         if (sotype == SOCK_DGRAM) {
 897             setsockopt(fd, level, SO_REUSEPORT, arg, len);
 898         }
 899     }
 900 #endif
 901 
 902     return setsockopt(fd, level, opt, arg, len);
 903 }
 904 
 905 /*
 906  * Wrapper for bind system call - performs any necessary pre/post
 907  * processing to deal with OS specific issues :-
 908  *
 909  * Linux allows a socket to bind to 127.0.0.255 which must be
 910  * caught.
<a name="9" id="anc9"></a><span class="line-removed"> 911  *</span>
<span class="line-removed"> 912  * On Solaris with IPv6 enabled we must use an exclusive</span>
<span class="line-removed"> 913  * bind to guarantee a unique port number across the IPv4 and</span>
<span class="line-removed"> 914  * IPv6 port spaces.</span>
<span class="line-removed"> 915  *</span>
 916  */
 917 int
 918 NET_Bind(int fd, SOCKETADDRESS *sa, int len)
 919 {
<a name="10" id="anc10"></a><span class="line-removed"> 920 #if defined(__solaris__)</span>
<span class="line-removed"> 921     int level = -1;</span>
<span class="line-removed"> 922     int exclbind = -1;</span>
<span class="line-removed"> 923 #endif</span>
 924     int rv;
 925     int arg, alen;
 926 
 927 #ifdef __linux__
 928     /*
 929      * ## get bugId for this issue - goes back to 1.2.2 port ##
 930      * ## When IPv6 is enabled this will be an IPv4-mapped
 931      * ## with family set to AF_INET6
 932      */
 933     if (sa-&gt;sa.sa_family == AF_INET) {
 934         if ((ntohl(sa-&gt;sa4.sin_addr.s_addr) &amp; 0x7f0000ff) == 0x7f0000ff) {
 935             errno = EADDRNOTAVAIL;
 936             return -1;
 937         }
 938     }
 939 #endif
 940 
<a name="11" id="anc11"></a><span class="line-removed"> 941 #if defined(__solaris__)</span>
<span class="line-removed"> 942     /*</span>
<span class="line-removed"> 943      * Solaris has separate IPv4 and IPv6 port spaces so we</span>
<span class="line-removed"> 944      * use an exclusive bind when SO_REUSEADDR is not used to</span>
<span class="line-removed"> 945      * give the illusion of a unified port space.</span>
<span class="line-removed"> 946      * This also avoids problems with IPv6 sockets connecting</span>
<span class="line-removed"> 947      * to IPv4 mapped addresses whereby the socket conversion</span>
<span class="line-removed"> 948      * results in a late bind that fails because the</span>
<span class="line-removed"> 949      * corresponding IPv4 port is in use.</span>
<span class="line-removed"> 950      */</span>
<span class="line-removed"> 951     alen = sizeof(arg);</span>
<span class="line-removed"> 952 </span>
<span class="line-removed"> 953     if (useExclBind ||</span>
<span class="line-removed"> 954         getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;arg, &amp;alen) == 0)</span>
<span class="line-removed"> 955     {</span>
<span class="line-removed"> 956         if (useExclBind || arg == 0) {</span>
<span class="line-removed"> 957             /*</span>
<span class="line-removed"> 958              * SO_REUSEADDR is disabled or sun.net.useExclusiveBind</span>
<span class="line-removed"> 959              * property is true so enable TCP_EXCLBIND or</span>
<span class="line-removed"> 960              * UDP_EXCLBIND</span>
<span class="line-removed"> 961              */</span>
<span class="line-removed"> 962             alen = sizeof(arg);</span>
<span class="line-removed"> 963             if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&amp;arg, &amp;alen) == 0)</span>
<span class="line-removed"> 964             {</span>
<span class="line-removed"> 965                 if (arg == SOCK_STREAM) {</span>
<span class="line-removed"> 966                     level = IPPROTO_TCP;</span>
<span class="line-removed"> 967                     exclbind = TCP_EXCLBIND;</span>
<span class="line-removed"> 968                 } else {</span>
<span class="line-removed"> 969                     level = IPPROTO_UDP;</span>
<span class="line-removed"> 970                     exclbind = UDP_EXCLBIND;</span>
<span class="line-removed"> 971                 }</span>
<span class="line-removed"> 972             }</span>
<span class="line-removed"> 973 </span>
<span class="line-removed"> 974             arg = 1;</span>
<span class="line-removed"> 975             setsockopt(fd, level, exclbind, (char *)&amp;arg, sizeof(arg));</span>
<span class="line-removed"> 976         }</span>
<span class="line-removed"> 977     }</span>
<span class="line-removed"> 978 </span>
<span class="line-removed"> 979 #endif</span>
<span class="line-removed"> 980 </span>
 981     rv = bind(fd, &amp;sa-&gt;sa, len);
 982 
<a name="12" id="anc12"></a><span class="line-removed"> 983 #if defined(__solaris__)</span>
<span class="line-removed"> 984     if (rv &lt; 0) {</span>
<span class="line-removed"> 985         int en = errno;</span>
<span class="line-removed"> 986         /* Restore *_EXCLBIND if the bind fails */</span>
<span class="line-removed"> 987         if (exclbind != -1) {</span>
<span class="line-removed"> 988             int arg = 0;</span>
<span class="line-removed"> 989             setsockopt(fd, level, exclbind, (char *)&amp;arg,</span>
<span class="line-removed"> 990                        sizeof(arg));</span>
<span class="line-removed"> 991         }</span>
<span class="line-removed"> 992         errno = en;</span>
<span class="line-removed"> 993     }</span>
<span class="line-removed"> 994 #endif</span>
<span class="line-removed"> 995 </span>
 996     return rv;
 997 }
 998 
 999 /**
1000  * Wrapper for poll with timeout on a single file descriptor.
1001  *
1002  * flags (defined in net_util_md.h can be any combination of
1003  * NET_WAIT_READ, NET_WAIT_WRITE &amp; NET_WAIT_CONNECT.
1004  *
1005  * The function will return when either the socket is ready for one
1006  * of the specified operations or the timeout expired.
1007  *
1008  * It returns the time left from the timeout (possibly 0), or -1 if it expired.
1009  */
1010 
1011 jint
1012 NET_Wait(JNIEnv *env, jint fd, jint flags, jint timeout)
1013 {
1014     jlong prevNanoTime = JVM_NanoTime(env, 0);
1015     jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;
1016     jint read_rv;
1017 
1018     while (1) {
1019         jlong newNanoTime;
1020         struct pollfd pfd;
1021         pfd.fd = fd;
1022         pfd.events = 0;
1023         if (flags &amp; NET_WAIT_READ)
1024           pfd.events |= POLLIN;
1025         if (flags &amp; NET_WAIT_WRITE)
1026           pfd.events |= POLLOUT;
1027         if (flags &amp; NET_WAIT_CONNECT)
1028           pfd.events |= POLLOUT;
1029 
1030         errno = 0;
1031         read_rv = NET_Poll(&amp;pfd, 1, nanoTimeout / NET_NSEC_PER_MSEC);
1032 
1033         newNanoTime = JVM_NanoTime(env, 0);
1034         nanoTimeout -= (newNanoTime - prevNanoTime);
1035         if (nanoTimeout &lt; NET_NSEC_PER_MSEC) {
1036           return read_rv &gt; 0 ? 0 : -1;
1037         }
1038         prevNanoTime = newNanoTime;
1039 
1040         if (read_rv &gt; 0) {
1041           break;
1042         }
1043       } /* while */
1044     return (nanoTimeout / NET_NSEC_PER_MSEC);
1045 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
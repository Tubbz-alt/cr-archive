<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/unix/native/libnet/NetworkInterface.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 #include &lt;arpa/inet.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;net/if.h&gt;
  28 #ifndef TARGET_IOS
  29 #include &lt;net/if_arp.h&gt;
  30 #endif
  31 #include &lt;stdlib.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;sys/ioctl.h&gt;
  34 
  35 #if defined(_AIX)
  36 #include &lt;netinet/in6_var.h&gt;
  37 #include &lt;sys/ndd_var.h&gt;
  38 #include &lt;sys/kinfo.h&gt;
  39 #include &lt;strings.h&gt;
  40 #endif
  41 
  42 #if defined(_ALLBSD_SOURCE)
  43 #include &lt;net/ethernet.h&gt;
  44 #include &lt;net/if_dl.h&gt;
  45 #include &lt;ifaddrs.h&gt;
  46 #endif
  47 
  48 #include &quot;net_util.h&quot;
  49 
  50 #include &quot;java_net_InetAddress.h&quot;
  51 
  52 #if defined(__linux__)
  53     #define _PATH_PROCNET_IFINET6 &quot;/proc/net/if_inet6&quot;
  54 #endif
  55 
  56 #ifdef LIFNAMSIZ
  57     #define IFNAMESIZE LIFNAMSIZ
  58 #else
  59     #define IFNAMESIZE IFNAMSIZ
  60 #endif
  61 
  62 #define CHECKED_MALLOC3(_pointer, _type, _size) \
  63     do { \
  64         _pointer = (_type)malloc(_size); \
  65         if (_pointer == NULL) { \
  66             JNU_ThrowOutOfMemoryError(env, &quot;Native heap allocation failed&quot;); \
  67             return ifs; /* return untouched list */ \
  68         } \
  69     } while(0)
  70 
  71 typedef struct _netaddr  {
  72     struct sockaddr *addr;
  73     struct sockaddr *brdcast;
  74     short mask;
  75     int family; /* to make searches simple */
  76     struct _netaddr *next;
  77 } netaddr;
  78 
  79 typedef struct _netif {
  80     char *name;
  81     int index;
  82     char virtual;
  83     netaddr *addr;
  84     struct _netif *childs;
  85     struct _netif *next;
  86 } netif;
  87 
  88 /************************************************************************
  89  * NetworkInterface
  90  */
  91 
  92 #include &quot;java_net_NetworkInterface.h&quot;
  93 
  94 /************************************************************************
  95  * NetworkInterface
  96  */
  97 jclass ni_class;
  98 jfieldID ni_nameID;
  99 jfieldID ni_indexID;
 100 jfieldID ni_descID;
 101 jfieldID ni_addrsID;
 102 jfieldID ni_bindsID;
 103 jfieldID ni_virutalID;
 104 jfieldID ni_childsID;
 105 jfieldID ni_parentID;
 106 jfieldID ni_defaultIndexID;
 107 jmethodID ni_ctrID;
 108 
 109 static jclass ni_ibcls;
 110 static jmethodID ni_ibctrID;
 111 static jfieldID ni_ibaddressID;
 112 static jfieldID ni_ib4broadcastID;
 113 static jfieldID ni_ib4maskID;
 114 
 115 /** Private methods declarations **/
 116 static jobject createNetworkInterface(JNIEnv *env, netif *ifs);
 117 static int     getFlags0(JNIEnv *env, jstring  ifname);
 118 
 119 static netif  *enumInterfaces(JNIEnv *env);
 120 static netif  *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs);
 121 static netif  *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs);
 122 
 123 static netif  *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 124                      struct sockaddr *ifr_addrP,
 125                      struct sockaddr *ifr_broadaddrP,
 126                      int family, short prefix);
 127 static void    freeif(netif *ifs);
 128 
 129 static int     openSocket(JNIEnv *env, int proto);
 130 static int     openSocketWithFallback(JNIEnv *env, const char *ifname);
 131 
 132 static short   translateIPv4AddressToPrefix(struct sockaddr_in *addr);
 133 static short   translateIPv6AddressToPrefix(struct sockaddr_in6 *addr);
 134 
 135 static int     getIndex(int sock, const char *ifname);
 136 static int     getFlags(int sock, const char *ifname, int *flags);
 137 static int     getMacAddress(JNIEnv *env, const char *ifname,
 138                              const struct in_addr *addr, unsigned char *buf);
 139 static int     getMTU(JNIEnv *env, int sock, const char *ifname);
 140 
 141 /******************* Java entry points *****************************/
 142 
 143 /*
 144  * Class:     java_net_NetworkInterface
 145  * Method:    init
 146  * Signature: ()V
 147  */
 148 JNIEXPORT void JNICALL Java_java_net_NetworkInterface_init
 149   (JNIEnv *env, jclass cls)
 150 {
 151     ni_class = (*env)-&gt;FindClass(env, &quot;java/net/NetworkInterface&quot;);
 152     CHECK_NULL(ni_class);
 153     ni_class = (*env)-&gt;NewGlobalRef(env, ni_class);
 154     CHECK_NULL(ni_class);
 155     ni_nameID = (*env)-&gt;GetFieldID(env, ni_class, &quot;name&quot;, &quot;Ljava/lang/String;&quot;);
 156     CHECK_NULL(ni_nameID);
 157     ni_indexID = (*env)-&gt;GetFieldID(env, ni_class, &quot;index&quot;, &quot;I&quot;);
 158     CHECK_NULL(ni_indexID);
 159     ni_addrsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;addrs&quot;,
 160                                     &quot;[Ljava/net/InetAddress;&quot;);
 161     CHECK_NULL(ni_addrsID);
 162     ni_bindsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;bindings&quot;,
 163                                     &quot;[Ljava/net/InterfaceAddress;&quot;);
 164     CHECK_NULL(ni_bindsID);
 165     ni_descID = (*env)-&gt;GetFieldID(env, ni_class, &quot;displayName&quot;,
 166                                    &quot;Ljava/lang/String;&quot;);
 167     CHECK_NULL(ni_descID);
 168     ni_virutalID = (*env)-&gt;GetFieldID(env, ni_class, &quot;virtual&quot;, &quot;Z&quot;);
 169     CHECK_NULL(ni_virutalID);
 170     ni_childsID = (*env)-&gt;GetFieldID(env, ni_class, &quot;childs&quot;,
 171                                      &quot;[Ljava/net/NetworkInterface;&quot;);
 172     CHECK_NULL(ni_childsID);
 173     ni_parentID = (*env)-&gt;GetFieldID(env, ni_class, &quot;parent&quot;,
 174                                      &quot;Ljava/net/NetworkInterface;&quot;);
 175     CHECK_NULL(ni_parentID);
 176     ni_ctrID = (*env)-&gt;GetMethodID(env, ni_class, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 177     CHECK_NULL(ni_ctrID);
 178     ni_ibcls = (*env)-&gt;FindClass(env, &quot;java/net/InterfaceAddress&quot;);
 179     CHECK_NULL(ni_ibcls);
 180     ni_ibcls = (*env)-&gt;NewGlobalRef(env, ni_ibcls);
 181     CHECK_NULL(ni_ibcls);
 182     ni_ibctrID = (*env)-&gt;GetMethodID(env, ni_ibcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 183     CHECK_NULL(ni_ibctrID);
 184     ni_ibaddressID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;address&quot;,
 185                                         &quot;Ljava/net/InetAddress;&quot;);
 186     CHECK_NULL(ni_ibaddressID);
 187     ni_ib4broadcastID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;broadcast&quot;,
 188                                            &quot;Ljava/net/Inet4Address;&quot;);
 189     CHECK_NULL(ni_ib4broadcastID);
 190     ni_ib4maskID = (*env)-&gt;GetFieldID(env, ni_ibcls, &quot;maskLength&quot;, &quot;S&quot;);
 191     CHECK_NULL(ni_ib4maskID);
 192     ni_defaultIndexID = (*env)-&gt;GetStaticFieldID(env, ni_class, &quot;defaultIndex&quot;,
 193                                                  &quot;I&quot;);
 194     CHECK_NULL(ni_defaultIndexID);
 195     initInetAddressIDs(env);
 196 }
 197 
 198 /*
 199  * Class:     java_net_NetworkInterface
 200  * Method:    getByName0
 201  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 202  */
 203 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByName0
 204   (JNIEnv *env, jclass cls, jstring name)
 205 {
 206     netif *ifs, *curr;
 207     jboolean isCopy;
 208     const char* name_utf;
 209     char *colonP;
 210     char searchName[IFNAMESIZE];
 211     jobject obj = NULL;
 212 
 213     if (name != NULL) {
 214         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 215     } else {
 216         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 217         return NULL;
 218     }
 219 
 220     if (name_utf == NULL) {
 221         if (!(*env)-&gt;ExceptionCheck(env))
 222             JNU_ThrowOutOfMemoryError(env, NULL);
 223         return NULL;
 224     }
 225 
 226     ifs = enumInterfaces(env);
 227     if (ifs == NULL) {
 228         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 229         return NULL;
 230     }
 231 
 232     // search the list of interfaces based on name,
 233     // if it is virtual sub interface search with parent first.
 234     strncpy(searchName, name_utf, IFNAMESIZE);
 235     searchName[IFNAMESIZE - 1] = &#39;\0&#39;;
 236     colonP = strchr(searchName, &#39;:&#39;);
 237     if (colonP != NULL) {
 238         *colonP = &#39;\0&#39;;
 239     }
 240     curr = ifs;
 241     while (curr != NULL) {
 242         if (strcmp(searchName, curr-&gt;name) == 0) {
 243             break;
 244         }
 245         curr = curr-&gt;next;
 246     }
 247 
 248     // search the child list
 249     if (colonP != NULL &amp;&amp; curr != NULL) {
 250         curr = curr-&gt;childs;
 251         while (curr != NULL) {
 252             if (strcmp(name_utf, curr-&gt;name) == 0) {
 253                 break;
 254             }
 255             curr = curr-&gt;next;
 256         }
 257     }
 258 
 259     // if found create a NetworkInterface
 260     if (curr != NULL) {
 261         obj = createNetworkInterface(env, curr);
 262     }
 263 
 264     // release the UTF string and interface list
 265     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 266     freeif(ifs);
 267 
 268     return obj;
 269 }
 270 
 271 /*
 272  * Class:     java_net_NetworkInterface
 273  * Method:    getByIndex0
 274  * Signature: (Ljava/lang/String;)Ljava/net/NetworkInterface;
 275  */
 276 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByIndex0
 277   (JNIEnv *env, jclass cls, jint index)
 278 {
 279     netif *ifs, *curr;
 280     jobject obj = NULL;
 281 
 282     if (index &lt;= 0) {
 283         return NULL;
 284     }
 285 
 286     ifs = enumInterfaces(env);
 287     if (ifs == NULL) {
 288         return NULL;
 289     }
 290 
 291     // search the list of interfaces based on index
 292     curr = ifs;
 293     while (curr != NULL) {
 294         if (index == curr-&gt;index) {
 295             break;
 296         }
 297         curr = curr-&gt;next;
 298     }
 299 
 300     // if found create a NetworkInterface
 301     if (curr != NULL) {
 302         obj = createNetworkInterface(env, curr);
 303     }
 304 
 305     // release the interface list
 306     freeif(ifs);
 307 
 308     return obj;
 309 }
 310 
 311 // Return the interface in ifs that iaObj is bound to, if any - otherwise NULL
 312 static netif* find_bound_interface(JNIEnv *env, netif* ifs, jobject iaObj, int family) {
 313     netif* curr = ifs;
 314     while (curr != NULL) {
 315         netaddr *addrP = curr-&gt;addr;
 316 
 317         // iterate through each address on the interface
 318         while (addrP != NULL) {
 319 
 320             if (family == addrP-&gt;family) {
 321                 if (family == AF_INET) {
 322                     int address1 = htonl(
 323                         ((struct sockaddr_in *)addrP-&gt;addr)-&gt;sin_addr.s_addr);
 324                     int address2 = getInetAddress_addr(env, iaObj);
 325                     if ((*env)-&gt;ExceptionCheck(env)) {
 326                         return NULL;
 327                     }
 328                     if (address1 == address2) {
 329                         return curr;
 330                     }
 331                 } else if (family == AF_INET6) {
 332                     jbyte *bytes = (jbyte *)&amp;(
 333                         ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr);
 334                     jbyte caddr[16];
 335                     int i;
 336                     unsigned int scopeid;
 337                     getInet6Address_ipaddress(env, iaObj, (char *)caddr);
 338                     scopeid = (unsigned int)getInet6Address_scopeid(env, iaObj);
 339                     if (scopeid != 0 &amp;&amp; scopeid != ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id)
 340                         break;
 341                     i = 0;
 342                     while (i &lt; 16) {
 343                         if (caddr[i] != bytes[i]) {
 344                             break;
 345                         }
 346                         i++;
 347                     }
 348                     if (i &gt;= 16) {
 349                         return curr;
 350                     }
 351                 }
 352             }
 353 
 354             addrP = addrP-&gt;next;
 355         }
 356         curr = curr-&gt;next;
 357     }
 358 
 359     return NULL;
 360 }
 361 
 362 /*
 363  * Class:     java_net_NetworkInterface
 364  * Method:    boundInetAddress0
 365  * Signature: (Ljava/net/InetAddress;)boundInetAddress;
 366  */
 367 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_boundInetAddress0
 368     (JNIEnv *env, jclass cls, jobject iaObj)
 369 {
 370     netif *ifs = NULL;
 371     jboolean bound = JNI_FALSE;
 372     int sock;
 373 
 374     int family = getInetAddress_family(env, iaObj);
 375     JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 376 
 377     if (family == java_net_InetAddress_IPv4) {
 378         family = AF_INET;
 379     } else if (family == java_net_InetAddress_IPv6) {
 380         family = AF_INET6;
 381     } else {
 382         return JNI_FALSE; // Invalid family
 383     }
 384 
 385     if (family == AF_INET) {
 386         sock = openSocket(env, AF_INET);
 387         if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {
 388             return JNI_FALSE;
 389         }
 390 
 391         // enumerate IPv4 addresses
 392         if (sock &gt;= 0) {
 393             ifs = enumIPv4Interfaces(env, sock, ifs);
 394             close(sock);
 395 
 396             if ((*env)-&gt;ExceptionOccurred(env)) {
 397                 goto cleanup;
 398             }
 399         }
 400         if (find_bound_interface(env, ifs, iaObj, family) != NULL)
 401             bound = JNI_TRUE;
 402     } else if (ipv6_available()) {
 403         // If IPv6 is available then enumerate IPv6 addresses.
 404         // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 405         // so we have to call ipv6_available()
 406         sock = openSocket(env, AF_INET6);
 407         if (sock &lt; 0) {
 408             return JNI_FALSE;
 409         }
 410 
 411         ifs = enumIPv6Interfaces(env, sock, ifs);
 412         close(sock);
 413 
 414         if ((*env)-&gt;ExceptionOccurred(env)) {
 415             goto cleanup;
 416         }
 417 
 418         if (find_bound_interface(env, ifs, iaObj, family) != NULL)
 419             bound = JNI_TRUE;
 420     }
 421 
 422 cleanup:
 423     freeif(ifs);
 424 
 425     return bound;
 426 }
 427 
 428 /*
 429  * Class:     java_net_NetworkInterface
 430  * Method:    getByInetAddress0
 431  * Signature: (Ljava/net/InetAddress;)Ljava/net/NetworkInterface;
 432  */
 433 JNIEXPORT jobject JNICALL Java_java_net_NetworkInterface_getByInetAddress0
 434   (JNIEnv *env, jclass cls, jobject iaObj)
 435 {
 436     netif *ifs, *curr;
 437     jobject obj = NULL;
 438     int family = getInetAddress_family(env, iaObj);
 439     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 440 
 441     if (family == java_net_InetAddress_IPv4) {
 442         family = AF_INET;
 443     } else if (family == java_net_InetAddress_IPv6) {
 444         family = AF_INET6;
 445     } else {
 446         return NULL; // Invalid family
 447     }
 448     ifs = enumInterfaces(env);
 449     if (ifs == NULL) {
 450         return NULL;
 451     }
 452 
 453     curr = find_bound_interface(env, ifs, iaObj, family);
 454 
 455     // if found create a NetworkInterface
 456     if (curr != NULL) {
 457         obj = createNetworkInterface(env, curr);
 458     }
 459 
 460     // release the interface list
 461     freeif(ifs);
 462 
 463     return obj;
 464 }
 465 
 466 /*
 467  * Class:     java_net_NetworkInterface
 468  * Method:    getAll
 469  * Signature: ()[Ljava/net/NetworkInterface;
 470  */
 471 JNIEXPORT jobjectArray JNICALL Java_java_net_NetworkInterface_getAll
 472   (JNIEnv *env, jclass cls)
 473 {
 474     netif *ifs, *curr;
 475     jobjectArray netIFArr;
 476     jint arr_index, ifCount;
 477 
 478     ifs = enumInterfaces(env);
 479     if (ifs == NULL) {
 480         return NULL;
 481     }
 482 
 483     // count the interfaces
 484     ifCount = 0;
 485     curr = ifs;
 486     while (curr != NULL) {
 487         ifCount++;
 488         curr = curr-&gt;next;
 489     }
 490 
 491     // allocate a NetworkInterface array
 492     netIFArr = (*env)-&gt;NewObjectArray(env, ifCount, cls, NULL);
 493     if (netIFArr == NULL) {
 494         freeif(ifs);
 495         return NULL;
 496     }
 497 
 498     // iterate through the interfaces, create a NetworkInterface instance
 499     // for each array element and populate the object
 500     curr = ifs;
 501     arr_index = 0;
 502     while (curr != NULL) {
 503         jobject netifObj;
 504 
 505         netifObj = createNetworkInterface(env, curr);
 506         if (netifObj == NULL) {
 507             freeif(ifs);
 508             return NULL;
 509         }
 510 
 511         // put the NetworkInterface into the array
 512         (*env)-&gt;SetObjectArrayElement(env, netIFArr, arr_index++, netifObj);
 513 
 514         curr = curr-&gt;next;
 515     }
 516 
 517     // release the interface list
 518     freeif(ifs);
 519 
 520     return netIFArr;
 521 }
 522 
 523 /*
 524  * Class:     java_net_NetworkInterface
 525  * Method:    isUp0
 526  * Signature: (Ljava/lang/String;I)Z
 527  */
 528 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isUp0
 529   (JNIEnv *env, jclass cls, jstring name, jint index)
 530 {
 531     int ret = getFlags0(env, name);
 532     return ((ret &amp; IFF_UP) &amp;&amp; (ret &amp; IFF_RUNNING)) ? JNI_TRUE :  JNI_FALSE;
 533 }
 534 
 535 /*
 536  * Class:     java_net_NetworkInterface
 537  * Method:    isP2P0
 538  * Signature: (Ljava/lang/String;I)Z
 539  */
 540 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isP2P0
 541   (JNIEnv *env, jclass cls, jstring name, jint index)
 542 {
 543     int ret = getFlags0(env, name);
 544     return (ret &amp; IFF_POINTOPOINT) ? JNI_TRUE :  JNI_FALSE;
 545 }
 546 
 547 /*
 548  * Class:     java_net_NetworkInterface
 549  * Method:    isLoopback0
 550  * Signature: (Ljava/lang/String;I)Z
 551  */
 552 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_isLoopback0
 553   (JNIEnv *env, jclass cls, jstring name, jint index)
 554 {
 555     int ret = getFlags0(env, name);
 556     return (ret &amp; IFF_LOOPBACK) ? JNI_TRUE :  JNI_FALSE;
 557 }
 558 
 559 /*
 560  * Class:     java_net_NetworkInterface
 561  * Method:    supportsMulticast0
 562  * Signature: (Ljava/lang/String;I)Z
 563  */
 564 JNIEXPORT jboolean JNICALL Java_java_net_NetworkInterface_supportsMulticast0
 565   (JNIEnv *env, jclass cls, jstring name, jint index)
 566 {
 567     int ret = getFlags0(env, name);
 568     return (ret &amp; IFF_MULTICAST) ? JNI_TRUE :  JNI_FALSE;
 569 }
 570 
 571 /*
 572  * Class:     java_net_NetworkInterface
 573  * Method:    getMacAddr0
 574  * Signature: ([bLjava/lang/String;I)[b
 575  */
 576 JNIEXPORT jbyteArray JNICALL Java_java_net_NetworkInterface_getMacAddr0
 577   (JNIEnv *env, jclass cls, jbyteArray addrArray, jstring name, jint index)
 578 {
 579     jint addr;
 580     jbyte caddr[4];
 581     struct in_addr iaddr;
 582     jbyteArray ret = NULL;
 583     unsigned char mac[16];
 584     int len;
 585     jboolean isCopy;
 586     const char *name_utf;
 587 
 588     if (name != NULL) {
 589         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 590     } else {
 591         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 592         return NULL;
 593     }
 594 
 595     if (name_utf == NULL) {
 596         if (!(*env)-&gt;ExceptionCheck(env))
 597             JNU_ThrowOutOfMemoryError(env, NULL);
 598         return NULL;
 599     }
 600 
 601     if (!IS_NULL(addrArray)) {
 602         (*env)-&gt;GetByteArrayRegion(env, addrArray, 0, 4, caddr);
 603         addr = ((caddr[0]&lt;&lt;24) &amp; 0xff000000);
 604         addr |= ((caddr[1] &lt;&lt;16) &amp; 0xff0000);
 605         addr |= ((caddr[2] &lt;&lt;8) &amp; 0xff00);
 606         addr |= (caddr[3] &amp; 0xff);
 607         iaddr.s_addr = htonl(addr);
 608         len = getMacAddress(env, name_utf, &amp;iaddr, mac);
 609     } else {
 610         len = getMacAddress(env, name_utf, NULL, mac);
 611     }
 612 
 613     if (len &gt; 0) {
 614         ret = (*env)-&gt;NewByteArray(env, len);
 615         if (!IS_NULL(ret)) {
 616             (*env)-&gt;SetByteArrayRegion(env, ret, 0, len, (jbyte *)(mac));
 617         }
 618     }
 619 
 620     // release the UTF string and interface list
 621     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 622 
 623     return ret;
 624 }
 625 
 626 /*
 627  * Class:       java_net_NetworkInterface
 628  * Method:      getMTU0
 629  * Signature:   ([bLjava/lang/String;I)I
 630  */
 631 JNIEXPORT jint JNICALL Java_java_net_NetworkInterface_getMTU0
 632   (JNIEnv *env, jclass cls, jstring name, jint index)
 633 {
 634     jboolean isCopy;
 635     int sock, ret = -1;
 636     const char* name_utf = NULL;
 637 
 638     if (name != NULL) {
 639         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 640     } else {
 641         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 642         return ret;
 643     }
 644 
 645     if (name_utf == NULL) {
 646         if (!(*env)-&gt;ExceptionCheck(env))
 647             JNU_ThrowOutOfMemoryError(env, NULL);
 648         return ret;
 649     }
 650 
 651     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 652         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 653         return JNI_FALSE;
 654     }
 655 
 656     ret = getMTU(env, sock, name_utf);
 657 
 658     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 659 
 660     close(sock);
 661     return ret;
 662 }
 663 
 664 /*** Private methods definitions ****/
 665 
 666 static int getFlags0(JNIEnv *env, jstring name) {
 667     jboolean isCopy;
 668     int ret, sock, flags = 0;
 669     const char *name_utf;
 670 
 671     if (name != NULL) {
 672         name_utf = (*env)-&gt;GetStringUTFChars(env, name, &amp;isCopy);
 673     } else {
 674         JNU_ThrowNullPointerException(env, &quot;network interface name is NULL&quot;);
 675         return -1;
 676     }
 677 
 678     if (name_utf == NULL) {
 679         if (!(*env)-&gt;ExceptionCheck(env))
 680             JNU_ThrowOutOfMemoryError(env, NULL);
 681         return -1;
 682     }
 683     if ((sock = openSocketWithFallback(env, name_utf)) &lt; 0) {
 684         (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 685         return -1;
 686     }
 687 
 688     ret = getFlags(sock, name_utf, &amp;flags);
 689 
 690     close(sock);
 691     (*env)-&gt;ReleaseStringUTFChars(env, name, name_utf);
 692 
 693     if (ret &lt; 0) {
 694         JNU_ThrowByNameWithMessageAndLastError
 695             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getFlags() failed&quot;);
 696         return -1;
 697     }
 698 
 699     return flags;
 700 }
 701 
 702 /*
 703  * Creates a NetworkInterface object, populates the name, the index, and
 704  * populates the InetAddress array based on the IP addresses for this
 705  * interface.
 706  */
 707 static jobject createNetworkInterface(JNIEnv *env, netif *ifs) {
 708     jobject netifObj;
 709     jobject name;
 710     jobjectArray addrArr;
 711     jobjectArray bindArr;
 712     jobjectArray childArr;
 713     netaddr *addrs;
 714     jint addr_index, addr_count, bind_index;
 715     jint child_count, child_index;
 716     netaddr *addrP;
 717     netif *childP;
 718     jobject tmp;
 719 
 720     // create a NetworkInterface object and populate it
 721     netifObj = (*env)-&gt;NewObject(env, ni_class, ni_ctrID);
 722     CHECK_NULL_RETURN(netifObj, NULL);
 723     name = (*env)-&gt;NewStringUTF(env, ifs-&gt;name);
 724     CHECK_NULL_RETURN(name, NULL);
 725     (*env)-&gt;SetObjectField(env, netifObj, ni_nameID, name);
 726     (*env)-&gt;SetObjectField(env, netifObj, ni_descID, name);
 727     (*env)-&gt;SetIntField(env, netifObj, ni_indexID, ifs-&gt;index);
 728     (*env)-&gt;SetBooleanField(env, netifObj, ni_virutalID,
 729                             ifs-&gt;virtual ? JNI_TRUE : JNI_FALSE);
 730 
 731     // count the number of addresses on this interface
 732     addr_count = 0;
 733     addrP = ifs-&gt;addr;
 734     while (addrP != NULL) {
 735         addr_count++;
 736         addrP = addrP-&gt;next;
 737     }
 738 
 739     // create the array of InetAddresses
 740     addrArr = (*env)-&gt;NewObjectArray(env, addr_count, ia_class, NULL);
 741     if (addrArr == NULL) {
 742         return NULL;
 743     }
 744 
 745     bindArr = (*env)-&gt;NewObjectArray(env, addr_count, ni_ibcls, NULL);
 746     if (bindArr == NULL) {
 747        return NULL;
 748     }
 749     addrP = ifs-&gt;addr;
 750     addr_index = 0;
 751     bind_index = 0;
 752     while (addrP != NULL) {
 753         jobject iaObj = NULL;
 754         jobject ibObj = NULL;
 755 
 756         if (addrP-&gt;family == AF_INET) {
 757             iaObj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 758             if (iaObj) {
 759                 setInetAddress_addr(env, iaObj, htonl(
 760                     ((struct sockaddr_in*)addrP-&gt;addr)-&gt;sin_addr.s_addr));
 761                 JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 762             } else {
 763                 return NULL;
 764             }
 765             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 766             if (ibObj) {
 767                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 768                 if (addrP-&gt;brdcast) {
 769                     jobject ia2Obj = NULL;
 770                     ia2Obj = (*env)-&gt;NewObject(env, ia4_class, ia4_ctrID);
 771                     if (ia2Obj) {
 772                         setInetAddress_addr(env, ia2Obj, htonl(
 773                             ((struct sockaddr_in*)addrP-&gt;brdcast)-&gt;sin_addr.s_addr));
 774                         JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 775                         (*env)-&gt;SetObjectField(env, ibObj, ni_ib4broadcastID, ia2Obj);
 776                     } else {
 777                         return NULL;
 778                     }
 779                 }
 780                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 781                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 782             } else {
 783                 return NULL;
 784             }
 785         }
 786         if (addrP-&gt;family == AF_INET6) {
 787             int scope=0;
 788             iaObj = (*env)-&gt;NewObject(env, ia6_class, ia6_ctrID);
 789             if (iaObj) {
 790                 jboolean ret = setInet6Address_ipaddress(env, iaObj,
 791                     (char *)&amp;(((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_addr));
 792                 if (ret == JNI_FALSE) {
 793                     return NULL;
 794                 }
 795 
 796                 scope = ((struct sockaddr_in6*)addrP-&gt;addr)-&gt;sin6_scope_id;
 797 
 798                 if (scope != 0) { /* zero is default value, no need to set */
 799                     setInet6Address_scopeid(env, iaObj, scope);
 800                     setInet6Address_scopeifname(env, iaObj, netifObj);
 801                 }
 802             } else {
 803                 return NULL;
 804             }
 805             ibObj = (*env)-&gt;NewObject(env, ni_ibcls, ni_ibctrID);
 806             if (ibObj) {
 807                 (*env)-&gt;SetObjectField(env, ibObj, ni_ibaddressID, iaObj);
 808                 (*env)-&gt;SetShortField(env, ibObj, ni_ib4maskID, addrP-&gt;mask);
 809                 (*env)-&gt;SetObjectArrayElement(env, bindArr, bind_index++, ibObj);
 810             } else {
 811                 return NULL;
 812             }
 813         }
 814 
 815         (*env)-&gt;SetObjectArrayElement(env, addrArr, addr_index++, iaObj);
 816         addrP = addrP-&gt;next;
 817     }
 818 
 819     // see if there is any virtual interface attached to this one.
 820     child_count = 0;
 821     childP = ifs-&gt;childs;
 822     while (childP) {
 823         child_count++;
 824         childP = childP-&gt;next;
 825     }
 826 
 827     childArr = (*env)-&gt;NewObjectArray(env, child_count, ni_class, NULL);
 828     if (childArr == NULL) {
 829         return NULL;
 830     }
 831 
 832     // create the NetworkInterface instances for the sub-interfaces as well
 833     child_index = 0;
 834     childP = ifs-&gt;childs;
 835     while(childP) {
 836         tmp = createNetworkInterface(env, childP);
 837         if (tmp == NULL) {
 838             return NULL;
 839         }
 840         (*env)-&gt;SetObjectField(env, tmp, ni_parentID, netifObj);
 841         (*env)-&gt;SetObjectArrayElement(env, childArr, child_index++, tmp);
 842         childP = childP-&gt;next;
 843     }
 844     (*env)-&gt;SetObjectField(env, netifObj, ni_addrsID, addrArr);
 845     (*env)-&gt;SetObjectField(env, netifObj, ni_bindsID, bindArr);
 846     (*env)-&gt;SetObjectField(env, netifObj, ni_childsID, childArr);
 847 
 848     // return the NetworkInterface
 849     return netifObj;
 850 }
 851 
 852 /*
 853  * Enumerates all interfaces
 854  */
 855 static netif *enumInterfaces(JNIEnv *env) {
 856     netif *ifs = NULL;
 857     int sock;
 858 
 859     sock = openSocket(env, AF_INET);
 860     if (sock &lt; 0 &amp;&amp; (*env)-&gt;ExceptionOccurred(env)) {
 861         return NULL;
 862     }
 863 
 864     // enumerate IPv4 addresses
 865     if (sock &gt;= 0) {
 866         ifs = enumIPv4Interfaces(env, sock, ifs);
 867         close(sock);
 868 
 869         if ((*env)-&gt;ExceptionOccurred(env)) {
 870             freeif(ifs);
 871             return NULL;
 872         }
 873     }
 874 
 875     // If IPv6 is available then enumerate IPv6 addresses.
 876     // User can disable ipv6 explicitly by -Djava.net.preferIPv4Stack=true,
 877     // so we have to call ipv6_available()
 878     if (ipv6_available()) {
 879         sock = openSocket(env, AF_INET6);
 880         if (sock &lt; 0) {
 881             freeif(ifs);
 882             return NULL;
 883         }
 884 
 885         ifs = enumIPv6Interfaces(env, sock, ifs);
 886         close(sock);
 887 
 888         if ((*env)-&gt;ExceptionOccurred(env)) {
 889             freeif(ifs);
 890             return NULL;
 891         }
 892     }
 893 
 894     return ifs;
 895 }
 896 
 897 /*
 898  * Frees an interface list (including any attached addresses).
 899  */
 900 static void freeif(netif *ifs) {
 901     netif *currif = ifs;
 902     netif *child = NULL;
 903 
 904     while (currif != NULL) {
 905         netaddr *addrP = currif-&gt;addr;
 906         while (addrP != NULL) {
 907             netaddr *next = addrP-&gt;next;
 908             free(addrP);
 909             addrP = next;
 910         }
 911 
 912         // don&#39;t forget to free the sub-interfaces
 913         if (currif-&gt;childs != NULL) {
 914             freeif(currif-&gt;childs);
 915         }
 916 
 917         ifs = currif-&gt;next;
 918         free(currif);
 919         currif = ifs;
 920     }
 921 }
 922 
 923 static netif *addif(JNIEnv *env, int sock, const char *if_name, netif *ifs,
 924                     struct sockaddr *ifr_addrP,
 925                     struct sockaddr *ifr_broadaddrP,
 926                     int family, short prefix)
 927 {
 928     netif *currif = ifs, *parent;
 929     netaddr *addrP;
 930     char name[IFNAMESIZE], vname[IFNAMESIZE];
 931     char *name_colonP;
 932     int isVirtual = 0;
 933     int addr_size;
 934 
 935     // If the interface name is a logical interface then we remove the unit
 936     // number so that we have the physical interface (eg: hme0:1 -&gt; hme0).
 937     // NetworkInterface currently doesn&#39;t have any concept of physical vs.
 938     // logical interfaces.
 939     strncpy(name, if_name, IFNAMESIZE);
 940     name[IFNAMESIZE - 1] = &#39;\0&#39;;
 941     *vname = 0;
 942 
 943     // Create and populate the netaddr node. If allocation fails
 944     // return an un-updated list.
 945 
 946     // Allocate for addr and brdcast at once
 947 
 948     addr_size = (family == AF_INET) ? sizeof(struct sockaddr_in)
 949                                     : sizeof(struct sockaddr_in6);
 950 
 951     CHECKED_MALLOC3(addrP, netaddr *, sizeof(netaddr) + 2 * addr_size);
 952     addrP-&gt;addr = (struct sockaddr *)((char *)addrP + sizeof(netaddr));
 953     memcpy(addrP-&gt;addr, ifr_addrP, addr_size);
 954 
 955     addrP-&gt;family = family;
 956     addrP-&gt;mask = prefix;
 957     addrP-&gt;next = 0;
 958 
 959     // for IPv4 add broadcast address
 960     if (family == AF_INET &amp;&amp; ifr_broadaddrP != NULL) {
 961         addrP-&gt;brdcast = (struct sockaddr *)
 962                              ((char *)addrP + sizeof(netaddr) + addr_size);
 963         memcpy(addrP-&gt;brdcast, ifr_broadaddrP, addr_size);
 964     } else {
 965         addrP-&gt;brdcast = NULL;
 966     }
 967 
 968     // Deal with virtual interface with colon notation e.g. eth0:1
 969     name_colonP = strchr(name, &#39;:&#39;);
 970     if (name_colonP != NULL) {
 971         int flags = 0;
 972         // This is a virtual interface. If we are able to access the parent
 973         // we need to create a new entry if it doesn&#39;t exist yet *and* update
 974         // the &#39;parent&#39; interface with the new records.
 975         *name_colonP = 0;
 976         if (getFlags(sock, name, &amp;flags) &lt; 0 || flags &lt; 0) {
 977             // failed to access parent interface do not create parent.
 978             // We are a virtual interface with no parent.
 979             isVirtual = 1;
 980             *name_colonP = &#39;:&#39;;
 981         } else {
 982             // Got access to parent, so create it if necessary.
 983             // Save original name to vname and truncate name by &#39;:&#39;
 984             memcpy(vname, name, sizeof(vname));
 985             vname[name_colonP - name] = &#39;:&#39;;
 986         }
 987     }
 988 
 989     // Check if this is a &quot;new&quot; interface. Use the interface name for
 990     // matching because index isn&#39;t supported on Solaris 2.6 &amp; 7.
 991     while (currif != NULL) {
 992         if (strcmp(name, currif-&gt;name) == 0) {
 993             break;
 994         }
 995         currif = currif-&gt;next;
 996     }
 997 
 998     // If &quot;new&quot; then create a netif structure and insert it into the list.
 999     if (currif == NULL) {
1000          CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
1001          currif-&gt;name = (char *)currif + sizeof(netif);
1002          strncpy(currif-&gt;name, name, IFNAMESIZE);
1003          currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
1004          currif-&gt;index = getIndex(sock, name);
1005          currif-&gt;addr = NULL;
1006          currif-&gt;childs = NULL;
1007          currif-&gt;virtual = isVirtual;
1008          currif-&gt;next = ifs;
1009          ifs = currif;
1010     }
1011 
1012     // Finally insert the address on the interface
1013     addrP-&gt;next = currif-&gt;addr;
1014     currif-&gt;addr = addrP;
1015 
1016     parent = currif;
1017 
1018     // Deal with the virtual interface now.
1019     if (vname[0]) {
1020         netaddr *tmpaddr;
1021 
1022         currif = parent-&gt;childs;
1023 
1024         while (currif != NULL) {
1025             if (strcmp(vname, currif-&gt;name) == 0) {
1026                 break;
1027             }
1028             currif = currif-&gt;next;
1029         }
1030 
1031         if (currif == NULL) {
1032             CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);
1033             currif-&gt;name = (char *)currif + sizeof(netif);
1034             strncpy(currif-&gt;name, vname, IFNAMESIZE);
1035             currif-&gt;name[IFNAMESIZE - 1] = &#39;\0&#39;;
1036             currif-&gt;index = getIndex(sock, vname);
1037             currif-&gt;addr = NULL; // Need to duplicate the addr entry?
1038             currif-&gt;virtual = 1;
1039             currif-&gt;childs = NULL;
1040             currif-&gt;next = parent-&gt;childs;
1041             parent-&gt;childs = currif;
1042         }
1043 
1044         CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);
1045         memcpy(tmpaddr, addrP, sizeof(netaddr));
1046         if (addrP-&gt;addr != NULL) {
1047             tmpaddr-&gt;addr = (struct sockaddr *)
1048                 ((char*)tmpaddr + sizeof(netaddr));
1049             memcpy(tmpaddr-&gt;addr, addrP-&gt;addr, addr_size);
1050         }
1051 
1052         if (addrP-&gt;brdcast != NULL) {
1053             tmpaddr-&gt;brdcast = (struct sockaddr *)
1054                 ((char *)tmpaddr + sizeof(netaddr) + addr_size);
1055             memcpy(tmpaddr-&gt;brdcast, addrP-&gt;brdcast, addr_size);
1056         }
1057 
1058         tmpaddr-&gt;next = currif-&gt;addr;
1059         currif-&gt;addr = tmpaddr;
1060     }
1061 
1062     return ifs;
1063 }
1064 
1065 /*
1066  * Determines the prefix value for an AF_INET subnet address.
1067  */
1068 static short translateIPv4AddressToPrefix(struct sockaddr_in *addr) {
1069     short prefix = 0;
1070     unsigned int mask;
1071     if (addr == NULL) {
1072         return 0;
1073     }
1074     mask = ntohl(addr-&gt;sin_addr.s_addr);
1075     while (mask) {
1076         mask &lt;&lt;= 1;
1077         prefix++;
1078     }
1079     return prefix;
1080 }
1081 
1082 /*
1083  * Determines the prefix value for an AF_INET6 subnet address.
1084  */
1085 static short translateIPv6AddressToPrefix(struct sockaddr_in6 *addr) {
1086     short prefix = 0;
1087     u_char *addrBytes;
1088     if (addr == NULL) {
1089         return 0;
1090     }
1091     addrBytes = (u_char *)&amp;(addr-&gt;sin6_addr);
1092     unsigned int byte, bit;
1093 
1094     for (byte = 0; byte &lt; sizeof(struct in6_addr); byte++, prefix += 8) {
1095         if (addrBytes[byte] != 0xff) {
1096             break;
1097         }
1098     }
1099     if (byte != sizeof(struct in6_addr)) {
1100         for (bit = 7; bit != 0; bit--, prefix++) {
1101             if (!(addrBytes[byte] &amp; (1 &lt;&lt; bit))) {
1102                 break;
1103             }
1104         }
1105         for (; bit != 0; bit--) {
1106             if (addrBytes[byte] &amp; (1 &lt;&lt; bit)) {
1107                 prefix = 0;
1108                 break;
1109             }
1110         }
1111         if (prefix &gt; 0) {
1112             byte++;
1113             for (; byte &lt; sizeof(struct in6_addr); byte++) {
1114                 if (addrBytes[byte]) {
1115                     prefix = 0;
1116                 }
1117             }
1118         }
1119     }
1120 
1121     return prefix;
1122 }
1123 
1124 /*
1125  * Opens a socket for further ioct calls. proto is one of AF_INET or AF_INET6.
1126  */
1127 static int openSocket(JNIEnv *env, int proto) {
1128     int sock;
1129 
1130     if ((sock = socket(proto, SOCK_DGRAM, 0)) &lt; 0) {
1131         // If we lack support for this address family or protocol,
1132         // don&#39;t throw an exception.
1133         if (errno != EPROTONOSUPPORT &amp;&amp; errno != EAFNOSUPPORT) {
1134             JNU_ThrowByNameWithMessageAndLastError
1135                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;Socket creation failed&quot;);
1136         }
1137         return -1;
1138     }
1139 
1140     return sock;
1141 }
1142 
1143 /** Linux **/
1144 #if defined(__linux__)
1145 
1146 /*
1147  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1148  * if it fails return AF_INET6 socket.
1149  */
1150 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1151     int sock;
1152 
1153     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1154         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1155             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1156                 JNU_ThrowByNameWithMessageAndLastError
1157                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1158                 return -1;
1159             }
1160         } else { // errno is not NOSUPPORT
1161             JNU_ThrowByNameWithMessageAndLastError
1162                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1163             return -1;
1164         }
1165     }
1166 
1167     // Linux starting from 2.6.? kernel allows ioctl call with either IPv4 or
1168     // IPv6 socket regardless of type of address of an interface.
1169     return sock;
1170 }
1171 
1172 /*
1173  * Enumerates and returns all IPv4 interfaces on Linux.
1174  */
1175 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1176     struct ifconf ifc;
1177     struct ifreq *ifreqP;
1178     char *buf = NULL;
1179     unsigned i;
1180 
1181     // do a dummy SIOCGIFCONF to determine the buffer size
1182     // SIOCGIFCOUNT doesn&#39;t work
1183     ifc.ifc_buf = NULL;
1184     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1185         JNU_ThrowByNameWithMessageAndLastError
1186             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1187         return ifs;
1188     }
1189 
1190     // call SIOCGIFCONF to enumerate the interfaces
1191     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1192     ifc.ifc_buf = buf;
1193     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1194         JNU_ThrowByNameWithMessageAndLastError
1195             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1196         free(buf);
1197         return ifs;
1198     }
1199 
1200     // iterate through each interface
1201     ifreqP = ifc.ifc_req;
1202     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1203         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1204         short prefix = 0;
1205 
1206         // ignore non IPv4 addresses
1207         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1208             continue;
1209         }
1210 
1211         // save socket address
1212         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1213 
1214         // determine broadcast address, if applicable
1215         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1216             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1217 
1218             // restore socket address to ifreqP
1219             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1220 
1221             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1222                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1223                        sizeof(struct sockaddr));
1224                 broadaddrP = &amp;broadaddr;
1225             }
1226         }
1227 
1228         // restore socket address to ifreqP
1229         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1230 
1231         // determine netmask
1232         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1233             prefix = translateIPv4AddressToPrefix(
1234                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_netmask));
1235         }
1236 
1237         // add interface to the list
1238         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1239                     &amp;addr, broadaddrP, AF_INET, prefix);
1240 
1241         // in case of exception, free interface list and buffer and return NULL
1242         if ((*env)-&gt;ExceptionOccurred(env)) {
1243             free(buf);
1244             freeif(ifs);
1245             return NULL;
1246         }
1247     }
1248 
1249     // free buffer
1250     free(buf);
1251     return ifs;
1252 }
1253 
1254 /*
1255  * Enumerates and returns all IPv6 interfaces on Linux.
1256  */
1257 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1258     FILE *f;
1259     char devname[21], addr6p[8][5];
1260     int prefix, scope, dad_status, if_idx;
1261 
1262     if ((f = fopen(_PATH_PROCNET_IFINET6, &quot;r&quot;)) != NULL) {
1263         while (fscanf(f, &quot;%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\n&quot;,
1264                       addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1265                       addr6p[4], addr6p[5], addr6p[6], addr6p[7],
1266                       &amp;if_idx, &amp;prefix, &amp;scope, &amp;dad_status, devname) != EOF) {
1267 
1268             char addr6[40];
1269             struct sockaddr_in6 addr;
1270 
1271             sprintf(addr6, &quot;%s:%s:%s:%s:%s:%s:%s:%s&quot;,
1272                     addr6p[0], addr6p[1], addr6p[2], addr6p[3],
1273                     addr6p[4], addr6p[5], addr6p[6], addr6p[7]);
1274 
1275             memset(&amp;addr, 0, sizeof(struct sockaddr_in6));
1276             inet_pton(AF_INET6, addr6, (void*)addr.sin6_addr.s6_addr);
1277 
1278             // set scope ID to interface index
1279             addr.sin6_scope_id = if_idx;
1280 
1281             // add interface to the list
1282             ifs = addif(env, sock, devname, ifs, (struct sockaddr *)&amp;addr,
1283                         NULL, AF_INET6, (short)prefix);
1284 
1285             // if an exception occurred then return the list as is
1286             if ((*env)-&gt;ExceptionOccurred(env)) {
1287                 break;
1288             }
1289        }
1290        fclose(f);
1291     }
1292     return ifs;
1293 }
1294 
1295 /*
1296  * Try to get the interface index.
1297  */
1298 static int getIndex(int sock, const char *name) {
1299     struct ifreq if2;
1300     memset((char *)&amp;if2, 0, sizeof(if2));
1301     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
1302 
1303     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
1304         return -1;
1305     }
1306 
1307     return if2.ifr_ifindex;
1308 }
1309 
1310 /*
1311  * Gets the Hardware address (usually MAC address) for the named interface.
1312  * On return puts the data in buf, and returns the length, in byte, of the
1313  * MAC address. Returns -1 if there is no hardware address on that interface.
1314  */
1315 static int getMacAddress
1316   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1317    unsigned char *buf)
1318 {
1319     struct ifreq ifr;
1320     int i, sock;
1321 
1322     if ((sock = openSocketWithFallback(env, ifname)) &lt; 0) {
1323         return -1;
1324     }
1325 
1326     memset((char *)&amp;ifr, 0, sizeof(ifr));
1327     strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
1328     if (ioctl(sock, SIOCGIFHWADDR, &amp;ifr) &lt; 0) {
1329         JNU_ThrowByNameWithMessageAndLastError
1330             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFHWADDR) failed&quot;);
1331         close(sock);
1332         return -1;
1333     }
1334 
1335     close(sock);
1336     memcpy(buf, &amp;ifr.ifr_hwaddr.sa_data, IFHWADDRLEN);
1337 
1338     // all bytes to 0 means no hardware address
1339     for (i = 0; i &lt; IFHWADDRLEN; i++) {
1340         if (buf[i] != 0)
1341             return IFHWADDRLEN;
1342     }
1343 
1344     return -1;
1345 }
1346 
1347 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1348     struct ifreq if2;
1349     memset((char *)&amp;if2, 0, sizeof(if2));
1350     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1351 
1352     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1353         JNU_ThrowByNameWithMessageAndLastError
1354             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1355         return -1;
1356     }
1357 
1358     return if2.ifr_mtu;
1359 }
1360 
1361 static int getFlags(int sock, const char *ifname, int *flags) {
1362     struct ifreq if2;
1363     memset((char *)&amp;if2, 0, sizeof(if2));
1364     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1365 
1366     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1367         return -1;
1368     }
1369 
1370     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1371         *flags = (if2.ifr_flags &amp; 0xffff);
1372     } else {
1373         *flags = if2.ifr_flags;
1374     }
1375     return 0;
1376 }
1377 
1378 #endif /* __linux__ */
1379 
1380 /** AIX **/
1381 #if defined(_AIX)
1382 
1383 /* seems getkerninfo is guarded by _KERNEL in the system headers */
1384 /* see net/proto_uipc.h */
1385 int getkerninfo(int, char *, int *, int32long64_t);
1386 
1387 /*
1388  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1389  * if it fails return AF_INET6 socket.
1390  */
1391 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1392     int sock;
1393 
1394     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1395         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1396             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1397                 JNU_ThrowByNameWithMessageAndLastError
1398                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1399                 return -1;
1400             }
1401         } else { // errno is not NOSUPPORT
1402             JNU_ThrowByNameWithMessageAndLastError
1403                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1404             return -1;
1405         }
1406     }
1407 
1408     return sock;
1409 }
1410 
1411 /*
1412  * Enumerates and returns all IPv4 interfaces on AIX.
1413  */
1414 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1415     struct ifconf ifc;
1416     struct ifreq *ifreqP;
1417     char *buf = NULL;
1418     unsigned i;
1419 
1420     // call SIOCGSIZIFCONF to get the size of SIOCGIFCONF buffer
1421     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1422         JNU_ThrowByNameWithMessageAndLastError
1423             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1424         return ifs;
1425     }
1426 
1427     // call CSIOCGIFCONF instead of SIOCGIFCONF where interface
1428     // records will always have sizeof(struct ifreq) length.
1429     // Be aware that only IPv4 data is complete this way.
1430     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1431     ifc.ifc_buf = buf;
1432     if (ioctl(sock, CSIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1433         JNU_ThrowByNameWithMessageAndLastError
1434             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(CSIOCGIFCONF) failed&quot;);
1435         free(buf);
1436         return ifs;
1437     }
1438 
1439     // iterate through each interface
1440     ifreqP = ifc.ifc_req;
1441     for (i = 0; i &lt; ifc.ifc_len / sizeof(struct ifreq); i++, ifreqP++) {
1442         struct sockaddr addr, broadaddr, *broadaddrP = NULL;
1443         short prefix = 0;
1444 
1445         // ignore non IPv4 addresses
1446         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET) {
1447             continue;
1448         }
1449 
1450         // save socket address
1451         memcpy(&amp;addr, &amp;(ifreqP-&gt;ifr_addr), sizeof(struct sockaddr));
1452 
1453         // determine broadcast address, if applicable
1454         if ((ioctl(sock, SIOCGIFFLAGS, ifreqP) == 0) &amp;&amp;
1455             ifreqP-&gt;ifr_flags &amp; IFF_BROADCAST) {
1456 
1457             // restore socket address to ifreqP
1458             memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1459 
1460             if (ioctl(sock, SIOCGIFBRDADDR, ifreqP) == 0) {
1461                 memcpy(&amp;broadaddr, &amp;(ifreqP-&gt;ifr_broadaddr),
1462                        sizeof(struct sockaddr));
1463                 broadaddrP = &amp;broadaddr;
1464             }
1465         }
1466 
1467         // restore socket address to ifreqP
1468         memcpy(&amp;(ifreqP-&gt;ifr_addr), &amp;addr, sizeof(struct sockaddr));
1469 
1470         // determine netmask
1471         if (ioctl(sock, SIOCGIFNETMASK, ifreqP) == 0) {
1472             prefix = translateIPv4AddressToPrefix(
1473                          (struct sockaddr_in *)&amp;(ifreqP-&gt;ifr_addr));
1474         }
1475 
1476         // add interface to the list
1477         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1478                     &amp;addr, broadaddrP, AF_INET, prefix);
1479 
1480         // in case of exception, free interface list and buffer and return NULL
1481         if ((*env)-&gt;ExceptionOccurred(env)) {
1482             free(buf);
1483             freeif(ifs);
1484             return NULL;
1485         }
1486     }
1487 
1488     // free buffer
1489     free(buf);
1490     return ifs;
1491 }
1492 
1493 /*
1494  * Enumerates and returns all IPv6 interfaces on AIX.
1495  */
1496 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1497     struct ifconf ifc;
1498     struct ifreq *ifreqP;
1499     char *buf, *cp, *cplimit;
1500 
1501     // call SIOCGSIZIFCONF to get size for SIOCGIFCONF buffer
1502     if (ioctl(sock, SIOCGSIZIFCONF, &amp;(ifc.ifc_len)) &lt; 0) {
1503         JNU_ThrowByNameWithMessageAndLastError
1504             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGSIZIFCONF) failed&quot;);
1505         return ifs;
1506     }
1507 
1508     // call SIOCGIFCONF to enumerate the interfaces
1509     CHECKED_MALLOC3(buf, char *, ifc.ifc_len);
1510     ifc.ifc_buf = buf;
1511     if (ioctl(sock, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) {
1512         JNU_ThrowByNameWithMessageAndLastError
1513             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFCONF) failed&quot;);
1514         free(buf);
1515         return ifs;
1516     }
1517 
1518     // iterate through each interface
1519     ifreqP = ifc.ifc_req;
1520     cp = (char *)ifc.ifc_req;
1521     cplimit = cp + ifc.ifc_len;
1522 
1523     for (; cp &lt; cplimit;
1524          cp += (sizeof(ifreqP-&gt;ifr_name) +
1525                 MAX((ifreqP-&gt;ifr_addr).sa_len, sizeof(ifreqP-&gt;ifr_addr))))
1526     {
1527         ifreqP = (struct ifreq *)cp;
1528         short prefix = 0;
1529 
1530         // ignore non IPv6 addresses
1531         if (ifreqP-&gt;ifr_addr.sa_family != AF_INET6) {
1532             continue;
1533         }
1534 
1535         // determine netmask
1536         struct in6_ifreq if6;
1537         memset((char *)&amp;if6, 0, sizeof(if6));
1538         strncpy(if6.ifr_name, ifreqP-&gt;ifr_name, sizeof(if6.ifr_name) - 1);
1539         memcpy(&amp;(if6.ifr_Addr), &amp;(ifreqP-&gt;ifr_addr),
1540                sizeof(struct sockaddr_in6));
1541         if (ioctl(sock, SIOCGIFNETMASK6, (char *)&amp;if6) &gt;= 0) {
1542             prefix = translateIPv6AddressToPrefix(&amp;(if6.ifr_Addr));
1543         }
1544 
1545         // set scope ID to interface index
1546         ((struct sockaddr_in6 *)&amp;(ifreqP-&gt;ifr_addr))-&gt;sin6_scope_id =
1547             getIndex(sock, ifreqP-&gt;ifr_name);
1548 
1549         // add interface to the list
1550         ifs = addif(env, sock, ifreqP-&gt;ifr_name, ifs,
1551                     (struct sockaddr *)&amp;(ifreqP-&gt;ifr_addr),
1552                     NULL, AF_INET6, prefix);
1553 
1554         // if an exception occurred then free the list
1555         if ((*env)-&gt;ExceptionOccurred(env)) {
1556             free(buf);
1557             freeif(ifs);
1558             return NULL;
1559         }
1560     }
1561 
1562     // free buffer
1563     free(buf);
1564     return ifs;
1565 }
1566 
1567 /*
1568  * Try to get the interface index.
1569  */
1570 static int getIndex(int sock, const char *name) {
1571     int index = if_nametoindex(name);
1572     return (index == 0) ? -1 : index;
1573 }
1574 
1575 /*
1576  * Gets the Hardware address (usually MAC address) for the named interface.
1577  * On return puts the data in buf, and returns the length, in byte, of the
1578  * MAC address. Returns -1 if there is no hardware address on that interface.
1579  */
1580 static int getMacAddress
1581   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1582    unsigned char *buf)
1583 {
1584     int size;
1585     struct kinfo_ndd *nddp;
1586     void *end;
1587 
1588     size = getkerninfo(KINFO_NDD, 0, 0, 0);
1589     if (size == 0) {
1590         return -1;
1591     }
1592 
1593     if (size &lt; 0) {
1594         perror(&quot;getkerninfo 1&quot;);
1595         return -1;
1596     }
1597 
1598     nddp = (struct kinfo_ndd *)malloc(size);
1599 
1600     if (!nddp) {
1601         JNU_ThrowOutOfMemoryError(env,
1602             &quot;Network interface getMacAddress native buffer allocation failed&quot;);
1603         return -1;
1604     }
1605 
1606     if (getkerninfo(KINFO_NDD, (char*) nddp, &amp;size, 0) &lt; 0) {
1607         perror(&quot;getkerninfo 2&quot;);
1608         free(nddp);
1609         return -1;
1610     }
1611 
1612     end = (void *)nddp + size;
1613     while ((void *)nddp &lt; end) {
1614         if (!strcmp(nddp-&gt;ndd_alias, ifname) ||
1615                  !strcmp(nddp-&gt;ndd_name, ifname)) {
1616             bcopy(nddp-&gt;ndd_addr, buf, 6);
1617             free(nddp);
1618             return 6;
1619         } else {
1620             nddp++;
1621         }
1622     }
1623 
1624     free(nddp);
1625     return -1;
1626 }
1627 
1628 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1629     struct ifreq if2;
1630     memset((char *)&amp;if2, 0, sizeof(if2));
1631     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1632 
1633     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1634         JNU_ThrowByNameWithMessageAndLastError
1635             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1636         return -1;
1637     }
1638 
1639     return if2.ifr_mtu;
1640 }
1641 
1642 static int getFlags(int sock, const char *ifname, int *flags) {
1643     struct ifreq if2;
1644     memset((char *)&amp;if2, 0, sizeof(if2));
1645     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1646 
1647     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1648         return -1;
1649     }
1650 
1651     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1652         *flags = (if2.ifr_flags &amp; 0xffff);
1653     } else {
1654         *flags = if2.ifr_flags;
1655     }
1656     return 0;
1657 }
1658 
1659 #endif /* _AIX */
1660 
1661 /** BSD **/
1662 #if defined(_ALLBSD_SOURCE)
1663 
1664 /*
1665  * Opens a socket for further ioctl calls. Tries AF_INET socket first and
1666  * if it fails return AF_INET6 socket.
1667  */
1668 static int openSocketWithFallback(JNIEnv *env, const char *ifname) {
1669     int sock;
1670 
1671     if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
1672         if (errno == EPROTONOSUPPORT || errno == EAFNOSUPPORT) {
1673             if ((sock = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0) {
1674                 JNU_ThrowByNameWithMessageAndLastError
1675                     (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV6 Socket creation failed&quot;);
1676                 return -1;
1677             }
1678         } else { // errno is not NOSUPPORT
1679             JNU_ThrowByNameWithMessageAndLastError
1680                 (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;IPV4 Socket creation failed&quot;);
1681             return -1;
1682         }
1683     }
1684 
1685     return sock;
1686 }
1687 
1688 /*
1689  * Enumerates and returns all IPv4 interfaces on BSD.
1690  */
1691 static netif *enumIPv4Interfaces(JNIEnv *env, int sock, netif *ifs) {
1692     struct ifaddrs *ifa, *origifa;
1693 
1694     if (getifaddrs(&amp;origifa) != 0) {
1695         JNU_ThrowByNameWithMessageAndLastError
1696             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
1697         return ifs;
1698     }
1699 
1700     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
1701         struct sockaddr *broadaddrP = NULL;
1702 
1703         // ignore non IPv4 addresses
1704         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET)
1705             continue;
1706 
1707         // set ifa_broadaddr, if there is one
1708         if ((ifa-&gt;ifa_flags &amp; IFF_POINTOPOINT) == 0 &amp;&amp;
1709             ifa-&gt;ifa_flags &amp; IFF_BROADCAST) {
1710             broadaddrP = ifa-&gt;ifa_dstaddr;
1711         }
1712 
1713         // add interface to the list
1714         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr,
1715                     broadaddrP, AF_INET,
1716                     translateIPv4AddressToPrefix((struct sockaddr_in *)
1717                                                  ifa-&gt;ifa_netmask));
1718 
1719         // if an exception occurred then free the list
1720         if ((*env)-&gt;ExceptionOccurred(env)) {
1721             freeifaddrs(origifa);
1722             freeif(ifs);
1723             return NULL;
1724         }
1725     }
1726 
1727     // free ifaddrs buffer
1728     freeifaddrs(origifa);
1729     return ifs;
1730 }
1731 
1732 /*
1733  * Enumerates and returns all IPv6 interfaces on BSD.
1734  */
1735 static netif *enumIPv6Interfaces(JNIEnv *env, int sock, netif *ifs) {
1736     struct ifaddrs *ifa, *origifa;
1737 
1738     if (getifaddrs(&amp;origifa) != 0) {
1739         JNU_ThrowByNameWithMessageAndLastError
1740             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;getifaddrs() failed&quot;);
1741         return ifs;
1742     }
1743 
1744     for (ifa = origifa; ifa != NULL; ifa = ifa-&gt;ifa_next) {
1745         // ignore non IPv6 addresses
1746         if (ifa-&gt;ifa_addr == NULL || ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6)
1747             continue;
1748 
1749         // set scope ID to interface index
1750         ((struct sockaddr_in6 *)ifa-&gt;ifa_addr)-&gt;sin6_scope_id =
1751             getIndex(sock, ifa-&gt;ifa_name);
1752 
1753         // add interface to the list
1754         ifs = addif(env, sock, ifa-&gt;ifa_name, ifs, ifa-&gt;ifa_addr, NULL,
1755                     AF_INET6,
1756                     translateIPv6AddressToPrefix((struct sockaddr_in6 *)
1757                                                  ifa-&gt;ifa_netmask));
1758 
1759         // if an exception occurred then free the list
1760         if ((*env)-&gt;ExceptionOccurred(env)) {
1761             freeifaddrs(origifa);
1762             freeif(ifs);
1763             return NULL;
1764         }
1765     }
1766 
1767     // free ifaddrs buffer
1768     freeifaddrs(origifa);
1769     return ifs;
1770 }
1771 
1772 /*
1773  * Try to get the interface index.
1774  */
1775 static int getIndex(int sock, const char *name) {
1776 #if !defined(__FreeBSD__)
1777     int index = if_nametoindex(name);
1778     return (index == 0) ? -1 : index;
1779 #else
1780     struct ifreq if2;
1781     memset((char *)&amp;if2, 0, sizeof(if2));
1782     strncpy(if2.ifr_name, name, sizeof(if2.ifr_name) - 1);
1783 
1784     if (ioctl(sock, SIOCGIFINDEX, (char *)&amp;if2) &lt; 0) {
1785         return -1;
1786     }
1787 
1788     return if2.ifr_index;
1789 #endif
1790 }
1791 
1792 /*
1793  * Gets the Hardware address (usually MAC address) for the named interface.
1794  * On return puts the data in buf, and returns the length, in byte, of the
1795  * MAC address. Returns -1 if there is no hardware address on that interface.
1796  */
1797 static int getMacAddress
1798   (JNIEnv *env, const char *ifname, const struct in_addr *addr,
1799    unsigned char *buf)
1800 {
1801     struct ifaddrs *ifa0, *ifa;
1802     struct sockaddr *saddr;
1803     int i;
1804 
1805     // grab the interface list
1806     if (!getifaddrs(&amp;ifa0)) {
1807         // cycle through the interfaces
1808         for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa-&gt;ifa_next, i++) {
1809             saddr = ifa-&gt;ifa_addr;
1810             if (saddr != NULL) {
1811                 // link layer contains the MAC address
1812                 if (saddr-&gt;sa_family == AF_LINK &amp;&amp; !strcmp(ifname, ifa-&gt;ifa_name)) {
1813                     struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
1814                     // check the address has the correct length
1815                     if (sadl-&gt;sdl_alen == ETHER_ADDR_LEN) {
1816                         memcpy(buf, (sadl-&gt;sdl_data + sadl-&gt;sdl_nlen), ETHER_ADDR_LEN);
1817                         freeifaddrs(ifa0);
1818                         return ETHER_ADDR_LEN;
1819                     }
1820                 }
1821             }
1822         }
1823         freeifaddrs(ifa0);
1824     }
1825 
1826     return -1;
1827 }
1828 
1829 static int getMTU(JNIEnv *env, int sock, const char *ifname) {
1830     struct ifreq if2;
1831     memset((char *)&amp;if2, 0, sizeof(if2));
1832     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1833 
1834     if (ioctl(sock, SIOCGIFMTU, (char *)&amp;if2) &lt; 0) {
1835         JNU_ThrowByNameWithMessageAndLastError
1836             (env, JNU_JAVANETPKG &quot;SocketException&quot;, &quot;ioctl(SIOCGIFMTU) failed&quot;);
1837         return -1;
1838     }
1839 
1840     return if2.ifr_mtu;
1841 }
1842 
1843 static int getFlags(int sock, const char *ifname, int *flags) {
1844     struct ifreq if2;
1845     memset((char *)&amp;if2, 0, sizeof(if2));
1846     strncpy(if2.ifr_name, ifname, sizeof(if2.ifr_name) - 1);
1847 
1848     if (ioctl(sock, SIOCGIFFLAGS, (char *)&amp;if2) &lt; 0) {
1849         return -1;
1850     }
1851 
1852     if (sizeof(if2.ifr_flags) == sizeof(short)) {
1853         *flags = (if2.ifr_flags &amp; 0xffff);
1854     } else {
1855         *flags = if2.ifr_flags;
1856     }
1857     return 0;
1858 }
1859 #endif /* _ALLBSD_SOURCE */
    </pre>
  </body>
</html>
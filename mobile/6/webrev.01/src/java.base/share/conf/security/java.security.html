<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/conf/security/java.security</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # This is the &quot;master security properties file&quot;.
   3 #
   4 # An alternate java.security properties file may be specified
   5 # from the command line via the system property
   6 #
   7 #    -Djava.security.properties=&lt;URL&gt;
   8 #
   9 # This properties file appends to the master security properties file.
  10 # If both properties files specify values for the same key, the value
  11 # from the command-line properties file is selected, as it is the last
  12 # one loaded.
  13 #
  14 # Also, if you specify
  15 #
  16 #    -Djava.security.properties==&lt;URL&gt; (2 equals),
  17 #
  18 # then that properties file completely overrides the master security
  19 # properties file.
  20 #
  21 # To disable the ability to specify an additional properties file from
  22 # the command line, set the key security.overridePropertiesFile
  23 # to false in the master security properties file. It is set to true
  24 # by default.
  25 
  26 # In this file, various security properties are set for use by
  27 # java.security classes. This is where users can statically register
  28 # Cryptography Package Providers (&quot;providers&quot; for short). The term
  29 # &quot;provider&quot; refers to a package or set of packages that supply a
  30 # concrete implementation of a subset of the cryptography aspects of
  31 # the Java Security API. A provider may, for example, implement one or
  32 # more digital signature algorithms or message digest algorithms.
  33 #
  34 # Each provider must implement a subclass of the Provider class.
  35 # To register a provider in this master security properties file,
  36 # specify the provider and priority in the format
  37 #
  38 #    security.provider.&lt;n&gt;=&lt;provName | className&gt;
  39 #
  40 # This declares a provider, and specifies its preference
  41 # order n. The preference order is the order in which providers are
  42 # searched for requested algorithms (when no specific provider is
  43 # requested). The order is 1-based; 1 is the most preferred, followed
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 security.provider.tbd=SUN
  64 security.provider.tbd=SunRsaSign
  65 security.provider.tbd=SunEC
  66 security.provider.tbd=SunJSSE
  67 security.provider.tbd=SunJCE
  68 security.provider.tbd=SunJGSS
  69 security.provider.tbd=SunSASL
  70 security.provider.tbd=XMLDSig
  71 security.provider.tbd=SunPCSC
  72 security.provider.tbd=JdkLDAP
  73 security.provider.tbd=JdkSASL
  74 #ifdef windows
  75 security.provider.tbd=SunMSCAPI
  76 #endif
  77 #ifdef macosx
  78 security.provider.tbd=Apple
  79 #endif
  80 security.provider.tbd=SunPKCS11
  81 
  82 #
  83 # A list of preferred providers for specific algorithms. These providers will
  84 # be searched for matching algorithms before the list of registered providers.
  85 # Entries containing errors (parsing, etc) will be ignored. Use the
  86 # -Djava.security.debug=jca property to debug these errors.
  87 #
  88 # The property is a comma-separated list of serviceType.algorithm:provider
  89 # entries. The serviceType (example: &quot;MessageDigest&quot;) is optional, and if
  90 # not specified, the algorithm applies to all service types that support it.
  91 # The algorithm is the standard algorithm name or transformation.
  92 # Transformations can be specified in their full standard name
  93 # (ex: AES/CBC/PKCS5Padding), or as partial matches (ex: AES, AES/CBC).
  94 # The provider is the name of the provider. Any provider that does not
  95 # also appear in the registered list will be ignored.
  96 #
  97 # There is a special serviceType for this property only to group a set of
  98 # algorithms together. The type is &quot;Group&quot; and is followed by an algorithm
  99 # keyword. Groups are to simplify and lessen the entries on the property
 100 # line. Current groups are:
 101 #   Group.SHA2 = SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256
 102 #   Group.HmacSHA2 = HmacSHA224, HmacSHA256, HmacSHA384, HmacSHA512
 103 #   Group.SHA2RSA = SHA224withRSA, SHA256withRSA, SHA384withRSA, SHA512withRSA
 104 #   Group.SHA2DSA = SHA224withDSA, SHA256withDSA, SHA384withDSA, SHA512withDSA
 105 #   Group.SHA2ECDSA = SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, \
 106 #                     SHA512withECDSA
 107 #   Group.SHA3 = SHA3-224, SHA3-256, SHA3-384, SHA3-512
 108 #   Group.HmacSHA3 = HmacSHA3-224, HmacSHA3-256, HmacSHA3-384, HmacSHA3-512
 109 #
 110 # Example:
 111 #   jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, \
 112 #         MessageDigest.SHA-256:SUN, Group.HmacSHA2:SunJCE
 113 #
 114 #jdk.security.provider.preferred=
 115 
 116 
 117 #
 118 # Sun Provider SecureRandom seed source.
 119 #
 120 # Select the primary source of seed data for the &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot;
 121 # and &quot;DRBG&quot; SecureRandom implementations in the &quot;Sun&quot; provider.
 122 # (Other SecureRandom implementations might also use this property.)
 123 #
 124 # On Unix-like systems (for example, Linux/MacOS), the
 125 # &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot; and &quot;DRBG&quot; implementations obtains seed data from
 126 # special device files such as file:/dev/random.
 127 #
 128 # On Windows systems, specifying the URLs &quot;file:/dev/random&quot; or
 129 # &quot;file:/dev/urandom&quot; will enable the native Microsoft CryptoAPI seeding
 130 # mechanism for SHA1PRNG and DRBG.
 131 #
 132 # By default, an attempt is made to use the entropy gathering device
 133 # specified by the &quot;securerandom.source&quot; Security property.  If an
 134 # exception occurs while accessing the specified URL:
 135 #
 136 #     NativePRNG:
 137 #         a default value of /dev/random will be used.  If neither
 138 #         are available, the implementation will be disabled.
 139 #         &quot;file&quot; is the only currently supported protocol type.
 140 #
 141 #     SHA1PRNG and DRBG:
 142 #         the traditional system/thread activity algorithm will be used.
 143 #
 144 # The entropy gathering device can also be specified with the System
 145 # property &quot;java.security.egd&quot;. For example:
 146 #
 147 #   % java -Djava.security.egd=file:/dev/random MainClass
 148 #
 149 # Specifying this System property will override the
 150 # &quot;securerandom.source&quot; Security property.
 151 #
 152 # In addition, if &quot;file:/dev/random&quot; or &quot;file:/dev/urandom&quot; is
 153 # specified, the &quot;NativePRNG&quot; implementation will be more preferred than
 154 # DRBG and SHA1PRNG in the Sun provider.
 155 #
 156 securerandom.source=file:/dev/random
 157 
 158 #
 159 # A list of known strong SecureRandom implementations.
 160 #
 161 # To help guide applications in selecting a suitable strong
 162 # java.security.SecureRandom implementation, Java distributions should
 163 # indicate a list of known strong implementations using the property.
 164 #
 165 # This is a comma-separated list of algorithm and/or algorithm:provider
 166 # entries.
 167 #
 168 #ifdef windows
 169 securerandom.strongAlgorithms=Windows-PRNG:SunMSCAPI,DRBG:SUN
 170 #endif
 171 #ifndef windows
 172 securerandom.strongAlgorithms=NativePRNGBlocking:SUN,DRBG:SUN
 173 #endif
 174 
 175 #
 176 # Sun provider DRBG configuration and default instantiation request.
 177 #
 178 # NIST SP 800-90Ar1 lists several DRBG mechanisms. Each can be configured
 179 # with a DRBG algorithm name, and can be instantiated with a security strength,
 180 # prediction resistance support, etc. This property defines the configuration
 181 # and the default instantiation request of &quot;DRBG&quot; SecureRandom implementations
 182 # in the SUN provider. (Other DRBG implementations can also use this property.)
 183 # Applications can request different instantiation parameters like security
 184 # strength, capability, personalization string using one of the
 185 # getInstance(...,SecureRandomParameters,...) methods with a
 186 # DrbgParameters.Instantiation argument, but other settings such as the
 187 # mechanism and DRBG algorithm names are not currently configurable by any API.
 188 #
 189 # Please note that the SUN implementation of DRBG always supports reseeding.
 190 #
 191 # The value of this property is a comma-separated list of all configurable
 192 # aspects. The aspects can appear in any order but the same aspect can only
 193 # appear at most once. Its BNF-style definition is:
 194 #
 195 #   Value:
 196 #     aspect { &quot;,&quot; aspect }
 197 #
 198 #   aspect:
 199 #     mech_name | algorithm_name | strength | capability | df
 200 #
 201 #   // The DRBG mechanism to use. Default &quot;Hash_DRBG&quot;
 202 #   mech_name:
 203 #     &quot;Hash_DRBG&quot; | &quot;HMAC_DRBG&quot; | &quot;CTR_DRBG&quot;
 204 #
 205 #   // The DRBG algorithm name. The &quot;SHA-***&quot; names are for Hash_DRBG and
 206 #   // HMAC_DRBG, default &quot;SHA-256&quot;. The &quot;AES-***&quot; names are for CTR_DRBG,
 207 #   // default &quot;AES-128&quot; when using the limited cryptographic or &quot;AES-256&quot;
 208 #   // when using the unlimited.
 209 #   algorithm_name:
 210 #     &quot;SHA-224&quot; | &quot;SHA-512/224&quot; | &quot;SHA-256&quot; |
 211 #     &quot;SHA-512/256&quot; | &quot;SHA-384&quot; | &quot;SHA-512&quot; |
 212 #     &quot;AES-128&quot; | &quot;AES-192&quot; | &quot;AES-256&quot;
 213 #
 214 #   // Security strength requested. Default &quot;128&quot;
 215 #   strength:
 216 #     &quot;112&quot; | &quot;128&quot; | &quot;192&quot; | &quot;256&quot;
 217 #
 218 #   // Prediction resistance and reseeding request. Default &quot;none&quot;
 219 #   //  &quot;pr_and_reseed&quot; - Both prediction resistance and reseeding
 220 #   //                    support requested
 221 #   //  &quot;reseed_only&quot;   - Only reseeding support requested
 222 #   //  &quot;none&quot;          - Neither prediction resistance not reseeding
 223 #   //                    support requested
 224 #   pr:
 225 #     &quot;pr_and_reseed&quot; | &quot;reseed_only&quot; | &quot;none&quot;
 226 #
 227 #   // Whether a derivation function should be used. only applicable
 228 #   // to CTR_DRBG. Default &quot;use_df&quot;
 229 #   df:
 230 #     &quot;use_df&quot; | &quot;no_df&quot;
 231 #
 232 # Examples,
 233 #   securerandom.drbg.config=Hash_DRBG,SHA-224,112,none
 234 #   securerandom.drbg.config=CTR_DRBG,AES-256,192,pr_and_reseed,use_df
 235 #
 236 # The default value is an empty string, which is equivalent to
 237 #   securerandom.drbg.config=Hash_DRBG,SHA-256,128,none
 238 #
 239 securerandom.drbg.config=
 240 
 241 #
 242 # Class to instantiate as the javax.security.auth.login.Configuration
 243 # provider.
 244 #
 245 login.configuration.provider=sun.security.provider.ConfigFile
 246 
 247 #
 248 # Default login configuration file
 249 #
 250 #login.config.url.1=file:${user.home}/.java.login.config
 251 
 252 #
 253 # Class to instantiate as the system Policy. This is the name of the class
 254 # that will be used as the Policy object. The system class loader is used to
 255 # locate this class.
 256 #
 257 policy.provider=sun.security.provider.PolicyFile
 258 
 259 # The default is to have a single system-wide policy file,
 260 # and a policy file in the user&#39;s home directory.
 261 #
 262 policy.url.1=file:${java.home}/conf/security/java.policy
 263 policy.url.2=file:${user.home}/.java.policy
 264 
 265 # Controls whether or not properties are expanded in policy and login
 266 # configuration files. If set to false, properties (${...}) will not
 267 # be expanded in policy and login configuration files. If commented out or
 268 # set to an empty string, the default value is &quot;false&quot; for policy files and
 269 # &quot;true&quot; for login configuration files.
 270 #
 271 policy.expandProperties=true
 272 
 273 # Controls whether or not an extra policy or login configuration file is
 274 # allowed to be passed on the command line with -Djava.security.policy=somefile
 275 # or -Djava.security.auth.login.config=somefile. If commented out or set to
 276 # an empty string, the default value is &quot;false&quot;.
 277 #
 278 policy.allowSystemProperty=true
 279 
 280 # whether or not we look into the IdentityScope for trusted Identities
 281 # when encountering a 1.1 signed JAR file. If the identity is found
 282 # and is trusted, we grant it AllPermission. Note: the default policy
 283 # provider (sun.security.provider.PolicyFile) does not support this property.
 284 #
 285 policy.ignoreIdentityScope=false
 286 
 287 #
 288 # Default keystore type.
 289 #
 290 keystore.type=pkcs12
 291 
 292 #
 293 # Controls compatibility mode for JKS and PKCS12 keystore types.
 294 #
 295 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 296 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
 297 # JKS keystore type supports loading only JKS keystore files and the PKCS12
 298 # keystore type supports loading only PKCS12 keystore files.
 299 #
 300 keystore.type.compat=true
 301 
 302 #
 303 # List of comma-separated packages that start with or equal this string
 304 # will cause a security exception to be thrown when passed to the
 305 # SecurityManager::checkPackageAccess method unless the corresponding
 306 # RuntimePermission(&quot;accessClassInPackage.&quot;+package) has been granted.
 307 #
 308 package.access=sun.misc.,\
 309                sun.reflect.,\
 310 
 311 #
 312 # List of comma-separated packages that start with or equal this string
 313 # will cause a security exception to be thrown when passed to the
 314 # SecurityManager::checkPackageDefinition method unless the corresponding
 315 # RuntimePermission(&quot;defineClassInPackage.&quot;+package) has been granted.
 316 #
 317 # By default, none of the class loaders supplied with the JDK call
 318 # checkPackageDefinition.
 319 #
 320 package.definition=sun.misc.,\
 321                    sun.reflect.,\
 322 
 323 #
 324 # Determines whether this properties file can be appended to
 325 # or overridden on the command line via -Djava.security.properties
 326 #
 327 security.overridePropertiesFile=true
 328 
 329 #
 330 # Determines the default key and trust manager factory algorithms for
 331 # the javax.net.ssl package.
 332 #
 333 ssl.KeyManagerFactory.algorithm=SunX509
 334 ssl.TrustManagerFactory.algorithm=PKIX
 335 
 336 #
 337 # The Java-level namelookup cache policy for successful lookups:
 338 #
 339 # any negative value: caching forever
 340 # any positive value: the number of seconds to cache an address for
 341 # zero: do not cache
 342 #
 343 # default value is forever (FOREVER). For security reasons, this
 344 # caching is made forever when a security manager is set. When a security
 345 # manager is not set, the default behavior in this implementation
 346 # is to cache for 30 seconds.
 347 #
 348 # NOTE: setting this to anything other than the default value can have
 349 #       serious security implications. Do not set it unless
 350 #       you are sure you are not exposed to DNS spoofing attack.
 351 #
 352 #networkaddress.cache.ttl=-1
 353 
 354 # The Java-level namelookup cache policy for failed lookups:
 355 #
 356 # any negative value: cache forever
 357 # any positive value: the number of seconds to cache negative lookup results
 358 # zero: do not cache
 359 #
 360 # In some Microsoft Windows networking environments that employ
 361 # the WINS name service in addition to DNS, name service lookups
 362 # that fail may take a noticeably long time to return (approx. 5 seconds).
 363 # For this reason the default caching policy is to maintain these
 364 # results for 10 seconds.
 365 #
 366 networkaddress.cache.negative.ttl=10
 367 
 368 #
 369 # Properties to configure OCSP for certificate revocation checking
 370 #
 371 
 372 # Enable OCSP
 373 #
 374 # By default, OCSP is not used for certificate revocation checking.
 375 # This property enables the use of OCSP when set to the value &quot;true&quot;.
 376 #
 377 # NOTE: SocketPermission is required to connect to an OCSP responder.
 378 #
 379 # Example,
 380 #   ocsp.enable=true
 381 
 382 #
 383 # Location of the OCSP responder
 384 #
 385 # By default, the location of the OCSP responder is determined implicitly
 386 # from the certificate being validated. This property explicitly specifies
 387 # the location of the OCSP responder. The property is used when the
 388 # Authority Information Access extension (defined in RFC 5280) is absent
 389 # from the certificate or when it requires overriding.
 390 #
 391 # Example,
 392 #   ocsp.responderURL=http://ocsp.example.net:80
 393 
 394 #
 395 # Subject name of the OCSP responder&#39;s certificate
 396 #
 397 # By default, the certificate of the OCSP responder is that of the issuer
 398 # of the certificate being validated. This property identifies the certificate
 399 # of the OCSP responder when the default does not apply. Its value is a string
 400 # distinguished name (defined in RFC 2253) which identifies a certificate in
 401 # the set of certificates supplied during cert path validation. In cases where
 402 # the subject name alone is not sufficient to uniquely identify the certificate
 403 # then both the &quot;ocsp.responderCertIssuerName&quot; and
 404 # &quot;ocsp.responderCertSerialNumber&quot; properties must be used instead. When this
 405 # property is set then those two properties are ignored.
 406 #
 407 # Example,
 408 #   ocsp.responderCertSubjectName=CN=OCSP Responder, O=XYZ Corp
 409 
 410 #
 411 # Issuer name of the OCSP responder&#39;s certificate
 412 #
 413 # By default, the certificate of the OCSP responder is that of the issuer
 414 # of the certificate being validated. This property identifies the certificate
 415 # of the OCSP responder when the default does not apply. Its value is a string
 416 # distinguished name (defined in RFC 2253) which identifies a certificate in
 417 # the set of certificates supplied during cert path validation. When this
 418 # property is set then the &quot;ocsp.responderCertSerialNumber&quot; property must also
 419 # be set. When the &quot;ocsp.responderCertSubjectName&quot; property is set then this
 420 # property is ignored.
 421 #
 422 # Example,
 423 #   ocsp.responderCertIssuerName=CN=Enterprise CA, O=XYZ Corp
 424 
 425 #
 426 # Serial number of the OCSP responder&#39;s certificate
 427 #
 428 # By default, the certificate of the OCSP responder is that of the issuer
 429 # of the certificate being validated. This property identifies the certificate
 430 # of the OCSP responder when the default does not apply. Its value is a string
 431 # of hexadecimal digits (colon or space separators may be present) which
 432 # identifies a certificate in the set of certificates supplied during cert path
 433 # validation. When this property is set then the &quot;ocsp.responderCertIssuerName&quot;
 434 # property must also be set. When the &quot;ocsp.responderCertSubjectName&quot; property
 435 # is set then this property is ignored.
 436 #
 437 # Example,
 438 #   ocsp.responderCertSerialNumber=2A:FF:00
 439 
 440 #
 441 # Policy for failed Kerberos KDC lookups:
 442 #
 443 # When a KDC is unavailable (network error, service failure, etc), it is
 444 # put inside a blacklist and accessed less often for future requests. The
 445 # value (case-insensitive) for this policy can be:
 446 #
 447 # tryLast
 448 #    KDCs in the blacklist are always tried after those not on the list.
 449 #
 450 # tryLess[:max_retries,timeout]
 451 #    KDCs in the blacklist are still tried by their order in the configuration,
 452 #    but with smaller max_retries and timeout values. max_retries and timeout
 453 #    are optional numerical parameters (default 1 and 5000, which means once
 454 #    and 5 seconds). Please notes that if any of the values defined here is
 455 #    more than what is defined in krb5.conf, it will be ignored.
 456 #
 457 # Whenever a KDC is detected as available, it is removed from the blacklist.
 458 # The blacklist is reset when krb5.conf is reloaded. You can add
 459 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 460 # reloaded whenever a JAAS authentication is attempted.
 461 #
 462 # Example,
 463 #   krb5.kdc.bad.policy = tryLast
 464 #   krb5.kdc.bad.policy = tryLess:2,2000
 465 #
 466 krb5.kdc.bad.policy = tryLast
 467 
 468 #
 469 # Kerberos cross-realm referrals (RFC 6806)
 470 #
 471 # OpenJDK&#39;s Kerberos client supports cross-realm referrals as defined in
 472 # RFC 6806. This allows to setup more dynamic environments in which clients
 473 # do not need to know in advance how to reach the realm of a target principal
 474 # (either a user or service).
 475 #
 476 # When a client issues an AS or a TGS request, the &quot;canonicalize&quot; option
 477 # is set to announce support of this feature. A KDC server may fulfill the
 478 # request or reply referring the client to a different one. If referred,
 479 # the client will issue a new request and the cycle repeats.
 480 #
 481 # In addition to referrals, the &quot;canonicalize&quot; option allows the KDC server
 482 # to change the client name in response to an AS request. For security reasons,
 483 # RFC 6806 (section 11) FAST scheme is enforced.
 484 #
 485 # Disable Kerberos cross-realm referrals. Value may be overwritten with a
 486 # System property (-Dsun.security.krb5.disableReferrals).
 487 sun.security.krb5.disableReferrals=false
 488 
 489 # Maximum number of AS or TGS referrals to avoid infinite loops. Value may
 490 # be overwritten with a System property (-Dsun.security.krb5.maxReferrals).
 491 sun.security.krb5.maxReferrals=5
 492 
 493 #
 494 # This property contains a list of disabled EC Named Curves that can be included
 495 # in the jdk.[tls|certpath|jar].disabledAlgorithms properties.  To include this
 496 # list in any of the disabledAlgorithms properties, add the property name as
 497 # an entry.
 498 jdk.disabled.namedCurves = secp112r1, secp112r2, secp128r1, secp128r2, \
 499     secp160k1, secp160r1, secp160r2, secp192k1, secp192r1, secp224k1, \
 500     secp224r1, secp256k1, sect113r1, sect113r2, sect131r1, sect131r2, \
 501     sect163k1, sect163r1, sect163r2, sect193r1, sect193r2, sect233k1, \
 502     sect233r1, sect239k1, sect283k1, sect283r1, sect409k1, sect409r1, \
 503     sect571k1, sect571r1, X9.62 c2tnb191v1, X9.62 c2tnb191v2, \
 504     X9.62 c2tnb191v3, X9.62 c2tnb239v1, X9.62 c2tnb239v2, X9.62 c2tnb239v3, \
 505     X9.62 c2tnb359v1, X9.62 c2tnb431r1, X9.62 prime192v2, X9.62 prime192v3, \
 506     X9.62 prime239v1, X9.62 prime239v2, X9.62 prime239v3, brainpoolP256r1, \
 507     brainpoolP320r1, brainpoolP384r1, brainpoolP512r1
 508 
 509 #
 510 # Algorithm restrictions for certification path (CertPath) processing
 511 #
 512 # In some environments, certain algorithms or key lengths may be undesirable
 513 # for certification path building and validation.  For example, &quot;MD2&quot; is
 514 # generally no longer considered to be a secure hash algorithm.  This section
 515 # describes the mechanism for disabling algorithms based on algorithm name
 516 # and/or key length.  This includes algorithms used in certificates, as well
 517 # as revocation information such as CRLs and signed OCSP Responses.
 518 # The syntax of the disabled algorithm string is described as follows:
 519 #   DisabledAlgorithms:
 520 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 521 #
 522 #   DisabledAlgorithm:
 523 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint } | IncludeProperty
 524 #
 525 #   AlgorithmName:
 526 #       (see below)
 527 #
 528 #   Constraint:
 529 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 530 #       UsageConstraint
 531 #
 532 #   KeySizeConstraint:
 533 #       keySize Operator KeyLength
 534 #
 535 #   Operator:
 536 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 537 #
 538 #   KeyLength:
 539 #       Integer value of the algorithm&#39;s key length in bits
 540 #
 541 #   CAConstraint:
 542 #       jdkCA
 543 #
 544 #   DenyAfterConstraint:
 545 #       denyAfter YYYY-MM-DD
 546 #
 547 #   UsageConstraint:
 548 #       usage [TLSServer] [TLSClient] [SignedJAR]
 549 #
 550 #   IncludeProperty:
 551 #       include &lt;security property&gt;
 552 #
 553 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
 554 # algorithm. See the Java Security Standard Algorithm Names Specification
 555 # for information about Standard Algorithm Names.  Matching is
 556 # performed using a case-insensitive sub-element matching rule.  (For
 557 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 558 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 559 # sub-element of the certificate algorithm name, the algorithm will be
 560 # rejected during certification path building and validation.  For example,
 561 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 562 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 563 # will not disable algorithms related to &quot;ECDSA&quot;.
 564 #
 565 # The &quot;IncludeProperty&quot; allows a implementation-defined security property that
 566 # can be included in the disabledAlgorithms properties.  These properties are
 567 # to help manage common actions easier across multiple disabledAlgorithm
 568 # properties.
 569 # There is one defined security property:  jdk.disabled.NamedCurves
 570 # See the property for more specific details.
 571 #
 572 #
 573 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 574 # a specified AlgorithmName:
 575 #
 576 #   KeySizeConstraint:
 577 #     keySize Operator KeyLength
 578 #       The constraint requires a key of a valid size range if the
 579 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 580 #       the key size specified in number of bits.  For example,
 581 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 582 #       than or equal to 1024 bits should be disabled, and
 583 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 584 #       with key size less than 1024 or greater than 2048 should be disabled.
 585 #       This constraint is only used on algorithms that have a key size.
 586 #
 587 #   CAConstraint:
 588 #     jdkCA
 589 #       This constraint prohibits the specified algorithm only if the
 590 #       algorithm is used in a certificate chain that terminates at a marked
 591 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 592 #       constraint is not set, then all chains using the specified algorithm
 593 #       are restricted.  jdkCA may only be used once in a DisabledAlgorithm
 594 #       expression.
 595 #       Example:  To apply this constraint to SHA-1 certificates, include
 596 #       the following:  &quot;SHA1 jdkCA&quot;
 597 #
 598 #   DenyAfterConstraint:
 599 #     denyAfter YYYY-MM-DD
 600 #       This constraint prohibits a certificate with the specified algorithm
 601 #       from being used after the date regardless of the certificate&#39;s
 602 #       validity.  JAR files that are signed and timestamped before the
 603 #       constraint date with certificates containing the disabled algorithm
 604 #       will not be restricted.  The date is processed in the UTC timezone.
 605 #       This constraint can only be used once in a DisabledAlgorithm
 606 #       expression.
 607 #       Example:  To deny usage of RSA 2048 bit certificates after Feb 3 2020,
 608 #       use the following:  &quot;RSA keySize == 2048 &amp; denyAfter 2020-02-03&quot;
 609 #
 610 #   UsageConstraint:
 611 #     usage [TLSServer] [TLSClient] [SignedJAR]
 612 #       This constraint prohibits the specified algorithm for
 613 #       a specified usage.  This should be used when disabling an algorithm
 614 #       for all usages is not practical. &#39;TLSServer&#39; restricts the algorithm
 615 #       in TLS server certificate chains when server authentication is
 616 #       performed. &#39;TLSClient&#39; restricts the algorithm in TLS client
 617 #       certificate chains when client authentication is performed.
 618 #       &#39;SignedJAR&#39; constrains use of certificates in signed jar files.
 619 #       The usage type follows the keyword and more than one usage type can
 620 #       be specified with a whitespace delimiter.
 621 #       Example:  &quot;SHA1 usage TLSServer TLSClient&quot;
 622 #
 623 # When an algorithm must satisfy more than one constraint, it must be
 624 # delimited by an ampersand &#39;&amp;&#39;.  For example, to restrict certificates in a
 625 # chain that terminate at a distribution provided trust anchor and contain
 626 # RSA keys that are less than or equal to 1024 bits, add the following
 627 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 628 #
 629 # All DisabledAlgorithms expressions are processed in the order defined in the
 630 # property.  This requires lower keysize constraints to be specified
 631 # before larger keysize constraints of the same algorithm.  For example:
 632 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 633 #
 634 # Note: The algorithm restrictions do not apply to trust anchors or
 635 # self-signed certificates.
 636 #
 637 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 638 # is not guaranteed to be examined and used by other implementations.
 639 #
 640 # Example:
 641 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 642 #
 643 #
 644 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
 645     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224, \
 646     include jdk.disabled.namedCurves
 647 
 648 #
 649 # Legacy algorithms for certification path (CertPath) processing and
 650 # signed JAR files.
 651 #
 652 # In some environments, a certain algorithm or key length may be undesirable
 653 # but is not yet disabled.
 654 #
 655 # Tools such as keytool and jarsigner may emit warnings when these legacy
 656 # algorithms are used. See the man pages for those tools for more information.
 657 #
 658 # The syntax is the same as the &quot;jdk.certpath.disabledAlgorithms&quot; and
 659 # &quot;jdk.jar.disabledAlgorithms&quot; security properties.
 660 #
 661 # Note: This property is currently used by the JDK Reference
 662 # implementation. It is not guaranteed to be examined and used by other
 663 # implementations.
 664 
 665 jdk.security.legacyAlgorithms=SHA1, \
 666     RSA keySize &lt; 2048, DSA keySize &lt; 2048
 667 
 668 #
 669 # Algorithm restrictions for signed JAR files
 670 #
 671 # In some environments, certain algorithms or key lengths may be undesirable
 672 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 673 # considered to be a secure hash algorithm.  This section describes the
 674 # mechanism for disabling algorithms based on algorithm name and/or key length.
 675 # JARs signed with any of the disabled algorithms or key sizes will be treated
 676 # as unsigned.
 677 #
 678 # The syntax of the disabled algorithm string is described as follows:
 679 #   DisabledAlgorithms:
 680 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 681 #
 682 #   DisabledAlgorithm:
 683 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 684 #
 685 #   AlgorithmName:
 686 #       (see below)
 687 #
 688 #   Constraint:
 689 #       KeySizeConstraint | DenyAfterConstraint
 690 #
 691 #   KeySizeConstraint:
 692 #       keySize Operator KeyLength
 693 #
 694 #   DenyAfterConstraint:
 695 #       denyAfter YYYY-MM-DD
 696 #
 697 #   Operator:
 698 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 699 #
 700 #   KeyLength:
 701 #       Integer value of the algorithm&#39;s key length in bits
 702 #
 703 # Note: This property is currently used by the JDK Reference
 704 # implementation. It is not guaranteed to be examined and used by other
 705 # implementations.
 706 #
 707 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 708 #
 709 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
 710       DSA keySize &lt; 1024, include jdk.disabled.namedCurves
 711 
 712 #
 713 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 714 # (SSL/TLS/DTLS) processing
 715 #
 716 # In some environments, certain algorithms or key lengths may be undesirable
 717 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 718 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
 719 # protocol version negotiation, cipher suites selection, named groups
 720 # selection, signature schemes selection, peer authentication and key
 721 # exchange mechanisms.
 722 #
 723 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 724 # if they are enabled explicitly in an application.
 725 #
 726 # For PKI-based peer authentication and key exchange mechanisms, this list
 727 # of disabled algorithms will also be checked during certification path
 728 # building and validation, including algorithms used in certificates, as
 729 # well as revocation information such as CRLs and signed OCSP Responses.
 730 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 731 #
 732 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 733 # syntax of the disabled algorithm string.
 734 #
 735 # Note: The algorithm restrictions do not apply to trust anchors or
 736 # self-signed certificates.
 737 #
 738 # Note: This property is currently used by the JDK Reference implementation.
 739 # It is not guaranteed to be examined and used by other implementations.
 740 #
 741 # Example:
 742 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048, \
 743 #       rsa_pkcs1_sha1, secp224r1
 744 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
 745     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \
 746     include jdk.disabled.namedCurves
 747 
 748 #
 749 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 750 # processing in JSSE implementation.
 751 #
 752 # In some environments, a certain algorithm may be undesirable but it
 753 # cannot be disabled because of its use in legacy applications.  Legacy
 754 # algorithms may still be supported, but applications should not use them
 755 # as the security strength of legacy algorithms are usually not strong enough
 756 # in practice.
 757 #
 758 # During SSL/TLS security parameters negotiation, legacy algorithms will
 759 # not be negotiated unless there are no other candidates.
 760 #
 761 # The syntax of the legacy algorithms string is described as this Java
 762 # BNF-style:
 763 #   LegacyAlgorithms:
 764 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 765 #
 766 #   LegacyAlgorithm:
 767 #       AlgorithmName (standard JSSE algorithm name)
 768 #
 769 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 770 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 771 #
 772 # Per SSL/TLS specifications, cipher suites have the form:
 773 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 774 # or
 775 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 776 #
 777 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 778 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 779 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 780 # algorithm for HMAC.
 781 #
 782 # The LegacyAlgorithm can be one of the following standard algorithm names:
 783 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 784 #     2. JSSE key exchange algorithm name, e.g., RSA
 785 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 786 #     4. JSSE message digest algorithm name, e.g., SHA
 787 #
 788 # See SSL/TLS specifications and the Java Security Standard Algorithm Names
 789 # Specification for information about the algorithm names.
 790 #
 791 # Note: If a legacy algorithm is also restricted through the
 792 # jdk.tls.disabledAlgorithms property or the
 793 # java.security.AlgorithmConstraints API (See
 794 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 795 # then the algorithm is completely disabled and will not be negotiated.
 796 #
 797 # Note: This property is currently used by the JDK Reference implementation.
 798 # It is not guaranteed to be examined and used by other implementations.
 799 # There is no guarantee the property will continue to exist or be of the
 800 # same syntax in future releases.
 801 #
 802 # Example:
 803 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 804 #
 805 jdk.tls.legacyAlgorithms=NULL, anon, RC4, DES, 3DES_EDE_CBC
 806 
 807 #
 808 # The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
 809 # parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
 810 #
 811 # In traditional SSL/TLS/DTLS connections where finite field DHE parameters
 812 # negotiation mechanism is not used, the server offers the client group
 813 # parameters, base generator g and prime modulus p, for DHE key exchange.
 814 # It is recommended to use dynamic group parameters.  This property defines
 815 # a mechanism that allows you to specify custom group parameters.
 816 #
 817 # The syntax of this property string is described as this Java BNF-style:
 818 #   DefaultDHEParameters:
 819 #       DefinedDHEParameters { , DefinedDHEParameters }
 820 #
 821 #   DefinedDHEParameters:
 822 #       &quot;{&quot; DHEPrimeModulus , DHEBaseGenerator &quot;}&quot;
 823 #
 824 #   DHEPrimeModulus:
 825 #       HexadecimalDigits
 826 #
 827 #   DHEBaseGenerator:
 828 #       HexadecimalDigits
 829 #
 830 #   HexadecimalDigits:
 831 #       HexadecimalDigit { HexadecimalDigit }
 832 #
 833 #   HexadecimalDigit: one of
 834 #       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
 835 #
 836 # Whitespace characters are ignored.
 837 #
 838 # The &quot;DefinedDHEParameters&quot; defines the custom group parameters, prime
 839 # modulus p and base generator g, for a particular size of prime modulus p.
 840 # The &quot;DHEPrimeModulus&quot; defines the hexadecimal prime modulus p, and the
 841 # &quot;DHEBaseGenerator&quot; defines the hexadecimal base generator g of a group
 842 # parameter.  It is recommended to use safe primes for the custom group
 843 # parameters.
 844 #
 845 # If this property is not defined or the value is empty, the underlying JSSE
 846 # provider&#39;s default group parameter is used for each connection.
 847 #
 848 # If the property value does not follow the grammar, or a particular group
 849 # parameter is not valid, the connection will fall back and use the
 850 # underlying JSSE provider&#39;s default group parameter.
 851 #
 852 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 853 # is not guaranteed to be examined and used by other implementations.
 854 #
 855 # Example:
 856 #   jdk.tls.server.defaultDHEParameters=
 857 #       { \
 858 #       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
 859 #       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
 860 #       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
 861 #       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
 862 #       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
 863 #       FFFFFFFF FFFFFFFF, 2}
 864 
 865 #
 866 # TLS key limits on symmetric cryptographic algorithms
 867 #
 868 # This security property sets limits on algorithms key usage in TLS 1.3.
 869 # When the amount of data encrypted exceeds the algorithm value listed below,
 870 # a KeyUpdate message will trigger a key change.  This is for symmetric ciphers
 871 # with TLS 1.3 only.
 872 #
 873 # The syntax for the property is described below:
 874 #   KeyLimits:
 875 #       &quot; KeyLimit { , KeyLimit } &quot;
 876 #
 877 #   WeakKeyLimit:
 878 #       AlgorithmName Action Length
 879 #
 880 #   AlgorithmName:
 881 #       A full algorithm transformation.
 882 #
 883 #   Action:
 884 #       KeyUpdate
 885 #
 886 #   Length:
 887 #       The amount of encrypted data in a session before the Action occurs
 888 #       This value may be an integer value in bytes, or as a power of two, 2^29.
 889 #
 890 #   KeyUpdate:
 891 #       The TLS 1.3 KeyUpdate handshake process begins when the Length amount
 892 #       is fulfilled.
 893 #
 894 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 895 # is not guaranteed to be examined and used by other implementations.
 896 #
 897 jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37
 898 
 899 #
 900 # Cryptographic Jurisdiction Policy defaults
 901 #
 902 # Import and export control rules on cryptographic software vary from
 903 # country to country.  By default, Java provides two different sets of
 904 # cryptographic policy files[1]:
 905 #
 906 #     unlimited:  These policy files contain no restrictions on cryptographic
 907 #                 strengths or algorithms
 908 #
 909 #     limited:    These policy files contain more restricted cryptographic
 910 #                 strengths
 911 #
 912 # The default setting is determined by the value of the &quot;crypto.policy&quot;
 913 # Security property below. If your country or usage requires the
 914 # traditional restrictive policy, the &quot;limited&quot; Java cryptographic
 915 # policy is still available and may be appropriate for your environment.
 916 #
 917 # If you have restrictions that do not fit either use case mentioned
 918 # above, Java provides the capability to customize these policy files.
 919 # The &quot;crypto.policy&quot; security property points to a subdirectory
 920 # within &lt;java-home&gt;/conf/security/policy/ which can be customized.
 921 # Please see the &lt;java-home&gt;/conf/security/policy/README.txt file or consult
 922 # the Java Security Guide/JCA documentation for more information.
 923 #
 924 # YOU ARE ADVISED TO CONSULT YOUR EXPORT/IMPORT CONTROL COUNSEL OR ATTORNEY
 925 # TO DETERMINE THE EXACT REQUIREMENTS.
 926 #
 927 # [1] Please note that the JCE for Java SE, including the JCE framework,
 928 # cryptographic policy files, and standard JCE providers provided with
 929 # the Java SE, have been reviewed and approved for export as mass market
 930 # encryption item by the US Bureau of Industry and Security.
 931 #
 932 # Note: This property is currently used by the JDK Reference implementation.
 933 # It is not guaranteed to be examined and used by other implementations.
 934 #
 935 crypto.policy=crypto.policydir-tbd
 936 
 937 #
 938 # The policy for the XML Signature secure validation mode. The mode is
 939 # enabled by setting the property &quot;org.jcp.xml.dsig.secureValidation&quot; to
 940 # true with the javax.xml.crypto.XMLCryptoContext.setProperty() method,
 941 # or by running the code with a SecurityManager.
 942 #
 943 #   Policy:
 944 #       Constraint {&quot;,&quot; Constraint }
 945 #   Constraint:
 946 #       AlgConstraint | MaxTransformsConstraint | MaxReferencesConstraint |
 947 #       ReferenceUriSchemeConstraint | KeySizeConstraint | OtherConstraint
 948 #   AlgConstraint
 949 #       &quot;disallowAlg&quot; Uri
 950 #   MaxTransformsConstraint:
 951 #       &quot;maxTransforms&quot; Integer
 952 #   MaxReferencesConstraint:
 953 #       &quot;maxReferences&quot; Integer
 954 #   ReferenceUriSchemeConstraint:
 955 #       &quot;disallowReferenceUriSchemes&quot; String { String }
 956 #   KeySizeConstraint:
 957 #       &quot;minKeySize&quot; KeyAlg Integer
 958 #   OtherConstraint:
 959 #       &quot;noDuplicateIds&quot; | &quot;noRetrievalMethodLoops&quot;
 960 #
 961 # For AlgConstraint, Uri is the algorithm URI String that is not allowed.
 962 # See the XML Signature Recommendation for more information on algorithm
 963 # URI Identifiers. For KeySizeConstraint, KeyAlg is the standard algorithm
 964 # name of the key type (ex: &quot;RSA&quot;). If the MaxTransformsConstraint,
 965 # MaxReferencesConstraint or KeySizeConstraint (for the same key type) is
 966 # specified more than once, only the last entry is enforced.
 967 #
 968 # Note: This property is currently used by the JDK Reference implementation. It
 969 # is not guaranteed to be examined and used by other implementations.
 970 #
 971 jdk.xml.dsig.secureValidationPolicy=\
 972     disallowAlg http://www.w3.org/TR/1999/REC-xslt-19991116,\
 973     disallowAlg http://www.w3.org/2001/04/xmldsig-more#rsa-md5,\
 974     disallowAlg http://www.w3.org/2001/04/xmldsig-more#hmac-md5,\
 975     disallowAlg http://www.w3.org/2001/04/xmldsig-more#md5,\
 976     maxTransforms 5,\
 977     maxReferences 30,\
 978     disallowReferenceUriSchemes file http https,\
 979     minKeySize RSA 1024,\
 980     minKeySize DSA 1024,\
 981     minKeySize EC 224,\
 982     noDuplicateIds,\
 983     noRetrievalMethodLoops
 984 
 985 #
 986 # Serialization system-wide filter
 987 #
 988 # A filter, if configured, is used by java.io.ObjectInputStream during
 989 # deserialization to check the contents of the stream.
 990 # A filter is configured as a sequence of patterns, each pattern is either
 991 # matched against the name of a class in the stream or defines a limit.
 992 # Patterns are separated by &quot;;&quot; (semicolon).
 993 # Whitespace is significant and is considered part of the pattern.
 994 #
 995 # If the system property jdk.serialFilter is also specified, it supersedes
 996 # the security property value defined here.
 997 #
 998 # If a pattern includes a &quot;=&quot;, it sets a limit.
 999 # If a limit appears more than once the last value is used.
1000 # Limits are checked before classes regardless of the order in the
1001 # sequence of patterns.
1002 # If any of the limits are exceeded, the filter status is REJECTED.
1003 #
1004 #   maxdepth=value - the maximum depth of a graph
1005 #   maxrefs=value  - the maximum number of internal references
1006 #   maxbytes=value - the maximum number of bytes in the input stream
1007 #   maxarray=value - the maximum array length allowed
1008 #
1009 # Other patterns, from left to right, match the class or package name as
1010 # returned from Class.getName.
1011 # If the class is an array type, the class or package to be matched is the
1012 # element type.
1013 # Arrays of any number of dimensions are treated the same as the element type.
1014 # For example, a pattern of &quot;!example.Foo&quot;, rejects creation of any instance or
1015 # array of example.Foo.
1016 #
1017 # If the pattern starts with &quot;!&quot;, the status is REJECTED if the remaining
1018 # pattern is matched; otherwise the status is ALLOWED if the pattern matches.
1019 # If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the
1020 # module name;
1021 #   if the module name matches the module name of the class then
1022 #   the remaining pattern is matched with the class name.
1023 #   If there is no &quot;/&quot;, the module name is not compared.
1024 # If the pattern ends with &quot;.**&quot; it matches any class in the package and all
1025 # subpackages.
1026 # If the pattern ends with &quot;.*&quot; it matches any class in the package.
1027 # If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a
1028 # prefix.
1029 # If the pattern is equal to the class name, it matches.
1030 # Otherwise, the status is UNDECIDED.
1031 #
1032 #jdk.serialFilter=pattern;pattern
1033 
1034 #
1035 # RMI Registry Serial Filter
1036 #
1037 # The filter pattern uses the same format as jdk.serialFilter.
1038 # This filter can override the builtin filter if additional types need to be
1039 # allowed or rejected from the RMI Registry or to decrease limits but not
1040 # to increase limits.
1041 # If the limits (maxdepth, maxrefs, or maxbytes) are exceeded, the object is rejected.
1042 #
1043 # Each non-array type is allowed or rejected if it matches one of the patterns,
1044 # evaluated from left to right, and is otherwise allowed. Arrays of any
1045 # component type, including subarrays and arrays of primitives, are allowed.
1046 #
1047 # Array construction of any component type, including subarrays and arrays of
1048 # primitives, are allowed unless the length is greater than the maxarray limit.
1049 # The filter is applied to each array element.
1050 #
1051 # Note: This property is currently used by the JDK Reference implementation.
1052 # It is not guaranteed to be examined and used by other implementations.
1053 #
1054 # The built-in filter allows subclasses of allowed classes and
1055 # can approximately be represented as the pattern:
1056 #
1057 #sun.rmi.registry.registryFilter=\
1058 #    maxarray=1000000;\
1059 #    maxdepth=20;\
1060 #    java.lang.String;\
1061 #    java.lang.Number;\
1062 #    java.lang.reflect.Proxy;\
1063 #    java.rmi.Remote;\
1064 #    sun.rmi.server.UnicastRef;\
1065 #    sun.rmi.server.RMIClientSocketFactory;\
1066 #    sun.rmi.server.RMIServerSocketFactory;\
1067 #    java.rmi.activation.ActivationID;\
1068 #    java.rmi.server.UID
1069 #
1070 # RMI Distributed Garbage Collector (DGC) Serial Filter
1071 #
1072 # The filter pattern uses the same format as jdk.serialFilter.
1073 # This filter can override the builtin filter if additional types need to be
1074 # allowed or rejected from the RMI DGC.
1075 #
1076 # Note: This property is currently used by the JDK Reference implementation.
1077 # It is not guaranteed to be examined and used by other implementations.
1078 #
1079 # The builtin DGC filter can approximately be represented as the filter pattern:
1080 #
1081 #sun.rmi.transport.dgcFilter=\
1082 #    java.rmi.server.ObjID;\
1083 #    java.rmi.server.UID;\
1084 #    java.rmi.dgc.VMID;\
1085 #    java.rmi.dgc.Lease;\
1086 #    maxdepth=5;maxarray=10000
1087 
1088 #
1089 # JCEKS Encrypted Key Serial Filter
1090 #
1091 # This filter, if configured, is used by the JCEKS KeyStore during the
1092 # deserialization of the encrypted Key object stored inside a key entry.
1093 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1094 # matches), the filter configured by jdk.serialFilter will be consulted.
1095 #
1096 # If the system property jceks.key.serialFilter is also specified, it supersedes
1097 # the security property value defined here.
1098 #
1099 # The filter pattern uses the same format as jdk.serialFilter. The default
1100 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1101 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1102 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1103   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1104 
1105 # The iteration count used for password-based encryption (PBE) in JCEKS
1106 # keystores. Values in the range 10000 to 5000000 are considered valid.
1107 # If the value is out of this range, or is not a number, or is unspecified;
1108 # a default of 200000 is used.
1109 #
1110 # If the system property jdk.jceks.iterationCount is also specified, it
1111 # supersedes the security property value defined here.
1112 #
1113 #jdk.jceks.iterationCount = 200000
1114 
1115 #
1116 # PKCS12 KeyStore properties
1117 #
1118 # The following properties, if configured, are used by the PKCS12 KeyStore
1119 # implementation during the creation of a new keystore. Several of the
1120 # properties may also be used when modifying an existing keystore. The
1121 # properties can be overridden by a KeyStore API that specifies its own
1122 # algorithms and parameters.
1123 #
1124 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1125 # parameter used to generate the existing Mac will be reused. If the existing
1126 # keystore does not have a Mac, no Mac will be created while storing. If there
1127 # is at least one certificate in the existing keystore, the algorithm and
1128 # parameters used to encrypt the last certificate in the existing keystore will
1129 # be reused to encrypt all certificates while storing. If the last certificate
1130 # in the existing keystore is not encrypted, all certificates will be stored
1131 # unencrypted. If there is no certificate in the existing keystore, any newly
1132 # added certificate will be encrypted (or stored unencrypted if algorithm
1133 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1134 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
1135 # and secret key(s) are not changed. Newly set private and secret key(s) will
1136 # be encrypted using the &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
1137 # &quot;keystore.pkcs12.keyPbeIterationCount&quot; values defined here.
1138 #
1139 # In order to apply new algorithms and parameters to all entries in an
1140 # existing keystore, one can create a new keystore and add entries in the
1141 # existing keystore into the new keystore. This can be achieved by calling the
1142 # &quot;keytool -importkeystore&quot; command.
1143 #
1144 # If a system property of the same name is also specified, it supersedes the
1145 # security property value defined here.
1146 #
1147 # If the property is set to an illegal value,
1148 # an iteration count that is not a positive integer, or an unknown algorithm
1149 # name, an exception will be thrown when the property is used.
1150 # If the property is not set or empty, a default value will be used.
1151 #
1152 # Note: These properties are currently used by the JDK Reference implementation.
1153 # They are not guaranteed to be examined and used by other implementations.
1154 
1155 # The algorithm used to encrypt a certificate. This can be any non-Hmac PBE
1156 # algorithm defined in the Cipher section of the Java Security Standard
1157 # Algorithm Names Specification. When set to &quot;NONE&quot;, the certificate
1158 # is not encrypted. The default value is &quot;PBEWithSHA1AndRC2_40&quot;.
1159 #keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40
1160 
1161 # The iteration count used by the PBE algorithm when encrypting a certificate.
1162 # This value must be a positive integer. The default value is 50000.
1163 #keystore.pkcs12.certPbeIterationCount = 50000
1164 
1165 # The algorithm used to encrypt a private key or secret key. This can be
1166 # any non-Hmac PBE algorithm defined in the Cipher section of the Java
1167 # Security Standard Algorithm Names Specification. The value must not be &quot;NONE&quot;.
1168 # The default value is &quot;PBEWithSHA1AndDESede&quot;.
1169 #keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede
1170 
1171 # The iteration count used by the PBE algorithm when encrypting a private key
1172 # or a secret key. This value must be a positive integer. The default value
1173 # is 50000.
1174 #keystore.pkcs12.keyPbeIterationCount = 50000
1175 
1176 # The algorithm used to calculate the optional MacData at the end of a PKCS12
1177 # file. This can be any HmacPBE algorithm defined in the Mac section of the
1178 # Java Security Standard Algorithm Names Specification. When set to &quot;NONE&quot;,
1179 # no Mac is generated. The default value is &quot;HmacPBESHA1&quot;.
1180 #keystore.pkcs12.macAlgorithm = HmacPBESHA1
1181 
1182 # The iteration count used by the MacData algorithm. This value must be a
1183 # positive integer. The default value is 100000.
1184 #keystore.pkcs12.macIterationCount = 100000
1185 
1186 #
1187 # Enhanced exception message information
1188 #
1189 # By default, exception messages should not include potentially sensitive
1190 # information such as file names, host names, or port numbers. This property
1191 # accepts one or more comma separated values, each of which represents a
1192 # category of enhanced exception message information to enable. Values are
1193 # case-insensitive. Leading and trailing whitespaces, surrounding each value,
1194 # are ignored. Unknown values are ignored.
1195 #
1196 # NOTE: Use caution before setting this property. Setting this property
1197 # exposes sensitive information in Exceptions, which could, for example,
1198 # propagate to untrusted code or be emitted in stack traces that are
1199 # inadvertently disclosed and made accessible over a public network.
1200 #
1201 # The categories are:
1202 #
1203 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1204 #             java.nio.channels package will contain enhanced exception
1205 #             message information
1206 #
1207 #  jar      - enables more detailed information in the IOExceptions thrown
1208 #             by classes in the java.util.jar package
1209 #
1210 # The property setting in this file can be overridden by a system property of
1211 # the same name, with the same syntax and possible values.
1212 #
1213 #jdk.includeInExceptions=hostInfo,jar
1214 
1215 #
1216 # Disabled mechanisms for the Simple Authentication and Security Layer (SASL)
1217 #
1218 # Disabled mechanisms will not be negotiated by both SASL clients and servers.
1219 # These mechanisms will be ignored if they are specified in the &quot;mechanisms&quot;
1220 # argument of &quot;Sasl.createSaslClient&quot; or the &quot;mechanism&quot; argument of
1221 # &quot;Sasl.createSaslServer&quot;.
1222 #
1223 # The value of this property is a comma-separated list of SASL mechanisms.
1224 # The mechanisms are case-sensitive. Whitespaces around the commas are ignored.
1225 #
1226 # Note: This property is currently used by the JDK Reference implementation.
1227 # It is not guaranteed to be examined and used by other implementations.
1228 #
1229 # Example:
1230 #   jdk.sasl.disabledMechanisms=PLAIN, CRAM-MD5, DIGEST-MD5
1231 jdk.sasl.disabledMechanisms=
1232 
1233 #
1234 # Policies for distrusting Certificate Authorities (CAs).
1235 #
1236 # This is a comma separated value of one or more case-sensitive strings, each
1237 # of which represents a policy for determining if a CA should be distrusted.
1238 # The supported values are:
1239 #
1240 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1241 #   root CA and issued after April 16, 2019 unless issued by one of the
1242 #   following subordinate CAs which have a later distrust date:
1243 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1244 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1245 #        Distrust after December 31, 2019.
1246 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1247 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1248 #        Distrust after December 31, 2019.
1249 #
1250 # Leading and trailing whitespace surrounding each value are ignored.
1251 # Unknown values are ignored. If the property is commented out or set to the
1252 # empty String, no policies are enforced.
1253 #
1254 # Note: This property is currently used by the JDK Reference implementation.
1255 # It is not guaranteed to be supported by other SE implementations. Also, this
1256 # property does not override other security properties which can restrict
1257 # certificates such as jdk.tls.disabledAlgorithms or
1258 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1259 # if this property is not enabled.
1260 #
1261 jdk.security.caDistrustPolicies=SYMANTEC_TLS
1262 
1263 #
1264 # FilePermission path canonicalization
1265 #
1266 # This security property dictates how the path argument is processed and stored
1267 # while constructing a FilePermission object. If the value is set to true, the
1268 # path argument is canonicalized and FilePermission methods (such as implies,
1269 # equals, and hashCode) are implemented based on this canonicalized result.
1270 # Otherwise, the path argument is not canonicalized and FilePermission methods are
1271 # implemented based on the original input. See the implementation note of the
1272 # FilePermission class for more details.
1273 #
1274 # If a system property of the same name is also specified, it supersedes the
1275 # security property value defined here.
1276 #
1277 # The default value for this property is false.
1278 #
1279 jdk.io.permissionsUseCanonicalPath=false
1280 
1281 
1282 #
1283 # Policies for the proxy_impersonator Kerberos ccache configuration entry
1284 #
1285 # The proxy_impersonator ccache configuration entry indicates that the ccache
1286 # is a synthetic delegated credential for use with S4U2Proxy by an intermediate
1287 # server. The ccache file should also contain the TGT of this server and
1288 # an evidence ticket from the default principal of the ccache to this server.
1289 #
1290 # This security property determines how Java uses this configuration entry.
1291 # There are 3 possible values:
1292 #
1293 #  no-impersonate     - Ignore this configuration entry, and always act as
1294 #                       the owner of the TGT (if it exists).
1295 #
1296 #  try-impersonate    - Try impersonation when this configuration entry exists.
1297 #                       If no matching TGT or evidence ticket is found,
1298 #                       fallback to no-impersonate.
1299 #
1300 #  always-impersonate - Always impersonate when this configuration entry exists.
1301 #                       If no matching TGT or evidence ticket is found,
1302 #                       no initial credential is read from the ccache.
1303 #
1304 # The default value is &quot;always-impersonate&quot;.
1305 #
1306 # If a system property of the same name is also specified, it supersedes the
1307 # security property value defined here.
1308 #
1309 #jdk.security.krb5.default.initiate.credential=always-impersonate
1310 
1311 #
1312 # Trust Anchor Certificates - CA Basic Constraint check
1313 #
1314 # X.509 v3 certificates used as Trust Anchors (to validate signed code or TLS
1315 # connections) must have the cA Basic Constraint field set to &#39;true&#39;. Also, if
1316 # they include a Key Usage extension, the keyCertSign bit must be set. These
1317 # checks, enabled by default, can be disabled for backward-compatibility
1318 # purposes with the jdk.security.allowNonCaAnchor System and Security
1319 # properties. In the case that both properties are simultaneously set, the
1320 # System value prevails. The default value of the property is &quot;false&quot;.
1321 #
1322 #jdk.security.allowNonCaAnchor=true
    </pre>
  </body>
</html>
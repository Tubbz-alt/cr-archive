<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.sctp/unix/native/libsctp/SctpChannelImpl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Sctp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SctpNet.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.sctp/unix/native/libsctp/SctpChannelImpl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
309   (JNIEnv* env, jobject resultContainerObj, struct sctp_paddr_change* spc) {
310     int event = 0;
311     jobject addressObj, resultObj;
312     unsigned int state = spc-&gt;spc_state;
313 
314     switch (state) {
315         case SCTP_ADDR_AVAILABLE :
316             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_AVAILABLE;
317             break;
318         case SCTP_ADDR_UNREACHABLE :
319             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_UNREACHABLE;
320             break;
321         case SCTP_ADDR_REMOVED :
322             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_REMOVED;
323             break;
324         case SCTP_ADDR_ADDED :
325             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_ADDED;
326             break;
327         case SCTP_ADDR_MADE_PRIM :
328             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_MADE_PRIM;
<span class="line-removed">329 #ifdef __linux__  /* Solaris currently doesn&#39;t support SCTP_ADDR_CONFIRMED */</span>
330             break;

331         case SCTP_ADDR_CONFIRMED :
332             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_CONFIRMED;

333 #endif  /* __linux__ */
334     }
335 
336     addressObj = SockAddrToInetSocketAddress(env, (struct sockaddr*)&amp;spc-&gt;spc_aaddr);
337     CHECK_NULL(addressObj);
338 
339     /* create PeerAddressChanged */
340     resultObj = (*env)-&gt;NewObject(env, spc_class, spc_ctrID, spc-&gt;spc_assoc_id,
341             addressObj, event);
342     CHECK_NULL(resultObj);
343     (*env)-&gt;SetObjectField(env, resultContainerObj, src_valueID, resultObj);
344     (*env)-&gt;SetIntField(env, resultContainerObj, src_typeID,
345             sun_nio_ch_sctp_ResultContainer_PEER_ADDRESS_CHANGED);
346 }
347 
348 void handleUninteresting
349   (union sctp_notification *snp) {
350     //fprintf(stdout,&quot;\nNative: handleUninterestingNotification: Receive notification type [%u]&quot;, snp-&gt;sn_header.sn_type);
351 }
352 
</pre>
<hr />
<pre>
462             if (!(msg-&gt;msg_flags &amp; MSG_EOR) &amp;&amp; length &lt; SCTP_NOTIFICATION_SIZE) {
463                 char* newBuf;
464                 int rvSAVE = rv;
465 
466                 if ((newBuf = malloc(SCTP_NOTIFICATION_SIZE)) == NULL) {
467                     JNU_ThrowOutOfMemoryError(env, &quot;Out of native heap space.&quot;);
468                     return -1;
469                 }
470                 allocated = JNI_TRUE;
471 
472                 memcpy(newBuf, addr, rv);
473                 iov-&gt;iov_base = newBuf + rv;
474                 iov-&gt;iov_len = SCTP_NOTIFICATION_SIZE - rv;
475                 if ((rv = recvmsg(fd, msg, flags)) &lt; 0) {
476                     handleSocketError(env, errno);
477                     return 0;
478                 }
479                 bufp = newBuf;
480                 rv += rvSAVE;
481             }
<span class="line-removed">482 #ifdef __sparc</span>
<span class="line-removed">483               else if ((intptr_t)addr &amp; 0x3) {</span>
<span class="line-removed">484                 /* the given buffer is not 4 byte aligned */</span>
<span class="line-removed">485                 char* newBuf;</span>
<span class="line-removed">486                 if ((newBuf = malloc(SCTP_NOTIFICATION_SIZE)) == NULL) {</span>
<span class="line-removed">487                     JNU_ThrowOutOfMemoryError(env, &quot;Out of native heap space.&quot;);</span>
<span class="line-removed">488                     return -1;</span>
<span class="line-removed">489                 }</span>
<span class="line-removed">490                 allocated = JNI_TRUE;</span>
<span class="line-removed">491 </span>
<span class="line-removed">492                 memcpy(newBuf, addr, rv);</span>
<span class="line-removed">493                 bufp = newBuf;</span>
<span class="line-removed">494             }</span>
<span class="line-removed">495 #endif</span>
496             snp = (union sctp_notification *) bufp;
497             if (handleNotification(env, fd, resultContainerObj, snp, rv,
498                                    (msg-&gt;msg_flags &amp; MSG_EOR),
499                                    &amp;sa.sa) == JNI_TRUE) {
500                 /* We have received a notification that is of interest
501                    to the Java API. The appropriate notification will be
502                    set in the result container. */
503                 if (allocated == JNI_TRUE) {
504                     free(bufp);
505                 }
506                 return 0;
507             }
508 
509             if (allocated == JNI_TRUE) {
510                 free(bufp);
511             }
512 
513             // set iov back to addr, and reset msg_controllen
514             iov-&gt;iov_base = addr;
515             iov-&gt;iov_len = length;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
309   (JNIEnv* env, jobject resultContainerObj, struct sctp_paddr_change* spc) {
310     int event = 0;
311     jobject addressObj, resultObj;
312     unsigned int state = spc-&gt;spc_state;
313 
314     switch (state) {
315         case SCTP_ADDR_AVAILABLE :
316             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_AVAILABLE;
317             break;
318         case SCTP_ADDR_UNREACHABLE :
319             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_UNREACHABLE;
320             break;
321         case SCTP_ADDR_REMOVED :
322             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_REMOVED;
323             break;
324         case SCTP_ADDR_ADDED :
325             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_ADDED;
326             break;
327         case SCTP_ADDR_MADE_PRIM :
328             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_MADE_PRIM;

329             break;
<span class="line-added">330 #ifdef __linux__</span>
331         case SCTP_ADDR_CONFIRMED :
332             event = sun_nio_ch_sctp_PeerAddrChange_SCTP_ADDR_CONFIRMED;
<span class="line-added">333             break;</span>
334 #endif  /* __linux__ */
335     }
336 
337     addressObj = SockAddrToInetSocketAddress(env, (struct sockaddr*)&amp;spc-&gt;spc_aaddr);
338     CHECK_NULL(addressObj);
339 
340     /* create PeerAddressChanged */
341     resultObj = (*env)-&gt;NewObject(env, spc_class, spc_ctrID, spc-&gt;spc_assoc_id,
342             addressObj, event);
343     CHECK_NULL(resultObj);
344     (*env)-&gt;SetObjectField(env, resultContainerObj, src_valueID, resultObj);
345     (*env)-&gt;SetIntField(env, resultContainerObj, src_typeID,
346             sun_nio_ch_sctp_ResultContainer_PEER_ADDRESS_CHANGED);
347 }
348 
349 void handleUninteresting
350   (union sctp_notification *snp) {
351     //fprintf(stdout,&quot;\nNative: handleUninterestingNotification: Receive notification type [%u]&quot;, snp-&gt;sn_header.sn_type);
352 }
353 
</pre>
<hr />
<pre>
463             if (!(msg-&gt;msg_flags &amp; MSG_EOR) &amp;&amp; length &lt; SCTP_NOTIFICATION_SIZE) {
464                 char* newBuf;
465                 int rvSAVE = rv;
466 
467                 if ((newBuf = malloc(SCTP_NOTIFICATION_SIZE)) == NULL) {
468                     JNU_ThrowOutOfMemoryError(env, &quot;Out of native heap space.&quot;);
469                     return -1;
470                 }
471                 allocated = JNI_TRUE;
472 
473                 memcpy(newBuf, addr, rv);
474                 iov-&gt;iov_base = newBuf + rv;
475                 iov-&gt;iov_len = SCTP_NOTIFICATION_SIZE - rv;
476                 if ((rv = recvmsg(fd, msg, flags)) &lt; 0) {
477                     handleSocketError(env, errno);
478                     return 0;
479                 }
480                 bufp = newBuf;
481                 rv += rvSAVE;
482             }














483             snp = (union sctp_notification *) bufp;
484             if (handleNotification(env, fd, resultContainerObj, snp, rv,
485                                    (msg-&gt;msg_flags &amp; MSG_EOR),
486                                    &amp;sa.sa) == JNI_TRUE) {
487                 /* We have received a notification that is of interest
488                    to the Java API. The appropriate notification will be
489                    set in the result container. */
490                 if (allocated == JNI_TRUE) {
491                     free(bufp);
492                 }
493                 return 0;
494             }
495 
496             if (allocated == JNI_TRUE) {
497                 free(bufp);
498             }
499 
500             // set iov back to addr, and reset msg_controllen
501             iov-&gt;iov_base = addr;
502             iov-&gt;iov_len = length;
</pre>
</td>
</tr>
</table>
<center><a href="Sctp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="SctpNet.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
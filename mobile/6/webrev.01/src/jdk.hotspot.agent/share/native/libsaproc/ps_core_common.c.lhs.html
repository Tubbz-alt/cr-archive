<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/share/native/libsaproc/ps_core_common.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
<a name="2" id="anc2"></a><span class="line-removed"> 25 #include &lt;jni.h&gt; // just include something, or else solaris compiler will complain that this file is empty</span>
<span class="line-removed"> 26 </span>
 27 #if defined(LINUX) || defined(__APPLE__)
 28 #include &lt;unistd.h&gt;
 29 #include &lt;fcntl.h&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;stddef.h&gt;
 33 #ifdef LINUX
 34 #include &lt;elf.h&gt;
 35 #include &lt;link.h&gt;
 36 #include &quot;proc_service.h&quot;
 37 #include &quot;salibelf.h&quot;
 38 #endif
 39 #include &quot;libproc_impl.h&quot;
 40 #include &quot;cds.h&quot;
 41 
 42 #ifdef __APPLE__
 43 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 44 #endif
 45 
 46 #ifdef LINUX
 47 // I have no idea why this function is called ps_pread() on macos but ps_pdread on linux.
 48 #define ps_pread ps_pdread
 49 #endif
 50 
 51 // Common code shared between linux/native/libsaproc/ps_core.c and macosx/native/libsaproc/ps_core.c
 52 
 53 //----------------------------------------------------------------------
 54 // ps_prochandle cleanup helper functions
 55 
 56 // close all file descriptors
 57 static void close_files(struct ps_prochandle* ph) {
 58   lib_info* lib = NULL;
 59 
 60   // close core file descriptor
 61   if (ph-&gt;core-&gt;core_fd &gt;= 0)
 62     close(ph-&gt;core-&gt;core_fd);
 63 
 64   // close exec file descriptor
 65   if (ph-&gt;core-&gt;exec_fd &gt;= 0)
 66     close(ph-&gt;core-&gt;exec_fd);
 67 
 68   // close interp file descriptor
 69   if (ph-&gt;core-&gt;interp_fd &gt;= 0)
 70     close(ph-&gt;core-&gt;interp_fd);
 71 
 72   // close class share archive file
 73   if (ph-&gt;core-&gt;classes_jsa_fd &gt;= 0)
 74     close(ph-&gt;core-&gt;classes_jsa_fd);
 75 
 76   // close all library file descriptors
 77   lib = ph-&gt;libs;
 78   while (lib) {
 79     int fd = lib-&gt;fd;
 80     if (fd &gt;= 0 &amp;&amp; fd != ph-&gt;core-&gt;exec_fd) {
 81       close(fd);
 82     }
 83     lib = lib-&gt;next;
 84   }
 85 }
 86 
 87 // clean all map_info stuff
 88 static void destroy_map_info(struct ps_prochandle* ph) {
 89   map_info* map = ph-&gt;core-&gt;maps;
 90   while (map) {
 91     map_info* next = map-&gt;next;
 92     free(map);
 93     map = next;
 94   }
 95 
 96   if (ph-&gt;core-&gt;map_array) {
 97     free(ph-&gt;core-&gt;map_array);
 98   }
 99 
100   // Part of the class sharing workaround
101   map = ph-&gt;core-&gt;class_share_maps;
102   while (map) {
103     map_info* next = map-&gt;next;
104     free(map);
105     map = next;
106   }
107 }
108 
109 // ps_prochandle operations
110 void core_release(struct ps_prochandle* ph) {
111   if (ph-&gt;core) {
112     close_files(ph);
113     destroy_map_info(ph);
114     free(ph-&gt;core);
115   }
116 }
117 
118 static map_info* allocate_init_map(int fd, off_t offset, uintptr_t vaddr, size_t memsz) {
119   map_info* map;
120   if ( (map = (map_info*) calloc(1, sizeof(map_info))) == NULL) {
121     print_debug(&quot;can&#39;t allocate memory for map_info\n&quot;);
122     return NULL;
123   }
124 
125   // initialize map
126   map-&gt;fd     = fd;
127   map-&gt;offset = offset;
128   map-&gt;vaddr  = vaddr;
129   map-&gt;memsz  = memsz;
130   return map;
131 }
132 
133 // add map info with given fd, offset, vaddr and memsz
134 map_info* add_map_info(struct ps_prochandle* ph, int fd, off_t offset,
135                        uintptr_t vaddr, size_t memsz) {
136   map_info* map;
137   if ((map = allocate_init_map(fd, offset, vaddr, memsz)) == NULL) {
138     return NULL;
139   }
140 
141   // add this to map list
142   map-&gt;next  = ph-&gt;core-&gt;maps;
143   ph-&gt;core-&gt;maps   = map;
144   ph-&gt;core-&gt;num_maps++;
145 
146   return map;
147 }
148 
149 // Part of the class sharing workaround
150 static map_info* add_class_share_map_info(struct ps_prochandle* ph, off_t offset,
151                              uintptr_t vaddr, size_t memsz) {
152   map_info* map;
153   if ((map = allocate_init_map(ph-&gt;core-&gt;classes_jsa_fd,
154                                offset, vaddr, memsz)) == NULL) {
155     return NULL;
156   }
157 
158   map-&gt;next = ph-&gt;core-&gt;class_share_maps;
159   ph-&gt;core-&gt;class_share_maps = map;
160   return map;
161 }
162 
163 // Return the map_info for the given virtual address.  We keep a sorted
164 // array of pointers in ph-&gt;map_array, so we can binary search.
165 map_info* core_lookup(struct ps_prochandle *ph, uintptr_t addr) {
166   int mid, lo = 0, hi = ph-&gt;core-&gt;num_maps - 1;
167   map_info *mp;
168 
169   while (hi - lo &gt; 1) {
170     mid = (lo + hi) / 2;
171     if (addr &gt;= ph-&gt;core-&gt;map_array[mid]-&gt;vaddr) {
172       lo = mid;
173     } else {
174       hi = mid;
175     }
176   }
177 
178   if (addr &lt; ph-&gt;core-&gt;map_array[hi]-&gt;vaddr) {
179     mp = ph-&gt;core-&gt;map_array[lo];
180   } else {
181     mp = ph-&gt;core-&gt;map_array[hi];
182   }
183 
184   if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {
185     return (mp);
186   }
187 
188 
189   // Part of the class sharing workaround
190   // Unfortunately, we have no way of detecting -Xshare state.
191   // Check out the share maps atlast, if we don&#39;t find anywhere.
192   // This is done this way so to avoid reading share pages
193   // ahead of other normal maps. For eg. with -Xshare:off we don&#39;t
194   // want to prefer class sharing data to data from core.
195   mp = ph-&gt;core-&gt;class_share_maps;
196   if (mp) {
197     print_debug(&quot;can&#39;t locate map_info at 0x%lx, trying class share maps\n&quot;, addr);
198   }
199   while (mp) {
200     if (addr &gt;= mp-&gt;vaddr &amp;&amp; addr &lt; mp-&gt;vaddr + mp-&gt;memsz) {
201       print_debug(&quot;located map_info at 0x%lx from class share maps\n&quot;, addr);
202       return (mp);
203     }
204     mp = mp-&gt;next;
205   }
206 
207   print_debug(&quot;can&#39;t locate map_info at 0x%lx\n&quot;, addr);
208   return (NULL);
209 }
210 
211 //---------------------------------------------------------------
212 // Part of the class sharing workaround:
213 //
214 // With class sharing, pages are mapped from classes.jsa file.
215 // The read-only class sharing pages are mapped as MAP_SHARED,
216 // PROT_READ pages. These pages are not dumped into core dump.
217 // With this workaround, these pages are read from classes.jsa.
218 
219 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {
220   jboolean i;
221   if (ps_pread(ph, (psaddr_t) addr, &amp;i, sizeof(i)) == PS_OK) {
222     *pvalue = i;
223     return true;
224   } else {
225     return false;
226   }
227 }
228 
229 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {
230   uintptr_t uip;
231   if (ps_pread(ph, (psaddr_t) addr, (char *)&amp;uip, sizeof(uip)) == PS_OK) {
232     *pvalue = uip;
233     return true;
234   } else {
235     return false;
236   }
237 }
238 
239 // used to read strings from debuggee
240 bool read_string(struct ps_prochandle* ph, uintptr_t addr, char* buf, size_t size) {
241   size_t i = 0;
242   char  c = &#39; &#39;;
243 
244   while (c != &#39;\0&#39;) {
245     if (ps_pread(ph, (psaddr_t) addr, &amp;c, sizeof(char)) != PS_OK) {
246       return false;
247     }
248     if (i &lt; size - 1) {
249       buf[i] = c;
250     } else {
251       // smaller buffer
252       return false;
253     }
254     i++; addr++;
255   }
256   buf[i] = &#39;\0&#39;;
257   return true;
258 }
259 
260 #ifdef LINUX
261 // mangled name of Arguments::SharedArchivePath
262 #define SHARED_ARCHIVE_PATH_SYM &quot;_ZN9Arguments17SharedArchivePathE&quot;
263 #define USE_SHARED_SPACES_SYM &quot;UseSharedSpaces&quot;
264 #define SHARED_BASE_ADDRESS_SYM &quot;SharedBaseAddress&quot;
265 #define LIBJVM_NAME &quot;/libjvm.so&quot;
266 #endif
267 
268 #ifdef __APPLE__
269 // mangled name of Arguments::SharedArchivePath
270 #define SHARED_ARCHIVE_PATH_SYM &quot;__ZN9Arguments17SharedArchivePathE&quot;
271 #define USE_SHARED_SPACES_SYM &quot;_UseSharedSpaces&quot;
272 #define SHARED_BASE_ADDRESS_SYM &quot;_SharedBaseAddress&quot;
273 #define LIBJVM_NAME &quot;/libjvm.dylib&quot;
274 #endif
275 
276 bool init_classsharing_workaround(struct ps_prochandle* ph) {
277   lib_info* lib = ph-&gt;libs;
278   while (lib != NULL) {
279     // we are iterating over shared objects from the core dump. look for
280     // libjvm.so.
281     const char *jvm_name = 0;
282     if ((jvm_name = strstr(lib-&gt;name, LIBJVM_NAME)) != 0) {
283       char classes_jsa[PATH_MAX];
284       CDSFileMapHeaderBase header;
285       int fd = -1;
286       uintptr_t useSharedSpacesAddr = 0;
287       uintptr_t sharedBaseAddressAddr = 0, sharedBaseAddress = 0;
288       uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;
289       jboolean useSharedSpaces = 0;
290       int m;
291       size_t n;
292 
293       memset(classes_jsa, 0, sizeof(classes_jsa));
294       jvm_name = lib-&gt;name;
295       useSharedSpacesAddr = lookup_symbol(ph, jvm_name, USE_SHARED_SPACES_SYM);
296       if (useSharedSpacesAddr == 0) {
297         print_debug(&quot;can&#39;t lookup &#39;UseSharedSpaces&#39; flag\n&quot;);
298         return false;
299       }
300 
301       // Hotspot vm types are not exported to build this library. So
302       // using equivalent type jboolean to read the value of
303       // UseSharedSpaces which is same as hotspot type &quot;bool&quot;.
304       if (read_jboolean(ph, useSharedSpacesAddr, &amp;useSharedSpaces) != true) {
305         print_debug(&quot;can&#39;t read the value of &#39;UseSharedSpaces&#39; flag\n&quot;);
306         return false;
307       }
308 
309       if ((int)useSharedSpaces == 0) {
310         print_debug(&quot;UseSharedSpaces is false, assuming -Xshare:off!\n&quot;);
311         return true;
312       }
313 
314       sharedBaseAddressAddr = lookup_symbol(ph, jvm_name, SHARED_BASE_ADDRESS_SYM);
315       if (sharedBaseAddressAddr == 0) {
316         print_debug(&quot;can&#39;t lookup &#39;SharedBaseAddress&#39; flag\n&quot;);
317         return false;
318       }
319 
320       if (read_pointer(ph, sharedBaseAddressAddr, &amp;sharedBaseAddress) != true) {
321         print_debug(&quot;can&#39;t read the value of &#39;SharedBaseAddress&#39; flag\n&quot;);
322         return false;
323       }
324 
325       sharedArchivePathAddrAddr = lookup_symbol(ph, jvm_name, SHARED_ARCHIVE_PATH_SYM);
326       if (sharedArchivePathAddrAddr == 0) {
327         print_debug(&quot;can&#39;t lookup shared archive path symbol\n&quot;);
328         return false;
329       }
330 
331       if (read_pointer(ph, sharedArchivePathAddrAddr, &amp;sharedArchivePathAddr) != true) {
332         print_debug(&quot;can&#39;t read shared archive path pointer\n&quot;);
333         return false;
334       }
335 
336       if (read_string(ph, sharedArchivePathAddr, classes_jsa, sizeof(classes_jsa)) != true) {
337         print_debug(&quot;can&#39;t read shared archive path value\n&quot;);
338         return false;
339       }
340 
341       print_debug(&quot;looking for %s\n&quot;, classes_jsa);
342       // open the class sharing archive file
343       fd = pathmap_open(classes_jsa);
344       if (fd &lt; 0) {
345         print_debug(&quot;can&#39;t open %s!\n&quot;, classes_jsa);
346         ph-&gt;core-&gt;classes_jsa_fd = -1;
347         return false;
348       } else {
349         print_debug(&quot;opened %s\n&quot;, classes_jsa);
350       }
351 
352       // read CDSFileMapHeaderBase from the file
353       memset(&amp;header, 0, sizeof(CDSFileMapHeaderBase));
354       if ((n = read(fd, &amp;header, sizeof(CDSFileMapHeaderBase)))
355            != sizeof(CDSFileMapHeaderBase)) {
356         print_debug(&quot;can&#39;t read shared archive file map header from %s\n&quot;, classes_jsa);
357         close(fd);
358         return false;
359       }
360 
361       // check file magic
362       if (header._magic != CDS_ARCHIVE_MAGIC) {
363         print_debug(&quot;%s has bad shared archive file magic number 0x%x, expecting 0x%x\n&quot;,
364                     classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);
365         close(fd);
366         return false;
367       }
368 
369       // check version
370       if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {
371         print_debug(&quot;%s has wrong shared archive file version %d, expecting %d\n&quot;,
372                      classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);
373         close(fd);
374         return false;
375       }
376 
377       ph-&gt;core-&gt;classes_jsa_fd = fd;
378       // add read-only maps from classes.jsa to the list of maps
379       for (m = 0; m &lt; NUM_CDS_REGIONS; m++) {
380         if (header._space[m]._read_only &amp;&amp;
381             !header._space[m]._is_heap_region &amp;&amp;
382             !header._space[m]._is_bitmap_region) {
383           // With *some* linux versions, the core file doesn&#39;t include read-only mmap&#39;ed
384           // files regions, so let&#39;s add them here. This is harmless if the core file also
385           // include these regions.
386           uintptr_t base = sharedBaseAddress + (uintptr_t) header._space[m]._mapping_offset;
387           size_t size = header._space[m]._used;
388           // no need to worry about the fractional pages at-the-end.
389           // possible fractional pages are handled by core_read_data.
390           add_class_share_map_info(ph, (off_t) header._space[m]._file_offset,
391                                    base, size);
392           print_debug(&quot;added a share archive map [%d] at 0x%lx (size 0x%lx bytes)\n&quot;, m, base, size);
393         }
394       }
395       return true;
396    }
397    lib = lib-&gt;next;
398   }
399   return true;
400 }
401 
402 #endif // defined(LINUX) || defined(__APPLE__)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
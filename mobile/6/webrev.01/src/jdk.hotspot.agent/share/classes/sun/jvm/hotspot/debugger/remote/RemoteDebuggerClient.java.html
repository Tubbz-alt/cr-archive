<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/remote/RemoteDebuggerClient.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.remote;
 26 
 27 import java.rmi.*;
 28 import java.util.*;
 29 import java.lang.reflect.*;
 30 
 31 import sun.jvm.hotspot.debugger.*;
 32 import sun.jvm.hotspot.debugger.cdbg.*;
 33 import sun.jvm.hotspot.debugger.remote.x86.*;
 34 import sun.jvm.hotspot.debugger.remote.amd64.*;
 35 import sun.jvm.hotspot.debugger.remote.ppc64.*;
 36 
 37 /** An implementation of Debugger which wraps a
 38     RemoteDebugger, providing remote debugging via RMI.
 39     This implementation provides caching of the remote process&#39;s
 40     address space on the local machine where the user interface is
 41     running. */
 42 
 43 public class RemoteDebuggerClient extends DebuggerBase implements JVMDebugger {
 44   private RemoteDebugger remoteDebugger;
 45   private RemoteThreadFactory threadFactory;
 46   private boolean unalignedAccessesOkay = false;
 47   private static final int cacheSize = 16 * 1024 * 1024; // 16 MB
 48 
 49   public RemoteDebuggerClient(RemoteDebugger remoteDebugger) throws DebuggerException {
 50     super();
 51     try {
 52       this.remoteDebugger = remoteDebugger;
 53       machDesc = remoteDebugger.getMachineDescription();
 54       utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian());
 55       int cacheNumPages;
 56       int cachePageSize;
 57       String cpu = remoteDebugger.getCPU();
 58       // page size. (FIXME: should pick this up from the remoteDebugger.)
 59       if (cpu.equals(&quot;x86&quot;)) {
 60         threadFactory = new RemoteX86ThreadFactory(this);
 61         cachePageSize = 4096;
 62         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 63         unalignedAccessesOkay = true;
 64       } else if (cpu.equals(&quot;amd64&quot;) || cpu.equals(&quot;x86_64&quot;)) {
 65         threadFactory = new RemoteAMD64ThreadFactory(this);
 66         cachePageSize = 4096;
 67         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 68         unalignedAccessesOkay = true;
 69       } else if (cpu.equals(&quot;ppc64&quot;)) {
 70         threadFactory = new RemotePPC64ThreadFactory(this);
 71         cachePageSize = 4096;
 72         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 73         unalignedAccessesOkay = true;
 74       } else {
 75         try {
 76           Class tf = Class.forName(&quot;sun.jvm.hotspot.debugger.remote.&quot; +
 77             cpu.toLowerCase() + &quot;.Remote&quot; + cpu.toUpperCase() +
 78             &quot;ThreadFactory&quot;);
 79           Constructor[] ctf = tf.getConstructors();
 80           threadFactory = (RemoteThreadFactory)ctf[0].newInstance(this);
 81         } catch (Exception e) {
 82           throw new DebuggerException(&quot;Thread access for CPU architecture &quot; + cpu + &quot; not yet supported&quot;);
 83         }
 84         cachePageSize = 4096;
 85         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 86         unalignedAccessesOkay = false;
 87       }
 88 
 89       // Cache portion of the remote process&#39;s address space.
 90       initCache(cachePageSize, cacheNumPages);
 91 
 92       jbooleanSize = remoteDebugger.getJBooleanSize();
 93       jbyteSize    = remoteDebugger.getJByteSize();
 94       jcharSize    = remoteDebugger.getJCharSize();
 95       jdoubleSize  = remoteDebugger.getJDoubleSize();
 96       jfloatSize   = remoteDebugger.getJFloatSize();
 97       jintSize     = remoteDebugger.getJIntSize();
 98       jlongSize    = remoteDebugger.getJLongSize();
 99       jshortSize   = remoteDebugger.getJShortSize();
100       javaPrimitiveTypesConfigured = true;
101       narrowOopBase  = remoteDebugger.getNarrowOopBase();
102       narrowOopShift = remoteDebugger.getNarrowOopShift();
103       narrowKlassBase  = remoteDebugger.getNarrowKlassBase();
104       narrowKlassShift = remoteDebugger.getNarrowKlassShift();
105       heapOopSize  = remoteDebugger.getHeapOopSize();
106       klassPtrSize  = remoteDebugger.getKlassPtrSize();
107     }
108     catch (RemoteException e) {
109       throw new DebuggerException(e);
110     }
111   }
112 
113   public long[] getThreadIntegerRegisterSet(Address addr) {
114     try {
115       return remoteDebugger.getThreadIntegerRegisterSet(getAddressValue(addr), true);
116     }
117     catch (RemoteException e) {
118       throw new DebuggerException(e);
119     }
120   }
121 
122   public long[] getThreadIntegerRegisterSet(long id) {
123     try {
124       return remoteDebugger.getThreadIntegerRegisterSet(id, false);
125     }
126     catch (RemoteException e) {
127       throw new DebuggerException(e);
128     }
129   }
130 
131   /** Unimplemented in this class (remote remoteDebugger should already be attached) */
132   public boolean hasProcessList() throws DebuggerException {
133     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
134   }
135 
136   /** Unimplemented in this class (remote remoteDebugger should already be attached) */
137   public List&lt;ProcessInfo&gt; getProcessList() throws DebuggerException {
138     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
139   }
140 
141   /** Unimplemented in this class (remote remoteDebugger should already be attached) */
142   public void attach(int processID) throws DebuggerException {
143     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
144   }
145 
146   /** Unimplemented in this class (remote remoteDebugger should already be attached) */
147   public void attach(String executableName, String coreFileName) throws DebuggerException {
148     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
149   }
150 
151   /** Unimplemented in this class (remote remoteDebugger can not be detached) */
152   public boolean detach() {
153     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
154   }
155 
156   public Address parseAddress(String addressString) throws NumberFormatException {
157     long addr = utils.scanAddress(addressString);
158     if (addr == 0) {
159       return null;
160     }
161     return new RemoteAddress(this, addr);
162   }
163 
164   public String getOS() throws DebuggerException {
165     try {
166       return remoteDebugger.getOS();
167     }
168     catch (RemoteException e) {
169       throw new DebuggerException(e);
170     }
171   }
172 
173   public String getCPU() {
174     try {
175       return remoteDebugger.getCPU();
176     }
177     catch (RemoteException e) {
178       throw new DebuggerException(e);
179     }
180   }
181 
182   public boolean hasConsole() throws DebuggerException {
183     try {
184        return remoteDebugger.hasConsole();
185     } catch (RemoteException e) {
186        throw new DebuggerException(e);
187     }
188   }
189 
190   public String consoleExecuteCommand(String cmd) throws DebuggerException {
191     try {
192       return remoteDebugger.consoleExecuteCommand(cmd);
193     }
194     catch (RemoteException e) {
195       throw new DebuggerException(e);
196     }
197   }
198 
199   public String getConsolePrompt() throws DebuggerException {
200     try {
201       return remoteDebugger.getConsolePrompt();
202     } catch (RemoteException e) {
203       throw new DebuggerException(e);
204     }
205   }
206 
207   public CDebugger getCDebugger() throws DebuggerException {
208     return null;
209   }
210 
211   //--------------------------------------------------------------------------------
212   // Implementation of SymbolLookup interface
213 
214   public Address lookup(String objectName, String symbol) {
215     try {
216       long addr = remoteDebugger.lookupInProcess(objectName, symbol);
217       if (addr == 0) {
218         return null;
219       }
220       return new RemoteAddress(this, addr);
221     }
222     catch (RemoteException e) {
223       throw new DebuggerException(e);
224     }
225   }
226 
227   public OopHandle lookupOop(String objectName, String symbol) {
228     try {
229       long addr = remoteDebugger.lookupInProcess(objectName, symbol);
230       if (addr == 0) {
231         return null;
232       }
233       return new RemoteOopHandle(this, addr);
234     }
235     catch (RemoteException e) {
236       throw new DebuggerException(e);
237     }
238   }
239 
240   /** Need to override this to relax alignment checks on x86. */
241   public long readCInteger(long address, long numBytes, boolean isUnsigned)
242     throws UnmappedAddressException, UnalignedAddressException {
243     if (!unalignedAccessesOkay) {
244       utils.checkAlignment(address, numBytes);
245     } else {
246       // Only slightly relaxed semantics -- this is a hack, but is
247       // necessary on x86 where it seems the compiler is
248       // putting some global 64-bit data on 32-bit boundaries
249       if (numBytes == 8) {
250         utils.checkAlignment(address, 4);
251       } else {
252         utils.checkAlignment(address, numBytes);
253       }
254     }
255     byte[] data = readBytes(address, numBytes);
256     return utils.dataToCInteger(data, isUnsigned);
257   }
258 
259   // Overridden from DebuggerBase because we need to relax alignment
260   // constraints on x86
261   public long readJLong(long address)
262     throws UnmappedAddressException, UnalignedAddressException {
263     // FIXME: allow this to be configurable. Undesirable to add a
264     // dependency on the runtime package here, though, since this
265     // package should be strictly underneath it.
266     if (unalignedAccessesOkay) {
267       utils.checkAlignment(address, jintSize);
268     } else {
269       utils.checkAlignment(address, jlongSize);
270     }
271     byte[] data = readBytes(address, jlongSize);
272     return utils.dataToJLong(data, jlongSize);
273   }
274 
275 
276   //--------------------------------------------------------------------------------
277   // Implementation of JVMDebugger interface
278   //
279 
280   /** Unimplemented in this class (remote remoteDebugger should already be configured) */
281   public void configureJavaPrimitiveTypeSizes(long jbooleanSize,
282                                               long jbyteSize,
283                                               long jcharSize,
284                                               long jdoubleSize,
285                                               long jfloatSize,
286                                               long jintSize,
287                                               long jlongSize,
288                                               long jshortSize) {
289     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
290   }
291 
292   public void setMachineDescription(MachineDescription machDesc) {
293     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
294   }
295 
296   public int getRemoteProcessAddressSize() {
297     throw new DebuggerException(&quot;Should not be called on RemoteDebuggerClient&quot;);
298   }
299 
300   public String addressValueToString(long addr) {
301     return utils.addressValueToString(addr);
302   }
303 
304   public long getAddressValue(Address addr) throws DebuggerException {
305     if (addr == null) return 0;
306     return ((RemoteAddress) addr).getValue();
307   }
308 
309   public Address newAddress(long value) {
310     if (value == 0) return null;
311     return new RemoteAddress(this, value);
312   }
313 
314   RemoteAddress readAddress(long address)
315     throws UnmappedAddressException, UnalignedAddressException {
316     long value = readAddressValue(address);
317     return (value == 0 ? null : new RemoteAddress(this, value));
318   }
319 
320   RemoteAddress readCompOopAddress(long address)
321     throws UnmappedAddressException, UnalignedAddressException {
322     long value = readCompOopAddressValue(address);
323     return (value == 0 ? null : new RemoteAddress(this, value));
324   }
325 
326   RemoteAddress readCompKlassAddress(long address)
327     throws UnmappedAddressException, UnalignedAddressException {
328     long value = readCompKlassAddressValue(address);
329     return (value == 0 ? null : new RemoteAddress(this, value));
330   }
331 
332   RemoteOopHandle readOopHandle(long address)
333     throws UnmappedAddressException, UnalignedAddressException, NotInHeapException {
334     long value = readAddressValue(address);
335     return (value == 0 ? null : new RemoteOopHandle(this, value));
336   }
337 
338   RemoteOopHandle readCompOopHandle(long address)
339     throws UnmappedAddressException, UnalignedAddressException, NotInHeapException {
340     long value = readCompOopAddressValue(address);
341     return (value == 0 ? null : new RemoteOopHandle(this, value));
342   }
343 
344   boolean areThreadsEqual(Address addr1, Address addr2) {
345     try {
346        return remoteDebugger.areThreadsEqual(getAddressValue(addr1), true,
347                                              getAddressValue(addr2), true);
348     } catch (RemoteException e) {
349     }
350     return false;
351   }
352 
353   boolean areThreadsEqual(long id1, long id2) {
354     try {
355        return remoteDebugger.areThreadsEqual(id1, false, id2, false);
356     } catch (RemoteException e) {
357     }
358     return false;
359   }
360 
361   boolean areThreadsEqual(Address addr1, long id2) {
362     try {
363        return remoteDebugger.areThreadsEqual(getAddressValue(addr1), true, id2, false);
364     } catch (RemoteException e) {
365     }
366     return false;
367   }
368 
369   boolean areThreadsEqual(long id1, Address addr2) {
370     try {
371        return remoteDebugger.areThreadsEqual(id1, false, getAddressValue(addr2), true);
372     } catch (RemoteException e) {
373     }
374     return false;
375   }
376 
377   int getThreadHashCode(Address a) {
378     try {
379        return remoteDebugger.getThreadHashCode(getAddressValue(a), true);
380     } catch (RemoteException e) {
381     }
382     return a.hashCode();
383   }
384 
385   int getThreadHashCode(long id) {
386     try {
387        return remoteDebugger.getThreadHashCode(id, false);
388     } catch (RemoteException e) {
389     }
390     return (int) id;
391   }
392 
393   public ThreadProxy getThreadForIdentifierAddress(Address addr) {
394      return threadFactory.createThreadWrapper(addr);
395   }
396 
397   public ThreadProxy getThreadForThreadId(long id) {
398      return threadFactory.createThreadWrapper(id);
399   }
400 
401   public MachineDescription getMachineDescription() throws DebuggerException {
402      return machDesc;
403   }
404 
405   /** This reads bytes from the remote process. */
406   public ReadResult readBytesFromProcess(long address, long numBytes) {
407     try {
408       return remoteDebugger.readBytesFromProcess(address, numBytes);
409     }
410     catch (RemoteException e) {
411       throw new DebuggerException(e);
412     }
413   }
414 
415   public void writeBytesToProcess(long a, long b, byte[] c) {
416      throw new DebuggerException(&quot;Unimplemented!&quot;);
417   }
418 }
    </pre>
  </body>
</html>
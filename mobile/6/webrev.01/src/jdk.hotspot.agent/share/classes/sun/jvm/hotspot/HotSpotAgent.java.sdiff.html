<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="HSDB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="asm/Disassembler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/HotSpotAgent.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot;
 26 
 27 import java.rmi.RemoteException;
 28 import java.lang.reflect.Constructor;
 29 import java.lang.reflect.InvocationTargetException;
 30 
 31 import sun.jvm.hotspot.debugger.Debugger;
 32 import sun.jvm.hotspot.debugger.DebuggerException;
 33 import sun.jvm.hotspot.debugger.JVMDebugger;
 34 import sun.jvm.hotspot.debugger.MachineDescription;
 35 import sun.jvm.hotspot.debugger.MachineDescriptionAMD64;
 36 import sun.jvm.hotspot.debugger.MachineDescriptionPPC64;
 37 import sun.jvm.hotspot.debugger.MachineDescriptionAArch64;
 38 import sun.jvm.hotspot.debugger.MachineDescriptionIntelX86;
<span class="line-removed"> 39 import sun.jvm.hotspot.debugger.MachineDescriptionSPARC32Bit;</span>
<span class="line-removed"> 40 import sun.jvm.hotspot.debugger.MachineDescriptionSPARC64Bit;</span>
 41 import sun.jvm.hotspot.debugger.NoSuchSymbolException;
 42 import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;
 43 import sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal;
<span class="line-removed"> 44 import sun.jvm.hotspot.debugger.proc.ProcDebuggerLocal;</span>
 45 import sun.jvm.hotspot.debugger.remote.RemoteDebugger;
 46 import sun.jvm.hotspot.debugger.remote.RemoteDebuggerClient;
 47 import sun.jvm.hotspot.debugger.remote.RemoteDebuggerServer;
 48 import sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal;
 49 import sun.jvm.hotspot.runtime.VM;
 50 import sun.jvm.hotspot.types.TypeDataBase;
 51 import sun.jvm.hotspot.utilities.PlatformInfo;
 52 import sun.jvm.hotspot.utilities.UnsupportedPlatformException;
 53 
 54 /** &lt;P&gt; This class wraps much of the basic functionality and is the
 55  * highest-level factory for VM data structures. It makes it simple
 56  * to start up the debugging system. &lt;/P&gt;
 57  *
 58  * &lt;P&gt; FIXME: especially with the addition of remote debugging, this
 59  * has turned into a mess; needs rethinking. &lt;/P&gt;
 60  */
 61 
 62 public class HotSpotAgent {
 63     private JVMDebugger debugger;
 64     private MachineDescription machDesc;
</pre>
<hr />
<pre>
340             // server, but not client attaching to server)
341             //
342 
343             // Handle existing or alternate JVMDebugger:
344             // these will set os, cpu independently of our PlatformInfo implementation.
345             String alternateDebugger = System.getProperty(&quot;sa.altDebugger&quot;);
346             if (debugger != null) {
347                 setupDebuggerExisting();
348 
349             } else if (alternateDebugger != null) {
350                 setupDebuggerAlternate(alternateDebugger);
351 
352             } else {
353                 // Otherwise, os, cpu are those of our current platform:
354                 try {
355                     os  = PlatformInfo.getOS();
356                     cpu = PlatformInfo.getCPU();
357                 } catch (UnsupportedPlatformException e) {
358                    throw new DebuggerException(e);
359                 }
<span class="line-modified">360                 if (os.equals(&quot;solaris&quot;)) {</span>
<span class="line-removed">361                     setupDebuggerSolaris();</span>
<span class="line-removed">362                 } else if (os.equals(&quot;win32&quot;)) {</span>
363                     setupDebuggerWin32();
364                 } else if (os.equals(&quot;linux&quot;)) {
365                     setupDebuggerLinux();
366                 } else if (os.equals(&quot;bsd&quot;)) {
367                     setupDebuggerBsd();
368                 } else if (os.equals(&quot;darwin&quot;)) {
369                     setupDebuggerDarwin();
370                 } else {
371                     // Add support for more operating systems here
372                     throw new DebuggerException(&quot;Operating system &quot; + os + &quot; not yet supported&quot;);
373                 }
374             }
375 
376             if (isServer) {
377                 RemoteDebuggerServer remote = null;
378                 try {
379                     remote = new RemoteDebuggerServer(debugger, rmiPort);
380                 }
381                 catch (RemoteException rem) {
382                     throw new DebuggerException(rem);
</pre>
<hr />
<pre>
394             // security problems since we&#39;re &quot;in the sun.* hierarchy&quot; here.
395             // Perhaps a permissive policy file would work around this. In
396             // the long run, will probably have to move into com.sun.*.
397 
398             //    if (System.getSecurityManager() == null) {
399             //      System.setSecurityManager(new RMISecurityManager());
400             //    }
401 
402             connectRemoteDebugger();
403         }
404     }
405 
406     private void setupVM() {
407         // We need to instantiate a HotSpotTypeDataBase on both the client
408         // and server machine. On the server it is only currently used to
409         // configure the Java primitive type sizes (which we should
410         // consider making constant). On the client it is used to
411         // configure the VM.
412 
413         try {
<span class="line-modified">414             if (os.equals(&quot;solaris&quot;)) {</span>
<span class="line-removed">415                 db = new HotSpotTypeDataBase(machDesc,</span>
<span class="line-removed">416                 new HotSpotSolarisVtblAccess(debugger, jvmLibNames),</span>
<span class="line-removed">417                 debugger, jvmLibNames);</span>
<span class="line-removed">418             } else if (os.equals(&quot;win32&quot;)) {</span>
419                 db = new HotSpotTypeDataBase(machDesc,
420                 new Win32VtblAccess(debugger, jvmLibNames),
421                 debugger, jvmLibNames);
422             } else if (os.equals(&quot;linux&quot;)) {
423                 db = new HotSpotTypeDataBase(machDesc,
424                 new LinuxVtblAccess(debugger, jvmLibNames),
425                 debugger, jvmLibNames);
426             } else if (os.equals(&quot;bsd&quot;)) {
427                 db = new HotSpotTypeDataBase(machDesc,
428                 new BsdVtblAccess(debugger, jvmLibNames),
429                 debugger, jvmLibNames);
430             } else if (os.equals(&quot;darwin&quot;)) {
431                 db = new HotSpotTypeDataBase(machDesc,
432                 new BsdVtblAccess(debugger, jvmLibNames),
433                 debugger, jvmLibNames);
434             } else {
435                 throw new DebuggerException(&quot;OS \&quot;&quot; + os + &quot;\&quot; not yet supported (no VtblAccess yet)&quot;);
436             }
437         }
438         catch (NoSuchSymbolException e) {
</pre>
<hr />
<pre>
487             Constructor cons = c.getConstructor();
488             debugger = (JVMDebugger) cons.newInstance();
489             attachDebugger();
490             setupDebuggerExisting();
491 
492         } catch (ClassNotFoundException cnfe) {
493             throw new DebuggerException(&quot;Cannot find alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39;&quot;);
494         } catch (NoSuchMethodException nsme) {
495             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; has missing constructor.&quot;);
496         } catch (InstantiationException ie) {
497             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, ie);
498         } catch (IllegalAccessException iae) {
499             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, iae);
500         } catch (InvocationTargetException iae) {
501             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, iae);
502         }
503 
504         System.err.println(&quot;Loaded alternate HotSpot SA Debugger: &quot; + alternateName);
505     }
506 
<span class="line-removed">507     //</span>
<span class="line-removed">508     // Solaris</span>
<span class="line-removed">509     //</span>
<span class="line-removed">510 </span>
<span class="line-removed">511     private void setupDebuggerSolaris() {</span>
<span class="line-removed">512         setupJVMLibNamesSolaris();</span>
<span class="line-removed">513         ProcDebuggerLocal dbg = new ProcDebuggerLocal(null, true);</span>
<span class="line-removed">514         debugger = dbg;</span>
<span class="line-removed">515         attachDebugger();</span>
<span class="line-removed">516 </span>
<span class="line-removed">517         // Set up CPU-dependent stuff</span>
<span class="line-removed">518         if (cpu.equals(&quot;x86&quot;)) {</span>
<span class="line-removed">519             machDesc = new MachineDescriptionIntelX86();</span>
<span class="line-removed">520         } else if (cpu.equals(&quot;sparc&quot;)) {</span>
<span class="line-removed">521             int addressSize = dbg.getRemoteProcessAddressSize();</span>
<span class="line-removed">522             if (addressSize == -1) {</span>
<span class="line-removed">523                 throw new DebuggerException(&quot;Error occurred while trying to determine the remote process&#39;s &quot; +</span>
<span class="line-removed">524                                             &quot;address size&quot;);</span>
<span class="line-removed">525             }</span>
<span class="line-removed">526 </span>
<span class="line-removed">527             if (addressSize == 32) {</span>
<span class="line-removed">528                 machDesc = new MachineDescriptionSPARC32Bit();</span>
<span class="line-removed">529             } else if (addressSize == 64) {</span>
<span class="line-removed">530                 machDesc = new MachineDescriptionSPARC64Bit();</span>
<span class="line-removed">531             } else {</span>
<span class="line-removed">532                 throw new DebuggerException(&quot;Address size &quot; + addressSize + &quot; is not supported on SPARC&quot;);</span>
<span class="line-removed">533             }</span>
<span class="line-removed">534         } else if (cpu.equals(&quot;amd64&quot;)) {</span>
<span class="line-removed">535             machDesc = new MachineDescriptionAMD64();</span>
<span class="line-removed">536         } else {</span>
<span class="line-removed">537             throw new DebuggerException(&quot;Solaris only supported on sparc/sparcv9/x86/amd64&quot;);</span>
<span class="line-removed">538         }</span>
<span class="line-removed">539 </span>
<span class="line-removed">540         dbg.setMachineDescription(machDesc);</span>
<span class="line-removed">541         return;</span>
<span class="line-removed">542     }</span>
<span class="line-removed">543 </span>
544     private void connectRemoteDebugger() throws DebuggerException {
545         RemoteDebugger remote =
546         (RemoteDebugger) RMIHelper.lookup(debugServerID);
547         debugger = new RemoteDebuggerClient(remote);
548         machDesc = ((RemoteDebuggerClient) debugger).getMachineDescription();
549         os = debugger.getOS();
550         setupJVMLibNames(os);
551         cpu = debugger.getCPU();
552     }
553 
554     private void setupJVMLibNames(String os) {
<span class="line-modified">555         if (os.equals(&quot;solaris&quot;)) {</span>
<span class="line-removed">556             setupJVMLibNamesSolaris();</span>
<span class="line-removed">557         } else if (os.equals(&quot;win32&quot;)) {</span>
558             setupJVMLibNamesWin32();
559         } else if (os.equals(&quot;linux&quot;)) {
560             setupJVMLibNamesLinux();
561         } else if (os.equals(&quot;bsd&quot;)) {
562             setupJVMLibNamesBsd();
563         } else if (os.equals(&quot;darwin&quot;)) {
564             setupJVMLibNamesDarwin();
565         } else {
566             throw new RuntimeException(&quot;Unknown OS type&quot;);
567         }
568     }
569 
<span class="line-removed">570     private void setupJVMLibNamesSolaris() {</span>
<span class="line-removed">571         jvmLibNames = new String[] { &quot;libjvm.so&quot; };</span>
<span class="line-removed">572     }</span>
<span class="line-removed">573 </span>
574     //
575     // Win32
576     //
577 
578     private void setupDebuggerWin32() {
579         setupJVMLibNamesWin32();
580 
581         if (cpu.equals(&quot;x86&quot;)) {
582             machDesc = new MachineDescriptionIntelX86();
583         } else if (cpu.equals(&quot;amd64&quot;)) {
584             machDesc = new MachineDescriptionAMD64();
585         } else {
586             throw new DebuggerException(&quot;Win32 supported under x86 and amd64 only&quot;);
587         }
588 
589         // Note we do not use a cache for the local debugger in server
590         // mode; it will be taken care of on the client side (once remote
591         // debugging is implemented).
592 
593         debugger = new WindbgDebuggerLocal(machDesc, !isServer);
</pre>
<hr />
<pre>
599 
600     private void setupJVMLibNamesWin32() {
601         jvmLibNames = new String[] { &quot;jvm.dll&quot; };
602     }
603 
604     //
605     // Linux
606     //
607 
608     private void setupDebuggerLinux() {
609         setupJVMLibNamesLinux();
610 
611         if (cpu.equals(&quot;x86&quot;)) {
612             machDesc = new MachineDescriptionIntelX86();
613         } else if (cpu.equals(&quot;amd64&quot;)) {
614             machDesc = new MachineDescriptionAMD64();
615         } else if (cpu.equals(&quot;ppc64&quot;)) {
616             machDesc = new MachineDescriptionPPC64();
617         } else if (cpu.equals(&quot;aarch64&quot;)) {
618             machDesc = new MachineDescriptionAArch64();
<span class="line-removed">619         } else if (cpu.equals(&quot;sparc&quot;)) {</span>
<span class="line-removed">620             if (LinuxDebuggerLocal.getAddressSize()==8) {</span>
<span class="line-removed">621                     machDesc = new MachineDescriptionSPARC64Bit();</span>
<span class="line-removed">622             } else {</span>
<span class="line-removed">623                     machDesc = new MachineDescriptionSPARC32Bit();</span>
<span class="line-removed">624             }</span>
625         } else {
626           try {
627             machDesc = (MachineDescription)
628               Class.forName(&quot;sun.jvm.hotspot.debugger.MachineDescription&quot; +
629                             cpu.toUpperCase()).getDeclaredConstructor().newInstance();
630           } catch (Exception e) {
631             throw new DebuggerException(&quot;Linux not supported on machine type &quot; + cpu);
632           }
633         }
634 
635         LinuxDebuggerLocal dbg =
636         new LinuxDebuggerLocal(machDesc, !isServer);
637         debugger = dbg;
638 
639         attachDebugger();
640     }
641 
642     private void setupJVMLibNamesLinux() {
643         jvmLibNames = new String[] { &quot;libjvm.so&quot; };
644     }
</pre>
</td>
<td>
<hr />
<pre>
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot;
 26 
 27 import java.rmi.RemoteException;
 28 import java.lang.reflect.Constructor;
 29 import java.lang.reflect.InvocationTargetException;
 30 
 31 import sun.jvm.hotspot.debugger.Debugger;
 32 import sun.jvm.hotspot.debugger.DebuggerException;
 33 import sun.jvm.hotspot.debugger.JVMDebugger;
 34 import sun.jvm.hotspot.debugger.MachineDescription;
 35 import sun.jvm.hotspot.debugger.MachineDescriptionAMD64;
 36 import sun.jvm.hotspot.debugger.MachineDescriptionPPC64;
 37 import sun.jvm.hotspot.debugger.MachineDescriptionAArch64;
 38 import sun.jvm.hotspot.debugger.MachineDescriptionIntelX86;


 39 import sun.jvm.hotspot.debugger.NoSuchSymbolException;
 40 import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;
 41 import sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal;

 42 import sun.jvm.hotspot.debugger.remote.RemoteDebugger;
 43 import sun.jvm.hotspot.debugger.remote.RemoteDebuggerClient;
 44 import sun.jvm.hotspot.debugger.remote.RemoteDebuggerServer;
 45 import sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal;
 46 import sun.jvm.hotspot.runtime.VM;
 47 import sun.jvm.hotspot.types.TypeDataBase;
 48 import sun.jvm.hotspot.utilities.PlatformInfo;
 49 import sun.jvm.hotspot.utilities.UnsupportedPlatformException;
 50 
 51 /** &lt;P&gt; This class wraps much of the basic functionality and is the
 52  * highest-level factory for VM data structures. It makes it simple
 53  * to start up the debugging system. &lt;/P&gt;
 54  *
 55  * &lt;P&gt; FIXME: especially with the addition of remote debugging, this
 56  * has turned into a mess; needs rethinking. &lt;/P&gt;
 57  */
 58 
 59 public class HotSpotAgent {
 60     private JVMDebugger debugger;
 61     private MachineDescription machDesc;
</pre>
<hr />
<pre>
337             // server, but not client attaching to server)
338             //
339 
340             // Handle existing or alternate JVMDebugger:
341             // these will set os, cpu independently of our PlatformInfo implementation.
342             String alternateDebugger = System.getProperty(&quot;sa.altDebugger&quot;);
343             if (debugger != null) {
344                 setupDebuggerExisting();
345 
346             } else if (alternateDebugger != null) {
347                 setupDebuggerAlternate(alternateDebugger);
348 
349             } else {
350                 // Otherwise, os, cpu are those of our current platform:
351                 try {
352                     os  = PlatformInfo.getOS();
353                     cpu = PlatformInfo.getCPU();
354                 } catch (UnsupportedPlatformException e) {
355                    throw new DebuggerException(e);
356                 }
<span class="line-modified">357                 if (os.equals(&quot;win32&quot;)) {</span>


358                     setupDebuggerWin32();
359                 } else if (os.equals(&quot;linux&quot;)) {
360                     setupDebuggerLinux();
361                 } else if (os.equals(&quot;bsd&quot;)) {
362                     setupDebuggerBsd();
363                 } else if (os.equals(&quot;darwin&quot;)) {
364                     setupDebuggerDarwin();
365                 } else {
366                     // Add support for more operating systems here
367                     throw new DebuggerException(&quot;Operating system &quot; + os + &quot; not yet supported&quot;);
368                 }
369             }
370 
371             if (isServer) {
372                 RemoteDebuggerServer remote = null;
373                 try {
374                     remote = new RemoteDebuggerServer(debugger, rmiPort);
375                 }
376                 catch (RemoteException rem) {
377                     throw new DebuggerException(rem);
</pre>
<hr />
<pre>
389             // security problems since we&#39;re &quot;in the sun.* hierarchy&quot; here.
390             // Perhaps a permissive policy file would work around this. In
391             // the long run, will probably have to move into com.sun.*.
392 
393             //    if (System.getSecurityManager() == null) {
394             //      System.setSecurityManager(new RMISecurityManager());
395             //    }
396 
397             connectRemoteDebugger();
398         }
399     }
400 
401     private void setupVM() {
402         // We need to instantiate a HotSpotTypeDataBase on both the client
403         // and server machine. On the server it is only currently used to
404         // configure the Java primitive type sizes (which we should
405         // consider making constant). On the client it is used to
406         // configure the VM.
407 
408         try {
<span class="line-modified">409             if (os.equals(&quot;win32&quot;)) {</span>




410                 db = new HotSpotTypeDataBase(machDesc,
411                 new Win32VtblAccess(debugger, jvmLibNames),
412                 debugger, jvmLibNames);
413             } else if (os.equals(&quot;linux&quot;)) {
414                 db = new HotSpotTypeDataBase(machDesc,
415                 new LinuxVtblAccess(debugger, jvmLibNames),
416                 debugger, jvmLibNames);
417             } else if (os.equals(&quot;bsd&quot;)) {
418                 db = new HotSpotTypeDataBase(machDesc,
419                 new BsdVtblAccess(debugger, jvmLibNames),
420                 debugger, jvmLibNames);
421             } else if (os.equals(&quot;darwin&quot;)) {
422                 db = new HotSpotTypeDataBase(machDesc,
423                 new BsdVtblAccess(debugger, jvmLibNames),
424                 debugger, jvmLibNames);
425             } else {
426                 throw new DebuggerException(&quot;OS \&quot;&quot; + os + &quot;\&quot; not yet supported (no VtblAccess yet)&quot;);
427             }
428         }
429         catch (NoSuchSymbolException e) {
</pre>
<hr />
<pre>
478             Constructor cons = c.getConstructor();
479             debugger = (JVMDebugger) cons.newInstance();
480             attachDebugger();
481             setupDebuggerExisting();
482 
483         } catch (ClassNotFoundException cnfe) {
484             throw new DebuggerException(&quot;Cannot find alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39;&quot;);
485         } catch (NoSuchMethodException nsme) {
486             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; has missing constructor.&quot;);
487         } catch (InstantiationException ie) {
488             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, ie);
489         } catch (IllegalAccessException iae) {
490             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, iae);
491         } catch (InvocationTargetException iae) {
492             throw new DebuggerException(&quot;Alternate SA Debugger: &#39;&quot; + alternateName + &quot;&#39; fails to initialise: &quot;, iae);
493         }
494 
495         System.err.println(&quot;Loaded alternate HotSpot SA Debugger: &quot; + alternateName);
496     }
497 





































498     private void connectRemoteDebugger() throws DebuggerException {
499         RemoteDebugger remote =
500         (RemoteDebugger) RMIHelper.lookup(debugServerID);
501         debugger = new RemoteDebuggerClient(remote);
502         machDesc = ((RemoteDebuggerClient) debugger).getMachineDescription();
503         os = debugger.getOS();
504         setupJVMLibNames(os);
505         cpu = debugger.getCPU();
506     }
507 
508     private void setupJVMLibNames(String os) {
<span class="line-modified">509         if (os.equals(&quot;win32&quot;)) {</span>


510             setupJVMLibNamesWin32();
511         } else if (os.equals(&quot;linux&quot;)) {
512             setupJVMLibNamesLinux();
513         } else if (os.equals(&quot;bsd&quot;)) {
514             setupJVMLibNamesBsd();
515         } else if (os.equals(&quot;darwin&quot;)) {
516             setupJVMLibNamesDarwin();
517         } else {
518             throw new RuntimeException(&quot;Unknown OS type&quot;);
519         }
520     }
521 




522     //
523     // Win32
524     //
525 
526     private void setupDebuggerWin32() {
527         setupJVMLibNamesWin32();
528 
529         if (cpu.equals(&quot;x86&quot;)) {
530             machDesc = new MachineDescriptionIntelX86();
531         } else if (cpu.equals(&quot;amd64&quot;)) {
532             machDesc = new MachineDescriptionAMD64();
533         } else {
534             throw new DebuggerException(&quot;Win32 supported under x86 and amd64 only&quot;);
535         }
536 
537         // Note we do not use a cache for the local debugger in server
538         // mode; it will be taken care of on the client side (once remote
539         // debugging is implemented).
540 
541         debugger = new WindbgDebuggerLocal(machDesc, !isServer);
</pre>
<hr />
<pre>
547 
548     private void setupJVMLibNamesWin32() {
549         jvmLibNames = new String[] { &quot;jvm.dll&quot; };
550     }
551 
552     //
553     // Linux
554     //
555 
556     private void setupDebuggerLinux() {
557         setupJVMLibNamesLinux();
558 
559         if (cpu.equals(&quot;x86&quot;)) {
560             machDesc = new MachineDescriptionIntelX86();
561         } else if (cpu.equals(&quot;amd64&quot;)) {
562             machDesc = new MachineDescriptionAMD64();
563         } else if (cpu.equals(&quot;ppc64&quot;)) {
564             machDesc = new MachineDescriptionPPC64();
565         } else if (cpu.equals(&quot;aarch64&quot;)) {
566             machDesc = new MachineDescriptionAArch64();






567         } else {
568           try {
569             machDesc = (MachineDescription)
570               Class.forName(&quot;sun.jvm.hotspot.debugger.MachineDescription&quot; +
571                             cpu.toUpperCase()).getDeclaredConstructor().newInstance();
572           } catch (Exception e) {
573             throw new DebuggerException(&quot;Linux not supported on machine type &quot; + cpu);
574           }
575         }
576 
577         LinuxDebuggerLocal dbg =
578         new LinuxDebuggerLocal(machDesc, !isServer);
579         debugger = dbg;
580 
581         attachDebugger();
582     }
583 
584     private void setupJVMLibNamesLinux() {
585         jvmLibNames = new String[] { &quot;libjvm.so&quot; };
586     }
</pre>
</td>
</tr>
</table>
<center><a href="HSDB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="asm/Disassembler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
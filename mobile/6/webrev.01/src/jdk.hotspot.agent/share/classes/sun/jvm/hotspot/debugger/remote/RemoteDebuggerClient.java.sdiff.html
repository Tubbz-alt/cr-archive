<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/remote/RemoteDebuggerClient.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../linux/LinuxThreadContextFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../gc/z/ZAddress.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/debugger/remote/RemoteDebuggerClient.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.remote;
 26 
 27 import java.rmi.*;
 28 import java.util.*;
 29 import java.lang.reflect.*;
 30 
 31 import sun.jvm.hotspot.debugger.*;
 32 import sun.jvm.hotspot.debugger.cdbg.*;
<span class="line-removed"> 33 import sun.jvm.hotspot.debugger.remote.sparc.*;</span>
 34 import sun.jvm.hotspot.debugger.remote.x86.*;
 35 import sun.jvm.hotspot.debugger.remote.amd64.*;
 36 import sun.jvm.hotspot.debugger.remote.ppc64.*;
 37 
 38 /** An implementation of Debugger which wraps a
 39     RemoteDebugger, providing remote debugging via RMI.
 40     This implementation provides caching of the remote process&#39;s
 41     address space on the local machine where the user interface is
 42     running. */
 43 
 44 public class RemoteDebuggerClient extends DebuggerBase implements JVMDebugger {
 45   private RemoteDebugger remoteDebugger;
 46   private RemoteThreadFactory threadFactory;
 47   private boolean unalignedAccessesOkay = false;
 48   private static final int cacheSize = 16 * 1024 * 1024; // 16 MB
 49 
 50   public RemoteDebuggerClient(RemoteDebugger remoteDebugger) throws DebuggerException {
 51     super();
 52     try {
 53       this.remoteDebugger = remoteDebugger;
 54       machDesc = remoteDebugger.getMachineDescription();
 55       utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian());
 56       int cacheNumPages;
 57       int cachePageSize;
 58       String cpu = remoteDebugger.getCPU();
 59       // page size. (FIXME: should pick this up from the remoteDebugger.)
<span class="line-modified"> 60       if (cpu.equals(&quot;sparc&quot;)) {</span>
<span class="line-removed"> 61         threadFactory = new RemoteSPARCThreadFactory(this);</span>
<span class="line-removed"> 62         cachePageSize = 8192;</span>
<span class="line-removed"> 63         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);</span>
<span class="line-removed"> 64       } else if (cpu.equals(&quot;x86&quot;)) {</span>
 65         threadFactory = new RemoteX86ThreadFactory(this);
 66         cachePageSize = 4096;
 67         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 68         unalignedAccessesOkay = true;
 69       } else if (cpu.equals(&quot;amd64&quot;) || cpu.equals(&quot;x86_64&quot;)) {
 70         threadFactory = new RemoteAMD64ThreadFactory(this);
 71         cachePageSize = 4096;
 72         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 73         unalignedAccessesOkay = true;
 74       } else if (cpu.equals(&quot;ppc64&quot;)) {
 75         threadFactory = new RemotePPC64ThreadFactory(this);
 76         cachePageSize = 4096;
 77         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 78         unalignedAccessesOkay = true;
 79       } else {
 80         try {
 81           Class tf = Class.forName(&quot;sun.jvm.hotspot.debugger.remote.&quot; +
 82             cpu.toLowerCase() + &quot;.Remote&quot; + cpu.toUpperCase() +
 83             &quot;ThreadFactory&quot;);
 84           Constructor[] ctf = tf.getConstructors();
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 package sun.jvm.hotspot.debugger.remote;
 26 
 27 import java.rmi.*;
 28 import java.util.*;
 29 import java.lang.reflect.*;
 30 
 31 import sun.jvm.hotspot.debugger.*;
 32 import sun.jvm.hotspot.debugger.cdbg.*;

 33 import sun.jvm.hotspot.debugger.remote.x86.*;
 34 import sun.jvm.hotspot.debugger.remote.amd64.*;
 35 import sun.jvm.hotspot.debugger.remote.ppc64.*;
 36 
 37 /** An implementation of Debugger which wraps a
 38     RemoteDebugger, providing remote debugging via RMI.
 39     This implementation provides caching of the remote process&#39;s
 40     address space on the local machine where the user interface is
 41     running. */
 42 
 43 public class RemoteDebuggerClient extends DebuggerBase implements JVMDebugger {
 44   private RemoteDebugger remoteDebugger;
 45   private RemoteThreadFactory threadFactory;
 46   private boolean unalignedAccessesOkay = false;
 47   private static final int cacheSize = 16 * 1024 * 1024; // 16 MB
 48 
 49   public RemoteDebuggerClient(RemoteDebugger remoteDebugger) throws DebuggerException {
 50     super();
 51     try {
 52       this.remoteDebugger = remoteDebugger;
 53       machDesc = remoteDebugger.getMachineDescription();
 54       utils = new DebuggerUtilities(machDesc.getAddressSize(), machDesc.isBigEndian());
 55       int cacheNumPages;
 56       int cachePageSize;
 57       String cpu = remoteDebugger.getCPU();
 58       // page size. (FIXME: should pick this up from the remoteDebugger.)
<span class="line-modified"> 59       if (cpu.equals(&quot;x86&quot;)) {</span>




 60         threadFactory = new RemoteX86ThreadFactory(this);
 61         cachePageSize = 4096;
 62         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 63         unalignedAccessesOkay = true;
 64       } else if (cpu.equals(&quot;amd64&quot;) || cpu.equals(&quot;x86_64&quot;)) {
 65         threadFactory = new RemoteAMD64ThreadFactory(this);
 66         cachePageSize = 4096;
 67         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 68         unalignedAccessesOkay = true;
 69       } else if (cpu.equals(&quot;ppc64&quot;)) {
 70         threadFactory = new RemotePPC64ThreadFactory(this);
 71         cachePageSize = 4096;
 72         cacheNumPages = parseCacheNumPagesProperty(cacheSize / cachePageSize);
 73         unalignedAccessesOkay = true;
 74       } else {
 75         try {
 76           Class tf = Class.forName(&quot;sun.jvm.hotspot.debugger.remote.&quot; +
 77             cpu.toLowerCase() + &quot;.Remote&quot; + cpu.toUpperCase() +
 78             &quot;ThreadFactory&quot;);
 79           Constructor[] ctf = tf.getConstructors();
</pre>
</td>
</tr>
</table>
<center><a href="../linux/LinuxThreadContextFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../gc/z/ZAddress.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.hotspot.agent/linux/native/libsaproc/LinuxDebuggerLocal.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2019, 2020, NTT DATA.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #include &lt;jni.h&gt;
 27 #include &quot;libproc.h&quot;
 28 #include &quot;proc_service.h&quot;
 29 
 30 #include &lt;elf.h&gt;
 31 #include &lt;sys/types.h&gt;
 32 #include &lt;sys/stat.h&gt;
 33 #include &lt;fcntl.h&gt;
 34 #include &lt;stdlib.h&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;limits.h&gt;
 37 #include &lt;cxxabi.h&gt;
 38 
 39 #if defined(x86_64) &amp;&amp; !defined(amd64)
 40 #define amd64 1
 41 #endif
 42 
 43 #if defined(i386) &amp;&amp; !defined(i586)
 44 #define i586 1
 45 #endif
 46 
 47 #ifdef i586
 48 #include &quot;sun_jvm_hotspot_debugger_x86_X86ThreadContext.h&quot;
 49 #endif
 50 
 51 #ifdef amd64
 52 #include &quot;sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext.h&quot;
 53 #endif
 54 
<a name="1" id="anc1"></a>



 55 #if defined(ppc64) || defined(ppc64le)
 56 #include &quot;sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext.h&quot;
 57 #endif
 58 
 59 #ifdef aarch64
 60 #include &quot;sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h&quot;
 61 #endif
 62 
 63 class AutoJavaString {
 64   JNIEnv* m_env;
 65   jstring m_str;
 66   const char* m_buf;
 67 
 68 public:
 69   // check env-&gt;ExceptionOccurred() after ctor
 70   AutoJavaString(JNIEnv* env, jstring str)
 71     : m_env(env), m_str(str), m_buf(env-&gt;GetStringUTFChars(str, NULL)) {
 72   }
 73 
 74   ~AutoJavaString() {
 75     if (m_buf) {
 76       m_env-&gt;ReleaseStringUTFChars(m_str, m_buf);
 77     }
 78   }
 79 
 80   operator const char* () const {
 81     return m_buf;
 82   }
 83 };
 84 
 85 static jfieldID p_ps_prochandle_ID = 0;
 86 static jfieldID threadList_ID = 0;
 87 static jfieldID loadObjectList_ID = 0;
 88 
 89 static jmethodID createClosestSymbol_ID = 0;
 90 static jmethodID createLoadObject_ID = 0;
 91 static jmethodID getThreadForThreadId_ID = 0;
 92 static jmethodID listAdd_ID = 0;
 93 
 94 /*
 95  * SA_ALTROOT environment variable.
 96  * This memory holds env string for putenv(3).
 97  */
 98 static char *saaltroot = NULL;
 99 
100 #define CHECK_EXCEPTION_(value) if (env-&gt;ExceptionOccurred()) { return value; }
101 #define CHECK_EXCEPTION if (env-&gt;ExceptionOccurred()) { return;}
102 #define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
103 #define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
104 
105 void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
106   jclass clazz;
107   clazz = env-&gt;FindClass(&quot;sun/jvm/hotspot/debugger/DebuggerException&quot;);
108   CHECK_EXCEPTION;
109   env-&gt;ThrowNew(clazz, errMsg);
110 }
111 
112 struct ps_prochandle* get_proc_handle(JNIEnv* env, jobject this_obj) {
113   jlong ptr = env-&gt;GetLongField(this_obj, p_ps_prochandle_ID);
114   return (struct ps_prochandle*)(intptr_t)ptr;
115 }
116 
117 /*
118  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
119  * Method:    init0
120  * Signature: ()V
121  */
122 extern &quot;C&quot;
123 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_init0
124   (JNIEnv *env, jclass cls) {
125   jclass listClass;
126 
127   if (init_libproc(getenv(&quot;LIBSAPROC_DEBUG&quot;) != NULL) != true) {
128      THROW_NEW_DEBUGGER_EXCEPTION(&quot;can&#39;t initialize libproc&quot;);
129   }
130 
131   // fields we use
132   p_ps_prochandle_ID = env-&gt;GetFieldID(cls, &quot;p_ps_prochandle&quot;, &quot;J&quot;);
133   CHECK_EXCEPTION;
134   threadList_ID = env-&gt;GetFieldID(cls, &quot;threadList&quot;, &quot;Ljava/util/List;&quot;);
135   CHECK_EXCEPTION;
136   loadObjectList_ID = env-&gt;GetFieldID(cls, &quot;loadObjectList&quot;, &quot;Ljava/util/List;&quot;);
137   CHECK_EXCEPTION;
138 
139   // methods we use
140   createClosestSymbol_ID = env-&gt;GetMethodID(cls, &quot;createClosestSymbol&quot;,
141                     &quot;(Ljava/lang/String;J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;&quot;);
142   CHECK_EXCEPTION;
143   createLoadObject_ID = env-&gt;GetMethodID(cls, &quot;createLoadObject&quot;,
144                     &quot;(Ljava/lang/String;JJ)Lsun/jvm/hotspot/debugger/cdbg/LoadObject;&quot;);
145   CHECK_EXCEPTION;
146   getThreadForThreadId_ID = env-&gt;GetMethodID(cls, &quot;getThreadForThreadId&quot;,
147                                                      &quot;(J)Lsun/jvm/hotspot/debugger/ThreadProxy;&quot;);
148   CHECK_EXCEPTION;
149   // java.util.List method we call
150   listClass = env-&gt;FindClass(&quot;java/util/List&quot;);
151   CHECK_EXCEPTION;
152   listAdd_ID = env-&gt;GetMethodID(listClass, &quot;add&quot;, &quot;(Ljava/lang/Object;)Z&quot;);
153   CHECK_EXCEPTION;
154 }
155 
156 extern &quot;C&quot;
157 JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_getAddressSize
158   (JNIEnv *env, jclass cls)
159 {
160 #ifdef _LP64
161  return 8;
162 #else
163  return 4;
164 #endif
165 
166 }
167 
168 
169 static void fillThreadsAndLoadObjects(JNIEnv* env, jobject this_obj, struct ps_prochandle* ph) {
170   int n = 0, i = 0;
171 
172   // add threads
173   n = get_num_threads(ph);
174   for (i = 0; i &lt; n; i++) {
175     jobject thread;
176     jobject threadList;
177     lwpid_t lwpid;
178 
179     lwpid = get_lwp_id(ph, i);
180     thread = env-&gt;CallObjectMethod(this_obj, getThreadForThreadId_ID, (jlong)lwpid);
181     CHECK_EXCEPTION;
182     threadList = env-&gt;GetObjectField(this_obj, threadList_ID);
183     CHECK_EXCEPTION;
184     env-&gt;CallBooleanMethod(threadList, listAdd_ID, thread);
185     CHECK_EXCEPTION;
186   }
187 
188   // add load objects
189   n = get_num_libs(ph);
190   for (i = 0; i &lt; n; i++) {
191      uintptr_t base;
192      const char* name;
193      jobject loadObject;
194      jobject loadObjectList;
195      jstring str;
196 
197      base = get_lib_base(ph, i);
198      name = get_lib_name(ph, i);
199 
200      str = env-&gt;NewStringUTF(name);
201      CHECK_EXCEPTION;
202      loadObject = env-&gt;CallObjectMethod(this_obj, createLoadObject_ID, str, (jlong)0, (jlong)base);
203      CHECK_EXCEPTION;
204      loadObjectList = env-&gt;GetObjectField(this_obj, loadObjectList_ID);
205      CHECK_EXCEPTION;
206      env-&gt;CallBooleanMethod(loadObjectList, listAdd_ID, loadObject);
207      CHECK_EXCEPTION;
208   }
209 }
210 
211 
212 /*
213  * Verify that a named ELF binary file (core or executable) has the same
214  * bitness as ourselves.
215  * Throw an exception if there is a mismatch or other problem.
216  *
217  * If we proceed using a mismatched debugger/debuggee, the best to hope
218  * for is a missing symbol, the worst is a crash searching for debug symbols.
219  */
220 void verifyBitness(JNIEnv *env, const char *binaryName) {
221   int fd = open(binaryName, O_RDONLY);
222   if (fd &lt; 0) {
223     THROW_NEW_DEBUGGER_EXCEPTION(&quot;cannot open binary file&quot;);
224   }
225   unsigned char elf_ident[EI_NIDENT];
226   int i = read(fd, &amp;elf_ident, sizeof(elf_ident));
227   close(fd);
228 
229   if (i &lt; 0) {
230     THROW_NEW_DEBUGGER_EXCEPTION(&quot;cannot read binary file&quot;);
231   }
232 #ifndef _LP64
233   if (elf_ident[EI_CLASS] == ELFCLASS64) {
234     THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 64 bit, use 64-bit java for debugger&quot;);
235   }
236 #else
237   if (elf_ident[EI_CLASS] != ELFCLASS64) {
238     THROW_NEW_DEBUGGER_EXCEPTION(&quot;debuggee is 32 bit, use 32 bit java for debugger&quot;);
239   }
240 #endif
241 }
242 
243 
244 /*
245  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
246  * Method:    setSAAltRoot0
247  * Signature: (Ljava/lang/String;)V
248  */
249 extern &quot;C&quot;
250 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_setSAAltRoot0
251   (JNIEnv *env, jobject this_obj, jstring altroot) {
252   if (saaltroot != NULL) {
253     free(saaltroot);
254   }
255   const char *path = env-&gt;GetStringUTFChars(altroot, NULL);
256   if (path == NULL) { return; }
257   /*
258    * `saaltroot` is used for putenv().
259    * So we need to keep this memory.
260    */
261   static const char *PREFIX = &quot;SA_ALTROOT=&quot;;
262   size_t len = strlen(PREFIX) + strlen(path) + 1;
263   saaltroot = (char *)malloc(len);
264   snprintf(saaltroot, len, &quot;%s%s&quot;, PREFIX, path);
265   putenv(saaltroot);
266   env-&gt;ReleaseStringUTFChars(altroot, path);
267 }
268 
269 /*
270  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
271  * Method:    attach0
272  * Signature: (I)V
273  */
274 extern &quot;C&quot;
275 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__I
276   (JNIEnv *env, jobject this_obj, jint jpid) {
277 
278   // For bitness checking, locate binary at /proc/jpid/exe
279   char buf[PATH_MAX];
280   snprintf((char *) &amp;buf, PATH_MAX, &quot;/proc/%d/exe&quot;, jpid);
281   verifyBitness(env, (char *) &amp;buf);
282   CHECK_EXCEPTION;
283 
284   char err_buf[200];
285   struct ps_prochandle* ph;
286   if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf))) == NULL) {
287     char msg[230];
288     snprintf(msg, sizeof(msg), &quot;Can&#39;t attach to the process: %s&quot;, err_buf);
289     THROW_NEW_DEBUGGER_EXCEPTION(msg);
290   }
291   env-&gt;SetLongField(this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
292   fillThreadsAndLoadObjects(env, this_obj, ph);
293 }
294 
295 /*
296  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
297  * Method:    attach0
298  * Signature: (Ljava/lang/String;Ljava/lang/String;)V
299  */
300 extern &quot;C&quot;
301 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
302   (JNIEnv *env, jobject this_obj, jstring execName, jstring coreName) {
303   struct ps_prochandle* ph;
304   AutoJavaString execName_cstr(env, execName);
305   CHECK_EXCEPTION;
306   AutoJavaString coreName_cstr(env, coreName);
307   CHECK_EXCEPTION;
308 
309   verifyBitness(env, execName_cstr);
310   CHECK_EXCEPTION;
311 
312   if ( (ph = Pgrab_core(execName_cstr, coreName_cstr)) == NULL) {
313     THROW_NEW_DEBUGGER_EXCEPTION(&quot;Can&#39;t attach to the core file&quot;);
314   }
315   env-&gt;SetLongField(this_obj, p_ps_prochandle_ID, (jlong)(intptr_t)ph);
316   fillThreadsAndLoadObjects(env, this_obj, ph);
317 }
318 
319 /*
320  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
321  * Method:    detach0
322  * Signature: ()V
323  */
324 extern &quot;C&quot;
325 JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_detach0
326   (JNIEnv *env, jobject this_obj) {
327   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
328   if (ph != NULL) {
329      Prelease(ph);
330   }
331   if (saaltroot != NULL) {
332     free(saaltroot);
333     saaltroot = NULL;
334   }
335 }
336 
337 /*
338  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
339  * Method:    lookupByName0
340  * Signature: (Ljava/lang/String;Ljava/lang/String;)J
341  */
342 extern &quot;C&quot;
343 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_lookupByName0
344   (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {
345   jlong addr;
346   jboolean isCopy;
347   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
348   AutoJavaString objectName_cstr(env, objectName);
349   CHECK_EXCEPTION_(0);
350   AutoJavaString symbolName_cstr(env, symbolName);
351   CHECK_EXCEPTION_(0);
352 
353   addr = (jlong) lookup_symbol(ph, objectName_cstr, symbolName_cstr);
354   return addr;
355 }
356 
357 /*
358  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
359  * Method:    lookupByAddress0
360  * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
361  */
362 extern &quot;C&quot;
363 JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_lookupByAddress0
364   (JNIEnv *env, jobject this_obj, jlong addr) {
365   uintptr_t offset;
366   jobject obj;
367   jstring str;
368   const char* sym = NULL;
369 
370   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
371   sym = symbol_for_pc(ph, (uintptr_t) addr, &amp;offset);
372   if (sym == NULL) return 0;
373   str = env-&gt;NewStringUTF(sym);
374   CHECK_EXCEPTION_(NULL);
375   obj = env-&gt;CallObjectMethod(this_obj, createClosestSymbol_ID, str, (jlong)offset);
376   CHECK_EXCEPTION_(NULL);
377   return obj;
378 }
379 
380 /*
381  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
382  * Method:    readBytesFromProcess0
383  * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
384  */
385 extern &quot;C&quot;
386 JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_readBytesFromProcess0
387   (JNIEnv *env, jobject this_obj, jlong addr, jlong numBytes) {
388 
389   jboolean isCopy;
390   jbyteArray array;
391   jbyte *bufPtr;
392   ps_err_e err;
393 
394   array = env-&gt;NewByteArray(numBytes);
395   CHECK_EXCEPTION_(0);
396   bufPtr = env-&gt;GetByteArrayElements(array, &amp;isCopy);
397   CHECK_EXCEPTION_(0);
398 
399   err = ps_pdread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
400   env-&gt;ReleaseByteArrayElements(array, bufPtr, 0);
401   return (err == PS_OK)? array : 0;
402 }
403 
<a name="2" id="anc2"></a><span class="line-modified">404 #if defined(i586) || defined(amd64) || defined(ppc64) || defined(ppc64le) || defined(aarch64)</span>
405 extern &quot;C&quot;
406 JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_getThreadIntegerRegisterSet0
407   (JNIEnv *env, jobject this_obj, jint lwp_id) {
408 
409   struct user_regs_struct gregs;
410   jboolean isCopy;
411   jlongArray array;
412   jlong *regs;
413   int i;
414 
415   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
416   if (get_lwp_regs(ph, lwp_id, &amp;gregs) != true) {
417      THROW_NEW_DEBUGGER_EXCEPTION_(&quot;get_thread_regs failed for a lwp&quot;, 0);
418   }
419 
420 #undef NPRGREG
421 #ifdef i586
422 #define NPRGREG sun_jvm_hotspot_debugger_x86_X86ThreadContext_NPRGREG
423 #endif
424 #ifdef amd64
425 #define NPRGREG sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_NPRGREG
426 #endif
427 #ifdef aarch64
428 #define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG
429 #endif
<a name="3" id="anc3"></a>


430 #if defined(ppc64) || defined(ppc64le)
431 #define NPRGREG sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_NPRGREG
432 #endif
433 
434 
435   array = env-&gt;NewLongArray(NPRGREG);
436   CHECK_EXCEPTION_(0);
437   regs = env-&gt;GetLongArrayElements(array, &amp;isCopy);
438 
439 #undef REG_INDEX
440 
441 #ifdef i586
442 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##reg
443 
444   regs[REG_INDEX(GS)]  = (uintptr_t) gregs.xgs;
445   regs[REG_INDEX(FS)]  = (uintptr_t) gregs.xfs;
446   regs[REG_INDEX(ES)]  = (uintptr_t) gregs.xes;
447   regs[REG_INDEX(DS)]  = (uintptr_t) gregs.xds;
448   regs[REG_INDEX(EDI)] = (uintptr_t) gregs.edi;
449   regs[REG_INDEX(ESI)] = (uintptr_t) gregs.esi;
450   regs[REG_INDEX(FP)] = (uintptr_t) gregs.ebp;
451   regs[REG_INDEX(SP)] = (uintptr_t) gregs.esp;
452   regs[REG_INDEX(EBX)] = (uintptr_t) gregs.ebx;
453   regs[REG_INDEX(EDX)] = (uintptr_t) gregs.edx;
454   regs[REG_INDEX(ECX)] = (uintptr_t) gregs.ecx;
455   regs[REG_INDEX(EAX)] = (uintptr_t) gregs.eax;
456   regs[REG_INDEX(PC)] = (uintptr_t) gregs.eip;
457   regs[REG_INDEX(CS)]  = (uintptr_t) gregs.xcs;
458   regs[REG_INDEX(SS)]  = (uintptr_t) gregs.xss;
459 
460 #endif /* i586 */
461 
462 #ifdef amd64
463 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
464 
465   regs[REG_INDEX(R15)] = gregs.r15;
466   regs[REG_INDEX(R14)] = gregs.r14;
467   regs[REG_INDEX(R13)] = gregs.r13;
468   regs[REG_INDEX(R12)] = gregs.r12;
469   regs[REG_INDEX(RBP)] = gregs.rbp;
470   regs[REG_INDEX(RBX)] = gregs.rbx;
471   regs[REG_INDEX(R11)] = gregs.r11;
472   regs[REG_INDEX(R10)] = gregs.r10;
473   regs[REG_INDEX(R9)] = gregs.r9;
474   regs[REG_INDEX(R8)] = gregs.r8;
475   regs[REG_INDEX(RAX)] = gregs.rax;
476   regs[REG_INDEX(RCX)] = gregs.rcx;
477   regs[REG_INDEX(RDX)] = gregs.rdx;
478   regs[REG_INDEX(RSI)] = gregs.rsi;
479   regs[REG_INDEX(RDI)] = gregs.rdi;
480   regs[REG_INDEX(RIP)] = gregs.rip;
481   regs[REG_INDEX(CS)] = gregs.cs;
482   regs[REG_INDEX(RSP)] = gregs.rsp;
483   regs[REG_INDEX(SS)] = gregs.ss;
484   regs[REG_INDEX(FSBASE)] = gregs.fs_base;
485   regs[REG_INDEX(GSBASE)] = gregs.gs_base;
486   regs[REG_INDEX(DS)] = gregs.ds;
487   regs[REG_INDEX(ES)] = gregs.es;
488   regs[REG_INDEX(FS)] = gregs.fs;
489   regs[REG_INDEX(GS)] = gregs.gs;
490 
491 #endif /* amd64 */
492 
<a name="4" id="anc4"></a>
































493 #if defined(aarch64)
494 
495 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg
496 
497   {
498     int i;
499     for (i = 0; i &lt; 31; i++)
500       regs[i] = gregs.regs[i];
501     regs[REG_INDEX(SP)] = gregs.sp;
502     regs[REG_INDEX(PC)] = gregs.pc;
503   }
504 #endif /* aarch64 */
505 
506 #if defined(ppc64) || defined(ppc64le)
507 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_ppc64_PPC64ThreadContext_##reg
508 
509   regs[REG_INDEX(LR)] = gregs.link;
510   regs[REG_INDEX(NIP)] = gregs.nip;
511   regs[REG_INDEX(R0)]  = gregs.gpr[0];
512   regs[REG_INDEX(R1)]  = gregs.gpr[1];
513   regs[REG_INDEX(R2)]  = gregs.gpr[2];
514   regs[REG_INDEX(R3)]  = gregs.gpr[3];
515   regs[REG_INDEX(R4)]  = gregs.gpr[4];
516   regs[REG_INDEX(R5)]  = gregs.gpr[5];
517   regs[REG_INDEX(R6)]  = gregs.gpr[6];
518   regs[REG_INDEX(R7)]  = gregs.gpr[7];
519   regs[REG_INDEX(R8)]  = gregs.gpr[8];
520   regs[REG_INDEX(R9)]  = gregs.gpr[9];
521   regs[REG_INDEX(R10)] = gregs.gpr[10];
522   regs[REG_INDEX(R11)] = gregs.gpr[11];
523   regs[REG_INDEX(R12)] = gregs.gpr[12];
524   regs[REG_INDEX(R13)] = gregs.gpr[13];
525   regs[REG_INDEX(R14)] = gregs.gpr[14];
526   regs[REG_INDEX(R15)] = gregs.gpr[15];
527   regs[REG_INDEX(R16)] = gregs.gpr[16];
528   regs[REG_INDEX(R17)] = gregs.gpr[17];
529   regs[REG_INDEX(R18)] = gregs.gpr[18];
530   regs[REG_INDEX(R19)] = gregs.gpr[19];
531   regs[REG_INDEX(R20)] = gregs.gpr[20];
532   regs[REG_INDEX(R21)] = gregs.gpr[21];
533   regs[REG_INDEX(R22)] = gregs.gpr[22];
534   regs[REG_INDEX(R23)] = gregs.gpr[23];
535   regs[REG_INDEX(R24)] = gregs.gpr[24];
536   regs[REG_INDEX(R25)] = gregs.gpr[25];
537   regs[REG_INDEX(R26)] = gregs.gpr[26];
538   regs[REG_INDEX(R27)] = gregs.gpr[27];
539   regs[REG_INDEX(R28)] = gregs.gpr[28];
540   regs[REG_INDEX(R29)] = gregs.gpr[29];
541   regs[REG_INDEX(R30)] = gregs.gpr[30];
542   regs[REG_INDEX(R31)] = gregs.gpr[31];
543 
544 #endif
545 
546   env-&gt;ReleaseLongArrayElements(array, regs, JNI_COMMIT);
547   return array;
548 }
549 #endif
550 
551 /*
552  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
553  * Method:    demangle
554  * Signature: (Ljava/lang/String;)Ljava/lang/String;
555  */
556 extern &quot;C&quot;
557 JNIEXPORT jstring JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_demangle
558   (JNIEnv *env, jobject this_obj, jstring jsym) {
559   int status;
560   jstring result = NULL;
561 
562   const char *sym = env-&gt;GetStringUTFChars(jsym, NULL);
563   if (sym == NULL) {
564     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Error getting symbol string&quot;, NULL);
565   }
566   char *demangled = abi::__cxa_demangle(sym, NULL, 0, &amp;status);
567   env-&gt;ReleaseStringUTFChars(jsym, sym);
568   if ((demangled != NULL) &amp;&amp; (status == 0)) {
569     result = env-&gt;NewStringUTF(demangled);
570     free(demangled);
571   } else if (status == -2) { // not C++ ABI mangling rules - maybe C style
572     result = jsym;
573   } else {
574     THROW_NEW_DEBUGGER_EXCEPTION_(&quot;Could not demangle&quot;, NULL);
575   }
576 
577   return result;
578 }
579 
580 /*
581  * Class:     sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal
582  * Method:    findLibPtrByAddress0
583  * Signature: (J)J
584  */
585 extern &quot;C&quot;
586 JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_findLibPtrByAddress0
587   (JNIEnv *env, jobject this_obj, jlong pc) {
588   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
589   return reinterpret_cast&lt;jlong&gt;(find_lib_by_address(ph, pc));
590 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
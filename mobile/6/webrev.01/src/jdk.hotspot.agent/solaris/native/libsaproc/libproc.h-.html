<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.hotspot.agent/solaris/native/libsaproc/libproc.h</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 /*
 26  * Interfaces available from the process control library, libproc.
 27  *
 28  * libproc provides process control functions for the /proc tools
 29  * (commands in /usr/proc/bin), /usr/bin/truss, and /usr/bin/gcore.
 30  * libproc is a private support library for these commands only.
 31  * It is _not_ a public interface, although it might become one
 32  * in the fullness of time, when the interfaces settle down.
 33  *
 34  * In the meantime, be aware that any program linked with libproc in this
 35  * release of Solaris is almost guaranteed to break in the next release.
 36  *
 37  * In short, do not use this header file or libproc for any purpose.
 38  */
 39 
 40 #ifndef _LIBPROC_H
 41 #define _LIBPROC_H
 42 
 43 #include &lt;stdlib.h&gt;
 44 #include &lt;unistd.h&gt;
 45 #include &lt;fcntl.h&gt;
 46 #include &lt;nlist.h&gt;
 47 #include &lt;door.h&gt;
 48 #include &lt;gelf.h&gt;
 49 #include &lt;proc_service.h&gt;
 50 #include &lt;rtld_db.h&gt;
 51 #include &lt;procfs.h&gt;
 52 #include &lt;sys/stat.h&gt;
 53 #include &lt;sys/statvfs.h&gt;
 54 #include &lt;sys/auxv.h&gt;
 55 #include &lt;sys/resource.h&gt;
 56 #include &lt;sys/socket.h&gt;
 57 #include &lt;sys/utsname.h&gt;
 58 
 59 #ifdef  __cplusplus
 60 extern &quot;C&quot; {
 61 #endif
 62 
 63 /*
 64  * Opaque structure tag reference to a process control structure.
 65  * Clients of libproc cannot look inside the process control structure.
 66  * The implementation of struct ps_prochandle can change w/o affecting clients.
 67  */
 68 struct ps_prochandle;
 69 
 70 extern  int     _libproc_debug; /* set non-zero to enable debugging fprintfs */
 71 
 72 #if defined(sparc) || defined(__sparc)
 73 #define R_RVAL1 R_O0            /* register holding a function return value */
 74 #define R_RVAL2 R_O1            /* 32 more bits for a 64-bit return value */
 75 #define SYSCALL32 0x91d02008    /* 32-bit syscall (ta 8) instruction */
 76 #define SYSCALL64 0x91d02040    /* 64-bit syscall (ta 64) instruction */
 77 typedef uint32_t syscall_t;     /* holds a syscall instruction */
 78 #endif  /* sparc */
 79 
 80 #if defined(__i386)
 81 #define R_PC    EIP
 82 #define R_SP    UESP
 83 #define R_RVAL1 EAX             /* register holding a function return value */
 84 #define R_RVAL2 EDX             /* 32 more bits for a 64-bit return value */
 85 #define SYSCALL 0x9a            /* syscall (lcall) instruction opcode */
 86 typedef uchar_t syscall_t[7];   /* holds a syscall instruction */
 87 #endif  /* __i386 */
 88 
 89 #define R_RVAL  R_RVAL1         /* simple function return value register */
 90 
 91 /* maximum sizes of things */
 92 #define PRMAXSIG        (32 * sizeof (sigset_t) / sizeof (uint32_t))
 93 #define PRMAXFAULT      (32 * sizeof (fltset_t) / sizeof (uint32_t))
 94 #define PRMAXSYS        (32 * sizeof (sysset_t) / sizeof (uint32_t))
 95 
 96 /* State values returned by Pstate() */
 97 #define PS_RUN          1       /* process is running */
 98 #define PS_STOP         2       /* process is stopped */
 99 #define PS_LOST         3       /* process is lost to control (EAGAIN) */
100 #define PS_UNDEAD       4       /* process is terminated (zombie) */
101 #define PS_DEAD         5       /* process is terminated (core file) */
102 
103 /* Flags accepted by Pgrab() */
104 #define PGRAB_RETAIN    0x01    /* Retain tracing flags, else clear flags */
105 #define PGRAB_FORCE     0x02    /* Open the process w/o O_EXCL */
106 #define PGRAB_RDONLY    0x04    /* Open the process or core w/ O_RDONLY */
107 #define PGRAB_NOSTOP    0x08    /* Open the process but do not stop it */
108 
109 /* Error codes from Pcreate() */
110 #define C_STRANGE       -1      /* Unanticipated error, errno is meaningful */
111 #define C_FORK          1       /* Unable to fork */
112 #define C_PERM          2       /* No permission (file set-id or unreadable) */
113 #define C_NOEXEC        3       /* Cannot find executable file */
114 #define C_INTR          4       /* Interrupt received while creating */
115 #define C_LP64          5       /* Program is _LP64, self is _ILP32 */
116 
117 /* Error codes from Pgrab(), Pfgrab_core(), and Pgrab_core() */
118 #define G_STRANGE       -1      /* Unanticipated error, errno is meaningful */
119 #define G_NOPROC        1       /* No such process */
120 #define G_NOCORE        2       /* No such core file */
121 #define G_NOPROCORCORE  3       /* No such proc or core (for proc_arg_grab) */
122 #define G_NOEXEC        4       /* Cannot locate executable file */
123 #define G_ZOMB          5       /* Zombie process */
124 #define G_PERM          6       /* No permission */
125 #define G_BUSY          7       /* Another process has control */
126 #define G_SYS           8       /* System process */
127 #define G_SELF          9       /* Process is self */
128 #define G_INTR          10      /* Interrupt received while grabbing */
129 #define G_LP64          11      /* Process is _LP64, self is ILP32 */
130 #define G_FORMAT        12      /* File is not an ELF format core file */
131 #define G_ELF           13      /* Libelf error, elf_errno() is meaningful */
132 #define G_NOTE          14      /* Required PT_NOTE Phdr not present in core */
133 
134 /* Flags accepted by Prelease */
135 #define PRELEASE_CLEAR  0x10    /* Clear all tracing flags */
136 #define PRELEASE_RETAIN 0x20    /* Retain final tracing flags */
137 #define PRELEASE_HANG   0x40    /* Leave the process stopped */
138 #define PRELEASE_KILL   0x80    /* Terminate the process */
139 
140 typedef struct {        /* argument descriptor for system call (Psyscall) */
141         long    arg_value;      /* value of argument given to system call */
142         void    *arg_object;    /* pointer to object in controlling process */
143         char    arg_type;       /* AT_BYVAL, AT_BYREF */
144         char    arg_inout;      /* AI_INPUT, AI_OUTPUT, AI_INOUT */
145         ushort_t arg_size;      /* if AT_BYREF, size of object in bytes */
146 } argdes_t;
147 
148 typedef struct {        /* return values from system call (Psyscall) */
149         int     sys_errno;      /* syscall error number */
150         long    sys_rval1;      /* primary return value from system call */
151         long    sys_rval2;      /* second return value from system call */
152 } sysret_t;
153 
154 /* values for type */
155 #define AT_BYVAL        1
156 #define AT_BYREF        2
157 
158 /* values for inout */
159 #define AI_INPUT        1
160 #define AI_OUTPUT       2
161 #define AI_INOUT        3
162 
163 /* maximum number of syscall arguments */
164 #define MAXARGS         8
165 
166 /* maximum size in bytes of a BYREF argument */
167 #define MAXARGL         (4*1024)
168 
169 /* Kludges to make things work on Solaris 2.6 */
170 #if !defined(_LP64) &amp;&amp; !defined(PR_MODEL_UNKNOWN)
171 #define PR_MODEL_UNKNOWN 0
172 #define PR_MODEL_ILP32  0       /* process data model is ILP32 */
173 #define PR_MODEL_LP64   2       /* process data model is LP64 */
174 #define PR_MODEL_NATIVE PR_MODEL_ILP32
175 #define pr_dmodel       pr_filler[0]
176 #define STACK_BIAS      0
177 #endif
178 
179 /*
180  * Function prototypes for routines in the process control package.
181  */
182 extern struct ps_prochandle *Pcreate(const char *, char *const *,
183     int *, char *, size_t);
184 
185 extern const char *Pcreate_error(int);
186 
187 extern struct ps_prochandle *Pgrab(pid_t, int, int *);
188 extern struct ps_prochandle *Pgrab_core(const char *, const char *, int, int *);
189 extern struct ps_prochandle *Pfgrab_core(int, const char *, int *);
190 
191 extern const char *Pgrab_error(int);
192 
193 extern  int     Preopen(struct ps_prochandle *);
194 extern  void    Prelease(struct ps_prochandle *, int);
195 extern  void    Pfree(struct ps_prochandle *);
196 
197 extern  int     Pasfd(struct ps_prochandle *);
198 extern  int     Pctlfd(struct ps_prochandle *);
199 extern  int     Pcreate_agent(struct ps_prochandle *);
200 extern  void    Pdestroy_agent(struct ps_prochandle *);
201 extern  int     Pwait(struct ps_prochandle *, uint_t);
202 extern  int     Pstop(struct ps_prochandle *, uint_t);
203 extern  int     Pstate(struct ps_prochandle *);
204 extern  const psinfo_t *Ppsinfo(struct ps_prochandle *);
205 extern  const pstatus_t *Pstatus(struct ps_prochandle *);
206 extern  int     Pcred(struct ps_prochandle *, prcred_t *, int);
207 extern  int     Pgetareg(struct ps_prochandle *, int, prgreg_t *);
208 extern  int     Pputareg(struct ps_prochandle *, int, prgreg_t);
209 extern  int     Psetrun(struct ps_prochandle *, int, int);
210 extern  ssize_t Pread(struct ps_prochandle *, void *, size_t, uintptr_t);
211 extern  ssize_t Pread_string(struct ps_prochandle *, char *, size_t, uintptr_t);
212 extern  ssize_t Pwrite(struct ps_prochandle *, const void *, size_t, uintptr_t);
213 extern  int     Pclearsig(struct ps_prochandle *);
214 extern  int     Pclearfault(struct ps_prochandle *);
215 extern  int     Psetbkpt(struct ps_prochandle *, uintptr_t, ulong_t *);
216 extern  int     Pdelbkpt(struct ps_prochandle *, uintptr_t, ulong_t);
217 extern  int     Pxecbkpt(struct ps_prochandle *, ulong_t);
218 extern  int     Psetflags(struct ps_prochandle *, long);
219 extern  int     Punsetflags(struct ps_prochandle *, long);
220 extern  int     Psignal(struct ps_prochandle *, int, int);
221 extern  int     Pfault(struct ps_prochandle *, int, int);
222 extern  int     Psysentry(struct ps_prochandle *, int, int);
223 extern  int     Psysexit(struct ps_prochandle *, int, int);
224 extern  void    Psetsignal(struct ps_prochandle *, const sigset_t *);
225 extern  void    Psetfault(struct ps_prochandle *, const fltset_t *);
226 extern  void    Psetsysentry(struct ps_prochandle *, const sysset_t *);
227 extern  void    Psetsysexit(struct ps_prochandle *, const sysset_t *);
228 extern  void    Psync(struct ps_prochandle *);
229 extern  sysret_t Psyscall(struct ps_prochandle *, int, uint_t, argdes_t *);
230 extern  int     Pisprocdir(struct ps_prochandle *, const char *);
231 
232 /*
233  * Function prototypes for system calls forced on the victim process.
234  */
235 extern  int     pr_open(struct ps_prochandle *, const char *, int, mode_t);
236 extern  int     pr_creat(struct ps_prochandle *, const char *, mode_t);
237 extern  int     pr_close(struct ps_prochandle *, int);
238 extern  int     pr_door_info(struct ps_prochandle *, int, struct door_info *);
239 extern  void    *pr_mmap(struct ps_prochandle *,
240                         void *, size_t, int, int, int, off_t);
241 extern  void    *pr_zmap(struct ps_prochandle *,
242                         void *, size_t, int, int);
243 extern  int     pr_munmap(struct ps_prochandle *, void *, size_t);
244 extern  int     pr_memcntl(struct ps_prochandle *,
245                         caddr_t, size_t, int, caddr_t, int, int);
246 extern  int     pr_sigaction(struct ps_prochandle *,
247                         int, const struct sigaction *, struct sigaction *);
248 extern  int     pr_getitimer(struct ps_prochandle *,
249                         int, struct itimerval *);
250 extern  int     pr_setitimer(struct ps_prochandle *,
251                         int, const struct itimerval *, struct itimerval *);
252 extern  int     pr_ioctl(struct ps_prochandle *, int, int, void *, size_t);
253 extern  int     pr_fcntl(struct ps_prochandle *, int, int, void *);
254 extern  int     pr_stat(struct ps_prochandle *, const char *, struct stat *);
255 extern  int     pr_lstat(struct ps_prochandle *, const char *, struct stat *);
256 extern  int     pr_fstat(struct ps_prochandle *, int, struct stat *);
257 extern  int     pr_statvfs(struct ps_prochandle *, const char *, statvfs_t *);
258 extern  int     pr_fstatvfs(struct ps_prochandle *, int, statvfs_t *);
259 extern  int     pr_getrlimit(struct ps_prochandle *,
260                         int, struct rlimit *);
261 extern  int     pr_setrlimit(struct ps_prochandle *,
262                         int, const struct rlimit *);
263 #if defined(_LARGEFILE64_SOURCE)
264 extern  int     pr_getrlimit64(struct ps_prochandle *,
265                         int, struct rlimit64 *);
266 extern  int     pr_setrlimit64(struct ps_prochandle *,
267                         int, const struct rlimit64 *);
268 #endif  /* _LARGEFILE64_SOURCE */
269 extern  int     pr_lwp_exit(struct ps_prochandle *);
270 extern  int     pr_exit(struct ps_prochandle *, int);
271 extern  int     pr_waitid(struct ps_prochandle *,
272                         idtype_t, id_t, siginfo_t *, int);
273 extern  off_t   pr_lseek(struct ps_prochandle *, int, off_t, int);
274 extern  offset_t pr_llseek(struct ps_prochandle *, int, offset_t, int);
275 extern  int     pr_rename(struct ps_prochandle *, const char *, const char *);
276 extern  int     pr_link(struct ps_prochandle *, const char *, const char *);
277 extern  int     pr_unlink(struct ps_prochandle *, const char *);
278 extern  int     pr_getpeername(struct ps_prochandle *,
279                         int, struct sockaddr *, socklen_t *);
280 extern  int     pr_getsockname(struct ps_prochandle *,
281                         int, struct sockaddr *, socklen_t *);
282 
283 /*
284  * Function prototypes for accessing per-LWP register information.
285  */
286 extern int Plwp_getregs(struct ps_prochandle *, lwpid_t, prgregset_t);
287 extern int Plwp_setregs(struct ps_prochandle *, lwpid_t, const prgregset_t);
288 
289 extern int Plwp_getfpregs(struct ps_prochandle *, lwpid_t, prfpregset_t *);
290 extern int Plwp_setfpregs(struct ps_prochandle *, lwpid_t,
291     const prfpregset_t *);
292 
293 #if defined(sparc) || defined(__sparc)
294 
295 extern int Plwp_getxregs(struct ps_prochandle *, lwpid_t, prxregset_t *);
296 extern int Plwp_setxregs(struct ps_prochandle *, lwpid_t, const prxregset_t *);
297 
298 #if defined(__sparcv9)
299 extern int Plwp_getasrs(struct ps_prochandle *, lwpid_t, asrset_t);
300 extern int Plwp_setasrs(struct ps_prochandle *, lwpid_t, const asrset_t);
301 #endif  /* __sparcv9 */
302 
303 #endif  /* __sparc */
304 
305 extern int Plwp_getpsinfo(struct ps_prochandle *, lwpid_t, lwpsinfo_t *);
306 
307 /*
308  * LWP iteration interface.
309  */
310 typedef int proc_lwp_f(void *, const lwpstatus_t *);
311 extern int Plwp_iter(struct ps_prochandle *, proc_lwp_f *, void *);
312 
313 /*
314  * Symbol table interfaces.
315  */
316 
317 /*
318  * Pseudo-names passed to Plookup_by_name() for well-known load objects.
319  * NOTE: It is required that PR_OBJ_EXEC and PR_OBJ_LDSO exactly match
320  * the definitions of PS_OBJ_EXEC and PS_OBJ_LDSO from &lt;proc_service.h&gt;.
321  */
322 #define PR_OBJ_EXEC     ((const char *)0)       /* search the executable file */
323 #define PR_OBJ_LDSO     ((const char *)1)       /* search ld.so.1 */
324 #define PR_OBJ_EVERY    ((const char *)-1)      /* search every load object */
325 
326 /*
327  * &#39;object_name&#39; is the name of a load object obtained from an
328  * iteration over the process&#39;s address space mappings (Pmapping_iter),
329  * or an iteration over the process&#39;s mapped objects (Pobject_iter),
330  * or else it is one of the special PR_OBJ_* values above.
331  */
332 extern int Plookup_by_name(struct ps_prochandle *,
333     const char *, const char *, GElf_Sym *);
334 
335 extern int Plookup_by_addr(struct ps_prochandle *,
336     uintptr_t, char *, size_t, GElf_Sym *);
337 
338 typedef int proc_map_f(void *, const prmap_t *, const char *);
339 
340 extern int Pmapping_iter(struct ps_prochandle *, proc_map_f *, void *);
341 extern int Pobject_iter(struct ps_prochandle *, proc_map_f *, void *);
342 
343 extern const prmap_t *Paddr_to_map(struct ps_prochandle *, uintptr_t);
344 extern const prmap_t *Paddr_to_text_map(struct ps_prochandle *, uintptr_t);
345 extern const prmap_t *Pname_to_map(struct ps_prochandle *, const char *);
346 
347 extern char *Pplatform(struct ps_prochandle *, char *, size_t);
348 extern int Puname(struct ps_prochandle *, struct utsname *);
349 
350 extern char *Pexecname(struct ps_prochandle *, char *, size_t);
351 extern char *Pobjname(struct ps_prochandle *, uintptr_t, char *, size_t);
352 
353 extern char *Pgetenv(struct ps_prochandle *, const char *, char *, size_t);
354 extern long Pgetauxval(struct ps_prochandle *, int);
355 
356 /*
357  * Symbol table iteration interface.
358  */
359 typedef int proc_sym_f(void *, const GElf_Sym *, const char *);
360 
361 extern int Psymbol_iter(struct ps_prochandle *,
362     const char *, int, int, proc_sym_f *, void *);
363 
364 /*
365  * &#39;which&#39; selects which symbol table and can be one of the following.
366  */
367 #define PR_SYMTAB       1
368 #define PR_DYNSYM       2
369 /*
370  * &#39;type&#39; selects the symbols of interest by binding and type.  It is a bit-
371  * mask of one or more of the following flags, whose order MUST match the
372  * order of STB and STT constants in &lt;sys/elf.h&gt;.
373  */
374 #define BIND_LOCAL      0x0001
375 #define BIND_GLOBAL     0x0002
376 #define BIND_WEAK       0x0004
377 #define BIND_ANY (BIND_LOCAL|BIND_GLOBAL|BIND_WEAK)
378 #define TYPE_NOTYPE     0x0100
379 #define TYPE_OBJECT     0x0200
380 #define TYPE_FUNC       0x0400
381 #define TYPE_SECTION    0x0800
382 #define TYPE_FILE       0x1000
383 #define TYPE_ANY (TYPE_NOTYPE|TYPE_OBJECT|TYPE_FUNC|TYPE_SECTION|TYPE_FILE)
384 
385 /*
386  * This returns the rtld_db agent handle for the process.
387  * The handle will become invalid at the next successful exec() and
388  * must not be used beyond that point (see Preset_maps(), below).
389  */
390 extern rd_agent_t *Prd_agent(struct ps_prochandle *);
391 
392 /*
393  * This should be called when an RD_DLACTIVITY event with the
394  * RD_CONSISTENT state occurs via librtld_db&#39;s event mechanism.
395  * This makes libproc&#39;s address space mappings and symbol tables current.
396  */
397 extern void Pupdate_maps(struct ps_prochandle *);
398 
399 /*
400  * This must be called after the victim process performs a successful
401  * exec() if any of the symbol table interface functions have been called
402  * prior to that point.  This is essential because an exec() invalidates
403  * all previous symbol table and address space mapping information.
404  * It is always safe to call, but if it is called other than after an
405  * exec() by the victim process it just causes unnecessary overhead.
406  *
407  * The rtld_db agent handle obtained from a previous call to Prd_agent() is
408  * made invalid by Preset_maps() and Prd_agent() must be called again to get
409  * the new handle.
410  */
411 extern void Preset_maps(struct ps_prochandle *);
412 
413 /*
414  * Given an address, Ppltdest() determines if this is part of a PLT, and if
415  * so returns the target address of this PLT entry and a flag indicating
416  * whether or not this PLT entry has been bound by the run-time linker.
417  */
418 extern uintptr_t Ppltdest(struct ps_prochandle *, uintptr_t, int *);
419 
420 /*
421  * Stack frame iteration interface.
422  */
423 typedef int proc_stack_f(
424     void *,             /* the cookie given to Pstack_iter() */
425     const prgregset_t,  /* the frame&#39;s registers */
426     uint_t,             /* argc for the frame&#39;s function */
427     const long *,       /* argv for the frame&#39;s function */
428     int,                /* bitwise flags describing the frame (see below) */
429     int);               /* a signal number */
430 
431 #define PR_SIGNAL_FRAME    1    /* called by a signal handler */
432 #define PR_FOUND_SIGNAL    2    /* we found the corresponding signal number */
433 
434 extern int Pstack_iter(struct ps_prochandle *,
435     const prgregset_t, proc_stack_f *, void *);
436 
437 /*
438  * Compute the full pathname of a named directory without using chdir().
439  * This is useful for dealing with /proc/&lt;pid&gt;/cwd.
440  */
441 extern char *proc_dirname(const char *, char *, size_t);
442 
443 /*
444  * Remove unprintable characters from psinfo.pr_psargs and replace with
445  * whitespace characters so it is safe for printing.
446  */
447 extern void proc_unctrl_psinfo(psinfo_t *);
448 
449 /*
450  * Utility functions for processing arguments which should be /proc files,
451  * pids, and/or core files.  The returned error code can be passed to
452  * Pgrab_error() in order to convert it to an error string.
453  */
454 #define PR_ARG_PIDS     0x1     /* Allow pid and /proc file arguments */
455 #define PR_ARG_CORES    0x2     /* Allow core file arguments */
456 
457 #define PR_ARG_ANY      (PR_ARG_PIDS | PR_ARG_CORES)
458 
459 extern struct ps_prochandle *proc_arg_grab(const char *, int, int, int *);
460 extern pid_t proc_arg_psinfo(const char *, int, psinfo_t *, int *);
461 
462 /*
463  * Utility functions for obtaining information via /proc without actually
464  * performing a Pcreate() or Pgrab():
465  */
466 extern int proc_get_auxv(pid_t, auxv_t *, int);
467 extern int proc_get_cred(pid_t, prcred_t *, int);
468 extern int proc_get_psinfo(pid_t, psinfo_t *);
469 extern int proc_get_status(pid_t, pstatus_t *);
470 
471 /*
472  * Utility functions for debugging tools to convert numeric fault,
473  * signal, and system call numbers to symbolic names:
474  */
475 extern char *proc_fltname(int, char *, size_t);
476 extern char *proc_signame(int, char *, size_t);
477 extern char *proc_sysname(int, char *, size_t);
478 
479 #ifdef  __cplusplus
480 }
481 #endif
482 
483 #endif  /* _LIBPROC_H */
    </pre>
  </body>
</html>
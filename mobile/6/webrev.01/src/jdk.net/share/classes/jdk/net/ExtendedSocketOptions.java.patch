diff a/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java b/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
--- a/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
+++ b/src/jdk.net/share/classes/jdk/net/ExtendedSocketOptions.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -163,29 +163,62 @@
      * @since 11
      */
     public static final SocketOption<Integer> TCP_KEEPCOUNT
             = new ExtSocketOption<Integer>("TCP_KEEPCOUNT", Integer.class);
 
+    /**
+     * Identifies the receive queue that the last incoming packet for the socket
+     * was received on.
+     *
+     * <p> The value of this socket option is a positive {@code Integer} that
+     * identifies a receive queue that the application can use to split the
+     * incoming flows among threads based on the queue identifier. The value is
+     * {@code 0} when the socket is not bound, a packet has not been received,
+     * or more generally, when there is no receive queue to identify.
+     * The socket option is supported by both stream-oriented and datagram-oriented
+     * sockets.
+     *
+     * <p> The socket option is read-only and an attempt to set the socket option
+     * will throw {@code SocketException}.
+     *
+     * @apiNote
+     * Network devices may have multiple queues or channels to transmit and receive
+     * network packets. The {@code SO_INCOMING_NAPI_ID} socket option provides a hint
+     * to the application to indicate the receive queue on which an incoming socket
+     * connection or packets for that connection are directed to. An application may
+     * take advantage of this by handling all socket connections assigned to a
+     * specific queue on one thread.
+     *
+     * @since 15
+     */
+    public static final SocketOption<Integer> SO_INCOMING_NAPI_ID
+            = new ExtSocketOption<Integer>("SO_INCOMING_NAPI_ID", Integer.class);
+
     private static final PlatformSocketOptions platformSocketOptions =
             PlatformSocketOptions.get();
 
     private static final boolean flowSupported =
             platformSocketOptions.flowSupported();
     private static final boolean quickAckSupported =
             platformSocketOptions.quickAckSupported();
     private static final boolean keepAliveOptSupported =
             platformSocketOptions.keepAliveOptionsSupported();
+    private static final boolean incomingNapiIdOptSupported  =
+            platformSocketOptions.incomingNapiIdSupported();
     private static final Set<SocketOption<?>> extendedOptions = options();
 
     static Set<SocketOption<?>> options() {
         Set<SocketOption<?>> options = new HashSet<>();
         if (flowSupported) {
             options.add(SO_FLOW_SLA);
         }
         if (quickAckSupported) {
             options.add(TCP_QUICKACK);
         }
+        if (incomingNapiIdOptSupported) {
+            options.add(SO_INCOMING_NAPI_ID);
+        }
         if (keepAliveOptSupported) {
             options.addAll(Set.of(TCP_KEEPCOUNT, TCP_KEEPIDLE, TCP_KEEPINTERVAL));
         }
         return Collections.unmodifiableSet(options);
     }
@@ -219,10 +252,15 @@
                     setTcpkeepAliveProbes(fd, (Integer) value);
                 } else if (option == TCP_KEEPIDLE) {
                     setTcpKeepAliveTime(fd, (Integer) value);
                 } else if (option == TCP_KEEPINTERVAL) {
                     setTcpKeepAliveIntvl(fd, (Integer) value);
+                } else if (option == SO_INCOMING_NAPI_ID) {
+                    if (!incomingNapiIdOptSupported)
+                        throw new UnsupportedOperationException("Attempt to set unsupported option " + option);
+                    else
+                        throw new SocketException("Attempt to set read only option " + option);
                 } else {
                     throw new InternalError("Unexpected option " + option);
                 }
             }
 
@@ -250,10 +288,12 @@
                     return getTcpkeepAliveProbes(fd);
                 } else if (option == TCP_KEEPIDLE) {
                     return getTcpKeepAliveTime(fd);
                 } else if (option == TCP_KEEPINTERVAL) {
                     return getTcpKeepAliveIntvl(fd);
+                } else if (option == SO_INCOMING_NAPI_ID) {
+                    return getIncomingNapiId(fd);
                 } else {
                     throw new InternalError("Unexpected option " + option);
                 }
             }
         });
@@ -323,10 +363,14 @@
 
     private static int getTcpKeepAliveIntvl(FileDescriptor fd) throws SocketException {
         return platformSocketOptions.getTcpKeepAliveIntvl(fdAccess.get(fd));
     }
 
+    private static int getIncomingNapiId(FileDescriptor fd) throws SocketException {
+        return platformSocketOptions.getIncomingNapiId(fdAccess.get(fd));
+    }
+
     static class PlatformSocketOptions {
 
         protected PlatformSocketOptions() {}
 
         @SuppressWarnings("unchecked")
@@ -345,13 +389,11 @@
                     new PrivilegedAction<String>() {
                         public String run() {
                             return System.getProperty("os.name");
                         }
                     });
-            if ("SunOS".equals(osname)) {
-                return newInstance("jdk.net.SolarisSocketOptions");
-            } else if ("Linux".equals(osname)) {
+            if ("Linux".equals(osname)) {
                 return newInstance("jdk.net.LinuxSocketOptions");
             } else if (osname.startsWith("Mac")) {
                 return newInstance("jdk.net.MacOSXSocketOptions");
             } else {
                 return new PlatformSocketOptions();
@@ -416,7 +458,15 @@
         }
 
         int getTcpKeepAliveIntvl(int fd) throws SocketException {
             throw new UnsupportedOperationException("unsupported TCP_KEEPINTVL option");
         }
+
+        boolean incomingNapiIdSupported() {
+            return false;
+        }
+
+        int getIncomingNapiId(int fd) throws SocketException {
+            throw new UnsupportedOperationException("unsupported SO_INCOMING_NAPI_ID socket option");
+        }
     }
 }

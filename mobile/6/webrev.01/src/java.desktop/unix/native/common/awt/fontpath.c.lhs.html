<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/native/common/awt/fontpath.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #if defined(__linux__)
  27 #include &lt;string.h&gt;
  28 #endif /* __linux__ */
  29 #include &lt;stdio.h&gt;
  30 #include &lt;stdlib.h&gt;
  31 #include &lt;strings.h&gt;
  32 #include &lt;sys/types.h&gt;
  33 #include &lt;sys/stat.h&gt;
  34 #include &lt;sys/mman.h&gt;
  35 #include &lt;fcntl.h&gt;
  36 #include &lt;unistd.h&gt;
<a name="2" id="anc2"></a><span class="line-removed">  37 #ifdef __solaris__</span>
<span class="line-removed">  38 #include &lt;sys/systeminfo.h&gt;</span>
<span class="line-removed">  39 #endif</span>
  40 
  41 #include &lt;jni.h&gt;
  42 #include &lt;jni_util.h&gt;
  43 #include &lt;jvm_md.h&gt;
  44 #include &lt;sizecalc.h&gt;
  45 #ifndef HEADLESS
  46 #include &lt;X11/Xlib.h&gt;
  47 #include &lt;awt.h&gt;
  48 #else
  49 /* locks ought to be included from awt.h */
  50 #define AWT_LOCK()
  51 #define AWT_UNLOCK()
  52 #endif /* !HEADLESS */
  53 
  54 #if defined(__linux__) &amp;&amp; !defined(MAP_FAILED)
  55 #define MAP_FAILED ((caddr_t)-1)
  56 #endif
  57 
  58 #ifndef HEADLESS
  59 extern Display *awt_display;
  60 #endif /* !HEADLESS */
  61 
  62 #define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME(&quot;fontconfig&quot;, &quot;1&quot;)
  63 #define FONTCONFIG_DLL JNI_LIB_NAME(&quot;fontconfig&quot;)
  64 
  65 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
  66 
<a name="3" id="anc3"></a><span class="line-modified">  67 #if defined(__solaris__)</span>
<span class="line-removed">  68 /*</span>
<span class="line-removed">  69  * This can be set in the makefile to &quot;/usr/X11&quot; if so desired.</span>
<span class="line-removed">  70  */</span>
<span class="line-removed">  71 #ifndef OPENWINHOMELIB</span>
<span class="line-removed">  72 #define OPENWINHOMELIB &quot;/usr/openwin/lib/&quot;</span>
<span class="line-removed">  73 #endif</span>
<span class="line-removed">  74 </span>
<span class="line-removed">  75 /* This is all known Solaris X11 directories on Solaris 8, 9 and 10.</span>
<span class="line-removed">  76  * It is ordered to give precedence to TrueType directories.</span>
<span class="line-removed">  77  * It is needed if fontconfig is not installed or configured properly.</span>
<span class="line-removed">  78  */</span>
<span class="line-removed">  79 static char *fullSolarisFontPath[] = {</span>
<span class="line-removed">  80     OPENWINHOMELIB &quot;X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  81     OPENWINHOMELIB &quot;locale/euro_fonts/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  82     OPENWINHOMELIB &quot;locale/iso_8859_2/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  83     OPENWINHOMELIB &quot;locale/iso_8859_5/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  84     OPENWINHOMELIB &quot;locale/iso_8859_7/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  85     OPENWINHOMELIB &quot;locale/iso_8859_8/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  86     OPENWINHOMELIB &quot;locale/iso_8859_9/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  87     OPENWINHOMELIB &quot;locale/iso_8859_13/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  88     OPENWINHOMELIB &quot;locale/iso_8859_15/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  89     OPENWINHOMELIB &quot;locale/ar/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  90     OPENWINHOMELIB &quot;locale/hi_IN.UTF-8/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  91     OPENWINHOMELIB &quot;locale/ja/X11/fonts/TT&quot;,</span>
<span class="line-removed">  92     OPENWINHOMELIB &quot;locale/ko/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  93     OPENWINHOMELIB &quot;locale/ko.UTF-8/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  94     OPENWINHOMELIB &quot;locale/KOI8-R/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  95     OPENWINHOMELIB &quot;locale/ru.ansi-1251/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  96     OPENWINHOMELIB &quot;locale/th_TH/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  97     OPENWINHOMELIB &quot;locale/zh_TW/X11/fonts/TrueType&quot;,</span>
<span class="line-removed">  98     OPENWINHOMELIB &quot;locale/zh_TW.BIG5/X11/fonts/TT&quot;,</span>
<span class="line-removed">  99     OPENWINHOMELIB &quot;locale/zh_HK.BIG5HK/X11/fonts/TT&quot;,</span>
<span class="line-removed"> 100     OPENWINHOMELIB &quot;locale/zh_CN.GB18030/X11/fonts/TrueType&quot;,</span>
<span class="line-removed"> 101     OPENWINHOMELIB &quot;locale/zh/X11/fonts/TrueType&quot;,</span>
<span class="line-removed"> 102     OPENWINHOMELIB &quot;locale/zh.GBK/X11/fonts/TrueType&quot;,</span>
<span class="line-removed"> 103     OPENWINHOMELIB &quot;X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 104     OPENWINHOMELIB &quot;X11/fonts/Type1/sun&quot;,</span>
<span class="line-removed"> 105     OPENWINHOMELIB &quot;X11/fonts/Type1/sun/outline&quot;,</span>
<span class="line-removed"> 106     OPENWINHOMELIB &quot;locale/iso_8859_2/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 107     OPENWINHOMELIB &quot;locale/iso_8859_4/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 108     OPENWINHOMELIB &quot;locale/iso_8859_5/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 109     OPENWINHOMELIB &quot;locale/iso_8859_7/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 110     OPENWINHOMELIB &quot;locale/iso_8859_8/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 111     OPENWINHOMELIB &quot;locale/iso_8859_9/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 112     OPENWINHOMELIB &quot;locale/iso_8859_13/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 113     OPENWINHOMELIB &quot;locale/ar/X11/fonts/Type1&quot;,</span>
<span class="line-removed"> 114     NULL, /* terminates the list */</span>
<span class="line-removed"> 115 };</span>
<span class="line-removed"> 116 </span>
<span class="line-removed"> 117 #elif defined( __linux__)</span>
 118 /* All the known interesting locations we have discovered on
 119  * various flavors of Linux
 120  */
 121 static char *fullLinuxFontPath[] = {
 122     &quot;/usr/X11R6/lib/X11/fonts/TrueType&quot;,  /* RH 7.1+ */
 123     &quot;/usr/X11R6/lib/X11/fonts/truetype&quot;,  /* SuSE */
 124     &quot;/usr/X11R6/lib/X11/fonts/tt&quot;,
 125     &quot;/usr/X11R6/lib/X11/fonts/TTF&quot;,
 126     &quot;/usr/X11R6/lib/X11/fonts/OTF&quot;,       /* RH 9.0 (but empty!) */
 127     &quot;/usr/share/fonts/ja/TrueType&quot;,       /* RH 7.2+ */
 128     &quot;/usr/share/fonts/truetype&quot;,
 129     &quot;/usr/share/fonts/ko/TrueType&quot;,       /* RH 9.0 */
 130     &quot;/usr/share/fonts/zh_CN/TrueType&quot;,    /* RH 9.0 */
 131     &quot;/usr/share/fonts/zh_TW/TrueType&quot;,    /* RH 9.0 */
 132     &quot;/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType&quot;, /* Debian */
 133     &quot;/usr/X11R6/lib/X11/fonts/Type1&quot;,
 134     &quot;/usr/share/fonts/default/Type1&quot;,     /* RH 9.0 */
 135     NULL, /* terminates the list */
 136 };
 137 #elif defined(_AIX)
 138 static char *fullAixFontPath[] = {
 139     &quot;/usr/lpp/X11/lib/X11/fonts/Type1&quot;,    /* from X11.fnt.iso_T1  */
 140     &quot;/usr/lpp/X11/lib/X11/fonts/TrueType&quot;, /* from X11.fnt.ucs.ttf */
 141     NULL, /* terminates the list */
 142 };
 143 #endif
 144 
 145 static char **getFontConfigLocations();
 146 
 147 typedef struct {
 148     const char *name[MAXFDIRS];
 149     int  num;
 150 } fDirRecord, *fDirRecordPtr;
 151 
 152 #ifndef HEADLESS
 153 
 154 /*
 155  * Returns True if display is local, False of it&#39;s remote.
 156  */
 157 jboolean isDisplayLocal(JNIEnv *env) {
 158     static jboolean isLocal = False;
 159     static jboolean isLocalSet = False;
 160     jboolean ret;
 161 
 162     if (! isLocalSet) {
 163       jclass geCls = (*env)-&gt;FindClass(env, &quot;java/awt/GraphicsEnvironment&quot;);
 164       CHECK_NULL_RETURN(geCls, JNI_FALSE);
 165       jmethodID getLocalGE = (*env)-&gt;GetStaticMethodID(env, geCls,
 166                                                  &quot;getLocalGraphicsEnvironment&quot;,
 167                                            &quot;()Ljava/awt/GraphicsEnvironment;&quot;);
 168       CHECK_NULL_RETURN(getLocalGE, JNI_FALSE);
 169       jobject ge = (*env)-&gt;CallStaticObjectMethod(env, geCls, getLocalGE);
 170       JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 171 
 172       jclass sgeCls = (*env)-&gt;FindClass(env,
 173                                         &quot;sun/java2d/SunGraphicsEnvironment&quot;);
 174       CHECK_NULL_RETURN(sgeCls, JNI_FALSE);
 175       if ((*env)-&gt;IsInstanceOf(env, ge, sgeCls)) {
 176         jmethodID isDisplayLocal = (*env)-&gt;GetMethodID(env, sgeCls,
 177                                                        &quot;isDisplayLocal&quot;,
 178                                                        &quot;()Z&quot;);
 179         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 180         isLocal = (*env)-&gt;CallBooleanMethod(env, ge, isDisplayLocal);
 181         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 182       } else {
 183         isLocal = True;
 184       }
 185       isLocalSet = True;
 186     }
 187 
 188     return isLocal;
 189 }
 190 
 191 static void AddFontsToX11FontPath ( fDirRecord *fDirP )
 192 {
 193     char *onePath;
 194     int index, nPaths;
 195     int origNumPaths, length;
 196     int origIndex;
 197     int totalDirCount;
 198     char  **origFontPath;
 199     char  **tempFontPath;
 200     int doNotAppend;
 201     int *appendDirList;
 202     char **newFontPath;
 203     int err, compareLength;
 204     char fontDirPath[512];
 205     int dirFile;
 206 
 207     doNotAppend = 0;
 208 
 209     if ( fDirP-&gt;num == 0 ) return;
 210 
 211     appendDirList = SAFE_SIZE_ARRAY_ALLOC(malloc, fDirP-&gt;num, sizeof ( int ));
 212     if ( appendDirList == NULL ) {
 213       return;  /* if it fails we cannot do much */
 214     }
 215 
 216     origFontPath = XGetFontPath ( awt_display, &amp;nPaths );
 217 
 218     totalDirCount = nPaths;
 219     origNumPaths = nPaths;
 220     tempFontPath = origFontPath;
 221 
 222 
 223     for (index = 0; index &lt; fDirP-&gt;num; index++ ) {
 224 
 225         doNotAppend = 0;
 226 
 227         tempFontPath = origFontPath;
 228         for ( origIndex = 0; origIndex &lt; nPaths; origIndex++ ) {
 229 
 230             onePath = *tempFontPath;
 231 
 232             compareLength = strlen ( onePath );
 233             if ( onePath[compareLength -1] == &#39;/&#39; )
 234               compareLength--;
 235 
 236             /* there is a slash at the end of every solaris X11 font path name */
 237             if ( strncmp ( onePath, fDirP-&gt;name[index], compareLength ) == 0 ) {
 238               doNotAppend = 1;
 239               break;
 240             }
 241             tempFontPath++;
 242         }
 243 
 244         appendDirList[index] = 0;
 245         if ( doNotAppend == 0 ) {
 246             snprintf(fontDirPath, sizeof(fontDirPath), &quot;%s/fonts.dir&quot;, fDirP-&gt;name[index]);
 247             fontDirPath[sizeof(fontDirPath) - 1] = &#39;\0&#39;;
 248             dirFile = open ( fontDirPath, O_RDONLY, 0 );
 249             if ( dirFile == -1 ) {
 250                 doNotAppend = 1;
 251             } else {
 252                close ( dirFile );
 253                totalDirCount++;
 254                appendDirList[index] = 1;
 255             }
 256         }
 257 
 258     }
 259 
 260     /* if no changes are required do not bother to do a setfontpath */
 261     if ( totalDirCount == nPaths ) {
 262       free ( ( void *) appendDirList );
 263       XFreeFontPath ( origFontPath );
 264       return;
 265     }
 266 
 267 
 268     newFontPath = SAFE_SIZE_ARRAY_ALLOC(malloc, totalDirCount, sizeof(char *));
 269     /* if it fails free things and get out */
 270     if ( newFontPath == NULL ) {
 271       free ( ( void *) appendDirList );
 272       XFreeFontPath ( origFontPath );
 273       return;
 274     }
 275 
 276     for ( origIndex = 0; origIndex &lt; nPaths; origIndex++ ) {
 277       onePath = origFontPath[origIndex];
 278       newFontPath[origIndex] = onePath;
 279     }
 280 
 281     /* now add the other font paths */
 282 
 283     for (index = 0; index &lt; fDirP-&gt;num; index++ ) {
 284 
 285       if ( appendDirList[index] == 1 ) {
 286 
 287         /* printf ( &quot;Appending %s\n&quot;, fDirP-&gt;name[index] ); */
 288 
 289         onePath = SAFE_SIZE_ARRAY_ALLOC(malloc, strlen (fDirP-&gt;name[index]) + 2, sizeof( char ) );
 290         if (onePath == NULL) {
 291             free ( ( void *) appendDirList );
 292 
 293             for ( index = origIndex; index &lt; nPaths; index++ ) {
 294                 free( newFontPath[index] );
 295             }
 296 
 297             free( ( void *) newFontPath);
 298             XFreeFontPath ( origFontPath );
 299             return;
 300         }
 301         strcpy ( onePath, fDirP-&gt;name[index] );
 302         strcat ( onePath, &quot;/&quot; );
 303         newFontPath[nPaths++] = onePath;
 304         /* printf ( &quot;The path to be appended is %s\n&quot;, onePath ); */
 305       }
 306     }
 307 
 308     /*   printf ( &quot;The dir count = %d\n&quot;, totalDirCount ); */
 309     free ( ( void *) appendDirList );
 310 
 311     XSetFontPath ( awt_display, newFontPath, totalDirCount );
 312 
 313         for ( index = origNumPaths; index &lt; totalDirCount; index++ ) {
 314                 free( newFontPath[index] );
 315     }
 316 
 317         free ( (void *) newFontPath );
 318     XFreeFontPath ( origFontPath );
 319     return;
 320 }
 321 #endif /* !HEADLESS */
 322 
 323 
 324 #ifndef HEADLESS
 325 static char **getX11FontPath ()
 326 {
 327     char **x11Path, **fontdirs;
 328     int i, pos, slen, nPaths, numDirs;
 329 
 330     x11Path = XGetFontPath (awt_display, &amp;nPaths);
 331 
 332     /* This isn&#39;t ever going to be perfect: the font path may contain
 333      * much we aren&#39;t interested in, but the cost should be moderate
 334      * Exclude all directories that contain the strings &quot;Speedo&quot;,&quot;/F3/&quot;,
 335      * &quot;75dpi&quot;, &quot;100dpi&quot;, &quot;misc&quot; or &quot;bitmap&quot;, or don&#39;t begin with a &quot;/&quot;,
 336      * the last of which should exclude font servers.
 337      * Also exclude the user specific &quot;.gnome*&quot; directories which
 338      * aren&#39;t going to contain the system fonts we need.
 339      * Hopefully we are left only with Type1 and TrueType directories.
 340      * It doesn&#39;t matter much if there are extraneous directories, it&#39;ll just
 341      * cost us a little wasted effort upstream.
 342      */
 343     fontdirs = (char**)calloc(nPaths+1, sizeof(char*));
 344     if (fontdirs == NULL) {
 345         return NULL;
 346     }
 347     pos = 0;
 348     for (i=0; i &lt; nPaths; i++) {
 349         if (x11Path[i][0] != &#39;/&#39;) {
 350             continue;
 351         }
 352         if (strstr(x11Path[i], &quot;/75dpi&quot;) != NULL) {
 353             continue;
 354         }
 355         if (strstr(x11Path[i], &quot;/100dpi&quot;) != NULL) {
 356             continue;
 357         }
 358         if (strstr(x11Path[i], &quot;/misc&quot;) != NULL) {
 359             continue;
 360         }
 361         if (strstr(x11Path[i], &quot;/Speedo&quot;) != NULL) {
 362             continue;
 363         }
 364         if (strstr(x11Path[i], &quot;.gnome&quot;) != NULL) {
 365             continue;
 366         }
<a name="4" id="anc4"></a><span class="line-removed"> 367 #ifdef __solaris__</span>
<span class="line-removed"> 368         if (strstr(x11Path[i], &quot;/F3/&quot;) != NULL) {</span>
<span class="line-removed"> 369             continue;</span>
<span class="line-removed"> 370         }</span>
<span class="line-removed"> 371         if (strstr(x11Path[i], &quot;bitmap&quot;) != NULL) {</span>
<span class="line-removed"> 372             continue;</span>
<span class="line-removed"> 373         }</span>
<span class="line-removed"> 374 #endif</span>
 375         fontdirs[pos] = strdup(x11Path[i]);
 376         slen = strlen(fontdirs[pos]);
 377         if (slen &gt; 0 &amp;&amp; fontdirs[pos][slen-1] == &#39;/&#39;) {
 378             fontdirs[pos][slen-1] = &#39;\0&#39;; /* null out trailing &quot;/&quot;  */
 379         }
 380         pos++;
 381     }
 382 
 383     XFreeFontPath(x11Path);
 384     if (pos == 0) {
 385         free(fontdirs);
 386         fontdirs = NULL;
 387     }
 388     return fontdirs;
 389 }
 390 
 391 
 392 #endif /* !HEADLESS */
 393 
 394 #if defined(__linux__)
 395 /* from awt_LoadLibrary.c */
 396 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 397 #endif
 398 
 399 /* This eliminates duplicates, at a non-linear but acceptable cost
 400  * since the lists are expected to be reasonably short, and then
 401  * deletes references to non-existent directories, and returns
 402  * a single path consisting of unique font directories.
 403  */
 404 static char* mergePaths(char **p1, char **p2, char **p3, jboolean noType1) {
 405 
 406     int len1=0, len2=0, len3=0, totalLen=0, numDirs=0,
 407         currLen, i, j, found, pathLen=0;
 408     char **ptr, **fontdirs;
 409     char *fontPath = NULL;
 410 
 411     if (p1 != NULL) {
 412         ptr = p1;
 413         while (*ptr++ != NULL) len1++;
 414     }
 415     if (p2 != NULL) {
 416         ptr = p2;
 417 
 418         while (*ptr++ != NULL) len2++;
 419     }
 420     if (p3 != NULL) {
 421         ptr = p3;
 422         while (*ptr++ != NULL) len3++;
 423     }
 424     totalLen = len1+len2+len3;
 425     fontdirs = (char**)calloc(totalLen, sizeof(char*));
 426     if (fontdirs == NULL) {
 427         return NULL;
 428     }
 429 
 430     for (i=0; i &lt; len1; i++) {
 431         if (noType1 &amp;&amp; strstr(p1[i], &quot;Type1&quot;) != NULL) {
 432             continue;
 433         }
 434         fontdirs[numDirs++] = p1[i];
 435     }
 436 
 437     currLen = numDirs; /* only compare against previous path dirs */
 438     for (i=0; i &lt; len2; i++) {
 439         if (noType1 &amp;&amp; strstr(p2[i], &quot;Type1&quot;) != NULL) {
 440             continue;
 441         }
 442         found = 0;
 443         for (j=0; j &lt; currLen; j++) {
 444             if (strcmp(fontdirs[j], p2[i]) == 0) {
 445                 found = 1;
 446                 break;
 447             }
 448         }
 449         if (!found) {
 450            fontdirs[numDirs++] = p2[i];
 451         }
 452     }
 453 
 454     currLen = numDirs; /* only compare against previous path dirs */
 455     for (i=0; i &lt; len3; i++) {
 456         if (noType1 &amp;&amp; strstr(p3[i], &quot;Type1&quot;) != NULL) {
 457             continue;
 458         }
 459         found = 0;
 460         for (j=0; j &lt; currLen; j++) {
 461             if (strcmp(fontdirs[j], p3[i]) == 0) {
 462                 found = 1;
 463                 break;
 464             }
 465         }
 466         if (!found) {
 467            fontdirs[numDirs++] = p3[i];
 468         }
 469     }
 470 
 471     /* Now fontdirs contains unique dirs and numDirs records how many.
 472      * What we don&#39;t know is if they all exist. On reflection I think
 473      * this isn&#39;t an issue, so for now I will return all these locations,
 474      * converted to one string */
 475     for (i=0; i&lt;numDirs; i++) {
 476         pathLen += (strlen(fontdirs[i]) + 1);
 477     }
 478     if (pathLen &gt; 0 &amp;&amp; (fontPath = malloc(pathLen))) {
 479         *fontPath = &#39;\0&#39;;
 480         for (i = 0; i&lt;numDirs; i++) {
 481             if (i != 0) {
 482                 strcat(fontPath, &quot;:&quot;);
 483             }
 484             strcat(fontPath, fontdirs[i]);
 485         }
 486     }
 487     free (fontdirs);
 488 
 489     return fontPath;
 490 }
 491 
 492 /*
 493  * The goal of this function is to find all &quot;system&quot; fonts which
 494  * are needed by the JRE to display text in supported locales etc, and
 495  * to support APIs which allow users to enumerate all system fonts and use
 496  * them from their Java applications.
 497  * The preferred mechanism is now using the new &quot;fontconfig&quot; library
 498  * This exists on newer versions of Linux and Solaris (S10 and above)
 499  * The library is dynamically located. The results are merged with
 500  * a set of &quot;known&quot; locations and with the X11 font path, if running in
 501  * a local X11 environment.
 502  * The hardwired paths are built into the JDK binary so as new font locations
 503  * are created on a host plaform for them to be located by the JRE they will
 504  * need to be added ito the host&#39;s font configuration database, typically
 505  * /etc/fonts/local.conf, and to ensure that directory contains a fonts.dir
 506  * NB: Fontconfig also depends heavily for performance on the host O/S
 507  * maintaining up to date caches.
 508  * This is consistent with the requirements of the desktop environments
 509  * on these OSes.
 510  * This also frees us from X11 APIs as JRE is required to function in
 511  * a &quot;headless&quot; mode where there is no Xserver.
 512  */
 513 static char *getPlatformFontPathChars(JNIEnv *env, jboolean noType1, jboolean isX11) {
 514 
 515     char **fcdirs = NULL, **x11dirs = NULL, **knowndirs = NULL, *path = NULL;
 516 
 517     /* As of 1.5 we try to use fontconfig on both Solaris and Linux.
 518      * If its not available NULL is returned.
 519      */
 520     fcdirs = getFontConfigLocations();
 521 
 522 #if defined(__linux__)
 523     knowndirs = fullLinuxFontPath;
<a name="5" id="anc5"></a><span class="line-removed"> 524 #elif defined(__solaris__)</span>
<span class="line-removed"> 525     knowndirs = fullSolarisFontPath;</span>
 526 #elif defined(_AIX)
 527     knowndirs = fullAixFontPath;
 528 #endif
 529     /* REMIND: this code requires to be executed when the GraphicsEnvironment
 530      * is already initialised. That is always true, but if it were not so,
 531      * this code could throw an exception and the fontpath would fail to
 532      * be initialised.
 533      */
 534 #ifndef HEADLESS
 535     if (isX11) { // The following only works in an x11 environment.
 536 #if defined(__linux__)
 537     /* There&#39;s no headless build on linux ... */
 538     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 539 #endif
 540       /* Using the X11 font path to locate font files is now a fallback
 541        * useful only if fontconfig failed, or is incomplete. So we could
 542        * remove this code completely and the consequences should be rare
 543        * and non-fatal. If this happens, then the calling Java code can
 544        * be modified to no longer require that the AWT lock (the X11GE)
 545        * be initialised prior to calling this code.
 546        */
 547     AWT_LOCK();
 548     if (isDisplayLocal(env)) {
 549         x11dirs = getX11FontPath();
 550     }
 551     AWT_UNLOCK();
 552 #if defined(__linux__)
 553     }
 554 #endif
 555     }
 556 #endif /* !HEADLESS */
 557     path = mergePaths(fcdirs, x11dirs, knowndirs, noType1);
 558     if (fcdirs != NULL) {
 559         char **p = fcdirs;
 560         while (*p != NULL)  free(*p++);
 561         free(fcdirs);
 562     }
 563 
 564     if (x11dirs != NULL) {
 565         char **p = x11dirs;
 566         while (*p != NULL) free(*p++);
 567         free(x11dirs);
 568     }
 569 
 570     return path;
 571 }
 572 
 573 JNIEXPORT jstring JNICALL Java_sun_awt_FcFontManager_getFontPathNative
 574 (JNIEnv *env, jobject thiz, jboolean noType1, jboolean isX11) {
 575     jstring ret;
 576     static char *ptr = NULL; /* retain result across calls */
 577 
 578     if (ptr == NULL) {
 579         ptr = getPlatformFontPathChars(env, noType1, isX11);
 580     }
 581     ret = (*env)-&gt;NewStringUTF(env, ptr);
 582     return ret;
 583 }
 584 
 585 #include &lt;dlfcn.h&gt;
 586 
 587 #include &lt;fontconfig/fontconfig.h&gt;
 588 
 589 
 590 static void* openFontConfig() {
 591 
 592     char *homeEnv;
 593     static char *homeEnvStr = &quot;HOME=&quot;; /* must be static */
 594     void* libfontconfig = NULL;
<a name="6" id="anc6"></a><span class="line-removed"> 595 #ifdef __solaris__</span>
<span class="line-removed"> 596 #define SYSINFOBUFSZ 8</span>
<span class="line-removed"> 597     char sysinfobuf[SYSINFOBUFSZ];</span>
<span class="line-removed"> 598 #endif</span>
 599 
 600     /* Private workaround to not use fontconfig library.
 601      * May be useful during testing/debugging
 602      */
 603     char *useFC = getenv(&quot;USE_J2D_FONTCONFIG&quot;);
 604     if (useFC != NULL &amp;&amp; !strcmp(useFC, &quot;no&quot;)) {
 605         return NULL;
 606     }
 607 
<a name="7" id="anc7"></a><span class="line-removed"> 608 #ifdef __solaris__</span>
<span class="line-removed"> 609     /* fontconfig is likely not properly configured on S8/S9 - skip it,</span>
<span class="line-removed"> 610      * although allow user to override this behaviour with an env. variable</span>
<span class="line-removed"> 611      * ie if USE_J2D_FONTCONFIG=yes then we skip this test.</span>
<span class="line-removed"> 612      * NB &quot;4&quot; is the length of a string which matches our patterns.</span>
<span class="line-removed"> 613      */</span>
<span class="line-removed"> 614     if (useFC == NULL || strcmp(useFC, &quot;yes&quot;)) {</span>
<span class="line-removed"> 615         if (sysinfo(SI_RELEASE, sysinfobuf, SYSINFOBUFSZ) == 4) {</span>
<span class="line-removed"> 616             if ((!strcmp(sysinfobuf, &quot;5.8&quot;) || !strcmp(sysinfobuf, &quot;5.9&quot;))) {</span>
<span class="line-removed"> 617                 return NULL;</span>
<span class="line-removed"> 618             }</span>
<span class="line-removed"> 619         }</span>
<span class="line-removed"> 620     }</span>
<span class="line-removed"> 621 #endif</span>
<span class="line-removed"> 622 </span>
 623 #if defined(_AIX)
 624     /* On AIX, fontconfig is not a standard package supported by IBM.
 625      * instead it has to be installed from the &quot;AIX Toolbox for Linux Applications&quot;
 626      * site http://www-03.ibm.com/systems/power/software/aix/linux/toolbox/alpha.html
 627      * and will be installed under /opt/freeware/lib/libfontconfig.a.
 628      * Notice that the archive contains the real 32- and 64-bit shared libraries.
 629      * We first try to load &#39;libfontconfig.so&#39; from the default library path in the
 630      * case the user has installed a private version of the library and if that
 631      * doesn&#39;t succeed, we try the version from /opt/freeware/lib/libfontconfig.a
 632      */
 633     libfontconfig = dlopen(&quot;libfontconfig.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 634     if (libfontconfig == NULL) {
 635         libfontconfig = dlopen(&quot;/opt/freeware/lib/libfontconfig.a(libfontconfig.so.1)&quot;, RTLD_MEMBER|RTLD_LOCAL|RTLD_LAZY);
 636         if (libfontconfig == NULL) {
 637             return NULL;
 638         }
 639     }
 640 #else
 641     /* 64 bit sparc should pick up the right version from the lib path.
 642      * New features may be added to libfontconfig, this is expected to
 643      * be compatible with old features, but we may need to start
 644      * distinguishing the library version, to know whether to expect
 645      * certain symbols - and functionality - to be available.
 646      * Also add explicit search for .so.1 in case .so symlink doesn&#39;t exist.
 647      */
 648     libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
 649     if (libfontconfig == NULL) {
 650         libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
 651         if (libfontconfig == NULL) {
 652             return NULL;
 653         }
 654     }
 655 #endif
 656 
 657     /* Version 1.0 of libfontconfig crashes if HOME isn&#39;t defined in
 658      * the environment. This should generally never happen, but we can&#39;t
 659      * control it, and can&#39;t control the version of fontconfig, so iff
 660      * its not defined we set it to an empty value which is sufficient
 661      * to prevent a crash. I considered unsetting it before exit, but
 662      * it doesn&#39;t appear to work on Solaris, so I will leave it set.
 663      */
 664     homeEnv = getenv(&quot;HOME&quot;);
 665     if (homeEnv == NULL) {
 666         putenv(homeEnvStr);
 667     }
 668 
 669     return libfontconfig;
 670 }
 671 
 672 typedef void* (FcFiniFuncType)();
 673 
 674 static void closeFontConfig(void* libfontconfig, jboolean fcFini) {
 675 
 676   /* NB FcFini is not in (eg) the Solaris 10 version of fontconfig. Its not
 677    * clear if this means we are really leaking resources in those cases
 678    * but it seems we should call this function when its available.
 679    * But since the Swing GTK code may be still accessing the lib, its probably
 680    * safest for now to just let this &quot;leak&quot; rather than potentially
 681    * concurrently free global data still in use by other code.
 682    */
 683 #if 0
 684     if (fcFini) { /* release resources */
 685         FcFiniFuncType FcFini = (FcFiniFuncType)dlsym(libfontconfig, &quot;FcFini&quot;);
 686 
 687         if (FcFini != NULL) {
 688             (*FcFini)();
 689         }
 690     }
 691 #endif
 692     dlclose(libfontconfig);
 693 }
 694 
 695 typedef FcConfig* (*FcInitLoadConfigFuncType)();
 696 typedef FcPattern* (*FcPatternBuildFuncType)(FcPattern *orig, ...);
 697 typedef FcObjectSet* (*FcObjectSetFuncType)(const char *first, ...);
 698 typedef FcFontSet* (*FcFontListFuncType)(FcConfig *config,
 699                                          FcPattern *p,
 700                                          FcObjectSet *os);
 701 typedef FcResult (*FcPatternGetBoolFuncType)(const FcPattern *p,
 702                                                const char *object,
 703                                                int n,
 704                                                FcBool *b);
 705 typedef FcResult (*FcPatternGetIntegerFuncType)(const FcPattern *p,
 706                                                 const char *object,
 707                                                 int n,
 708                                                 int *i);
 709 typedef FcResult (*FcPatternGetStringFuncType)(const FcPattern *p,
 710                                                const char *object,
 711                                                int n,
 712                                                FcChar8 ** s);
 713 typedef FcChar8* (*FcStrDirnameFuncType)(const FcChar8 *file);
 714 typedef void (*FcPatternDestroyFuncType)(FcPattern *p);
 715 typedef void (*FcFontSetDestroyFuncType)(FcFontSet *s);
 716 typedef FcPattern* (*FcNameParseFuncType)(const FcChar8 *name);
 717 typedef FcBool (*FcPatternAddStringFuncType)(FcPattern *p,
 718                                              const char *object,
 719                                              const FcChar8 *s);
 720 typedef void (*FcDefaultSubstituteFuncType)(FcPattern *p);
 721 typedef FcBool (*FcConfigSubstituteFuncType)(FcConfig *config,
 722                                              FcPattern *p,
 723                                              FcMatchKind kind);
 724 typedef FcPattern* (*FcFontMatchFuncType)(FcConfig *config,
 725                                           FcPattern *p,
 726                                           FcResult *result);
 727 typedef FcFontSet* (*FcFontSetCreateFuncType)();
 728 typedef FcBool (*FcFontSetAddFuncType)(FcFontSet *s, FcPattern *font);
 729 
 730 typedef FcResult (*FcPatternGetCharSetFuncType)(FcPattern *p,
 731                                                 const char *object,
 732                                                 int n,
 733                                                 FcCharSet **c);
 734 typedef FcFontSet* (*FcFontSortFuncType)(FcConfig *config,
 735                                          FcPattern *p,
 736                                          FcBool trim,
 737                                          FcCharSet **csp,
 738                                          FcResult *result);
 739 typedef FcCharSet* (*FcCharSetUnionFuncType)(const FcCharSet *a,
 740                                              const FcCharSet *b);
 741 typedef FcChar32 (*FcCharSetSubtractCountFuncType)(const FcCharSet *a,
 742                                                    const FcCharSet *b);
 743 
 744 typedef int (*FcGetVersionFuncType)();
 745 
 746 typedef FcStrList* (*FcConfigGetCacheDirsFuncType)(FcConfig *config);
 747 typedef FcChar8* (*FcStrListNextFuncType)(FcStrList *list);
 748 typedef FcChar8* (*FcStrListDoneFuncType)(FcStrList *list);
 749 
 750 static char **getFontConfigLocations() {
 751 
 752     char **fontdirs;
 753     int numdirs = 0;
 754     FcInitLoadConfigFuncType FcInitLoadConfig;
 755     FcPatternBuildFuncType FcPatternBuild;
 756     FcObjectSetFuncType FcObjectSetBuild;
 757     FcFontListFuncType FcFontList;
 758     FcPatternGetStringFuncType FcPatternGetString;
 759     FcStrDirnameFuncType FcStrDirname;
 760     FcPatternDestroyFuncType FcPatternDestroy;
 761     FcFontSetDestroyFuncType FcFontSetDestroy;
 762 
 763     FcConfig *fontconfig;
 764     FcPattern *pattern;
 765     FcObjectSet *objset;
 766     FcFontSet *fontSet;
 767     FcStrList *strList;
 768     FcChar8 *str;
 769     int i, f, found, len=0;
 770     char **fontPath;
 771 
 772     void* libfontconfig = openFontConfig();
 773 
 774     if (libfontconfig == NULL) {
 775         return NULL;
 776     }
 777 
 778     FcPatternBuild     =
 779         (FcPatternBuildFuncType)dlsym(libfontconfig, &quot;FcPatternBuild&quot;);
 780     FcObjectSetBuild   =
 781         (FcObjectSetFuncType)dlsym(libfontconfig, &quot;FcObjectSetBuild&quot;);
 782     FcFontList         =
 783         (FcFontListFuncType)dlsym(libfontconfig, &quot;FcFontList&quot;);
 784     FcPatternGetString =
 785         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
 786     FcStrDirname       =
 787         (FcStrDirnameFuncType)dlsym(libfontconfig, &quot;FcStrDirname&quot;);
 788     FcPatternDestroy   =
 789         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
 790     FcFontSetDestroy   =
 791         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
 792 
 793     if (FcPatternBuild     == NULL ||
 794         FcObjectSetBuild   == NULL ||
 795         FcPatternGetString == NULL ||
 796         FcFontList         == NULL ||
 797         FcStrDirname       == NULL ||
 798         FcPatternDestroy   == NULL ||
 799         FcFontSetDestroy   == NULL) { /* problem with the library: return. */
 800         closeFontConfig(libfontconfig, JNI_FALSE);
 801         return NULL;
 802     }
 803 
 804     /* Make calls into the fontconfig library to build a search for
 805      * outline fonts, and to get the set of full file paths from the matches.
 806      * This set is returned from the call to FcFontList(..)
 807      * We allocate an array of char* pointers sufficient to hold all
 808      * the matches + 1 extra which ensures there will be a NULL after all
 809      * valid entries.
 810      * We call FcStrDirname strip the file name from the path, and
 811      * check if we have yet seen this directory. If not we add a pointer to
 812      * it into our array of char*. Note that FcStrDirname returns newly
 813      * allocated storage so we can use this in the return char** value.
 814      * Finally we clean up, freeing allocated resources, and return the
 815      * array of unique directories.
 816      */
 817     pattern = (*FcPatternBuild)(NULL, FC_OUTLINE, FcTypeBool, FcTrue, NULL);
 818     objset = (*FcObjectSetBuild)(FC_FILE, NULL);
 819     fontSet = (*FcFontList)(NULL, pattern, objset);
 820     if (fontSet == NULL) {
 821         /* FcFontList() may return NULL if fonts are not installed. */
 822         fontdirs = NULL;
 823     } else {
 824         fontdirs = (char**)calloc(fontSet-&gt;nfont+1, sizeof(char*));
 825         if (fontdirs == NULL) {
 826             (*FcFontSetDestroy)(fontSet);
 827             goto cleanup;
 828         }
 829         for (f=0; f &lt; fontSet-&gt;nfont; f++) {
 830             FcChar8 *file;
 831             FcChar8 *dir;
 832             if ((*FcPatternGetString)(fontSet-&gt;fonts[f], FC_FILE, 0, &amp;file) ==
 833                                       FcResultMatch) {
 834                 dir = (*FcStrDirname)(file);
 835                 found = 0;
 836                 for (i=0;i&lt;numdirs; i++) {
 837                     if (strcmp(fontdirs[i], (char*)dir) == 0) {
 838                         found = 1;
 839                         break;
 840                     }
 841                 }
 842                 if (!found) {
 843                     fontdirs[numdirs++] = (char*)dir;
 844                 } else {
 845                     free((char*)dir);
 846                 }
 847             }
 848         }
 849         /* Free fontset if one was returned */
 850         (*FcFontSetDestroy)(fontSet);
 851     }
 852 
 853 cleanup:
 854     /* Free memory and close the &quot;.so&quot; */
 855     (*FcPatternDestroy)(pattern);
 856     closeFontConfig(libfontconfig, JNI_TRUE);
 857     return fontdirs;
 858 }
 859 
 860 /* These are copied from sun.awt.SunHints.
 861  * Consider initialising them as ints using JNI for more robustness.
 862  */
 863 #define TEXT_AA_OFF 1
 864 #define TEXT_AA_ON  2
 865 #define TEXT_AA_LCD_HRGB 4
 866 #define TEXT_AA_LCD_HBGR 5
 867 #define TEXT_AA_LCD_VRGB 6
 868 #define TEXT_AA_LCD_VBGR 7
 869 
 870 JNIEXPORT jint JNICALL
 871 Java_sun_font_FontConfigManager_getFontConfigAASettings
 872 (JNIEnv *env, jclass obj, jstring localeStr, jstring fcNameStr) {
 873 
 874     FcNameParseFuncType FcNameParse;
 875     FcPatternAddStringFuncType FcPatternAddString;
 876     FcConfigSubstituteFuncType FcConfigSubstitute;
 877     FcDefaultSubstituteFuncType  FcDefaultSubstitute;
 878     FcFontMatchFuncType FcFontMatch;
 879     FcPatternGetBoolFuncType FcPatternGetBool;
 880     FcPatternGetIntegerFuncType FcPatternGetInteger;
 881     FcPatternDestroyFuncType FcPatternDestroy;
 882 
 883     FcPattern *pattern, *matchPattern;
 884     FcResult result;
 885     FcBool antialias = FcFalse;
 886     int rgba = 0;
 887     const char *locale=NULL, *fcName=NULL;
 888     void* libfontconfig;
 889 
 890     if (fcNameStr == NULL || localeStr == NULL) {
 891         return -1;
 892     }
 893 
 894     fcName = (*env)-&gt;GetStringUTFChars(env, fcNameStr, 0);
 895     if (fcName == NULL) {
 896         return -1;
 897     }
 898     locale = (*env)-&gt;GetStringUTFChars(env, localeStr, 0);
 899 
 900     if ((libfontconfig = openFontConfig()) == NULL) {
 901         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 902         if (locale) {
 903             (*env)-&gt;ReleaseStringUTFChars(env, localeStr,(const char*)locale);
 904         }
 905         return -1;
 906     }
 907 
 908     FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, &quot;FcNameParse&quot;);
 909     FcPatternAddString =
 910         (FcPatternAddStringFuncType)dlsym(libfontconfig, &quot;FcPatternAddString&quot;);
 911     FcConfigSubstitute =
 912         (FcConfigSubstituteFuncType)dlsym(libfontconfig, &quot;FcConfigSubstitute&quot;);
 913     FcDefaultSubstitute = (FcDefaultSubstituteFuncType)
 914         dlsym(libfontconfig, &quot;FcDefaultSubstitute&quot;);
 915     FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, &quot;FcFontMatch&quot;);
 916     FcPatternGetBool = (FcPatternGetBoolFuncType)
 917         dlsym(libfontconfig, &quot;FcPatternGetBool&quot;);
 918     FcPatternGetInteger = (FcPatternGetIntegerFuncType)
 919         dlsym(libfontconfig, &quot;FcPatternGetInteger&quot;);
 920     FcPatternDestroy =
 921         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
 922 
 923     if (FcNameParse          == NULL ||
 924         FcPatternAddString   == NULL ||
 925         FcConfigSubstitute   == NULL ||
 926         FcDefaultSubstitute  == NULL ||
 927         FcFontMatch          == NULL ||
 928         FcPatternGetBool     == NULL ||
 929         FcPatternGetInteger  == NULL ||
 930         FcPatternDestroy     == NULL) { /* problem with the library: return. */
 931 
 932         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 933         if (locale) {
 934             (*env)-&gt;ReleaseStringUTFChars(env, localeStr,(const char*)locale);
 935         }
 936         closeFontConfig(libfontconfig, JNI_FALSE);
 937         return -1;
 938     }
 939 
 940 
 941     pattern = (*FcNameParse)((FcChar8 *)fcName);
 942     if (locale != NULL) {
 943         (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);
 944     }
 945     (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);
 946     (*FcDefaultSubstitute)(pattern);
 947     matchPattern = (*FcFontMatch)(NULL, pattern, &amp;result);
 948     /* Perhaps should call FcFontRenderPrepare() here as some pattern
 949      * elements might change as a result of that call, but I&#39;m not seeing
 950      * any difference in testing.
 951      */
 952     if (matchPattern) {
 953         (*FcPatternGetBool)(matchPattern, FC_ANTIALIAS, 0, &amp;antialias);
 954         (*FcPatternGetInteger)(matchPattern, FC_RGBA, 0, &amp;rgba);
 955         (*FcPatternDestroy)(matchPattern);
 956     }
 957     (*FcPatternDestroy)(pattern);
 958 
 959     (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 960     if (locale) {
 961         (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
 962     }
 963     closeFontConfig(libfontconfig, JNI_TRUE);
 964 
 965     if (antialias == FcFalse) {
 966         return TEXT_AA_OFF;
 967     } else if (rgba &lt;= FC_RGBA_UNKNOWN || rgba &gt;= FC_RGBA_NONE) {
 968         return TEXT_AA_ON;
 969     } else {
 970         switch (rgba) {
 971         case FC_RGBA_RGB : return TEXT_AA_LCD_HRGB;
 972         case FC_RGBA_BGR : return TEXT_AA_LCD_HBGR;
 973         case FC_RGBA_VRGB : return TEXT_AA_LCD_VRGB;
 974         case FC_RGBA_VBGR : return TEXT_AA_LCD_VBGR;
 975         default : return TEXT_AA_LCD_HRGB; // should not get here.
 976         }
 977     }
 978 }
 979 
 980 JNIEXPORT jint JNICALL
 981 Java_sun_font_FontConfigManager_getFontConfigVersion
 982     (JNIEnv *env, jclass obj) {
 983 
 984     void* libfontconfig;
 985     FcGetVersionFuncType FcGetVersion;
 986     int version = 0;
 987 
 988     if ((libfontconfig = openFontConfig()) == NULL) {
 989         return 0;
 990     }
 991 
 992     FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, &quot;FcGetVersion&quot;);
 993 
 994     if (FcGetVersion == NULL) {
 995         closeFontConfig(libfontconfig, JNI_FALSE);
 996         return 0;
 997     }
 998     version = (*FcGetVersion)();
 999     closeFontConfig(libfontconfig, JNI_FALSE);
1000 
1001     return version;
1002 }
1003 
1004 
1005 JNIEXPORT void JNICALL
1006 Java_sun_font_FontConfigManager_getFontConfig
1007 (JNIEnv *env, jclass obj, jstring localeStr, jobject fcInfoObj,
1008  jobjectArray fcCompFontArray,  jboolean includeFallbacks) {
1009 
1010     FcNameParseFuncType FcNameParse;
1011     FcPatternAddStringFuncType FcPatternAddString;
1012     FcConfigSubstituteFuncType FcConfigSubstitute;
1013     FcDefaultSubstituteFuncType  FcDefaultSubstitute;
1014     FcFontMatchFuncType FcFontMatch;
1015     FcPatternGetStringFuncType FcPatternGetString;
1016     FcPatternDestroyFuncType FcPatternDestroy;
1017     FcPatternGetCharSetFuncType FcPatternGetCharSet;
1018     FcFontSortFuncType FcFontSort;
1019     FcFontSetDestroyFuncType FcFontSetDestroy;
1020     FcCharSetUnionFuncType FcCharSetUnion;
1021     FcCharSetSubtractCountFuncType FcCharSetSubtractCount;
1022     FcGetVersionFuncType FcGetVersion;
1023     FcConfigGetCacheDirsFuncType FcConfigGetCacheDirs;
1024     FcStrListNextFuncType FcStrListNext;
1025     FcStrListDoneFuncType FcStrListDone;
1026 
1027     int i, arrlen;
1028     jobject fcCompFontObj;
1029     jstring fcNameStr, jstr;
1030     const char *locale, *fcName;
1031     FcPattern *pattern;
1032     FcResult result;
1033     void* libfontconfig;
1034     jfieldID fcNameID, fcFirstFontID, fcAllFontsID, fcVersionID, fcCacheDirsID;
1035     jfieldID familyNameID, styleNameID, fullNameID, fontFileID;
1036     jmethodID fcFontCons;
1037     char* debugMinGlyphsStr = getenv(&quot;J2D_DEBUG_MIN_GLYPHS&quot;);
1038     jclass fcInfoClass;
1039     jclass fcCompFontClass;
1040     jclass fcFontClass;
1041 
1042     CHECK_NULL(fcInfoObj);
1043     CHECK_NULL(fcCompFontArray);
1044 
1045     fcInfoClass =
1046         (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FontConfigInfo&quot;);
1047     CHECK_NULL(fcInfoClass);
1048     fcCompFontClass =
1049         (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FcCompFont&quot;);
1050     CHECK_NULL(fcCompFontClass);
1051     fcFontClass =
1052          (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FontConfigFont&quot;);
1053     CHECK_NULL(fcFontClass);
1054 
1055 
1056     CHECK_NULL(fcVersionID = (*env)-&gt;GetFieldID(env, fcInfoClass, &quot;fcVersion&quot;, &quot;I&quot;));
1057     CHECK_NULL(fcCacheDirsID = (*env)-&gt;GetFieldID(env, fcInfoClass, &quot;cacheDirs&quot;,
1058                                                   &quot;[Ljava/lang/String;&quot;));
1059     CHECK_NULL(fcNameID = (*env)-&gt;GetFieldID(env, fcCompFontClass,
1060                                              &quot;fcName&quot;, &quot;Ljava/lang/String;&quot;));
1061     CHECK_NULL(fcFirstFontID = (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;firstFont&quot;,
1062                                         &quot;Lsun/font/FontConfigManager$FontConfigFont;&quot;));
1063     CHECK_NULL(fcAllFontsID = (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;allFonts&quot;,
1064                                         &quot;[Lsun/font/FontConfigManager$FontConfigFont;&quot;));
1065     CHECK_NULL(fcFontCons = (*env)-&gt;GetMethodID(env, fcFontClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;));
1066     CHECK_NULL(familyNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
1067                                       &quot;familyName&quot;, &quot;Ljava/lang/String;&quot;));
1068     CHECK_NULL(styleNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
1069                                     &quot;styleStr&quot;, &quot;Ljava/lang/String;&quot;));
1070     CHECK_NULL(fullNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
1071                                     &quot;fullName&quot;, &quot;Ljava/lang/String;&quot;));
1072     CHECK_NULL(fontFileID = (*env)-&gt;GetFieldID(env, fcFontClass,
1073                                     &quot;fontFile&quot;, &quot;Ljava/lang/String;&quot;));
1074 
1075     if ((libfontconfig = openFontConfig()) == NULL) {
1076         return;
1077     }
1078 
1079     FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, &quot;FcNameParse&quot;);
1080     FcPatternAddString =
1081         (FcPatternAddStringFuncType)dlsym(libfontconfig, &quot;FcPatternAddString&quot;);
1082     FcConfigSubstitute =
1083         (FcConfigSubstituteFuncType)dlsym(libfontconfig, &quot;FcConfigSubstitute&quot;);
1084     FcDefaultSubstitute = (FcDefaultSubstituteFuncType)
1085         dlsym(libfontconfig, &quot;FcDefaultSubstitute&quot;);
1086     FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, &quot;FcFontMatch&quot;);
1087     FcPatternGetString =
1088         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
1089     FcPatternDestroy =
1090         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
1091     FcPatternGetCharSet =
1092         (FcPatternGetCharSetFuncType)dlsym(libfontconfig,
1093                                            &quot;FcPatternGetCharSet&quot;);
1094     FcFontSort =
1095         (FcFontSortFuncType)dlsym(libfontconfig, &quot;FcFontSort&quot;);
1096     FcFontSetDestroy =
1097         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
1098     FcCharSetUnion =
1099         (FcCharSetUnionFuncType)dlsym(libfontconfig, &quot;FcCharSetUnion&quot;);
1100     FcCharSetSubtractCount =
1101         (FcCharSetSubtractCountFuncType)dlsym(libfontconfig,
1102                                               &quot;FcCharSetSubtractCount&quot;);
1103     FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, &quot;FcGetVersion&quot;);
1104 
1105     if (FcNameParse          == NULL ||
1106         FcPatternAddString   == NULL ||
1107         FcConfigSubstitute   == NULL ||
1108         FcDefaultSubstitute  == NULL ||
1109         FcFontMatch          == NULL ||
1110         FcPatternGetString   == NULL ||
1111         FcPatternDestroy     == NULL ||
1112         FcPatternGetCharSet  == NULL ||
1113         FcFontSetDestroy     == NULL ||
1114         FcCharSetUnion       == NULL ||
1115         FcGetVersion         == NULL ||
1116         FcCharSetSubtractCount == NULL) {/* problem with the library: return.*/
1117         closeFontConfig(libfontconfig, JNI_FALSE);
1118         return;
1119     }
1120 
1121     (*env)-&gt;SetIntField(env, fcInfoObj, fcVersionID, (*FcGetVersion)());
1122 
1123     /* Optionally get the cache dir locations. This isn&#39;t
1124      * available until v 2.4.x, but this is OK since on those later versions
1125      * we can check the time stamps on the cache dirs to see if we
1126      * are out of date. There are a couple of assumptions here. First
1127      * that the time stamp on the directory changes when the contents are
1128      * updated. Secondly that the locations don&#39;t change. The latter is
1129      * most likely if a new version of fontconfig is installed, but we also
1130      * invalidate the cache if we detect that. Arguably even that is &quot;rare&quot;,
1131      * and most likely is tied to an OS upgrade which gets a new file anyway.
1132      */
1133     FcConfigGetCacheDirs =
1134         (FcConfigGetCacheDirsFuncType)dlsym(libfontconfig,
1135                                             &quot;FcConfigGetCacheDirs&quot;);
1136     FcStrListNext =
1137         (FcStrListNextFuncType)dlsym(libfontconfig, &quot;FcStrListNext&quot;);
1138     FcStrListDone =
1139         (FcStrListDoneFuncType)dlsym(libfontconfig, &quot;FcStrListDone&quot;);
1140     if (FcStrListNext != NULL &amp;&amp; FcStrListDone != NULL &amp;&amp;
1141         FcConfigGetCacheDirs != NULL) {
1142 
1143         FcStrList* cacheDirs;
1144         FcChar8* cacheDir;
1145         int cnt = 0;
1146         jobject cacheDirArray =
1147             (*env)-&gt;GetObjectField(env, fcInfoObj, fcCacheDirsID);
1148         int max = (*env)-&gt;GetArrayLength(env, cacheDirArray);
1149 
1150         cacheDirs = (*FcConfigGetCacheDirs)(NULL);
1151         if (cacheDirs != NULL) {
1152             while ((cnt &lt; max) &amp;&amp; (cacheDir = (*FcStrListNext)(cacheDirs))) {
1153                 jstr = (*env)-&gt;NewStringUTF(env, (const char*)cacheDir);
1154                 JNU_CHECK_EXCEPTION(env);
1155 
1156                 (*env)-&gt;SetObjectArrayElement(env, cacheDirArray, cnt++, jstr);
1157                 (*env)-&gt;DeleteLocalRef(env, jstr);
1158             }
1159             (*FcStrListDone)(cacheDirs);
1160         }
1161     }
1162 
1163     locale = (*env)-&gt;GetStringUTFChars(env, localeStr, 0);
1164     if (locale == NULL) {
1165         (*env)-&gt;ExceptionClear(env);
1166         JNU_ThrowOutOfMemoryError(env, &quot;Could not create locale&quot;);
1167         return;
1168     }
1169 
1170     arrlen = (*env)-&gt;GetArrayLength(env, fcCompFontArray);
1171     for (i=0; i&lt;arrlen; i++) {
1172         FcFontSet* fontset;
1173         int fn, j, fontCount, nfonts;
1174         unsigned int minGlyphs;
1175         FcChar8 **family, **styleStr, **fullname, **file;
1176         jarray fcFontArr = NULL;
1177         FcCharSet *unionCharset = NULL;
1178 
1179         fcCompFontObj = (*env)-&gt;GetObjectArrayElement(env, fcCompFontArray, i);
1180         fcNameStr =
1181             (jstring)((*env)-&gt;GetObjectField(env, fcCompFontObj, fcNameID));
1182         fcName = (*env)-&gt;GetStringUTFChars(env, fcNameStr, 0);
1183         if (fcName == NULL) {
1184             (*env)-&gt;DeleteLocalRef(env, fcCompFontObj);
1185             (*env)-&gt;DeleteLocalRef(env, fcNameStr);
1186             continue;
1187         }
1188         pattern = (*FcNameParse)((FcChar8 *)fcName);
1189         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
1190         (*env)-&gt;DeleteLocalRef(env, fcNameStr);
1191         if (pattern == NULL) {
1192             closeFontConfig(libfontconfig, JNI_FALSE);
1193             if (locale) {
1194                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1195             }
1196             return;
1197         }
1198 
1199         /* locale may not usually be necessary as fontconfig appears to apply
1200          * this anyway based on the user&#39;s environment. However we want
1201          * to use the value of the JDK startup locale so this should take
1202          * care of it.
1203          */
1204         if (locale != NULL) {
1205             (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);
1206         }
1207         (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);
1208         (*FcDefaultSubstitute)(pattern);
1209         fontset = (*FcFontSort)(NULL, pattern, FcTrue, NULL, &amp;result);
1210         if (fontset == NULL) {
1211             (*FcPatternDestroy)(pattern);
1212             closeFontConfig(libfontconfig, JNI_FALSE);
1213             if (locale) {
1214                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1215             }
1216             return;
1217         }
1218 
1219         /* fontconfig returned us &quot;nfonts&quot;. If we are just getting the
1220          * first font, we set nfont to zero. Otherwise we use &quot;nfonts&quot;.
1221          * Next create separate C arrrays of length nfonts for family file etc.
1222          * Inspect the returned fonts and the ones we like (adds enough glyphs)
1223          * are added to the arrays and we increment &#39;fontCount&#39;.
1224          */
1225         nfonts = fontset-&gt;nfont;
1226         family   = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1227         styleStr = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1228         fullname = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1229         file     = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1230         if (family == NULL || styleStr == NULL ||
1231             fullname == NULL || file == NULL) {
1232             if (family != NULL) {
1233                 free(family);
1234             }
1235             if (styleStr != NULL) {
1236                 free(styleStr);
1237             }
1238             if (fullname != NULL) {
1239                 free(fullname);
1240             }
1241             if (file != NULL) {
1242                 free(file);
1243             }
1244             (*FcPatternDestroy)(pattern);
1245             (*FcFontSetDestroy)(fontset);
1246             closeFontConfig(libfontconfig, JNI_FALSE);
1247             if (locale) {
1248                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1249             }
1250             return;
1251         }
1252         fontCount = 0;
1253         minGlyphs = 20;
1254         if (debugMinGlyphsStr != NULL) {
1255             int val = minGlyphs;
1256             sscanf(debugMinGlyphsStr, &quot;%5d&quot;, &amp;val);
1257             if (val &gt;= 0 &amp;&amp; val &lt;= 65536) {
1258                 minGlyphs = val;
1259             }
1260         }
1261 
1262         for (j=0; j&lt;nfonts; j++) {
1263             FcPattern *fontPattern = fontset-&gt;fonts[j];
1264             FcChar8 *fontformat;
1265             FcCharSet *charset = NULL;
1266 
1267             fontformat = NULL;
1268             (*FcPatternGetString)(fontPattern, FC_FONTFORMAT, 0, &amp;fontformat);
1269             /* We only want TrueType fonts but some Linuxes still depend
1270              * on Type 1 fonts for some Locale support, so we&#39;ll allow
1271              * them there.
1272              */
1273             if (fontformat != NULL
1274                 &amp;&amp; (strcmp((char*)fontformat, &quot;TrueType&quot;) != 0)
1275 #if defined(__linux__) || defined(_AIX)
1276                 &amp;&amp; (strcmp((char*)fontformat, &quot;Type 1&quot;) != 0)
1277                 &amp;&amp; (strcmp((char*)fontformat, &quot;CFF&quot;) != 0)
1278 #endif
1279              ) {
1280                 continue;
1281             }
1282             result = (*FcPatternGetCharSet)(fontPattern,
1283                                             FC_CHARSET, 0, &amp;charset);
1284             if (result != FcResultMatch) {
1285                 free(family);
1286                 free(fullname);
1287                 free(styleStr);
1288                 free(file);
1289                 (*FcPatternDestroy)(pattern);
1290                 (*FcFontSetDestroy)(fontset);
1291                 closeFontConfig(libfontconfig, JNI_FALSE);
1292                 if (locale) {
1293                     (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1294                 }
1295                 return;
1296             }
1297 
1298             /* We don&#39;t want 20 or 30 fonts, so once we hit 10 fonts,
1299              * then require that they really be adding value. Too many
1300              * adversely affects load time for minimal value-add.
1301              * This is still likely far more than we&#39;ve had in the past.
1302              */
1303             if (j==10) {
1304                 minGlyphs = 50;
1305             }
1306             if (unionCharset == NULL) {
1307                 unionCharset = charset;
1308             } else {
1309                 if ((*FcCharSetSubtractCount)(charset, unionCharset)
1310                     &gt; minGlyphs) {
1311                     unionCharset = (* FcCharSetUnion)(unionCharset, charset);
1312                 } else {
1313                     continue;
1314                 }
1315             }
1316 
1317             fontCount++; // found a font we will use.
1318             (*FcPatternGetString)(fontPattern, FC_FILE, 0, &amp;file[j]);
1319             (*FcPatternGetString)(fontPattern, FC_FAMILY, 0, &amp;family[j]);
1320             (*FcPatternGetString)(fontPattern, FC_STYLE, 0, &amp;styleStr[j]);
1321             (*FcPatternGetString)(fontPattern, FC_FULLNAME, 0, &amp;fullname[j]);
1322             if (!includeFallbacks) {
1323                 break;
1324             }
1325             if (fontCount == 254) {
1326                 break; // CompositeFont will only use up to 254 slots from here.
1327             }
1328         }
1329 
1330         /* Once we get here &#39;fontCount&#39; is the number of returned fonts
1331          * we actually want to use, so we create &#39;fcFontArr&#39; of that length.
1332          * The non-null entries of &quot;family[]&quot; etc are those fonts.
1333          * Then loop again over all nfonts adding just those non-null ones
1334          * to &#39;fcFontArr&#39;. If its null (we didn&#39;t want the font)
1335          * then we don&#39;t enter the main body.
1336          * So we should never get more than &#39;fontCount&#39; entries.
1337          */
1338         if (includeFallbacks) {
1339             fcFontArr =
1340                 (*env)-&gt;NewObjectArray(env, fontCount, fcFontClass, NULL);
1341             if (IS_NULL(fcFontArr)) {
1342                 free(family);
1343                 free(fullname);
1344                 free(styleStr);
1345                 free(file);
1346                 (*FcPatternDestroy)(pattern);
1347                 (*FcFontSetDestroy)(fontset);
1348                 closeFontConfig(libfontconfig, JNI_FALSE);
1349                 if (locale) {
1350                     (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1351                 }
1352                 return;
1353             }
1354             (*env)-&gt;SetObjectField(env,fcCompFontObj, fcAllFontsID, fcFontArr);
1355         }
1356         fn=0;
1357 
1358         for (j=0;j&lt;nfonts;j++) {
1359             if (family[j] != NULL) {
1360                 jobject fcFont =
1361                     (*env)-&gt;NewObject(env, fcFontClass, fcFontCons);
1362                 if (IS_NULL(fcFont)) break;
1363                 jstr = (*env)-&gt;NewStringUTF(env, (const char*)family[j]);
1364                 if (IS_NULL(jstr)) break;
1365                 (*env)-&gt;SetObjectField(env, fcFont, familyNameID, jstr);
1366                 (*env)-&gt;DeleteLocalRef(env, jstr);
1367                 if (file[j] != NULL) {
1368                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)file[j]);
1369                     if (IS_NULL(jstr)) break;
1370                     (*env)-&gt;SetObjectField(env, fcFont, fontFileID, jstr);
1371                     (*env)-&gt;DeleteLocalRef(env, jstr);
1372                 }
1373                 if (styleStr[j] != NULL) {
1374                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)styleStr[j]);
1375                     if (IS_NULL(jstr)) break;
1376                     (*env)-&gt;SetObjectField(env, fcFont, styleNameID, jstr);
1377                     (*env)-&gt;DeleteLocalRef(env, jstr);
1378                 }
1379                 if (fullname[j] != NULL) {
1380                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)fullname[j]);
1381                     if (IS_NULL(jstr)) break;
1382                     (*env)-&gt;SetObjectField(env, fcFont, fullNameID, jstr);
1383                     (*env)-&gt;DeleteLocalRef(env, jstr);
1384                 }
1385                 if (fn==0) {
1386                     (*env)-&gt;SetObjectField(env, fcCompFontObj,
1387                                            fcFirstFontID, fcFont);
1388                 }
1389                 if (includeFallbacks) {
1390                     (*env)-&gt;SetObjectArrayElement(env, fcFontArr, fn++,fcFont);
1391                 } else {
1392                     (*env)-&gt;DeleteLocalRef(env, fcFont);
1393                     break;
1394                 }
1395                 (*env)-&gt;DeleteLocalRef(env, fcFont);
1396             }
1397         }
1398         if (includeFallbacks) {
1399             (*env)-&gt;DeleteLocalRef(env, fcFontArr);
1400         }
1401         (*env)-&gt;DeleteLocalRef(env, fcCompFontObj);
1402         (*FcFontSetDestroy)(fontset);
1403         (*FcPatternDestroy)(pattern);
1404         free(family);
1405         free(styleStr);
1406         free(fullname);
1407         free(file);
1408     }
1409 
1410     /* release resources and close the &quot;.so&quot; */
1411 
1412     if (locale) {
1413         (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1414     }
1415     closeFontConfig(libfontconfig, JNI_TRUE);
1416 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
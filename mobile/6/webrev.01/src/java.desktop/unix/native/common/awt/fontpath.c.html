<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/unix/native/common/awt/fontpath.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #if defined(__linux__)
  27 #include &lt;string.h&gt;
  28 #endif /* __linux__ */
  29 #include &lt;stdio.h&gt;
  30 #include &lt;stdlib.h&gt;
  31 #include &lt;strings.h&gt;
  32 #include &lt;sys/types.h&gt;
  33 #include &lt;sys/stat.h&gt;
  34 #include &lt;sys/mman.h&gt;
  35 #include &lt;fcntl.h&gt;
  36 #include &lt;unistd.h&gt;
  37 
  38 #include &lt;jni.h&gt;
  39 #include &lt;jni_util.h&gt;
  40 #include &lt;jvm_md.h&gt;
  41 #include &lt;sizecalc.h&gt;
  42 #ifndef HEADLESS
  43 #include &lt;X11/Xlib.h&gt;
  44 #include &lt;awt.h&gt;
  45 #else
  46 /* locks ought to be included from awt.h */
  47 #define AWT_LOCK()
  48 #define AWT_UNLOCK()
  49 #endif /* !HEADLESS */
  50 
  51 #if defined(__linux__) &amp;&amp; !defined(MAP_FAILED)
  52 #define MAP_FAILED ((caddr_t)-1)
  53 #endif
  54 
  55 #ifndef HEADLESS
  56 extern Display *awt_display;
  57 #endif /* !HEADLESS */
  58 
  59 #define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME(&quot;fontconfig&quot;, &quot;1&quot;)
  60 #define FONTCONFIG_DLL JNI_LIB_NAME(&quot;fontconfig&quot;)
  61 
  62 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
  63 
  64 #if defined( __linux__)
  65 /* All the known interesting locations we have discovered on
  66  * various flavors of Linux
  67  */
  68 static char *fullLinuxFontPath[] = {
  69     &quot;/usr/X11R6/lib/X11/fonts/TrueType&quot;,  /* RH 7.1+ */
  70     &quot;/usr/X11R6/lib/X11/fonts/truetype&quot;,  /* SuSE */
  71     &quot;/usr/X11R6/lib/X11/fonts/tt&quot;,
  72     &quot;/usr/X11R6/lib/X11/fonts/TTF&quot;,
  73     &quot;/usr/X11R6/lib/X11/fonts/OTF&quot;,       /* RH 9.0 (but empty!) */
  74     &quot;/usr/share/fonts/ja/TrueType&quot;,       /* RH 7.2+ */
  75     &quot;/usr/share/fonts/truetype&quot;,
  76     &quot;/usr/share/fonts/ko/TrueType&quot;,       /* RH 9.0 */
  77     &quot;/usr/share/fonts/zh_CN/TrueType&quot;,    /* RH 9.0 */
  78     &quot;/usr/share/fonts/zh_TW/TrueType&quot;,    /* RH 9.0 */
  79     &quot;/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType&quot;, /* Debian */
  80     &quot;/usr/X11R6/lib/X11/fonts/Type1&quot;,
  81     &quot;/usr/share/fonts/default/Type1&quot;,     /* RH 9.0 */
  82     NULL, /* terminates the list */
  83 };
  84 #elif defined(_AIX)
  85 static char *fullAixFontPath[] = {
  86     &quot;/usr/lpp/X11/lib/X11/fonts/Type1&quot;,    /* from X11.fnt.iso_T1  */
  87     &quot;/usr/lpp/X11/lib/X11/fonts/TrueType&quot;, /* from X11.fnt.ucs.ttf */
  88     NULL, /* terminates the list */
  89 };
  90 #endif
  91 
  92 static char **getFontConfigLocations();
  93 
  94 typedef struct {
  95     const char *name[MAXFDIRS];
  96     int  num;
  97 } fDirRecord, *fDirRecordPtr;
  98 
  99 #ifndef HEADLESS
 100 
 101 /*
 102  * Returns True if display is local, False of it&#39;s remote.
 103  */
 104 jboolean isDisplayLocal(JNIEnv *env) {
 105     static jboolean isLocal = False;
 106     static jboolean isLocalSet = False;
 107     jboolean ret;
 108 
 109     if (! isLocalSet) {
 110       jclass geCls = (*env)-&gt;FindClass(env, &quot;java/awt/GraphicsEnvironment&quot;);
 111       CHECK_NULL_RETURN(geCls, JNI_FALSE);
 112       jmethodID getLocalGE = (*env)-&gt;GetStaticMethodID(env, geCls,
 113                                                  &quot;getLocalGraphicsEnvironment&quot;,
 114                                            &quot;()Ljava/awt/GraphicsEnvironment;&quot;);
 115       CHECK_NULL_RETURN(getLocalGE, JNI_FALSE);
 116       jobject ge = (*env)-&gt;CallStaticObjectMethod(env, geCls, getLocalGE);
 117       JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 118 
 119       jclass sgeCls = (*env)-&gt;FindClass(env,
 120                                         &quot;sun/java2d/SunGraphicsEnvironment&quot;);
 121       CHECK_NULL_RETURN(sgeCls, JNI_FALSE);
 122       if ((*env)-&gt;IsInstanceOf(env, ge, sgeCls)) {
 123         jmethodID isDisplayLocal = (*env)-&gt;GetMethodID(env, sgeCls,
 124                                                        &quot;isDisplayLocal&quot;,
 125                                                        &quot;()Z&quot;);
 126         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 127         isLocal = (*env)-&gt;CallBooleanMethod(env, ge, isDisplayLocal);
 128         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 129       } else {
 130         isLocal = True;
 131       }
 132       isLocalSet = True;
 133     }
 134 
 135     return isLocal;
 136 }
 137 
 138 static void AddFontsToX11FontPath ( fDirRecord *fDirP )
 139 {
 140     char *onePath;
 141     int index, nPaths;
 142     int origNumPaths, length;
 143     int origIndex;
 144     int totalDirCount;
 145     char  **origFontPath;
 146     char  **tempFontPath;
 147     int doNotAppend;
 148     int *appendDirList;
 149     char **newFontPath;
 150     int err, compareLength;
 151     char fontDirPath[512];
 152     int dirFile;
 153 
 154     doNotAppend = 0;
 155 
 156     if ( fDirP-&gt;num == 0 ) return;
 157 
 158     appendDirList = SAFE_SIZE_ARRAY_ALLOC(malloc, fDirP-&gt;num, sizeof ( int ));
 159     if ( appendDirList == NULL ) {
 160       return;  /* if it fails we cannot do much */
 161     }
 162 
 163     origFontPath = XGetFontPath ( awt_display, &amp;nPaths );
 164 
 165     totalDirCount = nPaths;
 166     origNumPaths = nPaths;
 167     tempFontPath = origFontPath;
 168 
 169 
 170     for (index = 0; index &lt; fDirP-&gt;num; index++ ) {
 171 
 172         doNotAppend = 0;
 173 
 174         tempFontPath = origFontPath;
 175         for ( origIndex = 0; origIndex &lt; nPaths; origIndex++ ) {
 176 
 177             onePath = *tempFontPath;
 178 
 179             compareLength = strlen ( onePath );
 180             if ( onePath[compareLength -1] == &#39;/&#39; )
 181               compareLength--;
 182 
 183             /* there is a slash at the end of every solaris X11 font path name */
 184             if ( strncmp ( onePath, fDirP-&gt;name[index], compareLength ) == 0 ) {
 185               doNotAppend = 1;
 186               break;
 187             }
 188             tempFontPath++;
 189         }
 190 
 191         appendDirList[index] = 0;
 192         if ( doNotAppend == 0 ) {
 193             snprintf(fontDirPath, sizeof(fontDirPath), &quot;%s/fonts.dir&quot;, fDirP-&gt;name[index]);
 194             fontDirPath[sizeof(fontDirPath) - 1] = &#39;\0&#39;;
 195             dirFile = open ( fontDirPath, O_RDONLY, 0 );
 196             if ( dirFile == -1 ) {
 197                 doNotAppend = 1;
 198             } else {
 199                close ( dirFile );
 200                totalDirCount++;
 201                appendDirList[index] = 1;
 202             }
 203         }
 204 
 205     }
 206 
 207     /* if no changes are required do not bother to do a setfontpath */
 208     if ( totalDirCount == nPaths ) {
 209       free ( ( void *) appendDirList );
 210       XFreeFontPath ( origFontPath );
 211       return;
 212     }
 213 
 214 
 215     newFontPath = SAFE_SIZE_ARRAY_ALLOC(malloc, totalDirCount, sizeof(char *));
 216     /* if it fails free things and get out */
 217     if ( newFontPath == NULL ) {
 218       free ( ( void *) appendDirList );
 219       XFreeFontPath ( origFontPath );
 220       return;
 221     }
 222 
 223     for ( origIndex = 0; origIndex &lt; nPaths; origIndex++ ) {
 224       onePath = origFontPath[origIndex];
 225       newFontPath[origIndex] = onePath;
 226     }
 227 
 228     /* now add the other font paths */
 229 
 230     for (index = 0; index &lt; fDirP-&gt;num; index++ ) {
 231 
 232       if ( appendDirList[index] == 1 ) {
 233 
 234         /* printf ( &quot;Appending %s\n&quot;, fDirP-&gt;name[index] ); */
 235 
 236         onePath = SAFE_SIZE_ARRAY_ALLOC(malloc, strlen (fDirP-&gt;name[index]) + 2, sizeof( char ) );
 237         if (onePath == NULL) {
 238             free ( ( void *) appendDirList );
 239 
 240             for ( index = origIndex; index &lt; nPaths; index++ ) {
 241                 free( newFontPath[index] );
 242             }
 243 
 244             free( ( void *) newFontPath);
 245             XFreeFontPath ( origFontPath );
 246             return;
 247         }
 248         strcpy ( onePath, fDirP-&gt;name[index] );
 249         strcat ( onePath, &quot;/&quot; );
 250         newFontPath[nPaths++] = onePath;
 251         /* printf ( &quot;The path to be appended is %s\n&quot;, onePath ); */
 252       }
 253     }
 254 
 255     /*   printf ( &quot;The dir count = %d\n&quot;, totalDirCount ); */
 256     free ( ( void *) appendDirList );
 257 
 258     XSetFontPath ( awt_display, newFontPath, totalDirCount );
 259 
 260         for ( index = origNumPaths; index &lt; totalDirCount; index++ ) {
 261                 free( newFontPath[index] );
 262     }
 263 
 264         free ( (void *) newFontPath );
 265     XFreeFontPath ( origFontPath );
 266     return;
 267 }
 268 #endif /* !HEADLESS */
 269 
 270 
 271 #ifndef HEADLESS
 272 static char **getX11FontPath ()
 273 {
 274     char **x11Path, **fontdirs;
 275     int i, pos, slen, nPaths, numDirs;
 276 
 277     x11Path = XGetFontPath (awt_display, &amp;nPaths);
 278 
 279     /* This isn&#39;t ever going to be perfect: the font path may contain
 280      * much we aren&#39;t interested in, but the cost should be moderate
 281      * Exclude all directories that contain the strings &quot;Speedo&quot;,&quot;/F3/&quot;,
 282      * &quot;75dpi&quot;, &quot;100dpi&quot;, &quot;misc&quot; or &quot;bitmap&quot;, or don&#39;t begin with a &quot;/&quot;,
 283      * the last of which should exclude font servers.
 284      * Also exclude the user specific &quot;.gnome*&quot; directories which
 285      * aren&#39;t going to contain the system fonts we need.
 286      * Hopefully we are left only with Type1 and TrueType directories.
 287      * It doesn&#39;t matter much if there are extraneous directories, it&#39;ll just
 288      * cost us a little wasted effort upstream.
 289      */
 290     fontdirs = (char**)calloc(nPaths+1, sizeof(char*));
 291     if (fontdirs == NULL) {
 292         return NULL;
 293     }
 294     pos = 0;
 295     for (i=0; i &lt; nPaths; i++) {
 296         if (x11Path[i][0] != &#39;/&#39;) {
 297             continue;
 298         }
 299         if (strstr(x11Path[i], &quot;/75dpi&quot;) != NULL) {
 300             continue;
 301         }
 302         if (strstr(x11Path[i], &quot;/100dpi&quot;) != NULL) {
 303             continue;
 304         }
 305         if (strstr(x11Path[i], &quot;/misc&quot;) != NULL) {
 306             continue;
 307         }
 308         if (strstr(x11Path[i], &quot;/Speedo&quot;) != NULL) {
 309             continue;
 310         }
 311         if (strstr(x11Path[i], &quot;.gnome&quot;) != NULL) {
 312             continue;
 313         }
 314         fontdirs[pos] = strdup(x11Path[i]);
 315         slen = strlen(fontdirs[pos]);
 316         if (slen &gt; 0 &amp;&amp; fontdirs[pos][slen-1] == &#39;/&#39;) {
 317             fontdirs[pos][slen-1] = &#39;\0&#39;; /* null out trailing &quot;/&quot;  */
 318         }
 319         pos++;
 320     }
 321 
 322     XFreeFontPath(x11Path);
 323     if (pos == 0) {
 324         free(fontdirs);
 325         fontdirs = NULL;
 326     }
 327     return fontdirs;
 328 }
 329 
 330 
 331 #endif /* !HEADLESS */
 332 
 333 #if defined(__linux__)
 334 /* from awt_LoadLibrary.c */
 335 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 336 #endif
 337 
 338 /* This eliminates duplicates, at a non-linear but acceptable cost
 339  * since the lists are expected to be reasonably short, and then
 340  * deletes references to non-existent directories, and returns
 341  * a single path consisting of unique font directories.
 342  */
 343 static char* mergePaths(char **p1, char **p2, char **p3, jboolean noType1) {
 344 
 345     int len1=0, len2=0, len3=0, totalLen=0, numDirs=0,
 346         currLen, i, j, found, pathLen=0;
 347     char **ptr, **fontdirs;
 348     char *fontPath = NULL;
 349 
 350     if (p1 != NULL) {
 351         ptr = p1;
 352         while (*ptr++ != NULL) len1++;
 353     }
 354     if (p2 != NULL) {
 355         ptr = p2;
 356 
 357         while (*ptr++ != NULL) len2++;
 358     }
 359     if (p3 != NULL) {
 360         ptr = p3;
 361         while (*ptr++ != NULL) len3++;
 362     }
 363     totalLen = len1+len2+len3;
 364     fontdirs = (char**)calloc(totalLen, sizeof(char*));
 365     if (fontdirs == NULL) {
 366         return NULL;
 367     }
 368 
 369     for (i=0; i &lt; len1; i++) {
 370         if (noType1 &amp;&amp; strstr(p1[i], &quot;Type1&quot;) != NULL) {
 371             continue;
 372         }
 373         fontdirs[numDirs++] = p1[i];
 374     }
 375 
 376     currLen = numDirs; /* only compare against previous path dirs */
 377     for (i=0; i &lt; len2; i++) {
 378         if (noType1 &amp;&amp; strstr(p2[i], &quot;Type1&quot;) != NULL) {
 379             continue;
 380         }
 381         found = 0;
 382         for (j=0; j &lt; currLen; j++) {
 383             if (strcmp(fontdirs[j], p2[i]) == 0) {
 384                 found = 1;
 385                 break;
 386             }
 387         }
 388         if (!found) {
 389            fontdirs[numDirs++] = p2[i];
 390         }
 391     }
 392 
 393     currLen = numDirs; /* only compare against previous path dirs */
 394     for (i=0; i &lt; len3; i++) {
 395         if (noType1 &amp;&amp; strstr(p3[i], &quot;Type1&quot;) != NULL) {
 396             continue;
 397         }
 398         found = 0;
 399         for (j=0; j &lt; currLen; j++) {
 400             if (strcmp(fontdirs[j], p3[i]) == 0) {
 401                 found = 1;
 402                 break;
 403             }
 404         }
 405         if (!found) {
 406            fontdirs[numDirs++] = p3[i];
 407         }
 408     }
 409 
 410     /* Now fontdirs contains unique dirs and numDirs records how many.
 411      * What we don&#39;t know is if they all exist. On reflection I think
 412      * this isn&#39;t an issue, so for now I will return all these locations,
 413      * converted to one string */
 414     for (i=0; i&lt;numDirs; i++) {
 415         pathLen += (strlen(fontdirs[i]) + 1);
 416     }
 417     if (pathLen &gt; 0 &amp;&amp; (fontPath = malloc(pathLen))) {
 418         *fontPath = &#39;\0&#39;;
 419         for (i = 0; i&lt;numDirs; i++) {
 420             if (i != 0) {
 421                 strcat(fontPath, &quot;:&quot;);
 422             }
 423             strcat(fontPath, fontdirs[i]);
 424         }
 425     }
 426     free (fontdirs);
 427 
 428     return fontPath;
 429 }
 430 
 431 /*
 432  * The goal of this function is to find all &quot;system&quot; fonts which
 433  * are needed by the JRE to display text in supported locales etc, and
 434  * to support APIs which allow users to enumerate all system fonts and use
 435  * them from their Java applications.
 436  * The preferred mechanism is now using the new &quot;fontconfig&quot; library
 437  * This exists on newer versions of Linux and Solaris (S10 and above)
 438  * The library is dynamically located. The results are merged with
 439  * a set of &quot;known&quot; locations and with the X11 font path, if running in
 440  * a local X11 environment.
 441  * The hardwired paths are built into the JDK binary so as new font locations
 442  * are created on a host plaform for them to be located by the JRE they will
 443  * need to be added ito the host&#39;s font configuration database, typically
 444  * /etc/fonts/local.conf, and to ensure that directory contains a fonts.dir
 445  * NB: Fontconfig also depends heavily for performance on the host O/S
 446  * maintaining up to date caches.
 447  * This is consistent with the requirements of the desktop environments
 448  * on these OSes.
 449  * This also frees us from X11 APIs as JRE is required to function in
 450  * a &quot;headless&quot; mode where there is no Xserver.
 451  */
 452 static char *getPlatformFontPathChars(JNIEnv *env, jboolean noType1, jboolean isX11) {
 453 
 454     char **fcdirs = NULL, **x11dirs = NULL, **knowndirs = NULL, *path = NULL;
 455 
 456     /* As of 1.5 we try to use fontconfig on both Solaris and Linux.
 457      * If its not available NULL is returned.
 458      */
 459     fcdirs = getFontConfigLocations();
 460 
 461 #if defined(__linux__)
 462     knowndirs = fullLinuxFontPath;
 463 #elif defined(_AIX)
 464     knowndirs = fullAixFontPath;
 465 #endif
 466     /* REMIND: this code requires to be executed when the GraphicsEnvironment
 467      * is already initialised. That is always true, but if it were not so,
 468      * this code could throw an exception and the fontpath would fail to
 469      * be initialised.
 470      */
 471 #ifndef HEADLESS
 472     if (isX11) { // The following only works in an x11 environment.
 473 #if defined(__linux__)
 474     /* There&#39;s no headless build on linux ... */
 475     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 476 #endif
 477       /* Using the X11 font path to locate font files is now a fallback
 478        * useful only if fontconfig failed, or is incomplete. So we could
 479        * remove this code completely and the consequences should be rare
 480        * and non-fatal. If this happens, then the calling Java code can
 481        * be modified to no longer require that the AWT lock (the X11GE)
 482        * be initialised prior to calling this code.
 483        */
 484     AWT_LOCK();
 485     if (isDisplayLocal(env)) {
 486         x11dirs = getX11FontPath();
 487     }
 488     AWT_UNLOCK();
 489 #if defined(__linux__)
 490     }
 491 #endif
 492     }
 493 #endif /* !HEADLESS */
 494     path = mergePaths(fcdirs, x11dirs, knowndirs, noType1);
 495     if (fcdirs != NULL) {
 496         char **p = fcdirs;
 497         while (*p != NULL)  free(*p++);
 498         free(fcdirs);
 499     }
 500 
 501     if (x11dirs != NULL) {
 502         char **p = x11dirs;
 503         while (*p != NULL) free(*p++);
 504         free(x11dirs);
 505     }
 506 
 507     return path;
 508 }
 509 
 510 JNIEXPORT jstring JNICALL Java_sun_awt_FcFontManager_getFontPathNative
 511 (JNIEnv *env, jobject thiz, jboolean noType1, jboolean isX11) {
 512     jstring ret;
 513     static char *ptr = NULL; /* retain result across calls */
 514 
 515     if (ptr == NULL) {
 516         ptr = getPlatformFontPathChars(env, noType1, isX11);
 517     }
 518     ret = (*env)-&gt;NewStringUTF(env, ptr);
 519     return ret;
 520 }
 521 
 522 #include &lt;dlfcn.h&gt;
 523 
 524 #include &lt;fontconfig/fontconfig.h&gt;
 525 
 526 
 527 static void* openFontConfig() {
 528 
 529     char *homeEnv;
 530     static char *homeEnvStr = &quot;HOME=&quot;; /* must be static */
 531     void* libfontconfig = NULL;
 532 
 533     /* Private workaround to not use fontconfig library.
 534      * May be useful during testing/debugging
 535      */
 536     char *useFC = getenv(&quot;USE_J2D_FONTCONFIG&quot;);
 537     if (useFC != NULL &amp;&amp; !strcmp(useFC, &quot;no&quot;)) {
 538         return NULL;
 539     }
 540 
 541 #if defined(_AIX)
 542     /* On AIX, fontconfig is not a standard package supported by IBM.
 543      * instead it has to be installed from the &quot;AIX Toolbox for Linux Applications&quot;
 544      * site http://www-03.ibm.com/systems/power/software/aix/linux/toolbox/alpha.html
 545      * and will be installed under /opt/freeware/lib/libfontconfig.a.
 546      * Notice that the archive contains the real 32- and 64-bit shared libraries.
 547      * We first try to load &#39;libfontconfig.so&#39; from the default library path in the
 548      * case the user has installed a private version of the library and if that
 549      * doesn&#39;t succeed, we try the version from /opt/freeware/lib/libfontconfig.a
 550      */
 551     libfontconfig = dlopen(&quot;libfontconfig.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 552     if (libfontconfig == NULL) {
 553         libfontconfig = dlopen(&quot;/opt/freeware/lib/libfontconfig.a(libfontconfig.so.1)&quot;, RTLD_MEMBER|RTLD_LOCAL|RTLD_LAZY);
 554         if (libfontconfig == NULL) {
 555             return NULL;
 556         }
 557     }
 558 #else
 559     /* 64 bit sparc should pick up the right version from the lib path.
 560      * New features may be added to libfontconfig, this is expected to
 561      * be compatible with old features, but we may need to start
 562      * distinguishing the library version, to know whether to expect
 563      * certain symbols - and functionality - to be available.
 564      * Also add explicit search for .so.1 in case .so symlink doesn&#39;t exist.
 565      */
 566     libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
 567     if (libfontconfig == NULL) {
 568         libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
 569         if (libfontconfig == NULL) {
 570             return NULL;
 571         }
 572     }
 573 #endif
 574 
 575     /* Version 1.0 of libfontconfig crashes if HOME isn&#39;t defined in
 576      * the environment. This should generally never happen, but we can&#39;t
 577      * control it, and can&#39;t control the version of fontconfig, so iff
 578      * its not defined we set it to an empty value which is sufficient
 579      * to prevent a crash. I considered unsetting it before exit, but
 580      * it doesn&#39;t appear to work on Solaris, so I will leave it set.
 581      */
 582     homeEnv = getenv(&quot;HOME&quot;);
 583     if (homeEnv == NULL) {
 584         putenv(homeEnvStr);
 585     }
 586 
 587     return libfontconfig;
 588 }
 589 
 590 typedef void* (FcFiniFuncType)();
 591 
 592 static void closeFontConfig(void* libfontconfig, jboolean fcFini) {
 593 
 594   /* NB FcFini is not in (eg) the Solaris 10 version of fontconfig. Its not
 595    * clear if this means we are really leaking resources in those cases
 596    * but it seems we should call this function when its available.
 597    * But since the Swing GTK code may be still accessing the lib, its probably
 598    * safest for now to just let this &quot;leak&quot; rather than potentially
 599    * concurrently free global data still in use by other code.
 600    */
 601 #if 0
 602     if (fcFini) { /* release resources */
 603         FcFiniFuncType FcFini = (FcFiniFuncType)dlsym(libfontconfig, &quot;FcFini&quot;);
 604 
 605         if (FcFini != NULL) {
 606             (*FcFini)();
 607         }
 608     }
 609 #endif
 610     dlclose(libfontconfig);
 611 }
 612 
 613 typedef FcConfig* (*FcInitLoadConfigFuncType)();
 614 typedef FcPattern* (*FcPatternBuildFuncType)(FcPattern *orig, ...);
 615 typedef FcObjectSet* (*FcObjectSetFuncType)(const char *first, ...);
 616 typedef FcFontSet* (*FcFontListFuncType)(FcConfig *config,
 617                                          FcPattern *p,
 618                                          FcObjectSet *os);
 619 typedef FcResult (*FcPatternGetBoolFuncType)(const FcPattern *p,
 620                                                const char *object,
 621                                                int n,
 622                                                FcBool *b);
 623 typedef FcResult (*FcPatternGetIntegerFuncType)(const FcPattern *p,
 624                                                 const char *object,
 625                                                 int n,
 626                                                 int *i);
 627 typedef FcResult (*FcPatternGetStringFuncType)(const FcPattern *p,
 628                                                const char *object,
 629                                                int n,
 630                                                FcChar8 ** s);
 631 typedef FcChar8* (*FcStrDirnameFuncType)(const FcChar8 *file);
 632 typedef void (*FcPatternDestroyFuncType)(FcPattern *p);
 633 typedef void (*FcFontSetDestroyFuncType)(FcFontSet *s);
 634 typedef FcPattern* (*FcNameParseFuncType)(const FcChar8 *name);
 635 typedef FcBool (*FcPatternAddStringFuncType)(FcPattern *p,
 636                                              const char *object,
 637                                              const FcChar8 *s);
 638 typedef void (*FcDefaultSubstituteFuncType)(FcPattern *p);
 639 typedef FcBool (*FcConfigSubstituteFuncType)(FcConfig *config,
 640                                              FcPattern *p,
 641                                              FcMatchKind kind);
 642 typedef FcPattern* (*FcFontMatchFuncType)(FcConfig *config,
 643                                           FcPattern *p,
 644                                           FcResult *result);
 645 typedef FcFontSet* (*FcFontSetCreateFuncType)();
 646 typedef FcBool (*FcFontSetAddFuncType)(FcFontSet *s, FcPattern *font);
 647 
 648 typedef FcResult (*FcPatternGetCharSetFuncType)(FcPattern *p,
 649                                                 const char *object,
 650                                                 int n,
 651                                                 FcCharSet **c);
 652 typedef FcFontSet* (*FcFontSortFuncType)(FcConfig *config,
 653                                          FcPattern *p,
 654                                          FcBool trim,
 655                                          FcCharSet **csp,
 656                                          FcResult *result);
 657 typedef FcCharSet* (*FcCharSetUnionFuncType)(const FcCharSet *a,
 658                                              const FcCharSet *b);
 659 typedef FcChar32 (*FcCharSetSubtractCountFuncType)(const FcCharSet *a,
 660                                                    const FcCharSet *b);
 661 
 662 typedef int (*FcGetVersionFuncType)();
 663 
 664 typedef FcStrList* (*FcConfigGetCacheDirsFuncType)(FcConfig *config);
 665 typedef FcChar8* (*FcStrListNextFuncType)(FcStrList *list);
 666 typedef FcChar8* (*FcStrListDoneFuncType)(FcStrList *list);
 667 
 668 static char **getFontConfigLocations() {
 669 
 670     char **fontdirs;
 671     int numdirs = 0;
 672     FcInitLoadConfigFuncType FcInitLoadConfig;
 673     FcPatternBuildFuncType FcPatternBuild;
 674     FcObjectSetFuncType FcObjectSetBuild;
 675     FcFontListFuncType FcFontList;
 676     FcPatternGetStringFuncType FcPatternGetString;
 677     FcStrDirnameFuncType FcStrDirname;
 678     FcPatternDestroyFuncType FcPatternDestroy;
 679     FcFontSetDestroyFuncType FcFontSetDestroy;
 680 
 681     FcConfig *fontconfig;
 682     FcPattern *pattern;
 683     FcObjectSet *objset;
 684     FcFontSet *fontSet;
 685     FcStrList *strList;
 686     FcChar8 *str;
 687     int i, f, found, len=0;
 688     char **fontPath;
 689 
 690     void* libfontconfig = openFontConfig();
 691 
 692     if (libfontconfig == NULL) {
 693         return NULL;
 694     }
 695 
 696     FcPatternBuild     =
 697         (FcPatternBuildFuncType)dlsym(libfontconfig, &quot;FcPatternBuild&quot;);
 698     FcObjectSetBuild   =
 699         (FcObjectSetFuncType)dlsym(libfontconfig, &quot;FcObjectSetBuild&quot;);
 700     FcFontList         =
 701         (FcFontListFuncType)dlsym(libfontconfig, &quot;FcFontList&quot;);
 702     FcPatternGetString =
 703         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
 704     FcStrDirname       =
 705         (FcStrDirnameFuncType)dlsym(libfontconfig, &quot;FcStrDirname&quot;);
 706     FcPatternDestroy   =
 707         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
 708     FcFontSetDestroy   =
 709         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
 710 
 711     if (FcPatternBuild     == NULL ||
 712         FcObjectSetBuild   == NULL ||
 713         FcPatternGetString == NULL ||
 714         FcFontList         == NULL ||
 715         FcStrDirname       == NULL ||
 716         FcPatternDestroy   == NULL ||
 717         FcFontSetDestroy   == NULL) { /* problem with the library: return. */
 718         closeFontConfig(libfontconfig, JNI_FALSE);
 719         return NULL;
 720     }
 721 
 722     /* Make calls into the fontconfig library to build a search for
 723      * outline fonts, and to get the set of full file paths from the matches.
 724      * This set is returned from the call to FcFontList(..)
 725      * We allocate an array of char* pointers sufficient to hold all
 726      * the matches + 1 extra which ensures there will be a NULL after all
 727      * valid entries.
 728      * We call FcStrDirname strip the file name from the path, and
 729      * check if we have yet seen this directory. If not we add a pointer to
 730      * it into our array of char*. Note that FcStrDirname returns newly
 731      * allocated storage so we can use this in the return char** value.
 732      * Finally we clean up, freeing allocated resources, and return the
 733      * array of unique directories.
 734      */
 735     pattern = (*FcPatternBuild)(NULL, FC_OUTLINE, FcTypeBool, FcTrue, NULL);
 736     objset = (*FcObjectSetBuild)(FC_FILE, NULL);
 737     fontSet = (*FcFontList)(NULL, pattern, objset);
 738     if (fontSet == NULL) {
 739         /* FcFontList() may return NULL if fonts are not installed. */
 740         fontdirs = NULL;
 741     } else {
 742         fontdirs = (char**)calloc(fontSet-&gt;nfont+1, sizeof(char*));
 743         if (fontdirs == NULL) {
 744             (*FcFontSetDestroy)(fontSet);
 745             goto cleanup;
 746         }
 747         for (f=0; f &lt; fontSet-&gt;nfont; f++) {
 748             FcChar8 *file;
 749             FcChar8 *dir;
 750             if ((*FcPatternGetString)(fontSet-&gt;fonts[f], FC_FILE, 0, &amp;file) ==
 751                                       FcResultMatch) {
 752                 dir = (*FcStrDirname)(file);
 753                 found = 0;
 754                 for (i=0;i&lt;numdirs; i++) {
 755                     if (strcmp(fontdirs[i], (char*)dir) == 0) {
 756                         found = 1;
 757                         break;
 758                     }
 759                 }
 760                 if (!found) {
 761                     fontdirs[numdirs++] = (char*)dir;
 762                 } else {
 763                     free((char*)dir);
 764                 }
 765             }
 766         }
 767         /* Free fontset if one was returned */
 768         (*FcFontSetDestroy)(fontSet);
 769     }
 770 
 771 cleanup:
 772     /* Free memory and close the &quot;.so&quot; */
 773     (*FcPatternDestroy)(pattern);
 774     closeFontConfig(libfontconfig, JNI_TRUE);
 775     return fontdirs;
 776 }
 777 
 778 /* These are copied from sun.awt.SunHints.
 779  * Consider initialising them as ints using JNI for more robustness.
 780  */
 781 #define TEXT_AA_OFF 1
 782 #define TEXT_AA_ON  2
 783 #define TEXT_AA_LCD_HRGB 4
 784 #define TEXT_AA_LCD_HBGR 5
 785 #define TEXT_AA_LCD_VRGB 6
 786 #define TEXT_AA_LCD_VBGR 7
 787 
 788 JNIEXPORT jint JNICALL
 789 Java_sun_font_FontConfigManager_getFontConfigAASettings
 790 (JNIEnv *env, jclass obj, jstring localeStr, jstring fcNameStr) {
 791 
 792     FcNameParseFuncType FcNameParse;
 793     FcPatternAddStringFuncType FcPatternAddString;
 794     FcConfigSubstituteFuncType FcConfigSubstitute;
 795     FcDefaultSubstituteFuncType  FcDefaultSubstitute;
 796     FcFontMatchFuncType FcFontMatch;
 797     FcPatternGetBoolFuncType FcPatternGetBool;
 798     FcPatternGetIntegerFuncType FcPatternGetInteger;
 799     FcPatternDestroyFuncType FcPatternDestroy;
 800 
 801     FcPattern *pattern, *matchPattern;
 802     FcResult result;
 803     FcBool antialias = FcFalse;
 804     int rgba = 0;
 805     const char *locale=NULL, *fcName=NULL;
 806     void* libfontconfig;
 807 
 808     if (fcNameStr == NULL || localeStr == NULL) {
 809         return -1;
 810     }
 811 
 812     fcName = (*env)-&gt;GetStringUTFChars(env, fcNameStr, 0);
 813     if (fcName == NULL) {
 814         return -1;
 815     }
 816     locale = (*env)-&gt;GetStringUTFChars(env, localeStr, 0);
 817 
 818     if ((libfontconfig = openFontConfig()) == NULL) {
 819         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 820         if (locale) {
 821             (*env)-&gt;ReleaseStringUTFChars(env, localeStr,(const char*)locale);
 822         }
 823         return -1;
 824     }
 825 
 826     FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, &quot;FcNameParse&quot;);
 827     FcPatternAddString =
 828         (FcPatternAddStringFuncType)dlsym(libfontconfig, &quot;FcPatternAddString&quot;);
 829     FcConfigSubstitute =
 830         (FcConfigSubstituteFuncType)dlsym(libfontconfig, &quot;FcConfigSubstitute&quot;);
 831     FcDefaultSubstitute = (FcDefaultSubstituteFuncType)
 832         dlsym(libfontconfig, &quot;FcDefaultSubstitute&quot;);
 833     FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, &quot;FcFontMatch&quot;);
 834     FcPatternGetBool = (FcPatternGetBoolFuncType)
 835         dlsym(libfontconfig, &quot;FcPatternGetBool&quot;);
 836     FcPatternGetInteger = (FcPatternGetIntegerFuncType)
 837         dlsym(libfontconfig, &quot;FcPatternGetInteger&quot;);
 838     FcPatternDestroy =
 839         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
 840 
 841     if (FcNameParse          == NULL ||
 842         FcPatternAddString   == NULL ||
 843         FcConfigSubstitute   == NULL ||
 844         FcDefaultSubstitute  == NULL ||
 845         FcFontMatch          == NULL ||
 846         FcPatternGetBool     == NULL ||
 847         FcPatternGetInteger  == NULL ||
 848         FcPatternDestroy     == NULL) { /* problem with the library: return. */
 849 
 850         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 851         if (locale) {
 852             (*env)-&gt;ReleaseStringUTFChars(env, localeStr,(const char*)locale);
 853         }
 854         closeFontConfig(libfontconfig, JNI_FALSE);
 855         return -1;
 856     }
 857 
 858 
 859     pattern = (*FcNameParse)((FcChar8 *)fcName);
 860     if (locale != NULL) {
 861         (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);
 862     }
 863     (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);
 864     (*FcDefaultSubstitute)(pattern);
 865     matchPattern = (*FcFontMatch)(NULL, pattern, &amp;result);
 866     /* Perhaps should call FcFontRenderPrepare() here as some pattern
 867      * elements might change as a result of that call, but I&#39;m not seeing
 868      * any difference in testing.
 869      */
 870     if (matchPattern) {
 871         (*FcPatternGetBool)(matchPattern, FC_ANTIALIAS, 0, &amp;antialias);
 872         (*FcPatternGetInteger)(matchPattern, FC_RGBA, 0, &amp;rgba);
 873         (*FcPatternDestroy)(matchPattern);
 874     }
 875     (*FcPatternDestroy)(pattern);
 876 
 877     (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
 878     if (locale) {
 879         (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
 880     }
 881     closeFontConfig(libfontconfig, JNI_TRUE);
 882 
 883     if (antialias == FcFalse) {
 884         return TEXT_AA_OFF;
 885     } else if (rgba &lt;= FC_RGBA_UNKNOWN || rgba &gt;= FC_RGBA_NONE) {
 886         return TEXT_AA_ON;
 887     } else {
 888         switch (rgba) {
 889         case FC_RGBA_RGB : return TEXT_AA_LCD_HRGB;
 890         case FC_RGBA_BGR : return TEXT_AA_LCD_HBGR;
 891         case FC_RGBA_VRGB : return TEXT_AA_LCD_VRGB;
 892         case FC_RGBA_VBGR : return TEXT_AA_LCD_VBGR;
 893         default : return TEXT_AA_LCD_HRGB; // should not get here.
 894         }
 895     }
 896 }
 897 
 898 JNIEXPORT jint JNICALL
 899 Java_sun_font_FontConfigManager_getFontConfigVersion
 900     (JNIEnv *env, jclass obj) {
 901 
 902     void* libfontconfig;
 903     FcGetVersionFuncType FcGetVersion;
 904     int version = 0;
 905 
 906     if ((libfontconfig = openFontConfig()) == NULL) {
 907         return 0;
 908     }
 909 
 910     FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, &quot;FcGetVersion&quot;);
 911 
 912     if (FcGetVersion == NULL) {
 913         closeFontConfig(libfontconfig, JNI_FALSE);
 914         return 0;
 915     }
 916     version = (*FcGetVersion)();
 917     closeFontConfig(libfontconfig, JNI_FALSE);
 918 
 919     return version;
 920 }
 921 
 922 
 923 JNIEXPORT void JNICALL
 924 Java_sun_font_FontConfigManager_getFontConfig
 925 (JNIEnv *env, jclass obj, jstring localeStr, jobject fcInfoObj,
 926  jobjectArray fcCompFontArray,  jboolean includeFallbacks) {
 927 
 928     FcNameParseFuncType FcNameParse;
 929     FcPatternAddStringFuncType FcPatternAddString;
 930     FcConfigSubstituteFuncType FcConfigSubstitute;
 931     FcDefaultSubstituteFuncType  FcDefaultSubstitute;
 932     FcFontMatchFuncType FcFontMatch;
 933     FcPatternGetStringFuncType FcPatternGetString;
 934     FcPatternDestroyFuncType FcPatternDestroy;
 935     FcPatternGetCharSetFuncType FcPatternGetCharSet;
 936     FcFontSortFuncType FcFontSort;
 937     FcFontSetDestroyFuncType FcFontSetDestroy;
 938     FcCharSetUnionFuncType FcCharSetUnion;
 939     FcCharSetSubtractCountFuncType FcCharSetSubtractCount;
 940     FcGetVersionFuncType FcGetVersion;
 941     FcConfigGetCacheDirsFuncType FcConfigGetCacheDirs;
 942     FcStrListNextFuncType FcStrListNext;
 943     FcStrListDoneFuncType FcStrListDone;
 944 
 945     int i, arrlen;
 946     jobject fcCompFontObj;
 947     jstring fcNameStr, jstr;
 948     const char *locale, *fcName;
 949     FcPattern *pattern;
 950     FcResult result;
 951     void* libfontconfig;
 952     jfieldID fcNameID, fcFirstFontID, fcAllFontsID, fcVersionID, fcCacheDirsID;
 953     jfieldID familyNameID, styleNameID, fullNameID, fontFileID;
 954     jmethodID fcFontCons;
 955     char* debugMinGlyphsStr = getenv(&quot;J2D_DEBUG_MIN_GLYPHS&quot;);
 956     jclass fcInfoClass;
 957     jclass fcCompFontClass;
 958     jclass fcFontClass;
 959 
 960     CHECK_NULL(fcInfoObj);
 961     CHECK_NULL(fcCompFontArray);
 962 
 963     fcInfoClass =
 964         (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FontConfigInfo&quot;);
 965     CHECK_NULL(fcInfoClass);
 966     fcCompFontClass =
 967         (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FcCompFont&quot;);
 968     CHECK_NULL(fcCompFontClass);
 969     fcFontClass =
 970          (*env)-&gt;FindClass(env, &quot;sun/font/FontConfigManager$FontConfigFont&quot;);
 971     CHECK_NULL(fcFontClass);
 972 
 973 
 974     CHECK_NULL(fcVersionID = (*env)-&gt;GetFieldID(env, fcInfoClass, &quot;fcVersion&quot;, &quot;I&quot;));
 975     CHECK_NULL(fcCacheDirsID = (*env)-&gt;GetFieldID(env, fcInfoClass, &quot;cacheDirs&quot;,
 976                                                   &quot;[Ljava/lang/String;&quot;));
 977     CHECK_NULL(fcNameID = (*env)-&gt;GetFieldID(env, fcCompFontClass,
 978                                              &quot;fcName&quot;, &quot;Ljava/lang/String;&quot;));
 979     CHECK_NULL(fcFirstFontID = (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;firstFont&quot;,
 980                                         &quot;Lsun/font/FontConfigManager$FontConfigFont;&quot;));
 981     CHECK_NULL(fcAllFontsID = (*env)-&gt;GetFieldID(env, fcCompFontClass, &quot;allFonts&quot;,
 982                                         &quot;[Lsun/font/FontConfigManager$FontConfigFont;&quot;));
 983     CHECK_NULL(fcFontCons = (*env)-&gt;GetMethodID(env, fcFontClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;));
 984     CHECK_NULL(familyNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
 985                                       &quot;familyName&quot;, &quot;Ljava/lang/String;&quot;));
 986     CHECK_NULL(styleNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
 987                                     &quot;styleStr&quot;, &quot;Ljava/lang/String;&quot;));
 988     CHECK_NULL(fullNameID = (*env)-&gt;GetFieldID(env, fcFontClass,
 989                                     &quot;fullName&quot;, &quot;Ljava/lang/String;&quot;));
 990     CHECK_NULL(fontFileID = (*env)-&gt;GetFieldID(env, fcFontClass,
 991                                     &quot;fontFile&quot;, &quot;Ljava/lang/String;&quot;));
 992 
 993     if ((libfontconfig = openFontConfig()) == NULL) {
 994         return;
 995     }
 996 
 997     FcNameParse = (FcNameParseFuncType)dlsym(libfontconfig, &quot;FcNameParse&quot;);
 998     FcPatternAddString =
 999         (FcPatternAddStringFuncType)dlsym(libfontconfig, &quot;FcPatternAddString&quot;);
1000     FcConfigSubstitute =
1001         (FcConfigSubstituteFuncType)dlsym(libfontconfig, &quot;FcConfigSubstitute&quot;);
1002     FcDefaultSubstitute = (FcDefaultSubstituteFuncType)
1003         dlsym(libfontconfig, &quot;FcDefaultSubstitute&quot;);
1004     FcFontMatch = (FcFontMatchFuncType)dlsym(libfontconfig, &quot;FcFontMatch&quot;);
1005     FcPatternGetString =
1006         (FcPatternGetStringFuncType)dlsym(libfontconfig, &quot;FcPatternGetString&quot;);
1007     FcPatternDestroy =
1008         (FcPatternDestroyFuncType)dlsym(libfontconfig, &quot;FcPatternDestroy&quot;);
1009     FcPatternGetCharSet =
1010         (FcPatternGetCharSetFuncType)dlsym(libfontconfig,
1011                                            &quot;FcPatternGetCharSet&quot;);
1012     FcFontSort =
1013         (FcFontSortFuncType)dlsym(libfontconfig, &quot;FcFontSort&quot;);
1014     FcFontSetDestroy =
1015         (FcFontSetDestroyFuncType)dlsym(libfontconfig, &quot;FcFontSetDestroy&quot;);
1016     FcCharSetUnion =
1017         (FcCharSetUnionFuncType)dlsym(libfontconfig, &quot;FcCharSetUnion&quot;);
1018     FcCharSetSubtractCount =
1019         (FcCharSetSubtractCountFuncType)dlsym(libfontconfig,
1020                                               &quot;FcCharSetSubtractCount&quot;);
1021     FcGetVersion = (FcGetVersionFuncType)dlsym(libfontconfig, &quot;FcGetVersion&quot;);
1022 
1023     if (FcNameParse          == NULL ||
1024         FcPatternAddString   == NULL ||
1025         FcConfigSubstitute   == NULL ||
1026         FcDefaultSubstitute  == NULL ||
1027         FcFontMatch          == NULL ||
1028         FcPatternGetString   == NULL ||
1029         FcPatternDestroy     == NULL ||
1030         FcPatternGetCharSet  == NULL ||
1031         FcFontSetDestroy     == NULL ||
1032         FcCharSetUnion       == NULL ||
1033         FcGetVersion         == NULL ||
1034         FcCharSetSubtractCount == NULL) {/* problem with the library: return.*/
1035         closeFontConfig(libfontconfig, JNI_FALSE);
1036         return;
1037     }
1038 
1039     (*env)-&gt;SetIntField(env, fcInfoObj, fcVersionID, (*FcGetVersion)());
1040 
1041     /* Optionally get the cache dir locations. This isn&#39;t
1042      * available until v 2.4.x, but this is OK since on those later versions
1043      * we can check the time stamps on the cache dirs to see if we
1044      * are out of date. There are a couple of assumptions here. First
1045      * that the time stamp on the directory changes when the contents are
1046      * updated. Secondly that the locations don&#39;t change. The latter is
1047      * most likely if a new version of fontconfig is installed, but we also
1048      * invalidate the cache if we detect that. Arguably even that is &quot;rare&quot;,
1049      * and most likely is tied to an OS upgrade which gets a new file anyway.
1050      */
1051     FcConfigGetCacheDirs =
1052         (FcConfigGetCacheDirsFuncType)dlsym(libfontconfig,
1053                                             &quot;FcConfigGetCacheDirs&quot;);
1054     FcStrListNext =
1055         (FcStrListNextFuncType)dlsym(libfontconfig, &quot;FcStrListNext&quot;);
1056     FcStrListDone =
1057         (FcStrListDoneFuncType)dlsym(libfontconfig, &quot;FcStrListDone&quot;);
1058     if (FcStrListNext != NULL &amp;&amp; FcStrListDone != NULL &amp;&amp;
1059         FcConfigGetCacheDirs != NULL) {
1060 
1061         FcStrList* cacheDirs;
1062         FcChar8* cacheDir;
1063         int cnt = 0;
1064         jobject cacheDirArray =
1065             (*env)-&gt;GetObjectField(env, fcInfoObj, fcCacheDirsID);
1066         int max = (*env)-&gt;GetArrayLength(env, cacheDirArray);
1067 
1068         cacheDirs = (*FcConfigGetCacheDirs)(NULL);
1069         if (cacheDirs != NULL) {
1070             while ((cnt &lt; max) &amp;&amp; (cacheDir = (*FcStrListNext)(cacheDirs))) {
1071                 jstr = (*env)-&gt;NewStringUTF(env, (const char*)cacheDir);
1072                 JNU_CHECK_EXCEPTION(env);
1073 
1074                 (*env)-&gt;SetObjectArrayElement(env, cacheDirArray, cnt++, jstr);
1075                 (*env)-&gt;DeleteLocalRef(env, jstr);
1076             }
1077             (*FcStrListDone)(cacheDirs);
1078         }
1079     }
1080 
1081     locale = (*env)-&gt;GetStringUTFChars(env, localeStr, 0);
1082     if (locale == NULL) {
1083         (*env)-&gt;ExceptionClear(env);
1084         JNU_ThrowOutOfMemoryError(env, &quot;Could not create locale&quot;);
1085         return;
1086     }
1087 
1088     arrlen = (*env)-&gt;GetArrayLength(env, fcCompFontArray);
1089     for (i=0; i&lt;arrlen; i++) {
1090         FcFontSet* fontset;
1091         int fn, j, fontCount, nfonts;
1092         unsigned int minGlyphs;
1093         FcChar8 **family, **styleStr, **fullname, **file;
1094         jarray fcFontArr = NULL;
1095         FcCharSet *unionCharset = NULL;
1096 
1097         fcCompFontObj = (*env)-&gt;GetObjectArrayElement(env, fcCompFontArray, i);
1098         fcNameStr =
1099             (jstring)((*env)-&gt;GetObjectField(env, fcCompFontObj, fcNameID));
1100         fcName = (*env)-&gt;GetStringUTFChars(env, fcNameStr, 0);
1101         if (fcName == NULL) {
1102             (*env)-&gt;DeleteLocalRef(env, fcCompFontObj);
1103             (*env)-&gt;DeleteLocalRef(env, fcNameStr);
1104             continue;
1105         }
1106         pattern = (*FcNameParse)((FcChar8 *)fcName);
1107         (*env)-&gt;ReleaseStringUTFChars(env, fcNameStr, (const char*)fcName);
1108         (*env)-&gt;DeleteLocalRef(env, fcNameStr);
1109         if (pattern == NULL) {
1110             closeFontConfig(libfontconfig, JNI_FALSE);
1111             if (locale) {
1112                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1113             }
1114             return;
1115         }
1116 
1117         /* locale may not usually be necessary as fontconfig appears to apply
1118          * this anyway based on the user&#39;s environment. However we want
1119          * to use the value of the JDK startup locale so this should take
1120          * care of it.
1121          */
1122         if (locale != NULL) {
1123             (*FcPatternAddString)(pattern, FC_LANG, (unsigned char*)locale);
1124         }
1125         (*FcConfigSubstitute)(NULL, pattern, FcMatchPattern);
1126         (*FcDefaultSubstitute)(pattern);
1127         fontset = (*FcFontSort)(NULL, pattern, FcTrue, NULL, &amp;result);
1128         if (fontset == NULL) {
1129             (*FcPatternDestroy)(pattern);
1130             closeFontConfig(libfontconfig, JNI_FALSE);
1131             if (locale) {
1132                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1133             }
1134             return;
1135         }
1136 
1137         /* fontconfig returned us &quot;nfonts&quot;. If we are just getting the
1138          * first font, we set nfont to zero. Otherwise we use &quot;nfonts&quot;.
1139          * Next create separate C arrrays of length nfonts for family file etc.
1140          * Inspect the returned fonts and the ones we like (adds enough glyphs)
1141          * are added to the arrays and we increment &#39;fontCount&#39;.
1142          */
1143         nfonts = fontset-&gt;nfont;
1144         family   = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1145         styleStr = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1146         fullname = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1147         file     = (FcChar8**)calloc(nfonts, sizeof(FcChar8*));
1148         if (family == NULL || styleStr == NULL ||
1149             fullname == NULL || file == NULL) {
1150             if (family != NULL) {
1151                 free(family);
1152             }
1153             if (styleStr != NULL) {
1154                 free(styleStr);
1155             }
1156             if (fullname != NULL) {
1157                 free(fullname);
1158             }
1159             if (file != NULL) {
1160                 free(file);
1161             }
1162             (*FcPatternDestroy)(pattern);
1163             (*FcFontSetDestroy)(fontset);
1164             closeFontConfig(libfontconfig, JNI_FALSE);
1165             if (locale) {
1166                 (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1167             }
1168             return;
1169         }
1170         fontCount = 0;
1171         minGlyphs = 20;
1172         if (debugMinGlyphsStr != NULL) {
1173             int val = minGlyphs;
1174             sscanf(debugMinGlyphsStr, &quot;%5d&quot;, &amp;val);
1175             if (val &gt;= 0 &amp;&amp; val &lt;= 65536) {
1176                 minGlyphs = val;
1177             }
1178         }
1179 
1180         for (j=0; j&lt;nfonts; j++) {
1181             FcPattern *fontPattern = fontset-&gt;fonts[j];
1182             FcChar8 *fontformat;
1183             FcCharSet *charset = NULL;
1184 
1185             fontformat = NULL;
1186             (*FcPatternGetString)(fontPattern, FC_FONTFORMAT, 0, &amp;fontformat);
1187             /* We only want TrueType fonts but some Linuxes still depend
1188              * on Type 1 fonts for some Locale support, so we&#39;ll allow
1189              * them there.
1190              */
1191             if (fontformat != NULL
1192                 &amp;&amp; (strcmp((char*)fontformat, &quot;TrueType&quot;) != 0)
1193 #if defined(__linux__) || defined(_AIX)
1194                 &amp;&amp; (strcmp((char*)fontformat, &quot;Type 1&quot;) != 0)
1195                 &amp;&amp; (strcmp((char*)fontformat, &quot;CFF&quot;) != 0)
1196 #endif
1197              ) {
1198                 continue;
1199             }
1200             result = (*FcPatternGetCharSet)(fontPattern,
1201                                             FC_CHARSET, 0, &amp;charset);
1202             if (result != FcResultMatch) {
1203                 free(family);
1204                 free(fullname);
1205                 free(styleStr);
1206                 free(file);
1207                 (*FcPatternDestroy)(pattern);
1208                 (*FcFontSetDestroy)(fontset);
1209                 closeFontConfig(libfontconfig, JNI_FALSE);
1210                 if (locale) {
1211                     (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1212                 }
1213                 return;
1214             }
1215 
1216             /* We don&#39;t want 20 or 30 fonts, so once we hit 10 fonts,
1217              * then require that they really be adding value. Too many
1218              * adversely affects load time for minimal value-add.
1219              * This is still likely far more than we&#39;ve had in the past.
1220              */
1221             if (j==10) {
1222                 minGlyphs = 50;
1223             }
1224             if (unionCharset == NULL) {
1225                 unionCharset = charset;
1226             } else {
1227                 if ((*FcCharSetSubtractCount)(charset, unionCharset)
1228                     &gt; minGlyphs) {
1229                     unionCharset = (* FcCharSetUnion)(unionCharset, charset);
1230                 } else {
1231                     continue;
1232                 }
1233             }
1234 
1235             fontCount++; // found a font we will use.
1236             (*FcPatternGetString)(fontPattern, FC_FILE, 0, &amp;file[j]);
1237             (*FcPatternGetString)(fontPattern, FC_FAMILY, 0, &amp;family[j]);
1238             (*FcPatternGetString)(fontPattern, FC_STYLE, 0, &amp;styleStr[j]);
1239             (*FcPatternGetString)(fontPattern, FC_FULLNAME, 0, &amp;fullname[j]);
1240             if (!includeFallbacks) {
1241                 break;
1242             }
1243             if (fontCount == 254) {
1244                 break; // CompositeFont will only use up to 254 slots from here.
1245             }
1246         }
1247 
1248         /* Once we get here &#39;fontCount&#39; is the number of returned fonts
1249          * we actually want to use, so we create &#39;fcFontArr&#39; of that length.
1250          * The non-null entries of &quot;family[]&quot; etc are those fonts.
1251          * Then loop again over all nfonts adding just those non-null ones
1252          * to &#39;fcFontArr&#39;. If its null (we didn&#39;t want the font)
1253          * then we don&#39;t enter the main body.
1254          * So we should never get more than &#39;fontCount&#39; entries.
1255          */
1256         if (includeFallbacks) {
1257             fcFontArr =
1258                 (*env)-&gt;NewObjectArray(env, fontCount, fcFontClass, NULL);
1259             if (IS_NULL(fcFontArr)) {
1260                 free(family);
1261                 free(fullname);
1262                 free(styleStr);
1263                 free(file);
1264                 (*FcPatternDestroy)(pattern);
1265                 (*FcFontSetDestroy)(fontset);
1266                 closeFontConfig(libfontconfig, JNI_FALSE);
1267                 if (locale) {
1268                     (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1269                 }
1270                 return;
1271             }
1272             (*env)-&gt;SetObjectField(env,fcCompFontObj, fcAllFontsID, fcFontArr);
1273         }
1274         fn=0;
1275 
1276         for (j=0;j&lt;nfonts;j++) {
1277             if (family[j] != NULL) {
1278                 jobject fcFont =
1279                     (*env)-&gt;NewObject(env, fcFontClass, fcFontCons);
1280                 if (IS_NULL(fcFont)) break;
1281                 jstr = (*env)-&gt;NewStringUTF(env, (const char*)family[j]);
1282                 if (IS_NULL(jstr)) break;
1283                 (*env)-&gt;SetObjectField(env, fcFont, familyNameID, jstr);
1284                 (*env)-&gt;DeleteLocalRef(env, jstr);
1285                 if (file[j] != NULL) {
1286                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)file[j]);
1287                     if (IS_NULL(jstr)) break;
1288                     (*env)-&gt;SetObjectField(env, fcFont, fontFileID, jstr);
1289                     (*env)-&gt;DeleteLocalRef(env, jstr);
1290                 }
1291                 if (styleStr[j] != NULL) {
1292                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)styleStr[j]);
1293                     if (IS_NULL(jstr)) break;
1294                     (*env)-&gt;SetObjectField(env, fcFont, styleNameID, jstr);
1295                     (*env)-&gt;DeleteLocalRef(env, jstr);
1296                 }
1297                 if (fullname[j] != NULL) {
1298                     jstr = (*env)-&gt;NewStringUTF(env, (const char*)fullname[j]);
1299                     if (IS_NULL(jstr)) break;
1300                     (*env)-&gt;SetObjectField(env, fcFont, fullNameID, jstr);
1301                     (*env)-&gt;DeleteLocalRef(env, jstr);
1302                 }
1303                 if (fn==0) {
1304                     (*env)-&gt;SetObjectField(env, fcCompFontObj,
1305                                            fcFirstFontID, fcFont);
1306                 }
1307                 if (includeFallbacks) {
1308                     (*env)-&gt;SetObjectArrayElement(env, fcFontArr, fn++,fcFont);
1309                 } else {
1310                     (*env)-&gt;DeleteLocalRef(env, fcFont);
1311                     break;
1312                 }
1313                 (*env)-&gt;DeleteLocalRef(env, fcFont);
1314             }
1315         }
1316         if (includeFallbacks) {
1317             (*env)-&gt;DeleteLocalRef(env, fcFontArr);
1318         }
1319         (*env)-&gt;DeleteLocalRef(env, fcCompFontObj);
1320         (*FcFontSetDestroy)(fontset);
1321         (*FcPatternDestroy)(pattern);
1322         free(family);
1323         free(styleStr);
1324         free(fullname);
1325         free(file);
1326     }
1327 
1328     /* release resources and close the &quot;.so&quot; */
1329 
1330     if (locale) {
1331         (*env)-&gt;ReleaseStringUTFChars(env, localeStr, (const char*)locale);
1332     }
1333     closeFontConfig(libfontconfig, JNI_TRUE);
1334 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/native/libawt/windows/awt_Toolkit.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #define _JNI_IMPLEMENTATION_
  27 
  28 #include &quot;awt.h&quot;
  29 #include &lt;signal.h&gt;
  30 #include &lt;windowsx.h&gt;
  31 #include &lt;process.h&gt;
  32 #include &lt;shellapi.h&gt;
  33 #include &lt;shlwapi.h&gt;
  34 
  35 #include &quot;awt_DrawingSurface.h&quot;
  36 #include &quot;awt_AWTEvent.h&quot;
  37 #include &quot;awt_Component.h&quot;
  38 #include &quot;awt_Canvas.h&quot;
  39 #include &quot;awt_Clipboard.h&quot;
  40 #include &quot;awt_Frame.h&quot;
  41 #include &quot;awt_Dialog.h&quot;
  42 #include &quot;awt_Font.h&quot;
  43 #include &quot;awt_Cursor.h&quot;
  44 #include &quot;awt_InputEvent.h&quot;
  45 #include &quot;awt_KeyEvent.h&quot;
  46 #include &quot;awt_List.h&quot;
  47 #include &quot;awt_Palette.h&quot;
  48 #include &quot;awt_PopupMenu.h&quot;
  49 #include &quot;awt_Toolkit.h&quot;
  50 #include &quot;awt_DesktopProperties.h&quot;
  51 #include &quot;awt_FileDialog.h&quot;
  52 #include &quot;CmdIDList.h&quot;
  53 #include &quot;awt_new.h&quot;
  54 #include &quot;debug_trace.h&quot;
  55 #include &quot;debug_mem.h&quot;
  56 
  57 #include &quot;ComCtl32Util.h&quot;
  58 #include &quot;DllUtil.h&quot;
  59 
  60 #include &quot;D3DPipelineManager.h&quot;
  61 
  62 #include &lt;awt_DnDDT.h&gt;
  63 #include &lt;awt_DnDDS.h&gt;
  64 
  65 #include &lt;java_awt_Toolkit.h&gt;
  66 #include &lt;java_awt_event_InputMethodEvent.h&gt;
  67 
  68 extern void initScreens(JNIEnv *env);
  69 extern &quot;C&quot; void awt_dnd_initialize();
  70 extern &quot;C&quot; void awt_dnd_uninitialize();
  71 extern &quot;C&quot; void awt_clipboard_uninitialize(JNIEnv *env);
  72 extern &quot;C&quot; BOOL g_bUserHasChangedInputLang;
  73 
  74 extern CriticalSection windowMoveLock;
  75 extern BOOL windowMoveLockHeld;
  76 
  77 // Needed by JAWT: see awt_DrawingSurface.cpp.
  78 extern jclass jawtVImgClass;
  79 extern jclass jawtVSMgrClass;
  80 extern jclass jawtComponentClass;
  81 extern jfieldID jawtPDataID;
  82 extern jfieldID jawtSDataID;
  83 extern jfieldID jawtSMgrID;
  84 
  85 jobject reasonUnspecified;
  86 jobject reasonConsole;
  87 jobject reasonRemote;
  88 jobject reasonLock;
  89 
  90 extern jobject GetStaticObject(JNIEnv *env, jclass wfClass, const char *fieldName,
  91                         const char *signature);
  92 
  93 extern BOOL isSuddenTerminationEnabled;
  94 
  95 extern void DWMResetCompositionEnabled();
  96 
  97 /************************************************************************
  98  * Utilities
  99  */
 100 
 101 /* Initialize the Java VM instance variable when the library is
 102    first loaded */
 103 JavaVM *jvm = NULL;
 104 
 105 JNIEXPORT jint JNICALL
 106 DEF_JNI_OnLoad(JavaVM *vm, void *reserved)
 107 {
 108     TRY;
 109 
 110     jvm = vm;
 111     return JNI_VERSION_1_2;
 112 
 113     CATCH_BAD_ALLOC_RET(0);
 114 }
 115 
 116 extern &quot;C&quot; JNIEXPORT jboolean JNICALL AWTIsHeadless() {
 117     static JNIEnv *env = NULL;
 118     static jboolean isHeadless;
 119     jmethodID headlessFn;
 120     jclass graphicsEnvClass;
 121 
 122     if (env == NULL) {
 123         env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 124         graphicsEnvClass = env-&gt;FindClass(
 125             &quot;java/awt/GraphicsEnvironment&quot;);
 126         if (graphicsEnvClass == NULL) {
 127             return JNI_TRUE;
 128         }
 129         headlessFn = env-&gt;GetStaticMethodID(
 130             graphicsEnvClass, &quot;isHeadless&quot;, &quot;()Z&quot;);
 131         if (headlessFn == NULL) {
 132             return JNI_TRUE;
 133         }
 134         isHeadless = env-&gt;CallStaticBooleanMethod(graphicsEnvClass,
 135             headlessFn);
 136     }
 137     return isHeadless;
 138 }
 139 
 140 #define IDT_AWT_MOUSECHECK 0x101
 141 
 142 static LPCTSTR szAwtToolkitClassName = TEXT(&quot;SunAwtToolkit&quot;);
 143 
 144 static const int MOUSE_BUTTONS_WINDOWS_SUPPORTED = 5; //three standard buttons + XBUTTON1 + XBUTTON2.
 145 
 146 UINT AwtToolkit::GetMouseKeyState()
 147 {
 148     static BOOL mbSwapped = ::GetSystemMetrics(SM_SWAPBUTTON);
 149     UINT mouseKeyState = 0;
 150 
 151     if (HIBYTE(::GetKeyState(VK_CONTROL)))
 152         mouseKeyState |= MK_CONTROL;
 153     if (HIBYTE(::GetKeyState(VK_SHIFT)))
 154         mouseKeyState |= MK_SHIFT;
 155     if (HIBYTE(::GetKeyState(VK_LBUTTON)))
 156         mouseKeyState |= (mbSwapped ? MK_RBUTTON : MK_LBUTTON);
 157     if (HIBYTE(::GetKeyState(VK_RBUTTON)))
 158         mouseKeyState |= (mbSwapped ? MK_LBUTTON : MK_RBUTTON);
 159     if (HIBYTE(::GetKeyState(VK_MBUTTON)))
 160         mouseKeyState |= MK_MBUTTON;
 161     return mouseKeyState;
 162 }
 163 
 164 //
 165 // Normal ::GetKeyboardState call only works if current thread has
 166 // a message pump, so provide a way for other threads to get
 167 // the keyboard state
 168 //
 169 void AwtToolkit::GetKeyboardState(PBYTE keyboardState)
 170 {
 171     CriticalSection::Lock       l(AwtToolkit::GetInstance().m_lockKB);
 172     DASSERT(!IsBadWritePtr(keyboardState, KB_STATE_SIZE));
 173     memcpy(keyboardState, AwtToolkit::GetInstance().m_lastKeyboardState,
 174            KB_STATE_SIZE);
 175 }
 176 
 177 void AwtToolkit::SetBusy(BOOL busy) {
 178 
 179     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 180 
 181     static jclass awtAutoShutdownClass = NULL;
 182     static jmethodID notifyBusyMethodID = NULL;
 183     static jmethodID notifyFreeMethodID = NULL;
 184 
 185     if (awtAutoShutdownClass == NULL) {
 186         jclass awtAutoShutdownClassLocal = env-&gt;FindClass(&quot;sun/awt/AWTAutoShutdown&quot;);
 187         DASSERT(awtAutoShutdownClassLocal != NULL);
 188         if (!awtAutoShutdownClassLocal) throw std::bad_alloc();
 189 
 190         awtAutoShutdownClass = (jclass)env-&gt;NewGlobalRef(awtAutoShutdownClassLocal);
 191         env-&gt;DeleteLocalRef(awtAutoShutdownClassLocal);
 192         if (!awtAutoShutdownClass) throw std::bad_alloc();
 193 
 194         notifyBusyMethodID = env-&gt;GetStaticMethodID(awtAutoShutdownClass,
 195                                                     &quot;notifyToolkitThreadBusy&quot;, &quot;()V&quot;);
 196         DASSERT(notifyBusyMethodID != NULL);
 197         if (!notifyBusyMethodID) throw std::bad_alloc();
 198 
 199         notifyFreeMethodID = env-&gt;GetStaticMethodID(awtAutoShutdownClass,
 200                                                     &quot;notifyToolkitThreadFree&quot;, &quot;()V&quot;);
 201         DASSERT(notifyFreeMethodID != NULL);
 202         if (!notifyFreeMethodID) throw std::bad_alloc();
 203     } /* awtAutoShutdownClass == NULL*/
 204 
 205     if (busy) {
 206         env-&gt;CallStaticVoidMethod(awtAutoShutdownClass,
 207                                   notifyBusyMethodID);
 208     } else {
 209         env-&gt;CallStaticVoidMethod(awtAutoShutdownClass,
 210                                   notifyFreeMethodID);
 211     }
 212 
 213     if (!JNU_IsNull(env, safe_ExceptionOccurred(env))) {
 214         env-&gt;ExceptionDescribe();
 215         env-&gt;ExceptionClear();
 216     }
 217 }
 218 
 219 BOOL AwtToolkit::activateKeyboardLayout(HKL hkl) {
 220     // This call should succeed in case of one of the following:
 221     // 1. Win 9x
 222     // 2. NT with that HKL already loaded
 223     HKL prev = ::ActivateKeyboardLayout(hkl, 0);
 224 
 225     // If the above call fails, try loading the layout in case of NT
 226     if (!prev) {
 227         // create input locale string, e.g., &quot;00000409&quot;, from hkl.
 228         TCHAR inputLocale[9];
 229         TCHAR buf[9];
 230         _tcscpy_s(inputLocale, 9, TEXT(&quot;00000000&quot;));
 231 
 232     // 64-bit: ::LoadKeyboardLayout() is such a weird API - a string of
 233     // the hex value you want?!  Here we&#39;re converting our HKL value to
 234     // a string.  Hopefully there is no 64-bit trouble.
 235         _i64tot(reinterpret_cast&lt;INT_PTR&gt;(hkl), buf, 16);
 236         size_t len = _tcslen(buf);
 237         memcpy(&amp;inputLocale[8-len], buf, len);
 238 
 239         // load and activate the keyboard layout
 240         hkl = ::LoadKeyboardLayout(inputLocale, 0);
 241         if (hkl != 0) {
 242             prev = ::ActivateKeyboardLayout(hkl, 0);
 243         }
 244     }
 245 
 246     return (prev != 0);
 247 }
 248 
 249 /************************************************************************
 250  * Exported functions
 251  */
 252 
 253 extern &quot;C&quot; BOOL APIENTRY DllMain(HANDLE hInstance, DWORD ul_reason_for_call,
 254                                  LPVOID)
 255 {
 256     // Don&#39;t use the TRY and CATCH_BAD_ALLOC_RET macros if we&#39;re detaching
 257     // the library. Doing so causes awt.dll to call back into the VM during
 258     // shutdown. This crashes the HotSpot VM.
 259     switch (ul_reason_for_call) {
 260     case DLL_PROCESS_ATTACH:
 261         TRY;
 262         AwtToolkit::GetInstance().SetModuleHandle((HMODULE)hInstance);
 263         CATCH_BAD_ALLOC_RET(FALSE);
 264         break;
 265     case DLL_PROCESS_DETACH:
 266 #ifdef DEBUG
 267         DTrace_DisableMutex();
 268         DMem_DisableMutex();
 269 #endif DEBUG
 270         break;
 271     }
 272     return TRUE;
 273 }
 274 
 275 /************************************************************************
 276  * AwtToolkit fields
 277  */
 278 
 279 AwtToolkit AwtToolkit::theInstance;
 280 
 281 /* ids for WToolkit fields accessed from native code */
 282 jmethodID AwtToolkit::windowsSettingChangeMID;
 283 jmethodID AwtToolkit::displayChangeMID;
 284 
 285 jmethodID AwtToolkit::userSessionMID;
 286 jmethodID AwtToolkit::systemSleepMID;
 287 /* ids for Toolkit methods */
 288 jmethodID AwtToolkit::getDefaultToolkitMID;
 289 jmethodID AwtToolkit::getFontMetricsMID;
 290 jmethodID AwtToolkit::insetsMID;
 291 
 292 /************************************************************************
 293  * AwtToolkit methods
 294  */
 295 
 296 AwtToolkit::AwtToolkit() {
 297     m_localPump = FALSE;
 298     m_mainThreadId = 0;
 299     m_toolkitHWnd = NULL;
 300     m_inputMethodHWnd = NULL;
 301     m_verbose = FALSE;
 302     m_isActive = TRUE;
 303     m_isDisposed = FALSE;
 304 
 305     m_vmSignalled = FALSE;
 306 
 307     m_isDynamicLayoutSet = FALSE;
 308     m_areExtraMouseButtonsEnabled = TRUE;
 309 
 310     m_isWin8OrLater = FALSE;
 311     m_touchKbrdAutoShowIsEnabled = FALSE;
 312     m_touchKbrdExeFilePath = NULL;
 313     m_pRegisterTouchWindow = NULL;
 314     m_pGetTouchInputInfo = NULL;
 315     m_pCloseTouchInputHandle = NULL;
 316 
 317     m_verifyComponents = FALSE;
 318     m_breakOnError = FALSE;
 319 
 320     m_breakMessageLoop = FALSE;
 321     m_messageLoopResult = 0;
 322 
 323     m_lastMouseOver = NULL;
 324     m_mouseDown = FALSE;
 325 
 326     m_hGetMessageHook = 0;
 327     m_hMouseLLHook = 0;
 328     m_lastWindowUnderMouse = NULL;
 329     m_timer = 0;
 330 
 331     m_cmdIDs = new AwtCmdIDList();
 332     m_pModalDialog = NULL;
 333     m_peer = NULL;
 334     m_dllHandle = NULL;
 335 
 336     m_displayChanged = FALSE;
 337     m_embedderProcessID = 0;
 338 
 339     // XXX: keyboard mapping should really be moved out of AwtComponent
 340     AwtComponent::InitDynamicKeyMapTable();
 341 
 342     // initialize kb state array
 343     ::GetKeyboardState(m_lastKeyboardState);
 344 
 345     m_waitEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
 346     isInDoDragDropLoop = FALSE;
 347     eventNumber = 0;
 348 }
 349 
 350 AwtToolkit::~AwtToolkit() {
 351 /*
 352  *  The code has been moved to AwtToolkit::Dispose() method.
 353  */
 354 }
 355 
 356 HWND AwtToolkit::CreateToolkitWnd(LPCTSTR name)
 357 {
 358     HWND hwnd = CreateWindow(
 359         szAwtToolkitClassName,
 360         (LPCTSTR)name,                    /* window name */
 361         WS_DISABLED,                      /* window style */
 362         -1, -1,                           /* position of window */
 363         0, 0,                             /* width and height */
 364         NULL, NULL,                       /* hWndParent and hWndMenu */
 365         GetModuleHandle(),
 366         NULL);                            /* lpParam */
 367     DASSERT(hwnd != NULL);
 368     return hwnd;
 369 }
 370 
 371 void AwtToolkit::InitTouchKeyboardExeFilePath() {
 372     enum RegistryView { WOW64_32BIT, WOW64_64BIT };
 373     const TCHAR tabTipCoKeyName[] = _T(&quot;SOFTWARE\\Classes\\CLSID\\&quot;)
 374         _T(&quot;{054AAE20-4BEA-4347-8A35-64A533254A9D}\\LocalServer32&quot;);
 375     HKEY hTabTipCoKey = NULL;
 376     RegistryView regViewWithTabTipCoKey = WOW64_32BIT;
 377 
 378     if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, tabTipCoKeyName, 0,
 379             KEY_READ | KEY_WOW64_32KEY, &amp;hTabTipCoKey) != ERROR_SUCCESS) {
 380         if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, tabTipCoKeyName, 0,
 381                 KEY_READ | KEY_WOW64_64KEY, &amp;hTabTipCoKey) != ERROR_SUCCESS) {
 382             return;
 383         } else {
 384             regViewWithTabTipCoKey = WOW64_64BIT;
 385         }
 386     }
 387 
 388     DWORD keyValType = 0;
 389     DWORD bytesCopied = 0;
 390     if ((::RegQueryValueEx(hTabTipCoKey, NULL, NULL, &amp;keyValType, NULL,
 391             &amp;bytesCopied) != ERROR_SUCCESS) ||
 392         ((keyValType != REG_EXPAND_SZ) &amp;&amp; (keyValType != REG_SZ))) {
 393         if (hTabTipCoKey != NULL) {
 394             ::RegCloseKey(hTabTipCoKey);
 395         }
 396         return;
 397     }
 398 
 399     // Increase the buffer size for 1 additional null-terminating character.
 400     bytesCopied += sizeof(TCHAR);
 401     TCHAR* tabTipFilePath = new TCHAR[bytesCopied / sizeof(TCHAR)];
 402     ::memset(tabTipFilePath, 0, bytesCopied);
 403 
 404     DWORD oldBytesCopied = bytesCopied;
 405     if (::RegQueryValueEx(hTabTipCoKey, NULL, NULL, NULL,
 406             (LPBYTE)tabTipFilePath, &amp;bytesCopied) == ERROR_SUCCESS) {
 407         const TCHAR searchedStr[] = _T(&quot;%CommonProgramFiles%&quot;);
 408         const size_t searchedStrLen = ::_tcslen(searchedStr);
 409         int searchedStrStartIndex = -1;
 410 
 411         TCHAR* commonFilesDirPath = NULL;
 412         DWORD commonFilesDirPathLen = 0;
 413 
 414         // Check, if &#39;%CommonProgramFiles%&#39; string is present in the defined
 415         // path of the touch keyboard executable.
 416         TCHAR* const searchedStrStart = ::_tcsstr(tabTipFilePath, searchedStr);
 417         if (searchedStrStart != NULL) {
 418             searchedStrStartIndex = searchedStrStart - tabTipFilePath;
 419 
 420             // Get value of &#39;CommonProgramFiles&#39; environment variable, if the
 421             // file path of the touch keyboard executable was found in 32-bit
 422             // registry view, otherwise get value of &#39;CommonProgramW6432&#39;.
 423             const TCHAR envVar32BitName[] = _T(&quot;CommonProgramFiles&quot;);
 424             const TCHAR envVar64BitName[] = _T(&quot;CommonProgramW6432&quot;);
 425             const TCHAR* envVarName = (regViewWithTabTipCoKey == WOW64_32BIT ?
 426                 envVar32BitName : envVar64BitName);
 427 
 428             DWORD charsStored = ::GetEnvironmentVariable(envVarName, NULL, 0);
 429             if (charsStored &gt; 0) {
 430                 commonFilesDirPath = new TCHAR[charsStored];
 431                 ::memset(commonFilesDirPath, 0, charsStored * sizeof(TCHAR));
 432 
 433                 DWORD oldCharsStored = charsStored;
 434                 if (((charsStored = ::GetEnvironmentVariable(envVarName,
 435                         commonFilesDirPath, charsStored)) &gt; 0) &amp;&amp;
 436                     (charsStored &lt;= oldCharsStored)) {
 437                     commonFilesDirPathLen = charsStored;
 438                 } else {
 439                     delete[] commonFilesDirPath;
 440                     commonFilesDirPath = NULL;
 441                 }
 442             }
 443         }
 444 
 445         // Calculate &#39;m_touchKbrdExeFilePath&#39; length in characters including
 446         // the null-terminating character.
 447         DWORD exeFilePathLen = oldBytesCopied / sizeof(TCHAR);
 448         if (commonFilesDirPathLen &gt; 0) {
 449             exeFilePathLen = exeFilePathLen - searchedStrLen +
 450                 commonFilesDirPathLen;
 451         }
 452 
 453         if (m_touchKbrdExeFilePath != NULL) {
 454             delete[] m_touchKbrdExeFilePath;
 455             m_touchKbrdExeFilePath = NULL;
 456         }
 457         m_touchKbrdExeFilePath = new TCHAR[exeFilePathLen];
 458         ::memset(m_touchKbrdExeFilePath, 0, exeFilePathLen * sizeof(TCHAR));
 459 
 460         if (commonFilesDirPathLen &gt; 0) {
 461             ::_tcsncpy_s(m_touchKbrdExeFilePath, exeFilePathLen, tabTipFilePath,
 462                 searchedStrStartIndex);
 463             DWORD charsCopied = searchedStrStartIndex;
 464 
 465             ::_tcsncpy_s(m_touchKbrdExeFilePath + charsCopied,
 466                 exeFilePathLen - charsCopied, commonFilesDirPath,
 467                 commonFilesDirPathLen);
 468             charsCopied += commonFilesDirPathLen;
 469 
 470             ::_tcsncpy_s(m_touchKbrdExeFilePath + charsCopied,
 471                 exeFilePathLen - charsCopied, searchedStrStart + searchedStrLen,
 472                 bytesCopied / sizeof(TCHAR) -
 473                     (searchedStrStartIndex + searchedStrLen));
 474         } else {
 475             ::_tcsncpy_s(m_touchKbrdExeFilePath, exeFilePathLen, tabTipFilePath,
 476                 bytesCopied / sizeof(TCHAR));
 477         }
 478 
 479         // Remove leading and trailing quotation marks.
 480         ::StrTrim(m_touchKbrdExeFilePath, _T(&quot;\&quot;&quot;));
 481 
 482         // Verify that a file with the path &#39;m_touchKbrdExeFilePath&#39; exists.
 483         DWORD fileAttrs = ::GetFileAttributes(m_touchKbrdExeFilePath);
 484         DWORD err = ::GetLastError();
 485         if ((fileAttrs == INVALID_FILE_ATTRIBUTES) ||
 486             (fileAttrs &amp; FILE_ATTRIBUTE_DIRECTORY)) {
 487             delete[] m_touchKbrdExeFilePath;
 488             m_touchKbrdExeFilePath = NULL;
 489         }
 490 
 491         if (commonFilesDirPath != NULL) {
 492             delete[] commonFilesDirPath;
 493         }
 494     }
 495 
 496     if (tabTipFilePath != NULL) {
 497         delete[] tabTipFilePath;
 498     }
 499     if (hTabTipCoKey != NULL) {
 500         ::RegCloseKey(hTabTipCoKey);
 501     }
 502 }
 503 
 504 HWND AwtToolkit::GetTouchKeyboardWindow() {
 505     const TCHAR wndClassName[] = _T(&quot;IPTip_Main_Window&quot;);
 506     HWND hwnd = ::FindWindow(wndClassName, NULL);
 507     if ((hwnd != NULL) &amp;&amp; ::IsWindow(hwnd) &amp;&amp; ::IsWindowEnabled(hwnd)) {
 508         return hwnd;
 509     }
 510     return NULL;
 511 }
 512 
 513 
 514 struct ToolkitThreadProc_Data {
 515     bool result;
 516     HANDLE hCompleted;
 517 
 518     jobject thread;
 519     jobject threadGroup;
 520 };
 521 
 522 void ToolkitThreadProc(void *param)
 523 {
 524     ToolkitThreadProc_Data *data = (ToolkitThreadProc_Data *)param;
 525 
 526     bool bNotified = false;
 527 
 528     JNIEnv *env;
 529     JavaVMAttachArgs attachArgs;
 530     attachArgs.version  = JNI_VERSION_1_2;
 531     attachArgs.name     = &quot;AWT-Windows&quot;;
 532     attachArgs.group    = data-&gt;threadGroup;
 533 
 534     jint res = jvm-&gt;AttachCurrentThreadAsDaemon((void **)&amp;env, &amp;attachArgs);
 535     if (res &lt; 0) {
 536         return;
 537     }
 538 
 539     jobject thread = env-&gt;NewGlobalRef(data-&gt;thread);
 540     if (thread != NULL) {
 541         jclass cls = env-&gt;GetObjectClass(thread);
 542         if (cls != NULL) {
 543             jmethodID runId = env-&gt;GetMethodID(cls, &quot;run&quot;, &quot;()V&quot;);
 544             if (runId != NULL) {
 545                 data-&gt;result = true;
 546                 ::SetEvent(data-&gt;hCompleted);
 547                 bNotified = true;
 548 
 549                 env-&gt;CallVoidMethod(thread, runId);
 550 
 551                 if (env-&gt;ExceptionCheck()) {
 552                     env-&gt;ExceptionDescribe();
 553                     env-&gt;ExceptionClear();
 554                     // TODO: handle
 555                 }
 556             }
 557             env-&gt;DeleteLocalRef(cls);
 558         }
 559         env-&gt;DeleteGlobalRef(thread);
 560     }
 561     if (!bNotified) {
 562         ::SetEvent(data-&gt;hCompleted);
 563     }
 564 
 565     jvm-&gt;DetachCurrentThread();
 566 }
 567 
 568 /*
 569  * Class:     sun_awt_windows_WToolkit
 570  * Method:    startToolkitThread
 571  * Signature: (Ljava/lang/Runnable;Ljava/lang/ThreadGroup)Z
 572  */
 573 JNIEXPORT jboolean JNICALL
 574 Java_sun_awt_windows_WToolkit_startToolkitThread(JNIEnv *env, jclass cls, jobject thread, jobject threadGroup)
 575 {
 576     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
 577 
 578     ToolkitThreadProc_Data data;
 579     data.result = false;
 580     data.thread = env-&gt;NewGlobalRef(thread);
 581     data.threadGroup = env-&gt;NewGlobalRef(threadGroup);
 582     if (data.thread == NULL || data.threadGroup == NULL) {
 583         return JNI_FALSE;
 584     }
 585     data.hCompleted = ::CreateEvent(NULL, FALSE, FALSE, NULL);
 586 
 587     bool result = tk.GetPreloadThread()
 588                     .InvokeAndTerminate(ToolkitThreadProc, &amp;data);
 589 
 590     if (result) {
 591         ::WaitForSingleObject(data.hCompleted, INFINITE);
 592         result = data.result;
 593     } else {
 594         // no awt preloading
 595         // return back to the usual toolkit way
 596     }
 597     ::CloseHandle(data.hCompleted);
 598 
 599     env-&gt;DeleteGlobalRef(data.thread);
 600     env-&gt;DeleteGlobalRef(data.threadGroup);
 601 
 602     return result ? JNI_TRUE : JNI_FALSE;
 603 }
 604 
 605 BOOL AwtToolkit::Initialize(BOOL localPump) {
 606     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
 607 
 608     if (!tk.m_isActive || tk.m_mainThreadId != 0) {
 609         /* Already initialized. */
 610         return FALSE;
 611     }
 612 
 613     // This call is moved here from AwtToolkit constructor. Having it
 614     // there led to the bug 6480630: there could be a situation when
 615     // ComCtl32Util was constructed but not disposed
 616     ComCtl32Util::GetInstance().InitLibraries();
 617 
 618     if (!localPump) {
 619         // if preload thread was run, terminate it
 620         preloadThread.Terminate(true);
 621     }
 622 
 623     /* Register this toolkit&#39;s helper window */
 624     VERIFY(tk.RegisterClass() != NULL);
 625 
 626     // Set up operator new/malloc out of memory handler.
 627     NewHandler::init();
 628 
 629         //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 630         // Bugs 4032109, 4047966, and 4071991 to fix AWT
 631         //      crash in 16 color display mode.  16 color mode is supported.  Less
 632         //      than 16 color is not.
 633         // creighto@eng.sun.com 1997-10-07
 634         //
 635         // Check for at least 16 colors
 636     HDC hDC = ::GetDC(NULL);
 637         if ((::GetDeviceCaps(hDC, BITSPIXEL) * ::GetDeviceCaps(hDC, PLANES)) &lt; 4) {
 638                 ::MessageBox(NULL,
 639                              TEXT(&quot;Sorry, but this release of Java requires at least 16 colors&quot;),
 640                              TEXT(&quot;AWT Initialization Error&quot;),
 641                              MB_ICONHAND | MB_APPLMODAL);
 642                 ::DeleteDC(hDC);
 643                 JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 644                 JNU_ThrowByName(env, &quot;java/lang/InternalError&quot;,
 645                                 &quot;unsupported screen depth&quot;);
 646                 return FALSE;
 647         }
 648     ::ReleaseDC(NULL, hDC);
 649         ///////////////////////////////////////////////////////////////////////////
 650 
 651     tk.m_localPump = localPump;
 652     tk.m_mainThreadId = ::GetCurrentThreadId();
 653 
 654     /*
 655      * Create the one-and-only toolkit window.  This window isn&#39;t
 656      * displayed, but is used to route messages to this thread.
 657      */
 658     tk.m_toolkitHWnd = tk.CreateToolkitWnd(TEXT(&quot;theAwtToolkitWindow&quot;));
 659     DASSERT(tk.m_toolkitHWnd != NULL);
 660 
 661     /*
 662      * Setup a GetMessage filter to watch all messages coming out of our
 663      * queue from PreProcessMsg().
 664      */
 665     tk.m_hGetMessageHook = ::SetWindowsHookEx(WH_GETMESSAGE,
 666                                               (HOOKPROC)GetMessageFilter,
 667                                               0, tk.m_mainThreadId);
 668 
 669     awt_dnd_initialize();
 670 
 671     /*
 672      * Initialization of the touch keyboard related variables.
 673      */
 674     tk.m_isWin8OrLater = IS_WIN8;
 675 
 676     TRY;
 677 
 678     JNIEnv* env = AwtToolkit::GetEnv();
 679     jclass sunToolkitCls = env-&gt;FindClass(&quot;sun/awt/SunToolkit&quot;);
 680     DASSERT(sunToolkitCls != 0);
 681     CHECK_NULL_RETURN(sunToolkitCls, FALSE);
 682 
 683     jmethodID isTouchKeyboardAutoShowEnabledMID = env-&gt;GetStaticMethodID(
 684         sunToolkitCls, &quot;isTouchKeyboardAutoShowEnabled&quot;, &quot;()Z&quot;);
 685     DASSERT(isTouchKeyboardAutoShowEnabledMID != 0);
 686     CHECK_NULL_RETURN(isTouchKeyboardAutoShowEnabledMID, FALSE);
 687 
 688     tk.m_touchKbrdAutoShowIsEnabled = env-&gt;CallStaticBooleanMethod(
 689         sunToolkitCls, isTouchKeyboardAutoShowEnabledMID);
 690 
 691     CATCH_BAD_ALLOC_RET(FALSE);
 692 
 693     if (tk.m_isWin8OrLater &amp;&amp; tk.m_touchKbrdAutoShowIsEnabled) {
 694         tk.InitTouchKeyboardExeFilePath();
 695         HMODULE hUser32Dll = ::LoadLibrary(_T(&quot;user32.dll&quot;));
 696         if (hUser32Dll != NULL) {
 697             tk.m_pRegisterTouchWindow = (RegisterTouchWindowFunc)
 698                 ::GetProcAddress(hUser32Dll, &quot;RegisterTouchWindow&quot;);
 699             tk.m_pGetTouchInputInfo = (GetTouchInputInfoFunc)
 700                 ::GetProcAddress(hUser32Dll, &quot;GetTouchInputInfo&quot;);
 701             tk.m_pCloseTouchInputHandle = (CloseTouchInputHandleFunc)
 702                 ::GetProcAddress(hUser32Dll, &quot;CloseTouchInputHandle&quot;);
 703         }
 704 
 705         if ((tk.m_pRegisterTouchWindow == NULL) ||
 706             (tk.m_pGetTouchInputInfo == NULL) ||
 707             (tk.m_pCloseTouchInputHandle == NULL)) {
 708             tk.m_pRegisterTouchWindow = NULL;
 709             tk.m_pGetTouchInputInfo = NULL;
 710             tk.m_pCloseTouchInputHandle = NULL;
 711         }
 712     }
 713     /*
 714      * End of the touch keyboard related initialization code.
 715      */
 716 
 717     return TRUE;
 718 }
 719 
 720 BOOL AwtToolkit::Dispose() {
 721     DTRACE_PRINTLN(&quot;In AwtToolkit::Dispose()&quot;);
 722 
 723     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
 724 
 725     if (!tk.m_isActive || tk.m_mainThreadId != ::GetCurrentThreadId()) {
 726         return FALSE;
 727     }
 728 
 729     tk.m_isActive = FALSE;
 730 
 731     // dispose Direct3D-related resources. This should be done
 732     // before AwtObjectList::Cleanup() as the d3d will attempt to
 733     // shutdown when the last of its windows is disposed of
 734     D3DInitializer::GetInstance().Clean();
 735 
 736     AwtObjectList::Cleanup();
 737 
 738     awt_dnd_uninitialize();
 739     awt_clipboard_uninitialize((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2));
 740 
 741     if (tk.m_touchKbrdExeFilePath != NULL) {
 742         delete[] tk.m_touchKbrdExeFilePath;
 743         tk.m_touchKbrdExeFilePath = NULL;
 744     }
 745     tk.m_pRegisterTouchWindow = NULL;
 746     tk.m_pGetTouchInputInfo = NULL;
 747     tk.m_pCloseTouchInputHandle = NULL;
 748 
 749     if (tk.m_inputMethodHWnd != NULL) {
 750         ::SendMessage(tk.m_inputMethodHWnd, WM_IME_CONTROL, IMC_OPENSTATUSWINDOW, 0);
 751     }
 752     tk.m_inputMethodHWnd = NULL;
 753 
 754     // wait for any messages to be processed, in particular,
 755     // all WM_AWT_DELETEOBJECT messages that delete components; no
 756     // new messages will appear as all the windows except toolkit
 757     // window are unsubclassed and destroyed
 758     MSG msg;
 759     while (::GetMessage(&amp;msg, NULL, 0, 0)) {
 760         ::TranslateMessage(&amp;msg);
 761         ::DispatchMessage(&amp;msg);
 762     }
 763 
 764     AwtFont::Cleanup();
 765 
 766     HWND toolkitHWndToDestroy = tk.m_toolkitHWnd;
 767     tk.m_toolkitHWnd = 0;
 768     VERIFY(::DestroyWindow(toolkitHWndToDestroy) != NULL);
 769 
 770     tk.UnregisterClass();
 771 
 772     ::UnhookWindowsHookEx(tk.m_hGetMessageHook);
 773     UninstallMouseLowLevelHook();
 774 
 775     tk.m_mainThreadId = 0;
 776 
 777     delete tk.m_cmdIDs;
 778 
 779     ::CloseHandle(m_waitEvent);
 780 
 781     tk.m_isDisposed = TRUE;
 782 
 783     return TRUE;
 784 }
 785 
 786 void AwtToolkit::SetDynamicLayout(BOOL dynamic) {
 787     m_isDynamicLayoutSet = dynamic;
 788 }
 789 
 790 BOOL AwtToolkit::IsDynamicLayoutSet() {
 791     return m_isDynamicLayoutSet;
 792 }
 793 
 794 BOOL AwtToolkit::IsDynamicLayoutSupported() {
 795     // SPI_GETDRAGFULLWINDOWS is only supported on Win95 if
 796     // Windows Plus! is installed.  Otherwise, box frame resize.
 797     BOOL fullWindowDragEnabled = FALSE;
 798     int result = 0;
 799     result = ::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0,
 800                                   &amp;fullWindowDragEnabled, 0);
 801 
 802     return (fullWindowDragEnabled &amp;&amp; (result != 0));
 803 }
 804 
 805 BOOL AwtToolkit::IsDynamicLayoutActive() {
 806     return (IsDynamicLayoutSet() &amp;&amp; IsDynamicLayoutSupported());
 807 }
 808 
 809 ATOM AwtToolkit::RegisterClass() {
 810     WNDCLASS  wc;
 811 
 812     wc.style         = 0;
 813     wc.lpfnWndProc   = (WNDPROC)WndProc;
 814     wc.cbClsExtra    = 0;
 815     wc.cbWndExtra    = 0;
 816     wc.hInstance     = AwtToolkit::GetInstance().GetModuleHandle(),
 817     wc.hIcon         = AwtToolkit::GetInstance().GetAwtIcon();
 818     wc.hCursor       = NULL;
 819     wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
 820     wc.lpszMenuName  = NULL;
 821     wc.lpszClassName = szAwtToolkitClassName;
 822 
 823     ATOM ret = ::RegisterClass(&amp;wc);
 824     DASSERT(ret != NULL);
 825     return ret;
 826 }
 827 
 828 void AwtToolkit::UnregisterClass() {
 829     VERIFY(::UnregisterClass(szAwtToolkitClassName, AwtToolkit::GetInstance().GetModuleHandle()));
 830 }
 831 
 832 /*
 833  * Structure holding the information to create a component. This packet is
 834  * sent to the toolkit window.
 835  */
 836 struct ComponentCreatePacket {
 837     void* hComponent;
 838     void* hParent;
 839     void (*factory)(void*, void*);
 840 };
 841 
 842 /*
 843  * Create an AwtXxxx component using a given factory function
 844  * Implemented by sending a message to the toolkit window to invoke the
 845  * factory function from that thread
 846  */
 847 void AwtToolkit::CreateComponent(void* component, void* parent,
 848                                  ComponentFactory compFactory, BOOL isParentALocalReference)
 849 {
 850     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
 851 
 852     /* Since Local references are not valid in another Thread, we need to
 853        create a global reference before we send this to the Toolkit thread.
 854        In some cases this method is called with parent being a native
 855        malloced struct so we cannot and do not need to create a Global
 856        Reference from it. This is indicated by isParentALocalReference */
 857 
 858     jobject gcomponent = env-&gt;NewGlobalRef((jobject)component);
 859     jobject gparent;
 860     if (isParentALocalReference) gparent = env-&gt;NewGlobalRef((jobject)parent);
 861     ComponentCreatePacket ccp = { gcomponent,
 862                                   isParentALocalReference == TRUE ?  gparent : parent,
 863                                    compFactory };
 864     AwtToolkit::GetInstance().SendMessage(WM_AWT_COMPONENT_CREATE, 0,
 865                                           (LPARAM)&amp;ccp);
 866     env-&gt;DeleteGlobalRef(gcomponent);
 867     if (isParentALocalReference) env-&gt;DeleteGlobalRef(gparent);
 868 }
 869 
 870 /*
 871  * Destroy an HWND that was created in the toolkit thread. Can be used on
 872  * Components and the toolkit window itself.
 873  */
 874 void AwtToolkit::DestroyComponentHWND(HWND hwnd)
 875 {
 876     if (!::IsWindow(hwnd)) {
 877         return;
 878     }
 879 
 880     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
 881     if ((tk.m_lastMouseOver != NULL) &amp;&amp;
 882         (tk.m_lastMouseOver-&gt;GetHWnd() == hwnd))
 883     {
 884         tk.m_lastMouseOver = NULL;
 885     }
 886 
 887     ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)NULL);
 888     tk.SendMessage(WM_AWT_DESTROY_WINDOW, (WPARAM)hwnd, 0);
 889 }
 890 
 891 #ifndef SPY_MESSAGES
 892 #define SpyWinMessage(hwin,msg,str)
 893 #else
 894 void SpyWinMessage(HWND hwnd, UINT message, LPCTSTR szComment);
 895 #endif
 896 
 897 /*
 898  * An AwtToolkit window is just a means of routing toolkit messages to here.
 899  */
 900 LRESULT CALLBACK AwtToolkit::WndProc(HWND hWnd, UINT message,
 901                                      WPARAM wParam, LPARAM lParam)
 902 {
 903     TRY;
 904 
 905     JNIEnv *env = GetEnv();
 906     JNILocalFrame lframe(env, 10);
 907 
 908     SpyWinMessage(hWnd, message, TEXT(&quot;AwtToolkit&quot;));
 909 
 910     AwtToolkit::GetInstance().eventNumber++;
 911     /*
 912      * Awt widget creation messages are routed here so that all
 913      * widgets are created on the main thread.  Java allows widgets
 914      * to live beyond their creating thread -- by creating them on
 915      * the main thread, a widget can always be properly disposed.
 916      */
 917     switch (message) {
 918       case WM_AWT_EXECUTE_SYNC: {
 919           jobject peerObject = (jobject)wParam;
 920           AwtObject* object = (AwtObject *)JNI_GET_PDATA(peerObject);
 921           DASSERT( !IsBadReadPtr(object, sizeof(AwtObject)));
 922           AwtObject::ExecuteArgs *args = (AwtObject::ExecuteArgs *)lParam;
 923           DASSERT(!IsBadReadPtr(args, sizeof(AwtObject::ExecuteArgs)));
 924           LRESULT result = 0;
 925           if (object != NULL)
 926           {
 927               result = object-&gt;WinThreadExecProc(args);
 928           }
 929           env-&gt;DeleteGlobalRef(peerObject);
 930           return result;
 931       }
 932       case WM_AWT_COMPONENT_CREATE: {
 933           ComponentCreatePacket* ccp = (ComponentCreatePacket*)lParam;
 934           DASSERT(ccp-&gt;factory != NULL);
 935           DASSERT(ccp-&gt;hComponent != NULL);
 936           (*ccp-&gt;factory)(ccp-&gt;hComponent, ccp-&gt;hParent);
 937           return 0;
 938       }
 939       case WM_AWT_DESTROY_WINDOW: {
 940           /* Destroy widgets from this same thread that created them */
 941           VERIFY(::DestroyWindow((HWND)wParam) != NULL);
 942           return 0;
 943       }
 944       case WM_AWT_DISPOSE: {
 945           if(wParam != NULL) {
 946               jobject self = (jobject)wParam;
 947               AwtObject *o = (AwtObject *) JNI_GET_PDATA(self);
 948               env-&gt;DeleteGlobalRef(self);
 949               if(o != NULL &amp;&amp; theAwtObjectList.Remove(o)) {
 950                   o-&gt;Dispose();
 951               }
 952           }
 953           return 0;
 954       }
 955       case WM_AWT_DISPOSEPDATA: {
 956           /*
 957            * NOTE: synchronization routine (like in WM_AWT_DISPOSE) was omitted because
 958            * this handler is called ONLY while disposing Cursor and Font objects where
 959            * synchronization takes place.
 960            */
 961           AwtObject *o = (AwtObject *) wParam;
 962           if(o != NULL &amp;&amp; theAwtObjectList.Remove(o)) {
 963               o-&gt;Dispose();
 964           }
 965           return 0;
 966       }
 967       case WM_AWT_DELETEOBJECT: {
 968           AwtObject *p = (AwtObject *) wParam;
 969           if (p-&gt;CanBeDeleted()) {
 970               // all the messages for this component are processed, so
 971               // it can be deleted
 972               delete p;
 973           } else {
 974               // postpone deletion, waiting for all the messages for this
 975               // component to be processed
 976               AwtToolkit::GetInstance().PostMessage(WM_AWT_DELETEOBJECT, wParam, (LPARAM)0);
 977           }
 978           return 0;
 979       }
 980       case WM_AWT_OBJECTLISTCLEANUP: {
 981           AwtObjectList::Cleanup();
 982           return 0;
 983       }
 984       case WM_SYSCOLORCHANGE: {
 985 
 986           jclass systemColorClass = env-&gt;FindClass(&quot;java/awt/SystemColor&quot;);
 987           DASSERT(systemColorClass);
 988           if (!systemColorClass) throw std::bad_alloc();
 989 
 990           jmethodID mid = env-&gt;GetStaticMethodID(systemColorClass, &quot;updateSystemColors&quot;, &quot;()V&quot;);
 991           DASSERT(mid);
 992           if (!mid) throw std::bad_alloc();
 993 
 994           env-&gt;CallStaticVoidMethod(systemColorClass, mid);
 995 
 996           /* FALL THROUGH - NO BREAK */
 997       }
 998 
 999       case WM_SETTINGCHANGE: {
1000           AwtWin32GraphicsDevice::ResetAllMonitorInfo();
1001           /* FALL THROUGH - NO BREAK */
1002       }
1003 // Remove this define when we move to newer (XP) version of SDK.
1004 #define WM_THEMECHANGED                 0x031A
1005       case WM_THEMECHANGED: {
1006           /* Upcall to WToolkit when user changes configuration.
1007            *
1008            * NOTE: there is a bug in Windows 98 and some older versions of
1009            * Windows NT (it seems to be fixed in NT4 SP5) where no
1010            * WM_SETTINGCHANGE is sent when any of the properties under
1011            * Control Panel -&gt; Display are changed.  You must _always_ query
1012            * the system for these - you can&#39;t rely on cached values.
1013            */
1014           jobject peer = AwtToolkit::GetInstance().m_peer;
1015           if (peer != NULL) {
1016               env-&gt;CallVoidMethod(peer, AwtToolkit::windowsSettingChangeMID);
1017           }
1018           return 0;
1019       }
1020 #ifndef WM_DWMCOMPOSITIONCHANGED
1021 #define WM_DWMCOMPOSITIONCHANGED        0x031E
1022 #define WM_DWMNCRENDERINGCHANGED        0x031F
1023 #define WM_DWMCOLORIZATIONCOLORCHANGED  0x0320
1024 #define WM_DWMWINDOWMAXIMIZEDCHANGED    0x0321
1025 #endif // WM_DWMCOMPOSITIONCHANGED
1026       case WM_DWMCOMPOSITIONCHANGED: {
1027           DWMResetCompositionEnabled();
1028           return 0;
1029       }
1030 
1031       case WM_TIMER: {
1032           // 6479820. Should check if a window is in manual resizing process: skip
1033           // sending any MouseExit/Enter events while inside resize-loop.
1034           // Note that window being in manual moving process could still
1035           // produce redundant enter/exit mouse events. In future, they can be
1036           // made skipped in a similar way.
1037            if (AwtWindow::IsResizing()) {
1038                return 0;
1039            }
1040           // Create an artifical MouseExit message if the mouse left to
1041           // a non-java window (bad mouse!)
1042           POINT pt;
1043           AwtToolkit&amp; tk = AwtToolkit::GetInstance();
1044           if (::GetCursorPos(&amp;pt)) {
1045               HWND hWndOver = ::WindowFromPoint(pt);
1046               AwtComponent * last_M;
1047               if ( AwtComponent::GetComponent(hWndOver) == NULL &amp;&amp; tk.m_lastMouseOver != NULL ) {
1048                   last_M = tk.m_lastMouseOver;
1049                   // translate point from screen to target window
1050                   MapWindowPoints(HWND_DESKTOP, last_M-&gt;GetHWnd(), &amp;pt, 1);
1051                   last_M-&gt;SendMessage(WM_AWT_MOUSEEXIT,
1052                                       GetMouseKeyState(),
1053                                       POINTTOPOINTS(pt));
1054                   tk.m_lastMouseOver = 0;
1055               }
1056           }
1057           if (tk.m_lastMouseOver == NULL &amp;&amp; tk.m_timer != 0) {
1058               VERIFY(::KillTimer(tk.m_toolkitHWnd, tk.m_timer));
1059               tk.m_timer = 0;
1060           }
1061           return 0;
1062       }
1063       case WM_DESTROYCLIPBOARD: {
1064           if (!AwtClipboard::IsGettingOwnership())
1065               AwtClipboard::LostOwnership((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2));
1066           return 0;
1067       }
1068       case WM_CHANGECBCHAIN: {
1069           AwtClipboard::WmChangeCbChain(wParam, lParam);
1070           return 0;
1071       }
1072       case WM_DRAWCLIPBOARD: {
1073           AwtClipboard::WmDrawClipboard((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), wParam, lParam);
1074           return 0;
1075       }
1076       case WM_AWT_LIST_SETMULTISELECT: {
1077           jobject peerObject = (jobject)wParam;
1078           AwtList* list = (AwtList *)JNI_GET_PDATA(peerObject);
1079           DASSERT( !IsBadReadPtr(list, sizeof(AwtObject)));
1080           list-&gt;SetMultiSelect(static_cast&lt;BOOL&gt;(lParam));
1081           return 0;
1082       }
1083 
1084       // Special awt message to call Imm APIs.
1085       // ImmXXXX() API must be used in the main thread.
1086       // In other thread these APIs does not work correctly even if
1087       // it returs with no error. (This restriction is not documented)
1088       // So we must use thse messages to call these APIs in main thread.
1089       case WM_AWT_CREATECONTEXT: {
1090         return reinterpret_cast&lt;LRESULT&gt;(
1091             reinterpret_cast&lt;void*&gt;(ImmCreateContext()));
1092       }
1093       case WM_AWT_DESTROYCONTEXT: {
1094           ImmDestroyContext((HIMC)wParam);
1095           return 0;
1096       }
1097       case WM_AWT_ASSOCIATECONTEXT: {
1098           EnableNativeIMEStruct *data = (EnableNativeIMEStruct*)wParam;
1099 
1100           jobject peer = data-&gt;peer;
1101           jobject self = data-&gt;self;
1102           jint context = data-&gt;context;
1103           jboolean useNativeCompWindow = data-&gt;useNativeCompWindow;
1104 
1105           AwtComponent* comp = (AwtComponent*)JNI_GET_PDATA(peer);
1106           if (comp != NULL)
1107           {
1108               comp-&gt;SetInputMethod(self, useNativeCompWindow);
1109               comp-&gt;ImmAssociateContext((HIMC)((intptr_t)context));
1110           }
1111 
1112           if (peer != NULL) {
1113               env-&gt;DeleteGlobalRef(peer);
1114           }
1115           if (self != NULL) {
1116               env-&gt;DeleteGlobalRef(self);
1117           }
1118 
1119           delete data;
1120           return 0;
1121       }
1122       case WM_AWT_GET_DEFAULT_IME_HANDLER: {
1123           LRESULT ret = (LRESULT)FALSE;
1124           jobject peer = (jobject)wParam;
1125 
1126           AwtComponent* comp = (AwtComponent*)JNI_GET_PDATA(peer);
1127           if (comp != NULL) {
1128               HWND defaultIMEHandler = ImmGetDefaultIMEWnd(comp-&gt;GetHWnd());
1129               if (defaultIMEHandler != NULL) {
1130                   AwtToolkit::GetInstance().SetInputMethodWindow(defaultIMEHandler);
1131                   ret = (LRESULT)TRUE;
1132               }
1133           }
1134 
1135           if (peer != NULL) {
1136               env-&gt;DeleteGlobalRef(peer);
1137           }
1138           return ret;
1139       }
1140       case WM_AWT_HANDLE_NATIVE_IME_EVENT: {
1141           jobject peer = (jobject)wParam;
1142           AwtComponent* comp = (AwtComponent*)JNI_GET_PDATA(peer);
1143           MSG* msg = (MSG*)lParam;
1144 
1145           long modifiers = comp-&gt;GetJavaModifiers();
1146           if ((comp != NULL) &amp;&amp; (msg-&gt;message==WM_CHAR || msg-&gt;message==WM_SYSCHAR)) {
1147               WCHAR unicodeChar = (WCHAR)msg-&gt;wParam;
1148               comp-&gt;SendKeyEvent(java_awt_event_KeyEvent_KEY_TYPED,
1149                                  0, //to be fixed nowMillis(),
1150                                  java_awt_event_KeyEvent_CHAR_UNDEFINED,
1151                                  unicodeChar,
1152                                  modifiers,
1153                                  java_awt_event_KeyEvent_KEY_LOCATION_UNKNOWN, (jlong)0,
1154                                  msg);
1155           } else if (comp != NULL) {
1156               MSG* pCopiedMsg = new MSG;
1157               *pCopiedMsg = *msg;
1158               comp-&gt;SendMessage(WM_AWT_HANDLE_EVENT, (WPARAM) FALSE,
1159                                 (LPARAM) pCopiedMsg);
1160           }
1161 
1162           if (peer != NULL) {
1163               env-&gt;DeleteGlobalRef(peer);
1164           }
1165           return 0;
1166       }
1167       case WM_AWT_ENDCOMPOSITION: {
1168           /*right now we just cancel the composition string
1169           may need to commit it in the furture
1170           Changed to commit it according to the flag 10/29/98*/
1171           ImmNotifyIME((HIMC)wParam, NI_COMPOSITIONSTR,
1172                        (lParam ? CPS_COMPLETE : CPS_CANCEL), 0);
1173           return 0;
1174       }
1175       case WM_AWT_SETCONVERSIONSTATUS: {
1176           DWORD cmode;
1177           DWORD smode;
1178           ImmGetConversionStatus((HIMC)wParam, (LPDWORD)&amp;cmode, (LPDWORD)&amp;smode);
1179           ImmSetConversionStatus((HIMC)wParam, (DWORD)LOWORD(lParam), smode);
1180           return 0;
1181       }
1182       case WM_AWT_GETCONVERSIONSTATUS: {
1183           DWORD cmode;
1184           DWORD smode;
1185           ImmGetConversionStatus((HIMC)wParam, (LPDWORD)&amp;cmode, (LPDWORD)&amp;smode);
1186           return cmode;
1187       }
1188       case WM_AWT_ACTIVATEKEYBOARDLAYOUT: {
1189           if (wParam &amp;&amp; g_bUserHasChangedInputLang) {
1190               // Input language has been changed since the last WInputMethod.getNativeLocale()
1191               // call.  So let&#39;s honor the user&#39;s selection.
1192               // Note: we need to check this flag inside the toolkit thread to synchronize access
1193               // to the flag.
1194               return FALSE;
1195           }
1196 
1197           if (lParam == (LPARAM)::GetKeyboardLayout(0)) {
1198               // already active
1199               return FALSE;
1200           }
1201 
1202           // Since ActivateKeyboardLayout does not post WM_INPUTLANGCHANGEREQUEST,
1203           // we explicitly need to do the same thing here.
1204           static BYTE keyboardState[AwtToolkit::KB_STATE_SIZE];
1205           AwtToolkit::GetKeyboardState(keyboardState);
1206           WORD ignored;
1207           ::ToAscii(VK_SPACE, ::MapVirtualKey(VK_SPACE, 0),
1208                     keyboardState, &amp;ignored, 0);
1209 
1210           return (LRESULT)activateKeyboardLayout((HKL)lParam);
1211       }
1212       case WM_AWT_OPENCANDIDATEWINDOW: {
1213           jobject peerObject = (jobject)wParam;
1214           AwtComponent* p = (AwtComponent*)JNI_GET_PDATA(peerObject);
1215           DASSERT( !IsBadReadPtr(p, sizeof(AwtObject)));
1216           // fix for 4805862: use GET_X_LPARAM and GET_Y_LPARAM macros
1217           // instead of LOWORD and HIWORD
1218           p-&gt;OpenCandidateWindow(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
1219           env-&gt;DeleteGlobalRef(peerObject);
1220           return 0;
1221       }
1222 
1223       /*
1224        * send this message via ::SendMessage() and the MPT will acquire the
1225        * HANDLE synchronized with the sender&#39;s thread. The HANDLE must be
1226        * signalled or deadlock may occur between the MPT and the caller.
1227        */
1228 
1229       case WM_AWT_WAIT_FOR_SINGLE_OBJECT: {
1230         return ::WaitForSingleObject((HANDLE)lParam, INFINITE);
1231       }
1232       case WM_AWT_INVOKE_METHOD: {
1233         return (LRESULT)(*(void*(*)(void*))wParam)((void *)lParam);
1234       }
1235       case WM_AWT_INVOKE_VOID_METHOD: {
1236         return (LRESULT)(*(void*(*)(void))wParam)();
1237       }
1238 
1239       case WM_AWT_SETOPENSTATUS: {
1240           ImmSetOpenStatus((HIMC)wParam, (BOOL)lParam);
1241           return 0;
1242       }
1243       case WM_AWT_GETOPENSTATUS: {
1244           return (DWORD)ImmGetOpenStatus((HIMC)wParam);
1245       }
1246       case WM_DISPLAYCHANGE: {
1247           // Reinitialize screens
1248           initScreens(env);
1249 
1250           // Notify Java side - call WToolkit.displayChanged()
1251           jclass clazz = env-&gt;FindClass(&quot;sun/awt/windows/WToolkit&quot;);
1252           DASSERT(clazz != NULL);
1253           if (!clazz) throw std::bad_alloc();
1254           env-&gt;CallStaticVoidMethod(clazz, AwtToolkit::displayChangeMID);
1255 
1256           GetInstance().m_displayChanged = TRUE;
1257 
1258           ::PostMessage(HWND_BROADCAST, WM_PALETTEISCHANGING, NULL, NULL);
1259           break;
1260       }
1261       case WM_AWT_SETCURSOR: {
1262           ::SetCursor((HCURSOR)wParam);
1263           return TRUE;
1264       }
1265       /* Session management */
1266       case WM_QUERYENDSESSION: {
1267           /* Shut down cleanly */
1268           if (!isSuddenTerminationEnabled) {
1269               return FALSE;
1270           }
1271           if (JVM_RaiseSignal(SIGTERM)) {
1272               AwtToolkit::GetInstance().m_vmSignalled = TRUE;
1273           }
1274           return TRUE;
1275       }
1276       case WM_ENDSESSION: {
1277           // Keep pumping messages until the shutdown sequence halts the VM,
1278           // or we exit the MessageLoop because of a WM_QUIT message
1279           AwtToolkit&amp; tk = AwtToolkit::GetInstance();
1280 
1281           // if WM_QUERYENDSESSION hasn&#39;t successfully raised SIGTERM
1282           // we ignore the ENDSESSION message
1283           if (!tk.m_vmSignalled) {
1284               return 0;
1285           }
1286           tk.MessageLoop(AwtToolkit::PrimaryIdleFunc,
1287                          AwtToolkit::CommonPeekMessageFunc);
1288 
1289           // Dispose here instead of in eventLoop so that we don&#39;t have
1290           // to return from the WM_ENDSESSION handler.
1291           tk.Dispose();
1292 
1293           // Never return. The VM will halt the process.
1294           hang_if_shutdown();
1295 
1296           // Should never get here.
1297           DASSERT(FALSE);
1298           break;
1299       }
1300 #ifndef WM_WTSSESSION_CHANGE
1301 #define WM_WTSSESSION_CHANGE        0x02B1
1302 #define WTS_CONSOLE_CONNECT 0x1
1303 #define WTS_CONSOLE_DISCONNECT 0x2
1304 #define WTS_REMOTE_CONNECT 0x3
1305 #define WTS_REMOTE_DISCONNECT 0x4
1306 #define WTS_SESSION_LOGON 0x5
1307 #define WTS_SESSION_LOGOFF 0x6
1308 #define WTS_SESSION_LOCK 0x7
1309 #define WTS_SESSION_UNLOCK 0x8
1310 #define WTS_SESSION_REMOTE_CONTROL 0x9
1311 #endif // WM_WTSSESSION_CHANGE
1312       case WM_WTSSESSION_CHANGE: {
1313           jclass clzz = env-&gt;FindClass(&quot;sun/awt/windows/WDesktopPeer&quot;);
1314           DASSERT(clzz != NULL);
1315           if (!clzz) throw std::bad_alloc();
1316 
1317           if (wParam == WTS_CONSOLE_CONNECT
1318                 || wParam == WTS_CONSOLE_DISCONNECT
1319                 || wParam == WTS_REMOTE_CONNECT
1320                 || wParam == WTS_REMOTE_DISCONNECT
1321                 || wParam == WTS_SESSION_UNLOCK
1322                 || wParam == WTS_SESSION_LOCK) {
1323 
1324               BOOL activate = wParam == WTS_CONSOLE_CONNECT
1325                                 || wParam == WTS_REMOTE_CONNECT
1326                                 || wParam == WTS_SESSION_UNLOCK;
1327               jobject reason = reasonUnspecified;
1328 
1329               switch (wParam) {
1330                   case WTS_CONSOLE_CONNECT:
1331                   case WTS_CONSOLE_DISCONNECT:
1332                       reason = reasonConsole;
1333                       break;
1334                   case WTS_REMOTE_CONNECT:
1335                   case WTS_REMOTE_DISCONNECT:
1336                       reason = reasonRemote;
1337                       break;
1338                   case WTS_SESSION_UNLOCK:
1339                   case WTS_SESSION_LOCK:
1340                       reason = reasonLock;
1341               }
1342 
1343               env-&gt;CallStaticVoidMethod(clzz, AwtToolkit::userSessionMID,
1344                                               activate
1345                                               ? JNI_TRUE
1346                                               : JNI_FALSE, reason);
1347           }
1348           break;
1349       }
1350       case WM_POWERBROADCAST: {
1351           jclass clzz = env-&gt;FindClass(&quot;sun/awt/windows/WDesktopPeer&quot;);
1352           DASSERT(clzz != NULL);
1353           if (!clzz) throw std::bad_alloc();
1354 
1355           if (wParam == PBT_APMSUSPEND || wParam == PBT_APMRESUMEAUTOMATIC) {
1356               env-&gt;CallStaticVoidMethod(clzz, AwtToolkit::systemSleepMID,
1357                                             wParam == PBT_APMRESUMEAUTOMATIC
1358                                                 ? JNI_TRUE
1359                                                 : JNI_FALSE);
1360           }
1361           break;
1362       }
1363       case WM_SYNC_WAIT:
1364           SetEvent(AwtToolkit::GetInstance().m_waitEvent);
1365           break;
1366     }
1367 
1368     return DefWindowProc(hWnd, message, wParam, lParam);
1369 
1370     CATCH_BAD_ALLOC_RET(0);
1371 }
1372 
1373 LRESULT CALLBACK AwtToolkit::GetMessageFilter(int code,
1374                                               WPARAM wParam, LPARAM lParam)
1375 {
1376     TRY;
1377 
1378     if (code &gt;= 0 &amp;&amp; wParam == PM_REMOVE &amp;&amp; lParam != 0) {
1379        if (AwtToolkit::GetInstance().PreProcessMsg(*(MSG*)lParam) !=
1380                mrPassAlong) {
1381            /* PreProcessMsg() wants us to eat it */
1382            ((MSG*)lParam)-&gt;message = WM_NULL;
1383        }
1384     }
1385     return ::CallNextHookEx(AwtToolkit::GetInstance().m_hGetMessageHook, code,
1386                             wParam, lParam);
1387 
1388     CATCH_BAD_ALLOC_RET(0);
1389 }
1390 
1391 void AwtToolkit::InstallMouseLowLevelHook()
1392 {
1393     // We need the low-level hook since we need to process mouse move
1394     // messages outside of our windows.
1395     m_hMouseLLHook = ::SetWindowsHookEx(WH_MOUSE_LL,
1396             (HOOKPROC)MouseLowLevelHook,
1397             GetModuleHandle(), NULL);
1398 
1399     // Reset the old value
1400     m_lastWindowUnderMouse = NULL;
1401 }
1402 
1403 void AwtToolkit::UninstallMouseLowLevelHook()
1404 {
1405     if (m_hMouseLLHook != 0) {
1406         ::UnhookWindowsHookEx(m_hMouseLLHook);
1407         m_hMouseLLHook = 0;
1408     }
1409 }
1410 
1411 LRESULT CALLBACK AwtToolkit::MouseLowLevelHook(int code,
1412         WPARAM wParam, LPARAM lParam)
1413 {
1414     TRY;
1415 
1416     if (code &gt;= 0 &amp;&amp; wParam == WM_MOUSEMOVE) {
1417         POINT pt = ((MSLLHOOKSTRUCT*)lParam)-&gt;pt;
1418 
1419         // We can&#39;t use GA_ROOTOWNER since in this case we&#39;ll go up to
1420         // the root Java toplevel, not the actual owned toplevel.
1421         HWND hwnd = ::GetAncestor(::WindowFromPoint(pt), GA_ROOT);
1422 
1423         AwtToolkit&amp; tk = AwtToolkit::GetInstance();
1424 
1425         if (tk.m_lastWindowUnderMouse != hwnd) {
1426             AwtWindow *fw = NULL, *tw = NULL;
1427 
1428             if (tk.m_lastWindowUnderMouse) {
1429                 fw = (AwtWindow*)
1430                     AwtComponent::GetComponent(tk.m_lastWindowUnderMouse);
1431             }
1432             if (hwnd) {
1433                 tw = (AwtWindow*)AwtComponent::GetComponent(hwnd);
1434             }
1435 
1436             tk.m_lastWindowUnderMouse = hwnd;
1437 
1438             if (fw) {
1439                 fw-&gt;UpdateSecurityWarningVisibility();
1440             }
1441             // ... however, because we use GA_ROOT, we may find the warningIcon
1442             // which is not a Java windows.
1443             if (AwtWindow::IsWarningWindow(hwnd)) {
1444                 hwnd = ::GetParent(hwnd);
1445                 if (hwnd) {
1446                     tw = (AwtWindow*)AwtComponent::GetComponent(hwnd);
1447                 }
1448                 tk.m_lastWindowUnderMouse = hwnd;
1449             }
1450             if (tw) {
1451                 tw-&gt;UpdateSecurityWarningVisibility();
1452             }
1453 
1454 
1455         }
1456     }
1457 
1458     return ::CallNextHookEx(AwtToolkit::GetInstance().m_hMouseLLHook, code,
1459             wParam, lParam);
1460 
1461     CATCH_BAD_ALLOC_RET(0);
1462 }
1463 
1464 /*
1465  * The main message loop
1466  */
1467 
1468 const int AwtToolkit::EXIT_ENCLOSING_LOOP      = 0;
1469 const int AwtToolkit::EXIT_ALL_ENCLOSING_LOOPS = -1;
1470 
1471 
1472 /**
1473  * Called upon event idle to ensure that we have released any
1474  * CriticalSections that we took during window event processing.
1475  *
1476  * Note that this gets used more often than you would think; some
1477  * window moves actually happen over more than one event burst.  So,
1478  * for example, we might get a WINDOWPOSCHANGING event, then we
1479  * idle and release the lock here, then eventually we get the
1480  * WINDOWPOSCHANGED event.
1481  *
1482  * This method may be called from WToolkit.embeddedEventLoopIdleProcessing
1483  * if there is a separate event loop that must do the same CriticalSection
1484  * check.
1485  *
1486  * See bug #4526587 for more information.
1487  */
1488 void VerifyWindowMoveLockReleased()
1489 {
1490     if (windowMoveLockHeld) {
1491         windowMoveLockHeld = FALSE;
1492         windowMoveLock.Leave();
1493     }
1494 }
1495 
1496 UINT
1497 AwtToolkit::MessageLoop(IDLEPROC lpIdleFunc,
1498                         PEEKMESSAGEPROC lpPeekMessageFunc)
1499 {
1500     DTRACE_PRINTLN(&quot;AWT event loop started&quot;);
1501 
1502     DASSERT(lpIdleFunc != NULL);
1503     DASSERT(lpPeekMessageFunc != NULL);
1504 
1505     m_messageLoopResult = 0;
1506     while (!m_breakMessageLoop) {
1507 
1508         (*lpIdleFunc)();
1509 
1510         PumpWaitingMessages(lpPeekMessageFunc); /* pumps waiting messages */
1511 
1512         // Catch problems with windowMoveLock critical section.  In case we
1513         // misunderstood the way windows processes window move/resize
1514         // events, we don&#39;t want to hold onto the windowMoveLock CS forever.
1515         // If we&#39;ve finished processing events for now, release the lock
1516         // if held.
1517         VerifyWindowMoveLockReleased();
1518     }
1519     if (m_messageLoopResult == EXIT_ALL_ENCLOSING_LOOPS)
1520         ::PostQuitMessage(EXIT_ALL_ENCLOSING_LOOPS);
1521     m_breakMessageLoop = FALSE;
1522 
1523     DTRACE_PRINTLN(&quot;AWT event loop ended&quot;);
1524 
1525     return m_messageLoopResult;
1526 }
1527 
1528 /*
1529  * Exit the enclosing message loop(s).
1530  *
1531  * The message will be ignored if Windows is currently is in an internal
1532  * message loop (such as a scroll bar drag). So we first send IDCANCEL and
1533  * WM_CANCELMODE messages to every Window on the thread.
1534  */
1535 static BOOL CALLBACK CancelAllThreadWindows(HWND hWnd, LPARAM)
1536 {
1537     TRY;
1538 
1539     ::SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), (LPARAM)hWnd);
1540     ::SendMessage(hWnd, WM_CANCELMODE, 0, 0);
1541 
1542     return TRUE;
1543 
1544     CATCH_BAD_ALLOC_RET(FALSE);
1545 }
1546 
1547 static void DoQuitMessageLoop(void* param) {
1548     int status = *static_cast&lt;int*&gt;(param);
1549 
1550     AwtToolkit::GetInstance().QuitMessageLoop(status);
1551 }
1552 
1553 void AwtToolkit::QuitMessageLoop(int status) {
1554     /*
1555      * Fix for 4623377.
1556      * Reinvoke QuitMessageLoop on the toolkit thread, so that
1557      * m_breakMessageLoop is accessed on a single thread.
1558      */
1559     if (!AwtToolkit::IsMainThread()) {
1560         InvokeFunction(DoQuitMessageLoop, &amp;status);
1561         return;
1562     }
1563 
1564     /*
1565      * Fix for BugTraq ID 4445747.
1566      * EnumThreadWindows() is very slow during dnd on Win9X/ME.
1567      * This call is unnecessary during dnd, since we postpone processing of all
1568      * messages that can enter internal message loop until dnd is over.
1569      */
1570       if (status == EXIT_ALL_ENCLOSING_LOOPS) {
1571           ::EnumThreadWindows(MainThread(), (WNDENUMPROC)CancelAllThreadWindows,
1572                               0);
1573       }
1574 
1575     /*
1576      * Fix for 4623377.
1577      * Modal loop may not exit immediatelly after WM_CANCELMODE, so it still can
1578      * eat WM_QUIT message and the nested message loop will never exit.
1579      * The fix is to use AwtToolkit instance variables instead of WM_QUIT to
1580      * guarantee that we exit from the nested message loop when any possible
1581      * modal loop quits. In this case CancelAllThreadWindows is needed only to
1582      * ensure that the nested message loop exits quickly and doesn&#39;t wait until
1583      * a possible modal loop completes.
1584      */
1585     m_breakMessageLoop = TRUE;
1586     m_messageLoopResult = status;
1587 
1588     /*
1589      * Fix for 4683602.
1590      * Post an empty message, to wake up the toolkit thread
1591      * if it is currently in WaitMessage(),
1592      */
1593     PostMessage(WM_NULL);
1594 }
1595 
1596 /*
1597  * Called by the message loop to pump the message queue when there are
1598  * messages waiting. Can also be called anywhere to pump messages.
1599  */
1600 BOOL AwtToolkit::PumpWaitingMessages(PEEKMESSAGEPROC lpPeekMessageFunc)
1601 {
1602     MSG  msg;
1603     BOOL foundOne = FALSE;
1604 
1605     DASSERT(lpPeekMessageFunc != NULL);
1606 
1607     while (!m_breakMessageLoop &amp;&amp; (*lpPeekMessageFunc)(msg)) {
1608         foundOne = TRUE;
1609         ProcessMsg(msg);
1610     }
1611     return foundOne;
1612 }
1613 
1614 void AwtToolkit::PumpToDestroy(class AwtComponent* p)
1615 {
1616     MSG  msg;
1617 
1618     DASSERT(AwtToolkit::PrimaryIdleFunc != NULL);
1619     DASSERT(AwtToolkit::CommonPeekMessageFunc != NULL);
1620 
1621     while (p-&gt;IsDestroyPaused() &amp;&amp; !m_breakMessageLoop) {
1622 
1623         PrimaryIdleFunc();
1624 
1625         while (p-&gt;IsDestroyPaused() &amp;&amp; !m_breakMessageLoop &amp;&amp; CommonPeekMessageFunc(msg)) {
1626             ProcessMsg(msg);
1627         }
1628     }
1629 }
1630 
1631 void AwtToolkit::ProcessMsg(MSG&amp; msg)
1632 {
1633     if (msg.message == WM_QUIT) {
1634         m_breakMessageLoop = TRUE;
1635         m_messageLoopResult = static_cast&lt;UINT&gt;(msg.wParam);
1636         if (m_messageLoopResult == EXIT_ALL_ENCLOSING_LOOPS)
1637             ::PostQuitMessage(static_cast&lt;int&gt;(msg.wParam));  // make sure all loops exit
1638     }
1639     else if (msg.message != WM_NULL) {
1640         /*
1641         * The AWT in standalone mode (that is, dynamically loaded from the
1642         * Java VM) doesn&#39;t have any translation tables to worry about, so
1643         * TranslateAccelerator isn&#39;t called.
1644         */
1645 
1646         ::TranslateMessage(&amp;msg);
1647         ::DispatchMessage(&amp;msg);
1648     }
1649 }
1650 
1651 VOID CALLBACK
1652 AwtToolkit::PrimaryIdleFunc() {
1653     AwtToolkit::SetBusy(FALSE);
1654     ::WaitMessage();               /* allow system to go idle */
1655     AwtToolkit::SetBusy(TRUE);
1656 }
1657 
1658 VOID CALLBACK
1659 AwtToolkit::SecondaryIdleFunc() {
1660     ::WaitMessage();               /* allow system to go idle */
1661 }
1662 
1663 BOOL
1664 AwtToolkit::CommonPeekMessageFunc(MSG&amp; msg) {
1665     return ::PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE);
1666 }
1667 
1668 /*
1669  * Perform pre-processing on a message before it is translated &amp;
1670  * dispatched.  Returns true to eat the message
1671  */
1672 BOOL AwtToolkit::PreProcessMsg(MSG&amp; msg)
1673 {
1674     /*
1675      * Offer preprocessing first to the target component, then call out to
1676      * specific mouse and key preprocessor methods
1677      */
1678     AwtComponent* p = AwtComponent::GetComponent(msg.hwnd);
1679     if (p &amp;&amp; p-&gt;PreProcessMsg(msg) == mrConsume)
1680         return TRUE;
1681 
1682     if ((msg.message &gt;= WM_MOUSEFIRST &amp;&amp; msg.message &lt;= WM_MOUSELAST) ||
1683         (msg.message &gt;= WM_NCMOUSEMOVE &amp;&amp; msg.message &lt;= WM_NCMBUTTONDBLCLK)) {
1684         if (PreProcessMouseMsg(p, msg)) {
1685             return TRUE;
1686         }
1687     }
1688     else if (msg.message &gt;= WM_KEYFIRST &amp;&amp; msg.message &lt;= WM_KEYLAST) {
1689         if (PreProcessKeyMsg(p, msg))
1690             return TRUE;
1691     }
1692     return FALSE;
1693 }
1694 
1695 BOOL AwtToolkit::PreProcessMouseMsg(AwtComponent* p, MSG&amp; msg)
1696 {
1697     WPARAM mouseWParam;
1698     LPARAM mouseLParam;
1699 
1700     /*
1701      * Fix for BugTraq ID 4395290.
1702      * Do not synthesize mouse enter/exit events during drag-and-drop,
1703      * since it messes up LightweightDispatcher.
1704      */
1705     if (AwtDropTarget::IsLocalDnD()) {
1706         return FALSE;
1707     }
1708 
1709     if (msg.message &gt;= WM_MOUSEFIRST &amp;&amp; msg.message &lt;= WM_MOUSELAST) {
1710         mouseWParam = msg.wParam;
1711         mouseLParam = msg.lParam;
1712     } else {
1713         mouseWParam = GetMouseKeyState();
1714     }
1715 
1716     /*
1717      * Get the window under the mouse, as it will be different if its
1718      * captured.
1719      */
1720     DWORD dwCurPos = ::GetMessagePos();
1721     DWORD dwScreenPos = dwCurPos;
1722     POINT curPos;
1723     // fix for 4805862
1724     // According to MSDN: do not use LOWORD and HIWORD macros to extract x and
1725     // y coordinates because these macros return incorrect results on systems
1726     // with multiple monitors (signed values are treated as unsigned)
1727     curPos.x = GET_X_LPARAM(dwCurPos);
1728     curPos.y = GET_Y_LPARAM(dwCurPos);
1729     HWND hWndFromPoint = ::WindowFromPoint(curPos);
1730     // hWndFromPoint == 0 if mouse is over a scrollbar
1731     AwtComponent* mouseComp =
1732         AwtComponent::GetComponent(hWndFromPoint);
1733     // Need extra copies for non-client area issues
1734     HWND hWndForWheel = hWndFromPoint;
1735 
1736     // If the point under the mouse isn&#39;t in the client area,
1737     // ignore it to maintain compatibility with Solaris (#4095172)
1738     RECT windowRect;
1739     ::GetClientRect(hWndFromPoint, &amp;windowRect);
1740     POINT topLeft;
1741     topLeft.x = 0;
1742     topLeft.y = 0;
1743     ::ClientToScreen(hWndFromPoint, &amp;topLeft);
1744     windowRect.top += topLeft.y;
1745     windowRect.bottom += topLeft.y;
1746     windowRect.left += topLeft.x;
1747     windowRect.right += topLeft.x;
1748     if ((curPos.y &lt; windowRect.top) ||
1749         (curPos.y &gt;= windowRect.bottom) ||
1750         (curPos.x &lt; windowRect.left) ||
1751         (curPos.x &gt;= windowRect.right)) {
1752         mouseComp = NULL;
1753         hWndFromPoint = NULL;
1754     }
1755 
1756     /*
1757      * Look for mouse transitions between windows &amp; create
1758      * MouseExit &amp; MouseEnter messages
1759      */
1760     // 6479820. Should check if a window is in manual resizing process: skip
1761     // sending any MouseExit/Enter events while inside resize-loop.
1762     // Note that window being in manual moving process could still
1763     // produce redundant enter/exit mouse events. In future, they can be
1764     // made skipped in a similar way.
1765     if (mouseComp != m_lastMouseOver &amp;&amp; !AwtWindow::IsResizing()) {
1766         /*
1767          * Send the messages right to the windows so that they are in
1768          * the right sequence.
1769          */
1770         if (m_lastMouseOver) {
1771             dwCurPos = dwScreenPos;
1772             curPos.x = LOWORD(dwCurPos);
1773             curPos.y = HIWORD(dwCurPos);
1774             ::MapWindowPoints(HWND_DESKTOP, m_lastMouseOver-&gt;GetHWnd(),
1775                               &amp;curPos, 1);
1776             mouseLParam = MAKELPARAM((WORD)curPos.x, (WORD)curPos.y);
1777             m_lastMouseOver-&gt;SendMessage(WM_AWT_MOUSEEXIT, mouseWParam,
1778                                          mouseLParam);
1779         }
1780         if (mouseComp) {
1781                 dwCurPos = dwScreenPos;
1782                 curPos.x = LOWORD(dwCurPos);
1783                 curPos.y = HIWORD(dwCurPos);
1784                 ::MapWindowPoints(HWND_DESKTOP, mouseComp-&gt;GetHWnd(),
1785                                   &amp;curPos, 1);
1786                 mouseLParam = MAKELPARAM((WORD)curPos.x, (WORD)curPos.y);
1787             mouseComp-&gt;SendMessage(WM_AWT_MOUSEENTER, mouseWParam,
1788                                    mouseLParam);
1789         }
1790         m_lastMouseOver = mouseComp;
1791     }
1792 
1793     /*
1794      * For MouseWheelEvents, hwnd must be changed to be the Component under
1795      * the mouse, not the Component with the input focus.
1796      */
1797 
1798     if (msg.message == WM_MOUSEWHEEL || msg.message == WM_MOUSEHWHEEL) {
1799             //i.e. mouse is over client area for this window
1800             DWORD hWndForWheelProcess;
1801             DWORD hWndForWheelThread = ::GetWindowThreadProcessId(hWndForWheel, &amp;hWndForWheelProcess);
1802             if (::GetCurrentProcessId() == hWndForWheelProcess) {
1803                 if (AwtToolkit::MainThread() == hWndForWheelThread) {
1804                     msg.hwnd = hWndForWheel;
1805                 } else {
1806                     // Interop mode, redispatch the event to another toolkit.
1807                     ::SendMessage(hWndForWheel, msg.message, mouseWParam, mouseLParam);
1808                     return TRUE;
1809                 }
1810             }
1811     }
1812 
1813     /*
1814      * Make sure we get at least one last chance to check for transitions
1815      * before we sleep
1816      */
1817     if (m_lastMouseOver &amp;&amp; !m_timer) {
1818         m_timer = ::SetTimer(m_toolkitHWnd, IDT_AWT_MOUSECHECK, 200, 0);
1819     }
1820     return FALSE;  /* Now go ahead and process current message as usual */
1821 }
1822 
1823 BOOL AwtToolkit::PreProcessKeyMsg(AwtComponent* p, MSG&amp; msg)
1824 {
1825     // get keyboard state for use in AwtToolkit::GetKeyboardState
1826     CriticalSection::Lock       l(m_lockKB);
1827     ::GetKeyboardState(m_lastKeyboardState);
1828     return FALSE;
1829 }
1830 
1831 void *AwtToolkit::SyncCall(void *(*ftn)(void *), void *param) {
1832     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1833     if (!IsMainThread()) {
1834         CriticalSection::Lock l(GetSyncCS());
1835         return (*ftn)(param);
1836     } else {
1837         return (*ftn)(param);
1838     }
1839 }
1840 
1841 void AwtToolkit::SyncCall(void (*ftn)(void *), void *param) {
1842     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1843     if (!IsMainThread()) {
1844         CriticalSection::Lock l(GetSyncCS());
1845         (*ftn)(param);
1846     } else {
1847         (*ftn)(param);
1848     }
1849 }
1850 
1851 void *AwtToolkit::SyncCall(void *(*ftn)(void)) {
1852     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1853     if (!IsMainThread()) {
1854         CriticalSection::Lock l(GetSyncCS());
1855         return (*ftn)();
1856     } else {
1857         return (*ftn)();
1858     }
1859 }
1860 
1861 void AwtToolkit::SyncCall(void (*ftn)(void)) {
1862     JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1863     if (!IsMainThread()) {
1864         CriticalSection::Lock l(GetSyncCS());
1865         (*ftn)();
1866     } else {
1867         (*ftn)();
1868     }
1869 }
1870 
1871 jboolean AwtToolkit::isFreeIDAvailable()
1872 {
1873     return m_cmdIDs-&gt;isFreeIDAvailable();
1874 }
1875 
1876 UINT AwtToolkit::CreateCmdID(AwtObject* object)
1877 {
1878     return m_cmdIDs-&gt;Add(object);
1879 }
1880 
1881 void AwtToolkit::RemoveCmdID(UINT id)
1882 {
1883     m_cmdIDs-&gt;Remove(id);
1884 }
1885 
1886 AwtObject* AwtToolkit::LookupCmdID(UINT id)
1887 {
1888     return m_cmdIDs-&gt;Lookup(id);
1889 }
1890 
1891 HICON AwtToolkit::GetAwtIcon()
1892 {
1893     return ::LoadIcon(GetModuleHandle(), TEXT(&quot;AWT_ICON&quot;));
1894 }
1895 
1896 HICON AwtToolkit::GetAwtIconSm()
1897 {
1898     static HICON defaultIconSm = NULL;
1899     static int prevSmx = 0;
1900     static int prevSmy = 0;
1901 
1902     int smx = GetSystemMetrics(SM_CXSMICON);
1903     int smy = GetSystemMetrics(SM_CYSMICON);
1904 
1905     // Fixed 6364216: LoadImage() may leak memory
1906     if (defaultIconSm == NULL || smx != prevSmx || smy != prevSmy) {
1907         defaultIconSm = (HICON)LoadImage(GetModuleHandle(), TEXT(&quot;AWT_ICON&quot;), IMAGE_ICON, smx, smy, 0);
1908         prevSmx = smx;
1909         prevSmy = smy;
1910     }
1911     return defaultIconSm;
1912 }
1913 
1914 // The icon at index 0 must be gray. See AwtWindow::GetSecurityWarningIcon()
1915 HICON AwtToolkit::GetSecurityWarningIcon(UINT index, UINT w, UINT h)
1916 {
1917     //Note: should not exceed 10 because of the current implementation.
1918     static const int securityWarningIconCounter = 3;
1919 
1920     static HICON securityWarningIcon[securityWarningIconCounter]      = {NULL, NULL, NULL};;
1921     static UINT securityWarningIconWidth[securityWarningIconCounter]  = {0, 0, 0};
1922     static UINT securityWarningIconHeight[securityWarningIconCounter] = {0, 0, 0};
1923 
1924     index = AwtToolkit::CalculateWave(index, securityWarningIconCounter);
1925 
1926     if (securityWarningIcon[index] == NULL ||
1927             w != securityWarningIconWidth[index] ||
1928             h != securityWarningIconHeight[index])
1929     {
1930         if (securityWarningIcon[index] != NULL)
1931         {
1932             ::DestroyIcon(securityWarningIcon[index]);
1933         }
1934 
1935         static const wchar_t securityWarningIconName[] = L&quot;SECURITY_WARNING_&quot;;
1936         wchar_t iconResourceName[sizeof(securityWarningIconName) + 2];
1937         ::ZeroMemory(iconResourceName, sizeof(iconResourceName));
1938         wcscpy(iconResourceName, securityWarningIconName);
1939 
1940         wchar_t strIndex[2];
1941         ::ZeroMemory(strIndex, sizeof(strIndex));
1942         strIndex[0] = L&#39;0&#39; + index;
1943 
1944         wcscat(iconResourceName, strIndex);
1945 
1946         securityWarningIcon[index] = (HICON)::LoadImage(GetModuleHandle(),
1947                 iconResourceName,
1948                 IMAGE_ICON, w, h, LR_DEFAULTCOLOR);
1949         securityWarningIconWidth[index] = w;
1950         securityWarningIconHeight[index] = h;
1951     }
1952 
1953     return securityWarningIcon[index];
1954 }
1955 
1956 void AwtToolkit::SetHeapCheck(long flag) {
1957     if (flag) {
1958         printf(&quot;heap checking not supported with this build\n&quot;);
1959     }
1960 }
1961 
1962 void throw_if_shutdown(void) throw (awt_toolkit_shutdown)
1963 {
1964     AwtToolkit::GetInstance().VerifyActive();
1965 }
1966 void hang_if_shutdown(void)
1967 {
1968     try {
1969         AwtToolkit::GetInstance().VerifyActive();
1970     } catch (awt_toolkit_shutdown&amp;) {
1971         // Never return. The VM will halt the process.
1972         ::WaitForSingleObject(::CreateEvent(NULL, TRUE, FALSE, NULL),
1973                               INFINITE);
1974         // Should never get here.
1975         DASSERT(FALSE);
1976     }
1977 }
1978 
1979 // for now we support only one embedder, but should be ready for future
1980 void AwtToolkit::RegisterEmbedderProcessId(HWND embedder)
1981 {
1982     if (m_embedderProcessID) {
1983         // we already set embedder process and do not expect
1984         // two different processes to embed the same AwtToolkit
1985         return;
1986     }
1987 
1988     embedder = ::GetAncestor(embedder, GA_ROOT);
1989     ::GetWindowThreadProcessId(embedder, &amp;m_embedderProcessID);
1990 }
1991 
1992 JNIEnv* AwtToolkit::m_env;
1993 DWORD AwtToolkit::m_threadId;
1994 
1995 void AwtToolkit::SetEnv(JNIEnv *env) {
1996     if (m_env != NULL) { // If already cashed (by means of embeddedInit() call).
1997         return;
1998     }
1999     m_threadId = GetCurrentThreadId();
2000     m_env = env;
2001 }
2002 
2003 JNIEnv* AwtToolkit::GetEnv() {
2004     return (m_env == NULL || m_threadId != GetCurrentThreadId()) ?
2005         (JNIEnv*)JNU_GetEnv(jvm, JNI_VERSION_1_2) : m_env;
2006 }
2007 
2008 BOOL AwtToolkit::GetScreenInsets(int screenNum, RECT * rect)
2009 {
2010     /* if primary display */
2011     if (screenNum == 0) {
2012         RECT rRW;
2013         if (::SystemParametersInfo(SPI_GETWORKAREA,0,(void *) &amp;rRW,0) == TRUE) {
2014             rect-&gt;top = rRW.top;
2015             rect-&gt;left = rRW.left;
2016             rect-&gt;bottom = ::GetSystemMetrics(SM_CYSCREEN) - rRW.bottom;
2017             rect-&gt;right = ::GetSystemMetrics(SM_CXSCREEN) - rRW.right;
2018             return TRUE;
2019         }
2020     }
2021     /* if additional display */
2022     else {
2023         MONITORINFO *miInfo;
2024         miInfo = AwtWin32GraphicsDevice::GetMonitorInfo(screenNum);
2025         if (miInfo) {
2026             rect-&gt;top = miInfo-&gt;rcWork.top    - miInfo-&gt;rcMonitor.top;
2027             rect-&gt;left = miInfo-&gt;rcWork.left   - miInfo-&gt;rcMonitor.left;
2028             rect-&gt;bottom = miInfo-&gt;rcMonitor.bottom - miInfo-&gt;rcWork.bottom;
2029             rect-&gt;right = miInfo-&gt;rcMonitor.right - miInfo-&gt;rcWork.right;
2030             return TRUE;
2031         }
2032     }
2033     return FALSE;
2034 }
2035 
2036 
2037 void AwtToolkit::GetWindowRect(HWND hWnd, LPRECT lpRect)
2038 {
2039     try {
2040         if (S_OK == DwmAPI::DwmGetWindowAttribute(hWnd,
2041                 DwmAPI::DWMWA_EXTENDED_FRAME_BOUNDS,
2042                 lpRect, sizeof(*lpRect)))
2043         {
2044             return;
2045         }
2046     } catch (const DllUtil::Exception &amp;) {}
2047 
2048     ::GetWindowRect(hWnd, lpRect);
2049 }
2050 
2051 
2052 /************************************************************************
2053  * AWT preloading support
2054  */
2055 bool AwtToolkit::PreloadAction::EnsureInited()
2056 {
2057     DWORD _initThreadId = GetInitThreadID();
2058     if (_initThreadId != 0) {
2059         // already inited
2060         // ensure the action is inited on correct thread
2061         PreloadThread &amp;preloadThread
2062             = AwtToolkit::GetInstance().GetPreloadThread();
2063         if (_initThreadId == preloadThread.GetThreadId()) {
2064             if (!preloadThread.IsWrongThread()) {
2065                 return true;
2066             }
2067             // inited on preloadThread (wrongThread), not cleaned yet
2068             // have to wait cleanup completion
2069             preloadThread.Wait4Finish();
2070         } else {
2071             // inited on other thread (Toolkit thread?)
2072             // consider as correctly inited
2073             return true;
2074         }
2075     }
2076 
2077     // init on Toolkit thread
2078     AwtToolkit::GetInstance().InvokeFunction(InitWrapper, this);
2079 
2080     return true;
2081 }
2082 
2083 DWORD AwtToolkit::PreloadAction::GetInitThreadID()
2084 {
2085     CriticalSection::Lock lock(initLock);
2086     return initThreadId;
2087 }
2088 
2089 bool AwtToolkit::PreloadAction::Clean()
2090 {
2091     DWORD _initThreadId = GetInitThreadID();
2092     if (_initThreadId == ::GetCurrentThreadId()) {
2093         // inited on this thread
2094         Clean(false);
2095         return true;
2096     }
2097     return false;
2098 }
2099 
2100 /*static*/
2101 void AwtToolkit::PreloadAction::InitWrapper(void *param)
2102 {
2103     PreloadAction *pThis = (PreloadAction *)param;
2104     pThis-&gt;Init();
2105 }
2106 
2107 void AwtToolkit::PreloadAction::Init()
2108 {
2109     CriticalSection::Lock lock(initLock);
2110     if (initThreadId == 0) {
2111         initThreadId = ::GetCurrentThreadId();
2112         InitImpl();
2113     }
2114 }
2115 
2116 void AwtToolkit::PreloadAction::Clean(bool reInit) {
2117     CriticalSection::Lock lock(initLock);
2118     if (initThreadId != 0) {
2119         //ASSERT(initThreadId == ::GetCurrentThreadId());
2120         CleanImpl(reInit);
2121         initThreadId = 0;
2122     }
2123 }
2124 
2125 // PreloadThread implementation
2126 AwtToolkit::PreloadThread::PreloadThread()
2127     : status(None), wrongThread(false), threadId(0),
2128     pActionChain(NULL), pLastProcessedAction(NULL),
2129     execFunc(NULL), execParam(NULL)
2130 {
2131     hFinished = ::CreateEvent(NULL, TRUE, FALSE, NULL);
2132     hAwake = ::CreateEvent(NULL, FALSE, FALSE, NULL);
2133 }
2134 
2135 AwtToolkit::PreloadThread::~PreloadThread()
2136 {
2137     //Terminate(false);
2138     ::CloseHandle(hFinished);
2139     ::CloseHandle(hAwake);
2140 }
2141 
2142 bool AwtToolkit::PreloadThread::AddAction(AwtToolkit::PreloadAction *pAction)
2143 {
2144     CriticalSection::Lock lock(threadLock);
2145 
2146     if (status &gt; Preloading) {
2147         // too late - the thread already terminated or run as toolkit thread
2148         return false;
2149     }
2150 
2151     if (pActionChain == NULL) {
2152         // 1st action
2153         pActionChain = pAction;
2154     } else {
2155         // add the action to the chain
2156         PreloadAction *pChain = pActionChain;
2157         while (true) {
2158             PreloadAction *pNext = pChain-&gt;GetNext();
2159             if (pNext == NULL) {
2160                 break;
2161             }
2162             pChain = pNext;
2163         }
2164         pChain-&gt;SetNext(pAction);
2165     }
2166 
2167     if (status &gt; None) {
2168         // the thread is already running (status == Preloading)
2169         AwakeThread();
2170         return true;
2171     }
2172 
2173     // need to start thread
2174     ::ResetEvent(hAwake);
2175     ::ResetEvent(hFinished);
2176 
2177     HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0x100000, StaticThreadProc,
2178                                             this, 0, &amp;threadId);
2179 
2180     if (hThread == 0) {
2181         threadId = 0;
2182         return false;
2183     }
2184 
2185     status = Preloading;
2186 
2187     ::CloseHandle(hThread);
2188 
2189     return true;
2190 }
2191 
2192 bool AwtToolkit::PreloadThread::Terminate(bool wrongThread)
2193 {
2194     CriticalSection::Lock lock(threadLock);
2195 
2196     if (status != Preloading) {
2197         return false;
2198     }
2199 
2200     execFunc = NULL;
2201     execParam = NULL;
2202     this-&gt;wrongThread = wrongThread;
2203     status = Cleaning;
2204     AwakeThread();
2205 
2206     return true;
2207 }
2208 
2209 bool AwtToolkit::PreloadThread::InvokeAndTerminate(void(_cdecl *fn)(void *), void *param)
2210 {
2211     CriticalSection::Lock lock(threadLock);
2212 
2213     if (status != Preloading) {
2214         return false;
2215     }
2216 
2217     execFunc = fn;
2218     execParam = param;
2219     status = fn == NULL ? Cleaning : RunningToolkit;
2220     AwakeThread();
2221 
2222     return true;
2223 }
2224 
2225 bool AwtToolkit::PreloadThread::OnPreloadThread()
2226 {
2227     return GetThreadId() == ::GetCurrentThreadId();
2228 }
2229 
2230 /*static*/
2231 unsigned WINAPI AwtToolkit::PreloadThread::StaticThreadProc(void *param)
2232 {
2233     AwtToolkit::PreloadThread *pThis = (AwtToolkit::PreloadThread *)param;
2234     return pThis-&gt;ThreadProc();
2235 }
2236 
2237 unsigned AwtToolkit::PreloadThread::ThreadProc()
2238 {
2239     void(_cdecl *_execFunc)(void *) = NULL;
2240     void *_execParam = NULL;
2241     bool _wrongThread = false;
2242 
2243     // initialization
2244     while (true) {
2245         PreloadAction *pAction;
2246         {
2247             CriticalSection::Lock lock(threadLock);
2248             if (status != Preloading) {
2249                 // get invoke parameters
2250                 _execFunc = execFunc;
2251                 _execParam = execParam;
2252                 _wrongThread = wrongThread;
2253                 break;
2254             }
2255             pAction = GetNextAction();
2256         }
2257         if (pAction != NULL) {
2258             pAction-&gt;Init();
2259         } else {
2260             ::WaitForSingleObject(hAwake, INFINITE);
2261         }
2262     }
2263 
2264     // call a function from InvokeAndTerminate
2265     if (_execFunc != NULL) {
2266         _execFunc(_execParam);
2267     } else {
2268         // time to terminate..
2269     }
2270 
2271     // cleanup
2272     {
2273         CriticalSection::Lock lock(threadLock);
2274         pLastProcessedAction = NULL; // goto 1st action in the chain
2275         status = Cleaning;
2276     }
2277     for (PreloadAction *pAction = GetNextAction(); pAction != NULL;
2278             pAction = GetNextAction()) {
2279         pAction-&gt;Clean(_wrongThread);
2280     }
2281 
2282     // don&#39;t clear threadId! it is used by PreloadAction::EnsureInited
2283 
2284     {
2285         CriticalSection::Lock lock(threadLock);
2286         status = Finished;
2287     }
2288     ::SetEvent(hFinished);
2289     return 0;
2290 }
2291 
2292 AwtToolkit::PreloadAction* AwtToolkit::PreloadThread::GetNextAction()
2293 {
2294     CriticalSection::Lock lock(threadLock);
2295     PreloadAction *pAction = (pLastProcessedAction == NULL)
2296                                     ? pActionChain
2297                                     : pLastProcessedAction-&gt;GetNext();
2298     if (pAction != NULL) {
2299         pLastProcessedAction = pAction;
2300     }
2301 
2302     return pAction;
2303 }
2304 
2305 
2306 extern &quot;C&quot; {
2307 
2308 /* Terminates preload thread (if it&#39;s still alive
2309  * - it may occur if the application doesn&#39;t use AWT).
2310  * The function is called from launcher after completion main java thread.
2311  */
2312 __declspec(dllexport) void preloadStop()
2313 {
2314     AwtToolkit::GetInstance().GetPreloadThread().Terminate(false);
2315 }
2316 
2317 }
2318 
2319 
2320 /************************************************************************
2321  * Toolkit native methods
2322  */
2323 
2324 extern &quot;C&quot; {
2325 
2326 /*
2327  * Class:     java_awt_Toolkit
2328  * Method:    initIDs
2329  * Signature: ()V
2330  */
2331 JNIEXPORT void JNICALL
2332 Java_java_awt_Toolkit_initIDs(JNIEnv *env, jclass cls) {
2333     TRY;
2334 
2335     AwtToolkit::getDefaultToolkitMID =
2336         env-&gt;GetStaticMethodID(cls,&quot;getDefaultToolkit&quot;,&quot;()Ljava/awt/Toolkit;&quot;);
2337     DASSERT(AwtToolkit::getDefaultToolkitMID != NULL);
2338     CHECK_NULL(AwtToolkit::getDefaultToolkitMID);
2339 
2340     AwtToolkit::getFontMetricsMID =
2341         env-&gt;GetMethodID(cls, &quot;getFontMetrics&quot;, &quot;(Ljava/awt/Font;)Ljava/awt/FontMetrics;&quot;);
2342     DASSERT(AwtToolkit::getFontMetricsMID != NULL);
2343     CHECK_NULL(AwtToolkit::getFontMetricsMID);
2344 
2345     jclass insetsClass = env-&gt;FindClass(&quot;java/awt/Insets&quot;);
2346     DASSERT(insetsClass != NULL);
2347     CHECK_NULL(insetsClass);
2348     AwtToolkit::insetsMID = env-&gt;GetMethodID(insetsClass, &quot;&lt;init&gt;&quot;, &quot;(IIII)V&quot;);
2349     DASSERT(AwtToolkit::insetsMID != NULL);
2350     CHECK_NULL(AwtToolkit::insetsMID);
2351 
2352     CATCH_BAD_ALLOC;
2353 }
2354 
2355 
2356 } /* extern &quot;C&quot; */
2357 
2358 /************************************************************************
2359  * WToolkit native methods
2360  */
2361 
2362 extern &quot;C&quot; {
2363 
2364 /*
2365  * Class:     sun_awt_windows_WToolkit
2366  * Method:    initIDs
2367  * Signature: ()V
2368  */
2369 JNIEXPORT void JNICALL
2370 Java_sun_awt_windows_WToolkit_initIDs(JNIEnv *env, jclass cls)
2371 {
2372     TRY;
2373 
2374     AwtToolkit::windowsSettingChangeMID =
2375         env-&gt;GetMethodID(cls, &quot;windowsSettingChange&quot;, &quot;()V&quot;);
2376     DASSERT(AwtToolkit::windowsSettingChangeMID != 0);
2377     CHECK_NULL(AwtToolkit::windowsSettingChangeMID);
2378 
2379     AwtToolkit::displayChangeMID =
2380     env-&gt;GetStaticMethodID(cls, &quot;displayChanged&quot;, &quot;()V&quot;);
2381     DASSERT(AwtToolkit::displayChangeMID != 0);
2382     CHECK_NULL(AwtToolkit::displayChangeMID);
2383 
2384     // Set various global IDs needed by JAWT code.  Note: these
2385     // variables cannot be set by JAWT code directly due to
2386     // different permissions that that code may be run under
2387     // (bug 4796548).  It would be nice to initialize these
2388     // variables lazily, but given the minimal number of calls
2389     // for this, it seems simpler to just do it at startup with
2390     // negligible penalty.
2391     jclass sDataClassLocal = env-&gt;FindClass(&quot;sun/java2d/SurfaceData&quot;);
2392     DASSERT(sDataClassLocal != 0);
2393     CHECK_NULL(sDataClassLocal);
2394 
2395     jclass vImgClassLocal = env-&gt;FindClass(&quot;sun/awt/image/SunVolatileImage&quot;);
2396     DASSERT(vImgClassLocal != 0);
2397     CHECK_NULL(vImgClassLocal);
2398 
2399     jclass vSMgrClassLocal =
2400         env-&gt;FindClass(&quot;sun/awt/image/VolatileSurfaceManager&quot;);
2401     DASSERT(vSMgrClassLocal != 0);
2402     CHECK_NULL(vSMgrClassLocal);
2403 
2404     jclass componentClassLocal = env-&gt;FindClass(&quot;java/awt/Component&quot;);
2405     DASSERT(componentClassLocal != 0);
2406     CHECK_NULL(componentClassLocal);
2407 
2408     jawtSMgrID = env-&gt;GetFieldID(vImgClassLocal, &quot;volSurfaceManager&quot;,
2409                                  &quot;Lsun/awt/image/VolatileSurfaceManager;&quot;);
2410     DASSERT(jawtSMgrID != 0);
2411     CHECK_NULL(jawtSMgrID);
2412 
2413     jawtSDataID = env-&gt;GetFieldID(vSMgrClassLocal, &quot;sdCurrent&quot;,
2414                                   &quot;Lsun/java2d/SurfaceData;&quot;);
2415     DASSERT(jawtSDataID != 0);
2416     CHECK_NULL(jawtSDataID);
2417 
2418     jawtPDataID = env-&gt;GetFieldID(sDataClassLocal, &quot;pData&quot;, &quot;J&quot;);
2419     DASSERT(jawtPDataID != 0);
2420     CHECK_NULL(jawtPDataID);
2421     // Save these classes in global references for later use
2422     jawtVImgClass = (jclass)env-&gt;NewGlobalRef(vImgClassLocal);
2423     CHECK_NULL(jawtVImgClass);
2424     jawtComponentClass = (jclass)env-&gt;NewGlobalRef(componentClassLocal);
2425 
2426     jclass dPeerClassLocal = env-&gt;FindClass(&quot;sun/awt/windows/WDesktopPeer&quot;);
2427     DASSERT(dPeerClassLocal != 0);
2428     CHECK_NULL(dPeerClassLocal);
2429 
2430     jclass reasonClassLocal    = env-&gt;FindClass(&quot;java/awt/desktop/UserSessionEvent$Reason&quot;);
2431     CHECK_NULL(reasonClassLocal);
2432 
2433     reasonUnspecified = GetStaticObject(env, reasonClassLocal, &quot;UNSPECIFIED&quot;,
2434                                          &quot;Ljava/awt/desktop/UserSessionEvent$Reason;&quot;);
2435     CHECK_NULL (reasonUnspecified);
2436     reasonUnspecified = env-&gt;NewGlobalRef(reasonUnspecified);
2437 
2438     reasonConsole = GetStaticObject(env, reasonClassLocal, &quot;CONSOLE&quot;,
2439                                          &quot;Ljava/awt/desktop/UserSessionEvent$Reason;&quot;);
2440     CHECK_NULL (reasonConsole);
2441     reasonConsole = env-&gt;NewGlobalRef(reasonConsole);
2442 
2443     reasonRemote = GetStaticObject(env, reasonClassLocal, &quot;REMOTE&quot;,
2444                                          &quot;Ljava/awt/desktop/UserSessionEvent$Reason;&quot;);
2445     CHECK_NULL (reasonRemote);
2446     reasonRemote = env-&gt;NewGlobalRef(reasonRemote);
2447 
2448     reasonLock = GetStaticObject(env, reasonClassLocal, &quot;LOCK&quot;,
2449                                          &quot;Ljava/awt/desktop/UserSessionEvent$Reason;&quot;);
2450     CHECK_NULL (reasonLock);
2451     reasonLock = env-&gt;NewGlobalRef(reasonLock);
2452 
2453 
2454     AwtToolkit::userSessionMID =
2455     env-&gt;GetStaticMethodID(dPeerClassLocal, &quot;userSessionCallback&quot;,
2456                             &quot;(ZLjava/awt/desktop/UserSessionEvent$Reason;)V&quot;);
2457     DASSERT(AwtToolkit::userSessionMID != 0);
2458     CHECK_NULL(AwtToolkit::userSessionMID);
2459 
2460     AwtToolkit::systemSleepMID =
2461     env-&gt;GetStaticMethodID(dPeerClassLocal, &quot;systemSleepCallback&quot;, &quot;(Z)V&quot;);
2462     DASSERT(AwtToolkit::systemSleepMID != 0);
2463     CHECK_NULL(AwtToolkit::systemSleepMID);
2464 
2465     CATCH_BAD_ALLOC;
2466 }
2467 
2468 /*
2469  * Class:     sun_awt_windows_WToolkit
2470  * Method:    embeddedInit
2471  * Signature: ()Z
2472  */
2473 JNIEXPORT jboolean JNICALL
2474 Java_sun_awt_windows_WToolkit_embeddedInit(JNIEnv *env, jclass cls)
2475 {
2476     TRY;
2477 
2478     AwtToolkit::SetEnv(env);
2479 
2480     return AwtToolkit::GetInstance().Initialize(FALSE);
2481 
2482     CATCH_BAD_ALLOC_RET(JNI_FALSE);
2483 }
2484 
2485 /*
2486  * Class:     sun_awt_windows_WToolkit
2487  * Method:    embeddedDispose
2488  * Signature: ()Z
2489  */
2490 JNIEXPORT jboolean JNICALL
2491 Java_sun_awt_windows_WToolkit_embeddedDispose(JNIEnv *env, jclass cls)
2492 {
2493     TRY;
2494 
2495     BOOL retval = AwtToolkit::GetInstance().Dispose();
2496     AwtToolkit::GetInstance().SetPeer(env, NULL);
2497     return retval;
2498 
2499     CATCH_BAD_ALLOC_RET(JNI_FALSE);
2500 }
2501 
2502 /*
2503  * Class:     sun_awt_windows_WToolkit
2504  * Method:    embeddedEventLoopIdleProcessing
2505  * Signature: ()V
2506  */
2507 JNIEXPORT void JNICALL
2508 Java_sun_awt_windows_WToolkit_embeddedEventLoopIdleProcessing(JNIEnv *env,
2509     jobject self)
2510 {
2511     VerifyWindowMoveLockReleased();
2512 }
2513 
2514 
2515 /*
2516  * Class:     sun_awt_windows_WToolkit
2517  * Method:    init
2518  * Signature: ()Z
2519  */
2520 JNIEXPORT jboolean JNICALL
2521 Java_sun_awt_windows_WToolkit_init(JNIEnv *env, jobject self)
2522 {
2523     TRY;
2524 
2525     AwtToolkit::SetEnv(env);
2526 
2527     AwtToolkit::GetInstance().SetPeer(env, self);
2528 
2529     // This call will fail if the Toolkit was already initialized.
2530     // In that case, we don&#39;t want to start another message pump.
2531     return AwtToolkit::GetInstance().Initialize(TRUE);
2532 
2533     CATCH_BAD_ALLOC_RET(FALSE);
2534 }
2535 
2536 /*
2537  * Class:     sun_awt_windows_WToolkit
2538  * Method:    eventLoop
2539  * Signature: ()V
2540  */
2541 JNIEXPORT void JNICALL
2542 Java_sun_awt_windows_WToolkit_eventLoop(JNIEnv *env, jobject self)
2543 {
2544     TRY;
2545 
2546     DASSERT(AwtToolkit::GetInstance().localPump());
2547 
2548     AwtToolkit::SetBusy(TRUE);
2549 
2550     AwtToolkit::GetInstance().MessageLoop(AwtToolkit::PrimaryIdleFunc,
2551                                           AwtToolkit::CommonPeekMessageFunc);
2552 
2553     AwtToolkit::GetInstance().Dispose();
2554 
2555     AwtToolkit::SetBusy(FALSE);
2556 
2557     /*
2558      * IMPORTANT NOTES:
2559      *   The AwtToolkit has been destructed by now.
2560      * DO NOT CALL any method of AwtToolkit!!!
2561      */
2562 
2563     CATCH_BAD_ALLOC;
2564 }
2565 
2566 /*
2567  * Class:     sun_awt_windows_WToolkit
2568  * Method:    shutdown
2569  * Signature: ()V
2570  */
2571 JNIEXPORT void JNICALL
2572 Java_sun_awt_windows_WToolkit_shutdown(JNIEnv *env, jobject self)
2573 {
2574     TRY;
2575 
2576     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
2577 
2578     tk.QuitMessageLoop(AwtToolkit::EXIT_ALL_ENCLOSING_LOOPS);
2579 
2580     while (!tk.IsDisposed()) {
2581         Sleep(100);
2582     }
2583 
2584     CATCH_BAD_ALLOC;
2585 }
2586 
2587 /*
2588  * Class:     sun_awt_windows_WToolkit
2589  * Method:    startSecondaryEventLoop
2590  * Signature: ()V;
2591  */
2592 JNIEXPORT void JNICALL
2593 Java_sun_awt_windows_WToolkit_startSecondaryEventLoop(
2594     JNIEnv *env,
2595     jclass)
2596 {
2597     TRY;
2598 
2599     DASSERT(AwtToolkit::MainThread() == ::GetCurrentThreadId());
2600 
2601     AwtToolkit::GetInstance().MessageLoop(AwtToolkit::SecondaryIdleFunc,
2602                                           AwtToolkit::CommonPeekMessageFunc);
2603 
2604     CATCH_BAD_ALLOC;
2605 }
2606 
2607 /*
2608  * Class:     sun_awt_windows_WToolkit
2609  * Method:    quitSecondaryEventLoop
2610  * Signature: ()V;
2611  */
2612 JNIEXPORT void JNICALL
2613 Java_sun_awt_windows_WToolkit_quitSecondaryEventLoop(
2614     JNIEnv *env,
2615     jclass)
2616 {
2617     TRY;
2618 
2619     AwtToolkit::GetInstance().QuitMessageLoop(AwtToolkit::EXIT_ENCLOSING_LOOP);
2620 
2621     CATCH_BAD_ALLOC;
2622 }
2623 
2624 /*
2625  * Class:     sun_awt_windows_WToolkit
2626  * Method:    makeColorModel
2627  * Signature: ()Ljava/awt/image/ColorModel;
2628  */
2629 JNIEXPORT jobject JNICALL
2630 Java_sun_awt_windows_WToolkit_makeColorModel(JNIEnv *env, jclass cls)
2631 {
2632     TRY;
2633 
2634     return AwtWin32GraphicsDevice::GetColorModel(env, JNI_FALSE,
2635         AwtWin32GraphicsDevice::GetDefaultDeviceIndex());
2636 
2637     CATCH_BAD_ALLOC_RET(NULL);
2638 }
2639 
2640 /*
2641  * Class:     sun_awt_windows_WToolkit
2642  * Method:    getMaximumCursorColors
2643  * Signature: ()I
2644  */
2645 JNIEXPORT jint JNICALL
2646 Java_sun_awt_windows_WToolkit_getMaximumCursorColors(JNIEnv *env, jobject self)
2647 {
2648     TRY;
2649 
2650     HDC hIC = ::CreateIC(TEXT(&quot;DISPLAY&quot;), NULL, NULL, NULL);
2651 
2652     int nColor = 256;
2653     switch (::GetDeviceCaps(hIC, BITSPIXEL) * ::GetDeviceCaps(hIC, PLANES)) {
2654         case 1:         nColor = 2;             break;
2655         case 4:         nColor = 16;            break;
2656         case 8:         nColor = 256;           break;
2657         case 16:        nColor = 65536;         break;
2658         case 24:        nColor = 16777216;      break;
2659     }
2660     ::DeleteDC(hIC);
2661     return nColor;
2662 
2663     CATCH_BAD_ALLOC_RET(0);
2664 }
2665 
2666 /*
2667  * Class:     sun_awt_windows_WToolkit
2668  * Method:    getSreenInsets
2669  * Signature: (I)Ljava/awt/Insets;
2670  */
2671 JNIEXPORT jobject JNICALL
2672 Java_sun_awt_windows_WToolkit_getScreenInsets(JNIEnv *env,
2673                                               jobject self,
2674                                               jint screen)
2675 {
2676     jobject insets = NULL;
2677     RECT rect;
2678 
2679     TRY;
2680 
2681     if (AwtToolkit::GetScreenInsets(screen, &amp;rect)) {
2682         jclass insetsClass = env-&gt;FindClass(&quot;java/awt/Insets&quot;);
2683         DASSERT(insetsClass != NULL);
2684         CHECK_NULL_RETURN(insetsClass, NULL);
<a name="1" id="anc1"></a><span class="line-modified">2685         Devices::InstanceAccess devices;</span>
<span class="line-added">2686         AwtWin32GraphicsDevice *device = devices-&gt;GetDevice(screen);</span>
2687         insets = env-&gt;NewObject(insetsClass,
2688                 AwtToolkit::insetsMID,
<a name="2" id="anc2"></a><span class="line-modified">2689                 device == NULL ? rect.top : device-&gt;ScaleDownY(rect.top),</span>
<span class="line-modified">2690                 device == NULL ? rect.left : device-&gt;ScaleDownX(rect.left),</span>
<span class="line-modified">2691                 device == NULL ? rect.bottom : device-&gt;ScaleDownY(rect.bottom),</span>
<span class="line-modified">2692                 device == NULL ? rect.right : device-&gt;ScaleDownX(rect.right));</span>
2693     }
2694 
2695     if (safe_ExceptionOccurred(env)) {
2696         return 0;
2697     }
2698     return insets;
2699 
2700     CATCH_BAD_ALLOC_RET(NULL);
2701 }
2702 
2703 
2704 /*
2705  * Class:     sun_awt_windows_WToolkit
2706  * Method:    nativeSync
2707  * Signature: ()V
2708  */
2709 JNIEXPORT void JNICALL
2710 Java_sun_awt_windows_WToolkit_nativeSync(JNIEnv *env, jobject self)
2711 {
2712     TRY;
2713 
2714     // Synchronize both GDI and DDraw
2715     VERIFY(::GdiFlush());
2716 
2717     CATCH_BAD_ALLOC;
2718 }
2719 
2720 /*
2721  * Class:     sun_awt_windows_WToolkit
2722  * Method:    beep
2723  * Signature: ()V
2724  */
2725 JNIEXPORT void JNICALL
2726 Java_sun_awt_windows_WToolkit_beep(JNIEnv *env, jobject self)
2727 {
2728     TRY;
2729 
2730     VERIFY(::MessageBeep(MB_OK));
2731 
2732     CATCH_BAD_ALLOC;
2733 }
2734 
2735 /*
2736  * Class:     sun_awt_windows_WToolkit
2737  * Method:    getLockingKeyStateNative
2738  * Signature: (I)Z
2739  */
2740 JNIEXPORT jboolean JNICALL
2741 Java_sun_awt_windows_WToolkit_getLockingKeyStateNative(JNIEnv *env, jobject self, jint javaKey)
2742 {
2743     TRY;
2744 
2745     UINT windowsKey, modifiers;
2746     AwtComponent::JavaKeyToWindowsKey(javaKey, &amp;windowsKey, &amp;modifiers);
2747 
2748     if (windowsKey == 0) {
2749         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;Keyboard doesn&#39;t have requested key&quot;);
2750         return JNI_FALSE;
2751     }
2752 
2753     // low order bit in keyboardState indicates whether the key is toggled
2754     BYTE keyboardState[AwtToolkit::KB_STATE_SIZE];
2755     AwtToolkit::GetKeyboardState(keyboardState);
2756     return keyboardState[windowsKey] &amp; 0x01;
2757 
2758     CATCH_BAD_ALLOC_RET(JNI_FALSE);
2759 }
2760 
2761 /*
2762  * Class:     sun_awt_windows_WToolkit
2763  * Method:    setLockingKeyStateNative
2764  * Signature: (IZ)V
2765  */
2766 JNIEXPORT void JNICALL
2767 Java_sun_awt_windows_WToolkit_setLockingKeyStateNative(JNIEnv *env, jobject self, jint javaKey, jboolean state)
2768 {
2769     TRY;
2770 
2771     UINT windowsKey, modifiers;
2772     AwtComponent::JavaKeyToWindowsKey(javaKey, &amp;windowsKey, &amp;modifiers);
2773 
2774     if (windowsKey == 0) {
2775         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;Keyboard doesn&#39;t have requested key&quot;);
2776         return;
2777     }
2778 
2779     // if the key isn&#39;t in the desired state yet, simulate key events to get there
2780     // low order bit in keyboardState indicates whether the key is toggled
2781     BYTE keyboardState[AwtToolkit::KB_STATE_SIZE];
2782     AwtToolkit::GetKeyboardState(keyboardState);
2783     if ((keyboardState[windowsKey] &amp; 0x01) != state) {
2784         ::keybd_event(windowsKey, 0, 0, 0);
2785         ::keybd_event(windowsKey, 0, KEYEVENTF_KEYUP, 0);
2786     }
2787 
2788     CATCH_BAD_ALLOC;
2789 }
2790 
2791 /*
2792  * Class:     sun_awt_windows_WToolkit
2793  * Method:    loadSystemColors
2794  * Signature: ([I)V
2795  */
2796 JNIEXPORT void JNICALL
2797 Java_sun_awt_windows_WToolkit_loadSystemColors(JNIEnv *env, jobject self,
2798                                                jintArray colors)
2799 {
2800     TRY;
2801 
2802     static int indexMap[] = {
2803         COLOR_DESKTOP, /* DESKTOP */
2804         COLOR_ACTIVECAPTION, /* ACTIVE_CAPTION */
2805         COLOR_CAPTIONTEXT, /* ACTIVE_CAPTION_TEXT */
2806         COLOR_ACTIVEBORDER, /* ACTIVE_CAPTION_BORDER */
2807         COLOR_INACTIVECAPTION, /* INACTIVE_CAPTION */
2808         COLOR_INACTIVECAPTIONTEXT, /* INACTIVE_CAPTION_TEXT */
2809         COLOR_INACTIVEBORDER, /* INACTIVE_CAPTION_BORDER */
2810         COLOR_WINDOW, /* WINDOW */
2811         COLOR_WINDOWFRAME, /* WINDOW_BORDER */
2812         COLOR_WINDOWTEXT, /* WINDOW_TEXT */
2813         COLOR_MENU, /* MENU */
2814         COLOR_MENUTEXT, /* MENU_TEXT */
2815         COLOR_WINDOW, /* TEXT */
2816         COLOR_WINDOWTEXT, /* TEXT_TEXT */
2817         COLOR_HIGHLIGHT, /* TEXT_HIGHLIGHT */
2818         COLOR_HIGHLIGHTTEXT, /* TEXT_HIGHLIGHT_TEXT */
2819         COLOR_GRAYTEXT, /* TEXT_INACTIVE_TEXT */
2820         COLOR_3DFACE, /* CONTROL */
2821         COLOR_BTNTEXT, /* CONTROL_TEXT */
2822         COLOR_3DLIGHT, /* CONTROL_HIGHLIGHT */
2823         COLOR_3DHILIGHT, /* CONTROL_LT_HIGHLIGHT */
2824         COLOR_3DSHADOW, /* CONTROL_SHADOW */
2825         COLOR_3DDKSHADOW, /* CONTROL_DK_SHADOW */
2826         COLOR_SCROLLBAR, /* SCROLLBAR */
2827         COLOR_INFOBK, /* INFO */
2828         COLOR_INFOTEXT, /* INFO_TEXT */
2829     };
2830 
2831     jint colorLen = env-&gt;GetArrayLength(colors);
2832     jint* colorsPtr = NULL;
2833     try {
2834         colorsPtr = (jint *)env-&gt;GetPrimitiveArrayCritical(colors, 0);
2835         for (int i = 0; i &lt; (sizeof indexMap)/(sizeof *indexMap) &amp;&amp; i &lt; colorLen; i++) {
2836             colorsPtr[i] = DesktopColor2RGB(indexMap[i]);
2837         }
2838     } catch (...) {
2839         if (colorsPtr != NULL) {
2840             env-&gt;ReleasePrimitiveArrayCritical(colors, colorsPtr, 0);
2841         }
2842         throw;
2843     }
2844 
2845     env-&gt;ReleasePrimitiveArrayCritical(colors, colorsPtr, 0);
2846 
2847     CATCH_BAD_ALLOC;
2848 }
2849 
2850 extern &quot;C&quot; JNIEXPORT jobject JNICALL DSGetComponent
2851     (JNIEnv* env, void* platformInfo)
2852 {
2853     TRY;
2854 
2855     HWND hWnd = (HWND)platformInfo;
2856     if (!::IsWindow(hWnd))
2857         return NULL;
2858 
2859     AwtComponent* comp = AwtComponent::GetComponent(hWnd);
2860     if (comp == NULL)
2861         return NULL;
2862 
2863     return comp-&gt;GetTarget(env);
2864 
2865     CATCH_BAD_ALLOC_RET(NULL);
2866 }
2867 
2868 JNIEXPORT void JNICALL
2869 Java_sun_awt_windows_WToolkit_postDispose(JNIEnv *env, jclass clazz)
2870 {
2871 #ifdef DEBUG
2872     TRY_NO_VERIFY;
2873 
2874     // If this method was called, that means runFinalizersOnExit is turned
2875     // on and the VM is exiting cleanly. We should signal the debug memory
2876     // manager to generate a leaks report.
2877     AwtDebugSupport::GenerateLeaksReport();
2878 
2879     CATCH_BAD_ALLOC;
2880 #endif
2881 }
2882 
2883 /*
2884  * Class:     sun_awt_windows_WToolkit
2885  * Method:    setDynamicLayoutNative
2886  * Signature: (Z)V
2887  */
2888 JNIEXPORT void JNICALL
2889 Java_sun_awt_windows_WToolkit_setDynamicLayoutNative(JNIEnv *env,
2890   jobject self, jboolean dynamic)
2891 {
2892     TRY;
2893 
2894     AwtToolkit::GetInstance().SetDynamicLayout(dynamic);
2895 
2896     CATCH_BAD_ALLOC;
2897 }
2898 
2899 /*
2900  * Class:     sun_awt_windows_WToolkit
2901  * Method:    isDynamicLayoutSupportedNative
2902  * Signature: ()Z
2903  */
2904 JNIEXPORT jboolean JNICALL
2905 Java_sun_awt_windows_WToolkit_isDynamicLayoutSupportedNative(JNIEnv *env,
2906   jobject self)
2907 {
2908     TRY;
2909 
2910     return (jboolean) AwtToolkit::GetInstance().IsDynamicLayoutSupported();
2911 
2912     CATCH_BAD_ALLOC_RET(FALSE);
2913 }
2914 
2915 /*
2916  * Class:     sun_awt_windows_WToolkit
2917  * Method:    printWindowsVersion
2918  * Signature: ()Ljava/lang/String;
2919  */
2920 JNIEXPORT jstring JNICALL
2921 Java_sun_awt_windows_WToolkit_getWindowsVersion(JNIEnv *env, jclass cls)
2922 {
2923     TRY;
2924 
2925     WCHAR szVer[128];
2926 
2927     DWORD version = ::GetVersion();
2928     swprintf(szVer, 128, L&quot;0x%x = %ld&quot;, version, version);
2929     int l = lstrlen(szVer);
2930 
2931     if (IS_WIN2000) {
2932         if (IS_WINXP) {
2933             if (IS_WINVISTA) {
2934                 swprintf(szVer + l, 128, L&quot; (Windows Vista)&quot;);
2935             } else {
2936                 swprintf(szVer + l, 128, L&quot; (Windows XP)&quot;);
2937             }
2938         } else {
2939             swprintf(szVer + l, 128, L&quot; (Windows 2000)&quot;);
2940         }
2941     } else {
2942         swprintf(szVer + l, 128, L&quot; (Unknown)&quot;);
2943     }
2944 
2945     return JNU_NewStringPlatform(env, szVer);
2946 
2947     CATCH_BAD_ALLOC_RET(NULL);
2948 }
2949 
2950 JNIEXPORT void JNICALL
2951 Java_sun_awt_windows_WToolkit_showTouchKeyboard(JNIEnv *env, jobject self,
2952     jboolean causedByTouchEvent)
2953 {
2954     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
2955     if (!tk.IsWin8OrLater() || !tk.IsTouchKeyboardAutoShowEnabled()) {
2956         return;
2957     }
2958 
2959     if (causedByTouchEvent ||
2960         (tk.IsTouchKeyboardAutoShowSystemEnabled() &amp;&amp;
2961             !tk.IsAnyKeyboardAttached())) {
2962         tk.ShowTouchKeyboard();
2963     }
2964 }
2965 
2966 JNIEXPORT void JNICALL
2967 Java_sun_awt_windows_WToolkit_hideTouchKeyboard(JNIEnv *env, jobject self)
2968 {
2969     AwtToolkit&amp; tk = AwtToolkit::GetInstance();
2970     if (!tk.IsWin8OrLater() || !tk.IsTouchKeyboardAutoShowEnabled()) {
2971         return;
2972     }
2973     tk.HideTouchKeyboard();
2974 }
2975 
2976 JNIEXPORT jboolean JNICALL
2977 Java_sun_awt_windows_WToolkit_syncNativeQueue(JNIEnv *env, jobject self, jlong timeout)
2978 {
2979     AwtToolkit &amp; tk = AwtToolkit::GetInstance();
2980     DWORD eventNumber = tk.eventNumber;
2981     tk.PostMessage(WM_SYNC_WAIT, 0, 0);
2982     for(long t = 2; t &lt; timeout &amp;&amp;
2983                WAIT_TIMEOUT == ::WaitForSingleObject(tk.m_waitEvent, 2); t+=2) {
2984         if (tk.isInDoDragDropLoop) {
2985             break;
2986         }
2987     }
2988     DWORD newEventNumber = tk.eventNumber;
2989     return (newEventNumber - eventNumber) &gt; 2;
2990 }
2991 
2992 } /* extern &quot;C&quot; */
2993 
2994 /* Convert a Windows desktop color index into an RGB value. */
2995 COLORREF DesktopColor2RGB(int colorIndex) {
2996     DWORD sysColor = ::GetSysColor(colorIndex);
2997     return ((GetRValue(sysColor)&lt;&lt;16) | (GetGValue(sysColor)&lt;&lt;8) |
2998             (GetBValue(sysColor)) | 0xff000000);
2999 }
3000 
3001 
3002 /*
3003  * Class:     sun_awt_SunToolkit
3004  * Method:    closeSplashScreen
3005  * Signature: ()V
3006  */
3007 extern &quot;C&quot; JNIEXPORT void JNICALL
3008 Java_sun_awt_SunToolkit_closeSplashScreen(JNIEnv *env, jclass cls)
3009 {
3010     typedef void (*SplashClose_t)();
3011     HMODULE hSplashDll = GetModuleHandle(_T(&quot;splashscreen.dll&quot;));
3012     if (!hSplashDll) {
3013         return; // dll not loaded
3014     }
3015     SplashClose_t splashClose = (SplashClose_t)GetProcAddress(hSplashDll,
3016         &quot;SplashClose&quot;);
3017     if (splashClose) {
3018         splashClose();
3019     }
3020 }
3021 
3022 /*
3023  * accessible from awt_Component
3024  */
3025 BOOL AwtToolkit::areExtraMouseButtonsEnabled() {
3026     return m_areExtraMouseButtonsEnabled;
3027 }
3028 
3029 /*
3030  * Class:     sun_awt_windows_WToolkit
3031  * Method:    setExtraMouseButtonsEnabledNative
3032  * Signature: (Z)V
3033  */
3034 extern &quot;C&quot; JNIEXPORT void JNICALL Java_sun_awt_windows_WToolkit_setExtraMouseButtonsEnabledNative
3035 (JNIEnv *env, jclass self, jboolean enable){
3036     TRY;
3037     AwtToolkit::GetInstance().setExtraMouseButtonsEnabled(enable);
3038     CATCH_BAD_ALLOC;
3039 }
3040 
3041 void AwtToolkit::setExtraMouseButtonsEnabled(BOOL enable) {
3042     m_areExtraMouseButtonsEnabled = enable;
3043 }
3044 
3045 JNIEXPORT jint JNICALL Java_sun_awt_windows_WToolkit_getNumberOfButtonsImpl
3046 (JNIEnv *, jobject self) {
3047     return AwtToolkit::GetNumberOfButtons();
3048 }
3049 
3050 UINT AwtToolkit::GetNumberOfButtons() {
3051     return MOUSE_BUTTONS_WINDOWS_SUPPORTED;
3052 }
3053 
3054 bool AwtToolkit::IsWin8OrLater() {
3055     return m_isWin8OrLater;
3056 }
3057 
3058 bool AwtToolkit::IsTouchKeyboardAutoShowEnabled() {
3059     return m_touchKbrdAutoShowIsEnabled;
3060 }
3061 
3062 bool AwtToolkit::IsAnyKeyboardAttached() {
3063     UINT numDevs = 0;
3064     UINT numDevsRet = 0;
3065     const UINT devListTypeSize = sizeof(RAWINPUTDEVICELIST);
3066     if ((::GetRawInputDeviceList(NULL, &amp;numDevs, devListTypeSize) != 0) ||
3067         (numDevs == 0)) {
3068         return false;
3069     }
3070 
3071     RAWINPUTDEVICELIST* pDevList = new RAWINPUTDEVICELIST[numDevs];
3072     while (((numDevsRet = ::GetRawInputDeviceList(pDevList, &amp;numDevs,
3073             devListTypeSize)) == (UINT)-1) &amp;&amp;
3074         (::GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
3075         if (pDevList != NULL) {
3076             delete[] pDevList;
3077         }
3078         pDevList = new RAWINPUTDEVICELIST[numDevs];
3079     }
3080 
3081     bool keyboardIsAttached = false;
3082     if (numDevsRet != (UINT)-1) {
3083         for (UINT i = 0; i &lt; numDevsRet; i++) {
3084             if (pDevList[i].dwType == RIM_TYPEKEYBOARD) {
3085                 keyboardIsAttached = true;
3086                 break;
3087             }
3088         }
3089     }
3090 
3091     if (pDevList != NULL) {
3092         delete[] pDevList;
3093     }
3094     return keyboardIsAttached;
3095 }
3096 
3097 bool AwtToolkit::IsTouchKeyboardAutoShowSystemEnabled() {
3098     const TCHAR tabTipKeyName[] = _T(&quot;SOFTWARE\\Microsoft\\TabletTip\\1.7&quot;);
3099     HKEY hTabTipKey = NULL;
3100     if (::RegOpenKeyEx(HKEY_CURRENT_USER, tabTipKeyName, 0, KEY_READ,
3101             &amp;hTabTipKey) != ERROR_SUCCESS) {
3102         return false;
3103     }
3104 
3105     const TCHAR enableAutoInvokeValName[] = _T(&quot;EnableDesktopModeAutoInvoke&quot;);
3106     DWORD keyValType = 0;
3107     bool autoShowIsEnabled = false;
3108     if (::RegQueryValueEx(hTabTipKey, enableAutoInvokeValName, NULL,
3109             &amp;keyValType, NULL, NULL) == ERROR_SUCCESS) {
3110         if (keyValType == REG_DWORD) {
3111             DWORD enableAutoInvokeVal = 0;
3112             DWORD bytesCopied = sizeof(DWORD);
3113             if (::RegQueryValueEx(hTabTipKey, enableAutoInvokeValName, NULL,
3114                     NULL, (LPBYTE)(DWORD*)&amp;enableAutoInvokeVal,
3115                     &amp;bytesCopied) == ERROR_SUCCESS) {
3116                 autoShowIsEnabled = (enableAutoInvokeVal == 0 ? false : true);
3117             }
3118         }
3119     }
3120 
3121     if (hTabTipKey != NULL) {
3122         ::RegCloseKey(hTabTipKey);
3123     }
3124     return autoShowIsEnabled;
3125 }
3126 
3127 void AwtToolkit::ShowTouchKeyboard() {
3128     if (m_isWin8OrLater &amp;&amp; m_touchKbrdAutoShowIsEnabled &amp;&amp;
3129         (m_touchKbrdExeFilePath != NULL)) {
3130         int retVal = (int)((intptr_t)::ShellExecute(NULL, _T(&quot;open&quot;),
3131             m_touchKbrdExeFilePath, NULL, NULL, SW_SHOW));
3132         if (retVal &lt;= 32) {
3133             DTRACE_PRINTLN1(&quot;AwtToolkit::ShowTouchKeyboard: Failed&quot;
3134                 &quot;, retVal=&#39;%d&#39;&quot;, retVal);
3135         }
3136     }
3137 }
3138 
3139 void AwtToolkit::HideTouchKeyboard() {
3140     if (m_isWin8OrLater &amp;&amp; m_touchKbrdAutoShowIsEnabled) {
3141         HWND hwnd = GetTouchKeyboardWindow();
3142         if (hwnd != NULL) {
3143             ::PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0);
3144         }
3145     }
3146 }
3147 
3148 BOOL AwtToolkit::TIRegisterTouchWindow(HWND hWnd, ULONG ulFlags) {
3149     if (m_pRegisterTouchWindow == NULL) {
3150         return FALSE;
3151     }
3152     return m_pRegisterTouchWindow(hWnd, ulFlags);
3153 }
3154 
3155 BOOL AwtToolkit::TIGetTouchInputInfo(HTOUCHINPUT hTouchInput,
3156     UINT cInputs, PTOUCHINPUT pInputs, int cbSize) {
3157     if (m_pGetTouchInputInfo == NULL) {
3158         return FALSE;
3159     }
3160     return m_pGetTouchInputInfo(hTouchInput, cInputs, pInputs, cbSize);
3161 }
3162 
3163 BOOL AwtToolkit::TICloseTouchInputHandle(HTOUCHINPUT hTouchInput) {
3164     if (m_pCloseTouchInputHandle == NULL) {
3165         return FALSE;
3166     }
3167     return m_pCloseTouchInputHandle(hTouchInput);
3168 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/solaris/classes/sun/font/X11CNS11643.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.nio.CharBuffer;
 29 import java.nio.ByteBuffer;
 30 import java.nio.charset.*;
 31 import sun.nio.cs.*;
 32 
 33 public abstract class X11CNS11643 extends Charset {
 34     private final int plane;
 35     public X11CNS11643 (int plane, String name) {
 36         super(name, null);
 37         switch (plane) {
 38         case 1:
 39             this.plane = 0; // CS1
 40             break;
 41         case 2:
 42         case 3:
 43             this.plane = plane;
 44             break;
 45         default:
 46             throw new IllegalArgumentException
 47                 (&quot;Only planes 1, 2, and 3 supported&quot;);
 48         }
 49     }
 50 
 51     public CharsetEncoder newEncoder() {
 52         return new Encoder(this, plane);
 53     }
 54 
 55     public CharsetDecoder newDecoder() {
 56         return new Decoder(this, plane);
 57     }
 58 
 59     public boolean contains(Charset cs) {
 60         return cs instanceof X11CNS11643;
 61     }
 62 
 63     private class Encoder extends EUC_TW.Encoder {
 64         private int plane;
 65         public Encoder(Charset cs, int plane) {
 66             super(cs);
 67             this.plane = plane;
 68         }
 69 
 70         private byte[] bb = new byte[4];
 71         public boolean canEncode(char c) {
 72             if (c &lt;= 0x7F) {
 73                 return false;
 74             }
 75             int nb = toEUC(c, bb);
 76             if (nb == -1)
 77                 return false;
 78             int p = 0;
 79             if (nb == 4)
 80                 p = (bb[1] &amp; 0xff) - 0xa0;
 81             return (p == plane);
 82         }
 83 
 84         public boolean isLegalReplacement(byte[] repl) {
 85             return true;
 86         }
 87 
 88         protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst) {
 89             char[] sa = src.array();
 90             int sp = src.arrayOffset() + src.position();
 91             int sl = src.arrayOffset() + src.limit();
 92             byte[] da = dst.array();
 93             int dp = dst.arrayOffset() + dst.position();
 94             int dl = dst.arrayOffset() + dst.limit();
 95 
 96             try {
 97                 while (sp &lt; sl) {
 98                     char c = sa[sp];
 99                     if ( c &gt; &#39;\u007f&#39;&amp;&amp; c &lt; &#39;\uFFFE&#39;) {
100                         int nb = toEUC(c, bb);
101                         if (nb != -1) {
102                             int p = 0;
103                             if (nb == 4)
104                                 p = (bb[1] &amp; 0xff) - 0xa0;
105                             if (p == plane) {
106                                 if (dl - dp &lt; 2)
107                                     return CoderResult.OVERFLOW;
108                                 if (nb == 2) {
109                                     da[dp++] = (byte)(bb[0] &amp; 0x7f);
110                                     da[dp++] = (byte)(bb[1] &amp; 0x7f);
111                                 } else {
112                                     da[dp++] = (byte)(bb[2] &amp; 0x7f);
113                                     da[dp++] = (byte)(bb[3] &amp; 0x7f);
114                                 }
115                                 sp++;
116                                 continue;
117                             }
118                         }
119                     }
120                     return CoderResult.unmappableForLength(1);
121                 }
122                 return CoderResult.UNDERFLOW;
123             } finally {
124                 src.position(sp - src.arrayOffset());
125                 dst.position(dp - dst.arrayOffset());
126             }
127         }
128     }
129 
130     private class Decoder extends EUC_TW.Decoder {
131         int plane;
132         private String table;
133         protected Decoder(Charset cs, int plane) {
134             super(cs);
135             if (plane == 0)
136                 this.plane = plane;
137             else if (plane == 2 || plane == 3)
138                 this.plane = plane - 1;
139             else
140                 throw new IllegalArgumentException
141                     (&quot;Only planes 1, 2, and 3 supported&quot;);
142         }
143 
144         //we only work on array backed buffer.
145         protected CoderResult decodeLoop(ByteBuffer src, CharBuffer dst) {
146             byte[] sa = src.array();
147             int sp = src.arrayOffset() + src.position();
148             int sl = src.arrayOffset() + src.limit();
149 
150             char[] da = dst.array();
151             int dp = dst.arrayOffset() + dst.position();
152             int dl = dst.arrayOffset() + dst.limit();
153 
154             try {
155                 while (sp &lt; sl) {
156                     if ( sl - sp &lt; 2) {
157                         return CoderResult.UNDERFLOW;
158                     }
159                     int b1 = (sa[sp] &amp; 0xff) | 0x80;
160                     int b2 = (sa[sp + 1] &amp; 0xff) | 0x80;
161                     char[] cc = toUnicode(b1, b2, plane);
162                     // plane3 has non-bmp characters(added), x11cnsp3
163                     // however does not support them
164                     if (cc == null || cc.length == 2)
165                         return CoderResult.unmappableForLength(2);
166                     if (dl - dp &lt; 1)
167                         return CoderResult.OVERFLOW;
168                     da[dp++] = cc[0];
169                     sp +=2;
170                 }
171                 return CoderResult.UNDERFLOW;
172             } finally {
173                 src.position(sp - src.arrayOffset());
174                 dst.position(dp - dst.arrayOffset());
175             }
176         }
177     }
178 }
    </pre>
  </body>
</html>
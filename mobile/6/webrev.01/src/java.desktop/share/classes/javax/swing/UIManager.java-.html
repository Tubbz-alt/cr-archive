<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/javax/swing/UIManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing;
  26 
  27 import java.awt.Component;
  28 import java.awt.Font;
  29 import java.awt.Color;
  30 import java.awt.Insets;
  31 import java.awt.Dimension;
  32 import java.awt.KeyboardFocusManager;
  33 import java.awt.KeyEventPostProcessor;
  34 import java.awt.Toolkit;
  35 
  36 import java.awt.event.KeyEvent;
  37 
  38 import java.security.AccessController;
  39 
  40 import javax.swing.plaf.ComponentUI;
  41 import javax.swing.border.Border;
  42 
  43 import javax.swing.event.SwingPropertyChangeSupport;
  44 import java.beans.PropertyChangeListener;
  45 
  46 import java.io.Serializable;
  47 import java.io.File;
  48 import java.io.FileInputStream;
  49 
  50 import java.util.ArrayList;
  51 import java.util.Properties;
  52 import java.util.StringTokenizer;
  53 import java.util.Vector;
  54 import java.util.Locale;
  55 
  56 import sun.awt.SunToolkit;
  57 import sun.awt.OSInfo;
  58 import sun.security.action.GetPropertyAction;
  59 import sun.swing.SwingUtilities2;
  60 import java.lang.reflect.Method;
  61 import java.util.HashMap;
  62 import java.util.Objects;
  63 import sun.awt.AppContext;
  64 import sun.awt.AWTAccessor;
  65 
  66 
  67 /**
  68  * {@code UIManager} manages the current look and feel, the set of
  69  * available look and feels, {@code PropertyChangeListeners} that
  70  * are notified when the look and feel changes, look and feel defaults, and
  71  * convenience methods for obtaining various default values.
  72  *
  73  * &lt;h2&gt;Specifying the look and feel&lt;/h2&gt;
  74  *
  75  * The look and feel can be specified in two distinct ways: by
  76  * specifying the fully qualified name of the class for the look and
  77  * feel, or by creating an instance of {@code LookAndFeel} and passing
  78  * it to {@code setLookAndFeel}. The following example illustrates
  79  * setting the look and feel to the system look and feel:
  80  * &lt;pre&gt;
  81  *   UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  82  * &lt;/pre&gt;
  83  * The following example illustrates setting the look and feel based on
  84  * class name:
  85  * &lt;pre&gt;
  86  *   UIManager.setLookAndFeel(&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;);
  87  * &lt;/pre&gt;
  88  * Once the look and feel has been changed it is imperative to invoke
  89  * {@code updateUI} on all {@code JComponents}. The method {@link
  90  * SwingUtilities#updateComponentTreeUI} makes it easy to apply {@code
  91  * updateUI} to a containment hierarchy. Refer to it for
  92  * details. The exact behavior of not invoking {@code
  93  * updateUI} after changing the look and feel is
  94  * unspecified. It is very possible to receive unexpected exceptions,
  95  * painting problems, or worse.
  96  *
  97  * &lt;h2&gt;Default look and feel&lt;/h2&gt;
  98  *
  99  * The class used for the default look and feel is chosen in the following
 100  * manner:
 101  * &lt;ol&gt;
 102  *   &lt;li&gt;If the system property &lt;code&gt;swing.defaultlaf&lt;/code&gt; is
 103  *       {@code non-null}, use its value as the default look and feel class
 104  *       name.
 105  *   &lt;li&gt;If the {@link java.util.Properties} file &lt;code&gt;swing.properties&lt;/code&gt;
 106  *       exists and contains the key &lt;code&gt;swing.defaultlaf&lt;/code&gt;,
 107  *       use its value as the default look and feel class name. The location
 108  *       that is checked for &lt;code&gt;swing.properties&lt;/code&gt; may vary depending
 109  *       upon the implementation of the Java platform. Typically the
 110  *       &lt;code&gt;swing.properties&lt;/code&gt; file is located in the &lt;code&gt;conf&lt;/code&gt;
 111  *       subdirectory of the Java installation directory.
 112  *       Refer to the release notes of the implementation being used for
 113  *       further details.
 114  *   &lt;li&gt;Otherwise use the cross platform look and feel.
 115  * &lt;/ol&gt;
 116  *
 117  * &lt;h2&gt;Defaults&lt;/h2&gt;
 118  *
 119  * {@code UIManager} manages three sets of {@code UIDefaults}. In order, they
 120  * are:
 121  * &lt;ol&gt;
 122  *   &lt;li&gt;Developer defaults. With few exceptions Swing does not
 123  *       alter the developer defaults; these are intended to be modified
 124  *       and used by the developer.
 125  *   &lt;li&gt;Look and feel defaults. The look and feel defaults are
 126  *       supplied by the look and feel at the time it is installed as the
 127  *       current look and feel ({@code setLookAndFeel()} is invoked). The
 128  *       look and feel defaults can be obtained using the {@code
 129  *       getLookAndFeelDefaults()} method.
 130  *   &lt;li&gt;System defaults. The system defaults are provided by Swing.
 131  * &lt;/ol&gt;
 132  * Invoking any of the various {@code get} methods
 133  * results in checking each of the defaults, in order, returning
 134  * the first {@code non-null} value. For example, invoking
 135  * {@code UIManager.getString(&quot;Table.foreground&quot;)} results in first
 136  * checking developer defaults. If the developer defaults contain
 137  * a value for {@code &quot;Table.foreground&quot;} it is returned, otherwise
 138  * the look and feel defaults are checked, followed by the system defaults.
 139  * &lt;p&gt;
 140  * It&#39;s important to note that {@code getDefaults} returns a custom
 141  * instance of {@code UIDefaults} with this resolution logic built into it.
 142  * For example, {@code UIManager.getDefaults().getString(&quot;Table.foreground&quot;)}
 143  * is equivalent to {@code UIManager.getString(&quot;Table.foreground&quot;)}. Both
 144  * resolve using the algorithm just described. In many places the
 145  * documentation uses the word defaults to refer to the custom instance
 146  * of {@code UIDefaults} with the resolution logic as previously described.
 147  * &lt;p&gt;
 148  * When the look and feel is changed, {@code UIManager} alters only the
 149  * look and feel defaults; the developer and system defaults are not
 150  * altered by the {@code UIManager} in any way.
 151  * &lt;p&gt;
 152  * The set of defaults a particular look and feel supports is defined
 153  * and documented by that look and feel. In addition, each look and
 154  * feel, or {@code ComponentUI} provided by a look and feel, may
 155  * access the defaults at different times in their life cycle. Some
 156  * look and feels may aggressively look up defaults, so that changing a
 157  * default may not have an effect after installing the look and feel.
 158  * Other look and feels may lazily access defaults so that a change to
 159  * the defaults may effect an existing look and feel. Finally, other look
 160  * and feels might not configure themselves from the defaults table in
 161  * any way. None-the-less it is usually the case that a look and feel
 162  * expects certain defaults, so that in general
 163  * a {@code ComponentUI} provided by one look and feel will not
 164  * work with another look and feel.
 165  * &lt;p&gt;
 166  * &lt;strong&gt;Warning:&lt;/strong&gt;
 167  * Serialized objects of this class will not be compatible with
 168  * future Swing releases. The current serialization support is
 169  * appropriate for short term storage or RMI between applications running
 170  * the same version of Swing.  As of 1.4, support for long term storage
 171  * of all JavaBeans&amp;trade;
 172  * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 173  * Please see {@link java.beans.XMLEncoder}.
 174  *
 175  * @author Thomas Ball
 176  * @author Hans Muller
 177  * @since 1.2
 178  */
 179 @SuppressWarnings(&quot;serial&quot;) // Same-version serialization only
 180 public class UIManager implements Serializable
 181 {
 182     /**
 183      * This class defines the state managed by the &lt;code&gt;UIManager&lt;/code&gt;.  For
 184      * Swing applications the fields in this class could just as well
 185      * be static members of &lt;code&gt;UIManager&lt;/code&gt; however we give them
 186      * &quot;AppContext&quot;
 187      * scope instead so that applets (and potentially multiple lightweight
 188      * applications running in a single VM) have their own state. For example,
 189      * an applet can alter its look and feel, see &lt;code&gt;setLookAndFeel&lt;/code&gt;.
 190      * Doing so has no affect on other applets (or the browser).
 191      */
 192     private static class LAFState
 193     {
 194         Properties swingProps;
 195         private UIDefaults[] tables = new UIDefaults[2];
 196 
 197         boolean initialized = false;
 198         boolean focusPolicyInitialized = false;
 199         MultiUIDefaults multiUIDefaults = new MultiUIDefaults(tables);
 200         LookAndFeel lookAndFeel;
 201         LookAndFeel multiLookAndFeel = null;
 202         Vector&lt;LookAndFeel&gt; auxLookAndFeels = null;
 203         SwingPropertyChangeSupport changeSupport;
 204 
 205         LookAndFeelInfo[] installedLAFs;
 206 
 207         UIDefaults getLookAndFeelDefaults() { return tables[0]; }
 208         void setLookAndFeelDefaults(UIDefaults x) { tables[0] = x; }
 209 
 210         UIDefaults getSystemDefaults() { return tables[1]; }
 211         void setSystemDefaults(UIDefaults x) { tables[1] = x; }
 212 
 213         /**
 214          * Returns the SwingPropertyChangeSupport for the current
 215          * AppContext.  If &lt;code&gt;create&lt;/code&gt; is a true, a non-null
 216          * &lt;code&gt;SwingPropertyChangeSupport&lt;/code&gt; will be returned, if
 217          * &lt;code&gt;create&lt;/code&gt; is false and this has not been invoked
 218          * with true, null will be returned.
 219          */
 220         public synchronized SwingPropertyChangeSupport
 221                                  getPropertyChangeSupport(boolean create) {
 222             if (create &amp;&amp; changeSupport == null) {
 223                 changeSupport = new SwingPropertyChangeSupport(
 224                                          UIManager.class);
 225             }
 226             return changeSupport;
 227         }
 228     }
 229 
 230 
 231 
 232 
 233     /* Lock object used in place of class object for synchronization. (4187686)
 234      */
 235     private static final Object classLock = new Object();
 236 
 237     /**
 238      * Return the &lt;code&gt;LAFState&lt;/code&gt; object, lazily create one if necessary.
 239      * All access to the &lt;code&gt;LAFState&lt;/code&gt; fields is done via this method,
 240      * for example:
 241      * &lt;pre&gt;
 242      *     getLAFState().initialized = true;
 243      * &lt;/pre&gt;
 244      */
 245     private static LAFState getLAFState() {
 246         LAFState rv = (LAFState)SwingUtilities.appContextGet(
 247                 SwingUtilities2.LAF_STATE_KEY);
 248         if (rv == null) {
 249             synchronized (classLock) {
 250                 rv = (LAFState)SwingUtilities.appContextGet(
 251                         SwingUtilities2.LAF_STATE_KEY);
 252                 if (rv == null) {
 253                     SwingUtilities.appContextPut(
 254                             SwingUtilities2.LAF_STATE_KEY,
 255                             (rv = new LAFState()));
 256                 }
 257             }
 258         }
 259         return rv;
 260     }
 261 
 262 
 263     /* Keys used in the &lt;code&gt;swing.properties&lt;/code&gt; properties file.
 264      * See loadUserProperties(), initialize().
 265      */
 266 
 267     private static final String defaultLAFKey = &quot;swing.defaultlaf&quot;;
 268     private static final String auxiliaryLAFsKey = &quot;swing.auxiliarylaf&quot;;
 269     private static final String multiplexingLAFKey = &quot;swing.plaf.multiplexinglaf&quot;;
 270     private static final String installedLAFsKey = &quot;swing.installedlafs&quot;;
 271     private static final String disableMnemonicKey = &quot;swing.disablenavaids&quot;;
 272 
 273     /**
 274      * Return a &lt;code&gt;swing.properties&lt;/code&gt; file key for the attribute of specified
 275      * look and feel.  The attr is either &quot;name&quot; or &quot;class&quot;, a typical
 276      * key would be: &quot;swing.installedlaf.windows.name&quot;
 277      */
 278     private static String makeInstalledLAFKey(String laf, String attr) {
 279         return &quot;swing.installedlaf.&quot; + laf + &quot;.&quot; + attr;
 280     }
 281 
 282     /**
 283      * The location of the &lt;code&gt;swing.properties&lt;/code&gt; property file is
 284      * implementation-specific.
 285      * It is typically located in the &lt;code&gt;conf&lt;/code&gt; subdirectory of the Java
 286      * installation directory. This method returns a bogus filename
 287      * if &lt;code&gt;java.home&lt;/code&gt; isn&#39;t defined.
 288      */
 289     private static String makeSwingPropertiesFilename() {
 290         String sep = File.separator;
 291         // No need to wrap this in a doPrivileged as it&#39;s called from
 292         // a doPrivileged.
 293         String javaHome = System.getProperty(&quot;java.home&quot;);
 294         if (javaHome == null) {
 295             javaHome = &quot;&lt;java.home undefined&gt;&quot;;
 296         }
 297         return javaHome + sep + &quot;conf&quot; + sep + &quot;swing.properties&quot;;
 298     }
 299 
 300 
 301     /**
 302      * Provides a little information about an installed
 303      * &lt;code&gt;LookAndFeel&lt;/code&gt; for the sake of configuring a menu or
 304      * for initial application set up.
 305      *
 306      * @see UIManager#getInstalledLookAndFeels
 307      * @see LookAndFeel
 308      */
 309     public static class LookAndFeelInfo {
 310         private String name;
 311         private String className;
 312 
 313         /**
 314          * Constructs a &lt;code&gt;UIManager&lt;/code&gt;s
 315          * &lt;code&gt;LookAndFeelInfo&lt;/code&gt; object.
 316          *
 317          * @param name      a &lt;code&gt;String&lt;/code&gt; specifying the name of
 318          *                      the look and feel
 319          * @param className a &lt;code&gt;String&lt;/code&gt; specifying the name of
 320          *                      the class that implements the look and feel
 321          */
 322         public LookAndFeelInfo(String name, String className) {
 323             this.name = name;
 324             this.className = className;
 325         }
 326 
 327         /**
 328          * Returns the name of the look and feel in a form suitable
 329          * for a menu or other presentation
 330          * @return a &lt;code&gt;String&lt;/code&gt; containing the name
 331          * @see LookAndFeel#getName
 332          */
 333         public String getName() {
 334             return name;
 335         }
 336 
 337         /**
 338          * Returns the name of the class that implements this look and feel.
 339          * @return the name of the class that implements this
 340          *              &lt;code&gt;LookAndFeel&lt;/code&gt;
 341          * @see LookAndFeel
 342          */
 343         public String getClassName() {
 344             return className;
 345         }
 346 
 347         /**
 348          * Returns a string that displays and identifies this
 349          * object&#39;s properties.
 350          *
 351          * @return a &lt;code&gt;String&lt;/code&gt; representation of this object
 352          */
 353         public String toString() {
 354             return getClass().getName() + &quot;[&quot; + getName() + &quot; &quot; + getClassName() + &quot;]&quot;;
 355         }
 356     }
 357 
 358 
 359     /**
 360      * The default value of &lt;code&gt;installedLAFS&lt;/code&gt; is used when no
 361      * &lt;code&gt;swing.properties&lt;/code&gt;
 362      * file is available or if the file doesn&#39;t contain a &quot;swing.installedlafs&quot;
 363      * property.
 364      *
 365      * @see #initializeInstalledLAFs
 366      */
 367     private static LookAndFeelInfo[] installedLAFs;
 368 
 369     static {
 370         ArrayList&lt;LookAndFeelInfo&gt; iLAFs = new ArrayList&lt;LookAndFeelInfo&gt;(4);
 371         iLAFs.add(new LookAndFeelInfo(
 372                       &quot;Metal&quot;, &quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;));
 373         iLAFs.add(new LookAndFeelInfo(
 374                       &quot;Nimbus&quot;, &quot;javax.swing.plaf.nimbus.NimbusLookAndFeel&quot;));
 375         iLAFs.add(new LookAndFeelInfo(&quot;CDE/Motif&quot;,
 376                   &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;));
 377 
 378         // Only include windows on Windows boxs.
 379         OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());
 380         if (osType == OSInfo.OSType.WINDOWS) {
 381             iLAFs.add(new LookAndFeelInfo(&quot;Windows&quot;,
 382                         &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;));
 383             if (Toolkit.getDefaultToolkit().getDesktopProperty(
 384                     &quot;win.xpstyle.themeActive&quot;) != null) {
 385                 iLAFs.add(new LookAndFeelInfo(&quot;Windows Classic&quot;,
 386                  &quot;com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel&quot;));
 387             }
 388         }
 389         else if (osType == OSInfo.OSType.MACOSX) {
 390             iLAFs.add(new LookAndFeelInfo(&quot;Mac OS X&quot;, &quot;com.apple.laf.AquaLookAndFeel&quot;));
 391         }
 392         else {
 393             // GTK is not shipped on Windows.
 394             iLAFs.add(new LookAndFeelInfo(&quot;GTK+&quot;,
 395                   &quot;com.sun.java.swing.plaf.gtk.GTKLookAndFeel&quot;));
 396         }
 397         installedLAFs = iLAFs.toArray(new LookAndFeelInfo[iLAFs.size()]);
 398     }
 399 
 400 
 401     /**
 402      * Returns an array of {@code LookAndFeelInfo}s representing the
 403      * {@code LookAndFeel} implementations currently available. The
 404      * &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects can be used by an
 405      * application to construct a menu of look and feel options for
 406      * the user, or to determine which look and feel to set at startup
 407      * time. To avoid the penalty of creating numerous {@code
 408      * LookAndFeel} objects, {@code LookAndFeelInfo} maintains the
 409      * class name of the {@code LookAndFeel} class, not the actual
 410      * {@code LookAndFeel} instance.
 411      * &lt;p&gt;
 412      * The following example illustrates setting the current look and feel
 413      * from an instance of {@code LookAndFeelInfo}:
 414      * &lt;pre&gt;
 415      *   UIManager.setLookAndFeel(info.getClassName());
 416      * &lt;/pre&gt;
 417      *
 418      * @return an array of &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects
 419      * @see #setLookAndFeel
 420      */
 421     public static LookAndFeelInfo[] getInstalledLookAndFeels() {
 422         maybeInitialize();
 423         LookAndFeelInfo[] ilafs = getLAFState().installedLAFs;
 424         if (ilafs == null) {
 425             ilafs = installedLAFs;
 426         }
 427         LookAndFeelInfo[] rv = new LookAndFeelInfo[ilafs.length];
 428         System.arraycopy(ilafs, 0, rv, 0, ilafs.length);
 429         return rv;
 430     }
 431 
 432 
 433     /**
 434      * Sets the set of available look and feels. While this method does
 435      * not check to ensure all of the {@code LookAndFeelInfos} are
 436      * {@code non-null}, it is strongly recommended that only {@code non-null}
 437      * values are supplied in the {@code infos} array.
 438      *
 439      * @param infos set of &lt;code&gt;LookAndFeelInfo&lt;/code&gt; objects specifying
 440      *        the available look and feels
 441      *
 442      * @see #getInstalledLookAndFeels
 443      * @throws NullPointerException if {@code infos} is {@code null}
 444      */
 445     public static void setInstalledLookAndFeels(LookAndFeelInfo[] infos)
 446         throws SecurityException
 447     {
 448         maybeInitialize();
 449         LookAndFeelInfo[] newInfos = new LookAndFeelInfo[infos.length];
 450         System.arraycopy(infos, 0, newInfos, 0, infos.length);
 451         getLAFState().installedLAFs = newInfos;
 452     }
 453 
 454 
 455     /**
 456      * Adds the specified look and feel to the set of available look
 457      * and feels. While this method allows a {@code null} {@code info},
 458      * it is strongly recommended that a {@code non-null} value be used.
 459      *
 460      * @param info a &lt;code&gt;LookAndFeelInfo&lt;/code&gt; object that names the
 461      *          look and feel and identifies the class that implements it
 462      * @see #setInstalledLookAndFeels
 463      */
 464     public static void installLookAndFeel(LookAndFeelInfo info) {
 465         LookAndFeelInfo[] infos = getInstalledLookAndFeels();
 466         LookAndFeelInfo[] newInfos = new LookAndFeelInfo[infos.length + 1];
 467         System.arraycopy(infos, 0, newInfos, 0, infos.length);
 468         newInfos[infos.length] = info;
 469         setInstalledLookAndFeels(newInfos);
 470     }
 471 
 472 
 473     /**
 474      * Adds the specified look and feel to the set of available look
 475      * and feels. While this method does not check the
 476      * arguments in any way, it is strongly recommended that {@code
 477      * non-null} values be supplied.
 478      *
 479      * @param name descriptive name of the look and feel
 480      * @param className name of the class that implements the look and feel
 481      * @see #setInstalledLookAndFeels
 482      */
 483     public static void installLookAndFeel(String name, String className) {
 484         installLookAndFeel(new LookAndFeelInfo(name, className));
 485     }
 486 
 487 
 488     /**
 489      * Returns the current look and feel or &lt;code&gt;null&lt;/code&gt;.
 490      *
 491      * @return current look and feel, or &lt;code&gt;null&lt;/code&gt;
 492      * @see #setLookAndFeel
 493      */
 494     public static LookAndFeel getLookAndFeel() {
 495         maybeInitialize();
 496         return getLAFState().lookAndFeel;
 497     }
 498 
 499     /**
 500      * Creates a supported built-in Java {@code LookAndFeel} specified
 501      * by the given {@code L&amp;F name} name.
 502      *
 503      * @param name a {@code String} specifying the name of the built-in
 504      *             look and feel
 505      * @return the built-in {@code LookAndFeel} object
 506      * @throws NullPointerException if {@code name} is {@code null}
 507      * @throws UnsupportedLookAndFeelException if the built-in Java {@code L&amp;F}
 508      *         is not found for the given name or it is not supported by the
 509      *         underlying platform
 510      *
 511      * @see LookAndFeel#getName
 512      * @see LookAndFeel#isSupportedLookAndFeel
 513      *
 514      * @since 9
 515      */
 516     @SuppressWarnings(&quot;deprecation&quot;)
 517     public static LookAndFeel createLookAndFeel(String name)
 518             throws UnsupportedLookAndFeelException {
 519         Objects.requireNonNull(name);
 520 
 521         if (&quot;GTK look and feel&quot;.equals(name)) {
 522             name = &quot;GTK+&quot;;
 523         }
 524 
 525         try {
 526             for (LookAndFeelInfo info : installedLAFs) {
 527                 if (info.getName().equals(name)) {
 528                     Class&lt;?&gt; cls = Class.forName(UIManager.class.getModule(),
 529                                                  info.getClassName());
 530                     LookAndFeel laf =
 531                         (LookAndFeel) cls.newInstance();
 532                     if (!laf.isSupportedLookAndFeel()) {
 533                         break;
 534                     }
 535                     return laf;
 536                 }
 537             }
 538         } catch (ReflectiveOperationException |
 539                  IllegalArgumentException ignore) {
 540         }
 541 
 542         throw new UnsupportedLookAndFeelException(name);
 543     }
 544 
 545     /**
 546      * Sets the current look and feel to {@code newLookAndFeel}.
 547      * If the current look and feel is {@code non-null} {@code
 548      * uninitialize} is invoked on it. If {@code newLookAndFeel} is
 549      * {@code non-null}, {@code initialize} is invoked on it followed
 550      * by {@code getDefaults}. The defaults returned from {@code
 551      * newLookAndFeel.getDefaults()} replace those of the defaults
 552      * from the previous look and feel. If the {@code newLookAndFeel} is
 553      * {@code null}, the look and feel defaults are set to {@code null}.
 554      * &lt;p&gt;
 555      * A value of {@code null} can be used to set the look and feel
 556      * to {@code null}. As the {@code LookAndFeel} is required for
 557      * most of Swing to function, setting the {@code LookAndFeel} to
 558      * {@code null} is strongly discouraged.
 559      * &lt;p&gt;
 560      * This is a JavaBeans bound property.
 561      *
 562      * @param newLookAndFeel {@code LookAndFeel} to install
 563      * @throws UnsupportedLookAndFeelException if
 564      *          {@code newLookAndFeel} is {@code non-null} and
 565      *          {@code newLookAndFeel.isSupportedLookAndFeel()} returns
 566      *          {@code false}
 567      * @see #getLookAndFeel
 568      */
 569     public static void setLookAndFeel(LookAndFeel newLookAndFeel)
 570         throws UnsupportedLookAndFeelException
 571     {
 572         if ((newLookAndFeel != null) &amp;&amp; !newLookAndFeel.isSupportedLookAndFeel()) {
 573             String s = newLookAndFeel.toString() + &quot; not supported on this platform&quot;;
 574             throw new UnsupportedLookAndFeelException(s);
 575         }
 576 
 577         LAFState lafState = getLAFState();
 578         LookAndFeel oldLookAndFeel = lafState.lookAndFeel;
 579         if (oldLookAndFeel != null) {
 580             oldLookAndFeel.uninitialize();
 581         }
 582 
 583         lafState.lookAndFeel = newLookAndFeel;
 584         if (newLookAndFeel != null) {
 585             sun.swing.DefaultLookup.setDefaultLookup(null);
 586             newLookAndFeel.initialize();
 587             lafState.setLookAndFeelDefaults(newLookAndFeel.getDefaults());
 588         }
 589         else {
 590             lafState.setLookAndFeelDefaults(null);
 591         }
 592 
 593         SwingPropertyChangeSupport changeSupport = lafState.
 594                                          getPropertyChangeSupport(false);
 595         if (changeSupport != null) {
 596             changeSupport.firePropertyChange(&quot;lookAndFeel&quot;, oldLookAndFeel,
 597                                              newLookAndFeel);
 598         }
 599     }
 600 
 601 
 602     /**
 603      * Loads the {@code LookAndFeel} specified by the given class
 604      * name, using the current thread&#39;s context class loader, and
 605      * passes it to {@code setLookAndFeel(LookAndFeel)}.
 606      *
 607      * @param className  a string specifying the name of the class that implements
 608      *        the look and feel
 609      * @throws ClassNotFoundException if the &lt;code&gt;LookAndFeel&lt;/code&gt;
 610      *           class could not be found
 611      * @throws InstantiationException if a new instance of the class
 612      *          couldn&#39;t be created
 613      * @throws IllegalAccessException if the class or initializer isn&#39;t accessible
 614      * @throws UnsupportedLookAndFeelException if
 615      *          &lt;code&gt;lnf.isSupportedLookAndFeel()&lt;/code&gt; is false
 616      * @throws ClassCastException if {@code className} does not identify
 617      *         a class that extends {@code LookAndFeel}
 618      * @throws NullPointerException if {@code className} is {@code null}
 619      */
 620     @SuppressWarnings(&quot;deprecation&quot;)
 621     public static void setLookAndFeel(String className)
 622         throws ClassNotFoundException,
 623                InstantiationException,
 624                IllegalAccessException,
 625                UnsupportedLookAndFeelException
 626     {
 627         if (&quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;.equals(className)) {
 628             // Avoid reflection for the common case of metal.
 629             setLookAndFeel(new javax.swing.plaf.metal.MetalLookAndFeel());
 630         }
 631         else {
 632             Class&lt;?&gt; lnfClass = SwingUtilities.loadSystemClass(className);
 633             setLookAndFeel((LookAndFeel)(lnfClass.newInstance()));
 634         }
 635     }
 636 
 637     /**
 638      * Returns the name of the &lt;code&gt;LookAndFeel&lt;/code&gt; class that implements
 639      * the native system look and feel if there is one, otherwise
 640      * the name of the default cross platform &lt;code&gt;LookAndFeel&lt;/code&gt;
 641      * class. This value can be overriden by setting the
 642      * &lt;code&gt;swing.systemlaf&lt;/code&gt; system property.
 643      *
 644      * @return the &lt;code&gt;String&lt;/code&gt; of the &lt;code&gt;LookAndFeel&lt;/code&gt;
 645      *          class
 646      *
 647      * @see #setLookAndFeel
 648      * @see #getCrossPlatformLookAndFeelClassName
 649      */
 650     public static String getSystemLookAndFeelClassName() {
 651         String systemLAF = AccessController.doPrivileged(
 652                              new GetPropertyAction(&quot;swing.systemlaf&quot;));
 653         if (systemLAF != null) {
 654             return systemLAF;
 655         }
 656         OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());
 657         if (osType == OSInfo.OSType.WINDOWS) {
 658             return &quot;com.sun.java.swing.plaf.windows.WindowsLookAndFeel&quot;;
 659         } else {
 660             Toolkit toolkit = Toolkit.getDefaultToolkit();
 661             if (toolkit instanceof SunToolkit) {
 662                 SunToolkit suntk = (SunToolkit)toolkit;
 663                 String desktop = suntk.getDesktop();
 664                 boolean gtkAvailable = suntk.isNativeGTKAvailable();
 665                 if (&quot;gnome&quot;.equals(desktop) &amp;&amp; gtkAvailable) {
 666                     return &quot;com.sun.java.swing.plaf.gtk.GTKLookAndFeel&quot;;
 667                 }
 668             }
 669             if (osType == OSInfo.OSType.MACOSX) {
 670                 if (toolkit.getClass() .getName()
 671                                        .equals(&quot;sun.lwawt.macosx.LWCToolkit&quot;)) {
 672                     return &quot;com.apple.laf.AquaLookAndFeel&quot;;
 673                 }
 674             }
 675             if (osType == OSInfo.OSType.SOLARIS) {
 676                 return &quot;com.sun.java.swing.plaf.motif.MotifLookAndFeel&quot;;
 677             }
 678         }
 679         return getCrossPlatformLookAndFeelClassName();
 680     }
 681 
 682 
 683     /**
 684      * Returns the name of the &lt;code&gt;LookAndFeel&lt;/code&gt; class that implements
 685      * the default cross platform look and feel -- the Java
 686      * Look and Feel (JLF).  This value can be overriden by setting the
 687      * &lt;code&gt;swing.crossplatformlaf&lt;/code&gt; system property.
 688      *
 689      * @return  a string with the JLF implementation-class
 690      * @see #setLookAndFeel
 691      * @see #getSystemLookAndFeelClassName
 692      */
 693     public static String getCrossPlatformLookAndFeelClassName() {
 694         String laf = AccessController.doPrivileged(
 695                              new GetPropertyAction(&quot;swing.crossplatformlaf&quot;));
 696         if (laf != null) {
 697             return laf;
 698         }
 699         return &quot;javax.swing.plaf.metal.MetalLookAndFeel&quot;;
 700     }
 701 
 702 
 703     /**
 704      * Returns the defaults. The returned defaults resolve using the
 705      * logic specified in the class documentation.
 706      *
 707      * @return a &lt;code&gt;UIDefaults&lt;/code&gt; object containing the default values
 708      */
 709     public static UIDefaults getDefaults() {
 710         maybeInitialize();
 711         return getLAFState().multiUIDefaults;
 712     }
 713 
 714     /**
 715      * Returns a font from the defaults. If the value for {@code key} is
 716      * not a {@code Font}, {@code null} is returned.
 717      *
 718      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the font
 719      * @return the &lt;code&gt;Font&lt;/code&gt; object
 720      * @throws NullPointerException if {@code key} is {@code null}
 721      */
 722     public static Font getFont(Object key) {
 723         return getDefaults().getFont(key);
 724     }
 725 
 726     /**
 727      * Returns a font from the defaults that is appropriate
 728      * for the given locale. If the value for {@code key} is
 729      * not a {@code Font}, {@code null} is returned.
 730      *
 731      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the font
 732      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the font is desired; refer
 733      *        to {@code UIDefaults} for details on how a {@code null}
 734      *        {@code Locale} is handled
 735      * @return the &lt;code&gt;Font&lt;/code&gt; object
 736      * @throws NullPointerException if {@code key} is {@code null}
 737      * @since 1.4
 738      */
 739     public static Font getFont(Object key, Locale l) {
 740         return getDefaults().getFont(key,l);
 741     }
 742 
 743     /**
 744      * Returns a color from the defaults. If the value for {@code key} is
 745      * not a {@code Color}, {@code null} is returned.
 746      *
 747      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the color
 748      * @return the &lt;code&gt;Color&lt;/code&gt; object
 749      * @throws NullPointerException if {@code key} is {@code null}
 750      */
 751     public static Color getColor(Object key) {
 752         return getDefaults().getColor(key);
 753     }
 754 
 755     /**
 756      * Returns a color from the defaults that is appropriate
 757      * for the given locale. If the value for {@code key} is
 758      * not a {@code Color}, {@code null} is returned.
 759      *
 760      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the color
 761      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the color is desired; refer
 762      *        to {@code UIDefaults} for details on how a {@code null}
 763      *        {@code Locale} is handled
 764      * @return the &lt;code&gt;Color&lt;/code&gt; object
 765      * @throws NullPointerException if {@code key} is {@code null}
 766      * @since 1.4
 767      */
 768     public static Color getColor(Object key, Locale l) {
 769         return getDefaults().getColor(key,l);
 770     }
 771 
 772     /**
 773      * Returns an &lt;code&gt;Icon&lt;/code&gt; from the defaults. If the value for
 774      * {@code key} is not an {@code Icon}, {@code null} is returned.
 775      *
 776      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the icon
 777      * @return the &lt;code&gt;Icon&lt;/code&gt; object
 778      * @throws NullPointerException if {@code key} is {@code null}
 779      */
 780     public static Icon getIcon(Object key) {
 781         return getDefaults().getIcon(key);
 782     }
 783 
 784     /**
 785      * Returns an &lt;code&gt;Icon&lt;/code&gt; from the defaults that is appropriate
 786      * for the given locale. If the value for
 787      * {@code key} is not an {@code Icon}, {@code null} is returned.
 788      *
 789      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the icon
 790      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the icon is desired; refer
 791      *        to {@code UIDefaults} for details on how a {@code null}
 792      *        {@code Locale} is handled
 793      * @return the &lt;code&gt;Icon&lt;/code&gt; object
 794      * @throws NullPointerException if {@code key} is {@code null}
 795      * @since 1.4
 796      */
 797     public static Icon getIcon(Object key, Locale l) {
 798         return getDefaults().getIcon(key,l);
 799     }
 800 
 801     /**
 802      * Returns a border from the defaults. If the value for
 803      * {@code key} is not a {@code Border}, {@code null} is returned.
 804      *
 805      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the border
 806      * @return the &lt;code&gt;Border&lt;/code&gt; object
 807      * @throws NullPointerException if {@code key} is {@code null}
 808      */
 809     public static Border getBorder(Object key) {
 810         return getDefaults().getBorder(key);
 811     }
 812 
 813     /**
 814      * Returns a border from the defaults that is appropriate
 815      * for the given locale.  If the value for
 816      * {@code key} is not a {@code Border}, {@code null} is returned.
 817      *
 818      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the border
 819      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the border is desired; refer
 820      *        to {@code UIDefaults} for details on how a {@code null}
 821      *        {@code Locale} is handled
 822      * @return the &lt;code&gt;Border&lt;/code&gt; object
 823      * @throws NullPointerException if {@code key} is {@code null}
 824      * @since 1.4
 825      */
 826     public static Border getBorder(Object key, Locale l) {
 827         return getDefaults().getBorder(key,l);
 828     }
 829 
 830     /**
 831      * Returns a string from the defaults. If the value for
 832      * {@code key} is not a {@code String}, {@code null} is returned.
 833      *
 834      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
 835      * @return the &lt;code&gt;String&lt;/code&gt;
 836      * @throws NullPointerException if {@code key} is {@code null}
 837      */
 838     public static String getString(Object key) {
 839         return getDefaults().getString(key);
 840     }
 841 
 842     /**
 843      * Returns a string from the defaults that is appropriate for the
 844      * given locale.  If the value for
 845      * {@code key} is not a {@code String}, {@code null} is returned.
 846      *
 847      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
 848      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the string is desired; refer
 849      *        to {@code UIDefaults} for details on how a {@code null}
 850      *        {@code Locale} is handled
 851      * @return the &lt;code&gt;String&lt;/code&gt;
 852      * @since 1.4
 853      * @throws NullPointerException if {@code key} is {@code null}
 854      */
 855     public static String getString(Object key, Locale l) {
 856         return getDefaults().getString(key,l);
 857     }
 858 
 859     /**
 860      * Returns a string from the defaults that is appropriate for the
 861      * given locale.  If the value for
 862      * {@code key} is not a {@code String}, {@code null} is returned.
 863      *
 864      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the string
 865      * @param c {@code Component} used to determine the locale;
 866      *          {@code null} implies the default locale as
 867      *          returned by {@code Locale.getDefault()}
 868      * @return the &lt;code&gt;String&lt;/code&gt;
 869      * @throws NullPointerException if {@code key} is {@code null}
 870      */
 871     static String getString(Object key, Component c) {
 872         Locale l = (c == null) ? Locale.getDefault() : c.getLocale();
 873         return getString(key, l);
 874     }
 875 
 876     /**
 877      * Returns an integer from the defaults. If the value for
 878      * {@code key} is not an {@code Integer}, or does not exist,
 879      * {@code 0} is returned.
 880      *
 881      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int
 882      * @return the int
 883      * @throws NullPointerException if {@code key} is {@code null}
 884      */
 885     public static int getInt(Object key) {
 886         return getDefaults().getInt(key);
 887     }
 888 
 889     /**
 890      * Returns an integer from the defaults that is appropriate
 891      * for the given locale. If the value for
 892      * {@code key} is not an {@code Integer}, or does not exist,
 893      * {@code 0} is returned.
 894      *
 895      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int
 896      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the int is desired; refer
 897      *        to {@code UIDefaults} for details on how a {@code null}
 898      *        {@code Locale} is handled
 899      * @return the int
 900      * @throws NullPointerException if {@code key} is {@code null}
 901      * @since 1.4
 902      */
 903     public static int getInt(Object key, Locale l) {
 904         return getDefaults().getInt(key,l);
 905     }
 906 
 907     /**
 908      * Returns a boolean from the defaults which is associated with
 909      * the key value. If the key is not found or the key doesn&#39;t represent
 910      * a boolean value then {@code false} is returned.
 911      *
 912      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the key for the desired boolean value
 913      * @return the boolean value corresponding to the key
 914      * @throws NullPointerException if {@code key} is {@code null}
 915      * @since 1.4
 916      */
 917     public static boolean getBoolean(Object key) {
 918         return getDefaults().getBoolean(key);
 919     }
 920 
 921     /**
 922      * Returns a boolean from the defaults which is associated with
 923      * the key value and the given &lt;code&gt;Locale&lt;/code&gt;. If the key is not
 924      * found or the key doesn&#39;t represent
 925      * a boolean value then {@code false} will be returned.
 926      *
 927      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the key for the desired
 928      *             boolean value
 929      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the boolean is desired; refer
 930      *        to {@code UIDefaults} for details on how a {@code null}
 931      *        {@code Locale} is handled
 932      * @return the boolean value corresponding to the key
 933      * @throws NullPointerException if {@code key} is {@code null}
 934      * @since 1.4
 935      */
 936     public static boolean getBoolean(Object key, Locale l) {
 937         return getDefaults().getBoolean(key,l);
 938     }
 939 
 940     /**
 941      * Returns an &lt;code&gt;Insets&lt;/code&gt; object from the defaults. If the value
 942      * for {@code key} is not an {@code Insets}, {@code null} is returned.
 943      *
 944      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the &lt;code&gt;Insets&lt;/code&gt; object
 945      * @return the &lt;code&gt;Insets&lt;/code&gt; object
 946      * @throws NullPointerException if {@code key} is {@code null}
 947      */
 948     public static Insets getInsets(Object key) {
 949         return getDefaults().getInsets(key);
 950     }
 951 
 952     /**
 953      * Returns an &lt;code&gt;Insets&lt;/code&gt; object from the defaults that is
 954      * appropriate for the given locale. If the value
 955      * for {@code key} is not an {@code Insets}, {@code null} is returned.
 956      *
 957      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the &lt;code&gt;Insets&lt;/code&gt; object
 958      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
 959      *        to {@code UIDefaults} for details on how a {@code null}
 960      *        {@code Locale} is handled
 961      * @return the &lt;code&gt;Insets&lt;/code&gt; object
 962      * @throws NullPointerException if {@code key} is {@code null}
 963      * @since 1.4
 964      */
 965     public static Insets getInsets(Object key, Locale l) {
 966         return getDefaults().getInsets(key,l);
 967     }
 968 
 969     /**
 970      * Returns a dimension from the defaults. If the value
 971      * for {@code key} is not a {@code Dimension}, {@code null} is returned.
 972      *
 973      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the dimension object
 974      * @return the &lt;code&gt;Dimension&lt;/code&gt; object
 975      * @throws NullPointerException if {@code key} is {@code null}
 976      */
 977     public static Dimension getDimension(Object key) {
 978         return getDefaults().getDimension(key);
 979     }
 980 
 981     /**
 982      * Returns a dimension from the defaults that is appropriate
 983      * for the given locale. If the value
 984      * for {@code key} is not a {@code Dimension}, {@code null} is returned.
 985      *
 986      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the dimension object
 987      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
 988      *        to {@code UIDefaults} for details on how a {@code null}
 989      *        {@code Locale} is handled
 990      * @return the &lt;code&gt;Dimension&lt;/code&gt; object
 991      * @throws NullPointerException if {@code key} is {@code null}
 992      * @since 1.4
 993      */
 994     public static Dimension getDimension(Object key, Locale l) {
 995         return getDefaults().getDimension(key,l);
 996     }
 997 
 998     /**
 999      * Returns an object from the defaults.
1000      *
1001      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the desired object
1002      * @return the &lt;code&gt;Object&lt;/code&gt;
1003      * @throws NullPointerException if {@code key} is {@code null}
1004      */
1005     public static Object get(Object key) {
1006         return getDefaults().get(key);
1007     }
1008 
1009     /**
1010      * Returns an object from the defaults that is appropriate for
1011      * the given locale.
1012      *
1013      * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the desired object
1014      * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the object is desired; refer
1015      *        to {@code UIDefaults} for details on how a {@code null}
1016      *        {@code Locale} is handled
1017      * @return the &lt;code&gt;Object&lt;/code&gt;
1018      * @throws NullPointerException if {@code key} is {@code null}
1019      * @since 1.4
1020      */
1021     public static Object get(Object key, Locale l) {
1022         return getDefaults().get(key,l);
1023     }
1024 
1025     /**
1026      * Stores an object in the developer defaults. This is a cover method
1027      * for {@code getDefaults().put(key, value)}. This only effects the
1028      * developer defaults, not the system or look and feel defaults.
1029      *
1030      * @param key    an &lt;code&gt;Object&lt;/code&gt; specifying the retrieval key
1031      * @param value  the &lt;code&gt;Object&lt;/code&gt; to store; refer to
1032      *               {@code UIDefaults} for details on how {@code null} is
1033      *               handled
1034      * @return the &lt;code&gt;Object&lt;/code&gt; returned by {@link UIDefaults#put}
1035      * @throws NullPointerException if {@code key} is {@code null}
1036      * @see UIDefaults#put
1037      */
1038     public static Object put(Object key, Object value) {
1039         return getDefaults().put(key, value);
1040     }
1041 
1042     /**
1043      * Returns the appropriate {@code ComponentUI} implementation for
1044      * {@code target}. Typically, this is a cover for
1045      * {@code getDefaults().getUI(target)}. However, if an auxiliary
1046      * look and feel has been installed, this first invokes
1047      * {@code getUI(target)} on the multiplexing look and feel&#39;s
1048      * defaults, and returns that value if it is {@code non-null}.
1049      *
1050      * @param target the &lt;code&gt;JComponent&lt;/code&gt; to return the
1051      *        {@code ComponentUI} for
1052      * @return the &lt;code&gt;ComponentUI&lt;/code&gt; object for {@code target}
1053      * @throws NullPointerException if {@code target} is {@code null}
1054      * @see UIDefaults#getUI
1055      */
1056     public static ComponentUI getUI(JComponent target) {
1057         maybeInitialize();
1058         maybeInitializeFocusPolicy(target);
1059         ComponentUI ui = null;
1060         LookAndFeel multiLAF = getLAFState().multiLookAndFeel;
1061         if (multiLAF != null) {
1062             // This can return null if the multiplexing look and feel
1063             // doesn&#39;t support a particular UI.
1064             ui = multiLAF.getDefaults().getUI(target);
1065         }
1066         if (ui == null) {
1067             ui = getDefaults().getUI(target);
1068         }
1069         return ui;
1070     }
1071 
1072 
1073     /**
1074      * Returns the {@code UIDefaults} from the current look and feel,
1075      * that were obtained at the time the look and feel was installed.
1076      * &lt;p&gt;
1077      * In general, developers should use the {@code UIDefaults} returned from
1078      * {@code getDefaults()}. As the current look and feel may expect
1079      * certain values to exist, altering the {@code UIDefaults} returned
1080      * from this method could have unexpected results.
1081      *
1082      * @return &lt;code&gt;UIDefaults&lt;/code&gt; from the current look and feel
1083      * @see #getDefaults
1084      * @see #setLookAndFeel(LookAndFeel)
1085      * @see LookAndFeel#getDefaults
1086      */
1087     public static UIDefaults getLookAndFeelDefaults() {
1088         maybeInitialize();
1089         return getLAFState().getLookAndFeelDefaults();
1090     }
1091 
1092     /**
1093      * Finds the Multiplexing &lt;code&gt;LookAndFeel&lt;/code&gt;.
1094      */
1095     @SuppressWarnings(&quot;deprecation&quot;)
1096     private static LookAndFeel getMultiLookAndFeel() {
1097         LookAndFeel multiLookAndFeel = getLAFState().multiLookAndFeel;
1098         if (multiLookAndFeel == null) {
1099             String defaultName = &quot;javax.swing.plaf.multi.MultiLookAndFeel&quot;;
1100             String className = getLAFState().swingProps.getProperty(multiplexingLAFKey, defaultName);
1101             try {
1102                 Class&lt;?&gt; lnfClass = SwingUtilities.loadSystemClass(className);
1103                 multiLookAndFeel =
1104                         (LookAndFeel)lnfClass.newInstance();
1105             } catch (Exception exc) {
1106                 System.err.println(&quot;UIManager: failed loading &quot; + className);
1107             }
1108         }
1109         return multiLookAndFeel;
1110     }
1111 
1112     /**
1113      * Adds a &lt;code&gt;LookAndFeel&lt;/code&gt; to the list of auxiliary look and feels.
1114      * The auxiliary look and feels tell the multiplexing look and feel what
1115      * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are to be used
1116      * in addition to the default &lt;code&gt;LookAndFeel&lt;/code&gt; class when creating a
1117      * multiplexing UI.  The change will only take effect when a new
1118      * UI class is created or when the default look and feel is changed
1119      * on a component instance.
1120      * &lt;p&gt;Note these are not the same as the installed look and feels.
1121      *
1122      * @param laf the &lt;code&gt;LookAndFeel&lt;/code&gt; object
1123      * @see #removeAuxiliaryLookAndFeel
1124      * @see #setLookAndFeel
1125      * @see #getAuxiliaryLookAndFeels
1126      * @see #getInstalledLookAndFeels
1127      */
1128     public static void addAuxiliaryLookAndFeel(LookAndFeel laf) {
1129         maybeInitialize();
1130 
1131         if (!laf.isSupportedLookAndFeel()) {
1132             // Ideally we would throw an exception here, but it&#39;s too late
1133             // for that.
1134             return;
1135         }
1136         Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;
1137         if (v == null) {
1138             v = new Vector&lt;LookAndFeel&gt;();
1139         }
1140 
1141         if (!v.contains(laf)) {
1142             v.addElement(laf);
1143             laf.initialize();
1144             getLAFState().auxLookAndFeels = v;
1145 
1146             if (getLAFState().multiLookAndFeel == null) {
1147                 getLAFState().multiLookAndFeel = getMultiLookAndFeel();
1148             }
1149         }
1150     }
1151 
1152     /**
1153      * Removes a &lt;code&gt;LookAndFeel&lt;/code&gt; from the list of auxiliary look and feels.
1154      * The auxiliary look and feels tell the multiplexing look and feel what
1155      * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are to be used
1156      * in addition to the default &lt;code&gt;LookAndFeel&lt;/code&gt; class when creating a
1157      * multiplexing UI.  The change will only take effect when a new
1158      * UI class is created or when the default look and feel is changed
1159      * on a component instance.
1160      * &lt;p&gt;Note these are not the same as the installed look and feels.
1161      *
1162      * @param laf the {@code LookAndFeel} to be removed
1163      * @return true if the &lt;code&gt;LookAndFeel&lt;/code&gt; was removed from the list
1164      * @see #removeAuxiliaryLookAndFeel
1165      * @see #getAuxiliaryLookAndFeels
1166      * @see #setLookAndFeel
1167      * @see #getInstalledLookAndFeels
1168      */
1169     public static boolean removeAuxiliaryLookAndFeel(LookAndFeel laf) {
1170         maybeInitialize();
1171 
1172         boolean result;
1173 
1174         Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;
1175         if ((v == null) || (v.size() == 0)) {
1176             return false;
1177         }
1178 
1179         result = v.removeElement(laf);
1180         if (result) {
1181             if (v.size() == 0) {
1182                 getLAFState().auxLookAndFeels = null;
1183                 getLAFState().multiLookAndFeel = null;
1184             } else {
1185                 getLAFState().auxLookAndFeels = v;
1186             }
1187         }
1188         laf.uninitialize();
1189 
1190         return result;
1191     }
1192 
1193     /**
1194      * Returns the list of auxiliary look and feels (can be &lt;code&gt;null&lt;/code&gt;).
1195      * The auxiliary look and feels tell the multiplexing look and feel what
1196      * other &lt;code&gt;LookAndFeel&lt;/code&gt; classes for a component instance are
1197      * to be used in addition to the default LookAndFeel class when creating a
1198      * multiplexing UI.
1199      * &lt;p&gt;Note these are not the same as the installed look and feels.
1200      *
1201      * @return list of auxiliary &lt;code&gt;LookAndFeel&lt;/code&gt;s or &lt;code&gt;null&lt;/code&gt;
1202      * @see #addAuxiliaryLookAndFeel
1203      * @see #removeAuxiliaryLookAndFeel
1204      * @see #setLookAndFeel
1205      * @see #getInstalledLookAndFeels
1206      */
1207     public static LookAndFeel[] getAuxiliaryLookAndFeels() {
1208         maybeInitialize();
1209 
1210         Vector&lt;LookAndFeel&gt; v = getLAFState().auxLookAndFeels;
1211         if ((v == null) || (v.size() == 0)) {
1212             return null;
1213         }
1214         else {
1215             LookAndFeel[] rv = new LookAndFeel[v.size()];
1216             for (int i = 0; i &lt; rv.length; i++) {
1217                 rv[i] = v.elementAt(i);
1218             }
1219             return rv;
1220         }
1221     }
1222 
1223 
1224     /**
1225      * Adds a &lt;code&gt;PropertyChangeListener&lt;/code&gt; to the listener list.
1226      * The listener is registered for all properties.
1227      *
1228      * @param listener  the &lt;code&gt;PropertyChangeListener&lt;/code&gt; to be added
1229      * @see java.beans.PropertyChangeSupport
1230      */
1231     public static void addPropertyChangeListener(PropertyChangeListener listener)
1232     {
1233         synchronized (classLock) {
1234             getLAFState().getPropertyChangeSupport(true).
1235                              addPropertyChangeListener(listener);
1236         }
1237     }
1238 
1239 
1240     /**
1241      * Removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; from the listener list.
1242      * This removes a &lt;code&gt;PropertyChangeListener&lt;/code&gt; that was registered
1243      * for all properties.
1244      *
1245      * @param listener  the &lt;code&gt;PropertyChangeListener&lt;/code&gt; to be removed
1246      * @see java.beans.PropertyChangeSupport
1247      */
1248     public static void removePropertyChangeListener(PropertyChangeListener listener)
1249     {
1250         synchronized (classLock) {
1251             getLAFState().getPropertyChangeSupport(true).
1252                           removePropertyChangeListener(listener);
1253         }
1254     }
1255 
1256 
1257     /**
1258      * Returns an array of all the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s added
1259      * to this UIManager with addPropertyChangeListener().
1260      *
1261      * @return all of the &lt;code&gt;PropertyChangeListener&lt;/code&gt;s added or an empty
1262      *         array if no listeners have been added
1263      * @since 1.4
1264      */
1265     public static PropertyChangeListener[] getPropertyChangeListeners() {
1266         synchronized(classLock) {
1267             return getLAFState().getPropertyChangeSupport(true).
1268                       getPropertyChangeListeners();
1269         }
1270     }
1271 
1272     private static Properties loadSwingProperties()
1273     {
1274         /* Don&#39;t bother checking for Swing properties if untrusted, as
1275          * there&#39;s no way to look them up without triggering SecurityExceptions.
1276          */
1277         if (UIManager.class.getClassLoader() != null) {
1278             return new Properties();
1279         }
1280         else {
1281             final Properties props = new Properties();
1282 
1283             java.security.AccessController.doPrivileged(
1284                 new java.security.PrivilegedAction&lt;Object&gt;() {
1285                 public Object run() {
1286                     OSInfo.OSType osType = AccessController.doPrivileged(OSInfo.getOSTypeAction());
1287                     if (osType == OSInfo.OSType.MACOSX) {
1288                         props.put(defaultLAFKey, getSystemLookAndFeelClassName());
1289                     }
1290 
1291                     try {
1292                         File file = new File(makeSwingPropertiesFilename());
1293 
1294                         if (file.exists()) {
1295                             // InputStream has been buffered in Properties
1296                             // class
1297                             FileInputStream ins = new FileInputStream(file);
1298                             props.load(ins);
1299                             ins.close();
1300                         }
1301                     }
1302                     catch (Exception e) {
1303                         // No such file, or file is otherwise non-readable.
1304                     }
1305 
1306                     // Check whether any properties were overridden at the
1307                     // command line.
1308                     checkProperty(props, defaultLAFKey);
1309                     checkProperty(props, auxiliaryLAFsKey);
1310                     checkProperty(props, multiplexingLAFKey);
1311                     checkProperty(props, installedLAFsKey);
1312                     checkProperty(props, disableMnemonicKey);
1313                     // Don&#39;t care about return value.
1314                     return null;
1315                 }
1316             });
1317             return props;
1318         }
1319     }
1320 
1321     private static void checkProperty(Properties props, String key) {
1322         // No need to do catch the SecurityException here, this runs
1323         // in a doPrivileged.
1324         String value = System.getProperty(key);
1325         if (value != null) {
1326             props.put(key, value);
1327         }
1328     }
1329 
1330 
1331     /**
1332      * If a &lt;code&gt;swing.properties&lt;/code&gt; file exist and it has a
1333      * &lt;code&gt;swing.installedlafs&lt;/code&gt; property
1334      * then initialize the &lt;code&gt;installedLAFs&lt;/code&gt; field.
1335      *
1336      * @see #getInstalledLookAndFeels
1337      */
1338     private static void initializeInstalledLAFs(Properties swingProps)
1339     {
1340         String ilafsString = swingProps.getProperty(installedLAFsKey);
1341         if (ilafsString == null) {
1342             return;
1343         }
1344 
1345         /* Create a vector that contains the value of the swing.installedlafs
1346          * property.  For example given &quot;swing.installedlafs=motif,windows&quot;
1347          * lafs = {&quot;motif&quot;, &quot;windows&quot;}.
1348          */
1349         Vector&lt;String&gt; lafs = new Vector&lt;String&gt;();
1350         StringTokenizer st = new StringTokenizer(ilafsString, &quot;,&quot;, false);
1351         while (st.hasMoreTokens()) {
1352             lafs.addElement(st.nextToken());
1353         }
1354 
1355         /* Look up the name and class for each name in the &quot;swing.installedlafs&quot;
1356          * list.  If they both exist then add a LookAndFeelInfo to
1357          * the installedLafs array.
1358          */
1359         Vector&lt;LookAndFeelInfo&gt; ilafs = new Vector&lt;LookAndFeelInfo&gt;(lafs.size());
1360         for (String laf : lafs) {
1361             String name = swingProps.getProperty(makeInstalledLAFKey(laf, &quot;name&quot;), laf);
1362             String cls = swingProps.getProperty(makeInstalledLAFKey(laf, &quot;class&quot;));
1363             if (cls != null) {
1364                 ilafs.addElement(new LookAndFeelInfo(name, cls));
1365             }
1366         }
1367 
1368         LookAndFeelInfo[] installedLAFs = new LookAndFeelInfo[ilafs.size()];
1369         for(int i = 0; i &lt; ilafs.size(); i++) {
1370             installedLAFs[i] = ilafs.elementAt(i);
1371         }
1372         getLAFState().installedLAFs = installedLAFs;
1373     }
1374 
1375 
1376     /**
1377      * If the user has specified a default look and feel, use that.
1378      * Otherwise use the look and feel that&#39;s native to this platform.
1379      * If this code is called after the application has explicitly
1380      * set it&#39;s look and feel, do nothing.
1381      *
1382      * @see #maybeInitialize
1383      */
1384     private static void initializeDefaultLAF(Properties swingProps)
1385     {
1386         if (getLAFState().lookAndFeel != null) {
1387             return;
1388         }
1389 
1390         // Try to get default LAF from system property, then from AppContext
1391         // (6653395), then use cross-platform one by default.
1392         String lafName = null;
1393         @SuppressWarnings(&quot;unchecked&quot;)
1394         HashMap&lt;Object, String&gt; lafData =
1395                 (HashMap) AppContext.getAppContext().remove(&quot;swing.lafdata&quot;);
1396         if (lafData != null) {
1397             lafName = lafData.remove(&quot;defaultlaf&quot;);
1398         }
1399         if (lafName == null) {
1400             lafName = getCrossPlatformLookAndFeelClassName();
1401         }
1402         lafName = swingProps.getProperty(defaultLAFKey, lafName);
1403 
1404         try {
1405             setLookAndFeel(lafName);
1406         } catch (Exception e) {
1407             throw new Error(&quot;Cannot load &quot; + lafName);
1408         }
1409 
1410         // Set any properties passed through AppContext (6653395).
1411         if (lafData != null) {
1412             for (Object key: lafData.keySet()) {
1413                 UIManager.put(key, lafData.get(key));
1414             }
1415         }
1416     }
1417 
1418 
1419     @SuppressWarnings(&quot;deprecation&quot;)
1420     private static void initializeAuxiliaryLAFs(Properties swingProps)
1421     {
1422         String auxLookAndFeelNames = swingProps.getProperty(auxiliaryLAFsKey);
1423         if (auxLookAndFeelNames == null) {
1424             return;
1425         }
1426 
1427         Vector&lt;LookAndFeel&gt; auxLookAndFeels = new Vector&lt;LookAndFeel&gt;();
1428 
1429         StringTokenizer p = new StringTokenizer(auxLookAndFeelNames,&quot;,&quot;);
1430         String factoryName;
1431 
1432         /* Try to load each LookAndFeel subclass in the list.
1433          */
1434 
1435         while (p.hasMoreTokens()) {
1436             String className = p.nextToken();
1437             try {
1438                 Class&lt;?&gt; lnfClass = SwingUtilities.loadSystemClass(className);
1439                 LookAndFeel newLAF =
1440                         (LookAndFeel)lnfClass.newInstance();
1441                 newLAF.initialize();
1442                 auxLookAndFeels.addElement(newLAF);
1443             }
1444             catch (Exception e) {
1445                 System.err.println(&quot;UIManager: failed loading auxiliary look and feel &quot; + className);
1446             }
1447         }
1448 
1449         /* If there were problems and no auxiliary look and feels were
1450          * loaded, make sure we reset auxLookAndFeels to null.
1451          * Otherwise, we are going to use the MultiLookAndFeel to get
1452          * all component UI&#39;s, so we need to load it now.
1453          */
1454         if (auxLookAndFeels.size() == 0) {
1455             auxLookAndFeels = null;
1456         }
1457         else {
1458             getLAFState().multiLookAndFeel = getMultiLookAndFeel();
1459             if (getLAFState().multiLookAndFeel == null) {
1460                 auxLookAndFeels = null;
1461             }
1462         }
1463 
1464         getLAFState().auxLookAndFeels = auxLookAndFeels;
1465     }
1466 
1467 
1468     private static void initializeSystemDefaults(Properties swingProps) {
1469         getLAFState().swingProps = swingProps;
1470     }
1471 
1472 
1473     /*
1474      * This method is called before any code that depends on the
1475      * &lt;code&gt;AppContext&lt;/code&gt; specific LAFState object runs.  When the AppContext
1476      * corresponds to a set of applets it&#39;s possible for this method
1477      * to be re-entered, which is why we grab a lock before calling
1478      * initialize().
1479      */
1480     private static void maybeInitialize() {
1481         synchronized (classLock) {
1482             if (!getLAFState().initialized) {
1483                 getLAFState().initialized = true;
1484                 initialize();
1485             }
1486         }
1487     }
1488 
1489     /*
1490      * Sets default swing focus traversal policy.
1491      */
1492     @SuppressWarnings(&quot;deprecation&quot;)
1493     private static void maybeInitializeFocusPolicy(JComponent comp) {
1494         // Check for JRootPane which indicates that a swing toplevel
1495         // is coming, in which case a swing default focus policy
1496         // should be instatiated. See 7125044.
1497         if (comp instanceof JRootPane) {
1498             synchronized (classLock) {
1499                 if (!getLAFState().focusPolicyInitialized) {
1500                     getLAFState().focusPolicyInitialized = true;
1501 
1502                     if (FocusManager.isFocusManagerEnabled()) {
1503                         KeyboardFocusManager.getCurrentKeyboardFocusManager().
1504                             setDefaultFocusTraversalPolicy(
1505                                 new LayoutFocusTraversalPolicy());
1506                     }
1507                 }
1508             }
1509         }
1510     }
1511 
1512     /*
1513      * Only called by maybeInitialize().
1514      */
1515     private static void initialize() {
1516         Properties swingProps = loadSwingProperties();
1517         initializeSystemDefaults(swingProps);
1518         initializeDefaultLAF(swingProps);
1519         initializeAuxiliaryLAFs(swingProps);
1520         initializeInstalledLAFs(swingProps);
1521 
1522         // Install Swing&#39;s PaintEventDispatcher
1523         if (RepaintManager.HANDLE_TOP_LEVEL_PAINT) {
1524             sun.awt.PaintEventDispatcher.setPaintEventDispatcher(
1525                                         new SwingPaintEventDispatcher());
1526         }
1527         // Install a hook that will be invoked if no one consumes the
1528         // KeyEvent.  If the source isn&#39;t a JComponent this will process
1529         // key bindings, if the source is a JComponent it implies that
1530         // processKeyEvent was already invoked and thus no need to process
1531         // the bindings again, unless the Component is disabled, in which
1532         // case KeyEvents will no longer be dispatched to it so that we
1533         // handle it here.
1534         KeyboardFocusManager.getCurrentKeyboardFocusManager().
1535                 addKeyEventPostProcessor(new KeyEventPostProcessor() {
1536                     public boolean postProcessKeyEvent(KeyEvent e) {
1537                         Component c = e.getComponent();
1538 
1539                         if ((!(c instanceof JComponent) ||
1540                              (c != null &amp;&amp; !c.isEnabled())) &amp;&amp;
1541                                 JComponent.KeyboardState.shouldProcess(e) &amp;&amp;
1542                                 SwingUtilities.processKeyBindings(e)) {
1543                             e.consume();
1544                             return true;
1545                         }
1546                         return false;
1547                     }
1548                 });
1549         AWTAccessor.getComponentAccessor().
1550             setRequestFocusController(JComponent.focusController);
1551     }
1552 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/classes/sun/font/FileFontStrike.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.lang.ref.SoftReference;
 29 import java.lang.ref.WeakReference;
 30 import java.awt.Font;
 31 import java.awt.GraphicsEnvironment;
 32 import java.awt.Rectangle;
 33 import java.awt.geom.AffineTransform;
 34 import java.awt.geom.GeneralPath;
 35 import java.awt.geom.NoninvertibleTransformException;
 36 import java.awt.geom.Point2D;
 37 import java.awt.geom.Rectangle2D;
 38 import java.util.concurrent.ConcurrentHashMap;
 39 import static sun.awt.SunHints.*;
 40 
 41 
 42 public class FileFontStrike extends PhysicalStrike {
 43 
 44     /* fffe and ffff are values we specially interpret as meaning
 45      * invisible glyphs.
 46      */
 47     static final int INVISIBLE_GLYPHS = 0x0fffe;
 48 
 49     private FileFont fileFont;
 50 
 51     /* REMIND: replace this scheme with one that installs a cache
 52      * instance of the appropriate type. It will require changes in
 53      * FontStrikeDisposer and NativeStrike etc.
 54      */
 55     private static final int UNINITIALISED = 0;
 56     private static final int INTARRAY      = 1;
 57     private static final int LONGARRAY     = 2;
 58     private static final int SEGINTARRAY   = 3;
 59     private static final int SEGLONGARRAY  = 4;
 60 
 61     private volatile int glyphCacheFormat = UNINITIALISED;
 62 
 63     /* segmented arrays are blocks of 32 */
 64     private static final int SEGSHIFT = 5;
 65     private static final int SEGSIZE  = 1 &lt;&lt; SEGSHIFT;
 66 
 67     private boolean segmentedCache;
 68     private int[][] segIntGlyphImages;
 69     private long[][] segLongGlyphImages;
 70 
 71     /* The &quot;metrics&quot; information requested by clients is usually nothing
 72      * more than the horizontal advance of the character.
 73      * In most cases this advance and other metrics information is stored
 74      * in the glyph image cache.
 75      * But in some cases we do not automatically retrieve the glyph
 76      * image when the advance is requested. In those cases we want to
 77      * cache the advances since this has been shown to be important for
 78      * performance.
 79      * The segmented cache is used in cases when the single array
 80      * would be too large.
 81      */
 82     private float[] horizontalAdvances;
 83     private float[][] segHorizontalAdvances;
 84 
 85     /* Outline bounds are used when printing and when drawing outlines
 86      * to the screen. On balance the relative rarity of these cases
 87      * and the fact that getting this requires generating a path at
 88      * the scaler level means that its probably OK to store these
 89      * in a Java-level hashmap as the trade-off between time and space.
 90      * Later can revisit whether to cache these at all, or elsewhere.
 91      * Should also profile whether subsequent to getting the bounds, the
 92      * outline itself is also requested. The 1.4 implementation doesn&#39;t
 93      * cache outlines so you could generate the path twice - once to get
 94      * the bounds and again to return the outline to the client.
 95      * If the two uses are coincident then also look into caching outlines.
 96      * One simple optimisation is that we could store the last single
 97      * outline retrieved. This assumes that bounds then outline will always
 98      * be retrieved for a glyph rather than retrieving bounds for all glyphs
 99      * then outlines for all glyphs.
100      */
101     ConcurrentHashMap&lt;Integer, Rectangle2D.Float&gt; boundsMap;
102     SoftReference&lt;ConcurrentHashMap&lt;Integer, Point2D.Float&gt;&gt;
103         glyphMetricsMapRef;
104 
105     AffineTransform invertDevTx;
106 
107     boolean useNatives;
108     NativeStrike[] nativeStrikes;
109 
110     /* Used only for communication to native layer */
111     private int intPtSize;
112 
113     /* Perform global initialisation needed for Windows native rasterizer */
114     private static native boolean initNative();
115     private static boolean isXPorLater = false;
116     static {
117         if (FontUtilities.isWindows &amp;&amp; !FontUtilities.useJDKScaler &amp;&amp;
118             !GraphicsEnvironment.isHeadless()) {
119             isXPorLater = initNative();
120         }
121     }
122 
123     FileFontStrike(FileFont fileFont, FontStrikeDesc desc) {
124         super(fileFont, desc);
125         this.fileFont = fileFont;
126 
127         if (desc.style != fileFont.style) {
128           /* If using algorithmic styling, the base values are
129            * boldness = 1.0, italic = 0.0. The superclass constructor
130            * initialises these.
131            */
132             if ((desc.style &amp; Font.ITALIC) == Font.ITALIC &amp;&amp;
133                 (fileFont.style &amp; Font.ITALIC) == 0) {
134                 algoStyle = true;
135                 italic = 0.7f;
136             }
137             if ((desc.style &amp; Font.BOLD) == Font.BOLD &amp;&amp;
138                 ((fileFont.style &amp; Font.BOLD) == 0)) {
139                 algoStyle = true;
140                 boldness = 1.33f;
141             }
142         }
143         double[] matrix = new double[4];
144         AffineTransform at = desc.glyphTx;
145         at.getMatrix(matrix);
146         if (!desc.devTx.isIdentity() &amp;&amp;
147             desc.devTx.getType() != AffineTransform.TYPE_TRANSLATION) {
148             try {
149                 invertDevTx = desc.devTx.createInverse();
150             } catch (NoninvertibleTransformException e) {
151             }
152         }
153 
154         /* If any of the values is NaN then substitute the null scaler context.
155          * This will return null images, zero advance, and empty outlines
156          * as no rendering need take place in this case.
157          * We pass in the null scaler as the singleton null context
158          * requires it. However
159          */
160         if (Double.isNaN(matrix[0]) || Double.isNaN(matrix[1]) ||
161             Double.isNaN(matrix[2]) || Double.isNaN(matrix[3]) ||
162             fileFont.getScaler() == null) {
163             pScalerContext = NullFontScaler.getNullScalerContext();
164         } else {
165             pScalerContext = fileFont.getScaler().createScalerContext(matrix,
166                                     desc.aaHint, desc.fmHint,
167                                     boldness, italic);
168         }
169 
170         mapper = fileFont.getMapper();
171         int numGlyphs = mapper.getNumGlyphs();
172 
173         /* Always segment for fonts with &gt; 256 glyphs, but also for smaller
174          * fonts with non-typical sizes and transforms.
175          * Segmenting for all non-typical pt sizes helps to minimize memory
176          * usage when very many distinct strikes are created.
177          * The size range of 0-&gt;5 and 37-&gt;INF for segmenting is arbitrary
178          * but the intention is that typical GUI integer point sizes (6-&gt;36)
179          * should not segment unless there&#39;s another reason to do so.
180          */
181         float ptSize = (float)matrix[3]; // interpreted only when meaningful.
182         int iSize = intPtSize = (int)ptSize;
183         boolean isSimpleTx = (at.getType() &amp; complexTX) == 0;
184         segmentedCache =
185             (numGlyphs &gt; SEGSIZE &lt;&lt; 3) ||
186             ((numGlyphs &gt; SEGSIZE &lt;&lt; 1) &amp;&amp;
187              (!isSimpleTx || ptSize != iSize || iSize &lt; 6 || iSize &gt; 36));
188 
189         /* This can only happen if we failed to allocate memory for context.
190          * NB: in such case we may still have some memory in java heap
191          *     but subsequent attempt to allocate null scaler context
192          *     may fail too (cause it is allocate in the native heap).
193          *     It is not clear how to make this more robust but on the
194          *     other hand getting NULL here seems to be extremely unlikely.
195          */
196         if (pScalerContext == 0L) {
197             /* REMIND: when the code is updated to install cache objects
198              * rather than using a switch this will be more efficient.
199              */
200             this.disposer = new FontStrikeDisposer(fileFont, desc);
201             initGlyphCache();
202             pScalerContext = NullFontScaler.getNullScalerContext();
203             SunFontManager.getInstance().deRegisterBadFont(fileFont);
204             return;
205         }
206         /* First, see if native code should be used to create the glyph.
207          * GDI will return the integer metrics, not fractional metrics, which
208          * may be requested for this strike, so we would require here that :
209          * desc.fmHint != INTVAL_FRACTIONALMETRICS_ON
210          * except that the advance returned by GDI is always overwritten by
211          * the JDK rasteriser supplied one (see getGlyphImageFromWindows()).
212          */
213         if (FontUtilities.isWindows &amp;&amp; isXPorLater &amp;&amp;
214             !FontUtilities.useJDKScaler &amp;&amp;
215             !GraphicsEnvironment.isHeadless() &amp;&amp;
216             !fileFont.useJavaRasterizer &amp;&amp;
217             (desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HRGB ||
218              desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HBGR) &amp;&amp;
219             (matrix[1] == 0.0 &amp;&amp; matrix[2] == 0.0 &amp;&amp;
220              matrix[0] == matrix[3] &amp;&amp;
221              matrix[0] &gt;= 3.0 &amp;&amp; matrix[0] &lt;= 100.0) &amp;&amp;
222             !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {
223             useNatives = true;
224         }
225         else if (fileFont.checkUseNatives() &amp;&amp; desc.aaHint==0 &amp;&amp; !algoStyle) {
226             /* Check its a simple scale of a pt size in the range
227              * where native bitmaps typically exist (6-36 pts) */
228             if (matrix[1] == 0.0 &amp;&amp; matrix[2] == 0.0 &amp;&amp;
229                 matrix[0] &gt;= 6.0 &amp;&amp; matrix[0] &lt;= 36.0 &amp;&amp;
230                 matrix[0] == matrix[3]) {
231                 useNatives = true;
232                 int numNatives = fileFont.nativeFonts.length;
233                 nativeStrikes = new NativeStrike[numNatives];
234                 /* Maybe initialise these strikes lazily?. But we
235                  * know we need at least one
236                  */
237                 for (int i=0; i&lt;numNatives; i++) {
238                     nativeStrikes[i] =
239                         new NativeStrike(fileFont.nativeFonts[i], desc, false);
240                 }
241             }
242         }
243         if (FontUtilities.isLogging() &amp;&amp; FontUtilities.isWindows) {
244             FontUtilities.getLogger().info
245                 (&quot;Strike for &quot; + fileFont + &quot; at size = &quot; + intPtSize +
246                  &quot; use natives = &quot; + useNatives +
247                  &quot; useJavaRasteriser = &quot; + fileFont.useJavaRasterizer +
248                  &quot; AAHint = &quot; + desc.aaHint +
249                  &quot; Has Embedded bitmaps = &quot; +
250                  ((TrueTypeFont)fileFont).
251                  useEmbeddedBitmapsForSize(intPtSize));
252         }
253         this.disposer = new FontStrikeDisposer(fileFont, desc, pScalerContext);
254 
255         /* Always get the image and the advance together for smaller sizes
256          * that are likely to be important to rendering performance.
257          * The pixel size of 48.0 can be thought of as
258          * &quot;maximumSizeForGetImageWithAdvance&quot;.
259          * This should be no greater than OutlineTextRender.THRESHOLD.
260          */
261         double maxSz = 48.0;
262         getImageWithAdvance =
263             Math.abs(at.getScaleX()) &lt;= maxSz &amp;&amp;
264             Math.abs(at.getScaleY()) &lt;= maxSz &amp;&amp;
265             Math.abs(at.getShearX()) &lt;= maxSz &amp;&amp;
266             Math.abs(at.getShearY()) &lt;= maxSz;
267 
268         /* Some applications request advance frequently during layout.
269          * If we are not getting and caching the image with the advance,
270          * there is a potentially significant performance penalty if the
271          * advance is repeatedly requested before requesting the image.
272          * We should at least cache the horizontal advance.
273          * REMIND: could use info in the font, eg hmtx, to retrieve some
274          * advances. But still want to cache it here.
275          */
276 
277         if (!getImageWithAdvance) {
278             if (!segmentedCache) {
279                 horizontalAdvances = new float[numGlyphs];
280                 /* use max float as uninitialised advance */
281                 for (int i=0; i&lt;numGlyphs; i++) {
282                     horizontalAdvances[i] = Float.MAX_VALUE;
283                 }
284             } else {
285                 int numSegments = (numGlyphs + SEGSIZE-1)/SEGSIZE;
286                 segHorizontalAdvances = new float[numSegments][];
287             }
288         }
289     }
290 
291     /* A number of methods are delegated by the strike to the scaler
292      * context which is a shared resource on a physical font.
293      */
294 
295     public int getNumGlyphs() {
296         return fileFont.getNumGlyphs();
297     }
298 
299     long getGlyphImageFromNative(int glyphCode) {
300         if (FontUtilities.isWindows) {
301             return getGlyphImageFromWindows(glyphCode);
302         } else {
303             return getGlyphImageFromX11(glyphCode);
304         }
305     }
306 
307     /* There&#39;s no global state conflicts, so this method is not
308      * presently synchronized.
309      */
310     private native long _getGlyphImageFromWindows(String family,
311                                                   int style,
312                                                   int size,
313                                                   int glyphCode,
314                                                   boolean fracMetrics,
315                                                   int fontDataSize);
316 
317     long getGlyphImageFromWindows(int glyphCode) {
318         String family = fileFont.getFamilyName(null);
319         int style = desc.style &amp; Font.BOLD | desc.style &amp; Font.ITALIC
320             | fileFont.getStyle();
321         int size = intPtSize;
322         long ptr = _getGlyphImageFromWindows
323             (family, style, size, glyphCode,
324              desc.fmHint == INTVAL_FRACTIONALMETRICS_ON,
325              ((TrueTypeFont)fileFont).fontDataSize);
326         if (ptr != 0) {
327             /* Get the advance from the JDK rasterizer. This is mostly
328              * necessary for the fractional metrics case, but there are
329              * also some very small number (&lt;0.25%) of marginal cases where
330              * there is some rounding difference between windows and JDK.
331              * After these are resolved, we can restrict this extra
332              * work to the FM case.
333              */
334             float advance = getGlyphAdvance(glyphCode, false);
335             StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,
336                                         advance);
337             return ptr;
338         } else {
339             if (FontUtilities.isLogging()) {
340                 FontUtilities.getLogger().warning(
341                         &quot;Failed to render glyph using GDI: code=&quot; + glyphCode
342                                 + &quot;, fontFamily=&quot; + family + &quot;, style=&quot; + style
343                                 + &quot;, size=&quot; + size);
344             }
345             return fileFont.getGlyphImage(pScalerContext, glyphCode);
346         }
347     }
348 
349     /* Try the native strikes first, then try the fileFont strike */
350     long getGlyphImageFromX11(int glyphCode) {
351         long glyphPtr;
352         char charCode = fileFont.glyphToCharMap[glyphCode];
353         for (int i=0;i&lt;nativeStrikes.length;i++) {
354             CharToGlyphMapper mapper = fileFont.nativeFonts[i].getMapper();
355             int gc = mapper.charToGlyph(charCode)&amp;0xffff;
356             if (gc != mapper.getMissingGlyphCode()) {
357                 glyphPtr = nativeStrikes[i].getGlyphImagePtrNoCache(gc);
358                 if (glyphPtr != 0L) {
359                     return glyphPtr;
360                 }
361             }
362         }
363         return fileFont.getGlyphImage(pScalerContext, glyphCode);
364     }
365 
366     long getGlyphImagePtr(int glyphCode) {
367         if (glyphCode &gt;= INVISIBLE_GLYPHS) {
368             return StrikeCache.invisibleGlyphPtr;
369         }
370         long glyphPtr = 0L;
371         if ((glyphPtr = getCachedGlyphPtr(glyphCode)) != 0L) {
372             return glyphPtr;
373         } else {
374             if (useNatives) {
375                 glyphPtr = getGlyphImageFromNative(glyphCode);
376                 if (glyphPtr == 0L &amp;&amp; FontUtilities.isLogging()) {
377                     FontUtilities.getLogger().info
378                         (&quot;Strike for &quot; + fileFont +
379                          &quot; at size = &quot; + intPtSize +
380                          &quot; couldn&#39;t get native glyph for code = &quot; + glyphCode);
381                  }
382             } if (glyphPtr == 0L) {
383                 glyphPtr = fileFont.getGlyphImage(pScalerContext,
384                                                   glyphCode);
385             }
386             return setCachedGlyphPtr(glyphCode, glyphPtr);
387         }
388     }
389 
390     void getGlyphImagePtrs(int[] glyphCodes, long[] images, int  len) {
391 
392         for (int i=0; i&lt;len; i++) {
393             int glyphCode = glyphCodes[i];
394             if (glyphCode &gt;= INVISIBLE_GLYPHS) {
395                 images[i] = StrikeCache.invisibleGlyphPtr;
396                 continue;
397             } else if ((images[i] = getCachedGlyphPtr(glyphCode)) != 0L) {
398                 continue;
399             } else {
400                 long glyphPtr = 0L;
401                 if (useNatives) {
402                     glyphPtr = getGlyphImageFromNative(glyphCode);
403                 } if (glyphPtr == 0L) {
404                     glyphPtr = fileFont.getGlyphImage(pScalerContext,
405                                                       glyphCode);
406                 }
407                 images[i] = setCachedGlyphPtr(glyphCode, glyphPtr);
408             }
409         }
410     }
411 
412     /* The following method is called from CompositeStrike as a special case.
413      */
414     int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int len) {
415 
416         int convertedCnt = 0;
417 
418         for (int i=0; i&lt;len; i++) {
419             int glyphCode = glyphCodes[i];
420             if (glyphCode &gt;&gt;&gt; 24 != 0) {
421                 return convertedCnt;
422             } else {
423                 convertedCnt++;
424             }
425             if (glyphCode &gt;= INVISIBLE_GLYPHS) {
426                 images[i] = StrikeCache.invisibleGlyphPtr;
427                 continue;
428             } else if ((images[i] = getCachedGlyphPtr(glyphCode)) != 0L) {
429                 continue;
430             } else {
431                 long glyphPtr = 0L;
432                 if (useNatives) {
433                     glyphPtr = getGlyphImageFromNative(glyphCode);
434                 }
435                 if (glyphPtr == 0L) {
436                     glyphPtr = fileFont.getGlyphImage(pScalerContext,
437                                                       glyphCode);
438                 }
439                 images[i] = setCachedGlyphPtr(glyphCode, glyphPtr);
440             }
441         }
442         return convertedCnt;
443     }
444 
445     /* Only look in the cache */
446     long getCachedGlyphPtr(int glyphCode) {
447         try {
448             return getCachedGlyphPtrInternal(glyphCode);
449         } catch (Exception e) {
450           NullFontScaler nullScaler =
451              (NullFontScaler)FontScaler.getNullScaler();
452           long nullSC = NullFontScaler.getNullScalerContext();
453           return nullScaler.getGlyphImage(nullSC, glyphCode);
454         }
455     }
456 
457     private long getCachedGlyphPtrInternal(int glyphCode) {
458         switch (glyphCacheFormat) {
459             case INTARRAY:
460                 return intGlyphImages[glyphCode] &amp; INTMASK;
461             case SEGINTARRAY:
462                 int segIndex = glyphCode &gt;&gt; SEGSHIFT;
463                 if (segIntGlyphImages[segIndex] != null) {
464                     int subIndex = glyphCode % SEGSIZE;
465                     return segIntGlyphImages[segIndex][subIndex] &amp; INTMASK;
466                 } else {
467                     return 0L;
468                 }
469             case LONGARRAY:
470                 return longGlyphImages[glyphCode];
471             case SEGLONGARRAY:
472                 segIndex = glyphCode &gt;&gt; SEGSHIFT;
473                 if (segLongGlyphImages[segIndex] != null) {
474                     int subIndex = glyphCode % SEGSIZE;
475                     return segLongGlyphImages[segIndex][subIndex];
476                 } else {
477                     return 0L;
478                 }
479         }
480         /* If reach here cache is UNINITIALISED. */
481         return 0L;
482     }
483 
484     private synchronized long setCachedGlyphPtr(int glyphCode, long glyphPtr) {
485         try {
486             return setCachedGlyphPtrInternal(glyphCode, glyphPtr);
487         } catch (Exception e) {
488             switch (glyphCacheFormat) {
489                 case INTARRAY:
490                 case SEGINTARRAY:
491                     StrikeCache.freeIntPointer((int)glyphPtr);
492                     break;
493                 case LONGARRAY:
494                 case SEGLONGARRAY:
495                     StrikeCache.freeLongPointer(glyphPtr);
496                     break;
497              }
498              NullFontScaler nullScaler =
499                  (NullFontScaler)FontScaler.getNullScaler();
500              long nullSC = NullFontScaler.getNullScalerContext();
501              return nullScaler.getGlyphImage(nullSC, glyphCode);
502         }
503     }
504 
505     private long setCachedGlyphPtrInternal(int glyphCode, long glyphPtr) {
506         switch (glyphCacheFormat) {
507             case INTARRAY:
508                 if (intGlyphImages[glyphCode] == 0) {
509                     intGlyphImages[glyphCode] = (int)glyphPtr;
510                     return glyphPtr;
511                 } else {
512                     StrikeCache.freeIntPointer((int)glyphPtr);
513                     return intGlyphImages[glyphCode] &amp; INTMASK;
514                 }
515 
516             case SEGINTARRAY:
517                 int segIndex = glyphCode &gt;&gt; SEGSHIFT;
518                 int subIndex = glyphCode % SEGSIZE;
519                 if (segIntGlyphImages[segIndex] == null) {
520                     segIntGlyphImages[segIndex] = new int[SEGSIZE];
521                 }
522                 if (segIntGlyphImages[segIndex][subIndex] == 0) {
523                     segIntGlyphImages[segIndex][subIndex] = (int)glyphPtr;
524                     return glyphPtr;
525                 } else {
526                     StrikeCache.freeIntPointer((int)glyphPtr);
527                     return segIntGlyphImages[segIndex][subIndex] &amp; INTMASK;
528                 }
529 
530             case LONGARRAY:
531                 if (longGlyphImages[glyphCode] == 0L) {
532                     longGlyphImages[glyphCode] = glyphPtr;
533                     return glyphPtr;
534                 } else {
535                     StrikeCache.freeLongPointer(glyphPtr);
536                     return longGlyphImages[glyphCode];
537                 }
538 
539            case SEGLONGARRAY:
540                 segIndex = glyphCode &gt;&gt; SEGSHIFT;
541                 subIndex = glyphCode % SEGSIZE;
542                 if (segLongGlyphImages[segIndex] == null) {
543                     segLongGlyphImages[segIndex] = new long[SEGSIZE];
544                 }
545                 if (segLongGlyphImages[segIndex][subIndex] == 0L) {
546                     segLongGlyphImages[segIndex][subIndex] = glyphPtr;
547                     return glyphPtr;
548                 } else {
549                     StrikeCache.freeLongPointer(glyphPtr);
550                     return segLongGlyphImages[segIndex][subIndex];
551                 }
552         }
553 
554         /* Reach here only when the cache is not initialised which is only
555          * for the first glyph to be initialised in the strike.
556          * Initialise it and recurse. Note that we are already synchronized.
557          */
558         initGlyphCache();
559         return setCachedGlyphPtr(glyphCode, glyphPtr);
560     }
561 
562     /* Called only from synchronized code or constructor */
563     private synchronized void initGlyphCache() {
564 
565         int numGlyphs = mapper.getNumGlyphs();
566         int tmpFormat = UNINITIALISED;
567         if (segmentedCache) {
568             int numSegments = (numGlyphs + SEGSIZE-1)/SEGSIZE;
569             if (longAddresses) {
570                 tmpFormat = SEGLONGARRAY;
571                 segLongGlyphImages = new long[numSegments][];
572                 this.disposer.segLongGlyphImages = segLongGlyphImages;
573              } else {
574                  tmpFormat = SEGINTARRAY;
575                  segIntGlyphImages = new int[numSegments][];
576                  this.disposer.segIntGlyphImages = segIntGlyphImages;
577              }
578         } else {
579             if (longAddresses) {
580                 tmpFormat = LONGARRAY;
581                 longGlyphImages = new long[numGlyphs];
582                 this.disposer.longGlyphImages = longGlyphImages;
583             } else {
584                 tmpFormat = INTARRAY;
585                 intGlyphImages = new int[numGlyphs];
586                 this.disposer.intGlyphImages = intGlyphImages;
587             }
588         }
589         glyphCacheFormat = tmpFormat;
590     }
591 
592     float getGlyphAdvance(int glyphCode) {
593         return getGlyphAdvance(glyphCode, true);
594     }
595 
596     /* Metrics info is always retrieved. If the GlyphInfo address is non-zero
597      * then metrics info there is valid and can just be copied.
598      * This is in user space coordinates unless getUserAdv == false.
599      * Device space advance should not be propagated out of this class.
600      */
601     private float getGlyphAdvance(int glyphCode, boolean getUserAdv) {
602         float advance;
603 
604         if (glyphCode &gt;= INVISIBLE_GLYPHS) {
605             return 0f;
606         }
607 
608         /* Notes on the (getUserAdv == false) case.
609          *
610          * Setting getUserAdv == false is internal to this class.
611          * If there&#39;s no graphics transform we can let
612          * getGlyphAdvance take its course, and potentially caching in
613          * advances arrays, except for signalling that
614          * getUserAdv == false means there is no need to create an image.
615          * It is possible that code already calculated the user advance,
616          * and it is desirable to take advantage of that work.
617          * But, if there&#39;s a transform and we want device advance, we
618          * can&#39;t use any values cached in the advances arrays - unless
619          * first re-transform them into device space using &#39;desc.devTx&#39;.
620          * invertDevTx is null if the graphics transform is identity,
621          * a translate, or non-invertible. The latter case should
622          * not ever occur in the getUserAdv == false path.
623          * In other words its either null, or the inversion of a
624          * simple uniform scale. If its null, we can populate and
625          * use the advance caches as normal.
626          *
627          * If we don&#39;t find a cached value, obtain the device advance and
628          * return it. This will get stashed on the image by the caller and any
629          * subsequent metrics calls will be able to use it as is the case
630          * whenever an image is what is initially requested.
631          *
632          * Don&#39;t query if there&#39;s a value cached on the image, since this
633          * getUserAdv==false code path is entered solely when none exists.
634          */
635         if (horizontalAdvances != null) {
636             advance = horizontalAdvances[glyphCode];
637             if (advance != Float.MAX_VALUE) {
638                 if (!getUserAdv &amp;&amp; invertDevTx != null) {
639                     Point2D.Float metrics = new Point2D.Float(advance, 0f);
640                     desc.devTx.deltaTransform(metrics, metrics);
641                     return metrics.x;
642                 } else {
643                     return advance;
644                 }
645             }
646         } else if (segmentedCache &amp;&amp; segHorizontalAdvances != null) {
647             int segIndex = glyphCode &gt;&gt; SEGSHIFT;
648             float[] subArray = segHorizontalAdvances[segIndex];
649             if (subArray != null) {
650                 advance = subArray[glyphCode % SEGSIZE];
651                 if (advance != Float.MAX_VALUE) {
652                     if (!getUserAdv &amp;&amp; invertDevTx != null) {
653                         Point2D.Float metrics = new Point2D.Float(advance, 0f);
654                         desc.devTx.deltaTransform(metrics, metrics);
655                         return metrics.x;
656                     } else {
657                         return advance;
658                     }
659                 }
660             }
661         }
662 
663         if (!getUserAdv &amp;&amp; invertDevTx != null) {
664             Point2D.Float metrics = new Point2D.Float();
665             fileFont.getGlyphMetrics(pScalerContext, glyphCode, metrics);
666             return metrics.x;
667         }
668 
669         if (invertDevTx != null || !getUserAdv) {
670             /* If there is a device transform need x &amp; y advance to
671              * transform back into user space.
672              */
673             advance = getGlyphMetrics(glyphCode, getUserAdv).x;
674         } else {
675             long glyphPtr;
676             if (getImageWithAdvance) {
677                 /* A heuristic optimisation says that for most cases its
678                  * worthwhile retrieving the image at the same time as the
679                  * advance. So here we get the image data even if its not
680                  * already cached.
681                  */
682                 glyphPtr = getGlyphImagePtr(glyphCode);
683             } else {
684                 glyphPtr = getCachedGlyphPtr(glyphCode);
685             }
686             if (glyphPtr != 0L) {
687                 advance = StrikeCache.unsafe.getFloat
688                     (glyphPtr + StrikeCache.xAdvanceOffset);
689 
690             } else {
691                 advance = fileFont.getGlyphAdvance(pScalerContext, glyphCode);
692             }
693         }
694 
695         if (horizontalAdvances != null) {
696             horizontalAdvances[glyphCode] = advance;
697         } else if (segmentedCache &amp;&amp; segHorizontalAdvances != null) {
698             int segIndex = glyphCode &gt;&gt; SEGSHIFT;
699             int subIndex = glyphCode % SEGSIZE;
700             if (segHorizontalAdvances[segIndex] == null) {
701                 segHorizontalAdvances[segIndex] = new float[SEGSIZE];
702                 for (int i=0; i&lt;SEGSIZE; i++) {
703                      segHorizontalAdvances[segIndex][i] = Float.MAX_VALUE;
704                 }
705             }
706             segHorizontalAdvances[segIndex][subIndex] = advance;
707         }
708         return advance;
709     }
710 
711     float getCodePointAdvance(int cp) {
712         return getGlyphAdvance(mapper.charToGlyph(cp));
713     }
714 
715     /**
716      * Result and pt are both in device space.
717      */
718     void getGlyphImageBounds(int glyphCode, Point2D.Float pt,
719                              Rectangle result) {
720 
721         long ptr = getGlyphImagePtr(glyphCode);
722         float topLeftX, topLeftY;
723 
724         /* With our current design NULL ptr is not possible
725            but if we eventually allow scalers to return NULL pointers
726            this check might be actually useful. */
727         if (ptr == 0L) {
728             result.x = (int) Math.floor(pt.x+0.5f);
729             result.y = (int) Math.floor(pt.y+0.5f);
730             result.width = result.height = 0;
731             return;
732         }
733 
734         topLeftX = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftXOffset);
735         topLeftY = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftYOffset);
736 
737         result.x = (int)Math.floor(pt.x + topLeftX + 0.5f);
738         result.y = (int)Math.floor(pt.y + topLeftY + 0.5f);
739         result.width =
740             StrikeCache.unsafe.getShort(ptr+StrikeCache.widthOffset)  &amp;0x0ffff;
741         result.height =
742             StrikeCache.unsafe.getShort(ptr+StrikeCache.heightOffset) &amp;0x0ffff;
743 
744         /* HRGB LCD text may have padding that is empty. This is almost always
745          * going to be when topLeftX is -2 or less.
746          * Try to return a tighter bounding box in that case.
747          * If the first three bytes of every row are all zero, then
748          * add 1 to &quot;x&quot; and reduce &quot;width&quot; by 1.
749          */
750         if ((desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HRGB ||
751              desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HBGR)
752             &amp;&amp; topLeftX &lt;= -2.0f) {
753             int minx = getGlyphImageMinX(ptr, result.x);
754             if (minx &gt; result.x) {
755                 result.x += 1;
756                 result.width -=1;
757             }
758         }
759     }
760 
761     private int getGlyphImageMinX(long ptr, int origMinX) {
762 
763         int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);
764         int height = StrikeCache.unsafe.getChar(ptr+StrikeCache.heightOffset);
765         int rowBytes =
766             StrikeCache.unsafe.getChar(ptr+StrikeCache.rowBytesOffset);
767 
768         if (rowBytes == width) {
769             return origMinX;
770         }
771 
772         long pixelData =
773             StrikeCache.unsafe.getAddress(ptr + StrikeCache.pixelDataOffset);
774 
775         if (pixelData == 0L) {
776             return origMinX;
777         }
778 
779         for (int y=0;y&lt;height;y++) {
780             for (int x=0;x&lt;3;x++) {
781                 if (StrikeCache.unsafe.getByte(pixelData+y*rowBytes+x) != 0) {
782                     return origMinX;
783                 }
784             }
785         }
786         return origMinX+1;
787     }
788 
789     /* These 3 metrics methods below should be implemented to return
790      * values in user space.
791      */
792     StrikeMetrics getFontMetrics() {
793         if (strikeMetrics == null) {
794             strikeMetrics =
795                 fileFont.getFontMetrics(pScalerContext);
796             if (invertDevTx != null) {
797                 strikeMetrics.convertToUserSpace(invertDevTx);
798             }
799         }
800         return strikeMetrics;
801     }
802 
803     Point2D.Float getGlyphMetrics(int glyphCode) {
804         return getGlyphMetrics(glyphCode, true);
805     }
806 
807     private Point2D.Float getGlyphMetrics(int glyphCode, boolean getImage) {
808         Point2D.Float metrics = new Point2D.Float();
809 
810         // !!! or do we force sgv user glyphs?
811         if (glyphCode &gt;= INVISIBLE_GLYPHS) {
812             return metrics;
813         }
814         long glyphPtr;
815         if (getImageWithAdvance &amp;&amp; getImage) {
816             /* A heuristic optimisation says that for most cases its
817              * worthwhile retrieving the image at the same time as the
818              * metrics. So here we get the image data even if its not
819              * already cached.
820              */
821             glyphPtr = getGlyphImagePtr(glyphCode);
822         } else {
823              glyphPtr = getCachedGlyphPtr(glyphCode);
824         }
825         if (glyphPtr != 0L) {
826             metrics = new Point2D.Float();
827             metrics.x = StrikeCache.unsafe.getFloat
828                 (glyphPtr + StrikeCache.xAdvanceOffset);
829             metrics.y = StrikeCache.unsafe.getFloat
830                 (glyphPtr + StrikeCache.yAdvanceOffset);
831             /* advance is currently in device space, need to convert back
832              * into user space.
833              * This must not include the translation component. */
834             if (invertDevTx != null) {
835                 invertDevTx.deltaTransform(metrics, metrics);
836             }
837         } else {
838             /* We sometimes cache these metrics as they are expensive to
839              * generate for large glyphs.
840              * We never reach this path if we obtain images with advances.
841              * But if we do not obtain images with advances its possible that
842              * we first obtain this information, then the image, and never
843              * will access this value again.
844              */
845             Integer key = Integer.valueOf(glyphCode);
846             Point2D.Float value = null;
847             ConcurrentHashMap&lt;Integer, Point2D.Float&gt; glyphMetricsMap = null;
848             if (glyphMetricsMapRef != null) {
849                 glyphMetricsMap = glyphMetricsMapRef.get();
850             }
851             if (glyphMetricsMap != null) {
852                 value = glyphMetricsMap.get(key);
853                 if (value != null) {
854                     metrics.x = value.x;
855                     metrics.y = value.y;
856                     /* already in user space */
857                     return metrics;
858                 }
859             }
860             if (value == null) {
861                 fileFont.getGlyphMetrics(pScalerContext, glyphCode, metrics);
862                 /* advance is currently in device space, need to convert back
863                  * into user space.
864                  */
865                 if (invertDevTx != null) {
866                     invertDevTx.deltaTransform(metrics, metrics);
867                 }
868                 value = new Point2D.Float(metrics.x, metrics.y);
869                 /* We aren&#39;t synchronizing here so it is possible to
870                  * overwrite the map with another one but this is harmless.
871                  */
872                 if (glyphMetricsMap == null) {
873                     glyphMetricsMap =
874                         new ConcurrentHashMap&lt;Integer, Point2D.Float&gt;();
875                     glyphMetricsMapRef =
876                         new SoftReference&lt;ConcurrentHashMap&lt;Integer,
877                         Point2D.Float&gt;&gt;(glyphMetricsMap);
878                 }
879                 glyphMetricsMap.put(key, value);
880             }
881         }
882         return metrics;
883     }
884 
885     Point2D.Float getCharMetrics(char ch) {
886         return getGlyphMetrics(mapper.charToGlyph(ch));
887     }
888 
889     /* The caller of this can be trusted to return a copy of this
890      * return value rectangle to public API. In fact frequently it
891      * can&#39;t use this return value directly anyway.
892      * This returns bounds in device space. Currently the only
893      * caller is SGV and it converts back to user space.
894      * We could change things so that this code does the conversion so
895      * that all coords coming out of the font system are converted back
896      * into user space even if they were measured in device space.
897      * The same applies to the other methods that return outlines (below)
898      * But it may make particular sense for this method that caches its
899      * results.
900      * There&#39;d be plenty of exceptions, to this too, eg getGlyphPoint needs
901      * device coords as its called from native layout and getGlyphImageBounds
902      * is used by GlyphVector.getGlyphPixelBounds which is specified to
903      * return device coordinates, the image pointers aren&#39;t really used
904      * up in Java code either.
905      */
906     Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {
907 
908         if (boundsMap == null) {
909             boundsMap = new ConcurrentHashMap&lt;Integer, Rectangle2D.Float&gt;();
910         }
911 
912         Integer key = Integer.valueOf(glyphCode);
913         Rectangle2D.Float bounds = boundsMap.get(key);
914 
915         if (bounds == null) {
916             bounds = fileFont.getGlyphOutlineBounds(pScalerContext, glyphCode);
917             boundsMap.put(key, bounds);
918         }
919         return bounds;
920     }
921 
922     public Rectangle2D getOutlineBounds(int glyphCode) {
923         return fileFont.getGlyphOutlineBounds(pScalerContext, glyphCode);
924     }
925 
926     private
927         WeakReference&lt;ConcurrentHashMap&lt;Integer,GeneralPath&gt;&gt; outlineMapRef;
928 
929     GeneralPath getGlyphOutline(int glyphCode, float x, float y) {
930 
931         GeneralPath gp = null;
932         ConcurrentHashMap&lt;Integer, GeneralPath&gt; outlineMap = null;
933 
934         if (outlineMapRef != null) {
935             outlineMap = outlineMapRef.get();
936             if (outlineMap != null) {
937                 gp = outlineMap.get(glyphCode);
938             }
939         }
940 
941         if (gp == null) {
942             gp = fileFont.getGlyphOutline(pScalerContext, glyphCode, 0, 0);
943             if (outlineMap == null) {
944                 outlineMap = new ConcurrentHashMap&lt;Integer, GeneralPath&gt;();
945                 outlineMapRef =
946                    new WeakReference
947                        &lt;ConcurrentHashMap&lt;Integer,GeneralPath&gt;&gt;(outlineMap);
948             }
949             outlineMap.put(glyphCode, gp);
950         }
951         gp = (GeneralPath)gp.clone(); // mutable!
952         if (x != 0f || y != 0f) {
953             gp.transform(AffineTransform.getTranslateInstance(x, y));
954         }
955         return gp;
956     }
957 
958     GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {
959         return fileFont.getGlyphVectorOutline(pScalerContext,
960                                               glyphs, glyphs.length, x, y);
961     }
962 
963     protected void adjustPoint(Point2D.Float pt) {
964         if (invertDevTx != null) {
965             invertDevTx.deltaTransform(pt, pt);
966         }
967     }
968 }
    </pre>
  </body>
</html>
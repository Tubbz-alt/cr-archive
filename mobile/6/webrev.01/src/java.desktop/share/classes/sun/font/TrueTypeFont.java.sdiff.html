<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/TrueTypeFont.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="SunFontManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeGlyphMapper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/TrueTypeFont.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 212         super(platname, nativeNames);
 213         useJavaRasterizer = javaRasterizer;
 214         fontRank = Font2D.TTF_RANK;
 215         try {
 216             verify(useFilePool);
 217             init(fIndex);
 218             if (!useFilePool) {
 219                close();
 220             }
 221         } catch (Throwable t) {
 222             close();
 223             if (t instanceof FontFormatException) {
 224                 throw (FontFormatException)t;
 225             } else {
 226                 throw new FontFormatException(&quot;Unexpected runtime exception.&quot;);
 227             }
 228         }
 229         Disposer.addObjectRecord(this, disposerRecord);
 230     }
 231 
<span class="line-removed"> 232     /* Enable natives just for fonts picked up from the platform that</span>
<span class="line-removed"> 233      * may have external bitmaps on Solaris. Could do this just for</span>
<span class="line-removed"> 234      * the fonts that are specified in font configuration files which</span>
<span class="line-removed"> 235      * would lighten the burden (think about that).</span>
<span class="line-removed"> 236      * The EBLCTag is used to skip natives for fonts that contain embedded</span>
<span class="line-removed"> 237      * bitmaps as there&#39;s no need to use X11 for those fonts.</span>
<span class="line-removed"> 238      * Skip all the latin fonts as they don&#39;t need this treatment.</span>
<span class="line-removed"> 239      * Further refine this to fonts that are natively accessible (ie</span>
<span class="line-removed"> 240      * as PCF bitmap fonts on the X11 font path).</span>
<span class="line-removed"> 241      * This method is called when creating the first strike for this font.</span>
<span class="line-removed"> 242      */</span>
<span class="line-removed"> 243     @Override</span>
<span class="line-removed"> 244     protected boolean checkUseNatives() {</span>
<span class="line-removed"> 245         if (checkedNatives) {</span>
<span class="line-removed"> 246             return useNatives;</span>
<span class="line-removed"> 247         }</span>
<span class="line-removed"> 248         if (!FontUtilities.isSolaris || useJavaRasterizer ||</span>
<span class="line-removed"> 249             FontUtilities.useJDKScaler || nativeNames == null ||</span>
<span class="line-removed"> 250             getDirectoryEntry(EBLCTag) != null ||</span>
<span class="line-removed"> 251             GraphicsEnvironment.isHeadless()) {</span>
<span class="line-removed"> 252             checkedNatives = true;</span>
<span class="line-removed"> 253             return false; /* useNatives is false */</span>
<span class="line-removed"> 254         } else if (nativeNames instanceof String) {</span>
<span class="line-removed"> 255             String name = (String)nativeNames;</span>
<span class="line-removed"> 256             /* Don&#39;t do this for Latin fonts */</span>
<span class="line-removed"> 257             if (name.indexOf(&quot;8859&quot;) &gt; 0) {</span>
<span class="line-removed"> 258                 checkedNatives = true;</span>
<span class="line-removed"> 259                 return false;</span>
<span class="line-removed"> 260             } else if (NativeFont.hasExternalBitmaps(name)) {</span>
<span class="line-removed"> 261                 nativeFonts = new NativeFont[1];</span>
<span class="line-removed"> 262                 try {</span>
<span class="line-removed"> 263                     nativeFonts[0] = new NativeFont(name, true);</span>
<span class="line-removed"> 264                     /* If reach here we have an non-latin font that has</span>
<span class="line-removed"> 265                      * external bitmaps and we successfully created it.</span>
<span class="line-removed"> 266                      */</span>
<span class="line-removed"> 267                     useNatives = true;</span>
<span class="line-removed"> 268                 } catch (FontFormatException e) {</span>
<span class="line-removed"> 269                     nativeFonts = null;</span>
<span class="line-removed"> 270                 }</span>
<span class="line-removed"> 271             }</span>
<span class="line-removed"> 272         } else if (nativeNames instanceof String[]) {</span>
<span class="line-removed"> 273             String[] natNames = (String[])nativeNames;</span>
<span class="line-removed"> 274             int numNames = natNames.length;</span>
<span class="line-removed"> 275             boolean externalBitmaps = false;</span>
<span class="line-removed"> 276             for (int nn = 0; nn &lt; numNames; nn++) {</span>
<span class="line-removed"> 277                 if (natNames[nn].indexOf(&quot;8859&quot;) &gt; 0) {</span>
<span class="line-removed"> 278                     checkedNatives = true;</span>
<span class="line-removed"> 279                     return false;</span>
<span class="line-removed"> 280                 } else if (NativeFont.hasExternalBitmaps(natNames[nn])) {</span>
<span class="line-removed"> 281                     externalBitmaps = true;</span>
<span class="line-removed"> 282                 }</span>
<span class="line-removed"> 283             }</span>
<span class="line-removed"> 284             if (!externalBitmaps) {</span>
<span class="line-removed"> 285                 checkedNatives = true;</span>
<span class="line-removed"> 286                 return false;</span>
<span class="line-removed"> 287             }</span>
<span class="line-removed"> 288             useNatives = true;</span>
<span class="line-removed"> 289             nativeFonts = new NativeFont[numNames];</span>
<span class="line-removed"> 290             for (int nn = 0; nn &lt; numNames; nn++) {</span>
<span class="line-removed"> 291                 try {</span>
<span class="line-removed"> 292                     nativeFonts[nn] = new NativeFont(natNames[nn], true);</span>
<span class="line-removed"> 293                 } catch (FontFormatException e) {</span>
<span class="line-removed"> 294                     useNatives = false;</span>
<span class="line-removed"> 295                     nativeFonts = null;</span>
<span class="line-removed"> 296                 }</span>
<span class="line-removed"> 297             }</span>
<span class="line-removed"> 298         }</span>
<span class="line-removed"> 299         if (useNatives) {</span>
<span class="line-removed"> 300             glyphToCharMap = new char[getMapper().getNumGlyphs()];</span>
<span class="line-removed"> 301         }</span>
<span class="line-removed"> 302         checkedNatives = true;</span>
<span class="line-removed"> 303         return useNatives;</span>
<span class="line-removed"> 304     }</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306 </span>
 307     private synchronized FileChannel open() throws FontFormatException {
 308         return open(true);
<span class="line-modified"> 309      }</span>
 310 
 311     /* This is intended to be called, and the returned value used,
 312      * from within a block synchronized on this font object.
 313      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 314      * unless the caller holds a lock.
 315      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 316      * which means nested locks may be in effect.
 317      */
 318     private synchronized FileChannel open(boolean usePool)
 319                                      throws FontFormatException {
 320         if (disposerRecord.channel == null) {
 321             if (FontUtilities.isLogging()) {
 322                 FontUtilities.getLogger().info(&quot;open TTF: &quot; + platName);
 323             }
 324             try {
 325                 RandomAccessFile raf = AccessController.doPrivileged(
 326                     new PrivilegedExceptionAction&lt;RandomAccessFile&gt;() {
 327                         public RandomAccessFile run() throws FileNotFoundException {
 328                             return new RandomAccessFile(platName, &quot;r&quot;);
 329                     }
</pre>
<hr />
<pre>
1029         int italic  = fsSelection &amp; fsSelectionItalicBit;
1030         int bold    = fsSelection &amp; fsSelectionBoldBit;
1031         int regular = fsSelection &amp; fsSelectionRegularBit;
1032 //      System.out.println(&quot;platname=&quot;+platName+&quot; font=&quot;+fullName+
1033 //                         &quot; family=&quot;+familyName+
1034 //                         &quot; R=&quot;+regular+&quot; I=&quot;+italic+&quot; B=&quot;+bold);
1035         if (regular!=0 &amp;&amp; ((italic|bold)!=0)) {
1036             /* This is inconsistent. Try using the font name algorithm */
1037             super.setStyle();
1038             return;
1039         } else if ((regular|italic|bold) == 0) {
1040             /* No style specified. Try using the font name algorithm */
1041             super.setStyle();
1042             return;
1043         }
1044         switch (bold|italic) {
1045         case fsSelectionItalicBit:
1046             style = Font.ITALIC;
1047             break;
1048         case fsSelectionBoldBit:
<span class="line-modified">1049             if (FontUtilities.isSolaris &amp;&amp; platName.endsWith(&quot;HG-GothicB.ttf&quot;)) {</span>
<span class="line-removed">1050                 /* Workaround for Solaris&#39;s use of a JA font that&#39;s marked as</span>
<span class="line-removed">1051                  * being designed bold, but is used as a PLAIN font.</span>
<span class="line-removed">1052                  */</span>
<span class="line-removed">1053                 style = Font.PLAIN;</span>
<span class="line-removed">1054             } else {</span>
<span class="line-removed">1055                 style = Font.BOLD;</span>
<span class="line-removed">1056             }</span>
1057             break;
1058         case fsSelectionBoldBit|fsSelectionItalicBit:
1059             style = Font.BOLD|Font.ITALIC;
1060         }
1061     }
1062 
1063     private float stSize, stPos, ulSize, ulPos;
1064 
1065     private void setStrikethroughMetrics(ByteBuffer os_2Table, int upem) {
1066         if (os_2Table == null || os_2Table.capacity() &lt; 30 || upem &lt; 0) {
1067             stSize = .05f;
1068             stPos = -.4f;
1069             return;
1070         }
1071         ShortBuffer sb = os_2Table.asShortBuffer();
1072         stSize = sb.get(13) / (float)upem;
1073         stPos = -sb.get(14) / (float)upem;
1074     }
1075 
1076     private void setUnderlineMetrics(ByteBuffer postTable, int upem) {
</pre>
</td>
<td>
<hr />
<pre>
 212         super(platname, nativeNames);
 213         useJavaRasterizer = javaRasterizer;
 214         fontRank = Font2D.TTF_RANK;
 215         try {
 216             verify(useFilePool);
 217             init(fIndex);
 218             if (!useFilePool) {
 219                close();
 220             }
 221         } catch (Throwable t) {
 222             close();
 223             if (t instanceof FontFormatException) {
 224                 throw (FontFormatException)t;
 225             } else {
 226                 throw new FontFormatException(&quot;Unexpected runtime exception.&quot;);
 227             }
 228         }
 229         Disposer.addObjectRecord(this, disposerRecord);
 230     }
 231 











































































 232     private synchronized FileChannel open() throws FontFormatException {
 233         return open(true);
<span class="line-modified"> 234     }</span>
 235 
 236     /* This is intended to be called, and the returned value used,
 237      * from within a block synchronized on this font object.
 238      * ie the channel returned may be nulled out at any time by &quot;close()&quot;
 239      * unless the caller holds a lock.
 240      * Deadlock warning: FontManager.addToPool(..) acquires a global lock,
 241      * which means nested locks may be in effect.
 242      */
 243     private synchronized FileChannel open(boolean usePool)
 244                                      throws FontFormatException {
 245         if (disposerRecord.channel == null) {
 246             if (FontUtilities.isLogging()) {
 247                 FontUtilities.getLogger().info(&quot;open TTF: &quot; + platName);
 248             }
 249             try {
 250                 RandomAccessFile raf = AccessController.doPrivileged(
 251                     new PrivilegedExceptionAction&lt;RandomAccessFile&gt;() {
 252                         public RandomAccessFile run() throws FileNotFoundException {
 253                             return new RandomAccessFile(platName, &quot;r&quot;);
 254                     }
</pre>
<hr />
<pre>
 954         int italic  = fsSelection &amp; fsSelectionItalicBit;
 955         int bold    = fsSelection &amp; fsSelectionBoldBit;
 956         int regular = fsSelection &amp; fsSelectionRegularBit;
 957 //      System.out.println(&quot;platname=&quot;+platName+&quot; font=&quot;+fullName+
 958 //                         &quot; family=&quot;+familyName+
 959 //                         &quot; R=&quot;+regular+&quot; I=&quot;+italic+&quot; B=&quot;+bold);
 960         if (regular!=0 &amp;&amp; ((italic|bold)!=0)) {
 961             /* This is inconsistent. Try using the font name algorithm */
 962             super.setStyle();
 963             return;
 964         } else if ((regular|italic|bold) == 0) {
 965             /* No style specified. Try using the font name algorithm */
 966             super.setStyle();
 967             return;
 968         }
 969         switch (bold|italic) {
 970         case fsSelectionItalicBit:
 971             style = Font.ITALIC;
 972             break;
 973         case fsSelectionBoldBit:
<span class="line-modified"> 974             style = Font.BOLD;</span>







 975             break;
 976         case fsSelectionBoldBit|fsSelectionItalicBit:
 977             style = Font.BOLD|Font.ITALIC;
 978         }
 979     }
 980 
 981     private float stSize, stPos, ulSize, ulPos;
 982 
 983     private void setStrikethroughMetrics(ByteBuffer os_2Table, int upem) {
 984         if (os_2Table == null || os_2Table.capacity() &lt; 30 || upem &lt; 0) {
 985             stSize = .05f;
 986             stPos = -.4f;
 987             return;
 988         }
 989         ShortBuffer sb = os_2Table.asShortBuffer();
 990         stSize = sb.get(13) / (float)upem;
 991         stPos = -sb.get(14) / (float)upem;
 992     }
 993 
 994     private void setUnderlineMetrics(ByteBuffer postTable, int upem) {
</pre>
</td>
</tr>
</table>
<center><a href="SunFontManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeGlyphMapper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_ImageConv_8ext.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_ImageConv_32nw.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_8nw.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_ImageConv_8ext.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147 /***************************************************************/
 148 typedef union {
 149   mlib_d64 d64;
 150   struct {
 151     mlib_s32 i0;
 152     mlib_s32 i1;
 153   } i32s;
 154 } d64_2x32;
 155 
 156 /***************************************************************/
 157 #define GET_SRC_DST_PARAMETERS(type)                            \
 158   hgt = mlib_ImageGetHeight(src);                               \
 159   wid = mlib_ImageGetWidth(src);                                \
 160   nchannel = mlib_ImageGetChannels(src);                        \
 161   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 162   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 163   adr_src = (type *)mlib_ImageGetData(src);                     \
 164   adr_dst = (type *)mlib_ImageGetData(dst)
 165 
 166 /***************************************************************/
<span class="line-removed"> 167 #ifndef __sparc</span>
 168 #if IMG_TYPE == 1
 169 
 170 /*
 171  * Test for the presence of any &quot;1&quot; bit in bits
 172    8 to 31 of val. If present, then val is either
 173    negative or &gt;255. If over/underflows of 8 bits
 174    are uncommon, then this technique can be a win,
 175    since only a single test, rather than two, is
 176    necessary to determine if clamping is needed.
 177    On the other hand, if over/underflows are common,
 178    it adds an extra test.
 179 */
 180 #define CLAMP_STORE(dst, val)                                   \
 181   if (val &amp; 0xffffff00) {                                       \
 182     if (val &lt; MLIB_U8_MIN)                                      \
 183       dst = MLIB_U8_MIN;                                        \
 184     else                                                        \
 185       dst = MLIB_U8_MAX;                                        \
 186   } else {                                                      \
 187     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 191 
 192 #define CLAMP_STORE(dst, val)                                   \
 193   if (val &gt;= MLIB_S16_MAX)                                      \
 194     dst = MLIB_S16_MAX;                                         \
 195   else if (val &lt;= MLIB_S16_MIN)                                 \
 196     dst = MLIB_S16_MIN;                                         \
 197   else                                                          \
 198     dst = (mlib_s16)val
 199 
 200 #elif IMG_TYPE == 3
 201 
 202 #define CLAMP_STORE(dst, val)                                   \
 203   if (val &gt;= MLIB_U16_MAX)                                      \
 204     dst = MLIB_U16_MAX;                                         \
 205   else if (val &lt;= MLIB_U16_MIN)                                 \
 206     dst = MLIB_U16_MIN;                                         \
 207   else                                                          \
 208     dst = (mlib_u16)val
 209 
 210 #endif /* IMG_TYPE == 1 */
<span class="line-removed"> 211 #endif /* __sparc */</span>
 212 
 213 /***************************************************************/
 214 #define MAX_KER   7
 215 #define MAX_N    15
 216 #define BUFF_SIZE   1600
 217 #define CACHE_SIZE  (64*1024)
 218 
 219 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 220                                          const mlib_image *src,
 221                                          const mlib_d64   *k,
 222                                          mlib_s32         n,
 223                                          mlib_s32         dy_t,
 224                                          mlib_s32         dy_b,
 225                                          mlib_s32         cmask)
 226 {
 227   DTYPE    *adr_src, *sl;
 228   DTYPE    *adr_dst, *dl, *dp;
 229   FTYPE    buff[BUFF_SIZE];
 230   FTYPE    *buffd;
 231   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 259 
 260   sbuff = pbuff;
 261   buffd = sbuff + smax_hsize;
 262 
 263   shgt -= (dy_t + dy_b);
 264   k_off = 0;
 265 
 266   for (l = 0; l &lt; hgt; l += hsize) {
 267     hsize = hgt - l;
 268 
 269     if (hsize &gt; max_hsize) hsize = max_hsize;
 270 
 271     smax_hsize = hsize + (n - 1);
 272 
 273     for (c = 0; c &lt; nchannel; c++) {
 274       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 275 
 276       sl = adr_src + c;
 277       dl = adr_dst + c;
 278 
<span class="line-removed"> 279 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 280 #pragma pipeloop(0)</span>
<span class="line-removed"> 281 #endif /* __SUNPRO_C */</span>
 282       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 283 
 284       for (j = 0; j &lt; wid; j++) {
 285         FTYPE    *buff = sbuff;
 286 
 287         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 288           sbuff[i - k_off] = (FTYPE)sl[0];
 289         }
 290 
<span class="line-removed"> 291 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 292 #pragma pipeloop(0)</span>
<span class="line-removed"> 293 #endif /* __SUNPRO_C */</span>
 294         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 295           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 296         }
 297 
 298         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 299           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 300         }
 301 
 302         pk = k;
 303 
 304         for (off = 0; off &lt; (n - 4); off += 4) {
 305 
 306           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 307           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 308 
<span class="line-removed"> 309 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 310 #pragma pipeloop(0)</span>
<span class="line-removed"> 311 #endif /* __SUNPRO_C */</span>
 312           for (i = 0; i &lt; hsize; i += 2) {
 313             p0 = p2; p1 = p3; p2 = p4;
 314 
 315             p3 = buff[i + 3]; p4 = buff[i + 4];
 316 
 317             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 318             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 319           }
 320 
 321           pk += 4;
 322           buff += 4;
 323         }
 324 
 325         dp = dl;
 326         kh = n - off;
 327 
 328         if (kh == 4) {
 329           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 330           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 331 
<span class="line-removed"> 332 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 333 #pragma pipeloop(0)</span>
<span class="line-removed"> 334 #endif /* __SUNPRO_C */</span>
 335           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 336             p0 = p2; p1 = p3; p2 = p4;
 337 
 338             p3 = buff[i + 3]; p4 = buff[i + 4];
 339 
 340             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 341             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 342 
 343             dp[0  ] = FROM_S32(d0);
 344             dp[dll] = FROM_S32(d1);
 345 
 346             buffd[i    ] = 0.0;
 347             buffd[i + 1] = 0.0;
 348 
 349             dp += 2*dll;
 350           }
 351 
 352           if (i &lt; hsize) {
 353             p0 = p2; p1 = p3; p2 = p4;
 354             p3 = buff[i + 3];
 355             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 356             dp[0] = FROM_S32(d0);
 357             buffd[i] = 0.0;
 358           }
 359 
 360         } else if (kh == 3) {
 361 
 362           p2 = buff[0]; p3 = buff[1];
 363           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 364 
<span class="line-removed"> 365 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 366 #pragma pipeloop(0)</span>
<span class="line-removed"> 367 #endif /* __SUNPRO_C */</span>
 368           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 369             p0 = p2; p1 = p3;
 370 
 371             p2 = buff[i + 2]; p3 = buff[i + 3];
 372 
 373             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 374             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 375 
 376             dp[0  ] = FROM_S32(d0);
 377             dp[dll] = FROM_S32(d1);
 378 
 379             buffd[i    ] = 0.0;
 380             buffd[i + 1] = 0.0;
 381 
 382             dp += 2*dll;
 383           }
 384 
 385           if (i &lt; hsize) {
 386             p0 = p2; p1 = p3;
 387             p2 = buff[i + 2];
 388             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 389             dp[0] = FROM_S32(d0);
 390 
 391             buffd[i] = 0.0;
 392           }
 393 
 394         } else if (kh == 2) {
 395 
 396           p2 = buff[0];
 397           k0 = pk[0]; k1 = pk[1];
 398 
<span class="line-removed"> 399 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 400 #pragma pipeloop(0)</span>
<span class="line-removed"> 401 #endif /* __SUNPRO_C */</span>
 402           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 403             p0 = p2;
 404 
 405             p1 = buff[i + 1]; p2 = buff[i + 2];
 406 
 407             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 408             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 409 
 410             dp[0  ] = FROM_S32(d0);
 411             dp[dll] = FROM_S32(d1);
 412 
 413             buffd[i    ] = 0.0;
 414             buffd[i + 1] = 0.0;
 415 
 416             dp += 2*dll;
 417           }
 418 
 419           if (i &lt; hsize) {
 420             p0 = p2;
 421             p1 = buff[i + 1];
 422             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 423             dp[0] = FROM_S32(d0);
 424 
 425             buffd[i] = 0.0;
 426           }
 427 
 428         } else /* kh == 1 */{
 429 
 430           k0 = pk[0];
 431 
<span class="line-removed"> 432 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 433 #pragma pipeloop(0)</span>
<span class="line-removed"> 434 #endif /* __SUNPRO_C */</span>
 435           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 436             p0 = buff[i]; p1 = buff[i + 1];
 437 
 438             d0 = D2I(p0*k0 + buffd[i    ]);
 439             d1 = D2I(p1*k0 + buffd[i + 1]);
 440 
 441             dp[0  ] = FROM_S32(d0);
 442             dp[dll] = FROM_S32(d1);
 443 
 444             buffd[i    ] = 0.0;
 445             buffd[i + 1] = 0.0;
 446 
 447             dp += 2*dll;
 448           }
 449 
 450           if (i &lt; hsize) {
 451             p0 = buff[i];
 452             d0 = D2I(p0*k0 + buffd[i]);
 453             dp[0] = FROM_S32(d0);
 454 
</pre>
<hr />
<pre>
 537   buffi = (mlib_s32*)(buffd + swid);
 538 
 539   chan1 = nchannel;
 540   chan2 = chan1 + chan1;
 541 
 542   swid -= (dx_l + dx_r);
 543 
 544   for (c = 0; c &lt; nchannel; c++) {
 545     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 546 
 547     sl = adr_src + c;
 548     dl = adr_dst + c;
 549 
 550     for (l = 0; l &lt; n; l++) {
 551       FTYPE    *buff = buffs[l];
 552 
 553       for (i = 0; i &lt; dx_l; i++) {
 554         buff[i] = (FTYPE)sl[0];
 555       }
 556 
<span class="line-removed"> 557 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 558 #pragma pipeloop(0)</span>
<span class="line-removed"> 559 #endif /* __SUNPRO_C */</span>
 560       for (i = 0; i &lt; swid; i++) {
 561         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 562       }
 563 
 564       for (i = 0; i &lt; dx_r; i++) {
 565         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 566       }
 567 
 568       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 569     }
 570 
 571     buff_ind = 0;
 572 
<span class="line-removed"> 573 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 574 #pragma pipeloop(0)</span>
<span class="line-removed"> 575 #endif /* __SUNPRO_C */</span>
 576     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 577 
 578     for (j = 0; j &lt; hgt; j++) {
 579       FTYPE    **buffc = buffs + buff_ind;
 580       FTYPE    *buffn = buffc[n];
 581       FTYPE    *pk = k;
 582 
 583       for (l = 0; l &lt; n; l++) {
 584         FTYPE    *buff_l = buffc[l];
 585 
 586         for (off = 0; off &lt; m;) {
 587           FTYPE    *buff = buff_l + off;
 588 
 589           kw = m - off;
 590 
 591           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 592             if (kw &gt; MAX_KER) kw = kw/2;
 593           off += kw;
 594 
 595           sp = sl;
 596           dp = dl;
 597 
 598           if (kw == 7) {
 599 
 600             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 601             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 602 
 603             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 604             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 605 
 606             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 607 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 608 #pragma pipeloop(0)</span>
<span class="line-removed"> 609 #endif /* __SUNPRO_C */</span>
 610               for (i = 0; i &lt;= (wid - 2); i += 2) {
 611                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 612 
 613                 p6 = buff[i + 6]; p7 = buff[i + 7];
 614 
 615                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 616                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 617               }
 618 
 619             } else {
<span class="line-removed"> 620 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 621 #pragma pipeloop(0)</span>
<span class="line-removed"> 622 #endif /* __SUNPRO_C */</span>
 623               for (i = 0; i &lt;= (wid - 2); i += 2) {
 624                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 625 
 626                 p6 = buff[i + 6]; p7 = buff[i + 7];
 627 
 628                 LOAD_BUFF(buffi);
 629 
 630                 dd.d64 = *(FTYPE   *)(buffi + i);
 631                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 632                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 633 
 634                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 635                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 636 
 637                 dp[0    ] = FROM_S32(d0);
 638                 dp[chan1] = FROM_S32(d1);
 639 
 640                 buffd[i    ] = 0.0;
 641                 buffd[i + 1] = 0.0;
 642 
 643                 sp += chan2;
 644                 dp += chan2;
 645               }
 646             }
 647 
 648           } else if (kw == 6) {
 649 
 650             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 651             p5 = buff[3]; p6 = buff[4];
 652 
 653             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 654             k4 = pk[4]; k5 = pk[5];
 655 
 656             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 657 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 658 #pragma pipeloop(0)</span>
<span class="line-removed"> 659 #endif /* __SUNPRO_C */</span>
 660               for (i = 0; i &lt;= (wid - 2); i += 2) {
 661                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 662 
 663                 p5 = buff[i + 5]; p6 = buff[i + 6];
 664 
 665                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 666                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 667               }
 668 
 669             } else {
<span class="line-removed"> 670 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 671 #pragma pipeloop(0)</span>
<span class="line-removed"> 672 #endif /* __SUNPRO_C */</span>
 673               for (i = 0; i &lt;= (wid - 2); i += 2) {
 674                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 675 
 676                 p5 = buff[i + 5]; p6 = buff[i + 6];
 677 
 678                 LOAD_BUFF(buffi);
 679 
 680                 dd.d64 = *(FTYPE   *)(buffi + i);
 681                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 682                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 683 
 684                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 685                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 686 
 687                 dp[0    ] = FROM_S32(d0);
 688                 dp[chan1] = FROM_S32(d1);
 689 
 690                 buffd[i    ] = 0.0;
 691                 buffd[i + 1] = 0.0;
 692 
 693                 sp += chan2;
 694                 dp += chan2;
 695               }
 696             }
 697 
 698           } else if (kw == 5) {
 699 
 700             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 701             p5 = buff[3];
 702 
 703             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 704             k4 = pk[4];
 705 
 706             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 707 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 708 #pragma pipeloop(0)</span>
<span class="line-removed"> 709 #endif /* __SUNPRO_C */</span>
 710               for (i = 0; i &lt;= (wid - 2); i += 2) {
 711                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 712 
 713                 p4 = buff[i + 4]; p5 = buff[i + 5];
 714 
 715                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 716                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 717               }
 718 
 719             } else {
<span class="line-removed"> 720 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 721 #pragma pipeloop(0)</span>
<span class="line-removed"> 722 #endif /* __SUNPRO_C */</span>
 723               for (i = 0; i &lt;= (wid - 2); i += 2) {
 724                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 725 
 726                 p4 = buff[i + 4]; p5 = buff[i + 5];
 727 
 728                 LOAD_BUFF(buffi);
 729 
 730                 dd.d64 = *(FTYPE   *)(buffi + i);
 731                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 732                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 733 
 734                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 735                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 736 
 737                 dp[0    ] = FROM_S32(d0);
 738                 dp[chan1] = FROM_S32(d1);
 739 
 740                 buffd[i    ] = 0.0;
 741                 buffd[i + 1] = 0.0;
 742 
 743                 sp += chan2;
 744                 dp += chan2;
 745               }
 746             }
 747 
 748           } else if (kw == 4) {
 749 
 750             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 751 
 752             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 753 
 754             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 755 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 756 #pragma pipeloop(0)</span>
<span class="line-removed"> 757 #endif /* __SUNPRO_C */</span>
 758               for (i = 0; i &lt;= (wid - 2); i += 2) {
 759                 p0 = p2; p1 = p3; p2 = p4;
 760 
 761                 p3 = buff[i + 3]; p4 = buff[i + 4];
 762 
 763                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 764                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 765               }
 766 
 767             } else {
<span class="line-removed"> 768 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 769 #pragma pipeloop(0)</span>
<span class="line-removed"> 770 #endif /* __SUNPRO_C */</span>
 771               for (i = 0; i &lt;= (wid - 2); i += 2) {
 772                 p0 = p2; p1 = p3; p2 = p4;
 773 
 774                 p3 = buff[i + 3]; p4 = buff[i + 4];
 775 
 776                 LOAD_BUFF(buffi);
 777 
 778                 dd.d64 = *(FTYPE   *)(buffi + i);
 779                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 780                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 781 
 782                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 783                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 784 
 785                 dp[0    ] = FROM_S32(d0);
 786                 dp[chan1] = FROM_S32(d1);
 787 
 788                 buffd[i    ] = 0.0;
 789                 buffd[i + 1] = 0.0;
 790 
 791                 sp += chan2;
 792                 dp += chan2;
 793               }
 794             }
 795 
 796           } else if (kw == 3) {
 797 
 798             p2 = buff[0]; p3 = buff[1];
 799             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 800 
 801             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 802 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 803 #pragma pipeloop(0)</span>
<span class="line-removed"> 804 #endif /* __SUNPRO_C */</span>
 805               for (i = 0; i &lt;= (wid - 2); i += 2) {
 806                 p0 = p2; p1 = p3;
 807 
 808                 p2 = buff[i + 2]; p3 = buff[i + 3];
 809 
 810                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 811                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 812               }
 813 
 814             } else {
<span class="line-removed"> 815 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 816 #pragma pipeloop(0)</span>
<span class="line-removed"> 817 #endif /* __SUNPRO_C */</span>
 818               for (i = 0; i &lt;= (wid - 2); i += 2) {
 819                 p0 = p2; p1 = p3;
 820 
 821                 p2 = buff[i + 2]; p3 = buff[i + 3];
 822 
 823                 LOAD_BUFF(buffi);
 824 
 825                 dd.d64 = *(FTYPE   *)(buffi + i);
 826                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 827                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 828 
 829                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 830                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 831 
 832                 dp[0    ] = FROM_S32(d0);
 833                 dp[chan1] = FROM_S32(d1);
 834 
 835                 buffd[i    ] = 0.0;
 836                 buffd[i + 1] = 0.0;
 837 
 838                 sp += chan2;
 839                 dp += chan2;
 840               }
 841             }
 842 
 843           } else /* if (kw == 2) */ {
 844 
 845             p2 = buff[0];
 846             k0 = pk[0]; k1 = pk[1];
 847 
 848             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 849 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 850 #pragma pipeloop(0)</span>
<span class="line-removed"> 851 #endif /* __SUNPRO_C */</span>
 852               for (i = 0; i &lt;= (wid - 2); i += 2) {
 853                 p0 = p2;
 854 
 855                 p1 = buff[i + 1]; p2 = buff[i + 2];
 856 
 857                 buffd[i    ] += p0*k0 + p1*k1;
 858                 buffd[i + 1] += p1*k0 + p2*k1;
 859               }
 860 
 861             } else {
<span class="line-removed"> 862 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 863 #pragma pipeloop(0)</span>
<span class="line-removed"> 864 #endif /* __SUNPRO_C */</span>
 865               for (i = 0; i &lt;= (wid - 2); i += 2) {
 866                 p0 = p2;
 867 
 868                 p1 = buff[i + 1]; p2 = buff[i + 2];
 869 
 870                 LOAD_BUFF(buffi);
 871 
 872                 dd.d64 = *(FTYPE   *)(buffi + i);
 873                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 874                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 875 
 876                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 877                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 878 
 879                 dp[0    ] = FROM_S32(d0);
 880                 dp[chan1] = FROM_S32(d1);
 881 
 882                 buffd[i    ] = 0.0;
 883                 buffd[i + 1] = 0.0;
 884 
</pre>
<hr />
<pre>
 918       }
 919 
 920       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 921       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 922 
 923       /* next line */
 924 
 925       if (j &lt; hgt - dy_b - 2) sl += sll;
 926       dl += dll;
 927 
 928       buff_ind++;
 929 
 930       if (buff_ind &gt;= n + 1) buff_ind = 0;
 931     }
 932   }
 933 
 934   FREE_AND_RETURN_STATUS;
 935 }
 936 
 937 /***************************************************************/
<span class="line-modified"> 938 #ifndef __sparc /* for x86, using integer multiplies is faster */</span>
 939 
 940 #define STORE_RES(res, x)                                       \
 941   x &gt;&gt;= shift2;                                                 \
 942   CLAMP_STORE(res, x)
 943 
 944 mlib_status CONV_FUNC_MxN_I
 945 {
 946   DTYPE    *adr_src, *sl, *sp = NULL;
 947   DTYPE    *adr_dst, *dl, *dp = NULL;
 948   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 949   mlib_s32 *pbuff = buff;
 950   mlib_s32 **buffs = buffs_arr, *buffd;
 951   mlib_s32 l, off, kw, bsize, buff_ind;
 952   mlib_s32 d0, d1, shift1, shift2;
 953   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 954   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 955   mlib_s32 wid, hgt, sll, dll;
 956   mlib_s32 nchannel, chan1;
 957   mlib_s32 i, j, c, swid;
 958   mlib_s32 chan2;
</pre>
<hr />
<pre>
 995 
 996   for (i = 0; i &lt; m*n; i++) {
 997     k[i] = kernel[i] &gt;&gt; shift1;
 998   }
 999 
1000   swid -= (dx_l + dx_r);
1001 
1002   for (c = 0; c &lt; nchannel; c++) {
1003     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
1004 
1005     sl = adr_src + c;
1006     dl = adr_dst + c;
1007 
1008     for (l = 0; l &lt; n; l++) {
1009       mlib_s32  *buff = buffs[l];
1010 
1011       for (i = 0; i &lt; dx_l; i++) {
1012         buff[i] = (mlib_s32)sl[0];
1013       }
1014 
<span class="line-removed">1015 #ifdef __SUNPRO_C</span>
<span class="line-removed">1016 #pragma pipeloop(0)</span>
<span class="line-removed">1017 #endif /* __SUNPRO_C */</span>
1018       for (i = 0; i &lt; swid; i++) {
1019         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
1020       }
1021 
1022       for (i = 0; i &lt; dx_r; i++) {
1023         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
1024       }
1025 
1026       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
1027     }
1028 
1029     buff_ind = 0;
1030 
<span class="line-removed">1031 #ifdef __SUNPRO_C</span>
<span class="line-removed">1032 #pragma pipeloop(0)</span>
<span class="line-removed">1033 #endif /* __SUNPRO_C */</span>
1034     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
1035 
1036     for (j = 0; j &lt; hgt; j++) {
1037       mlib_s32 **buffc = buffs + buff_ind;
1038       mlib_s32 *buffn = buffc[n];
1039       mlib_s32 *pk = k;
1040 
1041       for (l = 0; l &lt; n; l++) {
1042         mlib_s32  *buff_l = buffc[l];
1043 
1044         for (off = 0; off &lt; m;) {
1045           mlib_s32 *buff = buff_l + off;
1046 
1047           sp = sl;
1048           dp = dl;
1049 
1050           kw = m - off;
1051 
1052           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
1053             if (kw &gt; MAX_KER) kw = kw/2;
1054           off += kw;
1055 
1056           if (kw == 7) {
1057 
1058             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1059             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
1060 
1061             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1062             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
1063 
1064             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1065 #ifdef __SUNPRO_C</span>
<span class="line-removed">1066 #pragma pipeloop(0)</span>
<span class="line-removed">1067 #endif /* __SUNPRO_C */</span>
1068               for (i = 0; i &lt;= (wid - 2); i += 2) {
1069                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1070 
1071                 p6 = buff[i + 6]; p7 = buff[i + 7];
1072 
1073                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1074                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1075               }
1076 
1077             } else {
<span class="line-removed">1078 #ifdef __SUNPRO_C</span>
<span class="line-removed">1079 #pragma pipeloop(0)</span>
<span class="line-removed">1080 #endif /* __SUNPRO_C */</span>
1081               for (i = 0; i &lt;= (wid - 2); i += 2) {
1082                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1083 
1084                 p6 = buff[i + 6]; p7 = buff[i + 7];
1085 
1086                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1087                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1088 
1089                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1090                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1091 
1092                 STORE_RES(dp[0    ], d0);
1093                 STORE_RES(dp[chan1], d1);
1094 
1095                 buffd[i    ] = 0;
1096                 buffd[i + 1] = 0;
1097 
1098                 sp += chan2;
1099                 dp += chan2;
1100               }
1101             }
1102 
1103           } else if (kw == 6) {
1104 
1105             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1106             p5 = buff[3]; p6 = buff[4];
1107 
1108             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1109             k4 = pk[4]; k5 = pk[5];
1110 
1111             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1112 #ifdef __SUNPRO_C</span>
<span class="line-removed">1113 #pragma pipeloop(0)</span>
<span class="line-removed">1114 #endif /* __SUNPRO_C */</span>
1115               for (i = 0; i &lt;= (wid - 2); i += 2) {
1116                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1117 
1118                 p5 = buff[i + 5]; p6 = buff[i + 6];
1119 
1120                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1121                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1122               }
1123 
1124             } else {
<span class="line-removed">1125 #ifdef __SUNPRO_C</span>
<span class="line-removed">1126 #pragma pipeloop(0)</span>
<span class="line-removed">1127 #endif /* __SUNPRO_C */</span>
1128               for (i = 0; i &lt;= (wid - 2); i += 2) {
1129                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1130 
1131                 p5 = buff[i + 5]; p6 = buff[i + 6];
1132 
1133                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1134                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1135 
1136                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1137                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1138 
1139                 STORE_RES(dp[0    ], d0);
1140                 STORE_RES(dp[chan1], d1);
1141 
1142                 buffd[i    ] = 0;
1143                 buffd[i + 1] = 0;
1144 
1145                 sp += chan2;
1146                 dp += chan2;
1147               }
1148             }
1149 
1150           } else if (kw == 5) {
1151 
1152             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1153             p5 = buff[3];
1154 
1155             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1156             k4 = pk[4];
1157 
1158             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1159 #ifdef __SUNPRO_C</span>
<span class="line-removed">1160 #pragma pipeloop(0)</span>
<span class="line-removed">1161 #endif /* __SUNPRO_C */</span>
1162               for (i = 0; i &lt;= (wid - 2); i += 2) {
1163                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1164 
1165                 p4 = buff[i + 4]; p5 = buff[i + 5];
1166 
1167                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1168                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1169               }
1170 
1171             } else {
<span class="line-removed">1172 #ifdef __SUNPRO_C</span>
<span class="line-removed">1173 #pragma pipeloop(0)</span>
<span class="line-removed">1174 #endif /* __SUNPRO_C */</span>
1175               for (i = 0; i &lt;= (wid - 2); i += 2) {
1176                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1177 
1178                 p4 = buff[i + 4]; p5 = buff[i + 5];
1179 
1180                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1181                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1182 
1183                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1184                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1185 
1186                 STORE_RES(dp[0    ], d0);
1187                 STORE_RES(dp[chan1], d1);
1188 
1189                 buffd[i    ] = 0;
1190                 buffd[i + 1] = 0;
1191 
1192                 sp += chan2;
1193                 dp += chan2;
1194               }
1195             }
1196 
1197           } else if (kw == 4) {
1198 
1199             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1200 
1201             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1202 
1203             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1204 #ifdef __SUNPRO_C</span>
<span class="line-removed">1205 #pragma pipeloop(0)</span>
<span class="line-removed">1206 #endif /* __SUNPRO_C */</span>
1207               for (i = 0; i &lt;= (wid - 2); i += 2) {
1208                 p0 = p2; p1 = p3; p2 = p4;
1209 
1210                 p3 = buff[i + 3]; p4 = buff[i + 4];
1211 
1212                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1213                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1214               }
1215 
1216             } else {
<span class="line-removed">1217 #ifdef __SUNPRO_C</span>
<span class="line-removed">1218 #pragma pipeloop(0)</span>
<span class="line-removed">1219 #endif /* __SUNPRO_C */</span>
1220               for (i = 0; i &lt;= (wid - 2); i += 2) {
1221                 p0 = p2; p1 = p3; p2 = p4;
1222 
1223                 p3 = buff[i + 3]; p4 = buff[i + 4];
1224 
1225                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1226                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1227 
1228                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1229                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1230 
1231                 STORE_RES(dp[0    ], d0);
1232                 STORE_RES(dp[chan1], d1);
1233 
1234                 buffd[i    ] = 0;
1235                 buffd[i + 1] = 0;
1236 
1237                 sp += chan2;
1238                 dp += chan2;
1239               }
1240             }
1241 
1242           } else if (kw == 3) {
1243 
1244             p2 = buff[0]; p3 = buff[1];
1245             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1246 
1247             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1248 #ifdef __SUNPRO_C</span>
<span class="line-removed">1249 #pragma pipeloop(0)</span>
<span class="line-removed">1250 #endif /* __SUNPRO_C */</span>
1251               for (i = 0; i &lt;= (wid - 2); i += 2) {
1252                 p0 = p2; p1 = p3;
1253 
1254                 p2 = buff[i + 2]; p3 = buff[i + 3];
1255 
1256                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1257                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1258               }
1259 
1260             } else {
<span class="line-removed">1261 #ifdef __SUNPRO_C</span>
<span class="line-removed">1262 #pragma pipeloop(0)</span>
<span class="line-removed">1263 #endif /* __SUNPRO_C */</span>
1264               for (i = 0; i &lt;= (wid - 2); i += 2) {
1265                 p0 = p2; p1 = p3;
1266 
1267                 p2 = buff[i + 2]; p3 = buff[i + 3];
1268 
1269                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1270                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1271 
1272                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1273                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1274 
1275                 STORE_RES(dp[0    ], d0);
1276                 STORE_RES(dp[chan1], d1);
1277 
1278                 buffd[i    ] = 0;
1279                 buffd[i + 1] = 0;
1280 
1281                 sp += chan2;
1282                 dp += chan2;
1283               }
1284             }
1285 
1286           } else if (kw == 2) {
1287 
1288             p2 = buff[0];
1289             k0 = pk[0]; k1 = pk[1];
1290 
1291             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1292 #ifdef __SUNPRO_C</span>
<span class="line-removed">1293 #pragma pipeloop(0)</span>
<span class="line-removed">1294 #endif /* __SUNPRO_C */</span>
1295               for (i = 0; i &lt;= (wid - 2); i += 2) {
1296                 p0 = p2;
1297 
1298                 p1 = buff[i + 1]; p2 = buff[i + 2];
1299 
1300                 buffd[i    ] += p0*k0 + p1*k1;
1301                 buffd[i + 1] += p1*k0 + p2*k1;
1302               }
1303 
1304             } else {
<span class="line-removed">1305 #ifdef __SUNPRO_C</span>
<span class="line-removed">1306 #pragma pipeloop(0)</span>
<span class="line-removed">1307 #endif /* __SUNPRO_C */</span>
1308               for (i = 0; i &lt;= (wid - 2); i += 2) {
1309                 p0 = p2;
1310 
1311                 p1 = buff[i + 1]; p2 = buff[i + 2];
1312 
1313                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1314                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1315 
1316                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1317                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1318 
1319                 STORE_RES(dp[0    ], d0);
1320                 STORE_RES(dp[chan1], d1);
1321 
1322                 buffd[i    ] = 0;
1323                 buffd[i + 1] = 0;
1324 
1325                 sp += chan2;
1326                 dp += chan2;
1327               }
1328             }
1329 
1330           } else /* kw == 1 */{
1331 
1332             k0 = pk[0];
1333 
1334             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1335 #ifdef __SUNPRO_C</span>
<span class="line-removed">1336 #pragma pipeloop(0)</span>
<span class="line-removed">1337 #endif /* __SUNPRO_C */</span>
1338               for (i = 0; i &lt;= (wid - 2); i += 2) {
1339                 p0 = buff[i]; p1 = buff[i + 1];
1340 
1341                 buffd[i    ] += p0*k0;
1342                 buffd[i + 1] += p1*k0;
1343               }
1344 
1345             } else {
<span class="line-removed">1346 #ifdef __SUNPRO_C</span>
<span class="line-removed">1347 #pragma pipeloop(0)</span>
<span class="line-removed">1348 #endif /* __SUNPRO_C */</span>
1349               for (i = 0; i &lt;= (wid - 2); i += 2) {
1350                 p0 = buff[i]; p1 = buff[i + 1];
1351 
1352                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1353                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1354 
1355                 d0 = (p0*k0 + buffd[i    ]);
1356                 d1 = (p1*k0 + buffd[i + 1]);
1357 
1358                 STORE_RES(dp[0    ], d0);
1359                 STORE_RES(dp[chan1], d1);
1360 
1361                 buffd[i    ] = 0;
1362                 buffd[i + 1] = 0;
1363 
1364                 sp += chan2;
1365                 dp += chan2;
1366               }
1367             }
1368           }
</pre>
<hr />
<pre>
1397       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1398       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1399 
1400       /* next line */
1401 
1402       if (j &lt; hgt - dy_b - 2) sl += sll;
1403       dl += dll;
1404 
1405       buff_ind++;
1406 
1407       if (buff_ind &gt;= n + 1) buff_ind = 0;
1408     }
1409   }
1410 
1411   if (pbuff != buff) mlib_free(pbuff);
1412   if (k != k_locl) mlib_free(k);
1413 
1414   return MLIB_SUCCESS;
1415 }
1416 
<span class="line-removed">1417 #endif /* __sparc ( for x86, using integer multiplies is faster ) */</span>
<span class="line-removed">1418 </span>
1419 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147 /***************************************************************/
 148 typedef union {
 149   mlib_d64 d64;
 150   struct {
 151     mlib_s32 i0;
 152     mlib_s32 i1;
 153   } i32s;
 154 } d64_2x32;
 155 
 156 /***************************************************************/
 157 #define GET_SRC_DST_PARAMETERS(type)                            \
 158   hgt = mlib_ImageGetHeight(src);                               \
 159   wid = mlib_ImageGetWidth(src);                                \
 160   nchannel = mlib_ImageGetChannels(src);                        \
 161   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 162   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 163   adr_src = (type *)mlib_ImageGetData(src);                     \
 164   adr_dst = (type *)mlib_ImageGetData(dst)
 165 
 166 /***************************************************************/

 167 #if IMG_TYPE == 1
 168 
 169 /*
 170  * Test for the presence of any &quot;1&quot; bit in bits
 171    8 to 31 of val. If present, then val is either
 172    negative or &gt;255. If over/underflows of 8 bits
 173    are uncommon, then this technique can be a win,
 174    since only a single test, rather than two, is
 175    necessary to determine if clamping is needed.
 176    On the other hand, if over/underflows are common,
 177    it adds an extra test.
 178 */
 179 #define CLAMP_STORE(dst, val)                                   \
 180   if (val &amp; 0xffffff00) {                                       \
 181     if (val &lt; MLIB_U8_MIN)                                      \
 182       dst = MLIB_U8_MIN;                                        \
 183     else                                                        \
 184       dst = MLIB_U8_MAX;                                        \
 185   } else {                                                      \
 186     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 190 
 191 #define CLAMP_STORE(dst, val)                                   \
 192   if (val &gt;= MLIB_S16_MAX)                                      \
 193     dst = MLIB_S16_MAX;                                         \
 194   else if (val &lt;= MLIB_S16_MIN)                                 \
 195     dst = MLIB_S16_MIN;                                         \
 196   else                                                          \
 197     dst = (mlib_s16)val
 198 
 199 #elif IMG_TYPE == 3
 200 
 201 #define CLAMP_STORE(dst, val)                                   \
 202   if (val &gt;= MLIB_U16_MAX)                                      \
 203     dst = MLIB_U16_MAX;                                         \
 204   else if (val &lt;= MLIB_U16_MIN)                                 \
 205     dst = MLIB_U16_MIN;                                         \
 206   else                                                          \
 207     dst = (mlib_u16)val
 208 
 209 #endif /* IMG_TYPE == 1 */

 210 
 211 /***************************************************************/
 212 #define MAX_KER   7
 213 #define MAX_N    15
 214 #define BUFF_SIZE   1600
 215 #define CACHE_SIZE  (64*1024)
 216 
 217 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 218                                          const mlib_image *src,
 219                                          const mlib_d64   *k,
 220                                          mlib_s32         n,
 221                                          mlib_s32         dy_t,
 222                                          mlib_s32         dy_b,
 223                                          mlib_s32         cmask)
 224 {
 225   DTYPE    *adr_src, *sl;
 226   DTYPE    *adr_dst, *dl, *dp;
 227   FTYPE    buff[BUFF_SIZE];
 228   FTYPE    *buffd;
 229   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 257 
 258   sbuff = pbuff;
 259   buffd = sbuff + smax_hsize;
 260 
 261   shgt -= (dy_t + dy_b);
 262   k_off = 0;
 263 
 264   for (l = 0; l &lt; hgt; l += hsize) {
 265     hsize = hgt - l;
 266 
 267     if (hsize &gt; max_hsize) hsize = max_hsize;
 268 
 269     smax_hsize = hsize + (n - 1);
 270 
 271     for (c = 0; c &lt; nchannel; c++) {
 272       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 273 
 274       sl = adr_src + c;
 275       dl = adr_dst + c;
 276 



 277       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 278 
 279       for (j = 0; j &lt; wid; j++) {
 280         FTYPE    *buff = sbuff;
 281 
 282         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 283           sbuff[i - k_off] = (FTYPE)sl[0];
 284         }
 285 



 286         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 287           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 288         }
 289 
 290         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 291           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 292         }
 293 
 294         pk = k;
 295 
 296         for (off = 0; off &lt; (n - 4); off += 4) {
 297 
 298           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 299           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 300 



 301           for (i = 0; i &lt; hsize; i += 2) {
 302             p0 = p2; p1 = p3; p2 = p4;
 303 
 304             p3 = buff[i + 3]; p4 = buff[i + 4];
 305 
 306             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 307             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 308           }
 309 
 310           pk += 4;
 311           buff += 4;
 312         }
 313 
 314         dp = dl;
 315         kh = n - off;
 316 
 317         if (kh == 4) {
 318           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 319           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 320 



 321           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 322             p0 = p2; p1 = p3; p2 = p4;
 323 
 324             p3 = buff[i + 3]; p4 = buff[i + 4];
 325 
 326             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 327             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 328 
 329             dp[0  ] = FROM_S32(d0);
 330             dp[dll] = FROM_S32(d1);
 331 
 332             buffd[i    ] = 0.0;
 333             buffd[i + 1] = 0.0;
 334 
 335             dp += 2*dll;
 336           }
 337 
 338           if (i &lt; hsize) {
 339             p0 = p2; p1 = p3; p2 = p4;
 340             p3 = buff[i + 3];
 341             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 342             dp[0] = FROM_S32(d0);
 343             buffd[i] = 0.0;
 344           }
 345 
 346         } else if (kh == 3) {
 347 
 348           p2 = buff[0]; p3 = buff[1];
 349           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 350 



 351           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 352             p0 = p2; p1 = p3;
 353 
 354             p2 = buff[i + 2]; p3 = buff[i + 3];
 355 
 356             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 357             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 358 
 359             dp[0  ] = FROM_S32(d0);
 360             dp[dll] = FROM_S32(d1);
 361 
 362             buffd[i    ] = 0.0;
 363             buffd[i + 1] = 0.0;
 364 
 365             dp += 2*dll;
 366           }
 367 
 368           if (i &lt; hsize) {
 369             p0 = p2; p1 = p3;
 370             p2 = buff[i + 2];
 371             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 372             dp[0] = FROM_S32(d0);
 373 
 374             buffd[i] = 0.0;
 375           }
 376 
 377         } else if (kh == 2) {
 378 
 379           p2 = buff[0];
 380           k0 = pk[0]; k1 = pk[1];
 381 



 382           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 383             p0 = p2;
 384 
 385             p1 = buff[i + 1]; p2 = buff[i + 2];
 386 
 387             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 388             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 389 
 390             dp[0  ] = FROM_S32(d0);
 391             dp[dll] = FROM_S32(d1);
 392 
 393             buffd[i    ] = 0.0;
 394             buffd[i + 1] = 0.0;
 395 
 396             dp += 2*dll;
 397           }
 398 
 399           if (i &lt; hsize) {
 400             p0 = p2;
 401             p1 = buff[i + 1];
 402             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 403             dp[0] = FROM_S32(d0);
 404 
 405             buffd[i] = 0.0;
 406           }
 407 
 408         } else /* kh == 1 */{
 409 
 410           k0 = pk[0];
 411 



 412           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 413             p0 = buff[i]; p1 = buff[i + 1];
 414 
 415             d0 = D2I(p0*k0 + buffd[i    ]);
 416             d1 = D2I(p1*k0 + buffd[i + 1]);
 417 
 418             dp[0  ] = FROM_S32(d0);
 419             dp[dll] = FROM_S32(d1);
 420 
 421             buffd[i    ] = 0.0;
 422             buffd[i + 1] = 0.0;
 423 
 424             dp += 2*dll;
 425           }
 426 
 427           if (i &lt; hsize) {
 428             p0 = buff[i];
 429             d0 = D2I(p0*k0 + buffd[i]);
 430             dp[0] = FROM_S32(d0);
 431 
</pre>
<hr />
<pre>
 514   buffi = (mlib_s32*)(buffd + swid);
 515 
 516   chan1 = nchannel;
 517   chan2 = chan1 + chan1;
 518 
 519   swid -= (dx_l + dx_r);
 520 
 521   for (c = 0; c &lt; nchannel; c++) {
 522     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 523 
 524     sl = adr_src + c;
 525     dl = adr_dst + c;
 526 
 527     for (l = 0; l &lt; n; l++) {
 528       FTYPE    *buff = buffs[l];
 529 
 530       for (i = 0; i &lt; dx_l; i++) {
 531         buff[i] = (FTYPE)sl[0];
 532       }
 533 



 534       for (i = 0; i &lt; swid; i++) {
 535         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 536       }
 537 
 538       for (i = 0; i &lt; dx_r; i++) {
 539         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 540       }
 541 
 542       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 543     }
 544 
 545     buff_ind = 0;
 546 



 547     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 548 
 549     for (j = 0; j &lt; hgt; j++) {
 550       FTYPE    **buffc = buffs + buff_ind;
 551       FTYPE    *buffn = buffc[n];
 552       FTYPE    *pk = k;
 553 
 554       for (l = 0; l &lt; n; l++) {
 555         FTYPE    *buff_l = buffc[l];
 556 
 557         for (off = 0; off &lt; m;) {
 558           FTYPE    *buff = buff_l + off;
 559 
 560           kw = m - off;
 561 
 562           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 563             if (kw &gt; MAX_KER) kw = kw/2;
 564           off += kw;
 565 
 566           sp = sl;
 567           dp = dl;
 568 
 569           if (kw == 7) {
 570 
 571             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 572             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 573 
 574             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 575             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 576 
 577             if (l &lt; (n - 1) || off &lt; m) {



 578               for (i = 0; i &lt;= (wid - 2); i += 2) {
 579                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 580 
 581                 p6 = buff[i + 6]; p7 = buff[i + 7];
 582 
 583                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 584                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 585               }
 586 
 587             } else {



 588               for (i = 0; i &lt;= (wid - 2); i += 2) {
 589                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 590 
 591                 p6 = buff[i + 6]; p7 = buff[i + 7];
 592 
 593                 LOAD_BUFF(buffi);
 594 
 595                 dd.d64 = *(FTYPE   *)(buffi + i);
 596                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 597                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 598 
 599                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 600                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 601 
 602                 dp[0    ] = FROM_S32(d0);
 603                 dp[chan1] = FROM_S32(d1);
 604 
 605                 buffd[i    ] = 0.0;
 606                 buffd[i + 1] = 0.0;
 607 
 608                 sp += chan2;
 609                 dp += chan2;
 610               }
 611             }
 612 
 613           } else if (kw == 6) {
 614 
 615             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 616             p5 = buff[3]; p6 = buff[4];
 617 
 618             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 619             k4 = pk[4]; k5 = pk[5];
 620 
 621             if (l &lt; (n - 1) || off &lt; m) {



 622               for (i = 0; i &lt;= (wid - 2); i += 2) {
 623                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 624 
 625                 p5 = buff[i + 5]; p6 = buff[i + 6];
 626 
 627                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 628                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 629               }
 630 
 631             } else {



 632               for (i = 0; i &lt;= (wid - 2); i += 2) {
 633                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 634 
 635                 p5 = buff[i + 5]; p6 = buff[i + 6];
 636 
 637                 LOAD_BUFF(buffi);
 638 
 639                 dd.d64 = *(FTYPE   *)(buffi + i);
 640                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 641                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 642 
 643                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 644                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 645 
 646                 dp[0    ] = FROM_S32(d0);
 647                 dp[chan1] = FROM_S32(d1);
 648 
 649                 buffd[i    ] = 0.0;
 650                 buffd[i + 1] = 0.0;
 651 
 652                 sp += chan2;
 653                 dp += chan2;
 654               }
 655             }
 656 
 657           } else if (kw == 5) {
 658 
 659             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 660             p5 = buff[3];
 661 
 662             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 663             k4 = pk[4];
 664 
 665             if (l &lt; (n - 1) || off &lt; m) {



 666               for (i = 0; i &lt;= (wid - 2); i += 2) {
 667                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 668 
 669                 p4 = buff[i + 4]; p5 = buff[i + 5];
 670 
 671                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 672                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 673               }
 674 
 675             } else {



 676               for (i = 0; i &lt;= (wid - 2); i += 2) {
 677                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 678 
 679                 p4 = buff[i + 4]; p5 = buff[i + 5];
 680 
 681                 LOAD_BUFF(buffi);
 682 
 683                 dd.d64 = *(FTYPE   *)(buffi + i);
 684                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 685                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 686 
 687                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 688                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 689 
 690                 dp[0    ] = FROM_S32(d0);
 691                 dp[chan1] = FROM_S32(d1);
 692 
 693                 buffd[i    ] = 0.0;
 694                 buffd[i + 1] = 0.0;
 695 
 696                 sp += chan2;
 697                 dp += chan2;
 698               }
 699             }
 700 
 701           } else if (kw == 4) {
 702 
 703             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 704 
 705             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 706 
 707             if (l &lt; (n - 1) || off &lt; m) {



 708               for (i = 0; i &lt;= (wid - 2); i += 2) {
 709                 p0 = p2; p1 = p3; p2 = p4;
 710 
 711                 p3 = buff[i + 3]; p4 = buff[i + 4];
 712 
 713                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 714                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 715               }
 716 
 717             } else {



 718               for (i = 0; i &lt;= (wid - 2); i += 2) {
 719                 p0 = p2; p1 = p3; p2 = p4;
 720 
 721                 p3 = buff[i + 3]; p4 = buff[i + 4];
 722 
 723                 LOAD_BUFF(buffi);
 724 
 725                 dd.d64 = *(FTYPE   *)(buffi + i);
 726                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 727                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 728 
 729                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 730                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 731 
 732                 dp[0    ] = FROM_S32(d0);
 733                 dp[chan1] = FROM_S32(d1);
 734 
 735                 buffd[i    ] = 0.0;
 736                 buffd[i + 1] = 0.0;
 737 
 738                 sp += chan2;
 739                 dp += chan2;
 740               }
 741             }
 742 
 743           } else if (kw == 3) {
 744 
 745             p2 = buff[0]; p3 = buff[1];
 746             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 747 
 748             if (l &lt; (n - 1) || off &lt; m) {



 749               for (i = 0; i &lt;= (wid - 2); i += 2) {
 750                 p0 = p2; p1 = p3;
 751 
 752                 p2 = buff[i + 2]; p3 = buff[i + 3];
 753 
 754                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 755                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 756               }
 757 
 758             } else {



 759               for (i = 0; i &lt;= (wid - 2); i += 2) {
 760                 p0 = p2; p1 = p3;
 761 
 762                 p2 = buff[i + 2]; p3 = buff[i + 3];
 763 
 764                 LOAD_BUFF(buffi);
 765 
 766                 dd.d64 = *(FTYPE   *)(buffi + i);
 767                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 768                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 769 
 770                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 771                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 772 
 773                 dp[0    ] = FROM_S32(d0);
 774                 dp[chan1] = FROM_S32(d1);
 775 
 776                 buffd[i    ] = 0.0;
 777                 buffd[i + 1] = 0.0;
 778 
 779                 sp += chan2;
 780                 dp += chan2;
 781               }
 782             }
 783 
 784           } else /* if (kw == 2) */ {
 785 
 786             p2 = buff[0];
 787             k0 = pk[0]; k1 = pk[1];
 788 
 789             if (l &lt; (n - 1) || off &lt; m) {



 790               for (i = 0; i &lt;= (wid - 2); i += 2) {
 791                 p0 = p2;
 792 
 793                 p1 = buff[i + 1]; p2 = buff[i + 2];
 794 
 795                 buffd[i    ] += p0*k0 + p1*k1;
 796                 buffd[i + 1] += p1*k0 + p2*k1;
 797               }
 798 
 799             } else {



 800               for (i = 0; i &lt;= (wid - 2); i += 2) {
 801                 p0 = p2;
 802 
 803                 p1 = buff[i + 1]; p2 = buff[i + 2];
 804 
 805                 LOAD_BUFF(buffi);
 806 
 807                 dd.d64 = *(FTYPE   *)(buffi + i);
 808                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 809                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 810 
 811                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 812                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 813 
 814                 dp[0    ] = FROM_S32(d0);
 815                 dp[chan1] = FROM_S32(d1);
 816 
 817                 buffd[i    ] = 0.0;
 818                 buffd[i + 1] = 0.0;
 819 
</pre>
<hr />
<pre>
 853       }
 854 
 855       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 856       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 857 
 858       /* next line */
 859 
 860       if (j &lt; hgt - dy_b - 2) sl += sll;
 861       dl += dll;
 862 
 863       buff_ind++;
 864 
 865       if (buff_ind &gt;= n + 1) buff_ind = 0;
 866     }
 867   }
 868 
 869   FREE_AND_RETURN_STATUS;
 870 }
 871 
 872 /***************************************************************/
<span class="line-modified"> 873 /* for x86, using integer multiplies is faster */</span>
 874 
 875 #define STORE_RES(res, x)                                       \
 876   x &gt;&gt;= shift2;                                                 \
 877   CLAMP_STORE(res, x)
 878 
 879 mlib_status CONV_FUNC_MxN_I
 880 {
 881   DTYPE    *adr_src, *sl, *sp = NULL;
 882   DTYPE    *adr_dst, *dl, *dp = NULL;
 883   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 884   mlib_s32 *pbuff = buff;
 885   mlib_s32 **buffs = buffs_arr, *buffd;
 886   mlib_s32 l, off, kw, bsize, buff_ind;
 887   mlib_s32 d0, d1, shift1, shift2;
 888   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 889   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 890   mlib_s32 wid, hgt, sll, dll;
 891   mlib_s32 nchannel, chan1;
 892   mlib_s32 i, j, c, swid;
 893   mlib_s32 chan2;
</pre>
<hr />
<pre>
 930 
 931   for (i = 0; i &lt; m*n; i++) {
 932     k[i] = kernel[i] &gt;&gt; shift1;
 933   }
 934 
 935   swid -= (dx_l + dx_r);
 936 
 937   for (c = 0; c &lt; nchannel; c++) {
 938     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 939 
 940     sl = adr_src + c;
 941     dl = adr_dst + c;
 942 
 943     for (l = 0; l &lt; n; l++) {
 944       mlib_s32  *buff = buffs[l];
 945 
 946       for (i = 0; i &lt; dx_l; i++) {
 947         buff[i] = (mlib_s32)sl[0];
 948       }
 949 



 950       for (i = 0; i &lt; swid; i++) {
 951         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
 952       }
 953 
 954       for (i = 0; i &lt; dx_r; i++) {
 955         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 956       }
 957 
 958       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 959     }
 960 
 961     buff_ind = 0;
 962 



 963     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
 964 
 965     for (j = 0; j &lt; hgt; j++) {
 966       mlib_s32 **buffc = buffs + buff_ind;
 967       mlib_s32 *buffn = buffc[n];
 968       mlib_s32 *pk = k;
 969 
 970       for (l = 0; l &lt; n; l++) {
 971         mlib_s32  *buff_l = buffc[l];
 972 
 973         for (off = 0; off &lt; m;) {
 974           mlib_s32 *buff = buff_l + off;
 975 
 976           sp = sl;
 977           dp = dl;
 978 
 979           kw = m - off;
 980 
 981           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 982             if (kw &gt; MAX_KER) kw = kw/2;
 983           off += kw;
 984 
 985           if (kw == 7) {
 986 
 987             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 988             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 989 
 990             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 991             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 992 
 993             if (l &lt; (n - 1) || off &lt; m) {



 994               for (i = 0; i &lt;= (wid - 2); i += 2) {
 995                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 996 
 997                 p6 = buff[i + 6]; p7 = buff[i + 7];
 998 
 999                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1000                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1001               }
1002 
1003             } else {



1004               for (i = 0; i &lt;= (wid - 2); i += 2) {
1005                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1006 
1007                 p6 = buff[i + 6]; p7 = buff[i + 7];
1008 
1009                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1010                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1011 
1012                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1013                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1014 
1015                 STORE_RES(dp[0    ], d0);
1016                 STORE_RES(dp[chan1], d1);
1017 
1018                 buffd[i    ] = 0;
1019                 buffd[i + 1] = 0;
1020 
1021                 sp += chan2;
1022                 dp += chan2;
1023               }
1024             }
1025 
1026           } else if (kw == 6) {
1027 
1028             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1029             p5 = buff[3]; p6 = buff[4];
1030 
1031             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1032             k4 = pk[4]; k5 = pk[5];
1033 
1034             if (l &lt; (n - 1) || off &lt; m) {



1035               for (i = 0; i &lt;= (wid - 2); i += 2) {
1036                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1037 
1038                 p5 = buff[i + 5]; p6 = buff[i + 6];
1039 
1040                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1041                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1042               }
1043 
1044             } else {



1045               for (i = 0; i &lt;= (wid - 2); i += 2) {
1046                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1047 
1048                 p5 = buff[i + 5]; p6 = buff[i + 6];
1049 
1050                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1051                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1052 
1053                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1054                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1055 
1056                 STORE_RES(dp[0    ], d0);
1057                 STORE_RES(dp[chan1], d1);
1058 
1059                 buffd[i    ] = 0;
1060                 buffd[i + 1] = 0;
1061 
1062                 sp += chan2;
1063                 dp += chan2;
1064               }
1065             }
1066 
1067           } else if (kw == 5) {
1068 
1069             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1070             p5 = buff[3];
1071 
1072             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1073             k4 = pk[4];
1074 
1075             if (l &lt; (n - 1) || off &lt; m) {



1076               for (i = 0; i &lt;= (wid - 2); i += 2) {
1077                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1078 
1079                 p4 = buff[i + 4]; p5 = buff[i + 5];
1080 
1081                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1082                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1083               }
1084 
1085             } else {



1086               for (i = 0; i &lt;= (wid - 2); i += 2) {
1087                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1088 
1089                 p4 = buff[i + 4]; p5 = buff[i + 5];
1090 
1091                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1092                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1093 
1094                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1095                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1096 
1097                 STORE_RES(dp[0    ], d0);
1098                 STORE_RES(dp[chan1], d1);
1099 
1100                 buffd[i    ] = 0;
1101                 buffd[i + 1] = 0;
1102 
1103                 sp += chan2;
1104                 dp += chan2;
1105               }
1106             }
1107 
1108           } else if (kw == 4) {
1109 
1110             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1111 
1112             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1113 
1114             if (l &lt; (n - 1) || off &lt; m) {



1115               for (i = 0; i &lt;= (wid - 2); i += 2) {
1116                 p0 = p2; p1 = p3; p2 = p4;
1117 
1118                 p3 = buff[i + 3]; p4 = buff[i + 4];
1119 
1120                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1121                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1122               }
1123 
1124             } else {



1125               for (i = 0; i &lt;= (wid - 2); i += 2) {
1126                 p0 = p2; p1 = p3; p2 = p4;
1127 
1128                 p3 = buff[i + 3]; p4 = buff[i + 4];
1129 
1130                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1131                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1132 
1133                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1134                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1135 
1136                 STORE_RES(dp[0    ], d0);
1137                 STORE_RES(dp[chan1], d1);
1138 
1139                 buffd[i    ] = 0;
1140                 buffd[i + 1] = 0;
1141 
1142                 sp += chan2;
1143                 dp += chan2;
1144               }
1145             }
1146 
1147           } else if (kw == 3) {
1148 
1149             p2 = buff[0]; p3 = buff[1];
1150             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1151 
1152             if (l &lt; (n - 1) || off &lt; m) {



1153               for (i = 0; i &lt;= (wid - 2); i += 2) {
1154                 p0 = p2; p1 = p3;
1155 
1156                 p2 = buff[i + 2]; p3 = buff[i + 3];
1157 
1158                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1159                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1160               }
1161 
1162             } else {



1163               for (i = 0; i &lt;= (wid - 2); i += 2) {
1164                 p0 = p2; p1 = p3;
1165 
1166                 p2 = buff[i + 2]; p3 = buff[i + 3];
1167 
1168                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1169                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1170 
1171                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1172                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1173 
1174                 STORE_RES(dp[0    ], d0);
1175                 STORE_RES(dp[chan1], d1);
1176 
1177                 buffd[i    ] = 0;
1178                 buffd[i + 1] = 0;
1179 
1180                 sp += chan2;
1181                 dp += chan2;
1182               }
1183             }
1184 
1185           } else if (kw == 2) {
1186 
1187             p2 = buff[0];
1188             k0 = pk[0]; k1 = pk[1];
1189 
1190             if (l &lt; (n - 1) || off &lt; m) {



1191               for (i = 0; i &lt;= (wid - 2); i += 2) {
1192                 p0 = p2;
1193 
1194                 p1 = buff[i + 1]; p2 = buff[i + 2];
1195 
1196                 buffd[i    ] += p0*k0 + p1*k1;
1197                 buffd[i + 1] += p1*k0 + p2*k1;
1198               }
1199 
1200             } else {



1201               for (i = 0; i &lt;= (wid - 2); i += 2) {
1202                 p0 = p2;
1203 
1204                 p1 = buff[i + 1]; p2 = buff[i + 2];
1205 
1206                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1207                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1208 
1209                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1210                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1211 
1212                 STORE_RES(dp[0    ], d0);
1213                 STORE_RES(dp[chan1], d1);
1214 
1215                 buffd[i    ] = 0;
1216                 buffd[i + 1] = 0;
1217 
1218                 sp += chan2;
1219                 dp += chan2;
1220               }
1221             }
1222 
1223           } else /* kw == 1 */{
1224 
1225             k0 = pk[0];
1226 
1227             if (l &lt; (n - 1) || off &lt; m) {



1228               for (i = 0; i &lt;= (wid - 2); i += 2) {
1229                 p0 = buff[i]; p1 = buff[i + 1];
1230 
1231                 buffd[i    ] += p0*k0;
1232                 buffd[i + 1] += p1*k0;
1233               }
1234 
1235             } else {



1236               for (i = 0; i &lt;= (wid - 2); i += 2) {
1237                 p0 = buff[i]; p1 = buff[i + 1];
1238 
1239                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1240                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1241 
1242                 d0 = (p0*k0 + buffd[i    ]);
1243                 d1 = (p1*k0 + buffd[i + 1]);
1244 
1245                 STORE_RES(dp[0    ], d0);
1246                 STORE_RES(dp[chan1], d1);
1247 
1248                 buffd[i    ] = 0;
1249                 buffd[i + 1] = 0;
1250 
1251                 sp += chan2;
1252                 dp += chan2;
1253               }
1254             }
1255           }
</pre>
<hr />
<pre>
1284       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1285       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1286 
1287       /* next line */
1288 
1289       if (j &lt; hgt - dy_b - 2) sl += sll;
1290       dl += dll;
1291 
1292       buff_ind++;
1293 
1294       if (buff_ind &gt;= n + 1) buff_ind = 0;
1295     }
1296   }
1297 
1298   if (pbuff != buff) mlib_free(pbuff);
1299   if (k != k_locl) mlib_free(k);
1300 
1301   return MLIB_SUCCESS;
1302 }
1303 


1304 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_ImageConv_32nw.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_8nw.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
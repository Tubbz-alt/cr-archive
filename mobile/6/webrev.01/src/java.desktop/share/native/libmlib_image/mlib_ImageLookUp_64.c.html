<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libmlib_image/mlib_ImageLookUp_64.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 /*
  28  * FUNCTION
  29  *      mlib_ImageLookUp_U8D64 - table lookup
  30  *      mlib_ImageLookUp_S16D64 - table lookup
  31  *      mlib_ImageLookUp_U16D64 - table lookup
  32  *      mlib_ImageLookUp_S32D64 - table lookup
  33  *
  34  * SYNOPSIS
  35  *      void mlib_ImageLookUp_U8_D64(src, slb,
  36  *                                   dst, dlb,
  37  *                                   xsize, ysize,
  38  *                                   csize, table)
  39  *
  40  *      void mlib_ImageLookUp_S16_D64(src, slb,
  41  *                                    dst, dlb,
  42  *                                    xsize, ysize,
  43  *                                    csize, table)
  44  *
  45  *      void mlib_ImageLookUp_U16_D64(src, slb,
  46  *                                    dst, dlb,
  47  *                                    xsize, ysize,
  48  *                                    csize, table)
  49  *
  50  *      void mlib_ImageLookUp_S32_D64(src, slb,
  51  *                                    dst, dlb,
  52  *                                    xsize, ysize,
  53  *                                    csize, table)
  54  *
  55  * ARGUMENT
  56  *      src     pointer to input image (BYTE, SHORT, USHORT, INT)
  57  *      slb     stride of input image (in pixels)
  58  *      dst     pointer to output image (DOUBLE)
  59  *      dlb     stride of output image (in pixels)
  60  *      xsize   image width
  61  *      ysize   image height
  62  *      csize   number of channels
  63  *      table   lookup table
  64  *
  65  * DESCRIPTION
  66  *      dst = table[src] (c, vis version)
  67  */
  68 
  69 #include &quot;mlib_image.h&quot;
  70 #include &quot;mlib_ImageLookUp.h&quot;
  71 
  72 /***************************************************************/
  73 #define MLIB_C_IMAGELOOKUP(DTYPE, STYPE, TABLE)                 \
  74 {                                                               \
  75   mlib_s32 i, j, k;                                             \
  76                                                                 \
  77   if (xsize &lt; 2) {                                              \
  78     for(j = 0; j &lt; ysize; j++, dst += dlb, src += slb){         \
  79       for(k = 0; k &lt; csize; k++) {                              \
  80         DTYPE *da = dst + k;                                    \
  81         const STYPE *sa = src + k;                              \
  82         DTYPE *tab = (DTYPE*) TABLE[k];                         \
  83                                                                 \
  84         for(i = 0; i &lt; xsize; i++, da += csize, sa += csize)    \
  85         *da=tab[*sa];                                           \
  86       }                                                         \
  87     }                                                           \
  88   } else {                                                      \
  89     for(j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {        \
  90       for(k = 0; k &lt; csize; k++) {                              \
  91         DTYPE *da = dst + k;                                    \
  92         const STYPE *sa = src + k;                              \
  93         DTYPE *tab = (DTYPE*) TABLE[k];                         \
  94         mlib_s32 s0, s1;                                        \
  95         DTYPE t0, t1;                                           \
  96                                                                 \
  97         s0 = (mlib_s32)sa[0];                                   \
  98         s1 = (mlib_s32)sa[csize];                               \
  99         sa += 2*csize;                                          \
 100                                                                 \
 101         for(i = 0;                                              \
 102             i &lt; xsize - 3;                                      \
 103             i+=2, da += 2*csize, sa += 2*csize) {               \
 104           t0 = tab[s0];                                         \
 105           t1 = tab[s1];                                         \
 106           s0 = (mlib_s32)sa[0];                                 \
 107           s1 = (mlib_s32)sa[csize];                             \
 108           da[0] = (DTYPE)t0;                                    \
 109           da[csize] = (DTYPE)t1;                                \
 110         }                                                       \
 111         t0 = tab[s0];                                           \
 112         t1 = tab[s1];                                           \
 113         da[0] = (DTYPE)t0;                                      \
 114         da[csize] = (DTYPE)t1;                                  \
 115         if (xsize &amp; 1) da[2*csize] = tab[sa[0]];                \
 116       }                                                         \
 117     }                                                           \
 118   }                                                             \
 119 }
 120 
 121 /***************************************************************/
 122 #define MLIB_C_IMAGELOOKUPSI(DTYPE, STYPE, TABLE)               \
 123 {                                                               \
 124   mlib_s32 i, j, k;                                             \
 125                                                                 \
 126   if (xsize &lt; 2) {                                              \
 127     for(j = 0; j &lt; ysize; j++, dst += dlb, src += slb){         \
 128       for(k = 0; k &lt; csize; k++) {                              \
 129         DTYPE *da = dst + k;                                    \
 130         const STYPE *sa = (void *)src;                                  \
 131         DTYPE *tab = (DTYPE*) TABLE[k];                         \
 132                                                                 \
 133         for(i = 0; i &lt; xsize; i++, da += csize, sa ++)          \
 134         *da=tab[*sa];                                           \
 135       }                                                         \
 136     }                                                           \
 137   } else {                                                      \
 138     for(j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {        \
 139       for(k = 0; k &lt; csize; k++) {                              \
 140         DTYPE *da = dst + k;                                    \
 141         const STYPE *sa = (void *)src;                                  \
 142         DTYPE *tab = (DTYPE*) TABLE[k];                         \
 143         mlib_s32 s0, s1;                                        \
 144         DTYPE t0, t1;                                           \
 145                                                                 \
 146         s0 = (mlib_s32)sa[0];                                   \
 147         s1 = (mlib_s32)sa[1];                                   \
 148         sa += 2;                                                \
 149                                                                 \
 150         for(i = 0;                                              \
 151             i &lt; xsize - 3;                                      \
 152             i+=2, da += 2*csize, sa += 2) {                     \
 153           t0 = tab[s0];                                         \
 154           t1 = tab[s1];                                         \
 155           s0 = (mlib_s32)sa[0];                                 \
 156           s1 = (mlib_s32)sa[1];                                 \
 157           da[0] = (DTYPE)t0;                                    \
 158           da[csize] = (DTYPE)t1;                                \
 159         }                                                       \
 160         t0 = tab[s0];                                           \
 161         t1 = tab[s1];                                           \
 162         da[0] = (DTYPE)t0;                                      \
 163         da[csize] = (DTYPE)t1;                                  \
 164         if (xsize &amp; 1) da[2*csize] = tab[sa[0]];                \
 165       }                                                         \
 166     }                                                           \
 167   }                                                             \
 168 }
 169 
 170 /***************************************************************/
 171 #ifdef _LITTLE_ENDIAN
 172 
 173 #define READ_U8_D64(table0, table1, table2, table3)             \
 174   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));    \
 175   t1 = *(mlib_d64*)((mlib_u8*)table1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));    \
 176   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 &gt;&gt; 13)  &amp; 0x7F8));  \
 177   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 &gt;&gt; 21)  &amp; 0x7F8))
 178 
 179 #else
 180 
 181 #define READ_U8_D64(table0, table1, table2, table3)             \
 182   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));   \
 183   t1 = *(mlib_d64*)((mlib_u8*)table1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));   \
 184   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 &gt;&gt; 5)  &amp; 0x7F8));   \
 185   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 &lt;&lt; 3)  &amp; 0x7F8))
 186 
 187 #endif /* _LITTLE_ENDIAN */
 188 
 189 /***************************************************************/
 190 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
 191                              mlib_s32       slb,
 192                              mlib_d64       *dst,
 193                              mlib_s32       dlb,
 194                              mlib_s32       xsize,
 195                              mlib_s32       ysize,
 196                              mlib_s32       csize,
 197                              const mlib_d64 **table)
 198 {
 199 
 200   if (xsize * csize &lt; 7) {
 201     MLIB_C_IMAGELOOKUP(mlib_d64, mlib_u8, table);
 202   }
 203   else if (csize == 1) {
 204     mlib_s32 i, j;
 205 
 206     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 207       mlib_u32 *sa;
 208       mlib_d64 *tab = (mlib_d64 *) table[0];
 209       mlib_u32 s0;
 210       mlib_d64 t0, t1, t2, t3;
 211       mlib_s32 off;
 212       mlib_s32 size = xsize;
 213       mlib_d64 *dp = (mlib_d64 *) dst;
 214       mlib_u8 *sp = (void *)src;
 215 
 216       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 217 
 218       for (i = 0; i &lt; off; i++, sp++) {
 219         *dp++ = tab[sp[0]];
 220         size--;
 221       }
 222 
 223       sa = (mlib_u32 *) sp;
 224 
 225       s0 = sa[0];
 226       sa++;
 227 
 228       for (i = 0; i &lt; size - 7; i += 4, dp += 4, sa++) {
 229         READ_U8_D64(tab, tab, tab, tab);
 230         s0 = sa[0];
 231         dp[0] = t0;
 232         dp[1] = t1;
 233         dp[2] = t2;
 234         dp[3] = t3;
 235       }
 236 
 237       READ_U8_D64(tab, tab, tab, tab);
 238       dp[0] = t0;
 239       dp[1] = t1;
 240       dp[2] = t2;
 241       dp[3] = t3;
 242       dp += 4;
 243       sp = (mlib_u8 *) sa;
 244       i += 4;
 245       for (; i &lt; size; i++, dp++, sp++)
 246         dp[0] = tab[sp[0]];
 247     }
 248   }
 249   else if (csize == 2) {
 250     mlib_s32 i, j;
 251 
 252     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 253       mlib_u32 *sa;
 254       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 255       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 256       mlib_d64 *tab;
 257       mlib_u32 s0;
 258       mlib_d64 t0, t1, t2, t3;
 259       mlib_s32 off;
 260       mlib_s32 size = xsize * 2;
 261       mlib_d64 *dp = (mlib_d64 *) dst;
 262       mlib_u8 *sp = (void *)src;
 263 
 264       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 265 
 266       for (i = 0; i &lt; off - 1; i += 2, sp += 2) {
 267         *dp++ = tab0[sp[0]];
 268         *dp++ = tab1[sp[1]];
 269         size -= 2;
 270       }
 271 
 272       if ((off &amp; 1) != 0) {
 273         *dp++ = tab0[*sp];
 274         size--;
 275         sp++;
 276         tab = tab0;
 277         tab0 = tab1;
 278         tab1 = tab;
 279       }
 280 
 281       sa = (mlib_u32 *) sp;
 282 
 283       s0 = sa[0];
 284       sa++;
 285 
 286       for (i = 0; i &lt; size - 7; i += 4, dp += 4, sa++) {
 287         READ_U8_D64(tab0, tab1, tab0, tab1);
 288         s0 = sa[0];
 289         dp[0] = t0;
 290         dp[1] = t1;
 291         dp[2] = t2;
 292         dp[3] = t3;
 293       }
 294 
 295       READ_U8_D64(tab0, tab1, tab0, tab1);
 296       dp[0] = t0;
 297       dp[1] = t1;
 298       dp[2] = t2;
 299       dp[3] = t3;
 300       dp += 4;
 301       sp = (mlib_u8 *) sa;
 302       i += 4;
 303 
 304       for (; i &lt; size - 1; i += 2, sp += 2) {
 305         *dp++ = tab0[sp[0]];
 306         *dp++ = tab1[sp[1]];
 307       }
 308 
 309       if (i &lt; size)
 310         *dp = tab0[(*sp)];
 311     }
 312   }
 313   else if (csize == 3) {
 314     mlib_s32 i, j;
 315 
 316     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 317       mlib_u32 *sa;
 318       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 319       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 320       mlib_d64 *tab2 = (mlib_d64 *) table[2];
 321       mlib_d64 *tab;
 322       mlib_u32 s0;
 323       mlib_d64 t0, t1, t2, t3;
 324       mlib_s32 off;
 325       mlib_s32 size = xsize * 3;
 326       mlib_d64 *dp = (mlib_d64 *) dst;
 327       mlib_u8 *sp = (void *)src;
 328 
 329       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 330 
 331       if (off == 1) {
 332         *dp++ = tab0[(*sp)];
 333         tab = tab0;
 334         tab0 = tab1;
 335         tab1 = tab2;
 336         tab2 = tab;
 337         size--;
 338         sp++;
 339       }
 340       else if (off == 2) {
 341         *dp++ = tab0[sp[0]];
 342         *dp++ = tab1[sp[1]];
 343         tab = tab2;
 344         tab2 = tab1;
 345         tab1 = tab0;
 346         tab0 = tab;
 347         size -= 2;
 348         sp += 2;
 349       }
 350       else if (off == 3) {
 351         *dp++ = tab0[sp[0]];
 352         *dp++ = tab1[sp[1]];
 353         *dp++ = tab2[sp[2]];
 354         size -= 3;
 355         sp += 3;
 356       }
 357 
 358       sa = (mlib_u32 *) sp;
 359 
 360       s0 = sa[0];
 361       sa++;
 362 
 363       for (i = 0; i &lt; size - 7; i += 4, dp += 4, sa++) {
 364         READ_U8_D64(tab0, tab1, tab2, tab0);
 365         tab = tab0;
 366         tab0 = tab1;
 367         tab1 = tab2;
 368         tab2 = tab;
 369         s0 = sa[0];
 370         dp[0] = t0;
 371         dp[1] = t1;
 372         dp[2] = t2;
 373         dp[3] = t3;
 374       }
 375 
 376       READ_U8_D64(tab0, tab1, tab2, tab0);
 377       dp[0] = t0;
 378       dp[1] = t1;
 379       dp[2] = t2;
 380       dp[3] = t3;
 381       dp += 4;
 382       sp = (mlib_u8 *) sa;
 383       i += 4;
 384 
 385       if (i &lt; size) {
 386         *dp++ = tab1[(*sp)];
 387         i++;
 388         sp++;
 389       }
 390 
 391       if (i &lt; size) {
 392         *dp++ = tab2[(*sp)];
 393         i++;
 394         sp++;
 395       }
 396 
 397       if (i &lt; size) {
 398         *dp = tab0[(*sp)];
 399       }
 400     }
 401   }
 402   else if (csize == 4) {
 403     mlib_s32 i, j;
 404 
 405     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 406       mlib_u32 *sa;
 407       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 408       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 409       mlib_d64 *tab2 = (mlib_d64 *) table[2];
 410       mlib_d64 *tab3 = (mlib_d64 *) table[3];
 411       mlib_d64 *tab;
 412       mlib_u32 s0;
 413       mlib_d64 t0, t1, t2, t3;
 414       mlib_s32 off;
 415       mlib_s32 size = xsize * 4;
 416       mlib_d64 *dp = (mlib_d64 *) dst;
 417       mlib_u8 *sp = (void *)src;
 418 
 419       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 420 
 421       if (off == 1) {
 422         *dp++ = tab0[(*sp)];
 423         tab = tab0;
 424         tab0 = tab1;
 425         tab1 = tab2;
 426         tab2 = tab3;
 427         tab3 = tab;
 428         size--;
 429         sp++;
 430       }
 431       else if (off == 2) {
 432         *dp++ = tab0[sp[0]];
 433         *dp++ = tab1[sp[1]];
 434         tab = tab0;
 435         tab0 = tab2;
 436         tab2 = tab;
 437         tab = tab1;
 438         tab1 = tab3;
 439         tab3 = tab;
 440         size -= 2;
 441         sp += 2;
 442       }
 443       else if (off == 3) {
 444         *dp++ = tab0[sp[0]];
 445         *dp++ = tab1[sp[1]];
 446         *dp++ = tab2[sp[2]];
 447         tab = tab3;
 448         tab3 = tab2;
 449         tab2 = tab1;
 450         tab1 = tab0;
 451         tab0 = tab;
 452         size -= 3;
 453         sp += 3;
 454       }
 455 
 456       sa = (mlib_u32 *) sp;
 457 
 458       s0 = sa[0];
 459       sa++;
 460 
 461       for (i = 0; i &lt; size - 7; i += 4, dp += 4, sa++) {
 462         READ_U8_D64(tab0, tab1, tab2, tab3);
 463         s0 = sa[0];
 464         dp[0] = t0;
 465         dp[1] = t1;
 466         dp[2] = t2;
 467         dp[3] = t3;
 468       }
 469 
 470       READ_U8_D64(tab0, tab1, tab2, tab3);
 471       dp[0] = t0;
 472       dp[1] = t1;
 473       dp[2] = t2;
 474       dp[3] = t3;
 475       dp += 4;
 476       sp = (mlib_u8 *) sa;
 477       i += 4;
 478 
 479       if (i &lt; size) {
 480         *dp++ = tab0[(*sp)];
 481         i++;
 482         sp++;
 483       }
 484 
 485       if (i &lt; size) {
 486         *dp++ = tab1[(*sp)];
 487         i++;
 488         sp++;
 489       }
 490 
 491       if (i &lt; size) {
 492         *dp = tab2[(*sp)];
 493       }
 494     }
 495   }
 496 }
 497 
 498 /***************************************************************/
 499 void mlib_ImageLookUp_S16_D64(const mlib_s16 *src,
 500                               mlib_s32       slb,
 501                               mlib_d64       *dst,
 502                               mlib_s32       dlb,
 503                               mlib_s32       xsize,
 504                               mlib_s32       ysize,
 505                               mlib_s32       csize,
 506                               const mlib_d64 **table)
 507 {
 508   const mlib_d64 *table_base[4];
 509   mlib_s32 c;
 510 
 511   for (c = 0; c &lt; csize; c++) {
 512     table_base[c] = &amp;table[c][32768];
 513   }
 514 
 515   MLIB_C_IMAGELOOKUP(mlib_d64, mlib_s16, table_base);
 516 }
 517 
 518 /***************************************************************/
 519 void mlib_ImageLookUp_U16_D64(const mlib_u16 *src,
 520                               mlib_s32       slb,
 521                               mlib_d64       *dst,
 522                               mlib_s32       dlb,
 523                               mlib_s32       xsize,
 524                               mlib_s32       ysize,
 525                               mlib_s32       csize,
 526                               const mlib_d64 **table)
 527 {
 528   const mlib_d64 *table_base[4];
 529   mlib_s32 c;
 530 
 531   for (c = 0; c &lt; csize; c++) {
 532     table_base[c] = &amp;table[c][0];
 533   }
 534 
 535   MLIB_C_IMAGELOOKUP(mlib_d64, mlib_u16, table_base);
 536 }
 537 
 538 /***************************************************************/
 539 void mlib_ImageLookUp_S32_D64(const mlib_s32 *src,
 540                               mlib_s32       slb,
 541                               mlib_d64       *dst,
 542                               mlib_s32       dlb,
 543                               mlib_s32       xsize,
 544                               mlib_s32       ysize,
 545                               mlib_s32       csize,
 546                               const mlib_d64 **table)
 547 {
 548   const mlib_d64 *table_base[4];
 549   mlib_u32 shift = TABLE_SHIFT_S32;
 550   mlib_s32 c;
 551 
 552   for (c = 0; c &lt; csize; c++) {
 553     table_base[c] = &amp;table[c][shift];
 554   }
 555 
 556   MLIB_C_IMAGELOOKUP(mlib_d64, mlib_s32, table_base);
 557 }
 558 
 559 /***************************************************************/
 560 void mlib_ImageLookUpSI_U8_D64(const mlib_u8  *src,
 561                                mlib_s32       slb,
 562                                mlib_d64       *dst,
 563                                mlib_s32       dlb,
 564                                mlib_s32       xsize,
 565                                mlib_s32       ysize,
 566                                mlib_s32       csize,
 567                                const mlib_d64 **table)
 568 {
 569 
 570   if (xsize &lt; 7) {
 571     MLIB_C_IMAGELOOKUPSI(mlib_d64, mlib_u8, table);
 572   }
 573   else if (csize == 2) {
 574     mlib_s32 i, j;
 575 
 576     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 577       mlib_u32 *sa;
 578       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 579       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 580       mlib_u32 s0;
 581       mlib_d64 t0, t1, t2, t3;
 582       mlib_s32 off;
 583       mlib_s32 size = xsize;
 584       mlib_d64 *dp = (mlib_d64 *) dst;
 585       mlib_u8 *sp = (void *)src;
 586 
 587       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 588 
 589       for (i = 0; i &lt; off; i++, sp++) {
 590         *dp++ = tab0[sp[0]];
 591         *dp++ = tab1[sp[0]];
 592         size--;
 593       }
 594 
 595       sa = (mlib_u32 *) sp;
 596 
 597       s0 = sa[0];
 598       sa++;
 599 
 600       for (i = 0; i &lt; size - 7; i += 4, dp += 8, sa++) {
 601 #ifdef _LITTLE_ENDIAN
 602         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 603         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 604         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 605         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 606 #else
 607         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 608         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 609         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 610         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 611 #endif /* _LITTLE_ENDIAN */
 612         dp[0] = t0;
 613         dp[1] = t1;
 614         dp[2] = t2;
 615         dp[3] = t3;
 616 #ifdef _LITTLE_ENDIAN
 617         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 618         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 619         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 620         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 621 #else
 622         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 623         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 624         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 625         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 626 #endif /* _LITTLE_ENDIAN */
 627         s0 = sa[0];
 628         dp[4] = t0;
 629         dp[5] = t1;
 630         dp[6] = t2;
 631         dp[7] = t3;
 632       }
 633 
 634 #ifdef _LITTLE_ENDIAN
 635       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 636       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 637       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 638       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 639 #else
 640       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 641       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 642       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 643       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 644 #endif /* _LITTLE_ENDIAN */
 645       dp[0] = t0;
 646       dp[1] = t1;
 647       dp[2] = t2;
 648       dp[3] = t3;
 649 #ifdef _LITTLE_ENDIAN
 650       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 651       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 652       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 653       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 654 #else
 655       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 656       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 657       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 658       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 659 #endif /* _LITTLE_ENDIAN */
 660       dp[4] = t0;
 661       dp[5] = t1;
 662       dp[6] = t2;
 663       dp[7] = t3;
 664       dp += 8;
 665       sp = (mlib_u8 *) sa;
 666       i += 4;
 667 
 668       for (; i &lt; size; i++, sp++) {
 669         *dp++ = tab0[sp[0]];
 670         *dp++ = tab1[sp[0]];
 671       }
 672     }
 673   }
 674   else if (csize == 3) {
 675     mlib_s32 i, j;
 676 
 677     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 678       mlib_u32 *sa;
 679       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 680       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 681       mlib_d64 *tab2 = (mlib_d64 *) table[2];
 682       mlib_u32 s0;
 683       mlib_d64 t0, t1, t2, t3, t4, t5;
 684       mlib_s32 off;
 685       mlib_s32 size = xsize;
 686       mlib_d64 *dp = (mlib_d64 *) dst;
 687       mlib_u8 *sp = (void *)src;
 688 
 689       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 690 
 691       for (i = 0; i &lt; off; i++, sp++) {
 692         *dp++ = tab0[sp[0]];
 693         *dp++ = tab1[sp[0]];
 694         *dp++ = tab2[sp[0]];
 695         size--;
 696       }
 697 
 698       sa = (mlib_u32 *) sp;
 699 
 700       s0 = sa[0];
 701       sa++;
 702 
 703       for (i = 0; i &lt; size - 7; i += 4, dp += 12, sa++) {
 704 #ifdef _LITTLE_ENDIAN
 705         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 706         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 707         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 708         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 709         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 710         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 711 #else
 712         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 713         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 714         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 715         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 716         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 717         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 718 #endif /* _LITTLE_ENDIAN */
 719         dp[0] = t0;
 720         dp[1] = t1;
 721         dp[2] = t2;
 722         dp[3] = t3;
 723         dp[4] = t4;
 724         dp[5] = t5;
 725 #ifdef _LITTLE_ENDIAN
 726         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 727         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 728         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 729         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 730         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 731         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 732 #else
 733         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 734         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 735         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 736         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 737         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 738         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 739 #endif /* _LITTLE_ENDIAN */
 740         s0 = sa[0];
 741         dp[6] = t0;
 742         dp[7] = t1;
 743         dp[8] = t2;
 744         dp[9] = t3;
 745         dp[10] = t4;
 746         dp[11] = t5;
 747       }
 748 
 749 #ifdef _LITTLE_ENDIAN
 750       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 751       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 752       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 753       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 754       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 755       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 756 #else
 757       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 758       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 759       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 760       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 761       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 762       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 763 #endif /* _LITTLE_ENDIAN */
 764       dp[0] = t0;
 765       dp[1] = t1;
 766       dp[2] = t2;
 767       dp[3] = t3;
 768       dp[4] = t4;
 769       dp[5] = t5;
 770 #ifdef _LITTLE_ENDIAN
 771       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 772       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 773       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 774       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 775       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 776       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 777 #else
 778       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 779       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 780       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 781       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 782       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 783       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 784 #endif /* _LITTLE_ENDIAN */
 785       dp[6] = t0;
 786       dp[7] = t1;
 787       dp[8] = t2;
 788       dp[9] = t3;
 789       dp[10] = t4;
 790       dp[11] = t5;
 791       dp += 12;
 792       sp = (mlib_u8 *) sa;
 793       i += 4;
 794 
 795       for (; i &lt; size; i++, sp++) {
 796         *dp++ = tab0[sp[0]];
 797         *dp++ = tab1[sp[0]];
 798         *dp++ = tab2[sp[0]];
 799       }
 800     }
 801   }
 802   else if (csize == 4) {
 803     mlib_s32 i, j;
 804 
 805     for (j = 0; j &lt; ysize; j++, dst += dlb, src += slb) {
 806       mlib_u32 *sa;
 807       mlib_d64 *tab0 = (mlib_d64 *) table[0];
 808       mlib_d64 *tab1 = (mlib_d64 *) table[1];
 809       mlib_d64 *tab2 = (mlib_d64 *) table[2];
 810       mlib_d64 *tab3 = (mlib_d64 *) table[3];
 811       mlib_u32 s0;
 812       mlib_d64 t0, t1, t2, t3;
 813       mlib_s32 off;
 814       mlib_s32 size = xsize;
 815       mlib_d64 *dp = (mlib_d64 *) dst;
 816       mlib_u8 *sp = (void *)src;
 817 
 818       off = (mlib_s32) ((4 - ((mlib_addr) src &amp; 3)) &amp; 3);
 819 
 820       for (i = 0; i &lt; off; i++, sp++) {
 821         *dp++ = tab0[sp[0]];
 822         *dp++ = tab1[sp[0]];
 823         *dp++ = tab2[sp[0]];
 824         *dp++ = tab3[sp[0]];
 825         size--;
 826       }
 827 
 828       sa = (mlib_u32 *) sp;
 829 
 830       s0 = sa[0];
 831       sa++;
 832 
 833       for (i = 0; i &lt; size - 7; i += 4, dp += 16, sa++) {
 834 #ifdef _LITTLE_ENDIAN
 835         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 836         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 837         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 838         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 839 #else
 840         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 841         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 842         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 843         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 844 #endif /* _LITTLE_ENDIAN */
 845         dp[0] = t0;
 846         dp[1] = t1;
 847         dp[2] = t2;
 848         dp[3] = t3;
 849 #ifdef _LITTLE_ENDIAN
 850         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 851         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 852         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 853         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 854 #else
 855         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 856         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 857         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 858         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 859 #endif /* _LITTLE_ENDIAN */
 860         dp[4] = t0;
 861         dp[5] = t1;
 862         dp[6] = t2;
 863         dp[7] = t3;
 864 #ifdef _LITTLE_ENDIAN
 865         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 866         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 867         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 868         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 869 #else
 870         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 871         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 872         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 873         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 874 #endif /* _LITTLE_ENDIAN */
 875         dp[8] = t0;
 876         dp[9] = t1;
 877         dp[10] = t2;
 878         dp[11] = t3;
 879 #ifdef _LITTLE_ENDIAN
 880         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 881         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 882         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 883         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 884 #else
 885         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 886         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 887         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 888         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 889 #endif /* _LITTLE_ENDIAN */
 890         s0 = sa[0];
 891         dp[12] = t0;
 892         dp[13] = t1;
 893         dp[14] = t2;
 894         dp[15] = t3;
 895       }
 896 
 897 #ifdef _LITTLE_ENDIAN
 898       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 899       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 900       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 901       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 902 #else
 903       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 904       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 905       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 906       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 907 #endif /* _LITTLE_ENDIAN */
 908       dp[0] = t0;
 909       dp[1] = t1;
 910       dp[2] = t2;
 911       dp[3] = t3;
 912 #ifdef _LITTLE_ENDIAN
 913       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 914       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 915       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 916       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 917 #else
 918       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 919       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 920       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 921       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 922 #endif /* _LITTLE_ENDIAN */
 923       dp[4] = t0;
 924       dp[5] = t1;
 925       dp[6] = t2;
 926       dp[7] = t3;
 927 #ifdef _LITTLE_ENDIAN
 928       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 929       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 930       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 931       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 13) &amp; 0x7F8));
 932 #else
 933       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 934       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 935       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 936       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 5) &amp; 0x7F8));
 937 #endif /* _LITTLE_ENDIAN */
 938       dp[8] = t0;
 939       dp[9] = t1;
 940       dp[10] = t2;
 941       dp[11] = t3;
 942 #ifdef _LITTLE_ENDIAN
 943       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 944       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 945       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 946       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &gt;&gt; 21) &amp; 0x7F8));
 947 #else
 948       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 949       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 950       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 951       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 &lt;&lt; 3) &amp; 0x7F8));
 952 #endif /* _LITTLE_ENDIAN */
 953       dp[12] = t0;
 954       dp[13] = t1;
 955       dp[14] = t2;
 956       dp[15] = t3;
 957       dp += 16;
 958       sp = (mlib_u8 *) sa;
 959       i += 4;
 960 
 961       for (; i &lt; size; i++, sp++) {
 962         *dp++ = tab0[sp[0]];
 963         *dp++ = tab1[sp[0]];
 964         *dp++ = tab2[sp[0]];
 965         *dp++ = tab3[sp[0]];
 966       }
 967     }
 968   }
 969 }
 970 
 971 /***************************************************************/
 972 void mlib_ImageLookUpSI_S16_D64(const mlib_s16 *src,
 973                                 mlib_s32       slb,
 974                                 mlib_d64       *dst,
 975                                 mlib_s32       dlb,
 976                                 mlib_s32       xsize,
 977                                 mlib_s32       ysize,
 978                                 mlib_s32       csize,
 979                                 const mlib_d64 **table)
 980 {
 981   const mlib_d64 *table_base[4];
 982   mlib_s32 c;
 983 
 984   for (c = 0; c &lt; csize; c++) {
 985     table_base[c] = &amp;table[c][32768];
 986   }
 987 
 988   MLIB_C_IMAGELOOKUPSI(mlib_d64, mlib_s16, table_base);
 989 }
 990 
 991 /***************************************************************/
 992 void mlib_ImageLookUpSI_U16_D64(const mlib_u16 *src,
 993                                 mlib_s32       slb,
 994                                 mlib_d64       *dst,
 995                                 mlib_s32       dlb,
 996                                 mlib_s32       xsize,
 997                                 mlib_s32       ysize,
 998                                 mlib_s32       csize,
 999                                 const mlib_d64 **table)
1000 {
1001   const mlib_d64 *table_base[4];
1002   mlib_s32 c;
1003 
1004   for (c = 0; c &lt; csize; c++) {
1005     table_base[c] = &amp;table[c][0];
1006   }
1007 
1008   MLIB_C_IMAGELOOKUPSI(mlib_d64, mlib_u16, table_base);
1009 }
1010 
1011 /***************************************************************/
1012 void mlib_ImageLookUpSI_S32_D64(const mlib_s32 *src,
1013                                 mlib_s32       slb,
1014                                 mlib_d64       *dst,
1015                                 mlib_s32       dlb,
1016                                 mlib_s32       xsize,
1017                                 mlib_s32       ysize,
1018                                 mlib_s32       csize,
1019                                 const mlib_d64 **table)
1020 {
1021   const mlib_d64 *table_base[4];
1022   mlib_u32 shift = TABLE_SHIFT_S32;
1023   mlib_s32 c;
1024 
1025   for (c = 0; c &lt; csize; c++) {
1026     table_base[c] = &amp;table[c][shift];
1027   }
1028 
1029   MLIB_C_IMAGELOOKUPSI(mlib_d64, mlib_s32, table_base);
1030 }
1031 
1032 /***************************************************************/
    </pre>
  </body>
</html>
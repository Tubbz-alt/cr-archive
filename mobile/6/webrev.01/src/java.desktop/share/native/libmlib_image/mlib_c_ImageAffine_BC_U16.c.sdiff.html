<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_U16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_c_ImageAffine_BC_S16.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BL.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_U16.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE  mlib_u16
  67 
  68 #define FUN_NAME(CHAN) mlib_ImageAffine_u16_##CHAN##_bc
  69 
  70 #define FILTER_BITS   9
  71 
  72 /***************************************************************/
<span class="line-modified">  73 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  74 </span>
<span class="line-removed">  75 /***************************************************************/</span>
<span class="line-removed">  76 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  77 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  78 </span>
<span class="line-removed">  79 /***************************************************************/</span>
<span class="line-removed">  80 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  81 </span>
<span class="line-removed">  82 #define SAT_U16(DST)                                            \</span>
<span class="line-removed">  83   DST = ((mlib_s32)(val0 - (mlib_d64)0x7FFF8000) &gt;&gt; 16) ^ 0x8000</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85 #else</span>
<span class="line-removed">  86 </span>
<span class="line-removed">  87 #define SAT_U16(DST)                                            \</span>
<span class="line-removed">  88   if (val0 &gt;= MLIB_U32_MAX)                                     \</span>
<span class="line-removed">  89     DST = MLIB_U16_MAX;                                         \</span>
<span class="line-removed">  90   else if (val0 &lt;= MLIB_U32_MIN)                                \</span>
<span class="line-removed">  91     DST = MLIB_U16_MIN;                                         \</span>
<span class="line-removed">  92   else                                                          \</span>
<span class="line-removed">  93     DST = ((mlib_u32)val0) &gt;&gt; 16</span>
<span class="line-removed">  94 </span>
<span class="line-removed">  95 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97 /***************************************************************/</span>
<span class="line-removed">  98 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  99 {</span>
<span class="line-removed"> 100   DECLAREVAR_BC();</span>
<span class="line-removed"> 101   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 102   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 103 </span>
<span class="line-removed"> 104   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 105     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 106   }</span>
<span class="line-removed"> 107   else {</span>
<span class="line-removed"> 108     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 109   }</span>
<span class="line-removed"> 110 </span>
<span class="line-removed"> 111   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 112     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 113     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 114     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 115     mlib_s32 filterpos;</span>
<span class="line-removed"> 116     mlib_f32 *fptr;</span>
<span class="line-removed"> 117     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 118     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120     CLIP(1);</span>
<span class="line-removed"> 121     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 124     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     xf0 = fptr[0];</span>
<span class="line-removed"> 127     xf1 = fptr[1];</span>
<span class="line-removed"> 128     xf2 = fptr[2];</span>
<span class="line-removed"> 129     xf3 = fptr[3];</span>
<span class="line-removed"> 130 </span>
<span class="line-removed"> 131     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 132     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     yf0 = fptr[0];</span>
<span class="line-removed"> 135     yf1 = fptr[1];</span>
<span class="line-removed"> 136     yf2 = fptr[2];</span>
<span class="line-removed"> 137     yf3 = fptr[3];</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 140     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 141 </span>
<span class="line-removed"> 142     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 143     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 144     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 145     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 146     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 149     s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 150     s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 151     s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 152     s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 155 </span>
<span class="line-removed"> 156       X += dX;</span>
<span class="line-removed"> 157       Y += dY;</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 160       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 161       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 162       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 163             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 164       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 165       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 166             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 167 </span>
<span class="line-removed"> 168       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 169       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171       xf0 = fptr[0];</span>
<span class="line-removed"> 172       xf1 = fptr[1];</span>
<span class="line-removed"> 173       xf2 = fptr[2];</span>
<span class="line-removed"> 174       xf3 = fptr[3];</span>
<span class="line-removed"> 175 </span>
<span class="line-removed"> 176       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 179       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181       yf0 = fptr[0];</span>
<span class="line-removed"> 182       yf1 = fptr[1];</span>
<span class="line-removed"> 183       yf2 = fptr[2];</span>
<span class="line-removed"> 184       yf3 = fptr[3];</span>
<span class="line-removed"> 185 </span>
<span class="line-removed"> 186       SAT_U16(dstPixelPtr[0]);</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 189       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 192       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 193       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 194       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 195       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 198       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 199       s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 200       s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 201       s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 202     }</span>
<span class="line-removed"> 203 </span>
<span class="line-removed"> 204     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 205     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 206     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 207     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 208           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 209     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 210     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 211           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 214     SAT_U16(dstPixelPtr[0]);</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216 </span>
<span class="line-removed"> 217   return MLIB_SUCCESS;</span>
<span class="line-removed"> 218 }</span>
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220 /***************************************************************/</span>
<span class="line-removed"> 221 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 222 {</span>
<span class="line-removed"> 223   DECLAREVAR_BC();</span>
<span class="line-removed"> 224   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 225   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 226 </span>
<span class="line-removed"> 227   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 228     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 229   }</span>
<span class="line-removed"> 230   else {</span>
<span class="line-removed"> 231     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 232   }</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 235     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 236     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 237     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 238     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 239     mlib_f32 *fptr;</span>
<span class="line-removed"> 240     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 241     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     CLIP(2);</span>
<span class="line-removed"> 244     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 247       mlib_s32 X1 = X;</span>
<span class="line-removed"> 248       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 249       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 252       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254       xf0 = fptr[0];</span>
<span class="line-removed"> 255       xf1 = fptr[1];</span>
<span class="line-removed"> 256       xf2 = fptr[2];</span>
<span class="line-removed"> 257       xf3 = fptr[3];</span>
<span class="line-removed"> 258 </span>
<span class="line-removed"> 259       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 260       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 261 </span>
<span class="line-removed"> 262       yf0 = fptr[0];</span>
<span class="line-removed"> 263       yf1 = fptr[1];</span>
<span class="line-removed"> 264       yf2 = fptr[2];</span>
<span class="line-removed"> 265       yf3 = fptr[3];</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 268       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 271       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 272       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 273       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 274       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 277       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 278       s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 279       s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 280       s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 283 </span>
<span class="line-removed"> 284         X1 += dX;</span>
<span class="line-removed"> 285         Y1 += dY;</span>
<span class="line-removed"> 286 </span>
<span class="line-removed"> 287         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 288         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 289         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 290         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 291               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 292         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 293         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 294               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 297         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299         xf0 = fptr[0];</span>
<span class="line-removed"> 300         xf1 = fptr[1];</span>
<span class="line-removed"> 301         xf2 = fptr[2];</span>
<span class="line-removed"> 302         xf3 = fptr[3];</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 307         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309         yf0 = fptr[0];</span>
<span class="line-removed"> 310         yf1 = fptr[1];</span>
<span class="line-removed"> 311         yf2 = fptr[2];</span>
<span class="line-removed"> 312         yf3 = fptr[3];</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 317         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 318 </span>
<span class="line-removed"> 319         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 320         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 321         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 322         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 323         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 326         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 327         s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 328         s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 329         s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 330       }</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 333       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 334       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 335       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 336             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 337       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 338       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 339             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 340 </span>
<span class="line-removed"> 341       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 342       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344   }</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346   return MLIB_SUCCESS;</span>
<span class="line-removed"> 347 }</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349 /***************************************************************/</span>
<span class="line-removed"> 350 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 351 {</span>
<span class="line-removed"> 352   DECLAREVAR_BC();</span>
<span class="line-removed"> 353   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 354   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 357     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 358   }</span>
<span class="line-removed"> 359   else {</span>
<span class="line-removed"> 360     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 361   }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 364     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 365     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 366     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 367     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 368     mlib_f32 *fptr;</span>
<span class="line-removed"> 369     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 370     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372     CLIP(3);</span>
<span class="line-removed"> 373     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 374 </span>
<span class="line-removed"> 375     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 376       mlib_s32 X1 = X;</span>
<span class="line-removed"> 377       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 378       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 381       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383       xf0 = fptr[0];</span>
<span class="line-removed"> 384       xf1 = fptr[1];</span>
<span class="line-removed"> 385       xf2 = fptr[2];</span>
<span class="line-removed"> 386       xf3 = fptr[3];</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 389       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 390 </span>
<span class="line-removed"> 391       yf0 = fptr[0];</span>
<span class="line-removed"> 392       yf1 = fptr[1];</span>
<span class="line-removed"> 393       yf2 = fptr[2];</span>
<span class="line-removed"> 394       yf3 = fptr[3];</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 397       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 400       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 401       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 402       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 403       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 404 </span>
<span class="line-removed"> 405       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 406       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 407       s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 408       s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 409       s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 410 </span>
<span class="line-removed"> 411       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 412 </span>
<span class="line-removed"> 413         X1 += dX;</span>
<span class="line-removed"> 414         Y1 += dY;</span>
<span class="line-removed"> 415 </span>
<span class="line-removed"> 416         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 417         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 418         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 419         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 420               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 421         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 422         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 423               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 424 </span>
<span class="line-removed"> 425         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 426         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         xf0 = fptr[0];</span>
<span class="line-removed"> 429         xf1 = fptr[1];</span>
<span class="line-removed"> 430         xf2 = fptr[2];</span>
<span class="line-removed"> 431         xf3 = fptr[3];</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 434 </span>
<span class="line-removed"> 435         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 436         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         yf0 = fptr[0];</span>
<span class="line-removed"> 439         yf1 = fptr[1];</span>
<span class="line-removed"> 440         yf2 = fptr[2];</span>
<span class="line-removed"> 441         yf3 = fptr[3];</span>
<span class="line-removed"> 442 </span>
<span class="line-removed"> 443         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 444 </span>
<span class="line-removed"> 445         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 446         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 449         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 450         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 451         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 452         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 455         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 456         s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 457         s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 458         s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 459       }</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 462       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 463       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 464       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 465             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 466       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 467       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 468             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 469 </span>
<span class="line-removed"> 470       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 471       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 472     }</span>
<span class="line-removed"> 473   }</span>
<span class="line-removed"> 474 </span>
<span class="line-removed"> 475   return MLIB_SUCCESS;</span>
<span class="line-removed"> 476 }</span>
<span class="line-removed"> 477 </span>
<span class="line-removed"> 478 /***************************************************************/</span>
<span class="line-removed"> 479 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 480 {</span>
<span class="line-removed"> 481   DECLAREVAR_BC();</span>
<span class="line-removed"> 482   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 483   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 484 </span>
<span class="line-removed"> 485   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 486     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 487   }</span>
<span class="line-removed"> 488   else {</span>
<span class="line-removed"> 489     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 490   }</span>
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 493     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 494     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 495     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 496     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 497     mlib_f32 *fptr;</span>
<span class="line-removed"> 498     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 499     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     CLIP(4);</span>
<span class="line-removed"> 502     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 505       mlib_s32 X1 = X;</span>
<span class="line-removed"> 506       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 507       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 510       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       xf0 = fptr[0];</span>
<span class="line-removed"> 513       xf1 = fptr[1];</span>
<span class="line-removed"> 514       xf2 = fptr[2];</span>
<span class="line-removed"> 515       xf3 = fptr[3];</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 518       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520       yf0 = fptr[0];</span>
<span class="line-removed"> 521       yf1 = fptr[1];</span>
<span class="line-removed"> 522       yf2 = fptr[2];</span>
<span class="line-removed"> 523       yf3 = fptr[3];</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 526       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 529       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 530       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 531       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 532       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 535       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 536       s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 537       s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 538       s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542         X1 += dX;</span>
<span class="line-removed"> 543         Y1 += dY;</span>
<span class="line-removed"> 544 </span>
<span class="line-removed"> 545         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 546         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 547         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 548         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 549               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 550         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 551         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 552               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 555         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557         xf0 = fptr[0];</span>
<span class="line-removed"> 558         xf1 = fptr[1];</span>
<span class="line-removed"> 559         xf2 = fptr[2];</span>
<span class="line-removed"> 560         xf3 = fptr[3];</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 565         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 566 </span>
<span class="line-removed"> 567         yf0 = fptr[0];</span>
<span class="line-removed"> 568         yf1 = fptr[1];</span>
<span class="line-removed"> 569         yf2 = fptr[2];</span>
<span class="line-removed"> 570         yf3 = fptr[3];</span>
<span class="line-removed"> 571 </span>
<span class="line-removed"> 572         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 575         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 578         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 579         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 580         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 581         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 584         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 585         s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 586         s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 587         s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 588       }</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 591       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 592       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 593       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 594             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 595       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 596       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 597             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 600       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 601     }</span>
<span class="line-removed"> 602   }</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604   return MLIB_SUCCESS;</span>
<span class="line-removed"> 605 }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607 #else       /* for x86, using integer multiplies is faster */</span>
 608 
 609 #define SHIFT_X  15
 610 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 611 
 612 #define SHIFT_Y  14
 613 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 614 
 615 #define S32_TO_U16_SAT(DST)                                     \
 616   if (val0 &gt;= MLIB_U16_MAX)                                     \
 617     DST = MLIB_U16_MAX;                                         \
 618   else if (val0 &lt;= MLIB_U16_MIN)                                \
 619     DST = MLIB_U16_MIN;                                         \
 620   else                                                          \
 621     DST = (mlib_u16)val0
 622 
 623 /***************************************************************/
 624 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
 625 {
 626   DECLAREVAR_BC();
 627   DTYPE *dstLineEnd;
</pre>
<hr />
<pre>
1113         s7 = srcPixelPtr[12];
1114       }
1115 
1116       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1117       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1118       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1119       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1120             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1121       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1122       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1123             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1124 
1125       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1126       S32_TO_U16_SAT(dPtr[0]);
1127     }
1128   }
1129 
1130   return MLIB_SUCCESS;
1131 }
1132 
<span class="line-removed">1133 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1134 </span>
1135 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE  mlib_u16
  67 
  68 #define FUN_NAME(CHAN) mlib_ImageAffine_u16_##CHAN##_bc
  69 
  70 #define FILTER_BITS   9
  71 
  72 /***************************************************************/
<span class="line-modified">  73 /* for x86, using integer multiplies is faster */</span>






















































































































































































































































































































































































































































































































































  74 
  75 #define SHIFT_X  15
  76 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
  77 
  78 #define SHIFT_Y  14
  79 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
  80 
  81 #define S32_TO_U16_SAT(DST)                                     \
  82   if (val0 &gt;= MLIB_U16_MAX)                                     \
  83     DST = MLIB_U16_MAX;                                         \
  84   else if (val0 &lt;= MLIB_U16_MIN)                                \
  85     DST = MLIB_U16_MIN;                                         \
  86   else                                                          \
  87     DST = (mlib_u16)val0
  88 
  89 /***************************************************************/
  90 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
  91 {
  92   DECLAREVAR_BC();
  93   DTYPE *dstLineEnd;
</pre>
<hr />
<pre>
 579         s7 = srcPixelPtr[12];
 580       }
 581 
 582       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 583       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 584       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 585       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 586             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 587       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 588       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 589             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 590 
 591       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 592       S32_TO_U16_SAT(dPtr[0]);
 593     }
 594   }
 595 
 596   return MLIB_SUCCESS;
 597 }
 598 


 599 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_c_ImageAffine_BC_S16.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BL.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_ImageConv_16ext.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_ImageConvMxN_ext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_16nw.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_ImageConv_16ext.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 162 /***************************************************************/
 163 typedef union {
 164   mlib_d64 d64;
 165   struct {
 166     mlib_s32 i0;
 167     mlib_s32 i1;
 168   } i32s;
 169 } d64_2x32;
 170 
 171 /***************************************************************/
 172 #define GET_SRC_DST_PARAMETERS(type)                            \
 173   hgt = mlib_ImageGetHeight(src);                               \
 174   wid = mlib_ImageGetWidth(src);                                \
 175   nchannel = mlib_ImageGetChannels(src);                        \
 176   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 177   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 178   adr_src = (type *)mlib_ImageGetData(src);                     \
 179   adr_dst = (type *)mlib_ImageGetData(dst)
 180 
 181 /***************************************************************/
<span class="line-removed"> 182 #ifndef __sparc</span>
 183 #if IMG_TYPE == 1
 184 
 185 /*
 186  * Test for the presence of any &quot;1&quot; bit in bits
 187    8 to 31 of val. If present, then val is either
 188    negative or &gt;255. If over/underflows of 8 bits
 189    are uncommon, then this technique can be a win,
 190    since only a single test, rather than two, is
 191    necessary to determine if clamping is needed.
 192    On the other hand, if over/underflows are common,
 193    it adds an extra test.
 194 */
 195 #define CLAMP_STORE(dst, val)                                   \
 196   if (val &amp; 0xffffff00) {                                       \
 197     if (val &lt; MLIB_U8_MIN)                                      \
 198       dst = MLIB_U8_MIN;                                        \
 199     else                                                        \
 200       dst = MLIB_U8_MAX;                                        \
 201   } else {                                                      \
 202     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 206 
 207 #define CLAMP_STORE(dst, val)                                   \
 208   if (val &gt;= MLIB_S16_MAX)                                      \
 209     dst = MLIB_S16_MAX;                                         \
 210   else if (val &lt;= MLIB_S16_MIN)                                 \
 211     dst = MLIB_S16_MIN;                                         \
 212   else                                                          \
 213     dst = (mlib_s16)val
 214 
 215 #elif IMG_TYPE == 3
 216 
 217 #define CLAMP_STORE(dst, val)                                   \
 218   if (val &gt;= MLIB_U16_MAX)                                      \
 219     dst = MLIB_U16_MAX;                                         \
 220   else if (val &lt;= MLIB_U16_MIN)                                 \
 221     dst = MLIB_U16_MIN;                                         \
 222   else                                                          \
 223     dst = (mlib_u16)val
 224 
 225 #endif /* IMG_TYPE == 1 */
<span class="line-removed"> 226 #endif /* __sparc */</span>
 227 
 228 /***************************************************************/
 229 #define MAX_KER   7
 230 #define MAX_N    15
 231 #define BUFF_SIZE   1600
 232 #define CACHE_SIZE  (64*1024)
 233 
 234 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 235                                          const mlib_image *src,
 236                                          const mlib_d64   *k,
 237                                          mlib_s32         n,
 238                                          mlib_s32         dy_t,
 239                                          mlib_s32         dy_b,
 240                                          mlib_s32         cmask)
 241 {
 242   DTYPE    *adr_src, *sl;
 243   DTYPE    *adr_dst, *dl, *dp;
 244   FTYPE    buff[BUFF_SIZE];
 245   FTYPE    *buffd;
 246   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 274 
 275   sbuff = pbuff;
 276   buffd = sbuff + smax_hsize;
 277 
 278   shgt -= (dy_t + dy_b);
 279   k_off = 0;
 280 
 281   for (l = 0; l &lt; hgt; l += hsize) {
 282     hsize = hgt - l;
 283 
 284     if (hsize &gt; max_hsize) hsize = max_hsize;
 285 
 286     smax_hsize = hsize + (n - 1);
 287 
 288     for (c = 0; c &lt; nchannel; c++) {
 289       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 290 
 291       sl = adr_src + c;
 292       dl = adr_dst + c;
 293 
<span class="line-removed"> 294 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 295 #pragma pipeloop(0)</span>
<span class="line-removed"> 296 #endif /* __SUNPRO_C */</span>
 297       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 298 
 299       for (j = 0; j &lt; wid; j++) {
 300         FTYPE    *buff = sbuff;
 301 
 302         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 303           sbuff[i - k_off] = (FTYPE)sl[0];
 304         }
 305 
<span class="line-removed"> 306 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 307 #pragma pipeloop(0)</span>
<span class="line-removed"> 308 #endif /* __SUNPRO_C */</span>
 309         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 310           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 311         }
 312 
 313         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 314           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 315         }
 316 
 317         pk = k;
 318 
 319         for (off = 0; off &lt; (n - 4); off += 4) {
 320 
 321           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 322           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 323 
<span class="line-removed"> 324 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 325 #pragma pipeloop(0)</span>
<span class="line-removed"> 326 #endif /* __SUNPRO_C */</span>
 327           for (i = 0; i &lt; hsize; i += 2) {
 328             p0 = p2; p1 = p3; p2 = p4;
 329 
 330             p3 = buff[i + 3]; p4 = buff[i + 4];
 331 
 332             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 333             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 334           }
 335 
 336           pk += 4;
 337           buff += 4;
 338         }
 339 
 340         dp = dl;
 341         kh = n - off;
 342 
 343         if (kh == 4) {
 344           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 345           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 346 
<span class="line-removed"> 347 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 348 #pragma pipeloop(0)</span>
<span class="line-removed"> 349 #endif /* __SUNPRO_C */</span>
 350           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 351             p0 = p2; p1 = p3; p2 = p4;
 352 
 353             p3 = buff[i + 3]; p4 = buff[i + 4];
 354 
 355             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 356             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 357 
 358             dp[0  ] = FROM_S32(d0);
 359             dp[dll] = FROM_S32(d1);
 360 
 361             buffd[i    ] = 0.0;
 362             buffd[i + 1] = 0.0;
 363 
 364             dp += 2*dll;
 365           }
 366 
 367           if (i &lt; hsize) {
 368             p0 = p2; p1 = p3; p2 = p4;
 369             p3 = buff[i + 3];
 370             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 371             dp[0] = FROM_S32(d0);
 372             buffd[i] = 0.0;
 373           }
 374 
 375         } else if (kh == 3) {
 376 
 377           p2 = buff[0]; p3 = buff[1];
 378           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 379 
<span class="line-removed"> 380 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 381 #pragma pipeloop(0)</span>
<span class="line-removed"> 382 #endif /* __SUNPRO_C */</span>
 383           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 384             p0 = p2; p1 = p3;
 385 
 386             p2 = buff[i + 2]; p3 = buff[i + 3];
 387 
 388             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 389             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 390 
 391             dp[0  ] = FROM_S32(d0);
 392             dp[dll] = FROM_S32(d1);
 393 
 394             buffd[i    ] = 0.0;
 395             buffd[i + 1] = 0.0;
 396 
 397             dp += 2*dll;
 398           }
 399 
 400           if (i &lt; hsize) {
 401             p0 = p2; p1 = p3;
 402             p2 = buff[i + 2];
 403             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 404             dp[0] = FROM_S32(d0);
 405 
 406             buffd[i] = 0.0;
 407           }
 408 
 409         } else if (kh == 2) {
 410 
 411           p2 = buff[0];
 412           k0 = pk[0]; k1 = pk[1];
 413 
<span class="line-removed"> 414 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 415 #pragma pipeloop(0)</span>
<span class="line-removed"> 416 #endif /* __SUNPRO_C */</span>
 417           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 418             p0 = p2;
 419 
 420             p1 = buff[i + 1]; p2 = buff[i + 2];
 421 
 422             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 423             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 424 
 425             dp[0  ] = FROM_S32(d0);
 426             dp[dll] = FROM_S32(d1);
 427 
 428             buffd[i    ] = 0.0;
 429             buffd[i + 1] = 0.0;
 430 
 431             dp += 2*dll;
 432           }
 433 
 434           if (i &lt; hsize) {
 435             p0 = p2;
 436             p1 = buff[i + 1];
 437             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 438             dp[0] = FROM_S32(d0);
 439 
 440             buffd[i] = 0.0;
 441           }
 442 
 443         } else /* kh == 1 */{
 444 
 445           k0 = pk[0];
 446 
<span class="line-removed"> 447 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 448 #pragma pipeloop(0)</span>
<span class="line-removed"> 449 #endif /* __SUNPRO_C */</span>
 450           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 451             p0 = buff[i]; p1 = buff[i + 1];
 452 
 453             d0 = D2I(p0*k0 + buffd[i    ]);
 454             d1 = D2I(p1*k0 + buffd[i + 1]);
 455 
 456             dp[0  ] = FROM_S32(d0);
 457             dp[dll] = FROM_S32(d1);
 458 
 459             buffd[i    ] = 0.0;
 460             buffd[i + 1] = 0.0;
 461 
 462             dp += 2*dll;
 463           }
 464 
 465           if (i &lt; hsize) {
 466             p0 = buff[i];
 467             d0 = D2I(p0*k0 + buffd[i]);
 468             dp[0] = FROM_S32(d0);
 469 
</pre>
<hr />
<pre>
 552   buffi = (mlib_s32*)(buffd + swid);
 553 
 554   chan1 = nchannel;
 555   chan2 = chan1 + chan1;
 556 
 557   swid -= (dx_l + dx_r);
 558 
 559   for (c = 0; c &lt; nchannel; c++) {
 560     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 561 
 562     sl = adr_src + c;
 563     dl = adr_dst + c;
 564 
 565     for (l = 0; l &lt; n; l++) {
 566       FTYPE    *buff = buffs[l];
 567 
 568       for (i = 0; i &lt; dx_l; i++) {
 569         buff[i] = (FTYPE)sl[0];
 570       }
 571 
<span class="line-removed"> 572 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 573 #pragma pipeloop(0)</span>
<span class="line-removed"> 574 #endif /* __SUNPRO_C */</span>
 575       for (i = 0; i &lt; swid; i++) {
 576         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 577       }
 578 
 579       for (i = 0; i &lt; dx_r; i++) {
 580         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 581       }
 582 
 583       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 584     }
 585 
 586     buff_ind = 0;
 587 
<span class="line-removed"> 588 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 589 #pragma pipeloop(0)</span>
<span class="line-removed"> 590 #endif /* __SUNPRO_C */</span>
 591     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 592 
 593     for (j = 0; j &lt; hgt; j++) {
 594       FTYPE    **buffc = buffs + buff_ind;
 595       FTYPE    *buffn = buffc[n];
 596       FTYPE    *pk = k;
 597 
 598       for (l = 0; l &lt; n; l++) {
 599         FTYPE    *buff_l = buffc[l];
 600 
 601         for (off = 0; off &lt; m;) {
 602           FTYPE    *buff = buff_l + off;
 603 
 604           kw = m - off;
 605 
 606           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 607             if (kw &gt; MAX_KER) kw = kw/2;
 608           off += kw;
 609 
 610           sp = sl;
 611           dp = dl;
 612 
 613           if (kw == 7) {
 614 
 615             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 616             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 617 
 618             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 619             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 620 
 621             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 622 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 623 #pragma pipeloop(0)</span>
<span class="line-removed"> 624 #endif /* __SUNPRO_C */</span>
 625               for (i = 0; i &lt;= (wid - 2); i += 2) {
 626                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 627 
 628                 p6 = buff[i + 6]; p7 = buff[i + 7];
 629 
 630                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 631                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 632               }
 633 
 634             } else {
<span class="line-removed"> 635 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 636 #pragma pipeloop(0)</span>
<span class="line-removed"> 637 #endif /* __SUNPRO_C */</span>
 638               for (i = 0; i &lt;= (wid - 2); i += 2) {
 639                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 640 
 641                 p6 = buff[i + 6]; p7 = buff[i + 7];
 642 
 643                 LOAD_BUFF(buffi);
 644 
 645                 dd.d64 = *(FTYPE   *)(buffi + i);
 646                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 647                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 648 
 649                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 650                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 651 
 652                 dp[0    ] = FROM_S32(d0);
 653                 dp[chan1] = FROM_S32(d1);
 654 
 655                 buffd[i    ] = 0.0;
 656                 buffd[i + 1] = 0.0;
 657 
 658                 sp += chan2;
 659                 dp += chan2;
 660               }
 661             }
 662 
 663           } else if (kw == 6) {
 664 
 665             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 666             p5 = buff[3]; p6 = buff[4];
 667 
 668             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 669             k4 = pk[4]; k5 = pk[5];
 670 
 671             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 672 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 673 #pragma pipeloop(0)</span>
<span class="line-removed"> 674 #endif /* __SUNPRO_C */</span>
 675               for (i = 0; i &lt;= (wid - 2); i += 2) {
 676                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 677 
 678                 p5 = buff[i + 5]; p6 = buff[i + 6];
 679 
 680                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 681                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 682               }
 683 
 684             } else {
<span class="line-removed"> 685 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 686 #pragma pipeloop(0)</span>
<span class="line-removed"> 687 #endif /* __SUNPRO_C */</span>
 688               for (i = 0; i &lt;= (wid - 2); i += 2) {
 689                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 690 
 691                 p5 = buff[i + 5]; p6 = buff[i + 6];
 692 
 693                 LOAD_BUFF(buffi);
 694 
 695                 dd.d64 = *(FTYPE   *)(buffi + i);
 696                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 697                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 698 
 699                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 700                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 701 
 702                 dp[0    ] = FROM_S32(d0);
 703                 dp[chan1] = FROM_S32(d1);
 704 
 705                 buffd[i    ] = 0.0;
 706                 buffd[i + 1] = 0.0;
 707 
 708                 sp += chan2;
 709                 dp += chan2;
 710               }
 711             }
 712 
 713           } else if (kw == 5) {
 714 
 715             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 716             p5 = buff[3];
 717 
 718             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 719             k4 = pk[4];
 720 
 721             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 722 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 723 #pragma pipeloop(0)</span>
<span class="line-removed"> 724 #endif /* __SUNPRO_C */</span>
 725               for (i = 0; i &lt;= (wid - 2); i += 2) {
 726                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 727 
 728                 p4 = buff[i + 4]; p5 = buff[i + 5];
 729 
 730                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 731                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 732               }
 733 
 734             } else {
<span class="line-removed"> 735 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 736 #pragma pipeloop(0)</span>
<span class="line-removed"> 737 #endif /* __SUNPRO_C */</span>
 738               for (i = 0; i &lt;= (wid - 2); i += 2) {
 739                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 740 
 741                 p4 = buff[i + 4]; p5 = buff[i + 5];
 742 
 743                 LOAD_BUFF(buffi);
 744 
 745                 dd.d64 = *(FTYPE   *)(buffi + i);
 746                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 747                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 748 
 749                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 750                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 751 
 752                 dp[0    ] = FROM_S32(d0);
 753                 dp[chan1] = FROM_S32(d1);
 754 
 755                 buffd[i    ] = 0.0;
 756                 buffd[i + 1] = 0.0;
 757 
 758                 sp += chan2;
 759                 dp += chan2;
 760               }
 761             }
 762 
 763           } else if (kw == 4) {
 764 
 765             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 766 
 767             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 768 
 769             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 770 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 771 #pragma pipeloop(0)</span>
<span class="line-removed"> 772 #endif /* __SUNPRO_C */</span>
 773               for (i = 0; i &lt;= (wid - 2); i += 2) {
 774                 p0 = p2; p1 = p3; p2 = p4;
 775 
 776                 p3 = buff[i + 3]; p4 = buff[i + 4];
 777 
 778                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 779                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 780               }
 781 
 782             } else {
<span class="line-removed"> 783 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 784 #pragma pipeloop(0)</span>
<span class="line-removed"> 785 #endif /* __SUNPRO_C */</span>
 786               for (i = 0; i &lt;= (wid - 2); i += 2) {
 787                 p0 = p2; p1 = p3; p2 = p4;
 788 
 789                 p3 = buff[i + 3]; p4 = buff[i + 4];
 790 
 791                 LOAD_BUFF(buffi);
 792 
 793                 dd.d64 = *(FTYPE   *)(buffi + i);
 794                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 795                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 796 
 797                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 798                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 799 
 800                 dp[0    ] = FROM_S32(d0);
 801                 dp[chan1] = FROM_S32(d1);
 802 
 803                 buffd[i    ] = 0.0;
 804                 buffd[i + 1] = 0.0;
 805 
 806                 sp += chan2;
 807                 dp += chan2;
 808               }
 809             }
 810 
 811           } else if (kw == 3) {
 812 
 813             p2 = buff[0]; p3 = buff[1];
 814             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 815 
 816             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 817 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 818 #pragma pipeloop(0)</span>
<span class="line-removed"> 819 #endif /* __SUNPRO_C */</span>
 820               for (i = 0; i &lt;= (wid - 2); i += 2) {
 821                 p0 = p2; p1 = p3;
 822 
 823                 p2 = buff[i + 2]; p3 = buff[i + 3];
 824 
 825                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 826                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 827               }
 828 
 829             } else {
<span class="line-removed"> 830 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 831 #pragma pipeloop(0)</span>
<span class="line-removed"> 832 #endif /* __SUNPRO_C */</span>
 833               for (i = 0; i &lt;= (wid - 2); i += 2) {
 834                 p0 = p2; p1 = p3;
 835 
 836                 p2 = buff[i + 2]; p3 = buff[i + 3];
 837 
 838                 LOAD_BUFF(buffi);
 839 
 840                 dd.d64 = *(FTYPE   *)(buffi + i);
 841                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 842                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 843 
 844                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 845                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 846 
 847                 dp[0    ] = FROM_S32(d0);
 848                 dp[chan1] = FROM_S32(d1);
 849 
 850                 buffd[i    ] = 0.0;
 851                 buffd[i + 1] = 0.0;
 852 
 853                 sp += chan2;
 854                 dp += chan2;
 855               }
 856             }
 857 
 858           } else /* if (kw == 2) */ {
 859 
 860             p2 = buff[0];
 861             k0 = pk[0]; k1 = pk[1];
 862 
 863             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 864 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 865 #pragma pipeloop(0)</span>
<span class="line-removed"> 866 #endif /* __SUNPRO_C */</span>
 867               for (i = 0; i &lt;= (wid - 2); i += 2) {
 868                 p0 = p2;
 869 
 870                 p1 = buff[i + 1]; p2 = buff[i + 2];
 871 
 872                 buffd[i    ] += p0*k0 + p1*k1;
 873                 buffd[i + 1] += p1*k0 + p2*k1;
 874               }
 875 
 876             } else {
<span class="line-removed"> 877 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 878 #pragma pipeloop(0)</span>
<span class="line-removed"> 879 #endif /* __SUNPRO_C */</span>
 880               for (i = 0; i &lt;= (wid - 2); i += 2) {
 881                 p0 = p2;
 882 
 883                 p1 = buff[i + 1]; p2 = buff[i + 2];
 884 
 885                 LOAD_BUFF(buffi);
 886 
 887                 dd.d64 = *(FTYPE   *)(buffi + i);
 888                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 889                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 890 
 891                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 892                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 893 
 894                 dp[0    ] = FROM_S32(d0);
 895                 dp[chan1] = FROM_S32(d1);
 896 
 897                 buffd[i    ] = 0.0;
 898                 buffd[i + 1] = 0.0;
 899 
</pre>
<hr />
<pre>
 933       }
 934 
 935       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 936       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 937 
 938       /* next line */
 939 
 940       if (j &lt; hgt - dy_b - 2) sl += sll;
 941       dl += dll;
 942 
 943       buff_ind++;
 944 
 945       if (buff_ind &gt;= n + 1) buff_ind = 0;
 946     }
 947   }
 948 
 949   FREE_AND_RETURN_STATUS;
 950 }
 951 
 952 /***************************************************************/
<span class="line-modified"> 953 #ifndef __sparc /* for x86, using integer multiplies is faster */</span>
 954 
 955 #define STORE_RES(res, x)                                       \
 956   x &gt;&gt;= shift2;                                                 \
 957   CLAMP_STORE(res, x)
 958 
 959 mlib_status CONV_FUNC_MxN_I
 960 {
 961   DTYPE    *adr_src, *sl, *sp = NULL;
 962   DTYPE    *adr_dst, *dl, *dp = NULL;
 963   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 964   mlib_s32 *pbuff = buff;
 965   mlib_s32 **buffs = buffs_arr, *buffd;
 966   mlib_s32 l, off, kw, bsize, buff_ind;
 967   mlib_s32 d0, d1, shift1, shift2;
 968   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 969   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 970   mlib_s32 wid, hgt, sll, dll;
 971   mlib_s32 nchannel, chan1;
 972   mlib_s32 i, j, c, swid;
 973   mlib_s32 chan2;
</pre>
<hr />
<pre>
1010 
1011   for (i = 0; i &lt; m*n; i++) {
1012     k[i] = kernel[i] &gt;&gt; shift1;
1013   }
1014 
1015   swid -= (dx_l + dx_r);
1016 
1017   for (c = 0; c &lt; nchannel; c++) {
1018     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
1019 
1020     sl = adr_src + c;
1021     dl = adr_dst + c;
1022 
1023     for (l = 0; l &lt; n; l++) {
1024       mlib_s32  *buff = buffs[l];
1025 
1026       for (i = 0; i &lt; dx_l; i++) {
1027         buff[i] = (mlib_s32)sl[0];
1028       }
1029 
<span class="line-removed">1030 #ifdef __SUNPRO_C</span>
<span class="line-removed">1031 #pragma pipeloop(0)</span>
<span class="line-removed">1032 #endif /* __SUNPRO_C */</span>
1033       for (i = 0; i &lt; swid; i++) {
1034         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
1035       }
1036 
1037       for (i = 0; i &lt; dx_r; i++) {
1038         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
1039       }
1040 
1041       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
1042     }
1043 
1044     buff_ind = 0;
1045 
<span class="line-removed">1046 #ifdef __SUNPRO_C</span>
<span class="line-removed">1047 #pragma pipeloop(0)</span>
<span class="line-removed">1048 #endif /* __SUNPRO_C */</span>
1049     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
1050 
1051     for (j = 0; j &lt; hgt; j++) {
1052       mlib_s32 **buffc = buffs + buff_ind;
1053       mlib_s32 *buffn = buffc[n];
1054       mlib_s32 *pk = k;
1055 
1056       for (l = 0; l &lt; n; l++) {
1057         mlib_s32  *buff_l = buffc[l];
1058 
1059         for (off = 0; off &lt; m;) {
1060           mlib_s32 *buff = buff_l + off;
1061 
1062           sp = sl;
1063           dp = dl;
1064 
1065           kw = m - off;
1066 
1067           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
1068             if (kw &gt; MAX_KER) kw = kw/2;
1069           off += kw;
1070 
1071           if (kw == 7) {
1072 
1073             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1074             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
1075 
1076             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1077             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
1078 
1079             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1080 #ifdef __SUNPRO_C</span>
<span class="line-removed">1081 #pragma pipeloop(0)</span>
<span class="line-removed">1082 #endif /* __SUNPRO_C */</span>
1083               for (i = 0; i &lt;= (wid - 2); i += 2) {
1084                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1085 
1086                 p6 = buff[i + 6]; p7 = buff[i + 7];
1087 
1088                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1089                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1090               }
1091 
1092             } else {
<span class="line-removed">1093 #ifdef __SUNPRO_C</span>
<span class="line-removed">1094 #pragma pipeloop(0)</span>
<span class="line-removed">1095 #endif /* __SUNPRO_C */</span>
1096               for (i = 0; i &lt;= (wid - 2); i += 2) {
1097                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1098 
1099                 p6 = buff[i + 6]; p7 = buff[i + 7];
1100 
1101                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1102                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1103 
1104                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1105                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1106 
1107                 STORE_RES(dp[0    ], d0);
1108                 STORE_RES(dp[chan1], d1);
1109 
1110                 buffd[i    ] = 0;
1111                 buffd[i + 1] = 0;
1112 
1113                 sp += chan2;
1114                 dp += chan2;
1115               }
1116             }
1117 
1118           } else if (kw == 6) {
1119 
1120             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1121             p5 = buff[3]; p6 = buff[4];
1122 
1123             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1124             k4 = pk[4]; k5 = pk[5];
1125 
1126             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1127 #ifdef __SUNPRO_C</span>
<span class="line-removed">1128 #pragma pipeloop(0)</span>
<span class="line-removed">1129 #endif /* __SUNPRO_C */</span>
1130               for (i = 0; i &lt;= (wid - 2); i += 2) {
1131                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1132 
1133                 p5 = buff[i + 5]; p6 = buff[i + 6];
1134 
1135                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1136                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1137               }
1138 
1139             } else {
<span class="line-removed">1140 #ifdef __SUNPRO_C</span>
<span class="line-removed">1141 #pragma pipeloop(0)</span>
<span class="line-removed">1142 #endif /* __SUNPRO_C */</span>
1143               for (i = 0; i &lt;= (wid - 2); i += 2) {
1144                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1145 
1146                 p5 = buff[i + 5]; p6 = buff[i + 6];
1147 
1148                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1149                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1150 
1151                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1152                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1153 
1154                 STORE_RES(dp[0    ], d0);
1155                 STORE_RES(dp[chan1], d1);
1156 
1157                 buffd[i    ] = 0;
1158                 buffd[i + 1] = 0;
1159 
1160                 sp += chan2;
1161                 dp += chan2;
1162               }
1163             }
1164 
1165           } else if (kw == 5) {
1166 
1167             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1168             p5 = buff[3];
1169 
1170             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1171             k4 = pk[4];
1172 
1173             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1174 #ifdef __SUNPRO_C</span>
<span class="line-removed">1175 #pragma pipeloop(0)</span>
<span class="line-removed">1176 #endif /* __SUNPRO_C */</span>
1177               for (i = 0; i &lt;= (wid - 2); i += 2) {
1178                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1179 
1180                 p4 = buff[i + 4]; p5 = buff[i + 5];
1181 
1182                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1183                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1184               }
1185 
1186             } else {
<span class="line-removed">1187 #ifdef __SUNPRO_C</span>
<span class="line-removed">1188 #pragma pipeloop(0)</span>
<span class="line-removed">1189 #endif /* __SUNPRO_C */</span>
1190               for (i = 0; i &lt;= (wid - 2); i += 2) {
1191                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1192 
1193                 p4 = buff[i + 4]; p5 = buff[i + 5];
1194 
1195                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1196                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1197 
1198                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1199                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1200 
1201                 STORE_RES(dp[0    ], d0);
1202                 STORE_RES(dp[chan1], d1);
1203 
1204                 buffd[i    ] = 0;
1205                 buffd[i + 1] = 0;
1206 
1207                 sp += chan2;
1208                 dp += chan2;
1209               }
1210             }
1211 
1212           } else if (kw == 4) {
1213 
1214             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1215 
1216             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1217 
1218             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1219 #ifdef __SUNPRO_C</span>
<span class="line-removed">1220 #pragma pipeloop(0)</span>
<span class="line-removed">1221 #endif /* __SUNPRO_C */</span>
1222               for (i = 0; i &lt;= (wid - 2); i += 2) {
1223                 p0 = p2; p1 = p3; p2 = p4;
1224 
1225                 p3 = buff[i + 3]; p4 = buff[i + 4];
1226 
1227                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1228                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1229               }
1230 
1231             } else {
<span class="line-removed">1232 #ifdef __SUNPRO_C</span>
<span class="line-removed">1233 #pragma pipeloop(0)</span>
<span class="line-removed">1234 #endif /* __SUNPRO_C */</span>
1235               for (i = 0; i &lt;= (wid - 2); i += 2) {
1236                 p0 = p2; p1 = p3; p2 = p4;
1237 
1238                 p3 = buff[i + 3]; p4 = buff[i + 4];
1239 
1240                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1241                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1242 
1243                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1244                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1245 
1246                 STORE_RES(dp[0    ], d0);
1247                 STORE_RES(dp[chan1], d1);
1248 
1249                 buffd[i    ] = 0;
1250                 buffd[i + 1] = 0;
1251 
1252                 sp += chan2;
1253                 dp += chan2;
1254               }
1255             }
1256 
1257           } else if (kw == 3) {
1258 
1259             p2 = buff[0]; p3 = buff[1];
1260             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1261 
1262             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1263 #ifdef __SUNPRO_C</span>
<span class="line-removed">1264 #pragma pipeloop(0)</span>
<span class="line-removed">1265 #endif /* __SUNPRO_C */</span>
1266               for (i = 0; i &lt;= (wid - 2); i += 2) {
1267                 p0 = p2; p1 = p3;
1268 
1269                 p2 = buff[i + 2]; p3 = buff[i + 3];
1270 
1271                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1272                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1273               }
1274 
1275             } else {
<span class="line-removed">1276 #ifdef __SUNPRO_C</span>
<span class="line-removed">1277 #pragma pipeloop(0)</span>
<span class="line-removed">1278 #endif /* __SUNPRO_C */</span>
1279               for (i = 0; i &lt;= (wid - 2); i += 2) {
1280                 p0 = p2; p1 = p3;
1281 
1282                 p2 = buff[i + 2]; p3 = buff[i + 3];
1283 
1284                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1285                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1286 
1287                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1288                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1289 
1290                 STORE_RES(dp[0    ], d0);
1291                 STORE_RES(dp[chan1], d1);
1292 
1293                 buffd[i    ] = 0;
1294                 buffd[i + 1] = 0;
1295 
1296                 sp += chan2;
1297                 dp += chan2;
1298               }
1299             }
1300 
1301           } else if (kw == 2) {
1302 
1303             p2 = buff[0];
1304             k0 = pk[0]; k1 = pk[1];
1305 
1306             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1307 #ifdef __SUNPRO_C</span>
<span class="line-removed">1308 #pragma pipeloop(0)</span>
<span class="line-removed">1309 #endif /* __SUNPRO_C */</span>
1310               for (i = 0; i &lt;= (wid - 2); i += 2) {
1311                 p0 = p2;
1312 
1313                 p1 = buff[i + 1]; p2 = buff[i + 2];
1314 
1315                 buffd[i    ] += p0*k0 + p1*k1;
1316                 buffd[i + 1] += p1*k0 + p2*k1;
1317               }
1318 
1319             } else {
<span class="line-removed">1320 #ifdef __SUNPRO_C</span>
<span class="line-removed">1321 #pragma pipeloop(0)</span>
<span class="line-removed">1322 #endif /* __SUNPRO_C */</span>
1323               for (i = 0; i &lt;= (wid - 2); i += 2) {
1324                 p0 = p2;
1325 
1326                 p1 = buff[i + 1]; p2 = buff[i + 2];
1327 
1328                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1329                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1330 
1331                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1332                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1333 
1334                 STORE_RES(dp[0    ], d0);
1335                 STORE_RES(dp[chan1], d1);
1336 
1337                 buffd[i    ] = 0;
1338                 buffd[i + 1] = 0;
1339 
1340                 sp += chan2;
1341                 dp += chan2;
1342               }
1343             }
1344 
1345           } else /* kw == 1 */{
1346 
1347             k0 = pk[0];
1348 
1349             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1350 #ifdef __SUNPRO_C</span>
<span class="line-removed">1351 #pragma pipeloop(0)</span>
<span class="line-removed">1352 #endif /* __SUNPRO_C */</span>
1353               for (i = 0; i &lt;= (wid - 2); i += 2) {
1354                 p0 = buff[i]; p1 = buff[i + 1];
1355 
1356                 buffd[i    ] += p0*k0;
1357                 buffd[i + 1] += p1*k0;
1358               }
1359 
1360             } else {
<span class="line-removed">1361 #ifdef __SUNPRO_C</span>
<span class="line-removed">1362 #pragma pipeloop(0)</span>
<span class="line-removed">1363 #endif /* __SUNPRO_C */</span>
1364               for (i = 0; i &lt;= (wid - 2); i += 2) {
1365                 p0 = buff[i]; p1 = buff[i + 1];
1366 
1367                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1368                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1369 
1370                 d0 = (p0*k0 + buffd[i    ]);
1371                 d1 = (p1*k0 + buffd[i + 1]);
1372 
1373                 STORE_RES(dp[0    ], d0);
1374                 STORE_RES(dp[chan1], d1);
1375 
1376                 buffd[i    ] = 0;
1377                 buffd[i + 1] = 0;
1378 
1379                 sp += chan2;
1380                 dp += chan2;
1381               }
1382             }
1383           }
</pre>
<hr />
<pre>
1412       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1413       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1414 
1415       /* next line */
1416 
1417       if (j &lt; hgt - dy_b - 2) sl += sll;
1418       dl += dll;
1419 
1420       buff_ind++;
1421 
1422       if (buff_ind &gt;= n + 1) buff_ind = 0;
1423     }
1424   }
1425 
1426   if (pbuff != buff) mlib_free(pbuff);
1427   if (k != k_locl) mlib_free(k);
1428 
1429   return MLIB_SUCCESS;
1430 }
1431 
<span class="line-removed">1432 #endif /* __sparc ( for x86, using integer multiplies is faster ) */</span>
<span class="line-removed">1433 </span>
1434 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 162 /***************************************************************/
 163 typedef union {
 164   mlib_d64 d64;
 165   struct {
 166     mlib_s32 i0;
 167     mlib_s32 i1;
 168   } i32s;
 169 } d64_2x32;
 170 
 171 /***************************************************************/
 172 #define GET_SRC_DST_PARAMETERS(type)                            \
 173   hgt = mlib_ImageGetHeight(src);                               \
 174   wid = mlib_ImageGetWidth(src);                                \
 175   nchannel = mlib_ImageGetChannels(src);                        \
 176   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 177   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 178   adr_src = (type *)mlib_ImageGetData(src);                     \
 179   adr_dst = (type *)mlib_ImageGetData(dst)
 180 
 181 /***************************************************************/

 182 #if IMG_TYPE == 1
 183 
 184 /*
 185  * Test for the presence of any &quot;1&quot; bit in bits
 186    8 to 31 of val. If present, then val is either
 187    negative or &gt;255. If over/underflows of 8 bits
 188    are uncommon, then this technique can be a win,
 189    since only a single test, rather than two, is
 190    necessary to determine if clamping is needed.
 191    On the other hand, if over/underflows are common,
 192    it adds an extra test.
 193 */
 194 #define CLAMP_STORE(dst, val)                                   \
 195   if (val &amp; 0xffffff00) {                                       \
 196     if (val &lt; MLIB_U8_MIN)                                      \
 197       dst = MLIB_U8_MIN;                                        \
 198     else                                                        \
 199       dst = MLIB_U8_MAX;                                        \
 200   } else {                                                      \
 201     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 205 
 206 #define CLAMP_STORE(dst, val)                                   \
 207   if (val &gt;= MLIB_S16_MAX)                                      \
 208     dst = MLIB_S16_MAX;                                         \
 209   else if (val &lt;= MLIB_S16_MIN)                                 \
 210     dst = MLIB_S16_MIN;                                         \
 211   else                                                          \
 212     dst = (mlib_s16)val
 213 
 214 #elif IMG_TYPE == 3
 215 
 216 #define CLAMP_STORE(dst, val)                                   \
 217   if (val &gt;= MLIB_U16_MAX)                                      \
 218     dst = MLIB_U16_MAX;                                         \
 219   else if (val &lt;= MLIB_U16_MIN)                                 \
 220     dst = MLIB_U16_MIN;                                         \
 221   else                                                          \
 222     dst = (mlib_u16)val
 223 
 224 #endif /* IMG_TYPE == 1 */

 225 
 226 /***************************************************************/
 227 #define MAX_KER   7
 228 #define MAX_N    15
 229 #define BUFF_SIZE   1600
 230 #define CACHE_SIZE  (64*1024)
 231 
 232 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 233                                          const mlib_image *src,
 234                                          const mlib_d64   *k,
 235                                          mlib_s32         n,
 236                                          mlib_s32         dy_t,
 237                                          mlib_s32         dy_b,
 238                                          mlib_s32         cmask)
 239 {
 240   DTYPE    *adr_src, *sl;
 241   DTYPE    *adr_dst, *dl, *dp;
 242   FTYPE    buff[BUFF_SIZE];
 243   FTYPE    *buffd;
 244   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 272 
 273   sbuff = pbuff;
 274   buffd = sbuff + smax_hsize;
 275 
 276   shgt -= (dy_t + dy_b);
 277   k_off = 0;
 278 
 279   for (l = 0; l &lt; hgt; l += hsize) {
 280     hsize = hgt - l;
 281 
 282     if (hsize &gt; max_hsize) hsize = max_hsize;
 283 
 284     smax_hsize = hsize + (n - 1);
 285 
 286     for (c = 0; c &lt; nchannel; c++) {
 287       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 288 
 289       sl = adr_src + c;
 290       dl = adr_dst + c;
 291 



 292       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 293 
 294       for (j = 0; j &lt; wid; j++) {
 295         FTYPE    *buff = sbuff;
 296 
 297         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 298           sbuff[i - k_off] = (FTYPE)sl[0];
 299         }
 300 



 301         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 302           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 303         }
 304 
 305         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 306           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 307         }
 308 
 309         pk = k;
 310 
 311         for (off = 0; off &lt; (n - 4); off += 4) {
 312 
 313           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 314           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 315 



 316           for (i = 0; i &lt; hsize; i += 2) {
 317             p0 = p2; p1 = p3; p2 = p4;
 318 
 319             p3 = buff[i + 3]; p4 = buff[i + 4];
 320 
 321             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 322             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 323           }
 324 
 325           pk += 4;
 326           buff += 4;
 327         }
 328 
 329         dp = dl;
 330         kh = n - off;
 331 
 332         if (kh == 4) {
 333           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 334           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 335 



 336           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 337             p0 = p2; p1 = p3; p2 = p4;
 338 
 339             p3 = buff[i + 3]; p4 = buff[i + 4];
 340 
 341             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 342             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 343 
 344             dp[0  ] = FROM_S32(d0);
 345             dp[dll] = FROM_S32(d1);
 346 
 347             buffd[i    ] = 0.0;
 348             buffd[i + 1] = 0.0;
 349 
 350             dp += 2*dll;
 351           }
 352 
 353           if (i &lt; hsize) {
 354             p0 = p2; p1 = p3; p2 = p4;
 355             p3 = buff[i + 3];
 356             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 357             dp[0] = FROM_S32(d0);
 358             buffd[i] = 0.0;
 359           }
 360 
 361         } else if (kh == 3) {
 362 
 363           p2 = buff[0]; p3 = buff[1];
 364           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 365 



 366           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 367             p0 = p2; p1 = p3;
 368 
 369             p2 = buff[i + 2]; p3 = buff[i + 3];
 370 
 371             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 372             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 373 
 374             dp[0  ] = FROM_S32(d0);
 375             dp[dll] = FROM_S32(d1);
 376 
 377             buffd[i    ] = 0.0;
 378             buffd[i + 1] = 0.0;
 379 
 380             dp += 2*dll;
 381           }
 382 
 383           if (i &lt; hsize) {
 384             p0 = p2; p1 = p3;
 385             p2 = buff[i + 2];
 386             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 387             dp[0] = FROM_S32(d0);
 388 
 389             buffd[i] = 0.0;
 390           }
 391 
 392         } else if (kh == 2) {
 393 
 394           p2 = buff[0];
 395           k0 = pk[0]; k1 = pk[1];
 396 



 397           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 398             p0 = p2;
 399 
 400             p1 = buff[i + 1]; p2 = buff[i + 2];
 401 
 402             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 403             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 404 
 405             dp[0  ] = FROM_S32(d0);
 406             dp[dll] = FROM_S32(d1);
 407 
 408             buffd[i    ] = 0.0;
 409             buffd[i + 1] = 0.0;
 410 
 411             dp += 2*dll;
 412           }
 413 
 414           if (i &lt; hsize) {
 415             p0 = p2;
 416             p1 = buff[i + 1];
 417             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 418             dp[0] = FROM_S32(d0);
 419 
 420             buffd[i] = 0.0;
 421           }
 422 
 423         } else /* kh == 1 */{
 424 
 425           k0 = pk[0];
 426 



 427           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 428             p0 = buff[i]; p1 = buff[i + 1];
 429 
 430             d0 = D2I(p0*k0 + buffd[i    ]);
 431             d1 = D2I(p1*k0 + buffd[i + 1]);
 432 
 433             dp[0  ] = FROM_S32(d0);
 434             dp[dll] = FROM_S32(d1);
 435 
 436             buffd[i    ] = 0.0;
 437             buffd[i + 1] = 0.0;
 438 
 439             dp += 2*dll;
 440           }
 441 
 442           if (i &lt; hsize) {
 443             p0 = buff[i];
 444             d0 = D2I(p0*k0 + buffd[i]);
 445             dp[0] = FROM_S32(d0);
 446 
</pre>
<hr />
<pre>
 529   buffi = (mlib_s32*)(buffd + swid);
 530 
 531   chan1 = nchannel;
 532   chan2 = chan1 + chan1;
 533 
 534   swid -= (dx_l + dx_r);
 535 
 536   for (c = 0; c &lt; nchannel; c++) {
 537     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 538 
 539     sl = adr_src + c;
 540     dl = adr_dst + c;
 541 
 542     for (l = 0; l &lt; n; l++) {
 543       FTYPE    *buff = buffs[l];
 544 
 545       for (i = 0; i &lt; dx_l; i++) {
 546         buff[i] = (FTYPE)sl[0];
 547       }
 548 



 549       for (i = 0; i &lt; swid; i++) {
 550         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 551       }
 552 
 553       for (i = 0; i &lt; dx_r; i++) {
 554         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 555       }
 556 
 557       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 558     }
 559 
 560     buff_ind = 0;
 561 



 562     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 563 
 564     for (j = 0; j &lt; hgt; j++) {
 565       FTYPE    **buffc = buffs + buff_ind;
 566       FTYPE    *buffn = buffc[n];
 567       FTYPE    *pk = k;
 568 
 569       for (l = 0; l &lt; n; l++) {
 570         FTYPE    *buff_l = buffc[l];
 571 
 572         for (off = 0; off &lt; m;) {
 573           FTYPE    *buff = buff_l + off;
 574 
 575           kw = m - off;
 576 
 577           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 578             if (kw &gt; MAX_KER) kw = kw/2;
 579           off += kw;
 580 
 581           sp = sl;
 582           dp = dl;
 583 
 584           if (kw == 7) {
 585 
 586             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 587             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 588 
 589             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 590             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 591 
 592             if (l &lt; (n - 1) || off &lt; m) {



 593               for (i = 0; i &lt;= (wid - 2); i += 2) {
 594                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 595 
 596                 p6 = buff[i + 6]; p7 = buff[i + 7];
 597 
 598                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 599                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 600               }
 601 
 602             } else {



 603               for (i = 0; i &lt;= (wid - 2); i += 2) {
 604                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 605 
 606                 p6 = buff[i + 6]; p7 = buff[i + 7];
 607 
 608                 LOAD_BUFF(buffi);
 609 
 610                 dd.d64 = *(FTYPE   *)(buffi + i);
 611                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 612                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 613 
 614                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 615                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 616 
 617                 dp[0    ] = FROM_S32(d0);
 618                 dp[chan1] = FROM_S32(d1);
 619 
 620                 buffd[i    ] = 0.0;
 621                 buffd[i + 1] = 0.0;
 622 
 623                 sp += chan2;
 624                 dp += chan2;
 625               }
 626             }
 627 
 628           } else if (kw == 6) {
 629 
 630             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 631             p5 = buff[3]; p6 = buff[4];
 632 
 633             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 634             k4 = pk[4]; k5 = pk[5];
 635 
 636             if (l &lt; (n - 1) || off &lt; m) {



 637               for (i = 0; i &lt;= (wid - 2); i += 2) {
 638                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 639 
 640                 p5 = buff[i + 5]; p6 = buff[i + 6];
 641 
 642                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 643                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 644               }
 645 
 646             } else {



 647               for (i = 0; i &lt;= (wid - 2); i += 2) {
 648                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 649 
 650                 p5 = buff[i + 5]; p6 = buff[i + 6];
 651 
 652                 LOAD_BUFF(buffi);
 653 
 654                 dd.d64 = *(FTYPE   *)(buffi + i);
 655                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 656                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 657 
 658                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 659                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 660 
 661                 dp[0    ] = FROM_S32(d0);
 662                 dp[chan1] = FROM_S32(d1);
 663 
 664                 buffd[i    ] = 0.0;
 665                 buffd[i + 1] = 0.0;
 666 
 667                 sp += chan2;
 668                 dp += chan2;
 669               }
 670             }
 671 
 672           } else if (kw == 5) {
 673 
 674             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 675             p5 = buff[3];
 676 
 677             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 678             k4 = pk[4];
 679 
 680             if (l &lt; (n - 1) || off &lt; m) {



 681               for (i = 0; i &lt;= (wid - 2); i += 2) {
 682                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 683 
 684                 p4 = buff[i + 4]; p5 = buff[i + 5];
 685 
 686                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 687                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 688               }
 689 
 690             } else {



 691               for (i = 0; i &lt;= (wid - 2); i += 2) {
 692                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 693 
 694                 p4 = buff[i + 4]; p5 = buff[i + 5];
 695 
 696                 LOAD_BUFF(buffi);
 697 
 698                 dd.d64 = *(FTYPE   *)(buffi + i);
 699                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 700                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 701 
 702                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 703                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 704 
 705                 dp[0    ] = FROM_S32(d0);
 706                 dp[chan1] = FROM_S32(d1);
 707 
 708                 buffd[i    ] = 0.0;
 709                 buffd[i + 1] = 0.0;
 710 
 711                 sp += chan2;
 712                 dp += chan2;
 713               }
 714             }
 715 
 716           } else if (kw == 4) {
 717 
 718             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 719 
 720             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 721 
 722             if (l &lt; (n - 1) || off &lt; m) {



 723               for (i = 0; i &lt;= (wid - 2); i += 2) {
 724                 p0 = p2; p1 = p3; p2 = p4;
 725 
 726                 p3 = buff[i + 3]; p4 = buff[i + 4];
 727 
 728                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 729                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 730               }
 731 
 732             } else {



 733               for (i = 0; i &lt;= (wid - 2); i += 2) {
 734                 p0 = p2; p1 = p3; p2 = p4;
 735 
 736                 p3 = buff[i + 3]; p4 = buff[i + 4];
 737 
 738                 LOAD_BUFF(buffi);
 739 
 740                 dd.d64 = *(FTYPE   *)(buffi + i);
 741                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 742                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 743 
 744                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 745                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 746 
 747                 dp[0    ] = FROM_S32(d0);
 748                 dp[chan1] = FROM_S32(d1);
 749 
 750                 buffd[i    ] = 0.0;
 751                 buffd[i + 1] = 0.0;
 752 
 753                 sp += chan2;
 754                 dp += chan2;
 755               }
 756             }
 757 
 758           } else if (kw == 3) {
 759 
 760             p2 = buff[0]; p3 = buff[1];
 761             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 762 
 763             if (l &lt; (n - 1) || off &lt; m) {



 764               for (i = 0; i &lt;= (wid - 2); i += 2) {
 765                 p0 = p2; p1 = p3;
 766 
 767                 p2 = buff[i + 2]; p3 = buff[i + 3];
 768 
 769                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 770                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 771               }
 772 
 773             } else {



 774               for (i = 0; i &lt;= (wid - 2); i += 2) {
 775                 p0 = p2; p1 = p3;
 776 
 777                 p2 = buff[i + 2]; p3 = buff[i + 3];
 778 
 779                 LOAD_BUFF(buffi);
 780 
 781                 dd.d64 = *(FTYPE   *)(buffi + i);
 782                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 783                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 784 
 785                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 786                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 787 
 788                 dp[0    ] = FROM_S32(d0);
 789                 dp[chan1] = FROM_S32(d1);
 790 
 791                 buffd[i    ] = 0.0;
 792                 buffd[i + 1] = 0.0;
 793 
 794                 sp += chan2;
 795                 dp += chan2;
 796               }
 797             }
 798 
 799           } else /* if (kw == 2) */ {
 800 
 801             p2 = buff[0];
 802             k0 = pk[0]; k1 = pk[1];
 803 
 804             if (l &lt; (n - 1) || off &lt; m) {



 805               for (i = 0; i &lt;= (wid - 2); i += 2) {
 806                 p0 = p2;
 807 
 808                 p1 = buff[i + 1]; p2 = buff[i + 2];
 809 
 810                 buffd[i    ] += p0*k0 + p1*k1;
 811                 buffd[i + 1] += p1*k0 + p2*k1;
 812               }
 813 
 814             } else {



 815               for (i = 0; i &lt;= (wid - 2); i += 2) {
 816                 p0 = p2;
 817 
 818                 p1 = buff[i + 1]; p2 = buff[i + 2];
 819 
 820                 LOAD_BUFF(buffi);
 821 
 822                 dd.d64 = *(FTYPE   *)(buffi + i);
 823                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 824                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 825 
 826                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 827                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 828 
 829                 dp[0    ] = FROM_S32(d0);
 830                 dp[chan1] = FROM_S32(d1);
 831 
 832                 buffd[i    ] = 0.0;
 833                 buffd[i + 1] = 0.0;
 834 
</pre>
<hr />
<pre>
 868       }
 869 
 870       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 871       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 872 
 873       /* next line */
 874 
 875       if (j &lt; hgt - dy_b - 2) sl += sll;
 876       dl += dll;
 877 
 878       buff_ind++;
 879 
 880       if (buff_ind &gt;= n + 1) buff_ind = 0;
 881     }
 882   }
 883 
 884   FREE_AND_RETURN_STATUS;
 885 }
 886 
 887 /***************************************************************/
<span class="line-modified"> 888 /* for x86, using integer multiplies is faster */</span>
 889 
 890 #define STORE_RES(res, x)                                       \
 891   x &gt;&gt;= shift2;                                                 \
 892   CLAMP_STORE(res, x)
 893 
 894 mlib_status CONV_FUNC_MxN_I
 895 {
 896   DTYPE    *adr_src, *sl, *sp = NULL;
 897   DTYPE    *adr_dst, *dl, *dp = NULL;
 898   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 899   mlib_s32 *pbuff = buff;
 900   mlib_s32 **buffs = buffs_arr, *buffd;
 901   mlib_s32 l, off, kw, bsize, buff_ind;
 902   mlib_s32 d0, d1, shift1, shift2;
 903   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 904   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 905   mlib_s32 wid, hgt, sll, dll;
 906   mlib_s32 nchannel, chan1;
 907   mlib_s32 i, j, c, swid;
 908   mlib_s32 chan2;
</pre>
<hr />
<pre>
 945 
 946   for (i = 0; i &lt; m*n; i++) {
 947     k[i] = kernel[i] &gt;&gt; shift1;
 948   }
 949 
 950   swid -= (dx_l + dx_r);
 951 
 952   for (c = 0; c &lt; nchannel; c++) {
 953     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 954 
 955     sl = adr_src + c;
 956     dl = adr_dst + c;
 957 
 958     for (l = 0; l &lt; n; l++) {
 959       mlib_s32  *buff = buffs[l];
 960 
 961       for (i = 0; i &lt; dx_l; i++) {
 962         buff[i] = (mlib_s32)sl[0];
 963       }
 964 



 965       for (i = 0; i &lt; swid; i++) {
 966         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
 967       }
 968 
 969       for (i = 0; i &lt; dx_r; i++) {
 970         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 971       }
 972 
 973       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 974     }
 975 
 976     buff_ind = 0;
 977 



 978     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
 979 
 980     for (j = 0; j &lt; hgt; j++) {
 981       mlib_s32 **buffc = buffs + buff_ind;
 982       mlib_s32 *buffn = buffc[n];
 983       mlib_s32 *pk = k;
 984 
 985       for (l = 0; l &lt; n; l++) {
 986         mlib_s32  *buff_l = buffc[l];
 987 
 988         for (off = 0; off &lt; m;) {
 989           mlib_s32 *buff = buff_l + off;
 990 
 991           sp = sl;
 992           dp = dl;
 993 
 994           kw = m - off;
 995 
 996           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 997             if (kw &gt; MAX_KER) kw = kw/2;
 998           off += kw;
 999 
1000           if (kw == 7) {
1001 
1002             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1003             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
1004 
1005             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1006             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
1007 
1008             if (l &lt; (n - 1) || off &lt; m) {



1009               for (i = 0; i &lt;= (wid - 2); i += 2) {
1010                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1011 
1012                 p6 = buff[i + 6]; p7 = buff[i + 7];
1013 
1014                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1015                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1016               }
1017 
1018             } else {



1019               for (i = 0; i &lt;= (wid - 2); i += 2) {
1020                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1021 
1022                 p6 = buff[i + 6]; p7 = buff[i + 7];
1023 
1024                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1025                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1026 
1027                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1028                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1029 
1030                 STORE_RES(dp[0    ], d0);
1031                 STORE_RES(dp[chan1], d1);
1032 
1033                 buffd[i    ] = 0;
1034                 buffd[i + 1] = 0;
1035 
1036                 sp += chan2;
1037                 dp += chan2;
1038               }
1039             }
1040 
1041           } else if (kw == 6) {
1042 
1043             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1044             p5 = buff[3]; p6 = buff[4];
1045 
1046             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1047             k4 = pk[4]; k5 = pk[5];
1048 
1049             if (l &lt; (n - 1) || off &lt; m) {



1050               for (i = 0; i &lt;= (wid - 2); i += 2) {
1051                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1052 
1053                 p5 = buff[i + 5]; p6 = buff[i + 6];
1054 
1055                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1056                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1057               }
1058 
1059             } else {



1060               for (i = 0; i &lt;= (wid - 2); i += 2) {
1061                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1062 
1063                 p5 = buff[i + 5]; p6 = buff[i + 6];
1064 
1065                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1066                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1067 
1068                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1069                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1070 
1071                 STORE_RES(dp[0    ], d0);
1072                 STORE_RES(dp[chan1], d1);
1073 
1074                 buffd[i    ] = 0;
1075                 buffd[i + 1] = 0;
1076 
1077                 sp += chan2;
1078                 dp += chan2;
1079               }
1080             }
1081 
1082           } else if (kw == 5) {
1083 
1084             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1085             p5 = buff[3];
1086 
1087             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1088             k4 = pk[4];
1089 
1090             if (l &lt; (n - 1) || off &lt; m) {



1091               for (i = 0; i &lt;= (wid - 2); i += 2) {
1092                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1093 
1094                 p4 = buff[i + 4]; p5 = buff[i + 5];
1095 
1096                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1097                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1098               }
1099 
1100             } else {



1101               for (i = 0; i &lt;= (wid - 2); i += 2) {
1102                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1103 
1104                 p4 = buff[i + 4]; p5 = buff[i + 5];
1105 
1106                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1107                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1108 
1109                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1110                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1111 
1112                 STORE_RES(dp[0    ], d0);
1113                 STORE_RES(dp[chan1], d1);
1114 
1115                 buffd[i    ] = 0;
1116                 buffd[i + 1] = 0;
1117 
1118                 sp += chan2;
1119                 dp += chan2;
1120               }
1121             }
1122 
1123           } else if (kw == 4) {
1124 
1125             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1126 
1127             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1128 
1129             if (l &lt; (n - 1) || off &lt; m) {



1130               for (i = 0; i &lt;= (wid - 2); i += 2) {
1131                 p0 = p2; p1 = p3; p2 = p4;
1132 
1133                 p3 = buff[i + 3]; p4 = buff[i + 4];
1134 
1135                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1136                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1137               }
1138 
1139             } else {



1140               for (i = 0; i &lt;= (wid - 2); i += 2) {
1141                 p0 = p2; p1 = p3; p2 = p4;
1142 
1143                 p3 = buff[i + 3]; p4 = buff[i + 4];
1144 
1145                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1146                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1147 
1148                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1149                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1150 
1151                 STORE_RES(dp[0    ], d0);
1152                 STORE_RES(dp[chan1], d1);
1153 
1154                 buffd[i    ] = 0;
1155                 buffd[i + 1] = 0;
1156 
1157                 sp += chan2;
1158                 dp += chan2;
1159               }
1160             }
1161 
1162           } else if (kw == 3) {
1163 
1164             p2 = buff[0]; p3 = buff[1];
1165             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1166 
1167             if (l &lt; (n - 1) || off &lt; m) {



1168               for (i = 0; i &lt;= (wid - 2); i += 2) {
1169                 p0 = p2; p1 = p3;
1170 
1171                 p2 = buff[i + 2]; p3 = buff[i + 3];
1172 
1173                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1174                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1175               }
1176 
1177             } else {



1178               for (i = 0; i &lt;= (wid - 2); i += 2) {
1179                 p0 = p2; p1 = p3;
1180 
1181                 p2 = buff[i + 2]; p3 = buff[i + 3];
1182 
1183                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1184                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1185 
1186                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1187                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1188 
1189                 STORE_RES(dp[0    ], d0);
1190                 STORE_RES(dp[chan1], d1);
1191 
1192                 buffd[i    ] = 0;
1193                 buffd[i + 1] = 0;
1194 
1195                 sp += chan2;
1196                 dp += chan2;
1197               }
1198             }
1199 
1200           } else if (kw == 2) {
1201 
1202             p2 = buff[0];
1203             k0 = pk[0]; k1 = pk[1];
1204 
1205             if (l &lt; (n - 1) || off &lt; m) {



1206               for (i = 0; i &lt;= (wid - 2); i += 2) {
1207                 p0 = p2;
1208 
1209                 p1 = buff[i + 1]; p2 = buff[i + 2];
1210 
1211                 buffd[i    ] += p0*k0 + p1*k1;
1212                 buffd[i + 1] += p1*k0 + p2*k1;
1213               }
1214 
1215             } else {



1216               for (i = 0; i &lt;= (wid - 2); i += 2) {
1217                 p0 = p2;
1218 
1219                 p1 = buff[i + 1]; p2 = buff[i + 2];
1220 
1221                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1222                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1223 
1224                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1225                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1226 
1227                 STORE_RES(dp[0    ], d0);
1228                 STORE_RES(dp[chan1], d1);
1229 
1230                 buffd[i    ] = 0;
1231                 buffd[i + 1] = 0;
1232 
1233                 sp += chan2;
1234                 dp += chan2;
1235               }
1236             }
1237 
1238           } else /* kw == 1 */{
1239 
1240             k0 = pk[0];
1241 
1242             if (l &lt; (n - 1) || off &lt; m) {



1243               for (i = 0; i &lt;= (wid - 2); i += 2) {
1244                 p0 = buff[i]; p1 = buff[i + 1];
1245 
1246                 buffd[i    ] += p0*k0;
1247                 buffd[i + 1] += p1*k0;
1248               }
1249 
1250             } else {



1251               for (i = 0; i &lt;= (wid - 2); i += 2) {
1252                 p0 = buff[i]; p1 = buff[i + 1];
1253 
1254                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1255                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1256 
1257                 d0 = (p0*k0 + buffd[i    ]);
1258                 d1 = (p1*k0 + buffd[i + 1]);
1259 
1260                 STORE_RES(dp[0    ], d0);
1261                 STORE_RES(dp[chan1], d1);
1262 
1263                 buffd[i    ] = 0;
1264                 buffd[i + 1] = 0;
1265 
1266                 sp += chan2;
1267                 dp += chan2;
1268               }
1269             }
1270           }
</pre>
<hr />
<pre>
1299       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1300       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1301 
1302       /* next line */
1303 
1304       if (j &lt; hgt - dy_b - 2) sl += sll;
1305       dl += dll;
1306 
1307       buff_ind++;
1308 
1309       if (buff_ind &gt;= n + 1) buff_ind = 0;
1310     }
1311   }
1312 
1313   if (pbuff != buff) mlib_free(pbuff);
1314   if (k != k_locl) mlib_free(k);
1315 
1316   return MLIB_SUCCESS;
1317 }
1318 


1319 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_ImageConvMxN_ext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_16nw.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
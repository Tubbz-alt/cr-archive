<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libmlib_image/mlib_ImageAffine_NN.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 /*
 28  * FUNCTION
 29  *      Internal functions for mlib_ImageAffine with Nearest Neighbor filtering.
 30  */
 31 
 32 #include &quot;mlib_ImageAffine.h&quot;
 33 
 34 /***************************************************************/
 35 #define sp  srcPixelPtr
 36 #define dp  dstPixelPtr
 37 
 38 /***************************************************************/
 39 #undef  DTYPE
 40 #define DTYPE mlib_s32
 41 
 42 #ifdef _MSC_VER
 43 /* Workaround for MSC optimizer bug (known affected versions
 44    12.00.8168-12.00.8804). See bug 4893435 for details. */
 45 #pragma optimize(&quot;gs&quot;, off)
 46 #endif /* _MSC_VER */
 47 #ifdef i386 /* do not perform the coping by mlib_d64 data type for x86 */
 48 
 49 mlib_status mlib_ImageAffine_s32_1ch_nn(mlib_affine_param *param)
 50 {
 51   DECLAREVAR();
 52   DTYPE *srcPixelPtr;
 53   DTYPE *dstLineEnd;
 54 
 55   for (j = yStart; j &lt;= yFinish; j++) {
 56     CLIP(1);
 57     dstLineEnd = (DTYPE *) dstData + xRight;
 58 
 59 #ifdef __SUNPRO_C
 60 #pragma pipeloop(0)
 61 #endif /* __SUNPRO_C */
 62     for (; dp &lt;= dstLineEnd; dp++) {
 63       sp = S_PTR(Y) + (X &gt;&gt; MLIB_SHIFT);
 64       dp[0] = sp[0];
 65 
 66       X += dX;
 67       Y += dY;
 68     }
 69   }
 70 
 71   return MLIB_SUCCESS;
 72 }
 73 
 74 #else
 75 
 76 mlib_status mlib_ImageAffine_s32_1ch_nn(mlib_affine_param *param)
 77 {
 78   DECLAREVAR();
 79   DTYPE *srcPixelPtr;
 80   mlib_s32 i, size;
 81 
 82   for (j = yStart; j &lt;= yFinish; j++) {
 83     d64_2x32 dd;
 84 
 85     CLIP(1);
 86     size = xRight - xLeft + 1;
 87 
 88     if ((mlib_addr) dp &amp; 7) {
 89       sp = S_PTR(Y);
 90       *dp++ = sp[X &gt;&gt; MLIB_SHIFT];
 91       X += dX;
 92       Y += dY;
 93       size--;
 94     }
 95 
 96 #ifdef __SUNPRO_C
 97 #pragma pipeloop(0)
 98 #endif /* __SUNPRO_C */
 99     for (i = 0; i &lt;= (size - 2); i += 2) {
100       mlib_f32 *sp0, *sp1;
101 
102       sp0 = (mlib_f32 *) S_PTR(Y);
103       sp1 = (mlib_f32 *) S_PTR(Y + dY);
104 
105       dd.f32s.f0 = sp0[X &gt;&gt; MLIB_SHIFT];
106       dd.f32s.f1 = sp1[(X + dX) &gt;&gt; MLIB_SHIFT];
107 
108       *(mlib_d64 *) dp = dd.d64;
109 
110       dp += 2;
111       X += 2 * dX;
112       Y += 2 * dY;
113     }
114 
115     if (size &amp; 1) {
116       sp = S_PTR(Y);
117       *dp = sp[X &gt;&gt; MLIB_SHIFT];
118     }
119   }
120 
121   return MLIB_SUCCESS;
122 }
123 
124 #endif /* i386 ( do not perform the coping by mlib_d64 data type for x86 ) */
125 
126 /***************************************************************/
127 mlib_status mlib_ImageAffine_s32_2ch_nn(mlib_affine_param *param)
128 {
129   DECLAREVAR();
130   DTYPE *srcPixelPtr;
131   DTYPE *dstLineEnd;
132 
133   for (j = yStart; j &lt;= yFinish; j++) {
134     CLIP(2);
135     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
136 
137 #ifdef __SUNPRO_C
138 #pragma pipeloop(0)
139 #endif /* __SUNPRO_C */
140     for (; dp &lt;= dstLineEnd; dp += 2) {
141       sp = S_PTR(Y) + 2 * (X &gt;&gt; MLIB_SHIFT);
142       dp[0] = sp[0];
143       dp[1] = sp[1];
144 
145       X += dX;
146       Y += dY;
147     }
148   }
149 
150   return MLIB_SUCCESS;
151 }
152 
153 /***************************************************************/
154 mlib_status mlib_ImageAffine_s32_3ch_nn(mlib_affine_param *param)
155 {
156   DECLAREVAR();
157   DTYPE *srcPixelPtr;
158   DTYPE *dstLineEnd;
159 
160   for (j = yStart; j &lt;= yFinish; j++) {
161     CLIP(3);
162     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
163 
164 #ifdef __SUNPRO_C
165 #pragma pipeloop(0)
166 #endif /* __SUNPRO_C */
167     for (; dp &lt;= dstLineEnd; dp += 3) {
168       sp = S_PTR(Y) + 3 * (X &gt;&gt; MLIB_SHIFT);
169       dp[0] = sp[0];
170       dp[1] = sp[1];
171       dp[2] = sp[2];
172 
173       X += dX;
174       Y += dY;
175     }
176   }
177 
178   return MLIB_SUCCESS;
179 }
180 
181 /***************************************************************/
182 mlib_status mlib_ImageAffine_s32_4ch_nn(mlib_affine_param *param)
183 {
184   DECLAREVAR();
185   DTYPE *srcPixelPtr;
186   DTYPE *dstLineEnd;
187 
188   for (j = yStart; j &lt;= yFinish; j++) {
189     CLIP(4);
190     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
191 
192 #ifdef __SUNPRO_C
193 #pragma pipeloop(0)
194 #endif /* __SUNPRO_C */
195     for (; dp &lt;= dstLineEnd; dp += 4) {
196       sp = S_PTR(Y) + 4 * (X &gt;&gt; MLIB_SHIFT);
197       dp[0] = sp[0];
198       dp[1] = sp[1];
199       dp[2] = sp[2];
200       dp[3] = sp[3];
201 
202       X += dX;
203       Y += dY;
204     }
205   }
206 
207   return MLIB_SUCCESS;
208 }
209 
210 /***************************************************************/
211 #undef  DTYPE
212 #define DTYPE mlib_d64
213 
214 mlib_status mlib_ImageAffine_d64_1ch_nn(mlib_affine_param *param)
215 {
216   DECLAREVAR();
217   DTYPE *srcPixelPtr;
218   DTYPE *dstLineEnd;
219 
220   for (j = yStart; j &lt;= yFinish; j++) {
221     CLIP(1);
222     dstLineEnd = (DTYPE *) dstData + xRight;
223 
224 #ifdef __SUNPRO_C
225 #pragma pipeloop(0)
226 #endif /* __SUNPRO_C */
227     for (; dp &lt;= dstLineEnd; dp++) {
228       sp = S_PTR(Y);
229       dp[0] = sp[X &gt;&gt; MLIB_SHIFT];
230 
231       X += dX;
232       Y += dY;
233     }
234   }
235 
236   return MLIB_SUCCESS;
237 }
238 
239 /***************************************************************/
240 mlib_status mlib_ImageAffine_d64_2ch_nn(mlib_affine_param *param)
241 {
242   DECLAREVAR();
243   DTYPE *srcPixelPtr;
244   DTYPE *dstLineEnd;
245 
246   for (j = yStart; j &lt;= yFinish; j++) {
247     CLIP(2);
248     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
249 
250 #ifdef __SUNPRO_C
251 #pragma pipeloop(0)
252 #endif /* __SUNPRO_C */
253     for (; dp &lt;= dstLineEnd; dp += 2) {
254       sp = S_PTR(Y) + 2 * (X &gt;&gt; MLIB_SHIFT);
255       dp[0] = sp[0];
256       dp[1] = sp[1];
257 
258       X += dX;
259       Y += dY;
260     }
261   }
262 
263   return MLIB_SUCCESS;
264 }
265 
266 /***************************************************************/
267 mlib_status mlib_ImageAffine_d64_3ch_nn(mlib_affine_param *param)
268 {
269   DECLAREVAR();
270   DTYPE *srcPixelPtr;
271   DTYPE *dstLineEnd;
272 
273   for (j = yStart; j &lt;= yFinish; j++) {
274     CLIP(3);
275     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
276 
277 #ifdef __SUNPRO_C
278 #pragma pipeloop(0)
279 #endif /* __SUNPRO_C */
280     for (; dp &lt;= dstLineEnd; dp += 3) {
281       sp = S_PTR(Y) + 3 * (X &gt;&gt; MLIB_SHIFT);
282       dp[0] = sp[0];
283       dp[1] = sp[1];
284       dp[2] = sp[2];
285 
286       X += dX;
287       Y += dY;
288     }
289   }
290 
291   return MLIB_SUCCESS;
292 }
293 
294 /***************************************************************/
295 mlib_status mlib_ImageAffine_d64_4ch_nn(mlib_affine_param *param)
296 {
297   DECLAREVAR();
298   DTYPE *srcPixelPtr;
299   DTYPE *dstLineEnd;
300 
301   for (j = yStart; j &lt;= yFinish; j++) {
302     CLIP(4);
303     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
304 
305 #ifdef __SUNPRO_C
306 #pragma pipeloop(0)
307 #endif /* __SUNPRO_C */
308     for (; dp &lt;= dstLineEnd; dp += 4) {
309       sp = S_PTR(Y) + 4 * (X &gt;&gt; MLIB_SHIFT);
310       dp[0] = sp[0];
311       dp[1] = sp[1];
312       dp[2] = sp[2];
313       dp[3] = sp[3];
314 
315       X += dX;
316       Y += dY;
317     }
318   }
319 
320   return MLIB_SUCCESS;
321 }
322 
323 /***************************************************************/
324 #ifdef _MSC_VER
325 /* Workaround for MSC optimizer bug (known affected versions
326    12.00.8168-12.00.8804). See bug 4893435 for details. */
327 #pragma optimize(&quot;gs&quot;, on)
328 #endif /* _MSC_VER */
    </pre>
  </body>
</html>
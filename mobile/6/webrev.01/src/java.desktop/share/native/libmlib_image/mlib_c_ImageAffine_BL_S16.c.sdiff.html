<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BL_S16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_c_ImageAffine_BL.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BL_U16.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BL_S16.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60  * DESCRIPTION
 61  *      The functions step along the lines from xLeft to xRight and apply
 62  *      the bilinear filtering.
 63  *
 64  */
 65 
 66 #include &quot;mlib_ImageAffine.h&quot;
 67 
 68 /***************************************************************/
 69 #define DTYPE  mlib_s16
 70 #define FTYPE  mlib_d64
 71 
 72 /***************************************************************/
 73 #define TTYPE    mlib_s32
 74 #define I2F(x)   (x)
 75 #define ROUND(x) (x)
 76 
 77 #define FUN_NAME(CHAN) mlib_ImageAffine_s16_##CHAN##_bl
 78 
 79 /***************************************************************/
<span class="line-modified"> 80 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82 /***************************************************************/</span>
<span class="line-removed"> 83 #define GET_POINTERS(ind)                                       \</span>
<span class="line-removed"> 84   fdx = (FTYPE)(X &amp; MLIB_MASK) * scale;                         \</span>
<span class="line-removed"> 85   fdy = (FTYPE)(Y &amp; MLIB_MASK) * scale;                         \</span>
<span class="line-removed"> 86   ySrc = MLIB_POINTER_SHIFT(Y);  Y += dY;                       \</span>
<span class="line-removed"> 87   xSrc = X &gt;&gt; MLIB_SHIFT;  X += dX;                             \</span>
<span class="line-removed"> 88   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;  \</span>
<span class="line-removed"> 89   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride)</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91 /***************************************************************/</span>
<span class="line-removed"> 92 #define COUNT(ind)                                              \</span>
<span class="line-removed"> 93   pix0_##ind = a00_##ind + fdy * (a10_##ind - a00_##ind);       \</span>
<span class="line-removed"> 94   pix1_##ind = a01_##ind + fdy * (a11_##ind - a01_##ind);       \</span>
<span class="line-removed"> 95   res##ind = ROUND(pix0_##ind + fdx * (pix1_##ind - pix0_##ind))</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 /***************************************************************/</span>
<span class="line-removed"> 98 #define LOAD(ind, ind1, ind2)                                   \</span>
<span class="line-removed"> 99   a00_##ind = I2F(srcPixelPtr[ind1]);                           \</span>
<span class="line-removed">100   a01_##ind = I2F(srcPixelPtr[ind2]);                           \</span>
<span class="line-removed">101   a10_##ind = I2F(srcPixelPtr2[ind1]);                          \</span>
<span class="line-removed">102   a11_##ind = I2F(srcPixelPtr2[ind2])</span>
<span class="line-removed">103 </span>
<span class="line-removed">104 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">105 {</span>
<span class="line-removed">106   DECLAREVAR_BL();</span>
<span class="line-removed">107   DTYPE *dstLineEnd;</span>
<span class="line-removed">108   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">109   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">110 </span>
<span class="line-removed">111   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">112     FTYPE fdx, fdy;</span>
<span class="line-removed">113     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">114     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">115 </span>
<span class="line-removed">116     CLIP(1);</span>
<span class="line-removed">117     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed">118 </span>
<span class="line-removed">119     GET_POINTERS(1);</span>
<span class="line-removed">120     LOAD(0, 0, 1);</span>
<span class="line-removed">121 #ifdef __SUNPRO_C</span>
<span class="line-removed">122 #pragma pipeloop(0)</span>
<span class="line-removed">123 #endif /* __SUNPRO_C */</span>
<span class="line-removed">124     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {</span>
<span class="line-removed">125       COUNT(0);</span>
<span class="line-removed">126       GET_POINTERS(1);</span>
<span class="line-removed">127       LOAD(0, 0, 1);</span>
<span class="line-removed">128       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">129     }</span>
<span class="line-removed">130 </span>
<span class="line-removed">131     COUNT(0);</span>
<span class="line-removed">132     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">133   }</span>
<span class="line-removed">134 </span>
<span class="line-removed">135   return MLIB_SUCCESS;</span>
<span class="line-removed">136 }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed">139 {</span>
<span class="line-removed">140   DECLAREVAR_BL();</span>
<span class="line-removed">141   DTYPE *dstLineEnd;</span>
<span class="line-removed">142   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">143   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">144 </span>
<span class="line-removed">145   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">146     FTYPE fdx, fdy;</span>
<span class="line-removed">147     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">148     TTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">149     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">150     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     CLIP(2);</span>
<span class="line-removed">153     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed">154 </span>
<span class="line-removed">155     GET_POINTERS(2);</span>
<span class="line-removed">156     LOAD(0, 0, 2);</span>
<span class="line-removed">157     LOAD(1, 1, 3);</span>
<span class="line-removed">158 #ifdef __SUNPRO_C</span>
<span class="line-removed">159 #pragma pipeloop(0)</span>
<span class="line-removed">160 #endif /* __SUNPRO_C */</span>
<span class="line-removed">161     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {</span>
<span class="line-removed">162       COUNT(0);</span>
<span class="line-removed">163       COUNT(1);</span>
<span class="line-removed">164       GET_POINTERS(2);</span>
<span class="line-removed">165       LOAD(0, 0, 2);</span>
<span class="line-removed">166       LOAD(1, 1, 3);</span>
<span class="line-removed">167       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">168       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">169     }</span>
<span class="line-removed">170 </span>
<span class="line-removed">171     COUNT(0);</span>
<span class="line-removed">172     COUNT(1);</span>
<span class="line-removed">173     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">174     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">175   }</span>
<span class="line-removed">176 </span>
<span class="line-removed">177   return MLIB_SUCCESS;</span>
<span class="line-removed">178 }</span>
<span class="line-removed">179 </span>
<span class="line-removed">180 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed">181 {</span>
<span class="line-removed">182   DECLAREVAR_BL();</span>
<span class="line-removed">183   DTYPE *dstLineEnd;</span>
<span class="line-removed">184   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">185   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">186 </span>
<span class="line-removed">187   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">188     FTYPE fdx, fdy;</span>
<span class="line-removed">189     FTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">190     FTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">191     FTYPE a00_2, a01_2, a10_2, a11_2;</span>
<span class="line-removed">192     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">193     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">194     FTYPE pix0_2, pix1_2, res2;</span>
<span class="line-removed">195 </span>
<span class="line-removed">196     CLIP(3);</span>
<span class="line-removed">197     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed">198 </span>
<span class="line-removed">199     GET_POINTERS(3);</span>
<span class="line-removed">200     LOAD(0, 0, 3);</span>
<span class="line-removed">201     LOAD(1, 1, 4);</span>
<span class="line-removed">202     LOAD(2, 2, 5);</span>
<span class="line-removed">203 #ifdef __SUNPRO_C</span>
<span class="line-removed">204 #pragma pipeloop(0)</span>
<span class="line-removed">205 #endif /* __SUNPRO_C */</span>
<span class="line-removed">206     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {</span>
<span class="line-removed">207       COUNT(0);</span>
<span class="line-removed">208       COUNT(1);</span>
<span class="line-removed">209       COUNT(2);</span>
<span class="line-removed">210       GET_POINTERS(3);</span>
<span class="line-removed">211       LOAD(0, 0, 3);</span>
<span class="line-removed">212       LOAD(1, 1, 4);</span>
<span class="line-removed">213       LOAD(2, 2, 5);</span>
<span class="line-removed">214       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">215       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">216       dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219     COUNT(0);</span>
<span class="line-removed">220     COUNT(1);</span>
<span class="line-removed">221     COUNT(2);</span>
<span class="line-removed">222     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">223     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">224     dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">225   }</span>
<span class="line-removed">226 </span>
<span class="line-removed">227   return MLIB_SUCCESS;</span>
<span class="line-removed">228 }</span>
<span class="line-removed">229 </span>
<span class="line-removed">230 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed">231 {</span>
<span class="line-removed">232   DECLAREVAR_BL();</span>
<span class="line-removed">233   DTYPE *dstLineEnd;</span>
<span class="line-removed">234   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">235   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">236 </span>
<span class="line-removed">237   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">238     FTYPE fdx, fdy;</span>
<span class="line-removed">239     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">240     TTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">241     TTYPE a00_2, a01_2, a10_2, a11_2;</span>
<span class="line-removed">242     TTYPE a00_3, a01_3, a10_3, a11_3;</span>
<span class="line-removed">243     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">244     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">245     FTYPE pix0_2, pix1_2, res2;</span>
<span class="line-removed">246     FTYPE pix0_3, pix1_3, res3;</span>
<span class="line-removed">247 </span>
<span class="line-removed">248     CLIP(4);</span>
<span class="line-removed">249     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed">250 </span>
<span class="line-removed">251     GET_POINTERS(4);</span>
<span class="line-removed">252     LOAD(0, 0, 4);</span>
<span class="line-removed">253     LOAD(1, 1, 5);</span>
<span class="line-removed">254     LOAD(2, 2, 6);</span>
<span class="line-removed">255     LOAD(3, 3, 7);</span>
<span class="line-removed">256 #ifdef __SUNPRO_C</span>
<span class="line-removed">257 #pragma pipeloop(0)</span>
<span class="line-removed">258 #endif /* __SUNPRO_C */</span>
<span class="line-removed">259     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {</span>
<span class="line-removed">260       COUNT(0);</span>
<span class="line-removed">261       COUNT(1);</span>
<span class="line-removed">262       COUNT(2);</span>
<span class="line-removed">263       COUNT(3);</span>
<span class="line-removed">264       GET_POINTERS(4);</span>
<span class="line-removed">265       LOAD(0, 0, 4);</span>
<span class="line-removed">266       LOAD(1, 1, 5);</span>
<span class="line-removed">267       LOAD(2, 2, 6);</span>
<span class="line-removed">268       LOAD(3, 3, 7);</span>
<span class="line-removed">269       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">270       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">271       dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">272       dstPixelPtr[3] = (DTYPE) res3;</span>
<span class="line-removed">273     }</span>
<span class="line-removed">274 </span>
<span class="line-removed">275     COUNT(0);</span>
<span class="line-removed">276     COUNT(1);</span>
<span class="line-removed">277     COUNT(2);</span>
<span class="line-removed">278     COUNT(3);</span>
<span class="line-removed">279     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">280     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">281     dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">282     dstPixelPtr[3] = (DTYPE) res3;</span>
<span class="line-removed">283   }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285   return MLIB_SUCCESS;</span>
<span class="line-removed">286 }</span>
<span class="line-removed">287 </span>
<span class="line-removed">288 #else       /* for x86, using integer multiplies is faster */</span>
289 
290 /***************************************************************/
291 /* for SHORT/USHORT decrease MLIB_SHIFT due to
292  * overflow in multiplies like fdy * (a10 - a00)
293  */
294 #undef  MLIB_SHIFT
295 #define MLIB_SHIFT  15
296 
297 #define MLIB_ROUND   (1 &lt;&lt; (MLIB_SHIFT - 1))
298 
299 /***************************************************************/
300 #define GET_POINTERS(ind)                                        \
301   fdx = X &amp; MLIB_MASK;                                           \
302   fdy = Y &amp; MLIB_MASK;                                           \
303   ySrc = MLIB_POINTER_SHIFT(Y);                                  \
304   xSrc = X &gt;&gt; MLIB_SHIFT;                                        \
305   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;   \
306   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride); \
307   X += dX;                                                       \
308   Y += dY
</pre>
<hr />
<pre>
335   for (j = yStart; j &lt;= yFinish; j++) {
336     mlib_s32 fdx, fdy;
337     mlib_s32 a00_0, a01_0, a10_0, a11_0;
338     mlib_s32 pix0_0, pix1_0, res0;
339 
340     CLIP(1);
341     dstLineEnd = (DTYPE *) dstData + xRight;
342 #if MLIB_SHIFT == 15
343     X = X &gt;&gt; 1;
344     Y = Y &gt;&gt; 1;
345 
346     if (warp_tbl != NULL) {
347       dX = (dX + 1) &gt;&gt; 1;
348       dY = (dY + 1) &gt;&gt; 1;
349     }
350 
351 #endif /* MLIB_SHIFT == 15 */
352 
353     GET_POINTERS(1);
354     LOAD(0, 0, 1);
<span class="line-removed">355 #ifdef __SUNPRO_C</span>
<span class="line-removed">356 #pragma pipeloop(0)</span>
<span class="line-removed">357 #endif /* __SUNPRO_C */</span>
358     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {
359       COUNT(0);
360       GET_POINTERS(1);
361       LOAD(0, 0, 1);
362       dstPixelPtr[0] = (DTYPE) res0;
363     }
364 
365     COUNT(0);
366     dstPixelPtr[0] = (DTYPE) res0;
367   }
368 
369   return MLIB_SUCCESS;
370 }
371 
372 /***************************************************************/
373 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
374 {
375   DECLAREVAR_BL();
376   DTYPE *dstLineEnd;
377   DTYPE *srcPixelPtr2;
</pre>
<hr />
<pre>
387     mlib_s32 a00_1, a01_1, a10_1, a11_1;
388     mlib_s32 pix0_0, pix1_0, res0;
389     mlib_s32 pix0_1, pix1_1, res1;
390 
391     CLIP(2);
392     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
393 #if MLIB_SHIFT == 15
394     X = X &gt;&gt; 1;
395     Y = Y &gt;&gt; 1;
396 
397     if (warp_tbl != NULL) {
398       dX = (dX + 1) &gt;&gt; 1;
399       dY = (dY + 1) &gt;&gt; 1;
400     }
401 
402 #endif /* MLIB_SHIFT == 15 */
403 
404     GET_POINTERS(2);
405     LOAD(0, 0, 2);
406     LOAD(1, 1, 3);
<span class="line-removed">407 #ifdef __SUNPRO_C</span>
<span class="line-removed">408 #pragma pipeloop(0)</span>
<span class="line-removed">409 #endif /* __SUNPRO_C */</span>
410     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {
411       COUNT(0);
412       COUNT(1);
413       GET_POINTERS(2);
414       LOAD(0, 0, 2);
415       LOAD(1, 1, 3);
416       dstPixelPtr[0] = (DTYPE) res0;
417       dstPixelPtr[1] = (DTYPE) res1;
418     }
419 
420     COUNT(0);
421     COUNT(1);
422     dstPixelPtr[0] = (DTYPE) res0;
423     dstPixelPtr[1] = (DTYPE) res1;
424   }
425 
426   return MLIB_SUCCESS;
427 }
428 
429 /***************************************************************/
</pre>
<hr />
<pre>
447     mlib_s32 pix0_1, pix1_1, res1;
448     mlib_s32 pix0_2, pix1_2, res2;
449 
450     CLIP(3);
451     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
452 #if MLIB_SHIFT == 15
453     X = X &gt;&gt; 1;
454     Y = Y &gt;&gt; 1;
455 
456     if (warp_tbl != NULL) {
457       dX = (dX + 1) &gt;&gt; 1;
458       dY = (dY + 1) &gt;&gt; 1;
459     }
460 
461 #endif /* MLIB_SHIFT == 15 */
462 
463     GET_POINTERS(3);
464     LOAD(0, 0, 3);
465     LOAD(1, 1, 4);
466     LOAD(2, 2, 5);
<span class="line-removed">467 #ifdef __SUNPRO_C</span>
<span class="line-removed">468 #pragma pipeloop(0)</span>
<span class="line-removed">469 #endif /* __SUNPRO_C */</span>
470     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {
471       COUNT(0);
472       COUNT(1);
473       COUNT(2);
474       GET_POINTERS(3);
475       LOAD(0, 0, 3);
476       LOAD(1, 1, 4);
477       LOAD(2, 2, 5);
478       dstPixelPtr[0] = (DTYPE) res0;
479       dstPixelPtr[1] = (DTYPE) res1;
480       dstPixelPtr[2] = (DTYPE) res2;
481     }
482 
483     COUNT(0);
484     COUNT(1);
485     COUNT(2);
486     dstPixelPtr[0] = (DTYPE) res0;
487     dstPixelPtr[1] = (DTYPE) res1;
488     dstPixelPtr[2] = (DTYPE) res2;
489   }
</pre>
<hr />
<pre>
515     mlib_s32 pix0_3, pix1_3, res3;
516 
517     CLIP(4);
518     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
519 #if MLIB_SHIFT == 15
520     X = X &gt;&gt; 1;
521     Y = Y &gt;&gt; 1;
522 
523     if (warp_tbl != NULL) {
524       dX = (dX + 1) &gt;&gt; 1;
525       dY = (dY + 1) &gt;&gt; 1;
526     }
527 
528 #endif /* MLIB_SHIFT == 15 */
529 
530     GET_POINTERS(4);
531     LOAD(0, 0, 4);
532     LOAD(1, 1, 5);
533     LOAD(2, 2, 6);
534     LOAD(3, 3, 7);
<span class="line-removed">535 #ifdef __SUNPRO_C</span>
<span class="line-removed">536 #pragma pipeloop(0)</span>
<span class="line-removed">537 #endif /* __SUNPRO_C */</span>
538     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {
539       COUNT(0);
540       COUNT(1);
541       COUNT(2);
542       COUNT(3);
543       GET_POINTERS(4);
544       LOAD(0, 0, 4);
545       LOAD(1, 1, 5);
546       LOAD(2, 2, 6);
547       LOAD(3, 3, 7);
548       dstPixelPtr[0] = (DTYPE) res0;
549       dstPixelPtr[1] = (DTYPE) res1;
550       dstPixelPtr[2] = (DTYPE) res2;
551       dstPixelPtr[3] = (DTYPE) res3;
552     }
553 
554     COUNT(0);
555     COUNT(1);
556     COUNT(2);
557     COUNT(3);
558     dstPixelPtr[0] = (DTYPE) res0;
559     dstPixelPtr[1] = (DTYPE) res1;
560     dstPixelPtr[2] = (DTYPE) res2;
561     dstPixelPtr[3] = (DTYPE) res3;
562   }
563 
564   return MLIB_SUCCESS;
565 }
566 
<span class="line-removed">567 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">568 </span>
569 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60  * DESCRIPTION
 61  *      The functions step along the lines from xLeft to xRight and apply
 62  *      the bilinear filtering.
 63  *
 64  */
 65 
 66 #include &quot;mlib_ImageAffine.h&quot;
 67 
 68 /***************************************************************/
 69 #define DTYPE  mlib_s16
 70 #define FTYPE  mlib_d64
 71 
 72 /***************************************************************/
 73 #define TTYPE    mlib_s32
 74 #define I2F(x)   (x)
 75 #define ROUND(x) (x)
 76 
 77 #define FUN_NAME(CHAN) mlib_ImageAffine_s16_##CHAN##_bl
 78 
 79 /***************************************************************/
<span class="line-modified"> 80 /* for x86, using integer multiplies is faster */</span>
















































































































































































































 81 
 82 /***************************************************************/
 83 /* for SHORT/USHORT decrease MLIB_SHIFT due to
 84  * overflow in multiplies like fdy * (a10 - a00)
 85  */
 86 #undef  MLIB_SHIFT
 87 #define MLIB_SHIFT  15
 88 
 89 #define MLIB_ROUND   (1 &lt;&lt; (MLIB_SHIFT - 1))
 90 
 91 /***************************************************************/
 92 #define GET_POINTERS(ind)                                        \
 93   fdx = X &amp; MLIB_MASK;                                           \
 94   fdy = Y &amp; MLIB_MASK;                                           \
 95   ySrc = MLIB_POINTER_SHIFT(Y);                                  \
 96   xSrc = X &gt;&gt; MLIB_SHIFT;                                        \
 97   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;   \
 98   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride); \
 99   X += dX;                                                       \
100   Y += dY
</pre>
<hr />
<pre>
127   for (j = yStart; j &lt;= yFinish; j++) {
128     mlib_s32 fdx, fdy;
129     mlib_s32 a00_0, a01_0, a10_0, a11_0;
130     mlib_s32 pix0_0, pix1_0, res0;
131 
132     CLIP(1);
133     dstLineEnd = (DTYPE *) dstData + xRight;
134 #if MLIB_SHIFT == 15
135     X = X &gt;&gt; 1;
136     Y = Y &gt;&gt; 1;
137 
138     if (warp_tbl != NULL) {
139       dX = (dX + 1) &gt;&gt; 1;
140       dY = (dY + 1) &gt;&gt; 1;
141     }
142 
143 #endif /* MLIB_SHIFT == 15 */
144 
145     GET_POINTERS(1);
146     LOAD(0, 0, 1);



147     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {
148       COUNT(0);
149       GET_POINTERS(1);
150       LOAD(0, 0, 1);
151       dstPixelPtr[0] = (DTYPE) res0;
152     }
153 
154     COUNT(0);
155     dstPixelPtr[0] = (DTYPE) res0;
156   }
157 
158   return MLIB_SUCCESS;
159 }
160 
161 /***************************************************************/
162 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
163 {
164   DECLAREVAR_BL();
165   DTYPE *dstLineEnd;
166   DTYPE *srcPixelPtr2;
</pre>
<hr />
<pre>
176     mlib_s32 a00_1, a01_1, a10_1, a11_1;
177     mlib_s32 pix0_0, pix1_0, res0;
178     mlib_s32 pix0_1, pix1_1, res1;
179 
180     CLIP(2);
181     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
182 #if MLIB_SHIFT == 15
183     X = X &gt;&gt; 1;
184     Y = Y &gt;&gt; 1;
185 
186     if (warp_tbl != NULL) {
187       dX = (dX + 1) &gt;&gt; 1;
188       dY = (dY + 1) &gt;&gt; 1;
189     }
190 
191 #endif /* MLIB_SHIFT == 15 */
192 
193     GET_POINTERS(2);
194     LOAD(0, 0, 2);
195     LOAD(1, 1, 3);



196     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {
197       COUNT(0);
198       COUNT(1);
199       GET_POINTERS(2);
200       LOAD(0, 0, 2);
201       LOAD(1, 1, 3);
202       dstPixelPtr[0] = (DTYPE) res0;
203       dstPixelPtr[1] = (DTYPE) res1;
204     }
205 
206     COUNT(0);
207     COUNT(1);
208     dstPixelPtr[0] = (DTYPE) res0;
209     dstPixelPtr[1] = (DTYPE) res1;
210   }
211 
212   return MLIB_SUCCESS;
213 }
214 
215 /***************************************************************/
</pre>
<hr />
<pre>
233     mlib_s32 pix0_1, pix1_1, res1;
234     mlib_s32 pix0_2, pix1_2, res2;
235 
236     CLIP(3);
237     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
238 #if MLIB_SHIFT == 15
239     X = X &gt;&gt; 1;
240     Y = Y &gt;&gt; 1;
241 
242     if (warp_tbl != NULL) {
243       dX = (dX + 1) &gt;&gt; 1;
244       dY = (dY + 1) &gt;&gt; 1;
245     }
246 
247 #endif /* MLIB_SHIFT == 15 */
248 
249     GET_POINTERS(3);
250     LOAD(0, 0, 3);
251     LOAD(1, 1, 4);
252     LOAD(2, 2, 5);



253     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {
254       COUNT(0);
255       COUNT(1);
256       COUNT(2);
257       GET_POINTERS(3);
258       LOAD(0, 0, 3);
259       LOAD(1, 1, 4);
260       LOAD(2, 2, 5);
261       dstPixelPtr[0] = (DTYPE) res0;
262       dstPixelPtr[1] = (DTYPE) res1;
263       dstPixelPtr[2] = (DTYPE) res2;
264     }
265 
266     COUNT(0);
267     COUNT(1);
268     COUNT(2);
269     dstPixelPtr[0] = (DTYPE) res0;
270     dstPixelPtr[1] = (DTYPE) res1;
271     dstPixelPtr[2] = (DTYPE) res2;
272   }
</pre>
<hr />
<pre>
298     mlib_s32 pix0_3, pix1_3, res3;
299 
300     CLIP(4);
301     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
302 #if MLIB_SHIFT == 15
303     X = X &gt;&gt; 1;
304     Y = Y &gt;&gt; 1;
305 
306     if (warp_tbl != NULL) {
307       dX = (dX + 1) &gt;&gt; 1;
308       dY = (dY + 1) &gt;&gt; 1;
309     }
310 
311 #endif /* MLIB_SHIFT == 15 */
312 
313     GET_POINTERS(4);
314     LOAD(0, 0, 4);
315     LOAD(1, 1, 5);
316     LOAD(2, 2, 6);
317     LOAD(3, 3, 7);



318     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {
319       COUNT(0);
320       COUNT(1);
321       COUNT(2);
322       COUNT(3);
323       GET_POINTERS(4);
324       LOAD(0, 0, 4);
325       LOAD(1, 1, 5);
326       LOAD(2, 2, 6);
327       LOAD(3, 3, 7);
328       dstPixelPtr[0] = (DTYPE) res0;
329       dstPixelPtr[1] = (DTYPE) res1;
330       dstPixelPtr[2] = (DTYPE) res2;
331       dstPixelPtr[3] = (DTYPE) res3;
332     }
333 
334     COUNT(0);
335     COUNT(1);
336     COUNT(2);
337     COUNT(3);
338     dstPixelPtr[0] = (DTYPE) res0;
339     dstPixelPtr[1] = (DTYPE) res1;
340     dstPixelPtr[2] = (DTYPE) res2;
341     dstPixelPtr[3] = (DTYPE) res3;
342   }
343 
344   return MLIB_SUCCESS;
345 }
346 


347 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_c_ImageAffine_BL.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BL_U16.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
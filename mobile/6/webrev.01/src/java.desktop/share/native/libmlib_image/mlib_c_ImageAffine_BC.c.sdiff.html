<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_SysMath.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BC_S16.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  54  *      dstYStride stride of destination image
  55  *      is_affine  indicator (Affine - GridWarp)
  56  *      srcYStride stride of source image
  57  *      filter     type of resampling filter
  58  *
  59  * DESCRIPTION
  60  *      The functions step along the lines from xLeft to xRight and apply
  61  *      the bicubic filtering.
  62  *
  63  */
  64 
  65 #include &quot;mlib_ImageAffine.h&quot;
  66 
  67 #define DTYPE  mlib_u8
  68 
  69 #define FUN_NAME(CHAN) mlib_ImageAffine_u8_##CHAN##_bc
  70 
  71 #define FILTER_BITS   8
  72 
  73 /***************************************************************/
<span class="line-modified">  74 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  77 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  78 </span>
<span class="line-removed">  79 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  80 </span>
<span class="line-removed">  81 #define SAT8(DST)                                               \</span>
<span class="line-removed">  82   DST = ((mlib_s32)(val0 - sat) &gt;&gt; 24) ^ 0x80</span>
<span class="line-removed">  83 </span>
<span class="line-removed">  84 #else</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86 #define SAT8(DST)                                               \</span>
<span class="line-removed">  87   val0 -= sat;                                                  \</span>
<span class="line-removed">  88   if (val0 &gt;= MLIB_S32_MAX)                                     \</span>
<span class="line-removed">  89     DST = MLIB_U8_MAX;                                          \</span>
<span class="line-removed">  90   else if (val0 &lt;= MLIB_S32_MIN)                                \</span>
<span class="line-removed">  91     DST = MLIB_U8_MIN;                                          \</span>
<span class="line-removed">  92   else                                                          \</span>
<span class="line-removed">  93     DST = ((mlib_s32)val0 &gt;&gt; 24) ^ 0x80</span>
<span class="line-removed">  94 </span>
<span class="line-removed">  95 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97 /***************************************************************/</span>
<span class="line-removed">  98 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  99 {</span>
<span class="line-removed"> 100   DECLAREVAR_BC();</span>
<span class="line-removed"> 101   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 102   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 103   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 104 </span>
<span class="line-removed"> 105   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 106     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 107   }</span>
<span class="line-removed"> 108   else {</span>
<span class="line-removed"> 109     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 110   }</span>
<span class="line-removed"> 111 </span>
<span class="line-removed"> 112   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 113     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 114     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 115     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 116     mlib_s32 filterpos;</span>
<span class="line-removed"> 117     mlib_f32 *fptr;</span>
<span class="line-removed"> 118     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120     CLIP(1);</span>
<span class="line-removed"> 121     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 124     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     xf0 = fptr[0];</span>
<span class="line-removed"> 127     xf1 = fptr[1];</span>
<span class="line-removed"> 128     xf2 = fptr[2];</span>
<span class="line-removed"> 129     xf3 = fptr[3];</span>
<span class="line-removed"> 130 </span>
<span class="line-removed"> 131     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 132     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     yf0 = fptr[0];</span>
<span class="line-removed"> 135     yf1 = fptr[1];</span>
<span class="line-removed"> 136     yf2 = fptr[2];</span>
<span class="line-removed"> 137     yf3 = fptr[3];</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 140     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 141 </span>
<span class="line-removed"> 142     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 143     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 144     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 145     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 146     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 149 #pragma pipeloop(0)</span>
<span class="line-removed"> 150 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 151     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 152       X += dX;</span>
<span class="line-removed"> 153       Y += dY;</span>
<span class="line-removed"> 154 </span>
<span class="line-removed"> 155       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 156             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 157       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 158       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 159             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 160       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 161       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 162             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 163       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 164       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 165             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 168       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 169 </span>
<span class="line-removed"> 170       xf0 = fptr[0];</span>
<span class="line-removed"> 171       xf1 = fptr[1];</span>
<span class="line-removed"> 172       xf2 = fptr[2];</span>
<span class="line-removed"> 173       xf3 = fptr[3];</span>
<span class="line-removed"> 174 </span>
<span class="line-removed"> 175       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 178       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 179 </span>
<span class="line-removed"> 180       yf0 = fptr[0];</span>
<span class="line-removed"> 181       yf1 = fptr[1];</span>
<span class="line-removed"> 182       yf2 = fptr[2];</span>
<span class="line-removed"> 183       yf3 = fptr[3];</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185       SAT8(dstPixelPtr[0]);</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 188       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 189 </span>
<span class="line-removed"> 190       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 191       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 192       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 193       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 194       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 195     }</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197     c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 198           mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 199     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 200     c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 201           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 202     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 203     c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 204           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 205     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 206     c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 207           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 210 </span>
<span class="line-removed"> 211     SAT8(dstPixelPtr[0]);</span>
<span class="line-removed"> 212   }</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214   return MLIB_SUCCESS;</span>
<span class="line-removed"> 215 }</span>
<span class="line-removed"> 216 </span>
<span class="line-removed"> 217 /***************************************************************/</span>
<span class="line-removed"> 218 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 219 {</span>
<span class="line-removed"> 220   DECLAREVAR_BC();</span>
<span class="line-removed"> 221   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 222   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 223   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 224 </span>
<span class="line-removed"> 225   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 226     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 227   }</span>
<span class="line-removed"> 228   else {</span>
<span class="line-removed"> 229     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 230   }</span>
<span class="line-removed"> 231 </span>
<span class="line-removed"> 232   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 233     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 234     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 235     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 236     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 237     mlib_f32 *fptr;</span>
<span class="line-removed"> 238     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240     CLIP(2);</span>
<span class="line-removed"> 241     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 244       mlib_s32 X1 = X;</span>
<span class="line-removed"> 245       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 246       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 249       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251       xf0 = fptr[0];</span>
<span class="line-removed"> 252       xf1 = fptr[1];</span>
<span class="line-removed"> 253       xf2 = fptr[2];</span>
<span class="line-removed"> 254       xf3 = fptr[3];</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 257       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 258 </span>
<span class="line-removed"> 259       yf0 = fptr[0];</span>
<span class="line-removed"> 260       yf1 = fptr[1];</span>
<span class="line-removed"> 261       yf2 = fptr[2];</span>
<span class="line-removed"> 262       yf3 = fptr[3];</span>
<span class="line-removed"> 263 </span>
<span class="line-removed"> 264       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 265       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 268       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 269       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 270       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 271       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 272 </span>
<span class="line-removed"> 273 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 274 #pragma pipeloop(0)</span>
<span class="line-removed"> 275 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 276       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 277         X1 += dX;</span>
<span class="line-removed"> 278         Y1 += dY;</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 281               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 282         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 283         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 284               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 285         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 286         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 287               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 288         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 289         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 290               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 291 </span>
<span class="line-removed"> 292         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 293         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 294 </span>
<span class="line-removed"> 295         xf0 = fptr[0];</span>
<span class="line-removed"> 296         xf1 = fptr[1];</span>
<span class="line-removed"> 297         xf2 = fptr[2];</span>
<span class="line-removed"> 298         xf3 = fptr[3];</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 301 </span>
<span class="line-removed"> 302         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 303         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 304 </span>
<span class="line-removed"> 305         yf0 = fptr[0];</span>
<span class="line-removed"> 306         yf1 = fptr[1];</span>
<span class="line-removed"> 307         yf2 = fptr[2];</span>
<span class="line-removed"> 308         yf3 = fptr[3];</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310         SAT8(dPtr[0]);</span>
<span class="line-removed"> 311 </span>
<span class="line-removed"> 312         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 313         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 314 </span>
<span class="line-removed"> 315         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 316         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 317         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 318         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 319         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 320       }</span>
<span class="line-removed"> 321 </span>
<span class="line-removed"> 322       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 323             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 324       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 325       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 326             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 327       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 328       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 329             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 330       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 331       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 332             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 333 </span>
<span class="line-removed"> 334       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 335 </span>
<span class="line-removed"> 336       SAT8(dPtr[0]);</span>
<span class="line-removed"> 337     }</span>
<span class="line-removed"> 338   }</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340   return MLIB_SUCCESS;</span>
<span class="line-removed"> 341 }</span>
<span class="line-removed"> 342 </span>
<span class="line-removed"> 343 /***************************************************************/</span>
<span class="line-removed"> 344 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 345 {</span>
<span class="line-removed"> 346   DECLAREVAR_BC();</span>
<span class="line-removed"> 347   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 348   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 349   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 352     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 353   }</span>
<span class="line-removed"> 354   else {</span>
<span class="line-removed"> 355     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 356   }</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 359     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 360     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 361     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 362     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 363     mlib_f32 *fptr;</span>
<span class="line-removed"> 364     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366     CLIP(3);</span>
<span class="line-removed"> 367     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 370       mlib_s32 X1 = X;</span>
<span class="line-removed"> 371       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 372       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 375       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377       xf0 = fptr[0];</span>
<span class="line-removed"> 378       xf1 = fptr[1];</span>
<span class="line-removed"> 379       xf2 = fptr[2];</span>
<span class="line-removed"> 380       xf3 = fptr[3];</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 383       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385       yf0 = fptr[0];</span>
<span class="line-removed"> 386       yf1 = fptr[1];</span>
<span class="line-removed"> 387       yf2 = fptr[2];</span>
<span class="line-removed"> 388       yf3 = fptr[3];</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 391       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 394       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 395       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 396       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 397       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 400 #pragma pipeloop(0)</span>
<span class="line-removed"> 401 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 402       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 403         X1 += dX;</span>
<span class="line-removed"> 404         Y1 += dY;</span>
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 407               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 408         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 409         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 410               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 411         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 412         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 413               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 414         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 415         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 416               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 419         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 420 </span>
<span class="line-removed"> 421         xf0 = fptr[0];</span>
<span class="line-removed"> 422         xf1 = fptr[1];</span>
<span class="line-removed"> 423         xf2 = fptr[2];</span>
<span class="line-removed"> 424         xf3 = fptr[3];</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 429         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         yf0 = fptr[0];</span>
<span class="line-removed"> 432         yf1 = fptr[1];</span>
<span class="line-removed"> 433         yf2 = fptr[2];</span>
<span class="line-removed"> 434         yf3 = fptr[3];</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436         SAT8(dPtr[0]);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 439         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 442         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 443         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 444         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 445         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 446       }</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 449             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 450       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 451       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 452             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 453       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 454       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 455             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 456       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 457       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 458             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 459 </span>
<span class="line-removed"> 460       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462       SAT8(dPtr[0]);</span>
<span class="line-removed"> 463     }</span>
<span class="line-removed"> 464   }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466   return MLIB_SUCCESS;</span>
<span class="line-removed"> 467 }</span>
<span class="line-removed"> 468 </span>
<span class="line-removed"> 469 /***************************************************************/</span>
<span class="line-removed"> 470 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 471 {</span>
<span class="line-removed"> 472   DECLAREVAR_BC();</span>
<span class="line-removed"> 473   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 474   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 475   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 478     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 479   }</span>
<span class="line-removed"> 480   else {</span>
<span class="line-removed"> 481     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 482   }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 485     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 486     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 487     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 488     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 489     mlib_f32 *fptr;</span>
<span class="line-removed"> 490     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492     CLIP(4);</span>
<span class="line-removed"> 493     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 494 </span>
<span class="line-removed"> 495     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 496       mlib_s32 X1 = X;</span>
<span class="line-removed"> 497       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 498       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 499 </span>
<span class="line-removed"> 500       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 501       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 502 </span>
<span class="line-removed"> 503       xf0 = fptr[0];</span>
<span class="line-removed"> 504       xf1 = fptr[1];</span>
<span class="line-removed"> 505       xf2 = fptr[2];</span>
<span class="line-removed"> 506       xf3 = fptr[3];</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 509       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511       yf0 = fptr[0];</span>
<span class="line-removed"> 512       yf1 = fptr[1];</span>
<span class="line-removed"> 513       yf2 = fptr[2];</span>
<span class="line-removed"> 514       yf3 = fptr[3];</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 517       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 520       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 521       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 522       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 523       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 526 #pragma pipeloop(0)</span>
<span class="line-removed"> 527 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 528       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 529         X1 += dX;</span>
<span class="line-removed"> 530         Y1 += dY;</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 533               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 534         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 535         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 536               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 537         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 538         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 539               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 540         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 541         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 542               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 543 </span>
<span class="line-removed"> 544         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 545         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547         xf0 = fptr[0];</span>
<span class="line-removed"> 548         xf1 = fptr[1];</span>
<span class="line-removed"> 549         xf2 = fptr[2];</span>
<span class="line-removed"> 550         xf3 = fptr[3];</span>
<span class="line-removed"> 551 </span>
<span class="line-removed"> 552         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 555         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557         yf0 = fptr[0];</span>
<span class="line-removed"> 558         yf1 = fptr[1];</span>
<span class="line-removed"> 559         yf2 = fptr[2];</span>
<span class="line-removed"> 560         yf3 = fptr[3];</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562         SAT8(dPtr[0]);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 565         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 566 </span>
<span class="line-removed"> 567         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 568         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 569         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 570         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 571         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 572       }</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 575             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 576       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 577       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 578             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 579       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 580       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 581             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 582       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 583       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 584             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588       SAT8(dPtr[0]);</span>
<span class="line-removed"> 589     }</span>
<span class="line-removed"> 590   }</span>
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592   return MLIB_SUCCESS;</span>
<span class="line-removed"> 593 }</span>
<span class="line-removed"> 594 </span>
<span class="line-removed"> 595 #else       /* for x86, using integer multiplies is faster */</span>
 596 
 597 #define SHIFT_X  12
 598 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 599 
 600 #define SHIFT_Y  (14 + 14 - SHIFT_X)
 601 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 602 
 603 /***************************************************************/
 604 /* Test for the presence of any &quot;1&quot; bit in bits
 605    8 to 31 of val. If present, then val is either
 606    negative or &gt;255. If over/underflows of 8 bits
 607    are uncommon, then this technique can be a win,
 608    since only a single test, rather than two, is
 609    necessary to determine if clamping is needed.
 610    On the other hand, if over/underflows are common,
 611    it adds an extra test.
 612 */
 613 #define S32_TO_U8_SAT(DST)                                      \
 614   if (val0 &amp; 0xffffff00) {                                      \
 615     if (val0 &lt; MLIB_U8_MIN)                                     \
</pre>
<hr />
<pre>
 653     xf2 = fptr[2];
 654     xf3 = fptr[3];
 655 
 656     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 657     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 658 
 659     yf0 = fptr[0];
 660     yf1 = fptr[1];
 661     yf2 = fptr[2];
 662     yf3 = fptr[3];
 663 
 664     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 665     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 666 
 667     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 668     s0 = srcPixelPtr[0];
 669     s1 = srcPixelPtr[1];
 670     s2 = srcPixelPtr[2];
 671     s3 = srcPixelPtr[3];
 672 
<span class="line-removed"> 673 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 674 #pragma pipeloop(0)</span>
<span class="line-removed"> 675 #endif /* __SUNPRO_C */</span>
 676     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {
 677       X += dX;
 678       Y += dY;
 679 
 680       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 681       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 682       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 683             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 684       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 685       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 686             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 687       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 688       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 689             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 690 
 691       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 692       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 693 
 694       xf0 = fptr[0];
 695       xf1 = fptr[1];
</pre>
<hr />
<pre>
 775       xf2 = fptr[2];
 776       xf3 = fptr[3];
 777 
 778       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 779       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 780 
 781       yf0 = fptr[0];
 782       yf1 = fptr[1];
 783       yf2 = fptr[2];
 784       yf3 = fptr[3];
 785 
 786       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 787       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 788 
 789       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 790       s0 = srcPixelPtr[0];
 791       s1 = srcPixelPtr[2];
 792       s2 = srcPixelPtr[4];
 793       s3 = srcPixelPtr[6];
 794 
<span class="line-removed"> 795 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 796 #pragma pipeloop(0)</span>
<span class="line-removed"> 797 #endif /* __SUNPRO_C */</span>
 798       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {
 799         X1 += dX;
 800         Y1 += dY;
 801 
 802         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 803         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 804         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 805               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 806         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 807         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 808               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 809         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 810         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 811               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 812 
 813         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 814         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 815 
 816         xf0 = fptr[0];
 817         xf1 = fptr[1];
</pre>
<hr />
<pre>
 898       xf2 = fptr[2];
 899       xf3 = fptr[3];
 900 
 901       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 902       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 903 
 904       yf0 = fptr[0];
 905       yf1 = fptr[1];
 906       yf2 = fptr[2];
 907       yf3 = fptr[3];
 908 
 909       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 910       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 911 
 912       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 913       s0 = srcPixelPtr[0];
 914       s1 = srcPixelPtr[3];
 915       s2 = srcPixelPtr[6];
 916       s3 = srcPixelPtr[9];
 917 
<span class="line-removed"> 918 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 919 #pragma pipeloop(0)</span>
<span class="line-removed"> 920 #endif /* __SUNPRO_C */</span>
 921       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {
 922         X1 += dX;
 923         Y1 += dY;
 924 
 925         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 926         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 927         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 928               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 929         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 930         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 931               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 932         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 933         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 934               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 935 
 936         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 937         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 938 
 939         xf0 = fptr[0];
 940         xf1 = fptr[1];
</pre>
<hr />
<pre>
1021       xf2 = fptr[2];
1022       xf3 = fptr[3];
1023 
1024       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1025       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1026 
1027       yf0 = fptr[0];
1028       yf1 = fptr[1];
1029       yf2 = fptr[2];
1030       yf3 = fptr[3];
1031 
1032       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1033       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1034 
1035       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1036       s0 = srcPixelPtr[0];
1037       s1 = srcPixelPtr[4];
1038       s2 = srcPixelPtr[8];
1039       s3 = srcPixelPtr[12];
1040 
<span class="line-removed">1041 #ifdef __SUNPRO_C</span>
<span class="line-removed">1042 #pragma pipeloop(0)</span>
<span class="line-removed">1043 #endif /* __SUNPRO_C */</span>
1044       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {
1045         X1 += dX;
1046         Y1 += dY;
1047 
1048         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1049         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1050         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1051               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1052         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1053         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1054               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1055         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1056         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1057               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1058 
1059         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1060         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1061 
1062         xf0 = fptr[0];
1063         xf1 = fptr[1];
</pre>
<hr />
<pre>
1089       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1090       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1091       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1092             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1093       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1094       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1095             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1096       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1097       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1098             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1099 
1100       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1101 
1102       S32_TO_U8_SAT(dPtr[0]);
1103     }
1104   }
1105 
1106   return MLIB_SUCCESS;
1107 }
1108 
<span class="line-removed">1109 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1110 </span>
1111 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  54  *      dstYStride stride of destination image
  55  *      is_affine  indicator (Affine - GridWarp)
  56  *      srcYStride stride of source image
  57  *      filter     type of resampling filter
  58  *
  59  * DESCRIPTION
  60  *      The functions step along the lines from xLeft to xRight and apply
  61  *      the bicubic filtering.
  62  *
  63  */
  64 
  65 #include &quot;mlib_ImageAffine.h&quot;
  66 
  67 #define DTYPE  mlib_u8
  68 
  69 #define FUN_NAME(CHAN) mlib_ImageAffine_u8_##CHAN##_bc
  70 
  71 #define FILTER_BITS   8
  72 
  73 /***************************************************************/
<span class="line-modified">  74 /* for x86, using integer multiplies is faster */</span>









































































































































































































































































































































































































































































































































  75 
  76 #define SHIFT_X  12
  77 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
  78 
  79 #define SHIFT_Y  (14 + 14 - SHIFT_X)
  80 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
  81 
  82 /***************************************************************/
  83 /* Test for the presence of any &quot;1&quot; bit in bits
  84    8 to 31 of val. If present, then val is either
  85    negative or &gt;255. If over/underflows of 8 bits
  86    are uncommon, then this technique can be a win,
  87    since only a single test, rather than two, is
  88    necessary to determine if clamping is needed.
  89    On the other hand, if over/underflows are common,
  90    it adds an extra test.
  91 */
  92 #define S32_TO_U8_SAT(DST)                                      \
  93   if (val0 &amp; 0xffffff00) {                                      \
  94     if (val0 &lt; MLIB_U8_MIN)                                     \
</pre>
<hr />
<pre>
 132     xf2 = fptr[2];
 133     xf3 = fptr[3];
 134 
 135     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 136     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 137 
 138     yf0 = fptr[0];
 139     yf1 = fptr[1];
 140     yf2 = fptr[2];
 141     yf3 = fptr[3];
 142 
 143     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 144     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 145 
 146     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 147     s0 = srcPixelPtr[0];
 148     s1 = srcPixelPtr[1];
 149     s2 = srcPixelPtr[2];
 150     s3 = srcPixelPtr[3];
 151 



 152     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {
 153       X += dX;
 154       Y += dY;
 155 
 156       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 157       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 158       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 159             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 160       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 161       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 162             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 163       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 164       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 165             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 166 
 167       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 168       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 169 
 170       xf0 = fptr[0];
 171       xf1 = fptr[1];
</pre>
<hr />
<pre>
 251       xf2 = fptr[2];
 252       xf3 = fptr[3];
 253 
 254       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 255       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 256 
 257       yf0 = fptr[0];
 258       yf1 = fptr[1];
 259       yf2 = fptr[2];
 260       yf3 = fptr[3];
 261 
 262       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 263       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 264 
 265       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 266       s0 = srcPixelPtr[0];
 267       s1 = srcPixelPtr[2];
 268       s2 = srcPixelPtr[4];
 269       s3 = srcPixelPtr[6];
 270 



 271       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {
 272         X1 += dX;
 273         Y1 += dY;
 274 
 275         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 276         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 277         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 278               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 279         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 280         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 281               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 282         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 283         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 284               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 285 
 286         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 287         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 288 
 289         xf0 = fptr[0];
 290         xf1 = fptr[1];
</pre>
<hr />
<pre>
 371       xf2 = fptr[2];
 372       xf3 = fptr[3];
 373 
 374       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 375       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 376 
 377       yf0 = fptr[0];
 378       yf1 = fptr[1];
 379       yf2 = fptr[2];
 380       yf3 = fptr[3];
 381 
 382       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 383       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 384 
 385       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 386       s0 = srcPixelPtr[0];
 387       s1 = srcPixelPtr[3];
 388       s2 = srcPixelPtr[6];
 389       s3 = srcPixelPtr[9];
 390 



 391       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {
 392         X1 += dX;
 393         Y1 += dY;
 394 
 395         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 396         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 397         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 398               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 399         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 400         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 401               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 402         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 403         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 404               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 405 
 406         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 407         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 408 
 409         xf0 = fptr[0];
 410         xf1 = fptr[1];
</pre>
<hr />
<pre>
 491       xf2 = fptr[2];
 492       xf3 = fptr[3];
 493 
 494       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 495       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 496 
 497       yf0 = fptr[0];
 498       yf1 = fptr[1];
 499       yf2 = fptr[2];
 500       yf3 = fptr[3];
 501 
 502       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 503       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 504 
 505       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
 506       s0 = srcPixelPtr[0];
 507       s1 = srcPixelPtr[4];
 508       s2 = srcPixelPtr[8];
 509       s3 = srcPixelPtr[12];
 510 



 511       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {
 512         X1 += dX;
 513         Y1 += dY;
 514 
 515         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 516         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 517         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 518               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 519         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 520         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 521               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 522         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 523         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 524               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 525 
 526         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 527         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 528 
 529         xf0 = fptr[0];
 530         xf1 = fptr[1];
</pre>
<hr />
<pre>
 556       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 557       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 558       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 559             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 560       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 561       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 562             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 563       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 564       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 565             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 566 
 567       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 568 
 569       S32_TO_U8_SAT(dPtr[0]);
 570     }
 571   }
 572 
 573   return MLIB_SUCCESS;
 574 }
 575 


 576 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_SysMath.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BC_S16.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/share/native/libmlib_image/mlib_ImageLookUp_Bit.c b/src/java.desktop/share/native/libmlib_image/mlib_ImageLookUp_Bit.c
--- a/src/java.desktop/share/native/libmlib_image/mlib_ImageLookUp_Bit.c
+++ b/src/java.desktop/share/native/libmlib_image/mlib_ImageLookUp_Bit.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -162,20 +162,14 @@
   for (i = 0; i < 16; i++) {
     mlib_u32 v, mask = mlib_bit_mask[i];
 
     v = (val0 &~ mask) | (val1 & mask);
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (j = 0; j < 16; j++) {
       p_dd[2*(16*i + j)] = v;
     }
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (j = 0; j < 16; j++) {
       p_dd[2*(i + 16*j) + 1] = v;
     }
   }
 
@@ -221,13 +215,10 @@
     if ((mlib_addr)sa & 1 && size >= 8) {
       *da++ = dd_array[*sa++];
       i += 8;
     }
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
 #ifdef _LITTLE_ENDIAN
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
@@ -359,13 +350,10 @@
     }
 
     sa = (mlib_u8*)sp;
     da = (DTYPE*)dp;
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (i = 0; i <= (size - 16); i += 16) {
       s0 = *sa++;
       *da++ = dd_array[s0 >> 4];
       *da++ = dd_array[s0 & 0xF];
     }
@@ -477,13 +465,10 @@
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
 #endif /* _LITTLE_ENDIAN */
 
   /* calculate lookup table */
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
   for (i = 0; i < 16; i++) {
     mlib_u32 mask0 = mlib_bit_mask_3[i >> 2];
     mlib_u32 mask1 = mlib_bit_mask_3[4 + ((i >> 1) & 3)];
     mlib_u32 mask2 = mlib_bit_mask_3[8 + (i & 3)];
 
@@ -511,13 +496,10 @@
     }
 
     sa = (mlib_u8*)sp;
     da = (mlib_u32*)dp;
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (i = 0; i <= (size - 24); i += 24) {
       d64_2_f32 dd;
       s0 = *sa++;
 
       ((TYPE_64BIT*)da)[0] = *(d_array01 + (s0 >> 4));
@@ -656,13 +638,10 @@
     }
 
     sa = (mlib_u8*)sp;
     da = (DTYPE*)dp;
 
-#ifdef __SUNPRO_C
-#pragma pipeloop(0)
-#endif /* __SUNPRO_C */
     for (i = 0; i <= (size - 32); i += 32) {
       s0 = *sa++;
       *da++ = dd_array0[s0 >> 4];
       *da++ = dd_array1[s0 >> 4];
       *da++ = dd_array0[s0 & 0xF];

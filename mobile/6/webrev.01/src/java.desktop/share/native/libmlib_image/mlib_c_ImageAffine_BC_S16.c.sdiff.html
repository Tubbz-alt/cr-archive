<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_S16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_c_ImageAffine_BC.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BC_U16.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_S16.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  51  *      lineAddr   array[srcHeight] of pointers to the first pixel on
  52  *                 the corresponding lines
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE           mlib_s16
  67 #define FILTER_BITS     9
  68 #define FUN_NAME(CHAN)  mlib_ImageAffine_s16_##CHAN##_bc
  69 
  70 /***************************************************************/
<span class="line-modified">  71 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  72 </span>
<span class="line-removed">  73 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  74 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  77 </span>
<span class="line-removed">  78 #define SAT16(DST)                                              \</span>
<span class="line-removed">  79   DST = ((mlib_s32)val0) &gt;&gt; 16</span>
<span class="line-removed">  80 </span>
<span class="line-removed">  81 #else</span>
<span class="line-removed">  82 </span>
<span class="line-removed">  83 #define SAT16(DST)                                              \</span>
<span class="line-removed">  84   if (val0 &gt;= MLIB_S32_MAX)                                     \</span>
<span class="line-removed">  85     DST = MLIB_S16_MAX;                                         \</span>
<span class="line-removed">  86   else if (val0 &lt;= MLIB_S32_MIN)                                \</span>
<span class="line-removed">  87     DST = MLIB_S16_MIN;                                         \</span>
<span class="line-removed">  88   else                                                          \</span>
<span class="line-removed">  89     DST = ((mlib_s32)val0) &gt;&gt; 16</span>
<span class="line-removed">  90 </span>
<span class="line-removed">  91 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  92 </span>
<span class="line-removed">  93 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  94 {</span>
<span class="line-removed">  95   DECLAREVAR_BC();</span>
<span class="line-removed">  96   DTYPE *dstLineEnd;</span>
<span class="line-removed">  97   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed">  98 </span>
<span class="line-removed">  99   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 100     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 101   }</span>
<span class="line-removed"> 102   else {</span>
<span class="line-removed"> 103     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 104   }</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 107     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 108     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 109     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 110     mlib_s32 filterpos;</span>
<span class="line-removed"> 111     mlib_f32 *fptr;</span>
<span class="line-removed"> 112     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 113     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 114 </span>
<span class="line-removed"> 115     CLIP(1);</span>
<span class="line-removed"> 116     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 117 </span>
<span class="line-removed"> 118     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 119     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 120 </span>
<span class="line-removed"> 121     xf0 = fptr[0];</span>
<span class="line-removed"> 122     xf1 = fptr[1];</span>
<span class="line-removed"> 123     xf2 = fptr[2];</span>
<span class="line-removed"> 124     xf3 = fptr[3];</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 127     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 128 </span>
<span class="line-removed"> 129     yf0 = fptr[0];</span>
<span class="line-removed"> 130     yf1 = fptr[1];</span>
<span class="line-removed"> 131     yf2 = fptr[2];</span>
<span class="line-removed"> 132     yf3 = fptr[3];</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 135     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 136 </span>
<span class="line-removed"> 137     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 138     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 139     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 140     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 141     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 142 </span>
<span class="line-removed"> 143     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 144     s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 145     s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 146     s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 147     s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 148 </span>
<span class="line-removed"> 149     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 150 </span>
<span class="line-removed"> 151       X += dX;</span>
<span class="line-removed"> 152       Y += dY;</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 155       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 156       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 157       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 158             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 159       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 160       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 161             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 162 </span>
<span class="line-removed"> 163       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 164       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166       xf0 = fptr[0];</span>
<span class="line-removed"> 167       xf1 = fptr[1];</span>
<span class="line-removed"> 168       xf2 = fptr[2];</span>
<span class="line-removed"> 169       xf3 = fptr[3];</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 174       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 175 </span>
<span class="line-removed"> 176       yf0 = fptr[0];</span>
<span class="line-removed"> 177       yf1 = fptr[1];</span>
<span class="line-removed"> 178       yf2 = fptr[2];</span>
<span class="line-removed"> 179       yf3 = fptr[3];</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181       SAT16(dstPixelPtr[0]);</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 184       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 185 </span>
<span class="line-removed"> 186       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 187       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 188       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 189       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 190       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 191 </span>
<span class="line-removed"> 192       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 193       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 194       s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 195       s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 196       s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 197     }</span>
<span class="line-removed"> 198 </span>
<span class="line-removed"> 199     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 200     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 201     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 202     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 203           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 204     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 205     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 206           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 209     SAT16(dstPixelPtr[0]);</span>
<span class="line-removed"> 210   }</span>
<span class="line-removed"> 211 </span>
<span class="line-removed"> 212   return MLIB_SUCCESS;</span>
<span class="line-removed"> 213 }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 216 {</span>
<span class="line-removed"> 217   DECLAREVAR_BC();</span>
<span class="line-removed"> 218   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 219   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 220 </span>
<span class="line-removed"> 221   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 222     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 223   }</span>
<span class="line-removed"> 224   else {</span>
<span class="line-removed"> 225     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 226   }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 229     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 230     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 231     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 232     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 233     mlib_f32 *fptr;</span>
<span class="line-removed"> 234     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 235     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237     CLIP(2);</span>
<span class="line-removed"> 238     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 241       mlib_s32 X1 = X;</span>
<span class="line-removed"> 242       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 243       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 244 </span>
<span class="line-removed"> 245       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 246       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248       xf0 = fptr[0];</span>
<span class="line-removed"> 249       xf1 = fptr[1];</span>
<span class="line-removed"> 250       xf2 = fptr[2];</span>
<span class="line-removed"> 251       xf3 = fptr[3];</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 254       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256       yf0 = fptr[0];</span>
<span class="line-removed"> 257       yf1 = fptr[1];</span>
<span class="line-removed"> 258       yf2 = fptr[2];</span>
<span class="line-removed"> 259       yf3 = fptr[3];</span>
<span class="line-removed"> 260 </span>
<span class="line-removed"> 261       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 262       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 263 </span>
<span class="line-removed"> 264       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 265       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 266       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 267       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 268       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 271       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 272       s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 273       s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 274       s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 277 </span>
<span class="line-removed"> 278         X1 += dX;</span>
<span class="line-removed"> 279         Y1 += dY;</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 282         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 283         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 284         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 285               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 286         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 287         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 288               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 291         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293         xf0 = fptr[0];</span>
<span class="line-removed"> 294         xf1 = fptr[1];</span>
<span class="line-removed"> 295         xf2 = fptr[2];</span>
<span class="line-removed"> 296         xf3 = fptr[3];</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 301         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303         yf0 = fptr[0];</span>
<span class="line-removed"> 304         yf1 = fptr[1];</span>
<span class="line-removed"> 305         yf2 = fptr[2];</span>
<span class="line-removed"> 306         yf3 = fptr[3];</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308         SAT16(dPtr[0]);</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 311         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 314         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 315         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 316         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 317         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 318 </span>
<span class="line-removed"> 319         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 320         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 321         s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 322         s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 323         s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 324       }</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 327       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 328       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 329       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 330             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 331       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 332       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 333             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 336       SAT16(dPtr[0]);</span>
<span class="line-removed"> 337     }</span>
<span class="line-removed"> 338   }</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340   return MLIB_SUCCESS;</span>
<span class="line-removed"> 341 }</span>
<span class="line-removed"> 342 </span>
<span class="line-removed"> 343 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 344 {</span>
<span class="line-removed"> 345   DECLAREVAR_BC();</span>
<span class="line-removed"> 346   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 347   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 350     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 351   }</span>
<span class="line-removed"> 352   else {</span>
<span class="line-removed"> 353     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 354   }</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 357     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 358     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 359     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 360     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 361     mlib_f32 *fptr;</span>
<span class="line-removed"> 362     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 363     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365     CLIP(3);</span>
<span class="line-removed"> 366     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 367 </span>
<span class="line-removed"> 368     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 369       mlib_s32 X1 = X;</span>
<span class="line-removed"> 370       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 371       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 372 </span>
<span class="line-removed"> 373       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 374       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 375 </span>
<span class="line-removed"> 376       xf0 = fptr[0];</span>
<span class="line-removed"> 377       xf1 = fptr[1];</span>
<span class="line-removed"> 378       xf2 = fptr[2];</span>
<span class="line-removed"> 379       xf3 = fptr[3];</span>
<span class="line-removed"> 380 </span>
<span class="line-removed"> 381       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 382       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 383 </span>
<span class="line-removed"> 384       yf0 = fptr[0];</span>
<span class="line-removed"> 385       yf1 = fptr[1];</span>
<span class="line-removed"> 386       yf2 = fptr[2];</span>
<span class="line-removed"> 387       yf3 = fptr[3];</span>
<span class="line-removed"> 388 </span>
<span class="line-removed"> 389       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 390       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 393       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 394       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 395       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 396       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 397 </span>
<span class="line-removed"> 398       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 399       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 400       s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 401       s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 402       s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406         X1 += dX;</span>
<span class="line-removed"> 407         Y1 += dY;</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 410         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 411         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 412         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 413               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 414         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 415         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 416               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 419         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 420 </span>
<span class="line-removed"> 421         xf0 = fptr[0];</span>
<span class="line-removed"> 422         xf1 = fptr[1];</span>
<span class="line-removed"> 423         xf2 = fptr[2];</span>
<span class="line-removed"> 424         xf3 = fptr[3];</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 429         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         yf0 = fptr[0];</span>
<span class="line-removed"> 432         yf1 = fptr[1];</span>
<span class="line-removed"> 433         yf2 = fptr[2];</span>
<span class="line-removed"> 434         yf3 = fptr[3];</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436         SAT16(dPtr[0]);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 439         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 442         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 443         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 444         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 445         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 446 </span>
<span class="line-removed"> 447         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 448         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 449         s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 450         s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 451         s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 452       }</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 455       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 456       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 457       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 458             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 459       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 460       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 461             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 462 </span>
<span class="line-removed"> 463       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 464       SAT16(dPtr[0]);</span>
<span class="line-removed"> 465     }</span>
<span class="line-removed"> 466   }</span>
<span class="line-removed"> 467 </span>
<span class="line-removed"> 468   return MLIB_SUCCESS;</span>
<span class="line-removed"> 469 }</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 472 {</span>
<span class="line-removed"> 473   DECLAREVAR_BC();</span>
<span class="line-removed"> 474   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 475   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 478     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 479   }</span>
<span class="line-removed"> 480   else {</span>
<span class="line-removed"> 481     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 482   }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 485     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 486     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 487     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 488     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 489     mlib_f32 *fptr;</span>
<span class="line-removed"> 490     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 491     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493     CLIP(4);</span>
<span class="line-removed"> 494     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 497       mlib_s32 X1 = X;</span>
<span class="line-removed"> 498       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 499       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 502       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504       xf0 = fptr[0];</span>
<span class="line-removed"> 505       xf1 = fptr[1];</span>
<span class="line-removed"> 506       xf2 = fptr[2];</span>
<span class="line-removed"> 507       xf3 = fptr[3];</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 510       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       yf0 = fptr[0];</span>
<span class="line-removed"> 513       yf1 = fptr[1];</span>
<span class="line-removed"> 514       yf2 = fptr[2];</span>
<span class="line-removed"> 515       yf3 = fptr[3];</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 518       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 521       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 522       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 523       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 524       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 525 </span>
<span class="line-removed"> 526       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 527       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 528       s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 529       s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 530       s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534         X1 += dX;</span>
<span class="line-removed"> 535         Y1 += dY;</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 538         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 539         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 540         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 541               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 542         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 543         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 544               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 545 </span>
<span class="line-removed"> 546         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 547         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549         xf0 = fptr[0];</span>
<span class="line-removed"> 550         xf1 = fptr[1];</span>
<span class="line-removed"> 551         xf2 = fptr[2];</span>
<span class="line-removed"> 552         xf3 = fptr[3];</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 557         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559         yf0 = fptr[0];</span>
<span class="line-removed"> 560         yf1 = fptr[1];</span>
<span class="line-removed"> 561         yf2 = fptr[2];</span>
<span class="line-removed"> 562         yf3 = fptr[3];</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         SAT16(dPtr[0]);</span>
<span class="line-removed"> 565 </span>
<span class="line-removed"> 566         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 567         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 570         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 571         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 572         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 573         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 574 </span>
<span class="line-removed"> 575         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 576         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 577         s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 578         s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 579         s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 580       }</span>
<span class="line-removed"> 581 </span>
<span class="line-removed"> 582       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 583       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 584       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 585       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 586             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 587       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 588       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 589             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 592       SAT16(dPtr[0]);</span>
<span class="line-removed"> 593     }</span>
<span class="line-removed"> 594   }</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   return MLIB_SUCCESS;</span>
<span class="line-removed"> 597 }</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599 #else       /* for x86, using integer multiplies is faster */</span>
 600 
 601 #define SHIFT_X  15
 602 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 603 
 604 #define SHIFT_Y  (15 + 15 - SHIFT_X)
 605 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 606 
 607 #define S32_TO_S16_SAT(DST)                                     \
 608   if (val0 &gt;= MLIB_S16_MAX)                                     \
 609     DST = MLIB_S16_MAX;                                         \
 610   else if (val0 &lt;= MLIB_S16_MIN)                                \
 611     DST = MLIB_S16_MIN;                                         \
 612   else                                                          \
 613     DST = (mlib_s16)val0
 614 
 615 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
 616 {
 617   DECLAREVAR_BC();
 618   DTYPE *dstLineEnd;
 619   const mlib_s16 *mlib_filters_table;
</pre>
<hr />
<pre>
1101         s7 = srcPixelPtr[12];
1102       }
1103 
1104       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1105       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1106       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1107       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1108             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1109       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1110       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1111             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1112 
1113       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1114       S32_TO_S16_SAT(dPtr[0]);
1115     }
1116   }
1117 
1118   return MLIB_SUCCESS;
1119 }
1120 
<span class="line-removed">1121 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1122 </span>
1123 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  51  *      lineAddr   array[srcHeight] of pointers to the first pixel on
  52  *                 the corresponding lines
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE           mlib_s16
  67 #define FILTER_BITS     9
  68 #define FUN_NAME(CHAN)  mlib_ImageAffine_s16_##CHAN##_bc
  69 
  70 /***************************************************************/
<span class="line-modified">  71 /* for x86, using integer multiplies is faster */</span>
















































































































































































































































































































































































































































































































































  72 
  73 #define SHIFT_X  15
  74 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
  75 
  76 #define SHIFT_Y  (15 + 15 - SHIFT_X)
  77 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
  78 
  79 #define S32_TO_S16_SAT(DST)                                     \
  80   if (val0 &gt;= MLIB_S16_MAX)                                     \
  81     DST = MLIB_S16_MAX;                                         \
  82   else if (val0 &lt;= MLIB_S16_MIN)                                \
  83     DST = MLIB_S16_MIN;                                         \
  84   else                                                          \
  85     DST = (mlib_s16)val0
  86 
  87 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
  88 {
  89   DECLAREVAR_BC();
  90   DTYPE *dstLineEnd;
  91   const mlib_s16 *mlib_filters_table;
</pre>
<hr />
<pre>
 573         s7 = srcPixelPtr[12];
 574       }
 575 
 576       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 577       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 578       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 579       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 580             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 581       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 582       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
 583             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 584 
 585       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 586       S32_TO_S16_SAT(dPtr[0]);
 587     }
 588   }
 589 
 590   return MLIB_SUCCESS;
 591 }
 592 


 593 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_c_ImageAffine_BC.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_BC_U16.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
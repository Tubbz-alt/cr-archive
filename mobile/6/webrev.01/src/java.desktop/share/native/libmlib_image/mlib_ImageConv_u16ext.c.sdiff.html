<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_ImageConv_u16ext.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_ImageConv_F32nw.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_u16nw.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_ImageConv_u16ext.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 172 #define DEF_VARS(type)                                          \
 173   type     *adr_src, *sl, *sp, *sl1;                            \
 174   type     *adr_dst, *dl, *dp;                                  \
 175   FTYPE    *pbuff = buff;                                       \
 176   mlib_s32 *buffi, *buffo;                                      \
 177   mlib_s32 wid, hgt, sll, dll;                                  \
 178   mlib_s32 nchannel, chan1, chan2;                              \
 179   mlib_s32 i, j, c, swid
 180 
 181 /***************************************************************/
 182 #define GET_SRC_DST_PARAMETERS(type)                            \
 183   hgt = mlib_ImageGetHeight(src);                               \
 184   wid = mlib_ImageGetWidth(src);                                \
 185   nchannel = mlib_ImageGetChannels(src);                        \
 186   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 187   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 188   adr_src = (type *)mlib_ImageGetData(src);                     \
 189   adr_dst = (type *)mlib_ImageGetData(dst)
 190 
 191 /***************************************************************/
<span class="line-removed"> 192 #ifndef __sparc</span>
 193 #if IMG_TYPE == 1
 194 
 195 /*
 196  * Test for the presence of any &quot;1&quot; bit in bits
 197    8 to 31 of val. If present, then val is either
 198    negative or &gt;255. If over/underflows of 8 bits
 199    are uncommon, then this technique can be a win,
 200    since only a single test, rather than two, is
 201    necessary to determine if clamping is needed.
 202    On the other hand, if over/underflows are common,
 203    it adds an extra test.
 204 */
 205 #define CLAMP_STORE(dst, val)                                   \
 206   if (val &amp; 0xffffff00) {                                       \
 207     if (val &lt; MLIB_U8_MIN)                                      \
 208       dst = MLIB_U8_MIN;                                        \
 209     else                                                        \
 210       dst = MLIB_U8_MAX;                                        \
 211   } else {                                                      \
 212     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 216 
 217 #define CLAMP_STORE(dst, val)                                   \
 218   if (val &gt;= MLIB_S16_MAX)                                      \
 219     dst = MLIB_S16_MAX;                                         \
 220   else if (val &lt;= MLIB_S16_MIN)                                 \
 221     dst = MLIB_S16_MIN;                                         \
 222   else                                                          \
 223     dst = (mlib_s16)val
 224 
 225 #elif IMG_TYPE == 3
 226 
 227 #define CLAMP_STORE(dst, val)                                   \
 228   if (val &gt;= MLIB_U16_MAX)                                      \
 229     dst = MLIB_U16_MAX;                                         \
 230   else if (val &lt;= MLIB_U16_MIN)                                 \
 231     dst = MLIB_U16_MIN;                                         \
 232   else                                                          \
 233     dst = (mlib_u16)val
 234 
 235 #endif /* IMG_TYPE == 1 */
<span class="line-removed"> 236 #endif /* __sparc */</span>
 237 
 238 /***************************************************************/
 239 #define MAX_KER   7
 240 #define MAX_N    15
 241 #define BUFF_SIZE   1600
 242 #define CACHE_SIZE  (64*1024)
 243 
 244 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 245                                          const mlib_image *src,
 246                                          const mlib_d64   *k,
 247                                          mlib_s32         n,
 248                                          mlib_s32         dy_t,
 249                                          mlib_s32         dy_b,
 250                                          mlib_s32         cmask)
 251 {
 252   DTYPE    *adr_src, *sl;
 253   DTYPE    *adr_dst, *dl, *dp;
 254   FTYPE    buff[BUFF_SIZE];
 255   FTYPE    *buffd;
 256   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 284 
 285   sbuff = pbuff;
 286   buffd = sbuff + smax_hsize;
 287 
 288   shgt -= (dy_t + dy_b);
 289   k_off = 0;
 290 
 291   for (l = 0; l &lt; hgt; l += hsize) {
 292     hsize = hgt - l;
 293 
 294     if (hsize &gt; max_hsize) hsize = max_hsize;
 295 
 296     smax_hsize = hsize + (n - 1);
 297 
 298     for (c = 0; c &lt; nchannel; c++) {
 299       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 300 
 301       sl = adr_src + c;
 302       dl = adr_dst + c;
 303 
<span class="line-removed"> 304 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 305 #pragma pipeloop(0)</span>
<span class="line-removed"> 306 #endif /* __SUNPRO_C */</span>
 307       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 308 
 309       for (j = 0; j &lt; wid; j++) {
 310         FTYPE    *buff = sbuff;
 311 
 312         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 313           sbuff[i - k_off] = (FTYPE)sl[0];
 314         }
 315 
<span class="line-removed"> 316 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 317 #pragma pipeloop(0)</span>
<span class="line-removed"> 318 #endif /* __SUNPRO_C */</span>
 319         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 320           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 321         }
 322 
 323         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 324           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 325         }
 326 
 327         pk = k;
 328 
 329         for (off = 0; off &lt; (n - 4); off += 4) {
 330 
 331           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 332           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 333 
<span class="line-removed"> 334 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 335 #pragma pipeloop(0)</span>
<span class="line-removed"> 336 #endif /* __SUNPRO_C */</span>
 337           for (i = 0; i &lt; hsize; i += 2) {
 338             p0 = p2; p1 = p3; p2 = p4;
 339 
 340             p3 = buff[i + 3]; p4 = buff[i + 4];
 341 
 342             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 343             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 344           }
 345 
 346           pk += 4;
 347           buff += 4;
 348         }
 349 
 350         dp = dl;
 351         kh = n - off;
 352 
 353         if (kh == 4) {
 354           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 355           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 356 
<span class="line-removed"> 357 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 358 #pragma pipeloop(0)</span>
<span class="line-removed"> 359 #endif /* __SUNPRO_C */</span>
 360           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 361             p0 = p2; p1 = p3; p2 = p4;
 362 
 363             p3 = buff[i + 3]; p4 = buff[i + 4];
 364 
 365             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 366             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 367 
 368             dp[0  ] = FROM_S32(d0);
 369             dp[dll] = FROM_S32(d1);
 370 
 371             buffd[i    ] = 0.0;
 372             buffd[i + 1] = 0.0;
 373 
 374             dp += 2*dll;
 375           }
 376 
 377           if (i &lt; hsize) {
 378             p0 = p2; p1 = p3; p2 = p4;
 379             p3 = buff[i + 3];
 380             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 381             dp[0] = FROM_S32(d0);
 382             buffd[i] = 0.0;
 383           }
 384 
 385         } else if (kh == 3) {
 386 
 387           p2 = buff[0]; p3 = buff[1];
 388           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 389 
<span class="line-removed"> 390 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 391 #pragma pipeloop(0)</span>
<span class="line-removed"> 392 #endif /* __SUNPRO_C */</span>
 393           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 394             p0 = p2; p1 = p3;
 395 
 396             p2 = buff[i + 2]; p3 = buff[i + 3];
 397 
 398             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 399             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 400 
 401             dp[0  ] = FROM_S32(d0);
 402             dp[dll] = FROM_S32(d1);
 403 
 404             buffd[i    ] = 0.0;
 405             buffd[i + 1] = 0.0;
 406 
 407             dp += 2*dll;
 408           }
 409 
 410           if (i &lt; hsize) {
 411             p0 = p2; p1 = p3;
 412             p2 = buff[i + 2];
 413             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 414             dp[0] = FROM_S32(d0);
 415 
 416             buffd[i] = 0.0;
 417           }
 418 
 419         } else if (kh == 2) {
 420 
 421           p2 = buff[0];
 422           k0 = pk[0]; k1 = pk[1];
 423 
<span class="line-removed"> 424 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 425 #pragma pipeloop(0)</span>
<span class="line-removed"> 426 #endif /* __SUNPRO_C */</span>
 427           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 428             p0 = p2;
 429 
 430             p1 = buff[i + 1]; p2 = buff[i + 2];
 431 
 432             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 433             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 434 
 435             dp[0  ] = FROM_S32(d0);
 436             dp[dll] = FROM_S32(d1);
 437 
 438             buffd[i    ] = 0.0;
 439             buffd[i + 1] = 0.0;
 440 
 441             dp += 2*dll;
 442           }
 443 
 444           if (i &lt; hsize) {
 445             p0 = p2;
 446             p1 = buff[i + 1];
 447             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 448             dp[0] = FROM_S32(d0);
 449 
 450             buffd[i] = 0.0;
 451           }
 452 
 453         } else /* kh == 1 */{
 454 
 455           k0 = pk[0];
 456 
<span class="line-removed"> 457 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 458 #pragma pipeloop(0)</span>
<span class="line-removed"> 459 #endif /* __SUNPRO_C */</span>
 460           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 461             p0 = buff[i]; p1 = buff[i + 1];
 462 
 463             d0 = D2I(p0*k0 + buffd[i    ]);
 464             d1 = D2I(p1*k0 + buffd[i + 1]);
 465 
 466             dp[0  ] = FROM_S32(d0);
 467             dp[dll] = FROM_S32(d1);
 468 
 469             buffd[i    ] = 0.0;
 470             buffd[i + 1] = 0.0;
 471 
 472             dp += 2*dll;
 473           }
 474 
 475           if (i &lt; hsize) {
 476             p0 = buff[i];
 477             d0 = D2I(p0*k0 + buffd[i]);
 478             dp[0] = FROM_S32(d0);
 479 
</pre>
<hr />
<pre>
 562   buffi = (mlib_s32*)(buffd + swid);
 563 
 564   chan1 = nchannel;
 565   chan2 = chan1 + chan1;
 566 
 567   swid -= (dx_l + dx_r);
 568 
 569   for (c = 0; c &lt; nchannel; c++) {
 570     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 571 
 572     sl = adr_src + c;
 573     dl = adr_dst + c;
 574 
 575     for (l = 0; l &lt; n; l++) {
 576       FTYPE    *buff = buffs[l];
 577 
 578       for (i = 0; i &lt; dx_l; i++) {
 579         buff[i] = (FTYPE)sl[0];
 580       }
 581 
<span class="line-removed"> 582 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 583 #pragma pipeloop(0)</span>
<span class="line-removed"> 584 #endif /* __SUNPRO_C */</span>
 585       for (i = 0; i &lt; swid; i++) {
 586         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 587       }
 588 
 589       for (i = 0; i &lt; dx_r; i++) {
 590         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 591       }
 592 
 593       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 594     }
 595 
 596     buff_ind = 0;
 597 
<span class="line-removed"> 598 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 599 #pragma pipeloop(0)</span>
<span class="line-removed"> 600 #endif /* __SUNPRO_C */</span>
 601     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 602 
 603     for (j = 0; j &lt; hgt; j++) {
 604       FTYPE    **buffc = buffs + buff_ind;
 605       FTYPE    *buffn = buffc[n];
 606       FTYPE    *pk = k;
 607 
 608       for (l = 0; l &lt; n; l++) {
 609         FTYPE    *buff_l = buffc[l];
 610 
 611         for (off = 0; off &lt; m;) {
 612           FTYPE    *buff = buff_l + off;
 613 
 614           kw = m - off;
 615 
 616           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 617             if (kw &gt; MAX_KER) kw = kw/2;
 618           off += kw;
 619 
 620           sp = sl;
 621           dp = dl;
 622 
 623           if (kw == 7) {
 624 
 625             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 626             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 627 
 628             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 629             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 630 
 631             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 632 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 633 #pragma pipeloop(0)</span>
<span class="line-removed"> 634 #endif /* __SUNPRO_C */</span>
 635               for (i = 0; i &lt;= (wid - 2); i += 2) {
 636                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 637 
 638                 p6 = buff[i + 6]; p7 = buff[i + 7];
 639 
 640                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 641                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 642               }
 643 
 644             } else {
<span class="line-removed"> 645 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 646 #pragma pipeloop(0)</span>
<span class="line-removed"> 647 #endif /* __SUNPRO_C */</span>
 648               for (i = 0; i &lt;= (wid - 2); i += 2) {
 649                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 650 
 651                 p6 = buff[i + 6]; p7 = buff[i + 7];
 652 
 653                 LOAD_BUFF(buffi);
 654 
 655                 dd.d64 = *(FTYPE   *)(buffi + i);
 656                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 657                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 658 
 659                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 660                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 661 
 662                 dp[0    ] = FROM_S32(d0);
 663                 dp[chan1] = FROM_S32(d1);
 664 
 665                 buffd[i    ] = 0.0;
 666                 buffd[i + 1] = 0.0;
 667 
 668                 sp += chan2;
 669                 dp += chan2;
 670               }
 671             }
 672 
 673           } else if (kw == 6) {
 674 
 675             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 676             p5 = buff[3]; p6 = buff[4];
 677 
 678             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 679             k4 = pk[4]; k5 = pk[5];
 680 
 681             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 682 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 683 #pragma pipeloop(0)</span>
<span class="line-removed"> 684 #endif /* __SUNPRO_C */</span>
 685               for (i = 0; i &lt;= (wid - 2); i += 2) {
 686                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 687 
 688                 p5 = buff[i + 5]; p6 = buff[i + 6];
 689 
 690                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 691                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 692               }
 693 
 694             } else {
<span class="line-removed"> 695 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 696 #pragma pipeloop(0)</span>
<span class="line-removed"> 697 #endif /* __SUNPRO_C */</span>
 698               for (i = 0; i &lt;= (wid - 2); i += 2) {
 699                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 700 
 701                 p5 = buff[i + 5]; p6 = buff[i + 6];
 702 
 703                 LOAD_BUFF(buffi);
 704 
 705                 dd.d64 = *(FTYPE   *)(buffi + i);
 706                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 707                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 708 
 709                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 710                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 711 
 712                 dp[0    ] = FROM_S32(d0);
 713                 dp[chan1] = FROM_S32(d1);
 714 
 715                 buffd[i    ] = 0.0;
 716                 buffd[i + 1] = 0.0;
 717 
 718                 sp += chan2;
 719                 dp += chan2;
 720               }
 721             }
 722 
 723           } else if (kw == 5) {
 724 
 725             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 726             p5 = buff[3];
 727 
 728             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 729             k4 = pk[4];
 730 
 731             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 732 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 733 #pragma pipeloop(0)</span>
<span class="line-removed"> 734 #endif /* __SUNPRO_C */</span>
 735               for (i = 0; i &lt;= (wid - 2); i += 2) {
 736                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 737 
 738                 p4 = buff[i + 4]; p5 = buff[i + 5];
 739 
 740                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 741                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 742               }
 743 
 744             } else {
<span class="line-removed"> 745 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 746 #pragma pipeloop(0)</span>
<span class="line-removed"> 747 #endif /* __SUNPRO_C */</span>
 748               for (i = 0; i &lt;= (wid - 2); i += 2) {
 749                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 750 
 751                 p4 = buff[i + 4]; p5 = buff[i + 5];
 752 
 753                 LOAD_BUFF(buffi);
 754 
 755                 dd.d64 = *(FTYPE   *)(buffi + i);
 756                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 757                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 758 
 759                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 760                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 761 
 762                 dp[0    ] = FROM_S32(d0);
 763                 dp[chan1] = FROM_S32(d1);
 764 
 765                 buffd[i    ] = 0.0;
 766                 buffd[i + 1] = 0.0;
 767 
 768                 sp += chan2;
 769                 dp += chan2;
 770               }
 771             }
 772 
 773           } else if (kw == 4) {
 774 
 775             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 776 
 777             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 778 
 779             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 780 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 781 #pragma pipeloop(0)</span>
<span class="line-removed"> 782 #endif /* __SUNPRO_C */</span>
 783               for (i = 0; i &lt;= (wid - 2); i += 2) {
 784                 p0 = p2; p1 = p3; p2 = p4;
 785 
 786                 p3 = buff[i + 3]; p4 = buff[i + 4];
 787 
 788                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 789                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 790               }
 791 
 792             } else {
<span class="line-removed"> 793 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 794 #pragma pipeloop(0)</span>
<span class="line-removed"> 795 #endif /* __SUNPRO_C */</span>
 796               for (i = 0; i &lt;= (wid - 2); i += 2) {
 797                 p0 = p2; p1 = p3; p2 = p4;
 798 
 799                 p3 = buff[i + 3]; p4 = buff[i + 4];
 800 
 801                 LOAD_BUFF(buffi);
 802 
 803                 dd.d64 = *(FTYPE   *)(buffi + i);
 804                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 805                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 806 
 807                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 808                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 809 
 810                 dp[0    ] = FROM_S32(d0);
 811                 dp[chan1] = FROM_S32(d1);
 812 
 813                 buffd[i    ] = 0.0;
 814                 buffd[i + 1] = 0.0;
 815 
 816                 sp += chan2;
 817                 dp += chan2;
 818               }
 819             }
 820 
 821           } else if (kw == 3) {
 822 
 823             p2 = buff[0]; p3 = buff[1];
 824             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 825 
 826             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 827 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 828 #pragma pipeloop(0)</span>
<span class="line-removed"> 829 #endif /* __SUNPRO_C */</span>
 830               for (i = 0; i &lt;= (wid - 2); i += 2) {
 831                 p0 = p2; p1 = p3;
 832 
 833                 p2 = buff[i + 2]; p3 = buff[i + 3];
 834 
 835                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 836                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 837               }
 838 
 839             } else {
<span class="line-removed"> 840 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 841 #pragma pipeloop(0)</span>
<span class="line-removed"> 842 #endif /* __SUNPRO_C */</span>
 843               for (i = 0; i &lt;= (wid - 2); i += 2) {
 844                 p0 = p2; p1 = p3;
 845 
 846                 p2 = buff[i + 2]; p3 = buff[i + 3];
 847 
 848                 LOAD_BUFF(buffi);
 849 
 850                 dd.d64 = *(FTYPE   *)(buffi + i);
 851                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 852                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 853 
 854                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 855                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 856 
 857                 dp[0    ] = FROM_S32(d0);
 858                 dp[chan1] = FROM_S32(d1);
 859 
 860                 buffd[i    ] = 0.0;
 861                 buffd[i + 1] = 0.0;
 862 
 863                 sp += chan2;
 864                 dp += chan2;
 865               }
 866             }
 867 
 868           } else /* if (kw == 2) */ {
 869 
 870             p2 = buff[0];
 871             k0 = pk[0]; k1 = pk[1];
 872 
 873             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 874 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 875 #pragma pipeloop(0)</span>
<span class="line-removed"> 876 #endif /* __SUNPRO_C */</span>
 877               for (i = 0; i &lt;= (wid - 2); i += 2) {
 878                 p0 = p2;
 879 
 880                 p1 = buff[i + 1]; p2 = buff[i + 2];
 881 
 882                 buffd[i    ] += p0*k0 + p1*k1;
 883                 buffd[i + 1] += p1*k0 + p2*k1;
 884               }
 885 
 886             } else {
<span class="line-removed"> 887 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 888 #pragma pipeloop(0)</span>
<span class="line-removed"> 889 #endif /* __SUNPRO_C */</span>
 890               for (i = 0; i &lt;= (wid - 2); i += 2) {
 891                 p0 = p2;
 892 
 893                 p1 = buff[i + 1]; p2 = buff[i + 2];
 894 
 895                 LOAD_BUFF(buffi);
 896 
 897                 dd.d64 = *(FTYPE   *)(buffi + i);
 898                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 899                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 900 
 901                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 902                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 903 
 904                 dp[0    ] = FROM_S32(d0);
 905                 dp[chan1] = FROM_S32(d1);
 906 
 907                 buffd[i    ] = 0.0;
 908                 buffd[i + 1] = 0.0;
 909 
</pre>
<hr />
<pre>
 943       }
 944 
 945       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 946       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 947 
 948       /* next line */
 949 
 950       if (j &lt; hgt - dy_b - 2) sl += sll;
 951       dl += dll;
 952 
 953       buff_ind++;
 954 
 955       if (buff_ind &gt;= n + 1) buff_ind = 0;
 956     }
 957   }
 958 
 959   FREE_AND_RETURN_STATUS;
 960 }
 961 
 962 /***************************************************************/
<span class="line-removed"> 963 #ifndef __sparc /* for x86, using integer multiplies is faster */</span>
<span class="line-removed"> 964 </span>
 965 #define STORE_RES(res, x)                                       \
 966   x &gt;&gt;= shift2;                                                 \
 967   CLAMP_STORE(res, x)
 968 
 969 mlib_status CONV_FUNC_MxN_I
 970 {
 971   DTYPE    *adr_src, *sl, *sp = NULL;
 972   DTYPE    *adr_dst, *dl, *dp = NULL;
 973   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 974   mlib_s32 *pbuff = buff;
 975   mlib_s32 **buffs = buffs_arr, *buffd;
 976   mlib_s32 l, off, kw, bsize, buff_ind;
 977   mlib_s32 d0, d1, shift1, shift2;
 978   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 979   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 980   mlib_s32 wid, hgt, sll, dll;
 981   mlib_s32 nchannel, chan1;
 982   mlib_s32 i, j, c, swid;
 983   mlib_s32 chan2;
 984   mlib_s32 k_locl[MAX_N*MAX_N], *k = k_locl;
</pre>
<hr />
<pre>
1020 
1021   for (i = 0; i &lt; m*n; i++) {
1022     k[i] = kernel[i] &gt;&gt; shift1;
1023   }
1024 
1025   swid -= (dx_l + dx_r);
1026 
1027   for (c = 0; c &lt; nchannel; c++) {
1028     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
1029 
1030     sl = adr_src + c;
1031     dl = adr_dst + c;
1032 
1033     for (l = 0; l &lt; n; l++) {
1034       mlib_s32  *buff = buffs[l];
1035 
1036       for (i = 0; i &lt; dx_l; i++) {
1037         buff[i] = (mlib_s32)sl[0];
1038       }
1039 
<span class="line-removed">1040 #ifdef __SUNPRO_C</span>
<span class="line-removed">1041 #pragma pipeloop(0)</span>
<span class="line-removed">1042 #endif /* __SUNPRO_C */</span>
1043       for (i = 0; i &lt; swid; i++) {
1044         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
1045       }
1046 
1047       for (i = 0; i &lt; dx_r; i++) {
1048         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
1049       }
1050 
1051       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
1052     }
1053 
1054     buff_ind = 0;
1055 
<span class="line-removed">1056 #ifdef __SUNPRO_C</span>
<span class="line-removed">1057 #pragma pipeloop(0)</span>
<span class="line-removed">1058 #endif /* __SUNPRO_C */</span>
1059     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
1060 
1061     for (j = 0; j &lt; hgt; j++) {
1062       mlib_s32 **buffc = buffs + buff_ind;
1063       mlib_s32 *buffn = buffc[n];
1064       mlib_s32 *pk = k;
1065 
1066       for (l = 0; l &lt; n; l++) {
1067         mlib_s32  *buff_l = buffc[l];
1068 
1069         for (off = 0; off &lt; m;) {
1070           mlib_s32 *buff = buff_l + off;
1071 
1072           sp = sl;
1073           dp = dl;
1074 
1075           kw = m - off;
1076 
1077           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
1078             if (kw &gt; MAX_KER) kw = kw/2;
1079           off += kw;
1080 
1081           if (kw == 7) {
1082 
1083             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1084             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
1085 
1086             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1087             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
1088 
1089             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1090 #ifdef __SUNPRO_C</span>
<span class="line-removed">1091 #pragma pipeloop(0)</span>
<span class="line-removed">1092 #endif /* __SUNPRO_C */</span>
1093               for (i = 0; i &lt;= (wid - 2); i += 2) {
1094                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1095 
1096                 p6 = buff[i + 6]; p7 = buff[i + 7];
1097 
1098                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1099                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1100               }
1101 
1102             } else {
<span class="line-removed">1103 #ifdef __SUNPRO_C</span>
<span class="line-removed">1104 #pragma pipeloop(0)</span>
<span class="line-removed">1105 #endif /* __SUNPRO_C */</span>
1106               for (i = 0; i &lt;= (wid - 2); i += 2) {
1107                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1108 
1109                 p6 = buff[i + 6]; p7 = buff[i + 7];
1110 
1111                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1112                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1113 
1114                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1115                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1116 
1117                 STORE_RES(dp[0    ], d0);
1118                 STORE_RES(dp[chan1], d1);
1119 
1120                 buffd[i    ] = 0;
1121                 buffd[i + 1] = 0;
1122 
1123                 sp += chan2;
1124                 dp += chan2;
1125               }
1126             }
1127 
1128           } else if (kw == 6) {
1129 
1130             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1131             p5 = buff[3]; p6 = buff[4];
1132 
1133             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1134             k4 = pk[4]; k5 = pk[5];
1135 
1136             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1137 #ifdef __SUNPRO_C</span>
<span class="line-removed">1138 #pragma pipeloop(0)</span>
<span class="line-removed">1139 #endif /* __SUNPRO_C */</span>
1140               for (i = 0; i &lt;= (wid - 2); i += 2) {
1141                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1142 
1143                 p5 = buff[i + 5]; p6 = buff[i + 6];
1144 
1145                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1146                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1147               }
1148 
1149             } else {
<span class="line-removed">1150 #ifdef __SUNPRO_C</span>
<span class="line-removed">1151 #pragma pipeloop(0)</span>
<span class="line-removed">1152 #endif /* __SUNPRO_C */</span>
1153               for (i = 0; i &lt;= (wid - 2); i += 2) {
1154                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1155 
1156                 p5 = buff[i + 5]; p6 = buff[i + 6];
1157 
1158                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1159                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1160 
1161                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1162                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1163 
1164                 STORE_RES(dp[0    ], d0);
1165                 STORE_RES(dp[chan1], d1);
1166 
1167                 buffd[i    ] = 0;
1168                 buffd[i + 1] = 0;
1169 
1170                 sp += chan2;
1171                 dp += chan2;
1172               }
1173             }
1174 
1175           } else if (kw == 5) {
1176 
1177             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1178             p5 = buff[3];
1179 
1180             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1181             k4 = pk[4];
1182 
1183             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1184 #ifdef __SUNPRO_C</span>
<span class="line-removed">1185 #pragma pipeloop(0)</span>
<span class="line-removed">1186 #endif /* __SUNPRO_C */</span>
1187               for (i = 0; i &lt;= (wid - 2); i += 2) {
1188                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1189 
1190                 p4 = buff[i + 4]; p5 = buff[i + 5];
1191 
1192                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1193                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1194               }
1195 
1196             } else {
<span class="line-removed">1197 #ifdef __SUNPRO_C</span>
<span class="line-removed">1198 #pragma pipeloop(0)</span>
<span class="line-removed">1199 #endif /* __SUNPRO_C */</span>
1200               for (i = 0; i &lt;= (wid - 2); i += 2) {
1201                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1202 
1203                 p4 = buff[i + 4]; p5 = buff[i + 5];
1204 
1205                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1206                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1207 
1208                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1209                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1210 
1211                 STORE_RES(dp[0    ], d0);
1212                 STORE_RES(dp[chan1], d1);
1213 
1214                 buffd[i    ] = 0;
1215                 buffd[i + 1] = 0;
1216 
1217                 sp += chan2;
1218                 dp += chan2;
1219               }
1220             }
1221 
1222           } else if (kw == 4) {
1223 
1224             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1225 
1226             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1227 
1228             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1229 #ifdef __SUNPRO_C</span>
<span class="line-removed">1230 #pragma pipeloop(0)</span>
<span class="line-removed">1231 #endif /* __SUNPRO_C */</span>
1232               for (i = 0; i &lt;= (wid - 2); i += 2) {
1233                 p0 = p2; p1 = p3; p2 = p4;
1234 
1235                 p3 = buff[i + 3]; p4 = buff[i + 4];
1236 
1237                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1238                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1239               }
1240 
1241             } else {
<span class="line-removed">1242 #ifdef __SUNPRO_C</span>
<span class="line-removed">1243 #pragma pipeloop(0)</span>
<span class="line-removed">1244 #endif /* __SUNPRO_C */</span>
1245               for (i = 0; i &lt;= (wid - 2); i += 2) {
1246                 p0 = p2; p1 = p3; p2 = p4;
1247 
1248                 p3 = buff[i + 3]; p4 = buff[i + 4];
1249 
1250                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1251                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1252 
1253                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1254                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1255 
1256                 STORE_RES(dp[0    ], d0);
1257                 STORE_RES(dp[chan1], d1);
1258 
1259                 buffd[i    ] = 0;
1260                 buffd[i + 1] = 0;
1261 
1262                 sp += chan2;
1263                 dp += chan2;
1264               }
1265             }
1266 
1267           } else if (kw == 3) {
1268 
1269             p2 = buff[0]; p3 = buff[1];
1270             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1271 
1272             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1273 #ifdef __SUNPRO_C</span>
<span class="line-removed">1274 #pragma pipeloop(0)</span>
<span class="line-removed">1275 #endif /* __SUNPRO_C */</span>
1276               for (i = 0; i &lt;= (wid - 2); i += 2) {
1277                 p0 = p2; p1 = p3;
1278 
1279                 p2 = buff[i + 2]; p3 = buff[i + 3];
1280 
1281                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1282                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1283               }
1284 
1285             } else {
<span class="line-removed">1286 #ifdef __SUNPRO_C</span>
<span class="line-removed">1287 #pragma pipeloop(0)</span>
<span class="line-removed">1288 #endif /* __SUNPRO_C */</span>
1289               for (i = 0; i &lt;= (wid - 2); i += 2) {
1290                 p0 = p2; p1 = p3;
1291 
1292                 p2 = buff[i + 2]; p3 = buff[i + 3];
1293 
1294                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1295                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1296 
1297                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1298                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1299 
1300                 STORE_RES(dp[0    ], d0);
1301                 STORE_RES(dp[chan1], d1);
1302 
1303                 buffd[i    ] = 0;
1304                 buffd[i + 1] = 0;
1305 
1306                 sp += chan2;
1307                 dp += chan2;
1308               }
1309             }
1310 
1311           } else if (kw == 2) {
1312 
1313             p2 = buff[0];
1314             k0 = pk[0]; k1 = pk[1];
1315 
1316             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1317 #ifdef __SUNPRO_C</span>
<span class="line-removed">1318 #pragma pipeloop(0)</span>
<span class="line-removed">1319 #endif /* __SUNPRO_C */</span>
1320               for (i = 0; i &lt;= (wid - 2); i += 2) {
1321                 p0 = p2;
1322 
1323                 p1 = buff[i + 1]; p2 = buff[i + 2];
1324 
1325                 buffd[i    ] += p0*k0 + p1*k1;
1326                 buffd[i + 1] += p1*k0 + p2*k1;
1327               }
1328 
1329             } else {
<span class="line-removed">1330 #ifdef __SUNPRO_C</span>
<span class="line-removed">1331 #pragma pipeloop(0)</span>
<span class="line-removed">1332 #endif /* __SUNPRO_C */</span>
1333               for (i = 0; i &lt;= (wid - 2); i += 2) {
1334                 p0 = p2;
1335 
1336                 p1 = buff[i + 1]; p2 = buff[i + 2];
1337 
1338                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1339                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1340 
1341                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1342                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1343 
1344                 STORE_RES(dp[0    ], d0);
1345                 STORE_RES(dp[chan1], d1);
1346 
1347                 buffd[i    ] = 0;
1348                 buffd[i + 1] = 0;
1349 
1350                 sp += chan2;
1351                 dp += chan2;
1352               }
1353             }
1354 
1355           } else /* kw == 1 */{
1356 
1357             k0 = pk[0];
1358 
1359             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1360 #ifdef __SUNPRO_C</span>
<span class="line-removed">1361 #pragma pipeloop(0)</span>
<span class="line-removed">1362 #endif /* __SUNPRO_C */</span>
1363               for (i = 0; i &lt;= (wid - 2); i += 2) {
1364                 p0 = buff[i]; p1 = buff[i + 1];
1365 
1366                 buffd[i    ] += p0*k0;
1367                 buffd[i + 1] += p1*k0;
1368               }
1369 
1370             } else {
<span class="line-removed">1371 #ifdef __SUNPRO_C</span>
<span class="line-removed">1372 #pragma pipeloop(0)</span>
<span class="line-removed">1373 #endif /* __SUNPRO_C */</span>
1374               for (i = 0; i &lt;= (wid - 2); i += 2) {
1375                 p0 = buff[i]; p1 = buff[i + 1];
1376 
1377                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1378                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1379 
1380                 d0 = (p0*k0 + buffd[i    ]);
1381                 d1 = (p1*k0 + buffd[i + 1]);
1382 
1383                 STORE_RES(dp[0    ], d0);
1384                 STORE_RES(dp[chan1], d1);
1385 
1386                 buffd[i    ] = 0;
1387                 buffd[i + 1] = 0;
1388 
1389                 sp += chan2;
1390                 dp += chan2;
1391               }
1392             }
1393           }
</pre>
<hr />
<pre>
1422       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1423       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1424 
1425       /* next line */
1426 
1427       if (j &lt; hgt - dy_b - 2) sl += sll;
1428       dl += dll;
1429 
1430       buff_ind++;
1431 
1432       if (buff_ind &gt;= n + 1) buff_ind = 0;
1433     }
1434   }
1435 
1436   if (pbuff != buff) mlib_free(pbuff);
1437   if (k != k_locl) mlib_free(k);
1438 
1439   return MLIB_SUCCESS;
1440 }
1441 
<span class="line-removed">1442 #endif /* __sparc ( for x86, using integer multiplies is faster ) */</span>
<span class="line-removed">1443 </span>
1444 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 172 #define DEF_VARS(type)                                          \
 173   type     *adr_src, *sl, *sp, *sl1;                            \
 174   type     *adr_dst, *dl, *dp;                                  \
 175   FTYPE    *pbuff = buff;                                       \
 176   mlib_s32 *buffi, *buffo;                                      \
 177   mlib_s32 wid, hgt, sll, dll;                                  \
 178   mlib_s32 nchannel, chan1, chan2;                              \
 179   mlib_s32 i, j, c, swid
 180 
 181 /***************************************************************/
 182 #define GET_SRC_DST_PARAMETERS(type)                            \
 183   hgt = mlib_ImageGetHeight(src);                               \
 184   wid = mlib_ImageGetWidth(src);                                \
 185   nchannel = mlib_ImageGetChannels(src);                        \
 186   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 187   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 188   adr_src = (type *)mlib_ImageGetData(src);                     \
 189   adr_dst = (type *)mlib_ImageGetData(dst)
 190 
 191 /***************************************************************/

 192 #if IMG_TYPE == 1
 193 
 194 /*
 195  * Test for the presence of any &quot;1&quot; bit in bits
 196    8 to 31 of val. If present, then val is either
 197    negative or &gt;255. If over/underflows of 8 bits
 198    are uncommon, then this technique can be a win,
 199    since only a single test, rather than two, is
 200    necessary to determine if clamping is needed.
 201    On the other hand, if over/underflows are common,
 202    it adds an extra test.
 203 */
 204 #define CLAMP_STORE(dst, val)                                   \
 205   if (val &amp; 0xffffff00) {                                       \
 206     if (val &lt; MLIB_U8_MIN)                                      \
 207       dst = MLIB_U8_MIN;                                        \
 208     else                                                        \
 209       dst = MLIB_U8_MAX;                                        \
 210   } else {                                                      \
 211     dst = (mlib_u8)val;                                         \
</pre>
<hr />
<pre>
 215 
 216 #define CLAMP_STORE(dst, val)                                   \
 217   if (val &gt;= MLIB_S16_MAX)                                      \
 218     dst = MLIB_S16_MAX;                                         \
 219   else if (val &lt;= MLIB_S16_MIN)                                 \
 220     dst = MLIB_S16_MIN;                                         \
 221   else                                                          \
 222     dst = (mlib_s16)val
 223 
 224 #elif IMG_TYPE == 3
 225 
 226 #define CLAMP_STORE(dst, val)                                   \
 227   if (val &gt;= MLIB_U16_MAX)                                      \
 228     dst = MLIB_U16_MAX;                                         \
 229   else if (val &lt;= MLIB_U16_MIN)                                 \
 230     dst = MLIB_U16_MIN;                                         \
 231   else                                                          \
 232     dst = (mlib_u16)val
 233 
 234 #endif /* IMG_TYPE == 1 */

 235 
 236 /***************************************************************/
 237 #define MAX_KER   7
 238 #define MAX_N    15
 239 #define BUFF_SIZE   1600
 240 #define CACHE_SIZE  (64*1024)
 241 
 242 static mlib_status mlib_ImageConv1xN_ext(mlib_image       *dst,
 243                                          const mlib_image *src,
 244                                          const mlib_d64   *k,
 245                                          mlib_s32         n,
 246                                          mlib_s32         dy_t,
 247                                          mlib_s32         dy_b,
 248                                          mlib_s32         cmask)
 249 {
 250   DTYPE    *adr_src, *sl;
 251   DTYPE    *adr_dst, *dl, *dp;
 252   FTYPE    buff[BUFF_SIZE];
 253   FTYPE    *buffd;
 254   FTYPE    *pbuff = buff;
</pre>
<hr />
<pre>
 282 
 283   sbuff = pbuff;
 284   buffd = sbuff + smax_hsize;
 285 
 286   shgt -= (dy_t + dy_b);
 287   k_off = 0;
 288 
 289   for (l = 0; l &lt; hgt; l += hsize) {
 290     hsize = hgt - l;
 291 
 292     if (hsize &gt; max_hsize) hsize = max_hsize;
 293 
 294     smax_hsize = hsize + (n - 1);
 295 
 296     for (c = 0; c &lt; nchannel; c++) {
 297       if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 298 
 299       sl = adr_src + c;
 300       dl = adr_dst + c;
 301 



 302       for (i = 0; i &lt; hsize; i++) buffd[i] = 0.0;
 303 
 304       for (j = 0; j &lt; wid; j++) {
 305         FTYPE    *buff = sbuff;
 306 
 307         for (i = k_off, ii = 0; (i &lt; dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 308           sbuff[i - k_off] = (FTYPE)sl[0];
 309         }
 310 



 311         for (; (i &lt; shgt + dy_t) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 312           sbuff[i - k_off] = (FTYPE)sl[(i - dy_t)*sll];
 313         }
 314 
 315         for (; (i &lt; shgt + dy_t + dy_b) &amp;&amp; (ii &lt; smax_hsize); i++, ii++) {
 316           sbuff[i - k_off] = (FTYPE)sl[(shgt - 1)*sll];
 317         }
 318 
 319         pk = k;
 320 
 321         for (off = 0; off &lt; (n - 4); off += 4) {
 322 
 323           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 324           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 325 



 326           for (i = 0; i &lt; hsize; i += 2) {
 327             p0 = p2; p1 = p3; p2 = p4;
 328 
 329             p3 = buff[i + 3]; p4 = buff[i + 4];
 330 
 331             buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 332             buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 333           }
 334 
 335           pk += 4;
 336           buff += 4;
 337         }
 338 
 339         dp = dl;
 340         kh = n - off;
 341 
 342         if (kh == 4) {
 343           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 344           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 345 



 346           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 347             p0 = p2; p1 = p3; p2 = p4;
 348 
 349             p3 = buff[i + 3]; p4 = buff[i + 4];
 350 
 351             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 352             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 353 
 354             dp[0  ] = FROM_S32(d0);
 355             dp[dll] = FROM_S32(d1);
 356 
 357             buffd[i    ] = 0.0;
 358             buffd[i + 1] = 0.0;
 359 
 360             dp += 2*dll;
 361           }
 362 
 363           if (i &lt; hsize) {
 364             p0 = p2; p1 = p3; p2 = p4;
 365             p3 = buff[i + 3];
 366             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i]);
 367             dp[0] = FROM_S32(d0);
 368             buffd[i] = 0.0;
 369           }
 370 
 371         } else if (kh == 3) {
 372 
 373           p2 = buff[0]; p3 = buff[1];
 374           k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 375 



 376           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 377             p0 = p2; p1 = p3;
 378 
 379             p2 = buff[i + 2]; p3 = buff[i + 3];
 380 
 381             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 382             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 383 
 384             dp[0  ] = FROM_S32(d0);
 385             dp[dll] = FROM_S32(d1);
 386 
 387             buffd[i    ] = 0.0;
 388             buffd[i + 1] = 0.0;
 389 
 390             dp += 2*dll;
 391           }
 392 
 393           if (i &lt; hsize) {
 394             p0 = p2; p1 = p3;
 395             p2 = buff[i + 2];
 396             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i]);
 397             dp[0] = FROM_S32(d0);
 398 
 399             buffd[i] = 0.0;
 400           }
 401 
 402         } else if (kh == 2) {
 403 
 404           p2 = buff[0];
 405           k0 = pk[0]; k1 = pk[1];
 406 



 407           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 408             p0 = p2;
 409 
 410             p1 = buff[i + 1]; p2 = buff[i + 2];
 411 
 412             d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 413             d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 414 
 415             dp[0  ] = FROM_S32(d0);
 416             dp[dll] = FROM_S32(d1);
 417 
 418             buffd[i    ] = 0.0;
 419             buffd[i + 1] = 0.0;
 420 
 421             dp += 2*dll;
 422           }
 423 
 424           if (i &lt; hsize) {
 425             p0 = p2;
 426             p1 = buff[i + 1];
 427             d0 = D2I(p0*k0 + p1*k1 + buffd[i]);
 428             dp[0] = FROM_S32(d0);
 429 
 430             buffd[i] = 0.0;
 431           }
 432 
 433         } else /* kh == 1 */{
 434 
 435           k0 = pk[0];
 436 



 437           for (i = 0; i &lt;= (hsize - 2); i += 2) {
 438             p0 = buff[i]; p1 = buff[i + 1];
 439 
 440             d0 = D2I(p0*k0 + buffd[i    ]);
 441             d1 = D2I(p1*k0 + buffd[i + 1]);
 442 
 443             dp[0  ] = FROM_S32(d0);
 444             dp[dll] = FROM_S32(d1);
 445 
 446             buffd[i    ] = 0.0;
 447             buffd[i + 1] = 0.0;
 448 
 449             dp += 2*dll;
 450           }
 451 
 452           if (i &lt; hsize) {
 453             p0 = buff[i];
 454             d0 = D2I(p0*k0 + buffd[i]);
 455             dp[0] = FROM_S32(d0);
 456 
</pre>
<hr />
<pre>
 539   buffi = (mlib_s32*)(buffd + swid);
 540 
 541   chan1 = nchannel;
 542   chan2 = chan1 + chan1;
 543 
 544   swid -= (dx_l + dx_r);
 545 
 546   for (c = 0; c &lt; nchannel; c++) {
 547     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 548 
 549     sl = adr_src + c;
 550     dl = adr_dst + c;
 551 
 552     for (l = 0; l &lt; n; l++) {
 553       FTYPE    *buff = buffs[l];
 554 
 555       for (i = 0; i &lt; dx_l; i++) {
 556         buff[i] = (FTYPE)sl[0];
 557       }
 558 



 559       for (i = 0; i &lt; swid; i++) {
 560         buff[i + dx_l] = (FTYPE)sl[i*chan1];
 561       }
 562 
 563       for (i = 0; i &lt; dx_r; i++) {
 564         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 565       }
 566 
 567       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 568     }
 569 
 570     buff_ind = 0;
 571 



 572     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 573 
 574     for (j = 0; j &lt; hgt; j++) {
 575       FTYPE    **buffc = buffs + buff_ind;
 576       FTYPE    *buffn = buffc[n];
 577       FTYPE    *pk = k;
 578 
 579       for (l = 0; l &lt; n; l++) {
 580         FTYPE    *buff_l = buffc[l];
 581 
 582         for (off = 0; off &lt; m;) {
 583           FTYPE    *buff = buff_l + off;
 584 
 585           kw = m - off;
 586 
 587           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 588             if (kw &gt; MAX_KER) kw = kw/2;
 589           off += kw;
 590 
 591           sp = sl;
 592           dp = dl;
 593 
 594           if (kw == 7) {
 595 
 596             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 597             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 598 
 599             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 600             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 601 
 602             if (l &lt; (n - 1) || off &lt; m) {



 603               for (i = 0; i &lt;= (wid - 2); i += 2) {
 604                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 605 
 606                 p6 = buff[i + 6]; p7 = buff[i + 7];
 607 
 608                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 609                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 610               }
 611 
 612             } else {



 613               for (i = 0; i &lt;= (wid - 2); i += 2) {
 614                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 615 
 616                 p6 = buff[i + 6]; p7 = buff[i + 7];
 617 
 618                 LOAD_BUFF(buffi);
 619 
 620                 dd.d64 = *(FTYPE   *)(buffi + i);
 621                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 622                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 623 
 624                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 625                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 626 
 627                 dp[0    ] = FROM_S32(d0);
 628                 dp[chan1] = FROM_S32(d1);
 629 
 630                 buffd[i    ] = 0.0;
 631                 buffd[i + 1] = 0.0;
 632 
 633                 sp += chan2;
 634                 dp += chan2;
 635               }
 636             }
 637 
 638           } else if (kw == 6) {
 639 
 640             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 641             p5 = buff[3]; p6 = buff[4];
 642 
 643             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 644             k4 = pk[4]; k5 = pk[5];
 645 
 646             if (l &lt; (n - 1) || off &lt; m) {



 647               for (i = 0; i &lt;= (wid - 2); i += 2) {
 648                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 649 
 650                 p5 = buff[i + 5]; p6 = buff[i + 6];
 651 
 652                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 653                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 654               }
 655 
 656             } else {



 657               for (i = 0; i &lt;= (wid - 2); i += 2) {
 658                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 659 
 660                 p5 = buff[i + 5]; p6 = buff[i + 6];
 661 
 662                 LOAD_BUFF(buffi);
 663 
 664                 dd.d64 = *(FTYPE   *)(buffi + i);
 665                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 666                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 667 
 668                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 669                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 670 
 671                 dp[0    ] = FROM_S32(d0);
 672                 dp[chan1] = FROM_S32(d1);
 673 
 674                 buffd[i    ] = 0.0;
 675                 buffd[i + 1] = 0.0;
 676 
 677                 sp += chan2;
 678                 dp += chan2;
 679               }
 680             }
 681 
 682           } else if (kw == 5) {
 683 
 684             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 685             p5 = buff[3];
 686 
 687             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 688             k4 = pk[4];
 689 
 690             if (l &lt; (n - 1) || off &lt; m) {



 691               for (i = 0; i &lt;= (wid - 2); i += 2) {
 692                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 693 
 694                 p4 = buff[i + 4]; p5 = buff[i + 5];
 695 
 696                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 697                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 698               }
 699 
 700             } else {



 701               for (i = 0; i &lt;= (wid - 2); i += 2) {
 702                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 703 
 704                 p4 = buff[i + 4]; p5 = buff[i + 5];
 705 
 706                 LOAD_BUFF(buffi);
 707 
 708                 dd.d64 = *(FTYPE   *)(buffi + i);
 709                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 710                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 711 
 712                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 713                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 714 
 715                 dp[0    ] = FROM_S32(d0);
 716                 dp[chan1] = FROM_S32(d1);
 717 
 718                 buffd[i    ] = 0.0;
 719                 buffd[i + 1] = 0.0;
 720 
 721                 sp += chan2;
 722                 dp += chan2;
 723               }
 724             }
 725 
 726           } else if (kw == 4) {
 727 
 728             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 729 
 730             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 731 
 732             if (l &lt; (n - 1) || off &lt; m) {



 733               for (i = 0; i &lt;= (wid - 2); i += 2) {
 734                 p0 = p2; p1 = p3; p2 = p4;
 735 
 736                 p3 = buff[i + 3]; p4 = buff[i + 4];
 737 
 738                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 739                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 740               }
 741 
 742             } else {



 743               for (i = 0; i &lt;= (wid - 2); i += 2) {
 744                 p0 = p2; p1 = p3; p2 = p4;
 745 
 746                 p3 = buff[i + 3]; p4 = buff[i + 4];
 747 
 748                 LOAD_BUFF(buffi);
 749 
 750                 dd.d64 = *(FTYPE   *)(buffi + i);
 751                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 752                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 753 
 754                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 755                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 756 
 757                 dp[0    ] = FROM_S32(d0);
 758                 dp[chan1] = FROM_S32(d1);
 759 
 760                 buffd[i    ] = 0.0;
 761                 buffd[i + 1] = 0.0;
 762 
 763                 sp += chan2;
 764                 dp += chan2;
 765               }
 766             }
 767 
 768           } else if (kw == 3) {
 769 
 770             p2 = buff[0]; p3 = buff[1];
 771             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
 772 
 773             if (l &lt; (n - 1) || off &lt; m) {



 774               for (i = 0; i &lt;= (wid - 2); i += 2) {
 775                 p0 = p2; p1 = p3;
 776 
 777                 p2 = buff[i + 2]; p3 = buff[i + 3];
 778 
 779                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 780                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 781               }
 782 
 783             } else {



 784               for (i = 0; i &lt;= (wid - 2); i += 2) {
 785                 p0 = p2; p1 = p3;
 786 
 787                 p2 = buff[i + 2]; p3 = buff[i + 3];
 788 
 789                 LOAD_BUFF(buffi);
 790 
 791                 dd.d64 = *(FTYPE   *)(buffi + i);
 792                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 793                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 794 
 795                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 796                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 797 
 798                 dp[0    ] = FROM_S32(d0);
 799                 dp[chan1] = FROM_S32(d1);
 800 
 801                 buffd[i    ] = 0.0;
 802                 buffd[i + 1] = 0.0;
 803 
 804                 sp += chan2;
 805                 dp += chan2;
 806               }
 807             }
 808 
 809           } else /* if (kw == 2) */ {
 810 
 811             p2 = buff[0];
 812             k0 = pk[0]; k1 = pk[1];
 813 
 814             if (l &lt; (n - 1) || off &lt; m) {



 815               for (i = 0; i &lt;= (wid - 2); i += 2) {
 816                 p0 = p2;
 817 
 818                 p1 = buff[i + 1]; p2 = buff[i + 2];
 819 
 820                 buffd[i    ] += p0*k0 + p1*k1;
 821                 buffd[i + 1] += p1*k0 + p2*k1;
 822               }
 823 
 824             } else {



 825               for (i = 0; i &lt;= (wid - 2); i += 2) {
 826                 p0 = p2;
 827 
 828                 p1 = buff[i + 1]; p2 = buff[i + 2];
 829 
 830                 LOAD_BUFF(buffi);
 831 
 832                 dd.d64 = *(FTYPE   *)(buffi + i);
 833                 buffn[i + dx_l    ] = (FTYPE)dd.i32s.i0;
 834                 buffn[i + dx_l + 1] = (FTYPE)dd.i32s.i1;
 835 
 836                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 837                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 838 
 839                 dp[0    ] = FROM_S32(d0);
 840                 dp[chan1] = FROM_S32(d1);
 841 
 842                 buffd[i    ] = 0.0;
 843                 buffd[i + 1] = 0.0;
 844 
</pre>
<hr />
<pre>
 878       }
 879 
 880       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
 881       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
 882 
 883       /* next line */
 884 
 885       if (j &lt; hgt - dy_b - 2) sl += sll;
 886       dl += dll;
 887 
 888       buff_ind++;
 889 
 890       if (buff_ind &gt;= n + 1) buff_ind = 0;
 891     }
 892   }
 893 
 894   FREE_AND_RETURN_STATUS;
 895 }
 896 
 897 /***************************************************************/


 898 #define STORE_RES(res, x)                                       \
 899   x &gt;&gt;= shift2;                                                 \
 900   CLAMP_STORE(res, x)
 901 
 902 mlib_status CONV_FUNC_MxN_I
 903 {
 904   DTYPE    *adr_src, *sl, *sp = NULL;
 905   DTYPE    *adr_dst, *dl, *dp = NULL;
 906   mlib_s32 buff[BUFF_SIZE], *buffs_arr[2*(MAX_N + 1)];
 907   mlib_s32 *pbuff = buff;
 908   mlib_s32 **buffs = buffs_arr, *buffd;
 909   mlib_s32 l, off, kw, bsize, buff_ind;
 910   mlib_s32 d0, d1, shift1, shift2;
 911   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 912   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
 913   mlib_s32 wid, hgt, sll, dll;
 914   mlib_s32 nchannel, chan1;
 915   mlib_s32 i, j, c, swid;
 916   mlib_s32 chan2;
 917   mlib_s32 k_locl[MAX_N*MAX_N], *k = k_locl;
</pre>
<hr />
<pre>
 953 
 954   for (i = 0; i &lt; m*n; i++) {
 955     k[i] = kernel[i] &gt;&gt; shift1;
 956   }
 957 
 958   swid -= (dx_l + dx_r);
 959 
 960   for (c = 0; c &lt; nchannel; c++) {
 961     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 962 
 963     sl = adr_src + c;
 964     dl = adr_dst + c;
 965 
 966     for (l = 0; l &lt; n; l++) {
 967       mlib_s32  *buff = buffs[l];
 968 
 969       for (i = 0; i &lt; dx_l; i++) {
 970         buff[i] = (mlib_s32)sl[0];
 971       }
 972 



 973       for (i = 0; i &lt; swid; i++) {
 974         buff[i + dx_l] = (mlib_s32)sl[i*chan1];
 975       }
 976 
 977       for (i = 0; i &lt; dx_r; i++) {
 978         buff[swid + dx_l + i] = buff[swid + dx_l - 1];
 979       }
 980 
 981       if ((l &gt;= dy_t) &amp;&amp; (l &lt; hgt + n - dy_b - 2)) sl += sll;
 982     }
 983 
 984     buff_ind = 0;
 985 



 986     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
 987 
 988     for (j = 0; j &lt; hgt; j++) {
 989       mlib_s32 **buffc = buffs + buff_ind;
 990       mlib_s32 *buffn = buffc[n];
 991       mlib_s32 *pk = k;
 992 
 993       for (l = 0; l &lt; n; l++) {
 994         mlib_s32  *buff_l = buffc[l];
 995 
 996         for (off = 0; off &lt; m;) {
 997           mlib_s32 *buff = buff_l + off;
 998 
 999           sp = sl;
1000           dp = dl;
1001 
1002           kw = m - off;
1003 
1004           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
1005             if (kw &gt; MAX_KER) kw = kw/2;
1006           off += kw;
1007 
1008           if (kw == 7) {
1009 
1010             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1011             p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
1012 
1013             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1014             k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
1015 
1016             if (l &lt; (n - 1) || off &lt; m) {



1017               for (i = 0; i &lt;= (wid - 2); i += 2) {
1018                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1019 
1020                 p6 = buff[i + 6]; p7 = buff[i + 7];
1021 
1022                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
1023                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
1024               }
1025 
1026             } else {



1027               for (i = 0; i &lt;= (wid - 2); i += 2) {
1028                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
1029 
1030                 p6 = buff[i + 6]; p7 = buff[i + 7];
1031 
1032                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1033                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1034 
1035                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
1036                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
1037 
1038                 STORE_RES(dp[0    ], d0);
1039                 STORE_RES(dp[chan1], d1);
1040 
1041                 buffd[i    ] = 0;
1042                 buffd[i + 1] = 0;
1043 
1044                 sp += chan2;
1045                 dp += chan2;
1046               }
1047             }
1048 
1049           } else if (kw == 6) {
1050 
1051             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1052             p5 = buff[3]; p6 = buff[4];
1053 
1054             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1055             k4 = pk[4]; k5 = pk[5];
1056 
1057             if (l &lt; (n - 1) || off &lt; m) {



1058               for (i = 0; i &lt;= (wid - 2); i += 2) {
1059                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1060 
1061                 p5 = buff[i + 5]; p6 = buff[i + 6];
1062 
1063                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1064                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1065               }
1066 
1067             } else {



1068               for (i = 0; i &lt;= (wid - 2); i += 2) {
1069                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1070 
1071                 p5 = buff[i + 5]; p6 = buff[i + 6];
1072 
1073                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1074                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1075 
1076                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1077                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1078 
1079                 STORE_RES(dp[0    ], d0);
1080                 STORE_RES(dp[chan1], d1);
1081 
1082                 buffd[i    ] = 0;
1083                 buffd[i + 1] = 0;
1084 
1085                 sp += chan2;
1086                 dp += chan2;
1087               }
1088             }
1089 
1090           } else if (kw == 5) {
1091 
1092             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1093             p5 = buff[3];
1094 
1095             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1096             k4 = pk[4];
1097 
1098             if (l &lt; (n - 1) || off &lt; m) {



1099               for (i = 0; i &lt;= (wid - 2); i += 2) {
1100                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1101 
1102                 p4 = buff[i + 4]; p5 = buff[i + 5];
1103 
1104                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1105                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1106               }
1107 
1108             } else {



1109               for (i = 0; i &lt;= (wid - 2); i += 2) {
1110                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1111 
1112                 p4 = buff[i + 4]; p5 = buff[i + 5];
1113 
1114                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1115                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1116 
1117                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1118                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1119 
1120                 STORE_RES(dp[0    ], d0);
1121                 STORE_RES(dp[chan1], d1);
1122 
1123                 buffd[i    ] = 0;
1124                 buffd[i + 1] = 0;
1125 
1126                 sp += chan2;
1127                 dp += chan2;
1128               }
1129             }
1130 
1131           } else if (kw == 4) {
1132 
1133             p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
1134 
1135             k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
1136 
1137             if (l &lt; (n - 1) || off &lt; m) {



1138               for (i = 0; i &lt;= (wid - 2); i += 2) {
1139                 p0 = p2; p1 = p3; p2 = p4;
1140 
1141                 p3 = buff[i + 3]; p4 = buff[i + 4];
1142 
1143                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1144                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1145               }
1146 
1147             } else {



1148               for (i = 0; i &lt;= (wid - 2); i += 2) {
1149                 p0 = p2; p1 = p3; p2 = p4;
1150 
1151                 p3 = buff[i + 3]; p4 = buff[i + 4];
1152 
1153                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1154                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1155 
1156                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1157                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1158 
1159                 STORE_RES(dp[0    ], d0);
1160                 STORE_RES(dp[chan1], d1);
1161 
1162                 buffd[i    ] = 0;
1163                 buffd[i + 1] = 0;
1164 
1165                 sp += chan2;
1166                 dp += chan2;
1167               }
1168             }
1169 
1170           } else if (kw == 3) {
1171 
1172             p2 = buff[0]; p3 = buff[1];
1173             k0 = pk[0]; k1 = pk[1]; k2 = pk[2];
1174 
1175             if (l &lt; (n - 1) || off &lt; m) {



1176               for (i = 0; i &lt;= (wid - 2); i += 2) {
1177                 p0 = p2; p1 = p3;
1178 
1179                 p2 = buff[i + 2]; p3 = buff[i + 3];
1180 
1181                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1182                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1183               }
1184 
1185             } else {



1186               for (i = 0; i &lt;= (wid - 2); i += 2) {
1187                 p0 = p2; p1 = p3;
1188 
1189                 p2 = buff[i + 2]; p3 = buff[i + 3];
1190 
1191                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1192                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1193 
1194                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1195                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1196 
1197                 STORE_RES(dp[0    ], d0);
1198                 STORE_RES(dp[chan1], d1);
1199 
1200                 buffd[i    ] = 0;
1201                 buffd[i + 1] = 0;
1202 
1203                 sp += chan2;
1204                 dp += chan2;
1205               }
1206             }
1207 
1208           } else if (kw == 2) {
1209 
1210             p2 = buff[0];
1211             k0 = pk[0]; k1 = pk[1];
1212 
1213             if (l &lt; (n - 1) || off &lt; m) {



1214               for (i = 0; i &lt;= (wid - 2); i += 2) {
1215                 p0 = p2;
1216 
1217                 p1 = buff[i + 1]; p2 = buff[i + 2];
1218 
1219                 buffd[i    ] += p0*k0 + p1*k1;
1220                 buffd[i + 1] += p1*k0 + p2*k1;
1221               }
1222 
1223             } else {



1224               for (i = 0; i &lt;= (wid - 2); i += 2) {
1225                 p0 = p2;
1226 
1227                 p1 = buff[i + 1]; p2 = buff[i + 2];
1228 
1229                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1230                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1231 
1232                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1233                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1234 
1235                 STORE_RES(dp[0    ], d0);
1236                 STORE_RES(dp[chan1], d1);
1237 
1238                 buffd[i    ] = 0;
1239                 buffd[i + 1] = 0;
1240 
1241                 sp += chan2;
1242                 dp += chan2;
1243               }
1244             }
1245 
1246           } else /* kw == 1 */{
1247 
1248             k0 = pk[0];
1249 
1250             if (l &lt; (n - 1) || off &lt; m) {



1251               for (i = 0; i &lt;= (wid - 2); i += 2) {
1252                 p0 = buff[i]; p1 = buff[i + 1];
1253 
1254                 buffd[i    ] += p0*k0;
1255                 buffd[i + 1] += p1*k0;
1256               }
1257 
1258             } else {



1259               for (i = 0; i &lt;= (wid - 2); i += 2) {
1260                 p0 = buff[i]; p1 = buff[i + 1];
1261 
1262                 buffn[i + dx_l    ] = (mlib_s32)sp[0];
1263                 buffn[i + dx_l + 1] = (mlib_s32)sp[chan1];
1264 
1265                 d0 = (p0*k0 + buffd[i    ]);
1266                 d1 = (p1*k0 + buffd[i + 1]);
1267 
1268                 STORE_RES(dp[0    ], d0);
1269                 STORE_RES(dp[chan1], d1);
1270 
1271                 buffd[i    ] = 0;
1272                 buffd[i + 1] = 0;
1273 
1274                 sp += chan2;
1275                 dp += chan2;
1276               }
1277             }
1278           }
</pre>
<hr />
<pre>
1307       for (i = 0; i &lt; dx_l; i++) buffn[i] = buffn[dx_l];
1308       for (i = 0; i &lt; dx_r; i++) buffn[swid + dx_l + i] = buffn[swid + dx_l - 1];
1309 
1310       /* next line */
1311 
1312       if (j &lt; hgt - dy_b - 2) sl += sll;
1313       dl += dll;
1314 
1315       buff_ind++;
1316 
1317       if (buff_ind &gt;= n + 1) buff_ind = 0;
1318     }
1319   }
1320 
1321   if (pbuff != buff) mlib_free(pbuff);
1322   if (k != k_locl) mlib_free(k);
1323 
1324   return MLIB_SUCCESS;
1325 }
1326 


1327 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_ImageConv_F32nw.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_u16nw.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
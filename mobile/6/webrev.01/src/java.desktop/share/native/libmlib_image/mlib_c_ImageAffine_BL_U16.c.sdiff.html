<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BL_U16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_c_ImageAffine_BL_S16.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_NN.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BL_U16.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60  * DESCRIPTION
 61  *      The functions step along the lines from xLeft to xRight and apply
 62  *      the bilinear filtering.
 63  *
 64  */
 65 
 66 #include &quot;mlib_ImageAffine.h&quot;
 67 
 68 /***************************************************************/
 69 #define DTYPE  mlib_u16
 70 #define FTYPE  mlib_d64
 71 
 72 /***************************************************************/
 73 #define TTYPE    mlib_s32
 74 #define I2F(x)   (x)
 75 #define ROUND(x) (x)
 76 
 77 #define FUN_NAME(CHAN) mlib_ImageAffine_u16_##CHAN##_bl
 78 
 79 /***************************************************************/
<span class="line-modified"> 80 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82 /***************************************************************/</span>
<span class="line-removed"> 83 #define GET_POINTERS(ind)                                       \</span>
<span class="line-removed"> 84   fdx = (FTYPE)(X &amp; MLIB_MASK) * scale;                         \</span>
<span class="line-removed"> 85   fdy = (FTYPE)(Y &amp; MLIB_MASK) * scale;                         \</span>
<span class="line-removed"> 86   ySrc = MLIB_POINTER_SHIFT(Y);  Y += dY;                       \</span>
<span class="line-removed"> 87   xSrc = X &gt;&gt; MLIB_SHIFT;  X += dX;                             \</span>
<span class="line-removed"> 88   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;  \</span>
<span class="line-removed"> 89   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride)</span>
<span class="line-removed"> 90 </span>
<span class="line-removed"> 91 /***************************************************************/</span>
<span class="line-removed"> 92 #define COUNT(ind)                                              \</span>
<span class="line-removed"> 93   pix0_##ind = a00_##ind + fdy * (a10_##ind - a00_##ind);       \</span>
<span class="line-removed"> 94   pix1_##ind = a01_##ind + fdy * (a11_##ind - a01_##ind);       \</span>
<span class="line-removed"> 95   res##ind = ROUND(pix0_##ind + fdx * (pix1_##ind - pix0_##ind))</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 /***************************************************************/</span>
<span class="line-removed"> 98 #define LOAD(ind, ind1, ind2)                                   \</span>
<span class="line-removed"> 99   a00_##ind = I2F(srcPixelPtr[ind1]);                           \</span>
<span class="line-removed">100   a01_##ind = I2F(srcPixelPtr[ind2]);                           \</span>
<span class="line-removed">101   a10_##ind = I2F(srcPixelPtr2[ind1]);                          \</span>
<span class="line-removed">102   a11_##ind = I2F(srcPixelPtr2[ind2])</span>
<span class="line-removed">103 </span>
<span class="line-removed">104 /***************************************************************/</span>
<span class="line-removed">105 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">106 {</span>
<span class="line-removed">107   DECLAREVAR_BL();</span>
<span class="line-removed">108   DTYPE *dstLineEnd;</span>
<span class="line-removed">109   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">110   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">111 </span>
<span class="line-removed">112   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">113     FTYPE fdx, fdy;</span>
<span class="line-removed">114     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">115     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">116 </span>
<span class="line-removed">117     CLIP(1);</span>
<span class="line-removed">118     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed">119 </span>
<span class="line-removed">120     GET_POINTERS(1);</span>
<span class="line-removed">121     LOAD(0, 0, 1);</span>
<span class="line-removed">122 </span>
<span class="line-removed">123 #ifdef __SUNPRO_C</span>
<span class="line-removed">124 #pragma pipeloop(0)</span>
<span class="line-removed">125 #endif /* __SUNPRO_C */</span>
<span class="line-removed">126     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {</span>
<span class="line-removed">127       COUNT(0);</span>
<span class="line-removed">128       GET_POINTERS(1);</span>
<span class="line-removed">129       LOAD(0, 0, 1);</span>
<span class="line-removed">130       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">131     }</span>
<span class="line-removed">132 </span>
<span class="line-removed">133     COUNT(0);</span>
<span class="line-removed">134     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">135   }</span>
<span class="line-removed">136 </span>
<span class="line-removed">137   return MLIB_SUCCESS;</span>
<span class="line-removed">138 }</span>
<span class="line-removed">139 </span>
<span class="line-removed">140 /***************************************************************/</span>
<span class="line-removed">141 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed">142 {</span>
<span class="line-removed">143   DECLAREVAR_BL();</span>
<span class="line-removed">144   DTYPE *dstLineEnd;</span>
<span class="line-removed">145   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">146   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">147 </span>
<span class="line-removed">148   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">149     FTYPE fdx, fdy;</span>
<span class="line-removed">150     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">151     TTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">152     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">153     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">154 </span>
<span class="line-removed">155     CLIP(2);</span>
<span class="line-removed">156     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed">157 </span>
<span class="line-removed">158     GET_POINTERS(2);</span>
<span class="line-removed">159     LOAD(0, 0, 2);</span>
<span class="line-removed">160     LOAD(1, 1, 3);</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 #ifdef __SUNPRO_C</span>
<span class="line-removed">163 #pragma pipeloop(0)</span>
<span class="line-removed">164 #endif /* __SUNPRO_C */</span>
<span class="line-removed">165     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {</span>
<span class="line-removed">166       COUNT(0);</span>
<span class="line-removed">167       COUNT(1);</span>
<span class="line-removed">168       GET_POINTERS(2);</span>
<span class="line-removed">169       LOAD(0, 0, 2);</span>
<span class="line-removed">170       LOAD(1, 1, 3);</span>
<span class="line-removed">171       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">172       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">173     }</span>
<span class="line-removed">174 </span>
<span class="line-removed">175     COUNT(0);</span>
<span class="line-removed">176     COUNT(1);</span>
<span class="line-removed">177     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">178     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">179   }</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   return MLIB_SUCCESS;</span>
<span class="line-removed">182 }</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 /***************************************************************/</span>
<span class="line-removed">185 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed">186 {</span>
<span class="line-removed">187   DECLAREVAR_BL();</span>
<span class="line-removed">188   DTYPE *dstLineEnd;</span>
<span class="line-removed">189   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">190   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">191 </span>
<span class="line-removed">192   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">193     FTYPE fdx, fdy;</span>
<span class="line-removed">194     FTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">195     FTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">196     FTYPE a00_2, a01_2, a10_2, a11_2;</span>
<span class="line-removed">197     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">198     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">199     FTYPE pix0_2, pix1_2, res2;</span>
<span class="line-removed">200 </span>
<span class="line-removed">201     CLIP(3);</span>
<span class="line-removed">202     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed">203 </span>
<span class="line-removed">204     GET_POINTERS(3);</span>
<span class="line-removed">205     LOAD(0, 0, 3);</span>
<span class="line-removed">206     LOAD(1, 1, 4);</span>
<span class="line-removed">207     LOAD(2, 2, 5);</span>
<span class="line-removed">208 </span>
<span class="line-removed">209 #ifdef __SUNPRO_C</span>
<span class="line-removed">210 #pragma pipeloop(0)</span>
<span class="line-removed">211 #endif /* __SUNPRO_C */</span>
<span class="line-removed">212     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {</span>
<span class="line-removed">213       COUNT(0);</span>
<span class="line-removed">214       COUNT(1);</span>
<span class="line-removed">215       COUNT(2);</span>
<span class="line-removed">216       GET_POINTERS(3);</span>
<span class="line-removed">217       LOAD(0, 0, 3);</span>
<span class="line-removed">218       LOAD(1, 1, 4);</span>
<span class="line-removed">219       LOAD(2, 2, 5);</span>
<span class="line-removed">220       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">221       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">222       dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">223     }</span>
<span class="line-removed">224 </span>
<span class="line-removed">225     COUNT(0);</span>
<span class="line-removed">226     COUNT(1);</span>
<span class="line-removed">227     COUNT(2);</span>
<span class="line-removed">228     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">229     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">230     dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">231   }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233   return MLIB_SUCCESS;</span>
<span class="line-removed">234 }</span>
<span class="line-removed">235 </span>
<span class="line-removed">236 /***************************************************************/</span>
<span class="line-removed">237 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed">238 {</span>
<span class="line-removed">239   DECLAREVAR_BL();</span>
<span class="line-removed">240   DTYPE *dstLineEnd;</span>
<span class="line-removed">241   DTYPE *srcPixelPtr2;</span>
<span class="line-removed">242   FTYPE scale = (FTYPE) 1.0 / MLIB_PREC;</span>
<span class="line-removed">243 </span>
<span class="line-removed">244   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed">245     FTYPE fdx, fdy;</span>
<span class="line-removed">246     TTYPE a00_0, a01_0, a10_0, a11_0;</span>
<span class="line-removed">247     TTYPE a00_1, a01_1, a10_1, a11_1;</span>
<span class="line-removed">248     TTYPE a00_2, a01_2, a10_2, a11_2;</span>
<span class="line-removed">249     TTYPE a00_3, a01_3, a10_3, a11_3;</span>
<span class="line-removed">250     FTYPE pix0_0, pix1_0, res0;</span>
<span class="line-removed">251     FTYPE pix0_1, pix1_1, res1;</span>
<span class="line-removed">252     FTYPE pix0_2, pix1_2, res2;</span>
<span class="line-removed">253     FTYPE pix0_3, pix1_3, res3;</span>
<span class="line-removed">254 </span>
<span class="line-removed">255     CLIP(4);</span>
<span class="line-removed">256     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed">257 </span>
<span class="line-removed">258     GET_POINTERS(4);</span>
<span class="line-removed">259     LOAD(0, 0, 4);</span>
<span class="line-removed">260     LOAD(1, 1, 5);</span>
<span class="line-removed">261     LOAD(2, 2, 6);</span>
<span class="line-removed">262     LOAD(3, 3, 7);</span>
<span class="line-removed">263 </span>
<span class="line-removed">264 #ifdef __SUNPRO_C</span>
<span class="line-removed">265 #pragma pipeloop(0)</span>
<span class="line-removed">266 #endif /* __SUNPRO_C */</span>
<span class="line-removed">267     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {</span>
<span class="line-removed">268       COUNT(0);</span>
<span class="line-removed">269       COUNT(1);</span>
<span class="line-removed">270       COUNT(2);</span>
<span class="line-removed">271       COUNT(3);</span>
<span class="line-removed">272       GET_POINTERS(4);</span>
<span class="line-removed">273       LOAD(0, 0, 4);</span>
<span class="line-removed">274       LOAD(1, 1, 5);</span>
<span class="line-removed">275       LOAD(2, 2, 6);</span>
<span class="line-removed">276       LOAD(3, 3, 7);</span>
<span class="line-removed">277       dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">278       dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">279       dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">280       dstPixelPtr[3] = (DTYPE) res3;</span>
<span class="line-removed">281     }</span>
<span class="line-removed">282 </span>
<span class="line-removed">283     COUNT(0);</span>
<span class="line-removed">284     COUNT(1);</span>
<span class="line-removed">285     COUNT(2);</span>
<span class="line-removed">286     COUNT(3);</span>
<span class="line-removed">287     dstPixelPtr[0] = (DTYPE) res0;</span>
<span class="line-removed">288     dstPixelPtr[1] = (DTYPE) res1;</span>
<span class="line-removed">289     dstPixelPtr[2] = (DTYPE) res2;</span>
<span class="line-removed">290     dstPixelPtr[3] = (DTYPE) res3;</span>
<span class="line-removed">291   }</span>
<span class="line-removed">292 </span>
<span class="line-removed">293   return MLIB_SUCCESS;</span>
<span class="line-removed">294 }</span>
<span class="line-removed">295 </span>
<span class="line-removed">296 /***************************************************************/</span>
<span class="line-removed">297 #else       /* for x86, using integer multiplies is faster */</span>
298 
299 /***************************************************************/
300 /* for SHORT/USHORT decrease MLIB_SHIFT due to overflow in multiplies like fdy * (a10 - a00) */
301 #undef  MLIB_SHIFT
302 #define MLIB_SHIFT  15
303 
304 #define MLIB_ROUND   (1 &lt;&lt; (MLIB_SHIFT - 1))
305 
306 /***************************************************************/
307 #define GET_POINTERS(ind)                                        \
308   fdx = X &amp; MLIB_MASK;                                           \
309   fdy = Y &amp; MLIB_MASK;                                           \
310   ySrc = MLIB_POINTER_SHIFT(Y);                                  \
311   xSrc = X &gt;&gt; MLIB_SHIFT;                                        \
312   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;   \
313   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride); \
314   X += dX;                                                       \
315   Y += dY
316 
317 /***************************************************************/
</pre>
<hr />
<pre>
343     mlib_s32 fdx, fdy;
344     mlib_s32 a00_0, a01_0, a10_0, a11_0;
345     mlib_s32 pix0_0, pix1_0, res0;
346 
347     CLIP(1);
348     dstLineEnd = (DTYPE *) dstData + xRight;
349 #if MLIB_SHIFT == 15
350     X = X &gt;&gt; 1;
351     Y = Y &gt;&gt; 1;
352 
353     if (warp_tbl != NULL) {
354       dX = (dX + 1) &gt;&gt; 1;
355       dY = (dY + 1) &gt;&gt; 1;
356     }
357 
358 #endif
359 
360     GET_POINTERS(1);
361     LOAD(0, 0, 1);
362 
<span class="line-removed">363 #ifdef __SUNPRO_C</span>
<span class="line-removed">364 #pragma pipeloop(0)</span>
<span class="line-removed">365 #endif /* __SUNPRO_C */</span>
366     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {
367       COUNT(0);
368       GET_POINTERS(1);
369       LOAD(0, 0, 1);
370       dstPixelPtr[0] = (DTYPE) res0;
371     }
372 
373     COUNT(0);
374     dstPixelPtr[0] = (DTYPE) res0;
375   }
376 
377   return MLIB_SUCCESS;
378 }
379 
380 /***************************************************************/
381 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
382 {
383   DECLAREVAR_BL();
384   DTYPE *dstLineEnd;
385   DTYPE *srcPixelPtr2;
</pre>
<hr />
<pre>
396     mlib_s32 pix0_0, pix1_0, res0;
397     mlib_s32 pix0_1, pix1_1, res1;
398 
399     CLIP(2);
400     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
401 #if MLIB_SHIFT == 15
402     X = X &gt;&gt; 1;
403     Y = Y &gt;&gt; 1;
404 
405     if (warp_tbl != NULL) {
406       dX = (dX + 1) &gt;&gt; 1;
407       dY = (dY + 1) &gt;&gt; 1;
408     }
409 
410 #endif
411 
412     GET_POINTERS(2);
413     LOAD(0, 0, 2);
414     LOAD(1, 1, 3);
415 
<span class="line-removed">416 #ifdef __SUNPRO_C</span>
<span class="line-removed">417 #pragma pipeloop(0)</span>
<span class="line-removed">418 #endif /* __SUNPRO_C */</span>
419     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {
420       COUNT(0);
421       COUNT(1);
422       GET_POINTERS(2);
423       LOAD(0, 0, 2);
424       LOAD(1, 1, 3);
425       dstPixelPtr[0] = (DTYPE) res0;
426       dstPixelPtr[1] = (DTYPE) res1;
427     }
428 
429     COUNT(0);
430     COUNT(1);
431     dstPixelPtr[0] = (DTYPE) res0;
432     dstPixelPtr[1] = (DTYPE) res1;
433   }
434 
435   return MLIB_SUCCESS;
436 }
437 
438 /***************************************************************/
</pre>
<hr />
<pre>
457     mlib_s32 pix0_2, pix1_2, res2;
458 
459     CLIP(3);
460     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
461 #if MLIB_SHIFT == 15
462     X = X &gt;&gt; 1;
463     Y = Y &gt;&gt; 1;
464 
465     if (warp_tbl != NULL) {
466       dX = (dX + 1) &gt;&gt; 1;
467       dY = (dY + 1) &gt;&gt; 1;
468     }
469 
470 #endif
471 
472     GET_POINTERS(3);
473     LOAD(0, 0, 3);
474     LOAD(1, 1, 4);
475     LOAD(2, 2, 5);
476 
<span class="line-removed">477 #ifdef __SUNPRO_C</span>
<span class="line-removed">478 #pragma pipeloop(0)</span>
<span class="line-removed">479 #endif /* __SUNPRO_C */</span>
480     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {
481       COUNT(0);
482       COUNT(1);
483       COUNT(2);
484       GET_POINTERS(3);
485       LOAD(0, 0, 3);
486       LOAD(1, 1, 4);
487       LOAD(2, 2, 5);
488       dstPixelPtr[0] = (DTYPE) res0;
489       dstPixelPtr[1] = (DTYPE) res1;
490       dstPixelPtr[2] = (DTYPE) res2;
491     }
492 
493     COUNT(0);
494     COUNT(1);
495     COUNT(2);
496     dstPixelPtr[0] = (DTYPE) res0;
497     dstPixelPtr[1] = (DTYPE) res1;
498     dstPixelPtr[2] = (DTYPE) res2;
499   }
</pre>
<hr />
<pre>
526 
527     CLIP(4);
528     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
529 #if MLIB_SHIFT == 15
530     X = X &gt;&gt; 1;
531     Y = Y &gt;&gt; 1;
532 
533     if (warp_tbl != NULL) {
534       dX = (dX + 1) &gt;&gt; 1;
535       dY = (dY + 1) &gt;&gt; 1;
536     }
537 
538 #endif
539 
540     GET_POINTERS(4);
541     LOAD(0, 0, 4);
542     LOAD(1, 1, 5);
543     LOAD(2, 2, 6);
544     LOAD(3, 3, 7);
545 
<span class="line-removed">546 #ifdef __SUNPRO_C</span>
<span class="line-removed">547 #pragma pipeloop(0)</span>
<span class="line-removed">548 #endif /* __SUNPRO_C */</span>
549     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {
550       COUNT(0);
551       COUNT(1);
552       COUNT(2);
553       COUNT(3);
554       GET_POINTERS(4);
555       LOAD(0, 0, 4);
556       LOAD(1, 1, 5);
557       LOAD(2, 2, 6);
558       LOAD(3, 3, 7);
559       dstPixelPtr[0] = (DTYPE) res0;
560       dstPixelPtr[1] = (DTYPE) res1;
561       dstPixelPtr[2] = (DTYPE) res2;
562       dstPixelPtr[3] = (DTYPE) res3;
563     }
564 
565     COUNT(0);
566     COUNT(1);
567     COUNT(2);
568     COUNT(3);
569     dstPixelPtr[0] = (DTYPE) res0;
570     dstPixelPtr[1] = (DTYPE) res1;
571     dstPixelPtr[2] = (DTYPE) res2;
572     dstPixelPtr[3] = (DTYPE) res3;
573   }
574 
575   return MLIB_SUCCESS;
576 }
577 
<span class="line-removed">578 #endif /* #ifdef __sparc */</span>
<span class="line-removed">579 </span>
580 /***************************************************************/
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 60  * DESCRIPTION
 61  *      The functions step along the lines from xLeft to xRight and apply
 62  *      the bilinear filtering.
 63  *
 64  */
 65 
 66 #include &quot;mlib_ImageAffine.h&quot;
 67 
 68 /***************************************************************/
 69 #define DTYPE  mlib_u16
 70 #define FTYPE  mlib_d64
 71 
 72 /***************************************************************/
 73 #define TTYPE    mlib_s32
 74 #define I2F(x)   (x)
 75 #define ROUND(x) (x)
 76 
 77 #define FUN_NAME(CHAN) mlib_ImageAffine_u16_##CHAN##_bl
 78 
 79 /***************************************************************/
<span class="line-modified"> 80 /* for x86, using integer multiplies is faster */</span>

























































































































































































































 81 
 82 /***************************************************************/
 83 /* for SHORT/USHORT decrease MLIB_SHIFT due to overflow in multiplies like fdy * (a10 - a00) */
 84 #undef  MLIB_SHIFT
 85 #define MLIB_SHIFT  15
 86 
 87 #define MLIB_ROUND   (1 &lt;&lt; (MLIB_SHIFT - 1))
 88 
 89 /***************************************************************/
 90 #define GET_POINTERS(ind)                                        \
 91   fdx = X &amp; MLIB_MASK;                                           \
 92   fdy = Y &amp; MLIB_MASK;                                           \
 93   ySrc = MLIB_POINTER_SHIFT(Y);                                  \
 94   xSrc = X &gt;&gt; MLIB_SHIFT;                                        \
 95   srcPixelPtr = MLIB_POINTER_GET(lineAddr, ySrc) + ind * xSrc;   \
 96   srcPixelPtr2 = (DTYPE *)((mlib_u8 *)srcPixelPtr + srcYStride); \
 97   X += dX;                                                       \
 98   Y += dY
 99 
100 /***************************************************************/
</pre>
<hr />
<pre>
126     mlib_s32 fdx, fdy;
127     mlib_s32 a00_0, a01_0, a10_0, a11_0;
128     mlib_s32 pix0_0, pix1_0, res0;
129 
130     CLIP(1);
131     dstLineEnd = (DTYPE *) dstData + xRight;
132 #if MLIB_SHIFT == 15
133     X = X &gt;&gt; 1;
134     Y = Y &gt;&gt; 1;
135 
136     if (warp_tbl != NULL) {
137       dX = (dX + 1) &gt;&gt; 1;
138       dY = (dY + 1) &gt;&gt; 1;
139     }
140 
141 #endif
142 
143     GET_POINTERS(1);
144     LOAD(0, 0, 1);
145 



146     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr++) {
147       COUNT(0);
148       GET_POINTERS(1);
149       LOAD(0, 0, 1);
150       dstPixelPtr[0] = (DTYPE) res0;
151     }
152 
153     COUNT(0);
154     dstPixelPtr[0] = (DTYPE) res0;
155   }
156 
157   return MLIB_SUCCESS;
158 }
159 
160 /***************************************************************/
161 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
162 {
163   DECLAREVAR_BL();
164   DTYPE *dstLineEnd;
165   DTYPE *srcPixelPtr2;
</pre>
<hr />
<pre>
176     mlib_s32 pix0_0, pix1_0, res0;
177     mlib_s32 pix0_1, pix1_1, res1;
178 
179     CLIP(2);
180     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
181 #if MLIB_SHIFT == 15
182     X = X &gt;&gt; 1;
183     Y = Y &gt;&gt; 1;
184 
185     if (warp_tbl != NULL) {
186       dX = (dX + 1) &gt;&gt; 1;
187       dY = (dY + 1) &gt;&gt; 1;
188     }
189 
190 #endif
191 
192     GET_POINTERS(2);
193     LOAD(0, 0, 2);
194     LOAD(1, 1, 3);
195 



196     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 2) {
197       COUNT(0);
198       COUNT(1);
199       GET_POINTERS(2);
200       LOAD(0, 0, 2);
201       LOAD(1, 1, 3);
202       dstPixelPtr[0] = (DTYPE) res0;
203       dstPixelPtr[1] = (DTYPE) res1;
204     }
205 
206     COUNT(0);
207     COUNT(1);
208     dstPixelPtr[0] = (DTYPE) res0;
209     dstPixelPtr[1] = (DTYPE) res1;
210   }
211 
212   return MLIB_SUCCESS;
213 }
214 
215 /***************************************************************/
</pre>
<hr />
<pre>
234     mlib_s32 pix0_2, pix1_2, res2;
235 
236     CLIP(3);
237     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
238 #if MLIB_SHIFT == 15
239     X = X &gt;&gt; 1;
240     Y = Y &gt;&gt; 1;
241 
242     if (warp_tbl != NULL) {
243       dX = (dX + 1) &gt;&gt; 1;
244       dY = (dY + 1) &gt;&gt; 1;
245     }
246 
247 #endif
248 
249     GET_POINTERS(3);
250     LOAD(0, 0, 3);
251     LOAD(1, 1, 4);
252     LOAD(2, 2, 5);
253 



254     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 3) {
255       COUNT(0);
256       COUNT(1);
257       COUNT(2);
258       GET_POINTERS(3);
259       LOAD(0, 0, 3);
260       LOAD(1, 1, 4);
261       LOAD(2, 2, 5);
262       dstPixelPtr[0] = (DTYPE) res0;
263       dstPixelPtr[1] = (DTYPE) res1;
264       dstPixelPtr[2] = (DTYPE) res2;
265     }
266 
267     COUNT(0);
268     COUNT(1);
269     COUNT(2);
270     dstPixelPtr[0] = (DTYPE) res0;
271     dstPixelPtr[1] = (DTYPE) res1;
272     dstPixelPtr[2] = (DTYPE) res2;
273   }
</pre>
<hr />
<pre>
300 
301     CLIP(4);
302     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
303 #if MLIB_SHIFT == 15
304     X = X &gt;&gt; 1;
305     Y = Y &gt;&gt; 1;
306 
307     if (warp_tbl != NULL) {
308       dX = (dX + 1) &gt;&gt; 1;
309       dY = (dY + 1) &gt;&gt; 1;
310     }
311 
312 #endif
313 
314     GET_POINTERS(4);
315     LOAD(0, 0, 4);
316     LOAD(1, 1, 5);
317     LOAD(2, 2, 6);
318     LOAD(3, 3, 7);
319 



320     for (; dstPixelPtr &lt; dstLineEnd; dstPixelPtr += 4) {
321       COUNT(0);
322       COUNT(1);
323       COUNT(2);
324       COUNT(3);
325       GET_POINTERS(4);
326       LOAD(0, 0, 4);
327       LOAD(1, 1, 5);
328       LOAD(2, 2, 6);
329       LOAD(3, 3, 7);
330       dstPixelPtr[0] = (DTYPE) res0;
331       dstPixelPtr[1] = (DTYPE) res1;
332       dstPixelPtr[2] = (DTYPE) res2;
333       dstPixelPtr[3] = (DTYPE) res3;
334     }
335 
336     COUNT(0);
337     COUNT(1);
338     COUNT(2);
339     COUNT(3);
340     dstPixelPtr[0] = (DTYPE) res0;
341     dstPixelPtr[1] = (DTYPE) res1;
342     dstPixelPtr[2] = (DTYPE) res2;
343     dstPixelPtr[3] = (DTYPE) res3;
344   }
345 
346   return MLIB_SUCCESS;
347 }
348 


349 /***************************************************************/
</pre>
</td>
</tr>
</table>
<center><a href="mlib_c_ImageAffine_BL_S16.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_c_ImageAffine_NN.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
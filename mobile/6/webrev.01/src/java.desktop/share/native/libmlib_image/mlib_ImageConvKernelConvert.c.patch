diff a/src/java.desktop/share/native/libmlib_image/mlib_ImageConvKernelConvert.c b/src/java.desktop/share/native/libmlib_image/mlib_ImageConvKernelConvert.c
--- a/src/java.desktop/share/native/libmlib_image/mlib_ImageConvKernelConvert.c
+++ b/src/java.desktop/share/native/libmlib_image/mlib_ImageConvKernelConvert.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -59,26 +59,18 @@
 #include "mlib_image.h"
 #include "mlib_SysMath.h"
 #include "mlib_ImageConv.h"
 
 /***************************************************************/
-#ifdef __sparc
-
-#define CLAMP_S32(dst, src)                                     \
-  dst = (mlib_s32)(src)
-
-#else
 
 #define CLAMP_S32(dst, src) {                                   \
   mlib_d64 s0 = (mlib_d64)(src);                                \
   if (s0 > (mlib_d64)MLIB_S32_MAX) s0 = (mlib_d64)MLIB_S32_MAX; \
   if (s0 < (mlib_d64)MLIB_S32_MIN) s0 = (mlib_d64)MLIB_S32_MIN; \
   dst = (mlib_s32)s0;                                           \
 }
 
-#endif /* __sparc */
-
 /***************************************************************/
 JNIEXPORT
 mlib_status mlib_ImageConvKernelConvert(mlib_s32       *ikernel,
                                         mlib_s32       *iscale,
                                         const mlib_d64 *fkernel,
@@ -148,19 +140,14 @@
 
       return MLIB_SUCCESS;
     }
 
     /* try to round coefficients */
-#ifdef __sparc
-    scale1 = 16;                            /* shift of coefficients is 16 */
-#else
-
     if (chk_flag == 3)
       scale1 = 16;                          /* MMX */
     else
       scale1 = (type == MLIB_BYTE) ? 8 : 16;
-#endif /* __sparc */
     norm = (1u << (scale - scale1));
 
     for (i = 0; i < m * n; i++) {
       if (fkernel[i] > 0)
         ikernel[i] = (mlib_s32) (fkernel[i] * norm + 0.5);

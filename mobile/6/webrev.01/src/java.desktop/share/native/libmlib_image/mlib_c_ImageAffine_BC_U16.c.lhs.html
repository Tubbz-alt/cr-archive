<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_U16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 /*
  28  * FUNCTION
  29  *      Image affine transformation with Bicubic filtering
  30  * SYNOPSIS
  31  *      mlib_status mlib_ImageAffine_[u8|s16|u16]_?ch_bc(mlib_s32 *leftEdges,
  32  *                                                       mlib_s32 *rightEdges,
  33  *                                                       mlib_s32 *xStarts,
  34  *                                                       mlib_s32 *yStarts,
  35  *                                                       mlib_s32 *sides,
  36  *                                                       mlib_u8  *dstData,
  37  *                                                       mlib_u8  **lineAddr,
  38  *                                                       mlib_s32 dstYStride,
  39  *                                                       mlib_s32 is_affine,
  40  *                                                       mlib_s32 srcYStride,
  41  *                                                       mlib_filter filter)
  42  *
  43  * ARGUMENTS
  44  *      leftEdges  array[dstHeight] of xLeft coordinates
  45  *      RightEdges array[dstHeight] of xRight coordinates
  46  *      xStarts    array[dstHeight] of xStart * 65536 coordinates
  47  *      yStarts    array[dstHeight] of yStart * 65536 coordinates
  48  *      sides      output array[4]. sides[0] is yStart, sides[1] is yFinish,
  49  *                 sides[2] is dx * 65536, sides[3] is dy * 65536
  50  *      dstData    pointer to the first pixel on (yStart - 1) line
  51  *      lineAddr   array[srcHeight] of pointers to the first pixel on
  52  *                 the corresponding lines
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE  mlib_u16
  67 
  68 #define FUN_NAME(CHAN) mlib_ImageAffine_u16_##CHAN##_bc
  69 
  70 #define FILTER_BITS   9
  71 
  72 /***************************************************************/
<a name="2" id="anc2"></a><span class="line-modified">  73 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  74 </span>
<span class="line-removed">  75 /***************************************************************/</span>
<span class="line-removed">  76 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  77 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  78 </span>
<span class="line-removed">  79 /***************************************************************/</span>
<span class="line-removed">  80 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  81 </span>
<span class="line-removed">  82 #define SAT_U16(DST)                                            \</span>
<span class="line-removed">  83   DST = ((mlib_s32)(val0 - (mlib_d64)0x7FFF8000) &gt;&gt; 16) ^ 0x8000</span>
<span class="line-removed">  84 </span>
<span class="line-removed">  85 #else</span>
<span class="line-removed">  86 </span>
<span class="line-removed">  87 #define SAT_U16(DST)                                            \</span>
<span class="line-removed">  88   if (val0 &gt;= MLIB_U32_MAX)                                     \</span>
<span class="line-removed">  89     DST = MLIB_U16_MAX;                                         \</span>
<span class="line-removed">  90   else if (val0 &lt;= MLIB_U32_MIN)                                \</span>
<span class="line-removed">  91     DST = MLIB_U16_MIN;                                         \</span>
<span class="line-removed">  92   else                                                          \</span>
<span class="line-removed">  93     DST = ((mlib_u32)val0) &gt;&gt; 16</span>
<span class="line-removed">  94 </span>
<span class="line-removed">  95 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97 /***************************************************************/</span>
<span class="line-removed">  98 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  99 {</span>
<span class="line-removed"> 100   DECLAREVAR_BC();</span>
<span class="line-removed"> 101   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 102   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 103 </span>
<span class="line-removed"> 104   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 105     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 106   }</span>
<span class="line-removed"> 107   else {</span>
<span class="line-removed"> 108     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 109   }</span>
<span class="line-removed"> 110 </span>
<span class="line-removed"> 111   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 112     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 113     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 114     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 115     mlib_s32 filterpos;</span>
<span class="line-removed"> 116     mlib_f32 *fptr;</span>
<span class="line-removed"> 117     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 118     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120     CLIP(1);</span>
<span class="line-removed"> 121     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 124     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     xf0 = fptr[0];</span>
<span class="line-removed"> 127     xf1 = fptr[1];</span>
<span class="line-removed"> 128     xf2 = fptr[2];</span>
<span class="line-removed"> 129     xf3 = fptr[3];</span>
<span class="line-removed"> 130 </span>
<span class="line-removed"> 131     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 132     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     yf0 = fptr[0];</span>
<span class="line-removed"> 135     yf1 = fptr[1];</span>
<span class="line-removed"> 136     yf2 = fptr[2];</span>
<span class="line-removed"> 137     yf3 = fptr[3];</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 140     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 141 </span>
<span class="line-removed"> 142     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 143     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 144     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 145     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 146     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 149     s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 150     s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 151     s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 152     s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 155 </span>
<span class="line-removed"> 156       X += dX;</span>
<span class="line-removed"> 157       Y += dY;</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 160       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 161       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 162       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 163             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 164       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 165       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 166             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 167 </span>
<span class="line-removed"> 168       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 169       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171       xf0 = fptr[0];</span>
<span class="line-removed"> 172       xf1 = fptr[1];</span>
<span class="line-removed"> 173       xf2 = fptr[2];</span>
<span class="line-removed"> 174       xf3 = fptr[3];</span>
<span class="line-removed"> 175 </span>
<span class="line-removed"> 176       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 179       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181       yf0 = fptr[0];</span>
<span class="line-removed"> 182       yf1 = fptr[1];</span>
<span class="line-removed"> 183       yf2 = fptr[2];</span>
<span class="line-removed"> 184       yf3 = fptr[3];</span>
<span class="line-removed"> 185 </span>
<span class="line-removed"> 186       SAT_U16(dstPixelPtr[0]);</span>
<span class="line-removed"> 187 </span>
<span class="line-removed"> 188       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 189       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 192       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 193       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 194       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 195       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 198       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 199       s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 200       s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 201       s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 202     }</span>
<span class="line-removed"> 203 </span>
<span class="line-removed"> 204     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 205     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 206     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 207     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 208           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 209     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 210     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 211           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 214     SAT_U16(dstPixelPtr[0]);</span>
<span class="line-removed"> 215   }</span>
<span class="line-removed"> 216 </span>
<span class="line-removed"> 217   return MLIB_SUCCESS;</span>
<span class="line-removed"> 218 }</span>
<span class="line-removed"> 219 </span>
<span class="line-removed"> 220 /***************************************************************/</span>
<span class="line-removed"> 221 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 222 {</span>
<span class="line-removed"> 223   DECLAREVAR_BC();</span>
<span class="line-removed"> 224   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 225   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 226 </span>
<span class="line-removed"> 227   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 228     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 229   }</span>
<span class="line-removed"> 230   else {</span>
<span class="line-removed"> 231     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 232   }</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 235     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 236     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 237     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 238     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 239     mlib_f32 *fptr;</span>
<span class="line-removed"> 240     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 241     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     CLIP(2);</span>
<span class="line-removed"> 244     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 245 </span>
<span class="line-removed"> 246     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 247       mlib_s32 X1 = X;</span>
<span class="line-removed"> 248       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 249       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 252       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254       xf0 = fptr[0];</span>
<span class="line-removed"> 255       xf1 = fptr[1];</span>
<span class="line-removed"> 256       xf2 = fptr[2];</span>
<span class="line-removed"> 257       xf3 = fptr[3];</span>
<span class="line-removed"> 258 </span>
<span class="line-removed"> 259       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 260       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 261 </span>
<span class="line-removed"> 262       yf0 = fptr[0];</span>
<span class="line-removed"> 263       yf1 = fptr[1];</span>
<span class="line-removed"> 264       yf2 = fptr[2];</span>
<span class="line-removed"> 265       yf3 = fptr[3];</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 268       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 271       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 272       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 273       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 274       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 277       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 278       s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 279       s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 280       s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 281 </span>
<span class="line-removed"> 282       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 283 </span>
<span class="line-removed"> 284         X1 += dX;</span>
<span class="line-removed"> 285         Y1 += dY;</span>
<span class="line-removed"> 286 </span>
<span class="line-removed"> 287         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 288         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 289         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 290         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 291               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 292         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 293         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 294               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 297         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 298 </span>
<span class="line-removed"> 299         xf0 = fptr[0];</span>
<span class="line-removed"> 300         xf1 = fptr[1];</span>
<span class="line-removed"> 301         xf2 = fptr[2];</span>
<span class="line-removed"> 302         xf3 = fptr[3];</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 307         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 308 </span>
<span class="line-removed"> 309         yf0 = fptr[0];</span>
<span class="line-removed"> 310         yf1 = fptr[1];</span>
<span class="line-removed"> 311         yf2 = fptr[2];</span>
<span class="line-removed"> 312         yf3 = fptr[3];</span>
<span class="line-removed"> 313 </span>
<span class="line-removed"> 314         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 315 </span>
<span class="line-removed"> 316         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 317         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 318 </span>
<span class="line-removed"> 319         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 320         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 321         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 322         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 323         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 324 </span>
<span class="line-removed"> 325         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 326         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 327         s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 328         s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 329         s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 330       }</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 333       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 334       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 335       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 336             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 337       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 338       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 339             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 340 </span>
<span class="line-removed"> 341       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 342       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344   }</span>
<span class="line-removed"> 345 </span>
<span class="line-removed"> 346   return MLIB_SUCCESS;</span>
<span class="line-removed"> 347 }</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349 /***************************************************************/</span>
<span class="line-removed"> 350 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 351 {</span>
<span class="line-removed"> 352   DECLAREVAR_BC();</span>
<span class="line-removed"> 353   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 354   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 357     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 358   }</span>
<span class="line-removed"> 359   else {</span>
<span class="line-removed"> 360     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 361   }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 364     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 365     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 366     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 367     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 368     mlib_f32 *fptr;</span>
<span class="line-removed"> 369     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 370     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372     CLIP(3);</span>
<span class="line-removed"> 373     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 374 </span>
<span class="line-removed"> 375     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 376       mlib_s32 X1 = X;</span>
<span class="line-removed"> 377       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 378       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 381       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383       xf0 = fptr[0];</span>
<span class="line-removed"> 384       xf1 = fptr[1];</span>
<span class="line-removed"> 385       xf2 = fptr[2];</span>
<span class="line-removed"> 386       xf3 = fptr[3];</span>
<span class="line-removed"> 387 </span>
<span class="line-removed"> 388       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 389       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 390 </span>
<span class="line-removed"> 391       yf0 = fptr[0];</span>
<span class="line-removed"> 392       yf1 = fptr[1];</span>
<span class="line-removed"> 393       yf2 = fptr[2];</span>
<span class="line-removed"> 394       yf3 = fptr[3];</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 397       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 400       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 401       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 402       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 403       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 404 </span>
<span class="line-removed"> 405       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 406       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 407       s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 408       s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 409       s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 410 </span>
<span class="line-removed"> 411       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 412 </span>
<span class="line-removed"> 413         X1 += dX;</span>
<span class="line-removed"> 414         Y1 += dY;</span>
<span class="line-removed"> 415 </span>
<span class="line-removed"> 416         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 417         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 418         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 419         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 420               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 421         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 422         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 423               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 424 </span>
<span class="line-removed"> 425         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 426         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         xf0 = fptr[0];</span>
<span class="line-removed"> 429         xf1 = fptr[1];</span>
<span class="line-removed"> 430         xf2 = fptr[2];</span>
<span class="line-removed"> 431         xf3 = fptr[3];</span>
<span class="line-removed"> 432 </span>
<span class="line-removed"> 433         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 434 </span>
<span class="line-removed"> 435         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 436         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         yf0 = fptr[0];</span>
<span class="line-removed"> 439         yf1 = fptr[1];</span>
<span class="line-removed"> 440         yf2 = fptr[2];</span>
<span class="line-removed"> 441         yf3 = fptr[3];</span>
<span class="line-removed"> 442 </span>
<span class="line-removed"> 443         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 444 </span>
<span class="line-removed"> 445         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 446         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 449         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 450         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 451         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 452         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 455         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 456         s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 457         s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 458         s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 459       }</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 462       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 463       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 464       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 465             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 466       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 467       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 468             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 469 </span>
<span class="line-removed"> 470       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 471       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 472     }</span>
<span class="line-removed"> 473   }</span>
<span class="line-removed"> 474 </span>
<span class="line-removed"> 475   return MLIB_SUCCESS;</span>
<span class="line-removed"> 476 }</span>
<span class="line-removed"> 477 </span>
<span class="line-removed"> 478 /***************************************************************/</span>
<span class="line-removed"> 479 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 480 {</span>
<span class="line-removed"> 481   DECLAREVAR_BC();</span>
<span class="line-removed"> 482   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 483   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 484 </span>
<span class="line-removed"> 485   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 486     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 487   }</span>
<span class="line-removed"> 488   else {</span>
<span class="line-removed"> 489     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 490   }</span>
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 493     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 494     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 495     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 496     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 497     mlib_f32 *fptr;</span>
<span class="line-removed"> 498     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 499     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     CLIP(4);</span>
<span class="line-removed"> 502     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 505       mlib_s32 X1 = X;</span>
<span class="line-removed"> 506       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 507       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 510       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       xf0 = fptr[0];</span>
<span class="line-removed"> 513       xf1 = fptr[1];</span>
<span class="line-removed"> 514       xf2 = fptr[2];</span>
<span class="line-removed"> 515       xf3 = fptr[3];</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 518       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520       yf0 = fptr[0];</span>
<span class="line-removed"> 521       yf1 = fptr[1];</span>
<span class="line-removed"> 522       yf2 = fptr[2];</span>
<span class="line-removed"> 523       yf3 = fptr[3];</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 526       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 527 </span>
<span class="line-removed"> 528       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 529       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 530       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 531       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 532       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 535       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 536       s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 537       s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 538       s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 539 </span>
<span class="line-removed"> 540       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 541 </span>
<span class="line-removed"> 542         X1 += dX;</span>
<span class="line-removed"> 543         Y1 += dY;</span>
<span class="line-removed"> 544 </span>
<span class="line-removed"> 545         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 546         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 547         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 548         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 549               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 550         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 551         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 552               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 555         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557         xf0 = fptr[0];</span>
<span class="line-removed"> 558         xf1 = fptr[1];</span>
<span class="line-removed"> 559         xf2 = fptr[2];</span>
<span class="line-removed"> 560         xf3 = fptr[3];</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 565         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 566 </span>
<span class="line-removed"> 567         yf0 = fptr[0];</span>
<span class="line-removed"> 568         yf1 = fptr[1];</span>
<span class="line-removed"> 569         yf2 = fptr[2];</span>
<span class="line-removed"> 570         yf3 = fptr[3];</span>
<span class="line-removed"> 571 </span>
<span class="line-removed"> 572         SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 575         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 576 </span>
<span class="line-removed"> 577         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 578         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 579         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 580         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 581         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 584         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 585         s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 586         s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 587         s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 588       }</span>
<span class="line-removed"> 589 </span>
<span class="line-removed"> 590       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 591       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 592       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 593       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 594             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 595       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 596       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 597             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 600       SAT_U16(dPtr[0]);</span>
<span class="line-removed"> 601     }</span>
<span class="line-removed"> 602   }</span>
<span class="line-removed"> 603 </span>
<span class="line-removed"> 604   return MLIB_SUCCESS;</span>
<span class="line-removed"> 605 }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607 #else       /* for x86, using integer multiplies is faster */</span>
 608 
 609 #define SHIFT_X  15
 610 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 611 
 612 #define SHIFT_Y  14
 613 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 614 
 615 #define S32_TO_U16_SAT(DST)                                     \
 616   if (val0 &gt;= MLIB_U16_MAX)                                     \
 617     DST = MLIB_U16_MAX;                                         \
 618   else if (val0 &lt;= MLIB_U16_MIN)                                \
 619     DST = MLIB_U16_MIN;                                         \
 620   else                                                          \
 621     DST = (mlib_u16)val0
 622 
 623 /***************************************************************/
 624 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
 625 {
 626   DECLAREVAR_BC();
 627   DTYPE *dstLineEnd;
 628   const mlib_s16 *mlib_filters_table;
 629 
 630   if (filter == MLIB_BICUBIC) {
 631     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 632   }
 633   else {
 634     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 635   }
 636 
 637   for (j = yStart; j &lt;= yFinish; j++) {
 638     mlib_s32 xf0, xf1, xf2, xf3;
 639     mlib_s32 yf0, yf1, yf2, yf3;
 640     mlib_s32 c0, c1, c2, c3, val0;
 641     mlib_s32 filterpos;
 642     mlib_s16 *fptr;
 643     mlib_s32 s0, s1, s2, s3;
 644     mlib_s32 s4, s5, s6, s7;
 645 
 646     CLIP(1);
 647     dstLineEnd = (DTYPE *) dstData + xRight;
 648 
 649     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 650     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 651 
 652     xf0 = fptr[0] &gt;&gt; 1;
 653     xf1 = fptr[1] &gt;&gt; 1;
 654     xf2 = fptr[2] &gt;&gt; 1;
 655     xf3 = fptr[3] &gt;&gt; 1;
 656 
 657     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 658     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 659 
 660     yf0 = fptr[0];
 661     yf1 = fptr[1];
 662     yf2 = fptr[2];
 663     yf3 = fptr[3];
 664 
 665     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 666     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 667 
 668     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 669     s0 = srcPixelPtr[0];
 670     s1 = srcPixelPtr[1];
 671     s2 = srcPixelPtr[2];
 672     s3 = srcPixelPtr[3];
 673 
 674     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 675     s4 = srcPixelPtr[0];
 676     s5 = srcPixelPtr[1];
 677     s6 = srcPixelPtr[2];
 678     s7 = srcPixelPtr[3];
 679 
 680     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {
 681 
 682       X += dX;
 683       Y += dY;
 684 
 685       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 686       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 687       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 688       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 689             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 690       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 691       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 692             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 693 
 694       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 695       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 696 
 697       xf0 = fptr[0] &gt;&gt; 1;
 698       xf1 = fptr[1] &gt;&gt; 1;
 699       xf2 = fptr[2] &gt;&gt; 1;
 700       xf3 = fptr[3] &gt;&gt; 1;
 701 
 702       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 703 
 704       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 705       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 706 
 707       yf0 = fptr[0];
 708       yf1 = fptr[1];
 709       yf2 = fptr[2];
 710       yf3 = fptr[3];
 711 
 712       S32_TO_U16_SAT(dstPixelPtr[0]);
 713 
 714       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 715       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 716 
 717       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 718       s0 = srcPixelPtr[0];
 719       s1 = srcPixelPtr[1];
 720       s2 = srcPixelPtr[2];
 721       s3 = srcPixelPtr[3];
 722 
 723       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 724       s4 = srcPixelPtr[0];
 725       s5 = srcPixelPtr[1];
 726       s6 = srcPixelPtr[2];
 727       s7 = srcPixelPtr[3];
 728     }
 729 
 730     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 731     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 732     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 733     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 734           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 735     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 736     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 737           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 738 
 739     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 740     S32_TO_U16_SAT(dstPixelPtr[0]);
 741   }
 742 
 743   return MLIB_SUCCESS;
 744 }
 745 
 746 /***************************************************************/
 747 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
 748 {
 749   DECLAREVAR_BC();
 750   DTYPE *dstLineEnd;
 751   const mlib_s16 *mlib_filters_table;
 752 
 753   if (filter == MLIB_BICUBIC) {
 754     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 755   }
 756   else {
 757     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 758   }
 759 
 760   for (j = yStart; j &lt;= yFinish; j++) {
 761     mlib_s32 xf0, xf1, xf2, xf3;
 762     mlib_s32 yf0, yf1, yf2, yf3;
 763     mlib_s32 c0, c1, c2, c3, val0;
 764     mlib_s32 filterpos, k;
 765     mlib_s16 *fptr;
 766     mlib_s32 s0, s1, s2, s3;
 767     mlib_s32 s4, s5, s6, s7;
 768 
 769     CLIP(2);
 770     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
 771 
 772     for (k = 0; k &lt; 2; k++) {
 773       mlib_s32 X1 = X;
 774       mlib_s32 Y1 = Y;
 775       DTYPE *dPtr = dstPixelPtr + k;
 776 
 777       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 778       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 779 
 780       xf0 = fptr[0] &gt;&gt; 1;
 781       xf1 = fptr[1] &gt;&gt; 1;
 782       xf2 = fptr[2] &gt;&gt; 1;
 783       xf3 = fptr[3] &gt;&gt; 1;
 784 
 785       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 786       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 787 
 788       yf0 = fptr[0];
 789       yf1 = fptr[1];
 790       yf2 = fptr[2];
 791       yf3 = fptr[3];
 792 
 793       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 794       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 795 
 796       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 797       s0 = srcPixelPtr[0];
 798       s1 = srcPixelPtr[2];
 799       s2 = srcPixelPtr[4];
 800       s3 = srcPixelPtr[6];
 801 
 802       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 803       s4 = srcPixelPtr[0];
 804       s5 = srcPixelPtr[2];
 805       s6 = srcPixelPtr[4];
 806       s7 = srcPixelPtr[6];
 807 
 808       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {
 809 
 810         X1 += dX;
 811         Y1 += dY;
 812 
 813         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 814         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 815         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 816         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 817               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 818         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 819         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 820               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 821 
 822         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 823         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 824 
 825         xf0 = fptr[0] &gt;&gt; 1;
 826         xf1 = fptr[1] &gt;&gt; 1;
 827         xf2 = fptr[2] &gt;&gt; 1;
 828         xf3 = fptr[3] &gt;&gt; 1;
 829 
 830         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 831 
 832         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 833         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 834 
 835         yf0 = fptr[0];
 836         yf1 = fptr[1];
 837         yf2 = fptr[2];
 838         yf3 = fptr[3];
 839 
 840         S32_TO_U16_SAT(dPtr[0]);
 841 
 842         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 843         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 844 
 845         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 846         s0 = srcPixelPtr[0];
 847         s1 = srcPixelPtr[2];
 848         s2 = srcPixelPtr[4];
 849         s3 = srcPixelPtr[6];
 850 
 851         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 852         s4 = srcPixelPtr[0];
 853         s5 = srcPixelPtr[2];
 854         s6 = srcPixelPtr[4];
 855         s7 = srcPixelPtr[6];
 856       }
 857 
 858       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 859       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 860       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 861       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 862             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 863       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 864       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 865             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 866 
 867       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 868       S32_TO_U16_SAT(dPtr[0]);
 869     }
 870   }
 871 
 872   return MLIB_SUCCESS;
 873 }
 874 
 875 /***************************************************************/
 876 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)
 877 {
 878   DECLAREVAR_BC();
 879   DTYPE *dstLineEnd;
 880   const mlib_s16 *mlib_filters_table;
 881 
 882   if (filter == MLIB_BICUBIC) {
 883     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 884   }
 885   else {
 886     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 887   }
 888 
 889   for (j = yStart; j &lt;= yFinish; j++) {
 890     mlib_s32 xf0, xf1, xf2, xf3;
 891     mlib_s32 yf0, yf1, yf2, yf3;
 892     mlib_s32 c0, c1, c2, c3, val0;
 893     mlib_s32 filterpos, k;
 894     mlib_s16 *fptr;
 895     mlib_s32 s0, s1, s2, s3;
 896     mlib_s32 s4, s5, s6, s7;
 897 
 898     CLIP(3);
 899     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
 900 
 901     for (k = 0; k &lt; 3; k++) {
 902       mlib_s32 X1 = X;
 903       mlib_s32 Y1 = Y;
 904       DTYPE *dPtr = dstPixelPtr + k;
 905 
 906       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 907       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 908 
 909       xf0 = fptr[0] &gt;&gt; 1;
 910       xf1 = fptr[1] &gt;&gt; 1;
 911       xf2 = fptr[2] &gt;&gt; 1;
 912       xf3 = fptr[3] &gt;&gt; 1;
 913 
 914       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 915       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 916 
 917       yf0 = fptr[0];
 918       yf1 = fptr[1];
 919       yf2 = fptr[2];
 920       yf3 = fptr[3];
 921 
 922       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 923       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 924 
 925       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 926       s0 = srcPixelPtr[0];
 927       s1 = srcPixelPtr[3];
 928       s2 = srcPixelPtr[6];
 929       s3 = srcPixelPtr[9];
 930 
 931       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 932       s4 = srcPixelPtr[0];
 933       s5 = srcPixelPtr[3];
 934       s6 = srcPixelPtr[6];
 935       s7 = srcPixelPtr[9];
 936 
 937       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {
 938 
 939         X1 += dX;
 940         Y1 += dY;
 941 
 942         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 943         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 944         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 945         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 946               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 947         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 948         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 949               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 950 
 951         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 952         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 953 
 954         xf0 = fptr[0] &gt;&gt; 1;
 955         xf1 = fptr[1] &gt;&gt; 1;
 956         xf2 = fptr[2] &gt;&gt; 1;
 957         xf3 = fptr[3] &gt;&gt; 1;
 958 
 959         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 960 
 961         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 962         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 963 
 964         yf0 = fptr[0];
 965         yf1 = fptr[1];
 966         yf2 = fptr[2];
 967         yf3 = fptr[3];
 968 
 969         S32_TO_U16_SAT(dPtr[0]);
 970 
 971         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 972         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 973 
 974         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 975         s0 = srcPixelPtr[0];
 976         s1 = srcPixelPtr[3];
 977         s2 = srcPixelPtr[6];
 978         s3 = srcPixelPtr[9];
 979 
 980         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 981         s4 = srcPixelPtr[0];
 982         s5 = srcPixelPtr[3];
 983         s6 = srcPixelPtr[6];
 984         s7 = srcPixelPtr[9];
 985       }
 986 
 987       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 988       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 989       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 990       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 991             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 992       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 993       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 994             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 995 
 996       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 997       S32_TO_U16_SAT(dPtr[0]);
 998     }
 999   }
1000 
1001   return MLIB_SUCCESS;
1002 }
1003 
1004 /***************************************************************/
1005 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)
1006 {
1007   DECLAREVAR_BC();
1008   DTYPE *dstLineEnd;
1009   const mlib_s16 *mlib_filters_table;
1010 
1011   if (filter == MLIB_BICUBIC) {
1012     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
1013   }
1014   else {
1015     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
1016   }
1017 
1018   for (j = yStart; j &lt;= yFinish; j++) {
1019     mlib_s32 xf0, xf1, xf2, xf3;
1020     mlib_s32 yf0, yf1, yf2, yf3;
1021     mlib_s32 c0, c1, c2, c3, val0;
1022     mlib_s32 filterpos, k;
1023     mlib_s16 *fptr;
1024     mlib_s32 s0, s1, s2, s3;
1025     mlib_s32 s4, s5, s6, s7;
1026 
1027     CLIP(4);
1028     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
1029 
1030     for (k = 0; k &lt; 4; k++) {
1031       mlib_s32 X1 = X;
1032       mlib_s32 Y1 = Y;
1033       DTYPE *dPtr = dstPixelPtr + k;
1034 
1035       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1036       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1037 
1038       xf0 = fptr[0] &gt;&gt; 1;
1039       xf1 = fptr[1] &gt;&gt; 1;
1040       xf2 = fptr[2] &gt;&gt; 1;
1041       xf3 = fptr[3] &gt;&gt; 1;
1042 
1043       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1044       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1045 
1046       yf0 = fptr[0];
1047       yf1 = fptr[1];
1048       yf2 = fptr[2];
1049       yf3 = fptr[3];
1050 
1051       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1052       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1053 
1054       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1055       s0 = srcPixelPtr[0];
1056       s1 = srcPixelPtr[4];
1057       s2 = srcPixelPtr[8];
1058       s3 = srcPixelPtr[12];
1059 
1060       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1061       s4 = srcPixelPtr[0];
1062       s5 = srcPixelPtr[4];
1063       s6 = srcPixelPtr[8];
1064       s7 = srcPixelPtr[12];
1065 
1066       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {
1067 
1068         X1 += dX;
1069         Y1 += dY;
1070 
1071         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1072         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1073         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1074         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1075               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1076         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1077         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1078               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1079 
1080         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1081         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1082 
1083         xf0 = fptr[0] &gt;&gt; 1;
1084         xf1 = fptr[1] &gt;&gt; 1;
1085         xf2 = fptr[2] &gt;&gt; 1;
1086         xf3 = fptr[3] &gt;&gt; 1;
1087 
1088         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1089 
1090         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1091         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1092 
1093         yf0 = fptr[0];
1094         yf1 = fptr[1];
1095         yf2 = fptr[2];
1096         yf3 = fptr[3];
1097 
1098         S32_TO_U16_SAT(dPtr[0]);
1099 
1100         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1101         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1102 
1103         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1104         s0 = srcPixelPtr[0];
1105         s1 = srcPixelPtr[4];
1106         s2 = srcPixelPtr[8];
1107         s3 = srcPixelPtr[12];
1108 
1109         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1110         s4 = srcPixelPtr[0];
1111         s5 = srcPixelPtr[4];
1112         s6 = srcPixelPtr[8];
1113         s7 = srcPixelPtr[12];
1114       }
1115 
1116       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1117       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1118       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1119       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1120             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1121       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1122       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1123             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1124 
1125       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1126       S32_TO_U16_SAT(dPtr[0]);
1127     }
1128   }
1129 
1130   return MLIB_SUCCESS;
1131 }
1132 
<a name="3" id="anc3"></a><span class="line-removed">1133 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1134 </span>
1135 /***************************************************************/
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
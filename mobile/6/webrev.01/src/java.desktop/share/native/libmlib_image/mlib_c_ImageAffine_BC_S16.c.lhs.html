<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC_S16.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 /*
  28  * FUNCTION
  29  *      Image affine transformation with Bicubic filtering
  30  * SYNOPSIS
  31  *      mlib_status mlib_ImageAffine_[u8|s16|u16]_?ch_bc(mlib_s32 *leftEdges,
  32  *                                                       mlib_s32 *rightEdges,
  33  *                                                       mlib_s32 *xStarts,
  34  *                                                       mlib_s32 *yStarts,
  35  *                                                       mlib_s32 *sides,
  36  *                                                       mlib_u8  *dstData,
  37  *                                                       mlib_u8  **lineAddr,
  38  *                                                       mlib_s32 dstYStride,
  39  *                                                       mlib_s32 is_affine,
  40  *                                                       mlib_s32 srcYStride,
  41  *                                                       mlib_filter filter)
  42  *
  43  * ARGUMENTS
  44  *      leftEdges  array[dstHeight] of xLeft coordinates
  45  *      RightEdges array[dstHeight] of xRight coordinates
  46  *      xStarts    array[dstHeight] of xStart * 65536 coordinates
  47  *      yStarts    array[dstHeight] of yStart * 65536 coordinates
  48  *      sides      output array[4]. sides[0] is yStart, sides[1] is yFinish,
  49  *                 sides[2] is dx * 65536, sides[3] is dy * 65536
  50  *      dstData    pointer to the first pixel on (yStart - 1) line
  51  *      lineAddr   array[srcHeight] of pointers to the first pixel on
  52  *                 the corresponding lines
  53  *      dstYStride stride of destination image
  54  *      is_affine  indicator (Affine - GridWarp)
  55  *      srcYStride stride of source image
  56  *      filter     type of resampling filter
  57  *
  58  * DESCRIPTION
  59  *      The functions step along the lines from xLeft to xRight and apply
  60  *      the bicubic filtering.
  61  *
  62  */
  63 
  64 #include &quot;mlib_ImageAffine.h&quot;
  65 
  66 #define DTYPE           mlib_s16
  67 #define FILTER_BITS     9
  68 #define FUN_NAME(CHAN)  mlib_ImageAffine_s16_##CHAN##_bc
  69 
  70 /***************************************************************/
<a name="2" id="anc2"></a><span class="line-modified">  71 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  72 </span>
<span class="line-removed">  73 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  74 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  77 </span>
<span class="line-removed">  78 #define SAT16(DST)                                              \</span>
<span class="line-removed">  79   DST = ((mlib_s32)val0) &gt;&gt; 16</span>
<span class="line-removed">  80 </span>
<span class="line-removed">  81 #else</span>
<span class="line-removed">  82 </span>
<span class="line-removed">  83 #define SAT16(DST)                                              \</span>
<span class="line-removed">  84   if (val0 &gt;= MLIB_S32_MAX)                                     \</span>
<span class="line-removed">  85     DST = MLIB_S16_MAX;                                         \</span>
<span class="line-removed">  86   else if (val0 &lt;= MLIB_S32_MIN)                                \</span>
<span class="line-removed">  87     DST = MLIB_S16_MIN;                                         \</span>
<span class="line-removed">  88   else                                                          \</span>
<span class="line-removed">  89     DST = ((mlib_s32)val0) &gt;&gt; 16</span>
<span class="line-removed">  90 </span>
<span class="line-removed">  91 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  92 </span>
<span class="line-removed">  93 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  94 {</span>
<span class="line-removed">  95   DECLAREVAR_BC();</span>
<span class="line-removed">  96   DTYPE *dstLineEnd;</span>
<span class="line-removed">  97   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed">  98 </span>
<span class="line-removed">  99   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 100     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 101   }</span>
<span class="line-removed"> 102   else {</span>
<span class="line-removed"> 103     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 104   }</span>
<span class="line-removed"> 105 </span>
<span class="line-removed"> 106   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 107     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 108     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 109     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 110     mlib_s32 filterpos;</span>
<span class="line-removed"> 111     mlib_f32 *fptr;</span>
<span class="line-removed"> 112     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 113     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 114 </span>
<span class="line-removed"> 115     CLIP(1);</span>
<span class="line-removed"> 116     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 117 </span>
<span class="line-removed"> 118     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 119     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 120 </span>
<span class="line-removed"> 121     xf0 = fptr[0];</span>
<span class="line-removed"> 122     xf1 = fptr[1];</span>
<span class="line-removed"> 123     xf2 = fptr[2];</span>
<span class="line-removed"> 124     xf3 = fptr[3];</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 127     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 128 </span>
<span class="line-removed"> 129     yf0 = fptr[0];</span>
<span class="line-removed"> 130     yf1 = fptr[1];</span>
<span class="line-removed"> 131     yf2 = fptr[2];</span>
<span class="line-removed"> 132     yf3 = fptr[3];</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 135     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 136 </span>
<span class="line-removed"> 137     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 138     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 139     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 140     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 141     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 142 </span>
<span class="line-removed"> 143     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 144     s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 145     s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 146     s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 147     s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 148 </span>
<span class="line-removed"> 149     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 150 </span>
<span class="line-removed"> 151       X += dX;</span>
<span class="line-removed"> 152       Y += dY;</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 155       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 156       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 157       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 158             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 159       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 160       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 161             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 162 </span>
<span class="line-removed"> 163       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 164       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166       xf0 = fptr[0];</span>
<span class="line-removed"> 167       xf1 = fptr[1];</span>
<span class="line-removed"> 168       xf2 = fptr[2];</span>
<span class="line-removed"> 169       xf3 = fptr[3];</span>
<span class="line-removed"> 170 </span>
<span class="line-removed"> 171       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 172 </span>
<span class="line-removed"> 173       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 174       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 175 </span>
<span class="line-removed"> 176       yf0 = fptr[0];</span>
<span class="line-removed"> 177       yf1 = fptr[1];</span>
<span class="line-removed"> 178       yf2 = fptr[2];</span>
<span class="line-removed"> 179       yf3 = fptr[3];</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181       SAT16(dstPixelPtr[0]);</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 184       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 185 </span>
<span class="line-removed"> 186       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 187       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 188       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 189       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 190       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 191 </span>
<span class="line-removed"> 192       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 193       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 194       s5 = srcPixelPtr[1];</span>
<span class="line-removed"> 195       s6 = srcPixelPtr[2];</span>
<span class="line-removed"> 196       s7 = srcPixelPtr[3];</span>
<span class="line-removed"> 197     }</span>
<span class="line-removed"> 198 </span>
<span class="line-removed"> 199     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 200     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 201     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 202     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 203           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 204     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 205     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +</span>
<span class="line-removed"> 206           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3);</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 209     SAT16(dstPixelPtr[0]);</span>
<span class="line-removed"> 210   }</span>
<span class="line-removed"> 211 </span>
<span class="line-removed"> 212   return MLIB_SUCCESS;</span>
<span class="line-removed"> 213 }</span>
<span class="line-removed"> 214 </span>
<span class="line-removed"> 215 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 216 {</span>
<span class="line-removed"> 217   DECLAREVAR_BC();</span>
<span class="line-removed"> 218   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 219   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 220 </span>
<span class="line-removed"> 221   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 222     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 223   }</span>
<span class="line-removed"> 224   else {</span>
<span class="line-removed"> 225     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 226   }</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 229     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 230     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 231     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 232     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 233     mlib_f32 *fptr;</span>
<span class="line-removed"> 234     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 235     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237     CLIP(2);</span>
<span class="line-removed"> 238     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 241       mlib_s32 X1 = X;</span>
<span class="line-removed"> 242       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 243       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 244 </span>
<span class="line-removed"> 245       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 246       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248       xf0 = fptr[0];</span>
<span class="line-removed"> 249       xf1 = fptr[1];</span>
<span class="line-removed"> 250       xf2 = fptr[2];</span>
<span class="line-removed"> 251       xf3 = fptr[3];</span>
<span class="line-removed"> 252 </span>
<span class="line-removed"> 253       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 254       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256       yf0 = fptr[0];</span>
<span class="line-removed"> 257       yf1 = fptr[1];</span>
<span class="line-removed"> 258       yf2 = fptr[2];</span>
<span class="line-removed"> 259       yf3 = fptr[3];</span>
<span class="line-removed"> 260 </span>
<span class="line-removed"> 261       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 262       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 263 </span>
<span class="line-removed"> 264       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 265       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 266       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 267       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 268       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 269 </span>
<span class="line-removed"> 270       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 271       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 272       s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 273       s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 274       s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 277 </span>
<span class="line-removed"> 278         X1 += dX;</span>
<span class="line-removed"> 279         Y1 += dY;</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 282         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 283         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 284         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 285               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 286         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 287         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 288               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 291         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293         xf0 = fptr[0];</span>
<span class="line-removed"> 294         xf1 = fptr[1];</span>
<span class="line-removed"> 295         xf2 = fptr[2];</span>
<span class="line-removed"> 296         xf3 = fptr[3];</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 301         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 302 </span>
<span class="line-removed"> 303         yf0 = fptr[0];</span>
<span class="line-removed"> 304         yf1 = fptr[1];</span>
<span class="line-removed"> 305         yf2 = fptr[2];</span>
<span class="line-removed"> 306         yf3 = fptr[3];</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308         SAT16(dPtr[0]);</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 311         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 314         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 315         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 316         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 317         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 318 </span>
<span class="line-removed"> 319         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 320         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 321         s5 = srcPixelPtr[2];</span>
<span class="line-removed"> 322         s6 = srcPixelPtr[4];</span>
<span class="line-removed"> 323         s7 = srcPixelPtr[6];</span>
<span class="line-removed"> 324       }</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 327       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 328       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 329       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 330             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 331       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 332       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +</span>
<span class="line-removed"> 333             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3);</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 336       SAT16(dPtr[0]);</span>
<span class="line-removed"> 337     }</span>
<span class="line-removed"> 338   }</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340   return MLIB_SUCCESS;</span>
<span class="line-removed"> 341 }</span>
<span class="line-removed"> 342 </span>
<span class="line-removed"> 343 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 344 {</span>
<span class="line-removed"> 345   DECLAREVAR_BC();</span>
<span class="line-removed"> 346   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 347   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 350     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 351   }</span>
<span class="line-removed"> 352   else {</span>
<span class="line-removed"> 353     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 354   }</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 357     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 358     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 359     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 360     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 361     mlib_f32 *fptr;</span>
<span class="line-removed"> 362     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 363     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365     CLIP(3);</span>
<span class="line-removed"> 366     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 367 </span>
<span class="line-removed"> 368     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 369       mlib_s32 X1 = X;</span>
<span class="line-removed"> 370       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 371       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 372 </span>
<span class="line-removed"> 373       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 374       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 375 </span>
<span class="line-removed"> 376       xf0 = fptr[0];</span>
<span class="line-removed"> 377       xf1 = fptr[1];</span>
<span class="line-removed"> 378       xf2 = fptr[2];</span>
<span class="line-removed"> 379       xf3 = fptr[3];</span>
<span class="line-removed"> 380 </span>
<span class="line-removed"> 381       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 382       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 383 </span>
<span class="line-removed"> 384       yf0 = fptr[0];</span>
<span class="line-removed"> 385       yf1 = fptr[1];</span>
<span class="line-removed"> 386       yf2 = fptr[2];</span>
<span class="line-removed"> 387       yf3 = fptr[3];</span>
<span class="line-removed"> 388 </span>
<span class="line-removed"> 389       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 390       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 393       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 394       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 395       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 396       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 397 </span>
<span class="line-removed"> 398       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 399       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 400       s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 401       s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 402       s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406         X1 += dX;</span>
<span class="line-removed"> 407         Y1 += dY;</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 410         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 411         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 412         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 413               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 414         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 415         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 416               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 419         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 420 </span>
<span class="line-removed"> 421         xf0 = fptr[0];</span>
<span class="line-removed"> 422         xf1 = fptr[1];</span>
<span class="line-removed"> 423         xf2 = fptr[2];</span>
<span class="line-removed"> 424         xf3 = fptr[3];</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 429         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         yf0 = fptr[0];</span>
<span class="line-removed"> 432         yf1 = fptr[1];</span>
<span class="line-removed"> 433         yf2 = fptr[2];</span>
<span class="line-removed"> 434         yf3 = fptr[3];</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436         SAT16(dPtr[0]);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 439         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 442         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 443         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 444         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 445         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 446 </span>
<span class="line-removed"> 447         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 448         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 449         s5 = srcPixelPtr[3];</span>
<span class="line-removed"> 450         s6 = srcPixelPtr[6];</span>
<span class="line-removed"> 451         s7 = srcPixelPtr[9];</span>
<span class="line-removed"> 452       }</span>
<span class="line-removed"> 453 </span>
<span class="line-removed"> 454       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 455       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 456       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 457       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 458             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 459       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 460       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +</span>
<span class="line-removed"> 461             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3);</span>
<span class="line-removed"> 462 </span>
<span class="line-removed"> 463       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 464       SAT16(dPtr[0]);</span>
<span class="line-removed"> 465     }</span>
<span class="line-removed"> 466   }</span>
<span class="line-removed"> 467 </span>
<span class="line-removed"> 468   return MLIB_SUCCESS;</span>
<span class="line-removed"> 469 }</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 472 {</span>
<span class="line-removed"> 473   DECLAREVAR_BC();</span>
<span class="line-removed"> 474   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 475   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 478     mlib_filters_table = mlib_filters_s16f_bc;</span>
<span class="line-removed"> 479   }</span>
<span class="line-removed"> 480   else {</span>
<span class="line-removed"> 481     mlib_filters_table = mlib_filters_s16f_bc2;</span>
<span class="line-removed"> 482   }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 485     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 486     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 487     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 488     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 489     mlib_f32 *fptr;</span>
<span class="line-removed"> 490     mlib_s32 s0, s1, s2, s3;</span>
<span class="line-removed"> 491     mlib_s32 s4, s5, s6, s7;</span>
<span class="line-removed"> 492 </span>
<span class="line-removed"> 493     CLIP(4);</span>
<span class="line-removed"> 494     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 497       mlib_s32 X1 = X;</span>
<span class="line-removed"> 498       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 499       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 502       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 503 </span>
<span class="line-removed"> 504       xf0 = fptr[0];</span>
<span class="line-removed"> 505       xf1 = fptr[1];</span>
<span class="line-removed"> 506       xf2 = fptr[2];</span>
<span class="line-removed"> 507       xf3 = fptr[3];</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 510       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512       yf0 = fptr[0];</span>
<span class="line-removed"> 513       yf1 = fptr[1];</span>
<span class="line-removed"> 514       yf2 = fptr[2];</span>
<span class="line-removed"> 515       yf3 = fptr[3];</span>
<span class="line-removed"> 516 </span>
<span class="line-removed"> 517       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 518       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 521       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 522       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 523       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 524       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 525 </span>
<span class="line-removed"> 526       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 527       s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 528       s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 529       s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 530       s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 533 </span>
<span class="line-removed"> 534         X1 += dX;</span>
<span class="line-removed"> 535         Y1 += dY;</span>
<span class="line-removed"> 536 </span>
<span class="line-removed"> 537         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 538         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 539         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 540         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 541               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 542         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 543         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 544               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 545 </span>
<span class="line-removed"> 546         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 547         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549         xf0 = fptr[0];</span>
<span class="line-removed"> 550         xf1 = fptr[1];</span>
<span class="line-removed"> 551         xf2 = fptr[2];</span>
<span class="line-removed"> 552         xf3 = fptr[3];</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 557         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559         yf0 = fptr[0];</span>
<span class="line-removed"> 560         yf1 = fptr[1];</span>
<span class="line-removed"> 561         yf2 = fptr[2];</span>
<span class="line-removed"> 562         yf3 = fptr[3];</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         SAT16(dPtr[0]);</span>
<span class="line-removed"> 565 </span>
<span class="line-removed"> 566         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 567         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 568 </span>
<span class="line-removed"> 569         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 570         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 571         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 572         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 573         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 574 </span>
<span class="line-removed"> 575         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 576         s4 = srcPixelPtr[0];</span>
<span class="line-removed"> 577         s5 = srcPixelPtr[4];</span>
<span class="line-removed"> 578         s6 = srcPixelPtr[8];</span>
<span class="line-removed"> 579         s7 = srcPixelPtr[12];</span>
<span class="line-removed"> 580       }</span>
<span class="line-removed"> 581 </span>
<span class="line-removed"> 582       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3);</span>
<span class="line-removed"> 583       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3);</span>
<span class="line-removed"> 584       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 585       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 586             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 587       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 588       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +</span>
<span class="line-removed"> 589             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3);</span>
<span class="line-removed"> 590 </span>
<span class="line-removed"> 591       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 592       SAT16(dPtr[0]);</span>
<span class="line-removed"> 593     }</span>
<span class="line-removed"> 594   }</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   return MLIB_SUCCESS;</span>
<span class="line-removed"> 597 }</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599 #else       /* for x86, using integer multiplies is faster */</span>
 600 
 601 #define SHIFT_X  15
 602 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 603 
 604 #define SHIFT_Y  (15 + 15 - SHIFT_X)
 605 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 606 
 607 #define S32_TO_S16_SAT(DST)                                     \
 608   if (val0 &gt;= MLIB_S16_MAX)                                     \
 609     DST = MLIB_S16_MAX;                                         \
 610   else if (val0 &lt;= MLIB_S16_MIN)                                \
 611     DST = MLIB_S16_MIN;                                         \
 612   else                                                          \
 613     DST = (mlib_s16)val0
 614 
 615 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
 616 {
 617   DECLAREVAR_BC();
 618   DTYPE *dstLineEnd;
 619   const mlib_s16 *mlib_filters_table;
 620 
 621   if (filter == MLIB_BICUBIC) {
 622     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 623   }
 624   else {
 625     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 626   }
 627 
 628   for (j = yStart; j &lt;= yFinish; j++) {
 629     mlib_s32 xf0, xf1, xf2, xf3;
 630     mlib_s32 yf0, yf1, yf2, yf3;
 631     mlib_s32 c0, c1, c2, c3, val0;
 632     mlib_s32 filterpos;
 633     mlib_s16 *fptr;
 634     mlib_s32 s0, s1, s2, s3;
 635     mlib_s32 s4, s5, s6, s7;
 636 
 637     CLIP(1);
 638     dstLineEnd = (DTYPE *) dstData + xRight;
 639 
 640     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 641     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 642 
 643     xf0 = fptr[0];
 644     xf1 = fptr[1];
 645     xf2 = fptr[2];
 646     xf3 = fptr[3];
 647 
 648     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 649     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 650 
 651     yf0 = fptr[0];
 652     yf1 = fptr[1];
 653     yf2 = fptr[2];
 654     yf3 = fptr[3];
 655 
 656     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 657     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 658 
 659     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 660     s0 = srcPixelPtr[0];
 661     s1 = srcPixelPtr[1];
 662     s2 = srcPixelPtr[2];
 663     s3 = srcPixelPtr[3];
 664 
 665     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 666     s4 = srcPixelPtr[0];
 667     s5 = srcPixelPtr[1];
 668     s6 = srcPixelPtr[2];
 669     s7 = srcPixelPtr[3];
 670 
 671     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {
 672 
 673       X += dX;
 674       Y += dY;
 675 
 676       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 677       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 678       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 679       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 680             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 681       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 682       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 683             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 684 
 685       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 686       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 687 
 688       xf0 = fptr[0];
 689       xf1 = fptr[1];
 690       xf2 = fptr[2];
 691       xf3 = fptr[3];
 692 
 693       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 694 
 695       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 696       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 697 
 698       yf0 = fptr[0];
 699       yf1 = fptr[1];
 700       yf2 = fptr[2];
 701       yf3 = fptr[3];
 702 
 703       S32_TO_S16_SAT(dstPixelPtr[0]);
 704 
 705       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 706       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 707 
 708       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 709       s0 = srcPixelPtr[0];
 710       s1 = srcPixelPtr[1];
 711       s2 = srcPixelPtr[2];
 712       s3 = srcPixelPtr[3];
 713 
 714       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 715       s4 = srcPixelPtr[0];
 716       s5 = srcPixelPtr[1];
 717       s6 = srcPixelPtr[2];
 718       s7 = srcPixelPtr[3];
 719     }
 720 
 721     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 722     c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 723     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 724     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 725           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 726     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 727     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 728           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 729 
 730     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 731     S32_TO_S16_SAT(dstPixelPtr[0]);
 732   }
 733 
 734   return MLIB_SUCCESS;
 735 }
 736 
 737 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
 738 {
 739   DECLAREVAR_BC();
 740   DTYPE *dstLineEnd;
 741   const mlib_s16 *mlib_filters_table;
 742 
 743   if (filter == MLIB_BICUBIC) {
 744     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 745   }
 746   else {
 747     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 748   }
 749 
 750   for (j = yStart; j &lt;= yFinish; j++) {
 751     mlib_s32 xf0, xf1, xf2, xf3;
 752     mlib_s32 yf0, yf1, yf2, yf3;
 753     mlib_s32 c0, c1, c2, c3, val0;
 754     mlib_s32 filterpos, k;
 755     mlib_s16 *fptr;
 756     mlib_s32 s0, s1, s2, s3;
 757     mlib_s32 s4, s5, s6, s7;
 758 
 759     CLIP(2);
 760     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
 761 
 762     for (k = 0; k &lt; 2; k++) {
 763       mlib_s32 X1 = X;
 764       mlib_s32 Y1 = Y;
 765       DTYPE *dPtr = dstPixelPtr + k;
 766 
 767       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 768       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 769 
 770       xf0 = fptr[0];
 771       xf1 = fptr[1];
 772       xf2 = fptr[2];
 773       xf3 = fptr[3];
 774 
 775       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 776       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 777 
 778       yf0 = fptr[0];
 779       yf1 = fptr[1];
 780       yf2 = fptr[2];
 781       yf3 = fptr[3];
 782 
 783       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 784       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 785 
 786       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 787       s0 = srcPixelPtr[0];
 788       s1 = srcPixelPtr[2];
 789       s2 = srcPixelPtr[4];
 790       s3 = srcPixelPtr[6];
 791 
 792       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 793       s4 = srcPixelPtr[0];
 794       s5 = srcPixelPtr[2];
 795       s6 = srcPixelPtr[4];
 796       s7 = srcPixelPtr[6];
 797 
 798       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {
 799 
 800         X1 += dX;
 801         Y1 += dY;
 802 
 803         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 804         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 805         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 806         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 807               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 808         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 809         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 810               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 811 
 812         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 813         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 814 
 815         xf0 = fptr[0];
 816         xf1 = fptr[1];
 817         xf2 = fptr[2];
 818         xf3 = fptr[3];
 819 
 820         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 821 
 822         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 823         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 824 
 825         yf0 = fptr[0];
 826         yf1 = fptr[1];
 827         yf2 = fptr[2];
 828         yf3 = fptr[3];
 829 
 830         S32_TO_S16_SAT(dPtr[0]);
 831 
 832         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 833         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 834 
 835         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 836         s0 = srcPixelPtr[0];
 837         s1 = srcPixelPtr[2];
 838         s2 = srcPixelPtr[4];
 839         s3 = srcPixelPtr[6];
 840 
 841         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 842         s4 = srcPixelPtr[0];
 843         s5 = srcPixelPtr[2];
 844         s6 = srcPixelPtr[4];
 845         s7 = srcPixelPtr[6];
 846       }
 847 
 848       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 849       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 850       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 851       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 852             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 853       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 854       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 855             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 856 
 857       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 858       S32_TO_S16_SAT(dPtr[0]);
 859     }
 860   }
 861 
 862   return MLIB_SUCCESS;
 863 }
 864 
 865 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)
 866 {
 867   DECLAREVAR_BC();
 868   DTYPE *dstLineEnd;
 869   const mlib_s16 *mlib_filters_table;
 870 
 871   if (filter == MLIB_BICUBIC) {
 872     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
 873   }
 874   else {
 875     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
 876   }
 877 
 878   for (j = yStart; j &lt;= yFinish; j++) {
 879     mlib_s32 xf0, xf1, xf2, xf3;
 880     mlib_s32 yf0, yf1, yf2, yf3;
 881     mlib_s32 c0, c1, c2, c3, val0;
 882     mlib_s32 filterpos, k;
 883     mlib_s16 *fptr;
 884     mlib_s32 s0, s1, s2, s3;
 885     mlib_s32 s4, s5, s6, s7;
 886 
 887     CLIP(3);
 888     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
 889 
 890     for (k = 0; k &lt; 3; k++) {
 891       mlib_s32 X1 = X;
 892       mlib_s32 Y1 = Y;
 893       DTYPE *dPtr = dstPixelPtr + k;
 894 
 895       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 896       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 897 
 898       xf0 = fptr[0];
 899       xf1 = fptr[1];
 900       xf2 = fptr[2];
 901       xf3 = fptr[3];
 902 
 903       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 904       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 905 
 906       yf0 = fptr[0];
 907       yf1 = fptr[1];
 908       yf2 = fptr[2];
 909       yf3 = fptr[3];
 910 
 911       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 912       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 913 
 914       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 915       s0 = srcPixelPtr[0];
 916       s1 = srcPixelPtr[3];
 917       s2 = srcPixelPtr[6];
 918       s3 = srcPixelPtr[9];
 919 
 920       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 921       s4 = srcPixelPtr[0];
 922       s5 = srcPixelPtr[3];
 923       s6 = srcPixelPtr[6];
 924       s7 = srcPixelPtr[9];
 925 
 926       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {
 927 
 928         X1 += dX;
 929         Y1 += dY;
 930 
 931         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 932         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 933         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 934         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 935               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 936         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 937         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 938               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 939 
 940         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 941         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 942 
 943         xf0 = fptr[0];
 944         xf1 = fptr[1];
 945         xf2 = fptr[2];
 946         xf3 = fptr[3];
 947 
 948         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 949 
 950         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 951         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 952 
 953         yf0 = fptr[0];
 954         yf1 = fptr[1];
 955         yf2 = fptr[2];
 956         yf3 = fptr[3];
 957 
 958         S32_TO_S16_SAT(dPtr[0]);
 959 
 960         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 961         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 962 
 963         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 964         s0 = srcPixelPtr[0];
 965         s1 = srcPixelPtr[3];
 966         s2 = srcPixelPtr[6];
 967         s3 = srcPixelPtr[9];
 968 
 969         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 970         s4 = srcPixelPtr[0];
 971         s5 = srcPixelPtr[3];
 972         s6 = srcPixelPtr[6];
 973         s7 = srcPixelPtr[9];
 974       }
 975 
 976       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 977       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 978       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 979       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 980             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 981       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 982       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 983             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 984 
 985       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 986       S32_TO_S16_SAT(dPtr[0]);
 987     }
 988   }
 989 
 990   return MLIB_SUCCESS;
 991 }
 992 
 993 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)
 994 {
 995   DECLAREVAR_BC();
 996   DTYPE *dstLineEnd;
 997   const mlib_s16 *mlib_filters_table;
 998 
 999   if (filter == MLIB_BICUBIC) {
1000     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc;
1001   }
1002   else {
1003     mlib_filters_table = (mlib_s16 *) mlib_filters_s16_bc2;
1004   }
1005 
1006   for (j = yStart; j &lt;= yFinish; j++) {
1007     mlib_s32 xf0, xf1, xf2, xf3;
1008     mlib_s32 yf0, yf1, yf2, yf3;
1009     mlib_s32 c0, c1, c2, c3, val0;
1010     mlib_s32 filterpos, k;
1011     mlib_s16 *fptr;
1012     mlib_s32 s0, s1, s2, s3;
1013     mlib_s32 s4, s5, s6, s7;
1014 
1015     CLIP(4);
1016     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
1017 
1018     for (k = 0; k &lt; 4; k++) {
1019       mlib_s32 X1 = X;
1020       mlib_s32 Y1 = Y;
1021       DTYPE *dPtr = dstPixelPtr + k;
1022 
1023       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1024       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1025 
1026       xf0 = fptr[0];
1027       xf1 = fptr[1];
1028       xf2 = fptr[2];
1029       xf3 = fptr[3];
1030 
1031       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1032       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1033 
1034       yf0 = fptr[0];
1035       yf1 = fptr[1];
1036       yf2 = fptr[2];
1037       yf3 = fptr[3];
1038 
1039       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1040       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1041 
1042       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1043       s0 = srcPixelPtr[0];
1044       s1 = srcPixelPtr[4];
1045       s2 = srcPixelPtr[8];
1046       s3 = srcPixelPtr[12];
1047 
1048       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1049       s4 = srcPixelPtr[0];
1050       s5 = srcPixelPtr[4];
1051       s6 = srcPixelPtr[8];
1052       s7 = srcPixelPtr[12];
1053 
1054       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {
1055 
1056         X1 += dX;
1057         Y1 += dY;
1058 
1059         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1060         c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1061         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1062         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1063               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1064         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1065         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1066               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1067 
1068         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1069         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1070 
1071         xf0 = fptr[0];
1072         xf1 = fptr[1];
1073         xf2 = fptr[2];
1074         xf3 = fptr[3];
1075 
1076         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1077 
1078         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1079         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1080 
1081         yf0 = fptr[0];
1082         yf1 = fptr[1];
1083         yf2 = fptr[2];
1084         yf3 = fptr[3];
1085 
1086         S32_TO_S16_SAT(dPtr[0]);
1087 
1088         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1089         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1090 
1091         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1092         s0 = srcPixelPtr[0];
1093         s1 = srcPixelPtr[4];
1094         s2 = srcPixelPtr[8];
1095         s3 = srcPixelPtr[12];
1096 
1097         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1098         s4 = srcPixelPtr[0];
1099         s5 = srcPixelPtr[4];
1100         s6 = srcPixelPtr[8];
1101         s7 = srcPixelPtr[12];
1102       }
1103 
1104       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1105       c1 = (s4 * xf0 + s5 * xf1 + s6 * xf2 + s7 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1106       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1107       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1108             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1109       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1110       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1111             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1112 
1113       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1114       S32_TO_S16_SAT(dPtr[0]);
1115     }
1116   }
1117 
1118   return MLIB_SUCCESS;
1119 }
1120 
<a name="3" id="anc3"></a><span class="line-removed">1121 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1122 </span>
1123 /***************************************************************/
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
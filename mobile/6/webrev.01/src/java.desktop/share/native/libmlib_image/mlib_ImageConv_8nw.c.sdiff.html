<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libmlib_image/mlib_ImageConv_8nw.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="mlib_ImageConv_8ext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_D64nw.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libmlib_image/mlib_ImageConv_8nw.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147 /***************************************************************/
 148 #define DEF_VARS(type)                                          \
 149   type     *adr_src, *sl, *sp = NULL;                           \
 150   type     *adr_dst, *dl, *dp = NULL;                           \
 151   FTYPE    *pbuff = buff;                                       \
 152   mlib_s32 wid, hgt, sll, dll;                                  \
 153   mlib_s32 nchannel, chan1;                                     \
 154   mlib_s32 i, j, c
 155 
 156 /***************************************************************/
 157 #define GET_SRC_DST_PARAMETERS(type)                            \
 158   hgt = mlib_ImageGetHeight(src);                               \
 159   wid = mlib_ImageGetWidth(src);                                \
 160   nchannel = mlib_ImageGetChannels(src);                        \
 161   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 162   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 163   adr_src = (type *)mlib_ImageGetData(src);                     \
 164   adr_dst = (type *)mlib_ImageGetData(dst)
 165 
 166 /***************************************************************/
<span class="line-removed"> 167 #ifndef __sparc</span>
<span class="line-removed"> 168 </span>
 169 #if IMG_TYPE == 1
 170 
 171 /* Test for the presence of any &quot;1&quot; bit in bits
 172    8 to 31 of val. If present, then val is either
 173    negative or &gt;255. If over/underflows of 8 bits
 174    are uncommon, then this technique can be a win,
 175    since only a single test, rather than two, is
 176    necessary to determine if clamping is needed.
 177    On the other hand, if over/underflows are common,
 178    it adds an extra test.
 179 */
 180 #define CLAMP_STORE(dst, val)                                   \
 181   if (val &amp; 0xffffff00) {                                       \
 182     if (val &lt; MLIB_U8_MIN)                                      \
 183       dst = MLIB_U8_MIN;                                        \
 184     else                                                        \
 185       dst = MLIB_U8_MAX;                                        \
 186   } else {                                                      \
 187     dst = (mlib_u8)val;                                         \
 188   }
</pre>
<hr />
<pre>
 191 
 192 #define CLAMP_STORE(dst, val)                                   \
 193   if (val &gt;= MLIB_S16_MAX)                                      \
 194     dst = MLIB_S16_MAX;                                         \
 195   else if (val &lt;= MLIB_S16_MIN)                                 \
 196     dst = MLIB_S16_MIN;                                         \
 197   else                                                          \
 198     dst = (mlib_s16)val
 199 
 200 #elif IMG_TYPE == 3
 201 
 202 #define CLAMP_STORE(dst, val)                                   \
 203   if (val &gt;= MLIB_U16_MAX)                                      \
 204     dst = MLIB_U16_MAX;                                         \
 205   else if (val &lt;= MLIB_U16_MIN)                                 \
 206     dst = MLIB_U16_MIN;                                         \
 207   else                                                          \
 208     dst = (mlib_u16)val
 209 
 210 #endif /* IMG_TYPE == 1 */
<span class="line-removed"> 211 #endif /* __sparc */</span>
 212 
 213 /***************************************************************/
 214 #define MAX_KER   7
 215 #define MAX_N    15
 216 
 217 static mlib_status mlib_ImageConv1xN(mlib_image       *dst,
 218                                      const mlib_image *src,
 219                                      const mlib_d64   *k,
 220                                      mlib_s32         n,
 221                                      mlib_s32         dn,
 222                                      mlib_s32         cmask)
 223 {
 224   FTYPE    buff[BUFF_SIZE];
 225   mlib_s32 off, kh;
 226   mlib_s32 d0, d1;
 227   const FTYPE    *pk;
 228   FTYPE    k0, k1, k2, k3;
 229   FTYPE    p0, p1, p2, p3, p4;
 230   DEF_VARS(DTYPE);
 231   DTYPE    *sl_c, *dl_c, *sl0;
</pre>
<hr />
<pre>
 242   if (max_hsize &gt; BUFF_SIZE) {
 243     pbuff = mlib_malloc(sizeof(FTYPE)*max_hsize);
 244   }
 245 
 246   chan1 = nchannel;
 247 
 248   sl_c = adr_src;
 249   dl_c = adr_dst;
 250 
 251   for (l = 0; l &lt; hgt; l += hsize) {
 252     hsize = hgt - l;
 253 
 254     if (hsize &gt; max_hsize) hsize = max_hsize;
 255 
 256     for (c = 0; c &lt; nchannel; c++) {
 257       if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 258 
 259       sl = sl_c + c;
 260       dl = dl_c + c;
 261 
<span class="line-removed"> 262 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 263 #pragma pipeloop(0)</span>
<span class="line-removed"> 264 #endif /* __SUNPRO_C */</span>
 265       for (j = 0; j &lt; hsize; j++) pbuff[j] = 0.0;
 266 
 267       for (i = 0; i &lt; wid; i++) {
 268         sl0 = sl;
 269 
 270         for (off = 0; off &lt; (n - 4); off += 4) {
 271           pk = k + off;
 272           sp = sl0;
 273 
 274           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 275           p2 = sp[0]; p3 = sp[sll]; p4 = sp[2*sll];
 276           sp += 3*sll;
 277 
<span class="line-removed"> 278 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 279 #pragma pipeloop(0)</span>
<span class="line-removed"> 280 #endif /* __SUNPRO_C */</span>
 281           for (j = 0; j &lt; hsize; j += 2) {
 282             p0 = p2; p1 = p3; p2 = p4;
 283             p3 = sp[0];
 284             p4 = sp[sll];
 285 
 286             pbuff[j    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 287             pbuff[j + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 288 
 289             sp += 2*sll;
 290           }
 291 
 292           sl0 += 4*sll;
 293         }
 294 
 295         pk = k + off;
 296         sp = sl0;
 297 
 298         k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 299         p2 = sp[0]; p3 = sp[sll]; p4 = sp[2*sll];
 300 
 301         dp = dl;
 302         kh = n - off;
 303 
 304         if (kh == 4) {
 305           sp += 3*sll;
 306 
<span class="line-removed"> 307 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 308 #pragma pipeloop(0)</span>
<span class="line-removed"> 309 #endif /* __SUNPRO_C */</span>
 310           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 311             p0 = p2; p1 = p3; p2 = p4;
 312             p3 = sp[0];
 313             p4 = sp[sll];
 314 
 315             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + pbuff[j]);
 316             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + pbuff[j + 1]);
 317 
 318             dp[0  ] = FROM_S32(d0);
 319             dp[dll] = FROM_S32(d1);
 320 
 321             pbuff[j] = 0;
 322             pbuff[j + 1] = 0;
 323 
 324             sp += 2*sll;
 325             dp += 2*dll;
 326           }
 327 
 328           if (j &lt; hsize) {
 329             p0 = p2; p1 = p3; p2 = p4;
 330             p3 = sp[0];
 331 
 332             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + pbuff[j]);
 333 
 334             pbuff[j] = 0;
 335 
 336             dp[0] = FROM_S32(d0);
 337           }
 338 
 339         } else if (kh == 3) {
 340           sp += 2*sll;
 341 
<span class="line-removed"> 342 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 343 #pragma pipeloop(0)</span>
<span class="line-removed"> 344 #endif /* __SUNPRO_C */</span>
 345           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 346             p0 = p2; p1 = p3;
 347             p2 = sp[0];
 348             p3 = sp[sll];
 349 
 350             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + pbuff[j]);
 351             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + pbuff[j + 1]);
 352 
 353             dp[0  ] = FROM_S32(d0);
 354             dp[dll] = FROM_S32(d1);
 355 
 356             pbuff[j] = 0;
 357             pbuff[j + 1] = 0;
 358 
 359             sp += 2*sll;
 360             dp += 2*dll;
 361           }
 362 
 363           if (j &lt; hsize) {
 364             p0 = p2; p1 = p3;
 365             p2 = sp[0];
 366 
 367             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + pbuff[j]);
 368 
 369             pbuff[j] = 0;
 370 
 371             dp[0] = FROM_S32(d0);
 372           }
 373 
 374         } else if (kh == 2) {
 375           sp += sll;
 376 
<span class="line-removed"> 377 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 378 #pragma pipeloop(0)</span>
<span class="line-removed"> 379 #endif /* __SUNPRO_C */</span>
 380           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 381             p0 = p2;
 382             p1 = sp[0];
 383             p2 = sp[sll];
 384 
 385             d0 = D2I(p0*k0 + p1*k1 + pbuff[j]);
 386             d1 = D2I(p1*k0 + p2*k1 + pbuff[j + 1]);
 387 
 388             dp[0  ] = FROM_S32(d0);
 389             dp[dll] = FROM_S32(d1);
 390 
 391             pbuff[j] = 0;
 392             pbuff[j + 1] = 0;
 393 
 394             sp += 2*sll;
 395             dp += 2*dll;
 396           }
 397 
 398           if (j &lt; hsize) {
 399             p0 = p2;
 400             p1 = sp[0];
 401 
 402             d0 = D2I(p0*k0 + p1*k1 + pbuff[j]);
 403 
 404             pbuff[j] = 0;
 405 
 406             dp[0] = FROM_S32(d0);
 407           }
 408 
 409         } else /* if (kh == 1) */ {
<span class="line-removed"> 410 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 411 #pragma pipeloop(0)</span>
<span class="line-removed"> 412 #endif /* __SUNPRO_C */</span>
 413           for (j = 0; j &lt; hsize; j++) {
 414             p0 = sp[0];
 415 
 416             d0 = D2I(p0*k0 + pbuff[j]);
 417 
 418             dp[0] = FROM_S32(d0);
 419 
 420             pbuff[j] = 0;
 421 
 422             sp += sll;
 423             dp += dll;
 424           }
 425         }
 426 
 427         sl += chan1;
 428         dl += chan1;
 429       }
 430     }
 431 
 432     sl_c += max_hsize*sll;
</pre>
<hr />
<pre>
 505   buffd = buffs[n] + wid;
 506   buffo = (mlib_s32*)(buffd + wid);
 507   buffi = buffo + (wid &amp;~ 1);
 508 
 509   chan1 = nchannel;
 510   chan2 = chan1 + chan1;
 511 
 512   wid -= (m - 1);
 513   hgt -= (n - 1);
 514   adr_dst += dn*dll + dm*nchannel;
 515 
 516   for (c = 0; c &lt; nchannel; c++) {
 517     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 518 
 519     sl = adr_src + c;
 520     dl = adr_dst + c;
 521 
 522     for (l = 0; l &lt; n; l++) {
 523       FTYPE    *buff = buffs[l];
 524 
<span class="line-removed"> 525 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 526 #pragma pipeloop(0)</span>
<span class="line-removed"> 527 #endif /* __SUNPRO_C */</span>
 528       for (i = 0; i &lt; wid + (m - 1); i++) {
 529         buff[i] = (FTYPE)sl[i*chan1];
 530       }
 531 
 532       sl += sll;
 533     }
 534 
 535     buff_ind = 0;
 536 
<span class="line-removed"> 537 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 538 #pragma pipeloop(0)</span>
<span class="line-removed"> 539 #endif /* __SUNPRO_C */</span>
 540     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 541 
 542     for (j = 0; j &lt; hgt; j++) {
 543       FTYPE    **buffc = buffs + buff_ind;
 544       FTYPE    *buffn = buffc[n];
 545       FTYPE    *pk = k;
 546 
 547       for (l = 0; l &lt; n; l++) {
 548         FTYPE    *buff_l = buffc[l];
 549 
 550         for (off = 0; off &lt; m;) {
 551           FTYPE    *buff = buff_l + off;
 552 
 553           kw = m - off;
 554 
 555           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 556             if (kw &gt; MAX_KER) kw = kw/2;
 557           off += kw;
 558 
 559           sp = sl;
 560           dp = dl;
 561 
 562           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 563           p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 564 
 565           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 566           k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 567           pk += kw;
 568 
 569           if (kw == 7) {
 570 
 571             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 572 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 573 #pragma pipeloop(0)</span>
<span class="line-removed"> 574 #endif /* __SUNPRO_C */</span>
 575               for (i = 0; i &lt;= (wid - 2); i += 2) {
 576                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 577 
 578                 p6 = buff[i + 6]; p7 = buff[i + 7];
 579 
 580                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 581                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 582               }
 583 
 584             } else {
<span class="line-removed"> 585 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 586 #pragma pipeloop(0)</span>
<span class="line-removed"> 587 #endif /* __SUNPRO_C */</span>
 588               for (i = 0; i &lt;= (wid - 2); i += 2) {
 589                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 590 
 591                 p6 = buff[i + 6]; p7 = buff[i + 7];
 592 
 593                 LOAD_BUFF(buffi);
 594 
 595                 dd.d64 = *(FTYPE   *)(buffi + i);
 596                 buffn[i    ] = (FTYPE)dd.i32s.i0;
 597                 buffn[i + 1] = (FTYPE)dd.i32s.i1;
 598 
 599                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 600                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 601 
 602                 dp[0    ] = FROM_S32(d0);
 603                 dp[chan1] = FROM_S32(d1);
 604 
 605                 buffd[i    ] = 0.0;
 606                 buffd[i + 1] = 0.0;
 607 
 608                 sp += chan2;
 609                 dp += chan2;
 610               }
 611             }
 612 
 613           } else if (kw == 6) {
 614 
 615             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 616 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 617 #pragma pipeloop(0)</span>
<span class="line-removed"> 618 #endif /* __SUNPRO_C */</span>
 619               for (i = 0; i &lt;= (wid - 2); i += 2) {
 620                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 621 
 622                 p5 = buff[i + 5]; p6 = buff[i + 6];
 623 
 624                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 625                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 626               }
 627 
 628             } else {
<span class="line-removed"> 629 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 630 #pragma pipeloop(0)</span>
<span class="line-removed"> 631 #endif /* __SUNPRO_C */</span>
 632               for (i = 0; i &lt;= (wid - 2); i += 2) {
 633                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 634 
 635                 p5 = buff[i + 5]; p6 = buff[i + 6];
 636 
 637                 buffn[i    ] = (FTYPE)sp[0];
 638                 buffn[i + 1] = (FTYPE)sp[chan1];
 639 
 640                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 641                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 642 
 643                 dp[0    ] = FROM_S32(d0);
 644                 dp[chan1] = FROM_S32(d1);
 645 
 646                 buffd[i    ] = 0.0;
 647                 buffd[i + 1] = 0.0;
 648 
 649                 sp += chan2;
 650                 dp += chan2;
 651               }
 652             }
 653 
 654           } else if (kw == 5) {
 655 
 656             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 657 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 658 #pragma pipeloop(0)</span>
<span class="line-removed"> 659 #endif /* __SUNPRO_C */</span>
 660               for (i = 0; i &lt;= (wid - 2); i += 2) {
 661                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 662 
 663                 p4 = buff[i + 4]; p5 = buff[i + 5];
 664 
 665                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 666                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 667               }
 668 
 669             } else {
<span class="line-removed"> 670 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 671 #pragma pipeloop(0)</span>
<span class="line-removed"> 672 #endif /* __SUNPRO_C */</span>
 673               for (i = 0; i &lt;= (wid - 2); i += 2) {
 674                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 675 
 676                 p4 = buff[i + 4]; p5 = buff[i + 5];
 677 
 678                 buffn[i    ] = (FTYPE)sp[0];
 679                 buffn[i + 1] = (FTYPE)sp[chan1];
 680 
 681                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 682                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 683 
 684                 dp[0    ] = FROM_S32(d0);
 685                 dp[chan1] = FROM_S32(d1);
 686 
 687                 buffd[i    ] = 0.0;
 688                 buffd[i + 1] = 0.0;
 689 
 690                 sp += chan2;
 691                 dp += chan2;
 692               }
 693             }
 694 
 695           } else if (kw == 4) {
 696 
 697             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 698 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 699 #pragma pipeloop(0)</span>
<span class="line-removed"> 700 #endif /* __SUNPRO_C */</span>
 701               for (i = 0; i &lt;= (wid - 2); i += 2) {
 702                 p0 = p2; p1 = p3; p2 = p4;
 703 
 704                 p3 = buff[i + 3]; p4 = buff[i + 4];
 705 
 706                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 707                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 708               }
 709 
 710             } else {
<span class="line-removed"> 711 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 712 #pragma pipeloop(0)</span>
<span class="line-removed"> 713 #endif /* __SUNPRO_C */</span>
 714               for (i = 0; i &lt;= (wid - 2); i += 2) {
 715                 p0 = p2; p1 = p3; p2 = p4;
 716 
 717                 p3 = buff[i + 3]; p4 = buff[i + 4];
 718 
 719                 buffn[i    ] = (FTYPE)sp[0];
 720                 buffn[i + 1] = (FTYPE)sp[chan1];
 721 
 722                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 723                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 724 
 725                 dp[0    ] = FROM_S32(d0);
 726                 dp[chan1] = FROM_S32(d1);
 727 
 728                 buffd[i    ] = 0.0;
 729                 buffd[i + 1] = 0.0;
 730 
 731                 sp += chan2;
 732                 dp += chan2;
 733               }
 734             }
 735 
 736           } else if (kw == 3) {
 737 
 738             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 739 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 740 #pragma pipeloop(0)</span>
<span class="line-removed"> 741 #endif /* __SUNPRO_C */</span>
 742               for (i = 0; i &lt;= (wid - 2); i += 2) {
 743                 p0 = p2; p1 = p3;
 744 
 745                 p2 = buff[i + 2]; p3 = buff[i + 3];
 746 
 747                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 748                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 749               }
 750 
 751             } else {
<span class="line-removed"> 752 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 753 #pragma pipeloop(0)</span>
<span class="line-removed"> 754 #endif /* __SUNPRO_C */</span>
 755               for (i = 0; i &lt;= (wid - 2); i += 2) {
 756                 p0 = p2; p1 = p3;
 757 
 758                 p2 = buff[i + 2]; p3 = buff[i + 3];
 759 
 760                 buffn[i    ] = (FTYPE)sp[0];
 761                 buffn[i + 1] = (FTYPE)sp[chan1];
 762 
 763                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 764                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 765 
 766                 dp[0    ] = FROM_S32(d0);
 767                 dp[chan1] = FROM_S32(d1);
 768 
 769                 buffd[i    ] = 0.0;
 770                 buffd[i + 1] = 0.0;
 771 
 772                 sp += chan2;
 773                 dp += chan2;
 774               }
 775             }
 776 
 777           } else /*if (kw == 2)*/ {
 778 
 779             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 780 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 781 #pragma pipeloop(0)</span>
<span class="line-removed"> 782 #endif /* __SUNPRO_C */</span>
 783               for (i = 0; i &lt;= (wid - 2); i += 2) {
 784                 p0 = p2;
 785 
 786                 p1 = buff[i + 1]; p2 = buff[i + 2];
 787 
 788                 buffd[i    ] += p0*k0 + p1*k1;
 789                 buffd[i + 1] += p1*k0 + p2*k1;
 790               }
 791 
 792             } else {
<span class="line-removed"> 793 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 794 #pragma pipeloop(0)</span>
<span class="line-removed"> 795 #endif /* __SUNPRO_C */</span>
 796               for (i = 0; i &lt;= (wid - 2); i += 2) {
 797                 p0 = p2;
 798 
 799                 p1 = buff[i + 1]; p2 = buff[i + 2];
 800 
 801                 buffn[i    ] = (FTYPE)sp[0];
 802                 buffn[i + 1] = (FTYPE)sp[chan1];
 803 
 804                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 805                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 806 
 807                 dp[0    ] = FROM_S32(d0);
 808                 dp[chan1] = FROM_S32(d1);
 809 
 810                 buffd[i    ] = 0.0;
 811                 buffd[i + 1] = 0.0;
 812 
 813                 sp += chan2;
 814                 dp += chan2;
 815               }
</pre>
<hr />
<pre>
 837         sp += chan1;
 838         dp += chan1;
 839       }
 840 
 841       for (l = 0; l &lt; (m - 1); l++) buffn[wid + l] = sp[l*chan1];
 842 
 843       /* next line */
 844       sl += sll;
 845       dl += dll;
 846 
 847       buff_ind++;
 848 
 849       if (buff_ind &gt;= n + 1) buff_ind = 0;
 850     }
 851   }
 852 
 853   FREE_AND_RETURN_STATUS;
 854 }
 855 
 856 /***************************************************************/
<span class="line-modified"> 857 #ifndef __sparc /* for x86, using integer multiplies is faster */</span>
 858 
 859 #define STORE_RES(res, x)                                       \
 860   x &gt;&gt;= shift2;                                                 \
 861   CLAMP_STORE(res, x)
 862 
 863 mlib_status CONV_FUNC_I(MxN)(mlib_image       *dst,
 864                              const mlib_image *src,
 865                              const mlib_s32   *kernel,
 866                              mlib_s32         m,
 867                              mlib_s32         n,
 868                              mlib_s32         dm,
 869                              mlib_s32         dn,
 870                              mlib_s32         scale,
 871                              mlib_s32         cmask)
 872 {
 873   mlib_s32 buff[BUFF_SIZE], *buffd = buff;
 874   mlib_s32 l, off, kw;
 875   mlib_s32 d0, d1, shift1, shift2;
 876   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 877   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
</pre>
<hr />
<pre>
 906 
 907   if (m*n &gt; MAX_N*MAX_N) {
 908     k = mlib_malloc(sizeof(mlib_s32)*(m*n));
 909 
 910     if (k == NULL) {
 911       if (buffd != buff) mlib_free(buffd);
 912       return MLIB_FAILURE;
 913     }
 914   }
 915 
 916   for (i = 0; i &lt; m*n; i++) {
 917     k[i] = kernel[i] &gt;&gt; shift1;
 918   }
 919 
 920   for (c = 0; c &lt; nchannel; c++) {
 921     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 922 
 923     sl = adr_src + c;
 924     dl = adr_dst + c;
 925 
<span class="line-removed"> 926 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 927 #pragma pipeloop(0)</span>
<span class="line-removed"> 928 #endif /* __SUNPRO_C */</span>
 929     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
 930 
 931     for (j = 0; j &lt; hgt; j++) {
 932       mlib_s32 *pk = k;
 933 
 934       for (l = 0; l &lt; n; l++) {
 935         DTYPE *sp0 = sl + l*sll;
 936 
 937         for (off = 0; off &lt; m;) {
 938           sp = sp0 + off*chan1;
 939           dp = dl;
 940 
 941           kw = m - off;
 942 
 943           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 944             if (kw &gt; MAX_KER) kw = kw/2;
 945           off += kw;
 946 
 947           p2 = sp[0]; p3 = sp[chan1]; p4 = sp[chan2];
 948           p5 = sp[chan2 + chan1]; p6 = sp[chan2 + chan2]; p7 = sp[5*chan1];
 949 
 950           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 951           k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 952           pk += kw;
 953 
 954           sp += (kw - 1)*chan1;
 955 
 956           if (kw == 7) {
 957 
 958             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 959 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 960 #pragma pipeloop(0)</span>
<span class="line-removed"> 961 #endif /* __SUNPRO_C */</span>
 962               for (i = 0; i &lt;= (wid - 2); i += 2) {
 963                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 964                 p6 = sp[0];
 965                 p7 = sp[chan1];
 966 
 967                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 968                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 969 
 970                 sp += chan2;
 971               }
 972 
 973             } else {
<span class="line-removed"> 974 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 975 #pragma pipeloop(0)</span>
<span class="line-removed"> 976 #endif /* __SUNPRO_C */</span>
 977               for (i = 0; i &lt;= (wid - 2); i += 2) {
 978                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 979                 p6 = sp[0];
 980                 p7 = sp[chan1];
 981 
 982                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 983                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 984 
 985                 STORE_RES(dp[0    ], d0);
 986                 STORE_RES(dp[chan1], d1);
 987 
 988                 buffd[i    ] = 0;
 989                 buffd[i + 1] = 0;
 990 
 991                 sp += chan2;
 992                 dp += chan2;
 993               }
 994             }
 995 
 996           } else if (kw == 6) {
 997 
 998             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed"> 999 #ifdef __SUNPRO_C</span>
<span class="line-removed">1000 #pragma pipeloop(0)</span>
<span class="line-removed">1001 #endif /* __SUNPRO_C */</span>
1002               for (i = 0; i &lt;= (wid - 2); i += 2) {
1003                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1004                 p5 = sp[0];
1005                 p6 = sp[chan1];
1006 
1007                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
1008                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
1009 
1010                 sp += chan2;
1011               }
1012 
1013             } else {
<span class="line-removed">1014 #ifdef __SUNPRO_C</span>
<span class="line-removed">1015 #pragma pipeloop(0)</span>
<span class="line-removed">1016 #endif /* __SUNPRO_C */</span>
1017               for (i = 0; i &lt;= (wid - 2); i += 2) {
1018                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
1019                 p5 = sp[0];
1020                 p6 = sp[chan1];
1021 
1022                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
1023                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
1024 
1025                 STORE_RES(dp[0    ], d0);
1026                 STORE_RES(dp[chan1], d1);
1027 
1028                 buffd[i    ] = 0;
1029                 buffd[i + 1] = 0;
1030 
1031                 sp += chan2;
1032                 dp += chan2;
1033               }
1034             }
1035 
1036           } else if (kw == 5) {
1037 
1038             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1039 #ifdef __SUNPRO_C</span>
<span class="line-removed">1040 #pragma pipeloop(0)</span>
<span class="line-removed">1041 #endif /* __SUNPRO_C */</span>
1042               for (i = 0; i &lt;= (wid - 2); i += 2) {
1043                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1044                 p4 = sp[0];
1045                 p5 = sp[chan1];
1046 
1047                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
1048                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
1049 
1050                 sp += chan2;
1051               }
1052 
1053             } else {
<span class="line-removed">1054 #ifdef __SUNPRO_C</span>
<span class="line-removed">1055 #pragma pipeloop(0)</span>
<span class="line-removed">1056 #endif /* __SUNPRO_C */</span>
1057               for (i = 0; i &lt;= (wid - 2); i += 2) {
1058                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
1059                 p4 = sp[0];
1060                 p5 = sp[chan1];
1061 
1062                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
1063                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
1064 
1065                 STORE_RES(dp[0    ], d0);
1066                 STORE_RES(dp[chan1], d1);
1067 
1068                 buffd[i    ] = 0;
1069                 buffd[i + 1] = 0;
1070 
1071                 sp += chan2;
1072                 dp += chan2;
1073               }
1074             }
1075 
1076           } else if (kw == 4) {
1077 
1078             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1079 #ifdef __SUNPRO_C</span>
<span class="line-removed">1080 #pragma pipeloop(0)</span>
<span class="line-removed">1081 #endif /* __SUNPRO_C */</span>
1082               for (i = 0; i &lt;= (wid - 2); i += 2) {
1083                 p0 = p2; p1 = p3; p2 = p4;
1084                 p3 = sp[0];
1085                 p4 = sp[chan1];
1086 
1087                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1088                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1089 
1090                 sp += chan2;
1091               }
1092 
1093             } else {
<span class="line-removed">1094 #ifdef __SUNPRO_C</span>
<span class="line-removed">1095 #pragma pipeloop(0)</span>
<span class="line-removed">1096 #endif /* __SUNPRO_C */</span>
1097               for (i = 0; i &lt;= (wid - 2); i += 2) {
1098                 p0 = p2; p1 = p3; p2 = p4;
1099                 p3 = sp[0];
1100                 p4 = sp[chan1];
1101 
1102                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1103                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1104 
1105                 STORE_RES(dp[0    ], d0);
1106                 STORE_RES(dp[chan1], d1);
1107 
1108                 buffd[i    ] = 0;
1109                 buffd[i + 1] = 0;
1110 
1111                 sp += chan2;
1112                 dp += chan2;
1113               }
1114             }
1115 
1116           } else if (kw == 3) {
1117 
1118             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1119 #ifdef __SUNPRO_C</span>
<span class="line-removed">1120 #pragma pipeloop(0)</span>
<span class="line-removed">1121 #endif /* __SUNPRO_C */</span>
1122               for (i = 0; i &lt;= (wid - 2); i += 2) {
1123                 p0 = p2; p1 = p3;
1124                 p2 = sp[0];
1125                 p3 = sp[chan1];
1126 
1127                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1128                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1129 
1130                 sp += chan2;
1131               }
1132 
1133             } else {
<span class="line-removed">1134 #ifdef __SUNPRO_C</span>
<span class="line-removed">1135 #pragma pipeloop(0)</span>
<span class="line-removed">1136 #endif /* __SUNPRO_C */</span>
1137               for (i = 0; i &lt;= (wid - 2); i += 2) {
1138                 p0 = p2; p1 = p3;
1139                 p2 = sp[0];
1140                 p3 = sp[chan1];
1141 
1142                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1143                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1144 
1145                 STORE_RES(dp[0    ], d0);
1146                 STORE_RES(dp[chan1], d1);
1147 
1148                 buffd[i    ] = 0;
1149                 buffd[i + 1] = 0;
1150 
1151                 sp += chan2;
1152                 dp += chan2;
1153               }
1154             }
1155 
1156           } else if (kw == 2) {
1157 
1158             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1159 #ifdef __SUNPRO_C</span>
<span class="line-removed">1160 #pragma pipeloop(0)</span>
<span class="line-removed">1161 #endif /* __SUNPRO_C */</span>
1162               for (i = 0; i &lt;= (wid - 2); i += 2) {
1163                 p0 = p2;
1164                 p1 = sp[0];
1165                 p2 = sp[chan1];
1166 
1167                 buffd[i    ] += p0*k0 + p1*k1;
1168                 buffd[i + 1] += p1*k0 + p2*k1;
1169 
1170                 sp += chan2;
1171               }
1172 
1173             } else {
<span class="line-removed">1174 #ifdef __SUNPRO_C</span>
<span class="line-removed">1175 #pragma pipeloop(0)</span>
<span class="line-removed">1176 #endif /* __SUNPRO_C */</span>
1177               for (i = 0; i &lt;= (wid - 2); i += 2) {
1178                 p0 = p2;
1179                 p1 = sp[0];
1180                 p2 = sp[chan1];
1181 
1182                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1183                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1184 
1185                 STORE_RES(dp[0    ], d0);
1186                 STORE_RES(dp[chan1], d1);
1187 
1188                 buffd[i    ] = 0;
1189                 buffd[i + 1] = 0;
1190 
1191                 sp += chan2;
1192                 dp += chan2;
1193               }
1194             }
1195 
1196           } else /*if (kw == 1)*/ {
1197 
1198             if (l &lt; (n - 1) || off &lt; m) {
<span class="line-removed">1199 #ifdef __SUNPRO_C</span>
<span class="line-removed">1200 #pragma pipeloop(0)</span>
<span class="line-removed">1201 #endif /* __SUNPRO_C */</span>
1202               for (i = 0; i &lt;= (wid - 2); i += 2) {
1203                 p0 = sp[0];
1204                 p1 = sp[chan1];
1205 
1206                 buffd[i    ] += p0*k0;
1207                 buffd[i + 1] += p1*k0;
1208 
1209                 sp += chan2;
1210               }
1211 
1212             } else {
<span class="line-removed">1213 #ifdef __SUNPRO_C</span>
<span class="line-removed">1214 #pragma pipeloop(0)</span>
<span class="line-removed">1215 #endif /* __SUNPRO_C */</span>
1216               for (i = 0; i &lt;= (wid - 2); i += 2) {
1217                 p0 = sp[0];
1218                 p1 = sp[chan1];
1219 
1220                 d0 = (p0*k0 + buffd[i    ]);
1221                 d1 = (p1*k0 + buffd[i + 1]);
1222 
1223                 STORE_RES(dp[0    ], d0);
1224                 STORE_RES(dp[chan1], d1);
1225 
1226                 buffd[i    ] = 0;
1227                 buffd[i + 1] = 0;
1228 
1229                 sp += chan2;
1230                 dp += chan2;
1231               }
1232             }
1233           }
1234         }
1235       }
</pre>
<hr />
<pre>
1250         }
1251 
1252         STORE_RES(dp[0], s);
1253 
1254         sp += chan1;
1255         dp += chan1;
1256       }
1257 
1258       sl += sll;
1259       dl += dll;
1260     }
1261   }
1262 
1263   if (buffd != buff) mlib_free(buffd);
1264   if (k != k_locl) mlib_free(k);
1265 
1266   return MLIB_SUCCESS;
1267 }
1268 
1269 /***************************************************************/
<span class="line-removed">1270 #endif /* __sparc ( for x86, using integer multiplies is faster ) */</span>
<span class="line-removed">1271 </span>
<span class="line-removed">1272 /***************************************************************/</span>
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 147 /***************************************************************/
 148 #define DEF_VARS(type)                                          \
 149   type     *adr_src, *sl, *sp = NULL;                           \
 150   type     *adr_dst, *dl, *dp = NULL;                           \
 151   FTYPE    *pbuff = buff;                                       \
 152   mlib_s32 wid, hgt, sll, dll;                                  \
 153   mlib_s32 nchannel, chan1;                                     \
 154   mlib_s32 i, j, c
 155 
 156 /***************************************************************/
 157 #define GET_SRC_DST_PARAMETERS(type)                            \
 158   hgt = mlib_ImageGetHeight(src);                               \
 159   wid = mlib_ImageGetWidth(src);                                \
 160   nchannel = mlib_ImageGetChannels(src);                        \
 161   sll = mlib_ImageGetStride(src) / sizeof(type);                \
 162   dll = mlib_ImageGetStride(dst) / sizeof(type);                \
 163   adr_src = (type *)mlib_ImageGetData(src);                     \
 164   adr_dst = (type *)mlib_ImageGetData(dst)
 165 
 166 /***************************************************************/


 167 #if IMG_TYPE == 1
 168 
 169 /* Test for the presence of any &quot;1&quot; bit in bits
 170    8 to 31 of val. If present, then val is either
 171    negative or &gt;255. If over/underflows of 8 bits
 172    are uncommon, then this technique can be a win,
 173    since only a single test, rather than two, is
 174    necessary to determine if clamping is needed.
 175    On the other hand, if over/underflows are common,
 176    it adds an extra test.
 177 */
 178 #define CLAMP_STORE(dst, val)                                   \
 179   if (val &amp; 0xffffff00) {                                       \
 180     if (val &lt; MLIB_U8_MIN)                                      \
 181       dst = MLIB_U8_MIN;                                        \
 182     else                                                        \
 183       dst = MLIB_U8_MAX;                                        \
 184   } else {                                                      \
 185     dst = (mlib_u8)val;                                         \
 186   }
</pre>
<hr />
<pre>
 189 
 190 #define CLAMP_STORE(dst, val)                                   \
 191   if (val &gt;= MLIB_S16_MAX)                                      \
 192     dst = MLIB_S16_MAX;                                         \
 193   else if (val &lt;= MLIB_S16_MIN)                                 \
 194     dst = MLIB_S16_MIN;                                         \
 195   else                                                          \
 196     dst = (mlib_s16)val
 197 
 198 #elif IMG_TYPE == 3
 199 
 200 #define CLAMP_STORE(dst, val)                                   \
 201   if (val &gt;= MLIB_U16_MAX)                                      \
 202     dst = MLIB_U16_MAX;                                         \
 203   else if (val &lt;= MLIB_U16_MIN)                                 \
 204     dst = MLIB_U16_MIN;                                         \
 205   else                                                          \
 206     dst = (mlib_u16)val
 207 
 208 #endif /* IMG_TYPE == 1 */

 209 
 210 /***************************************************************/
 211 #define MAX_KER   7
 212 #define MAX_N    15
 213 
 214 static mlib_status mlib_ImageConv1xN(mlib_image       *dst,
 215                                      const mlib_image *src,
 216                                      const mlib_d64   *k,
 217                                      mlib_s32         n,
 218                                      mlib_s32         dn,
 219                                      mlib_s32         cmask)
 220 {
 221   FTYPE    buff[BUFF_SIZE];
 222   mlib_s32 off, kh;
 223   mlib_s32 d0, d1;
 224   const FTYPE    *pk;
 225   FTYPE    k0, k1, k2, k3;
 226   FTYPE    p0, p1, p2, p3, p4;
 227   DEF_VARS(DTYPE);
 228   DTYPE    *sl_c, *dl_c, *sl0;
</pre>
<hr />
<pre>
 239   if (max_hsize &gt; BUFF_SIZE) {
 240     pbuff = mlib_malloc(sizeof(FTYPE)*max_hsize);
 241   }
 242 
 243   chan1 = nchannel;
 244 
 245   sl_c = adr_src;
 246   dl_c = adr_dst;
 247 
 248   for (l = 0; l &lt; hgt; l += hsize) {
 249     hsize = hgt - l;
 250 
 251     if (hsize &gt; max_hsize) hsize = max_hsize;
 252 
 253     for (c = 0; c &lt; nchannel; c++) {
 254       if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 255 
 256       sl = sl_c + c;
 257       dl = dl_c + c;
 258 



 259       for (j = 0; j &lt; hsize; j++) pbuff[j] = 0.0;
 260 
 261       for (i = 0; i &lt; wid; i++) {
 262         sl0 = sl;
 263 
 264         for (off = 0; off &lt; (n - 4); off += 4) {
 265           pk = k + off;
 266           sp = sl0;
 267 
 268           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 269           p2 = sp[0]; p3 = sp[sll]; p4 = sp[2*sll];
 270           sp += 3*sll;
 271 



 272           for (j = 0; j &lt; hsize; j += 2) {
 273             p0 = p2; p1 = p3; p2 = p4;
 274             p3 = sp[0];
 275             p4 = sp[sll];
 276 
 277             pbuff[j    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 278             pbuff[j + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 279 
 280             sp += 2*sll;
 281           }
 282 
 283           sl0 += 4*sll;
 284         }
 285 
 286         pk = k + off;
 287         sp = sl0;
 288 
 289         k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 290         p2 = sp[0]; p3 = sp[sll]; p4 = sp[2*sll];
 291 
 292         dp = dl;
 293         kh = n - off;
 294 
 295         if (kh == 4) {
 296           sp += 3*sll;
 297 



 298           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 299             p0 = p2; p1 = p3; p2 = p4;
 300             p3 = sp[0];
 301             p4 = sp[sll];
 302 
 303             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + pbuff[j]);
 304             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + pbuff[j + 1]);
 305 
 306             dp[0  ] = FROM_S32(d0);
 307             dp[dll] = FROM_S32(d1);
 308 
 309             pbuff[j] = 0;
 310             pbuff[j + 1] = 0;
 311 
 312             sp += 2*sll;
 313             dp += 2*dll;
 314           }
 315 
 316           if (j &lt; hsize) {
 317             p0 = p2; p1 = p3; p2 = p4;
 318             p3 = sp[0];
 319 
 320             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + pbuff[j]);
 321 
 322             pbuff[j] = 0;
 323 
 324             dp[0] = FROM_S32(d0);
 325           }
 326 
 327         } else if (kh == 3) {
 328           sp += 2*sll;
 329 



 330           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 331             p0 = p2; p1 = p3;
 332             p2 = sp[0];
 333             p3 = sp[sll];
 334 
 335             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + pbuff[j]);
 336             d1 = D2I(p1*k0 + p2*k1 + p3*k2 + pbuff[j + 1]);
 337 
 338             dp[0  ] = FROM_S32(d0);
 339             dp[dll] = FROM_S32(d1);
 340 
 341             pbuff[j] = 0;
 342             pbuff[j + 1] = 0;
 343 
 344             sp += 2*sll;
 345             dp += 2*dll;
 346           }
 347 
 348           if (j &lt; hsize) {
 349             p0 = p2; p1 = p3;
 350             p2 = sp[0];
 351 
 352             d0 = D2I(p0*k0 + p1*k1 + p2*k2 + pbuff[j]);
 353 
 354             pbuff[j] = 0;
 355 
 356             dp[0] = FROM_S32(d0);
 357           }
 358 
 359         } else if (kh == 2) {
 360           sp += sll;
 361 



 362           for (j = 0; j &lt;= (hsize - 2); j += 2) {
 363             p0 = p2;
 364             p1 = sp[0];
 365             p2 = sp[sll];
 366 
 367             d0 = D2I(p0*k0 + p1*k1 + pbuff[j]);
 368             d1 = D2I(p1*k0 + p2*k1 + pbuff[j + 1]);
 369 
 370             dp[0  ] = FROM_S32(d0);
 371             dp[dll] = FROM_S32(d1);
 372 
 373             pbuff[j] = 0;
 374             pbuff[j + 1] = 0;
 375 
 376             sp += 2*sll;
 377             dp += 2*dll;
 378           }
 379 
 380           if (j &lt; hsize) {
 381             p0 = p2;
 382             p1 = sp[0];
 383 
 384             d0 = D2I(p0*k0 + p1*k1 + pbuff[j]);
 385 
 386             pbuff[j] = 0;
 387 
 388             dp[0] = FROM_S32(d0);
 389           }
 390 
 391         } else /* if (kh == 1) */ {



 392           for (j = 0; j &lt; hsize; j++) {
 393             p0 = sp[0];
 394 
 395             d0 = D2I(p0*k0 + pbuff[j]);
 396 
 397             dp[0] = FROM_S32(d0);
 398 
 399             pbuff[j] = 0;
 400 
 401             sp += sll;
 402             dp += dll;
 403           }
 404         }
 405 
 406         sl += chan1;
 407         dl += chan1;
 408       }
 409     }
 410 
 411     sl_c += max_hsize*sll;
</pre>
<hr />
<pre>
 484   buffd = buffs[n] + wid;
 485   buffo = (mlib_s32*)(buffd + wid);
 486   buffi = buffo + (wid &amp;~ 1);
 487 
 488   chan1 = nchannel;
 489   chan2 = chan1 + chan1;
 490 
 491   wid -= (m - 1);
 492   hgt -= (n - 1);
 493   adr_dst += dn*dll + dm*nchannel;
 494 
 495   for (c = 0; c &lt; nchannel; c++) {
 496     if (!(cmask &amp; (1 &lt;&lt; (chan1 - 1 - c)))) continue;
 497 
 498     sl = adr_src + c;
 499     dl = adr_dst + c;
 500 
 501     for (l = 0; l &lt; n; l++) {
 502       FTYPE    *buff = buffs[l];
 503 



 504       for (i = 0; i &lt; wid + (m - 1); i++) {
 505         buff[i] = (FTYPE)sl[i*chan1];
 506       }
 507 
 508       sl += sll;
 509     }
 510 
 511     buff_ind = 0;
 512 



 513     for (i = 0; i &lt; wid; i++) buffd[i] = 0.0;
 514 
 515     for (j = 0; j &lt; hgt; j++) {
 516       FTYPE    **buffc = buffs + buff_ind;
 517       FTYPE    *buffn = buffc[n];
 518       FTYPE    *pk = k;
 519 
 520       for (l = 0; l &lt; n; l++) {
 521         FTYPE    *buff_l = buffc[l];
 522 
 523         for (off = 0; off &lt; m;) {
 524           FTYPE    *buff = buff_l + off;
 525 
 526           kw = m - off;
 527 
 528           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 529             if (kw &gt; MAX_KER) kw = kw/2;
 530           off += kw;
 531 
 532           sp = sl;
 533           dp = dl;
 534 
 535           p2 = buff[0]; p3 = buff[1]; p4 = buff[2];
 536           p5 = buff[3]; p6 = buff[4]; p7 = buff[5];
 537 
 538           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 539           k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 540           pk += kw;
 541 
 542           if (kw == 7) {
 543 
 544             if (l &lt; (n - 1) || off &lt; m) {



 545               for (i = 0; i &lt;= (wid - 2); i += 2) {
 546                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 547 
 548                 p6 = buff[i + 6]; p7 = buff[i + 7];
 549 
 550                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 551                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 552               }
 553 
 554             } else {



 555               for (i = 0; i &lt;= (wid - 2); i += 2) {
 556                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 557 
 558                 p6 = buff[i + 6]; p7 = buff[i + 7];
 559 
 560                 LOAD_BUFF(buffi);
 561 
 562                 dd.d64 = *(FTYPE   *)(buffi + i);
 563                 buffn[i    ] = (FTYPE)dd.i32s.i0;
 564                 buffn[i + 1] = (FTYPE)dd.i32s.i1;
 565 
 566                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 567                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 568 
 569                 dp[0    ] = FROM_S32(d0);
 570                 dp[chan1] = FROM_S32(d1);
 571 
 572                 buffd[i    ] = 0.0;
 573                 buffd[i + 1] = 0.0;
 574 
 575                 sp += chan2;
 576                 dp += chan2;
 577               }
 578             }
 579 
 580           } else if (kw == 6) {
 581 
 582             if (l &lt; (n - 1) || off &lt; m) {



 583               for (i = 0; i &lt;= (wid - 2); i += 2) {
 584                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 585 
 586                 p5 = buff[i + 5]; p6 = buff[i + 6];
 587 
 588                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 589                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 590               }
 591 
 592             } else {



 593               for (i = 0; i &lt;= (wid - 2); i += 2) {
 594                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 595 
 596                 p5 = buff[i + 5]; p6 = buff[i + 6];
 597 
 598                 buffn[i    ] = (FTYPE)sp[0];
 599                 buffn[i + 1] = (FTYPE)sp[chan1];
 600 
 601                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 602                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 603 
 604                 dp[0    ] = FROM_S32(d0);
 605                 dp[chan1] = FROM_S32(d1);
 606 
 607                 buffd[i    ] = 0.0;
 608                 buffd[i + 1] = 0.0;
 609 
 610                 sp += chan2;
 611                 dp += chan2;
 612               }
 613             }
 614 
 615           } else if (kw == 5) {
 616 
 617             if (l &lt; (n - 1) || off &lt; m) {



 618               for (i = 0; i &lt;= (wid - 2); i += 2) {
 619                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 620 
 621                 p4 = buff[i + 4]; p5 = buff[i + 5];
 622 
 623                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 624                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 625               }
 626 
 627             } else {



 628               for (i = 0; i &lt;= (wid - 2); i += 2) {
 629                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 630 
 631                 p4 = buff[i + 4]; p5 = buff[i + 5];
 632 
 633                 buffn[i    ] = (FTYPE)sp[0];
 634                 buffn[i + 1] = (FTYPE)sp[chan1];
 635 
 636                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 637                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 638 
 639                 dp[0    ] = FROM_S32(d0);
 640                 dp[chan1] = FROM_S32(d1);
 641 
 642                 buffd[i    ] = 0.0;
 643                 buffd[i + 1] = 0.0;
 644 
 645                 sp += chan2;
 646                 dp += chan2;
 647               }
 648             }
 649 
 650           } else if (kw == 4) {
 651 
 652             if (l &lt; (n - 1) || off &lt; m) {



 653               for (i = 0; i &lt;= (wid - 2); i += 2) {
 654                 p0 = p2; p1 = p3; p2 = p4;
 655 
 656                 p3 = buff[i + 3]; p4 = buff[i + 4];
 657 
 658                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
 659                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
 660               }
 661 
 662             } else {



 663               for (i = 0; i &lt;= (wid - 2); i += 2) {
 664                 p0 = p2; p1 = p3; p2 = p4;
 665 
 666                 p3 = buff[i + 3]; p4 = buff[i + 4];
 667 
 668                 buffn[i    ] = (FTYPE)sp[0];
 669                 buffn[i + 1] = (FTYPE)sp[chan1];
 670 
 671                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
 672                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
 673 
 674                 dp[0    ] = FROM_S32(d0);
 675                 dp[chan1] = FROM_S32(d1);
 676 
 677                 buffd[i    ] = 0.0;
 678                 buffd[i + 1] = 0.0;
 679 
 680                 sp += chan2;
 681                 dp += chan2;
 682               }
 683             }
 684 
 685           } else if (kw == 3) {
 686 
 687             if (l &lt; (n - 1) || off &lt; m) {



 688               for (i = 0; i &lt;= (wid - 2); i += 2) {
 689                 p0 = p2; p1 = p3;
 690 
 691                 p2 = buff[i + 2]; p3 = buff[i + 3];
 692 
 693                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
 694                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
 695               }
 696 
 697             } else {



 698               for (i = 0; i &lt;= (wid - 2); i += 2) {
 699                 p0 = p2; p1 = p3;
 700 
 701                 p2 = buff[i + 2]; p3 = buff[i + 3];
 702 
 703                 buffn[i    ] = (FTYPE)sp[0];
 704                 buffn[i + 1] = (FTYPE)sp[chan1];
 705 
 706                 d0 = D2I(p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
 707                 d1 = D2I(p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
 708 
 709                 dp[0    ] = FROM_S32(d0);
 710                 dp[chan1] = FROM_S32(d1);
 711 
 712                 buffd[i    ] = 0.0;
 713                 buffd[i + 1] = 0.0;
 714 
 715                 sp += chan2;
 716                 dp += chan2;
 717               }
 718             }
 719 
 720           } else /*if (kw == 2)*/ {
 721 
 722             if (l &lt; (n - 1) || off &lt; m) {



 723               for (i = 0; i &lt;= (wid - 2); i += 2) {
 724                 p0 = p2;
 725 
 726                 p1 = buff[i + 1]; p2 = buff[i + 2];
 727 
 728                 buffd[i    ] += p0*k0 + p1*k1;
 729                 buffd[i + 1] += p1*k0 + p2*k1;
 730               }
 731 
 732             } else {



 733               for (i = 0; i &lt;= (wid - 2); i += 2) {
 734                 p0 = p2;
 735 
 736                 p1 = buff[i + 1]; p2 = buff[i + 2];
 737 
 738                 buffn[i    ] = (FTYPE)sp[0];
 739                 buffn[i + 1] = (FTYPE)sp[chan1];
 740 
 741                 d0 = D2I(p0*k0 + p1*k1 + buffd[i    ]);
 742                 d1 = D2I(p1*k0 + p2*k1 + buffd[i + 1]);
 743 
 744                 dp[0    ] = FROM_S32(d0);
 745                 dp[chan1] = FROM_S32(d1);
 746 
 747                 buffd[i    ] = 0.0;
 748                 buffd[i + 1] = 0.0;
 749 
 750                 sp += chan2;
 751                 dp += chan2;
 752               }
</pre>
<hr />
<pre>
 774         sp += chan1;
 775         dp += chan1;
 776       }
 777 
 778       for (l = 0; l &lt; (m - 1); l++) buffn[wid + l] = sp[l*chan1];
 779 
 780       /* next line */
 781       sl += sll;
 782       dl += dll;
 783 
 784       buff_ind++;
 785 
 786       if (buff_ind &gt;= n + 1) buff_ind = 0;
 787     }
 788   }
 789 
 790   FREE_AND_RETURN_STATUS;
 791 }
 792 
 793 /***************************************************************/
<span class="line-modified"> 794 /* for x86, using integer multiplies is faster */</span>
 795 
 796 #define STORE_RES(res, x)                                       \
 797   x &gt;&gt;= shift2;                                                 \
 798   CLAMP_STORE(res, x)
 799 
 800 mlib_status CONV_FUNC_I(MxN)(mlib_image       *dst,
 801                              const mlib_image *src,
 802                              const mlib_s32   *kernel,
 803                              mlib_s32         m,
 804                              mlib_s32         n,
 805                              mlib_s32         dm,
 806                              mlib_s32         dn,
 807                              mlib_s32         scale,
 808                              mlib_s32         cmask)
 809 {
 810   mlib_s32 buff[BUFF_SIZE], *buffd = buff;
 811   mlib_s32 l, off, kw;
 812   mlib_s32 d0, d1, shift1, shift2;
 813   mlib_s32 k0, k1, k2, k3, k4, k5, k6;
 814   mlib_s32 p0, p1, p2, p3, p4, p5, p6, p7;
</pre>
<hr />
<pre>
 843 
 844   if (m*n &gt; MAX_N*MAX_N) {
 845     k = mlib_malloc(sizeof(mlib_s32)*(m*n));
 846 
 847     if (k == NULL) {
 848       if (buffd != buff) mlib_free(buffd);
 849       return MLIB_FAILURE;
 850     }
 851   }
 852 
 853   for (i = 0; i &lt; m*n; i++) {
 854     k[i] = kernel[i] &gt;&gt; shift1;
 855   }
 856 
 857   for (c = 0; c &lt; nchannel; c++) {
 858     if (!(cmask &amp; (1 &lt;&lt; (nchannel - 1 - c)))) continue;
 859 
 860     sl = adr_src + c;
 861     dl = adr_dst + c;
 862 



 863     for (i = 0; i &lt; wid; i++) buffd[i] = 0;
 864 
 865     for (j = 0; j &lt; hgt; j++) {
 866       mlib_s32 *pk = k;
 867 
 868       for (l = 0; l &lt; n; l++) {
 869         DTYPE *sp0 = sl + l*sll;
 870 
 871         for (off = 0; off &lt; m;) {
 872           sp = sp0 + off*chan1;
 873           dp = dl;
 874 
 875           kw = m - off;
 876 
 877           if (kw &gt; 2*MAX_KER) kw = MAX_KER; else
 878             if (kw &gt; MAX_KER) kw = kw/2;
 879           off += kw;
 880 
 881           p2 = sp[0]; p3 = sp[chan1]; p4 = sp[chan2];
 882           p5 = sp[chan2 + chan1]; p6 = sp[chan2 + chan2]; p7 = sp[5*chan1];
 883 
 884           k0 = pk[0]; k1 = pk[1]; k2 = pk[2]; k3 = pk[3];
 885           k4 = pk[4]; k5 = pk[5]; k6 = pk[6];
 886           pk += kw;
 887 
 888           sp += (kw - 1)*chan1;
 889 
 890           if (kw == 7) {
 891 
 892             if (l &lt; (n - 1) || off &lt; m) {



 893               for (i = 0; i &lt;= (wid - 2); i += 2) {
 894                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 895                 p6 = sp[0];
 896                 p7 = sp[chan1];
 897 
 898                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6;
 899                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6;
 900 
 901                 sp += chan2;
 902               }
 903 
 904             } else {



 905               for (i = 0; i &lt;= (wid - 2); i += 2) {
 906                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6; p5 = p7;
 907                 p6 = sp[0];
 908                 p7 = sp[chan1];
 909 
 910                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + p6*k6 + buffd[i    ]);
 911                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + p7*k6 + buffd[i + 1]);
 912 
 913                 STORE_RES(dp[0    ], d0);
 914                 STORE_RES(dp[chan1], d1);
 915 
 916                 buffd[i    ] = 0;
 917                 buffd[i + 1] = 0;
 918 
 919                 sp += chan2;
 920                 dp += chan2;
 921               }
 922             }
 923 
 924           } else if (kw == 6) {
 925 
 926             if (l &lt; (n - 1) || off &lt; m) {



 927               for (i = 0; i &lt;= (wid - 2); i += 2) {
 928                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 929                 p5 = sp[0];
 930                 p6 = sp[chan1];
 931 
 932                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5;
 933                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5;
 934 
 935                 sp += chan2;
 936               }
 937 
 938             } else {



 939               for (i = 0; i &lt;= (wid - 2); i += 2) {
 940                 p0 = p2; p1 = p3; p2 = p4; p3 = p5; p4 = p6;
 941                 p5 = sp[0];
 942                 p6 = sp[chan1];
 943 
 944                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + p5*k5 + buffd[i    ]);
 945                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + p6*k5 + buffd[i + 1]);
 946 
 947                 STORE_RES(dp[0    ], d0);
 948                 STORE_RES(dp[chan1], d1);
 949 
 950                 buffd[i    ] = 0;
 951                 buffd[i + 1] = 0;
 952 
 953                 sp += chan2;
 954                 dp += chan2;
 955               }
 956             }
 957 
 958           } else if (kw == 5) {
 959 
 960             if (l &lt; (n - 1) || off &lt; m) {



 961               for (i = 0; i &lt;= (wid - 2); i += 2) {
 962                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 963                 p4 = sp[0];
 964                 p5 = sp[chan1];
 965 
 966                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4;
 967                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4;
 968 
 969                 sp += chan2;
 970               }
 971 
 972             } else {



 973               for (i = 0; i &lt;= (wid - 2); i += 2) {
 974                 p0 = p2; p1 = p3; p2 = p4; p3 = p5;
 975                 p4 = sp[0];
 976                 p5 = sp[chan1];
 977 
 978                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + p4*k4 + buffd[i    ]);
 979                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + p5*k4 + buffd[i + 1]);
 980 
 981                 STORE_RES(dp[0    ], d0);
 982                 STORE_RES(dp[chan1], d1);
 983 
 984                 buffd[i    ] = 0;
 985                 buffd[i + 1] = 0;
 986 
 987                 sp += chan2;
 988                 dp += chan2;
 989               }
 990             }
 991 
 992           } else if (kw == 4) {
 993 
 994             if (l &lt; (n - 1) || off &lt; m) {



 995               for (i = 0; i &lt;= (wid - 2); i += 2) {
 996                 p0 = p2; p1 = p3; p2 = p4;
 997                 p3 = sp[0];
 998                 p4 = sp[chan1];
 999 
1000                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2 + p3*k3;
1001                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2 + p4*k3;
1002 
1003                 sp += chan2;
1004               }
1005 
1006             } else {



1007               for (i = 0; i &lt;= (wid - 2); i += 2) {
1008                 p0 = p2; p1 = p3; p2 = p4;
1009                 p3 = sp[0];
1010                 p4 = sp[chan1];
1011 
1012                 d0 = (p0*k0 + p1*k1 + p2*k2 + p3*k3 + buffd[i    ]);
1013                 d1 = (p1*k0 + p2*k1 + p3*k2 + p4*k3 + buffd[i + 1]);
1014 
1015                 STORE_RES(dp[0    ], d0);
1016                 STORE_RES(dp[chan1], d1);
1017 
1018                 buffd[i    ] = 0;
1019                 buffd[i + 1] = 0;
1020 
1021                 sp += chan2;
1022                 dp += chan2;
1023               }
1024             }
1025 
1026           } else if (kw == 3) {
1027 
1028             if (l &lt; (n - 1) || off &lt; m) {



1029               for (i = 0; i &lt;= (wid - 2); i += 2) {
1030                 p0 = p2; p1 = p3;
1031                 p2 = sp[0];
1032                 p3 = sp[chan1];
1033 
1034                 buffd[i    ] += p0*k0 + p1*k1 + p2*k2;
1035                 buffd[i + 1] += p1*k0 + p2*k1 + p3*k2;
1036 
1037                 sp += chan2;
1038               }
1039 
1040             } else {



1041               for (i = 0; i &lt;= (wid - 2); i += 2) {
1042                 p0 = p2; p1 = p3;
1043                 p2 = sp[0];
1044                 p3 = sp[chan1];
1045 
1046                 d0 = (p0*k0 + p1*k1 + p2*k2 + buffd[i    ]);
1047                 d1 = (p1*k0 + p2*k1 + p3*k2 + buffd[i + 1]);
1048 
1049                 STORE_RES(dp[0    ], d0);
1050                 STORE_RES(dp[chan1], d1);
1051 
1052                 buffd[i    ] = 0;
1053                 buffd[i + 1] = 0;
1054 
1055                 sp += chan2;
1056                 dp += chan2;
1057               }
1058             }
1059 
1060           } else if (kw == 2) {
1061 
1062             if (l &lt; (n - 1) || off &lt; m) {



1063               for (i = 0; i &lt;= (wid - 2); i += 2) {
1064                 p0 = p2;
1065                 p1 = sp[0];
1066                 p2 = sp[chan1];
1067 
1068                 buffd[i    ] += p0*k0 + p1*k1;
1069                 buffd[i + 1] += p1*k0 + p2*k1;
1070 
1071                 sp += chan2;
1072               }
1073 
1074             } else {



1075               for (i = 0; i &lt;= (wid - 2); i += 2) {
1076                 p0 = p2;
1077                 p1 = sp[0];
1078                 p2 = sp[chan1];
1079 
1080                 d0 = (p0*k0 + p1*k1 + buffd[i    ]);
1081                 d1 = (p1*k0 + p2*k1 + buffd[i + 1]);
1082 
1083                 STORE_RES(dp[0    ], d0);
1084                 STORE_RES(dp[chan1], d1);
1085 
1086                 buffd[i    ] = 0;
1087                 buffd[i + 1] = 0;
1088 
1089                 sp += chan2;
1090                 dp += chan2;
1091               }
1092             }
1093 
1094           } else /*if (kw == 1)*/ {
1095 
1096             if (l &lt; (n - 1) || off &lt; m) {



1097               for (i = 0; i &lt;= (wid - 2); i += 2) {
1098                 p0 = sp[0];
1099                 p1 = sp[chan1];
1100 
1101                 buffd[i    ] += p0*k0;
1102                 buffd[i + 1] += p1*k0;
1103 
1104                 sp += chan2;
1105               }
1106 
1107             } else {



1108               for (i = 0; i &lt;= (wid - 2); i += 2) {
1109                 p0 = sp[0];
1110                 p1 = sp[chan1];
1111 
1112                 d0 = (p0*k0 + buffd[i    ]);
1113                 d1 = (p1*k0 + buffd[i + 1]);
1114 
1115                 STORE_RES(dp[0    ], d0);
1116                 STORE_RES(dp[chan1], d1);
1117 
1118                 buffd[i    ] = 0;
1119                 buffd[i + 1] = 0;
1120 
1121                 sp += chan2;
1122                 dp += chan2;
1123               }
1124             }
1125           }
1126         }
1127       }
</pre>
<hr />
<pre>
1142         }
1143 
1144         STORE_RES(dp[0], s);
1145 
1146         sp += chan1;
1147         dp += chan1;
1148       }
1149 
1150       sl += sll;
1151       dl += dll;
1152     }
1153   }
1154 
1155   if (buffd != buff) mlib_free(buffd);
1156   if (k != k_locl) mlib_free(k);
1157 
1158   return MLIB_SUCCESS;
1159 }
1160 
1161 /***************************************************************/



</pre>
</td>
</tr>
</table>
<center><a href="mlib_ImageConv_8ext.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="mlib_ImageConv_D64nw.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
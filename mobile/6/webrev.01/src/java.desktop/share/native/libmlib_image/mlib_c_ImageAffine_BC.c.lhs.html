<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libmlib_image/mlib_c_ImageAffine_BC.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 
  27 /*
  28  * FUNCTION
  29  *      Image affine transformation with Bicubic filtering
  30  * SYNOPSIS
  31  *      mlib_status mlib_ImageAffine_[u8|s16|u16]_?ch_bc(mlib_s32 *leftEdges,
  32  *                                                       mlib_s32 *rightEdges,
  33  *                                                       mlib_s32 *xStarts,
  34  *                                                       mlib_s32 *yStarts,
  35  *                                                       mlib_s32 *sides,
  36  *                                                       mlib_u8  *dstData,
  37  *                                                       mlib_u8  **lineAddr,
  38  *                                                       mlib_s32 dstYStride,
  39  *                                                       mlib_s32 is_affine,
  40  *                                                       mlib_s32 srcYStride,
  41  *                                                       mlib_filter filter)
  42  *
  43  *
  44  * ARGUMENTS
  45  *      leftEdges  array[dstHeight] of xLeft coordinates
  46  *      RightEdges array[dstHeight] of xRight coordinates
  47  *      xStarts    array[dstHeight] of xStart * 65536 coordinates
  48  *      yStarts    array[dstHeight] of yStart * 65536 coordinates
  49  *      sides      output array[4]. sides[0] is yStart, sides[1] is yFinish,
  50  *                 sides[2] is dx * 65536, sides[3] is dy * 65536
  51  *      dstData    pointer to the first pixel on (yStart - 1) line
  52  *      lineAddr   array[srcHeight] of pointers to the first pixel on
  53  *                 the corresponding lines
  54  *      dstYStride stride of destination image
  55  *      is_affine  indicator (Affine - GridWarp)
  56  *      srcYStride stride of source image
  57  *      filter     type of resampling filter
  58  *
  59  * DESCRIPTION
  60  *      The functions step along the lines from xLeft to xRight and apply
  61  *      the bicubic filtering.
  62  *
  63  */
  64 
  65 #include &quot;mlib_ImageAffine.h&quot;
  66 
  67 #define DTYPE  mlib_u8
  68 
  69 #define FUN_NAME(CHAN) mlib_ImageAffine_u8_##CHAN##_bc
  70 
  71 #define FILTER_BITS   8
  72 
  73 /***************************************************************/
<a name="2" id="anc2"></a><span class="line-modified">  74 #ifdef __sparc /* for SPARC, using floating-point multiplies is faster */</span>
<span class="line-removed">  75 </span>
<span class="line-removed">  76 #undef  FILTER_ELEM_BITS</span>
<span class="line-removed">  77 #define FILTER_ELEM_BITS  4</span>
<span class="line-removed">  78 </span>
<span class="line-removed">  79 #ifdef MLIB_USE_FTOI_CLAMPING</span>
<span class="line-removed">  80 </span>
<span class="line-removed">  81 #define SAT8(DST)                                               \</span>
<span class="line-removed">  82   DST = ((mlib_s32)(val0 - sat) &gt;&gt; 24) ^ 0x80</span>
<span class="line-removed">  83 </span>
<span class="line-removed">  84 #else</span>
<span class="line-removed">  85 </span>
<span class="line-removed">  86 #define SAT8(DST)                                               \</span>
<span class="line-removed">  87   val0 -= sat;                                                  \</span>
<span class="line-removed">  88   if (val0 &gt;= MLIB_S32_MAX)                                     \</span>
<span class="line-removed">  89     DST = MLIB_U8_MAX;                                          \</span>
<span class="line-removed">  90   else if (val0 &lt;= MLIB_S32_MIN)                                \</span>
<span class="line-removed">  91     DST = MLIB_U8_MIN;                                          \</span>
<span class="line-removed">  92   else                                                          \</span>
<span class="line-removed">  93     DST = ((mlib_s32)val0 &gt;&gt; 24) ^ 0x80</span>
<span class="line-removed">  94 </span>
<span class="line-removed">  95 #endif /* MLIB_USE_FTOI_CLAMPING */</span>
<span class="line-removed">  96 </span>
<span class="line-removed">  97 /***************************************************************/</span>
<span class="line-removed">  98 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)</span>
<span class="line-removed">  99 {</span>
<span class="line-removed"> 100   DECLAREVAR_BC();</span>
<span class="line-removed"> 101   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 102   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 103   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 104 </span>
<span class="line-removed"> 105   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 106     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 107   }</span>
<span class="line-removed"> 108   else {</span>
<span class="line-removed"> 109     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 110   }</span>
<span class="line-removed"> 111 </span>
<span class="line-removed"> 112   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 113     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 114     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 115     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 116     mlib_s32 filterpos;</span>
<span class="line-removed"> 117     mlib_f32 *fptr;</span>
<span class="line-removed"> 118     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120     CLIP(1);</span>
<span class="line-removed"> 121     dstLineEnd = (DTYPE *) dstData + xRight;</span>
<span class="line-removed"> 122 </span>
<span class="line-removed"> 123     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 124     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 125 </span>
<span class="line-removed"> 126     xf0 = fptr[0];</span>
<span class="line-removed"> 127     xf1 = fptr[1];</span>
<span class="line-removed"> 128     xf2 = fptr[2];</span>
<span class="line-removed"> 129     xf3 = fptr[3];</span>
<span class="line-removed"> 130 </span>
<span class="line-removed"> 131     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 132     fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     yf0 = fptr[0];</span>
<span class="line-removed"> 135     yf1 = fptr[1];</span>
<span class="line-removed"> 136     yf2 = fptr[2];</span>
<span class="line-removed"> 137     yf3 = fptr[3];</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 140     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 141 </span>
<span class="line-removed"> 142     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 143     s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 144     s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 145     s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 146     s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 149 #pragma pipeloop(0)</span>
<span class="line-removed"> 150 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 151     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {</span>
<span class="line-removed"> 152       X += dX;</span>
<span class="line-removed"> 153       Y += dY;</span>
<span class="line-removed"> 154 </span>
<span class="line-removed"> 155       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 156             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 157       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 158       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 159             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 160       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 161       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 162             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 163       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 164       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 165             mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 168       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 169 </span>
<span class="line-removed"> 170       xf0 = fptr[0];</span>
<span class="line-removed"> 171       xf1 = fptr[1];</span>
<span class="line-removed"> 172       xf2 = fptr[2];</span>
<span class="line-removed"> 173       xf3 = fptr[3];</span>
<span class="line-removed"> 174 </span>
<span class="line-removed"> 175       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 176 </span>
<span class="line-removed"> 177       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 178       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 179 </span>
<span class="line-removed"> 180       yf0 = fptr[0];</span>
<span class="line-removed"> 181       yf1 = fptr[1];</span>
<span class="line-removed"> 182       yf2 = fptr[2];</span>
<span class="line-removed"> 183       yf3 = fptr[3];</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185       SAT8(dstPixelPtr[0]);</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 188       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 189 </span>
<span class="line-removed"> 190       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;</span>
<span class="line-removed"> 191       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 192       s1 = srcPixelPtr[1];</span>
<span class="line-removed"> 193       s2 = srcPixelPtr[2];</span>
<span class="line-removed"> 194       s3 = srcPixelPtr[3];</span>
<span class="line-removed"> 195     }</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197     c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 198           mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 199     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 200     c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 201           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 202     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 203     c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 204           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 205     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 206     c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[1]] * xf1 +</span>
<span class="line-removed"> 207           mlib_U82D64[srcPixelPtr[2]] * xf2 + mlib_U82D64[srcPixelPtr[3]] * xf3);</span>
<span class="line-removed"> 208 </span>
<span class="line-removed"> 209     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 210 </span>
<span class="line-removed"> 211     SAT8(dstPixelPtr[0]);</span>
<span class="line-removed"> 212   }</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214   return MLIB_SUCCESS;</span>
<span class="line-removed"> 215 }</span>
<span class="line-removed"> 216 </span>
<span class="line-removed"> 217 /***************************************************************/</span>
<span class="line-removed"> 218 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 219 {</span>
<span class="line-removed"> 220   DECLAREVAR_BC();</span>
<span class="line-removed"> 221   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 222   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 223   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 224 </span>
<span class="line-removed"> 225   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 226     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 227   }</span>
<span class="line-removed"> 228   else {</span>
<span class="line-removed"> 229     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 230   }</span>
<span class="line-removed"> 231 </span>
<span class="line-removed"> 232   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 233     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 234     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 235     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 236     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 237     mlib_f32 *fptr;</span>
<span class="line-removed"> 238     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 239 </span>
<span class="line-removed"> 240     CLIP(2);</span>
<span class="line-removed"> 241     dstLineEnd = (DTYPE *) dstData + 2 * xRight;</span>
<span class="line-removed"> 242 </span>
<span class="line-removed"> 243     for (k = 0; k &lt; 2; k++) {</span>
<span class="line-removed"> 244       mlib_s32 X1 = X;</span>
<span class="line-removed"> 245       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 246       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 249       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251       xf0 = fptr[0];</span>
<span class="line-removed"> 252       xf1 = fptr[1];</span>
<span class="line-removed"> 253       xf2 = fptr[2];</span>
<span class="line-removed"> 254       xf3 = fptr[3];</span>
<span class="line-removed"> 255 </span>
<span class="line-removed"> 256       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 257       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 258 </span>
<span class="line-removed"> 259       yf0 = fptr[0];</span>
<span class="line-removed"> 260       yf1 = fptr[1];</span>
<span class="line-removed"> 261       yf2 = fptr[2];</span>
<span class="line-removed"> 262       yf3 = fptr[3];</span>
<span class="line-removed"> 263 </span>
<span class="line-removed"> 264       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 265       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 268       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 269       s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 270       s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 271       s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 272 </span>
<span class="line-removed"> 273 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 274 #pragma pipeloop(0)</span>
<span class="line-removed"> 275 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 276       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {</span>
<span class="line-removed"> 277         X1 += dX;</span>
<span class="line-removed"> 278         Y1 += dY;</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 281               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 282         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 283         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 284               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 285         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 286         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 287               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 288         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 289         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 290               mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 291 </span>
<span class="line-removed"> 292         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 293         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 294 </span>
<span class="line-removed"> 295         xf0 = fptr[0];</span>
<span class="line-removed"> 296         xf1 = fptr[1];</span>
<span class="line-removed"> 297         xf2 = fptr[2];</span>
<span class="line-removed"> 298         xf3 = fptr[3];</span>
<span class="line-removed"> 299 </span>
<span class="line-removed"> 300         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 301 </span>
<span class="line-removed"> 302         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 303         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 304 </span>
<span class="line-removed"> 305         yf0 = fptr[0];</span>
<span class="line-removed"> 306         yf1 = fptr[1];</span>
<span class="line-removed"> 307         yf2 = fptr[2];</span>
<span class="line-removed"> 308         yf3 = fptr[3];</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310         SAT8(dPtr[0]);</span>
<span class="line-removed"> 311 </span>
<span class="line-removed"> 312         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 313         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 314 </span>
<span class="line-removed"> 315         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;</span>
<span class="line-removed"> 316         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 317         s1 = srcPixelPtr[2];</span>
<span class="line-removed"> 318         s2 = srcPixelPtr[4];</span>
<span class="line-removed"> 319         s3 = srcPixelPtr[6];</span>
<span class="line-removed"> 320       }</span>
<span class="line-removed"> 321 </span>
<span class="line-removed"> 322       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 323             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 324       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 325       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 326             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 327       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 328       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 329             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 330       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 331       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[2]] * xf1 +</span>
<span class="line-removed"> 332             mlib_U82D64[srcPixelPtr[4]] * xf2 + mlib_U82D64[srcPixelPtr[6]] * xf3);</span>
<span class="line-removed"> 333 </span>
<span class="line-removed"> 334       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 335 </span>
<span class="line-removed"> 336       SAT8(dPtr[0]);</span>
<span class="line-removed"> 337     }</span>
<span class="line-removed"> 338   }</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340   return MLIB_SUCCESS;</span>
<span class="line-removed"> 341 }</span>
<span class="line-removed"> 342 </span>
<span class="line-removed"> 343 /***************************************************************/</span>
<span class="line-removed"> 344 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 345 {</span>
<span class="line-removed"> 346   DECLAREVAR_BC();</span>
<span class="line-removed"> 347   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 348   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 349   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 350 </span>
<span class="line-removed"> 351   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 352     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 353   }</span>
<span class="line-removed"> 354   else {</span>
<span class="line-removed"> 355     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 356   }</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 359     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 360     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 361     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 362     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 363     mlib_f32 *fptr;</span>
<span class="line-removed"> 364     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366     CLIP(3);</span>
<span class="line-removed"> 367     dstLineEnd = (DTYPE *) dstData + 3 * xRight;</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369     for (k = 0; k &lt; 3; k++) {</span>
<span class="line-removed"> 370       mlib_s32 X1 = X;</span>
<span class="line-removed"> 371       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 372       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 373 </span>
<span class="line-removed"> 374       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 375       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 376 </span>
<span class="line-removed"> 377       xf0 = fptr[0];</span>
<span class="line-removed"> 378       xf1 = fptr[1];</span>
<span class="line-removed"> 379       xf2 = fptr[2];</span>
<span class="line-removed"> 380       xf3 = fptr[3];</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 383       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385       yf0 = fptr[0];</span>
<span class="line-removed"> 386       yf1 = fptr[1];</span>
<span class="line-removed"> 387       yf2 = fptr[2];</span>
<span class="line-removed"> 388       yf3 = fptr[3];</span>
<span class="line-removed"> 389 </span>
<span class="line-removed"> 390       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 391       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 394       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 395       s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 396       s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 397       s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 398 </span>
<span class="line-removed"> 399 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 400 #pragma pipeloop(0)</span>
<span class="line-removed"> 401 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 402       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {</span>
<span class="line-removed"> 403         X1 += dX;</span>
<span class="line-removed"> 404         Y1 += dY;</span>
<span class="line-removed"> 405 </span>
<span class="line-removed"> 406         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 407               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 408         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 409         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 410               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 411         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 412         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 413               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 414         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 415         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 416               mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 419         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 420 </span>
<span class="line-removed"> 421         xf0 = fptr[0];</span>
<span class="line-removed"> 422         xf1 = fptr[1];</span>
<span class="line-removed"> 423         xf2 = fptr[2];</span>
<span class="line-removed"> 424         xf3 = fptr[3];</span>
<span class="line-removed"> 425 </span>
<span class="line-removed"> 426         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 429         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431         yf0 = fptr[0];</span>
<span class="line-removed"> 432         yf1 = fptr[1];</span>
<span class="line-removed"> 433         yf2 = fptr[2];</span>
<span class="line-removed"> 434         yf3 = fptr[3];</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436         SAT8(dPtr[0]);</span>
<span class="line-removed"> 437 </span>
<span class="line-removed"> 438         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 439         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;</span>
<span class="line-removed"> 442         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 443         s1 = srcPixelPtr[3];</span>
<span class="line-removed"> 444         s2 = srcPixelPtr[6];</span>
<span class="line-removed"> 445         s3 = srcPixelPtr[9];</span>
<span class="line-removed"> 446       }</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 449             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 450       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 451       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 452             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 453       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 454       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 455             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 456       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 457       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[3]] * xf1 +</span>
<span class="line-removed"> 458             mlib_U82D64[srcPixelPtr[6]] * xf2 + mlib_U82D64[srcPixelPtr[9]] * xf3);</span>
<span class="line-removed"> 459 </span>
<span class="line-removed"> 460       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462       SAT8(dPtr[0]);</span>
<span class="line-removed"> 463     }</span>
<span class="line-removed"> 464   }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466   return MLIB_SUCCESS;</span>
<span class="line-removed"> 467 }</span>
<span class="line-removed"> 468 </span>
<span class="line-removed"> 469 /***************************************************************/</span>
<span class="line-removed"> 470 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)</span>
<span class="line-removed"> 471 {</span>
<span class="line-removed"> 472   DECLAREVAR_BC();</span>
<span class="line-removed"> 473   DTYPE *dstLineEnd;</span>
<span class="line-removed"> 474   mlib_d64 sat = (mlib_d64) 0x7F800000;</span>
<span class="line-removed"> 475   const mlib_f32 *mlib_filters_table;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477   if (filter == MLIB_BICUBIC) {</span>
<span class="line-removed"> 478     mlib_filters_table = mlib_filters_u8f_bc;</span>
<span class="line-removed"> 479   }</span>
<span class="line-removed"> 480   else {</span>
<span class="line-removed"> 481     mlib_filters_table = mlib_filters_u8f_bc2;</span>
<span class="line-removed"> 482   }</span>
<span class="line-removed"> 483 </span>
<span class="line-removed"> 484   for (j = yStart; j &lt;= yFinish; j++) {</span>
<span class="line-removed"> 485     mlib_d64 xf0, xf1, xf2, xf3;</span>
<span class="line-removed"> 486     mlib_d64 yf0, yf1, yf2, yf3;</span>
<span class="line-removed"> 487     mlib_d64 c0, c1, c2, c3, val0;</span>
<span class="line-removed"> 488     mlib_s32 filterpos, k;</span>
<span class="line-removed"> 489     mlib_f32 *fptr;</span>
<span class="line-removed"> 490     mlib_u8 s0, s1, s2, s3;</span>
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492     CLIP(4);</span>
<span class="line-removed"> 493     dstLineEnd = (DTYPE *) dstData + 4 * xRight;</span>
<span class="line-removed"> 494 </span>
<span class="line-removed"> 495     for (k = 0; k &lt; 4; k++) {</span>
<span class="line-removed"> 496       mlib_s32 X1 = X;</span>
<span class="line-removed"> 497       mlib_s32 Y1 = Y;</span>
<span class="line-removed"> 498       DTYPE *dPtr = dstPixelPtr + k;</span>
<span class="line-removed"> 499 </span>
<span class="line-removed"> 500       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 501       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 502 </span>
<span class="line-removed"> 503       xf0 = fptr[0];</span>
<span class="line-removed"> 504       xf1 = fptr[1];</span>
<span class="line-removed"> 505       xf2 = fptr[2];</span>
<span class="line-removed"> 506       xf3 = fptr[3];</span>
<span class="line-removed"> 507 </span>
<span class="line-removed"> 508       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 509       fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 510 </span>
<span class="line-removed"> 511       yf0 = fptr[0];</span>
<span class="line-removed"> 512       yf1 = fptr[1];</span>
<span class="line-removed"> 513       yf2 = fptr[2];</span>
<span class="line-removed"> 514       yf3 = fptr[3];</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 517       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 518 </span>
<span class="line-removed"> 519       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 520       s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 521       s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 522       s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 523       s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 526 #pragma pipeloop(0)</span>
<span class="line-removed"> 527 #endif /* __SUNPRO_C */</span>
<span class="line-removed"> 528       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {</span>
<span class="line-removed"> 529         X1 += dX;</span>
<span class="line-removed"> 530         Y1 += dY;</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532         c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 533               mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 534         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 535         c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 536               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 537         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 538         c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 539               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 540         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 541         c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 542               mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 543 </span>
<span class="line-removed"> 544         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 545         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547         xf0 = fptr[0];</span>
<span class="line-removed"> 548         xf1 = fptr[1];</span>
<span class="line-removed"> 549         xf2 = fptr[2];</span>
<span class="line-removed"> 550         xf3 = fptr[3];</span>
<span class="line-removed"> 551 </span>
<span class="line-removed"> 552         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;</span>
<span class="line-removed"> 555         fptr = (mlib_f32 *) ((mlib_u8 *) mlib_filters_table + filterpos);</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557         yf0 = fptr[0];</span>
<span class="line-removed"> 558         yf1 = fptr[1];</span>
<span class="line-removed"> 559         yf2 = fptr[2];</span>
<span class="line-removed"> 560         yf3 = fptr[3];</span>
<span class="line-removed"> 561 </span>
<span class="line-removed"> 562         SAT8(dPtr[0]);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 565         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;</span>
<span class="line-removed"> 566 </span>
<span class="line-removed"> 567         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;</span>
<span class="line-removed"> 568         s0 = srcPixelPtr[0];</span>
<span class="line-removed"> 569         s1 = srcPixelPtr[4];</span>
<span class="line-removed"> 570         s2 = srcPixelPtr[8];</span>
<span class="line-removed"> 571         s3 = srcPixelPtr[12];</span>
<span class="line-removed"> 572       }</span>
<span class="line-removed"> 573 </span>
<span class="line-removed"> 574       c0 = (mlib_U82D64[s0] * xf0 + mlib_U82D64[s1] * xf1 +</span>
<span class="line-removed"> 575             mlib_U82D64[s2] * xf2 + mlib_U82D64[s3] * xf3);</span>
<span class="line-removed"> 576       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 577       c1 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 578             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 579       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 580       c2 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 581             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 582       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);</span>
<span class="line-removed"> 583       c3 = (mlib_U82D64[srcPixelPtr[0]] * xf0 + mlib_U82D64[srcPixelPtr[4]] * xf1 +</span>
<span class="line-removed"> 584             mlib_U82D64[srcPixelPtr[8]] * xf2 + mlib_U82D64[srcPixelPtr[12]] * xf3);</span>
<span class="line-removed"> 585 </span>
<span class="line-removed"> 586       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3);</span>
<span class="line-removed"> 587 </span>
<span class="line-removed"> 588       SAT8(dPtr[0]);</span>
<span class="line-removed"> 589     }</span>
<span class="line-removed"> 590   }</span>
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592   return MLIB_SUCCESS;</span>
<span class="line-removed"> 593 }</span>
<span class="line-removed"> 594 </span>
<span class="line-removed"> 595 #else       /* for x86, using integer multiplies is faster */</span>
 596 
 597 #define SHIFT_X  12
 598 #define ROUND_X  0 /* (1 &lt;&lt; (SHIFT_X - 1)) */
 599 
 600 #define SHIFT_Y  (14 + 14 - SHIFT_X)
 601 #define ROUND_Y  (1 &lt;&lt; (SHIFT_Y - 1))
 602 
 603 /***************************************************************/
 604 /* Test for the presence of any &quot;1&quot; bit in bits
 605    8 to 31 of val. If present, then val is either
 606    negative or &gt;255. If over/underflows of 8 bits
 607    are uncommon, then this technique can be a win,
 608    since only a single test, rather than two, is
 609    necessary to determine if clamping is needed.
 610    On the other hand, if over/underflows are common,
 611    it adds an extra test.
 612 */
 613 #define S32_TO_U8_SAT(DST)                                      \
 614   if (val0 &amp; 0xffffff00) {                                      \
 615     if (val0 &lt; MLIB_U8_MIN)                                     \
 616       DST = MLIB_U8_MIN;                                        \
 617     else                                                        \
 618       DST = MLIB_U8_MAX;                                        \
 619   } else {                                                      \
 620     DST = (mlib_u8)val0;                                        \
 621   }
 622 
 623 /***************************************************************/
 624 mlib_status FUN_NAME(1ch)(mlib_affine_param *param)
 625 {
 626   DECLAREVAR_BC();
 627   DTYPE *dstLineEnd;
 628   const mlib_s16 *mlib_filters_table;
 629 
 630   if (filter == MLIB_BICUBIC) {
 631     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc;
 632   }
 633   else {
 634     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc2;
 635   }
 636 
 637   for (j = yStart; j &lt;= yFinish; j++) {
 638     mlib_s32 xf0, xf1, xf2, xf3;
 639     mlib_s32 yf0, yf1, yf2, yf3;
 640     mlib_s32 c0, c1, c2, c3, val0;
 641     mlib_s32 filterpos;
 642     mlib_s16 *fptr;
 643     mlib_u8 s0, s1, s2, s3;
 644 
 645     CLIP(1);
 646     dstLineEnd = (DTYPE *) dstData + xRight;
 647 
 648     filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 649     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 650 
 651     xf0 = fptr[0];
 652     xf1 = fptr[1];
 653     xf2 = fptr[2];
 654     xf3 = fptr[3];
 655 
 656     filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 657     fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 658 
 659     yf0 = fptr[0];
 660     yf1 = fptr[1];
 661     yf2 = fptr[2];
 662     yf3 = fptr[3];
 663 
 664     xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 665     ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 666 
 667     srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 668     s0 = srcPixelPtr[0];
 669     s1 = srcPixelPtr[1];
 670     s2 = srcPixelPtr[2];
 671     s3 = srcPixelPtr[3];
 672 
<a name="3" id="anc3"></a><span class="line-removed"> 673 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 674 #pragma pipeloop(0)</span>
<span class="line-removed"> 675 #endif /* __SUNPRO_C */</span>
 676     for (; dstPixelPtr &lt;= (dstLineEnd - 1); dstPixelPtr++) {
 677       X += dX;
 678       Y += dY;
 679 
 680       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 681       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 682       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 683             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 684       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 685       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 686             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 687       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 688       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 689             srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 690 
 691       filterpos = (X &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 692       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 693 
 694       xf0 = fptr[0];
 695       xf1 = fptr[1];
 696       xf2 = fptr[2];
 697       xf3 = fptr[3];
 698 
 699       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 700 
 701       filterpos = (Y &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 702       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 703 
 704       yf0 = fptr[0];
 705       yf1 = fptr[1];
 706       yf2 = fptr[2];
 707       yf3 = fptr[3];
 708 
 709       S32_TO_U8_SAT(dstPixelPtr[0]);
 710 
 711       xSrc = (X &gt;&gt; MLIB_SHIFT) - 1;
 712       ySrc = (Y &gt;&gt; MLIB_SHIFT) - 1;
 713 
 714       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + xSrc;
 715       s0 = srcPixelPtr[0];
 716       s1 = srcPixelPtr[1];
 717       s2 = srcPixelPtr[2];
 718       s3 = srcPixelPtr[3];
 719     }
 720 
 721     c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 722     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 723     c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 724           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 725     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 726     c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 727           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 728     srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 729     c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[1] * xf1 +
 730           srcPixelPtr[2] * xf2 + srcPixelPtr[3] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 731 
 732     val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 733 
 734     S32_TO_U8_SAT(dstPixelPtr[0]);
 735   }
 736 
 737   return MLIB_SUCCESS;
 738 }
 739 
 740 /***************************************************************/
 741 mlib_status FUN_NAME(2ch)(mlib_affine_param *param)
 742 {
 743   DECLAREVAR_BC();
 744   DTYPE *dstLineEnd;
 745   const mlib_s16 *mlib_filters_table;
 746 
 747   if (filter == MLIB_BICUBIC) {
 748     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc;
 749   }
 750   else {
 751     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc2;
 752   }
 753 
 754   for (j = yStart; j &lt;= yFinish; j++) {
 755     mlib_s32 xf0, xf1, xf2, xf3;
 756     mlib_s32 yf0, yf1, yf2, yf3;
 757     mlib_s32 c0, c1, c2, c3, val0;
 758     mlib_s32 filterpos, k;
 759     mlib_s16 *fptr;
 760     mlib_u8 s0, s1, s2, s3;
 761 
 762     CLIP(2);
 763     dstLineEnd = (DTYPE *) dstData + 2 * xRight;
 764 
 765     for (k = 0; k &lt; 2; k++) {
 766       mlib_s32 X1 = X;
 767       mlib_s32 Y1 = Y;
 768       DTYPE *dPtr = dstPixelPtr + k;
 769 
 770       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 771       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 772 
 773       xf0 = fptr[0];
 774       xf1 = fptr[1];
 775       xf2 = fptr[2];
 776       xf3 = fptr[3];
 777 
 778       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 779       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 780 
 781       yf0 = fptr[0];
 782       yf1 = fptr[1];
 783       yf2 = fptr[2];
 784       yf3 = fptr[3];
 785 
 786       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 787       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 788 
 789       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 790       s0 = srcPixelPtr[0];
 791       s1 = srcPixelPtr[2];
 792       s2 = srcPixelPtr[4];
 793       s3 = srcPixelPtr[6];
 794 
<a name="4" id="anc4"></a><span class="line-removed"> 795 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 796 #pragma pipeloop(0)</span>
<span class="line-removed"> 797 #endif /* __SUNPRO_C */</span>
 798       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 2) {
 799         X1 += dX;
 800         Y1 += dY;
 801 
 802         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 803         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 804         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 805               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 806         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 807         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 808               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 809         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 810         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 811               srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 812 
 813         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 814         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 815 
 816         xf0 = fptr[0];
 817         xf1 = fptr[1];
 818         xf2 = fptr[2];
 819         xf3 = fptr[3];
 820 
 821         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 822 
 823         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 824         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 825 
 826         yf0 = fptr[0];
 827         yf1 = fptr[1];
 828         yf2 = fptr[2];
 829         yf3 = fptr[3];
 830 
 831         S32_TO_U8_SAT(dPtr[0]);
 832 
 833         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 834         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 835 
 836         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 2 * xSrc + k;
 837         s0 = srcPixelPtr[0];
 838         s1 = srcPixelPtr[2];
 839         s2 = srcPixelPtr[4];
 840         s3 = srcPixelPtr[6];
 841       }
 842 
 843       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 844       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 845       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 846             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 847       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 848       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 849             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 850       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 851       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[2] * xf1 +
 852             srcPixelPtr[4] * xf2 + srcPixelPtr[6] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 853 
 854       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 855 
 856       S32_TO_U8_SAT(dPtr[0]);
 857     }
 858   }
 859 
 860   return MLIB_SUCCESS;
 861 }
 862 
 863 /***************************************************************/
 864 mlib_status FUN_NAME(3ch)(mlib_affine_param *param)
 865 {
 866   DECLAREVAR_BC();
 867   DTYPE *dstLineEnd;
 868   const mlib_s16 *mlib_filters_table;
 869 
 870   if (filter == MLIB_BICUBIC) {
 871     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc;
 872   }
 873   else {
 874     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc2;
 875   }
 876 
 877   for (j = yStart; j &lt;= yFinish; j++) {
 878     mlib_s32 xf0, xf1, xf2, xf3;
 879     mlib_s32 yf0, yf1, yf2, yf3;
 880     mlib_s32 c0, c1, c2, c3, val0;
 881     mlib_s32 filterpos, k;
 882     mlib_s16 *fptr;
 883     mlib_u8 s0, s1, s2, s3;
 884 
 885     CLIP(3);
 886     dstLineEnd = (DTYPE *) dstData + 3 * xRight;
 887 
 888     for (k = 0; k &lt; 3; k++) {
 889       mlib_s32 X1 = X;
 890       mlib_s32 Y1 = Y;
 891       DTYPE *dPtr = dstPixelPtr + k;
 892 
 893       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 894       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 895 
 896       xf0 = fptr[0];
 897       xf1 = fptr[1];
 898       xf2 = fptr[2];
 899       xf3 = fptr[3];
 900 
 901       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 902       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 903 
 904       yf0 = fptr[0];
 905       yf1 = fptr[1];
 906       yf2 = fptr[2];
 907       yf3 = fptr[3];
 908 
 909       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 910       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 911 
 912       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 913       s0 = srcPixelPtr[0];
 914       s1 = srcPixelPtr[3];
 915       s2 = srcPixelPtr[6];
 916       s3 = srcPixelPtr[9];
 917 
<a name="5" id="anc5"></a><span class="line-removed"> 918 #ifdef __SUNPRO_C</span>
<span class="line-removed"> 919 #pragma pipeloop(0)</span>
<span class="line-removed"> 920 #endif /* __SUNPRO_C */</span>
 921       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 3) {
 922         X1 += dX;
 923         Y1 += dY;
 924 
 925         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 926         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 927         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 928               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 929         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 930         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 931               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 932         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 933         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 934               srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 935 
 936         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 937         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 938 
 939         xf0 = fptr[0];
 940         xf1 = fptr[1];
 941         xf2 = fptr[2];
 942         xf3 = fptr[3];
 943 
 944         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 945 
 946         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
 947         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
 948 
 949         yf0 = fptr[0];
 950         yf1 = fptr[1];
 951         yf2 = fptr[2];
 952         yf3 = fptr[3];
 953 
 954         S32_TO_U8_SAT(dPtr[0]);
 955 
 956         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
 957         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
 958 
 959         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 3 * xSrc + k;
 960         s0 = srcPixelPtr[0];
 961         s1 = srcPixelPtr[3];
 962         s2 = srcPixelPtr[6];
 963         s3 = srcPixelPtr[9];
 964       }
 965 
 966       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 967       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 968       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 969             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 970       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 971       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 972             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 973       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
 974       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[3] * xf1 +
 975             srcPixelPtr[6] * xf2 + srcPixelPtr[9] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
 976 
 977       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
 978 
 979       S32_TO_U8_SAT(dPtr[0]);
 980     }
 981   }
 982 
 983   return MLIB_SUCCESS;
 984 }
 985 
 986 /***************************************************************/
 987 mlib_status FUN_NAME(4ch)(mlib_affine_param *param)
 988 {
 989   DECLAREVAR_BC();
 990   DTYPE *dstLineEnd;
 991   const mlib_s16 *mlib_filters_table;
 992 
 993   if (filter == MLIB_BICUBIC) {
 994     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc;
 995   }
 996   else {
 997     mlib_filters_table = (mlib_s16 *) mlib_filters_u8_bc2;
 998   }
 999 
1000   for (j = yStart; j &lt;= yFinish; j++) {
1001     mlib_s32 xf0, xf1, xf2, xf3;
1002     mlib_s32 yf0, yf1, yf2, yf3;
1003     mlib_s32 c0, c1, c2, c3, val0;
1004     mlib_s32 filterpos, k;
1005     mlib_s16 *fptr;
1006     mlib_u8 s0, s1, s2, s3;
1007 
1008     CLIP(4);
1009     dstLineEnd = (DTYPE *) dstData + 4 * xRight;
1010 
1011     for (k = 0; k &lt; 4; k++) {
1012       mlib_s32 X1 = X;
1013       mlib_s32 Y1 = Y;
1014       DTYPE *dPtr = dstPixelPtr + k;
1015 
1016       filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1017       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1018 
1019       xf0 = fptr[0];
1020       xf1 = fptr[1];
1021       xf2 = fptr[2];
1022       xf3 = fptr[3];
1023 
1024       filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1025       fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1026 
1027       yf0 = fptr[0];
1028       yf1 = fptr[1];
1029       yf2 = fptr[2];
1030       yf3 = fptr[3];
1031 
1032       xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1033       ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1034 
1035       srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1036       s0 = srcPixelPtr[0];
1037       s1 = srcPixelPtr[4];
1038       s2 = srcPixelPtr[8];
1039       s3 = srcPixelPtr[12];
1040 
<a name="6" id="anc6"></a><span class="line-removed">1041 #ifdef __SUNPRO_C</span>
<span class="line-removed">1042 #pragma pipeloop(0)</span>
<span class="line-removed">1043 #endif /* __SUNPRO_C */</span>
1044       for (; dPtr &lt;= (dstLineEnd - 1); dPtr += 4) {
1045         X1 += dX;
1046         Y1 += dY;
1047 
1048         c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1049         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1050         c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1051               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1052         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1053         c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1054               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1055         srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1056         c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1057               srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1058 
1059         filterpos = (X1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1060         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1061 
1062         xf0 = fptr[0];
1063         xf1 = fptr[1];
1064         xf2 = fptr[2];
1065         xf3 = fptr[3];
1066 
1067         val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1068 
1069         filterpos = (Y1 &gt;&gt; FILTER_SHIFT) &amp; FILTER_MASK;
1070         fptr = (mlib_s16 *) ((mlib_u8 *) mlib_filters_table + filterpos);
1071 
1072         yf0 = fptr[0];
1073         yf1 = fptr[1];
1074         yf2 = fptr[2];
1075         yf3 = fptr[3];
1076 
1077         S32_TO_U8_SAT(dPtr[0]);
1078 
1079         xSrc = (X1 &gt;&gt; MLIB_SHIFT) - 1;
1080         ySrc = (Y1 &gt;&gt; MLIB_SHIFT) - 1;
1081 
1082         srcPixelPtr = ((DTYPE **) lineAddr)[ySrc] + 4 * xSrc + k;
1083         s0 = srcPixelPtr[0];
1084         s1 = srcPixelPtr[4];
1085         s2 = srcPixelPtr[8];
1086         s3 = srcPixelPtr[12];
1087       }
1088 
1089       c0 = (s0 * xf0 + s1 * xf1 + s2 * xf2 + s3 * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1090       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1091       c1 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1092             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1093       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1094       c2 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1095             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1096       srcPixelPtr = (DTYPE *) ((mlib_addr) srcPixelPtr + srcYStride);
1097       c3 = (srcPixelPtr[0] * xf0 + srcPixelPtr[4] * xf1 +
1098             srcPixelPtr[8] * xf2 + srcPixelPtr[12] * xf3 + ROUND_X) &gt;&gt; SHIFT_X;
1099 
1100       val0 = (c0 * yf0 + c1 * yf1 + c2 * yf2 + c3 * yf3 + ROUND_Y) &gt;&gt; SHIFT_Y;
1101 
1102       S32_TO_U8_SAT(dPtr[0]);
1103     }
1104   }
1105 
1106   return MLIB_SUCCESS;
1107 }
1108 
<a name="7" id="anc7"></a><span class="line-removed">1109 #endif /* __sparc ( for SPARC, using floating-point multiplies is faster ) */</span>
<span class="line-removed">1110 </span>
1111 /***************************************************************/
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libawt/java2d/loops/TransformHelper.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../common/awt/medialib/mlib_sys.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../libjsound/SoundDefs.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libawt/java2d/loops/TransformHelper.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
676         yfactor = URShift(yfract, 32-8);
677         BL_ACCUM(0);
678         BL_ACCUM(1);
679         BL_ACCUM(2);
680         BL_ACCUM(3);
681         pRes++;
682         pRGB += 4;
683         xfract += dxfract;
684         yfract += dyfract;
685     }
686 }
687 
688 #define SAT(val, max) \
689     do { \
690         val &amp;= ~(val &gt;&gt; 31);  /* negatives become 0 */ \
691         val -= max;           /* only overflows are now positive */ \
692         val &amp;= (val &gt;&gt; 31);   /* positives become 0 */ \
693         val += max;           /* range is now [0 -&gt; max] */ \
694     } while (0)
695 
<span class="line-removed">696 #ifdef __sparc</span>
<span class="line-removed">697 /* For sparc, floating point multiplies are faster than integer */</span>
<span class="line-removed">698 #define BICUBIC_USE_DBL_LUT</span>
<span class="line-removed">699 #else</span>
700 /* For x86, integer multiplies are faster than floating point */
701 /* Note that on x86 Linux the choice of best algorithm varies
702  * depending on the compiler optimization and the processor type.
703  * Currently, the sun/awt x86 Linux builds are not optimized so
704  * all the variations produce mediocre performance.
705  * For now we will use the choice that works best for the Windows
706  * build until the (lack of) optimization issues on Linux are resolved.
707  */
708 #define BICUBIC_USE_INT_MATH
<span class="line-removed">709 #endif</span>
710 
711 #ifdef BICUBIC_USE_DBL_CAST
712 
713 #define BC_DblToCoeff(v)        (v)
714 #define BC_COEFF_ONE            1.0
715 #define BC_TYPE                 jdouble
716 #define BC_V_HALF               0.5
717 #define BC_CompToV(v)           ((jdouble) (v))
718 #define BC_STORE_COMPS(pRes) \
719     do { \
720         jint a = (jint) accumA; \
721         jint r = (jint) accumR; \
722         jint g = (jint) accumG; \
723         jint b = (jint) accumB; \
724         SAT(a, 255); \
725         SAT(r, a); \
726         SAT(g, a); \
727         SAT(b, a); \
728         *pRes = ((a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt;  8) | (b)); \
729     } while (0)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
676         yfactor = URShift(yfract, 32-8);
677         BL_ACCUM(0);
678         BL_ACCUM(1);
679         BL_ACCUM(2);
680         BL_ACCUM(3);
681         pRes++;
682         pRGB += 4;
683         xfract += dxfract;
684         yfract += dyfract;
685     }
686 }
687 
688 #define SAT(val, max) \
689     do { \
690         val &amp;= ~(val &gt;&gt; 31);  /* negatives become 0 */ \
691         val -= max;           /* only overflows are now positive */ \
692         val &amp;= (val &gt;&gt; 31);   /* positives become 0 */ \
693         val += max;           /* range is now [0 -&gt; max] */ \
694     } while (0)
695 




696 /* For x86, integer multiplies are faster than floating point */
697 /* Note that on x86 Linux the choice of best algorithm varies
698  * depending on the compiler optimization and the processor type.
699  * Currently, the sun/awt x86 Linux builds are not optimized so
700  * all the variations produce mediocre performance.
701  * For now we will use the choice that works best for the Windows
702  * build until the (lack of) optimization issues on Linux are resolved.
703  */
704 #define BICUBIC_USE_INT_MATH

705 
706 #ifdef BICUBIC_USE_DBL_CAST
707 
708 #define BC_DblToCoeff(v)        (v)
709 #define BC_COEFF_ONE            1.0
710 #define BC_TYPE                 jdouble
711 #define BC_V_HALF               0.5
712 #define BC_CompToV(v)           ((jdouble) (v))
713 #define BC_STORE_COMPS(pRes) \
714     do { \
715         jint a = (jint) accumA; \
716         jint r = (jint) accumR; \
717         jint g = (jint) accumG; \
718         jint b = (jint) accumB; \
719         SAT(a, 255); \
720         SAT(r, a); \
721         SAT(g, a); \
722         SAT(b, a); \
723         *pRes = ((a &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt;  8) | (b)); \
724     } while (0)
</pre>
</td>
</tr>
</table>
<center><a href="../../../common/awt/medialib/mlib_sys.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../libjsound/SoundDefs.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
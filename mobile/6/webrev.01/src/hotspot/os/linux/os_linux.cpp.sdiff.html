<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../posix/include/jvm_md.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3778   // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
3779   // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
3780   // page as large as 256M.
3781   //
3782   // Here we try to figure out page size by parsing /proc/meminfo and looking
3783   // for a line with the following format:
3784   //    Hugepagesize:     2048 kB
3785   //
3786   // If we can&#39;t determine the value (e.g. /proc is not mounted, or the text
3787   // format has been changed), we&#39;ll use the largest page size supported by
3788   // the processor.
3789 
3790 #ifndef ZERO
3791   large_page_size =
3792     AARCH64_ONLY(2 * M)
3793     AMD64_ONLY(2 * M)
3794     ARM32_ONLY(2 * M)
3795     IA32_ONLY(4 * M)
3796     IA64_ONLY(256 * M)
3797     PPC_ONLY(4 * M)
<span class="line-modified">3798     S390_ONLY(1 * M)</span>
<span class="line-removed">3799     SPARC_ONLY(4 * M);</span>
3800 #endif // ZERO
3801 
3802   FILE *fp = fopen(&quot;/proc/meminfo&quot;, &quot;r&quot;);
3803   if (fp) {
3804     while (!feof(fp)) {
3805       int x = 0;
3806       char buf[16];
3807       if (fscanf(fp, &quot;Hugepagesize: %d&quot;, &amp;x) == 1) {
3808         if (x &amp;&amp; fgets(buf, sizeof(buf), fp) &amp;&amp; strcmp(buf, &quot; kB\n&quot;) == 0) {
3809           large_page_size = x * K;
3810           break;
3811         }
3812       } else {
3813         // skip to next line
3814         for (;;) {
3815           int ch = fgetc(fp);
3816           if (ch == EOF || ch == (int)&#39;\n&#39;) break;
3817         }
3818       }
3819     }
</pre>
</td>
<td>
<hr />
<pre>
3778   // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
3779   // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
3780   // page as large as 256M.
3781   //
3782   // Here we try to figure out page size by parsing /proc/meminfo and looking
3783   // for a line with the following format:
3784   //    Hugepagesize:     2048 kB
3785   //
3786   // If we can&#39;t determine the value (e.g. /proc is not mounted, or the text
3787   // format has been changed), we&#39;ll use the largest page size supported by
3788   // the processor.
3789 
3790 #ifndef ZERO
3791   large_page_size =
3792     AARCH64_ONLY(2 * M)
3793     AMD64_ONLY(2 * M)
3794     ARM32_ONLY(2 * M)
3795     IA32_ONLY(4 * M)
3796     IA64_ONLY(256 * M)
3797     PPC_ONLY(4 * M)
<span class="line-modified">3798     S390_ONLY(1 * M);</span>

3799 #endif // ZERO
3800 
3801   FILE *fp = fopen(&quot;/proc/meminfo&quot;, &quot;r&quot;);
3802   if (fp) {
3803     while (!feof(fp)) {
3804       int x = 0;
3805       char buf[16];
3806       if (fscanf(fp, &quot;Hugepagesize: %d&quot;, &amp;x) == 1) {
3807         if (x &amp;&amp; fgets(buf, sizeof(buf), fp) &amp;&amp; strcmp(buf, &quot; kB\n&quot;) == 0) {
3808           large_page_size = x * K;
3809           break;
3810         }
3811       } else {
3812         // skip to next line
3813         for (;;) {
3814           int ch = fgetc(fp);
3815           if (ch == EOF || ch == (int)&#39;\n&#39;) break;
3816         }
3817       }
3818     }
</pre>
</td>
</tr>
</table>
<center><a href="../bsd/os_bsd.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../posix/include/jvm_md.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
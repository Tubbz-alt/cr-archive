<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/os_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/zero/bytecodeInterpreter_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/os_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/os_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 205     init = true;
 206   }
 207   return privileges;
 208 }
 209 
 210 
 211 
 212 // Cpu architecture string
 213 #if   defined(ZERO)
 214 static char cpu_arch[] = ZERO_LIBARCH;
 215 #elif defined(IA64)
 216 static char cpu_arch[] = &quot;ia64&quot;;
 217 #elif defined(IA32)
 218 static char cpu_arch[] = &quot;i386&quot;;
 219 #elif defined(AMD64)
 220 static char cpu_arch[] = &quot;amd64&quot;;
 221 #elif defined(ARM)
 222 static char cpu_arch[] = &quot;arm&quot;;
 223 #elif defined(PPC32)
 224 static char cpu_arch[] = &quot;ppc&quot;;
<span class="line-removed"> 225 #elif defined(SPARC)</span>
<span class="line-removed"> 226   #ifdef _LP64</span>
<span class="line-removed"> 227 static char cpu_arch[] = &quot;sparcv9&quot;;</span>
<span class="line-removed"> 228   #else</span>
<span class="line-removed"> 229 static char cpu_arch[] = &quot;sparc&quot;;</span>
<span class="line-removed"> 230   #endif</span>
 231 #else
 232   #error Add appropriate cpu_arch setting
 233 #endif
 234 
 235 // Compiler variant
 236 #ifdef COMPILER2
 237   #define COMPILER_VARIANT &quot;server&quot;
 238 #else
 239   #define COMPILER_VARIANT &quot;client&quot;
 240 #endif
 241 
 242 
 243 void os::Bsd::initialize_system_info() {
 244   int mib[2];
 245   size_t len;
 246   int cpu_val;
 247   julong mem_val;
 248 
 249   // get processors count via hw.ncpus sysctl
 250   mib[0] = CTL_HW;
</pre>
<hr />
<pre>
1348     #define EM_PPC64        21              /* PowerPC64 */
1349   #endif
1350 
1351   #ifndef EM_S390
1352     #define EM_S390         22              /* IBM System/390 */
1353   #endif
1354 
1355   #ifndef EM_IA_64
1356     #define EM_IA_64        50              /* HP/Intel IA-64 */
1357   #endif
1358 
1359   #ifndef EM_X86_64
1360     #define EM_X86_64       62              /* AMD x86-64 */
1361   #endif
1362 
1363   static const arch_t arch_array[]={
1364     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1365     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1366     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1367     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},
<span class="line-removed">1368     {EM_SPARC,       EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},</span>
<span class="line-removed">1369     {EM_SPARC32PLUS, EM_SPARC,   ELFCLASS32, ELFDATA2MSB, (char*)&quot;Sparc 32&quot;},</span>
<span class="line-removed">1370     {EM_SPARCV9,     EM_SPARCV9, ELFCLASS64, ELFDATA2MSB, (char*)&quot;Sparc v9 64&quot;},</span>
1371     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1372     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1373     {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)&quot;ARM&quot;},
1374     {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},
1375     {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
1376     {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
1377     {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
1378     {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
1379     {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;}
1380   };
1381 
1382   #if  (defined IA32)
1383   static  Elf32_Half running_arch_code=EM_386;
1384   #elif   (defined AMD64)
1385   static  Elf32_Half running_arch_code=EM_X86_64;
1386   #elif  (defined IA64)
1387   static  Elf32_Half running_arch_code=EM_IA_64;
<span class="line-removed">1388   #elif  (defined __sparc) &amp;&amp; (defined _LP64)</span>
<span class="line-removed">1389   static  Elf32_Half running_arch_code=EM_SPARCV9;</span>
<span class="line-removed">1390   #elif  (defined __sparc) &amp;&amp; (!defined _LP64)</span>
<span class="line-removed">1391   static  Elf32_Half running_arch_code=EM_SPARC;</span>
1392   #elif  (defined __powerpc64__)
1393   static  Elf32_Half running_arch_code=EM_PPC64;
1394   #elif  (defined __powerpc__)
1395   static  Elf32_Half running_arch_code=EM_PPC;
1396   #elif  (defined ARM)
1397   static  Elf32_Half running_arch_code=EM_ARM;
1398   #elif  (defined S390)
1399   static  Elf32_Half running_arch_code=EM_S390;
1400   #elif  (defined ALPHA)
1401   static  Elf32_Half running_arch_code=EM_ALPHA;
1402   #elif  (defined MIPSEL)
1403   static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
1404   #elif  (defined PARISC)
1405   static  Elf32_Half running_arch_code=EM_PARISC;
1406   #elif  (defined MIPS)
1407   static  Elf32_Half running_arch_code=EM_MIPS;
1408   #elif  (defined M68K)
1409   static  Elf32_Half running_arch_code=EM_68K;
1410   #else
1411     #error Method os::dll_load requires that one of following is defined:\
<span class="line-modified">1412          IA32, AMD64, IA64, __sparc, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K</span>
1413   #endif
1414 
1415   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture
1416   // Obtain string descriptions for architectures
1417 
1418   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1419   int running_arch_index=-1;
1420 
1421   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1422     if (running_arch_code == arch_array[i].code) {
1423       running_arch_index    = i;
1424     }
1425     if (lib_arch.code == arch_array[i].code) {
1426       lib_arch.compat_class = arch_array[i].compat_class;
1427       lib_arch.name         = arch_array[i].name;
1428     }
1429   }
1430 
1431   assert(running_arch_index != -1,
1432          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 205     init = true;
 206   }
 207   return privileges;
 208 }
 209 
 210 
 211 
 212 // Cpu architecture string
 213 #if   defined(ZERO)
 214 static char cpu_arch[] = ZERO_LIBARCH;
 215 #elif defined(IA64)
 216 static char cpu_arch[] = &quot;ia64&quot;;
 217 #elif defined(IA32)
 218 static char cpu_arch[] = &quot;i386&quot;;
 219 #elif defined(AMD64)
 220 static char cpu_arch[] = &quot;amd64&quot;;
 221 #elif defined(ARM)
 222 static char cpu_arch[] = &quot;arm&quot;;
 223 #elif defined(PPC32)
 224 static char cpu_arch[] = &quot;ppc&quot;;






 225 #else
 226   #error Add appropriate cpu_arch setting
 227 #endif
 228 
 229 // Compiler variant
 230 #ifdef COMPILER2
 231   #define COMPILER_VARIANT &quot;server&quot;
 232 #else
 233   #define COMPILER_VARIANT &quot;client&quot;
 234 #endif
 235 
 236 
 237 void os::Bsd::initialize_system_info() {
 238   int mib[2];
 239   size_t len;
 240   int cpu_val;
 241   julong mem_val;
 242 
 243   // get processors count via hw.ncpus sysctl
 244   mib[0] = CTL_HW;
</pre>
<hr />
<pre>
1342     #define EM_PPC64        21              /* PowerPC64 */
1343   #endif
1344 
1345   #ifndef EM_S390
1346     #define EM_S390         22              /* IBM System/390 */
1347   #endif
1348 
1349   #ifndef EM_IA_64
1350     #define EM_IA_64        50              /* HP/Intel IA-64 */
1351   #endif
1352 
1353   #ifndef EM_X86_64
1354     #define EM_X86_64       62              /* AMD x86-64 */
1355   #endif
1356 
1357   static const arch_t arch_array[]={
1358     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1359     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)&quot;IA 32&quot;},
1360     {EM_IA_64,       EM_IA_64,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;IA 64&quot;},
1361     {EM_X86_64,      EM_X86_64,  ELFCLASS64, ELFDATA2LSB, (char*)&quot;AMD 64&quot;},



1362     {EM_PPC,         EM_PPC,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;Power PC 32&quot;},
1363     {EM_PPC64,       EM_PPC64,   ELFCLASS64, ELFDATA2MSB, (char*)&quot;Power PC 64&quot;},
1364     {EM_ARM,         EM_ARM,     ELFCLASS32,   ELFDATA2LSB, (char*)&quot;ARM&quot;},
1365     {EM_S390,        EM_S390,    ELFCLASSNONE, ELFDATA2MSB, (char*)&quot;IBM System/390&quot;},
1366     {EM_ALPHA,       EM_ALPHA,   ELFCLASS64, ELFDATA2LSB, (char*)&quot;Alpha&quot;},
1367     {EM_MIPS_RS3_LE, EM_MIPS_RS3_LE, ELFCLASS32, ELFDATA2LSB, (char*)&quot;MIPSel&quot;},
1368     {EM_MIPS,        EM_MIPS,    ELFCLASS32, ELFDATA2MSB, (char*)&quot;MIPS&quot;},
1369     {EM_PARISC,      EM_PARISC,  ELFCLASS32, ELFDATA2MSB, (char*)&quot;PARISC&quot;},
1370     {EM_68K,         EM_68K,     ELFCLASS32, ELFDATA2MSB, (char*)&quot;M68k&quot;}
1371   };
1372 
1373   #if  (defined IA32)
1374   static  Elf32_Half running_arch_code=EM_386;
1375   #elif   (defined AMD64)
1376   static  Elf32_Half running_arch_code=EM_X86_64;
1377   #elif  (defined IA64)
1378   static  Elf32_Half running_arch_code=EM_IA_64;




1379   #elif  (defined __powerpc64__)
1380   static  Elf32_Half running_arch_code=EM_PPC64;
1381   #elif  (defined __powerpc__)
1382   static  Elf32_Half running_arch_code=EM_PPC;
1383   #elif  (defined ARM)
1384   static  Elf32_Half running_arch_code=EM_ARM;
1385   #elif  (defined S390)
1386   static  Elf32_Half running_arch_code=EM_S390;
1387   #elif  (defined ALPHA)
1388   static  Elf32_Half running_arch_code=EM_ALPHA;
1389   #elif  (defined MIPSEL)
1390   static  Elf32_Half running_arch_code=EM_MIPS_RS3_LE;
1391   #elif  (defined PARISC)
1392   static  Elf32_Half running_arch_code=EM_PARISC;
1393   #elif  (defined MIPS)
1394   static  Elf32_Half running_arch_code=EM_MIPS;
1395   #elif  (defined M68K)
1396   static  Elf32_Half running_arch_code=EM_68K;
1397   #else
1398     #error Method os::dll_load requires that one of following is defined:\
<span class="line-modified">1399          IA32, AMD64, IA64, __powerpc__, ARM, S390, ALPHA, MIPS, MIPSEL, PARISC, M68K</span>
1400   #endif
1401 
1402   // Identify compatability class for VM&#39;s architecture and library&#39;s architecture
1403   // Obtain string descriptions for architectures
1404 
1405   arch_t lib_arch={elf_head.e_machine,0,elf_head.e_ident[EI_CLASS], elf_head.e_ident[EI_DATA], NULL};
1406   int running_arch_index=-1;
1407 
1408   for (unsigned int i=0; i &lt; ARRAY_SIZE(arch_array); i++) {
1409     if (running_arch_code == arch_array[i].code) {
1410       running_arch_index    = i;
1411     }
1412     if (lib_arch.code == arch_array[i].code) {
1413       lib_arch.compat_class = arch_array[i].compat_class;
1414       lib_arch.name         = arch_array[i].name;
1415     }
1416   }
1417 
1418   assert(running_arch_index != -1,
1419          &quot;Didn&#39;t find running architecture code (running_arch_code) in arch_array&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/zero/bytecodeInterpreter_zero.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/os_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/posix/os_posix.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="include/jvm_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/posix/os_posix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 441     // hard limit
 442     st-&gt;print(&quot;/&quot;);
 443     if (rlim.rlim_max == RLIM_INFINITY) { st-&gt;print(&quot;infinity&quot;); }
 444     else {
 445       if (output_k) { st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_max) / 1024); }
 446       else { st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_max)); }
 447     }
 448   }
 449 }
 450 
 451 void os::Posix::print_rlimit_info(outputStream* st) {
 452   st-&gt;print(&quot;rlimit (soft/hard):&quot;);
 453   print_rlimit(st, &quot;STACK&quot;, RLIMIT_STACK, true);
 454   print_rlimit(st, &quot;, CORE&quot;, RLIMIT_CORE, true);
 455 
 456 #if defined(AIX)
 457   st-&gt;print(&quot;, NPROC &quot;);
 458   st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));
 459 
 460   print_rlimit(st, &quot;, THREADS&quot;, RLIMIT_THREADS);
<span class="line-modified"> 461 #elif !defined(SOLARIS)</span>
 462   print_rlimit(st, &quot;, NPROC&quot;, RLIMIT_NPROC);
 463 #endif
 464 
 465   print_rlimit(st, &quot;, NOFILE&quot;, RLIMIT_NOFILE);
 466   print_rlimit(st, &quot;, AS&quot;, RLIMIT_AS, true);
 467   print_rlimit(st, &quot;, CPU&quot;, RLIMIT_CPU);
 468   print_rlimit(st, &quot;, DATA&quot;, RLIMIT_DATA, true);
 469 
 470   // maximum size of files that the process may create
 471   print_rlimit(st, &quot;, FSIZE&quot;, RLIMIT_FSIZE, true);
 472 
 473 #if defined(LINUX) || defined(__APPLE__)
 474   // maximum number of bytes of memory that may be locked into RAM
 475   // (rounded down to the nearest  multiple of system pagesize)
 476   print_rlimit(st, &quot;, MEMLOCK&quot;, RLIMIT_MEMLOCK, true);
 477 #endif
 478 
<span class="line-removed"> 479 #if defined(SOLARIS)</span>
<span class="line-removed"> 480   // maximum size of mapped address space of a process in bytes;</span>
<span class="line-removed"> 481   // if the limit is exceeded, mmap and brk fail</span>
<span class="line-removed"> 482   print_rlimit(st, &quot;, VMEM&quot;, RLIMIT_VMEM, true);</span>
<span class="line-removed"> 483 #endif</span>
<span class="line-removed"> 484 </span>
 485   // MacOS; The maximum size (in bytes) to which a process&#39;s resident set size may grow.
 486 #if defined(__APPLE__)
 487   print_rlimit(st, &quot;, RSS&quot;, RLIMIT_RSS, true);
 488 #endif
 489 
 490   st-&gt;cr();
 491 }
 492 
 493 void os::Posix::print_uname_info(outputStream* st) {
 494   // kernel
 495   st-&gt;print(&quot;uname:&quot;);
 496   struct utsname name;
 497   uname(&amp;name);
 498   st-&gt;print(&quot;%s &quot;, name.sysname);
 499 #ifdef ASSERT
 500   st-&gt;print(&quot;%s &quot;, name.nodename);
 501 #endif
 502   st-&gt;print(&quot;%s &quot;, name.release);
 503   st-&gt;print(&quot;%s &quot;, name.version);
 504   st-&gt;print(&quot;%s&quot;, name.machine);
</pre>
<hr />
<pre>
1088     { SIGILL,  ILL_BADIADDR, &quot;ILL_BADIADDR&quot;, &quot;Unimplemented instruction address&quot; },
1089     { SIGILL,  ILL_BREAK,    &quot;ILL_BREAK&quot;,    &quot;Application Break instruction&quot; },
1090 #endif
1091     { SIGFPE,  FPE_INTDIV,   &quot;FPE_INTDIV&quot;,   &quot;Integer divide by zero.&quot; },
1092     { SIGFPE,  FPE_INTOVF,   &quot;FPE_INTOVF&quot;,   &quot;Integer overflow.&quot; },
1093     { SIGFPE,  FPE_FLTDIV,   &quot;FPE_FLTDIV&quot;,   &quot;Floating-point divide by zero.&quot; },
1094     { SIGFPE,  FPE_FLTOVF,   &quot;FPE_FLTOVF&quot;,   &quot;Floating-point overflow.&quot; },
1095     { SIGFPE,  FPE_FLTUND,   &quot;FPE_FLTUND&quot;,   &quot;Floating-point underflow.&quot; },
1096     { SIGFPE,  FPE_FLTRES,   &quot;FPE_FLTRES&quot;,   &quot;Floating-point inexact result.&quot; },
1097     { SIGFPE,  FPE_FLTINV,   &quot;FPE_FLTINV&quot;,   &quot;Invalid floating-point operation.&quot; },
1098     { SIGFPE,  FPE_FLTSUB,   &quot;FPE_FLTSUB&quot;,   &quot;Subscript out of range.&quot; },
1099     { SIGSEGV, SEGV_MAPERR,  &quot;SEGV_MAPERR&quot;,  &quot;Address not mapped to object.&quot; },
1100     { SIGSEGV, SEGV_ACCERR,  &quot;SEGV_ACCERR&quot;,  &quot;Invalid permissions for mapped object.&quot; },
1101 #ifdef AIX
1102     // no explanation found what keyerr would be
1103     { SIGSEGV, SEGV_KEYERR,  &quot;SEGV_KEYERR&quot;,  &quot;key error&quot; },
1104 #endif
1105 #if defined(IA64) &amp;&amp; !defined(AIX)
1106     { SIGSEGV, SEGV_PSTKOVF, &quot;SEGV_PSTKOVF&quot;, &quot;Paragraph stack overflow&quot; },
1107 #endif
<span class="line-removed">1108 #if defined(__sparc) &amp;&amp; defined(SOLARIS)</span>
<span class="line-removed">1109 // define Solaris Sparc M7 ADI SEGV signals</span>
<span class="line-removed">1110 #if !defined(SEGV_ACCADI)</span>
<span class="line-removed">1111 #define SEGV_ACCADI 3</span>
<span class="line-removed">1112 #endif</span>
<span class="line-removed">1113     { SIGSEGV, SEGV_ACCADI,  &quot;SEGV_ACCADI&quot;,  &quot;ADI not enabled for mapped object.&quot; },</span>
<span class="line-removed">1114 #if !defined(SEGV_ACCDERR)</span>
<span class="line-removed">1115 #define SEGV_ACCDERR 4</span>
<span class="line-removed">1116 #endif</span>
<span class="line-removed">1117     { SIGSEGV, SEGV_ACCDERR, &quot;SEGV_ACCDERR&quot;, &quot;ADI disrupting exception.&quot; },</span>
<span class="line-removed">1118 #if !defined(SEGV_ACCPERR)</span>
<span class="line-removed">1119 #define SEGV_ACCPERR 5</span>
<span class="line-removed">1120 #endif</span>
<span class="line-removed">1121     { SIGSEGV, SEGV_ACCPERR, &quot;SEGV_ACCPERR&quot;, &quot;ADI precise exception.&quot; },</span>
<span class="line-removed">1122 #endif // defined(__sparc) &amp;&amp; defined(SOLARIS)</span>
1123     { SIGBUS,  BUS_ADRALN,   &quot;BUS_ADRALN&quot;,   &quot;Invalid address alignment.&quot; },
1124     { SIGBUS,  BUS_ADRERR,   &quot;BUS_ADRERR&quot;,   &quot;Nonexistent physical address.&quot; },
1125     { SIGBUS,  BUS_OBJERR,   &quot;BUS_OBJERR&quot;,   &quot;Object-specific hardware error.&quot; },
1126     { SIGTRAP, TRAP_BRKPT,   &quot;TRAP_BRKPT&quot;,   &quot;Process breakpoint.&quot; },
1127     { SIGTRAP, TRAP_TRACE,   &quot;TRAP_TRACE&quot;,   &quot;Process trace trap.&quot; },
1128     { SIGCHLD, CLD_EXITED,   &quot;CLD_EXITED&quot;,   &quot;Child has exited.&quot; },
1129     { SIGCHLD, CLD_KILLED,   &quot;CLD_KILLED&quot;,   &quot;Child has terminated abnormally and did not create a core file.&quot; },
1130     { SIGCHLD, CLD_DUMPED,   &quot;CLD_DUMPED&quot;,   &quot;Child has terminated abnormally and created a core file.&quot; },
1131     { SIGCHLD, CLD_TRAPPED,  &quot;CLD_TRAPPED&quot;,  &quot;Traced child has trapped.&quot; },
1132     { SIGCHLD, CLD_STOPPED,  &quot;CLD_STOPPED&quot;,  &quot;Child has stopped.&quot; },
1133     { SIGCHLD, CLD_CONTINUED,&quot;CLD_CONTINUED&quot;,&quot;Stopped child has continued.&quot; },
1134 #ifdef SIGPOLL
1135     { SIGPOLL, POLL_OUT,     &quot;POLL_OUT&quot;,     &quot;Output buffers available.&quot; },
1136     { SIGPOLL, POLL_MSG,     &quot;POLL_MSG&quot;,     &quot;Input message available.&quot; },
1137     { SIGPOLL, POLL_ERR,     &quot;POLL_ERR&quot;,     &quot;I/O error.&quot; },
1138     { SIGPOLL, POLL_PRI,     &quot;POLL_PRI&quot;,     &quot;High priority input available.&quot; },
1139     { SIGPOLL, POLL_HUP,     &quot;POLL_HUP&quot;,     &quot;Device disconnected. [Option End]&quot; },
1140 #endif
1141     { -1, -1, NULL, NULL }
1142   };
</pre>
<hr />
<pre>
1261       os-&gt;print(&quot; (invalid)&quot;);
1262     }
1263     os-&gt;print(&quot;, si_uid: %ld&quot;, (long) si-&gt;si_uid);
1264     if (sig == SIGCHLD) {
1265       os-&gt;print(&quot;, si_status: %d&quot;, si-&gt;si_status);
1266     }
1267   } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||
1268              sig == SIGTRAP || sig == SIGFPE) {
1269     os-&gt;print(&quot;, si_addr: &quot; PTR_FORMAT, p2i(si-&gt;si_addr));
1270 #ifdef SIGPOLL
1271   } else if (sig == SIGPOLL) {
1272     os-&gt;print(&quot;, si_band: %ld&quot;, si-&gt;si_band);
1273 #endif
1274   }
1275 
1276 }
1277 
1278 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1279   OSThread* osthread = thread-&gt;osthread();
1280   if (osthread) {
<span class="line-removed">1281 #if defined (SOLARIS)</span>
<span class="line-removed">1282     // Note: we cannot use pthread_kill on Solaris - not because</span>
<span class="line-removed">1283     // its missing, but because we do not have the pthread_t id.</span>
<span class="line-removed">1284     int status = thr_kill(osthread-&gt;thread_id(), sig);</span>
<span class="line-removed">1285 #else</span>
1286     int status = pthread_kill(osthread-&gt;pthread_id(), sig);
<span class="line-removed">1287 #endif</span>
1288     if (status == 0) {
1289       Events::log(Thread::current(), &quot;sent signal %d to Thread &quot; INTPTR_FORMAT &quot; because %s.&quot;,
1290                   sig, p2i(thread), reason);
1291       return true;
1292     }
1293   }
1294   return false;
1295 }
1296 
1297 int os::Posix::unblock_thread_signal_mask(const sigset_t *set) {
1298   return pthread_sigmask(SIG_UNBLOCK, set, NULL);
1299 }
1300 
1301 address os::Posix::ucontext_get_pc(const ucontext_t* ctx) {
1302 #if defined(AIX)
1303    return Aix::ucontext_get_pc(ctx);
1304 #elif defined(BSD)
1305    return Bsd::ucontext_get_pc(ctx);
1306 #elif defined(LINUX)
1307    return Linux::ucontext_get_pc(ctx);
<span class="line-removed">1308 #elif defined(SOLARIS)</span>
<span class="line-removed">1309    return Solaris::ucontext_get_pc(ctx);</span>
1310 #else
1311    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1312 #endif
1313 }
1314 
1315 void os::Posix::ucontext_set_pc(ucontext_t* ctx, address pc) {
1316 #if defined(AIX)
1317    Aix::ucontext_set_pc(ctx, pc);
1318 #elif defined(BSD)
1319    Bsd::ucontext_set_pc(ctx, pc);
1320 #elif defined(LINUX)
1321    Linux::ucontext_set_pc(ctx, pc);
<span class="line-removed">1322 #elif defined(SOLARIS)</span>
<span class="line-removed">1323    Solaris::ucontext_set_pc(ctx, pc);</span>
1324 #else
1325    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1326 #endif
1327 }
1328 
1329 char* os::Posix::describe_pthread_attr(char* buf, size_t buflen, const pthread_attr_t* attr) {
1330   size_t stack_size = 0;
1331   size_t guard_size = 0;
1332   int detachstate = 0;
1333   pthread_attr_getstacksize(attr, &amp;stack_size);
1334   pthread_attr_getguardsize(attr, &amp;guard_size);
1335   // Work around linux NPTL implementation error, see also os::create_thread() in os_linux.cpp.
1336   LINUX_ONLY(stack_size -= guard_size);
1337   pthread_attr_getdetachstate(attr, &amp;detachstate);
1338   jio_snprintf(buf, buflen, &quot;stacksize: &quot; SIZE_FORMAT &quot;k, guardsize: &quot; SIZE_FORMAT &quot;k, %s&quot;,
1339     stack_size / 1024, guard_size / 1024,
1340     (detachstate == PTHREAD_CREATE_DETACHED ? &quot;detached&quot; : &quot;joinable&quot;));
1341   return buf;
1342 }
1343 
</pre>
<hr />
<pre>
1408   }
1409 
1410   if (st1.st_dev == st2.st_dev &amp;&amp; st1.st_ino == st2.st_ino) {
1411     // same files
1412     is_same = true;
1413   }
1414   return is_same;
1415 }
1416 
1417 // Check minimum allowable stack sizes for thread creation and to initialize
1418 // the java system classes, including StackOverflowError - depends on page
1419 // size.
1420 // The space needed for frames during startup is platform dependent. It
1421 // depends on word size, platform calling conventions, C frame layout and
1422 // interpreter/C1/C2 design decisions. Therefore this is given in a
1423 // platform (os/cpu) dependent constant.
1424 // To this, space for guard mechanisms is added, which depends on the
1425 // page size which again depends on the concrete system the VM is running
1426 // on. Space for libc guard pages is not included in this size.
1427 jint os::Posix::set_minimum_stack_sizes() {
<span class="line-modified">1428   size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);</span>
1429 
1430   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
1431                                    JavaThread::stack_guard_zone_size() +
1432                                    JavaThread::stack_shadow_zone_size();
1433 
1434   _java_thread_min_stack_allowed = align_up(_java_thread_min_stack_allowed, vm_page_size());
1435   _java_thread_min_stack_allowed = MAX2(_java_thread_min_stack_allowed, os_min_stack_allowed);
1436 
1437   size_t stack_size_in_bytes = ThreadStackSize * K;
1438   if (stack_size_in_bytes != 0 &amp;&amp;
1439       stack_size_in_bytes &lt; _java_thread_min_stack_allowed) {
1440     // The &#39;-Xss&#39; and &#39;-XX:ThreadStackSize=N&#39; options both set
1441     // ThreadStackSize so we go with &quot;Java thread stack size&quot; instead
1442     // of &quot;ThreadStackSize&quot; to be more friendly.
1443     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
1444                   &quot;Specify at least &quot; SIZE_FORMAT &quot;k&quot;,
1445                   _java_thread_min_stack_allowed / K);
1446     return JNI_ERR;
1447   }
1448 
</pre>
<hr />
<pre>
1618 // but otherwise whatever default is used by the platform - generally the
1619 // time-of-day clock.
1620 static pthread_condattr_t _condAttr[1];
1621 
1622 // Shared mutexattr to explicitly set the type to PTHREAD_MUTEX_NORMAL as not
1623 // all systems (e.g. FreeBSD) map the default to &quot;normal&quot;.
1624 static pthread_mutexattr_t _mutexAttr[1];
1625 
1626 // common basic initialization that is always supported
1627 static void pthread_init_common(void) {
1628   int status;
1629   if ((status = pthread_condattr_init(_condAttr)) != 0) {
1630     fatal(&quot;pthread_condattr_init: %s&quot;, os::strerror(status));
1631   }
1632   if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
1633     fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
1634   }
1635   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
1636     fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
1637   }
<span class="line-modified">1638   // Solaris has it&#39;s own PlatformMutex, distinct from the one for POSIX.</span>
<span class="line-removed">1639   NOT_SOLARIS(os::PlatformMutex::init();)</span>
1640 }
1641 
<span class="line-removed">1642 #ifndef SOLARIS</span>
1643 sigset_t sigs;
1644 struct sigaction sigact[NSIG];
1645 
1646 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
1647   if (sigismember(&amp;sigs, sig)) {
1648     return &amp;sigact[sig];
1649   }
1650   return NULL;
1651 }
1652 
1653 void os::Posix::save_preinstalled_handler(int sig, struct sigaction&amp; oldAct) {
1654   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
1655   sigact[sig] = oldAct;
1656   sigaddset(&amp;sigs, sig);
1657 }
<span class="line-removed">1658 #endif</span>
1659 
1660 // Not all POSIX types and API&#39;s are available on all notionally &quot;posix&quot;
1661 // platforms. If we have build-time support then we will check for actual
1662 // runtime support via dlopen/dlsym lookup. This allows for running on an
1663 // older OS version compared to the build platform. But if there is no
1664 // build time support then there cannot be any runtime support as we do not
1665 // know what the runtime types would be (for example clockid_t might be an
1666 // int or int64_t).
1667 //
1668 #ifdef SUPPORTS_CLOCK_MONOTONIC
1669 
1670 // This means we have clockid_t, clock_gettime et al and CLOCK_MONOTONIC
1671 
1672 int (*os::Posix::_clock_gettime)(clockid_t, struct timespec *) = NULL;
1673 int (*os::Posix::_clock_getres)(clockid_t, struct timespec *) = NULL;
1674 
1675 static int (*_pthread_condattr_setclock)(pthread_condattr_t *, clockid_t) = NULL;
1676 
1677 static bool _use_clock_monotonic_condattr = false;
1678 
</pre>
<hr />
<pre>
1723         dlclose(handle);
1724       }
1725 #endif
1726     }
1727   }
1728 
1729   // 2. Check for pthread_condattr_setclock support.
1730 
1731   // libpthread is already loaded.
1732   int (*condattr_setclock_func)(pthread_condattr_t*, clockid_t) =
1733     (int (*)(pthread_condattr_t*, clockid_t))dlsym(RTLD_DEFAULT,
1734                                                    &quot;pthread_condattr_setclock&quot;);
1735   if (condattr_setclock_func != NULL) {
1736     _pthread_condattr_setclock = condattr_setclock_func;
1737   }
1738 
1739   // Now do general initialization.
1740 
1741   pthread_init_common();
1742 
<span class="line-removed">1743 #ifndef SOLARIS</span>
1744   int status;
1745   if (_pthread_condattr_setclock != NULL &amp;&amp; _clock_gettime != NULL) {
1746     if ((status = _pthread_condattr_setclock(_condAttr, CLOCK_MONOTONIC)) != 0) {
1747       if (status == EINVAL) {
1748         _use_clock_monotonic_condattr = false;
1749         warning(&quot;Unable to use monotonic clock with relative timed-waits&quot; \
1750                 &quot; - changes to the time-of-day clock may have adverse affects&quot;);
1751       } else {
1752         fatal(&quot;pthread_condattr_setclock: %s&quot;, os::strerror(status));
1753       }
1754     } else {
1755       _use_clock_monotonic_condattr = true;
1756     }
1757   }
<span class="line-removed">1758 #endif // !SOLARIS</span>
<span class="line-removed">1759 </span>
1760 }
1761 
1762 void os::Posix::init_2(void) {
<span class="line-removed">1763 #ifndef SOLARIS</span>
1764   log_info(os)(&quot;Use of CLOCK_MONOTONIC is%s supported&quot;,
1765                (_clock_gettime != NULL ? &quot;&quot; : &quot; not&quot;));
1766   log_info(os)(&quot;Use of pthread_condattr_setclock is%s supported&quot;,
1767                (_pthread_condattr_setclock != NULL ? &quot;&quot; : &quot; not&quot;));
1768   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with %s&quot;,
1769                _use_clock_monotonic_condattr ? &quot;CLOCK_MONOTONIC&quot; : &quot;the default clock&quot;);
1770   sigemptyset(&amp;sigs);
<span class="line-removed">1771 #endif // !SOLARIS</span>
1772 }
1773 
1774 #else // !SUPPORTS_CLOCK_MONOTONIC
1775 
1776 void os::Posix::init(void) {
1777   pthread_init_common();
1778 }
1779 
1780 void os::Posix::init_2(void) {
<span class="line-removed">1781 #ifndef SOLARIS</span>
1782   log_info(os)(&quot;Use of CLOCK_MONOTONIC is not supported&quot;);
1783   log_info(os)(&quot;Use of pthread_condattr_setclock is not supported&quot;);
1784   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with the default clock&quot;);
1785   sigemptyset(&amp;sigs);
<span class="line-removed">1786 #endif // !SOLARIS</span>
1787 }
1788 
1789 #endif // SUPPORTS_CLOCK_MONOTONIC
1790 
1791 // Utility to convert the given timeout to an absolute timespec
1792 // (based on the appropriate clock) to use with pthread_cond_timewait,
1793 // and sem_timedwait().
1794 // The clock queried here must be the clock used to manage the
1795 // timeout of the condition variable or semaphore.
1796 //
1797 // The passed in timeout value is either a relative time in nanoseconds
1798 // or an absolute time in milliseconds. A relative timeout will be
1799 // associated with CLOCK_MONOTONIC if available, unless the real-time clock
1800 // is explicitly requested; otherwise, or if absolute,
1801 // the default time-of-day clock will be used.
1802 
1803 // Given time is a 64-bit value and the time_t used in the timespec is
1804 // sometimes a signed-32-bit value we have to watch for overflow if times
1805 // way in the future are given. Further on Solaris versions
1806 // prior to 10 there is a restriction (see cond_timedwait) that the specified
</pre>
<hr />
<pre>
1907     DEBUG_ONLY(max_secs += now.tv_sec;)
1908   }
1909 
1910   assert(abstime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
1911   assert(abstime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
1912   assert(abstime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
1913   assert(abstime-&gt;tv_nsec &lt; NANOUNITS, &quot;tv_nsec &gt;= NANOUNITS&quot;);
1914 }
1915 
1916 // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
1917 // real-time (time-of-day) clock. Used by PosixSemaphore.
1918 void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
1919   to_abstime(abstime, millis_to_nanos_bounded(millis),
1920              false /* not absolute */,
1921              true  /* use real-time clock */);
1922 }
1923 
1924 // Shared pthread_mutex/cond based PlatformEvent implementation.
1925 // Not currently usable by Solaris.
1926 
<span class="line-removed">1927 #ifndef SOLARIS</span>
1928 
1929 // PlatformEvent
1930 //
1931 // Assumption:
1932 //    Only one parker can exist on an event, which is why we allocate
1933 //    them per-thread. Multiple unparkers can coexist.
1934 //
1935 // _event serves as a restricted-range semaphore.
1936 //   -1 : thread is blocked, i.e. there is a waiter
1937 //    0 : neutral: thread is running or ready,
1938 //        could have been signaled after a wait started
1939 //    1 : signaled - thread is running or ready
1940 //
1941 //    Having three states allows for some detection of bad usage - see
1942 //    comments on unpark().
1943 
1944 os::PlatformEvent::PlatformEvent() {
1945   int status = pthread_cond_init(_cond, _condAttr);
1946   assert_status(status == 0, status, &quot;cond_init&quot;);
1947   status = pthread_mutex_init(_mutex, _mutexAttr);
</pre>
<hr />
<pre>
2339     if (millis / MILLIUNITS &gt; MAX_SECS) {
2340       millis = jlong(MAX_SECS) * MILLIUNITS;
2341     }
2342     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);
2343 
2344     int ret = OS_TIMEOUT;
2345     int status = pthread_cond_timedwait(cond(), mutex(), &amp;abst);
2346     assert_status(status == 0 || status == ETIMEDOUT,
2347                   status, &quot;cond_timedwait&quot;);
2348     if (status == 0) {
2349       ret = OS_OK;
2350     }
2351     return ret;
2352   } else {
2353     int status = pthread_cond_wait(cond(), mutex());
2354     assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),
2355                   status, &quot;cond_wait&quot;);
2356     return OS_OK;
2357   }
2358 }
<span class="line-removed">2359 </span>
<span class="line-removed">2360 #endif // !SOLARIS</span>
</pre>
</td>
<td>
<hr />
<pre>
 441     // hard limit
 442     st-&gt;print(&quot;/&quot;);
 443     if (rlim.rlim_max == RLIM_INFINITY) { st-&gt;print(&quot;infinity&quot;); }
 444     else {
 445       if (output_k) { st-&gt;print(UINT64_FORMAT &quot;k&quot;, uint64_t(rlim.rlim_max) / 1024); }
 446       else { st-&gt;print(UINT64_FORMAT, uint64_t(rlim.rlim_max)); }
 447     }
 448   }
 449 }
 450 
 451 void os::Posix::print_rlimit_info(outputStream* st) {
 452   st-&gt;print(&quot;rlimit (soft/hard):&quot;);
 453   print_rlimit(st, &quot;STACK&quot;, RLIMIT_STACK, true);
 454   print_rlimit(st, &quot;, CORE&quot;, RLIMIT_CORE, true);
 455 
 456 #if defined(AIX)
 457   st-&gt;print(&quot;, NPROC &quot;);
 458   st-&gt;print(&quot;%d&quot;, sysconf(_SC_CHILD_MAX));
 459 
 460   print_rlimit(st, &quot;, THREADS&quot;, RLIMIT_THREADS);
<span class="line-modified"> 461 #else</span>
 462   print_rlimit(st, &quot;, NPROC&quot;, RLIMIT_NPROC);
 463 #endif
 464 
 465   print_rlimit(st, &quot;, NOFILE&quot;, RLIMIT_NOFILE);
 466   print_rlimit(st, &quot;, AS&quot;, RLIMIT_AS, true);
 467   print_rlimit(st, &quot;, CPU&quot;, RLIMIT_CPU);
 468   print_rlimit(st, &quot;, DATA&quot;, RLIMIT_DATA, true);
 469 
 470   // maximum size of files that the process may create
 471   print_rlimit(st, &quot;, FSIZE&quot;, RLIMIT_FSIZE, true);
 472 
 473 #if defined(LINUX) || defined(__APPLE__)
 474   // maximum number of bytes of memory that may be locked into RAM
 475   // (rounded down to the nearest  multiple of system pagesize)
 476   print_rlimit(st, &quot;, MEMLOCK&quot;, RLIMIT_MEMLOCK, true);
 477 #endif
 478 






 479   // MacOS; The maximum size (in bytes) to which a process&#39;s resident set size may grow.
 480 #if defined(__APPLE__)
 481   print_rlimit(st, &quot;, RSS&quot;, RLIMIT_RSS, true);
 482 #endif
 483 
 484   st-&gt;cr();
 485 }
 486 
 487 void os::Posix::print_uname_info(outputStream* st) {
 488   // kernel
 489   st-&gt;print(&quot;uname:&quot;);
 490   struct utsname name;
 491   uname(&amp;name);
 492   st-&gt;print(&quot;%s &quot;, name.sysname);
 493 #ifdef ASSERT
 494   st-&gt;print(&quot;%s &quot;, name.nodename);
 495 #endif
 496   st-&gt;print(&quot;%s &quot;, name.release);
 497   st-&gt;print(&quot;%s &quot;, name.version);
 498   st-&gt;print(&quot;%s&quot;, name.machine);
</pre>
<hr />
<pre>
1082     { SIGILL,  ILL_BADIADDR, &quot;ILL_BADIADDR&quot;, &quot;Unimplemented instruction address&quot; },
1083     { SIGILL,  ILL_BREAK,    &quot;ILL_BREAK&quot;,    &quot;Application Break instruction&quot; },
1084 #endif
1085     { SIGFPE,  FPE_INTDIV,   &quot;FPE_INTDIV&quot;,   &quot;Integer divide by zero.&quot; },
1086     { SIGFPE,  FPE_INTOVF,   &quot;FPE_INTOVF&quot;,   &quot;Integer overflow.&quot; },
1087     { SIGFPE,  FPE_FLTDIV,   &quot;FPE_FLTDIV&quot;,   &quot;Floating-point divide by zero.&quot; },
1088     { SIGFPE,  FPE_FLTOVF,   &quot;FPE_FLTOVF&quot;,   &quot;Floating-point overflow.&quot; },
1089     { SIGFPE,  FPE_FLTUND,   &quot;FPE_FLTUND&quot;,   &quot;Floating-point underflow.&quot; },
1090     { SIGFPE,  FPE_FLTRES,   &quot;FPE_FLTRES&quot;,   &quot;Floating-point inexact result.&quot; },
1091     { SIGFPE,  FPE_FLTINV,   &quot;FPE_FLTINV&quot;,   &quot;Invalid floating-point operation.&quot; },
1092     { SIGFPE,  FPE_FLTSUB,   &quot;FPE_FLTSUB&quot;,   &quot;Subscript out of range.&quot; },
1093     { SIGSEGV, SEGV_MAPERR,  &quot;SEGV_MAPERR&quot;,  &quot;Address not mapped to object.&quot; },
1094     { SIGSEGV, SEGV_ACCERR,  &quot;SEGV_ACCERR&quot;,  &quot;Invalid permissions for mapped object.&quot; },
1095 #ifdef AIX
1096     // no explanation found what keyerr would be
1097     { SIGSEGV, SEGV_KEYERR,  &quot;SEGV_KEYERR&quot;,  &quot;key error&quot; },
1098 #endif
1099 #if defined(IA64) &amp;&amp; !defined(AIX)
1100     { SIGSEGV, SEGV_PSTKOVF, &quot;SEGV_PSTKOVF&quot;, &quot;Paragraph stack overflow&quot; },
1101 #endif















1102     { SIGBUS,  BUS_ADRALN,   &quot;BUS_ADRALN&quot;,   &quot;Invalid address alignment.&quot; },
1103     { SIGBUS,  BUS_ADRERR,   &quot;BUS_ADRERR&quot;,   &quot;Nonexistent physical address.&quot; },
1104     { SIGBUS,  BUS_OBJERR,   &quot;BUS_OBJERR&quot;,   &quot;Object-specific hardware error.&quot; },
1105     { SIGTRAP, TRAP_BRKPT,   &quot;TRAP_BRKPT&quot;,   &quot;Process breakpoint.&quot; },
1106     { SIGTRAP, TRAP_TRACE,   &quot;TRAP_TRACE&quot;,   &quot;Process trace trap.&quot; },
1107     { SIGCHLD, CLD_EXITED,   &quot;CLD_EXITED&quot;,   &quot;Child has exited.&quot; },
1108     { SIGCHLD, CLD_KILLED,   &quot;CLD_KILLED&quot;,   &quot;Child has terminated abnormally and did not create a core file.&quot; },
1109     { SIGCHLD, CLD_DUMPED,   &quot;CLD_DUMPED&quot;,   &quot;Child has terminated abnormally and created a core file.&quot; },
1110     { SIGCHLD, CLD_TRAPPED,  &quot;CLD_TRAPPED&quot;,  &quot;Traced child has trapped.&quot; },
1111     { SIGCHLD, CLD_STOPPED,  &quot;CLD_STOPPED&quot;,  &quot;Child has stopped.&quot; },
1112     { SIGCHLD, CLD_CONTINUED,&quot;CLD_CONTINUED&quot;,&quot;Stopped child has continued.&quot; },
1113 #ifdef SIGPOLL
1114     { SIGPOLL, POLL_OUT,     &quot;POLL_OUT&quot;,     &quot;Output buffers available.&quot; },
1115     { SIGPOLL, POLL_MSG,     &quot;POLL_MSG&quot;,     &quot;Input message available.&quot; },
1116     { SIGPOLL, POLL_ERR,     &quot;POLL_ERR&quot;,     &quot;I/O error.&quot; },
1117     { SIGPOLL, POLL_PRI,     &quot;POLL_PRI&quot;,     &quot;High priority input available.&quot; },
1118     { SIGPOLL, POLL_HUP,     &quot;POLL_HUP&quot;,     &quot;Device disconnected. [Option End]&quot; },
1119 #endif
1120     { -1, -1, NULL, NULL }
1121   };
</pre>
<hr />
<pre>
1240       os-&gt;print(&quot; (invalid)&quot;);
1241     }
1242     os-&gt;print(&quot;, si_uid: %ld&quot;, (long) si-&gt;si_uid);
1243     if (sig == SIGCHLD) {
1244       os-&gt;print(&quot;, si_status: %d&quot;, si-&gt;si_status);
1245     }
1246   } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||
1247              sig == SIGTRAP || sig == SIGFPE) {
1248     os-&gt;print(&quot;, si_addr: &quot; PTR_FORMAT, p2i(si-&gt;si_addr));
1249 #ifdef SIGPOLL
1250   } else if (sig == SIGPOLL) {
1251     os-&gt;print(&quot;, si_band: %ld&quot;, si-&gt;si_band);
1252 #endif
1253   }
1254 
1255 }
1256 
1257 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
1258   OSThread* osthread = thread-&gt;osthread();
1259   if (osthread) {





1260     int status = pthread_kill(osthread-&gt;pthread_id(), sig);

1261     if (status == 0) {
1262       Events::log(Thread::current(), &quot;sent signal %d to Thread &quot; INTPTR_FORMAT &quot; because %s.&quot;,
1263                   sig, p2i(thread), reason);
1264       return true;
1265     }
1266   }
1267   return false;
1268 }
1269 
1270 int os::Posix::unblock_thread_signal_mask(const sigset_t *set) {
1271   return pthread_sigmask(SIG_UNBLOCK, set, NULL);
1272 }
1273 
1274 address os::Posix::ucontext_get_pc(const ucontext_t* ctx) {
1275 #if defined(AIX)
1276    return Aix::ucontext_get_pc(ctx);
1277 #elif defined(BSD)
1278    return Bsd::ucontext_get_pc(ctx);
1279 #elif defined(LINUX)
1280    return Linux::ucontext_get_pc(ctx);


1281 #else
1282    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1283 #endif
1284 }
1285 
1286 void os::Posix::ucontext_set_pc(ucontext_t* ctx, address pc) {
1287 #if defined(AIX)
1288    Aix::ucontext_set_pc(ctx, pc);
1289 #elif defined(BSD)
1290    Bsd::ucontext_set_pc(ctx, pc);
1291 #elif defined(LINUX)
1292    Linux::ucontext_set_pc(ctx, pc);


1293 #else
1294    VMError::report_and_die(&quot;unimplemented ucontext_get_pc&quot;);
1295 #endif
1296 }
1297 
1298 char* os::Posix::describe_pthread_attr(char* buf, size_t buflen, const pthread_attr_t* attr) {
1299   size_t stack_size = 0;
1300   size_t guard_size = 0;
1301   int detachstate = 0;
1302   pthread_attr_getstacksize(attr, &amp;stack_size);
1303   pthread_attr_getguardsize(attr, &amp;guard_size);
1304   // Work around linux NPTL implementation error, see also os::create_thread() in os_linux.cpp.
1305   LINUX_ONLY(stack_size -= guard_size);
1306   pthread_attr_getdetachstate(attr, &amp;detachstate);
1307   jio_snprintf(buf, buflen, &quot;stacksize: &quot; SIZE_FORMAT &quot;k, guardsize: &quot; SIZE_FORMAT &quot;k, %s&quot;,
1308     stack_size / 1024, guard_size / 1024,
1309     (detachstate == PTHREAD_CREATE_DETACHED ? &quot;detached&quot; : &quot;joinable&quot;));
1310   return buf;
1311 }
1312 
</pre>
<hr />
<pre>
1377   }
1378 
1379   if (st1.st_dev == st2.st_dev &amp;&amp; st1.st_ino == st2.st_ino) {
1380     // same files
1381     is_same = true;
1382   }
1383   return is_same;
1384 }
1385 
1386 // Check minimum allowable stack sizes for thread creation and to initialize
1387 // the java system classes, including StackOverflowError - depends on page
1388 // size.
1389 // The space needed for frames during startup is platform dependent. It
1390 // depends on word size, platform calling conventions, C frame layout and
1391 // interpreter/C1/C2 design decisions. Therefore this is given in a
1392 // platform (os/cpu) dependent constant.
1393 // To this, space for guard mechanisms is added, which depends on the
1394 // page size which again depends on the concrete system the VM is running
1395 // on. Space for libc guard pages is not included in this size.
1396 jint os::Posix::set_minimum_stack_sizes() {
<span class="line-modified">1397   size_t os_min_stack_allowed = PTHREAD_STACK_MIN;</span>
1398 
1399   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
1400                                    JavaThread::stack_guard_zone_size() +
1401                                    JavaThread::stack_shadow_zone_size();
1402 
1403   _java_thread_min_stack_allowed = align_up(_java_thread_min_stack_allowed, vm_page_size());
1404   _java_thread_min_stack_allowed = MAX2(_java_thread_min_stack_allowed, os_min_stack_allowed);
1405 
1406   size_t stack_size_in_bytes = ThreadStackSize * K;
1407   if (stack_size_in_bytes != 0 &amp;&amp;
1408       stack_size_in_bytes &lt; _java_thread_min_stack_allowed) {
1409     // The &#39;-Xss&#39; and &#39;-XX:ThreadStackSize=N&#39; options both set
1410     // ThreadStackSize so we go with &quot;Java thread stack size&quot; instead
1411     // of &quot;ThreadStackSize&quot; to be more friendly.
1412     tty-&gt;print_cr(&quot;\nThe Java thread stack size specified is too small. &quot;
1413                   &quot;Specify at least &quot; SIZE_FORMAT &quot;k&quot;,
1414                   _java_thread_min_stack_allowed / K);
1415     return JNI_ERR;
1416   }
1417 
</pre>
<hr />
<pre>
1587 // but otherwise whatever default is used by the platform - generally the
1588 // time-of-day clock.
1589 static pthread_condattr_t _condAttr[1];
1590 
1591 // Shared mutexattr to explicitly set the type to PTHREAD_MUTEX_NORMAL as not
1592 // all systems (e.g. FreeBSD) map the default to &quot;normal&quot;.
1593 static pthread_mutexattr_t _mutexAttr[1];
1594 
1595 // common basic initialization that is always supported
1596 static void pthread_init_common(void) {
1597   int status;
1598   if ((status = pthread_condattr_init(_condAttr)) != 0) {
1599     fatal(&quot;pthread_condattr_init: %s&quot;, os::strerror(status));
1600   }
1601   if ((status = pthread_mutexattr_init(_mutexAttr)) != 0) {
1602     fatal(&quot;pthread_mutexattr_init: %s&quot;, os::strerror(status));
1603   }
1604   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
1605     fatal(&quot;pthread_mutexattr_settype: %s&quot;, os::strerror(status));
1606   }
<span class="line-modified">1607   os::PlatformMutex::init();</span>

1608 }
1609 

1610 sigset_t sigs;
1611 struct sigaction sigact[NSIG];
1612 
1613 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
1614   if (sigismember(&amp;sigs, sig)) {
1615     return &amp;sigact[sig];
1616   }
1617   return NULL;
1618 }
1619 
1620 void os::Posix::save_preinstalled_handler(int sig, struct sigaction&amp; oldAct) {
1621   assert(sig &gt; 0 &amp;&amp; sig &lt; NSIG, &quot;vm signal out of expected range&quot;);
1622   sigact[sig] = oldAct;
1623   sigaddset(&amp;sigs, sig);
1624 }

1625 
1626 // Not all POSIX types and API&#39;s are available on all notionally &quot;posix&quot;
1627 // platforms. If we have build-time support then we will check for actual
1628 // runtime support via dlopen/dlsym lookup. This allows for running on an
1629 // older OS version compared to the build platform. But if there is no
1630 // build time support then there cannot be any runtime support as we do not
1631 // know what the runtime types would be (for example clockid_t might be an
1632 // int or int64_t).
1633 //
1634 #ifdef SUPPORTS_CLOCK_MONOTONIC
1635 
1636 // This means we have clockid_t, clock_gettime et al and CLOCK_MONOTONIC
1637 
1638 int (*os::Posix::_clock_gettime)(clockid_t, struct timespec *) = NULL;
1639 int (*os::Posix::_clock_getres)(clockid_t, struct timespec *) = NULL;
1640 
1641 static int (*_pthread_condattr_setclock)(pthread_condattr_t *, clockid_t) = NULL;
1642 
1643 static bool _use_clock_monotonic_condattr = false;
1644 
</pre>
<hr />
<pre>
1689         dlclose(handle);
1690       }
1691 #endif
1692     }
1693   }
1694 
1695   // 2. Check for pthread_condattr_setclock support.
1696 
1697   // libpthread is already loaded.
1698   int (*condattr_setclock_func)(pthread_condattr_t*, clockid_t) =
1699     (int (*)(pthread_condattr_t*, clockid_t))dlsym(RTLD_DEFAULT,
1700                                                    &quot;pthread_condattr_setclock&quot;);
1701   if (condattr_setclock_func != NULL) {
1702     _pthread_condattr_setclock = condattr_setclock_func;
1703   }
1704 
1705   // Now do general initialization.
1706 
1707   pthread_init_common();
1708 

1709   int status;
1710   if (_pthread_condattr_setclock != NULL &amp;&amp; _clock_gettime != NULL) {
1711     if ((status = _pthread_condattr_setclock(_condAttr, CLOCK_MONOTONIC)) != 0) {
1712       if (status == EINVAL) {
1713         _use_clock_monotonic_condattr = false;
1714         warning(&quot;Unable to use monotonic clock with relative timed-waits&quot; \
1715                 &quot; - changes to the time-of-day clock may have adverse affects&quot;);
1716       } else {
1717         fatal(&quot;pthread_condattr_setclock: %s&quot;, os::strerror(status));
1718       }
1719     } else {
1720       _use_clock_monotonic_condattr = true;
1721     }
1722   }


1723 }
1724 
1725 void os::Posix::init_2(void) {

1726   log_info(os)(&quot;Use of CLOCK_MONOTONIC is%s supported&quot;,
1727                (_clock_gettime != NULL ? &quot;&quot; : &quot; not&quot;));
1728   log_info(os)(&quot;Use of pthread_condattr_setclock is%s supported&quot;,
1729                (_pthread_condattr_setclock != NULL ? &quot;&quot; : &quot; not&quot;));
1730   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with %s&quot;,
1731                _use_clock_monotonic_condattr ? &quot;CLOCK_MONOTONIC&quot; : &quot;the default clock&quot;);
1732   sigemptyset(&amp;sigs);

1733 }
1734 
1735 #else // !SUPPORTS_CLOCK_MONOTONIC
1736 
1737 void os::Posix::init(void) {
1738   pthread_init_common();
1739 }
1740 
1741 void os::Posix::init_2(void) {

1742   log_info(os)(&quot;Use of CLOCK_MONOTONIC is not supported&quot;);
1743   log_info(os)(&quot;Use of pthread_condattr_setclock is not supported&quot;);
1744   log_info(os)(&quot;Relative timed-wait using pthread_cond_timedwait is associated with the default clock&quot;);
1745   sigemptyset(&amp;sigs);

1746 }
1747 
1748 #endif // SUPPORTS_CLOCK_MONOTONIC
1749 
1750 // Utility to convert the given timeout to an absolute timespec
1751 // (based on the appropriate clock) to use with pthread_cond_timewait,
1752 // and sem_timedwait().
1753 // The clock queried here must be the clock used to manage the
1754 // timeout of the condition variable or semaphore.
1755 //
1756 // The passed in timeout value is either a relative time in nanoseconds
1757 // or an absolute time in milliseconds. A relative timeout will be
1758 // associated with CLOCK_MONOTONIC if available, unless the real-time clock
1759 // is explicitly requested; otherwise, or if absolute,
1760 // the default time-of-day clock will be used.
1761 
1762 // Given time is a 64-bit value and the time_t used in the timespec is
1763 // sometimes a signed-32-bit value we have to watch for overflow if times
1764 // way in the future are given. Further on Solaris versions
1765 // prior to 10 there is a restriction (see cond_timedwait) that the specified
</pre>
<hr />
<pre>
1866     DEBUG_ONLY(max_secs += now.tv_sec;)
1867   }
1868 
1869   assert(abstime-&gt;tv_sec &gt;= 0, &quot;tv_sec &lt; 0&quot;);
1870   assert(abstime-&gt;tv_sec &lt;= max_secs, &quot;tv_sec &gt; max_secs&quot;);
1871   assert(abstime-&gt;tv_nsec &gt;= 0, &quot;tv_nsec &lt; 0&quot;);
1872   assert(abstime-&gt;tv_nsec &lt; NANOUNITS, &quot;tv_nsec &gt;= NANOUNITS&quot;);
1873 }
1874 
1875 // Create an absolute time &#39;millis&#39; milliseconds in the future, using the
1876 // real-time (time-of-day) clock. Used by PosixSemaphore.
1877 void os::Posix::to_RTC_abstime(timespec* abstime, int64_t millis) {
1878   to_abstime(abstime, millis_to_nanos_bounded(millis),
1879              false /* not absolute */,
1880              true  /* use real-time clock */);
1881 }
1882 
1883 // Shared pthread_mutex/cond based PlatformEvent implementation.
1884 // Not currently usable by Solaris.
1885 

1886 
1887 // PlatformEvent
1888 //
1889 // Assumption:
1890 //    Only one parker can exist on an event, which is why we allocate
1891 //    them per-thread. Multiple unparkers can coexist.
1892 //
1893 // _event serves as a restricted-range semaphore.
1894 //   -1 : thread is blocked, i.e. there is a waiter
1895 //    0 : neutral: thread is running or ready,
1896 //        could have been signaled after a wait started
1897 //    1 : signaled - thread is running or ready
1898 //
1899 //    Having three states allows for some detection of bad usage - see
1900 //    comments on unpark().
1901 
1902 os::PlatformEvent::PlatformEvent() {
1903   int status = pthread_cond_init(_cond, _condAttr);
1904   assert_status(status == 0, status, &quot;cond_init&quot;);
1905   status = pthread_mutex_init(_mutex, _mutexAttr);
</pre>
<hr />
<pre>
2297     if (millis / MILLIUNITS &gt; MAX_SECS) {
2298       millis = jlong(MAX_SECS) * MILLIUNITS;
2299     }
2300     to_abstime(&amp;abst, millis_to_nanos(millis), false, false);
2301 
2302     int ret = OS_TIMEOUT;
2303     int status = pthread_cond_timedwait(cond(), mutex(), &amp;abst);
2304     assert_status(status == 0 || status == ETIMEDOUT,
2305                   status, &quot;cond_timedwait&quot;);
2306     if (status == 0) {
2307       ret = OS_OK;
2308     }
2309     return ret;
2310   } else {
2311     int status = pthread_cond_wait(cond(), mutex());
2312     assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),
2313                   status, &quot;cond_wait&quot;);
2314     return OS_OK;
2315   }
2316 }


</pre>
</td>
</tr>
</table>
<center><a href="include/jvm_md.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
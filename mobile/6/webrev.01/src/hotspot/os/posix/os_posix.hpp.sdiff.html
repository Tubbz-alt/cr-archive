<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/posix/os_posix.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="os_posix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/posix/os_posix.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
155  * or anything else where we are not in control if we suddenly jump out.
156  */
157 class ThreadCrashProtection : public StackObj {
158 public:
159   static bool is_crash_protected(Thread* thr) {
160     return _crash_protection != NULL &amp;&amp; _protected_thread == thr;
161   }
162 
163   ThreadCrashProtection();
164   bool call(os::CrashProtectionCallback&amp; cb);
165 
166   static void check_crash_protection(int signal, Thread* thread);
167 private:
168   static Thread* _protected_thread;
169   static ThreadCrashProtection* _crash_protection;
170   static volatile intptr_t _crash_mux;
171   void restore();
172   sigjmp_buf _jmpbuf;
173 };
174 
<span class="line-removed">175 #ifndef SOLARIS</span>
<span class="line-removed">176 </span>
177 /*
178  * This is the platform-specific implementation underpinning
179  * the ParkEvent class, which itself underpins Java-level monitor
180  * operations. See park.hpp for details.
181  * These event objects are type-stable and immortal - we never delete them.
182  * Events are associated with a thread for the lifetime of the thread.
183  */
184 class PlatformEvent : public CHeapObj&lt;mtSynchronizer&gt; {
185  private:
186   double cachePad[4];        // Increase odds that _mutex is sole occupant of cache line
187   volatile int _event;       // Event count/permit: -1, 0 or 1
188   volatile int _nParked;     // Indicates if associated thread is blocked: 0 or 1
189   pthread_mutex_t _mutex[1]; // Native mutex for locking
190   pthread_cond_t  _cond[1];  // Native condition variable for blocking
191   double postPad[2];
192 
193  protected:       // TODO-FIXME: make dtor private
194   ~PlatformEvent() { guarantee(false, &quot;invariant&quot;); } // immortal so can&#39;t delete
195 
196  public:
</pre>
<hr />
<pre>
319 #else
320 
321   pthread_cond_t _cond;
322   pthread_cond_t* cond() { return &amp;_cond; }
323 
324  public:
325   PlatformMonitor();
326   ~PlatformMonitor();
327 
328 #endif // PLATFORM_MONITOR_IMPL_INDIRECT
329 
330  private:
331   NONCOPYABLE(PlatformMonitor);
332 
333  public:
334   int wait(jlong millis);
335   void notify();
336   void notify_all();
337 };
338 
<span class="line-removed">339 #endif // !SOLARIS</span>
<span class="line-removed">340 </span>
341 #endif // OS_POSIX_OS_POSIX_HPP
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
155  * or anything else where we are not in control if we suddenly jump out.
156  */
157 class ThreadCrashProtection : public StackObj {
158 public:
159   static bool is_crash_protected(Thread* thr) {
160     return _crash_protection != NULL &amp;&amp; _protected_thread == thr;
161   }
162 
163   ThreadCrashProtection();
164   bool call(os::CrashProtectionCallback&amp; cb);
165 
166   static void check_crash_protection(int signal, Thread* thread);
167 private:
168   static Thread* _protected_thread;
169   static ThreadCrashProtection* _crash_protection;
170   static volatile intptr_t _crash_mux;
171   void restore();
172   sigjmp_buf _jmpbuf;
173 };
174 


175 /*
176  * This is the platform-specific implementation underpinning
177  * the ParkEvent class, which itself underpins Java-level monitor
178  * operations. See park.hpp for details.
179  * These event objects are type-stable and immortal - we never delete them.
180  * Events are associated with a thread for the lifetime of the thread.
181  */
182 class PlatformEvent : public CHeapObj&lt;mtSynchronizer&gt; {
183  private:
184   double cachePad[4];        // Increase odds that _mutex is sole occupant of cache line
185   volatile int _event;       // Event count/permit: -1, 0 or 1
186   volatile int _nParked;     // Indicates if associated thread is blocked: 0 or 1
187   pthread_mutex_t _mutex[1]; // Native mutex for locking
188   pthread_cond_t  _cond[1];  // Native condition variable for blocking
189   double postPad[2];
190 
191  protected:       // TODO-FIXME: make dtor private
192   ~PlatformEvent() { guarantee(false, &quot;invariant&quot;); } // immortal so can&#39;t delete
193 
194  public:
</pre>
<hr />
<pre>
317 #else
318 
319   pthread_cond_t _cond;
320   pthread_cond_t* cond() { return &amp;_cond; }
321 
322  public:
323   PlatformMonitor();
324   ~PlatformMonitor();
325 
326 #endif // PLATFORM_MONITOR_IMPL_INDIRECT
327 
328  private:
329   NONCOPYABLE(PlatformMonitor);
330 
331  public:
332   int wait(jlong millis);
333   void notify();
334   void notify_all();
335 };
336 


337 #endif // OS_POSIX_OS_POSIX_HPP
</pre>
</td>
</tr>
</table>
<center><a href="os_posix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="os_posix.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
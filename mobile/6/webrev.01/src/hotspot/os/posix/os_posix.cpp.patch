diff a/src/hotspot/os/posix/os_posix.cpp b/src/hotspot/os/posix/os_posix.cpp
--- a/src/hotspot/os/posix/os_posix.cpp
+++ b/src/hotspot/os/posix/os_posix.cpp
@@ -456,11 +456,11 @@
 #if defined(AIX)
   st->print(", NPROC ");
   st->print("%d", sysconf(_SC_CHILD_MAX));
 
   print_rlimit(st, ", THREADS", RLIMIT_THREADS);
-#elif !defined(SOLARIS)
+#else
   print_rlimit(st, ", NPROC", RLIMIT_NPROC);
 #endif
 
   print_rlimit(st, ", NOFILE", RLIMIT_NOFILE);
   print_rlimit(st, ", AS", RLIMIT_AS, true);
@@ -474,16 +474,10 @@
   // maximum number of bytes of memory that may be locked into RAM
   // (rounded down to the nearest  multiple of system pagesize)
   print_rlimit(st, ", MEMLOCK", RLIMIT_MEMLOCK, true);
 #endif
 
-#if defined(SOLARIS)
-  // maximum size of mapped address space of a process in bytes;
-  // if the limit is exceeded, mmap and brk fail
-  print_rlimit(st, ", VMEM", RLIMIT_VMEM, true);
-#endif
-
   // MacOS; The maximum size (in bytes) to which a process's resident set size may grow.
 #if defined(__APPLE__)
   print_rlimit(st, ", RSS", RLIMIT_RSS, true);
 #endif
 
@@ -1103,25 +1097,10 @@
     { SIGSEGV, SEGV_KEYERR,  "SEGV_KEYERR",  "key error" },
 #endif
 #if defined(IA64) && !defined(AIX)
     { SIGSEGV, SEGV_PSTKOVF, "SEGV_PSTKOVF", "Paragraph stack overflow" },
 #endif
-#if defined(__sparc) && defined(SOLARIS)
-// define Solaris Sparc M7 ADI SEGV signals
-#if !defined(SEGV_ACCADI)
-#define SEGV_ACCADI 3
-#endif
-    { SIGSEGV, SEGV_ACCADI,  "SEGV_ACCADI",  "ADI not enabled for mapped object." },
-#if !defined(SEGV_ACCDERR)
-#define SEGV_ACCDERR 4
-#endif
-    { SIGSEGV, SEGV_ACCDERR, "SEGV_ACCDERR", "ADI disrupting exception." },
-#if !defined(SEGV_ACCPERR)
-#define SEGV_ACCPERR 5
-#endif
-    { SIGSEGV, SEGV_ACCPERR, "SEGV_ACCPERR", "ADI precise exception." },
-#endif // defined(__sparc) && defined(SOLARIS)
     { SIGBUS,  BUS_ADRALN,   "BUS_ADRALN",   "Invalid address alignment." },
     { SIGBUS,  BUS_ADRERR,   "BUS_ADRERR",   "Nonexistent physical address." },
     { SIGBUS,  BUS_OBJERR,   "BUS_OBJERR",   "Object-specific hardware error." },
     { SIGTRAP, TRAP_BRKPT,   "TRAP_BRKPT",   "Process breakpoint." },
     { SIGTRAP, TRAP_TRACE,   "TRAP_TRACE",   "Process trace trap." },
@@ -1276,17 +1255,11 @@
 }
 
 bool os::signal_thread(Thread* thread, int sig, const char* reason) {
   OSThread* osthread = thread->osthread();
   if (osthread) {
-#if defined (SOLARIS)
-    // Note: we cannot use pthread_kill on Solaris - not because
-    // its missing, but because we do not have the pthread_t id.
-    int status = thr_kill(osthread->thread_id(), sig);
-#else
     int status = pthread_kill(osthread->pthread_id(), sig);
-#endif
     if (status == 0) {
       Events::log(Thread::current(), "sent signal %d to Thread " INTPTR_FORMAT " because %s.",
                   sig, p2i(thread), reason);
       return true;
     }
@@ -1303,12 +1276,10 @@
    return Aix::ucontext_get_pc(ctx);
 #elif defined(BSD)
    return Bsd::ucontext_get_pc(ctx);
 #elif defined(LINUX)
    return Linux::ucontext_get_pc(ctx);
-#elif defined(SOLARIS)
-   return Solaris::ucontext_get_pc(ctx);
 #else
    VMError::report_and_die("unimplemented ucontext_get_pc");
 #endif
 }
 
@@ -1317,12 +1288,10 @@
    Aix::ucontext_set_pc(ctx, pc);
 #elif defined(BSD)
    Bsd::ucontext_set_pc(ctx, pc);
 #elif defined(LINUX)
    Linux::ucontext_set_pc(ctx, pc);
-#elif defined(SOLARIS)
-   Solaris::ucontext_set_pc(ctx, pc);
 #else
    VMError::report_and_die("unimplemented ucontext_get_pc");
 #endif
 }
 
@@ -1423,11 +1392,11 @@
 // platform (os/cpu) dependent constant.
 // To this, space for guard mechanisms is added, which depends on the
 // page size which again depends on the concrete system the VM is running
 // on. Space for libc guard pages is not included in this size.
 jint os::Posix::set_minimum_stack_sizes() {
-  size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);
+  size_t os_min_stack_allowed = PTHREAD_STACK_MIN;
 
   _java_thread_min_stack_allowed = _java_thread_min_stack_allowed +
                                    JavaThread::stack_guard_zone_size() +
                                    JavaThread::stack_shadow_zone_size();
 
@@ -1633,15 +1602,13 @@
     fatal("pthread_mutexattr_init: %s", os::strerror(status));
   }
   if ((status = pthread_mutexattr_settype(_mutexAttr, PTHREAD_MUTEX_NORMAL)) != 0) {
     fatal("pthread_mutexattr_settype: %s", os::strerror(status));
   }
-  // Solaris has it's own PlatformMutex, distinct from the one for POSIX.
-  NOT_SOLARIS(os::PlatformMutex::init();)
+  os::PlatformMutex::init();
 }
 
-#ifndef SOLARIS
 sigset_t sigs;
 struct sigaction sigact[NSIG];
 
 struct sigaction* os::Posix::get_preinstalled_handler(int sig) {
   if (sigismember(&sigs, sig)) {
@@ -1653,11 +1620,10 @@
 void os::Posix::save_preinstalled_handler(int sig, struct sigaction& oldAct) {
   assert(sig > 0 && sig < NSIG, "vm signal out of expected range");
   sigact[sig] = oldAct;
   sigaddset(&sigs, sig);
 }
-#endif
 
 // Not all POSIX types and API's are available on all notionally "posix"
 // platforms. If we have build-time support then we will check for actual
 // runtime support via dlopen/dlsym lookup. This allows for running on an
 // older OS version compared to the build platform. But if there is no
@@ -1738,11 +1704,10 @@
 
   // Now do general initialization.
 
   pthread_init_common();
 
-#ifndef SOLARIS
   int status;
   if (_pthread_condattr_setclock != NULL && _clock_gettime != NULL) {
     if ((status = _pthread_condattr_setclock(_condAttr, CLOCK_MONOTONIC)) != 0) {
       if (status == EINVAL) {
         _use_clock_monotonic_condattr = false;
@@ -1753,39 +1718,33 @@
       }
     } else {
       _use_clock_monotonic_condattr = true;
     }
   }
-#endif // !SOLARIS
-
 }
 
 void os::Posix::init_2(void) {
-#ifndef SOLARIS
   log_info(os)("Use of CLOCK_MONOTONIC is%s supported",
                (_clock_gettime != NULL ? "" : " not"));
   log_info(os)("Use of pthread_condattr_setclock is%s supported",
                (_pthread_condattr_setclock != NULL ? "" : " not"));
   log_info(os)("Relative timed-wait using pthread_cond_timedwait is associated with %s",
                _use_clock_monotonic_condattr ? "CLOCK_MONOTONIC" : "the default clock");
   sigemptyset(&sigs);
-#endif // !SOLARIS
 }
 
 #else // !SUPPORTS_CLOCK_MONOTONIC
 
 void os::Posix::init(void) {
   pthread_init_common();
 }
 
 void os::Posix::init_2(void) {
-#ifndef SOLARIS
   log_info(os)("Use of CLOCK_MONOTONIC is not supported");
   log_info(os)("Use of pthread_condattr_setclock is not supported");
   log_info(os)("Relative timed-wait using pthread_cond_timedwait is associated with the default clock");
   sigemptyset(&sigs);
-#endif // !SOLARIS
 }
 
 #endif // SUPPORTS_CLOCK_MONOTONIC
 
 // Utility to convert the given timeout to an absolute timespec
@@ -1922,11 +1881,10 @@
 }
 
 // Shared pthread_mutex/cond based PlatformEvent implementation.
 // Not currently usable by Solaris.
 
-#ifndef SOLARIS
 
 // PlatformEvent
 //
 // Assumption:
 //    Only one parker can exist on an event, which is why we allocate
@@ -2354,7 +2312,5 @@
     assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),
                   status, "cond_wait");
     return OS_OK;
   }
 }
-
-#endif // !SOLARIS

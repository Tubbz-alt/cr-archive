<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os/solaris/perfMemory_solaris.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/vmSymbols.hpp&quot;
  27 #include &quot;logging/log.hpp&quot;
  28 #include &quot;memory/allocation.inline.hpp&quot;
  29 #include &quot;memory/resourceArea.hpp&quot;
  30 #include &quot;oops/oop.inline.hpp&quot;
  31 #include &quot;os_solaris.inline.hpp&quot;
  32 #include &quot;runtime/handles.inline.hpp&quot;
  33 #include &quot;runtime/perfMemory.hpp&quot;
  34 #include &quot;services/memTracker.hpp&quot;
  35 #include &quot;utilities/exceptions.hpp&quot;
  36 
  37 // put OS-includes here
  38 #include &lt;sys/types.h&gt;
  39 #include &lt;sys/mman.h&gt;
  40 #include &lt;errno.h&gt;
  41 #include &lt;stdio.h&gt;
  42 #include &lt;unistd.h&gt;
  43 #include &lt;sys/stat.h&gt;
  44 #include &lt;signal.h&gt;
  45 #include &lt;procfs.h&gt;
  46 
  47 /* For POSIX-compliant getpwuid_r on Solaris */
  48 #define _POSIX_PTHREAD_SEMANTICS
  49 #include &lt;pwd.h&gt;
  50 
  51 static char* backing_store_file_name = NULL;  // name of the backing store
  52                                               // file, if successfully created.
  53 
  54 // Standard Memory Implementation Details
  55 
  56 // create the PerfData memory region in standard memory.
  57 //
  58 static char* create_standard_memory(size_t size) {
  59 
  60   // allocate an aligned chuck of memory
  61   char* mapAddress = os::reserve_memory(size);
  62 
  63   if (mapAddress == NULL) {
  64     return NULL;
  65   }
  66 
  67   // commit memory
  68   if (!os::commit_memory(mapAddress, size, !ExecMem)) {
  69     if (PrintMiscellaneous &amp;&amp; Verbose) {
  70       warning(&quot;Could not commit PerfData memory\n&quot;);
  71     }
  72     os::release_memory(mapAddress, size);
  73     return NULL;
  74   }
  75 
  76   return mapAddress;
  77 }
  78 
  79 // delete the PerfData memory region
  80 //
  81 static void delete_standard_memory(char* addr, size_t size) {
  82 
  83   // there are no persistent external resources to cleanup for standard
  84   // memory. since DestroyJavaVM does not support unloading of the JVM,
  85   // cleanup of the memory resource is not performed. The memory will be
  86   // reclaimed by the OS upon termination of the process.
  87   //
  88   return;
  89 }
  90 
  91 // save the specified memory region to the given file
  92 //
  93 // Note: this function might be called from signal handler (by os::abort()),
  94 // don&#39;t allocate heap memory.
  95 //
  96 static void save_memory_to_file(char* addr, size_t size) {
  97 
  98   const char* destfile = PerfMemory::get_perfdata_file_path();
  99   assert(destfile[0] != &#39;\0&#39;, &quot;invalid PerfData file path&quot;);
 100 
 101   int result;
 102 
 103   RESTARTABLE(::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IREAD|S_IWRITE),
 104               result);;
 105   if (result == OS_ERR) {
 106     if (PrintMiscellaneous &amp;&amp; Verbose) {
 107       warning(&quot;Could not create Perfdata save file: %s: %s\n&quot;,
 108               destfile, os::strerror(errno));
 109     }
 110   } else {
 111 
 112     int fd = result;
 113 
 114     for (size_t remaining = size; remaining &gt; 0;) {
 115 
 116       RESTARTABLE(::write(fd, addr, remaining), result);
 117       if (result == OS_ERR) {
 118         if (PrintMiscellaneous &amp;&amp; Verbose) {
 119           warning(&quot;Could not write Perfdata save file: %s: %s\n&quot;,
 120                   destfile, os::strerror(errno));
 121         }
 122         break;
 123       }
 124       remaining -= (size_t)result;
 125       addr += result;
 126     }
 127 
 128     result = ::close(fd);
 129     if (PrintMiscellaneous &amp;&amp; Verbose) {
 130       if (result == OS_ERR) {
 131         warning(&quot;Could not close %s: %s\n&quot;, destfile, os::strerror(errno));
 132       }
 133     }
 134   }
 135   FREE_C_HEAP_ARRAY(char, destfile);
 136 }
 137 
 138 
 139 // Shared Memory Implementation Details
 140 
 141 // Note: the solaris and linux shared memory implementation uses the mmap
 142 // interface with a backing store file to implement named shared memory.
 143 // Using the file system as the name space for shared memory allows a
 144 // common name space to be supported across a variety of platforms. It
 145 // also provides a name space that Java applications can deal with through
 146 // simple file apis.
 147 //
 148 // The solaris and linux implementations store the backing store file in
 149 // a user specific temporary directory located in the /tmp file system,
 150 // which is always a local file system and is sometimes a RAM based file
 151 // system.
 152 
 153 // return the user specific temporary directory name.
 154 //
 155 // the caller is expected to free the allocated memory.
 156 //
 157 static char* get_user_tmp_dir(const char* user) {
 158 
 159   const char* tmpdir = os::get_temp_directory();
 160   const char* perfdir = PERFDATA_NAME;
 161   size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;
 162   char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 163 
 164   // construct the path name to user specific tmp directory
 165   snprintf(dirname, nbytes, &quot;%s/%s_%s&quot;, tmpdir, perfdir, user);
 166 
 167   return dirname;
 168 }
 169 
 170 // convert the given file name into a process id. if the file
 171 // does not meet the file naming constraints, return 0.
 172 //
 173 static pid_t filename_to_pid(const char* filename) {
 174 
 175   // a filename that doesn&#39;t begin with a digit is not a
 176   // candidate for conversion.
 177   //
 178   if (!isdigit(*filename)) {
 179     return 0;
 180   }
 181 
 182   // check if file name can be converted to an integer without
 183   // any leftover characters.
 184   //
 185   char* remainder = NULL;
 186   errno = 0;
 187   pid_t pid = (pid_t)strtol(filename, &amp;remainder, 10);
 188 
 189   if (errno != 0) {
 190     return 0;
 191   }
 192 
 193   // check for left over characters. If any, then the filename is
 194   // not a candidate for conversion.
 195   //
 196   if (remainder != NULL &amp;&amp; *remainder != &#39;\0&#39;) {
 197     return 0;
 198   }
 199 
 200   // successful conversion, return the pid
 201   return pid;
 202 }
 203 
 204 
 205 // Check if the given statbuf is considered a secure directory for
 206 // the backing store files. Returns true if the directory is considered
 207 // a secure location. Returns false if the statbuf is a symbolic link or
 208 // if an error occurred.
 209 //
 210 static bool is_statbuf_secure(struct stat *statp) {
 211   if (S_ISLNK(statp-&gt;st_mode) || !S_ISDIR(statp-&gt;st_mode)) {
 212     // The path represents a link or some non-directory file type,
 213     // which is not what we expected. Declare it insecure.
 214     //
 215     return false;
 216   }
 217   // We have an existing directory, check if the permissions are safe.
 218   //
 219   if ((statp-&gt;st_mode &amp; (S_IWGRP|S_IWOTH)) != 0) {
 220     // The directory is open for writing and could be subjected
 221     // to a symlink or a hard link attack. Declare it insecure.
 222     //
 223     return false;
 224   }
 225   // If user is not root then see if the uid of the directory matches the effective uid of the process.
 226   uid_t euid = geteuid();
 227   if ((euid != 0) &amp;&amp; (statp-&gt;st_uid != euid)) {
 228     // The directory was not created by this user, declare it insecure.
 229     //
 230     return false;
 231   }
 232   return true;
 233 }
 234 
 235 
 236 // Check if the given path is considered a secure directory for
 237 // the backing store files. Returns true if the directory exists
 238 // and is considered a secure location. Returns false if the path
 239 // is a symbolic link or if an error occurred.
 240 //
 241 static bool is_directory_secure(const char* path) {
 242   struct stat statbuf;
 243   int result = 0;
 244 
 245   RESTARTABLE(::lstat(path, &amp;statbuf), result);
 246   if (result == OS_ERR) {
 247     return false;
 248   }
 249 
 250   // The path exists, see if it is secure.
 251   return is_statbuf_secure(&amp;statbuf);
 252 }
 253 
 254 
 255 // Check if the given directory file descriptor is considered a secure
 256 // directory for the backing store files. Returns true if the directory
 257 // exists and is considered a secure location. Returns false if the path
 258 // is a symbolic link or if an error occurred.
 259 //
 260 static bool is_dirfd_secure(int dir_fd) {
 261   struct stat statbuf;
 262   int result = 0;
 263 
 264   RESTARTABLE(::fstat(dir_fd, &amp;statbuf), result);
 265   if (result == OS_ERR) {
 266     return false;
 267   }
 268 
 269   // The path exists, now check its mode.
 270   return is_statbuf_secure(&amp;statbuf);
 271 }
 272 
 273 
 274 // Check to make sure fd1 and fd2 are referencing the same file system object.
 275 //
 276 static bool is_same_fsobject(int fd1, int fd2) {
 277   struct stat statbuf1;
 278   struct stat statbuf2;
 279   int result = 0;
 280 
 281   RESTARTABLE(::fstat(fd1, &amp;statbuf1), result);
 282   if (result == OS_ERR) {
 283     return false;
 284   }
 285   RESTARTABLE(::fstat(fd2, &amp;statbuf2), result);
 286   if (result == OS_ERR) {
 287     return false;
 288   }
 289 
 290   if ((statbuf1.st_ino == statbuf2.st_ino) &amp;&amp;
 291       (statbuf1.st_dev == statbuf2.st_dev)) {
 292     return true;
 293   } else {
 294     return false;
 295   }
 296 }
 297 
 298 
 299 // Open the directory of the given path and validate it.
 300 // Return a DIR * of the open directory.
 301 //
 302 static DIR *open_directory_secure(const char* dirname) {
 303   // Open the directory using open() so that it can be verified
 304   // to be secure by calling is_dirfd_secure(), opendir() and then check
 305   // to see if they are the same file system object.  This method does not
 306   // introduce a window of opportunity for the directory to be attacked that
 307   // calling opendir() and is_directory_secure() does.
 308   int result;
 309   DIR *dirp = NULL;
 310   RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);
 311   if (result == OS_ERR) {
 312     // Directory doesn&#39;t exist or is a symlink, so there is nothing to cleanup.
 313     if (PrintMiscellaneous &amp;&amp; Verbose) {
 314       if (errno == ELOOP) {
 315         warning(&quot;directory %s is a symlink and is not secure\n&quot;, dirname);
 316       } else {
 317         warning(&quot;could not open directory %s: %s\n&quot;, dirname, os::strerror(errno));
 318       }
 319     }
 320     return dirp;
 321   }
 322   int fd = result;
 323 
 324   // Determine if the open directory is secure.
 325   if (!is_dirfd_secure(fd)) {
 326     // The directory is not a secure directory.
 327     os::close(fd);
 328     return dirp;
 329   }
 330 
 331   // Open the directory.
 332   dirp = ::opendir(dirname);
 333   if (dirp == NULL) {
 334     // The directory doesn&#39;t exist, close fd and return.
 335     os::close(fd);
 336     return dirp;
 337   }
 338 
 339   // Check to make sure fd and dirp are referencing the same file system object.
 340   if (!is_same_fsobject(fd, dirp-&gt;d_fd)) {
 341     // The directory is not secure.
 342     os::close(fd);
 343     os::closedir(dirp);
 344     dirp = NULL;
 345     return dirp;
 346   }
 347 
 348   // Close initial open now that we know directory is secure
 349   os::close(fd);
 350 
 351   return dirp;
 352 }
 353 
 354 // NOTE: The code below uses fchdir(), open() and unlink() because
 355 // fdopendir(), openat() and unlinkat() are not supported on all
 356 // versions.  Once the support for fdopendir(), openat() and unlinkat()
 357 // is available on all supported versions the code can be changed
 358 // to use these functions.
 359 
 360 // Open the directory of the given path, validate it and set the
 361 // current working directory to it.
 362 // Return a DIR * of the open directory and the saved cwd fd.
 363 //
 364 static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {
 365 
 366   // Open the directory.
 367   DIR* dirp = open_directory_secure(dirname);
 368   if (dirp == NULL) {
 369     // Directory doesn&#39;t exist or is insecure, so there is nothing to cleanup.
 370     return dirp;
 371   }
 372   int fd = dirp-&gt;d_fd;
 373 
 374   // Open a fd to the cwd and save it off.
 375   int result;
 376   RESTARTABLE(::open(&quot;.&quot;, O_RDONLY), result);
 377   if (result == OS_ERR) {
 378     *saved_cwd_fd = -1;
 379   } else {
 380     *saved_cwd_fd = result;
 381   }
 382 
 383   // Set the current directory to dirname by using the fd of the directory and
 384   // handle errors, otherwise shared memory files will be created in cwd.
 385   result = fchdir(fd);
 386   if (result == OS_ERR) {
 387     if (PrintMiscellaneous &amp;&amp; Verbose) {
 388       warning(&quot;could not change to directory %s&quot;, dirname);
 389     }
 390     if (*saved_cwd_fd != -1) {
 391       ::close(*saved_cwd_fd);
 392       *saved_cwd_fd = -1;
 393     }
 394     // Close the directory.
 395     os::closedir(dirp);
 396     return NULL;
 397   } else {
 398     return dirp;
 399   }
 400 }
 401 
 402 // Close the directory and restore the current working directory.
 403 //
 404 static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {
 405 
 406   int result;
 407   // If we have a saved cwd change back to it and close the fd.
 408   if (saved_cwd_fd != -1) {
 409     result = fchdir(saved_cwd_fd);
 410     ::close(saved_cwd_fd);
 411   }
 412 
 413   // Close the directory.
 414   os::closedir(dirp);
 415 }
 416 
 417 // Check if the given file descriptor is considered a secure.
 418 //
 419 static bool is_file_secure(int fd, const char *filename) {
 420 
 421   int result;
 422   struct stat statbuf;
 423 
 424   // Determine if the file is secure.
 425   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
 426   if (result == OS_ERR) {
 427     if (PrintMiscellaneous &amp;&amp; Verbose) {
 428       warning(&quot;fstat failed on %s: %s\n&quot;, filename, os::strerror(errno));
 429     }
 430     return false;
 431   }
 432   if (statbuf.st_nlink &gt; 1) {
 433     // A file with multiple links is not expected.
 434     if (PrintMiscellaneous &amp;&amp; Verbose) {
 435       warning(&quot;file %s has multiple links\n&quot;, filename);
 436     }
 437     return false;
 438   }
 439   return true;
 440 }
 441 
 442 // return the user name for the given user id
 443 //
 444 // the caller is expected to free the allocated memory.
 445 //
 446 static char* get_user_name(uid_t uid) {
 447 
 448   struct passwd pwent;
 449 
 450   // determine the max pwbuf size from sysconf, and hardcode
 451   // a default if this not available through sysconf.
 452   //
 453   long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);
 454   if (bufsize == -1)
 455     bufsize = 1024;
 456 
 457   char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);
 458 
 459   struct passwd* p = NULL;
 460   int result = getpwuid_r(uid, &amp;pwent, pwbuf, (size_t)bufsize, &amp;p);
 461 
 462   if (p == NULL || p-&gt;pw_name == NULL || *(p-&gt;pw_name) == &#39;\0&#39;) {
 463     if (PrintMiscellaneous &amp;&amp; Verbose) {
 464       if (p == NULL) {
 465         warning(&quot;Could not retrieve passwd entry: %s\n&quot;,
 466                 os::strerror(errno));
 467       }
 468       else {
 469         warning(&quot;Could not determine user name: %s\n&quot;,
 470                 p-&gt;pw_name == NULL ? &quot;pw_name = NULL&quot; :
 471                                      &quot;pw_name zero length&quot;);
 472       }
 473     }
 474     FREE_C_HEAP_ARRAY(char, pwbuf);
 475     return NULL;
 476   }
 477 
 478   char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p-&gt;pw_name) + 1, mtInternal);
 479   strcpy(user_name, p-&gt;pw_name);
 480 
 481   FREE_C_HEAP_ARRAY(char, pwbuf);
 482   return user_name;
 483 }
 484 
 485 // return the name of the user that owns the process identified by vmid.
 486 //
 487 // This method uses a slow directory search algorithm to find the backing
 488 // store file for the specified vmid and returns the user name, as determined
 489 // by the user name suffix of the hsperfdata_&lt;username&gt; directory name.
 490 //
 491 // the caller is expected to free the allocated memory.
 492 //
 493 static char* get_user_name_slow(int vmid, TRAPS) {
 494 
 495   // short circuit the directory search if the process doesn&#39;t even exist.
 496   if (kill(vmid, 0) == OS_ERR) {
 497     if (errno == ESRCH) {
 498       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 499                   &quot;Process not found&quot;);
 500     }
 501     else /* EPERM */ {
 502       THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));
 503     }
 504   }
 505 
 506   // directory search
 507   char* oldest_user = NULL;
 508   time_t oldest_ctime = 0;
 509 
 510   const char* tmpdirname = os::get_temp_directory();
 511 
 512   // open the temp directory
 513   DIR* tmpdirp = os::opendir(tmpdirname);
 514 
 515   if (tmpdirp == NULL) {
 516     // Cannot open the directory to get the user name, return.
 517     return NULL;
 518   }
 519 
 520   // for each entry in the directory that matches the pattern hsperfdata_*,
 521   // open the directory and check if the file for the given vmid exists.
 522   // The file with the expected name and the latest creation date is used
 523   // to determine the user name for the process id.
 524   //
 525   struct dirent* dentry;
 526   errno = 0;
 527   while ((dentry = os::readdir(tmpdirp)) != NULL) {
 528 
 529     // check if the directory entry is a hsperfdata file
 530     if (strncmp(dentry-&gt;d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {
 531       continue;
 532     }
 533 
 534     char* usrdir_name = NEW_C_HEAP_ARRAY(char,
 535                   strlen(tmpdirname) + strlen(dentry-&gt;d_name) + 2, mtInternal);
 536     strcpy(usrdir_name, tmpdirname);
 537     strcat(usrdir_name, &quot;/&quot;);
 538     strcat(usrdir_name, dentry-&gt;d_name);
 539 
 540     // open the user directory
 541     DIR* subdirp = open_directory_secure(usrdir_name);
 542 
 543     if (subdirp == NULL) {
 544       FREE_C_HEAP_ARRAY(char, usrdir_name);
 545       continue;
 546     }
 547 
 548     // Since we don&#39;t create the backing store files in directories
 549     // pointed to by symbolic links, we also don&#39;t follow them when
 550     // looking for the files. We check for a symbolic link after the
 551     // call to opendir in order to eliminate a small window where the
 552     // symlink can be exploited.
 553     //
 554     if (!is_directory_secure(usrdir_name)) {
 555       FREE_C_HEAP_ARRAY(char, usrdir_name);
 556       os::closedir(subdirp);
 557       continue;
 558     }
 559 
 560     struct dirent* udentry;
 561     errno = 0;
 562     while ((udentry = os::readdir(subdirp)) != NULL) {
 563 
 564       if (filename_to_pid(udentry-&gt;d_name) == vmid) {
 565         struct stat statbuf;
 566         int result;
 567 
 568         char* filename = NEW_C_HEAP_ARRAY(char,
 569                  strlen(usrdir_name) + strlen(udentry-&gt;d_name) + 2, mtInternal);
 570 
 571         strcpy(filename, usrdir_name);
 572         strcat(filename, &quot;/&quot;);
 573         strcat(filename, udentry-&gt;d_name);
 574 
 575         // don&#39;t follow symbolic links for the file
 576         RESTARTABLE(::lstat(filename, &amp;statbuf), result);
 577         if (result == OS_ERR) {
 578            FREE_C_HEAP_ARRAY(char, filename);
 579            continue;
 580         }
 581 
 582         // skip over files that are not regular files.
 583         if (!S_ISREG(statbuf.st_mode)) {
 584           FREE_C_HEAP_ARRAY(char, filename);
 585           continue;
 586         }
 587 
 588         // compare and save filename with latest creation time
 589         if (statbuf.st_size &gt; 0 &amp;&amp; statbuf.st_ctime &gt; oldest_ctime) {
 590 
 591           if (statbuf.st_ctime &gt; oldest_ctime) {
 592             char* user = strchr(dentry-&gt;d_name, &#39;_&#39;) + 1;
 593 
 594             FREE_C_HEAP_ARRAY(char, oldest_user);
 595             oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);
 596 
 597             strcpy(oldest_user, user);
 598             oldest_ctime = statbuf.st_ctime;
 599           }
 600         }
 601 
 602         FREE_C_HEAP_ARRAY(char, filename);
 603       }
 604     }
 605     os::closedir(subdirp);
 606     FREE_C_HEAP_ARRAY(char, usrdir_name);
 607   }
 608   os::closedir(tmpdirp);
 609 
 610   return(oldest_user);
 611 }
 612 
 613 // return the name of the user that owns the JVM indicated by the given vmid.
 614 //
 615 static char* get_user_name(int vmid, TRAPS) {
 616 
 617   char psinfo_name[PATH_MAX];
 618   int result;
 619 
 620   snprintf(psinfo_name, PATH_MAX, &quot;/proc/%d/psinfo&quot;, vmid);
 621 
 622   RESTARTABLE(::open(psinfo_name, O_RDONLY), result);
 623 
 624   if (result != OS_ERR) {
 625     int fd = result;
 626 
 627     psinfo_t psinfo;
 628     char* addr = (char*)&amp;psinfo;
 629 
 630     for (size_t remaining = sizeof(psinfo_t); remaining &gt; 0;) {
 631 
 632       RESTARTABLE(::read(fd, addr, remaining), result);
 633       if (result == OS_ERR) {
 634         ::close(fd);
 635         THROW_MSG_0(vmSymbols::java_io_IOException(), &quot;Read error&quot;);
 636       } else {
 637         remaining-=result;
 638         addr+=result;
 639       }
 640     }
 641 
 642     ::close(fd);
 643 
 644     // get the user name for the effective user id of the process
 645     char* user_name = get_user_name(psinfo.pr_euid);
 646 
 647     return user_name;
 648   }
 649 
 650   if (result == OS_ERR &amp;&amp; errno == EACCES) {
 651 
 652     // In this case, the psinfo file for the process id existed,
 653     // but we didn&#39;t have permission to access it.
 654     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
 655                 os::strerror(errno));
 656   }
 657 
 658   // at this point, we don&#39;t know if the process id itself doesn&#39;t
 659   // exist or if the psinfo file doesn&#39;t exit. If the psinfo file
 660   // doesn&#39;t exist, then we are running on Solaris 2.5.1 or earlier.
 661   // since the structured procfs and old procfs interfaces can&#39;t be
 662   // mixed, we attempt to find the file through a directory search.
 663 
 664   return get_user_name_slow(vmid, THREAD);
 665 }
 666 
 667 // return the file name of the backing store file for the named
 668 // shared memory region for the given user name and vmid.
 669 //
 670 // the caller is expected to free the allocated memory.
 671 //
 672 static char* get_sharedmem_filename(const char* dirname, int vmid) {
 673 
 674   // add 2 for the file separator and a NULL terminator.
 675   size_t nbytes = strlen(dirname) + UINT_CHARS + 2;
 676 
 677   char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);
 678   snprintf(name, nbytes, &quot;%s/%d&quot;, dirname, vmid);
 679 
 680   return name;
 681 }
 682 
 683 
 684 // remove file
 685 //
 686 // this method removes the file specified by the given path
 687 //
 688 static void remove_file(const char* path) {
 689 
 690   int result;
 691 
 692   // if the file is a directory, the following unlink will fail. since
 693   // we don&#39;t expect to find directories in the user temp directory, we
 694   // won&#39;t try to handle this situation. even if accidentially or
 695   // maliciously planted, the directory&#39;s presence won&#39;t hurt anything.
 696   //
 697   RESTARTABLE(::unlink(path), result);
 698   if (PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; result == OS_ERR) {
 699     if (errno != ENOENT) {
 700       warning(&quot;Could not unlink shared memory backing&quot;
 701               &quot; store file %s : %s\n&quot;, path, os::strerror(errno));
 702     }
 703   }
 704 }
 705 
 706 
 707 // cleanup stale shared memory resources
 708 //
 709 // This method attempts to remove all stale shared memory files in
 710 // the named user temporary directory. It scans the named directory
 711 // for files matching the pattern ^$[0-9]*$. For each file found, the
 712 // process id is extracted from the file name and a test is run to
 713 // determine if the process is alive. If the process is not alive,
 714 // any stale file resources are removed.
 715 //
 716 static void cleanup_sharedmem_resources(const char* dirname) {
 717 
 718   int saved_cwd_fd;
 719   // open the directory
 720   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 721   if (dirp == NULL) {
 722     // directory doesn&#39;t exist or is insecure, so there is nothing to cleanup
 723     return;
 724   }
 725 
 726   // for each entry in the directory that matches the expected file
 727   // name pattern, determine if the file resources are stale and if
 728   // so, remove the file resources. Note, instrumented HotSpot processes
 729   // for this user may start and/or terminate during this search and
 730   // remove or create new files in this directory. The behavior of this
 731   // loop under these conditions is dependent upon the implementation of
 732   // opendir/readdir.
 733   //
 734   struct dirent* entry;
 735   errno = 0;
 736   while ((entry = os::readdir(dirp)) != NULL) {
 737 
 738     pid_t pid = filename_to_pid(entry-&gt;d_name);
 739 
 740     if (pid == 0) {
 741 
 742       if (strcmp(entry-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry-&gt;d_name, &quot;..&quot;) != 0) {
 743 
 744         // attempt to remove all unexpected files, except &quot;.&quot; and &quot;..&quot;
 745         unlink(entry-&gt;d_name);
 746       }
 747 
 748       errno = 0;
 749       continue;
 750     }
 751 
 752     // we now have a file name that converts to a valid integer
 753     // that could represent a process id . if this process id
 754     // matches the current process id or the process is not running,
 755     // then remove the stale file resources.
 756     //
 757     // process liveness is detected by sending signal number 0 to
 758     // the process id (see kill(2)). if kill determines that the
 759     // process does not exist, then the file resources are removed.
 760     // if kill determines that that we don&#39;t have permission to
 761     // signal the process, then the file resources are assumed to
 762     // be stale and are removed because the resources for such a
 763     // process should be in a different user specific directory.
 764     //
 765     if ((pid == os::current_process_id()) ||
 766         (kill(pid, 0) == OS_ERR &amp;&amp; (errno == ESRCH || errno == EPERM))) {
 767 
 768         unlink(entry-&gt;d_name);
 769     }
 770     errno = 0;
 771   }
 772 
 773   // close the directory and reset the current working directory
 774   close_directory_secure_cwd(dirp, saved_cwd_fd);
 775 }
 776 
 777 // make the user specific temporary directory. Returns true if
 778 // the directory exists and is secure upon return. Returns false
 779 // if the directory exists but is either a symlink, is otherwise
 780 // insecure, or if an error occurred.
 781 //
 782 static bool make_user_tmp_dir(const char* dirname) {
 783 
 784   // create the directory with 0755 permissions. note that the directory
 785   // will be owned by euid::egid, which may not be the same as uid::gid.
 786   //
 787   if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {
 788     if (errno == EEXIST) {
 789       // The directory already exists and was probably created by another
 790       // JVM instance. However, this could also be the result of a
 791       // deliberate symlink. Verify that the existing directory is safe.
 792       //
 793       if (!is_directory_secure(dirname)) {
 794         // directory is not secure
 795         if (PrintMiscellaneous &amp;&amp; Verbose) {
 796           warning(&quot;%s directory is insecure\n&quot;, dirname);
 797         }
 798         return false;
 799       }
 800     }
 801     else {
 802       // we encountered some other failure while attempting
 803       // to create the directory
 804       //
 805       if (PrintMiscellaneous &amp;&amp; Verbose) {
 806         warning(&quot;could not create directory %s: %s\n&quot;,
 807                 dirname, os::strerror(errno));
 808       }
 809       return false;
 810     }
 811   }
 812   return true;
 813 }
 814 
 815 // create the shared memory file resources
 816 //
 817 // This method creates the shared memory file with the given size
 818 // This method also creates the user specific temporary directory, if
 819 // it does not yet exist.
 820 //
 821 static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {
 822 
 823   // make the user temporary directory
 824   if (!make_user_tmp_dir(dirname)) {
 825     // could not make/find the directory or the found directory
 826     // was not secure
 827     return -1;
 828   }
 829 
 830   int saved_cwd_fd;
 831   // open the directory and set the current working directory to it
 832   DIR* dirp = open_directory_secure_cwd(dirname, &amp;saved_cwd_fd);
 833   if (dirp == NULL) {
 834     // Directory doesn&#39;t exist or is insecure, so cannot create shared
 835     // memory file.
 836     return -1;
 837   }
 838 
 839   // Open the filename in the current directory.
 840   // Cannot use O_TRUNC here; truncation of an existing file has to happen
 841   // after the is_file_secure() check below.
 842   int result;
 843   RESTARTABLE(::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IREAD|S_IWRITE), result);
 844   if (result == OS_ERR) {
 845     if (PrintMiscellaneous &amp;&amp; Verbose) {
 846       if (errno == ELOOP) {
 847         warning(&quot;file %s is a symlink and is not secure\n&quot;, filename);
 848       } else {
 849         warning(&quot;could not create file %s: %s\n&quot;, filename, os::strerror(errno));
 850       }
 851     }
 852     // close the directory and reset the current working directory
 853     close_directory_secure_cwd(dirp, saved_cwd_fd);
 854 
 855     return -1;
 856   }
 857   // close the directory and reset the current working directory
 858   close_directory_secure_cwd(dirp, saved_cwd_fd);
 859 
 860   // save the file descriptor
 861   int fd = result;
 862 
 863   // check to see if the file is secure
 864   if (!is_file_secure(fd, filename)) {
 865     ::close(fd);
 866     return -1;
 867   }
 868 
 869   // truncate the file to get rid of any existing data
 870   RESTARTABLE(::ftruncate(fd, (off_t)0), result);
 871   if (result == OS_ERR) {
 872     if (PrintMiscellaneous &amp;&amp; Verbose) {
 873       warning(&quot;could not truncate shared memory file: %s\n&quot;, os::strerror(errno));
 874     }
 875     ::close(fd);
 876     return -1;
 877   }
 878   // set the file size
 879   RESTARTABLE(::ftruncate(fd, (off_t)size), result);
 880   if (result == OS_ERR) {
 881     if (PrintMiscellaneous &amp;&amp; Verbose) {
 882       warning(&quot;could not set shared memory file size: %s\n&quot;, os::strerror(errno));
 883     }
 884     ::close(fd);
 885     return -1;
 886   }
 887 
 888   return fd;
 889 }
 890 
 891 // open the shared memory file for the given user and vmid. returns
 892 // the file descriptor for the open file or -1 if the file could not
 893 // be opened.
 894 //
 895 static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {
 896 
 897   // open the file
 898   int result;
 899   RESTARTABLE(::open(filename, oflags), result);
 900   if (result == OS_ERR) {
 901     if (errno == ENOENT) {
 902       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 903                  &quot;Process not found&quot;, OS_ERR);
 904     }
 905     else if (errno == EACCES) {
 906       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 907                  &quot;Permission denied&quot;, OS_ERR);
 908     }
 909     else {
 910       THROW_MSG_(vmSymbols::java_io_IOException(),
 911                  os::strerror(errno), OS_ERR);
 912     }
 913   }
 914   int fd = result;
 915 
 916   // check to see if the file is secure
 917   if (!is_file_secure(fd, filename)) {
 918     ::close(fd);
 919     return -1;
 920   }
 921 
 922   return fd;
 923 }
 924 
 925 // create a named shared memory region. returns the address of the
 926 // memory region on success or NULL on failure. A return value of
 927 // NULL will ultimately disable the shared memory feature.
 928 //
 929 // On Solaris, the name space for shared memory objects
 930 // is the file system name space.
 931 //
 932 // A monitoring application attaching to a JVM does not need to know
 933 // the file system name of the shared memory object. However, it may
 934 // be convenient for applications to discover the existence of newly
 935 // created and terminating JVMs by watching the file system name space
 936 // for files being created or removed.
 937 //
 938 static char* mmap_create_shared(size_t size) {
 939 
 940   int result;
 941   int fd;
 942   char* mapAddress;
 943 
 944   int vmid = os::current_process_id();
 945 
 946   char* user_name = get_user_name(geteuid());
 947 
 948   if (user_name == NULL)
 949     return NULL;
 950 
 951   char* dirname = get_user_tmp_dir(user_name);
 952   char* filename = get_sharedmem_filename(dirname, vmid);
 953 
 954   // get the short filename
 955   char* short_filename = strrchr(filename, &#39;/&#39;);
 956   if (short_filename == NULL) {
 957     short_filename = filename;
 958   } else {
 959     short_filename++;
 960   }
 961 
 962   // cleanup any stale shared memory files
 963   cleanup_sharedmem_resources(dirname);
 964 
 965   assert(((size &gt; 0) &amp;&amp; (size % os::vm_page_size() == 0)),
 966          &quot;unexpected PerfMemory region size&quot;);
 967 
 968   fd = create_sharedmem_resources(dirname, short_filename, size);
 969 
 970   FREE_C_HEAP_ARRAY(char, user_name);
 971   FREE_C_HEAP_ARRAY(char, dirname);
 972 
 973   if (fd == -1) {
 974     FREE_C_HEAP_ARRAY(char, filename);
 975     return NULL;
 976   }
 977 
 978   mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
 979 
 980   result = ::close(fd);
 981   assert(result != OS_ERR, &quot;could not close file&quot;);
 982 
 983   if (mapAddress == MAP_FAILED) {
 984     if (PrintMiscellaneous &amp;&amp; Verbose) {
 985       warning(&quot;mmap failed -  %s\n&quot;, os::strerror(errno));
 986     }
 987     remove_file(filename);
 988     FREE_C_HEAP_ARRAY(char, filename);
 989     return NULL;
 990   }
 991 
 992   // save the file name for use in delete_shared_memory()
 993   backing_store_file_name = filename;
 994 
 995   // clear the shared memory region
 996   (void)::memset((void*) mapAddress, 0, size);
 997 
 998   // it does not go through os api, the operation has to record from here
 999   MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress,
1000     size, CURRENT_PC, mtInternal);
1001 
1002   return mapAddress;
1003 }
1004 
1005 // release a named shared memory region
1006 //
1007 static void unmap_shared(char* addr, size_t bytes) {
1008   os::release_memory(addr, bytes);
1009 }
1010 
1011 // create the PerfData memory region in shared memory.
1012 //
1013 static char* create_shared_memory(size_t size) {
1014 
1015   // create the shared memory region.
1016   return mmap_create_shared(size);
1017 }
1018 
1019 // delete the shared PerfData memory region
1020 //
1021 static void delete_shared_memory(char* addr, size_t size) {
1022 
1023   // cleanup the persistent shared memory resources. since DestroyJavaVM does
1024   // not support unloading of the JVM, unmapping of the memory resource is
1025   // not performed. The memory will be reclaimed by the OS upon termination of
1026   // the process. The backing store file is deleted from the file system.
1027 
1028   assert(!PerfDisableSharedMem, &quot;shouldn&#39;t be here&quot;);
1029 
1030   if (backing_store_file_name != NULL) {
1031     remove_file(backing_store_file_name);
1032     // Don&#39;t.. Free heap memory could deadlock os::abort() if it is called
1033     // from signal handler. OS will reclaim the heap memory.
1034     // FREE_C_HEAP_ARRAY(char, backing_store_file_name);
1035     backing_store_file_name = NULL;
1036   }
1037 }
1038 
1039 // return the size of the file for the given file descriptor
1040 // or 0 if it is not a valid size for a shared memory file
1041 //
1042 static size_t sharedmem_filesize(int fd, TRAPS) {
1043 
1044   struct stat statbuf;
1045   int result;
1046 
1047   RESTARTABLE(::fstat(fd, &amp;statbuf), result);
1048   if (result == OS_ERR) {
1049     if (PrintMiscellaneous &amp;&amp; Verbose) {
1050       warning(&quot;fstat failed: %s\n&quot;, os::strerror(errno));
1051     }
1052     THROW_MSG_0(vmSymbols::java_io_IOException(),
1053                 &quot;Could not determine PerfMemory size&quot;);
1054   }
1055 
1056   if ((statbuf.st_size == 0) ||
1057      ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {
1058     THROW_MSG_0(vmSymbols::java_io_IOException(),
1059                 &quot;Invalid PerfMemory size&quot;);
1060   }
1061 
1062   return (size_t)statbuf.st_size;
1063 }
1064 
1065 // attach to a named shared memory region.
1066 //
1067 static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {
1068 
1069   char* mapAddress;
1070   int result;
1071   int fd;
1072   size_t size = 0;
1073   const char* luser = NULL;
1074 
1075   int mmap_prot;
1076   int file_flags;
1077 
1078   ResourceMark rm;
1079 
1080   // map the high level access mode to the appropriate permission
1081   // constructs for the file and the shared memory mapping.
1082   if (mode == PerfMemory::PERF_MODE_RO) {
1083     mmap_prot = PROT_READ;
1084     file_flags = O_RDONLY | O_NOFOLLOW;
1085   }
1086   else if (mode == PerfMemory::PERF_MODE_RW) {
1087 #ifdef LATER
1088     mmap_prot = PROT_READ | PROT_WRITE;
1089     file_flags = O_RDWR | O_NOFOLLOW;
1090 #else
1091     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1092               &quot;Unsupported access mode&quot;);
1093 #endif
1094   }
1095   else {
1096     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1097               &quot;Illegal access mode&quot;);
1098   }
1099 
1100   if (user == NULL || strlen(user) == 0) {
1101     luser = get_user_name(vmid, CHECK);
1102   }
1103   else {
1104     luser = user;
1105   }
1106 
1107   if (luser == NULL) {
1108     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1109               &quot;Could not map vmid to user Name&quot;);
1110   }
1111 
1112   char* dirname = get_user_tmp_dir(luser);
1113 
1114   // since we don&#39;t follow symbolic links when creating the backing
1115   // store file, we don&#39;t follow them when attaching either.
1116   //
1117   if (!is_directory_secure(dirname)) {
1118     FREE_C_HEAP_ARRAY(char, dirname);
1119     if (luser != user) {
1120       FREE_C_HEAP_ARRAY(char, luser);
1121     }
1122     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1123               &quot;Process not found&quot;);
1124   }
1125 
1126   char* filename = get_sharedmem_filename(dirname, vmid);
1127 
1128   // copy heap memory to resource memory. the open_sharedmem_file
1129   // method below need to use the filename, but could throw an
1130   // exception. using a resource array prevents the leak that
1131   // would otherwise occur.
1132   char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);
1133   strcpy(rfilename, filename);
1134 
1135   // free the c heap resources that are no longer needed
1136   if (luser != user) FREE_C_HEAP_ARRAY(char, luser);
1137   FREE_C_HEAP_ARRAY(char, dirname);
1138   FREE_C_HEAP_ARRAY(char, filename);
1139 
1140   // open the shared memory file for the give vmid
1141   fd = open_sharedmem_file(rfilename, file_flags, THREAD);
1142 
1143   if (fd == OS_ERR) {
1144     return;
1145   }
1146 
1147   if (HAS_PENDING_EXCEPTION) {
1148     ::close(fd);
1149     return;
1150   }
1151 
1152   if (*sizep == 0) {
1153     size = sharedmem_filesize(fd, CHECK);
1154   } else {
1155     size = *sizep;
1156   }
1157 
1158   assert(size &gt; 0, &quot;unexpected size &lt;= 0&quot;);
1159 
1160   mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);
1161 
1162   result = ::close(fd);
1163   assert(result != OS_ERR, &quot;could not close file&quot;);
1164 
1165   if (mapAddress == MAP_FAILED) {
1166     if (PrintMiscellaneous &amp;&amp; Verbose) {
1167       warning(&quot;mmap failed: %s\n&quot;, os::strerror(errno));
1168     }
1169     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
1170               &quot;Could not map PerfMemory&quot;);
1171   }
1172 
1173   // it does not go through os api, the operation has to record from here
1174   MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress,
1175     size, CURRENT_PC, mtInternal);
1176 
1177   *addr = mapAddress;
1178   *sizep = size;
1179 
1180   log_debug(perf, memops)(&quot;mapped &quot; SIZE_FORMAT &quot; bytes for vmid %d at &quot;
1181                           INTPTR_FORMAT, size, vmid, (void*)mapAddress);
1182 }
1183 
1184 // create the PerfData memory region
1185 //
1186 // This method creates the memory region used to store performance
1187 // data for the JVM. The memory may be created in standard or
1188 // shared memory.
1189 //
1190 void PerfMemory::create_memory_region(size_t size) {
1191 
1192   if (PerfDisableSharedMem) {
1193     // do not share the memory for the performance data.
1194     _start = create_standard_memory(size);
1195   }
1196   else {
1197     _start = create_shared_memory(size);
1198     if (_start == NULL) {
1199 
1200       // creation of the shared memory region failed, attempt
1201       // to create a contiguous, non-shared memory region instead.
1202       //
1203       if (PrintMiscellaneous &amp;&amp; Verbose) {
1204         warning(&quot;Reverting to non-shared PerfMemory region.\n&quot;);
1205       }
1206       PerfDisableSharedMem = true;
1207       _start = create_standard_memory(size);
1208     }
1209   }
1210 
1211   if (_start != NULL) _capacity = size;
1212 
1213 }
1214 
1215 // delete the PerfData memory region
1216 //
1217 // This method deletes the memory region used to store performance
1218 // data for the JVM. The memory region indicated by the &lt;address, size&gt;
1219 // tuple will be inaccessible after a call to this method.
1220 //
1221 void PerfMemory::delete_memory_region() {
1222 
1223   assert((start() != NULL &amp;&amp; capacity() &gt; 0), &quot;verify proper state&quot;);
1224 
1225   // If user specifies PerfDataSaveFile, it will save the performance data
1226   // to the specified file name no matter whether PerfDataSaveToFile is specified
1227   // or not. In other word, -XX:PerfDataSaveFile=.. overrides flag
1228   // -XX:+PerfDataSaveToFile.
1229   if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {
1230     save_memory_to_file(start(), capacity());
1231   }
1232 
1233   if (PerfDisableSharedMem) {
1234     delete_standard_memory(start(), capacity());
1235   }
1236   else {
1237     delete_shared_memory(start(), capacity());
1238   }
1239 }
1240 
1241 // attach to the PerfData memory region for another JVM
1242 //
1243 // This method returns an &lt;address, size&gt; tuple that points to
1244 // a memory buffer that is kept reasonably synchronized with
1245 // the PerfData memory region for the indicated JVM. This
1246 // buffer may be kept in synchronization via shared memory
1247 // or some other mechanism that keeps the buffer updated.
1248 //
1249 // If the JVM chooses not to support the attachability feature,
1250 // this method should throw an UnsupportedOperation exception.
1251 //
1252 // This implementation utilizes named shared memory to map
1253 // the indicated process&#39;s PerfData memory region into this JVMs
1254 // address space.
1255 //
1256 void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {
1257 
1258   if (vmid == 0 || vmid == os::current_process_id()) {
1259      *addrp = start();
1260      *sizep = capacity();
1261      return;
1262   }
1263 
1264   mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);
1265 }
1266 
1267 // detach from the PerfData memory region of another JVM
1268 //
1269 // This method detaches the PerfData memory region of another
1270 // JVM, specified as an &lt;address, size&gt; tuple of a buffer
1271 // in this process&#39;s address space. This method may perform
1272 // arbitrary actions to accomplish the detachment. The memory
1273 // region specified by &lt;address, size&gt; will be inaccessible after
1274 // a call to this method.
1275 //
1276 // If the JVM chooses not to support the attachability feature,
1277 // this method should throw an UnsupportedOperation exception.
1278 //
1279 // This implementation utilizes named shared memory to detach
1280 // the indicated process&#39;s PerfData memory region from this
1281 // process&#39;s address space.
1282 //
1283 void PerfMemory::detach(char* addr, size_t bytes, TRAPS) {
1284 
1285   assert(addr != 0, &quot;address sanity check&quot;);
1286   assert(bytes &gt; 0, &quot;capacity sanity check&quot;);
1287 
1288   if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {
1289     // prevent accidental detachment of this process&#39;s PerfMemory region
1290     return;
1291   }
1292 
1293   unmap_shared(addr, bytes);
1294 }
    </pre>
  </body>
</html>
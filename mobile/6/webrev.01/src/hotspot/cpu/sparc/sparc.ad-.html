<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // SPARC Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 register %{
   32 //----------Architecture Description Register Definitions----------------------
   33 // General Registers
   34 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   35 //                   ideal register type, encoding, vm name );
   36 // Register Save Types:
   37 //
   38 // NS  = No-Save:       The register allocator assumes that these registers
   39 //                      can be used without saving upon entry to the method, &amp;
   40 //                      that they do not need to be saved at call sites.
   41 //
   42 // SOC = Save-On-Call:  The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method,
   44 //                      but that they must be saved at call sites.
   45 //
   46 // SOE = Save-On-Entry: The register allocator assumes that these registers
   47 //                      must be saved before using them upon entry to the
   48 //                      method, but they do not need to be saved at call
   49 //                      sites.
   50 //
   51 // AS  = Always-Save:   The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, &amp; that they must be saved at call sites.
   54 //
   55 // Ideal Register Type is used to determine how to save &amp; restore a
   56 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   57 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   58 //
   59 // The encoding number is the actual bit-pattern placed into the opcodes.
   60 
   61 
   62 // ----------------------------
   63 // Integer/Long Registers
   64 // ----------------------------
   65 
   66 // Need to expose the hi/lo aspect of 64-bit registers
   67 // This register set is used for both the 64-bit build and
   68 // the 32-bit build with 1-register longs.
   69 
   70 // Global Registers 0-7
   71 reg_def R_G0H( NS,  NS, Op_RegI,128, G0-&gt;as_VMReg()-&gt;next());
   72 reg_def R_G0 ( NS,  NS, Op_RegI,  0, G0-&gt;as_VMReg());
   73 reg_def R_G1H(SOC, SOC, Op_RegI,129, G1-&gt;as_VMReg()-&gt;next());
   74 reg_def R_G1 (SOC, SOC, Op_RegI,  1, G1-&gt;as_VMReg());
   75 reg_def R_G2H( NS,  NS, Op_RegI,130, G2-&gt;as_VMReg()-&gt;next());
   76 reg_def R_G2 ( NS,  NS, Op_RegI,  2, G2-&gt;as_VMReg());
   77 reg_def R_G3H(SOC, SOC, Op_RegI,131, G3-&gt;as_VMReg()-&gt;next());
   78 reg_def R_G3 (SOC, SOC, Op_RegI,  3, G3-&gt;as_VMReg());
   79 reg_def R_G4H(SOC, SOC, Op_RegI,132, G4-&gt;as_VMReg()-&gt;next());
   80 reg_def R_G4 (SOC, SOC, Op_RegI,  4, G4-&gt;as_VMReg());
   81 reg_def R_G5H(SOC, SOC, Op_RegI,133, G5-&gt;as_VMReg()-&gt;next());
   82 reg_def R_G5 (SOC, SOC, Op_RegI,  5, G5-&gt;as_VMReg());
   83 reg_def R_G6H( NS,  NS, Op_RegI,134, G6-&gt;as_VMReg()-&gt;next());
   84 reg_def R_G6 ( NS,  NS, Op_RegI,  6, G6-&gt;as_VMReg());
   85 reg_def R_G7H( NS,  NS, Op_RegI,135, G7-&gt;as_VMReg()-&gt;next());
   86 reg_def R_G7 ( NS,  NS, Op_RegI,  7, G7-&gt;as_VMReg());
   87 
   88 // Output Registers 0-7
   89 reg_def R_O0H(SOC, SOC, Op_RegI,136, O0-&gt;as_VMReg()-&gt;next());
   90 reg_def R_O0 (SOC, SOC, Op_RegI,  8, O0-&gt;as_VMReg());
   91 reg_def R_O1H(SOC, SOC, Op_RegI,137, O1-&gt;as_VMReg()-&gt;next());
   92 reg_def R_O1 (SOC, SOC, Op_RegI,  9, O1-&gt;as_VMReg());
   93 reg_def R_O2H(SOC, SOC, Op_RegI,138, O2-&gt;as_VMReg()-&gt;next());
   94 reg_def R_O2 (SOC, SOC, Op_RegI, 10, O2-&gt;as_VMReg());
   95 reg_def R_O3H(SOC, SOC, Op_RegI,139, O3-&gt;as_VMReg()-&gt;next());
   96 reg_def R_O3 (SOC, SOC, Op_RegI, 11, O3-&gt;as_VMReg());
   97 reg_def R_O4H(SOC, SOC, Op_RegI,140, O4-&gt;as_VMReg()-&gt;next());
   98 reg_def R_O4 (SOC, SOC, Op_RegI, 12, O4-&gt;as_VMReg());
   99 reg_def R_O5H(SOC, SOC, Op_RegI,141, O5-&gt;as_VMReg()-&gt;next());
  100 reg_def R_O5 (SOC, SOC, Op_RegI, 13, O5-&gt;as_VMReg());
  101 reg_def R_SPH( NS,  NS, Op_RegI,142, SP-&gt;as_VMReg()-&gt;next());
  102 reg_def R_SP ( NS,  NS, Op_RegI, 14, SP-&gt;as_VMReg());
  103 reg_def R_O7H(SOC, SOC, Op_RegI,143, O7-&gt;as_VMReg()-&gt;next());
  104 reg_def R_O7 (SOC, SOC, Op_RegI, 15, O7-&gt;as_VMReg());
  105 
  106 // Local Registers 0-7
  107 reg_def R_L0H( NS,  NS, Op_RegI,144, L0-&gt;as_VMReg()-&gt;next());
  108 reg_def R_L0 ( NS,  NS, Op_RegI, 16, L0-&gt;as_VMReg());
  109 reg_def R_L1H( NS,  NS, Op_RegI,145, L1-&gt;as_VMReg()-&gt;next());
  110 reg_def R_L1 ( NS,  NS, Op_RegI, 17, L1-&gt;as_VMReg());
  111 reg_def R_L2H( NS,  NS, Op_RegI,146, L2-&gt;as_VMReg()-&gt;next());
  112 reg_def R_L2 ( NS,  NS, Op_RegI, 18, L2-&gt;as_VMReg());
  113 reg_def R_L3H( NS,  NS, Op_RegI,147, L3-&gt;as_VMReg()-&gt;next());
  114 reg_def R_L3 ( NS,  NS, Op_RegI, 19, L3-&gt;as_VMReg());
  115 reg_def R_L4H( NS,  NS, Op_RegI,148, L4-&gt;as_VMReg()-&gt;next());
  116 reg_def R_L4 ( NS,  NS, Op_RegI, 20, L4-&gt;as_VMReg());
  117 reg_def R_L5H( NS,  NS, Op_RegI,149, L5-&gt;as_VMReg()-&gt;next());
  118 reg_def R_L5 ( NS,  NS, Op_RegI, 21, L5-&gt;as_VMReg());
  119 reg_def R_L6H( NS,  NS, Op_RegI,150, L6-&gt;as_VMReg()-&gt;next());
  120 reg_def R_L6 ( NS,  NS, Op_RegI, 22, L6-&gt;as_VMReg());
  121 reg_def R_L7H( NS,  NS, Op_RegI,151, L7-&gt;as_VMReg()-&gt;next());
  122 reg_def R_L7 ( NS,  NS, Op_RegI, 23, L7-&gt;as_VMReg());
  123 
  124 // Input Registers 0-7
  125 reg_def R_I0H( NS,  NS, Op_RegI,152, I0-&gt;as_VMReg()-&gt;next());
  126 reg_def R_I0 ( NS,  NS, Op_RegI, 24, I0-&gt;as_VMReg());
  127 reg_def R_I1H( NS,  NS, Op_RegI,153, I1-&gt;as_VMReg()-&gt;next());
  128 reg_def R_I1 ( NS,  NS, Op_RegI, 25, I1-&gt;as_VMReg());
  129 reg_def R_I2H( NS,  NS, Op_RegI,154, I2-&gt;as_VMReg()-&gt;next());
  130 reg_def R_I2 ( NS,  NS, Op_RegI, 26, I2-&gt;as_VMReg());
  131 reg_def R_I3H( NS,  NS, Op_RegI,155, I3-&gt;as_VMReg()-&gt;next());
  132 reg_def R_I3 ( NS,  NS, Op_RegI, 27, I3-&gt;as_VMReg());
  133 reg_def R_I4H( NS,  NS, Op_RegI,156, I4-&gt;as_VMReg()-&gt;next());
  134 reg_def R_I4 ( NS,  NS, Op_RegI, 28, I4-&gt;as_VMReg());
  135 reg_def R_I5H( NS,  NS, Op_RegI,157, I5-&gt;as_VMReg()-&gt;next());
  136 reg_def R_I5 ( NS,  NS, Op_RegI, 29, I5-&gt;as_VMReg());
  137 reg_def R_FPH( NS,  NS, Op_RegI,158, FP-&gt;as_VMReg()-&gt;next());
  138 reg_def R_FP ( NS,  NS, Op_RegI, 30, FP-&gt;as_VMReg());
  139 reg_def R_I7H( NS,  NS, Op_RegI,159, I7-&gt;as_VMReg()-&gt;next());
  140 reg_def R_I7 ( NS,  NS, Op_RegI, 31, I7-&gt;as_VMReg());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Float Registers
  147 reg_def R_F0 ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg());
  148 reg_def R_F1 ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg());
  149 reg_def R_F2 ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg());
  150 reg_def R_F3 ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg());
  151 reg_def R_F4 ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg());
  152 reg_def R_F5 ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg());
  153 reg_def R_F6 ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg());
  154 reg_def R_F7 ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg());
  155 reg_def R_F8 ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg());
  156 reg_def R_F9 ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg());
  157 reg_def R_F10( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg());
  158 reg_def R_F11( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg());
  159 reg_def R_F12( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg());
  160 reg_def R_F13( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg());
  161 reg_def R_F14( SOC, SOC, Op_RegF, 14, F14-&gt;as_VMReg());
  162 reg_def R_F15( SOC, SOC, Op_RegF, 15, F15-&gt;as_VMReg());
  163 reg_def R_F16( SOC, SOC, Op_RegF, 16, F16-&gt;as_VMReg());
  164 reg_def R_F17( SOC, SOC, Op_RegF, 17, F17-&gt;as_VMReg());
  165 reg_def R_F18( SOC, SOC, Op_RegF, 18, F18-&gt;as_VMReg());
  166 reg_def R_F19( SOC, SOC, Op_RegF, 19, F19-&gt;as_VMReg());
  167 reg_def R_F20( SOC, SOC, Op_RegF, 20, F20-&gt;as_VMReg());
  168 reg_def R_F21( SOC, SOC, Op_RegF, 21, F21-&gt;as_VMReg());
  169 reg_def R_F22( SOC, SOC, Op_RegF, 22, F22-&gt;as_VMReg());
  170 reg_def R_F23( SOC, SOC, Op_RegF, 23, F23-&gt;as_VMReg());
  171 reg_def R_F24( SOC, SOC, Op_RegF, 24, F24-&gt;as_VMReg());
  172 reg_def R_F25( SOC, SOC, Op_RegF, 25, F25-&gt;as_VMReg());
  173 reg_def R_F26( SOC, SOC, Op_RegF, 26, F26-&gt;as_VMReg());
  174 reg_def R_F27( SOC, SOC, Op_RegF, 27, F27-&gt;as_VMReg());
  175 reg_def R_F28( SOC, SOC, Op_RegF, 28, F28-&gt;as_VMReg());
  176 reg_def R_F29( SOC, SOC, Op_RegF, 29, F29-&gt;as_VMReg());
  177 reg_def R_F30( SOC, SOC, Op_RegF, 30, F30-&gt;as_VMReg());
  178 reg_def R_F31( SOC, SOC, Op_RegF, 31, F31-&gt;as_VMReg());
  179 
  180 // Double Registers
  181 // The rules of ADL require that double registers be defined in pairs.
  182 // Each pair must be two 32-bit values, but not necessarily a pair of
  183 // single float registers.  In each pair, ADLC-assigned register numbers
  184 // must be adjacent, with the lower number even.  Finally, when the
  185 // CPU stores such a register pair to memory, the word associated with
  186 // the lower ADLC-assigned number must be stored to the lower address.
  187 
  188 // These definitions specify the actual bit encodings of the sparc
  189 // double fp register numbers.  FloatRegisterImpl in register_sparc.hpp
  190 // wants 0-63, so we have to convert every time we want to use fp regs
  191 // with the macroassembler, using reg_to_DoubleFloatRegister_object().
  192 // 255 is a flag meaning &quot;don&#39;t go here&quot;.
  193 // I believe we can&#39;t handle callee-save doubles D32 and up until
  194 // the place in the sparc stack crawler that asserts on the 255 is
  195 // fixed up.
  196 reg_def R_D32 (SOC, SOC, Op_RegD,  1, F32-&gt;as_VMReg());
  197 reg_def R_D32x(SOC, SOC, Op_RegD,255, F32-&gt;as_VMReg()-&gt;next());
  198 reg_def R_D34 (SOC, SOC, Op_RegD,  3, F34-&gt;as_VMReg());
  199 reg_def R_D34x(SOC, SOC, Op_RegD,255, F34-&gt;as_VMReg()-&gt;next());
  200 reg_def R_D36 (SOC, SOC, Op_RegD,  5, F36-&gt;as_VMReg());
  201 reg_def R_D36x(SOC, SOC, Op_RegD,255, F36-&gt;as_VMReg()-&gt;next());
  202 reg_def R_D38 (SOC, SOC, Op_RegD,  7, F38-&gt;as_VMReg());
  203 reg_def R_D38x(SOC, SOC, Op_RegD,255, F38-&gt;as_VMReg()-&gt;next());
  204 reg_def R_D40 (SOC, SOC, Op_RegD,  9, F40-&gt;as_VMReg());
  205 reg_def R_D40x(SOC, SOC, Op_RegD,255, F40-&gt;as_VMReg()-&gt;next());
  206 reg_def R_D42 (SOC, SOC, Op_RegD, 11, F42-&gt;as_VMReg());
  207 reg_def R_D42x(SOC, SOC, Op_RegD,255, F42-&gt;as_VMReg()-&gt;next());
  208 reg_def R_D44 (SOC, SOC, Op_RegD, 13, F44-&gt;as_VMReg());
  209 reg_def R_D44x(SOC, SOC, Op_RegD,255, F44-&gt;as_VMReg()-&gt;next());
  210 reg_def R_D46 (SOC, SOC, Op_RegD, 15, F46-&gt;as_VMReg());
  211 reg_def R_D46x(SOC, SOC, Op_RegD,255, F46-&gt;as_VMReg()-&gt;next());
  212 reg_def R_D48 (SOC, SOC, Op_RegD, 17, F48-&gt;as_VMReg());
  213 reg_def R_D48x(SOC, SOC, Op_RegD,255, F48-&gt;as_VMReg()-&gt;next());
  214 reg_def R_D50 (SOC, SOC, Op_RegD, 19, F50-&gt;as_VMReg());
  215 reg_def R_D50x(SOC, SOC, Op_RegD,255, F50-&gt;as_VMReg()-&gt;next());
  216 reg_def R_D52 (SOC, SOC, Op_RegD, 21, F52-&gt;as_VMReg());
  217 reg_def R_D52x(SOC, SOC, Op_RegD,255, F52-&gt;as_VMReg()-&gt;next());
  218 reg_def R_D54 (SOC, SOC, Op_RegD, 23, F54-&gt;as_VMReg());
  219 reg_def R_D54x(SOC, SOC, Op_RegD,255, F54-&gt;as_VMReg()-&gt;next());
  220 reg_def R_D56 (SOC, SOC, Op_RegD, 25, F56-&gt;as_VMReg());
  221 reg_def R_D56x(SOC, SOC, Op_RegD,255, F56-&gt;as_VMReg()-&gt;next());
  222 reg_def R_D58 (SOC, SOC, Op_RegD, 27, F58-&gt;as_VMReg());
  223 reg_def R_D58x(SOC, SOC, Op_RegD,255, F58-&gt;as_VMReg()-&gt;next());
  224 reg_def R_D60 (SOC, SOC, Op_RegD, 29, F60-&gt;as_VMReg());
  225 reg_def R_D60x(SOC, SOC, Op_RegD,255, F60-&gt;as_VMReg()-&gt;next());
  226 reg_def R_D62 (SOC, SOC, Op_RegD, 31, F62-&gt;as_VMReg());
  227 reg_def R_D62x(SOC, SOC, Op_RegD,255, F62-&gt;as_VMReg()-&gt;next());
  228 
  229 
  230 // ----------------------------
  231 // Special Registers
  232 // Condition Codes Flag Registers
  233 // I tried to break out ICC and XCC but it&#39;s not very pretty.
  234 // Every Sparc instruction which defs/kills one also kills the other.
  235 // Hence every compare instruction which defs one kind of flags ends
  236 // up needing a kill of the other.
  237 reg_def CCR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  238 
  239 reg_def FCC0(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  240 reg_def FCC1(SOC, SOC,  Op_RegFlags, 1, VMRegImpl::Bad());
  241 reg_def FCC2(SOC, SOC,  Op_RegFlags, 2, VMRegImpl::Bad());
  242 reg_def FCC3(SOC, SOC,  Op_RegFlags, 3, VMRegImpl::Bad());
  243 
  244 // ----------------------------
  245 // Specify the enum values for the registers.  These enums are only used by the
  246 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
  247 // for visibility to the rest of the vm. The order of this enum influences the
  248 // register allocator so having the freedom to set this order and not be stuck
  249 // with the order that is natural for the rest of the vm is worth it.
  250 alloc_class chunk0(
  251   R_L0,R_L0H, R_L1,R_L1H, R_L2,R_L2H, R_L3,R_L3H, R_L4,R_L4H, R_L5,R_L5H, R_L6,R_L6H, R_L7,R_L7H,
  252   R_G0,R_G0H, R_G1,R_G1H, R_G2,R_G2H, R_G3,R_G3H, R_G4,R_G4H, R_G5,R_G5H, R_G6,R_G6H, R_G7,R_G7H,
  253   R_O7,R_O7H, R_SP,R_SPH, R_O0,R_O0H, R_O1,R_O1H, R_O2,R_O2H, R_O3,R_O3H, R_O4,R_O4H, R_O5,R_O5H,
  254   R_I0,R_I0H, R_I1,R_I1H, R_I2,R_I2H, R_I3,R_I3H, R_I4,R_I4H, R_I5,R_I5H, R_FP,R_FPH, R_I7,R_I7H);
  255 
  256 // Note that a register is not allocatable unless it is also mentioned
  257 // in a widely-used reg_class below.  Thus, R_G7 and R_G0 are outside i_reg.
  258 
  259 alloc_class chunk1(
  260   // The first registers listed here are those most likely to be used
  261   // as temporaries.  We move F0..F7 away from the front of the list,
  262   // to reduce the likelihood of interferences with parameters and
  263   // return values.  Likewise, we avoid using F0/F1 for parameters,
  264   // since they are used for return values.
  265   // This FPU fine-tuning is worth about 1% on the SPEC geomean.
  266   R_F8 ,R_F9 ,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  267   R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,
  268   R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,R_F30,R_F31,
  269   R_F0 ,R_F1 ,R_F2 ,R_F3 ,R_F4 ,R_F5 ,R_F6 ,R_F7 , // used for arguments and return values
  270   R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,
  271   R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  272   R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,
  273   R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x);
  274 
  275 alloc_class chunk2(CCR, FCC0, FCC1, FCC2, FCC3);
  276 
  277 //----------Architecture Description Register Classes--------------------------
  278 // Several register classes are automatically defined based upon information in
  279 // this architecture description.
  280 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  281 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  282 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  283 //
  284 
  285 // G0 is not included in integer class since it has special meaning.
  286 reg_class g0_reg(R_G0);
  287 
  288 // ----------------------------
  289 // Integer Register Classes
  290 // ----------------------------
  291 // Exclusions from i_reg:
  292 // R_G0: hardwired zero
  293 // R_G2: reserved by HotSpot to the TLS register (invariant within Java)
  294 // R_G6: reserved by Solaris ABI to tools
  295 // R_G7: reserved by Solaris ABI to libthread
  296 // R_O7: Used as a temp in many encodings
  297 reg_class int_reg(R_G1,R_G3,R_G4,R_G5,R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  298 
  299 // Class for all integer registers, except the G registers.  This is used for
  300 // encodings which use G registers as temps.  The regular inputs to such
  301 // instructions use a &quot;notemp_&quot; prefix, as a hack to ensure that the allocator
  302 // will not put an input into a temp register.
  303 reg_class notemp_int_reg(R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  304 
  305 reg_class g1_regI(R_G1);
  306 reg_class g3_regI(R_G3);
  307 reg_class g4_regI(R_G4);
  308 reg_class o0_regI(R_O0);
  309 reg_class o7_regI(R_O7);
  310 
  311 // ----------------------------
  312 // Pointer Register Classes
  313 // ----------------------------
  314 // 64-bit build means 64-bit pointers means hi/lo pairs
  315 reg_class ptr_reg(            R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  316                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  317                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  318                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  319 // Lock encodings use G3 and G4 internally
  320 reg_class lock_ptr_reg(       R_G1H,R_G1,                                     R_G5H,R_G5,
  321                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  322                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  323                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  324 // Special class for storeP instructions, which can store SP or RPC to TLS.
  325 // It is also used for memory addressing, allowing direct TLS addressing.
  326 reg_class sp_ptr_reg(         R_G1H,R_G1, R_G2H,R_G2, R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  327                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5, R_SPH,R_SP,
  328                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  329                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5, R_FPH,R_FP );
  330 // R_L7 is the lowest-priority callee-save (i.e., NS) register
  331 // We use it to save R_G2 across calls out of Java.
  332 reg_class l7_regP(R_L7H,R_L7);
  333 
  334 // Other special pointer regs
  335 reg_class g1_regP(R_G1H,R_G1);
  336 reg_class g2_regP(R_G2H,R_G2);
  337 reg_class g3_regP(R_G3H,R_G3);
  338 reg_class g4_regP(R_G4H,R_G4);
  339 reg_class g5_regP(R_G5H,R_G5);
  340 reg_class i0_regP(R_I0H,R_I0);
  341 reg_class o0_regP(R_O0H,R_O0);
  342 reg_class o1_regP(R_O1H,R_O1);
  343 reg_class o2_regP(R_O2H,R_O2);
  344 reg_class o7_regP(R_O7H,R_O7);
  345 
  346 
  347 // ----------------------------
  348 // Long Register Classes
  349 // ----------------------------
  350 // Longs in 1 register.  Aligned adjacent hi/lo pairs.
  351 // Note:  O7 is never in this class; it is sometimes used as an encoding temp.
  352 reg_class long_reg(             R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5
  353                    ,R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5
  354 // 64-bit, longs in 1 register: use all 64-bit integer registers
  355                    ,R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7
  356                    ,R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5
  357                   );
  358 
  359 reg_class g1_regL(R_G1H,R_G1);
  360 reg_class g3_regL(R_G3H,R_G3);
  361 reg_class o2_regL(R_O2H,R_O2);
  362 reg_class o7_regL(R_O7H,R_O7);
  363 
  364 // ----------------------------
  365 // Special Class for Condition Code Flags Register
  366 reg_class int_flags(CCR);
  367 reg_class float_flags(FCC0,FCC1,FCC2,FCC3);
  368 reg_class float_flag0(FCC0);
  369 
  370 
  371 // ----------------------------
  372 // Float Point Register Classes
  373 // ----------------------------
  374 // Skip F30/F31, they are reserved for mem-mem copies
  375 reg_class sflt_reg(R_F0,R_F1,R_F2,R_F3,R_F4,R_F5,R_F6,R_F7,R_F8,R_F9,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  376 
  377 // Paired floating point registers--they show up in the same order as the floats,
  378 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  379 reg_class dflt_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  380                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,
  381                    /* Use extra V9 double registers; this AD file does not support V8 */
  382                    R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  383                    R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x
  384                    );
  385 
  386 // Paired floating point registers--they show up in the same order as the floats,
  387 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  388 // This class is usable for mis-aligned loads as happen in I2C adapters.
  389 reg_class dflt_low_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  390                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  391 %}
  392 
  393 //----------DEFINITION BLOCK---------------------------------------------------
  394 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  395 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  396 // Format:
  397 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  398 // Generated Code in ad_&lt;arch&gt;.hpp
  399 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  400 //        // value == &lt;int_value&gt;
  401 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  402 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  403 //
  404 definitions %{
  405 // The default cost (of an ALU instruction).
  406   int_def DEFAULT_COST      (    100,     100);
  407   int_def HUGE_COST         (1000000, 1000000);
  408 
  409 // Memory refs are twice as expensive as run-of-the-mill.
  410   int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);
  411 
  412 // Branches are even more expensive.
  413   int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
  414   int_def CALL_COST         (    300, DEFAULT_COST * 3);
  415 %}
  416 
  417 
  418 //----------SOURCE BLOCK-------------------------------------------------------
  419 // This is a block of C++ code which provides values, functions, and
  420 // definitions necessary in the rest of the architecture description
  421 source_hpp %{
  422 // Header information of the source block.
  423 // Method declarations/definitions which are used outside
  424 // the ad-scope can conveniently be defined here.
  425 //
  426 // To keep related declarations/definitions/uses close together,
  427 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  428 
  429 // Must be visible to the DFA in dfa_sparc.cpp
  430 extern bool can_branch_register( Node *bol, Node *cmp );
  431 
  432 extern bool use_block_zeroing(Node* count);
  433 
  434 // Macros to extract hi &amp; lo halves from a long pair.
  435 // G0 is not part of any long pair, so assert on that.
  436 // Prevents accidentally using G1 instead of G0.
  437 #define LONG_HI_REG(x) (x)
  438 #define LONG_LO_REG(x) (x)
  439 
  440 class CallStubImpl {
  441 
  442   //--------------------------------------------------------------
  443   //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
  444   //--------------------------------------------------------------
  445 
  446  public:
  447   // Size of call trampoline stub.
  448   static uint size_call_trampoline() {
  449     return 0; // no call trampolines on this platform
  450   }
  451 
  452   // number of relocations needed by a call trampoline stub
  453   static uint reloc_call_trampoline() {
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 
  474 class Node::PD {
  475 public:
  476   enum NodeFlags {
  477     _last_flag = Node::_last_flag
  478   };
  479 };
  480 
  481 %}
  482 
  483 source %{
  484 #define __ _masm.
  485 
  486 // tertiary op of a LoadP or StoreP encoding
  487 #define REGP_OP true
  488 
  489 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  490 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  491 static Register reg_to_register_object(int register_encoding);
  492 
  493 void PhaseOutput::pd_perform_mach_node_analysis() {
  494 }
  495 
  496 int MachNode::pd_alignment_required() const {
  497   return 1;
  498 }
  499 
  500 int MachNode::compute_padding(int current_offset) const {
  501   return 0;
  502 }
  503 
  504 // Used by the DFA in dfa_sparc.cpp.
  505 // Check for being able to use a V9 branch-on-register.  Requires a
  506 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  507 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  508 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  509 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  510 // replace them with zero, which could become sign-extension in a different OS
  511 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  512 // bits with non-zero junk (the registers are reloaded with standard LD
  513 // instructions which either zero-fill or sign-fill).
  514 bool can_branch_register( Node *bol, Node *cmp ) {
  515   if( !BranchOnRegister ) return false;
  516   if( cmp-&gt;Opcode() == Op_CmpP )
  517     return true;  // No problems with pointer compares
  518   if( cmp-&gt;Opcode() == Op_CmpL )
  519     return true;  // No problems with long compares
  520 
  521   if( !SparcV9RegsHiBitsZero ) return false;
  522   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  523       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
  524      return false;
  525 
  526   // Check for comparing against a &#39;safe&#39; value.  Any operation which
  527   // clears out the high word is safe.  Thus, loads and certain shifts
  528   // are safe, as are non-negative constants.  Any operation which
  529   // preserves zero bits in the high word is safe as long as each of its
  530   // inputs are safe.  Thus, phis and bitwise booleans are safe if their
  531   // inputs are safe.  At present, the only important case to recognize
  532   // seems to be loads.  Constants should fold away, and shifts &amp;
  533   // logicals can use the &#39;cc&#39; forms.
  534   Node *x = cmp-&gt;in(1);
  535   if( x-&gt;is_Load() ) return true;
  536   if( x-&gt;is_Phi() ) {
  537     for( uint i = 1; i &lt; x-&gt;req(); i++ )
  538       if( !x-&gt;in(i)-&gt;is_Load() )
  539         return false;
  540     return true;
  541   }
  542   return false;
  543 }
  544 
  545 bool use_block_zeroing(Node* count) {
  546   // Use BIS for zeroing if count is not constant
  547   // or it is &gt;= BlockZeroingLowLimit.
  548   return UseBlockZeroing &amp;&amp; (count-&gt;find_intptr_t_con(BlockZeroingLowLimit) &gt;= BlockZeroingLowLimit);
  549 }
  550 
  551 // ****************************************************************************
  552 
  553 // REQUIRED FUNCTIONALITY
  554 
  555 // !!!!! Special hack to get all type of calls to specify the byte offset
  556 //       from the start of the call to the point where the return address
  557 //       will point.
  558 //       The &quot;return address&quot; is the address of the call instruction, plus 8.
  559 
  560 int MachCallStaticJavaNode::ret_addr_offset() {
  561   int offset = NativeCall::instruction_size;  // call; delay slot
  562   if (_method_handle_invoke)
  563     offset += 4;  // restore SP
  564   return offset;
  565 }
  566 
  567 int MachCallDynamicJavaNode::ret_addr_offset() {
  568   int vtable_index = this-&gt;_vtable_index;
  569   if (vtable_index &lt; 0) {
  570     // must be invalid_vtable_index, not nonvirtual_vtable_index
  571     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
  572     return (NativeMovConstReg::instruction_size +
  573            NativeCall::instruction_size);  // sethi; setlo; call; delay slot
  574   } else {
  575     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  576     int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
  577     int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
  578     int klass_load_size;
  579     if (UseCompressedClassPointers) {
  580       assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
  581       klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
  582     } else {
  583       klass_load_size = 1*BytesPerInstWord;
  584     }
  585     if (Assembler::is_simm13(v_off)) {
  586       return klass_load_size +
  587              (2*BytesPerInstWord +           // ld_ptr, ld_ptr
  588              NativeCall::instruction_size);  // call; delay slot
  589     } else {
  590       return klass_load_size +
  591              (4*BytesPerInstWord +           // set_hi, set, ld_ptr, ld_ptr
  592              NativeCall::instruction_size);  // call; delay slot
  593     }
  594   }
  595 }
  596 
  597 int MachCallRuntimeNode::ret_addr_offset() {
  598   if (MacroAssembler::is_far_target(entry_point())) {
  599     return NativeFarCall::instruction_size;
  600   } else {
  601     return NativeCall::instruction_size;
  602   }
  603 }
  604 
  605 // Indicate if the safepoint node needs the polling page as an input.
  606 // Since Sparc does not have absolute addressing, it does.
  607 bool SafePointNode::needs_polling_address_input() {
  608   return true;
  609 }
  610 
  611 // emit an interrupt that is caught by the debugger (for debugging compiler)
  612 void emit_break(CodeBuffer &amp;cbuf) {
  613   C2_MacroAssembler _masm(&amp;cbuf);
  614   __ breakpoint_trap();
  615 }
  616 
  617 #ifndef PRODUCT
  618 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  619   st-&gt;print(&quot;TA&quot;);
  620 }
  621 #endif
  622 
  623 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  624   emit_break(cbuf);
  625 }
  626 
  627 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  628   return MachNode::size(ra_);
  629 }
  630 
  631 // Traceable jump
  632 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
  633   C2_MacroAssembler _masm(&amp;cbuf);
  634   Register rdest = reg_to_register_object(jump_target);
  635   __ JMP(rdest, 0);
  636   __ delayed()-&gt;nop();
  637 }
  638 
  639 // Traceable jump and set exception pc
  640 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
  641   C2_MacroAssembler _masm(&amp;cbuf);
  642   Register rdest = reg_to_register_object(jump_target);
  643   __ JMP(rdest, 0);
  644   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  645 }
  646 
  647 void emit_nop(CodeBuffer &amp;cbuf) {
  648   C2_MacroAssembler _masm(&amp;cbuf);
  649   __ nop();
  650 }
  651 
  652 void emit_illtrap(CodeBuffer &amp;cbuf) {
  653   C2_MacroAssembler _masm(&amp;cbuf);
  654   __ illtrap(0);
  655 }
  656 
  657 
  658 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  659   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  660 
  661   intptr_t offset = 0;
  662   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  663   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  664   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  665   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  666   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  667   atype = atype-&gt;add_offset(offset);
  668   assert(disp32 == offset, &quot;wrong disp32&quot;);
  669   return atype-&gt;_offset;
  670 }
  671 
  672 
  673 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
  674   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  675 
  676   intptr_t offset = 0;
  677   Node* addr = n-&gt;in(2);
  678   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  679   if (addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP) {
  680     Node* a = addr-&gt;in(2/*AddPNode::Address*/);
  681     Node* o = addr-&gt;in(3/*AddPNode::Offset*/);
  682     offset = o-&gt;is_Con() ? o-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() : Type::OffsetBot;
  683     atype = a-&gt;bottom_type()-&gt;is_ptr()-&gt;add_offset(offset);
  684     assert(atype-&gt;isa_oop_ptr(), &quot;still an oop&quot;);
  685   }
  686   offset = atype-&gt;is_ptr()-&gt;_offset;
  687   if (offset != Type::OffsetBot)  offset += disp32;
  688   return offset;
  689 }
  690 
  691 static inline jlong replicate_immI(int con, int count, int width) {
  692   // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
  693   assert(count*width == 8 &amp;&amp; width &lt;= 4, &quot;sanity&quot;);
  694   int bit_width = width * 8;
  695   jlong val = con;
  696   val &amp;= (((jlong) 1) &lt;&lt; bit_width) - 1;  // mask off sign bits
  697   for (int i = 0; i &lt; count - 1; i++) {
  698     val |= (val &lt;&lt; bit_width);
  699   }
  700   return val;
  701 }
  702 
  703 static inline jlong replicate_immF(float con) {
  704   // Replicate float con 2 times and pack into vector.
  705   int val = *((int*)&amp;con);
  706   jlong lval = val;
  707   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
  708   return lval;
  709 }
  710 
  711 // Standard Sparc opcode form2 field breakdown
  712 static inline void emit2_19(CodeBuffer &amp;cbuf, int f30, int f29, int f25, int f22, int f20, int f19, int f0 ) {
  713   f0 &amp;= (1&lt;&lt;19)-1;     // Mask displacement to 19 bits
  714   int op = (f30 &lt;&lt; 30) |
  715            (f29 &lt;&lt; 29) |
  716            (f25 &lt;&lt; 25) |
  717            (f22 &lt;&lt; 22) |
  718            (f20 &lt;&lt; 20) |
  719            (f19 &lt;&lt; 19) |
  720            (f0  &lt;&lt;  0);
  721   cbuf.insts()-&gt;emit_int32(op);
  722 }
  723 
  724 // Standard Sparc opcode form2 field breakdown
  725 static inline void emit2_22(CodeBuffer &amp;cbuf, int f30, int f25, int f22, int f0 ) {
  726   f0 &gt;&gt;= 10;           // Drop 10 bits
  727   f0 &amp;= (1&lt;&lt;22)-1;     // Mask displacement to 22 bits
  728   int op = (f30 &lt;&lt; 30) |
  729            (f25 &lt;&lt; 25) |
  730            (f22 &lt;&lt; 22) |
  731            (f0  &lt;&lt;  0);
  732   cbuf.insts()-&gt;emit_int32(op);
  733 }
  734 
  735 // Standard Sparc opcode form3 field breakdown
  736 static inline void emit3(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int f5, int f0 ) {
  737   int op = (f30 &lt;&lt; 30) |
  738            (f25 &lt;&lt; 25) |
  739            (f19 &lt;&lt; 19) |
  740            (f14 &lt;&lt; 14) |
  741            (f5  &lt;&lt;  5) |
  742            (f0  &lt;&lt;  0);
  743   cbuf.insts()-&gt;emit_int32(op);
  744 }
  745 
  746 // Standard Sparc opcode form3 field breakdown
  747 static inline void emit3_simm13(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm13 ) {
  748   simm13 &amp;= (1&lt;&lt;13)-1; // Mask to 13 bits
  749   int op = (f30 &lt;&lt; 30) |
  750            (f25 &lt;&lt; 25) |
  751            (f19 &lt;&lt; 19) |
  752            (f14 &lt;&lt; 14) |
  753            (1   &lt;&lt; 13) | // bit to indicate immediate-mode
  754            (simm13&lt;&lt;0);
  755   cbuf.insts()-&gt;emit_int32(op);
  756 }
  757 
  758 static inline void emit3_simm10(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm10 ) {
  759   simm10 &amp;= (1&lt;&lt;10)-1; // Mask to 10 bits
  760   emit3_simm13(cbuf,f30,f25,f19,f14,simm10);
  761 }
  762 
  763 #ifdef ASSERT
  764 // Helper function for VerifyOops in emit_form3_mem_reg
  765 void verify_oops_warning(const MachNode *n, int ideal_op, int mem_op) {
  766   warning(&quot;VerifyOops encountered unexpected instruction:&quot;);
  767   n-&gt;dump(2);
  768   warning(&quot;Instruction has ideal_Opcode==Op_%s and op_ld==Op_%s \n&quot;, NodeClassNames[ideal_op], NodeClassNames[mem_op]);
  769 }
  770 #endif
  771 
  772 
  773 void emit_form3_mem_reg(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra, const MachNode* n, int primary, int tertiary,
  774                         int src1_enc, int disp32, int src2_enc, int dst_enc) {
  775 
  776 #ifdef ASSERT
  777   // The following code implements the +VerifyOops feature.
  778   // It verifies oop values which are loaded into or stored out of
  779   // the current method activation.  +VerifyOops complements techniques
  780   // like ScavengeALot, because it eagerly inspects oops in transit,
  781   // as they enter or leave the stack, as opposed to ScavengeALot,
  782   // which inspects oops &quot;at rest&quot;, in the stack or heap, at safepoints.
  783   // For this reason, +VerifyOops can sometimes detect bugs very close
  784   // to their point of creation.  It can also serve as a cross-check
  785   // on the validity of oop maps, when used toegether with ScavengeALot.
  786 
  787   // It would be good to verify oops at other points, especially
  788   // when an oop is used as a base pointer for a load or store.
  789   // This is presently difficult, because it is hard to know when
  790   // a base address is biased or not.  (If we had such information,
  791   // it would be easy and useful to make a two-argument version of
  792   // verify_oop which unbiases the base, and performs verification.)
  793 
  794   assert((uint)tertiary == 0xFFFFFFFF || tertiary == REGP_OP, &quot;valid tertiary&quot;);
  795   bool is_verified_oop_base  = false;
  796   bool is_verified_oop_load  = false;
  797   bool is_verified_oop_store = false;
  798   int tmp_enc = -1;
  799   if (VerifyOops &amp;&amp; src1_enc != R_SP_enc) {
  800     // classify the op, mainly for an assert check
  801     int st_op = 0, ld_op = 0;
  802     switch (primary) {
  803     case Assembler::stb_op3:  st_op = Op_StoreB; break;
  804     case Assembler::sth_op3:  st_op = Op_StoreC; break;
  805     case Assembler::stx_op3:  // may become StoreP or stay StoreI or StoreD0
  806     case Assembler::stw_op3:  st_op = Op_StoreI; break;
  807     case Assembler::std_op3:  st_op = Op_StoreL; break;
  808     case Assembler::stf_op3:  st_op = Op_StoreF; break;
  809     case Assembler::stdf_op3: st_op = Op_StoreD; break;
  810 
  811     case Assembler::ldsb_op3: ld_op = Op_LoadB; break;
  812     case Assembler::ldub_op3: ld_op = Op_LoadUB; break;
  813     case Assembler::lduh_op3: ld_op = Op_LoadUS; break;
  814     case Assembler::ldsh_op3: ld_op = Op_LoadS; break;
  815     case Assembler::ldx_op3:  // may become LoadP or stay LoadI
  816     case Assembler::ldsw_op3: // may become LoadP or stay LoadI
  817     case Assembler::lduw_op3: ld_op = Op_LoadI; break;
  818     case Assembler::ldd_op3:  ld_op = Op_LoadL; break;
  819     case Assembler::ldf_op3:  ld_op = Op_LoadF; break;
  820     case Assembler::lddf_op3: ld_op = Op_LoadD; break;
  821     case Assembler::prefetch_op3: ld_op = Op_LoadI; break;
  822 
  823     default: ShouldNotReachHere();
  824     }
  825     if (tertiary == REGP_OP) {
  826       if      (st_op == Op_StoreI)  st_op = Op_StoreP;
  827       else if (ld_op == Op_LoadI)   ld_op = Op_LoadP;
  828       else                          ShouldNotReachHere();
  829       if (st_op) {
  830         // a store
  831         // inputs are (0:control, 1:memory, 2:address, 3:value)
  832         Node* n2 = n-&gt;in(3);
  833         if (n2 != NULL) {
  834           const Type* t = n2-&gt;bottom_type();
  835           is_verified_oop_store = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  836         }
  837       } else {
  838         // a load
  839         const Type* t = n-&gt;bottom_type();
  840         is_verified_oop_load = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  841       }
  842     }
  843 
  844     if (ld_op) {
  845       // a Load
  846       // inputs are (0:control, 1:memory, 2:address)
  847       if (!(n-&gt;ideal_Opcode()==ld_op)       &amp;&amp; // Following are special cases
  848           !(n-&gt;ideal_Opcode()==Op_LoadPLocked &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  849           !(n-&gt;ideal_Opcode()==Op_LoadI     &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  850           !(n-&gt;ideal_Opcode()==Op_LoadF     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  851           !(n-&gt;ideal_Opcode()==Op_LoadRange &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  852           !(n-&gt;ideal_Opcode()==Op_LoadKlass &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  853           !(n-&gt;ideal_Opcode()==Op_LoadL     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  854           !(n-&gt;ideal_Opcode()==Op_LoadL_unaligned &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  855           !(n-&gt;ideal_Opcode()==Op_LoadD_unaligned &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  856           !(n-&gt;ideal_Opcode()==Op_ConvI2F   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  857           !(n-&gt;ideal_Opcode()==Op_ConvI2D   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  858           !(n-&gt;ideal_Opcode()==Op_PrefetchAllocation &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  859           !(n-&gt;ideal_Opcode()==Op_LoadVector &amp;&amp; ld_op==Op_LoadD) &amp;&amp;
  860           !(n-&gt;rule() == loadUB_rule)) {
  861         verify_oops_warning(n, n-&gt;ideal_Opcode(), ld_op);
  862       }
  863     } else if (st_op) {
  864       // a Store
  865       // inputs are (0:control, 1:memory, 2:address, 3:value)
  866       if (!(n-&gt;ideal_Opcode()==st_op)    &amp;&amp; // Following are special cases
  867           !(n-&gt;ideal_Opcode()==Op_StoreCM &amp;&amp; st_op==Op_StoreB) &amp;&amp;
  868           !(n-&gt;ideal_Opcode()==Op_StoreI &amp;&amp; st_op==Op_StoreF) &amp;&amp;
  869           !(n-&gt;ideal_Opcode()==Op_StoreF &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  870           !(n-&gt;ideal_Opcode()==Op_StoreL &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  871           !(n-&gt;ideal_Opcode()==Op_StoreVector &amp;&amp; st_op==Op_StoreD) &amp;&amp;
  872           !(n-&gt;ideal_Opcode()==Op_StoreD &amp;&amp; st_op==Op_StoreI &amp;&amp; n-&gt;rule() == storeD0_rule)) {
  873         verify_oops_warning(n, n-&gt;ideal_Opcode(), st_op);
  874       }
  875     }
  876 
  877     if (src2_enc == R_G0_enc &amp;&amp; n-&gt;rule() != loadUB_rule &amp;&amp; n-&gt;ideal_Opcode() != Op_StoreCM ) {
  878       Node* addr = n-&gt;in(2);
  879       if (!(addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP)) {
  880         const TypeOopPtr* atype = addr-&gt;bottom_type()-&gt;isa_instptr();  // %%% oopptr?
  881         if (atype != NULL) {
  882           intptr_t offset = get_offset_from_base(n, atype, disp32);
  883           intptr_t offset_2 = get_offset_from_base_2(n, atype, disp32);
  884           if (offset != offset_2) {
  885             get_offset_from_base(n, atype, disp32);
  886             get_offset_from_base_2(n, atype, disp32);
  887           }
  888           assert(offset == offset_2, &quot;different offsets&quot;);
  889           if (offset == disp32) {
  890             // we now know that src1 is a true oop pointer
  891             is_verified_oop_base = true;
  892             if (ld_op &amp;&amp; src1_enc == dst_enc &amp;&amp; ld_op != Op_LoadF &amp;&amp; ld_op != Op_LoadD) {
  893               if( primary == Assembler::ldd_op3 ) {
  894                 is_verified_oop_base = false; // Cannot &#39;ldd&#39; into O7
  895               } else {
  896                 tmp_enc = dst_enc;
  897                 dst_enc = R_O7_enc; // Load into O7; preserve source oop
  898                 assert(src1_enc != dst_enc, &quot;&quot;);
  899               }
  900             }
  901           }
  902           if (st_op &amp;&amp; (( offset == oopDesc::klass_offset_in_bytes())
  903                        || offset == oopDesc::mark_offset_in_bytes())) {
  904                       // loading the mark should not be allowed either, but
  905                       // we don&#39;t check this since it conflicts with InlineObjectHash
  906                       // usage of LoadINode to get the mark. We could keep the
  907                       // check if we create a new LoadMarkNode
  908             // but do not verify the object before its header is initialized
  909             ShouldNotReachHere();
  910           }
  911         }
  912       }
  913     }
  914   }
  915 #endif
  916 
  917   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  918              | (dst_enc        &lt;&lt; 25)
  919              | (primary        &lt;&lt; 19)
  920              | (src1_enc       &lt;&lt; 14);
  921 
  922   uint index = src2_enc;
  923   int disp = disp32;
  924 
  925   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  926     disp += STACK_BIAS;
  927     // Check that stack offset fits, load into O7 if not
  928     if (!Assembler::is_simm13(disp)) {
  929       C2_MacroAssembler _masm(&amp;cbuf);
  930       __ set(disp, O7);
  931       if (index != R_G0_enc) {
  932         __ add(O7, reg_to_register_object(index), O7);
  933       }
  934       index = R_O7_enc;
  935       disp = 0;
  936     }
  937   }
  938 
  939   if( disp == 0 ) {
  940     // use reg-reg form
  941     // bit 13 is already zero
  942     instr |= index;
  943   } else {
  944     // use reg-imm form
  945     instr |= 0x00002000;          // set bit 13 to one
  946     instr |= disp &amp; 0x1FFF;
  947   }
  948 
  949   cbuf.insts()-&gt;emit_int32(instr);
  950 
  951 #ifdef ASSERT
  952   if (VerifyOops) {
  953     C2_MacroAssembler _masm(&amp;cbuf);
  954     if (is_verified_oop_base) {
  955       __ verify_oop(reg_to_register_object(src1_enc));
  956     }
  957     if (is_verified_oop_store) {
  958       __ verify_oop(reg_to_register_object(dst_enc));
  959     }
  960     if (tmp_enc != -1) {
  961       __ mov(O7, reg_to_register_object(tmp_enc));
  962     }
  963     if (is_verified_oop_load) {
  964       __ verify_oop(reg_to_register_object(dst_enc));
  965     }
  966   }
  967 #endif
  968 }
  969 
  970 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  971   // The method which records debug information at every safepoint
  972   // expects the call to be the first instruction in the snippet as
  973   // it creates a PcDesc structure which tracks the offset of a call
  974   // from the start of the codeBlob. This offset is computed as
  975   // code_end() - code_begin() of the code which has been emitted
  976   // so far.
  977   // In this particular case we have skirted around the problem by
  978   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  979   // may bite us again at some other point and a cleaner/generic
  980   // solution using relocations would be needed.
  981   C2_MacroAssembler _masm(&amp;cbuf);
  982   __ set_inst_mark();
  983 
  984   // We flush the current window just so that there is a valid stack copy
  985   // the fact that the current window becomes active again instantly is
  986   // not a problem there is nothing live in it.
  987 
  988 #ifdef ASSERT
  989   int startpos = __ offset();
  990 #endif /* ASSERT */
  991 
  992   __ call((address)entry_point, rspec);
  993 
  994   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  995   else __ delayed()-&gt;nop();
  996 
  997   if (preserve_g2)   __ mov(L7, G2);
  998 
  999 #ifdef ASSERT
 1000   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
 1001     // Trash argument dump slots.
 1002     __ set(0xb0b8ac0db0b8ac0d, G1);
 1003     __ mov(G1, G5);
 1004     __ stx(G1, SP, STACK_BIAS + 0x80);
 1005     __ stx(G1, SP, STACK_BIAS + 0x88);
 1006     __ stx(G1, SP, STACK_BIAS + 0x90);
 1007     __ stx(G1, SP, STACK_BIAS + 0x98);
 1008     __ stx(G1, SP, STACK_BIAS + 0xA0);
 1009     __ stx(G1, SP, STACK_BIAS + 0xA8);
 1010   }
 1011 #endif /*ASSERT*/
 1012 }
 1013 
 1014 //=============================================================================
 1015 // REQUIRED FUNCTIONALITY for encoding
 1016 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
 1017 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1018 
 1019 
 1020 //=============================================================================
 1021 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1022 
 1023 int ConstantTable::calculate_table_base_offset() const {
 1024   if (UseRDPCForConstantTableBase) {
 1025     // The table base offset might be less but then it fits into
 1026     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1027     return Assembler::min_simm13();
 1028   } else {
 1029     int offset = -(size() / 2);
 1030     if (!Assembler::is_simm13(offset)) {
 1031       offset = Assembler::min_simm13();
 1032     }
 1033     return offset;
 1034   }
 1035 }
 1036 
 1037 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1038 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1039   ShouldNotReachHere();
 1040 }
 1041 
 1042 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1043   Compile* C = ra_-&gt;C;
 1044   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1045   C2_MacroAssembler _masm(&amp;cbuf);
 1046 
 1047   Register r = as_Register(ra_-&gt;get_encode(this));
 1048   CodeSection* consts_section = __ code()-&gt;consts();
 1049   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1050   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1051 
 1052   if (UseRDPCForConstantTableBase) {
 1053     // For the following RDPC logic to work correctly the consts
 1054     // section must be allocated right before the insts section.  This
 1055     // assert checks for that.  The layout and the SECT_* constants
 1056     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1057     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1058     int insts_offset = __ offset();
 1059 
 1060     // Layout:
 1061     //
 1062     // |----------- consts section ------------|----------- insts section -----------...
 1063     // |------ constant table -----|- padding -|------------------x----
 1064     //                                                            \ current PC (RDPC instruction)
 1065     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1066     //                                                            \ table base
 1067     // The table base offset is later added to the load displacement
 1068     // so it has to be negative.
 1069     int table_base_offset = -(consts_size + insts_offset);
 1070     int disp;
 1071 
 1072     // If the displacement from the current PC to the constant table
 1073     // base fits into simm13 we set the constant table base to the
 1074     // current PC.
 1075     if (Assembler::is_simm13(table_base_offset)) {
 1076       constant_table.set_table_base_offset(table_base_offset);
 1077       disp = 0;
 1078     } else {
 1079       // Otherwise we set the constant table base offset to the
 1080       // maximum negative displacement of load instructions to keep
 1081       // the disp as small as possible:
 1082       //
 1083       // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1084       // |&lt;--------- min_simm13 ---------&gt;|&lt;-------- disp ---------&gt;|
 1085       //                                  \ table base
 1086       table_base_offset = Assembler::min_simm13();
 1087       constant_table.set_table_base_offset(table_base_offset);
 1088       disp = (consts_size + insts_offset) + table_base_offset;
 1089     }
 1090 
 1091     __ rdpc(r);
 1092 
 1093     if (disp == 0) {
 1094       // Emitting an additional &#39;nop&#39; instruction in order not to cause a code
 1095       // size adjustment in the code following the table setup (if the instruction
 1096       // immediately following after this section is a CTI).
 1097       __ nop();
 1098     }
 1099     else {
 1100       assert(r != O7, &quot;need temporary&quot;);
 1101       __ sub(r, __ ensure_simm13_or_reg(disp, O7), r);
 1102     }
 1103   }
 1104   else {
 1105     // Materialize the constant table base.
 1106     address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
 1107     RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
 1108     AddressLiteral base(baseaddr, rspec);
 1109     __ set(base, r);
 1110   }
 1111 }
 1112 
 1113 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
 1114   if (UseRDPCForConstantTableBase) {
 1115     // This is really the worst case but generally it&#39;s only 1 instruction.
 1116     return (1 /*rdpc*/ + 1 /*sub*/ + MacroAssembler::worst_case_insts_for_set()) * BytesPerInstWord;
 1117   } else {
 1118     return MacroAssembler::worst_case_insts_for_set() * BytesPerInstWord;
 1119   }
 1120 }
 1121 
 1122 #ifndef PRODUCT
 1123 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1124   char reg[128];
 1125   ra_-&gt;dump_register(this, reg);
 1126   if (UseRDPCForConstantTableBase) {
 1127     st-&gt;print(&quot;RDPC   %s\t! constant table base&quot;, reg);
 1128   } else {
 1129     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1130   }
 1131 }
 1132 #endif
 1133 
 1134 
 1135 //=============================================================================
 1136 
 1137 #ifndef PRODUCT
 1138 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1139   Compile* C = ra_-&gt;C;
 1140 
 1141   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1142     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1143   }
 1144 
 1145   if( VerifyThread ) {
 1146     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1147   }
 1148 
 1149   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
 1150   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
 1151 
 1152   // Calls to C2R adapters often do not accept exceptional returns.
 1153   // We require that their callers must bang for them.  But be careful, because
 1154   // some VM calls (such as call site linkage) can use several kilobytes of
 1155   // stack.  But the stack safety zone should account for that.
 1156   // See bugs 4446381, 4468289, 4497237.
 1157   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
 1158     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1159   }
 1160 
 1161   if (Assembler::is_simm13(-framesize)) {
 1162     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1163   } else {
 1164     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1165     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1166     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1167   }
 1168 
 1169 }
 1170 #endif
 1171 
 1172 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1173   Compile* C = ra_-&gt;C;
 1174   C2_MacroAssembler _masm(&amp;cbuf);
 1175 
 1176   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1177     __ nop();
 1178   }
 1179 
 1180   __ verify_thread();
 1181 
 1182   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
 1183   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1184   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1185   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
 1186 
 1187   // Calls to C2R adapters often do not accept exceptional returns.
 1188   // We require that their callers must bang for them.  But be careful, because
 1189   // some VM calls (such as call site linkage) can use several kilobytes of
 1190   // stack.  But the stack safety zone should account for that.
 1191   // See bugs 4446381, 4468289, 4497237.
 1192   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
 1193     __ generate_stack_overflow_check(bangsize);
 1194   }
 1195 
 1196   if (Assembler::is_simm13(-framesize)) {
 1197     __ save(SP, -framesize, SP);
 1198   } else {
 1199     __ sethi(-framesize &amp; ~0x3ff, G3);
 1200     __ add(G3, -framesize &amp; 0x3ff, G3);
 1201     __ save(SP, G3, SP);
 1202   }
 1203   C-&gt;output()-&gt;set_frame_complete( __ offset() );
 1204 
 1205   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1206     // NOTE: We set the table base offset here because users might be
 1207     // emitted before MachConstantBaseNode.
 1208     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1209     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1210   }
 1211 }
 1212 
 1213 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1214   return MachNode::size(ra_);
 1215 }
 1216 
 1217 int MachPrologNode::reloc() const {
 1218   return 10; // a large enough number
 1219 }
 1220 
 1221 //=============================================================================
 1222 #ifndef PRODUCT
 1223 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1224   Compile* C = ra_-&gt;C;
 1225 
 1226   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1227     st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);
 1228     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1229   }
 1230 
 1231   if(do_polling()) {
 1232     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1233       st-&gt;print(&quot;NOP\n\t&quot;);
 1234     }
 1235     st-&gt;print(&quot;RET\n\t&quot;);
 1236   }
 1237 
 1238   st-&gt;print(&quot;RESTORE&quot;);
 1239 }
 1240 #endif
 1241 
 1242 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1243   C2_MacroAssembler _masm(&amp;cbuf);
 1244   Compile* C = ra_-&gt;C;
 1245 
 1246   __ verify_thread();
 1247 
 1248   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1249     __ reserved_stack_check();
 1250   }
 1251 
 1252   // If this does safepoint polling, then do it here
 1253   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1254     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
 1255     __ relocate(relocInfo::poll_return_type);
 1256     __ ld_ptr(L0, 0, G0);
 1257   }
 1258 
 1259   // If this is a return, then stuff the restore in the delay slot
 1260   if(do_polling()) {
 1261     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1262       // Insert extra padding for the case when the epilogue is preceded by
 1263       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1264       __ nop();
 1265     }
 1266     __ ret();
 1267     __ delayed()-&gt;restore();
 1268   } else {
 1269     __ restore();
 1270   }
 1271 }
 1272 
 1273 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1274   return MachNode::size(ra_);
 1275 }
 1276 
 1277 int MachEpilogNode::reloc() const {
 1278   return 16; // a large enough number
 1279 }
 1280 
 1281 const Pipeline * MachEpilogNode::pipeline() const {
 1282   return MachNode::pipeline_class();
 1283 }
 1284 
 1285 //=============================================================================
 1286 
 1287 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1288 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1289 static enum RC rc_class( OptoReg::Name reg ) {
 1290   if (!OptoReg::is_valid(reg)) return rc_bad;
 1291   if (OptoReg::is_stack(reg)) return rc_stack;
 1292   VMReg r = OptoReg::as_VMReg(reg);
 1293   if (r-&gt;is_Register()) return rc_int;
 1294   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1295   return rc_float;
 1296 }
 1297 
 1298 #ifndef PRODUCT
 1299 ATTRIBUTE_PRINTF(2, 3)
 1300 static void print_helper(outputStream* st, const char* format, ...) {
 1301   const int tab_size = 8;
 1302   if (st-&gt;position() &gt; tab_size) {
 1303     st-&gt;cr();
 1304     st-&gt;sp();
 1305   }
 1306   va_list ap;
 1307   va_start(ap, format);
 1308   st-&gt;vprint(format, ap);
 1309   va_end(ap);
 1310 }
 1311 #endif // !PRODUCT
 1312 
 1313 static void impl_helper(const MachNode* mach, CodeBuffer* cbuf, PhaseRegAlloc* ra, bool is_load, int offset, int reg, int opcode, const char *op_str, outputStream* st) {
 1314   if (cbuf) {
 1315     emit_form3_mem_reg(*cbuf, ra, mach, opcode, -1, R_SP_enc, offset, 0, Matcher::_regEncode[reg]);
 1316   }
 1317 #ifndef PRODUCT
 1318   else {
 1319     if (is_load) {
 1320       print_helper(st, &quot;%s   [R_SP + #%d],R_%s\t! spill&quot;, op_str, offset, OptoReg::regname(reg));
 1321     } else {
 1322       print_helper(st, &quot;%s   R_%s,[R_SP + #%d]\t! spill&quot;, op_str, OptoReg::regname(reg), offset);
 1323     }
 1324   }
 1325 #endif
 1326 }
 1327 
 1328 static void impl_mov_helper(CodeBuffer *cbuf, int src, int dst, int op1, int op2, const char *op_str, outputStream* st) {
 1329   if (cbuf) {
 1330     emit3(*cbuf, Assembler::arith_op, Matcher::_regEncode[dst], op1, 0, op2, Matcher::_regEncode[src]);
 1331   }
 1332 #ifndef PRODUCT
 1333   else {
 1334     print_helper(st, &quot;%s  R_%s,R_%s\t! spill&quot;, op_str, OptoReg::regname(src), OptoReg::regname(dst));
 1335   }
 1336 #endif
 1337 }
 1338 
 1339 static void mach_spill_copy_implementation_helper(const MachNode* mach,
 1340                                                   CodeBuffer *cbuf,
 1341                                                   PhaseRegAlloc *ra_,
 1342                                                   outputStream* st) {
 1343   // Get registers to move
 1344   OptoReg::Name src_second = ra_-&gt;get_reg_second(mach-&gt;in(1));
 1345   OptoReg::Name src_first  = ra_-&gt;get_reg_first(mach-&gt;in(1));
 1346   OptoReg::Name dst_second = ra_-&gt;get_reg_second(mach);
 1347   OptoReg::Name dst_first  = ra_-&gt;get_reg_first(mach);
 1348 
 1349   enum RC src_second_rc = rc_class(src_second);
 1350   enum RC src_first_rc  = rc_class(src_first);
 1351   enum RC dst_second_rc = rc_class(dst_second);
 1352   enum RC dst_first_rc  = rc_class(dst_first);
 1353 
 1354   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot;);
 1355 
 1356   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1357     return; // Self copy, no move
 1358   }
 1359 
 1360   // --------------------------------------
 1361   // Check for mem-mem move.  Load into unused float registers and fall into
 1362   // the float-store case.
 1363   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
 1364     int offset = ra_-&gt;reg2offset(src_first);
 1365     // Further check for aligned-adjacent pair, so we can use a double load
 1366     if ((src_first&amp;1) == 0 &amp;&amp; src_first+1 == src_second) {
 1367       src_second    = OptoReg::Name(R_F31_num);
 1368       src_second_rc = rc_float;
 1369       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1370     } else {
 1371       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1372     }
 1373     src_first    = OptoReg::Name(R_F30_num);
 1374     src_first_rc = rc_float;
 1375   }
 1376 
 1377   if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) {
 1378     int offset = ra_-&gt;reg2offset(src_second);
 1379     impl_helper(mach, cbuf, ra_, true, offset, R_F31_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1380     src_second    = OptoReg::Name(R_F31_num);
 1381     src_second_rc = rc_float;
 1382   }
 1383 
 1384   // --------------------------------------
 1385   // Check for float-&gt;int copy; requires a trip through memory
 1386   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &lt; 3) {
 1387     int offset = frame::register_save_words*wordSize;
 1388     if (cbuf) {
 1389       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::sub_op3, R_SP_enc, 16);
 1390       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1391       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1392       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::add_op3, R_SP_enc, 16);
 1393     }
 1394 #ifndef PRODUCT
 1395     else {
 1396       print_helper(st, &quot;SUB    R_SP,16,R_SP&quot;);
 1397       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1398       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1399       print_helper(st, &quot;ADD    R_SP,16,R_SP&quot;);
 1400     }
 1401 #endif
 1402   }
 1403 
 1404   // Check for float-&gt;int copy on T4
 1405   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &gt;= 3) {
 1406     // Further check for aligned-adjacent pair, so we can use a double move
 1407     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1408       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mdtox_opf, &quot;MOVDTOX&quot;, st);
 1409       return;
 1410     }
 1411     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mstouw_opf, &quot;MOVSTOUW&quot;, st);
 1412   }
 1413   // Check for int-&gt;float copy on T4
 1414   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_float &amp;&amp; UseVIS &gt;= 3) {
 1415     // Further check for aligned-adjacent pair, so we can use a double move
 1416     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1417       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mxtod_opf, &quot;MOVXTOD&quot;, st);
 1418       return;
 1419     }
 1420     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mwtos_opf, &quot;MOVWTOS&quot;, st);
 1421   }
 1422 
 1423   // --------------------------------------
 1424   // In the 32-bit 1-reg-longs build ONLY, I see mis-aligned long destinations.
 1425   // In such cases, I have to do the big-endian swap.  For aligned targets, the
 1426   // hardware does the flop for me.  Doubles are always aligned, so no problem
 1427   // there.  Misaligned sources only come from native-long-returns (handled
 1428   // special below).
 1429 
 1430   // --------------------------------------
 1431   // Check for integer reg-reg copy
 1432   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int) {
 1433     // Else normal reg-reg copy
 1434     assert(src_second != dst_first, &quot;smashed second before evacuating it&quot;);
 1435     impl_mov_helper(cbuf, src_first, dst_first, Assembler::or_op3, 0, &quot;MOV  &quot;, st);
 1436     assert((src_first &amp; 1) == 0 &amp;&amp; (dst_first &amp; 1) == 0, &quot;never move second-halves of int registers&quot;);
 1437     // This moves an aligned adjacent pair.
 1438     // See if we are done.
 1439     if (src_first + 1 == src_second &amp;&amp; dst_first + 1 == dst_second) {
 1440       return;
 1441     }
 1442   }
 1443 
 1444   // Check for integer store
 1445   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack) {
 1446     int offset = ra_-&gt;reg2offset(dst_first);
 1447     // Further check for aligned-adjacent pair, so we can use a double store
 1448     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1449       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stx_op3, &quot;STX &quot;, st);
 1450       return;
 1451     }
 1452     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stw_op3, &quot;STW &quot;, st);
 1453   }
 1454 
 1455   // Check for integer load
 1456   if (dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack) {
 1457     int offset = ra_-&gt;reg2offset(src_first);
 1458     // Further check for aligned-adjacent pair, so we can use a double load
 1459     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1460       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldx_op3, &quot;LDX &quot;, st);
 1461       return;
 1462     }
 1463     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1464   }
 1465 
 1466   // Check for float reg-reg copy
 1467   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float) {
 1468     // Further check for aligned-adjacent pair, so we can use a double move
 1469     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1470       impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovd_opf, &quot;FMOVD&quot;, st);
 1471       return;
 1472     }
 1473     impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovs_opf, &quot;FMOVS&quot;, st);
 1474   }
 1475 
 1476   // Check for float store
 1477   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack) {
 1478     int offset = ra_-&gt;reg2offset(dst_first);
 1479     // Further check for aligned-adjacent pair, so we can use a double store
 1480     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1481       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stdf_op3, &quot;STDF&quot;, st);
 1482       return;
 1483     }
 1484     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stf_op3, &quot;STF &quot;, st);
 1485   }
 1486 
 1487   // Check for float load
 1488   if (dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack) {
 1489     int offset = ra_-&gt;reg2offset(src_first);
 1490     // Further check for aligned-adjacent pair, so we can use a double load
 1491     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1492       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1493       return;
 1494     }
 1495     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1496   }
 1497 
 1498   // --------------------------------------------------------------------
 1499   // Check for hi bits still needing moving.  Only happens for misaligned
 1500   // arguments to native calls.
 1501   if (src_second == dst_second) {
 1502     return; // Self copy; no move
 1503   }
 1504   assert(src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot;);
 1505 
 1506   Unimplemented();
 1507 }
 1508 
 1509 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf,
 1510                                        PhaseRegAlloc *ra_,
 1511                                        bool do_size,
 1512                                        outputStream* st) const {
 1513   assert(!do_size, &quot;not supported&quot;);
 1514   mach_spill_copy_implementation_helper(this, cbuf, ra_, st);
 1515   return 0;
 1516 }
 1517 
 1518 #ifndef PRODUCT
 1519 void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1520   implementation( NULL, ra_, false, st );
 1521 }
 1522 #endif
 1523 
 1524 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1525   implementation( &amp;cbuf, ra_, false, NULL );
 1526 }
 1527 
 1528 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1529   return MachNode::size(ra_);
 1530 }
 1531 
 1532 //=============================================================================
 1533 #ifndef PRODUCT
 1534 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1535   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1536 }
 1537 #endif
 1538 
 1539 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 1540   C2_MacroAssembler _masm(&amp;cbuf);
 1541   for (int i = 0; i &lt; _count; i += 1) {
 1542     __ nop();
 1543   }
 1544 }
 1545 
 1546 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1547   return 4 * _count;
 1548 }
 1549 
 1550 
 1551 //=============================================================================
 1552 #ifndef PRODUCT
 1553 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1554   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1555   int reg = ra_-&gt;get_reg_first(this);
 1556   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1557 }
 1558 #endif
 1559 
 1560 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1561   C2_MacroAssembler _masm(&amp;cbuf);
 1562   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1563   int reg = ra_-&gt;get_encode(this);
 1564 
 1565   if (Assembler::is_simm13(offset)) {
 1566      __ add(SP, offset, reg_to_register_object(reg));
 1567   } else {
 1568      __ set(offset, O7);
 1569      __ add(SP, O7, reg_to_register_object(reg));
 1570   }
 1571 }
 1572 
 1573 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1574   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1575   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
 1576   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);
 1577 }
 1578 
 1579 //=============================================================================
 1580 #ifndef PRODUCT
 1581 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1582   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1583   if (UseCompressedClassPointers) {
 1584     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1585     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1586     if (CompressedKlassPointers::base() != 0) {
 1587       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1588       if (CompressedKlassPointers::shift() != 0) {
 1589         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1590       }
 1591       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1592       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1593     } else {
 1594       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1595     }
 1596   } else {
 1597     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1598   }
 1599   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1600   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1601 }
 1602 #endif
 1603 
 1604 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1605   C2_MacroAssembler _masm(&amp;cbuf);
 1606   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1607   Register temp_reg   = G3;
 1608   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1609 
 1610   // Load klass from receiver
 1611   __ load_klass(O0, temp_reg);
 1612   // Compare against expected klass
 1613   __ cmp(temp_reg, G5_ic_reg);
 1614   // Branch to miss code, checks xcc or icc depending
 1615   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1616 }
 1617 
 1618 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1619   return MachNode::size(ra_);
 1620 }
 1621 
 1622 
 1623 //=============================================================================
 1624 
 1625 
 1626 // Emit exception handler code.
 1627 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1628   Register temp_reg = G3;
 1629   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
 1630   C2_MacroAssembler _masm(&amp;cbuf);
 1631 
 1632   address base = __ start_a_stub(size_exception_handler());
 1633   if (base == NULL) {
 1634     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1635     return 0;  // CodeBuffer::expand failed
 1636   }
 1637 
 1638   int offset = __ offset();
 1639 
 1640   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1641   __ delayed()-&gt;nop();
 1642 
 1643   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1644 
 1645   __ end_a_stub();
 1646 
 1647   return offset;
 1648 }
 1649 
 1650 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1651   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1652   // at a poll and everything (including G3) can be live.
 1653   Register temp_reg = L0;
 1654   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 1655   C2_MacroAssembler _masm(&amp;cbuf);
 1656 
 1657   address base = __ start_a_stub(size_deopt_handler());
 1658   if (base == NULL) {
 1659     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1660     return 0;  // CodeBuffer::expand failed
 1661   }
 1662 
 1663   int offset = __ offset();
 1664   __ save_frame(0);
 1665   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1666   __ delayed()-&gt;restore();
 1667 
 1668   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1669 
 1670   __ end_a_stub();
 1671   return offset;
 1672 
 1673 }
 1674 
 1675 // Given a register encoding, produce a Integer Register object
 1676 static Register reg_to_register_object(int register_encoding) {
 1677   assert(L5-&gt;encoding() == R_L5_enc &amp;&amp; G1-&gt;encoding() == R_G1_enc, &quot;right coding&quot;);
 1678   return as_Register(register_encoding);
 1679 }
 1680 
 1681 // Given a register encoding, produce a single-precision Float Register object
 1682 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding) {
 1683   assert(F5-&gt;encoding(FloatRegisterImpl::S) == R_F5_enc &amp;&amp; F12-&gt;encoding(FloatRegisterImpl::S) == R_F12_enc, &quot;right coding&quot;);
 1684   return as_SingleFloatRegister(register_encoding);
 1685 }
 1686 
 1687 // Given a register encoding, produce a double-precision Float Register object
 1688 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding) {
 1689   assert(F4-&gt;encoding(FloatRegisterImpl::D) == R_F4_enc, &quot;right coding&quot;);
 1690   assert(F32-&gt;encoding(FloatRegisterImpl::D) == R_D32_enc, &quot;right coding&quot;);
 1691   return as_DoubleFloatRegister(register_encoding);
 1692 }
 1693 
 1694 const bool Matcher::match_rule_supported(int opcode) {
 1695   if (!has_match_rule(opcode))
 1696     return false;
 1697 
 1698   switch (opcode) {
 1699   case Op_CountLeadingZerosI:
 1700   case Op_CountLeadingZerosL:
 1701   case Op_CountTrailingZerosI:
 1702   case Op_CountTrailingZerosL:
 1703   case Op_PopCountI:
 1704   case Op_PopCountL:
 1705     if (!UsePopCountInstruction)
 1706       return false;
 1707   case Op_CompareAndSwapL:
 1708   case Op_CompareAndSwapP:
 1709     if (!VM_Version::supports_cx8())
 1710       return false;
 1711     break;
 1712   }
 1713 
 1714   return true;  // Per default match rules are supported.
 1715 }
 1716 
 1717 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1718 
 1719   // TODO
 1720   // identify extra cases that we might want to provide match rules for
 1721   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 1722   bool ret_value = match_rule_supported(opcode);
 1723   // Add rules here.
 1724 
 1725   return ret_value;  // Per default match rules are supported.
 1726 }
 1727 
 1728 const bool Matcher::has_predicated_vectors(void) {
 1729   return false;
 1730 }
 1731 
 1732 const int Matcher::float_pressure(int default_pressure_threshold) {
 1733   return default_pressure_threshold;
 1734 }
 1735 
 1736 int Matcher::regnum_to_fpu_offset(int regnum) {
 1737   return regnum - 32; // The FP registers are in the second chunk
 1738 }
 1739 
 1740 #ifdef ASSERT
 1741 address last_rethrow = NULL;  // debugging aid for Rethrow encoding
 1742 #endif
 1743 
 1744 // Vector width in bytes
 1745 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1746   assert(MaxVectorSize == 8, &quot;&quot;);
 1747   return 8;
 1748 }
 1749 
 1750 // Vector ideal reg
 1751 const uint Matcher::vector_ideal_reg(int size) {
 1752   assert(MaxVectorSize == 8, &quot;&quot;);
 1753   return Op_RegD;
 1754 }
 1755 
 1756 // Limits on vector size (number of elements) loaded into vector.
 1757 const int Matcher::max_vector_size(const BasicType bt) {
 1758   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1759   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1760 }
 1761 
 1762 const int Matcher::min_vector_size(const BasicType bt) {
 1763   return max_vector_size(bt); // Same as max.
 1764 }
 1765 
 1766 // SPARC doesn&#39;t support misaligned vectors store/load.
 1767 const bool Matcher::misaligned_vectors_ok() {
 1768   return false;
 1769 }
 1770 
 1771 // Current (2013) SPARC platforms need to read original key
 1772 // to construct decryption expanded key
 1773 const bool Matcher::pass_original_key_for_aes() {
 1774   return true;
 1775 }
 1776 
 1777 // NOTE: All currently supported SPARC HW provides fast conversion.
 1778 const bool Matcher::convL2FSupported(void) { return true; }
 1779 
 1780 // Is this branch offset short enough that a short branch can be used?
 1781 //
 1782 // NOTE: If the platform does not provide any short branch variants, then
 1783 //       this method should return false for offset 0.
 1784 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1785   // The passed offset is relative to address of the branch.
 1786   // Don&#39;t need to adjust the offset.
 1787   return UseCBCond &amp;&amp; Assembler::is_simm12(offset);
 1788 }
 1789 
 1790 const bool Matcher::isSimpleConstant64(jlong value) {
 1791   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1792   // Depends on optimizations in MacroAssembler::setx.
 1793   int hi = (int)(value &gt;&gt; 32);
 1794   int lo = (int)(value &amp; ~0);
 1795   return (hi == 0) || (hi == -1) || (lo == 0);
 1796 }
 1797 
 1798 // No scaling for the parameter the ClearArray node.
 1799 const bool Matcher::init_array_count_is_in_bytes = true;
 1800 
 1801 // No additional cost for CMOVL.
 1802 const int Matcher::long_cmove_cost() { return 0; }
 1803 
 1804 // CMOVF/CMOVD are expensive on e.g., T4 and SPARC64.
 1805 const int Matcher::float_cmove_cost() {
 1806   return VM_Version::has_fast_cmove() ? 0 : ConditionalMoveLimit;
 1807 }
 1808 
 1809 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1810 const bool Matcher::require_postalloc_expand = false;
 1811 
 1812 // Do we need to mask the count passed to shift instructions or does
 1813 // the cpu only look at the lower 5/6 bits anyway?
 1814 const bool Matcher::need_masked_shift_count = false;
 1815 
 1816 // No support for generic vector operands.
 1817 const bool Matcher::supports_generic_vector_operands  = false;
 1818 
 1819 MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1820   ShouldNotReachHere(); // generic vector operands not supported
 1821   return NULL;
 1822 }
 1823 
 1824 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1825   ShouldNotReachHere();  // generic vector operands not supported
 1826   return false;
 1827 }
 1828 
 1829 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1830   ShouldNotReachHere();  // generic vector operands not supported
 1831   return false;
 1832 }
 1833 
 1834 bool Matcher::narrow_oop_use_complex_address() {
 1835   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1836   return false;
 1837 }
 1838 
 1839 bool Matcher::narrow_klass_use_complex_address() {
 1840   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1841   return false;
 1842 }
 1843 
 1844 bool Matcher::const_oop_prefer_decode() {
 1845   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1846   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1847   // return CompressedOops::base() == NULL;
 1848   return true;
 1849 }
 1850 
 1851 bool Matcher::const_klass_prefer_decode() {
 1852   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1853   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1854   // return CompressedKlassPointers::base() == NULL;
 1855   return true;
 1856 }
 1857 
 1858 // Is it better to copy float constants, or load them directly from memory?
 1859 // Intel can load a float constant from a direct address, requiring no
 1860 // extra registers.  Most RISCs will have to materialize an address into a
 1861 // register first, so they would do better to copy the constant from stack.
 1862 const bool Matcher::rematerialize_float_constants = false;
 1863 
 1864 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1865 // needed.  Else we split the double into 2 integer pieces and move it
 1866 // piece-by-piece.  Only happens when passing doubles into C code as the
 1867 // Java calling convention forces doubles to be aligned.
 1868 const bool Matcher::misaligned_doubles_ok = true;
 1869 
 1870 // No-op on SPARC.
 1871 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1872 }
 1873 
 1874 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1875 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1876 
 1877 // Are floats converted to double when stored to stack during deoptimization?
 1878 // Sparc does not handle callee-save floats.
 1879 bool Matcher::float_in_double() { return false; }
 1880 
 1881 // Do ints take an entire long register or just half?
 1882 // Note that we if-def off of _LP64.
 1883 // The relevant question is how the int is callee-saved.  In _LP64
 1884 // the whole long is written but de-opt&#39;ing will have to extract
 1885 // the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
 1886 const bool Matcher::int_in_long = true;
 1887 
 1888 // Return whether or not this register is ever used as an argument.  This
 1889 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1890 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1891 // arguments in those registers not be available to the callee.
 1892 bool Matcher::can_be_java_arg( int reg ) {
 1893   // Standard sparc 6 args in registers
 1894   if( reg == R_I0_num ||
 1895       reg == R_I1_num ||
 1896       reg == R_I2_num ||
 1897       reg == R_I3_num ||
 1898       reg == R_I4_num ||
 1899       reg == R_I5_num ) return true;
 1900   // 64-bit builds can pass 64-bit pointers and longs in
 1901   // the high I registers
 1902   if( reg == R_I0H_num ||
 1903       reg == R_I1H_num ||
 1904       reg == R_I2H_num ||
 1905       reg == R_I3H_num ||
 1906       reg == R_I4H_num ||
 1907       reg == R_I5H_num ) return true;
 1908 
 1909   if ((UseCompressedOops) &amp;&amp; (reg == R_G6_num || reg == R_G6H_num)) {
 1910     return true;
 1911   }
 1912 
 1913   // A few float args in registers
 1914   if( reg &gt;= R_F0_num &amp;&amp; reg &lt;= R_F7_num ) return true;
 1915 
 1916   return false;
 1917 }
 1918 
 1919 bool Matcher::is_spillable_arg( int reg ) {
 1920   return can_be_java_arg(reg);
 1921 }
 1922 
 1923 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1924   // Use hardware SDIVX instruction when it is
 1925   // faster than a code which use multiply.
 1926   return VM_Version::has_fast_idiv();
 1927 }
 1928 
 1929 // Register for DIVI projection of divmodI
 1930 RegMask Matcher::divI_proj_mask() {
 1931   ShouldNotReachHere();
 1932   return RegMask();
 1933 }
 1934 
 1935 // Register for MODI projection of divmodI
 1936 RegMask Matcher::modI_proj_mask() {
 1937   ShouldNotReachHere();
 1938   return RegMask();
 1939 }
 1940 
 1941 // Register for DIVL projection of divmodL
 1942 RegMask Matcher::divL_proj_mask() {
 1943   ShouldNotReachHere();
 1944   return RegMask();
 1945 }
 1946 
 1947 // Register for MODL projection of divmodL
 1948 RegMask Matcher::modL_proj_mask() {
 1949   ShouldNotReachHere();
 1950   return RegMask();
 1951 }
 1952 
 1953 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1954   return L7_REGP_mask();
 1955 }
 1956 
 1957 
 1958 const bool Matcher::convi2l_type_required = true;
 1959 
 1960 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?
 1961 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {
 1962   return false;
 1963 }
 1964 
 1965 // Should the Matcher clone shifts on addressing modes, expecting them
 1966 // to be subsumed into complex addressing expressions or compute them
 1967 // into registers?
 1968 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1969   return clone_base_plus_offset_address(m, mstack, address_visited);
 1970 }
 1971 
 1972 void Compile::reshape_address(AddPNode* addp) {
 1973 }
 1974 
 1975 %}
 1976 
 1977 
 1978 // The intptr_t operand types, defined by textual substitution.
 1979 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1980 #define immX      immL
 1981 #define immX13    immL13
 1982 #define immX13m7  immL13m7
 1983 #define iRegX     iRegL
 1984 #define g1RegX    g1RegL
 1985 
 1986 //----------ENCODING BLOCK-----------------------------------------------------
 1987 // This block specifies the encoding classes used by the compiler to output
 1988 // byte streams.  Encoding classes are parameterized macros used by
 1989 // Machine Instruction Nodes in order to generate the bit encoding of the
 1990 // instruction.  Operands specify their base encoding interface with the
 1991 // interface keyword.  There are currently supported four interfaces,
 1992 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1993 // operand to generate a function which returns its register number when
 1994 // queried.   CONST_INTER causes an operand to generate a function which
 1995 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1996 // operand to generate four functions which return the Base Register, the
 1997 // Index Register, the Scale Value, and the Offset Value of the operand when
 1998 // queried.  COND_INTER causes an operand to generate six functions which
 1999 // return the encoding code (ie - encoding bits for the instruction)
 2000 // associated with each basic boolean condition for a conditional instruction.
 2001 //
 2002 // Instructions specify two basic values for encoding.  Again, a function
 2003 // is available to check if the constant displacement is an oop. They use the
 2004 // ins_encode keyword to specify their encoding classes (which must be
 2005 // a sequence of enc_class names, and their parameters, specified in
 2006 // the encoding block), and they use the
 2007 // opcode keyword to specify, in order, their primary, secondary, and
 2008 // tertiary opcode.  Only the opcode sections which a particular instruction
 2009 // needs for encoding need to be specified.
 2010 encode %{
 2011   enc_class enc_untested %{
 2012 #ifdef ASSERT
 2013     C2_MacroAssembler _masm(&amp;cbuf);
 2014     __ untested(&quot;encoding&quot;);
 2015 #endif
 2016   %}
 2017 
 2018   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2019     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2020                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2021   %}
 2022 
 2023   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2024     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2025                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2026   %}
 2027 
 2028   enc_class form3_mem_prefetch_read( memory mem ) %{
 2029     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2030                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2031   %}
 2032 
 2033   enc_class form3_mem_prefetch_write( memory mem ) %{
 2034     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2035                        $mem$$base, $mem$$disp, $mem$$index, 2/*prefetch function many-writes*/);
 2036   %}
 2037 
 2038   enc_class form3_mem_reg_long_unaligned_marshal( memory mem, iRegL reg ) %{
 2039     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2040     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2041     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2042     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, R_O7_enc );
 2043     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg );
 2044     emit3_simm13( cbuf, Assembler::arith_op, $reg$$reg, Assembler::sllx_op3, $reg$$reg, 0x1020 );
 2045     emit3( cbuf, Assembler::arith_op, $reg$$reg, Assembler::or_op3, $reg$$reg, 0, R_O7_enc );
 2046   %}
 2047 
 2048   enc_class form3_mem_reg_double_unaligned( memory mem, RegD_low reg ) %{
 2049     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2050     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2051     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2052     // Load long with 2 instructions
 2053     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg+0 );
 2054     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, $reg$$reg+1 );
 2055   %}
 2056 
 2057   //%%% form3_mem_plus_4_reg is a hack--get rid of it
 2058   enc_class form3_mem_plus_4_reg( memory mem, iRegI dst ) %{
 2059     guarantee($mem$$disp, &quot;cannot offset a reg-reg operand by 4&quot;);
 2060     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp + 4, $mem$$index, $dst$$reg);
 2061   %}
 2062 
 2063   enc_class form3_g0_rs2_rd_move( iRegI rs2, iRegI rd ) %{
 2064     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2065     if( $rs2$$reg != $rd$$reg )
 2066       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, $rs2$$reg );
 2067   %}
 2068 
 2069   // Target lo half of long
 2070   enc_class form3_g0_rs2_rd_move_lo( iRegI rs2, iRegL rd ) %{
 2071     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2072     if( $rs2$$reg != LONG_LO_REG($rd$$reg) )
 2073       emit3( cbuf, Assembler::arith_op, LONG_LO_REG($rd$$reg), Assembler::or_op3, 0, 0, $rs2$$reg );
 2074   %}
 2075 
 2076   // Source lo half of long
 2077   enc_class form3_g0_rs2_rd_move_lo2( iRegL rs2, iRegI rd ) %{
 2078     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2079     if( LONG_LO_REG($rs2$$reg) != $rd$$reg )
 2080       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_LO_REG($rs2$$reg) );
 2081   %}
 2082 
 2083   // Target hi half of long
 2084   enc_class form3_rs1_rd_copysign_hi( iRegI rs1, iRegL rd ) %{
 2085     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 31 );
 2086   %}
 2087 
 2088   // Source lo half of long, and leave it sign extended.
 2089   enc_class form3_rs1_rd_signextend_lo1( iRegL rs1, iRegI rd ) %{
 2090     // Sign extend low half
 2091     emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 0, 0 );
 2092   %}
 2093 
 2094   // Source hi half of long, and leave it sign extended.
 2095   enc_class form3_rs1_rd_copy_hi1( iRegL rs1, iRegI rd ) %{
 2096     // Shift high half to low half
 2097     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::srlx_op3, $rs1$$reg, 32 );
 2098   %}
 2099 
 2100   // Source hi half of long
 2101   enc_class form3_g0_rs2_rd_move_hi2( iRegL rs2, iRegI rd ) %{
 2102     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2103     if( LONG_HI_REG($rs2$$reg) != $rd$$reg )
 2104       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_HI_REG($rs2$$reg) );
 2105   %}
 2106 
 2107   enc_class form3_rs1_rs2_rd( iRegI rs1, iRegI rs2, iRegI rd ) %{
 2108     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0, $rs2$$reg );
 2109   %}
 2110 
 2111   enc_class enc_to_bool( iRegI src, iRegI dst ) %{
 2112     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, 0, 0, $src$$reg );
 2113     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::addc_op3 , 0, 0 );
 2114   %}
 2115 
 2116   enc_class enc_ltmask( iRegI p, iRegI q, iRegI dst ) %{
 2117     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, $p$$reg, 0, $q$$reg );
 2118     // clear if nothing else is happening
 2119     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  0 );
 2120     // blt,a,pn done
 2121     emit2_19    ( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less, Assembler::bp_op2, Assembler::icc, 0/*predict not taken*/, 2 );
 2122     // mov dst,-1 in delay slot
 2123     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2124   %}
 2125 
 2126   enc_class form3_rs1_imm5_rd( iRegI rs1, immU5 imm5, iRegI rd ) %{
 2127     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $imm5$$constant &amp; 0x1F );
 2128   %}
 2129 
 2130   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2131     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2132   %}
 2133 
 2134   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2135     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2136   %}
 2137 
 2138   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2139     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2140   %}
 2141 
 2142   enc_class move_return_pc_to_o1() %{
 2143     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2144   %}
 2145 
 2146   /* %%% merge with enc_to_bool */
 2147   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
 2148     C2_MacroAssembler _masm(&amp;cbuf);
 2149 
 2150     Register   src_reg = reg_to_register_object($src$$reg);
 2151     Register   dst_reg = reg_to_register_object($dst$$reg);
 2152     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2153   %}
 2154 
 2155   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2156     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
 2157     C2_MacroAssembler _masm(&amp;cbuf);
 2158 
 2159     Register   p_reg = reg_to_register_object($p$$reg);
 2160     Register   q_reg = reg_to_register_object($q$$reg);
 2161     Register   y_reg = reg_to_register_object($y$$reg);
 2162     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2163 
 2164     __ subcc( p_reg, q_reg,   p_reg );
 2165     __ add  ( p_reg, y_reg, tmp_reg );
 2166     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2167   %}
 2168 
 2169   enc_class form_d2i_helper(regD src, regF dst) %{
 2170     // fcmp %fcc0,$src,$src
 2171     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2172     // branch %fcc0 not-nan, predict taken
 2173     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2174     // fdtoi $src,$dst
 2175     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2176     // fitos $dst,$dst (if nan)
 2177     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2178     // clear $dst (if nan)
 2179     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2180     // carry on here...
 2181   %}
 2182 
 2183   enc_class form_d2l_helper(regD src, regD dst) %{
 2184     // fcmp %fcc0,$src,$src  check for NAN
 2185     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2186     // branch %fcc0 not-nan, predict taken
 2187     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2188     // fdtox $src,$dst   convert in delay slot
 2189     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtox_opf, $src$$reg );
 2190     // fxtod $dst,$dst  (if nan)
 2191     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2192     // clear $dst (if nan)
 2193     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2194     // carry on here...
 2195   %}
 2196 
 2197   enc_class form_f2i_helper(regF src, regF dst) %{
 2198     // fcmps %fcc0,$src,$src
 2199     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2200     // branch %fcc0 not-nan, predict taken
 2201     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2202     // fstoi $src,$dst
 2203     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstoi_opf, $src$$reg );
 2204     // fitos $dst,$dst (if nan)
 2205     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2206     // clear $dst (if nan)
 2207     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2208     // carry on here...
 2209   %}
 2210 
 2211   enc_class form_f2l_helper(regF src, regD dst) %{
 2212     // fcmps %fcc0,$src,$src
 2213     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2214     // branch %fcc0 not-nan, predict taken
 2215     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2216     // fstox $src,$dst
 2217     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstox_opf, $src$$reg );
 2218     // fxtod $dst,$dst (if nan)
 2219     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2220     // clear $dst (if nan)
 2221     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2222     // carry on here...
 2223   %}
 2224 
 2225   enc_class form3_opf_rs2F_rdF(regF rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2226   enc_class form3_opf_rs2F_rdD(regF rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2227   enc_class form3_opf_rs2D_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2228   enc_class form3_opf_rs2D_rdD(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2229 
 2230   enc_class form3_opf_rs2D_lo_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg+1); %}
 2231 
 2232   enc_class form3_opf_rs2D_hi_rdD_hi(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2233   enc_class form3_opf_rs2D_lo_rdD_lo(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg+1,$primary,0,$tertiary,$rs2$$reg+1); %}
 2234 
 2235   enc_class form3_opf_rs1F_rs2F_rdF( regF rs1, regF rs2, regF rd ) %{
 2236     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2237   %}
 2238 
 2239   enc_class form3_opf_rs1D_rs2D_rdD( regD rs1, regD rs2, regD rd ) %{
 2240     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2241   %}
 2242 
 2243   enc_class form3_opf_rs1F_rs2F_fcc( regF rs1, regF rs2, flagsRegF fcc ) %{
 2244     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2245   %}
 2246 
 2247   enc_class form3_opf_rs1D_rs2D_fcc( regD rs1, regD rs2, flagsRegF fcc ) %{
 2248     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2249   %}
 2250 
 2251   enc_class form3_convI2F(regF rs2, regF rd) %{
 2252     emit3(cbuf,Assembler::arith_op,$rd$$reg,Assembler::fpop1_op3,0,$secondary,$rs2$$reg);
 2253   %}
 2254 
 2255   // Encloding class for traceable jumps
 2256   enc_class form_jmpl(g3RegP dest) %{
 2257     emit_jmpl(cbuf, $dest$$reg);
 2258   %}
 2259 
 2260   enc_class form_jmpl_set_exception_pc(g1RegP dest) %{
 2261     emit_jmpl_set_exception_pc(cbuf, $dest$$reg);
 2262   %}
 2263 
 2264   enc_class form2_nop() %{
 2265     emit_nop(cbuf);
 2266   %}
 2267 
 2268   enc_class form2_illtrap() %{
 2269     emit_illtrap(cbuf);
 2270   %}
 2271 
 2272 
 2273   // Compare longs and convert into -1, 0, 1.
 2274   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2275     // CMP $src1,$src2
 2276     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2277     // blt,a,pn done
 2278     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2279     // mov dst,-1 in delay slot
 2280     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2281     // bgt,a,pn done
 2282     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2283     // mov dst,1 in delay slot
 2284     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2285     // CLR    $dst
 2286     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2287   %}
 2288 
 2289   enc_class enc_PartialSubtypeCheck() %{
 2290     C2_MacroAssembler _masm(&amp;cbuf);
 2291     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2292     __ delayed()-&gt;nop();
 2293   %}
 2294 
 2295   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
 2296     C2_MacroAssembler _masm(&amp;cbuf);
 2297     Label* L = $labl$$label;
 2298     Assembler::Predict predict_taken =
 2299       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2300 
 2301     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2302     __ delayed()-&gt;nop();
 2303   %}
 2304 
 2305   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
 2306     C2_MacroAssembler _masm(&amp;cbuf);
 2307     Label* L = $labl$$label;
 2308     Assembler::Predict predict_taken =
 2309       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2310 
 2311     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2312     __ delayed()-&gt;nop();
 2313   %}
 2314 
 2315   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2316     int op = (Assembler::arith_op &lt;&lt; 30) |
 2317              ($dst$$reg &lt;&lt; 25) |
 2318              (Assembler::movcc_op3 &lt;&lt; 19) |
 2319              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2320              ($cmp$$cmpcode &lt;&lt; 14) |
 2321              (0 &lt;&lt; 13) |                    // select register move
 2322              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2323              ($src$$reg &lt;&lt; 0);
 2324     cbuf.insts()-&gt;emit_int32(op);
 2325   %}
 2326 
 2327   enc_class enc_cmov_imm( cmpOp cmp, iRegI dst, immI11 src, immI pcc ) %{
 2328     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2329     int op = (Assembler::arith_op &lt;&lt; 30) |
 2330              ($dst$$reg &lt;&lt; 25) |
 2331              (Assembler::movcc_op3 &lt;&lt; 19) |
 2332              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2333              ($cmp$$cmpcode &lt;&lt; 14) |
 2334              (1 &lt;&lt; 13) |                    // select immediate move
 2335              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39;
 2336              (simm11 &lt;&lt; 0);
 2337     cbuf.insts()-&gt;emit_int32(op);
 2338   %}
 2339 
 2340   enc_class enc_cmov_reg_f( cmpOpF cmp, iRegI dst, iRegI src, flagsRegF fcc ) %{
 2341     int op = (Assembler::arith_op &lt;&lt; 30) |
 2342              ($dst$$reg &lt;&lt; 25) |
 2343              (Assembler::movcc_op3 &lt;&lt; 19) |
 2344              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2345              ($cmp$$cmpcode &lt;&lt; 14) |
 2346              (0 &lt;&lt; 13) |                    // select register move
 2347              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2348              ($src$$reg &lt;&lt; 0);
 2349     cbuf.insts()-&gt;emit_int32(op);
 2350   %}
 2351 
 2352   enc_class enc_cmov_imm_f( cmpOp cmp, iRegI dst, immI11 src, flagsRegF fcc ) %{
 2353     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2354     int op = (Assembler::arith_op &lt;&lt; 30) |
 2355              ($dst$$reg &lt;&lt; 25) |
 2356              (Assembler::movcc_op3 &lt;&lt; 19) |
 2357              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2358              ($cmp$$cmpcode &lt;&lt; 14) |
 2359              (1 &lt;&lt; 13) |                    // select immediate move
 2360              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2361              (simm11 &lt;&lt; 0);
 2362     cbuf.insts()-&gt;emit_int32(op);
 2363   %}
 2364 
 2365   enc_class enc_cmovf_reg( cmpOp cmp, regD dst, regD src, immI pcc ) %{
 2366     int op = (Assembler::arith_op &lt;&lt; 30) |
 2367              ($dst$$reg &lt;&lt; 25) |
 2368              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2369              (0 &lt;&lt; 18) |
 2370              ($cmp$$cmpcode &lt;&lt; 14) |
 2371              (1 &lt;&lt; 13) |                    // select register move
 2372              ($pcc$$constant &lt;&lt; 11) |       // cc1-cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2373              ($primary &lt;&lt; 5) |              // select single, double or quad
 2374              ($src$$reg &lt;&lt; 0);
 2375     cbuf.insts()-&gt;emit_int32(op);
 2376   %}
 2377 
 2378   enc_class enc_cmovff_reg( cmpOpF cmp, flagsRegF fcc, regD dst, regD src ) %{
 2379     int op = (Assembler::arith_op &lt;&lt; 30) |
 2380              ($dst$$reg &lt;&lt; 25) |
 2381              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2382              (0 &lt;&lt; 18) |
 2383              ($cmp$$cmpcode &lt;&lt; 14) |
 2384              ($fcc$$reg &lt;&lt; 11) |            // cc2-cc0 bits for &#39;fccX&#39;
 2385              ($primary &lt;&lt; 5) |              // select single, double or quad
 2386              ($src$$reg &lt;&lt; 0);
 2387     cbuf.insts()-&gt;emit_int32(op);
 2388   %}
 2389 
 2390   // Used by the MIN/MAX encodings.  Same as a CMOV, but
 2391   // the condition comes from opcode-field instead of an argument.
 2392   enc_class enc_cmov_reg_minmax( iRegI dst, iRegI src ) %{
 2393     int op = (Assembler::arith_op &lt;&lt; 30) |
 2394              ($dst$$reg &lt;&lt; 25) |
 2395              (Assembler::movcc_op3 &lt;&lt; 19) |
 2396              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2397              ($primary &lt;&lt; 14) |
 2398              (0 &lt;&lt; 13) |                    // select register move
 2399              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2400              ($src$$reg &lt;&lt; 0);
 2401     cbuf.insts()-&gt;emit_int32(op);
 2402   %}
 2403 
 2404   enc_class enc_cmov_reg_minmax_long( iRegL dst, iRegL src ) %{
 2405     int op = (Assembler::arith_op &lt;&lt; 30) |
 2406              ($dst$$reg &lt;&lt; 25) |
 2407              (Assembler::movcc_op3 &lt;&lt; 19) |
 2408              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2409              ($primary &lt;&lt; 14) |
 2410              (0 &lt;&lt; 13) |                    // select register move
 2411              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2412              ($src$$reg &lt;&lt; 0);
 2413     cbuf.insts()-&gt;emit_int32(op);
 2414   %}
 2415 
 2416   enc_class Set13( immI13 src, iRegI rd ) %{
 2417     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2418   %}
 2419 
 2420   enc_class SetHi22( immI src, iRegI rd ) %{
 2421     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2422   %}
 2423 
 2424   enc_class Set32( immI src, iRegI rd ) %{
 2425     C2_MacroAssembler _masm(&amp;cbuf);
 2426     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2427   %}
 2428 
 2429   enc_class call_epilog %{
 2430     if( VerifyStackAtCalls ) {
 2431       C2_MacroAssembler _masm(&amp;cbuf);
 2432       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();
 2433       Register temp_reg = G3;
 2434       __ add(SP, framesize, temp_reg);
 2435       __ cmp(temp_reg, FP);
 2436       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2437     }
 2438   %}
 2439 
 2440   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2441   // to G1 so the register allocator will not have to deal with the misaligned register
 2442   // pair.
 2443   enc_class adjust_long_from_native_call %{
 2444   %}
 2445 
 2446   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2447     // CALL directly to the runtime
 2448     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2449     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2450   %}
 2451 
 2452   enc_class preserve_SP %{
 2453     C2_MacroAssembler _masm(&amp;cbuf);
 2454     __ mov(SP, L7_mh_SP_save);
 2455   %}
 2456 
 2457   enc_class restore_SP %{
 2458     C2_MacroAssembler _masm(&amp;cbuf);
 2459     __ mov(L7_mh_SP_save, SP);
 2460   %}
 2461 
 2462   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2463     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2464     // who we intended to call.
 2465     if (!_method) {
 2466       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2467     } else {
 2468       int method_index = resolved_method_index(cbuf);
 2469       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2470                                                   : static_call_Relocation::spec(method_index);
 2471       emit_call_reloc(cbuf, $meth$$method, rspec);
 2472 
 2473       // Emit stub for static call.
 2474       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2475       if (stub == NULL) {
 2476         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2477         return;
 2478       }
 2479     }
 2480   %}
 2481 
 2482   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 2483     C2_MacroAssembler _masm(&amp;cbuf);
 2484     __ set_inst_mark();
 2485     int vtable_index = this-&gt;_vtable_index;
 2486     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2487     if (vtable_index &lt; 0) {
 2488       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2489       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2490       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2491       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2492       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2493       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2494     } else {
 2495       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2496       // Just go thru the vtable
 2497       // get receiver klass (receiver already checked for non-null)
 2498       // If we end up going thru a c2i adapter interpreter expects method in G5
 2499       int off = __ offset();
 2500       __ load_klass(O0, G3_scratch);
 2501       int klass_load_size;
 2502       if (UseCompressedClassPointers) {
 2503         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 2504         klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
 2505       } else {
 2506         klass_load_size = 1*BytesPerInstWord;
 2507       }
 2508       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
 2509       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 2510       if (Assembler::is_simm13(v_off)) {
 2511         __ ld_ptr(G3, v_off, G5_method);
 2512       } else {
 2513         // Generate 2 instructions
 2514         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2515         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2516         // ld_ptr, set_hi, set
 2517         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2518                &quot;Unexpected instruction size(s)&quot;);
 2519         __ ld_ptr(G3, G5_method, G5_method);
 2520       }
 2521       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2522       // However it may very well end up in handle_wrong_method if the
 2523       // method is abstract for the particular class.
 2524       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2525       // jump to target (either compiled code or c2iadapter)
 2526       __ jmpl(G3_scratch, G0, O7);
 2527       __ delayed()-&gt;nop();
 2528     }
 2529   %}
 2530 
 2531   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 2532     C2_MacroAssembler _masm(&amp;cbuf);
 2533 
 2534     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2535     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2536                               // we might be calling a C2I adapter which needs it.
 2537 
 2538     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2539     // Load nmethod
 2540     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2541 
 2542     // CALL to compiled java, indirect the contents of G3
 2543     __ set_inst_mark();
 2544     __ callr(temp_reg, G0);
 2545     __ delayed()-&gt;nop();
 2546   %}
 2547 
 2548 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
 2549     C2_MacroAssembler _masm(&amp;cbuf);
 2550     Register Rdividend = reg_to_register_object($src1$$reg);
 2551     Register Rdivisor = reg_to_register_object($src2$$reg);
 2552     Register Rresult = reg_to_register_object($dst$$reg);
 2553 
 2554     __ sra(Rdivisor, 0, Rdivisor);
 2555     __ sra(Rdividend, 0, Rdividend);
 2556     __ sdivx(Rdividend, Rdivisor, Rresult);
 2557 %}
 2558 
 2559 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
 2560     C2_MacroAssembler _masm(&amp;cbuf);
 2561 
 2562     Register Rdividend = reg_to_register_object($src1$$reg);
 2563     int divisor = $imm$$constant;
 2564     Register Rresult = reg_to_register_object($dst$$reg);
 2565 
 2566     __ sra(Rdividend, 0, Rdividend);
 2567     __ sdivx(Rdividend, divisor, Rresult);
 2568 %}
 2569 
 2570 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
 2571     C2_MacroAssembler _masm(&amp;cbuf);
 2572     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2573     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2574     Register Rdst  = reg_to_register_object($dst$$reg);
 2575 
 2576     __ sra( Rsrc1, 0, Rsrc1 );
 2577     __ sra( Rsrc2, 0, Rsrc2 );
 2578     __ mulx( Rsrc1, Rsrc2, Rdst );
 2579     __ srlx( Rdst, 32, Rdst );
 2580 %}
 2581 
 2582 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
 2583     C2_MacroAssembler _masm(&amp;cbuf);
 2584     Register Rdividend = reg_to_register_object($src1$$reg);
 2585     Register Rdivisor = reg_to_register_object($src2$$reg);
 2586     Register Rresult = reg_to_register_object($dst$$reg);
 2587     Register Rscratch = reg_to_register_object($scratch$$reg);
 2588 
 2589     assert(Rdividend != Rscratch, &quot;&quot;);
 2590     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2591 
 2592     __ sra(Rdividend, 0, Rdividend);
 2593     __ sra(Rdivisor, 0, Rdivisor);
 2594     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2595     __ mulx(Rscratch, Rdivisor, Rscratch);
 2596     __ sub(Rdividend, Rscratch, Rresult);
 2597 %}
 2598 
 2599 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
 2600     C2_MacroAssembler _masm(&amp;cbuf);
 2601 
 2602     Register Rdividend = reg_to_register_object($src1$$reg);
 2603     int divisor = $imm$$constant;
 2604     Register Rresult = reg_to_register_object($dst$$reg);
 2605     Register Rscratch = reg_to_register_object($scratch$$reg);
 2606 
 2607     assert(Rdividend != Rscratch, &quot;&quot;);
 2608 
 2609     __ sra(Rdividend, 0, Rdividend);
 2610     __ sdivx(Rdividend, divisor, Rscratch);
 2611     __ mulx(Rscratch, divisor, Rscratch);
 2612     __ sub(Rdividend, Rscratch, Rresult);
 2613 %}
 2614 
 2615 enc_class fabss (sflt_reg dst, sflt_reg src) %{
 2616     C2_MacroAssembler _masm(&amp;cbuf);
 2617 
 2618     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2619     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2620 
 2621     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2622 %}
 2623 
 2624 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
 2625     C2_MacroAssembler _masm(&amp;cbuf);
 2626 
 2627     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2628     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2629 
 2630     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2631 %}
 2632 
 2633 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
 2634     C2_MacroAssembler _masm(&amp;cbuf);
 2635 
 2636     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2637     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2638 
 2639     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2640 %}
 2641 
 2642 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
 2643     C2_MacroAssembler _masm(&amp;cbuf);
 2644 
 2645     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2646     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2647 
 2648     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2649 %}
 2650 
 2651 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
 2652     C2_MacroAssembler _masm(&amp;cbuf);
 2653 
 2654     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2655     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2656 
 2657     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2658 %}
 2659 
 2660 
 2661 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2662     C2_MacroAssembler _masm(&amp;cbuf);
 2663 
 2664     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2665     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2666     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2667     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2668 
 2669     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2670 %}
 2671 
 2672 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2673     C2_MacroAssembler _masm(&amp;cbuf);
 2674 
 2675     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2676     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2677     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2678     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2679 
 2680     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2681 %}
 2682 
 2683 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2684     C2_MacroAssembler _masm(&amp;cbuf);
 2685 
 2686     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2687     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2688     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2689     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2690 
 2691     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2692 %}
 2693 
 2694 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2695     C2_MacroAssembler _masm(&amp;cbuf);
 2696 
 2697     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2698     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2699     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2700     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2701 
 2702     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2703 %}
 2704 
 2705 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2706     C2_MacroAssembler _masm(&amp;cbuf);
 2707 
 2708     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2709     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2710     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2711     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2712 
 2713     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2714 %}
 2715 
 2716 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2717     C2_MacroAssembler _masm(&amp;cbuf);
 2718 
 2719     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2720     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2721     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2722     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2723 
 2724     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2725 %}
 2726 
 2727 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2728     C2_MacroAssembler _masm(&amp;cbuf);
 2729 
 2730     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2731     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2732     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2733     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2734 
 2735     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2736 %}
 2737 
 2738 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2739     C2_MacroAssembler _masm(&amp;cbuf);
 2740 
 2741     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2742     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2743     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2744     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2745 
 2746     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2747 %}
 2748 
 2749 
 2750 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
 2751     C2_MacroAssembler _masm(&amp;cbuf);
 2752 
 2753     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2754     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2755 
 2756     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2757 %}
 2758 
 2759 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
 2760     C2_MacroAssembler _masm(&amp;cbuf);
 2761 
 2762     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2763     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2764 
 2765     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2766 %}
 2767 
 2768 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2769     C2_MacroAssembler _masm(&amp;cbuf);
 2770 
 2771     Register Roop  = reg_to_register_object($oop$$reg);
 2772     Register Rbox  = reg_to_register_object($box$$reg);
 2773     Register Rscratch = reg_to_register_object($scratch$$reg);
 2774     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2775 
 2776     assert(Roop  != Rscratch, &quot;&quot;);
 2777     assert(Roop  != Rmark, &quot;&quot;);
 2778     assert(Rbox  != Rscratch, &quot;&quot;);
 2779     assert(Rbox  != Rmark, &quot;&quot;);
 2780 
 2781     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2782 %}
 2783 
 2784 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2785     C2_MacroAssembler _masm(&amp;cbuf);
 2786 
 2787     Register Roop  = reg_to_register_object($oop$$reg);
 2788     Register Rbox  = reg_to_register_object($box$$reg);
 2789     Register Rscratch = reg_to_register_object($scratch$$reg);
 2790     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2791 
 2792     assert(Roop  != Rscratch, &quot;&quot;);
 2793     assert(Roop  != Rmark, &quot;&quot;);
 2794     assert(Rbox  != Rscratch, &quot;&quot;);
 2795     assert(Rbox  != Rmark, &quot;&quot;);
 2796 
 2797     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2798   %}
 2799 
 2800   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
 2801     C2_MacroAssembler _masm(&amp;cbuf);
 2802     Register Rmem = reg_to_register_object($mem$$reg);
 2803     Register Rold = reg_to_register_object($old$$reg);
 2804     Register Rnew = reg_to_register_object($new$$reg);
 2805 
 2806     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2807     __ cmp( Rold, Rnew );
 2808   %}
 2809 
 2810   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2811     Register Rmem = reg_to_register_object($mem$$reg);
 2812     Register Rold = reg_to_register_object($old$$reg);
 2813     Register Rnew = reg_to_register_object($new$$reg);
 2814 
 2815     C2_MacroAssembler _masm(&amp;cbuf);
 2816     __ mov(Rnew, O7);
 2817     __ casx(Rmem, Rold, O7);
 2818     __ cmp( Rold, O7 );
 2819   %}
 2820 
 2821   // raw int cas, used for compareAndSwap
 2822   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2823     Register Rmem = reg_to_register_object($mem$$reg);
 2824     Register Rold = reg_to_register_object($old$$reg);
 2825     Register Rnew = reg_to_register_object($new$$reg);
 2826 
 2827     C2_MacroAssembler _masm(&amp;cbuf);
 2828     __ mov(Rnew, O7);
 2829     __ cas(Rmem, Rold, O7);
 2830     __ cmp( Rold, O7 );
 2831   %}
 2832 
 2833   // raw int cas without using tmp register for compareAndExchange
 2834   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2835     Register Rmem = reg_to_register_object($mem$$reg);
 2836     Register Rold = reg_to_register_object($old$$reg);
 2837     Register Rnew = reg_to_register_object($new$$reg);
 2838 
 2839     C2_MacroAssembler _masm(&amp;cbuf);
 2840     __ cas(Rmem, Rold, Rnew);
 2841   %}
 2842 
 2843   // 64-bit cas without using tmp register for compareAndExchange
 2844   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2845     Register Rmem = reg_to_register_object($mem$$reg);
 2846     Register Rold = reg_to_register_object($old$$reg);
 2847     Register Rnew = reg_to_register_object($new$$reg);
 2848 
 2849     C2_MacroAssembler _masm(&amp;cbuf);
 2850     __ casx(Rmem, Rold, Rnew);
 2851   %}
 2852 
 2853   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2854     Register Rres = reg_to_register_object($res$$reg);
 2855 
 2856     C2_MacroAssembler _masm(&amp;cbuf);
 2857     __ mov(1, Rres);
 2858     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2859   %}
 2860 
 2861   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2862     Register Rres = reg_to_register_object($res$$reg);
 2863 
 2864     C2_MacroAssembler _masm(&amp;cbuf);
 2865     __ mov(1, Rres);
 2866     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2867   %}
 2868 
 2869   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
 2870     C2_MacroAssembler _masm(&amp;cbuf);
 2871     Register Rdst = reg_to_register_object($dst$$reg);
 2872     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2873                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2874     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2875                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2876 
 2877     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2878     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2879   %}
 2880 
 2881   enc_class enc_rethrow() %{
 2882     cbuf.set_insts_mark();
 2883     Register temp_reg = G3;
 2884     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2885     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
 2886     C2_MacroAssembler _masm(&amp;cbuf);
 2887 #ifdef ASSERT
 2888     __ save_frame(0);
 2889     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2890     __ sethi(last_rethrow_addrlit, L1);
 2891     Address addr(L1, last_rethrow_addrlit.low10());
 2892     __ rdpc(L2);
 2893     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2894     __ st_ptr(L2, addr);
 2895     __ restore();
 2896 #endif
 2897     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2898     __ delayed()-&gt;nop();
 2899   %}
 2900 
 2901   enc_class emit_mem_nop() %{
 2902     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2903     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2904   %}
 2905 
 2906   enc_class emit_fadd_nop() %{
 2907     // Generates the instruction FMOVS f31,f31
 2908     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2909   %}
 2910 
 2911   enc_class emit_br_nop() %{
 2912     // Generates the instruction BPN,PN .
 2913     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2914   %}
 2915 
 2916   enc_class enc_membar_acquire %{
 2917     C2_MacroAssembler _masm(&amp;cbuf);
 2918     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2919   %}
 2920 
 2921   enc_class enc_membar_release %{
 2922     C2_MacroAssembler _masm(&amp;cbuf);
 2923     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2924   %}
 2925 
 2926   enc_class enc_membar_volatile %{
 2927     C2_MacroAssembler _masm(&amp;cbuf);
 2928     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2929   %}
 2930 
 2931 %}
 2932 
 2933 //----------FRAME--------------------------------------------------------------
 2934 // Definition of frame structure and management information.
 2935 //
 2936 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2937 //                             |   (to get allocators register number
 2938 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2939 //  r   CALLER     |        |
 2940 //  o     |        +--------+      pad to even-align allocators stack-slot
 2941 //  w     V        |  pad0  |        numbers; owned by CALLER
 2942 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2943 //  h     ^        |   in   |  5
 2944 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2945 //  |     |        |        |  3
 2946 //  |     |        +--------+
 2947 //  V     |        | old out|      Empty on Intel, window on Sparc
 2948 //        |    old |preserve|      Must be even aligned.
 2949 //        |     SP-+--------+----&gt; Matcher::_old_SP, 8 (or 16 in LP64)-byte aligned
 2950 //        |        |   in   |  3   area for Intel ret address
 2951 //     Owned by    |preserve|      Empty on Sparc.
 2952 //       SELF      +--------+
 2953 //        |        |  pad2  |  2   pad to align old SP
 2954 //        |        +--------+  1
 2955 //        |        | locks  |  0
 2956 //        |        +--------+----&gt; VMRegImpl::stack0, 8 (or 16 in LP64)-byte aligned
 2957 //        |        |  pad1  | 11   pad to align new SP
 2958 //        |        +--------+
 2959 //        |        |        | 10
 2960 //        |        | spills |  9   spills
 2961 //        V        |        |  8   (pad0 slot for callee)
 2962 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2963 //        ^        |  out   |  7
 2964 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2965 //     Owned by    +--------+
 2966 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2967 //        |    new |preserve|      Must be even-aligned.
 2968 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2969 //        |        |        |
 2970 //
 2971 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2972 //         known from SELF&#39;s arguments and the Java calling convention.
 2973 //         Region 6-7 is determined per call site.
 2974 // Note 2: If the calling convention leaves holes in the incoming argument
 2975 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2976 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2977 //         incoming area, as the Java calling convention is completely under
 2978 //         the control of the AD file.  Doubles can be sorted and packed to
 2979 //         avoid holes.  Holes in the outgoing arguments may be necessary for
 2980 //         varargs C calling conventions.
 2981 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2982 //         even aligned with pad0 as needed.
 2983 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2984 //         region 6-11 is even aligned; it may be padded out more so that
 2985 //         the region from SP to FP meets the minimum stack alignment.
 2986 
 2987 frame %{
 2988   // What direction does stack grow in (assumed to be same for native &amp; Java)
 2989   stack_direction(TOWARDS_LOW);
 2990 
 2991   // These two registers define part of the calling convention
 2992   // between compiled code and the interpreter.
 2993   inline_cache_reg(R_G5);                // Inline Cache Register or Method* for I2C
 2994   interpreter_method_oop_reg(R_G5);      // Method Oop Register when calling interpreter
 2995 
 2996   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 2997   cisc_spilling_operand_name(indOffset);
 2998 
 2999   // Number of stack slots consumed by a Monitor enter
 3000   sync_stack_slots(2);
 3001 
 3002   // Compiled code&#39;s Frame Pointer
 3003   frame_pointer(R_SP);
 3004 
 3005   // Stack alignment requirement
 3006   stack_alignment(StackAlignmentInBytes);
 3007   //  LP64: Alignment size in bytes (128-bit -&gt; 16 bytes)
 3008   // !LP64: Alignment size in bytes (64-bit  -&gt;  8 bytes)
 3009 
 3010   // Number of stack slots between incoming argument block and the start of
 3011   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3012   // EPILOG must remove this many slots.
 3013   in_preserve_stack_slots(0);
 3014 
 3015   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3016   // for calls to C.  Supports the var-args backing area for register parms.
 3017   // ADLC doesn&#39;t support parsing expressions, so I folded the math by hand.
 3018   // (callee_register_argument_save_area_words (6) + callee_aggregate_return_pointer_words (0)) * 2-stack-slots-per-word
 3019   varargs_C_out_slots_killed(12);
 3020 
 3021   // The after-PROLOG location of the return address.  Location of
 3022   // return address specifies a type (REG or STACK) and a number
 3023   // representing the register number (i.e. - use a register name) or
 3024   // stack slot.
 3025   return_addr(REG R_I7);          // Ret Addr is in register I7
 3026 
 3027   // Body of function which returns an OptoRegs array locating
 3028   // arguments either in registers or in stack slots for calling
 3029   // java
 3030   calling_convention %{
 3031     (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
 3032 
 3033   %}
 3034 
 3035   // Body of function which returns an OptoRegs array locating
 3036   // arguments either in registers or in stack slots for calling
 3037   // C.
 3038   c_calling_convention %{
 3039     // This is obviously always outgoing
 3040     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3041   %}
 3042 
 3043   // Location of native (C/C++) and interpreter return values.  This is specified to
 3044   // be the  same as Java.  In the 32-bit VM, long values are actually returned from
 3045   // native calls in O0:O1 and returned to the interpreter in I0:I1.  The copying
 3046   // to and from the register pairs is done by the appropriate call and epilog
 3047   // opcodes.  This simplifies the register allocator.
 3048   c_return_value %{
 3049     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3050     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3051     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3052     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3053     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3054     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3055                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3056   %}
 3057 
 3058   // Location of compiled Java return values.  Same as C
 3059   return_value %{
 3060     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3061     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3062     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3063     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3064     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3065     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3066                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3067   %}
 3068 
 3069 %}
 3070 
 3071 
 3072 //----------ATTRIBUTES---------------------------------------------------------
 3073 //----------Operand Attributes-------------------------------------------------
 3074 op_attrib op_cost(1);          // Required cost attribute
 3075 
 3076 //----------Instruction Attributes---------------------------------------------
 3077 ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
 3078 ins_attrib ins_size(32);           // Required size attribute (in bits)
 3079 
 3080 // avoid_back_to_back attribute is an expression that must return
 3081 // one of the following values defined in MachNode:
 3082 // AVOID_NONE   - instruction can be placed anywhere
 3083 // AVOID_BEFORE - instruction cannot be placed after an
 3084 //                instruction with MachNode::AVOID_AFTER
 3085 // AVOID_AFTER  - the next instruction cannot be the one
 3086 //                with MachNode::AVOID_BEFORE
 3087 // AVOID_BEFORE_AND_AFTER - BEFORE and AFTER attributes at
 3088 //                          the same time
 3089 ins_attrib ins_avoid_back_to_back(MachNode::AVOID_NONE);
 3090 
 3091 ins_attrib ins_short_branch(0);    // Required flag: is this instruction a
 3092                                    // non-matching short branch variant of some
 3093                                                             // long branch?
 3094 
 3095 //----------OPERANDS-----------------------------------------------------------
 3096 // Operand definitions must precede instruction definitions for correct parsing
 3097 // in the ADLC because operands constitute user defined types which are used in
 3098 // instruction definitions.
 3099 
 3100 //----------Simple Operands----------------------------------------------------
 3101 // Immediate Operands
 3102 // Integer Immediate: 32-bit
 3103 operand immI() %{
 3104   match(ConI);
 3105 
 3106   op_cost(0);
 3107   // formats are generated automatically for constants and base registers
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 // Integer Immediate: 0-bit
 3113 operand immI0() %{
 3114   predicate(n-&gt;get_int() == 0);
 3115   match(ConI);
 3116   op_cost(0);
 3117 
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 // Integer Immediate: 5-bit
 3123 operand immI5() %{
 3124   predicate(Assembler::is_simm5(n-&gt;get_int()));
 3125   match(ConI);
 3126   op_cost(0);
 3127   format %{ %}
 3128   interface(CONST_INTER);
 3129 %}
 3130 
 3131 // Integer Immediate: 8-bit
 3132 operand immI8() %{
 3133   predicate(Assembler::is_simm8(n-&gt;get_int()));
 3134   match(ConI);
 3135   op_cost(0);
 3136   format %{ %}
 3137   interface(CONST_INTER);
 3138 %}
 3139 
 3140 // Integer Immediate: the value 10
 3141 operand immI10() %{
 3142   predicate(n-&gt;get_int() == 10);
 3143   match(ConI);
 3144   op_cost(0);
 3145 
 3146   format %{ %}
 3147   interface(CONST_INTER);
 3148 %}
 3149 
 3150 // Integer Immediate: 11-bit
 3151 operand immI11() %{
 3152   predicate(Assembler::is_simm11(n-&gt;get_int()));
 3153   match(ConI);
 3154   op_cost(0);
 3155   format %{ %}
 3156   interface(CONST_INTER);
 3157 %}
 3158 
 3159 // Integer Immediate: 13-bit
 3160 operand immI13() %{
 3161   predicate(Assembler::is_simm13(n-&gt;get_int()));
 3162   match(ConI);
 3163   op_cost(0);
 3164 
 3165   format %{ %}
 3166   interface(CONST_INTER);
 3167 %}
 3168 
 3169 // Integer Immediate: 13-bit minus 7
 3170 operand immI13m7() %{
 3171   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; ((n-&gt;get_int() + 7) &lt;= 4095));
 3172   match(ConI);
 3173   op_cost(0);
 3174 
 3175   format %{ %}
 3176   interface(CONST_INTER);
 3177 %}
 3178 
 3179 // Integer Immediate: 16-bit
 3180 operand immI16() %{
 3181   predicate(Assembler::is_simm16(n-&gt;get_int()));
 3182   match(ConI);
 3183   op_cost(0);
 3184   format %{ %}
 3185   interface(CONST_INTER);
 3186 %}
 3187 
 3188 // Integer Immediate: the values 1-31
 3189 operand immI_1_31() %{
 3190   predicate(n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3191   match(ConI);
 3192   op_cost(0);
 3193 
 3194   format %{ %}
 3195   interface(CONST_INTER);
 3196 %}
 3197 
 3198 // Integer Immediate: the values 32-63
 3199 operand immI_32_63() %{
 3200   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3201   match(ConI);
 3202   op_cost(0);
 3203 
 3204   format %{ %}
 3205   interface(CONST_INTER);
 3206 %}
 3207 
 3208 // Immediates for special shifts (sign extend)
 3209 
 3210 // Integer Immediate: the value 16
 3211 operand immI_16() %{
 3212   predicate(n-&gt;get_int() == 16);
 3213   match(ConI);
 3214   op_cost(0);
 3215 
 3216   format %{ %}
 3217   interface(CONST_INTER);
 3218 %}
 3219 
 3220 // Integer Immediate: the value 24
 3221 operand immI_24() %{
 3222   predicate(n-&gt;get_int() == 24);
 3223   match(ConI);
 3224   op_cost(0);
 3225 
 3226   format %{ %}
 3227   interface(CONST_INTER);
 3228 %}
 3229 // Integer Immediate: the value 255
 3230 operand immI_255() %{
 3231   predicate( n-&gt;get_int() == 255 );
 3232   match(ConI);
 3233   op_cost(0);
 3234 
 3235   format %{ %}
 3236   interface(CONST_INTER);
 3237 %}
 3238 
 3239 // Integer Immediate: the value 65535
 3240 operand immI_65535() %{
 3241   predicate(n-&gt;get_int() == 65535);
 3242   match(ConI);
 3243   op_cost(0);
 3244 
 3245   format %{ %}
 3246   interface(CONST_INTER);
 3247 %}
 3248 
 3249 // Integer Immediate: the values 0-31
 3250 operand immU5() %{
 3251   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3252   match(ConI);
 3253   op_cost(0);
 3254 
 3255   format %{ %}
 3256   interface(CONST_INTER);
 3257 %}
 3258 
 3259 // Integer Immediate: 6-bit
 3260 operand immU6() %{
 3261   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3262   match(ConI);
 3263   op_cost(0);
 3264   format %{ %}
 3265   interface(CONST_INTER);
 3266 %}
 3267 
 3268 // Unsigned Integer Immediate: 12-bit (non-negative that fits in simm13)
 3269 operand immU12() %{
 3270   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; Assembler::is_simm13(n-&gt;get_int()));
 3271   match(ConI);
 3272   op_cost(0);
 3273 
 3274   format %{ %}
 3275   interface(CONST_INTER);
 3276 %}
 3277 
 3278 // Unsigned Long Immediate: 12-bit (non-negative that fits in simm13)
 3279 operand immUL12() %{
 3280   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() == (int)n-&gt;get_long()) &amp;&amp; Assembler::is_simm13((int)n-&gt;get_long()));
 3281   match(ConL);
 3282   op_cost(0);
 3283 
 3284   format %{ %}
 3285   interface(CONST_INTER);
 3286 %}
 3287 
 3288 // Integer Immediate non-negative
 3289 operand immU31()
 3290 %{
 3291   predicate(n-&gt;get_int() &gt;= 0);
 3292   match(ConI);
 3293 
 3294   op_cost(0);
 3295   format %{ %}
 3296   interface(CONST_INTER);
 3297 %}
 3298 
 3299 // Long Immediate: the value FF
 3300 operand immL_FF() %{
 3301   predicate( n-&gt;get_long() == 0xFFL );
 3302   match(ConL);
 3303   op_cost(0);
 3304 
 3305   format %{ %}
 3306   interface(CONST_INTER);
 3307 %}
 3308 
 3309 // Long Immediate: the value FFFF
 3310 operand immL_FFFF() %{
 3311   predicate( n-&gt;get_long() == 0xFFFFL );
 3312   match(ConL);
 3313   op_cost(0);
 3314 
 3315   format %{ %}
 3316   interface(CONST_INTER);
 3317 %}
 3318 
 3319 // Pointer Immediate: 32 or 64-bit
 3320 operand immP() %{
 3321   match(ConP);
 3322 
 3323   op_cost(5);
 3324   // formats are generated automatically for constants and base registers
 3325   format %{ %}
 3326   interface(CONST_INTER);
 3327 %}
 3328 
 3329 // Pointer Immediate: 64-bit
 3330 operand immP_set() %{
 3331   predicate(!VM_Version::has_fast_ld());
 3332   match(ConP);
 3333 
 3334   op_cost(5);
 3335   // formats are generated automatically for constants and base registers
 3336   format %{ %}
 3337   interface(CONST_INTER);
 3338 %}
 3339 
 3340 // Pointer Immediate: 64-bit
 3341 // From Niagara2 processors on a load should be better than materializing.
 3342 operand immP_load() %{
 3343   predicate(VM_Version::has_fast_ld() &amp;&amp; (n-&gt;bottom_type()-&gt;isa_oop_ptr() || (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &gt; 3)));
 3344   match(ConP);
 3345 
 3346   op_cost(5);
 3347   // formats are generated automatically for constants and base registers
 3348   format %{ %}
 3349   interface(CONST_INTER);
 3350 %}
 3351 
 3352 // Pointer Immediate: 64-bit
 3353 operand immP_no_oop_cheap() %{
 3354   predicate(VM_Version::has_fast_ld() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_oop_ptr() &amp;&amp; (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &lt;= 3));
 3355   match(ConP);
 3356 
 3357   op_cost(5);
 3358   // formats are generated automatically for constants and base registers
 3359   format %{ %}
 3360   interface(CONST_INTER);
 3361 %}
 3362 
 3363 operand immP13() %{
 3364   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3365   match(ConP);
 3366   op_cost(0);
 3367 
 3368   format %{ %}
 3369   interface(CONST_INTER);
 3370 %}
 3371 
 3372 operand immP0() %{
 3373   predicate(n-&gt;get_ptr() == 0);
 3374   match(ConP);
 3375   op_cost(0);
 3376 
 3377   format %{ %}
 3378   interface(CONST_INTER);
 3379 %}
 3380 
 3381 // Pointer Immediate
 3382 operand immN()
 3383 %{
 3384   match(ConN);
 3385 
 3386   op_cost(10);
 3387   format %{ %}
 3388   interface(CONST_INTER);
 3389 %}
 3390 
 3391 operand immNKlass()
 3392 %{
 3393   match(ConNKlass);
 3394 
 3395   op_cost(10);
 3396   format %{ %}
 3397   interface(CONST_INTER);
 3398 %}
 3399 
 3400 // NULL Pointer Immediate
 3401 operand immN0()
 3402 %{
 3403   predicate(n-&gt;get_narrowcon() == 0);
 3404   match(ConN);
 3405 
 3406   op_cost(0);
 3407   format %{ %}
 3408   interface(CONST_INTER);
 3409 %}
 3410 
 3411 operand immL() %{
 3412   match(ConL);
 3413   op_cost(40);
 3414   // formats are generated automatically for constants and base registers
 3415   format %{ %}
 3416   interface(CONST_INTER);
 3417 %}
 3418 
 3419 operand immL0() %{
 3420   predicate(n-&gt;get_long() == 0L);
 3421   match(ConL);
 3422   op_cost(0);
 3423   // formats are generated automatically for constants and base registers
 3424   format %{ %}
 3425   interface(CONST_INTER);
 3426 %}
 3427 
 3428 // Integer Immediate: 5-bit
 3429 operand immL5() %{
 3430   predicate(n-&gt;get_long() == (int)n-&gt;get_long() &amp;&amp; Assembler::is_simm5((int)n-&gt;get_long()));
 3431   match(ConL);
 3432   op_cost(0);
 3433   format %{ %}
 3434   interface(CONST_INTER);
 3435 %}
 3436 
 3437 // Long Immediate: 13-bit
 3438 operand immL13() %{
 3439   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 4095L));
 3440   match(ConL);
 3441   op_cost(0);
 3442 
 3443   format %{ %}
 3444   interface(CONST_INTER);
 3445 %}
 3446 
 3447 // Long Immediate: 13-bit minus 7
 3448 operand immL13m7() %{
 3449   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; ((n-&gt;get_long() + 7L) &lt;= 4095L));
 3450   match(ConL);
 3451   op_cost(0);
 3452 
 3453   format %{ %}
 3454   interface(CONST_INTER);
 3455 %}
 3456 
 3457 // Long Immediate: low 32-bit mask
 3458 operand immL_32bits() %{
 3459   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3460   match(ConL);
 3461   op_cost(0);
 3462 
 3463   format %{ %}
 3464   interface(CONST_INTER);
 3465 %}
 3466 
 3467 // Long Immediate: cheap (materialize in &lt;= 3 instructions)
 3468 operand immL_cheap() %{
 3469   predicate(!VM_Version::has_fast_ld() || MacroAssembler::insts_for_set64(n-&gt;get_long()) &lt;= 3);
 3470   match(ConL);
 3471   op_cost(0);
 3472 
 3473   format %{ %}
 3474   interface(CONST_INTER);
 3475 %}
 3476 
 3477 // Long Immediate: expensive (materialize in &gt; 3 instructions)
 3478 operand immL_expensive() %{
 3479   predicate(VM_Version::has_fast_ld() &amp;&amp; MacroAssembler::insts_for_set64(n-&gt;get_long()) &gt; 3);
 3480   match(ConL);
 3481   op_cost(0);
 3482 
 3483   format %{ %}
 3484   interface(CONST_INTER);
 3485 %}
 3486 
 3487 // Double Immediate
 3488 operand immD() %{
 3489   match(ConD);
 3490 
 3491   op_cost(40);
 3492   format %{ %}
 3493   interface(CONST_INTER);
 3494 %}
 3495 
 3496 // Double Immediate: +0.0d
 3497 operand immD0() %{
 3498   predicate(jlong_cast(n-&gt;getd()) == 0);
 3499   match(ConD);
 3500 
 3501   op_cost(0);
 3502   format %{ %}
 3503   interface(CONST_INTER);
 3504 %}
 3505 
 3506 // Float Immediate
 3507 operand immF() %{
 3508   match(ConF);
 3509 
 3510   op_cost(20);
 3511   format %{ %}
 3512   interface(CONST_INTER);
 3513 %}
 3514 
 3515 // Float Immediate: +0.0f
 3516 operand immF0() %{
 3517   predicate(jint_cast(n-&gt;getf()) == 0);
 3518   match(ConF);
 3519 
 3520   op_cost(0);
 3521   format %{ %}
 3522   interface(CONST_INTER);
 3523 %}
 3524 
 3525 // Integer Register Operands
 3526 // Integer Register
 3527 operand iRegI() %{
 3528   constraint(ALLOC_IN_RC(int_reg));
 3529   match(RegI);
 3530 
 3531   match(notemp_iRegI);
 3532   match(g1RegI);
 3533   match(o0RegI);
 3534   match(iRegIsafe);
 3535 
 3536   format %{ %}
 3537   interface(REG_INTER);
 3538 %}
 3539 
 3540 operand notemp_iRegI() %{
 3541   constraint(ALLOC_IN_RC(notemp_int_reg));
 3542   match(RegI);
 3543 
 3544   match(o0RegI);
 3545 
 3546   format %{ %}
 3547   interface(REG_INTER);
 3548 %}
 3549 
 3550 operand o0RegI() %{
 3551   constraint(ALLOC_IN_RC(o0_regI));
 3552   match(iRegI);
 3553 
 3554   format %{ %}
 3555   interface(REG_INTER);
 3556 %}
 3557 
 3558 // Pointer Register
 3559 operand iRegP() %{
 3560   constraint(ALLOC_IN_RC(ptr_reg));
 3561   match(RegP);
 3562 
 3563   match(lock_ptr_RegP);
 3564   match(g1RegP);
 3565   match(g2RegP);
 3566   match(g3RegP);
 3567   match(g4RegP);
 3568   match(i0RegP);
 3569   match(o0RegP);
 3570   match(o1RegP);
 3571   match(l7RegP);
 3572 
 3573   format %{ %}
 3574   interface(REG_INTER);
 3575 %}
 3576 
 3577 operand sp_ptr_RegP() %{
 3578   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3579   match(RegP);
 3580   match(iRegP);
 3581 
 3582   format %{ %}
 3583   interface(REG_INTER);
 3584 %}
 3585 
 3586 operand lock_ptr_RegP() %{
 3587   constraint(ALLOC_IN_RC(lock_ptr_reg));
 3588   match(RegP);
 3589   match(i0RegP);
 3590   match(o0RegP);
 3591   match(o1RegP);
 3592   match(l7RegP);
 3593 
 3594   format %{ %}
 3595   interface(REG_INTER);
 3596 %}
 3597 
 3598 operand g1RegP() %{
 3599   constraint(ALLOC_IN_RC(g1_regP));
 3600   match(iRegP);
 3601 
 3602   format %{ %}
 3603   interface(REG_INTER);
 3604 %}
 3605 
 3606 operand g2RegP() %{
 3607   constraint(ALLOC_IN_RC(g2_regP));
 3608   match(iRegP);
 3609 
 3610   format %{ %}
 3611   interface(REG_INTER);
 3612 %}
 3613 
 3614 operand g3RegP() %{
 3615   constraint(ALLOC_IN_RC(g3_regP));
 3616   match(iRegP);
 3617 
 3618   format %{ %}
 3619   interface(REG_INTER);
 3620 %}
 3621 
 3622 operand g1RegI() %{
 3623   constraint(ALLOC_IN_RC(g1_regI));
 3624   match(iRegI);
 3625 
 3626   format %{ %}
 3627   interface(REG_INTER);
 3628 %}
 3629 
 3630 operand g3RegI() %{
 3631   constraint(ALLOC_IN_RC(g3_regI));
 3632   match(iRegI);
 3633 
 3634   format %{ %}
 3635   interface(REG_INTER);
 3636 %}
 3637 
 3638 operand g4RegI() %{
 3639   constraint(ALLOC_IN_RC(g4_regI));
 3640   match(iRegI);
 3641 
 3642   format %{ %}
 3643   interface(REG_INTER);
 3644 %}
 3645 
 3646 operand g4RegP() %{
 3647   constraint(ALLOC_IN_RC(g4_regP));
 3648   match(iRegP);
 3649 
 3650   format %{ %}
 3651   interface(REG_INTER);
 3652 %}
 3653 
 3654 operand i0RegP() %{
 3655   constraint(ALLOC_IN_RC(i0_regP));
 3656   match(iRegP);
 3657 
 3658   format %{ %}
 3659   interface(REG_INTER);
 3660 %}
 3661 
 3662 operand o0RegP() %{
 3663   constraint(ALLOC_IN_RC(o0_regP));
 3664   match(iRegP);
 3665 
 3666   format %{ %}
 3667   interface(REG_INTER);
 3668 %}
 3669 
 3670 operand o1RegP() %{
 3671   constraint(ALLOC_IN_RC(o1_regP));
 3672   match(iRegP);
 3673 
 3674   format %{ %}
 3675   interface(REG_INTER);
 3676 %}
 3677 
 3678 operand o2RegP() %{
 3679   constraint(ALLOC_IN_RC(o2_regP));
 3680   match(iRegP);
 3681 
 3682   format %{ %}
 3683   interface(REG_INTER);
 3684 %}
 3685 
 3686 operand o7RegP() %{
 3687   constraint(ALLOC_IN_RC(o7_regP));
 3688   match(iRegP);
 3689 
 3690   format %{ %}
 3691   interface(REG_INTER);
 3692 %}
 3693 
 3694 operand l7RegP() %{
 3695   constraint(ALLOC_IN_RC(l7_regP));
 3696   match(iRegP);
 3697 
 3698   format %{ %}
 3699   interface(REG_INTER);
 3700 %}
 3701 
 3702 operand o7RegI() %{
 3703   constraint(ALLOC_IN_RC(o7_regI));
 3704   match(iRegI);
 3705 
 3706   format %{ %}
 3707   interface(REG_INTER);
 3708 %}
 3709 
 3710 operand iRegN() %{
 3711   constraint(ALLOC_IN_RC(int_reg));
 3712   match(RegN);
 3713 
 3714   format %{ %}
 3715   interface(REG_INTER);
 3716 %}
 3717 
 3718 // Long Register
 3719 operand iRegL() %{
 3720   constraint(ALLOC_IN_RC(long_reg));
 3721   match(RegL);
 3722 
 3723   format %{ %}
 3724   interface(REG_INTER);
 3725 %}
 3726 
 3727 operand o2RegL() %{
 3728   constraint(ALLOC_IN_RC(o2_regL));
 3729   match(iRegL);
 3730 
 3731   format %{ %}
 3732   interface(REG_INTER);
 3733 %}
 3734 
 3735 operand o7RegL() %{
 3736   constraint(ALLOC_IN_RC(o7_regL));
 3737   match(iRegL);
 3738 
 3739   format %{ %}
 3740   interface(REG_INTER);
 3741 %}
 3742 
 3743 operand g1RegL() %{
 3744   constraint(ALLOC_IN_RC(g1_regL));
 3745   match(iRegL);
 3746 
 3747   format %{ %}
 3748   interface(REG_INTER);
 3749 %}
 3750 
 3751 operand g3RegL() %{
 3752   constraint(ALLOC_IN_RC(g3_regL));
 3753   match(iRegL);
 3754 
 3755   format %{ %}
 3756   interface(REG_INTER);
 3757 %}
 3758 
 3759 // Int Register safe
 3760 // This is 64bit safe
 3761 operand iRegIsafe() %{
 3762   constraint(ALLOC_IN_RC(long_reg));
 3763 
 3764   match(iRegI);
 3765 
 3766   format %{ %}
 3767   interface(REG_INTER);
 3768 %}
 3769 
 3770 // Condition Code Flag Register
 3771 operand flagsReg() %{
 3772   constraint(ALLOC_IN_RC(int_flags));
 3773   match(RegFlags);
 3774 
 3775   format %{ &quot;ccr&quot; %} // both ICC and XCC
 3776   interface(REG_INTER);
 3777 %}
 3778 
 3779 // Condition Code Register, unsigned comparisons.
 3780 operand flagsRegU() %{
 3781   constraint(ALLOC_IN_RC(int_flags));
 3782   match(RegFlags);
 3783 
 3784   format %{ &quot;icc_U&quot; %}
 3785   interface(REG_INTER);
 3786 %}
 3787 
 3788 // Condition Code Register, pointer comparisons.
 3789 operand flagsRegP() %{
 3790   constraint(ALLOC_IN_RC(int_flags));
 3791   match(RegFlags);
 3792 
 3793   format %{ &quot;xcc_P&quot; %}
 3794   interface(REG_INTER);
 3795 %}
 3796 
 3797 // Condition Code Register, long comparisons.
 3798 operand flagsRegL() %{
 3799   constraint(ALLOC_IN_RC(int_flags));
 3800   match(RegFlags);
 3801 
 3802   format %{ &quot;xcc_L&quot; %}
 3803   interface(REG_INTER);
 3804 %}
 3805 
 3806 // Condition Code Register, unsigned long comparisons.
 3807 operand flagsRegUL() %{
 3808   constraint(ALLOC_IN_RC(int_flags));
 3809   match(RegFlags);
 3810 
 3811   format %{ &quot;xcc_UL&quot; %}
 3812   interface(REG_INTER);
 3813 %}
 3814 
 3815 // Condition Code Register, floating comparisons, unordered same as &quot;less&quot;.
 3816 operand flagsRegF() %{
 3817   constraint(ALLOC_IN_RC(float_flags));
 3818   match(RegFlags);
 3819   match(flagsRegF0);
 3820 
 3821   format %{ %}
 3822   interface(REG_INTER);
 3823 %}
 3824 
 3825 operand flagsRegF0() %{
 3826   constraint(ALLOC_IN_RC(float_flag0));
 3827   match(RegFlags);
 3828 
 3829   format %{ %}
 3830   interface(REG_INTER);
 3831 %}
 3832 
 3833 
 3834 // Condition Code Flag Register used by long compare
 3835 operand flagsReg_long_LTGE() %{
 3836   constraint(ALLOC_IN_RC(int_flags));
 3837   match(RegFlags);
 3838   format %{ &quot;icc_LTGE&quot; %}
 3839   interface(REG_INTER);
 3840 %}
 3841 operand flagsReg_long_EQNE() %{
 3842   constraint(ALLOC_IN_RC(int_flags));
 3843   match(RegFlags);
 3844   format %{ &quot;icc_EQNE&quot; %}
 3845   interface(REG_INTER);
 3846 %}
 3847 operand flagsReg_long_LEGT() %{
 3848   constraint(ALLOC_IN_RC(int_flags));
 3849   match(RegFlags);
 3850   format %{ &quot;icc_LEGT&quot; %}
 3851   interface(REG_INTER);
 3852 %}
 3853 
 3854 
 3855 operand regD() %{
 3856   constraint(ALLOC_IN_RC(dflt_reg));
 3857   match(RegD);
 3858 
 3859   match(regD_low);
 3860 
 3861   format %{ %}
 3862   interface(REG_INTER);
 3863 %}
 3864 
 3865 operand regF() %{
 3866   constraint(ALLOC_IN_RC(sflt_reg));
 3867   match(RegF);
 3868 
 3869   format %{ %}
 3870   interface(REG_INTER);
 3871 %}
 3872 
 3873 operand regD_low() %{
 3874   constraint(ALLOC_IN_RC(dflt_low_reg));
 3875   match(regD);
 3876 
 3877   format %{ %}
 3878   interface(REG_INTER);
 3879 %}
 3880 
 3881 // Special Registers
 3882 
 3883 // Method Register
 3884 operand inline_cache_regP(iRegP reg) %{
 3885   constraint(ALLOC_IN_RC(g5_regP)); // G5=inline_cache_reg but uses 2 bits instead of 1
 3886   match(reg);
 3887   format %{ %}
 3888   interface(REG_INTER);
 3889 %}
 3890 
 3891 operand interpreter_method_oop_regP(iRegP reg) %{
 3892   constraint(ALLOC_IN_RC(g5_regP)); // G5=interpreter_method_oop_reg but uses 2 bits instead of 1
 3893   match(reg);
 3894   format %{ %}
 3895   interface(REG_INTER);
 3896 %}
 3897 
 3898 
 3899 //----------Complex Operands---------------------------------------------------
 3900 // Indirect Memory Reference
 3901 operand indirect(sp_ptr_RegP reg) %{
 3902   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3903   match(reg);
 3904 
 3905   op_cost(100);
 3906   format %{ &quot;[$reg]&quot; %}
 3907   interface(MEMORY_INTER) %{
 3908     base($reg);
 3909     index(0x0);
 3910     scale(0x0);
 3911     disp(0x0);
 3912   %}
 3913 %}
 3914 
 3915 // Indirect with simm13 Offset
 3916 operand indOffset13(sp_ptr_RegP reg, immX13 offset) %{
 3917   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3918   match(AddP reg offset);
 3919 
 3920   op_cost(100);
 3921   format %{ &quot;[$reg + $offset]&quot; %}
 3922   interface(MEMORY_INTER) %{
 3923     base($reg);
 3924     index(0x0);
 3925     scale(0x0);
 3926     disp($offset);
 3927   %}
 3928 %}
 3929 
 3930 // Indirect with simm13 Offset minus 7
 3931 operand indOffset13m7(sp_ptr_RegP reg, immX13m7 offset) %{
 3932   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3933   match(AddP reg offset);
 3934 
 3935   op_cost(100);
 3936   format %{ &quot;[$reg + $offset]&quot; %}
 3937   interface(MEMORY_INTER) %{
 3938     base($reg);
 3939     index(0x0);
 3940     scale(0x0);
 3941     disp($offset);
 3942   %}
 3943 %}
 3944 
 3945 // Note:  Intel has a swapped version also, like this:
 3946 //operand indOffsetX(iRegI reg, immP offset) %{
 3947 //  constraint(ALLOC_IN_RC(int_reg));
 3948 //  match(AddP offset reg);
 3949 //
 3950 //  op_cost(100);
 3951 //  format %{ &quot;[$reg + $offset]&quot; %}
 3952 //  interface(MEMORY_INTER) %{
 3953 //    base($reg);
 3954 //    index(0x0);
 3955 //    scale(0x0);
 3956 //    disp($offset);
 3957 //  %}
 3958 //%}
 3959 //// However, it doesn&#39;t make sense for SPARC, since
 3960 // we have no particularly good way to embed oops in
 3961 // single instructions.
 3962 
 3963 // Indirect with Register Index
 3964 operand indIndex(iRegP addr, iRegX index) %{
 3965   constraint(ALLOC_IN_RC(ptr_reg));
 3966   match(AddP addr index);
 3967 
 3968   op_cost(100);
 3969   format %{ &quot;[$addr + $index]&quot; %}
 3970   interface(MEMORY_INTER) %{
 3971     base($addr);
 3972     index($index);
 3973     scale(0x0);
 3974     disp(0x0);
 3975   %}
 3976 %}
 3977 
 3978 //----------Special Memory Operands--------------------------------------------
 3979 // Stack Slot Operand - This operand is used for loading and storing temporary
 3980 //                      values on the stack where a match requires a value to
 3981 //                      flow through memory.
 3982 operand stackSlotI(sRegI reg) %{
 3983   constraint(ALLOC_IN_RC(stack_slots));
 3984   op_cost(100);
 3985   //match(RegI);
 3986   format %{ &quot;[$reg]&quot; %}
 3987   interface(MEMORY_INTER) %{
 3988     base(0xE);   // R_SP
 3989     index(0x0);
 3990     scale(0x0);
 3991     disp($reg);  // Stack Offset
 3992   %}
 3993 %}
 3994 
 3995 operand stackSlotP(sRegP reg) %{
 3996   constraint(ALLOC_IN_RC(stack_slots));
 3997   op_cost(100);
 3998   //match(RegP);
 3999   format %{ &quot;[$reg]&quot; %}
 4000   interface(MEMORY_INTER) %{
 4001     base(0xE);   // R_SP
 4002     index(0x0);
 4003     scale(0x0);
 4004     disp($reg);  // Stack Offset
 4005   %}
 4006 %}
 4007 
 4008 operand stackSlotF(sRegF reg) %{
 4009   constraint(ALLOC_IN_RC(stack_slots));
 4010   op_cost(100);
 4011   //match(RegF);
 4012   format %{ &quot;[$reg]&quot; %}
 4013   interface(MEMORY_INTER) %{
 4014     base(0xE);   // R_SP
 4015     index(0x0);
 4016     scale(0x0);
 4017     disp($reg);  // Stack Offset
 4018   %}
 4019 %}
 4020 operand stackSlotD(sRegD reg) %{
 4021   constraint(ALLOC_IN_RC(stack_slots));
 4022   op_cost(100);
 4023   //match(RegD);
 4024   format %{ &quot;[$reg]&quot; %}
 4025   interface(MEMORY_INTER) %{
 4026     base(0xE);   // R_SP
 4027     index(0x0);
 4028     scale(0x0);
 4029     disp($reg);  // Stack Offset
 4030   %}
 4031 %}
 4032 operand stackSlotL(sRegL reg) %{
 4033   constraint(ALLOC_IN_RC(stack_slots));
 4034   op_cost(100);
 4035   //match(RegL);
 4036   format %{ &quot;[$reg]&quot; %}
 4037   interface(MEMORY_INTER) %{
 4038     base(0xE);   // R_SP
 4039     index(0x0);
 4040     scale(0x0);
 4041     disp($reg);  // Stack Offset
 4042   %}
 4043 %}
 4044 
 4045 // Operands for expressing Control Flow
 4046 // NOTE:  Label is a predefined operand which should not be redefined in
 4047 //        the AD file.  It is generically handled within the ADLC.
 4048 
 4049 //----------Conditional Branch Operands----------------------------------------
 4050 // Comparison Op  - This is the operation of the comparison, and is limited to
 4051 //                  the following set of codes:
 4052 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4053 //
 4054 // Other attributes of the comparison, such as unsignedness, are specified
 4055 // by the comparison instruction that sets a condition code flags register.
 4056 // That result is represented by a flags operand whose subtype is appropriate
 4057 // to the unsignedness (etc.) of the comparison.
 4058 //
 4059 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4060 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4061 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4062 
 4063 operand cmpOp() %{
 4064   match(Bool);
 4065 
 4066   format %{ &quot;&quot; %}
 4067   interface(COND_INTER) %{
 4068     equal(0x1);
 4069     not_equal(0x9);
 4070     less(0x3);
 4071     greater_equal(0xB);
 4072     less_equal(0x2);
 4073     greater(0xA);
 4074     overflow(0x7);
 4075     no_overflow(0xF);
 4076   %}
 4077 %}
 4078 
 4079 // Comparison Op, unsigned
 4080 operand cmpOpU() %{
 4081   match(Bool);
 4082   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4083             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4084 
 4085   format %{ &quot;u&quot; %}
 4086   interface(COND_INTER) %{
 4087     equal(0x1);
 4088     not_equal(0x9);
 4089     less(0x5);
 4090     greater_equal(0xD);
 4091     less_equal(0x4);
 4092     greater(0xC);
 4093     overflow(0x7);
 4094     no_overflow(0xF);
 4095   %}
 4096 %}
 4097 
 4098 // Comparison Op, pointer (same as unsigned)
 4099 operand cmpOpP() %{
 4100   match(Bool);
 4101   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4102             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4103 
 4104   format %{ &quot;p&quot; %}
 4105   interface(COND_INTER) %{
 4106     equal(0x1);
 4107     not_equal(0x9);
 4108     less(0x5);
 4109     greater_equal(0xD);
 4110     less_equal(0x4);
 4111     greater(0xC);
 4112     overflow(0x7);
 4113     no_overflow(0xF);
 4114   %}
 4115 %}
 4116 
 4117 // Comparison Op, branch-register encoding
 4118 operand cmpOp_reg() %{
 4119   match(Bool);
 4120   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4121             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4122 
 4123   format %{ &quot;&quot; %}
 4124   interface(COND_INTER) %{
 4125     equal        (0x1);
 4126     not_equal    (0x5);
 4127     less         (0x3);
 4128     greater_equal(0x7);
 4129     less_equal   (0x2);
 4130     greater      (0x6);
 4131     overflow(0x7); // not supported
 4132     no_overflow(0xF); // not supported
 4133   %}
 4134 %}
 4135 
 4136 // Comparison Code, floating, unordered same as less
 4137 operand cmpOpF() %{
 4138   match(Bool);
 4139   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4140             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4141 
 4142   format %{ &quot;fl&quot; %}
 4143   interface(COND_INTER) %{
 4144     equal(0x9);
 4145     not_equal(0x1);
 4146     less(0x3);
 4147     greater_equal(0xB);
 4148     less_equal(0xE);
 4149     greater(0x6);
 4150 
 4151     overflow(0x7); // not supported
 4152     no_overflow(0xF); // not supported
 4153   %}
 4154 %}
 4155 
 4156 // Used by long compare
 4157 operand cmpOp_commute() %{
 4158   match(Bool);
 4159   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4160             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4161 
 4162   format %{ &quot;&quot; %}
 4163   interface(COND_INTER) %{
 4164     equal(0x1);
 4165     not_equal(0x9);
 4166     less(0xA);
 4167     greater_equal(0x2);
 4168     less_equal(0xB);
 4169     greater(0x3);
 4170     overflow(0x7);
 4171     no_overflow(0xF);
 4172   %}
 4173 %}
 4174 
 4175 //----------OPERAND CLASSES----------------------------------------------------
 4176 // Operand Classes are groups of operands that are used to simplify
 4177 // instruction definitions by not requiring the AD writer to specify separate
 4178 // instructions for every form of operand when the instruction accepts
 4179 // multiple operand types with the same basic encoding and format.  The classic
 4180 // case of this is memory operands.
 4181 opclass memory( indirect, indOffset13, indIndex );
 4182 opclass indIndexMemory( indIndex );
 4183 
 4184 //----------PIPELINE-----------------------------------------------------------
 4185 pipeline %{
 4186 
 4187 //----------ATTRIBUTES---------------------------------------------------------
 4188 attributes %{
 4189   fixed_size_instructions;           // Fixed size instructions
 4190   branch_has_delay_slot;             // Branch has delay slot following
 4191   max_instructions_per_bundle = 4;   // Up to 4 instructions per bundle
 4192   instruction_unit_size = 4;         // An instruction is 4 bytes long
 4193   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4194   instruction_fetch_units = 1;       // of 16 bytes
 4195 
 4196   // List of nop instructions
 4197   nops( Nop_A0, Nop_A1, Nop_MS, Nop_FA, Nop_BR );
 4198 %}
 4199 
 4200 //----------RESOURCES----------------------------------------------------------
 4201 // Resources are the functional units available to the machine
 4202 resources(A0, A1, MS, BR, FA, FM, IDIV, FDIV, IALU = A0 | A1);
 4203 
 4204 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4205 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4206 
 4207 pipe_desc(A, P, F, B, I, J, S, R, E, C, M, W, X, T, D);
 4208 
 4209 //----------PIPELINE CLASSES---------------------------------------------------
 4210 // Pipeline Classes describe the stages in which input and output are
 4211 // referenced by the hardware pipeline.
 4212 
 4213 // Integer ALU reg-reg operation
 4214 pipe_class ialu_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4215     single_instruction;
 4216     dst   : E(write);
 4217     src1  : R(read);
 4218     src2  : R(read);
 4219     IALU  : R;
 4220 %}
 4221 
 4222 // Integer ALU reg-reg long operation
 4223 pipe_class ialu_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 4224     instruction_count(2);
 4225     dst   : E(write);
 4226     src1  : R(read);
 4227     src2  : R(read);
 4228     IALU  : R;
 4229     IALU  : R;
 4230 %}
 4231 
 4232 // Integer ALU reg-reg long dependent operation
 4233 pipe_class ialu_reg_reg_2_dep(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 4234     instruction_count(1); multiple_bundles;
 4235     dst   : E(write);
 4236     src1  : R(read);
 4237     src2  : R(read);
 4238     cr    : E(write);
 4239     IALU  : R(2);
 4240 %}
 4241 
 4242 // Integer ALU reg-imm operaion
 4243 pipe_class ialu_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4244     single_instruction;
 4245     dst   : E(write);
 4246     src1  : R(read);
 4247     IALU  : R;
 4248 %}
 4249 
 4250 // Integer ALU reg-reg operation with condition code
 4251 pipe_class ialu_cc_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 4252     single_instruction;
 4253     dst   : E(write);
 4254     cr    : E(write);
 4255     src1  : R(read);
 4256     src2  : R(read);
 4257     IALU  : R;
 4258 %}
 4259 
 4260 // Integer ALU reg-imm operation with condition code
 4261 pipe_class ialu_cc_reg_imm(iRegI dst, iRegI src1, immI13 src2, flagsReg cr) %{
 4262     single_instruction;
 4263     dst   : E(write);
 4264     cr    : E(write);
 4265     src1  : R(read);
 4266     IALU  : R;
 4267 %}
 4268 
 4269 // Integer ALU zero-reg operation
 4270 pipe_class ialu_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 4271     single_instruction;
 4272     dst   : E(write);
 4273     src2  : R(read);
 4274     IALU  : R;
 4275 %}
 4276 
 4277 // Integer ALU zero-reg operation with condition code only
 4278 pipe_class ialu_cconly_zero_reg(flagsReg cr, iRegI src) %{
 4279     single_instruction;
 4280     cr    : E(write);
 4281     src   : R(read);
 4282     IALU  : R;
 4283 %}
 4284 
 4285 // Integer ALU reg-reg operation with condition code only
 4286 pipe_class ialu_cconly_reg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4287     single_instruction;
 4288     cr    : E(write);
 4289     src1  : R(read);
 4290     src2  : R(read);
 4291     IALU  : R;
 4292 %}
 4293 
 4294 // Integer ALU reg-imm operation with condition code only
 4295 pipe_class ialu_cconly_reg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4296     single_instruction;
 4297     cr    : E(write);
 4298     src1  : R(read);
 4299     IALU  : R;
 4300 %}
 4301 
 4302 // Integer ALU reg-reg-zero operation with condition code only
 4303 pipe_class ialu_cconly_reg_reg_zero(flagsReg cr, iRegI src1, iRegI src2, immI0 zero) %{
 4304     single_instruction;
 4305     cr    : E(write);
 4306     src1  : R(read);
 4307     src2  : R(read);
 4308     IALU  : R;
 4309 %}
 4310 
 4311 // Integer ALU reg-imm-zero operation with condition code only
 4312 pipe_class ialu_cconly_reg_imm_zero(flagsReg cr, iRegI src1, immI13 src2, immI0 zero) %{
 4313     single_instruction;
 4314     cr    : E(write);
 4315     src1  : R(read);
 4316     IALU  : R;
 4317 %}
 4318 
 4319 // Integer ALU reg-reg operation with condition code, src1 modified
 4320 pipe_class ialu_cc_rwreg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4321     single_instruction;
 4322     cr    : E(write);
 4323     src1  : E(write);
 4324     src1  : R(read);
 4325     src2  : R(read);
 4326     IALU  : R;
 4327 %}
 4328 
 4329 // Integer ALU reg-imm operation with condition code, src1 modified
 4330 pipe_class ialu_cc_rwreg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4331     single_instruction;
 4332     cr    : E(write);
 4333     src1  : E(write);
 4334     src1  : R(read);
 4335     IALU  : R;
 4336 %}
 4337 
 4338 pipe_class cmpL_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr ) %{
 4339     multiple_bundles;
 4340     dst   : E(write)+4;
 4341     cr    : E(write);
 4342     src1  : R(read);
 4343     src2  : R(read);
 4344     IALU  : R(3);
 4345     BR    : R(2);
 4346 %}
 4347 
 4348 // Integer ALU operation
 4349 pipe_class ialu_none(iRegI dst) %{
 4350     single_instruction;
 4351     dst   : E(write);
 4352     IALU  : R;
 4353 %}
 4354 
 4355 // Integer ALU reg operation
 4356 pipe_class ialu_reg(iRegI dst, iRegI src) %{
 4357     single_instruction; may_have_no_code;
 4358     dst   : E(write);
 4359     src   : R(read);
 4360     IALU  : R;
 4361 %}
 4362 
 4363 // Integer ALU reg conditional operation
 4364 // This instruction has a 1 cycle stall, and cannot execute
 4365 // in the same cycle as the instruction setting the condition
 4366 // code. We kludge this by pretending to read the condition code
 4367 // 1 cycle earlier, and by marking the functional units as busy
 4368 // for 2 cycles with the result available 1 cycle later than
 4369 // is really the case.
 4370 pipe_class ialu_reg_flags( iRegI op2_out, iRegI op2_in, iRegI op1, flagsReg cr ) %{
 4371     single_instruction;
 4372     op2_out : C(write);
 4373     op1     : R(read);
 4374     cr      : R(read);       // This is really E, with a 1 cycle stall
 4375     BR      : R(2);
 4376     MS      : R(2);
 4377 %}
 4378 
 4379 pipe_class ialu_clr_and_mover( iRegI dst, iRegP src ) %{
 4380     instruction_count(1); multiple_bundles;
 4381     dst     : C(write)+1;
 4382     src     : R(read)+1;
 4383     IALU    : R(1);
 4384     BR      : E(2);
 4385     MS      : E(2);
 4386 %}
 4387 
 4388 // Integer ALU reg operation
 4389 pipe_class ialu_move_reg_L_to_I(iRegI dst, iRegL src) %{
 4390     single_instruction; may_have_no_code;
 4391     dst   : E(write);
 4392     src   : R(read);
 4393     IALU  : R;
 4394 %}
 4395 pipe_class ialu_move_reg_I_to_L(iRegL dst, iRegI src) %{
 4396     single_instruction; may_have_no_code;
 4397     dst   : E(write);
 4398     src   : R(read);
 4399     IALU  : R;
 4400 %}
 4401 
 4402 // Two integer ALU reg operations
 4403 pipe_class ialu_reg_2(iRegL dst, iRegL src) %{
 4404     instruction_count(2);
 4405     dst   : E(write);
 4406     src   : R(read);
 4407     A0    : R;
 4408     A1    : R;
 4409 %}
 4410 
 4411 // Two integer ALU reg operations
 4412 pipe_class ialu_move_reg_L_to_L(iRegL dst, iRegL src) %{
 4413     instruction_count(2); may_have_no_code;
 4414     dst   : E(write);
 4415     src   : R(read);
 4416     A0    : R;
 4417     A1    : R;
 4418 %}
 4419 
 4420 // Integer ALU imm operation
 4421 pipe_class ialu_imm(iRegI dst, immI13 src) %{
 4422     single_instruction;
 4423     dst   : E(write);
 4424     IALU  : R;
 4425 %}
 4426 
 4427 // Integer ALU reg-reg with carry operation
 4428 pipe_class ialu_reg_reg_cy(iRegI dst, iRegI src1, iRegI src2, iRegI cy) %{
 4429     single_instruction;
 4430     dst   : E(write);
 4431     src1  : R(read);
 4432     src2  : R(read);
 4433     IALU  : R;
 4434 %}
 4435 
 4436 // Integer ALU cc operation
 4437 pipe_class ialu_cc(iRegI dst, flagsReg cc) %{
 4438     single_instruction;
 4439     dst   : E(write);
 4440     cc    : R(read);
 4441     IALU  : R;
 4442 %}
 4443 
 4444 // Integer ALU cc / second IALU operation
 4445 pipe_class ialu_reg_ialu( iRegI dst, iRegI src ) %{
 4446     instruction_count(1); multiple_bundles;
 4447     dst   : E(write)+1;
 4448     src   : R(read);
 4449     IALU  : R;
 4450 %}
 4451 
 4452 // Integer ALU cc / second IALU operation
 4453 pipe_class ialu_reg_reg_ialu( iRegI dst, iRegI p, iRegI q ) %{
 4454     instruction_count(1); multiple_bundles;
 4455     dst   : E(write)+1;
 4456     p     : R(read);
 4457     q     : R(read);
 4458     IALU  : R;
 4459 %}
 4460 
 4461 // Integer ALU hi-lo-reg operation
 4462 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 4463     instruction_count(1); multiple_bundles;
 4464     dst   : E(write)+1;
 4465     IALU  : R(2);
 4466 %}
 4467 
 4468 // Float ALU hi-lo-reg operation (with temp)
 4469 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4470     instruction_count(1); multiple_bundles;
 4471     dst   : E(write)+1;
 4472     IALU  : R(2);
 4473 %}
 4474 
 4475 // Long Constant
 4476 pipe_class loadConL( iRegL dst, immL src ) %{
 4477     instruction_count(2); multiple_bundles;
 4478     dst   : E(write)+1;
 4479     IALU  : R(2);
 4480     IALU  : R(2);
 4481 %}
 4482 
 4483 // Pointer Constant
 4484 pipe_class loadConP( iRegP dst, immP src ) %{
 4485     instruction_count(0); multiple_bundles;
 4486     fixed_latency(6);
 4487 %}
 4488 
 4489 // Long Constant small
 4490 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4491     instruction_count(2);
 4492     dst   : E(write);
 4493     IALU  : R;
 4494     IALU  : R;
 4495 %}
 4496 
 4497 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4498 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4499     instruction_count(1); multiple_bundles;
 4500     src   : R(read);
 4501     dst   : M(write)+1;
 4502     IALU  : R;
 4503     MS    : E;
 4504 %}
 4505 
 4506 // Integer ALU nop operation
 4507 pipe_class ialu_nop() %{
 4508     single_instruction;
 4509     IALU  : R;
 4510 %}
 4511 
 4512 // Integer ALU nop operation
 4513 pipe_class ialu_nop_A0() %{
 4514     single_instruction;
 4515     A0    : R;
 4516 %}
 4517 
 4518 // Integer ALU nop operation
 4519 pipe_class ialu_nop_A1() %{
 4520     single_instruction;
 4521     A1    : R;
 4522 %}
 4523 
 4524 // Integer Multiply reg-reg operation
 4525 pipe_class imul_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4526     single_instruction;
 4527     dst   : E(write);
 4528     src1  : R(read);
 4529     src2  : R(read);
 4530     MS    : R(5);
 4531 %}
 4532 
 4533 // Integer Multiply reg-imm operation
 4534 pipe_class imul_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4535     single_instruction;
 4536     dst   : E(write);
 4537     src1  : R(read);
 4538     MS    : R(5);
 4539 %}
 4540 
 4541 pipe_class mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4542     single_instruction;
 4543     dst   : E(write)+4;
 4544     src1  : R(read);
 4545     src2  : R(read);
 4546     MS    : R(6);
 4547 %}
 4548 
 4549 pipe_class mulL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4550     single_instruction;
 4551     dst   : E(write)+4;
 4552     src1  : R(read);
 4553     MS    : R(6);
 4554 %}
 4555 
 4556 // Integer Divide reg-reg
 4557 pipe_class sdiv_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI temp, flagsReg cr) %{
 4558     instruction_count(1); multiple_bundles;
 4559     dst   : E(write);
 4560     temp  : E(write);
 4561     src1  : R(read);
 4562     src2  : R(read);
 4563     temp  : R(read);
 4564     MS    : R(38);
 4565 %}
 4566 
 4567 // Integer Divide reg-imm
 4568 pipe_class sdiv_reg_imm(iRegI dst, iRegI src1, immI13 src2, iRegI temp, flagsReg cr) %{
 4569     instruction_count(1); multiple_bundles;
 4570     dst   : E(write);
 4571     temp  : E(write);
 4572     src1  : R(read);
 4573     temp  : R(read);
 4574     MS    : R(38);
 4575 %}
 4576 
 4577 // Long Divide
 4578 pipe_class divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4579     dst  : E(write)+71;
 4580     src1 : R(read);
 4581     src2 : R(read)+1;
 4582     MS   : R(70);
 4583 %}
 4584 
 4585 pipe_class divL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4586     dst  : E(write)+71;
 4587     src1 : R(read);
 4588     MS   : R(70);
 4589 %}
 4590 
 4591 // Floating Point Add Float
 4592 pipe_class faddF_reg_reg(regF dst, regF src1, regF src2) %{
 4593     single_instruction;
 4594     dst   : X(write);
 4595     src1  : E(read);
 4596     src2  : E(read);
 4597     FA    : R;
 4598 %}
 4599 
 4600 // Floating Point Add Double
 4601 pipe_class faddD_reg_reg(regD dst, regD src1, regD src2) %{
 4602     single_instruction;
 4603     dst   : X(write);
 4604     src1  : E(read);
 4605     src2  : E(read);
 4606     FA    : R;
 4607 %}
 4608 
 4609 // Floating Point Conditional Move based on integer flags
 4610 pipe_class int_conditional_float_move (cmpOp cmp, flagsReg cr, regF dst, regF src) %{
 4611     single_instruction;
 4612     dst   : X(write);
 4613     src   : E(read);
 4614     cr    : R(read);
 4615     FA    : R(2);
 4616     BR    : R(2);
 4617 %}
 4618 
 4619 // Floating Point Conditional Move based on integer flags
 4620 pipe_class int_conditional_double_move (cmpOp cmp, flagsReg cr, regD dst, regD src) %{
 4621     single_instruction;
 4622     dst   : X(write);
 4623     src   : E(read);
 4624     cr    : R(read);
 4625     FA    : R(2);
 4626     BR    : R(2);
 4627 %}
 4628 
 4629 // Floating Point Multiply Float
 4630 pipe_class fmulF_reg_reg(regF dst, regF src1, regF src2) %{
 4631     single_instruction;
 4632     dst   : X(write);
 4633     src1  : E(read);
 4634     src2  : E(read);
 4635     FM    : R;
 4636 %}
 4637 
 4638 // Floating Point Multiply Double
 4639 pipe_class fmulD_reg_reg(regD dst, regD src1, regD src2) %{
 4640     single_instruction;
 4641     dst   : X(write);
 4642     src1  : E(read);
 4643     src2  : E(read);
 4644     FM    : R;
 4645 %}
 4646 
 4647 // Floating Point Divide Float
 4648 pipe_class fdivF_reg_reg(regF dst, regF src1, regF src2) %{
 4649     single_instruction;
 4650     dst   : X(write);
 4651     src1  : E(read);
 4652     src2  : E(read);
 4653     FM    : R;
 4654     FDIV  : C(14);
 4655 %}
 4656 
 4657 // Floating Point Divide Double
 4658 pipe_class fdivD_reg_reg(regD dst, regD src1, regD src2) %{
 4659     single_instruction;
 4660     dst   : X(write);
 4661     src1  : E(read);
 4662     src2  : E(read);
 4663     FM    : R;
 4664     FDIV  : C(17);
 4665 %}
 4666 
 4667 // Fused floating-point multiply-add float.
 4668 pipe_class fmaF_regx4(regF dst, regF src1, regF src2, regF src3) %{
 4669     single_instruction;
 4670     dst   : X(write);
 4671     src1  : E(read);
 4672     src2  : E(read);
 4673     src3  : E(read);
 4674     FM    : R;
 4675 %}
 4676 
 4677 // Fused gloating-point multiply-add double.
 4678 pipe_class fmaD_regx4(regD dst, regD src1, regD src2, regD src3) %{
 4679     single_instruction;
 4680     dst   : X(write);
 4681     src1  : E(read);
 4682     src2  : E(read);
 4683     src3  : E(read);
 4684     FM    : R;
 4685 %}
 4686 
 4687 // Floating Point Move/Negate/Abs Float
 4688 pipe_class faddF_reg(regF dst, regF src) %{
 4689     single_instruction;
 4690     dst   : W(write);
 4691     src   : E(read);
 4692     FA    : R(1);
 4693 %}
 4694 
 4695 // Floating Point Move/Negate/Abs Double
 4696 pipe_class faddD_reg(regD dst, regD src) %{
 4697     single_instruction;
 4698     dst   : W(write);
 4699     src   : E(read);
 4700     FA    : R;
 4701 %}
 4702 
 4703 // Floating Point Convert F-&gt;D
 4704 pipe_class fcvtF2D(regD dst, regF src) %{
 4705     single_instruction;
 4706     dst   : X(write);
 4707     src   : E(read);
 4708     FA    : R;
 4709 %}
 4710 
 4711 // Floating Point Convert I-&gt;D
 4712 pipe_class fcvtI2D(regD dst, regF src) %{
 4713     single_instruction;
 4714     dst   : X(write);
 4715     src   : E(read);
 4716     FA    : R;
 4717 %}
 4718 
 4719 // Floating Point Convert LHi-&gt;D
 4720 pipe_class fcvtLHi2D(regD dst, regD src) %{
 4721     single_instruction;
 4722     dst   : X(write);
 4723     src   : E(read);
 4724     FA    : R;
 4725 %}
 4726 
 4727 // Floating Point Convert L-&gt;D
 4728 pipe_class fcvtL2D(regD dst, regF src) %{
 4729     single_instruction;
 4730     dst   : X(write);
 4731     src   : E(read);
 4732     FA    : R;
 4733 %}
 4734 
 4735 // Floating Point Convert L-&gt;F
 4736 pipe_class fcvtL2F(regD dst, regF src) %{
 4737     single_instruction;
 4738     dst   : X(write);
 4739     src   : E(read);
 4740     FA    : R;
 4741 %}
 4742 
 4743 // Floating Point Convert D-&gt;F
 4744 pipe_class fcvtD2F(regD dst, regF src) %{
 4745     single_instruction;
 4746     dst   : X(write);
 4747     src   : E(read);
 4748     FA    : R;
 4749 %}
 4750 
 4751 // Floating Point Convert I-&gt;L
 4752 pipe_class fcvtI2L(regD dst, regF src) %{
 4753     single_instruction;
 4754     dst   : X(write);
 4755     src   : E(read);
 4756     FA    : R;
 4757 %}
 4758 
 4759 // Floating Point Convert D-&gt;F
 4760 pipe_class fcvtD2I(regF dst, regD src, flagsReg cr) %{
 4761     instruction_count(1); multiple_bundles;
 4762     dst   : X(write)+6;
 4763     src   : E(read);
 4764     FA    : R;
 4765 %}
 4766 
 4767 // Floating Point Convert D-&gt;L
 4768 pipe_class fcvtD2L(regD dst, regD src, flagsReg cr) %{
 4769     instruction_count(1); multiple_bundles;
 4770     dst   : X(write)+6;
 4771     src   : E(read);
 4772     FA    : R;
 4773 %}
 4774 
 4775 // Floating Point Convert F-&gt;I
 4776 pipe_class fcvtF2I(regF dst, regF src, flagsReg cr) %{
 4777     instruction_count(1); multiple_bundles;
 4778     dst   : X(write)+6;
 4779     src   : E(read);
 4780     FA    : R;
 4781 %}
 4782 
 4783 // Floating Point Convert F-&gt;L
 4784 pipe_class fcvtF2L(regD dst, regF src, flagsReg cr) %{
 4785     instruction_count(1); multiple_bundles;
 4786     dst   : X(write)+6;
 4787     src   : E(read);
 4788     FA    : R;
 4789 %}
 4790 
 4791 // Floating Point Convert I-&gt;F
 4792 pipe_class fcvtI2F(regF dst, regF src) %{
 4793     single_instruction;
 4794     dst   : X(write);
 4795     src   : E(read);
 4796     FA    : R;
 4797 %}
 4798 
 4799 // Floating Point Compare
 4800 pipe_class faddF_fcc_reg_reg_zero(flagsRegF cr, regF src1, regF src2, immI0 zero) %{
 4801     single_instruction;
 4802     cr    : X(write);
 4803     src1  : E(read);
 4804     src2  : E(read);
 4805     FA    : R;
 4806 %}
 4807 
 4808 // Floating Point Compare
 4809 pipe_class faddD_fcc_reg_reg_zero(flagsRegF cr, regD src1, regD src2, immI0 zero) %{
 4810     single_instruction;
 4811     cr    : X(write);
 4812     src1  : E(read);
 4813     src2  : E(read);
 4814     FA    : R;
 4815 %}
 4816 
 4817 // Floating Add Nop
 4818 pipe_class fadd_nop() %{
 4819     single_instruction;
 4820     FA  : R;
 4821 %}
 4822 
 4823 // Integer Store to Memory
 4824 pipe_class istore_mem_reg(memory mem, iRegI src) %{
 4825     single_instruction;
 4826     mem   : R(read);
 4827     src   : C(read);
 4828     MS    : R;
 4829 %}
 4830 
 4831 // Integer Store to Memory
 4832 pipe_class istore_mem_spORreg(memory mem, sp_ptr_RegP src) %{
 4833     single_instruction;
 4834     mem   : R(read);
 4835     src   : C(read);
 4836     MS    : R;
 4837 %}
 4838 
 4839 // Integer Store Zero to Memory
 4840 pipe_class istore_mem_zero(memory mem, immI0 src) %{
 4841     single_instruction;
 4842     mem   : R(read);
 4843     MS    : R;
 4844 %}
 4845 
 4846 // Special Stack Slot Store
 4847 pipe_class istore_stk_reg(stackSlotI stkSlot, iRegI src) %{
 4848     single_instruction;
 4849     stkSlot : R(read);
 4850     src     : C(read);
 4851     MS      : R;
 4852 %}
 4853 
 4854 // Special Stack Slot Store
 4855 pipe_class lstoreI_stk_reg(stackSlotL stkSlot, iRegI src) %{
 4856     instruction_count(2); multiple_bundles;
 4857     stkSlot : R(read);
 4858     src     : C(read);
 4859     MS      : R(2);
 4860 %}
 4861 
 4862 // Float Store
 4863 pipe_class fstoreF_mem_reg(memory mem, RegF src) %{
 4864     single_instruction;
 4865     mem : R(read);
 4866     src : C(read);
 4867     MS  : R;
 4868 %}
 4869 
 4870 // Float Store
 4871 pipe_class fstoreF_mem_zero(memory mem, immF0 src) %{
 4872     single_instruction;
 4873     mem : R(read);
 4874     MS  : R;
 4875 %}
 4876 
 4877 // Double Store
 4878 pipe_class fstoreD_mem_reg(memory mem, RegD src) %{
 4879     instruction_count(1);
 4880     mem : R(read);
 4881     src : C(read);
 4882     MS  : R;
 4883 %}
 4884 
 4885 // Double Store
 4886 pipe_class fstoreD_mem_zero(memory mem, immD0 src) %{
 4887     single_instruction;
 4888     mem : R(read);
 4889     MS  : R;
 4890 %}
 4891 
 4892 // Special Stack Slot Float Store
 4893 pipe_class fstoreF_stk_reg(stackSlotI stkSlot, RegF src) %{
 4894     single_instruction;
 4895     stkSlot : R(read);
 4896     src     : C(read);
 4897     MS      : R;
 4898 %}
 4899 
 4900 // Special Stack Slot Double Store
 4901 pipe_class fstoreD_stk_reg(stackSlotI stkSlot, RegD src) %{
 4902     single_instruction;
 4903     stkSlot : R(read);
 4904     src     : C(read);
 4905     MS      : R;
 4906 %}
 4907 
 4908 // Integer Load (when sign bit propagation not needed)
 4909 pipe_class iload_mem(iRegI dst, memory mem) %{
 4910     single_instruction;
 4911     mem : R(read);
 4912     dst : C(write);
 4913     MS  : R;
 4914 %}
 4915 
 4916 // Integer Load from stack operand
 4917 pipe_class iload_stkD(iRegI dst, stackSlotD mem ) %{
 4918     single_instruction;
 4919     mem : R(read);
 4920     dst : C(write);
 4921     MS  : R;
 4922 %}
 4923 
 4924 // Integer Load (when sign bit propagation or masking is needed)
 4925 pipe_class iload_mask_mem(iRegI dst, memory mem) %{
 4926     single_instruction;
 4927     mem : R(read);
 4928     dst : M(write);
 4929     MS  : R;
 4930 %}
 4931 
 4932 // Float Load
 4933 pipe_class floadF_mem(regF dst, memory mem) %{
 4934     single_instruction;
 4935     mem : R(read);
 4936     dst : M(write);
 4937     MS  : R;
 4938 %}
 4939 
 4940 // Float Load
 4941 pipe_class floadD_mem(regD dst, memory mem) %{
 4942     instruction_count(1); multiple_bundles; // Again, unaligned argument is only multiple case
 4943     mem : R(read);
 4944     dst : M(write);
 4945     MS  : R;
 4946 %}
 4947 
 4948 // Float Load
 4949 pipe_class floadF_stk(regF dst, stackSlotI stkSlot) %{
 4950     single_instruction;
 4951     stkSlot : R(read);
 4952     dst : M(write);
 4953     MS  : R;
 4954 %}
 4955 
 4956 // Float Load
 4957 pipe_class floadD_stk(regD dst, stackSlotI stkSlot) %{
 4958     single_instruction;
 4959     stkSlot : R(read);
 4960     dst : M(write);
 4961     MS  : R;
 4962 %}
 4963 
 4964 // Memory Nop
 4965 pipe_class mem_nop() %{
 4966     single_instruction;
 4967     MS  : R;
 4968 %}
 4969 
 4970 pipe_class sethi(iRegP dst, immI src) %{
 4971     single_instruction;
 4972     dst  : E(write);
 4973     IALU : R;
 4974 %}
 4975 
 4976 pipe_class loadPollP(iRegP poll) %{
 4977     single_instruction;
 4978     poll : R(read);
 4979     MS   : R;
 4980 %}
 4981 
 4982 pipe_class br(Universe br, label labl) %{
 4983     single_instruction_with_delay_slot;
 4984     BR  : R;
 4985 %}
 4986 
 4987 pipe_class br_cc(Universe br, cmpOp cmp, flagsReg cr, label labl) %{
 4988     single_instruction_with_delay_slot;
 4989     cr    : E(read);
 4990     BR    : R;
 4991 %}
 4992 
 4993 pipe_class br_reg(Universe br, cmpOp cmp, iRegI op1, label labl) %{
 4994     single_instruction_with_delay_slot;
 4995     op1 : E(read);
 4996     BR  : R;
 4997     MS  : R;
 4998 %}
 4999 
 5000 // Compare and branch
 5001 pipe_class cmp_br_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 5002     instruction_count(2); has_delay_slot;
 5003     cr    : E(write);
 5004     src1  : R(read);
 5005     src2  : R(read);
 5006     IALU  : R;
 5007     BR    : R;
 5008 %}
 5009 
 5010 // Compare and branch
 5011 pipe_class cmp_br_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI13 src2, label labl, flagsReg cr) %{
 5012     instruction_count(2); has_delay_slot;
 5013     cr    : E(write);
 5014     src1  : R(read);
 5015     IALU  : R;
 5016     BR    : R;
 5017 %}
 5018 
 5019 // Compare and branch using cbcond
 5020 pipe_class cbcond_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl) %{
 5021     single_instruction;
 5022     src1  : E(read);
 5023     src2  : E(read);
 5024     IALU  : R;
 5025     BR    : R;
 5026 %}
 5027 
 5028 // Compare and branch using cbcond
 5029 pipe_class cbcond_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI5 src2, label labl) %{
 5030     single_instruction;
 5031     src1  : E(read);
 5032     IALU  : R;
 5033     BR    : R;
 5034 %}
 5035 
 5036 pipe_class br_fcc(Universe br, cmpOpF cc, flagsReg cr, label labl) %{
 5037     single_instruction_with_delay_slot;
 5038     cr    : E(read);
 5039     BR    : R;
 5040 %}
 5041 
 5042 pipe_class br_nop() %{
 5043     single_instruction;
 5044     BR  : R;
 5045 %}
 5046 
 5047 pipe_class simple_call(method meth) %{
 5048     instruction_count(2); multiple_bundles; force_serialization;
 5049     fixed_latency(100);
 5050     BR  : R(1);
 5051     MS  : R(1);
 5052     A0  : R(1);
 5053 %}
 5054 
 5055 pipe_class compiled_call(method meth) %{
 5056     instruction_count(1); multiple_bundles; force_serialization;
 5057     fixed_latency(100);
 5058     MS  : R(1);
 5059 %}
 5060 
 5061 pipe_class call(method meth) %{
 5062     instruction_count(0); multiple_bundles; force_serialization;
 5063     fixed_latency(100);
 5064 %}
 5065 
 5066 pipe_class tail_call(Universe ignore, label labl) %{
 5067     single_instruction; has_delay_slot;
 5068     fixed_latency(100);
 5069     BR  : R(1);
 5070     MS  : R(1);
 5071 %}
 5072 
 5073 pipe_class ret(Universe ignore) %{
 5074     single_instruction; has_delay_slot;
 5075     BR  : R(1);
 5076     MS  : R(1);
 5077 %}
 5078 
 5079 pipe_class ret_poll(g3RegP poll) %{
 5080     instruction_count(3); has_delay_slot;
 5081     poll : E(read);
 5082     MS   : R;
 5083 %}
 5084 
 5085 // The real do-nothing guy
 5086 pipe_class empty( ) %{
 5087     instruction_count(0);
 5088 %}
 5089 
 5090 pipe_class long_memory_op() %{
 5091     instruction_count(0); multiple_bundles; force_serialization;
 5092     fixed_latency(25);
 5093     MS  : R(1);
 5094 %}
 5095 
 5096 // Check-cast
 5097 pipe_class partial_subtype_check_pipe(Universe ignore, iRegP array, iRegP match ) %{
 5098     array : R(read);
 5099     match  : R(read);
 5100     IALU   : R(2);
 5101     BR     : R(2);
 5102     MS     : R;
 5103 %}
 5104 
 5105 // Convert FPU flags into +1,0,-1
 5106 pipe_class floating_cmp( iRegI dst, regF src1, regF src2 ) %{
 5107     src1  : E(read);
 5108     src2  : E(read);
 5109     dst   : E(write);
 5110     FA    : R;
 5111     MS    : R(2);
 5112     BR    : R(2);
 5113 %}
 5114 
 5115 // Compare for p &lt; q, and conditionally add y
 5116 pipe_class cadd_cmpltmask( iRegI p, iRegI q, iRegI y ) %{
 5117     p     : E(read);
 5118     q     : E(read);
 5119     y     : E(read);
 5120     IALU  : R(3)
 5121 %}
 5122 
 5123 // Perform a compare, then move conditionally in a branch delay slot.
 5124 pipe_class min_max( iRegI src2, iRegI srcdst ) %{
 5125     src2   : E(read);
 5126     srcdst : E(read);
 5127     IALU   : R;
 5128     BR     : R;
 5129 %}
 5130 
 5131 // Define the class for the Nop node
 5132 define %{
 5133    MachNop = ialu_nop;
 5134 %}
 5135 
 5136 %}
 5137 
 5138 //----------INSTRUCTIONS-------------------------------------------------------
 5139 
 5140 //------------Special Stack Slot instructions - no match rules-----------------
 5141 instruct stkI_to_regF(regF dst, stackSlotI src) %{
 5142   // No match rule to avoid chain rule match.
 5143   effect(DEF dst, USE src);
 5144   ins_cost(MEMORY_REF_COST);
 5145   format %{ &quot;LDF    $src,$dst\t! stkI to regF&quot; %}
 5146   opcode(Assembler::ldf_op3);
 5147   ins_encode(simple_form3_mem_reg(src, dst));
 5148   ins_pipe(floadF_stk);
 5149 %}
 5150 
 5151 instruct stkL_to_regD(regD dst, stackSlotL src) %{
 5152   // No match rule to avoid chain rule match.
 5153   effect(DEF dst, USE src);
 5154   ins_cost(MEMORY_REF_COST);
 5155   format %{ &quot;LDDF   $src,$dst\t! stkL to regD&quot; %}
 5156   opcode(Assembler::lddf_op3);
 5157   ins_encode(simple_form3_mem_reg(src, dst));
 5158   ins_pipe(floadD_stk);
 5159 %}
 5160 
 5161 instruct regF_to_stkI(stackSlotI dst, regF src) %{
 5162   // No match rule to avoid chain rule match.
 5163   effect(DEF dst, USE src);
 5164   ins_cost(MEMORY_REF_COST);
 5165   format %{ &quot;STF    $src,$dst\t! regF to stkI&quot; %}
 5166   opcode(Assembler::stf_op3);
 5167   ins_encode(simple_form3_mem_reg(dst, src));
 5168   ins_pipe(fstoreF_stk_reg);
 5169 %}
 5170 
 5171 instruct regD_to_stkL(stackSlotL dst, regD src) %{
 5172   // No match rule to avoid chain rule match.
 5173   effect(DEF dst, USE src);
 5174   ins_cost(MEMORY_REF_COST);
 5175   format %{ &quot;STDF   $src,$dst\t! regD to stkL&quot; %}
 5176   opcode(Assembler::stdf_op3);
 5177   ins_encode(simple_form3_mem_reg(dst, src));
 5178   ins_pipe(fstoreD_stk_reg);
 5179 %}
 5180 
 5181 instruct regI_to_stkLHi(stackSlotL dst, iRegI src) %{
 5182   effect(DEF dst, USE src);
 5183   ins_cost(MEMORY_REF_COST*2);
 5184   format %{ &quot;STW    $src,$dst.hi\t! long\n\t&quot;
 5185             &quot;STW    R_G0,$dst.lo&quot; %}
 5186   opcode(Assembler::stw_op3);
 5187   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, R_G0));
 5188   ins_pipe(lstoreI_stk_reg);
 5189 %}
 5190 
 5191 instruct regL_to_stkD(stackSlotD dst, iRegL src) %{
 5192   // No match rule to avoid chain rule match.
 5193   effect(DEF dst, USE src);
 5194   ins_cost(MEMORY_REF_COST);
 5195   format %{ &quot;STX    $src,$dst\t! regL to stkD&quot; %}
 5196   opcode(Assembler::stx_op3);
 5197   ins_encode(simple_form3_mem_reg( dst, src ) );
 5198   ins_pipe(istore_stk_reg);
 5199 %}
 5200 
 5201 //---------- Chain stack slots between similar types --------
 5202 
 5203 // Load integer from stack slot
 5204 instruct stkI_to_regI( iRegI dst, stackSlotI src ) %{
 5205   match(Set dst src);
 5206   ins_cost(MEMORY_REF_COST);
 5207 
 5208   format %{ &quot;LDUW   $src,$dst\t!stk&quot; %}
 5209   opcode(Assembler::lduw_op3);
 5210   ins_encode(simple_form3_mem_reg( src, dst ) );
 5211   ins_pipe(iload_mem);
 5212 %}
 5213 
 5214 // Store integer to stack slot
 5215 instruct regI_to_stkI( stackSlotI dst, iRegI src ) %{
 5216   match(Set dst src);
 5217   ins_cost(MEMORY_REF_COST);
 5218 
 5219   format %{ &quot;STW    $src,$dst\t!stk&quot; %}
 5220   opcode(Assembler::stw_op3);
 5221   ins_encode(simple_form3_mem_reg( dst, src ) );
 5222   ins_pipe(istore_mem_reg);
 5223 %}
 5224 
 5225 // Load long from stack slot
 5226 instruct stkL_to_regL( iRegL dst, stackSlotL src ) %{
 5227   match(Set dst src);
 5228 
 5229   ins_cost(MEMORY_REF_COST);
 5230   format %{ &quot;LDX    $src,$dst\t! long&quot; %}
 5231   opcode(Assembler::ldx_op3);
 5232   ins_encode(simple_form3_mem_reg( src, dst ) );
 5233   ins_pipe(iload_mem);
 5234 %}
 5235 
 5236 // Store long to stack slot
 5237 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 5238   match(Set dst src);
 5239 
 5240   ins_cost(MEMORY_REF_COST);
 5241   format %{ &quot;STX    $src,$dst\t! long&quot; %}
 5242   opcode(Assembler::stx_op3);
 5243   ins_encode(simple_form3_mem_reg( dst, src ) );
 5244   ins_pipe(istore_mem_reg);
 5245 %}
 5246 
 5247 // Load pointer from stack slot, 64-bit encoding
 5248 instruct stkP_to_regP( iRegP dst, stackSlotP src ) %{
 5249   match(Set dst src);
 5250   ins_cost(MEMORY_REF_COST);
 5251   format %{ &quot;LDX    $src,$dst\t!ptr&quot; %}
 5252   opcode(Assembler::ldx_op3);
 5253   ins_encode(simple_form3_mem_reg( src, dst ) );
 5254   ins_pipe(iload_mem);
 5255 %}
 5256 
 5257 // Store pointer to stack slot
 5258 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 5259   match(Set dst src);
 5260   ins_cost(MEMORY_REF_COST);
 5261   format %{ &quot;STX    $src,$dst\t!ptr&quot; %}
 5262   opcode(Assembler::stx_op3);
 5263   ins_encode(simple_form3_mem_reg( dst, src ) );
 5264   ins_pipe(istore_mem_reg);
 5265 %}
 5266 
 5267 //------------Special Nop instructions for bundling - no match rules-----------
 5268 // Nop using the A0 functional unit
 5269 instruct Nop_A0() %{
 5270   ins_cost(0);
 5271 
 5272   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5273   opcode(Assembler::or_op3, Assembler::arith_op);
 5274   ins_encode( form2_nop() );
 5275   ins_pipe(ialu_nop_A0);
 5276 %}
 5277 
 5278 // Nop using the A1 functional unit
 5279 instruct Nop_A1( ) %{
 5280   ins_cost(0);
 5281 
 5282   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5283   opcode(Assembler::or_op3, Assembler::arith_op);
 5284   ins_encode( form2_nop() );
 5285   ins_pipe(ialu_nop_A1);
 5286 %}
 5287 
 5288 // Nop using the memory functional unit
 5289 instruct Nop_MS( ) %{
 5290   ins_cost(0);
 5291 
 5292   format %{ &quot;NOP    ! Memory Pipeline&quot; %}
 5293   ins_encode( emit_mem_nop );
 5294   ins_pipe(mem_nop);
 5295 %}
 5296 
 5297 // Nop using the floating add functional unit
 5298 instruct Nop_FA( ) %{
 5299   ins_cost(0);
 5300 
 5301   format %{ &quot;NOP    ! Floating Add Pipeline&quot; %}
 5302   ins_encode( emit_fadd_nop );
 5303   ins_pipe(fadd_nop);
 5304 %}
 5305 
 5306 // Nop using the branch functional unit
 5307 instruct Nop_BR( ) %{
 5308   ins_cost(0);
 5309 
 5310   format %{ &quot;NOP    ! Branch Pipeline&quot; %}
 5311   ins_encode( emit_br_nop );
 5312   ins_pipe(br_nop);
 5313 %}
 5314 
 5315 //----------Load/Store/Move Instructions---------------------------------------
 5316 //----------Load Instructions--------------------------------------------------
 5317 // Load Byte (8bit signed)
 5318 instruct loadB(iRegI dst, memory mem) %{
 5319   match(Set dst (LoadB mem));
 5320   ins_cost(MEMORY_REF_COST);
 5321 
 5322   size(4);
 5323   format %{ &quot;LDSB   $mem,$dst\t! byte&quot; %}
 5324   ins_encode %{
 5325     __ ldsb($mem$$Address, $dst$$Register);
 5326   %}
 5327   ins_pipe(iload_mask_mem);
 5328 %}
 5329 
 5330 // Load Byte (8bit signed) into a Long Register
 5331 instruct loadB2L(iRegL dst, memory mem) %{
 5332   match(Set dst (ConvI2L (LoadB mem)));
 5333   ins_cost(MEMORY_REF_COST);
 5334 
 5335   size(4);
 5336   format %{ &quot;LDSB   $mem,$dst\t! byte -&gt; long&quot; %}
 5337   ins_encode %{
 5338     __ ldsb($mem$$Address, $dst$$Register);
 5339   %}
 5340   ins_pipe(iload_mask_mem);
 5341 %}
 5342 
 5343 // Load Unsigned Byte (8bit UNsigned) into an int reg
 5344 instruct loadUB(iRegI dst, memory mem) %{
 5345   match(Set dst (LoadUB mem));
 5346   ins_cost(MEMORY_REF_COST);
 5347 
 5348   size(4);
 5349   format %{ &quot;LDUB   $mem,$dst\t! ubyte&quot; %}
 5350   ins_encode %{
 5351     __ ldub($mem$$Address, $dst$$Register);
 5352   %}
 5353   ins_pipe(iload_mem);
 5354 %}
 5355 
 5356 // Load Unsigned Byte (8bit UNsigned) into a Long Register
 5357 instruct loadUB2L(iRegL dst, memory mem) %{
 5358   match(Set dst (ConvI2L (LoadUB mem)));
 5359   ins_cost(MEMORY_REF_COST);
 5360 
 5361   size(4);
 5362   format %{ &quot;LDUB   $mem,$dst\t! ubyte -&gt; long&quot; %}
 5363   ins_encode %{
 5364     __ ldub($mem$$Address, $dst$$Register);
 5365   %}
 5366   ins_pipe(iload_mem);
 5367 %}
 5368 
 5369 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 5370 instruct loadUB2L_immI(iRegL dst, memory mem, immI mask) %{
 5371   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5372   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5373 
 5374   size(2*4);
 5375   format %{ &quot;LDUB   $mem,$dst\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5376             &quot;AND    $dst,right_n_bits($mask, 8),$dst&quot; %}
 5377   ins_encode %{
 5378     __ ldub($mem$$Address, $dst$$Register);
 5379     __ and3($dst$$Register, $mask$$constant &amp; right_n_bits(8), $dst$$Register);
 5380   %}
 5381   ins_pipe(iload_mem);
 5382 %}
 5383 
 5384 // Load Short (16bit signed)
 5385 instruct loadS(iRegI dst, memory mem) %{
 5386   match(Set dst (LoadS mem));
 5387   ins_cost(MEMORY_REF_COST);
 5388 
 5389   size(4);
 5390   format %{ &quot;LDSH   $mem,$dst\t! short&quot; %}
 5391   ins_encode %{
 5392     __ ldsh($mem$$Address, $dst$$Register);
 5393   %}
 5394   ins_pipe(iload_mask_mem);
 5395 %}
 5396 
 5397 // Load Short (16 bit signed) to Byte (8 bit signed)
 5398 instruct loadS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5399   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5400   ins_cost(MEMORY_REF_COST);
 5401 
 5402   size(4);
 5403 
 5404   format %{ &quot;LDSB   $mem+1,$dst\t! short -&gt; byte&quot; %}
 5405   ins_encode %{
 5406     __ ldsb($mem$$Address, $dst$$Register, 1);
 5407   %}
 5408   ins_pipe(iload_mask_mem);
 5409 %}
 5410 
 5411 // Load Short (16bit signed) into a Long Register
 5412 instruct loadS2L(iRegL dst, memory mem) %{
 5413   match(Set dst (ConvI2L (LoadS mem)));
 5414   ins_cost(MEMORY_REF_COST);
 5415 
 5416   size(4);
 5417   format %{ &quot;LDSH   $mem,$dst\t! short -&gt; long&quot; %}
 5418   ins_encode %{
 5419     __ ldsh($mem$$Address, $dst$$Register);
 5420   %}
 5421   ins_pipe(iload_mask_mem);
 5422 %}
 5423 
 5424 // Load Unsigned Short/Char (16bit UNsigned)
 5425 instruct loadUS(iRegI dst, memory mem) %{
 5426   match(Set dst (LoadUS mem));
 5427   ins_cost(MEMORY_REF_COST);
 5428 
 5429   size(4);
 5430   format %{ &quot;LDUH   $mem,$dst\t! ushort/char&quot; %}
 5431   ins_encode %{
 5432     __ lduh($mem$$Address, $dst$$Register);
 5433   %}
 5434   ins_pipe(iload_mem);
 5435 %}
 5436 
 5437 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5438 instruct loadUS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5439   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5440   ins_cost(MEMORY_REF_COST);
 5441 
 5442   size(4);
 5443   format %{ &quot;LDSB   $mem+1,$dst\t! ushort -&gt; byte&quot; %}
 5444   ins_encode %{
 5445     __ ldsb($mem$$Address, $dst$$Register, 1);
 5446   %}
 5447   ins_pipe(iload_mask_mem);
 5448 %}
 5449 
 5450 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register
 5451 instruct loadUS2L(iRegL dst, memory mem) %{
 5452   match(Set dst (ConvI2L (LoadUS mem)));
 5453   ins_cost(MEMORY_REF_COST);
 5454 
 5455   size(4);
 5456   format %{ &quot;LDUH   $mem,$dst\t! ushort/char -&gt; long&quot; %}
 5457   ins_encode %{
 5458     __ lduh($mem$$Address, $dst$$Register);
 5459   %}
 5460   ins_pipe(iload_mem);
 5461 %}
 5462 
 5463 // Load Unsigned Short/Char (16bit UNsigned) with mask 0xFF into a Long Register
 5464 instruct loadUS2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5465   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5466   ins_cost(MEMORY_REF_COST);
 5467 
 5468   size(4);
 5469   format %{ &quot;LDUB   $mem+1,$dst\t! ushort/char &amp; 0xFF -&gt; long&quot; %}
 5470   ins_encode %{
 5471     __ ldub($mem$$Address, $dst$$Register, 1);  // LSB is index+1 on BE
 5472   %}
 5473   ins_pipe(iload_mem);
 5474 %}
 5475 
 5476 // Load Unsigned Short/Char (16bit UNsigned) with a 13-bit mask into a Long Register
 5477 instruct loadUS2L_immI13(iRegL dst, memory mem, immI13 mask) %{
 5478   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5479   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5480 
 5481   size(2*4);
 5482   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 13-bit mask -&gt; long\n\t&quot;
 5483             &quot;AND    $dst,$mask,$dst&quot; %}
 5484   ins_encode %{
 5485     Register Rdst = $dst$$Register;
 5486     __ lduh($mem$$Address, Rdst);
 5487     __ and3(Rdst, $mask$$constant, Rdst);
 5488   %}
 5489   ins_pipe(iload_mem);
 5490 %}
 5491 
 5492 // Load Unsigned Short/Char (16bit UNsigned) with a 32-bit mask into a Long Register
 5493 instruct loadUS2L_immI(iRegL dst, memory mem, immI mask, iRegL tmp) %{
 5494   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5495   effect(TEMP dst, TEMP tmp);
 5496   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5497 
 5498   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5499             &quot;SET    right_n_bits($mask, 16),$tmp\n\t&quot;
 5500             &quot;AND    $dst,$tmp,$dst&quot; %}
 5501   ins_encode %{
 5502     Register Rdst = $dst$$Register;
 5503     Register Rtmp = $tmp$$Register;
 5504     __ lduh($mem$$Address, Rdst);
 5505     __ set($mask$$constant &amp; right_n_bits(16), Rtmp);
 5506     __ and3(Rdst, Rtmp, Rdst);
 5507   %}
 5508   ins_pipe(iload_mem);
 5509 %}
 5510 
 5511 // Load Integer
 5512 instruct loadI(iRegI dst, memory mem) %{
 5513   match(Set dst (LoadI mem));
 5514   ins_cost(MEMORY_REF_COST);
 5515 
 5516   size(4);
 5517   format %{ &quot;LDUW   $mem,$dst\t! int&quot; %}
 5518   ins_encode %{
 5519     __ lduw($mem$$Address, $dst$$Register);
 5520   %}
 5521   ins_pipe(iload_mem);
 5522 %}
 5523 
 5524 // Load Integer to Byte (8 bit signed)
 5525 instruct loadI2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5526   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5527   ins_cost(MEMORY_REF_COST);
 5528 
 5529   size(4);
 5530 
 5531   format %{ &quot;LDSB   $mem+3,$dst\t! int -&gt; byte&quot; %}
 5532   ins_encode %{
 5533     __ ldsb($mem$$Address, $dst$$Register, 3);
 5534   %}
 5535   ins_pipe(iload_mask_mem);
 5536 %}
 5537 
 5538 // Load Integer to Unsigned Byte (8 bit UNsigned)
 5539 instruct loadI2UB(iRegI dst, indOffset13m7 mem, immI_255 mask) %{
 5540   match(Set dst (AndI (LoadI mem) mask));
 5541   ins_cost(MEMORY_REF_COST);
 5542 
 5543   size(4);
 5544 
 5545   format %{ &quot;LDUB   $mem+3,$dst\t! int -&gt; ubyte&quot; %}
 5546   ins_encode %{
 5547     __ ldub($mem$$Address, $dst$$Register, 3);
 5548   %}
 5549   ins_pipe(iload_mask_mem);
 5550 %}
 5551 
 5552 // Load Integer to Short (16 bit signed)
 5553 instruct loadI2S(iRegI dst, indOffset13m7 mem, immI_16 sixteen) %{
 5554   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5555   ins_cost(MEMORY_REF_COST);
 5556 
 5557   size(4);
 5558 
 5559   format %{ &quot;LDSH   $mem+2,$dst\t! int -&gt; short&quot; %}
 5560   ins_encode %{
 5561     __ ldsh($mem$$Address, $dst$$Register, 2);
 5562   %}
 5563   ins_pipe(iload_mask_mem);
 5564 %}
 5565 
 5566 // Load Integer to Unsigned Short (16 bit UNsigned)
 5567 instruct loadI2US(iRegI dst, indOffset13m7 mem, immI_65535 mask) %{
 5568   match(Set dst (AndI (LoadI mem) mask));
 5569   ins_cost(MEMORY_REF_COST);
 5570 
 5571   size(4);
 5572 
 5573   format %{ &quot;LDUH   $mem+2,$dst\t! int -&gt; ushort/char&quot; %}
 5574   ins_encode %{
 5575     __ lduh($mem$$Address, $dst$$Register, 2);
 5576   %}
 5577   ins_pipe(iload_mask_mem);
 5578 %}
 5579 
 5580 // Load Integer into a Long Register
 5581 instruct loadI2L(iRegL dst, memory mem) %{
 5582   match(Set dst (ConvI2L (LoadI mem)));
 5583   ins_cost(MEMORY_REF_COST);
 5584 
 5585   size(4);
 5586   format %{ &quot;LDSW   $mem,$dst\t! int -&gt; long&quot; %}
 5587   ins_encode %{
 5588     __ ldsw($mem$$Address, $dst$$Register);
 5589   %}
 5590   ins_pipe(iload_mask_mem);
 5591 %}
 5592 
 5593 // Load Integer with mask 0xFF into a Long Register
 5594 instruct loadI2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5595   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5596   ins_cost(MEMORY_REF_COST);
 5597 
 5598   size(4);
 5599   format %{ &quot;LDUB   $mem+3,$dst\t! int &amp; 0xFF -&gt; long&quot; %}
 5600   ins_encode %{
 5601     __ ldub($mem$$Address, $dst$$Register, 3);  // LSB is index+3 on BE
 5602   %}
 5603   ins_pipe(iload_mem);
 5604 %}
 5605 
 5606 // Load Integer with mask 0xFFFF into a Long Register
 5607 instruct loadI2L_immI_65535(iRegL dst, indOffset13m7 mem, immI_65535 mask) %{
 5608   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5609   ins_cost(MEMORY_REF_COST);
 5610 
 5611   size(4);
 5612   format %{ &quot;LDUH   $mem+2,$dst\t! int &amp; 0xFFFF -&gt; long&quot; %}
 5613   ins_encode %{
 5614     __ lduh($mem$$Address, $dst$$Register, 2);  // LSW is index+2 on BE
 5615   %}
 5616   ins_pipe(iload_mem);
 5617 %}
 5618 
 5619 // Load Integer with a 12-bit mask into a Long Register
 5620 instruct loadI2L_immU12(iRegL dst, memory mem, immU12 mask) %{
 5621   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5622   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5623 
 5624   size(2*4);
 5625   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 12-bit mask -&gt; long\n\t&quot;
 5626             &quot;AND    $dst,$mask,$dst&quot; %}
 5627   ins_encode %{
 5628     Register Rdst = $dst$$Register;
 5629     __ lduw($mem$$Address, Rdst);
 5630     __ and3(Rdst, $mask$$constant, Rdst);
 5631   %}
 5632   ins_pipe(iload_mem);
 5633 %}
 5634 
 5635 // Load Integer with a 31-bit mask into a Long Register
 5636 instruct loadI2L_immU31(iRegL dst, memory mem, immU31 mask, iRegL tmp) %{
 5637   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5638   effect(TEMP dst, TEMP tmp);
 5639   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5640 
 5641   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 31-bit mask -&gt; long\n\t&quot;
 5642             &quot;SET    $mask,$tmp\n\t&quot;
 5643             &quot;AND    $dst,$tmp,$dst&quot; %}
 5644   ins_encode %{
 5645     Register Rdst = $dst$$Register;
 5646     Register Rtmp = $tmp$$Register;
 5647     __ lduw($mem$$Address, Rdst);
 5648     __ set($mask$$constant, Rtmp);
 5649     __ and3(Rdst, Rtmp, Rdst);
 5650   %}
 5651   ins_pipe(iload_mem);
 5652 %}
 5653 
 5654 // Load Unsigned Integer into a Long Register
 5655 instruct loadUI2L(iRegL dst, memory mem, immL_32bits mask) %{
 5656   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5657   ins_cost(MEMORY_REF_COST);
 5658 
 5659   size(4);
 5660   format %{ &quot;LDUW   $mem,$dst\t! uint -&gt; long&quot; %}
 5661   ins_encode %{
 5662     __ lduw($mem$$Address, $dst$$Register);
 5663   %}
 5664   ins_pipe(iload_mem);
 5665 %}
 5666 
 5667 // Load Long - aligned
 5668 instruct loadL(iRegL dst, memory mem ) %{
 5669   match(Set dst (LoadL mem));
 5670   ins_cost(MEMORY_REF_COST);
 5671 
 5672   size(4);
 5673   format %{ &quot;LDX    $mem,$dst\t! long&quot; %}
 5674   ins_encode %{
 5675     __ ldx($mem$$Address, $dst$$Register);
 5676   %}
 5677   ins_pipe(iload_mem);
 5678 %}
 5679 
 5680 // Load Long - UNaligned
 5681 instruct loadL_unaligned(iRegL dst, memory mem, o7RegI tmp) %{
 5682   match(Set dst (LoadL_unaligned mem));
 5683   effect(KILL tmp);
 5684   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5685   format %{ &quot;LDUW   $mem+4,R_O7\t! misaligned long\n&quot;
 5686           &quot;\tLDUW   $mem  ,$dst\n&quot;
 5687           &quot;\tSLLX   #32, $dst, $dst\n&quot;
 5688           &quot;\tOR     $dst, R_O7, $dst&quot; %}
 5689   opcode(Assembler::lduw_op3);
 5690   ins_encode(form3_mem_reg_long_unaligned_marshal( mem, dst ));
 5691   ins_pipe(iload_mem);
 5692 %}
 5693 
 5694 // Load Range
 5695 instruct loadRange(iRegI dst, memory mem) %{
 5696   match(Set dst (LoadRange mem));
 5697   ins_cost(MEMORY_REF_COST);
 5698 
 5699   format %{ &quot;LDUW   $mem,$dst\t! range&quot; %}
 5700   opcode(Assembler::lduw_op3);
 5701   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5702   ins_pipe(iload_mem);
 5703 %}
 5704 
 5705 // Load Integer into %f register (for fitos/fitod)
 5706 instruct loadI_freg(regF dst, memory mem) %{
 5707   match(Set dst (LoadI mem));
 5708   ins_cost(MEMORY_REF_COST);
 5709 
 5710   format %{ &quot;LDF    $mem,$dst\t! for fitos/fitod&quot; %}
 5711   opcode(Assembler::ldf_op3);
 5712   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5713   ins_pipe(floadF_mem);
 5714 %}
 5715 
 5716 // Load Pointer
 5717 instruct loadP(iRegP dst, memory mem) %{
 5718   match(Set dst (LoadP mem));
 5719   ins_cost(MEMORY_REF_COST);
 5720   size(4);
 5721 
 5722   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 5723   ins_encode %{
 5724     __ ldx($mem$$Address, $dst$$Register);
 5725   %}
 5726   ins_pipe(iload_mem);
 5727 %}
 5728 
 5729 // Load Compressed Pointer
 5730 instruct loadN(iRegN dst, memory mem) %{
 5731   match(Set dst (LoadN mem));
 5732   ins_cost(MEMORY_REF_COST);
 5733   size(4);
 5734 
 5735   format %{ &quot;LDUW   $mem,$dst\t! compressed ptr&quot; %}
 5736   ins_encode %{
 5737     __ lduw($mem$$Address, $dst$$Register);
 5738   %}
 5739   ins_pipe(iload_mem);
 5740 %}
 5741 
 5742 // Load Klass Pointer
 5743 instruct loadKlass(iRegP dst, memory mem) %{
 5744   match(Set dst (LoadKlass mem));
 5745   ins_cost(MEMORY_REF_COST);
 5746   size(4);
 5747 
 5748   format %{ &quot;LDX    $mem,$dst\t! klass ptr&quot; %}
 5749   ins_encode %{
 5750     __ ldx($mem$$Address, $dst$$Register);
 5751   %}
 5752   ins_pipe(iload_mem);
 5753 %}
 5754 
 5755 // Load narrow Klass Pointer
 5756 instruct loadNKlass(iRegN dst, memory mem) %{
 5757   match(Set dst (LoadNKlass mem));
 5758   ins_cost(MEMORY_REF_COST);
 5759   size(4);
 5760 
 5761   format %{ &quot;LDUW   $mem,$dst\t! compressed klass ptr&quot; %}
 5762   ins_encode %{
 5763     __ lduw($mem$$Address, $dst$$Register);
 5764   %}
 5765   ins_pipe(iload_mem);
 5766 %}
 5767 
 5768 // Load Double
 5769 instruct loadD(regD dst, memory mem) %{
 5770   match(Set dst (LoadD mem));
 5771   ins_cost(MEMORY_REF_COST);
 5772 
 5773   format %{ &quot;LDDF   $mem,$dst&quot; %}
 5774   opcode(Assembler::lddf_op3);
 5775   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5776   ins_pipe(floadD_mem);
 5777 %}
 5778 
 5779 // Load Double - UNaligned
 5780 instruct loadD_unaligned(regD_low dst, memory mem ) %{
 5781   match(Set dst (LoadD_unaligned mem));
 5782   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5783   format %{ &quot;LDF    $mem  ,$dst.hi\t! misaligned double\n&quot;
 5784           &quot;\tLDF    $mem+4,$dst.lo\t!&quot; %}
 5785   opcode(Assembler::ldf_op3);
 5786   ins_encode( form3_mem_reg_double_unaligned( mem, dst ));
 5787   ins_pipe(iload_mem);
 5788 %}
 5789 
 5790 // Load Float
 5791 instruct loadF(regF dst, memory mem) %{
 5792   match(Set dst (LoadF mem));
 5793   ins_cost(MEMORY_REF_COST);
 5794 
 5795   format %{ &quot;LDF    $mem,$dst&quot; %}
 5796   opcode(Assembler::ldf_op3);
 5797   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5798   ins_pipe(floadF_mem);
 5799 %}
 5800 
 5801 // Load Constant
 5802 instruct loadConI( iRegI dst, immI src ) %{
 5803   match(Set dst src);
 5804   ins_cost(DEFAULT_COST * 3/2);
 5805   format %{ &quot;SET    $src,$dst&quot; %}
 5806   ins_encode( Set32(src, dst) );
 5807   ins_pipe(ialu_hi_lo_reg);
 5808 %}
 5809 
 5810 instruct loadConI13( iRegI dst, immI13 src ) %{
 5811   match(Set dst src);
 5812 
 5813   size(4);
 5814   format %{ &quot;MOV    $src,$dst&quot; %}
 5815   ins_encode( Set13( src, dst ) );
 5816   ins_pipe(ialu_imm);
 5817 %}
 5818 
 5819 instruct loadConP_set(iRegP dst, immP_set con) %{
 5820   match(Set dst con);
 5821   ins_cost(DEFAULT_COST * 3/2);
 5822   format %{ &quot;SET    $con,$dst\t! ptr&quot; %}
 5823   ins_encode %{
 5824     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 5825       intptr_t val = $con$$constant;
 5826     if (constant_reloc == relocInfo::oop_type) {
 5827       __ set_oop_constant((jobject) val, $dst$$Register);
 5828     } else if (constant_reloc == relocInfo::metadata_type) {
 5829       __ set_metadata_constant((Metadata*)val, $dst$$Register);
 5830     } else {          // non-oop pointers, e.g. card mark base, heap top
 5831       assert(constant_reloc == relocInfo::none, &quot;unexpected reloc type&quot;);
 5832       __ set(val, $dst$$Register);
 5833     }
 5834   %}
 5835   ins_pipe(loadConP);
 5836 %}
 5837 
 5838 instruct loadConP_load(iRegP dst, immP_load con) %{
 5839   match(Set dst con);
 5840   ins_cost(MEMORY_REF_COST);
 5841   format %{ &quot;LD     [$constanttablebase + $constantoffset],$dst\t! load from constant table: ptr=$con&quot; %}
 5842   ins_encode %{
 5843     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5844     __ ld_ptr($constanttablebase, con_offset, $dst$$Register);
 5845   %}
 5846   ins_pipe(loadConP);
 5847 %}
 5848 
 5849 instruct loadConP_no_oop_cheap(iRegP dst, immP_no_oop_cheap con) %{
 5850   match(Set dst con);
 5851   ins_cost(DEFAULT_COST * 3/2);
 5852   format %{ &quot;SET    $con,$dst\t! non-oop ptr&quot; %}
 5853   ins_encode %{
 5854     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5855       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5856     } else {
 5857       __ set($con$$constant, $dst$$Register);
 5858     }
 5859   %}
 5860   ins_pipe(loadConP);
 5861 %}
 5862 
 5863 instruct loadConP0(iRegP dst, immP0 src) %{
 5864   match(Set dst src);
 5865 
 5866   size(4);
 5867   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5868   ins_encode %{
 5869     __ clr($dst$$Register);
 5870   %}
 5871   ins_pipe(ialu_imm);
 5872 %}
 5873 
 5874 instruct loadConN0(iRegN dst, immN0 src) %{
 5875   match(Set dst src);
 5876 
 5877   size(4);
 5878   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5879   ins_encode %{
 5880     __ clr($dst$$Register);
 5881   %}
 5882   ins_pipe(ialu_imm);
 5883 %}
 5884 
 5885 instruct loadConN(iRegN dst, immN src) %{
 5886   match(Set dst src);
 5887   ins_cost(DEFAULT_COST * 3/2);
 5888   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5889   ins_encode %{
 5890     Register dst = $dst$$Register;
 5891     __ set_narrow_oop((jobject)$src$$constant, dst);
 5892   %}
 5893   ins_pipe(ialu_hi_lo_reg);
 5894 %}
 5895 
 5896 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 5897   match(Set dst src);
 5898   ins_cost(DEFAULT_COST * 3/2);
 5899   format %{ &quot;SET    $src,$dst\t! compressed klass ptr&quot; %}
 5900   ins_encode %{
 5901     Register dst = $dst$$Register;
 5902     __ set_narrow_klass((Klass*)$src$$constant, dst);
 5903   %}
 5904   ins_pipe(ialu_hi_lo_reg);
 5905 %}
 5906 
 5907 // Materialize long value (predicated by immL_cheap).
 5908 instruct loadConL_set64(iRegL dst, immL_cheap con, o7RegL tmp) %{
 5909   match(Set dst con);
 5910   effect(KILL tmp);
 5911   ins_cost(DEFAULT_COST * 3);
 5912   format %{ &quot;SET64   $con,$dst KILL $tmp\t! cheap long&quot; %}
 5913   ins_encode %{
 5914     __ set64($con$$constant, $dst$$Register, $tmp$$Register);
 5915   %}
 5916   ins_pipe(loadConL);
 5917 %}
 5918 
 5919 // Load long value from constant table (predicated by immL_expensive).
 5920 instruct loadConL_ldx(iRegL dst, immL_expensive con) %{
 5921   match(Set dst con);
 5922   ins_cost(MEMORY_REF_COST);
 5923   format %{ &quot;LDX     [$constanttablebase + $constantoffset],$dst\t! load from constant table: long=$con&quot; %}
 5924   ins_encode %{
 5925       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5926     __ ldx($constanttablebase, con_offset, $dst$$Register);
 5927   %}
 5928   ins_pipe(loadConL);
 5929 %}
 5930 
 5931 instruct loadConL0( iRegL dst, immL0 src ) %{
 5932   match(Set dst src);
 5933   ins_cost(DEFAULT_COST);
 5934   size(4);
 5935   format %{ &quot;CLR    $dst\t! long&quot; %}
 5936   ins_encode( Set13( src, dst ) );
 5937   ins_pipe(ialu_imm);
 5938 %}
 5939 
 5940 instruct loadConL13( iRegL dst, immL13 src ) %{
 5941   match(Set dst src);
 5942   ins_cost(DEFAULT_COST * 2);
 5943 
 5944   size(4);
 5945   format %{ &quot;MOV    $src,$dst\t! long&quot; %}
 5946   ins_encode( Set13( src, dst ) );
 5947   ins_pipe(ialu_imm);
 5948 %}
 5949 
 5950 instruct loadConF(regF dst, immF con, o7RegI tmp) %{
 5951   match(Set dst con);
 5952   effect(KILL tmp);
 5953   format %{ &quot;LDF    [$constanttablebase + $constantoffset],$dst\t! load from constant table: float=$con&quot; %}
 5954   ins_encode %{
 5955       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5956     __ ldf(FloatRegisterImpl::S, $constanttablebase, con_offset, $dst$$FloatRegister);
 5957   %}
 5958   ins_pipe(loadConFD);
 5959 %}
 5960 
 5961 instruct loadConD(regD dst, immD con, o7RegI tmp) %{
 5962   match(Set dst con);
 5963   effect(KILL tmp);
 5964   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: double=$con&quot; %}
 5965   ins_encode %{
 5966     // XXX This is a quick fix for 6833573.
 5967     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset($con), $dst$$FloatRegister);
 5968     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5969     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
 5970   %}
 5971   ins_pipe(loadConFD);
 5972 %}
 5973 
 5974 // Prefetch instructions for allocation.
 5975 // Must be safe to execute with invalid address (cannot fault).
 5976 
 5977 instruct prefetchAlloc( memory mem ) %{
 5978   predicate(AllocatePrefetchInstr == 0);
 5979   match( PrefetchAllocation mem );
 5980   ins_cost(MEMORY_REF_COST);
 5981 
 5982   format %{ &quot;PREFETCH $mem,2\t! Prefetch allocation&quot; %}
 5983   opcode(Assembler::prefetch_op3);
 5984   ins_encode( form3_mem_prefetch_write( mem ) );
 5985   ins_pipe(iload_mem);
 5986 %}
 5987 
 5988 // Use BIS instruction to prefetch for allocation.
 5989 // Could fault, need space at the end of TLAB.
 5990 instruct prefetchAlloc_bis( iRegP dst ) %{
 5991   predicate(AllocatePrefetchInstr == 1);
 5992   match( PrefetchAllocation dst );
 5993   ins_cost(MEMORY_REF_COST);
 5994   size(4);
 5995 
 5996   format %{ &quot;STXA   [$dst]\t! // Prefetch allocation using BIS&quot; %}
 5997   ins_encode %{
 5998     __ stxa(G0, $dst$$Register, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
 5999   %}
 6000   ins_pipe(istore_mem_reg);
 6001 %}
 6002 
 6003 // Next code is used for finding next cache line address to prefetch.
 6004 instruct cacheLineAdr( iRegP dst, iRegP src, immL13 mask ) %{
 6005   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
 6006   ins_cost(DEFAULT_COST);
 6007   size(4);
 6008 
 6009   format %{ &quot;AND    $src,$mask,$dst\t! next cache line address&quot; %}
 6010   ins_encode %{
 6011     __ and3($src$$Register, $mask$$constant, $dst$$Register);
 6012   %}
 6013   ins_pipe(ialu_reg_imm);
 6014 %}
 6015 
 6016 //----------Store Instructions-------------------------------------------------
 6017 // Store Byte
 6018 instruct storeB(memory mem, iRegI src) %{
 6019   match(Set mem (StoreB mem src));
 6020   ins_cost(MEMORY_REF_COST);
 6021 
 6022   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6023   opcode(Assembler::stb_op3);
 6024   ins_encode(simple_form3_mem_reg( mem, src ) );
 6025   ins_pipe(istore_mem_reg);
 6026 %}
 6027 
 6028 instruct storeB0(memory mem, immI0 src) %{
 6029   match(Set mem (StoreB mem src));
 6030   ins_cost(MEMORY_REF_COST);
 6031 
 6032   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6033   opcode(Assembler::stb_op3);
 6034   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6035   ins_pipe(istore_mem_zero);
 6036 %}
 6037 
 6038 instruct storeCM0(memory mem, immI0 src) %{
 6039   match(Set mem (StoreCM mem src));
 6040   ins_cost(MEMORY_REF_COST);
 6041 
 6042   format %{ &quot;STB    $src,$mem\t! CMS card-mark byte 0&quot; %}
 6043   opcode(Assembler::stb_op3);
 6044   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6045   ins_pipe(istore_mem_zero);
 6046 %}
 6047 
 6048 // Store Char/Short
 6049 instruct storeC(memory mem, iRegI src) %{
 6050   match(Set mem (StoreC mem src));
 6051   ins_cost(MEMORY_REF_COST);
 6052 
 6053   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6054   opcode(Assembler::sth_op3);
 6055   ins_encode(simple_form3_mem_reg( mem, src ) );
 6056   ins_pipe(istore_mem_reg);
 6057 %}
 6058 
 6059 instruct storeC0(memory mem, immI0 src) %{
 6060   match(Set mem (StoreC mem src));
 6061   ins_cost(MEMORY_REF_COST);
 6062 
 6063   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6064   opcode(Assembler::sth_op3);
 6065   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6066   ins_pipe(istore_mem_zero);
 6067 %}
 6068 
 6069 // Store Integer
 6070 instruct storeI(memory mem, iRegI src) %{
 6071   match(Set mem (StoreI mem src));
 6072   ins_cost(MEMORY_REF_COST);
 6073 
 6074   format %{ &quot;STW    $src,$mem&quot; %}
 6075   opcode(Assembler::stw_op3);
 6076   ins_encode(simple_form3_mem_reg( mem, src ) );
 6077   ins_pipe(istore_mem_reg);
 6078 %}
 6079 
 6080 // Store Long
 6081 instruct storeL(memory mem, iRegL src) %{
 6082   match(Set mem (StoreL mem src));
 6083   ins_cost(MEMORY_REF_COST);
 6084   format %{ &quot;STX    $src,$mem\t! long&quot; %}
 6085   opcode(Assembler::stx_op3);
 6086   ins_encode(simple_form3_mem_reg( mem, src ) );
 6087   ins_pipe(istore_mem_reg);
 6088 %}
 6089 
 6090 instruct storeI0(memory mem, immI0 src) %{
 6091   match(Set mem (StoreI mem src));
 6092   ins_cost(MEMORY_REF_COST);
 6093 
 6094   format %{ &quot;STW    $src,$mem&quot; %}
 6095   opcode(Assembler::stw_op3);
 6096   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6097   ins_pipe(istore_mem_zero);
 6098 %}
 6099 
 6100 instruct storeL0(memory mem, immL0 src) %{
 6101   match(Set mem (StoreL mem src));
 6102   ins_cost(MEMORY_REF_COST);
 6103 
 6104   format %{ &quot;STX    $src,$mem&quot; %}
 6105   opcode(Assembler::stx_op3);
 6106   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6107   ins_pipe(istore_mem_zero);
 6108 %}
 6109 
 6110 // Store Integer from float register (used after fstoi)
 6111 instruct storeI_Freg(memory mem, regF src) %{
 6112   match(Set mem (StoreI mem src));
 6113   ins_cost(MEMORY_REF_COST);
 6114 
 6115   format %{ &quot;STF    $src,$mem\t! after fstoi/fdtoi&quot; %}
 6116   opcode(Assembler::stf_op3);
 6117   ins_encode(simple_form3_mem_reg( mem, src ) );
 6118   ins_pipe(fstoreF_mem_reg);
 6119 %}
 6120 
 6121 // Store Pointer
 6122 instruct storeP(memory dst, sp_ptr_RegP src) %{
 6123   match(Set dst (StoreP dst src));
 6124   ins_cost(MEMORY_REF_COST);
 6125 
 6126   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6127   opcode(Assembler::stx_op3, 0, REGP_OP);
 6128   ins_encode( form3_mem_reg( dst, src ) );
 6129   ins_pipe(istore_mem_spORreg);
 6130 %}
 6131 
 6132 instruct storeP0(memory dst, immP0 src) %{
 6133   match(Set dst (StoreP dst src));
 6134   ins_cost(MEMORY_REF_COST);
 6135 
 6136   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6137   opcode(Assembler::stx_op3, 0, REGP_OP);
 6138   ins_encode( form3_mem_reg( dst, R_G0 ) );
 6139   ins_pipe(istore_mem_zero);
 6140 %}
 6141 
 6142 // Store Compressed Pointer
 6143 instruct storeN(memory dst, iRegN src) %{
 6144    match(Set dst (StoreN dst src));
 6145    ins_cost(MEMORY_REF_COST);
 6146    size(4);
 6147 
 6148    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6149    ins_encode %{
 6150      Register base = as_Register($dst$$base);
 6151      Register index = as_Register($dst$$index);
 6152      Register src = $src$$Register;
 6153      if (index != G0) {
 6154        __ stw(src, base, index);
 6155      } else {
 6156        __ stw(src, base, $dst$$disp);
 6157      }
 6158    %}
 6159    ins_pipe(istore_mem_spORreg);
 6160 %}
 6161 
 6162 instruct storeNKlass(memory dst, iRegN src) %{
 6163    match(Set dst (StoreNKlass dst src));
 6164    ins_cost(MEMORY_REF_COST);
 6165    size(4);
 6166 
 6167    format %{ &quot;STW    $src,$dst\t! compressed klass ptr&quot; %}
 6168    ins_encode %{
 6169      Register base = as_Register($dst$$base);
 6170      Register index = as_Register($dst$$index);
 6171      Register src = $src$$Register;
 6172      if (index != G0) {
 6173        __ stw(src, base, index);
 6174      } else {
 6175        __ stw(src, base, $dst$$disp);
 6176      }
 6177    %}
 6178    ins_pipe(istore_mem_spORreg);
 6179 %}
 6180 
 6181 instruct storeN0(memory dst, immN0 src) %{
 6182    match(Set dst (StoreN dst src));
 6183    ins_cost(MEMORY_REF_COST);
 6184    size(4);
 6185 
 6186    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6187    ins_encode %{
 6188      Register base = as_Register($dst$$base);
 6189      Register index = as_Register($dst$$index);
 6190      if (index != G0) {
 6191        __ stw(0, base, index);
 6192      } else {
 6193        __ stw(0, base, $dst$$disp);
 6194      }
 6195    %}
 6196    ins_pipe(istore_mem_zero);
 6197 %}
 6198 
 6199 // Store Double
 6200 instruct storeD( memory mem, regD src) %{
 6201   match(Set mem (StoreD mem src));
 6202   ins_cost(MEMORY_REF_COST);
 6203 
 6204   format %{ &quot;STDF   $src,$mem&quot; %}
 6205   opcode(Assembler::stdf_op3);
 6206   ins_encode(simple_form3_mem_reg( mem, src ) );
 6207   ins_pipe(fstoreD_mem_reg);
 6208 %}
 6209 
 6210 instruct storeD0( memory mem, immD0 src) %{
 6211   match(Set mem (StoreD mem src));
 6212   ins_cost(MEMORY_REF_COST);
 6213 
 6214   format %{ &quot;STX    $src,$mem&quot; %}
 6215   opcode(Assembler::stx_op3);
 6216   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6217   ins_pipe(fstoreD_mem_zero);
 6218 %}
 6219 
 6220 // Store Float
 6221 instruct storeF( memory mem, regF src) %{
 6222   match(Set mem (StoreF mem src));
 6223   ins_cost(MEMORY_REF_COST);
 6224 
 6225   format %{ &quot;STF    $src,$mem&quot; %}
 6226   opcode(Assembler::stf_op3);
 6227   ins_encode(simple_form3_mem_reg( mem, src ) );
 6228   ins_pipe(fstoreF_mem_reg);
 6229 %}
 6230 
 6231 instruct storeF0( memory mem, immF0 src) %{
 6232   match(Set mem (StoreF mem src));
 6233   ins_cost(MEMORY_REF_COST);
 6234 
 6235   format %{ &quot;STW    $src,$mem\t! storeF0&quot; %}
 6236   opcode(Assembler::stw_op3);
 6237   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6238   ins_pipe(fstoreF_mem_zero);
 6239 %}
 6240 
 6241 // Convert oop pointer into compressed form
 6242 instruct encodeHeapOop(iRegN dst, iRegP src) %{
 6243   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6244   match(Set dst (EncodeP src));
 6245   format %{ &quot;encode_heap_oop $src, $dst&quot; %}
 6246   ins_encode %{
 6247     __ encode_heap_oop($src$$Register, $dst$$Register);
 6248   %}
 6249   ins_avoid_back_to_back(CompressedOops::base() == NULL ? AVOID_NONE : AVOID_BEFORE);
 6250   ins_pipe(ialu_reg);
 6251 %}
 6252 
 6253 instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
 6254   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6255   match(Set dst (EncodeP src));
 6256   format %{ &quot;encode_heap_oop_not_null $src, $dst&quot; %}
 6257   ins_encode %{
 6258     __ encode_heap_oop_not_null($src$$Register, $dst$$Register);
 6259   %}
 6260   ins_pipe(ialu_reg);
 6261 %}
 6262 
 6263 instruct decodeHeapOop(iRegP dst, iRegN src) %{
 6264   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6265             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant);
 6266   match(Set dst (DecodeN src));
 6267   format %{ &quot;decode_heap_oop $src, $dst&quot; %}
 6268   ins_encode %{
 6269     __ decode_heap_oop($src$$Register, $dst$$Register);
 6270   %}
 6271   ins_pipe(ialu_reg);
 6272 %}
 6273 
 6274 instruct decodeHeapOop_not_null(iRegP dst, iRegN src) %{
 6275   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 6276             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant);
 6277   match(Set dst (DecodeN src));
 6278   format %{ &quot;decode_heap_oop_not_null $src, $dst&quot; %}
 6279   ins_encode %{
 6280     __ decode_heap_oop_not_null($src$$Register, $dst$$Register);
 6281   %}
 6282   ins_pipe(ialu_reg);
 6283 %}
 6284 
 6285 instruct encodeKlass_not_null(iRegN dst, iRegP src) %{
 6286   match(Set dst (EncodePKlass src));
 6287   format %{ &quot;encode_klass_not_null $src, $dst&quot; %}
 6288   ins_encode %{
 6289     __ encode_klass_not_null($src$$Register, $dst$$Register);
 6290   %}
 6291   ins_pipe(ialu_reg);
 6292 %}
 6293 
 6294 instruct decodeKlass_not_null(iRegP dst, iRegN src) %{
 6295   match(Set dst (DecodeNKlass src));
 6296   format %{ &quot;decode_klass_not_null $src, $dst&quot; %}
 6297   ins_encode %{
 6298     __ decode_klass_not_null($src$$Register, $dst$$Register);
 6299   %}
 6300   ins_pipe(ialu_reg);
 6301 %}
 6302 
 6303 //----------MemBar Instructions-----------------------------------------------
 6304 // Memory barrier flavors
 6305 
 6306 instruct membar_acquire() %{
 6307   match(MemBarAcquire);
 6308   match(LoadFence);
 6309   ins_cost(4*MEMORY_REF_COST);
 6310 
 6311   size(0);
 6312   format %{ &quot;MEMBAR-acquire&quot; %}
 6313   ins_encode( enc_membar_acquire );
 6314   ins_pipe(long_memory_op);
 6315 %}
 6316 
 6317 instruct membar_acquire_lock() %{
 6318   match(MemBarAcquireLock);
 6319   ins_cost(0);
 6320 
 6321   size(0);
 6322   format %{ &quot;!MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 6323   ins_encode( );
 6324   ins_pipe(empty);
 6325 %}
 6326 
 6327 instruct membar_release() %{
 6328   match(MemBarRelease);
 6329   match(StoreFence);
 6330   ins_cost(4*MEMORY_REF_COST);
 6331 
 6332   size(0);
 6333   format %{ &quot;MEMBAR-release&quot; %}
 6334   ins_encode( enc_membar_release );
 6335   ins_pipe(long_memory_op);
 6336 %}
 6337 
 6338 instruct membar_release_lock() %{
 6339   match(MemBarReleaseLock);
 6340   ins_cost(0);
 6341 
 6342   size(0);
 6343   format %{ &quot;!MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 6344   ins_encode( );
 6345   ins_pipe(empty);
 6346 %}
 6347 
 6348 instruct membar_volatile() %{
 6349   match(MemBarVolatile);
 6350   ins_cost(4*MEMORY_REF_COST);
 6351 
 6352   size(4);
 6353   format %{ &quot;MEMBAR-volatile&quot; %}
 6354   ins_encode( enc_membar_volatile );
 6355   ins_pipe(long_memory_op);
 6356 %}
 6357 
 6358 instruct unnecessary_membar_volatile() %{
 6359   match(MemBarVolatile);
 6360   predicate(Matcher::post_store_load_barrier(n));
 6361   ins_cost(0);
 6362 
 6363   size(0);
 6364   format %{ &quot;!MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6365   ins_encode( );
 6366   ins_pipe(empty);
 6367 %}
 6368 
 6369 instruct membar_storestore() %{
 6370   match(MemBarStoreStore);
 6371   ins_cost(0);
 6372 
 6373   size(0);
 6374   format %{ &quot;!MEMBAR-storestore (empty encoding)&quot; %}
 6375   ins_encode( );
 6376   ins_pipe(empty);
 6377 %}
 6378 
 6379 //----------Register Move Instructions-----------------------------------------
 6380 instruct roundDouble_nop(regD dst) %{
 6381   match(Set dst (RoundDouble dst));
 6382   ins_cost(0);
 6383   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6384   ins_encode( );
 6385   ins_pipe(empty);
 6386 %}
 6387 
 6388 
 6389 instruct roundFloat_nop(regF dst) %{
 6390   match(Set dst (RoundFloat dst));
 6391   ins_cost(0);
 6392   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6393   ins_encode( );
 6394   ins_pipe(empty);
 6395 %}
 6396 
 6397 
 6398 // Cast Index to Pointer for unsafe natives
 6399 instruct castX2P(iRegX src, iRegP dst) %{
 6400   match(Set dst (CastX2P src));
 6401 
 6402   format %{ &quot;MOV    $src,$dst\t! IntX-&gt;Ptr&quot; %}
 6403   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6404   ins_pipe(ialu_reg);
 6405 %}
 6406 
 6407 // Cast Pointer to Index for unsafe natives
 6408 instruct castP2X(iRegP src, iRegX dst) %{
 6409   match(Set dst (CastP2X src));
 6410 
 6411   format %{ &quot;MOV    $src,$dst\t! Ptr-&gt;IntX&quot; %}
 6412   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6413   ins_pipe(ialu_reg);
 6414 %}
 6415 
 6416 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 6417   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6418   match(Set stkSlot src);   // chain rule
 6419   ins_cost(MEMORY_REF_COST);
 6420   format %{ &quot;STDF   $src,$stkSlot\t!stk&quot; %}
 6421   opcode(Assembler::stdf_op3);
 6422   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6423   ins_pipe(fstoreD_stk_reg);
 6424 %}
 6425 
 6426 instruct ldfSSD(regD dst, stackSlotD stkSlot) %{
 6427   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6428   match(Set dst stkSlot);   // chain rule
 6429   ins_cost(MEMORY_REF_COST);
 6430   format %{ &quot;LDDF   $stkSlot,$dst\t!stk&quot; %}
 6431   opcode(Assembler::lddf_op3);
 6432   ins_encode(simple_form3_mem_reg(stkSlot, dst));
 6433   ins_pipe(floadD_stk);
 6434 %}
 6435 
 6436 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 6437   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6438   match(Set stkSlot src);   // chain rule
 6439   ins_cost(MEMORY_REF_COST);
 6440   format %{ &quot;STF   $src,$stkSlot\t!stk&quot; %}
 6441   opcode(Assembler::stf_op3);
 6442   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6443   ins_pipe(fstoreF_stk_reg);
 6444 %}
 6445 
 6446 //----------Conditional Move---------------------------------------------------
 6447 // Conditional move
 6448 instruct cmovIP_reg(cmpOpP cmp, flagsRegP pcc, iRegI dst, iRegI src) %{
 6449   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6450   ins_cost(150);
 6451   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6452   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6453   ins_pipe(ialu_reg);
 6454 %}
 6455 
 6456 instruct cmovIP_imm(cmpOpP cmp, flagsRegP pcc, iRegI dst, immI11 src) %{
 6457   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6458   ins_cost(140);
 6459   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6460   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6461   ins_pipe(ialu_imm);
 6462 %}
 6463 
 6464 instruct cmovII_reg(cmpOp cmp, flagsReg icc, iRegI dst, iRegI src) %{
 6465   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6466   ins_cost(150);
 6467   size(4);
 6468   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6469   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6470   ins_pipe(ialu_reg);
 6471 %}
 6472 
 6473 instruct cmovII_imm(cmpOp cmp, flagsReg icc, iRegI dst, immI11 src) %{
 6474   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6475   ins_cost(140);
 6476   size(4);
 6477   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6478   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6479   ins_pipe(ialu_imm);
 6480 %}
 6481 
 6482 instruct cmovIIu_reg(cmpOpU cmp, flagsRegU icc, iRegI dst, iRegI src) %{
 6483   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6484   ins_cost(150);
 6485   size(4);
 6486   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6487   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6488   ins_pipe(ialu_reg);
 6489 %}
 6490 
 6491 instruct cmovIIu_imm(cmpOpU cmp, flagsRegU icc, iRegI dst, immI11 src) %{
 6492   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6493   ins_cost(140);
 6494   size(4);
 6495   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6496   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6497   ins_pipe(ialu_imm);
 6498 %}
 6499 
 6500 instruct cmovIF_reg(cmpOpF cmp, flagsRegF fcc, iRegI dst, iRegI src) %{
 6501   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6502   ins_cost(150);
 6503   size(4);
 6504   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6505   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6506   ins_pipe(ialu_reg);
 6507 %}
 6508 
 6509 instruct cmovIF_imm(cmpOpF cmp, flagsRegF fcc, iRegI dst, immI11 src) %{
 6510   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6511   ins_cost(140);
 6512   size(4);
 6513   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6514   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6515   ins_pipe(ialu_imm);
 6516 %}
 6517 
 6518 // Conditional move for RegN. Only cmov(reg,reg).
 6519 instruct cmovNP_reg(cmpOpP cmp, flagsRegP pcc, iRegN dst, iRegN src) %{
 6520   match(Set dst (CMoveN (Binary cmp pcc) (Binary dst src)));
 6521   ins_cost(150);
 6522   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6523   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6524   ins_pipe(ialu_reg);
 6525 %}
 6526 
 6527 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6528 instruct cmovNI_reg(cmpOp cmp, flagsReg icc, iRegN dst, iRegN src) %{
 6529   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6530   ins_cost(150);
 6531   size(4);
 6532   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6533   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6534   ins_pipe(ialu_reg);
 6535 %}
 6536 
 6537 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6538 instruct cmovNIu_reg(cmpOpU cmp, flagsRegU icc, iRegN dst, iRegN src) %{
 6539   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6540   ins_cost(150);
 6541   size(4);
 6542   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6543   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6544   ins_pipe(ialu_reg);
 6545 %}
 6546 
 6547 instruct cmovNF_reg(cmpOpF cmp, flagsRegF fcc, iRegN dst, iRegN src) %{
 6548   match(Set dst (CMoveN (Binary cmp fcc) (Binary dst src)));
 6549   ins_cost(150);
 6550   size(4);
 6551   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6552   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6553   ins_pipe(ialu_reg);
 6554 %}
 6555 
 6556 // Conditional move
 6557 instruct cmovPP_reg(cmpOpP cmp, flagsRegP pcc, iRegP dst, iRegP src) %{
 6558   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6559   ins_cost(150);
 6560   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6561   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6562   ins_pipe(ialu_reg);
 6563 %}
 6564 
 6565 instruct cmovPP_imm(cmpOpP cmp, flagsRegP pcc, iRegP dst, immP0 src) %{
 6566   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6567   ins_cost(140);
 6568   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6569   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6570   ins_pipe(ialu_imm);
 6571 %}
 6572 
 6573 // This instruction also works with CmpN so we don&#39;t need cmovPN_reg.
 6574 instruct cmovPI_reg(cmpOp cmp, flagsReg icc, iRegP dst, iRegP src) %{
 6575   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6576   ins_cost(150);
 6577 
 6578   size(4);
 6579   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6580   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6581   ins_pipe(ialu_reg);
 6582 %}
 6583 
 6584 instruct cmovPIu_reg(cmpOpU cmp, flagsRegU icc, iRegP dst, iRegP src) %{
 6585   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6586   ins_cost(150);
 6587 
 6588   size(4);
 6589   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6590   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6591   ins_pipe(ialu_reg);
 6592 %}
 6593 
 6594 instruct cmovPI_imm(cmpOp cmp, flagsReg icc, iRegP dst, immP0 src) %{
 6595   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6596   ins_cost(140);
 6597 
 6598   size(4);
 6599   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6600   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6601   ins_pipe(ialu_imm);
 6602 %}
 6603 
 6604 instruct cmovPIu_imm(cmpOpU cmp, flagsRegU icc, iRegP dst, immP0 src) %{
 6605   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6606   ins_cost(140);
 6607 
 6608   size(4);
 6609   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6610   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6611   ins_pipe(ialu_imm);
 6612 %}
 6613 
 6614 instruct cmovPF_reg(cmpOpF cmp, flagsRegF fcc, iRegP dst, iRegP src) %{
 6615   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6616   ins_cost(150);
 6617   size(4);
 6618   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6619   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6620   ins_pipe(ialu_imm);
 6621 %}
 6622 
 6623 instruct cmovPF_imm(cmpOpF cmp, flagsRegF fcc, iRegP dst, immP0 src) %{
 6624   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6625   ins_cost(140);
 6626   size(4);
 6627   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6628   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6629   ins_pipe(ialu_imm);
 6630 %}
 6631 
 6632 // Conditional move
 6633 instruct cmovFP_reg(cmpOpP cmp, flagsRegP pcc, regF dst, regF src) %{
 6634   match(Set dst (CMoveF (Binary cmp pcc) (Binary dst src)));
 6635   ins_cost(150);
 6636   opcode(0x101);
 6637   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6638   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6639   ins_pipe(int_conditional_float_move);
 6640 %}
 6641 
 6642 instruct cmovFI_reg(cmpOp cmp, flagsReg icc, regF dst, regF src) %{
 6643   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6644   ins_cost(150);
 6645 
 6646   size(4);
 6647   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6648   opcode(0x101);
 6649   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6650   ins_pipe(int_conditional_float_move);
 6651 %}
 6652 
 6653 instruct cmovFIu_reg(cmpOpU cmp, flagsRegU icc, regF dst, regF src) %{
 6654   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6655   ins_cost(150);
 6656 
 6657   size(4);
 6658   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6659   opcode(0x101);
 6660   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6661   ins_pipe(int_conditional_float_move);
 6662 %}
 6663 
 6664 // Conditional move,
 6665 instruct cmovFF_reg(cmpOpF cmp, flagsRegF fcc, regF dst, regF src) %{
 6666   match(Set dst (CMoveF (Binary cmp fcc) (Binary dst src)));
 6667   ins_cost(150);
 6668   size(4);
 6669   format %{ &quot;FMOVF$cmp $fcc,$src,$dst&quot; %}
 6670   opcode(0x1);
 6671   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6672   ins_pipe(int_conditional_double_move);
 6673 %}
 6674 
 6675 // Conditional move
 6676 instruct cmovDP_reg(cmpOpP cmp, flagsRegP pcc, regD dst, regD src) %{
 6677   match(Set dst (CMoveD (Binary cmp pcc) (Binary dst src)));
 6678   ins_cost(150);
 6679   size(4);
 6680   opcode(0x102);
 6681   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6682   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6683   ins_pipe(int_conditional_double_move);
 6684 %}
 6685 
 6686 instruct cmovDI_reg(cmpOp cmp, flagsReg icc, regD dst, regD src) %{
 6687   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6688   ins_cost(150);
 6689 
 6690   size(4);
 6691   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6692   opcode(0x102);
 6693   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6694   ins_pipe(int_conditional_double_move);
 6695 %}
 6696 
 6697 instruct cmovDIu_reg(cmpOpU cmp, flagsRegU icc, regD dst, regD src) %{
 6698   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6699   ins_cost(150);
 6700 
 6701   size(4);
 6702   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6703   opcode(0x102);
 6704   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6705   ins_pipe(int_conditional_double_move);
 6706 %}
 6707 
 6708 // Conditional move,
 6709 instruct cmovDF_reg(cmpOpF cmp, flagsRegF fcc, regD dst, regD src) %{
 6710   match(Set dst (CMoveD (Binary cmp fcc) (Binary dst src)));
 6711   ins_cost(150);
 6712   size(4);
 6713   format %{ &quot;FMOVD$cmp $fcc,$src,$dst&quot; %}
 6714   opcode(0x2);
 6715   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6716   ins_pipe(int_conditional_double_move);
 6717 %}
 6718 
 6719 // Conditional move
 6720 instruct cmovLP_reg(cmpOpP cmp, flagsRegP pcc, iRegL dst, iRegL src) %{
 6721   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6722   ins_cost(150);
 6723   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6724   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6725   ins_pipe(ialu_reg);
 6726 %}
 6727 
 6728 instruct cmovLP_imm(cmpOpP cmp, flagsRegP pcc, iRegL dst, immI11 src) %{
 6729   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6730   ins_cost(140);
 6731   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6732   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6733   ins_pipe(ialu_imm);
 6734 %}
 6735 
 6736 instruct cmovLI_reg(cmpOp cmp, flagsReg icc, iRegL dst, iRegL src) %{
 6737   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6738   ins_cost(150);
 6739 
 6740   size(4);
 6741   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6742   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6743   ins_pipe(ialu_reg);
 6744 %}
 6745 
 6746 
 6747 instruct cmovLIu_reg(cmpOpU cmp, flagsRegU icc, iRegL dst, iRegL src) %{
 6748   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6749   ins_cost(150);
 6750 
 6751   size(4);
 6752   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6753   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6754   ins_pipe(ialu_reg);
 6755 %}
 6756 
 6757 
 6758 instruct cmovLF_reg(cmpOpF cmp, flagsRegF fcc, iRegL dst, iRegL src) %{
 6759   match(Set dst (CMoveL (Binary cmp fcc) (Binary dst src)));
 6760   ins_cost(150);
 6761 
 6762   size(4);
 6763   format %{ &quot;MOV$cmp  $fcc,$src,$dst\t! long&quot; %}
 6764   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6765   ins_pipe(ialu_reg);
 6766 %}
 6767 
 6768 
 6769 
 6770 //----------OS and Locking Instructions----------------------------------------
 6771 
 6772 // This name is KNOWN by the ADLC and cannot be changed.
 6773 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 6774 // for this guy.
 6775 instruct tlsLoadP(g2RegP dst) %{
 6776   match(Set dst (ThreadLocal));
 6777 
 6778   size(0);
 6779   ins_cost(0);
 6780   format %{ &quot;# TLS is in G2&quot; %}
 6781   ins_encode( /*empty encoding*/ );
 6782   ins_pipe(ialu_none);
 6783 %}
 6784 
 6785 instruct checkCastPP( iRegP dst ) %{
 6786   match(Set dst (CheckCastPP dst));
 6787 
 6788   size(0);
 6789   format %{ &quot;# checkcastPP of $dst&quot; %}
 6790   ins_encode( /*empty encoding*/ );
 6791   ins_pipe(empty);
 6792 %}
 6793 
 6794 
 6795 instruct castPP( iRegP dst ) %{
 6796   match(Set dst (CastPP dst));
 6797   format %{ &quot;# castPP of $dst&quot; %}
 6798   ins_encode( /*empty encoding*/ );
 6799   ins_pipe(empty);
 6800 %}
 6801 
 6802 instruct castII( iRegI dst ) %{
 6803   match(Set dst (CastII dst));
 6804   format %{ &quot;# castII of $dst&quot; %}
 6805   ins_encode( /*empty encoding*/ );
 6806   ins_cost(0);
 6807   ins_pipe(empty);
 6808 %}
 6809 
 6810 //----------Arithmetic Instructions--------------------------------------------
 6811 // Addition Instructions
 6812 // Register Addition
 6813 instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6814   match(Set dst (AddI src1 src2));
 6815 
 6816   size(4);
 6817   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6818   ins_encode %{
 6819     __ add($src1$$Register, $src2$$Register, $dst$$Register);
 6820   %}
 6821   ins_pipe(ialu_reg_reg);
 6822 %}
 6823 
 6824 // Immediate Addition
 6825 instruct addI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 6826   match(Set dst (AddI src1 src2));
 6827 
 6828   size(4);
 6829   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6830   opcode(Assembler::add_op3, Assembler::arith_op);
 6831   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6832   ins_pipe(ialu_reg_imm);
 6833 %}
 6834 
 6835 // Pointer Register Addition
 6836 instruct addP_reg_reg(iRegP dst, iRegP src1, iRegX src2) %{
 6837   match(Set dst (AddP src1 src2));
 6838 
 6839   size(4);
 6840   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6841   opcode(Assembler::add_op3, Assembler::arith_op);
 6842   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6843   ins_pipe(ialu_reg_reg);
 6844 %}
 6845 
 6846 // Pointer Immediate Addition
 6847 instruct addP_reg_imm13(iRegP dst, iRegP src1, immX13 src2) %{
 6848   match(Set dst (AddP src1 src2));
 6849 
 6850   size(4);
 6851   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6852   opcode(Assembler::add_op3, Assembler::arith_op);
 6853   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6854   ins_pipe(ialu_reg_imm);
 6855 %}
 6856 
 6857 // Long Addition
 6858 instruct addL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6859   match(Set dst (AddL src1 src2));
 6860 
 6861   size(4);
 6862   format %{ &quot;ADD    $src1,$src2,$dst\t! long&quot; %}
 6863   opcode(Assembler::add_op3, Assembler::arith_op);
 6864   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6865   ins_pipe(ialu_reg_reg);
 6866 %}
 6867 
 6868 instruct addL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 6869   match(Set dst (AddL src1 con));
 6870 
 6871   size(4);
 6872   format %{ &quot;ADD    $src1,$con,$dst&quot; %}
 6873   opcode(Assembler::add_op3, Assembler::arith_op);
 6874   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 6875   ins_pipe(ialu_reg_imm);
 6876 %}
 6877 
 6878 //----------Conditional_store--------------------------------------------------
 6879 // Conditional-store of the updated heap-top.
 6880 // Used during allocation of the shared heap.
 6881 // Sets flags (EQ) on success.  Implemented with a CASA on Sparc.
 6882 
 6883 // LoadP-locked.  Same as a regular pointer load when used with a compare-swap
 6884 instruct loadPLocked(iRegP dst, memory mem) %{
 6885   match(Set dst (LoadPLocked mem));
 6886   ins_cost(MEMORY_REF_COST);
 6887 
 6888   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 6889   opcode(Assembler::ldx_op3, 0, REGP_OP);
 6890   ins_encode( form3_mem_reg( mem, dst ) );
 6891   ins_pipe(iload_mem);
 6892 %}
 6893 
 6894 instruct storePConditional( iRegP heap_top_ptr, iRegP oldval, g3RegP newval, flagsRegP pcc ) %{
 6895   match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));
 6896   effect( KILL newval );
 6897   format %{ &quot;CASA   [$heap_top_ptr],$oldval,R_G3\t! If $oldval==[$heap_top_ptr] Then store R_G3 into [$heap_top_ptr], set R_G3=[$heap_top_ptr] in any case\n\t&quot;
 6898             &quot;CMP    R_G3,$oldval\t\t! See if we made progress&quot;  %}
 6899   ins_encode( enc_cas(heap_top_ptr,oldval,newval) );
 6900   ins_pipe( long_memory_op );
 6901 %}
 6902 
 6903 // Conditional-store of an int value.
 6904 instruct storeIConditional( iRegP mem_ptr, iRegI oldval, g3RegI newval, flagsReg icc ) %{
 6905   match(Set icc (StoreIConditional mem_ptr (Binary oldval newval)));
 6906   effect( KILL newval );
 6907   format %{ &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6908             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6909   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6910   ins_pipe( long_memory_op );
 6911 %}
 6912 
 6913 // Conditional-store of a long value.
 6914 instruct storeLConditional( iRegP mem_ptr, iRegL oldval, g3RegL newval, flagsRegL xcc ) %{
 6915   match(Set xcc (StoreLConditional mem_ptr (Binary oldval newval)));
 6916   effect( KILL newval );
 6917   format %{ &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6918             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6919   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6920   ins_pipe( long_memory_op );
 6921 %}
 6922 
 6923 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 6924 
 6925 instruct compareAndSwapL_bool(iRegP mem_ptr, iRegL oldval, iRegL newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6926   predicate(VM_Version::supports_cx8());
 6927   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 6928   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 6929   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6930   format %{
 6931             &quot;MOV    $newval,O7\n\t&quot;
 6932             &quot;CASXA  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6933             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6934             &quot;MOV    1,$res\n\t&quot;
 6935             &quot;MOVne  xcc,R_G0,$res&quot;
 6936   %}
 6937   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6938               enc_lflags_ne_to_boolean(res) );
 6939   ins_pipe( long_memory_op );
 6940 %}
 6941 
 6942 
 6943 instruct compareAndSwapI_bool(iRegP mem_ptr, iRegI oldval, iRegI newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6944   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 6945   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 6946   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6947   format %{
 6948             &quot;MOV    $newval,O7\n\t&quot;
 6949             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6950             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6951             &quot;MOV    1,$res\n\t&quot;
 6952             &quot;MOVne  icc,R_G0,$res&quot;
 6953   %}
 6954   ins_encode( enc_casi(mem_ptr, oldval, newval),
 6955               enc_iflags_ne_to_boolean(res) );
 6956   ins_pipe( long_memory_op );
 6957 %}
 6958 
 6959 instruct compareAndSwapP_bool(iRegP mem_ptr, iRegP oldval, iRegP newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6960   predicate(VM_Version::supports_cx8());
 6961   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 6962   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 6963   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6964   format %{
 6965             &quot;MOV    $newval,O7\n\t&quot;
 6966             &quot;CASA_PTR  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6967             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6968             &quot;MOV    1,$res\n\t&quot;
 6969             &quot;MOVne  xcc,R_G0,$res&quot;
 6970   %}
 6971   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6972               enc_lflags_ne_to_boolean(res) );
 6973   ins_pipe( long_memory_op );
 6974 %}
 6975 
 6976 instruct compareAndSwapN_bool(iRegP mem_ptr, iRegN oldval, iRegN newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6977   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 6978   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 6979   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6980   format %{
 6981             &quot;MOV    $newval,O7\n\t&quot;
 6982             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6983             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6984             &quot;MOV    1,$res\n\t&quot;
 6985             &quot;MOVne  icc,R_G0,$res&quot;
 6986   %}
 6987   ins_encode( enc_casi(mem_ptr, oldval, newval),
 6988               enc_iflags_ne_to_boolean(res) );
 6989   ins_pipe( long_memory_op );
 6990 %}
 6991 
 6992 instruct compareAndExchangeI(iRegP mem_ptr, iRegI oldval, iRegI newval)
 6993 %{
 6994   match(Set newval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 6995   effect( USE mem_ptr );
 6996 
 6997   format %{
 6998             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 6999   %}
 7000   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7001   ins_pipe( long_memory_op );
 7002 %}
 7003 
 7004 instruct compareAndExchangeL(iRegP mem_ptr, iRegL oldval, iRegL newval)
 7005 %{
 7006   match(Set newval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7007   effect( USE mem_ptr );
 7008 
 7009   format %{
 7010             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7011   %}
 7012   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7013   ins_pipe( long_memory_op );
 7014 %}
 7015 
 7016 instruct compareAndExchangeP(iRegP mem_ptr, iRegP oldval, iRegP newval)
 7017 %{
 7018   match(Set newval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7019   effect( USE mem_ptr );
 7020 
 7021   format %{
 7022             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7023   %}
 7024   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7025   ins_pipe( long_memory_op );
 7026 %}
 7027 
 7028 instruct compareAndExchangeN(iRegP mem_ptr, iRegN oldval, iRegN newval)
 7029 %{
 7030   match(Set newval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7031   effect( USE mem_ptr );
 7032 
 7033   format %{
 7034             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7035   %}
 7036   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7037   ins_pipe( long_memory_op );
 7038 %}
 7039 
 7040 instruct xchgI( memory mem, iRegI newval) %{
 7041   match(Set newval (GetAndSetI mem newval));
 7042   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7043   size(4);
 7044   ins_encode %{
 7045     __ swap($mem$$Address, $newval$$Register);
 7046   %}
 7047   ins_pipe( long_memory_op );
 7048 %}
 7049 
 7050 
 7051 instruct xchgN( memory mem, iRegN newval) %{
 7052   match(Set newval (GetAndSetN mem newval));
 7053   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7054   size(4);
 7055   ins_encode %{
 7056     __ swap($mem$$Address, $newval$$Register);
 7057   %}
 7058   ins_pipe( long_memory_op );
 7059 %}
 7060 
 7061 //---------------------
 7062 // Subtraction Instructions
 7063 // Register Subtraction
 7064 instruct subI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7065   match(Set dst (SubI src1 src2));
 7066 
 7067   size(4);
 7068   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7069   opcode(Assembler::sub_op3, Assembler::arith_op);
 7070   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7071   ins_pipe(ialu_reg_reg);
 7072 %}
 7073 
 7074 // Immediate Subtraction
 7075 instruct subI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7076   match(Set dst (SubI src1 src2));
 7077 
 7078   size(4);
 7079   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7080   opcode(Assembler::sub_op3, Assembler::arith_op);
 7081   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7082   ins_pipe(ialu_reg_imm);
 7083 %}
 7084 
 7085 instruct subI_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 7086   match(Set dst (SubI zero src2));
 7087 
 7088   size(4);
 7089   format %{ &quot;NEG    $src2,$dst&quot; %}
 7090   opcode(Assembler::sub_op3, Assembler::arith_op);
 7091   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7092   ins_pipe(ialu_zero_reg);
 7093 %}
 7094 
 7095 // Long subtraction
 7096 instruct subL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7097   match(Set dst (SubL src1 src2));
 7098 
 7099   size(4);
 7100   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7101   opcode(Assembler::sub_op3, Assembler::arith_op);
 7102   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7103   ins_pipe(ialu_reg_reg);
 7104 %}
 7105 
 7106 // Immediate Subtraction
 7107 instruct subL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7108   match(Set dst (SubL src1 con));
 7109 
 7110   size(4);
 7111   format %{ &quot;SUB    $src1,$con,$dst\t! long&quot; %}
 7112   opcode(Assembler::sub_op3, Assembler::arith_op);
 7113   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7114   ins_pipe(ialu_reg_imm);
 7115 %}
 7116 
 7117 // Long negation
 7118 instruct negL_reg_reg(iRegL dst, immL0 zero, iRegL src2) %{
 7119   match(Set dst (SubL zero src2));
 7120 
 7121   size(4);
 7122   format %{ &quot;NEG    $src2,$dst\t! long&quot; %}
 7123   opcode(Assembler::sub_op3, Assembler::arith_op);
 7124   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7125   ins_pipe(ialu_zero_reg);
 7126 %}
 7127 
 7128 // Multiplication Instructions
 7129 // Integer Multiplication
 7130 // Register Multiplication
 7131 instruct mulI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7132   match(Set dst (MulI src1 src2));
 7133 
 7134   size(4);
 7135   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7136   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7137   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7138   ins_pipe(imul_reg_reg);
 7139 %}
 7140 
 7141 // Immediate Multiplication
 7142 instruct mulI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7143   match(Set dst (MulI src1 src2));
 7144 
 7145   size(4);
 7146   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7147   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7148   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7149   ins_pipe(imul_reg_imm);
 7150 %}
 7151 
 7152 instruct mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7153   match(Set dst (MulL src1 src2));
 7154   ins_cost(DEFAULT_COST * 5);
 7155   size(4);
 7156   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7157   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7158   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7159   ins_pipe(mulL_reg_reg);
 7160 %}
 7161 
 7162 // Immediate Multiplication
 7163 instruct mulL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7164   match(Set dst (MulL src1 src2));
 7165   ins_cost(DEFAULT_COST * 5);
 7166   size(4);
 7167   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7168   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7169   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7170   ins_pipe(mulL_reg_imm);
 7171 %}
 7172 
 7173 // Integer Division
 7174 // Register Division
 7175 instruct divI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2) %{
 7176   match(Set dst (DivI src1 src2));
 7177   ins_cost((2+71)*DEFAULT_COST);
 7178 
 7179   format %{ &quot;SRA     $src2,0,$src2\n\t&quot;
 7180             &quot;SRA     $src1,0,$src1\n\t&quot;
 7181             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7182   ins_encode( idiv_reg( src1, src2, dst ) );
 7183   ins_pipe(sdiv_reg_reg);
 7184 %}
 7185 
 7186 // Immediate Division
 7187 instruct divI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2) %{
 7188   match(Set dst (DivI src1 src2));
 7189   ins_cost((2+71)*DEFAULT_COST);
 7190 
 7191   format %{ &quot;SRA     $src1,0,$src1\n\t&quot;
 7192             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7193   ins_encode( idiv_imm( src1, src2, dst ) );
 7194   ins_pipe(sdiv_reg_imm);
 7195 %}
 7196 
 7197 //----------Div-By-10-Expansion------------------------------------------------
 7198 // Extract hi bits of a 32x32-&gt;64 bit multiply.
 7199 // Expand rule only, not matched
 7200 instruct mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2 ) %{
 7201   effect( DEF dst, USE src1, USE src2 );
 7202   format %{ &quot;MULX   $src1,$src2,$dst\t! Used in div-by-10\n\t&quot;
 7203             &quot;SRLX   $dst,#32,$dst\t\t! Extract only hi word of result&quot; %}
 7204   ins_encode( enc_mul_hi(dst,src1,src2));
 7205   ins_pipe(sdiv_reg_reg);
 7206 %}
 7207 
 7208 // Magic constant, reciprocal of 10
 7209 instruct loadConI_x66666667(iRegIsafe dst) %{
 7210   effect( DEF dst );
 7211 
 7212   size(8);
 7213   format %{ &quot;SET    0x66666667,$dst\t! Used in div-by-10&quot; %}
 7214   ins_encode( Set32(0x66666667, dst) );
 7215   ins_pipe(ialu_hi_lo_reg);
 7216 %}
 7217 
 7218 // Register Shift Right Arithmetic Long by 32-63
 7219 instruct sra_31( iRegI dst, iRegI src ) %{
 7220   effect( DEF dst, USE src );
 7221   format %{ &quot;SRA    $src,31,$dst\t! Used in div-by-10&quot; %}
 7222   ins_encode( form3_rs1_rd_copysign_hi(src,dst) );
 7223   ins_pipe(ialu_reg_reg);
 7224 %}
 7225 
 7226 // Arithmetic Shift Right by 8-bit immediate
 7227 instruct sra_reg_2( iRegI dst, iRegI src ) %{
 7228   effect( DEF dst, USE src );
 7229   format %{ &quot;SRA    $src,2,$dst\t! Used in div-by-10&quot; %}
 7230   opcode(Assembler::sra_op3, Assembler::arith_op);
 7231   ins_encode( form3_rs1_simm13_rd( src, 0x2, dst ) );
 7232   ins_pipe(ialu_reg_imm);
 7233 %}
 7234 
 7235 // Integer DIV with 10
 7236 instruct divI_10( iRegI dst, iRegIsafe src, immI10 div ) %{
 7237   match(Set dst (DivI src div));
 7238   ins_cost((6+6)*DEFAULT_COST);
 7239   expand %{
 7240     iRegIsafe tmp1;               // Killed temps;
 7241     iRegIsafe tmp2;               // Killed temps;
 7242     iRegI tmp3;                   // Killed temps;
 7243     iRegI tmp4;                   // Killed temps;
 7244     loadConI_x66666667( tmp1 );   // SET  0x66666667 -&gt; tmp1
 7245     mul_hi( tmp2, src, tmp1 );    // MUL  hibits(src * tmp1) -&gt; tmp2
 7246     sra_31( tmp3, src );          // SRA  src,31 -&gt; tmp3
 7247     sra_reg_2( tmp4, tmp2 );      // SRA  tmp2,2 -&gt; tmp4
 7248     subI_reg_reg( dst,tmp4,tmp3); // SUB  tmp4 - tmp3 -&gt; dst
 7249   %}
 7250 %}
 7251 
 7252 // Register Long Division
 7253 instruct divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7254   match(Set dst (DivL src1 src2));
 7255   ins_cost(DEFAULT_COST*71);
 7256   size(4);
 7257   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7258   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7259   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7260   ins_pipe(divL_reg_reg);
 7261 %}
 7262 
 7263 // Register Long Division
 7264 instruct divL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7265   match(Set dst (DivL src1 src2));
 7266   ins_cost(DEFAULT_COST*71);
 7267   size(4);
 7268   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7269   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7270   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7271   ins_pipe(divL_reg_imm);
 7272 %}
 7273 
 7274 // Integer Remainder
 7275 // Register Remainder
 7276 instruct modI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2, o7RegP temp, flagsReg ccr ) %{
 7277   match(Set dst (ModI src1 src2));
 7278   effect( KILL ccr, KILL temp);
 7279 
 7280   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7281   ins_encode( irem_reg(src1, src2, dst, temp) );
 7282   ins_pipe(sdiv_reg_reg);
 7283 %}
 7284 
 7285 // Immediate Remainder
 7286 instruct modI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2, o7RegP temp, flagsReg ccr ) %{
 7287   match(Set dst (ModI src1 src2));
 7288   effect( KILL ccr, KILL temp);
 7289 
 7290   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7291   ins_encode( irem_imm(src1, src2, dst, temp) );
 7292   ins_pipe(sdiv_reg_imm);
 7293 %}
 7294 
 7295 // Register Long Remainder
 7296 instruct divL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7297   effect(DEF dst, USE src1, USE src2);
 7298   size(4);
 7299   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7300   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7301   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7302   ins_pipe(divL_reg_reg);
 7303 %}
 7304 
 7305 // Register Long Division
 7306 instruct divL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7307   effect(DEF dst, USE src1, USE src2);
 7308   size(4);
 7309   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7310   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7311   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7312   ins_pipe(divL_reg_imm);
 7313 %}
 7314 
 7315 instruct mulL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7316   effect(DEF dst, USE src1, USE src2);
 7317   size(4);
 7318   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7319   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7320   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7321   ins_pipe(mulL_reg_reg);
 7322 %}
 7323 
 7324 // Immediate Multiplication
 7325 instruct mulL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7326   effect(DEF dst, USE src1, USE src2);
 7327   size(4);
 7328   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7329   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7330   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7331   ins_pipe(mulL_reg_imm);
 7332 %}
 7333 
 7334 instruct subL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7335   effect(DEF dst, USE src1, USE src2);
 7336   size(4);
 7337   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7338   opcode(Assembler::sub_op3, Assembler::arith_op);
 7339   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7340   ins_pipe(ialu_reg_reg);
 7341 %}
 7342 
 7343 instruct subL_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 7344   effect(DEF dst, USE src1, USE src2);
 7345   size(4);
 7346   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7347   opcode(Assembler::sub_op3, Assembler::arith_op);
 7348   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7349   ins_pipe(ialu_reg_reg);
 7350 %}
 7351 
 7352 // Register Long Remainder
 7353 instruct modL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7354   match(Set dst (ModL src1 src2));
 7355   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7356   expand %{
 7357     iRegL tmp1;
 7358     iRegL tmp2;
 7359     divL_reg_reg_1(tmp1, src1, src2);
 7360     mulL_reg_reg_1(tmp2, tmp1, src2);
 7361     subL_reg_reg_1(dst,  src1, tmp2);
 7362   %}
 7363 %}
 7364 
 7365 // Register Long Remainder
 7366 instruct modL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7367   match(Set dst (ModL src1 src2));
 7368   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7369   expand %{
 7370     iRegL tmp1;
 7371     iRegL tmp2;
 7372     divL_reg_imm13_1(tmp1, src1, src2);
 7373     mulL_reg_imm13_1(tmp2, tmp1, src2);
 7374     subL_reg_reg_2  (dst,  src1, tmp2);
 7375   %}
 7376 %}
 7377 
 7378 // Integer Shift Instructions
 7379 // Register Shift Left
 7380 instruct shlI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7381   match(Set dst (LShiftI src1 src2));
 7382 
 7383   size(4);
 7384   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7385   opcode(Assembler::sll_op3, Assembler::arith_op);
 7386   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7387   ins_pipe(ialu_reg_reg);
 7388 %}
 7389 
 7390 // Register Shift Left Immediate
 7391 instruct shlI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7392   match(Set dst (LShiftI src1 src2));
 7393 
 7394   size(4);
 7395   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7396   opcode(Assembler::sll_op3, Assembler::arith_op);
 7397   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7398   ins_pipe(ialu_reg_imm);
 7399 %}
 7400 
 7401 // Register Shift Left
 7402 instruct shlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7403   match(Set dst (LShiftL src1 src2));
 7404 
 7405   size(4);
 7406   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7407   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7408   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7409   ins_pipe(ialu_reg_reg);
 7410 %}
 7411 
 7412 // Register Shift Left Immediate
 7413 instruct shlL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7414   match(Set dst (LShiftL src1 src2));
 7415 
 7416   size(4);
 7417   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7418   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7419   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7420   ins_pipe(ialu_reg_imm);
 7421 %}
 7422 
 7423 // Register Arithmetic Shift Right
 7424 instruct sarI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7425   match(Set dst (RShiftI src1 src2));
 7426   size(4);
 7427   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7428   opcode(Assembler::sra_op3, Assembler::arith_op);
 7429   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7430   ins_pipe(ialu_reg_reg);
 7431 %}
 7432 
 7433 // Register Arithmetic Shift Right Immediate
 7434 instruct sarI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7435   match(Set dst (RShiftI src1 src2));
 7436 
 7437   size(4);
 7438   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7439   opcode(Assembler::sra_op3, Assembler::arith_op);
 7440   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7441   ins_pipe(ialu_reg_imm);
 7442 %}
 7443 
 7444 // Register Shift Right Arithmatic Long
 7445 instruct sarL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7446   match(Set dst (RShiftL src1 src2));
 7447 
 7448   size(4);
 7449   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7450   opcode(Assembler::srax_op3, Assembler::arith_op);
 7451   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7452   ins_pipe(ialu_reg_reg);
 7453 %}
 7454 
 7455 // Register Shift Left Immediate
 7456 instruct sarL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7457   match(Set dst (RShiftL src1 src2));
 7458 
 7459   size(4);
 7460   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7461   opcode(Assembler::srax_op3, Assembler::arith_op);
 7462   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7463   ins_pipe(ialu_reg_imm);
 7464 %}
 7465 
 7466 // Register Shift Right
 7467 instruct shrI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7468   match(Set dst (URShiftI src1 src2));
 7469 
 7470   size(4);
 7471   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7472   opcode(Assembler::srl_op3, Assembler::arith_op);
 7473   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7474   ins_pipe(ialu_reg_reg);
 7475 %}
 7476 
 7477 // Register Shift Right Immediate
 7478 instruct shrI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7479   match(Set dst (URShiftI src1 src2));
 7480 
 7481   size(4);
 7482   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7483   opcode(Assembler::srl_op3, Assembler::arith_op);
 7484   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7485   ins_pipe(ialu_reg_imm);
 7486 %}
 7487 
 7488 // Register Shift Right
 7489 instruct shrL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7490   match(Set dst (URShiftL src1 src2));
 7491 
 7492   size(4);
 7493   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7494   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7495   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7496   ins_pipe(ialu_reg_reg);
 7497 %}
 7498 
 7499 // Register Shift Right Immediate
 7500 instruct shrL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7501   match(Set dst (URShiftL src1 src2));
 7502 
 7503   size(4);
 7504   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7505   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7506   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7507   ins_pipe(ialu_reg_imm);
 7508 %}
 7509 
 7510 // Register Shift Right Immediate with a CastP2X
 7511 instruct shrP_reg_imm6(iRegL dst, iRegP src1, immU6 src2) %{
 7512   match(Set dst (URShiftL (CastP2X src1) src2));
 7513   size(4);
 7514   format %{ &quot;SRLX   $src1,$src2,$dst\t! Cast ptr $src1 to long and shift&quot; %}
 7515   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7516   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7517   ins_pipe(ialu_reg_imm);
 7518 %}
 7519 
 7520 
 7521 //----------Floating Point Arithmetic Instructions-----------------------------
 7522 
 7523 //  Add float single precision
 7524 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 7525   match(Set dst (AddF src1 src2));
 7526 
 7527   size(4);
 7528   format %{ &quot;FADDS  $src1,$src2,$dst&quot; %}
 7529   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fadds_opf);
 7530   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7531   ins_pipe(faddF_reg_reg);
 7532 %}
 7533 
 7534 //  Add float double precision
 7535 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 7536   match(Set dst (AddD src1 src2));
 7537 
 7538   size(4);
 7539   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 7540   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 7541   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7542   ins_pipe(faddD_reg_reg);
 7543 %}
 7544 
 7545 //  Sub float single precision
 7546 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 7547   match(Set dst (SubF src1 src2));
 7548 
 7549   size(4);
 7550   format %{ &quot;FSUBS  $src1,$src2,$dst&quot; %}
 7551   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubs_opf);
 7552   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7553   ins_pipe(faddF_reg_reg);
 7554 %}
 7555 
 7556 //  Sub float double precision
 7557 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 7558   match(Set dst (SubD src1 src2));
 7559 
 7560   size(4);
 7561   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 7562   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 7563   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7564   ins_pipe(faddD_reg_reg);
 7565 %}
 7566 
 7567 //  Mul float single precision
 7568 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 7569   match(Set dst (MulF src1 src2));
 7570 
 7571   size(4);
 7572   format %{ &quot;FMULS  $src1,$src2,$dst&quot; %}
 7573   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuls_opf);
 7574   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7575   ins_pipe(fmulF_reg_reg);
 7576 %}
 7577 
 7578 //  Mul float double precision
 7579 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 7580   match(Set dst (MulD src1 src2));
 7581 
 7582   size(4);
 7583   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 7584   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 7585   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7586   ins_pipe(fmulD_reg_reg);
 7587 %}
 7588 
 7589 //  Div float single precision
 7590 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 7591   match(Set dst (DivF src1 src2));
 7592 
 7593   size(4);
 7594   format %{ &quot;FDIVS  $src1,$src2,$dst&quot; %}
 7595   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivs_opf);
 7596   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7597   ins_pipe(fdivF_reg_reg);
 7598 %}
 7599 
 7600 //  Div float double precision
 7601 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 7602   match(Set dst (DivD src1 src2));
 7603 
 7604   size(4);
 7605   format %{ &quot;FDIVD  $src1,$src2,$dst&quot; %}
 7606   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivd_opf);
 7607   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7608   ins_pipe(fdivD_reg_reg);
 7609 %}
 7610 
 7611 //  Absolute float double precision
 7612 instruct absD_reg(regD dst, regD src) %{
 7613   match(Set dst (AbsD src));
 7614 
 7615   format %{ &quot;FABSd  $src,$dst&quot; %}
 7616   ins_encode(fabsd(dst, src));
 7617   ins_pipe(faddD_reg);
 7618 %}
 7619 
 7620 //  Absolute float single precision
 7621 instruct absF_reg(regF dst, regF src) %{
 7622   match(Set dst (AbsF src));
 7623 
 7624   format %{ &quot;FABSs  $src,$dst&quot; %}
 7625   ins_encode(fabss(dst, src));
 7626   ins_pipe(faddF_reg);
 7627 %}
 7628 
 7629 instruct negF_reg(regF dst, regF src) %{
 7630   match(Set dst (NegF src));
 7631 
 7632   size(4);
 7633   format %{ &quot;FNEGs  $src,$dst&quot; %}
 7634   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fnegs_opf);
 7635   ins_encode(form3_opf_rs2F_rdF(src, dst));
 7636   ins_pipe(faddF_reg);
 7637 %}
 7638 
 7639 instruct negD_reg(regD dst, regD src) %{
 7640   match(Set dst (NegD src));
 7641 
 7642   format %{ &quot;FNEGd  $src,$dst&quot; %}
 7643   ins_encode(fnegd(dst, src));
 7644   ins_pipe(faddD_reg);
 7645 %}
 7646 
 7647 //  Sqrt float double precision
 7648 instruct sqrtF_reg_reg(regF dst, regF src) %{
 7649   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7650 
 7651   size(4);
 7652   format %{ &quot;FSQRTS $src,$dst&quot; %}
 7653   ins_encode(fsqrts(dst, src));
 7654   ins_pipe(fdivF_reg_reg);
 7655 %}
 7656 
 7657 //  Sqrt float double precision
 7658 instruct sqrtD_reg_reg(regD dst, regD src) %{
 7659   match(Set dst (SqrtD src));
 7660 
 7661   size(4);
 7662   format %{ &quot;FSQRTD $src,$dst&quot; %}
 7663   ins_encode(fsqrtd(dst, src));
 7664   ins_pipe(fdivD_reg_reg);
 7665 %}
 7666 
 7667 // Single/Double precision fused floating-point multiply-add (d = a * b + c).
 7668 instruct fmaF_regx4(regF dst, regF a, regF b, regF c) %{
 7669   predicate(UseFMA);
 7670   match(Set dst (FmaF c (Binary a b)));
 7671   format %{ &quot;fmadds $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7672   ins_encode(fmadds(dst, a, b, c));
 7673   ins_pipe(fmaF_regx4);
 7674 %}
 7675 
 7676 instruct fmaD_regx4(regD dst, regD a, regD b, regD c) %{
 7677   predicate(UseFMA);
 7678   match(Set dst (FmaD c (Binary a b)));
 7679   format %{ &quot;fmaddd $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7680   ins_encode(fmaddd(dst, a, b, c));
 7681   ins_pipe(fmaD_regx4);
 7682 %}
 7683 
 7684 // Additional patterns matching complement versions that we can map directly to
 7685 // variants of the fused multiply-add instructions.
 7686 
 7687 // Single/Double precision fused floating-point multiply-sub (d = a * b - c)
 7688 instruct fmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7689   predicate(UseFMA);
 7690   match(Set dst (FmaF (NegF c) (Binary a b)));
 7691   format %{ &quot;fmsubs $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7692   ins_encode(fmsubs(dst, a, b, c));
 7693   ins_pipe(fmaF_regx4);
 7694 %}
 7695 
 7696 instruct fmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7697   predicate(UseFMA);
 7698   match(Set dst (FmaD (NegD c) (Binary a b)));
 7699   format %{ &quot;fmsubd $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7700   ins_encode(fmsubd(dst, a, b, c));
 7701   ins_pipe(fmaD_regx4);
 7702 %}
 7703 
 7704 // Single/Double precision fused floating-point neg. multiply-add,
 7705 //      d = -1 * a * b - c = -(a * b + c)
 7706 instruct fnmaddF_regx4(regF dst, regF a, regF b, regF c) %{
 7707   predicate(UseFMA);
 7708   match(Set dst (FmaF (NegF c) (Binary (NegF a) b)));
 7709   match(Set dst (FmaF (NegF c) (Binary a (NegF b))));
 7710   format %{ &quot;fnmadds $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7711   ins_encode(fnmadds(dst, a, b, c));
 7712   ins_pipe(fmaF_regx4);
 7713 %}
 7714 
 7715 instruct fnmaddD_regx4(regD dst, regD a, regD b, regD c) %{
 7716   predicate(UseFMA);
 7717   match(Set dst (FmaD (NegD c) (Binary (NegD a) b)));
 7718   match(Set dst (FmaD (NegD c) (Binary a (NegD b))));
 7719   format %{ &quot;fnmaddd $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7720   ins_encode(fnmaddd(dst, a, b, c));
 7721   ins_pipe(fmaD_regx4);
 7722 %}
 7723 
 7724 // Single/Double precision fused floating-point neg. multiply-sub,
 7725 //      d = -1 * a * b + c = -(a * b - c)
 7726 instruct fnmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7727   predicate(UseFMA);
 7728   match(Set dst (FmaF c (Binary (NegF a) b)));
 7729   match(Set dst (FmaF c (Binary a (NegF b))));
 7730   format %{ &quot;fnmsubs $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7731   ins_encode(fnmsubs(dst, a, b, c));
 7732   ins_pipe(fmaF_regx4);
 7733 %}
 7734 
 7735 instruct fnmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7736   predicate(UseFMA);
 7737   match(Set dst (FmaD c (Binary (NegD a) b)));
 7738   match(Set dst (FmaD c (Binary a (NegD b))));
 7739   format %{ &quot;fnmsubd $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7740   ins_encode(fnmsubd(dst, a, b, c));
 7741   ins_pipe(fmaD_regx4);
 7742 %}
 7743 
 7744 //----------Logical Instructions-----------------------------------------------
 7745 // And Instructions
 7746 // Register And
 7747 instruct andI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7748   match(Set dst (AndI src1 src2));
 7749 
 7750   size(4);
 7751   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7752   opcode(Assembler::and_op3, Assembler::arith_op);
 7753   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7754   ins_pipe(ialu_reg_reg);
 7755 %}
 7756 
 7757 // Immediate And
 7758 instruct andI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7759   match(Set dst (AndI src1 src2));
 7760 
 7761   size(4);
 7762   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7763   opcode(Assembler::and_op3, Assembler::arith_op);
 7764   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7765   ins_pipe(ialu_reg_imm);
 7766 %}
 7767 
 7768 // Register And Long
 7769 instruct andL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7770   match(Set dst (AndL src1 src2));
 7771 
 7772   ins_cost(DEFAULT_COST);
 7773   size(4);
 7774   format %{ &quot;AND    $src1,$src2,$dst\t! long&quot; %}
 7775   opcode(Assembler::and_op3, Assembler::arith_op);
 7776   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7777   ins_pipe(ialu_reg_reg);
 7778 %}
 7779 
 7780 instruct andL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7781   match(Set dst (AndL src1 con));
 7782 
 7783   ins_cost(DEFAULT_COST);
 7784   size(4);
 7785   format %{ &quot;AND    $src1,$con,$dst\t! long&quot; %}
 7786   opcode(Assembler::and_op3, Assembler::arith_op);
 7787   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7788   ins_pipe(ialu_reg_imm);
 7789 %}
 7790 
 7791 // Or Instructions
 7792 // Register Or
 7793 instruct orI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7794   match(Set dst (OrI src1 src2));
 7795 
 7796   size(4);
 7797   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7798   opcode(Assembler::or_op3, Assembler::arith_op);
 7799   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7800   ins_pipe(ialu_reg_reg);
 7801 %}
 7802 
 7803 // Immediate Or
 7804 instruct orI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7805   match(Set dst (OrI src1 src2));
 7806 
 7807   size(4);
 7808   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7809   opcode(Assembler::or_op3, Assembler::arith_op);
 7810   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7811   ins_pipe(ialu_reg_imm);
 7812 %}
 7813 
 7814 // Register Or Long
 7815 instruct orL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7816   match(Set dst (OrL src1 src2));
 7817 
 7818   ins_cost(DEFAULT_COST);
 7819   size(4);
 7820   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7821   opcode(Assembler::or_op3, Assembler::arith_op);
 7822   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7823   ins_pipe(ialu_reg_reg);
 7824 %}
 7825 
 7826 instruct orL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7827   match(Set dst (OrL src1 con));
 7828   ins_cost(DEFAULT_COST*2);
 7829 
 7830   ins_cost(DEFAULT_COST);
 7831   size(4);
 7832   format %{ &quot;OR     $src1,$con,$dst\t! long&quot; %}
 7833   opcode(Assembler::or_op3, Assembler::arith_op);
 7834   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7835   ins_pipe(ialu_reg_imm);
 7836 %}
 7837 
 7838 instruct orL_reg_castP2X(iRegL dst, iRegL src1, sp_ptr_RegP src2) %{
 7839   match(Set dst (OrL src1 (CastP2X src2)));
 7840 
 7841   ins_cost(DEFAULT_COST);
 7842   size(4);
 7843   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7844   opcode(Assembler::or_op3, Assembler::arith_op);
 7845   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7846   ins_pipe(ialu_reg_reg);
 7847 %}
 7848 
 7849 // Xor Instructions
 7850 // Register Xor
 7851 instruct xorI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7852   match(Set dst (XorI src1 src2));
 7853 
 7854   size(4);
 7855   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7856   opcode(Assembler::xor_op3, Assembler::arith_op);
 7857   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7858   ins_pipe(ialu_reg_reg);
 7859 %}
 7860 
 7861 // Immediate Xor
 7862 instruct xorI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7863   match(Set dst (XorI src1 src2));
 7864 
 7865   size(4);
 7866   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7867   opcode(Assembler::xor_op3, Assembler::arith_op);
 7868   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7869   ins_pipe(ialu_reg_imm);
 7870 %}
 7871 
 7872 // Register Xor Long
 7873 instruct xorL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7874   match(Set dst (XorL src1 src2));
 7875 
 7876   ins_cost(DEFAULT_COST);
 7877   size(4);
 7878   format %{ &quot;XOR    $src1,$src2,$dst\t! long&quot; %}
 7879   opcode(Assembler::xor_op3, Assembler::arith_op);
 7880   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7881   ins_pipe(ialu_reg_reg);
 7882 %}
 7883 
 7884 instruct xorL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7885   match(Set dst (XorL src1 con));
 7886 
 7887   ins_cost(DEFAULT_COST);
 7888   size(4);
 7889   format %{ &quot;XOR    $src1,$con,$dst\t! long&quot; %}
 7890   opcode(Assembler::xor_op3, Assembler::arith_op);
 7891   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7892   ins_pipe(ialu_reg_imm);
 7893 %}
 7894 
 7895 //----------Convert to Boolean-------------------------------------------------
 7896 // Nice hack for 32-bit tests but doesn&#39;t work for
 7897 // 64-bit pointers.
 7898 instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{
 7899   match(Set dst (Conv2B src));
 7900   effect( KILL ccr );
 7901   ins_cost(DEFAULT_COST*2);
 7902   format %{ &quot;CMP    R_G0,$src\n\t&quot;
 7903             &quot;ADDX   R_G0,0,$dst&quot; %}
 7904   ins_encode( enc_to_bool( src, dst ) );
 7905   ins_pipe(ialu_reg_ialu);
 7906 %}
 7907 
 7908 instruct convP2B( iRegI dst, iRegP src ) %{
 7909   match(Set dst (Conv2B src));
 7910   ins_cost(DEFAULT_COST*2);
 7911   format %{ &quot;MOV    $src,$dst\n\t&quot;
 7912             &quot;MOVRNZ $src,1,$dst&quot; %}
 7913   ins_encode( form3_g0_rs2_rd_move( src, dst ), enc_convP2B( dst, src ) );
 7914   ins_pipe(ialu_clr_and_mover);
 7915 %}
 7916 
 7917 instruct cmpLTMask0( iRegI dst, iRegI src, immI0 zero, flagsReg ccr ) %{
 7918   match(Set dst (CmpLTMask src zero));
 7919   effect(KILL ccr);
 7920   size(4);
 7921   format %{ &quot;SRA    $src,#31,$dst\t# cmpLTMask0&quot; %}
 7922   ins_encode %{
 7923     __ sra($src$$Register, 31, $dst$$Register);
 7924   %}
 7925   ins_pipe(ialu_reg_imm);
 7926 %}
 7927 
 7928 instruct cmpLTMask_reg_reg( iRegI dst, iRegI p, iRegI q, flagsReg ccr ) %{
 7929   match(Set dst (CmpLTMask p q));
 7930   effect( KILL ccr );
 7931   ins_cost(DEFAULT_COST*4);
 7932   format %{ &quot;CMP    $p,$q\n\t&quot;
 7933             &quot;MOV    #0,$dst\n\t&quot;
 7934             &quot;BLT,a  .+8\n\t&quot;
 7935             &quot;MOV    #-1,$dst&quot; %}
 7936   ins_encode( enc_ltmask(p,q,dst) );
 7937   ins_pipe(ialu_reg_reg_ialu);
 7938 %}
 7939 
 7940 instruct cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp, flagsReg ccr ) %{
 7941   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 7942   effect(KILL ccr, TEMP tmp);
 7943   ins_cost(DEFAULT_COST*3);
 7944 
 7945   format %{ &quot;SUBcc  $p,$q,$p\t! p&#39; = p-q\n\t&quot;
 7946             &quot;ADD    $p,$y,$tmp\t! g3=p-q+y\n\t&quot;
 7947             &quot;MOVlt  $tmp,$p\t! p&#39; &lt; 0 ? p&#39;+y : p&#39;&quot; %}
 7948   ins_encode(enc_cadd_cmpLTMask(p, q, y, tmp));
 7949   ins_pipe(cadd_cmpltmask);
 7950 %}
 7951 
 7952 instruct and_cmpLTMask(iRegI p, iRegI q, iRegI y, flagsReg ccr) %{
 7953   match(Set p (AndI (CmpLTMask p q) y));
 7954   effect(KILL ccr);
 7955   ins_cost(DEFAULT_COST*3);
 7956 
 7957   format %{ &quot;CMP  $p,$q\n\t&quot;
 7958             &quot;MOV  $y,$p\n\t&quot;
 7959             &quot;MOVge G0,$p&quot; %}
 7960   ins_encode %{
 7961     __ cmp($p$$Register, $q$$Register);
 7962     __ mov($y$$Register, $p$$Register);
 7963     __ movcc(Assembler::greaterEqual, false, Assembler::icc, G0, $p$$Register);
 7964   %}
 7965   ins_pipe(ialu_reg_reg_ialu);
 7966 %}
 7967 
 7968 //-----------------------------------------------------------------
 7969 // Direct raw moves between float and general registers using VIS3.
 7970 
 7971 //  ins_pipe(faddF_reg);
 7972 instruct MoveF2I_reg_reg(iRegI dst, regF src) %{
 7973   predicate(UseVIS &gt;= 3);
 7974   match(Set dst (MoveF2I src));
 7975 
 7976   format %{ &quot;MOVSTOUW $src,$dst\t! MoveF2I&quot; %}
 7977   ins_encode %{
 7978     __ movstouw($src$$FloatRegister, $dst$$Register);
 7979   %}
 7980   ins_pipe(ialu_reg_reg);
 7981 %}
 7982 
 7983 instruct MoveI2F_reg_reg(regF dst, iRegI src) %{
 7984   predicate(UseVIS &gt;= 3);
 7985   match(Set dst (MoveI2F src));
 7986 
 7987   format %{ &quot;MOVWTOS $src,$dst\t! MoveI2F&quot; %}
 7988   ins_encode %{
 7989     __ movwtos($src$$Register, $dst$$FloatRegister);
 7990   %}
 7991   ins_pipe(ialu_reg_reg);
 7992 %}
 7993 
 7994 instruct MoveD2L_reg_reg(iRegL dst, regD src) %{
 7995   predicate(UseVIS &gt;= 3);
 7996   match(Set dst (MoveD2L src));
 7997 
 7998   format %{ &quot;MOVDTOX $src,$dst\t! MoveD2L&quot; %}
 7999   ins_encode %{
 8000     __ movdtox(as_DoubleFloatRegister($src$$reg), $dst$$Register);
 8001   %}
 8002   ins_pipe(ialu_reg_reg);
 8003 %}
 8004 
 8005 instruct MoveL2D_reg_reg(regD dst, iRegL src) %{
 8006   predicate(UseVIS &gt;= 3);
 8007   match(Set dst (MoveL2D src));
 8008 
 8009   format %{ &quot;MOVXTOD $src,$dst\t! MoveL2D&quot; %}
 8010   ins_encode %{
 8011     __ movxtod($src$$Register, as_DoubleFloatRegister($dst$$reg));
 8012   %}
 8013   ins_pipe(ialu_reg_reg);
 8014 %}
 8015 
 8016 
 8017 // Raw moves between float and general registers using stack.
 8018 
 8019 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8020   match(Set dst (MoveF2I src));
 8021   effect(DEF dst, USE src);
 8022   ins_cost(MEMORY_REF_COST);
 8023 
 8024   format %{ &quot;LDUW   $src,$dst\t! MoveF2I&quot; %}
 8025   opcode(Assembler::lduw_op3);
 8026   ins_encode(simple_form3_mem_reg( src, dst ) );
 8027   ins_pipe(iload_mem);
 8028 %}
 8029 
 8030 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8031   match(Set dst (MoveI2F src));
 8032   effect(DEF dst, USE src);
 8033   ins_cost(MEMORY_REF_COST);
 8034 
 8035   format %{ &quot;LDF    $src,$dst\t! MoveI2F&quot; %}
 8036   opcode(Assembler::ldf_op3);
 8037   ins_encode(simple_form3_mem_reg(src, dst));
 8038   ins_pipe(floadF_stk);
 8039 %}
 8040 
 8041 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8042   match(Set dst (MoveD2L src));
 8043   effect(DEF dst, USE src);
 8044   ins_cost(MEMORY_REF_COST);
 8045 
 8046   format %{ &quot;LDX    $src,$dst\t! MoveD2L&quot; %}
 8047   opcode(Assembler::ldx_op3);
 8048   ins_encode(simple_form3_mem_reg( src, dst ) );
 8049   ins_pipe(iload_mem);
 8050 %}
 8051 
 8052 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8053   match(Set dst (MoveL2D src));
 8054   effect(DEF dst, USE src);
 8055   ins_cost(MEMORY_REF_COST);
 8056 
 8057   format %{ &quot;LDDF   $src,$dst\t! MoveL2D&quot; %}
 8058   opcode(Assembler::lddf_op3);
 8059   ins_encode(simple_form3_mem_reg(src, dst));
 8060   ins_pipe(floadD_stk);
 8061 %}
 8062 
 8063 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
 8064   match(Set dst (MoveF2I src));
 8065   effect(DEF dst, USE src);
 8066   ins_cost(MEMORY_REF_COST);
 8067 
 8068   format %{ &quot;STF   $src,$dst\t! MoveF2I&quot; %}
 8069   opcode(Assembler::stf_op3);
 8070   ins_encode(simple_form3_mem_reg(dst, src));
 8071   ins_pipe(fstoreF_stk_reg);
 8072 %}
 8073 
 8074 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8075   match(Set dst (MoveI2F src));
 8076   effect(DEF dst, USE src);
 8077   ins_cost(MEMORY_REF_COST);
 8078 
 8079   format %{ &quot;STW    $src,$dst\t! MoveI2F&quot; %}
 8080   opcode(Assembler::stw_op3);
 8081   ins_encode(simple_form3_mem_reg( dst, src ) );
 8082   ins_pipe(istore_mem_reg);
 8083 %}
 8084 
 8085 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8086   match(Set dst (MoveD2L src));
 8087   effect(DEF dst, USE src);
 8088   ins_cost(MEMORY_REF_COST);
 8089 
 8090   format %{ &quot;STDF   $src,$dst\t! MoveD2L&quot; %}
 8091   opcode(Assembler::stdf_op3);
 8092   ins_encode(simple_form3_mem_reg(dst, src));
 8093   ins_pipe(fstoreD_stk_reg);
 8094 %}
 8095 
 8096 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8097   match(Set dst (MoveL2D src));
 8098   effect(DEF dst, USE src);
 8099   ins_cost(MEMORY_REF_COST);
 8100 
 8101   format %{ &quot;STX    $src,$dst\t! MoveL2D&quot; %}
 8102   opcode(Assembler::stx_op3);
 8103   ins_encode(simple_form3_mem_reg( dst, src ) );
 8104   ins_pipe(istore_mem_reg);
 8105 %}
 8106 
 8107 
 8108 //----------Arithmetic Conversion Instructions---------------------------------
 8109 // The conversions operations are all Alpha sorted.  Please keep it that way!
 8110 
 8111 instruct convD2F_reg(regF dst, regD src) %{
 8112   match(Set dst (ConvD2F src));
 8113   size(4);
 8114   format %{ &quot;FDTOS  $src,$dst&quot; %}
 8115   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdtos_opf);
 8116   ins_encode(form3_opf_rs2D_rdF(src, dst));
 8117   ins_pipe(fcvtD2F);
 8118 %}
 8119 
 8120 
 8121 // Convert a double to an int in a float register.
 8122 // If the double is a NAN, stuff a zero in instead.
 8123 instruct convD2I_helper(regF dst, regD src, flagsRegF0 fcc0) %{
 8124   effect(DEF dst, USE src, KILL fcc0);
 8125   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8126             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8127             &quot;FDTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8128             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8129             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8130       &quot;skip:&quot; %}
 8131   ins_encode(form_d2i_helper(src,dst));
 8132   ins_pipe(fcvtD2I);
 8133 %}
 8134 
 8135 instruct convD2I_stk(stackSlotI dst, regD src) %{
 8136   match(Set dst (ConvD2I src));
 8137   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8138   expand %{
 8139     regF tmp;
 8140     convD2I_helper(tmp, src);
 8141     regF_to_stkI(dst, tmp);
 8142   %}
 8143 %}
 8144 
 8145 instruct convD2I_reg(iRegI dst, regD src) %{
 8146   predicate(UseVIS &gt;= 3);
 8147   match(Set dst (ConvD2I src));
 8148   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8149   expand %{
 8150     regF tmp;
 8151     convD2I_helper(tmp, src);
 8152     MoveF2I_reg_reg(dst, tmp);
 8153   %}
 8154 %}
 8155 
 8156 
 8157 // Convert a double to a long in a double register.
 8158 // If the double is a NAN, stuff a zero in instead.
 8159 instruct convD2L_helper(regD dst, regD src, flagsRegF0 fcc0) %{
 8160   effect(DEF dst, USE src, KILL fcc0);
 8161   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8162             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8163             &quot;FDTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8164             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8165             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8166       &quot;skip:&quot; %}
 8167   ins_encode(form_d2l_helper(src,dst));
 8168   ins_pipe(fcvtD2L);
 8169 %}
 8170 
 8171 instruct convD2L_stk(stackSlotL dst, regD src) %{
 8172   match(Set dst (ConvD2L src));
 8173   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8174   expand %{
 8175     regD tmp;
 8176     convD2L_helper(tmp, src);
 8177     regD_to_stkL(dst, tmp);
 8178   %}
 8179 %}
 8180 
 8181 instruct convD2L_reg(iRegL dst, regD src) %{
 8182   predicate(UseVIS &gt;= 3);
 8183   match(Set dst (ConvD2L src));
 8184   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8185   expand %{
 8186     regD tmp;
 8187     convD2L_helper(tmp, src);
 8188     MoveD2L_reg_reg(dst, tmp);
 8189   %}
 8190 %}
 8191 
 8192 
 8193 instruct convF2D_reg(regD dst, regF src) %{
 8194   match(Set dst (ConvF2D src));
 8195   format %{ &quot;FSTOD  $src,$dst&quot; %}
 8196   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fstod_opf);
 8197   ins_encode(form3_opf_rs2F_rdD(src, dst));
 8198   ins_pipe(fcvtF2D);
 8199 %}
 8200 
 8201 
 8202 // Convert a float to an int in a float register.
 8203 // If the float is a NAN, stuff a zero in instead.
 8204 instruct convF2I_helper(regF dst, regF src, flagsRegF0 fcc0) %{
 8205   effect(DEF dst, USE src, KILL fcc0);
 8206   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8207             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8208             &quot;FSTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8209             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8210             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8211       &quot;skip:&quot; %}
 8212   ins_encode(form_f2i_helper(src,dst));
 8213   ins_pipe(fcvtF2I);
 8214 %}
 8215 
 8216 instruct convF2I_stk(stackSlotI dst, regF src) %{
 8217   match(Set dst (ConvF2I src));
 8218   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8219   expand %{
 8220     regF tmp;
 8221     convF2I_helper(tmp, src);
 8222     regF_to_stkI(dst, tmp);
 8223   %}
 8224 %}
 8225 
 8226 instruct convF2I_reg(iRegI dst, regF src) %{
 8227   predicate(UseVIS &gt;= 3);
 8228   match(Set dst (ConvF2I src));
 8229   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8230   expand %{
 8231     regF tmp;
 8232     convF2I_helper(tmp, src);
 8233     MoveF2I_reg_reg(dst, tmp);
 8234   %}
 8235 %}
 8236 
 8237 
 8238 // Convert a float to a long in a float register.
 8239 // If the float is a NAN, stuff a zero in instead.
 8240 instruct convF2L_helper(regD dst, regF src, flagsRegF0 fcc0) %{
 8241   effect(DEF dst, USE src, KILL fcc0);
 8242   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8243             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8244             &quot;FSTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8245             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8246             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8247       &quot;skip:&quot; %}
 8248   ins_encode(form_f2l_helper(src,dst));
 8249   ins_pipe(fcvtF2L);
 8250 %}
 8251 
 8252 instruct convF2L_stk(stackSlotL dst, regF src) %{
 8253   match(Set dst (ConvF2L src));
 8254   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8255   expand %{
 8256     regD tmp;
 8257     convF2L_helper(tmp, src);
 8258     regD_to_stkL(dst, tmp);
 8259   %}
 8260 %}
 8261 
 8262 instruct convF2L_reg(iRegL dst, regF src) %{
 8263   predicate(UseVIS &gt;= 3);
 8264   match(Set dst (ConvF2L src));
 8265   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8266   expand %{
 8267     regD tmp;
 8268     convF2L_helper(tmp, src);
 8269     MoveD2L_reg_reg(dst, tmp);
 8270   %}
 8271 %}
 8272 
 8273 
 8274 instruct convI2D_helper(regD dst, regF tmp) %{
 8275   effect(USE tmp, DEF dst);
 8276   format %{ &quot;FITOD  $tmp,$dst&quot; %}
 8277   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8278   ins_encode(form3_opf_rs2F_rdD(tmp, dst));
 8279   ins_pipe(fcvtI2D);
 8280 %}
 8281 
 8282 instruct convI2D_stk(stackSlotI src, regD dst) %{
 8283   match(Set dst (ConvI2D src));
 8284   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8285   expand %{
 8286     regF tmp;
 8287     stkI_to_regF(tmp, src);
 8288     convI2D_helper(dst, tmp);
 8289   %}
 8290 %}
 8291 
 8292 instruct convI2D_reg(regD_low dst, iRegI src) %{
 8293   predicate(UseVIS &gt;= 3);
 8294   match(Set dst (ConvI2D src));
 8295   expand %{
 8296     regF tmp;
 8297     MoveI2F_reg_reg(tmp, src);
 8298     convI2D_helper(dst, tmp);
 8299   %}
 8300 %}
 8301 
 8302 instruct convI2D_mem(regD_low dst, memory mem) %{
 8303   match(Set dst (ConvI2D (LoadI mem)));
 8304   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8305   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8306             &quot;FITOD  $dst,$dst&quot; %}
 8307   opcode(Assembler::ldf_op3, Assembler::fitod_opf);
 8308   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8309   ins_pipe(floadF_mem);
 8310 %}
 8311 
 8312 
 8313 instruct convI2F_helper(regF dst, regF tmp) %{
 8314   effect(DEF dst, USE tmp);
 8315   format %{ &quot;FITOS  $tmp,$dst&quot; %}
 8316   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitos_opf);
 8317   ins_encode(form3_opf_rs2F_rdF(tmp, dst));
 8318   ins_pipe(fcvtI2F);
 8319 %}
 8320 
 8321 instruct convI2F_stk(regF dst, stackSlotI src) %{
 8322   match(Set dst (ConvI2F src));
 8323   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8324   expand %{
 8325     regF tmp;
 8326     stkI_to_regF(tmp,src);
 8327     convI2F_helper(dst, tmp);
 8328   %}
 8329 %}
 8330 
 8331 instruct convI2F_reg(regF dst, iRegI src) %{
 8332   predicate(UseVIS &gt;= 3);
 8333   match(Set dst (ConvI2F src));
 8334   ins_cost(DEFAULT_COST);
 8335   expand %{
 8336     regF tmp;
 8337     MoveI2F_reg_reg(tmp, src);
 8338     convI2F_helper(dst, tmp);
 8339   %}
 8340 %}
 8341 
 8342 instruct convI2F_mem( regF dst, memory mem ) %{
 8343   match(Set dst (ConvI2F (LoadI mem)));
 8344   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8345   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8346             &quot;FITOS  $dst,$dst&quot; %}
 8347   opcode(Assembler::ldf_op3, Assembler::fitos_opf);
 8348   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8349   ins_pipe(floadF_mem);
 8350 %}
 8351 
 8352 
 8353 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8354   match(Set dst (ConvI2L src));
 8355   size(4);
 8356   format %{ &quot;SRA    $src,0,$dst\t! int-&gt;long&quot; %}
 8357   opcode(Assembler::sra_op3, Assembler::arith_op);
 8358   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8359   ins_pipe(ialu_reg_reg);
 8360 %}
 8361 
 8362 // Zero-extend convert int to long
 8363 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask ) %{
 8364   match(Set dst (AndL (ConvI2L src) mask) );
 8365   size(4);
 8366   format %{ &quot;SRL    $src,0,$dst\t! zero-extend int to long&quot; %}
 8367   opcode(Assembler::srl_op3, Assembler::arith_op);
 8368   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8369   ins_pipe(ialu_reg_reg);
 8370 %}
 8371 
 8372 // Zero-extend long
 8373 instruct zerox_long(iRegL dst, iRegL src, immL_32bits mask ) %{
 8374   match(Set dst (AndL src mask) );
 8375   size(4);
 8376   format %{ &quot;SRL    $src,0,$dst\t! zero-extend long&quot; %}
 8377   opcode(Assembler::srl_op3, Assembler::arith_op);
 8378   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8379   ins_pipe(ialu_reg_reg);
 8380 %}
 8381 
 8382 
 8383 //-----------
 8384 // Long to Double conversion using V8 opcodes.
 8385 // Still useful because cheetah traps and becomes
 8386 // amazingly slow for some common numbers.
 8387 
 8388 // Magic constant, 0x43300000
 8389 instruct loadConI_x43300000(iRegI dst) %{
 8390   effect(DEF dst);
 8391   size(4);
 8392   format %{ &quot;SETHI  HI(0x43300000),$dst\t! 2^52&quot; %}
 8393   ins_encode(SetHi22(0x43300000, dst));
 8394   ins_pipe(ialu_none);
 8395 %}
 8396 
 8397 // Magic constant, 0x41f00000
 8398 instruct loadConI_x41f00000(iRegI dst) %{
 8399   effect(DEF dst);
 8400   size(4);
 8401   format %{ &quot;SETHI  HI(0x41f00000),$dst\t! 2^32&quot; %}
 8402   ins_encode(SetHi22(0x41f00000, dst));
 8403   ins_pipe(ialu_none);
 8404 %}
 8405 
 8406 // Construct a double from two float halves
 8407 instruct regDHi_regDLo_to_regD(regD_low dst, regD_low src1, regD_low src2) %{
 8408   effect(DEF dst, USE src1, USE src2);
 8409   size(8);
 8410   format %{ &quot;FMOVS  $src1.hi,$dst.hi\n\t&quot;
 8411             &quot;FMOVS  $src2.lo,$dst.lo&quot; %}
 8412   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmovs_opf);
 8413   ins_encode(form3_opf_rs2D_hi_rdD_hi(src1, dst), form3_opf_rs2D_lo_rdD_lo(src2, dst));
 8414   ins_pipe(faddD_reg_reg);
 8415 %}
 8416 
 8417 // Convert integer in high half of a double register (in the lower half of
 8418 // the double register file) to double
 8419 instruct convI2D_regDHi_regD(regD dst, regD_low src) %{
 8420   effect(DEF dst, USE src);
 8421   size(4);
 8422   format %{ &quot;FITOD  $src,$dst&quot; %}
 8423   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8424   ins_encode(form3_opf_rs2D_rdD(src, dst));
 8425   ins_pipe(fcvtLHi2D);
 8426 %}
 8427 
 8428 // Add float double precision
 8429 instruct addD_regD_regD(regD dst, regD src1, regD src2) %{
 8430   effect(DEF dst, USE src1, USE src2);
 8431   size(4);
 8432   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 8433   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 8434   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8435   ins_pipe(faddD_reg_reg);
 8436 %}
 8437 
 8438 // Sub float double precision
 8439 instruct subD_regD_regD(regD dst, regD src1, regD src2) %{
 8440   effect(DEF dst, USE src1, USE src2);
 8441   size(4);
 8442   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 8443   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 8444   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8445   ins_pipe(faddD_reg_reg);
 8446 %}
 8447 
 8448 // Mul float double precision
 8449 instruct mulD_regD_regD(regD dst, regD src1, regD src2) %{
 8450   effect(DEF dst, USE src1, USE src2);
 8451   size(4);
 8452   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 8453   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 8454   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8455   ins_pipe(fmulD_reg_reg);
 8456 %}
 8457 
 8458 // Long to Double conversion using fast fxtof
 8459 instruct convL2D_helper(regD dst, regD tmp) %{
 8460   effect(DEF dst, USE tmp);
 8461   size(4);
 8462   format %{ &quot;FXTOD  $tmp,$dst&quot; %}
 8463   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtod_opf);
 8464   ins_encode(form3_opf_rs2D_rdD(tmp, dst));
 8465   ins_pipe(fcvtL2D);
 8466 %}
 8467 
 8468 instruct convL2D_stk_fast_fxtof(regD dst, stackSlotL src) %{
 8469   match(Set dst (ConvL2D src));
 8470   ins_cost(DEFAULT_COST + 3 * MEMORY_REF_COST);
 8471   expand %{
 8472     regD tmp;
 8473     stkL_to_regD(tmp, src);
 8474     convL2D_helper(dst, tmp);
 8475   %}
 8476 %}
 8477 
 8478 instruct convL2D_reg(regD dst, iRegL src) %{
 8479   predicate(UseVIS &gt;= 3);
 8480   match(Set dst (ConvL2D src));
 8481   expand %{
 8482     regD tmp;
 8483     MoveL2D_reg_reg(tmp, src);
 8484     convL2D_helper(dst, tmp);
 8485   %}
 8486 %}
 8487 
 8488 // Long to Float conversion using fast fxtof
 8489 instruct convL2F_helper(regF dst, regD tmp) %{
 8490   effect(DEF dst, USE tmp);
 8491   size(4);
 8492   format %{ &quot;FXTOS  $tmp,$dst&quot; %}
 8493   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtos_opf);
 8494   ins_encode(form3_opf_rs2D_rdF(tmp, dst));
 8495   ins_pipe(fcvtL2F);
 8496 %}
 8497 
 8498 instruct convL2F_stk_fast_fxtof(regF dst, stackSlotL src) %{
 8499   match(Set dst (ConvL2F src));
 8500   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8501   expand %{
 8502     regD tmp;
 8503     stkL_to_regD(tmp, src);
 8504     convL2F_helper(dst, tmp);
 8505   %}
 8506 %}
 8507 
 8508 instruct convL2F_reg(regF dst, iRegL src) %{
 8509   predicate(UseVIS &gt;= 3);
 8510   match(Set dst (ConvL2F src));
 8511   ins_cost(DEFAULT_COST);
 8512   expand %{
 8513     regD tmp;
 8514     MoveL2D_reg_reg(tmp, src);
 8515     convL2F_helper(dst, tmp);
 8516   %}
 8517 %}
 8518 
 8519 //-----------
 8520 
 8521 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8522   match(Set dst (ConvL2I src));
 8523   size(4);
 8524   format %{ &quot;SRA    $src,R_G0,$dst\t! long-&gt;int&quot; %}
 8525   ins_encode( form3_rs1_rd_signextend_lo1( src, dst ) );
 8526   ins_pipe(ialu_reg);
 8527 %}
 8528 
 8529 // Register Shift Right Immediate
 8530 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt) %{
 8531   match(Set dst (ConvL2I (RShiftL src cnt)));
 8532 
 8533   size(4);
 8534   format %{ &quot;SRAX   $src,$cnt,$dst&quot; %}
 8535   opcode(Assembler::srax_op3, Assembler::arith_op);
 8536   ins_encode( form3_sd_rs1_imm6_rd( src, cnt, dst ) );
 8537   ins_pipe(ialu_reg_imm);
 8538 %}
 8539 
 8540 //----------Control Flow Instructions------------------------------------------
 8541 // Compare Instructions
 8542 // Compare Integers
 8543 instruct compI_iReg(flagsReg icc, iRegI op1, iRegI op2) %{
 8544   match(Set icc (CmpI op1 op2));
 8545   effect( DEF icc, USE op1, USE op2 );
 8546 
 8547   size(4);
 8548   format %{ &quot;CMP    $op1,$op2&quot; %}
 8549   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8550   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8551   ins_pipe(ialu_cconly_reg_reg);
 8552 %}
 8553 
 8554 instruct compU_iReg(flagsRegU icc, iRegI op1, iRegI op2) %{
 8555   match(Set icc (CmpU op1 op2));
 8556 
 8557   size(4);
 8558   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8559   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8560   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8561   ins_pipe(ialu_cconly_reg_reg);
 8562 %}
 8563 
 8564 instruct compUL_iReg(flagsRegUL xcc, iRegL op1, iRegL op2) %{
 8565   match(Set xcc (CmpUL op1 op2));
 8566   effect(DEF xcc, USE op1, USE op2);
 8567 
 8568   size(4);
 8569   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8570   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8571   ins_encode(form3_rs1_rs2_rd(op1, op2, R_G0));
 8572   ins_pipe(ialu_cconly_reg_reg);
 8573 %}
 8574 
 8575 instruct compI_iReg_imm13(flagsReg icc, iRegI op1, immI13 op2) %{
 8576   match(Set icc (CmpI op1 op2));
 8577   effect( DEF icc, USE op1 );
 8578 
 8579   size(4);
 8580   format %{ &quot;CMP    $op1,$op2&quot; %}
 8581   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8582   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8583   ins_pipe(ialu_cconly_reg_imm);
 8584 %}
 8585 
 8586 instruct testI_reg_reg( flagsReg icc, iRegI op1, iRegI op2, immI0 zero ) %{
 8587   match(Set icc (CmpI (AndI op1 op2) zero));
 8588 
 8589   size(4);
 8590   format %{ &quot;BTST   $op2,$op1&quot; %}
 8591   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8592   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8593   ins_pipe(ialu_cconly_reg_reg_zero);
 8594 %}
 8595 
 8596 instruct testI_reg_imm( flagsReg icc, iRegI op1, immI13 op2, immI0 zero ) %{
 8597   match(Set icc (CmpI (AndI op1 op2) zero));
 8598 
 8599   size(4);
 8600   format %{ &quot;BTST   $op2,$op1&quot; %}
 8601   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8602   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8603   ins_pipe(ialu_cconly_reg_imm_zero);
 8604 %}
 8605 
 8606 instruct compL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2 ) %{
 8607   match(Set xcc (CmpL op1 op2));
 8608   effect( DEF xcc, USE op1, USE op2 );
 8609 
 8610   size(4);
 8611   format %{ &quot;CMP    $op1,$op2\t\t! long&quot; %}
 8612   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8613   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8614   ins_pipe(ialu_cconly_reg_reg);
 8615 %}
 8616 
 8617 instruct compL_reg_con(flagsRegL xcc, iRegL op1, immL13 con) %{
 8618   match(Set xcc (CmpL op1 con));
 8619   effect( DEF xcc, USE op1, USE con );
 8620 
 8621   size(4);
 8622   format %{ &quot;CMP    $op1,$con\t\t! long&quot; %}
 8623   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8624   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8625   ins_pipe(ialu_cconly_reg_reg);
 8626 %}
 8627 
 8628 instruct testL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2, immL0 zero) %{
 8629   match(Set xcc (CmpL (AndL op1 op2) zero));
 8630   effect( DEF xcc, USE op1, USE op2 );
 8631 
 8632   size(4);
 8633   format %{ &quot;BTST   $op1,$op2\t\t! long&quot; %}
 8634   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8635   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8636   ins_pipe(ialu_cconly_reg_reg);
 8637 %}
 8638 
 8639 // useful for checking the alignment of a pointer:
 8640 instruct testL_reg_con(flagsRegL xcc, iRegL op1, immL13 con, immL0 zero) %{
 8641   match(Set xcc (CmpL (AndL op1 con) zero));
 8642   effect( DEF xcc, USE op1, USE con );
 8643 
 8644   size(4);
 8645   format %{ &quot;BTST   $op1,$con\t\t! long&quot; %}
 8646   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8647   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8648   ins_pipe(ialu_cconly_reg_reg);
 8649 %}
 8650 
 8651 instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU12 op2 ) %{
 8652   match(Set icc (CmpU op1 op2));
 8653 
 8654   size(4);
 8655   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8656   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8657   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8658   ins_pipe(ialu_cconly_reg_imm);
 8659 %}
 8660 
 8661 instruct compUL_iReg_imm13(flagsRegUL xcc, iRegL op1, immUL12 op2) %{
 8662   match(Set xcc (CmpUL op1 op2));
 8663   effect(DEF xcc, USE op1, USE op2);
 8664 
 8665   size(4);
 8666   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8667   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8668   ins_encode(form3_rs1_simm13_rd(op1, op2, R_G0));
 8669   ins_pipe(ialu_cconly_reg_imm);
 8670 %}
 8671 
 8672 // Compare Pointers
 8673 instruct compP_iRegP(flagsRegP pcc, iRegP op1, iRegP op2 ) %{
 8674   match(Set pcc (CmpP op1 op2));
 8675 
 8676   size(4);
 8677   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8678   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8679   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8680   ins_pipe(ialu_cconly_reg_reg);
 8681 %}
 8682 
 8683 instruct compP_iRegP_imm13(flagsRegP pcc, iRegP op1, immP13 op2 ) %{
 8684   match(Set pcc (CmpP op1 op2));
 8685 
 8686   size(4);
 8687   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8688   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8689   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8690   ins_pipe(ialu_cconly_reg_imm);
 8691 %}
 8692 
 8693 // Compare Narrow oops
 8694 instruct compN_iRegN(flagsReg icc, iRegN op1, iRegN op2 ) %{
 8695   match(Set icc (CmpN op1 op2));
 8696 
 8697   size(4);
 8698   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8699   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8700   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8701   ins_pipe(ialu_cconly_reg_reg);
 8702 %}
 8703 
 8704 instruct compN_iRegN_immN0(flagsReg icc, iRegN op1, immN0 op2 ) %{
 8705   match(Set icc (CmpN op1 op2));
 8706 
 8707   size(4);
 8708   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8709   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8710   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8711   ins_pipe(ialu_cconly_reg_imm);
 8712 %}
 8713 
 8714 //----------Max and Min--------------------------------------------------------
 8715 // Min Instructions
 8716 // Conditional move for min
 8717 instruct cmovI_reg_lt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8718   effect( USE_DEF op2, USE op1, USE icc );
 8719 
 8720   size(4);
 8721   format %{ &quot;MOVlt  icc,$op1,$op2\t! min&quot; %}
 8722   opcode(Assembler::less);
 8723   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8724   ins_pipe(ialu_reg_flags);
 8725 %}
 8726 
 8727 // Min Register with Register.
 8728 instruct minI_eReg(iRegI op1, iRegI op2) %{
 8729   match(Set op2 (MinI op1 op2));
 8730   ins_cost(DEFAULT_COST*2);
 8731   expand %{
 8732     flagsReg icc;
 8733     compI_iReg(icc,op1,op2);
 8734     cmovI_reg_lt(op2,op1,icc);
 8735   %}
 8736 %}
 8737 
 8738 // Max Instructions
 8739 // Conditional move for max
 8740 instruct cmovI_reg_gt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8741   effect( USE_DEF op2, USE op1, USE icc );
 8742   format %{ &quot;MOVgt  icc,$op1,$op2\t! max&quot; %}
 8743   opcode(Assembler::greater);
 8744   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8745   ins_pipe(ialu_reg_flags);
 8746 %}
 8747 
 8748 // Max Register with Register
 8749 instruct maxI_eReg(iRegI op1, iRegI op2) %{
 8750   match(Set op2 (MaxI op1 op2));
 8751   ins_cost(DEFAULT_COST*2);
 8752   expand %{
 8753     flagsReg icc;
 8754     compI_iReg(icc,op1,op2);
 8755     cmovI_reg_gt(op2,op1,icc);
 8756   %}
 8757 %}
 8758 
 8759 
 8760 //----------Float Compares----------------------------------------------------
 8761 // Compare floating, generate condition code
 8762 instruct cmpF_cc(flagsRegF fcc, regF src1, regF src2) %{
 8763   match(Set fcc (CmpF src1 src2));
 8764 
 8765   size(4);
 8766   format %{ &quot;FCMPs  $fcc,$src1,$src2&quot; %}
 8767   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmps_opf);
 8768   ins_encode( form3_opf_rs1F_rs2F_fcc( src1, src2, fcc ) );
 8769   ins_pipe(faddF_fcc_reg_reg_zero);
 8770 %}
 8771 
 8772 instruct cmpD_cc(flagsRegF fcc, regD src1, regD src2) %{
 8773   match(Set fcc (CmpD src1 src2));
 8774 
 8775   size(4);
 8776   format %{ &quot;FCMPd  $fcc,$src1,$src2&quot; %}
 8777   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmpd_opf);
 8778   ins_encode( form3_opf_rs1D_rs2D_fcc( src1, src2, fcc ) );
 8779   ins_pipe(faddD_fcc_reg_reg_zero);
 8780 %}
 8781 
 8782 
 8783 // Compare floating, generate -1,0,1
 8784 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsRegF0 fcc0) %{
 8785   match(Set dst (CmpF3 src1 src2));
 8786   effect(KILL fcc0);
 8787   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8788   format %{ &quot;fcmpl  $dst,$src1,$src2&quot; %}
 8789   // Primary = float
 8790   opcode( true );
 8791   ins_encode( floating_cmp( dst, src1, src2 ) );
 8792   ins_pipe( floating_cmp );
 8793 %}
 8794 
 8795 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsRegF0 fcc0) %{
 8796   match(Set dst (CmpD3 src1 src2));
 8797   effect(KILL fcc0);
 8798   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8799   format %{ &quot;dcmpl  $dst,$src1,$src2&quot; %}
 8800   // Primary = double (not float)
 8801   opcode( false );
 8802   ins_encode( floating_cmp( dst, src1, src2 ) );
 8803   ins_pipe( floating_cmp );
 8804 %}
 8805 
 8806 //----------Branches---------------------------------------------------------
 8807 // Jump
 8808 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8809 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8810   match(Jump switch_val);
 8811   effect(TEMP table);
 8812 
 8813   ins_cost(350);
 8814 
 8815   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8816              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8817              &quot;JUMP   O7&quot; %}
 8818   ins_encode %{
 8819     // Calculate table address into a register.
 8820     Register table_reg;
 8821     Register label_reg = O7;
 8822     // If we are calculating the size of this instruction don&#39;t trust
 8823     // zero offsets because they might change when
 8824     // MachConstantBaseNode decides to optimize the constant table
 8825     // base.
 8826     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {
 8827       table_reg = $constanttablebase;
 8828     } else {
 8829       table_reg = O7;
 8830       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8831       __ add($constanttablebase, con_offset, table_reg);
 8832     }
 8833 
 8834     // Jump to base address + switch value
 8835     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8836     __ jmp(label_reg, G0);
 8837     __ delayed()-&gt;nop();
 8838   %}
 8839   ins_pipe(ialu_reg_reg);
 8840 %}
 8841 
 8842 // Direct Branch.  Use V8 version with longer range.
 8843 instruct branch(label labl) %{
 8844   match(Goto);
 8845   effect(USE labl);
 8846 
 8847   size(8);
 8848   ins_cost(BRANCH_COST);
 8849   format %{ &quot;BA     $labl&quot; %}
 8850   ins_encode %{
 8851     Label* L = $labl$$label;
 8852     __ ba(*L);
 8853     __ delayed()-&gt;nop();
 8854   %}
 8855   ins_avoid_back_to_back(AVOID_BEFORE);
 8856   ins_pipe(br);
 8857 %}
 8858 
 8859 // Direct Branch, short with no delay slot
 8860 instruct branch_short(label labl) %{
 8861   match(Goto);
 8862   predicate(UseCBCond);
 8863   effect(USE labl);
 8864 
 8865   size(4); // Assuming no NOP inserted.
 8866   ins_cost(BRANCH_COST);
 8867   format %{ &quot;BA     $labl\t! short branch&quot; %}
 8868   ins_encode %{
 8869     Label* L = $labl$$label;
 8870     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 8871     __ ba_short(*L);
 8872   %}
 8873   ins_short_branch(1);
 8874   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 8875   ins_pipe(cbcond_reg_imm);
 8876 %}
 8877 
 8878 // Conditional Direct Branch
 8879 instruct branchCon(cmpOp cmp, flagsReg icc, label labl) %{
 8880   match(If cmp icc);
 8881   effect(USE labl);
 8882 
 8883   size(8);
 8884   ins_cost(BRANCH_COST);
 8885   format %{ &quot;BP$cmp   $icc,$labl&quot; %}
 8886   // Prim = bits 24-22, Secnd = bits 31-30
 8887   ins_encode( enc_bp( labl, cmp, icc ) );
 8888   ins_avoid_back_to_back(AVOID_BEFORE);
 8889   ins_pipe(br_cc);
 8890 %}
 8891 
 8892 instruct branchConU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8893   match(If cmp icc);
 8894   effect(USE labl);
 8895 
 8896   ins_cost(BRANCH_COST);
 8897   format %{ &quot;BP$cmp  $icc,$labl&quot; %}
 8898   // Prim = bits 24-22, Secnd = bits 31-30
 8899   ins_encode( enc_bp( labl, cmp, icc ) );
 8900   ins_avoid_back_to_back(AVOID_BEFORE);
 8901   ins_pipe(br_cc);
 8902 %}
 8903 
 8904 instruct branchConP(cmpOpP cmp, flagsRegP pcc, label labl) %{
 8905   match(If cmp pcc);
 8906   effect(USE labl);
 8907 
 8908   size(8);
 8909   ins_cost(BRANCH_COST);
 8910   format %{ &quot;BP$cmp  $pcc,$labl&quot; %}
 8911   ins_encode %{
 8912     Label* L = $labl$$label;
 8913     Assembler::Predict predict_taken =
 8914       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8915 
 8916     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 8917     __ delayed()-&gt;nop();
 8918   %}
 8919   ins_avoid_back_to_back(AVOID_BEFORE);
 8920   ins_pipe(br_cc);
 8921 %}
 8922 
 8923 instruct branchConF(cmpOpF cmp, flagsRegF fcc, label labl) %{
 8924   match(If cmp fcc);
 8925   effect(USE labl);
 8926 
 8927   size(8);
 8928   ins_cost(BRANCH_COST);
 8929   format %{ &quot;FBP$cmp $fcc,$labl&quot; %}
 8930   ins_encode %{
 8931     Label* L = $labl$$label;
 8932     Assembler::Predict predict_taken =
 8933       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8934 
 8935     __ fbp( (Assembler::Condition)($cmp$$cmpcode), false, (Assembler::CC)($fcc$$reg), predict_taken, *L);
 8936     __ delayed()-&gt;nop();
 8937   %}
 8938   ins_avoid_back_to_back(AVOID_BEFORE);
 8939   ins_pipe(br_fcc);
 8940 %}
 8941 
 8942 instruct branchLoopEnd(cmpOp cmp, flagsReg icc, label labl) %{
 8943   match(CountedLoopEnd cmp icc);
 8944   effect(USE labl);
 8945 
 8946   size(8);
 8947   ins_cost(BRANCH_COST);
 8948   format %{ &quot;BP$cmp   $icc,$labl\t! Loop end&quot; %}
 8949   // Prim = bits 24-22, Secnd = bits 31-30
 8950   ins_encode( enc_bp( labl, cmp, icc ) );
 8951   ins_avoid_back_to_back(AVOID_BEFORE);
 8952   ins_pipe(br_cc);
 8953 %}
 8954 
 8955 instruct branchLoopEndU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8956   match(CountedLoopEnd cmp icc);
 8957   effect(USE labl);
 8958 
 8959   size(8);
 8960   ins_cost(BRANCH_COST);
 8961   format %{ &quot;BP$cmp  $icc,$labl\t! Loop end&quot; %}
 8962   // Prim = bits 24-22, Secnd = bits 31-30
 8963   ins_encode( enc_bp( labl, cmp, icc ) );
 8964   ins_avoid_back_to_back(AVOID_BEFORE);
 8965   ins_pipe(br_cc);
 8966 %}
 8967 
 8968 // Compare and branch instructions
 8969 instruct cmpI_reg_branch(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 8970   match(If cmp (CmpI op1 op2));
 8971   effect(USE labl, KILL icc);
 8972 
 8973   size(12);
 8974   ins_cost(BRANCH_COST);
 8975   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 8976             &quot;BP$cmp   $labl&quot; %}
 8977   ins_encode %{
 8978     Label* L = $labl$$label;
 8979     Assembler::Predict predict_taken =
 8980       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8981     __ cmp($op1$$Register, $op2$$Register);
 8982     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 8983     __ delayed()-&gt;nop();
 8984   %}
 8985   ins_pipe(cmp_br_reg_reg);
 8986 %}
 8987 
 8988 instruct cmpI_imm_branch(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 8989   match(If cmp (CmpI op1 op2));
 8990   effect(USE labl, KILL icc);
 8991 
 8992   size(12);
 8993   ins_cost(BRANCH_COST);
 8994   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 8995             &quot;BP$cmp   $labl&quot; %}
 8996   ins_encode %{
 8997     Label* L = $labl$$label;
 8998     Assembler::Predict predict_taken =
 8999       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9000     __ cmp($op1$$Register, $op2$$constant);
 9001     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9002     __ delayed()-&gt;nop();
 9003   %}
 9004   ins_pipe(cmp_br_reg_imm);
 9005 %}
 9006 
 9007 instruct cmpU_reg_branch(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9008   match(If cmp (CmpU op1 op2));
 9009   effect(USE labl, KILL icc);
 9010 
 9011   size(12);
 9012   ins_cost(BRANCH_COST);
 9013   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9014             &quot;BP$cmp  $labl&quot; %}
 9015   ins_encode %{
 9016     Label* L = $labl$$label;
 9017     Assembler::Predict predict_taken =
 9018       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9019     __ cmp($op1$$Register, $op2$$Register);
 9020     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9021     __ delayed()-&gt;nop();
 9022   %}
 9023   ins_pipe(cmp_br_reg_reg);
 9024 %}
 9025 
 9026 instruct cmpU_imm_branch(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9027   match(If cmp (CmpU op1 op2));
 9028   effect(USE labl, KILL icc);
 9029 
 9030   size(12);
 9031   ins_cost(BRANCH_COST);
 9032   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9033             &quot;BP$cmp  $labl&quot; %}
 9034   ins_encode %{
 9035     Label* L = $labl$$label;
 9036     Assembler::Predict predict_taken =
 9037       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9038     __ cmp($op1$$Register, $op2$$constant);
 9039     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9040     __ delayed()-&gt;nop();
 9041   %}
 9042   ins_pipe(cmp_br_reg_imm);
 9043 %}
 9044 
 9045 instruct cmpUL_reg_branch(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9046   match(If cmp (CmpUL op1 op2));
 9047   effect(USE labl, KILL xcc);
 9048 
 9049   size(12);
 9050   ins_cost(BRANCH_COST);
 9051   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9052             &quot;BP$cmp   $labl&quot; %}
 9053   ins_encode %{
 9054     Label* L = $labl$$label;
 9055     Assembler::Predict predict_taken =
 9056       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9057     __ cmp($op1$$Register, $op2$$Register);
 9058     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9059     __ delayed()-&gt;nop();
 9060   %}
 9061   ins_pipe(cmp_br_reg_reg);
 9062 %}
 9063 
 9064 instruct cmpUL_imm_branch(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9065   match(If cmp (CmpUL op1 op2));
 9066   effect(USE labl, KILL xcc);
 9067 
 9068   size(12);
 9069   ins_cost(BRANCH_COST);
 9070   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9071             &quot;BP$cmp   $labl&quot; %}
 9072   ins_encode %{
 9073     Label* L = $labl$$label;
 9074     Assembler::Predict predict_taken =
 9075       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9076     __ cmp($op1$$Register, $op2$$constant);
 9077     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9078     __ delayed()-&gt;nop();
 9079   %}
 9080   ins_pipe(cmp_br_reg_imm);
 9081 %}
 9082 
 9083 instruct cmpL_reg_branch(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9084   match(If cmp (CmpL op1 op2));
 9085   effect(USE labl, KILL xcc);
 9086 
 9087   size(12);
 9088   ins_cost(BRANCH_COST);
 9089   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9090             &quot;BP$cmp   $labl&quot; %}
 9091   ins_encode %{
 9092     Label* L = $labl$$label;
 9093     Assembler::Predict predict_taken =
 9094       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9095     __ cmp($op1$$Register, $op2$$Register);
 9096     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9097     __ delayed()-&gt;nop();
 9098   %}
 9099   ins_pipe(cmp_br_reg_reg);
 9100 %}
 9101 
 9102 instruct cmpL_imm_branch(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9103   match(If cmp (CmpL op1 op2));
 9104   effect(USE labl, KILL xcc);
 9105 
 9106   size(12);
 9107   ins_cost(BRANCH_COST);
 9108   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9109             &quot;BP$cmp   $labl&quot; %}
 9110   ins_encode %{
 9111     Label* L = $labl$$label;
 9112     Assembler::Predict predict_taken =
 9113       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9114     __ cmp($op1$$Register, $op2$$constant);
 9115     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9116     __ delayed()-&gt;nop();
 9117   %}
 9118   ins_pipe(cmp_br_reg_imm);
 9119 %}
 9120 
 9121 // Compare Pointers and branch
 9122 instruct cmpP_reg_branch(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9123   match(If cmp (CmpP op1 op2));
 9124   effect(USE labl, KILL pcc);
 9125 
 9126   size(12);
 9127   ins_cost(BRANCH_COST);
 9128   format %{ &quot;CMP    $op1,$op2\t! ptr\n\t&quot;
 9129             &quot;B$cmp   $labl&quot; %}
 9130   ins_encode %{
 9131     Label* L = $labl$$label;
 9132     Assembler::Predict predict_taken =
 9133       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9134     __ cmp($op1$$Register, $op2$$Register);
 9135     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9136     __ delayed()-&gt;nop();
 9137   %}
 9138   ins_pipe(cmp_br_reg_reg);
 9139 %}
 9140 
 9141 instruct cmpP_null_branch(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9142   match(If cmp (CmpP op1 null));
 9143   effect(USE labl, KILL pcc);
 9144 
 9145   size(12);
 9146   ins_cost(BRANCH_COST);
 9147   format %{ &quot;CMP    $op1,0\t! ptr\n\t&quot;
 9148             &quot;B$cmp   $labl&quot; %}
 9149   ins_encode %{
 9150     Label* L = $labl$$label;
 9151     Assembler::Predict predict_taken =
 9152       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9153     __ cmp($op1$$Register, G0);
 9154     // bpr() is not used here since it has shorter distance.
 9155     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9156     __ delayed()-&gt;nop();
 9157   %}
 9158   ins_pipe(cmp_br_reg_reg);
 9159 %}
 9160 
 9161 instruct cmpN_reg_branch(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9162   match(If cmp (CmpN op1 op2));
 9163   effect(USE labl, KILL icc);
 9164 
 9165   size(12);
 9166   ins_cost(BRANCH_COST);
 9167   format %{ &quot;CMP    $op1,$op2\t! compressed ptr\n\t&quot;
 9168             &quot;BP$cmp   $labl&quot; %}
 9169   ins_encode %{
 9170     Label* L = $labl$$label;
 9171     Assembler::Predict predict_taken =
 9172       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9173     __ cmp($op1$$Register, $op2$$Register);
 9174     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9175     __ delayed()-&gt;nop();
 9176   %}
 9177   ins_pipe(cmp_br_reg_reg);
 9178 %}
 9179 
 9180 instruct cmpN_null_branch(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9181   match(If cmp (CmpN op1 null));
 9182   effect(USE labl, KILL icc);
 9183 
 9184   size(12);
 9185   ins_cost(BRANCH_COST);
 9186   format %{ &quot;CMP    $op1,0\t! compressed ptr\n\t&quot;
 9187             &quot;BP$cmp   $labl&quot; %}
 9188   ins_encode %{
 9189     Label* L = $labl$$label;
 9190     Assembler::Predict predict_taken =
 9191       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9192     __ cmp($op1$$Register, G0);
 9193     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9194     __ delayed()-&gt;nop();
 9195   %}
 9196   ins_pipe(cmp_br_reg_reg);
 9197 %}
 9198 
 9199 // Loop back branch
 9200 instruct cmpI_reg_branchLoopEnd(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9201   match(CountedLoopEnd cmp (CmpI op1 op2));
 9202   effect(USE labl, KILL icc);
 9203 
 9204   size(12);
 9205   ins_cost(BRANCH_COST);
 9206   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9207             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9208   ins_encode %{
 9209     Label* L = $labl$$label;
 9210     Assembler::Predict predict_taken =
 9211       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9212     __ cmp($op1$$Register, $op2$$Register);
 9213     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9214     __ delayed()-&gt;nop();
 9215   %}
 9216   ins_pipe(cmp_br_reg_reg);
 9217 %}
 9218 
 9219 instruct cmpI_imm_branchLoopEnd(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9220   match(CountedLoopEnd cmp (CmpI op1 op2));
 9221   effect(USE labl, KILL icc);
 9222 
 9223   size(12);
 9224   ins_cost(BRANCH_COST);
 9225   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9226             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9227   ins_encode %{
 9228     Label* L = $labl$$label;
 9229     Assembler::Predict predict_taken =
 9230       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9231     __ cmp($op1$$Register, $op2$$constant);
 9232     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9233     __ delayed()-&gt;nop();
 9234   %}
 9235   ins_pipe(cmp_br_reg_imm);
 9236 %}
 9237 
 9238 // Short compare and branch instructions
 9239 instruct cmpI_reg_branch_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9240   match(If cmp (CmpI op1 op2));
 9241   predicate(UseCBCond);
 9242   effect(USE labl, KILL icc);
 9243 
 9244   size(4); // Assuming no NOP inserted.
 9245   ins_cost(BRANCH_COST);
 9246   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9247   ins_encode %{
 9248     Label* L = $labl$$label;
 9249     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9250     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9251   %}
 9252   ins_short_branch(1);
 9253   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9254   ins_pipe(cbcond_reg_reg);
 9255 %}
 9256 
 9257 instruct cmpI_imm_branch_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9258   match(If cmp (CmpI op1 op2));
 9259   predicate(UseCBCond);
 9260   effect(USE labl, KILL icc);
 9261 
 9262   size(4); // Assuming no NOP inserted.
 9263   ins_cost(BRANCH_COST);
 9264   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9265   ins_encode %{
 9266     Label* L = $labl$$label;
 9267     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9268     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9269   %}
 9270   ins_short_branch(1);
 9271   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9272   ins_pipe(cbcond_reg_imm);
 9273 %}
 9274 
 9275 instruct cmpU_reg_branch_short(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9276   match(If cmp (CmpU op1 op2));
 9277   predicate(UseCBCond);
 9278   effect(USE labl, KILL icc);
 9279 
 9280   size(4); // Assuming no NOP inserted.
 9281   ins_cost(BRANCH_COST);
 9282   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9283   ins_encode %{
 9284     Label* L = $labl$$label;
 9285     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9286     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9287   %}
 9288   ins_short_branch(1);
 9289   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9290   ins_pipe(cbcond_reg_reg);
 9291 %}
 9292 
 9293 instruct cmpU_imm_branch_short(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9294   match(If cmp (CmpU op1 op2));
 9295   predicate(UseCBCond);
 9296   effect(USE labl, KILL icc);
 9297 
 9298   size(4); // Assuming no NOP inserted.
 9299   ins_cost(BRANCH_COST);
 9300   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9301   ins_encode %{
 9302     Label* L = $labl$$label;
 9303     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9304     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9305   %}
 9306   ins_short_branch(1);
 9307   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9308   ins_pipe(cbcond_reg_imm);
 9309 %}
 9310 
 9311 instruct cmpUL_reg_branch_short(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9312   match(If cmp (CmpUL op1 op2));
 9313   predicate(UseCBCond);
 9314   effect(USE labl, KILL xcc);
 9315 
 9316   size(4);
 9317   ins_cost(BRANCH_COST);
 9318   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9319   ins_encode %{
 9320     Label* L = $labl$$label;
 9321     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9322     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9323   %}
 9324   ins_short_branch(1);
 9325   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9326   ins_pipe(cbcond_reg_reg);
 9327 %}
 9328 
 9329 instruct cmpUL_imm_branch_short(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9330   match(If cmp (CmpUL op1 op2));
 9331   predicate(UseCBCond);
 9332   effect(USE labl, KILL xcc);
 9333 
 9334   size(4);
 9335   ins_cost(BRANCH_COST);
 9336   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9337   ins_encode %{
 9338     Label* L = $labl$$label;
 9339     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9340     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9341   %}
 9342   ins_short_branch(1);
 9343   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9344   ins_pipe(cbcond_reg_imm);
 9345 %}
 9346 
 9347 instruct cmpL_reg_branch_short(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9348   match(If cmp (CmpL op1 op2));
 9349   predicate(UseCBCond);
 9350   effect(USE labl, KILL xcc);
 9351 
 9352   size(4); // Assuming no NOP inserted.
 9353   ins_cost(BRANCH_COST);
 9354   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9355   ins_encode %{
 9356     Label* L = $labl$$label;
 9357     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9358     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9359   %}
 9360   ins_short_branch(1);
 9361   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9362   ins_pipe(cbcond_reg_reg);
 9363 %}
 9364 
 9365 instruct cmpL_imm_branch_short(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9366   match(If cmp (CmpL op1 op2));
 9367   predicate(UseCBCond);
 9368   effect(USE labl, KILL xcc);
 9369 
 9370   size(4); // Assuming no NOP inserted.
 9371   ins_cost(BRANCH_COST);
 9372   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9373   ins_encode %{
 9374     Label* L = $labl$$label;
 9375     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9376     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9377   %}
 9378   ins_short_branch(1);
 9379   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9380   ins_pipe(cbcond_reg_imm);
 9381 %}
 9382 
 9383 // Compare Pointers and branch
 9384 instruct cmpP_reg_branch_short(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9385   match(If cmp (CmpP op1 op2));
 9386   predicate(UseCBCond);
 9387   effect(USE labl, KILL pcc);
 9388 
 9389   size(4); // Assuming no NOP inserted.
 9390   ins_cost(BRANCH_COST);
 9391   format %{ &quot;CXB$cmp $op1,$op2,$labl\t! ptr&quot; %}
 9392   ins_encode %{
 9393     Label* L = $labl$$label;
 9394     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9395     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, $op2$$Register, *L);
 9396   %}
 9397   ins_short_branch(1);
 9398   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9399   ins_pipe(cbcond_reg_reg);
 9400 %}
 9401 
 9402 instruct cmpP_null_branch_short(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9403   match(If cmp (CmpP op1 null));
 9404   predicate(UseCBCond);
 9405   effect(USE labl, KILL pcc);
 9406 
 9407   size(4); // Assuming no NOP inserted.
 9408   ins_cost(BRANCH_COST);
 9409   format %{ &quot;CXB$cmp $op1,0,$labl\t! ptr&quot; %}
 9410   ins_encode %{
 9411     Label* L = $labl$$label;
 9412     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9413     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, G0, *L);
 9414   %}
 9415   ins_short_branch(1);
 9416   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9417   ins_pipe(cbcond_reg_reg);
 9418 %}
 9419 
 9420 instruct cmpN_reg_branch_short(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9421   match(If cmp (CmpN op1 op2));
 9422   predicate(UseCBCond);
 9423   effect(USE labl, KILL icc);
 9424 
 9425   size(4); // Assuming no NOP inserted.
 9426   ins_cost(BRANCH_COST);
 9427   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! compressed ptr&quot; %}
 9428   ins_encode %{
 9429     Label* L = $labl$$label;
 9430     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9431     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9432   %}
 9433   ins_short_branch(1);
 9434   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9435   ins_pipe(cbcond_reg_reg);
 9436 %}
 9437 
 9438 instruct cmpN_null_branch_short(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9439   match(If cmp (CmpN op1 null));
 9440   predicate(UseCBCond);
 9441   effect(USE labl, KILL icc);
 9442 
 9443   size(4); // Assuming no NOP inserted.
 9444   ins_cost(BRANCH_COST);
 9445   format %{ &quot;CWB$cmp  $op1,0,$labl\t! compressed ptr&quot; %}
 9446   ins_encode %{
 9447     Label* L = $labl$$label;
 9448     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9449     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, G0, *L);
 9450   %}
 9451   ins_short_branch(1);
 9452   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9453   ins_pipe(cbcond_reg_reg);
 9454 %}
 9455 
 9456 // Loop back branch
 9457 instruct cmpI_reg_branchLoopEnd_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9458   match(CountedLoopEnd cmp (CmpI op1 op2));
 9459   predicate(UseCBCond);
 9460   effect(USE labl, KILL icc);
 9461 
 9462   size(4); // Assuming no NOP inserted.
 9463   ins_cost(BRANCH_COST);
 9464   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9465   ins_encode %{
 9466     Label* L = $labl$$label;
 9467     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9468     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9469   %}
 9470   ins_short_branch(1);
 9471   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9472   ins_pipe(cbcond_reg_reg);
 9473 %}
 9474 
 9475 instruct cmpI_imm_branchLoopEnd_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9476   match(CountedLoopEnd cmp (CmpI op1 op2));
 9477   predicate(UseCBCond);
 9478   effect(USE labl, KILL icc);
 9479 
 9480   size(4); // Assuming no NOP inserted.
 9481   ins_cost(BRANCH_COST);
 9482   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9483   ins_encode %{
 9484     Label* L = $labl$$label;
 9485     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9486     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9487   %}
 9488   ins_short_branch(1);
 9489   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9490   ins_pipe(cbcond_reg_imm);
 9491 %}
 9492 
 9493 // Branch-on-register tests all 64 bits.  We assume that values
 9494 // in 64-bit registers always remains zero or sign extended
 9495 // unless our code munges the high bits.  Interrupts can chop
 9496 // the high order bits to zero or sign at any time.
 9497 instruct branchCon_regI(cmpOp_reg cmp, iRegI op1, immI0 zero, label labl) %{
 9498   match(If cmp (CmpI op1 zero));
 9499   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9500   effect(USE labl);
 9501 
 9502   size(8);
 9503   ins_cost(BRANCH_COST);
 9504   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9505   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9506   ins_avoid_back_to_back(AVOID_BEFORE);
 9507   ins_pipe(br_reg);
 9508 %}
 9509 
 9510 instruct branchCon_regP(cmpOp_reg cmp, iRegP op1, immP0 null, label labl) %{
 9511   match(If cmp (CmpP op1 null));
 9512   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9513   effect(USE labl);
 9514 
 9515   size(8);
 9516   ins_cost(BRANCH_COST);
 9517   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9518   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9519   ins_avoid_back_to_back(AVOID_BEFORE);
 9520   ins_pipe(br_reg);
 9521 %}
 9522 
 9523 instruct branchCon_regL(cmpOp_reg cmp, iRegL op1, immL0 zero, label labl) %{
 9524   match(If cmp (CmpL op1 zero));
 9525   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9526   effect(USE labl);
 9527 
 9528   size(8);
 9529   ins_cost(BRANCH_COST);
 9530   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9531   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9532   ins_avoid_back_to_back(AVOID_BEFORE);
 9533   ins_pipe(br_reg);
 9534 %}
 9535 
 9536 
 9537 // ============================================================================
 9538 // Long Compare
 9539 //
 9540 // Currently we hold longs in 2 registers.  Comparing such values efficiently
 9541 // is tricky.  The flavor of compare used depends on whether we are testing
 9542 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
 9543 // The GE test is the negated LT test.  The LE test can be had by commuting
 9544 // the operands (yielding a GE test) and then negating; negate again for the
 9545 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
 9546 // NE test is negated from that.
 9547 
 9548 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9549 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
 9550 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
 9551 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
 9552 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9553 // foo match ends up with the wrong leaf.  One fix is to not match both
 9554 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
 9555 // both forms beat the trinary form of long-compare and both are very useful
 9556 // on Intel which has so few registers.
 9557 
 9558 instruct branchCon_long(cmpOp cmp, flagsRegL xcc, label labl) %{
 9559   match(If cmp xcc);
 9560   effect(USE labl);
 9561 
 9562   size(8);
 9563   ins_cost(BRANCH_COST);
 9564   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9565   ins_encode %{
 9566     Label* L = $labl$$label;
 9567     Assembler::Predict predict_taken =
 9568       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9569 
 9570     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9571     __ delayed()-&gt;nop();
 9572   %}
 9573   ins_avoid_back_to_back(AVOID_BEFORE);
 9574   ins_pipe(br_cc);
 9575 %}
 9576 
 9577 instruct branchConU_long(cmpOpU cmp, flagsRegUL xcc, label labl) %{
 9578   match(If cmp xcc);
 9579   effect(USE labl);
 9580 
 9581   size(8);
 9582   ins_cost(BRANCH_COST);
 9583   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9584   ins_encode %{
 9585     Label* L = $labl$$label;
 9586     Assembler::Predict predict_taken =
 9587       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9588 
 9589     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9590     __ delayed()-&gt;nop();
 9591   %}
 9592   ins_avoid_back_to_back(AVOID_BEFORE);
 9593   ins_pipe(br_cc);
 9594 %}
 9595 
 9596 // Manifest a CmpL3 result in an integer register.  Very painful.
 9597 // This is the test to avoid.
 9598 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg ccr ) %{
 9599   match(Set dst (CmpL3 src1 src2) );
 9600   effect( KILL ccr );
 9601   ins_cost(6*DEFAULT_COST);
 9602   size(24);
 9603   format %{ &quot;CMP    $src1,$src2\t\t! long\n&quot;
 9604           &quot;\tBLT,a,pn done\n&quot;
 9605           &quot;\tMOV    -1,$dst\t! delay slot\n&quot;
 9606           &quot;\tBGT,a,pn done\n&quot;
 9607           &quot;\tMOV    1,$dst\t! delay slot\n&quot;
 9608           &quot;\tCLR    $dst\n&quot;
 9609     &quot;done:&quot;     %}
 9610   ins_encode( cmpl_flag(src1,src2,dst) );
 9611   ins_pipe(cmpL_reg);
 9612 %}
 9613 
 9614 // Conditional move
 9615 instruct cmovLL_reg(cmpOp cmp, flagsRegL xcc, iRegL dst, iRegL src) %{
 9616   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9617   ins_cost(150);
 9618   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9619   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9620   ins_pipe(ialu_reg);
 9621 %}
 9622 
 9623 instruct cmovLL_imm(cmpOp cmp, flagsRegL xcc, iRegL dst, immL0 src) %{
 9624   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9625   ins_cost(140);
 9626   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9627   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9628   ins_pipe(ialu_imm);
 9629 %}
 9630 
 9631 instruct cmovIL_reg(cmpOp cmp, flagsRegL xcc, iRegI dst, iRegI src) %{
 9632   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9633   ins_cost(150);
 9634   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9635   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9636   ins_pipe(ialu_reg);
 9637 %}
 9638 
 9639 instruct cmovIL_imm(cmpOp cmp, flagsRegL xcc, iRegI dst, immI11 src) %{
 9640   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9641   ins_cost(140);
 9642   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9643   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9644   ins_pipe(ialu_imm);
 9645 %}
 9646 
 9647 instruct cmovNL_reg(cmpOp cmp, flagsRegL xcc, iRegN dst, iRegN src) %{
 9648   match(Set dst (CMoveN (Binary cmp xcc) (Binary dst src)));
 9649   ins_cost(150);
 9650   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9651   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9652   ins_pipe(ialu_reg);
 9653 %}
 9654 
 9655 instruct cmovPL_reg(cmpOp cmp, flagsRegL xcc, iRegP dst, iRegP src) %{
 9656   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9657   ins_cost(150);
 9658   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9659   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9660   ins_pipe(ialu_reg);
 9661 %}
 9662 
 9663 instruct cmovPL_imm(cmpOp cmp, flagsRegL xcc, iRegP dst, immP0 src) %{
 9664   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9665   ins_cost(140);
 9666   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9667   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9668   ins_pipe(ialu_imm);
 9669 %}
 9670 
 9671 instruct cmovFL_reg(cmpOp cmp, flagsRegL xcc, regF dst, regF src) %{
 9672   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 9673   ins_cost(150);
 9674   opcode(0x101);
 9675   format %{ &quot;FMOVS$cmp $xcc,$src,$dst&quot; %}
 9676   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9677   ins_pipe(int_conditional_float_move);
 9678 %}
 9679 
 9680 instruct cmovDL_reg(cmpOp cmp, flagsRegL xcc, regD dst, regD src) %{
 9681   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 9682   ins_cost(150);
 9683   opcode(0x102);
 9684   format %{ &quot;FMOVD$cmp $xcc,$src,$dst&quot; %}
 9685   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9686   ins_pipe(int_conditional_float_move);
 9687 %}
 9688 
 9689 // ============================================================================
 9690 // Safepoint Instruction
 9691 instruct safePoint_poll(iRegP poll) %{
 9692   match(SafePoint poll);
 9693   effect(USE poll);
 9694 
 9695   size(4);
 9696   format %{ &quot;LDX    [$poll],R_G0\t! Safepoint: poll for GC&quot; %}
 9697   ins_encode %{
 9698     __ relocate(relocInfo::poll_type);
 9699     __ ld_ptr($poll$$Register, 0, G0);
 9700   %}
 9701   ins_pipe(loadPollP);
 9702 %}
 9703 
 9704 // ============================================================================
 9705 // Call Instructions
 9706 // Call Java Static Instruction
 9707 instruct CallStaticJavaDirect( method meth ) %{
 9708   match(CallStaticJava);
 9709   predicate(! ((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9710   effect(USE meth);
 9711 
 9712   size(8);
 9713   ins_cost(CALL_COST);
 9714   format %{ &quot;CALL,static  ; NOP ==&gt; &quot; %}
 9715   ins_encode( Java_Static_Call( meth ), call_epilog );
 9716   ins_avoid_back_to_back(AVOID_BEFORE);
 9717   ins_pipe(simple_call);
 9718 %}
 9719 
 9720 // Call Java Static Instruction (method handle version)
 9721 instruct CallStaticJavaHandle(method meth, l7RegP l7_mh_SP_save) %{
 9722   match(CallStaticJava);
 9723   predicate(((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9724   effect(USE meth, KILL l7_mh_SP_save);
 9725 
 9726   size(16);
 9727   ins_cost(CALL_COST);
 9728   format %{ &quot;CALL,static/MethodHandle&quot; %}
 9729   ins_encode(preserve_SP, Java_Static_Call(meth), restore_SP, call_epilog);
 9730   ins_pipe(simple_call);
 9731 %}
 9732 
 9733 // Call Java Dynamic Instruction
 9734 instruct CallDynamicJavaDirect( method meth ) %{
 9735   match(CallDynamicJava);
 9736   effect(USE meth);
 9737 
 9738   ins_cost(CALL_COST);
 9739   format %{ &quot;SET    (empty),R_G5\n\t&quot;
 9740             &quot;CALL,dynamic  ; NOP ==&gt; &quot; %}
 9741   ins_encode( Java_Dynamic_Call( meth ), call_epilog );
 9742   ins_pipe(call);
 9743 %}
 9744 
 9745 // Call Runtime Instruction
 9746 instruct CallRuntimeDirect(method meth, l7RegP l7) %{
 9747   match(CallRuntime);
 9748   effect(USE meth, KILL l7);
 9749   ins_cost(CALL_COST);
 9750   format %{ &quot;CALL,runtime&quot; %}
 9751   ins_encode( Java_To_Runtime( meth ),
 9752               call_epilog, adjust_long_from_native_call );
 9753   ins_avoid_back_to_back(AVOID_BEFORE);
 9754   ins_pipe(simple_call);
 9755 %}
 9756 
 9757 // Call runtime without safepoint - same as CallRuntime
 9758 instruct CallLeafDirect(method meth, l7RegP l7) %{
 9759   match(CallLeaf);
 9760   effect(USE meth, KILL l7);
 9761   ins_cost(CALL_COST);
 9762   format %{ &quot;CALL,runtime leaf&quot; %}
 9763   ins_encode( Java_To_Runtime( meth ),
 9764               call_epilog,
 9765               adjust_long_from_native_call );
 9766   ins_avoid_back_to_back(AVOID_BEFORE);
 9767   ins_pipe(simple_call);
 9768 %}
 9769 
 9770 // Call runtime without safepoint - same as CallLeaf
 9771 instruct CallLeafNoFPDirect(method meth, l7RegP l7) %{
 9772   match(CallLeafNoFP);
 9773   effect(USE meth, KILL l7);
 9774   ins_cost(CALL_COST);
 9775   format %{ &quot;CALL,runtime leaf nofp&quot; %}
 9776   ins_encode( Java_To_Runtime( meth ),
 9777               call_epilog,
 9778               adjust_long_from_native_call );
 9779   ins_avoid_back_to_back(AVOID_BEFORE);
 9780   ins_pipe(simple_call);
 9781 %}
 9782 
 9783 // Tail Call; Jump from runtime stub to Java code.
 9784 // Also known as an &#39;interprocedural jump&#39;.
 9785 // Target of jump will eventually return to caller.
 9786 // TailJump below removes the return address.
 9787 instruct TailCalljmpInd(g3RegP jump_target, inline_cache_regP method_oop) %{
 9788   match(TailCall jump_target method_oop );
 9789 
 9790   ins_cost(CALL_COST);
 9791   format %{ &quot;Jmp     $jump_target  ; NOP \t! $method_oop holds method oop&quot; %}
 9792   ins_encode(form_jmpl(jump_target));
 9793   ins_avoid_back_to_back(AVOID_BEFORE);
 9794   ins_pipe(tail_call);
 9795 %}
 9796 
 9797 
 9798 // Return Instruction
 9799 instruct Ret() %{
 9800   match(Return);
 9801 
 9802   // The epilogue node did the ret already.
 9803   size(0);
 9804   format %{ &quot;! return&quot; %}
 9805   ins_encode();
 9806   ins_pipe(empty);
 9807 %}
 9808 
 9809 
 9810 // Tail Jump; remove the return address; jump to target.
 9811 // TailCall above leaves the return address around.
 9812 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9813 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9814 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9815 // in %i0.
 9816 instruct tailjmpInd(g1RegP jump_target, i0RegP ex_oop) %{
 9817   match( TailJump jump_target ex_oop );
 9818   ins_cost(CALL_COST);
 9819   format %{ &quot;! discard R_O7\n\t&quot;
 9820             &quot;Jmp     $jump_target  ; ADD O7,8,O1 \t! $ex_oop holds exc. oop&quot; %}
 9821   ins_encode(form_jmpl_set_exception_pc(jump_target));
 9822   // opcode(Assembler::jmpl_op3, Assembler::arith_op);
 9823   // The hack duplicates the exception oop into G3, so that CreateEx can use it there.
 9824   // ins_encode( form3_rs1_simm13_rd( jump_target, 0x00, R_G0 ), move_return_pc_to_o1() );
 9825   ins_avoid_back_to_back(AVOID_BEFORE);
 9826   ins_pipe(tail_call);
 9827 %}
 9828 
 9829 // Create exception oop: created by stack-crawling runtime code.
 9830 // Created exception is now available to this handler, and is setup
 9831 // just prior to jumping to this handler.  No code emitted.
 9832 instruct CreateException( o0RegP ex_oop )
 9833 %{
 9834   match(Set ex_oop (CreateEx));
 9835   ins_cost(0);
 9836 
 9837   size(0);
 9838   // use the following format syntax
 9839   format %{ &quot;! exception oop is in R_O0; no code emitted&quot; %}
 9840   ins_encode();
 9841   ins_pipe(empty);
 9842 %}
 9843 
 9844 
 9845 // Rethrow exception:
 9846 // The exception oop will come in the first argument position.
 9847 // Then JUMP (not call) to the rethrow stub code.
 9848 instruct RethrowException()
 9849 %{
 9850   match(Rethrow);
 9851   ins_cost(CALL_COST);
 9852 
 9853   // use the following format syntax
 9854   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9855   ins_encode(enc_rethrow);
 9856   ins_avoid_back_to_back(AVOID_BEFORE);
 9857   ins_pipe(tail_call);
 9858 %}
 9859 
 9860 
 9861 // Die now
 9862 instruct ShouldNotReachHere( )
 9863 %{
 9864   match(Halt);
 9865   ins_cost(CALL_COST);
 9866 
 9867   size(4);
 9868   // Use the following format syntax
 9869   format %{ &quot;ILLTRAP   ; ShouldNotReachHere&quot; %}
 9870   ins_encode( form2_illtrap() );
 9871   ins_pipe(tail_call);
 9872 %}
 9873 
 9874 // ============================================================================
 9875 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
 9876 // array for an instance of the superklass.  Set a hidden internal cache on a
 9877 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
 9878 // not zero for a miss or zero for a hit.  The encoding ALSO sets flags.
 9879 instruct partialSubtypeCheck( o0RegP index, o1RegP sub, o2RegP super, flagsRegP pcc, o7RegP o7 ) %{
 9880   match(Set index (PartialSubtypeCheck sub super));
 9881   effect( KILL pcc, KILL o7 );
 9882   ins_cost(DEFAULT_COST*10);
 9883   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP&quot; %}
 9884   ins_encode( enc_PartialSubtypeCheck() );
 9885   ins_avoid_back_to_back(AVOID_BEFORE);
 9886   ins_pipe(partial_subtype_check_pipe);
 9887 %}
 9888 
 9889 instruct partialSubtypeCheck_vs_zero( flagsRegP pcc, o1RegP sub, o2RegP super, immP0 zero, o0RegP idx, o7RegP o7 ) %{
 9890   match(Set pcc (CmpP (PartialSubtypeCheck sub super) zero));
 9891   effect( KILL idx, KILL o7 );
 9892   ins_cost(DEFAULT_COST*10);
 9893   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP\t# (sets condition codes)&quot; %}
 9894   ins_encode( enc_PartialSubtypeCheck() );
 9895   ins_avoid_back_to_back(AVOID_BEFORE);
 9896   ins_pipe(partial_subtype_check_pipe);
 9897 %}
 9898 
 9899 
 9900 // ============================================================================
 9901 // inlined locking and unlocking
 9902 
 9903 instruct cmpFastLock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9904   match(Set pcc (FastLock object box));
 9905 
 9906   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9907   ins_cost(100);
 9908 
 9909   format %{ &quot;FASTLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9910   ins_encode( Fast_Lock(object, box, scratch, scratch2) );
 9911   ins_pipe(long_memory_op);
 9912 %}
 9913 
 9914 
 9915 instruct cmpFastUnlock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9916   match(Set pcc (FastUnlock object box));
 9917   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9918   ins_cost(100);
 9919 
 9920   format %{ &quot;FASTUNLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9921   ins_encode( Fast_Unlock(object, box, scratch, scratch2) );
 9922   ins_pipe(long_memory_op);
 9923 %}
 9924 
 9925 // The encodings are generic.
 9926 instruct clear_array(iRegX cnt, iRegP base, iRegX temp, Universe dummy, flagsReg ccr) %{
 9927   predicate(!use_block_zeroing(n-&gt;in(2)) );
 9928   match(Set dummy (ClearArray cnt base));
 9929   effect(TEMP temp, KILL ccr);
 9930   ins_cost(300);
 9931   format %{ &quot;MOV    $cnt,$temp\n&quot;
 9932     &quot;loop:   SUBcc  $temp,8,$temp\t! Count down a dword of bytes\n&quot;
 9933     &quot;        BRge   loop\t\t! Clearing loop\n&quot;
 9934     &quot;        STX    G0,[$base+$temp]\t! delay slot&quot; %}
 9935 
 9936   ins_encode %{
 9937     // Compiler ensures base is doubleword aligned and cnt is count of doublewords
 9938     Register nof_bytes_arg    = $cnt$$Register;
 9939     Register nof_bytes_tmp    = $temp$$Register;
 9940     Register base_pointer_arg = $base$$Register;
 9941 
 9942     Label loop;
 9943     __ mov(nof_bytes_arg, nof_bytes_tmp);
 9944 
 9945     // Loop and clear, walking backwards through the array.
 9946     // nof_bytes_tmp (if &gt;0) is always the number of bytes to zero
 9947     __ bind(loop);
 9948     __ deccc(nof_bytes_tmp, 8);
 9949     __ br(Assembler::greaterEqual, true, Assembler::pt, loop);
 9950     __ delayed()-&gt; stx(G0, base_pointer_arg, nof_bytes_tmp);
 9951     // %%%% this mini-loop must not cross a cache boundary!
 9952   %}
 9953   ins_pipe(long_memory_op);
 9954 %}
 9955 
 9956 instruct clear_array_bis(g1RegX cnt, o0RegP base, Universe dummy, flagsReg ccr) %{
 9957   predicate(use_block_zeroing(n-&gt;in(2)));
 9958   match(Set dummy (ClearArray cnt base));
 9959   effect(USE_KILL cnt, USE_KILL base, KILL ccr);
 9960   ins_cost(300);
 9961   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9962 
 9963   ins_encode %{
 9964 
 9965     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
 9966     Register to    = $base$$Register;
 9967     Register count = $cnt$$Register;
 9968 
 9969     Label Ldone;
 9970     __ nop(); // Separate short branches
 9971     // Use BIS for zeroing (temp is not used).
 9972     __ bis_zeroing(to, count, G0, Ldone);
 9973     __ bind(Ldone);
 9974 
 9975   %}
 9976   ins_pipe(long_memory_op);
 9977 %}
 9978 
 9979 instruct clear_array_bis_2(g1RegX cnt, o0RegP base, iRegX tmp, Universe dummy, flagsReg ccr) %{
 9980   predicate(use_block_zeroing(n-&gt;in(2)) &amp;&amp; !Assembler::is_simm13((int)BlockZeroingLowLimit));
 9981   match(Set dummy (ClearArray cnt base));
 9982   effect(TEMP tmp, USE_KILL cnt, USE_KILL base, KILL ccr);
 9983   ins_cost(300);
 9984   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9985 
 9986   ins_encode %{
 9987 
 9988     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
 9989     Register to    = $base$$Register;
 9990     Register count = $cnt$$Register;
 9991     Register temp  = $tmp$$Register;
 9992 
 9993     Label Ldone;
 9994     __ nop(); // Separate short branches
 9995     // Use BIS for zeroing
 9996     __ bis_zeroing(to, count, temp, Ldone);
 9997     __ bind(Ldone);
 9998 
 9999   %}
10000   ins_pipe(long_memory_op);
10001 %}
10002 
10003 instruct string_compareL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10004                          o7RegI tmp, flagsReg ccr) %{
10005   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10006   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10007   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10008   ins_cost(300);
10009   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10010   ins_encode %{
10011     __ string_compare($str1$$Register, $str2$$Register,
10012                       $cnt1$$Register, $cnt2$$Register,
10013                       $tmp$$Register, $tmp$$Register,
10014                       $result$$Register, StrIntrinsicNode::LL);
10015   %}
10016   ins_pipe(long_memory_op);
10017 %}
10018 
10019 instruct string_compareU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10020                          o7RegI tmp, flagsReg ccr) %{
10021   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10022   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10023   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10024   ins_cost(300);
10025   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10026   ins_encode %{
10027     __ string_compare($str1$$Register, $str2$$Register,
10028                       $cnt1$$Register, $cnt2$$Register,
10029                       $tmp$$Register, $tmp$$Register,
10030                       $result$$Register, StrIntrinsicNode::UU);
10031   %}
10032   ins_pipe(long_memory_op);
10033 %}
10034 
10035 instruct string_compareLU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10036                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10037   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10038   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10039   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10040   ins_cost(300);
10041   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10042   ins_encode %{
10043     __ string_compare($str1$$Register, $str2$$Register,
10044                       $cnt1$$Register, $cnt2$$Register,
10045                       $tmp1$$Register, $tmp2$$Register,
10046                       $result$$Register, StrIntrinsicNode::LU);
10047   %}
10048   ins_pipe(long_memory_op);
10049 %}
10050 
10051 instruct string_compareUL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10052                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10053   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10054   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10055   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10056   ins_cost(300);
10057   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10058   ins_encode %{
10059     __ string_compare($str2$$Register, $str1$$Register,
10060                       $cnt2$$Register, $cnt1$$Register,
10061                       $tmp1$$Register, $tmp2$$Register,
10062                       $result$$Register, StrIntrinsicNode::UL);
10063   %}
10064   ins_pipe(long_memory_op);
10065 %}
10066 
10067 instruct string_equalsL(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10068                         o7RegI tmp, flagsReg ccr) %{
10069   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10070   match(Set result (StrEquals (Binary str1 str2) cnt));
10071   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10072   ins_cost(300);
10073   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10074   ins_encode %{
10075     __ array_equals(false, $str1$$Register, $str2$$Register,
10076                     $cnt$$Register, $tmp$$Register,
10077                     $result$$Register, true /* byte */);
10078   %}
10079   ins_pipe(long_memory_op);
10080 %}
10081 
10082 instruct string_equalsU(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10083                         o7RegI tmp, flagsReg ccr) %{
10084   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10085   match(Set result (StrEquals (Binary str1 str2) cnt));
10086   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10087   ins_cost(300);
10088   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10089   ins_encode %{
10090     __ array_equals(false, $str1$$Register, $str2$$Register,
10091                     $cnt$$Register, $tmp$$Register,
10092                     $result$$Register, false /* byte */);
10093   %}
10094   ins_pipe(long_memory_op);
10095 %}
10096 
10097 instruct array_equalsB(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10098                        o7RegI tmp2, flagsReg ccr) %{
10099   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10100   match(Set result (AryEq ary1 ary2));
10101   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10102   ins_cost(300);
10103   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10104   ins_encode %{
10105     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10106                     $tmp1$$Register, $tmp2$$Register,
10107                     $result$$Register, true /* byte */);
10108   %}
10109   ins_pipe(long_memory_op);
10110 %}
10111 
10112 instruct array_equalsC(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10113                        o7RegI tmp2, flagsReg ccr) %{
10114   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10115   match(Set result (AryEq ary1 ary2));
10116   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10117   ins_cost(300);
10118   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10119   ins_encode %{
10120     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10121                     $tmp1$$Register, $tmp2$$Register,
10122                     $result$$Register, false /* byte */);
10123   %}
10124   ins_pipe(long_memory_op);
10125 %}
10126 
10127 instruct has_negatives(o0RegP pAryR, g3RegI iSizeR, notemp_iRegI resultR,
10128                        iRegL tmp1L, iRegL tmp2L, iRegL tmp3L, iRegL tmp4L,
10129                        flagsReg ccr)
10130 %{
10131   match(Set resultR (HasNegatives pAryR iSizeR));
10132   effect(TEMP resultR, TEMP tmp1L, TEMP tmp2L, TEMP tmp3L, TEMP tmp4L, USE pAryR, USE iSizeR, KILL ccr);
10133   format %{ &quot;has negatives byte[] $pAryR,$iSizeR -&gt; $resultR // KILL $tmp1L,$tmp2L,$tmp3L,$tmp4L&quot; %}
10134   ins_encode %{
10135     __ has_negatives($pAryR$$Register, $iSizeR$$Register,
10136                      $resultR$$Register,
10137                      $tmp1L$$Register, $tmp2L$$Register,
10138                      $tmp3L$$Register, $tmp4L$$Register);
10139   %}
10140   ins_pipe(long_memory_op);
10141 %}
10142 
10143 // char[] to byte[] compression
10144 instruct string_compress(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result, iRegL tmp, flagsReg ccr) %{
10145   predicate(UseVIS &lt; 3);
10146   match(Set result (StrCompressedCopy src (Binary dst len)));
10147   effect(TEMP result, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10148   ins_cost(300);
10149   format %{ &quot;String Compress $src,$dst,$len -&gt; $result    // KILL $tmp&quot; %}
10150   ins_encode %{
10151     Label Ldone;
10152     __ signx($len$$Register);
10153     __ cmp_zero_and_br(Assembler::zero, $len$$Register, Ldone, false, Assembler::pn);
10154     __ delayed()-&gt;mov($len$$Register, $result$$Register); // copy count
10155     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp$$Register, Ldone);
10156     __ bind(Ldone);
10157   %}
10158   ins_pipe(long_memory_op);
10159 %}
10160 
10161 // fast char[] to byte[] compression using VIS instructions
10162 instruct string_compress_fast(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result,
10163                               iRegL tmp1, iRegL tmp2, iRegL tmp3, iRegL tmp4,
10164                               regD ftmp1, regD ftmp2, regD ftmp3, flagsReg ccr) %{
10165   predicate(UseVIS &gt;= 3);
10166   match(Set result (StrCompressedCopy src (Binary dst len)));
10167   effect(TEMP result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10168   ins_cost(300);
10169   format %{ &quot;String Compress Fast $src,$dst,$len -&gt; $result    // KILL $tmp1,$tmp2,$tmp3,$tmp4,$ftmp1,$ftmp2,$ftmp3&quot; %}
10170   ins_encode %{
10171     Label Ldone;
10172     __ signx($len$$Register);
10173     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $result$$Register,
10174                           $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register,
10175                           $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, Ldone);
10176     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10177     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp1$$Register, Ldone);
10178     __ bind(Ldone);
10179   %}
10180   ins_pipe(long_memory_op);
10181 %}
10182 
10183 // byte[] to char[] inflation
10184 instruct string_inflate(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10185                         iRegL tmp, flagsReg ccr) %{
10186   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10187   effect(TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10188   ins_cost(300);
10189   format %{ &quot;String Inflate $src,$dst,$len    // KILL $tmp&quot; %}
10190   ins_encode %{
10191     Label Ldone;
10192     __ signx($len$$Register);
10193     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10194     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10195     __ bind(Ldone);
10196   %}
10197   ins_pipe(long_memory_op);
10198 %}
10199 
10200 // fast byte[] to char[] inflation using VIS instructions
10201 instruct string_inflate_fast(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10202                              iRegL tmp, regD ftmp1, regD ftmp2, regD ftmp3, regD ftmp4, flagsReg ccr) %{
10203   predicate(UseVIS &gt;= 3);
10204   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10205   effect(TEMP tmp, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, TEMP ftmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10206   ins_cost(300);
10207   format %{ &quot;String Inflate Fast $src,$dst,$len    // KILL $tmp,$ftmp1,$ftmp2,$ftmp3,$ftmp4&quot; %}
10208   ins_encode %{
10209     Label Ldone;
10210     __ signx($len$$Register);
10211     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register,
10212                          $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, $ftmp4$$FloatRegister, Ldone);
10213     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10214     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10215     __ bind(Ldone);
10216   %}
10217   ins_pipe(long_memory_op);
10218 %}
10219 
10220 
10221 //---------- Zeros Count Instructions ------------------------------------------
10222 
10223 instruct countLeadingZerosI(iRegIsafe dst, iRegI src, iRegI tmp, flagsReg cr) %{
10224   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10225   match(Set dst (CountLeadingZerosI src));
10226   effect(TEMP dst, TEMP tmp, KILL cr);
10227 
10228   // x |= (x &gt;&gt; 1);
10229   // x |= (x &gt;&gt; 2);
10230   // x |= (x &gt;&gt; 4);
10231   // x |= (x &gt;&gt; 8);
10232   // x |= (x &gt;&gt; 16);
10233   // return (WORDBITS - popc(x));
10234   format %{ &quot;SRL     $src,1,$tmp\t! count leading zeros (int)\n\t&quot;
10235             &quot;SRL     $src,0,$dst\t! 32-bit zero extend\n\t&quot;
10236             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10237             &quot;SRL     $dst,2,$tmp\n\t&quot;
10238             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10239             &quot;SRL     $dst,4,$tmp\n\t&quot;
10240             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10241             &quot;SRL     $dst,8,$tmp\n\t&quot;
10242             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10243             &quot;SRL     $dst,16,$tmp\n\t&quot;
10244             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10245             &quot;POPC    $dst,$dst\n\t&quot;
10246             &quot;MOV     32,$tmp\n\t&quot;
10247             &quot;SUB     $tmp,$dst,$dst&quot; %}
10248   ins_encode %{
10249     Register Rdst = $dst$$Register;
10250     Register Rsrc = $src$$Register;
10251     Register Rtmp = $tmp$$Register;
10252     __ srl(Rsrc, 1,    Rtmp);
10253     __ srl(Rsrc, 0,    Rdst);
10254     __ or3(Rdst, Rtmp, Rdst);
10255     __ srl(Rdst, 2,    Rtmp);
10256     __ or3(Rdst, Rtmp, Rdst);
10257     __ srl(Rdst, 4,    Rtmp);
10258     __ or3(Rdst, Rtmp, Rdst);
10259     __ srl(Rdst, 8,    Rtmp);
10260     __ or3(Rdst, Rtmp, Rdst);
10261     __ srl(Rdst, 16,   Rtmp);
10262     __ or3(Rdst, Rtmp, Rdst);
10263     __ popc(Rdst, Rdst);
10264     __ mov(BitsPerInt, Rtmp);
10265     __ sub(Rtmp, Rdst, Rdst);
10266   %}
10267   ins_pipe(ialu_reg);
10268 %}
10269 
10270 instruct countLeadingZerosL(iRegIsafe dst, iRegL src, iRegL tmp, flagsReg cr) %{
10271   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10272   match(Set dst (CountLeadingZerosL src));
10273   effect(TEMP dst, TEMP tmp, KILL cr);
10274 
10275   // x |= (x &gt;&gt; 1);
10276   // x |= (x &gt;&gt; 2);
10277   // x |= (x &gt;&gt; 4);
10278   // x |= (x &gt;&gt; 8);
10279   // x |= (x &gt;&gt; 16);
10280   // x |= (x &gt;&gt; 32);
10281   // return (WORDBITS - popc(x));
10282   format %{ &quot;SRLX    $src,1,$tmp\t! count leading zeros (long)\n\t&quot;
10283             &quot;OR      $src,$tmp,$dst\n\t&quot;
10284             &quot;SRLX    $dst,2,$tmp\n\t&quot;
10285             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10286             &quot;SRLX    $dst,4,$tmp\n\t&quot;
10287             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10288             &quot;SRLX    $dst,8,$tmp\n\t&quot;
10289             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10290             &quot;SRLX    $dst,16,$tmp\n\t&quot;
10291             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10292             &quot;SRLX    $dst,32,$tmp\n\t&quot;
10293             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10294             &quot;POPC    $dst,$dst\n\t&quot;
10295             &quot;MOV     64,$tmp\n\t&quot;
10296             &quot;SUB     $tmp,$dst,$dst&quot; %}
10297   ins_encode %{
10298     Register Rdst = $dst$$Register;
10299     Register Rsrc = $src$$Register;
10300     Register Rtmp = $tmp$$Register;
10301     __ srlx(Rsrc, 1,    Rtmp);
10302     __ or3( Rsrc, Rtmp, Rdst);
10303     __ srlx(Rdst, 2,    Rtmp);
10304     __ or3( Rdst, Rtmp, Rdst);
10305     __ srlx(Rdst, 4,    Rtmp);
10306     __ or3( Rdst, Rtmp, Rdst);
10307     __ srlx(Rdst, 8,    Rtmp);
10308     __ or3( Rdst, Rtmp, Rdst);
10309     __ srlx(Rdst, 16,   Rtmp);
10310     __ or3( Rdst, Rtmp, Rdst);
10311     __ srlx(Rdst, 32,   Rtmp);
10312     __ or3( Rdst, Rtmp, Rdst);
10313     __ popc(Rdst, Rdst);
10314     __ mov(BitsPerLong, Rtmp);
10315     __ sub(Rtmp, Rdst, Rdst);
10316   %}
10317   ins_pipe(ialu_reg);
10318 %}
10319 
10320 instruct countTrailingZerosI(iRegIsafe dst, iRegI src, flagsReg cr) %{
10321   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10322   match(Set dst (CountTrailingZerosI src));
10323   effect(TEMP dst, KILL cr);
10324 
10325   // return popc(~x &amp; (x - 1));
10326   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (int)\n\t&quot;
10327             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10328             &quot;SRL     $dst,R_G0,$dst\n\t&quot;
10329             &quot;POPC    $dst,$dst&quot; %}
10330   ins_encode %{
10331     Register Rdst = $dst$$Register;
10332     Register Rsrc = $src$$Register;
10333     __ sub(Rsrc, 1, Rdst);
10334     __ andn(Rdst, Rsrc, Rdst);
10335     __ srl(Rdst, G0, Rdst);
10336     __ popc(Rdst, Rdst);
10337   %}
10338   ins_pipe(ialu_reg);
10339 %}
10340 
10341 instruct countTrailingZerosL(iRegIsafe dst, iRegL src, flagsReg cr) %{
10342   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10343   match(Set dst (CountTrailingZerosL src));
10344   effect(TEMP dst, KILL cr);
10345 
10346   // return popc(~x &amp; (x - 1));
10347   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (long)\n\t&quot;
10348             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10349             &quot;POPC    $dst,$dst&quot; %}
10350   ins_encode %{
10351     Register Rdst = $dst$$Register;
10352     Register Rsrc = $src$$Register;
10353     __ sub(Rsrc, 1, Rdst);
10354     __ andn(Rdst, Rsrc, Rdst);
10355     __ popc(Rdst, Rdst);
10356   %}
10357   ins_pipe(ialu_reg);
10358 %}
10359 
10360 
10361 //---------- Population Count Instructions -------------------------------------
10362 
10363 instruct popCountI(iRegIsafe dst, iRegI src) %{
10364   predicate(UsePopCountInstruction);
10365   match(Set dst (PopCountI src));
10366 
10367   format %{ &quot;SRL    $src, G0, $dst\t! clear upper word for 64 bit POPC\n\t&quot;
10368             &quot;POPC   $dst, $dst&quot; %}
10369   ins_encode %{
10370     __ srl($src$$Register, G0, $dst$$Register);
10371     __ popc($dst$$Register, $dst$$Register);
10372   %}
10373   ins_pipe(ialu_reg);
10374 %}
10375 
10376 // Note: Long.bitCount(long) returns an int.
10377 instruct popCountL(iRegIsafe dst, iRegL src) %{
10378   predicate(UsePopCountInstruction);
10379   match(Set dst (PopCountL src));
10380 
10381   format %{ &quot;POPC   $src, $dst&quot; %}
10382   ins_encode %{
10383     __ popc($src$$Register, $dst$$Register);
10384   %}
10385   ins_pipe(ialu_reg);
10386 %}
10387 
10388 
10389 // ============================================================================
10390 //------------Bytes reverse--------------------------------------------------
10391 
10392 instruct bytes_reverse_int(iRegI dst, stackSlotI src) %{
10393   match(Set dst (ReverseBytesI src));
10394 
10395   // Op cost is artificially doubled to make sure that load or store
10396   // instructions are preferred over this one which requires a spill
10397   // onto a stack slot.
10398   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10399   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10400 
10401   ins_encode %{
10402     __ set($src$$disp + STACK_BIAS, O7);
10403     __ lduwa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10404   %}
10405   ins_pipe( iload_mem );
10406 %}
10407 
10408 instruct bytes_reverse_long(iRegL dst, stackSlotL src) %{
10409   match(Set dst (ReverseBytesL src));
10410 
10411   // Op cost is artificially doubled to make sure that load or store
10412   // instructions are preferred over this one which requires a spill
10413   // onto a stack slot.
10414   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10415   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10416 
10417   ins_encode %{
10418     __ set($src$$disp + STACK_BIAS, O7);
10419     __ ldxa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10420   %}
10421   ins_pipe( iload_mem );
10422 %}
10423 
10424 instruct bytes_reverse_unsigned_short(iRegI dst, stackSlotI src) %{
10425   match(Set dst (ReverseBytesUS src));
10426 
10427   // Op cost is artificially doubled to make sure that load or store
10428   // instructions are preferred over this one which requires a spill
10429   // onto a stack slot.
10430   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10431   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10432 
10433   ins_encode %{
10434     // the value was spilled as an int so bias the load
10435     __ set($src$$disp + STACK_BIAS + 2, O7);
10436     __ lduha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10437   %}
10438   ins_pipe( iload_mem );
10439 %}
10440 
10441 instruct bytes_reverse_short(iRegI dst, stackSlotI src) %{
10442   match(Set dst (ReverseBytesS src));
10443 
10444   // Op cost is artificially doubled to make sure that load or store
10445   // instructions are preferred over this one which requires a spill
10446   // onto a stack slot.
10447   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10448   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10449 
10450   ins_encode %{
10451     // the value was spilled as an int so bias the load
10452     __ set($src$$disp + STACK_BIAS + 2, O7);
10453     __ ldsha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10454   %}
10455   ins_pipe( iload_mem );
10456 %}
10457 
10458 // Load Integer reversed byte order
10459 instruct loadI_reversed(iRegI dst, indIndexMemory src) %{
10460   match(Set dst (ReverseBytesI (LoadI src)));
10461 
10462   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10463   size(4);
10464   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10465 
10466   ins_encode %{
10467     __ lduwa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10468   %}
10469   ins_pipe(iload_mem);
10470 %}
10471 
10472 // Load Long - aligned and reversed
10473 instruct loadL_reversed(iRegL dst, indIndexMemory src) %{
10474   match(Set dst (ReverseBytesL (LoadL src)));
10475 
10476   ins_cost(MEMORY_REF_COST);
10477   size(4);
10478   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10479 
10480   ins_encode %{
10481     __ ldxa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10482   %}
10483   ins_pipe(iload_mem);
10484 %}
10485 
10486 // Load unsigned short / char reversed byte order
10487 instruct loadUS_reversed(iRegI dst, indIndexMemory src) %{
10488   match(Set dst (ReverseBytesUS (LoadUS src)));
10489 
10490   ins_cost(MEMORY_REF_COST);
10491   size(4);
10492   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little&quot; %}
10493 
10494   ins_encode %{
10495     __ lduha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10496   %}
10497   ins_pipe(iload_mem);
10498 %}
10499 
10500 // Load short reversed byte order
10501 instruct loadS_reversed(iRegI dst, indIndexMemory src) %{
10502   match(Set dst (ReverseBytesS (LoadS src)));
10503 
10504   ins_cost(MEMORY_REF_COST);
10505   size(4);
10506   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little&quot; %}
10507 
10508   ins_encode %{
10509     __ ldsha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10510   %}
10511   ins_pipe(iload_mem);
10512 %}
10513 
10514 // Store Integer reversed byte order
10515 instruct storeI_reversed(indIndexMemory dst, iRegI src) %{
10516   match(Set dst (StoreI dst (ReverseBytesI src)));
10517 
10518   ins_cost(MEMORY_REF_COST);
10519   size(4);
10520   format %{ &quot;STWA   $src, $dst\t!asi=primary_little&quot; %}
10521 
10522   ins_encode %{
10523     __ stwa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10524   %}
10525   ins_pipe(istore_mem_reg);
10526 %}
10527 
10528 // Store Long reversed byte order
10529 instruct storeL_reversed(indIndexMemory dst, iRegL src) %{
10530   match(Set dst (StoreL dst (ReverseBytesL src)));
10531 
10532   ins_cost(MEMORY_REF_COST);
10533   size(4);
10534   format %{ &quot;STXA   $src, $dst\t!asi=primary_little&quot; %}
10535 
10536   ins_encode %{
10537     __ stxa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10538   %}
10539   ins_pipe(istore_mem_reg);
10540 %}
10541 
10542 // Store unsighed short/char reversed byte order
10543 instruct storeUS_reversed(indIndexMemory dst, iRegI src) %{
10544   match(Set dst (StoreC dst (ReverseBytesUS src)));
10545 
10546   ins_cost(MEMORY_REF_COST);
10547   size(4);
10548   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10549 
10550   ins_encode %{
10551     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10552   %}
10553   ins_pipe(istore_mem_reg);
10554 %}
10555 
10556 // Store short reversed byte order
10557 instruct storeS_reversed(indIndexMemory dst, iRegI src) %{
10558   match(Set dst (StoreC dst (ReverseBytesS src)));
10559 
10560   ins_cost(MEMORY_REF_COST);
10561   size(4);
10562   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10563 
10564   ins_encode %{
10565     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10566   %}
10567   ins_pipe(istore_mem_reg);
10568 %}
10569 
10570 // ====================VECTOR INSTRUCTIONS=====================================
10571 
10572 // Load Aligned Packed values into a Double Register
10573 instruct loadV8(regD dst, memory mem) %{
10574   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10575   match(Set dst (LoadVector mem));
10576   ins_cost(MEMORY_REF_COST);
10577   size(4);
10578   format %{ &quot;LDDF   $mem,$dst\t! load vector (8 bytes)&quot; %}
10579   ins_encode %{
10580     __ ldf(FloatRegisterImpl::D, $mem$$Address, as_DoubleFloatRegister($dst$$reg));
10581   %}
10582   ins_pipe(floadD_mem);
10583 %}
10584 
10585 // Store Vector in Double register to memory
10586 instruct storeV8(memory mem, regD src) %{
10587   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10588   match(Set mem (StoreVector mem src));
10589   ins_cost(MEMORY_REF_COST);
10590   size(4);
10591   format %{ &quot;STDF   $src,$mem\t! store vector (8 bytes)&quot; %}
10592   ins_encode %{
10593     __ stf(FloatRegisterImpl::D, as_DoubleFloatRegister($src$$reg), $mem$$Address);
10594   %}
10595   ins_pipe(fstoreD_mem_reg);
10596 %}
10597 
10598 // Store Zero into vector in memory
10599 instruct storeV8B_zero(memory mem, immI0 zero) %{
10600   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10601   match(Set mem (StoreVector mem (ReplicateB zero)));
10602   ins_cost(MEMORY_REF_COST);
10603   size(4);
10604   format %{ &quot;STX    $zero,$mem\t! store zero vector (8 bytes)&quot; %}
10605   ins_encode %{
10606     __ stx(G0, $mem$$Address);
10607   %}
10608   ins_pipe(fstoreD_mem_zero);
10609 %}
10610 
10611 instruct storeV4S_zero(memory mem, immI0 zero) %{
10612   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10613   match(Set mem (StoreVector mem (ReplicateS zero)));
10614   ins_cost(MEMORY_REF_COST);
10615   size(4);
10616   format %{ &quot;STX    $zero,$mem\t! store zero vector (4 shorts)&quot; %}
10617   ins_encode %{
10618     __ stx(G0, $mem$$Address);
10619   %}
10620   ins_pipe(fstoreD_mem_zero);
10621 %}
10622 
10623 instruct storeV2I_zero(memory mem, immI0 zero) %{
10624   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10625   match(Set mem (StoreVector mem (ReplicateI zero)));
10626   ins_cost(MEMORY_REF_COST);
10627   size(4);
10628   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 ints)&quot; %}
10629   ins_encode %{
10630     __ stx(G0, $mem$$Address);
10631   %}
10632   ins_pipe(fstoreD_mem_zero);
10633 %}
10634 
10635 instruct storeV2F_zero(memory mem, immF0 zero) %{
10636   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10637   match(Set mem (StoreVector mem (ReplicateF zero)));
10638   ins_cost(MEMORY_REF_COST);
10639   size(4);
10640   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 floats)&quot; %}
10641   ins_encode %{
10642     __ stx(G0, $mem$$Address);
10643   %}
10644   ins_pipe(fstoreD_mem_zero);
10645 %}
10646 
10647 // Replicate scalar to packed byte values into Double register
10648 instruct Repl8B_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10649   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &gt;= 3);
10650   match(Set dst (ReplicateB src));
10651   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10652   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10653             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10654             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10655             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10656             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10657             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10658             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10659             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10660   ins_encode %{
10661     Register Rsrc = $src$$Register;
10662     Register Rtmp = $tmp$$Register;
10663     Register Rtmp2 = $tmp2$$Register;
10664     __ sllx(Rsrc,    56, Rtmp);
10665     __ srlx(Rtmp,     8, Rtmp2);
10666     __ or3 (Rtmp, Rtmp2, Rtmp);
10667     __ srlx(Rtmp,    16, Rtmp2);
10668     __ or3 (Rtmp, Rtmp2, Rtmp);
10669     __ srlx(Rtmp,    32, Rtmp2);
10670     __ or3 (Rtmp, Rtmp2, Rtmp);
10671     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10672   %}
10673   ins_pipe(ialu_reg);
10674 %}
10675 
10676 // Replicate scalar to packed byte values into Double stack
10677 instruct Repl8B_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10678   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &lt; 3);
10679   match(Set dst (ReplicateB src));
10680   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10681   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10682             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10683             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10684             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10685             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10686             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10687             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10688             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10689   ins_encode %{
10690     Register Rsrc = $src$$Register;
10691     Register Rtmp = $tmp$$Register;
10692     Register Rtmp2 = $tmp2$$Register;
10693     __ sllx(Rsrc,    56, Rtmp);
10694     __ srlx(Rtmp,     8, Rtmp2);
10695     __ or3 (Rtmp, Rtmp2, Rtmp);
10696     __ srlx(Rtmp,    16, Rtmp2);
10697     __ or3 (Rtmp, Rtmp2, Rtmp);
10698     __ srlx(Rtmp,    32, Rtmp2);
10699     __ or3 (Rtmp, Rtmp2, Rtmp);
10700     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10701     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10702   %}
10703   ins_pipe(ialu_reg);
10704 %}
10705 
10706 // Replicate scalar constant to packed byte values in Double register
10707 instruct Repl8B_immI(regD dst, immI13 con, o7RegI tmp) %{
10708   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10709   match(Set dst (ReplicateB con));
10710   effect(KILL tmp);
10711   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl8B($con)&quot; %}
10712   ins_encode %{
10713     // XXX This is a quick fix for 6833573.
10714     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 8, 1)), $dst$$FloatRegister);
10715     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 8, 1)), $tmp$$Register);
10716     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10717   %}
10718   ins_pipe(loadConFD);
10719 %}
10720 
10721 // Replicate scalar to packed char/short values into Double register
10722 instruct Repl4S_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10723   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &gt;= 3);
10724   match(Set dst (ReplicateS src));
10725   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10726   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10727             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10728             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10729             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10730             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10731             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10732   ins_encode %{
10733     Register Rsrc = $src$$Register;
10734     Register Rtmp = $tmp$$Register;
10735     Register Rtmp2 = $tmp2$$Register;
10736     __ sllx(Rsrc,    48, Rtmp);
10737     __ srlx(Rtmp,    16, Rtmp2);
10738     __ or3 (Rtmp, Rtmp2, Rtmp);
10739     __ srlx(Rtmp,    32, Rtmp2);
10740     __ or3 (Rtmp, Rtmp2, Rtmp);
10741     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10742   %}
10743   ins_pipe(ialu_reg);
10744 %}
10745 
10746 // Replicate scalar to packed char/short values into Double stack
10747 instruct Repl4S_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10748   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &lt; 3);
10749   match(Set dst (ReplicateS src));
10750   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10751   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10752             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10753             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10754             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10755             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10756             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10757   ins_encode %{
10758     Register Rsrc = $src$$Register;
10759     Register Rtmp = $tmp$$Register;
10760     Register Rtmp2 = $tmp2$$Register;
10761     __ sllx(Rsrc,    48, Rtmp);
10762     __ srlx(Rtmp,    16, Rtmp2);
10763     __ or3 (Rtmp, Rtmp2, Rtmp);
10764     __ srlx(Rtmp,    32, Rtmp2);
10765     __ or3 (Rtmp, Rtmp2, Rtmp);
10766     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10767     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10768   %}
10769   ins_pipe(ialu_reg);
10770 %}
10771 
10772 // Replicate scalar constant to packed char/short values in Double register
10773 instruct Repl4S_immI(regD dst, immI con, o7RegI tmp) %{
10774   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10775   match(Set dst (ReplicateS con));
10776   effect(KILL tmp);
10777   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl4S($con)&quot; %}
10778   ins_encode %{
10779     // XXX This is a quick fix for 6833573.
10780     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 4, 2)), $dst$$FloatRegister);
10781     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 4, 2)), $tmp$$Register);
10782     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10783   %}
10784   ins_pipe(loadConFD);
10785 %}
10786 
10787 // Replicate scalar to packed int values into Double register
10788 instruct Repl2I_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10789   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &gt;= 3);
10790   match(Set dst (ReplicateI src));
10791   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10792   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10793             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10794             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10795             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10796   ins_encode %{
10797     Register Rsrc = $src$$Register;
10798     Register Rtmp = $tmp$$Register;
10799     Register Rtmp2 = $tmp2$$Register;
10800     __ sllx(Rsrc,    32, Rtmp);
10801     __ srlx(Rtmp,    32, Rtmp2);
10802     __ or3 (Rtmp, Rtmp2, Rtmp);
10803     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10804   %}
10805   ins_pipe(ialu_reg);
10806 %}
10807 
10808 // Replicate scalar to packed int values into Double stack
10809 instruct Repl2I_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10810   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &lt; 3);
10811   match(Set dst (ReplicateI src));
10812   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10813   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10814             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10815             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10816             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10817   ins_encode %{
10818     Register Rsrc = $src$$Register;
10819     Register Rtmp = $tmp$$Register;
10820     Register Rtmp2 = $tmp2$$Register;
10821     __ sllx(Rsrc,    32, Rtmp);
10822     __ srlx(Rtmp,    32, Rtmp2);
10823     __ or3 (Rtmp, Rtmp2, Rtmp);
10824     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10825     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10826   %}
10827   ins_pipe(ialu_reg);
10828 %}
10829 
10830 // Replicate scalar zero constant to packed int values in Double register
10831 instruct Repl2I_immI(regD dst, immI con, o7RegI tmp) %{
10832   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10833   match(Set dst (ReplicateI con));
10834   effect(KILL tmp);
10835   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2I($con)&quot; %}
10836   ins_encode %{
10837     // XXX This is a quick fix for 6833573.
10838     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 2, 4)), $dst$$FloatRegister);
10839     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 2, 4)), $tmp$$Register);
10840     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10841   %}
10842   ins_pipe(loadConFD);
10843 %}
10844 
10845 // Replicate scalar to packed float values into Double stack
10846 instruct Repl2F_stk(stackSlotD dst, regF src) %{
10847   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10848   match(Set dst (ReplicateF src));
10849   ins_cost(MEMORY_REF_COST*2);
10850   format %{ &quot;STF    $src,$dst.hi\t! packed2F\n\t&quot;
10851             &quot;STF    $src,$dst.lo&quot; %}
10852   opcode(Assembler::stf_op3);
10853   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, src));
10854   ins_pipe(fstoreF_stk_reg);
10855 %}
10856 
10857 // Replicate scalar zero constant to packed float values in Double register
10858 instruct Repl2F_immF(regD dst, immF con, o7RegI tmp) %{
10859   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10860   match(Set dst (ReplicateF con));
10861   effect(KILL tmp);
10862   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2F($con)&quot; %}
10863   ins_encode %{
10864     // XXX This is a quick fix for 6833573.
10865     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immF($con$$constant)), $dst$$FloatRegister);
10866     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immF($con$$constant)), $tmp$$Register);
10867     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10868   %}
10869   ins_pipe(loadConFD);
10870 %}
10871 
10872 //----------PEEPHOLE RULES-----------------------------------------------------
10873 // These must follow all instruction definitions as they use the names
10874 // defined in the instructions definitions.
10875 //
10876 // peepmatch ( root_instr_name [preceding_instruction]* );
10877 //
10878 // peepconstraint %{
10879 // (instruction_number.operand_name relational_op instruction_number.operand_name
10880 //  [, ...] );
10881 // // instruction numbers are zero-based using left to right order in peepmatch
10882 //
10883 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
10884 // // provide an instruction_number.operand_name for each operand that appears
10885 // // in the replacement instruction&#39;s match rule
10886 //
10887 // ---------VM FLAGS---------------------------------------------------------
10888 //
10889 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10890 //
10891 // Each peephole rule is given an identifying number starting with zero and
10892 // increasing by one in the order seen by the parser.  An individual peephole
10893 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10894 // on the command-line.
10895 //
10896 // ---------CURRENT LIMITATIONS----------------------------------------------
10897 //
10898 // Only match adjacent instructions in same basic block
10899 // Only equality constraints
10900 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10901 // Only one replacement instruction
10902 //
10903 // ---------EXAMPLE----------------------------------------------------------
10904 //
10905 // // pertinent parts of existing instructions in architecture description
10906 // instruct movI(eRegI dst, eRegI src) %{
10907 //   match(Set dst (CopyI src));
10908 // %}
10909 //
10910 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10911 //   match(Set dst (AddI dst src));
10912 //   effect(KILL cr);
10913 // %}
10914 //
10915 // // Change (inc mov) to lea
10916 // peephole %{
10917 //   // increment preceeded by register-register move
10918 //   peepmatch ( incI_eReg movI );
10919 //   // require that the destination register of the increment
10920 //   // match the destination register of the move
10921 //   peepconstraint ( 0.dst == 1.dst );
10922 //   // construct a replacement instruction that sets
10923 //   // the destination to ( move&#39;s source register + one )
10924 //   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
10925 // %}
10926 //
10927 
10928 // // Change load of spilled value to only a spill
10929 // instruct storeI(memory mem, eRegI src) %{
10930 //   match(Set mem (StoreI mem src));
10931 // %}
10932 //
10933 // instruct loadI(eRegI dst, memory mem) %{
10934 //   match(Set dst (LoadI mem));
10935 // %}
10936 //
10937 // peephole %{
10938 //   peepmatch ( loadI storeI );
10939 //   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
10940 //   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
10941 // %}
10942 
10943 //----------SMARTSPILL RULES---------------------------------------------------
10944 // These must follow all instruction definitions as they use the names
10945 // defined in the instructions definitions.
10946 //
10947 // SPARC will probably not have any of these rules due to RISC instruction set.
10948 
10949 //----------PIPELINE-----------------------------------------------------------
10950 // Rules which define the behavior of the target architectures pipeline.
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/abstractInterpreter_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;interpreter/interpreter.hpp&quot;
 27 #include &quot;oops/constMethod.hpp&quot;
 28 #include &quot;oops/klass.inline.hpp&quot;
 29 #include &quot;oops/method.hpp&quot;
 30 #include &quot;runtime/arguments.hpp&quot;
 31 #include &quot;runtime/frame.inline.hpp&quot;
 32 #include &quot;runtime/synchronizer.hpp&quot;
 33 #include &quot;utilities/align.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 
 37 int AbstractInterpreter::BasicType_as_index(BasicType type) {
 38   int i = 0;
 39   switch (type) {
 40     case T_BOOLEAN: i = 0; break;
 41     case T_CHAR   : i = 1; break;
 42     case T_BYTE   : i = 2; break;
 43     case T_SHORT  : i = 3; break;
 44     case T_INT    : i = 4; break;
 45     case T_LONG   : i = 5; break;
 46     case T_VOID   : i = 6; break;
 47     case T_FLOAT  : i = 7; break;
 48     case T_DOUBLE : i = 8; break;
 49     case T_OBJECT : i = 9; break;
 50     case T_ARRAY  : i = 9; break;
 51     default       : ShouldNotReachHere();
 52   }
 53   assert(0 &lt;= i &amp;&amp; i &lt; AbstractInterpreter::number_of_result_handlers, &quot;index out of bounds&quot;);
 54   return i;
 55 }
 56 
 57 static int size_activation_helper(int callee_extra_locals, int max_stack, int monitor_size) {
 58 
 59   // Figure out the size of an interpreter frame (in words) given that we have a fully allocated
 60   // expression stack, the callee will have callee_extra_locals (so we can account for
 61   // frame extension) and monitor_size for monitors. Basically we need to calculate
 62   // this exactly like generate_fixed_frame/generate_compute_interpreter_state.
 63   //
 64   //
 65   // The big complicating thing here is that we must ensure that the stack stays properly
 66   // aligned. This would be even uglier if monitor size wasn&#39;t modulo what the stack
 67   // needs to be aligned for). We are given that the sp (fp) is already aligned by
 68   // the caller so we must ensure that it is properly aligned for our callee.
 69   //
 70   const int rounded_vm_local_words =
 71       align_up((int)frame::interpreter_frame_vm_local_words,WordsPerLong);
 72   // callee_locals and max_stack are counts, not the size in frame.
 73   const int locals_size =
 74       align_up(callee_extra_locals * Interpreter::stackElementWords, WordsPerLong);
 75   const int max_stack_words = max_stack * Interpreter::stackElementWords;
 76   return (align_up((max_stack_words
 77                    + rounded_vm_local_words
 78                    + frame::memory_parameter_word_sp_offset), WordsPerLong)
 79                    // already rounded
 80                    + locals_size + monitor_size);
 81 }
 82 
 83 // How much stack a method top interpreter activation needs in words.
 84 int AbstractInterpreter::size_top_interpreter_activation(Method* method) {
 85 
 86   // See call_stub code
 87   int call_stub_size  = align_up(7 + frame::memory_parameter_word_sp_offset,
 88                                  WordsPerLong);    // 7 + register save area
 89 
 90   // Save space for one monitor to get into the interpreted method in case
 91   // the method is synchronized
 92   int monitor_size    = method-&gt;is_synchronized() ?
 93                                 1*frame::interpreter_frame_monitor_size() : 0;
 94   return size_activation_helper(method-&gt;max_locals(), method-&gt;max_stack(),
 95                                 monitor_size) + call_stub_size;
 96 }
 97 
 98 int AbstractInterpreter::size_activation(int max_stack,
 99                                          int temps,
100                                          int extra_args,
101                                          int monitors,
102                                          int callee_params,
103                                          int callee_locals,
104                                          bool is_top_frame) {
105   // Note: This calculation must exactly parallel the frame setup
106   // in TemplateInterpreterGenerator::generate_fixed_frame.
107 
108   int monitor_size           = monitors * frame::interpreter_frame_monitor_size();
109 
110   assert(is_aligned(monitor_size, WordsPerLong), &quot;must align&quot;);
111 
112   //
113   // Note: if you look closely this appears to be doing something much different
114   // than generate_fixed_frame. What is happening is this. On sparc we have to do
115   // this dance with interpreter_sp_adjustment because the window save area would
116   // appear just below the bottom (tos) of the caller&#39;s java expression stack. Because
117   // the interpreter want to have the locals completely contiguous generate_fixed_frame
118   // will adjust the caller&#39;s sp for the &quot;extra locals&quot; (max_locals - parameter_size).
119   // Now in generate_fixed_frame the extension of the caller&#39;s sp happens in the callee.
120   // In this code the opposite occurs the caller adjusts it&#39;s own stack base on the callee.
121   // This is mostly ok but it does cause a problem when we get to the initial frame (the oldest)
122   // because the oldest frame would have adjust its callers frame and yet that frame
123   // already exists and isn&#39;t part of this array of frames we are unpacking. So at first
124   // glance this would seem to mess up that frame. However Deoptimization::fetch_unroll_info_helper()
125   // will after it calculates all of the frame&#39;s on_stack_size()&#39;s will then figure out the
126   // amount to adjust the caller of the initial (oldest) frame and the calculation will all
127   // add up. It does seem like it simpler to account for the adjustment here (and remove the
128   // callee... parameters here). However this would mean that this routine would have to take
129   // the caller frame as input so we could adjust its sp (and set it&#39;s interpreter_sp_adjustment)
130   // and run the calling loop in the reverse order. This would also would appear to mean making
131   // this code aware of what the interactions are when that initial caller fram was an osr or
132   // other adapter frame. deoptimization is complicated enough and  hard enough to debug that
133   // there is no sense in messing working code.
134   //
135 
136   int rounded_cls = align_up((callee_locals - callee_params), WordsPerLong);
137   assert(is_aligned(rounded_cls, WordsPerLong), &quot;must align&quot;);
138 
139   int raw_frame_size = size_activation_helper(rounded_cls, max_stack, monitor_size);
140 
141   return raw_frame_size;
142 }
143 
144 void AbstractInterpreter::layout_activation(Method* method,
145                                             int tempcount,
146                                             int popframe_extra_args,
147                                             int moncount,
148                                             int caller_actual_parameters,
149                                             int callee_param_count,
150                                             int callee_local_count,
151                                             frame* caller,
152                                             frame* interpreter_frame,
153                                             bool is_top_frame,
154                                             bool is_bottom_frame) {
155   // Set up the following variables:
156   //   - Lmethod
157   //   - Llocals
158   //   - Lmonitors (to the indicated number of monitors)
159   //   - Lesp (to the indicated number of temps)
160   // The frame caller on entry is a description of the caller of the
161   // frame we are about to layout. We are guaranteed that we will be
162   // able to fill in a new interpreter frame as its callee (i.e. the
163   // stack space is allocated and the amount was determined by an
164   // earlier call to the size_activation() method).  On return caller
165   // while describe the interpreter frame we just layed out.
166 
167   // The skeleton frame must already look like an interpreter frame
168   // even if not fully filled out.
169   assert(interpreter_frame-&gt;is_interpreted_frame(), &quot;Must be interpreted frame&quot;);
170 
171   int rounded_vm_local_words = align_up((int)frame::interpreter_frame_vm_local_words,WordsPerLong);
172   int monitor_size           = moncount * frame::interpreter_frame_monitor_size();
173   assert(is_aligned(monitor_size, WordsPerLong), &quot;must align&quot;);
174 
175   intptr_t* fp = interpreter_frame-&gt;fp();
176 
177   JavaThread* thread = JavaThread::current();
178   RegisterMap map(thread, false);
179   // More verification that skeleton frame is properly walkable
180   assert(fp == caller-&gt;sp(), &quot;fp must match&quot;);
181 
182   intptr_t* montop     = fp - rounded_vm_local_words;
183 
184   // preallocate monitors (cf. __ add_monitor_to_stack)
185   intptr_t* monitors = montop - monitor_size;
186 
187   // preallocate stack space
188   intptr_t*  esp = monitors - 1 -
189     (tempcount * Interpreter::stackElementWords) -
190     popframe_extra_args;
191 
192   int local_words = method-&gt;max_locals() * Interpreter::stackElementWords;
193   NEEDS_CLEANUP;
194   intptr_t* locals;
195   if (caller-&gt;is_interpreted_frame()) {
196     // Can force the locals area to end up properly overlapping the top of the expression stack.
197     intptr_t* Lesp_ptr = caller-&gt;interpreter_frame_tos_address() - 1;
198     // Note that this computation means we replace size_of_parameters() values from the caller
199     // interpreter frame&#39;s expression stack with our argument locals
200     int parm_words  = caller_actual_parameters * Interpreter::stackElementWords;
201     locals = Lesp_ptr + parm_words;
202     int delta = local_words - parm_words;
203     int computed_sp_adjustment = (delta &gt; 0) ? align_up(delta, WordsPerLong) : 0;
204     *interpreter_frame-&gt;register_addr(I5_savedSP)    = (intptr_t) (fp + computed_sp_adjustment) - STACK_BIAS;
205     if (!is_bottom_frame) {
206       // Llast_SP is set below for the current frame to SP (with the
207       // extra space for the callee&#39;s locals). Here we adjust
208       // Llast_SP for the caller&#39;s frame, removing the extra space
209       // for the current method&#39;s locals.
210       *caller-&gt;register_addr(Llast_SP) = *interpreter_frame-&gt;register_addr(I5_savedSP);
211     } else {
212       assert(*caller-&gt;register_addr(Llast_SP) &gt;= *interpreter_frame-&gt;register_addr(I5_savedSP), &quot;strange Llast_SP&quot;);
213     }
214   } else {
215     assert(caller-&gt;is_compiled_frame() || caller-&gt;is_entry_frame(), &quot;only possible cases&quot;);
216     // Don&#39;t have Lesp available; lay out locals block in the caller
217     // adjacent to the register window save area.
218     //
219     // Compiled frames do not allocate a varargs area which is why this if
220     // statement is needed.
221     //
222     if (caller-&gt;is_compiled_frame()) {
223       locals = fp + frame::register_save_words + local_words - 1;
224     } else {
225       locals = fp + frame::memory_parameter_word_sp_offset + local_words - 1;
226     }
227     if (!caller-&gt;is_entry_frame()) {
228       // Caller wants his own SP back
229       int caller_frame_size = caller-&gt;cb()-&gt;frame_size();
230       *interpreter_frame-&gt;register_addr(I5_savedSP) = (intptr_t)(caller-&gt;fp() - caller_frame_size) - STACK_BIAS;
231     }
232   }
233   if (TraceDeoptimization) {
234     if (caller-&gt;is_entry_frame()) {
235       // make sure I5_savedSP and the entry frames notion of saved SP
236       // agree.  This assertion duplicate a check in entry frame code
237       // but catches the failure earlier.
238       assert(*caller-&gt;register_addr(Lscratch) == *interpreter_frame-&gt;register_addr(I5_savedSP),
239              &quot;would change callers SP&quot;);
240     }
241     if (caller-&gt;is_entry_frame()) {
242       tty-&gt;print(&quot;entry &quot;);
243     }
244     if (caller-&gt;is_compiled_frame()) {
245       tty-&gt;print(&quot;compiled &quot;);
246       if (caller-&gt;is_deoptimized_frame()) {
247         tty-&gt;print(&quot;(deopt) &quot;);
248       }
249     }
250     if (caller-&gt;is_interpreted_frame()) {
251       tty-&gt;print(&quot;interpreted &quot;);
252     }
253     tty-&gt;print_cr(&quot;caller fp=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(caller-&gt;fp()), p2i(caller-&gt;sp()));
254     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(caller-&gt;sp()), p2i(caller-&gt;sp() + 16));
255     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(caller-&gt;fp()), p2i(caller-&gt;fp() + 16));
256     tty-&gt;print_cr(&quot;interpreter fp=&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;fp()), p2i(interpreter_frame-&gt;sp()));
257     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;sp()), p2i(interpreter_frame-&gt;sp() + 16));
258     tty-&gt;print_cr(&quot;save area = &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT, p2i(interpreter_frame-&gt;fp()), p2i(interpreter_frame-&gt;fp() + 16));
259     tty-&gt;print_cr(&quot;Llocals = &quot; INTPTR_FORMAT, p2i(locals));
260     tty-&gt;print_cr(&quot;Lesp = &quot; INTPTR_FORMAT, p2i(esp));
261     tty-&gt;print_cr(&quot;Lmonitors = &quot; INTPTR_FORMAT, p2i(monitors));
262   }
263 
264   if (method-&gt;max_locals() &gt; 0) {
265     assert(locals &lt; caller-&gt;sp() || locals &gt;= (caller-&gt;sp() + 16), &quot;locals in save area&quot;);
266     assert(locals &lt; caller-&gt;fp() || locals &gt; (caller-&gt;fp() + 16), &quot;locals in save area&quot;);
267     assert(locals &lt; interpreter_frame-&gt;sp() || locals &gt; (interpreter_frame-&gt;sp() + 16), &quot;locals in save area&quot;);
268     assert(locals &lt; interpreter_frame-&gt;fp() || locals &gt;= (interpreter_frame-&gt;fp() + 16), &quot;locals in save area&quot;);
269   }
270   assert(*interpreter_frame-&gt;register_addr(I5_savedSP) &amp; 1, &quot;must be odd&quot;);
271 
272   *interpreter_frame-&gt;register_addr(Lmethod)     = (intptr_t) method;
273   *interpreter_frame-&gt;register_addr(Llocals)     = (intptr_t) locals;
274   *interpreter_frame-&gt;register_addr(Lmonitors)   = (intptr_t) monitors;
275   *interpreter_frame-&gt;register_addr(Lesp)        = (intptr_t) esp;
276   // Llast_SP will be same as SP as there is no adapter space
277   *interpreter_frame-&gt;register_addr(Llast_SP)    = (intptr_t) interpreter_frame-&gt;sp() - STACK_BIAS;
278   *interpreter_frame-&gt;register_addr(LcpoolCache) = (intptr_t) method-&gt;constants()-&gt;cache();
279   // save the mirror in the interpreter frame
280   *interpreter_frame-&gt;interpreter_frame_mirror_addr() = method-&gt;method_holder()-&gt;java_mirror();
281 
282 #ifdef ASSERT
283   BasicObjectLock* mp = (BasicObjectLock*)monitors;
284 
285   assert(interpreter_frame-&gt;interpreter_frame_method() == method, &quot;method matches&quot;);
286   assert(interpreter_frame-&gt;interpreter_frame_local_at(9) == (intptr_t *)((intptr_t)locals - (9 * Interpreter::stackElementSize)), &quot;locals match&quot;);
287   assert(interpreter_frame-&gt;interpreter_frame_monitor_end()   == mp, &quot;monitor_end matches&quot;);
288   assert(((intptr_t *)interpreter_frame-&gt;interpreter_frame_monitor_begin()) == ((intptr_t *)mp)+monitor_size, &quot;monitor_begin matches&quot;);
289   assert(interpreter_frame-&gt;interpreter_frame_tos_address()-1 == esp, &quot;esp matches&quot;);
290 
291   // check bounds
292   intptr_t* lo = interpreter_frame-&gt;sp() + (frame::memory_parameter_word_sp_offset - 1);
293   intptr_t* hi = interpreter_frame-&gt;fp() - rounded_vm_local_words;
294   assert(lo &lt; monitors &amp;&amp; montop &lt;= hi, &quot;monitors in bounds&quot;);
295   assert(lo &lt;= esp &amp;&amp; esp &lt; monitors, &quot;esp in bounds&quot;);
296 #endif // ASSERT
297 }
    </pre>
  </body>
</html>
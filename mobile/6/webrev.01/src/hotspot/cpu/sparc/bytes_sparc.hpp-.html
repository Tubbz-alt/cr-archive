<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/bytes_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_SPARC_BYTES_SPARC_HPP
 26 #define CPU_SPARC_BYTES_SPARC_HPP
 27 
 28 #include &quot;memory/allocation.hpp&quot;
 29 
 30 class Bytes: AllStatic {
 31  public:
 32   // Efficient reading and writing of unaligned unsigned data in platform-specific byte ordering
 33   // Sparc needs to check for alignment.
 34 
 35   // can I count on address always being a pointer to an unsigned char? Yes
 36 
 37   // Thus, a swap between native and Java ordering is always a no-op:
 38   static inline u2   swap_u2(u2 x)  { return x; }
 39   static inline u4   swap_u4(u4 x)  { return x; }
 40   static inline u8   swap_u8(u8 x)  { return x; }
 41 
 42   static inline u2   get_native_u2(address p){
 43     return (intptr_t(p) &amp; 1) == 0
 44              ?   *(u2*)p
 45              :   ( u2(p[0]) &lt;&lt; 8 )
 46                | ( u2(p[1])      );
 47   }
 48 
 49   static inline u4   get_native_u4(address p) {
 50     switch (intptr_t(p) &amp; 3) {
 51      case 0:  return *(u4*)p;
 52 
 53      case 2:  return (  u4( ((u2*)p)[0] ) &lt;&lt; 16  )
 54                    | (  u4( ((u2*)p)[1] )                  );
 55 
 56     default:  return ( u4(p[0]) &lt;&lt; 24 )
 57                    | ( u4(p[1]) &lt;&lt; 16 )
 58                    | ( u4(p[2]) &lt;&lt;  8 )
 59                    |   u4(p[3]);
 60     }
 61   }
 62 
 63   static inline u8   get_native_u8(address p) {
 64     switch (intptr_t(p) &amp; 7) {
 65       case 0:  return *(u8*)p;
 66 
 67       case 4:  return (  u8( ((u4*)p)[0] ) &lt;&lt; 32  )
 68                     | (  u8( ((u4*)p)[1] )        );
 69 
 70       case 2:  return (  u8( ((u2*)p)[0] ) &lt;&lt; 48  )
 71                     | (  u8( ((u2*)p)[1] ) &lt;&lt; 32  )
 72                     | (  u8( ((u2*)p)[2] ) &lt;&lt; 16  )
 73                     | (  u8( ((u2*)p)[3] )        );
 74 
 75      default:  return ( u8(p[0]) &lt;&lt; 56 )
 76                     | ( u8(p[1]) &lt;&lt; 48 )
 77                     | ( u8(p[2]) &lt;&lt; 40 )
 78                     | ( u8(p[3]) &lt;&lt; 32 )
 79                     | ( u8(p[4]) &lt;&lt; 24 )
 80                     | ( u8(p[5]) &lt;&lt; 16 )
 81                     | ( u8(p[6]) &lt;&lt;  8 )
 82                     |   u8(p[7]);
 83     }
 84   }
 85 
 86 
 87 
 88   static inline void put_native_u2(address p, u2 x)   {
 89     if ( (intptr_t(p) &amp; 1) == 0 )  *(u2*)p = x;
 90     else {
 91       p[0] = x &gt;&gt; 8;
 92       p[1] = x;
 93     }
 94   }
 95 
 96   static inline void put_native_u4(address p, u4 x) {
 97     switch ( intptr_t(p) &amp; 3 ) {
 98     case 0:  *(u4*)p = x;
 99               break;
100 
101     case 2:  ((u2*)p)[0] = x &gt;&gt; 16;
102              ((u2*)p)[1] = x;
103              break;
104 
105     default: ((u1*)p)[0] = x &gt;&gt; 24;
106              ((u1*)p)[1] = x &gt;&gt; 16;
107              ((u1*)p)[2] = x &gt;&gt;  8;
108              ((u1*)p)[3] = x;
109              break;
110     }
111   }
112 
113   static inline void put_native_u8(address p, u8 x) {
114     switch ( intptr_t(p) &amp; 7 ) {
115     case 0:  *(u8*)p = x;
116              break;
117 
118     case 4:  ((u4*)p)[0] = x &gt;&gt; 32;
119              ((u4*)p)[1] = x;
120              break;
121 
122     case 2:  ((u2*)p)[0] = x &gt;&gt; 48;
123              ((u2*)p)[1] = x &gt;&gt; 32;
124              ((u2*)p)[2] = x &gt;&gt; 16;
125              ((u2*)p)[3] = x;
126              break;
127 
128     default: ((u1*)p)[0] = x &gt;&gt; 56;
129              ((u1*)p)[1] = x &gt;&gt; 48;
130              ((u1*)p)[2] = x &gt;&gt; 40;
131              ((u1*)p)[3] = x &gt;&gt; 32;
132              ((u1*)p)[4] = x &gt;&gt; 24;
133              ((u1*)p)[5] = x &gt;&gt; 16;
134              ((u1*)p)[6] = x &gt;&gt;  8;
135              ((u1*)p)[7] = x;
136     }
137   }
138 
139 
140   // Efficient reading and writing of unaligned unsigned data in Java byte ordering (i.e. big-endian ordering)
141   // (no byte-order reversal is needed since SPARC CPUs are big-endian oriented)
142   static inline u2   get_Java_u2(address p) { return get_native_u2(p); }
143   static inline u4   get_Java_u4(address p) { return get_native_u4(p); }
144   static inline u8   get_Java_u8(address p) { return get_native_u8(p); }
145 
146   static inline void put_Java_u2(address p, u2 x)     { put_native_u2(p, x); }
147   static inline void put_Java_u4(address p, u4 x)     { put_native_u4(p, x); }
148   static inline void put_Java_u8(address p, u8 x)     { put_native_u8(p, x); }
149 };
150 
151 //Reconciliation History
152 // 1.7 98/02/24 10:18:41 bytes_i486.hpp
153 // 1.10 98/04/08 18:47:57 bytes_i486.hpp
154 // 1.13 98/07/15 17:10:03 bytes_i486.hpp
155 // 1.14 98/08/13 10:38:23 bytes_i486.hpp
156 // 1.15 98/10/05 16:30:21 bytes_i486.hpp
157 // 1.17 99/06/22 16:37:35 bytes_i486.hpp
158 //End
159 
160 #endif // CPU_SPARC_BYTES_SPARC_HPP
    </pre>
  </body>
</html>
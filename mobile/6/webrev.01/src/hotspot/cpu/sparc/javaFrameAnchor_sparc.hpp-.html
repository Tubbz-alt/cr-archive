<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/javaFrameAnchor_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef CPU_SPARC_JAVAFRAMEANCHOR_SPARC_HPP
 26 #define CPU_SPARC_JAVAFRAMEANCHOR_SPARC_HPP
 27 
 28 private:
 29   volatile int _flags;
 30 
 31 public:
 32 
 33    enum pd_Constants {
 34      flushed = 1                                 // winodows have flushed
 35    };
 36 
 37   int flags(void)                                { return _flags; }
 38   void set_flags(int flags)                      { _flags = flags; }
 39 
 40   static ByteSize flags_offset()                 { return byte_offset_of(JavaFrameAnchor, _flags); }
 41 
 42   // Each arch must define clear, copy
 43   // These are used by objects that only care about:
 44   //  1 - initializing a new state (thread creation, javaCalls)
 45   //  2 - saving a current state (javaCalls)
 46   //  3 - restoring an old state (javaCalls)
 47 
 48   void clear(void) {
 49     // clearing _last_Java_sp must be first
 50     _last_Java_sp = NULL;
 51     // fence?
 52     _flags = 0;
 53     _last_Java_pc = NULL;
 54   }
 55 
 56   void copy(JavaFrameAnchor* src) {
 57     // In order to make sure the transition state is valid for &quot;this&quot;
 58     // We must clear _last_Java_sp before copying the rest of the new data
 59     //
 60     // Hack Alert: Temporary bugfix for 4717480/4721647
 61     // To act like previous version (pd_cache_state) don&#39;t NULL _last_Java_sp
 62     // unless the value is changing
 63     //
 64     if (_last_Java_sp != src-&gt;_last_Java_sp)
 65       _last_Java_sp = NULL;
 66 
 67     _flags = src-&gt;_flags;
 68     _last_Java_pc = src-&gt;_last_Java_pc;
 69     // Must be last so profiler will always see valid frame if has_last_frame() is true
 70     _last_Java_sp = src-&gt;_last_Java_sp;
 71   }
 72 
 73   // Is stack walkable
 74   inline bool walkable( void) {
 75         return _flags &amp; flushed;
 76   }
 77 
 78   void make_walkable(JavaThread* thread);
 79 
 80   void set_last_Java_sp(intptr_t* sp)            { _last_Java_sp = sp; }
 81 
 82   address last_Java_pc(void)                     { return _last_Java_pc; }
 83 
 84   // These are only used by friends
 85 private:
 86 
 87   intptr_t* last_Java_sp() const {
 88     // _last_Java_sp will always be a an unbiased stack pointer
 89     // if is is biased then some setter screwed up. This is
 90     // deadly.
 91     assert(((intptr_t)_last_Java_sp &amp; 0xF) == 0, &quot;Biased last_Java_sp&quot;);
 92     return _last_Java_sp;
 93   }
 94 
 95   void capture_last_Java_pc(intptr_t* sp);
 96 
 97   void set_window_flushed( void) {
 98     _flags |= flushed;
 99     OrderAccess::fence();
100   }
101 
102 #endif // CPU_SPARC_JAVAFRAMEANCHOR_SPARC_HPP
    </pre>
  </body>
</html>
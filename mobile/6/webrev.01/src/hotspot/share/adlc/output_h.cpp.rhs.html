<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/adlc/output_h.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 // output_h.cpp - Class HPP file output routines for architecture definition
  26 #include &quot;adlc.hpp&quot;
  27 
  28 // The comment delimiter used in format statements after assembler instructions.
  29 #if defined(PPC64)
  30 #define commentSeperator &quot;\t//&quot;
  31 #else
  32 #define commentSeperator &quot;!&quot;
  33 #endif
  34 
  35 // Generate the #define that describes the number of registers.
  36 static void defineRegCount(FILE *fp, RegisterForm *registers) {
  37   if (registers) {
  38     int regCount =  AdlcVMDeps::Physical + registers-&gt;_rdefs.count();
  39     fprintf(fp,&quot;\n&quot;);
  40     fprintf(fp,&quot;// the number of reserved registers + machine registers.\n&quot;);
  41     fprintf(fp,&quot;#define REG_COUNT    %d\n&quot;, regCount);
  42   }
  43 }
  44 
  45 // Output enumeration of machine register numbers
  46 // (1)
  47 // // Enumerate machine registers starting after reserved regs.
  48 // // in the order of occurrence in the register block.
  49 // enum MachRegisterNumbers {
  50 //   EAX_num = 0,
  51 //   ...
  52 //   _last_Mach_Reg
  53 // }
  54 void ArchDesc::buildMachRegisterNumbers(FILE *fp_hpp) {
  55   if (_register) {
  56     RegDef *reg_def = NULL;
  57 
  58     // Output a #define for the number of machine registers
  59     defineRegCount(fp_hpp, _register);
  60 
  61     // Count all the Save_On_Entry and Always_Save registers
  62     int    saved_on_entry = 0;
  63     int  c_saved_on_entry = 0;
  64     _register-&gt;reset_RegDefs();
  65     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  66       if( strcmp(reg_def-&gt;_callconv,&quot;SOE&quot;) == 0 ||
  67           strcmp(reg_def-&gt;_callconv,&quot;AS&quot;)  == 0 )  ++saved_on_entry;
  68       if( strcmp(reg_def-&gt;_c_conv,&quot;SOE&quot;) == 0 ||
  69           strcmp(reg_def-&gt;_c_conv,&quot;AS&quot;)  == 0 )  ++c_saved_on_entry;
  70     }
  71     fprintf(fp_hpp, &quot;\n&quot;);
  72     fprintf(fp_hpp, &quot;// the number of save_on_entry + always_saved registers.\n&quot;);
  73     fprintf(fp_hpp, &quot;#define MAX_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   max(saved_on_entry,c_saved_on_entry));
  74     fprintf(fp_hpp, &quot;#define     SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;,   saved_on_entry);
  75     fprintf(fp_hpp, &quot;#define   C_SAVED_ON_ENTRY_REG_COUNT    %d\n&quot;, c_saved_on_entry);
  76 
  77     // (1)
  78     // Build definition for enumeration of register numbers
  79     fprintf(fp_hpp, &quot;\n&quot;);
  80     fprintf(fp_hpp, &quot;// Enumerate machine register numbers starting after reserved regs.\n&quot;);
  81     fprintf(fp_hpp, &quot;// in the order of occurrence in the register block.\n&quot;);
  82     fprintf(fp_hpp, &quot;enum MachRegisterNumbers {\n&quot;);
  83 
  84     // Output the register number for each register in the allocation classes
  85     _register-&gt;reset_RegDefs();
  86     int i = 0;
  87     while( (reg_def = _register-&gt;iter_RegDefs()) != NULL ) {
  88       fprintf(fp_hpp,&quot;  %s_num,&quot;, reg_def-&gt;_regname);
  89       for (int j = 0; j &lt; 20-(int)strlen(reg_def-&gt;_regname); j++) fprintf(fp_hpp, &quot; &quot;);
  90       fprintf(fp_hpp,&quot; // enum %3d, regnum %3d, reg encode %3s\n&quot;,
  91               i++,
  92               reg_def-&gt;register_num(),
  93               reg_def-&gt;register_encode());
  94     }
  95     // Finish defining enumeration
  96     fprintf(fp_hpp, &quot;  _last_Mach_Reg            // %d\n&quot;, i);
  97     fprintf(fp_hpp, &quot;};\n&quot;);
  98   }
  99 
 100   fprintf(fp_hpp, &quot;\n// Size of register-mask in ints\n&quot;);
 101   fprintf(fp_hpp, &quot;#define RM_SIZE %d\n&quot;,RegisterForm::RegMask_Size());
 102   fprintf(fp_hpp, &quot;// Unroll factor for loops over the data in a RegMask\n&quot;);
 103   fprintf(fp_hpp, &quot;#define FORALL_BODY &quot;);
 104   int len = RegisterForm::RegMask_Size();
 105   for( int i = 0; i &lt; len; i++ )
 106     fprintf(fp_hpp, &quot;BODY(%d) &quot;,i);
 107   fprintf(fp_hpp, &quot;\n\n&quot;);
 108 
 109   fprintf(fp_hpp,&quot;class RegMask;\n&quot;);
 110   // All RegMasks are declared &quot;extern const ...&quot; in ad_&lt;arch&gt;.hpp
 111   // fprintf(fp_hpp,&quot;extern RegMask STACK_OR_STACK_SLOTS_mask;\n\n&quot;);
 112 }
 113 
 114 
 115 // Output enumeration of machine register encodings
 116 // (2)
 117 // // Enumerate machine registers starting after reserved regs.
 118 // // in the order of occurrence in the alloc_class(es).
 119 // enum MachRegisterEncodes {
 120 //   EAX_enc = 0x00,
 121 //   ...
 122 // }
 123 void ArchDesc::buildMachRegisterEncodes(FILE *fp_hpp) {
 124   if (_register) {
 125     RegDef *reg_def = NULL;
 126     RegDef *reg_def_next = NULL;
 127 
 128     // (2)
 129     // Build definition for enumeration of encode values
 130     fprintf(fp_hpp, &quot;\n&quot;);
 131     fprintf(fp_hpp, &quot;// Enumerate machine registers starting after reserved regs.\n&quot;);
 132     fprintf(fp_hpp, &quot;// in the order of occurrence in the alloc_class(es).\n&quot;);
 133     fprintf(fp_hpp, &quot;enum MachRegisterEncodes {\n&quot;);
 134 
 135     // Find max enum string length.
 136     size_t maxlen = 0;
 137     _register-&gt;reset_RegDefs();
 138     reg_def = _register-&gt;iter_RegDefs();
 139     while (reg_def != NULL) {
 140       size_t len = strlen(reg_def-&gt;_regname);
 141       if (len &gt; maxlen) maxlen = len;
 142       reg_def = _register-&gt;iter_RegDefs();
 143     }
 144 
 145     // Output the register encoding for each register in the allocation classes
 146     _register-&gt;reset_RegDefs();
 147     reg_def_next = _register-&gt;iter_RegDefs();
 148     while( (reg_def = reg_def_next) != NULL ) {
 149       reg_def_next = _register-&gt;iter_RegDefs();
 150       fprintf(fp_hpp,&quot;  %s_enc&quot;, reg_def-&gt;_regname);
 151       for (size_t i = strlen(reg_def-&gt;_regname); i &lt; maxlen; i++) fprintf(fp_hpp, &quot; &quot;);
 152       fprintf(fp_hpp,&quot; = %3s%s\n&quot;, reg_def-&gt;register_encode(), reg_def_next == NULL? &quot;&quot; : &quot;,&quot; );
 153     }
 154     // Finish defining enumeration
 155     fprintf(fp_hpp, &quot;};\n&quot;);
 156 
 157   } // Done with register form
 158 }
 159 
 160 
 161 // Declare an array containing the machine register names, strings.
 162 static void declareRegNames(FILE *fp, RegisterForm *registers) {
 163   if (registers) {
 164 //    fprintf(fp,&quot;\n&quot;);
 165 //    fprintf(fp,&quot;// An array of character pointers to machine register names.\n&quot;);
 166 //    fprintf(fp,&quot;extern const char *regName[];\n&quot;);
 167   }
 168 }
 169 
 170 // Declare an array containing the machine register sizes in 32-bit words.
 171 void ArchDesc::declareRegSizes(FILE *fp) {
 172 // regSize[] is not used
 173 }
 174 
 175 // Declare an array containing the machine register encoding values
 176 static void declareRegEncodes(FILE *fp, RegisterForm *registers) {
 177   if (registers) {
 178     // // //
 179     // fprintf(fp,&quot;\n&quot;);
 180     // fprintf(fp,&quot;// An array containing the machine register encode values\n&quot;);
 181     // fprintf(fp,&quot;extern const char  regEncode[];\n&quot;);
 182   }
 183 }
 184 
 185 
 186 // ---------------------------------------------------------------------------
 187 //------------------------------Utilities to build Instruction Classes--------
 188 // ---------------------------------------------------------------------------
 189 static void out_RegMask(FILE *fp) {
 190   fprintf(fp,&quot;  virtual const RegMask &amp;out_RegMask() const;\n&quot;);
 191 }
 192 
 193 // ---------------------------------------------------------------------------
 194 //--------Utilities to build MachOper and MachNode derived Classes------------
 195 // ---------------------------------------------------------------------------
 196 
 197 //------------------------------Utilities to build Operand Classes------------
 198 static void in_RegMask(FILE *fp) {
 199   fprintf(fp,&quot;  virtual const RegMask *in_RegMask(int index) const;\n&quot;);
 200 }
 201 
 202 static void declareConstStorage(FILE *fp, FormDict &amp;globals, OperandForm *oper) {
 203   int i = 0;
 204   Component *comp;
 205 
 206   if (oper-&gt;num_consts(globals) == 0) return;
 207   // Iterate over the component list looking for constants
 208   oper-&gt;_components.reset();
 209   if ((comp = oper-&gt;_components.iter()) == NULL) {
 210     assert(oper-&gt;num_consts(globals) == 1, &quot;Bad component list detected.\n&quot;);
 211     const char *type = oper-&gt;ideal_type(globals);
 212     if (!strcmp(type, &quot;ConI&quot;)) {
 213       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 214       fprintf(fp,&quot;  int32_t        _c%d;\n&quot;, i);
 215     }
 216     else if (!strcmp(type, &quot;ConP&quot;)) {
 217       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 218       fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 219     }
 220     else if (!strcmp(type, &quot;ConN&quot;)) {
 221       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 222       fprintf(fp,&quot;  const TypeNarrowOop *_c%d;\n&quot;, i);
 223     }
 224     else if (!strcmp(type, &quot;ConNKlass&quot;)) {
 225       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 226       fprintf(fp,&quot;  const TypeNarrowKlass *_c%d;\n&quot;, i);
 227     }
 228     else if (!strcmp(type, &quot;ConL&quot;)) {
 229       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 230       fprintf(fp,&quot;  jlong          _c%d;\n&quot;, i);
 231     }
 232     else if (!strcmp(type, &quot;ConF&quot;)) {
 233       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 234       fprintf(fp,&quot;  jfloat         _c%d;\n&quot;, i);
 235     }
 236     else if (!strcmp(type, &quot;ConD&quot;)) {
 237       if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 238       fprintf(fp,&quot;  jdouble        _c%d;\n&quot;, i);
 239     }
 240     else if (!strcmp(type, &quot;Bool&quot;)) {
 241       fprintf(fp,&quot;private:\n&quot;);
 242       fprintf(fp,&quot;  BoolTest::mask _c%d;\n&quot;, i);
 243       fprintf(fp,&quot;public:\n&quot;);
 244     }
 245     else {
 246       assert(0, &quot;Non-constant operand lacks component list.&quot;);
 247     }
 248   } // end if NULL
 249   else {
 250     oper-&gt;_components.reset();
 251     while ((comp = oper-&gt;_components.iter()) != NULL) {
 252       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 253         fprintf(fp,&quot;  jint             _c%d;\n&quot;, i);
 254         i++;
 255       }
 256       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 257         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 258         i++;
 259       }
 260       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 261         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 262         i++;
 263       }
 264       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 265         fprintf(fp,&quot;  const TypePtr *_c%d;\n&quot;, i);
 266         i++;
 267       }
 268       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 269         fprintf(fp,&quot;  jlong            _c%d;\n&quot;, i);
 270         i++;
 271       }
 272       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 273         fprintf(fp,&quot;  jfloat           _c%d;\n&quot;, i);
 274         i++;
 275       }
 276       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 277         fprintf(fp,&quot;  jdouble          _c%d;\n&quot;, i);
 278         i++;
 279       }
 280     }
 281   }
 282 }
 283 
 284 // Declare constructor.
 285 // Parameters start with condition code, then all other constants
 286 //
 287 // (0) public:
 288 // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
 289 // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
 290 //
 291 static void defineConstructor(FILE *fp, const char *name, uint num_consts,
 292                               ComponentList &amp;lst, bool is_ideal_bool,
 293                               Form::DataType constant_type, FormDict &amp;globals) {
 294   fprintf(fp,&quot;public:\n&quot;);
 295   // generate line (1)
 296   fprintf(fp,&quot;  %sOper(&quot;, name);
 297   if( num_consts == 0 ) {
 298     fprintf(fp,&quot;) {}\n&quot;);
 299     return;
 300   }
 301 
 302   // generate parameters for constants
 303   uint i = 0;
 304   Component *comp;
 305   lst.reset();
 306   if ((comp = lst.iter()) == NULL) {
 307     assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
 308     switch( constant_type ) {
 309     case Form::idealI : {
 310       fprintf(fp,is_ideal_bool ? &quot;BoolTest::mask c%d&quot; : &quot;int32_t c%d&quot;, i);
 311       break;
 312     }
 313     case Form::idealN :      { fprintf(fp,&quot;const TypeNarrowOop *c%d&quot;, i); break; }
 314     case Form::idealNKlass : { fprintf(fp,&quot;const TypeNarrowKlass *c%d&quot;, i); break; }
 315     case Form::idealP :      { fprintf(fp,&quot;const TypePtr *c%d&quot;, i); break; }
 316     case Form::idealL :      { fprintf(fp,&quot;jlong c%d&quot;, i);   break;        }
 317     case Form::idealF :      { fprintf(fp,&quot;jfloat c%d&quot;, i);  break;        }
 318     case Form::idealD :      { fprintf(fp,&quot;jdouble c%d&quot;, i); break;        }
 319     default:
 320       assert(!is_ideal_bool, &quot;Non-constant operand lacks component list.&quot;);
 321       break;
 322     }
 323   } // end if NULL
 324   else {
 325     lst.reset();
 326     while((comp = lst.iter()) != NULL) {
 327       if (!strcmp(comp-&gt;base_type(globals), &quot;ConI&quot;)) {
 328         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 329         fprintf(fp,&quot;int32_t c%d&quot;, i);
 330         i++;
 331       }
 332       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConP&quot;)) {
 333         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 334         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 335         i++;
 336       }
 337       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConN&quot;)) {
 338         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 339         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 340         i++;
 341       }
 342       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConNKlass&quot;)) {
 343         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 344         fprintf(fp,&quot;const TypePtr *c%d&quot;, i);
 345         i++;
 346       }
 347       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConL&quot;)) {
 348         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 349         fprintf(fp,&quot;jlong c%d&quot;, i);
 350         i++;
 351       }
 352       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConF&quot;)) {
 353         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 354         fprintf(fp,&quot;jfloat c%d&quot;, i);
 355         i++;
 356       }
 357       else if (!strcmp(comp-&gt;base_type(globals), &quot;ConD&quot;)) {
 358         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 359         fprintf(fp,&quot;jdouble c%d&quot;, i);
 360         i++;
 361       }
 362       else if (!strcmp(comp-&gt;base_type(globals), &quot;Bool&quot;)) {
 363         if (i &gt; 0) fprintf(fp,&quot;, &quot;);
 364         fprintf(fp,&quot;BoolTest::mask c%d&quot;, i);
 365         i++;
 366       }
 367     }
 368   }
 369   // finish line (1) and start line (2)
 370   fprintf(fp,&quot;)  : &quot;);
 371   // generate initializers for constants
 372   i = 0;
 373   fprintf(fp,&quot;_c%d(c%d)&quot;, i, i);
 374   for( i = 1; i &lt; num_consts; ++i) {
 375     fprintf(fp,&quot;, _c%d(c%d)&quot;, i, i);
 376   }
 377   // The body for the constructor is empty
 378   fprintf(fp,&quot; {}\n&quot;);
 379 }
 380 
 381 // ---------------------------------------------------------------------------
 382 // Utilities to generate format rules for machine operands and instructions
 383 // ---------------------------------------------------------------------------
 384 
 385 // Generate the format rule for condition codes
 386 static void defineCCodeDump(OperandForm* oper, FILE *fp, int i) {
 387   assert(oper != NULL, &quot;what&quot;);
 388   CondInterface* cond = oper-&gt;_interface-&gt;is_CondInterface();
 389   fprintf(fp, &quot;       if( _c%d == BoolTest::eq ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_equal_format);
 390   fprintf(fp, &quot;  else if( _c%d == BoolTest::ne ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_not_equal_format);
 391   fprintf(fp, &quot;  else if( _c%d == BoolTest::le ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_equal_format);
 392   fprintf(fp, &quot;  else if( _c%d == BoolTest::ge ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_equal_format);
 393   fprintf(fp, &quot;  else if( _c%d == BoolTest::lt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_less_format);
 394   fprintf(fp, &quot;  else if( _c%d == BoolTest::gt ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_greater_format);
 395   fprintf(fp, &quot;  else if( _c%d == BoolTest::overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_overflow_format);
 396   fprintf(fp, &quot;  else if( _c%d == BoolTest::no_overflow ) st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;,i,cond-&gt;_no_overflow_format);
 397 }
 398 
 399 // Output code that dumps constant values, increment &quot;i&quot; if type is constant
 400 static uint dump_spec_constant(FILE *fp, const char *ideal_type, uint i, OperandForm* oper) {
 401   if (!strcmp(ideal_type, &quot;ConI&quot;)) {
 402     fprintf(fp,&quot;   st-&gt;print(\&quot;#%%d\&quot;, _c%d);\n&quot;, i);
 403     fprintf(fp,&quot;   st-&gt;print(\&quot;/0x%%08x\&quot;, _c%d);\n&quot;, i);
 404     ++i;
 405   }
 406   else if (!strcmp(ideal_type, &quot;ConP&quot;)) {
 407     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 408     ++i;
 409   }
 410   else if (!strcmp(ideal_type, &quot;ConN&quot;)) {
 411     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 412     ++i;
 413   }
 414   else if (!strcmp(ideal_type, &quot;ConNKlass&quot;)) {
 415     fprintf(fp,&quot;    _c%d-&gt;dump_on(st);\n&quot;, i);
 416     ++i;
 417   }
 418   else if (!strcmp(ideal_type, &quot;ConL&quot;)) {
 419     fprintf(fp,&quot;    st-&gt;print(\&quot;#\&quot; INT64_FORMAT, (int64_t)_c%d);\n&quot;, i);
 420     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%d);\n&quot;, i);
 421     ++i;
 422   }
 423   else if (!strcmp(ideal_type, &quot;ConF&quot;)) {
 424     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 425     fprintf(fp,&quot;    jint _c%di = JavaValue(_c%d).get_jint();\n&quot;, i, i);
 426     fprintf(fp,&quot;    st-&gt;print(\&quot;/0x%%x/\&quot;, _c%di);\n&quot;, i);
 427     ++i;
 428   }
 429   else if (!strcmp(ideal_type, &quot;ConD&quot;)) {
 430     fprintf(fp,&quot;    st-&gt;print(\&quot;#%%f\&quot;, _c%d);\n&quot;, i);
 431     fprintf(fp,&quot;    jlong _c%dl = JavaValue(_c%d).get_jlong();\n&quot;, i, i);
 432     fprintf(fp,&quot;    st-&gt;print(\&quot;/\&quot; PTR64_FORMAT, (uint64_t)_c%dl);\n&quot;, i);
 433     ++i;
 434   }
 435   else if (!strcmp(ideal_type, &quot;Bool&quot;)) {
 436     defineCCodeDump(oper, fp,i);
 437     ++i;
 438   }
 439 
 440   return i;
 441 }
 442 
 443 // Generate the format rule for an operand
 444 void gen_oper_format(FILE *fp, FormDict &amp;globals, OperandForm &amp;oper, bool for_c_file = false) {
 445   if (!for_c_file) {
 446     // invoked after output #ifndef PRODUCT to ad_&lt;arch&gt;.hpp
 447     // compile the bodies separately, to cut down on recompilations
 448     fprintf(fp,&quot;  virtual void           int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;\n&quot;);
 449     fprintf(fp,&quot;  virtual void           ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const;\n&quot;);
 450     return;
 451   }
 452 
 453   // Local pointer indicates remaining part of format rule
 454   int idx = 0;                   // position of operand in match rule
 455 
 456   // Generate internal format function, used when stored locally
 457   fprintf(fp, &quot;\n#ifndef PRODUCT\n&quot;);
 458   fprintf(fp,&quot;void %sOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {\n&quot;, oper._ident);
 459   // Generate the user-defined portion of the format
 460   if (oper._format) {
 461     if ( oper._format-&gt;_strings.count() != 0 ) {
 462       // No initialization code for int_format
 463 
 464       // Build the format from the entries in strings and rep_vars
 465       const char  *string  = NULL;
 466       oper._format-&gt;_rep_vars.reset();
 467       oper._format-&gt;_strings.reset();
 468       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 469 
 470         // Check if this is a standard string or a replacement variable
 471         if ( string != NameList::_signal ) {
 472           // Normal string
 473           // Pass through to st-&gt;print
 474           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 475         } else {
 476           // Replacement variable
 477           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 478           // Check that it is a local name, and an operand
 479           const Form* form = oper._localNames[rep_var];
 480           if (form == NULL) {
 481             globalAD-&gt;syntax_err(oper._linenum,
 482                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 483             assert(form, &quot;replacement variable was not found in local names&quot;);
 484           }
 485           OperandForm *op      = form-&gt;is_operand();
 486           // Get index if register or constant
 487           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 488             idx  = oper.register_position( globals, rep_var);
 489           }
 490           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 491             idx  = oper.constant_position( globals, rep_var);
 492           } else {
 493             idx = 0;
 494           }
 495 
 496           // output invocation of &quot;$...&quot;s format function
 497           if ( op != NULL ) op-&gt;int_format(fp, globals, idx);
 498 
 499           if ( idx == -1 ) {
 500             fprintf(stderr,
 501                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 502             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 503           }
 504         } // Done with a replacement variable
 505       } // Done with all format strings
 506     } else {
 507       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 508       oper.int_format(fp, globals, 0);
 509     }
 510 
 511   } else { // oper._format == NULL
 512     // Provide a few special case formats where the AD writer cannot.
 513     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 514       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 515     }
 516     // labelOper::int_format is defined in ad_&lt;...&gt;.cpp
 517   }
 518   // ALWAYS! Provide a special case output for condition codes.
 519   if( oper.is_ideal_bool() ) {
 520     defineCCodeDump(&amp;oper, fp,0);
 521   }
 522   fprintf(fp,&quot;}\n&quot;);
 523 
 524   // Generate external format function, when data is stored externally
 525   fprintf(fp,&quot;void %sOper::ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const {\n&quot;, oper._ident);
 526   // Generate the user-defined portion of the format
 527   if (oper._format) {
 528     if ( oper._format-&gt;_strings.count() != 0 ) {
 529 
 530       // Check for a replacement string &quot;$...&quot;
 531       if ( oper._format-&gt;_rep_vars.count() != 0 ) {
 532         // Initialization code for ext_format
 533       }
 534 
 535       // Build the format from the entries in strings and rep_vars
 536       const char  *string  = NULL;
 537       oper._format-&gt;_rep_vars.reset();
 538       oper._format-&gt;_strings.reset();
 539       while ( (string = oper._format-&gt;_strings.iter()) != NULL ) {
 540 
 541         // Check if this is a standard string or a replacement variable
 542         if ( string != NameList::_signal ) {
 543           // Normal string
 544           // Pass through to st-&gt;print
 545           fprintf(fp,&quot;  st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 546         } else {
 547           // Replacement variable
 548           const char *rep_var = oper._format-&gt;_rep_vars.iter();
 549          // Check that it is a local name, and an operand
 550           const Form* form = oper._localNames[rep_var];
 551           if (form == NULL) {
 552             globalAD-&gt;syntax_err(oper._linenum,
 553                                  &quot;\&#39;%s\&#39; not found in format for %s\n&quot;, rep_var, oper._ident);
 554             assert(form, &quot;replacement variable was not found in local names&quot;);
 555           }
 556           OperandForm *op      = form-&gt;is_operand();
 557           // Get index if register or constant
 558           if ( op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_register(globals) ) {
 559             idx  = oper.register_position( globals, rep_var);
 560           }
 561           else if (op-&gt;_matrule &amp;&amp; op-&gt;_matrule-&gt;is_base_constant(globals)) {
 562             idx  = oper.constant_position( globals, rep_var);
 563           } else {
 564             idx = 0;
 565           }
 566           // output invocation of &quot;$...&quot;s format function
 567           if ( op != NULL )   op-&gt;ext_format(fp, globals, idx);
 568 
 569           // Lookup the index position of the replacement variable
 570           idx      = oper._components.operand_position_format(rep_var, &amp;oper);
 571           if ( idx == -1 ) {
 572             fprintf(stderr,
 573                     &quot;Using a name, %s, that isn&#39;t in match rule\n&quot;, rep_var);
 574             assert( strcmp(op-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 575           }
 576         } // Done with a replacement variable
 577       } // Done with all format strings
 578 
 579     } else {
 580       // Default formats for base operands (RegI, RegP, ConI, ConP, ...)
 581       oper.ext_format(fp, globals, 0);
 582     }
 583   } else { // oper._format == NULL
 584     // Provide a few special case formats where the AD writer cannot.
 585     if ( strcmp(oper._ident,&quot;Universe&quot;)==0 ) {
 586       fprintf(fp, &quot;  st-&gt;print(\&quot;$$univ\&quot;);\n&quot;);
 587     }
 588     // labelOper::ext_format is defined in ad_&lt;...&gt;.cpp
 589   }
 590   // ALWAYS! Provide a special case output for condition codes.
 591   if( oper.is_ideal_bool() ) {
 592     defineCCodeDump(&amp;oper, fp,0);
 593   }
 594   fprintf(fp, &quot;}\n&quot;);
 595   fprintf(fp, &quot;#endif\n&quot;);
 596 }
 597 
 598 
 599 // Generate the format rule for an instruction
 600 void gen_inst_format(FILE *fp, FormDict &amp;globals, InstructForm &amp;inst, bool for_c_file = false) {
 601   if (!for_c_file) {
 602     // compile the bodies separately, to cut down on recompilations
 603     // #ifndef PRODUCT region generated by caller
 604     fprintf(fp,&quot;  virtual void           format(PhaseRegAlloc *ra, outputStream *st) const;\n&quot;);
 605     return;
 606   }
 607 
 608   // Define the format function
 609   fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
 610   fprintf(fp, &quot;void %sNode::format(PhaseRegAlloc *ra, outputStream *st) const {\n&quot;, inst._ident);
 611 
 612   // Generate the user-defined portion of the format
 613   if( inst._format ) {
 614     // If there are replacement variables,
 615     // Generate index values needed for determining the operand position
 616     if( inst._format-&gt;_rep_vars.count() )
 617       inst.index_temps(fp, globals);
 618 
 619     // Build the format from the entries in strings and rep_vars
 620     const char  *string  = NULL;
 621     inst._format-&gt;_rep_vars.reset();
 622     inst._format-&gt;_strings.reset();
 623     while( (string = inst._format-&gt;_strings.iter()) != NULL ) {
 624       fprintf(fp,&quot;  &quot;);
 625       // Check if this is a standard string or a replacement variable
 626       if( string == NameList::_signal ) { // Replacement variable
 627         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 628         inst.rep_var_format( fp, rep_var);
 629       } else if( string == NameList::_signal3 ) { // Replacement variable in raw text
 630         const char* rep_var =  inst._format-&gt;_rep_vars.iter();
 631         const Form *form   = inst._localNames[rep_var];
 632         if (form == NULL) {
 633           fprintf(stderr, &quot;unknown replacement variable in format statement: &#39;%s&#39;\n&quot;, rep_var);
 634           assert(false, &quot;ShouldNotReachHere()&quot;);
 635         }
 636         OpClassForm *opc   = form-&gt;is_opclass();
 637         assert( opc, &quot;replacement variable was not found in local names&quot;);
 638         // Lookup the index position of the replacement variable
 639         int idx  = inst.operand_position_format(rep_var);
 640         if ( idx == -1 ) {
 641           assert( strcmp(opc-&gt;_ident,&quot;label&quot;)==0, &quot;Unimplemented&quot;);
 642           assert( false, &quot;ShouldNotReachHere()&quot;);
 643         }
 644 
 645         if (inst.is_noninput_operand(idx)) {
 646           assert( false, &quot;ShouldNotReachHere()&quot;);
 647         } else {
 648           // Output the format call for this operand
 649           fprintf(fp,&quot;opnd_array(%d)&quot;,idx);
 650         }
 651         rep_var =  inst._format-&gt;_rep_vars.iter();
 652         inst._format-&gt;_strings.iter();
 653         if ( strcmp(rep_var,&quot;$constant&quot;) == 0 &amp;&amp; opc-&gt;is_operand()) {
 654           Form::DataType constant_type = form-&gt;is_operand()-&gt;is_base_constant(globals);
 655           if ( constant_type == Form::idealD ) {
 656             fprintf(fp,&quot;-&gt;constantD()&quot;);
 657           } else if ( constant_type == Form::idealF ) {
 658             fprintf(fp,&quot;-&gt;constantF()&quot;);
 659           } else if ( constant_type == Form::idealL ) {
 660             fprintf(fp,&quot;-&gt;constantL()&quot;);
 661           } else {
 662             fprintf(fp,&quot;-&gt;constant()&quot;);
 663           }
 664         } else if ( strcmp(rep_var,&quot;$cmpcode&quot;) == 0) {
 665             fprintf(fp,&quot;-&gt;ccode()&quot;);
 666         } else {
 667           assert( false, &quot;ShouldNotReachHere()&quot;);
 668         }
 669       } else if( string == NameList::_signal2 ) // Raw program text
 670         fputs(inst._format-&gt;_strings.iter(), fp);
 671       else
 672         fprintf(fp,&quot;st-&gt;print_raw(\&quot;%s\&quot;);\n&quot;, string);
 673     } // Done with all format strings
 674   } // Done generating the user-defined portion of the format
 675 
 676   // Add call debug info automatically
 677   Form::CallType call_type = inst.is_ideal_call();
 678   if( call_type != Form::invalid_type ) {
 679     switch( call_type ) {
 680     case Form::JAVA_DYNAMIC:
 681       fprintf(fp,&quot;  _method-&gt;print_short_name(st);\n&quot;);
 682       break;
 683     case Form::JAVA_STATIC:
 684       fprintf(fp,&quot;  if( _method ) _method-&gt;print_short_name(st);\n&quot;);
 685       fprintf(fp,&quot;  else st-&gt;print(\&quot; wrapper for: %%s\&quot;, _name);\n&quot;);
 686       fprintf(fp,&quot;  if( !_method ) dump_trap_args(st);\n&quot;);
 687       break;
 688     case Form::JAVA_COMPILED:
 689     case Form::JAVA_INTERP:
 690       break;
 691     case Form::JAVA_RUNTIME:
 692     case Form::JAVA_LEAF:
 693     case Form::JAVA_NATIVE:
 694       fprintf(fp,&quot;  st-&gt;print(\&quot; %%s\&quot;, _name);&quot;);
 695       break;
 696     default:
 697       assert(0,&quot;ShouldNotReachHere&quot;);
 698     }
 699     fprintf(fp,  &quot;  st-&gt;cr();\n&quot; );
 700     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 701     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 702     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 703   }
 704   else if(inst.is_ideal_safepoint()) {
 705     fprintf(fp,  &quot;  st-&gt;print_raw(\&quot;\&quot;);\n&quot; );
 706     fprintf(fp,  &quot;  if (_jvms) _jvms-&gt;format(ra, this, st); else st-&gt;print_cr(\&quot;        No JVM State Info\&quot;);\n&quot; );
 707     fprintf(fp,  &quot;  st-&gt;print(\&quot;        # \&quot;);\n&quot; );
 708     fprintf(fp,  &quot;  if( _jvms &amp;&amp; _oop_map ) _oop_map-&gt;print_on(st);\n&quot;);
 709   }
 710   else if( inst.is_ideal_if() ) {
 711     fprintf(fp,  &quot;  st-&gt;print(\&quot;  P=%%f C=%%f\&quot;,_prob,_fcnt);\n&quot; );
 712   }
 713   else if( inst.is_ideal_mem() ) {
 714     // Print out the field name if available to improve readability
 715     fprintf(fp,  &quot;  if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;field() != NULL) {\n&quot;);
 716     fprintf(fp,  &quot;    ciField* f = ra-&gt;C-&gt;alias_type(adr_type())-&gt;field();\n&quot;);
 717     fprintf(fp,  &quot;    st-&gt;print(\&quot; %s Field: \&quot;);\n&quot;, commentSeperator);
 718     fprintf(fp,  &quot;    if (f-&gt;is_volatile())\n&quot;);
 719     fprintf(fp,  &quot;      st-&gt;print(\&quot;volatile \&quot;);\n&quot;);
 720     fprintf(fp,  &quot;    f-&gt;holder()-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 721     fprintf(fp,  &quot;    st-&gt;print(\&quot;.\&quot;);\n&quot;);
 722     fprintf(fp,  &quot;    f-&gt;name()-&gt;print_symbol_on(st);\n&quot;);
 723     fprintf(fp,  &quot;    if (f-&gt;is_constant())\n&quot;);
 724     fprintf(fp,  &quot;      st-&gt;print(\&quot; (constant)\&quot;);\n&quot;);
 725     fprintf(fp,  &quot;  } else {\n&quot;);
 726     // Make sure &#39;Volatile&#39; gets printed out
 727     fprintf(fp,  &quot;    if (ra-&gt;C-&gt;alias_type(adr_type())-&gt;is_volatile())\n&quot;);
 728     fprintf(fp,  &quot;      st-&gt;print(\&quot; volatile!\&quot;);\n&quot;);
 729     fprintf(fp,  &quot;  }\n&quot;);
 730   }
 731 
 732   // Complete the definition of the format function
 733   fprintf(fp, &quot;}\n#endif\n&quot;);
 734 }
 735 
 736 void ArchDesc::declare_pipe_classes(FILE *fp_hpp) {
 737   if (!_pipeline)
 738     return;
 739 
 740   fprintf(fp_hpp, &quot;\n&quot;);
 741   fprintf(fp_hpp, &quot;// Pipeline_Use_Cycle_Mask Class\n&quot;);
 742   fprintf(fp_hpp, &quot;class Pipeline_Use_Cycle_Mask {\n&quot;);
 743 
<a name="2" id="anc2"></a><span class="line-modified"> 744   if (_pipeline-&gt;_maxcycleused &lt;= 32) {</span>






 745     fprintf(fp_hpp, &quot;protected:\n&quot;);
 746     fprintf(fp_hpp, &quot;  %s _mask;\n\n&quot;, _pipeline-&gt;_maxcycleused &lt;= 32 ? &quot;uint&quot; : &quot;uint64_t&quot; );
 747     fprintf(fp_hpp, &quot;public:\n&quot;);
 748     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : _mask(0) {}\n\n&quot;);
 749     if (_pipeline-&gt;_maxcycleused &lt;= 32)
 750       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask) : _mask(mask) {}\n\n&quot;);
 751     else {
 752       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint mask1, uint mask2) : _mask((((uint64_t)mask1) &lt;&lt; 32) | mask2) {}\n\n&quot;);
 753       fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(uint64_t mask) : _mask(mask) {}\n\n&quot;);
 754     }
 755     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 756     fprintf(fp_hpp, &quot;    return ((_mask &amp; in2._mask) != 0);\n&quot;);
 757     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 758     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 759     fprintf(fp_hpp, &quot;    _mask &lt;&lt;= n;\n&quot;);
 760     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 761     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 762     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 763     fprintf(fp_hpp, &quot;    _mask |= in2._mask;\n&quot;);
 764     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 765     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 766     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 767   }
 768   else {
 769     fprintf(fp_hpp, &quot;protected:\n&quot;);
 770     uint masklen = (_pipeline-&gt;_maxcycleused + 31) &gt;&gt; 5;
 771     uint l;
 772     fprintf(fp_hpp, &quot;  uint &quot;);
 773     for (l = 1; l &lt;= masklen; l++)
 774       fprintf(fp_hpp, &quot;_mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;;\n\n&quot;);
 775     fprintf(fp_hpp, &quot;public:\n&quot;);
 776     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask() : &quot;);
 777     for (l = 1; l &lt;= masklen; l++)
 778       fprintf(fp_hpp, &quot;_mask%d(0)%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 779     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask(&quot;);
 780     for (l = 1; l &lt;= masklen; l++)
 781       fprintf(fp_hpp, &quot;uint mask%d%s&quot;, l, l &lt; masklen ? &quot;, &quot; : &quot;) : &quot;);
 782     for (l = 1; l &lt;= masklen; l++)
 783       fprintf(fp_hpp, &quot;_mask%d(mask%d)%s&quot;, l, l, l &lt; masklen ? &quot;, &quot; : &quot; {}\n\n&quot;);
 784 
 785     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask intersect(const Pipeline_Use_Cycle_Mask &amp;in2) {\n&quot;);
 786     fprintf(fp_hpp, &quot;    Pipeline_Use_Cycle_Mask out;\n&quot;);
 787     for (l = 1; l &lt;= masklen; l++)
 788       fprintf(fp_hpp, &quot;    out._mask%d = _mask%d &amp; in2._mask%d;\n&quot;, l, l, l);
 789     fprintf(fp_hpp, &quot;    return out;\n&quot;);
 790     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 791     fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Cycle_Mask &amp;in2) const {\n&quot;);
 792     fprintf(fp_hpp, &quot;    return (&quot;);
 793     for (l = 1; l &lt;= masklen; l++)
 794       fprintf(fp_hpp, &quot;((_mask%d &amp; in2._mask%d) != 0)%s&quot;, l, l, l &lt; masklen ? &quot; || &quot; : &quot;&quot;);
 795     fprintf(fp_hpp, &quot;) ? true : false;\n&quot;);
 796     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 797     fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask&amp; operator&lt;&lt;=(int n) {\n&quot;);
 798     fprintf(fp_hpp, &quot;    if (n &gt;= 32)\n&quot;);
 799     fprintf(fp_hpp, &quot;      do {\n       &quot;);
 800     for (l = masklen; l &gt; 1; l--)
 801       fprintf(fp_hpp, &quot; _mask%d = _mask%d;&quot;, l, l-1);
 802     fprintf(fp_hpp, &quot; _mask%d = 0;\n&quot;, 1);
 803     fprintf(fp_hpp, &quot;      } while ((n -= 32) &gt;= 32);\n\n&quot;);
 804     fprintf(fp_hpp, &quot;    if (n &gt; 0) {\n&quot;);
 805     fprintf(fp_hpp, &quot;      uint m = 32 - n;\n&quot;);
 806     fprintf(fp_hpp, &quot;      uint mask = (1 &lt;&lt; n) - 1;\n&quot;);
 807     fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n;\n&quot;, 2, 1, 1);
 808     for (l = 2; l &lt; masklen; l++) {
 809       fprintf(fp_hpp, &quot;      uint temp%d = mask &amp; (_mask%d &gt;&gt; m); _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, l+1, l, l, l, l);
 810     }
 811     fprintf(fp_hpp, &quot;      _mask%d &lt;&lt;= n; _mask%d |= temp%d;\n&quot;, masklen, masklen, masklen);
 812     fprintf(fp_hpp, &quot;    }\n&quot;);
 813 
 814     fprintf(fp_hpp, &quot;    return *this;\n&quot;);
 815     fprintf(fp_hpp, &quot;  }\n\n&quot;);
 816     fprintf(fp_hpp, &quot;  void Or(const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 817     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator&amp;(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n&quot;);
 818     fprintf(fp_hpp, &quot;  friend Pipeline_Use_Cycle_Mask operator|(const Pipeline_Use_Cycle_Mask &amp;, const Pipeline_Use_Cycle_Mask &amp;);\n\n&quot;);
 819   }
 820 
 821   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n\n&quot;);
 822   fprintf(fp_hpp, &quot;  friend class Pipeline_Use_Element;\n\n&quot;);
 823   fprintf(fp_hpp, &quot;};\n\n&quot;);
 824 
 825   uint rescount = 0;
 826   const char *resource;
 827 
 828   for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
 829       int mask = _pipeline-&gt;_resdict[resource]-&gt;is_resource()-&gt;mask();
 830       if ((mask &amp; (mask-1)) == 0)
 831         rescount++;
 832     }
 833 
 834   fprintf(fp_hpp, &quot;// Pipeline_Use_Element Class\n&quot;);
 835   fprintf(fp_hpp, &quot;class Pipeline_Use_Element {\n&quot;);
 836   fprintf(fp_hpp, &quot;protected:\n&quot;);
 837   fprintf(fp_hpp, &quot;  // Mask of used functional units\n&quot;);
 838   fprintf(fp_hpp, &quot;  uint _used;\n\n&quot;);
 839   fprintf(fp_hpp, &quot;  // Lower and upper bound of functional unit number range\n&quot;);
 840   fprintf(fp_hpp, &quot;  uint _lb, _ub;\n\n&quot;);
 841   fprintf(fp_hpp, &quot;  // Indicates multiple functionals units available\n&quot;);
 842   fprintf(fp_hpp, &quot;  bool _multiple;\n\n&quot;);
 843   fprintf(fp_hpp, &quot;  // Mask of specific used cycles\n&quot;);
 844   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask _mask;\n\n&quot;);
 845   fprintf(fp_hpp, &quot;public:\n&quot;);
 846   fprintf(fp_hpp, &quot;  Pipeline_Use_Element() {}\n\n&quot;);
 847   fprintf(fp_hpp, &quot;  Pipeline_Use_Element(uint used, uint lb, uint ub, bool multiple, Pipeline_Use_Cycle_Mask mask)\n&quot;);
 848   fprintf(fp_hpp, &quot;  : _used(used), _lb(lb), _ub(ub), _multiple(multiple), _mask(mask) {}\n\n&quot;);
 849   fprintf(fp_hpp, &quot;  uint used() const { return _used; }\n\n&quot;);
 850   fprintf(fp_hpp, &quot;  uint lowerBound() const { return _lb; }\n\n&quot;);
 851   fprintf(fp_hpp, &quot;  uint upperBound() const { return _ub; }\n\n&quot;);
 852   fprintf(fp_hpp, &quot;  bool multiple() const { return _multiple; }\n\n&quot;);
 853   fprintf(fp_hpp, &quot;  Pipeline_Use_Cycle_Mask mask() const { return _mask; }\n\n&quot;);
 854   fprintf(fp_hpp, &quot;  bool overlaps(const Pipeline_Use_Element &amp;in2) const {\n&quot;);
 855   fprintf(fp_hpp, &quot;    return ((_used &amp; in2._used) != 0 &amp;&amp; _mask.overlaps(in2._mask));\n&quot;);
 856   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 857   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 858   fprintf(fp_hpp, &quot;    _used = 0;\n&quot;);
 859   fprintf(fp_hpp, &quot;    _mask &lt;&lt;= cycles;\n&quot;);
 860   fprintf(fp_hpp, &quot;  }\n\n&quot;);
 861   fprintf(fp_hpp, &quot;  friend class Pipeline_Use;\n&quot;);
 862   fprintf(fp_hpp, &quot;};\n\n&quot;);
 863 
 864   fprintf(fp_hpp, &quot;// Pipeline_Use Class\n&quot;);
 865   fprintf(fp_hpp, &quot;class Pipeline_Use {\n&quot;);
 866   fprintf(fp_hpp, &quot;protected:\n&quot;);
 867   fprintf(fp_hpp, &quot;  // These resources can be used\n&quot;);
 868   fprintf(fp_hpp, &quot;  uint _resources_used;\n\n&quot;);
 869   fprintf(fp_hpp, &quot;  // These resources are used; excludes multiple choice functional units\n&quot;);
 870   fprintf(fp_hpp, &quot;  uint _resources_used_exclusively;\n\n&quot;);
 871   fprintf(fp_hpp, &quot;  // Number of elements\n&quot;);
 872   fprintf(fp_hpp, &quot;  uint _count;\n\n&quot;);
 873   fprintf(fp_hpp, &quot;  // This is the array of Pipeline_Use_Elements\n&quot;);
 874   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * _elements;\n\n&quot;);
 875   fprintf(fp_hpp, &quot;public:\n&quot;);
 876   fprintf(fp_hpp, &quot;  Pipeline_Use(uint resources_used, uint resources_used_exclusively, uint count, Pipeline_Use_Element *elements)\n&quot;);
 877   fprintf(fp_hpp, &quot;  : _resources_used(resources_used)\n&quot;);
 878   fprintf(fp_hpp, &quot;  , _resources_used_exclusively(resources_used_exclusively)\n&quot;);
 879   fprintf(fp_hpp, &quot;  , _count(count)\n&quot;);
 880   fprintf(fp_hpp, &quot;  , _elements(elements)\n&quot;);
 881   fprintf(fp_hpp, &quot;  {}\n\n&quot;);
 882   fprintf(fp_hpp, &quot;  uint resourcesUsed() const { return _resources_used; }\n\n&quot;);
 883   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const { return _resources_used_exclusively; }\n\n&quot;);
 884   fprintf(fp_hpp, &quot;  uint count() const { return _count; }\n\n&quot;);
 885   fprintf(fp_hpp, &quot;  Pipeline_Use_Element * element(uint i) const { return &amp;_elements[i]; }\n\n&quot;);
 886   fprintf(fp_hpp, &quot;  uint full_latency(uint delay, const Pipeline_Use &amp;pred) const;\n\n&quot;);
 887   fprintf(fp_hpp, &quot;  void add_usage(const Pipeline_Use &amp;pred);\n\n&quot;);
 888   fprintf(fp_hpp, &quot;  void reset() {\n&quot;);
 889   fprintf(fp_hpp, &quot;    _resources_used = _resources_used_exclusively = 0;\n&quot;);
 890   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 891   fprintf(fp_hpp, &quot;  void step(uint cycles) {\n&quot;);
 892   fprintf(fp_hpp, &quot;    reset();\n&quot;);
 893   fprintf(fp_hpp, &quot;    for (uint i = 0; i &lt; %d; i++)\n&quot;,
 894     rescount);
 895   fprintf(fp_hpp, &quot;      (&amp;_elements[i])-&gt;step(cycles);\n&quot;);
 896   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 897   fprintf(fp_hpp, &quot;  static const Pipeline_Use         elaborated_use;\n&quot;);
 898   fprintf(fp_hpp, &quot;  static const Pipeline_Use_Element elaborated_elements[%d];\n\n&quot;,
 899     rescount);
 900   fprintf(fp_hpp, &quot;  friend class Pipeline;\n&quot;);
 901   fprintf(fp_hpp, &quot;};\n\n&quot;);
 902 
 903   fprintf(fp_hpp, &quot;// Pipeline Class\n&quot;);
 904   fprintf(fp_hpp, &quot;class Pipeline {\n&quot;);
 905   fprintf(fp_hpp, &quot;public:\n&quot;);
 906 
 907   fprintf(fp_hpp, &quot;  static bool enabled() { return %s; }\n\n&quot;,
 908     _pipeline ? &quot;true&quot; : &quot;false&quot; );
 909 
 910   assert( _pipeline-&gt;_maxInstrsPerBundle &amp;&amp;
 911         ( _pipeline-&gt;_instrUnitSize || _pipeline-&gt;_bundleUnitSize) &amp;&amp;
 912           _pipeline-&gt;_instrFetchUnitSize &amp;&amp;
 913           _pipeline-&gt;_instrFetchUnits,
 914     &quot;unspecified pipeline architecture units&quot;);
 915 
 916   uint unitSize = _pipeline-&gt;_instrUnitSize ? _pipeline-&gt;_instrUnitSize : _pipeline-&gt;_bundleUnitSize;
 917 
 918   fprintf(fp_hpp, &quot;  enum {\n&quot;);
 919   fprintf(fp_hpp, &quot;    _variable_size_instructions = %d,\n&quot;,
 920     _pipeline-&gt;_variableSizeInstrs ? 1 : 0);
 921   fprintf(fp_hpp, &quot;    _fixed_size_instructions = %d,\n&quot;,
 922     _pipeline-&gt;_variableSizeInstrs ? 0 : 1);
 923   fprintf(fp_hpp, &quot;    _branch_has_delay_slot = %d,\n&quot;,
 924     _pipeline-&gt;_branchHasDelaySlot ? 1 : 0);
 925   fprintf(fp_hpp, &quot;    _max_instrs_per_bundle = %d,\n&quot;,
 926     _pipeline-&gt;_maxInstrsPerBundle);
 927   fprintf(fp_hpp, &quot;    _max_bundles_per_cycle = %d,\n&quot;,
 928     _pipeline-&gt;_maxBundlesPerCycle);
 929   fprintf(fp_hpp, &quot;    _max_instrs_per_cycle = %d\n&quot;,
 930     _pipeline-&gt;_maxBundlesPerCycle * _pipeline-&gt;_maxInstrsPerBundle);
 931   fprintf(fp_hpp, &quot;  };\n\n&quot;);
 932 
 933   fprintf(fp_hpp, &quot;  static bool instr_has_unit_size() { return %s; }\n\n&quot;,
 934     _pipeline-&gt;_instrUnitSize != 0 ? &quot;true&quot; : &quot;false&quot; );
 935   if( _pipeline-&gt;_bundleUnitSize != 0 )
 936     if( _pipeline-&gt;_instrUnitSize != 0 )
 937       fprintf(fp_hpp, &quot;// Individual Instructions may be bundled together by the hardware\n\n&quot;);
 938     else
 939       fprintf(fp_hpp, &quot;// Instructions exist only in bundles\n\n&quot;);
 940   else
 941     fprintf(fp_hpp, &quot;// Bundling is not supported\n\n&quot;);
 942   if( _pipeline-&gt;_instrUnitSize != 0 )
 943     fprintf(fp_hpp, &quot;  // Size of an instruction\n&quot;);
 944   else
 945     fprintf(fp_hpp, &quot;  // Size of an individual instruction does not exist - unsupported\n&quot;);
 946   fprintf(fp_hpp, &quot;  static uint instr_unit_size() {&quot;);
 947   if( _pipeline-&gt;_instrUnitSize == 0 )
 948     fprintf(fp_hpp, &quot; assert( false, \&quot;Instructions are only in bundles\&quot; );&quot;);
 949   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_instrUnitSize);
 950 
 951   if( _pipeline-&gt;_bundleUnitSize != 0 )
 952     fprintf(fp_hpp, &quot;  // Size of a bundle\n&quot;);
 953   else
 954     fprintf(fp_hpp, &quot;  // Bundles do not exist - unsupported\n&quot;);
 955   fprintf(fp_hpp, &quot;  static uint bundle_unit_size() {&quot;);
 956   if( _pipeline-&gt;_bundleUnitSize == 0 )
 957     fprintf(fp_hpp, &quot; assert( false, \&quot;Bundles are not supported\&quot; );&quot;);
 958   fprintf(fp_hpp, &quot; return %d; };\n\n&quot;, _pipeline-&gt;_bundleUnitSize);
 959 
 960   fprintf(fp_hpp, &quot;  static bool requires_bundling() { return %s; }\n\n&quot;,
 961     _pipeline-&gt;_bundleUnitSize != 0 &amp;&amp; _pipeline-&gt;_instrUnitSize == 0 ? &quot;true&quot; : &quot;false&quot; );
 962 
 963   fprintf(fp_hpp, &quot;private:\n&quot;);
 964   fprintf(fp_hpp, &quot;  Pipeline();  // Not a legal constructor\n&quot;);
 965   fprintf(fp_hpp, &quot;\n&quot;);
 966   fprintf(fp_hpp, &quot;  const unsigned char                   _read_stage_count;\n&quot;);
 967   fprintf(fp_hpp, &quot;  const unsigned char                   _write_stage;\n&quot;);
 968   fprintf(fp_hpp, &quot;  const unsigned char                   _fixed_latency;\n&quot;);
 969   fprintf(fp_hpp, &quot;  const unsigned char                   _instruction_count;\n&quot;);
 970   fprintf(fp_hpp, &quot;  const bool                            _has_fixed_latency;\n&quot;);
 971   fprintf(fp_hpp, &quot;  const bool                            _has_branch_delay;\n&quot;);
 972   fprintf(fp_hpp, &quot;  const bool                            _has_multiple_bundles;\n&quot;);
 973   fprintf(fp_hpp, &quot;  const bool                            _force_serialization;\n&quot;);
 974   fprintf(fp_hpp, &quot;  const bool                            _may_have_no_code;\n&quot;);
 975   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _read_stages;\n&quot;);
 976   fprintf(fp_hpp, &quot;  const enum machPipelineStages * const _resource_stage;\n&quot;);
 977   fprintf(fp_hpp, &quot;  const uint                    * const _resource_cycles;\n&quot;);
 978   fprintf(fp_hpp, &quot;  const Pipeline_Use                    _resource_use;\n&quot;);
 979   fprintf(fp_hpp, &quot;\n&quot;);
 980   fprintf(fp_hpp, &quot;public:\n&quot;);
 981   fprintf(fp_hpp, &quot;  Pipeline(uint                            write_stage,\n&quot;);
 982   fprintf(fp_hpp, &quot;           uint                            count,\n&quot;);
 983   fprintf(fp_hpp, &quot;           bool                            has_fixed_latency,\n&quot;);
 984   fprintf(fp_hpp, &quot;           uint                            fixed_latency,\n&quot;);
 985   fprintf(fp_hpp, &quot;           uint                            instruction_count,\n&quot;);
 986   fprintf(fp_hpp, &quot;           bool                            has_branch_delay,\n&quot;);
 987   fprintf(fp_hpp, &quot;           bool                            has_multiple_bundles,\n&quot;);
 988   fprintf(fp_hpp, &quot;           bool                            force_serialization,\n&quot;);
 989   fprintf(fp_hpp, &quot;           bool                            may_have_no_code,\n&quot;);
 990   fprintf(fp_hpp, &quot;           enum machPipelineStages * const dst,\n&quot;);
 991   fprintf(fp_hpp, &quot;           enum machPipelineStages * const stage,\n&quot;);
 992   fprintf(fp_hpp, &quot;           uint                    * const cycles,\n&quot;);
 993   fprintf(fp_hpp, &quot;           Pipeline_Use                    resource_use)\n&quot;);
 994   fprintf(fp_hpp, &quot;  : _read_stage_count(count)\n&quot;);
 995   fprintf(fp_hpp, &quot;  , _write_stage(write_stage)\n&quot;);
 996   fprintf(fp_hpp, &quot;  , _fixed_latency(fixed_latency)\n&quot;);
 997   fprintf(fp_hpp, &quot;  , _instruction_count(instruction_count)\n&quot;);
 998   fprintf(fp_hpp, &quot;  , _has_fixed_latency(has_fixed_latency)\n&quot;);
 999   fprintf(fp_hpp, &quot;  , _has_branch_delay(has_branch_delay)\n&quot;);
1000   fprintf(fp_hpp, &quot;  , _has_multiple_bundles(has_multiple_bundles)\n&quot;);
1001   fprintf(fp_hpp, &quot;  , _force_serialization(force_serialization)\n&quot;);
1002   fprintf(fp_hpp, &quot;  , _may_have_no_code(may_have_no_code)\n&quot;);
1003   fprintf(fp_hpp, &quot;  , _read_stages(dst)\n&quot;);
1004   fprintf(fp_hpp, &quot;  , _resource_stage(stage)\n&quot;);
1005   fprintf(fp_hpp, &quot;  , _resource_cycles(cycles)\n&quot;);
1006   fprintf(fp_hpp, &quot;  , _resource_use(resource_use)\n&quot;);
1007   fprintf(fp_hpp, &quot;  {};\n&quot;);
1008   fprintf(fp_hpp, &quot;\n&quot;);
1009   fprintf(fp_hpp, &quot;  uint writeStage() const {\n&quot;);
1010   fprintf(fp_hpp, &quot;    return (_write_stage);\n&quot;);
1011   fprintf(fp_hpp, &quot;  }\n&quot;);
1012   fprintf(fp_hpp, &quot;\n&quot;);
1013   fprintf(fp_hpp, &quot;  enum machPipelineStages readStage(int ndx) const {\n&quot;);
1014   fprintf(fp_hpp, &quot;    return (ndx &lt; _read_stage_count ? _read_stages[ndx] : stage_undefined);&quot;);
1015   fprintf(fp_hpp, &quot;  }\n\n&quot;);
1016   fprintf(fp_hpp, &quot;  uint resourcesUsed() const {\n&quot;);
1017   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsed();\n  }\n\n&quot;);
1018   fprintf(fp_hpp, &quot;  uint resourcesUsedExclusively() const {\n&quot;);
1019   fprintf(fp_hpp, &quot;    return _resource_use.resourcesUsedExclusively();\n  }\n\n&quot;);
1020   fprintf(fp_hpp, &quot;  bool hasFixedLatency() const {\n&quot;);
1021   fprintf(fp_hpp, &quot;    return (_has_fixed_latency);\n  }\n\n&quot;);
1022   fprintf(fp_hpp, &quot;  uint fixedLatency() const {\n&quot;);
1023   fprintf(fp_hpp, &quot;    return (_fixed_latency);\n  }\n\n&quot;);
1024   fprintf(fp_hpp, &quot;  uint functional_unit_latency(uint start, const Pipeline *pred) const;\n\n&quot;);
1025   fprintf(fp_hpp, &quot;  uint operand_latency(uint opnd, const Pipeline *pred) const;\n\n&quot;);
1026   fprintf(fp_hpp, &quot;  const Pipeline_Use&amp; resourceUse() const {\n&quot;);
1027   fprintf(fp_hpp, &quot;    return (_resource_use); }\n\n&quot;);
1028   fprintf(fp_hpp, &quot;  const Pipeline_Use_Element * resourceUseElement(uint i) const {\n&quot;);
1029   fprintf(fp_hpp, &quot;    return (&amp;_resource_use._elements[i]); }\n\n&quot;);
1030   fprintf(fp_hpp, &quot;  uint resourceUseCount() const {\n&quot;);
1031   fprintf(fp_hpp, &quot;    return (_resource_use._count); }\n\n&quot;);
1032   fprintf(fp_hpp, &quot;  uint instructionCount() const {\n&quot;);
1033   fprintf(fp_hpp, &quot;    return (_instruction_count); }\n\n&quot;);
1034   fprintf(fp_hpp, &quot;  bool hasBranchDelay() const {\n&quot;);
1035   fprintf(fp_hpp, &quot;    return (_has_branch_delay); }\n\n&quot;);
1036   fprintf(fp_hpp, &quot;  bool hasMultipleBundles() const {\n&quot;);
1037   fprintf(fp_hpp, &quot;    return (_has_multiple_bundles); }\n\n&quot;);
1038   fprintf(fp_hpp, &quot;  bool forceSerialization() const {\n&quot;);
1039   fprintf(fp_hpp, &quot;    return (_force_serialization); }\n\n&quot;);
1040   fprintf(fp_hpp, &quot;  bool mayHaveNoCode() const {\n&quot;);
1041   fprintf(fp_hpp, &quot;    return (_may_have_no_code); }\n\n&quot;);
1042   fprintf(fp_hpp, &quot;//const Pipeline_Use_Cycle_Mask&amp; resourceUseMask(int resource) const {\n&quot;);
1043   fprintf(fp_hpp, &quot;//  return (_resource_use_masks[resource]); }\n\n&quot;);
1044   fprintf(fp_hpp, &quot;\n#ifndef PRODUCT\n&quot;);
1045   fprintf(fp_hpp, &quot;  static const char * stageName(uint i);\n&quot;);
1046   fprintf(fp_hpp, &quot;#endif\n&quot;);
1047   fprintf(fp_hpp, &quot;};\n\n&quot;);
1048 
1049   fprintf(fp_hpp, &quot;// Bundle class\n&quot;);
1050   fprintf(fp_hpp, &quot;class Bundle {\n&quot;);
1051 
1052   uint mshift = 0;
1053   for (uint msize = _pipeline-&gt;_maxInstrsPerBundle * _pipeline-&gt;_maxBundlesPerCycle; msize != 0; msize &gt;&gt;= 1)
1054     mshift++;
1055 
1056   uint rshift = rescount;
1057 
1058   fprintf(fp_hpp, &quot;protected:\n&quot;);
1059   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1060   fprintf(fp_hpp, &quot;    _unused_delay                   = 0x%x,\n&quot;, 0);
1061   fprintf(fp_hpp, &quot;    _use_nop_delay                  = 0x%x,\n&quot;, 1);
1062   fprintf(fp_hpp, &quot;    _use_unconditional_delay        = 0x%x,\n&quot;, 2);
1063   fprintf(fp_hpp, &quot;    _use_conditional_delay          = 0x%x,\n&quot;, 3);
1064   fprintf(fp_hpp, &quot;    _used_in_conditional_delay      = 0x%x,\n&quot;, 4);
1065   fprintf(fp_hpp, &quot;    _used_in_unconditional_delay    = 0x%x,\n&quot;, 5);
1066   fprintf(fp_hpp, &quot;    _used_in_all_conditional_delays = 0x%x,\n&quot;, 6);
1067   fprintf(fp_hpp, &quot;\n&quot;);
1068   fprintf(fp_hpp, &quot;    _use_delay                      = 0x%x,\n&quot;, 3);
1069   fprintf(fp_hpp, &quot;    _used_in_delay                  = 0x%x\n&quot;,  4);
1070   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1071   fprintf(fp_hpp, &quot;  uint _flags          : 3,\n&quot;);
1072   fprintf(fp_hpp, &quot;       _starts_bundle  : 1,\n&quot;);
1073   fprintf(fp_hpp, &quot;       _instr_count    : %d,\n&quot;,   mshift);
1074   fprintf(fp_hpp, &quot;       _resources_used : %d;\n&quot;,   rshift);
1075   fprintf(fp_hpp, &quot;public:\n&quot;);
1076   fprintf(fp_hpp, &quot;  Bundle() : _flags(_unused_delay), _starts_bundle(0), _instr_count(0), _resources_used(0) {}\n\n&quot;);
1077   fprintf(fp_hpp, &quot;  void set_instr_count(uint i) { _instr_count  = i; }\n&quot;);
1078   fprintf(fp_hpp, &quot;  void set_resources_used(uint i) { _resources_used   = i; }\n&quot;);
1079   fprintf(fp_hpp, &quot;  void clear_usage() { _flags = _unused_delay; }\n&quot;);
1080   fprintf(fp_hpp, &quot;  void set_starts_bundle() { _starts_bundle = true; }\n&quot;);
1081 
1082   fprintf(fp_hpp, &quot;  uint flags() const { return (_flags); }\n&quot;);
1083   fprintf(fp_hpp, &quot;  uint instr_count() const { return (_instr_count); }\n&quot;);
1084   fprintf(fp_hpp, &quot;  uint resources_used() const { return (_resources_used); }\n&quot;);
1085   fprintf(fp_hpp, &quot;  bool starts_bundle() const { return (_starts_bundle != 0); }\n&quot;);
1086 
1087   fprintf(fp_hpp, &quot;  void set_use_nop_delay() { _flags = _use_nop_delay; }\n&quot;);
1088   fprintf(fp_hpp, &quot;  void set_use_unconditional_delay() { _flags = _use_unconditional_delay; }\n&quot;);
1089   fprintf(fp_hpp, &quot;  void set_use_conditional_delay() { _flags = _use_conditional_delay; }\n&quot;);
1090   fprintf(fp_hpp, &quot;  void set_used_in_unconditional_delay() { _flags = _used_in_unconditional_delay; }\n&quot;);
1091   fprintf(fp_hpp, &quot;  void set_used_in_conditional_delay() { _flags = _used_in_conditional_delay; }\n&quot;);
1092   fprintf(fp_hpp, &quot;  void set_used_in_all_conditional_delays() { _flags = _used_in_all_conditional_delays; }\n&quot;);
1093 
1094   fprintf(fp_hpp, &quot;  bool use_nop_delay() { return (_flags == _use_nop_delay); }\n&quot;);
1095   fprintf(fp_hpp, &quot;  bool use_unconditional_delay() { return (_flags == _use_unconditional_delay); }\n&quot;);
1096   fprintf(fp_hpp, &quot;  bool use_conditional_delay() { return (_flags == _use_conditional_delay); }\n&quot;);
1097   fprintf(fp_hpp, &quot;  bool used_in_unconditional_delay() { return (_flags == _used_in_unconditional_delay); }\n&quot;);
1098   fprintf(fp_hpp, &quot;  bool used_in_conditional_delay() { return (_flags == _used_in_conditional_delay); }\n&quot;);
1099   fprintf(fp_hpp, &quot;  bool used_in_all_conditional_delays() { return (_flags == _used_in_all_conditional_delays); }\n&quot;);
1100   fprintf(fp_hpp, &quot;  bool use_delay() { return ((_flags &amp; _use_delay) != 0); }\n&quot;);
1101   fprintf(fp_hpp, &quot;  bool used_in_delay() { return ((_flags &amp; _used_in_delay) != 0); }\n\n&quot;);
1102 
1103   fprintf(fp_hpp, &quot;  enum {\n&quot;);
1104   fprintf(fp_hpp, &quot;    _nop_count = %d\n&quot;,
1105     _pipeline-&gt;_nopcnt);
1106   fprintf(fp_hpp, &quot;  };\n\n&quot;);
1107   fprintf(fp_hpp, &quot;  static void initialize_nops(MachNode *nop_list[%d]);\n\n&quot;,
1108     _pipeline-&gt;_nopcnt);
1109   fprintf(fp_hpp, &quot;#ifndef PRODUCT\n&quot;);
1110   fprintf(fp_hpp, &quot;  void dump(outputStream *st = tty) const;\n&quot;);
1111   fprintf(fp_hpp, &quot;#endif\n&quot;);
1112   fprintf(fp_hpp, &quot;};\n\n&quot;);
1113 
1114 //  const char *classname;
1115 //  for (_pipeline-&gt;_classlist.reset(); (classname = _pipeline-&gt;_classlist.iter()) != NULL; ) {
1116 //    PipeClassForm *pipeclass = _pipeline-&gt;_classdict[classname]-&gt;is_pipeclass();
1117 //    fprintf(fp_hpp, &quot;// Pipeline Class Instance for \&quot;%s\&quot;\n&quot;, classname);
1118 //  }
1119 }
1120 
1121 //------------------------------declareClasses---------------------------------
1122 // Construct the class hierarchy of MachNode classes from the instruction &amp;
1123 // operand lists
1124 void ArchDesc::declareClasses(FILE *fp) {
1125 
1126   // Declare an array containing the machine register names, strings.
1127   declareRegNames(fp, _register);
1128 
1129   // Declare an array containing the machine register encoding values
1130   declareRegEncodes(fp, _register);
1131 
1132   // Generate declarations for the total number of operands
1133   fprintf(fp,&quot;\n&quot;);
1134   fprintf(fp,&quot;// Total number of operands defined in architecture definition\n&quot;);
1135   int num_operands = 0;
1136   OperandForm *op;
1137   for (_operands.reset(); (op = (OperandForm*)_operands.iter()) != NULL; ) {
1138     // Ensure this is a machine-world instruction
1139     if (op-&gt;ideal_only()) continue;
1140 
1141     ++num_operands;
1142   }
1143   int first_operand_class = num_operands;
1144   OpClassForm *opc;
1145   for (_opclass.reset(); (opc = (OpClassForm*)_opclass.iter()) != NULL; ) {
1146     // Ensure this is a machine-world instruction
1147     if (opc-&gt;ideal_only()) continue;
1148 
1149     ++num_operands;
1150   }
1151   fprintf(fp,&quot;#define FIRST_OPERAND_CLASS   %d\n&quot;, first_operand_class);
1152   fprintf(fp,&quot;#define NUM_OPERANDS          %d\n&quot;, num_operands);
1153   fprintf(fp,&quot;\n&quot;);
1154   // Generate declarations for the total number of instructions
1155   fprintf(fp,&quot;// Total number of instructions defined in architecture definition\n&quot;);
1156   fprintf(fp,&quot;#define NUM_INSTRUCTIONS   %d\n&quot;,instructFormCount());
1157 
1158 
1159   // Generate Machine Classes for each operand defined in AD file
1160   fprintf(fp,&quot;\n&quot;);
1161   fprintf(fp,&quot;//----------------------------Declare classes derived from MachOper----------\n&quot;);
1162   // Iterate through all operands
1163   _operands.reset();
1164   OperandForm *oper;
1165   for( ; (oper = (OperandForm*)_operands.iter()) != NULL;) {
1166     // Ensure this is a machine-world instruction
1167     if (oper-&gt;ideal_only() ) continue;
1168     // The declaration of labelOper is in machine-independent file: machnode
1169     if ( strcmp(oper-&gt;_ident,&quot;label&quot;)  == 0 ) continue;
1170     // The declaration of methodOper is in machine-independent file: machnode
1171     if ( strcmp(oper-&gt;_ident,&quot;method&quot;) == 0 ) continue;
1172 
1173     // Build class definition for this operand
1174     fprintf(fp,&quot;\n&quot;);
1175     fprintf(fp,&quot;class %sOper : public MachOper { \n&quot;,oper-&gt;_ident);
1176     fprintf(fp,&quot;private:\n&quot;);
1177     // Operand definitions that depend upon number of input edges
1178     {
1179       uint num_edges = oper-&gt;num_edges(_globalNames);
1180       if( num_edges != 1 ) { // Use MachOper::num_edges() {return 1;}
1181         fprintf(fp,&quot;  virtual uint           num_edges() const { return %d; }\n&quot;,
1182               num_edges );
1183       }
1184       if( num_edges &gt; 0 ) {
1185         in_RegMask(fp);
1186       }
1187     }
1188 
1189     // Support storing constants inside the MachOper
1190     declareConstStorage(fp,_globalNames,oper);
1191 
1192     // Support storage of the condition codes
1193     if( oper-&gt;is_ideal_bool() ) {
1194       fprintf(fp,&quot;  virtual int ccode() const { \n&quot;);
1195       fprintf(fp,&quot;    switch (_c0) {\n&quot;);
1196       fprintf(fp,&quot;    case  BoolTest::eq : return equal();\n&quot;);
1197       fprintf(fp,&quot;    case  BoolTest::gt : return greater();\n&quot;);
1198       fprintf(fp,&quot;    case  BoolTest::lt : return less();\n&quot;);
1199       fprintf(fp,&quot;    case  BoolTest::ne : return not_equal();\n&quot;);
1200       fprintf(fp,&quot;    case  BoolTest::le : return less_equal();\n&quot;);
1201       fprintf(fp,&quot;    case  BoolTest::ge : return greater_equal();\n&quot;);
1202       fprintf(fp,&quot;    case  BoolTest::overflow : return overflow();\n&quot;);
1203       fprintf(fp,&quot;    case  BoolTest::no_overflow: return no_overflow();\n&quot;);
1204       fprintf(fp,&quot;    default : ShouldNotReachHere(); return 0;\n&quot;);
1205       fprintf(fp,&quot;    }\n&quot;);
1206       fprintf(fp,&quot;  };\n&quot;);
1207     }
1208 
1209     // Support storage of the condition codes
1210     if( oper-&gt;is_ideal_bool() ) {
1211       fprintf(fp,&quot;  virtual void negate() { \n&quot;);
1212       fprintf(fp,&quot;    _c0 = (BoolTest::mask)((int)_c0^0x4); \n&quot;);
1213       fprintf(fp,&quot;  };\n&quot;);
1214     }
1215 
1216     // Declare constructor.
1217     // Parameters start with condition code, then all other constants
1218     //
1219     // (1)  MachXOper(int32 ccode, int32 c0, int32 c1, ..., int32 cn)
1220     // (2)     : _ccode(ccode), _c0(c0), _c1(c1), ..., _cn(cn) { }
1221     //
1222     Form::DataType constant_type = oper-&gt;simple_type(_globalNames);
1223     defineConstructor(fp, oper-&gt;_ident, oper-&gt;num_consts(_globalNames),
1224                       oper-&gt;_components, oper-&gt;is_ideal_bool(),
1225                       constant_type, _globalNames);
1226 
1227     // Clone function
1228     fprintf(fp,&quot;  virtual MachOper      *clone() const;\n&quot;);
1229 
1230     // Support setting a spill offset into a constant operand.
1231     // We only support setting an &#39;int&#39; offset, while in the
1232     // LP64 build spill offsets are added with an AddP which
1233     // requires a long constant.  Thus we don&#39;t support spilling
1234     // in frames larger than 4Gig.
1235     if( oper-&gt;has_conI(_globalNames) ||
1236         oper-&gt;has_conL(_globalNames) )
1237       fprintf(fp, &quot;  virtual void set_con( jint c0 ) { _c0 = c0; }\n&quot;);
1238 
1239     // virtual functions for encoding and format
1240     //    fprintf(fp,&quot;  virtual void           encode()   const {\n    %s }\n&quot;,
1241     //            (oper-&gt;_encrule)?(oper-&gt;_encrule-&gt;_encrule):&quot;&quot;);
1242     // Check the interface type, and generate the correct query functions
1243     // encoding queries based upon MEMORY_INTER, REG_INTER, CONST_INTER.
1244 
1245     fprintf(fp,&quot;  virtual uint           opcode() const { return %s; }\n&quot;,
1246             machOperEnum(oper-&gt;_ident));
1247 
1248     // virtual function to look up ideal return type of machine instruction
1249     //
1250     // (1)  virtual const Type    *type() const { return .....; }
1251     //
1252     if ((oper-&gt;_matrule) &amp;&amp; (oper-&gt;_matrule-&gt;_lChild == NULL) &amp;&amp;
1253         (oper-&gt;_matrule-&gt;_rChild == NULL)) {
1254       unsigned int position = 0;
1255       const char  *opret, *opname, *optype;
1256       oper-&gt;_matrule-&gt;base_operand(position,_globalNames,opret,opname,optype);
1257       fprintf(fp,&quot;  virtual const Type    *type() const {&quot;);
1258       const char *type = getIdealType(optype);
1259       if( type != NULL ) {
1260         Form::DataType data_type = oper-&gt;is_base_constant(_globalNames);
1261         // Check if we are an ideal pointer type
1262         if( data_type == Form::idealP || data_type == Form::idealN || data_type == Form::idealNKlass ) {
1263           // Return the ideal type we already have: &lt;TypePtr *&gt;
1264           fprintf(fp,&quot; return _c0;&quot;);
1265         } else {
1266           // Return the appropriate bottom type
1267           fprintf(fp,&quot; return %s;&quot;, getIdealType(optype));
1268         }
1269       } else {
1270         fprintf(fp,&quot; ShouldNotCallThis(); return Type::BOTTOM;&quot;);
1271       }
1272       fprintf(fp,&quot; }\n&quot;);
1273     } else {
1274       // Check for user-defined stack slots, based upon sRegX
1275       Form::DataType data_type = oper-&gt;is_user_name_for_sReg();
1276       if( data_type != Form::none ){
1277         const char *type = NULL;
1278         switch( data_type ) {
1279         case Form::idealI: type = &quot;TypeInt::INT&quot;;   break;
1280         case Form::idealP: type = &quot;TypePtr::BOTTOM&quot;;break;
1281         case Form::idealF: type = &quot;Type::FLOAT&quot;;    break;
1282         case Form::idealD: type = &quot;Type::DOUBLE&quot;;   break;
1283         case Form::idealL: type = &quot;TypeLong::LONG&quot;; break;
1284         case Form::none: // fall through
1285         default:
1286           assert( false, &quot;No support for this type of stackSlot&quot;);
1287         }
1288         fprintf(fp,&quot;  virtual const Type    *type() const { return %s; } // stackSlotX\n&quot;, type);
1289       }
1290     }
1291 
1292 
1293     //
1294     // virtual functions for defining the encoding interface.
1295     //
1296     // Access the linearized ideal register mask,
1297     // map to physical register encoding
1298     if ( oper-&gt;_matrule &amp;&amp; oper-&gt;_matrule-&gt;is_base_register(_globalNames) ) {
1299       // Just use the default virtual &#39;reg&#39; call
1300     } else if ( oper-&gt;ideal_to_sReg_type(oper-&gt;_ident) != Form::none ) {
1301       // Special handling for operand &#39;sReg&#39;, a Stack Slot Register.
1302       // Map linearized ideal register mask to stack slot number
1303       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node) const {\n&quot;);
1304       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node));/* sReg */\n&quot;);
1305       fprintf(fp,&quot;  }\n&quot;);
1306       fprintf(fp,&quot;  virtual int            reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {\n&quot;);
1307       fprintf(fp,&quot;    return (int)OptoReg::reg2stack(ra_-&gt;get_reg_first(node-&gt;in(idx)));/* sReg */\n&quot;);
1308       fprintf(fp,&quot;  }\n&quot;);
1309     }
1310 
1311     // Output the operand specific access functions used by an enc_class
1312     // These are only defined when we want to override the default virtual func
1313     if (oper-&gt;_interface != NULL) {
1314       fprintf(fp,&quot;\n&quot;);
1315       // Check if it is a Memory Interface
1316       if ( oper-&gt;_interface-&gt;is_MemInterface() != NULL ) {
1317         MemInterface *mem_interface = oper-&gt;_interface-&gt;is_MemInterface();
1318         const char *base = mem_interface-&gt;_base;
1319         if( base != NULL ) {
1320           define_oper_interface(fp, *oper, _globalNames, &quot;base&quot;, base);
1321         }
1322         char *index = mem_interface-&gt;_index;
1323         if( index != NULL ) {
1324           define_oper_interface(fp, *oper, _globalNames, &quot;index&quot;, index);
1325         }
1326         const char *scale = mem_interface-&gt;_scale;
1327         if( scale != NULL ) {
1328           define_oper_interface(fp, *oper, _globalNames, &quot;scale&quot;, scale);
1329         }
1330         const char *disp = mem_interface-&gt;_disp;
1331         if( disp != NULL ) {
1332           define_oper_interface(fp, *oper, _globalNames, &quot;disp&quot;, disp);
1333           oper-&gt;disp_is_oop(fp, _globalNames);
1334         }
1335         if( oper-&gt;stack_slots_only(_globalNames) ) {
1336           // should not call this:
1337           fprintf(fp,&quot;  virtual int       constant_disp() const { return Type::OffsetBot; }&quot;);
1338         } else if ( disp != NULL ) {
1339           define_oper_interface(fp, *oper, _globalNames, &quot;constant_disp&quot;, disp);
1340         }
1341       } // end Memory Interface
1342       // Check if it is a Conditional Interface
1343       else if (oper-&gt;_interface-&gt;is_CondInterface() != NULL) {
1344         CondInterface *cInterface = oper-&gt;_interface-&gt;is_CondInterface();
1345         const char *equal = cInterface-&gt;_equal;
1346         if( equal != NULL ) {
1347           define_oper_interface(fp, *oper, _globalNames, &quot;equal&quot;, equal);
1348         }
1349         const char *not_equal = cInterface-&gt;_not_equal;
1350         if( not_equal != NULL ) {
1351           define_oper_interface(fp, *oper, _globalNames, &quot;not_equal&quot;, not_equal);
1352         }
1353         const char *less = cInterface-&gt;_less;
1354         if( less != NULL ) {
1355           define_oper_interface(fp, *oper, _globalNames, &quot;less&quot;, less);
1356         }
1357         const char *greater_equal = cInterface-&gt;_greater_equal;
1358         if( greater_equal != NULL ) {
1359           define_oper_interface(fp, *oper, _globalNames, &quot;greater_equal&quot;, greater_equal);
1360         }
1361         const char *less_equal = cInterface-&gt;_less_equal;
1362         if( less_equal != NULL ) {
1363           define_oper_interface(fp, *oper, _globalNames, &quot;less_equal&quot;, less_equal);
1364         }
1365         const char *greater = cInterface-&gt;_greater;
1366         if( greater != NULL ) {
1367           define_oper_interface(fp, *oper, _globalNames, &quot;greater&quot;, greater);
1368         }
1369         const char *overflow = cInterface-&gt;_overflow;
1370         if( overflow != NULL ) {
1371           define_oper_interface(fp, *oper, _globalNames, &quot;overflow&quot;, overflow);
1372         }
1373         const char *no_overflow = cInterface-&gt;_no_overflow;
1374         if( no_overflow != NULL ) {
1375           define_oper_interface(fp, *oper, _globalNames, &quot;no_overflow&quot;, no_overflow);
1376         }
1377       } // end Conditional Interface
1378       // Check if it is a Constant Interface
1379       else if (oper-&gt;_interface-&gt;is_ConstInterface() != NULL ) {
1380         assert( oper-&gt;num_consts(_globalNames) == 1,
1381                 &quot;Must have one constant when using CONST_INTER encoding&quot;);
1382         if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConI&quot;)) {
1383           // Access the locally stored constant
1384           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1385           fprintf(fp,   &quot; return (intptr_t)_c0;&quot;);
1386           fprintf(fp,&quot;  }\n&quot;);
1387         }
1388         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConP&quot;)) {
1389           // Access the locally stored constant
1390           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1391           fprintf(fp,   &quot; return _c0-&gt;get_con();&quot;);
1392           fprintf(fp, &quot; }\n&quot;);
1393           // Generate query to determine if this pointer is an oop
1394           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1395           fprintf(fp,   &quot; return _c0-&gt;reloc();&quot;);
1396           fprintf(fp, &quot; }\n&quot;);
1397         }
1398         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConN&quot;)) {
1399           // Access the locally stored constant
1400           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1401           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1402           fprintf(fp, &quot; }\n&quot;);
1403           // Generate query to determine if this pointer is an oop
1404           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1405           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1406           fprintf(fp, &quot; }\n&quot;);
1407         }
1408         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConNKlass&quot;)) {
1409           // Access the locally stored constant
1410           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1411           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;get_con();&quot;);
1412           fprintf(fp, &quot; }\n&quot;);
1413           // Generate query to determine if this pointer is an oop
1414           fprintf(fp,&quot;  virtual relocInfo::relocType           constant_reloc() const {&quot;);
1415           fprintf(fp,   &quot; return _c0-&gt;get_ptrtype()-&gt;reloc();&quot;);
1416           fprintf(fp, &quot; }\n&quot;);
1417         }
1418         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConL&quot;)) {
1419           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1420           // We don&#39;t support addressing modes with &gt; 4Gig offsets.
1421           // Truncate to int.
1422           fprintf(fp,   &quot;  return (intptr_t)_c0;&quot;);
1423           fprintf(fp, &quot; }\n&quot;);
1424           fprintf(fp,&quot;  virtual jlong          constantL() const {&quot;);
1425           fprintf(fp,   &quot; return _c0;&quot;);
1426           fprintf(fp, &quot; }\n&quot;);
1427         }
1428         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConF&quot;)) {
1429           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1430           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1431           fprintf(fp, &quot; }\n&quot;);
1432           fprintf(fp,&quot;  virtual jfloat         constantF() const {&quot;);
1433           fprintf(fp,   &quot; return (jfloat)_c0;&quot;);
1434           fprintf(fp, &quot; }\n&quot;);
1435         }
1436         else if (!strcmp(oper-&gt;ideal_type(_globalNames), &quot;ConD&quot;)) {
1437           fprintf(fp,&quot;  virtual intptr_t       constant() const {&quot;);
1438           fprintf(fp,   &quot; ShouldNotReachHere(); return 0; &quot;);
1439           fprintf(fp, &quot; }\n&quot;);
1440           fprintf(fp,&quot;  virtual jdouble        constantD() const {&quot;);
1441           fprintf(fp,   &quot; return _c0;&quot;);
1442           fprintf(fp, &quot; }\n&quot;);
1443         }
1444       }
1445       else if (oper-&gt;_interface-&gt;is_RegInterface() != NULL) {
1446         // make sure that a fixed format string isn&#39;t used for an
1447         // operand which might be assiged to multiple registers.
1448         // Otherwise the opto assembly output could be misleading.
1449         if (oper-&gt;_format-&gt;_strings.count() != 0 &amp;&amp; !oper-&gt;is_bound_register()) {
1450           syntax_err(oper-&gt;_linenum,
1451                      &quot;Only bound registers can have fixed formats: %s\n&quot;,
1452                      oper-&gt;_ident);
1453         }
1454       }
1455       else {
1456         assert( false, &quot;ShouldNotReachHere();&quot;);
1457       }
1458     }
1459 
1460     fprintf(fp,&quot;\n&quot;);
1461     // // Currently all XXXOper::hash() methods are identical (990820)
1462     // declare_hash(fp);
1463     // // Currently all XXXOper::Cmp() methods are identical (990820)
1464     // declare_cmp(fp);
1465 
1466     // Do not place dump_spec() and Name() into PRODUCT code
1467     // int_format and ext_format are not needed in PRODUCT code either
1468     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
1469 
1470     // Declare int_format() and ext_format()
1471     gen_oper_format(fp, _globalNames, *oper);
1472 
1473     // Machine independent print functionality for debugging
1474     // IF we have constants, create a dump_spec function for the derived class
1475     //
1476     // (1)  virtual void           dump_spec() const {
1477     // (2)    st-&gt;print(&quot;#%d&quot;, _c#);        // Constant != ConP
1478     //  OR    _c#-&gt;dump_on(st);             // Type ConP
1479     //  ...
1480     // (3)  }
1481     uint num_consts = oper-&gt;num_consts(_globalNames);
1482     if( num_consts &gt; 0 ) {
1483       // line (1)
1484       fprintf(fp, &quot;  virtual void           dump_spec(outputStream *st) const {\n&quot;);
1485       // generate format string for st-&gt;print
1486       // Iterate over the component list &amp; spit out the right thing
1487       uint i = 0;
1488       const char *type = oper-&gt;ideal_type(_globalNames);
1489       Component  *comp;
1490       oper-&gt;_components.reset();
1491       if ((comp = oper-&gt;_components.iter()) == NULL) {
1492         assert(num_consts == 1, &quot;Bad component list detected.\n&quot;);
1493         i = dump_spec_constant( fp, type, i, oper );
1494         // Check that type actually matched
1495         assert( i != 0, &quot;Non-constant operand lacks component list.&quot;);
1496       } // end if NULL
1497       else {
1498         // line (2)
1499         // dump all components
1500         oper-&gt;_components.reset();
1501         while((comp = oper-&gt;_components.iter()) != NULL) {
1502           type = comp-&gt;base_type(_globalNames);
1503           i = dump_spec_constant( fp, type, i, NULL );
1504         }
1505       }
1506       // finish line (3)
1507       fprintf(fp,&quot;  }\n&quot;);
1508     }
1509 
1510     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
1511             oper-&gt;_ident);
1512 
1513     fprintf(fp,&quot;#endif\n&quot;);
1514 
1515     // Close definition of this XxxMachOper
1516     fprintf(fp,&quot;};\n&quot;);
1517   }
1518 
1519 
1520   // Generate Machine Classes for each instruction defined in AD file
1521   fprintf(fp,&quot;\n&quot;);
1522   fprintf(fp,&quot;//----------------------------Declare classes for Pipelines-----------------\n&quot;);
1523   declare_pipe_classes(fp);
1524 
1525   // Generate Machine Classes for each instruction defined in AD file
1526   fprintf(fp,&quot;\n&quot;);
1527   fprintf(fp,&quot;//----------------------------Declare classes derived from MachNode----------\n&quot;);
1528   _instructions.reset();
1529   InstructForm *instr;
1530   for( ; (instr = (InstructForm*)_instructions.iter()) != NULL; ) {
1531     // Ensure this is a machine-world instruction
1532     if ( instr-&gt;ideal_only() ) continue;
1533 
1534     // Build class definition for this instruction
1535     fprintf(fp,&quot;\n&quot;);
1536     fprintf(fp,&quot;class %sNode : public %s { \n&quot;,
1537             instr-&gt;_ident, instr-&gt;mach_base_class(_globalNames) );
1538     fprintf(fp,&quot;private:\n&quot;);
1539     fprintf(fp,&quot;  MachOper *_opnd_array[%d];\n&quot;, instr-&gt;num_opnds() );
1540     if ( instr-&gt;is_ideal_jump() ) {
1541       fprintf(fp, &quot;  GrowableArray&lt;Label*&gt; _index2label;\n&quot;);
1542     }
1543 
1544     fprintf(fp, &quot;public:\n&quot;);
1545 
1546     Attribute *att = instr-&gt;_attribs;
1547     // Fields of the node specified in the ad file.
1548     while (att != NULL) {
1549       if (strncmp(att-&gt;_ident, &quot;ins_field_&quot;, 10) == 0) {
1550         const char *field_name = att-&gt;_ident+10;
1551         const char *field_type = att-&gt;_val;
1552         fprintf(fp, &quot;  %s _%s;\n&quot;, field_type, field_name);
1553       }
1554       att = (Attribute *)att-&gt;_next;
1555     }
1556 
1557     fprintf(fp,&quot;  MachOper *opnd_array(uint operand_index) const {\n&quot;);
1558     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1559     fprintf(fp,&quot;    return _opnd_array[operand_index];\n&quot;);
1560     fprintf(fp,&quot;  }\n&quot;);
1561     fprintf(fp,&quot;  void      set_opnd_array(uint operand_index, MachOper *operand) {\n&quot;);
1562     fprintf(fp,&quot;    assert(operand_index &lt; _num_opnds, \&quot;invalid _opnd_array index\&quot;);\n&quot;);
1563     fprintf(fp,&quot;    _opnd_array[operand_index] = operand;\n&quot;);
1564     fprintf(fp,&quot;  }\n&quot;);
1565     fprintf(fp,&quot;  virtual uint           rule() const { return %s_rule; }\n&quot;,
1566             instr-&gt;_ident);
1567     fprintf(fp,&quot;private:\n&quot;);
1568     if ( instr-&gt;is_ideal_jump() ) {
1569       fprintf(fp,&quot;  virtual void           add_case_label(int index_num, Label* blockLabel) {\n&quot;);
1570       fprintf(fp,&quot;    _index2label.at_put_grow(index_num, blockLabel);\n&quot;);
1571       fprintf(fp,&quot;  }\n&quot;);
1572     }
1573     if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1574       fprintf(fp,&quot;  const RegMask  *_cisc_RegMask;\n&quot;);
1575     }
1576 
1577     out_RegMask(fp);                      // output register mask
1578 
1579     // If this instruction contains a labelOper
1580     // Declare Node::methods that set operand Label&#39;s contents
1581     int label_position = instr-&gt;label_position();
1582     if( label_position != -1 ) {
1583       // Set/Save the label, stored in labelOper::_branch_label
1584       fprintf(fp,&quot;  virtual void           label_set( Label* label, uint block_num );\n&quot;);
1585       fprintf(fp,&quot;  virtual void           save_label( Label** label, uint* block_num );\n&quot;);
1586     }
1587 
1588     // If this instruction contains a methodOper
1589     // Declare Node::methods that set operand method&#39;s contents
1590     int method_position = instr-&gt;method_position();
1591     if( method_position != -1 ) {
1592       // Set the address method, stored in methodOper::_method
1593       fprintf(fp,&quot;  virtual void           method_set( intptr_t method );\n&quot;);
1594     }
1595 
1596     // virtual functions for attributes
1597     //
1598     // Each instruction attribute results in a virtual call of same name.
1599     // The ins_cost is not handled here.
1600     Attribute *attr = instr-&gt;_attribs;
1601     Attribute *avoid_back_to_back_attr = NULL;
1602     while (attr != NULL) {
1603       if (strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) == 0) {
1604         fprintf(fp, &quot;  virtual bool           is_TrapBasedCheckNode() const { return %s; }\n&quot;, attr-&gt;_val);
1605       } else if (strcmp (attr-&gt;_ident, &quot;ins_cost&quot;) != 0 &amp;&amp;
1606           strncmp(attr-&gt;_ident, &quot;ins_field_&quot;, 10) != 0 &amp;&amp;
1607           // Must match function in node.hpp: return type bool, no prefix &quot;ins_&quot;.
1608           strcmp (attr-&gt;_ident, &quot;ins_is_TrapBasedCheckNode&quot;) != 0 &amp;&amp;
1609           strcmp (attr-&gt;_ident, &quot;ins_short_branch&quot;) != 0) {
1610         fprintf(fp, &quot;  virtual int            %s() const { return %s; }\n&quot;, attr-&gt;_ident, attr-&gt;_val);
1611       }
1612       if (strcmp(attr-&gt;_ident, &quot;ins_avoid_back_to_back&quot;) == 0) {
1613         avoid_back_to_back_attr = attr;
1614       }
1615       attr = (Attribute *)attr-&gt;_next;
1616     }
1617 
1618     // virtual functions for encode and format
1619 
1620     // Virtual function for evaluating the constant.
1621     if (instr-&gt;is_mach_constant()) {
1622       fprintf(fp,&quot;  virtual void           eval_constant(Compile* C);\n&quot;);
1623     }
1624 
1625     // Output the opcode function and the encode function here using the
1626     // encoding class information in the _insencode slot.
1627     if ( instr-&gt;_insencode ) {
1628       if (instr-&gt;postalloc_expands()) {
1629         fprintf(fp,&quot;  virtual bool           requires_postalloc_expand() const { return true; }\n&quot;);
1630         fprintf(fp,&quot;  virtual void           postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);\n&quot;);
1631       } else {
1632         fprintf(fp,&quot;  virtual void           emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;\n&quot;);
1633       }
1634     }
1635 
1636     // virtual function for getting the size of an instruction
1637     if ( instr-&gt;_size ) {
1638       fprintf(fp,&quot;  virtual uint           size(PhaseRegAlloc *ra_) const;\n&quot;);
1639     }
1640 
1641     // Return the top-level ideal opcode.
1642     // Use MachNode::ideal_Opcode() for nodes based on MachNode class
1643     // if the ideal_Opcode == Op_Node.
1644     if ( strcmp(&quot;Node&quot;, instr-&gt;ideal_Opcode(_globalNames)) != 0 ||
1645          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1646       fprintf(fp,&quot;  virtual int            ideal_Opcode() const { return Op_%s; }\n&quot;,
1647             instr-&gt;ideal_Opcode(_globalNames) );
1648     }
1649 
1650     if (instr-&gt;needs_constant_base() &amp;&amp;
1651         !instr-&gt;is_mach_constant()) {  // These inherit the funcion from MachConstantNode.
1652       fprintf(fp,&quot;  virtual uint           mach_constant_base_node_input() const { &quot;);
1653       if (instr-&gt;is_ideal_call() != Form::invalid_type &amp;&amp;
1654           instr-&gt;is_ideal_call() != Form::JAVA_LEAF) {
1655         // MachConstantBase goes behind arguments, but before jvms.
1656         fprintf(fp,&quot;assert(tf() &amp;&amp; tf()-&gt;domain(), \&quot;\&quot;); return tf()-&gt;domain()-&gt;cnt();&quot;);
1657       } else {
1658         fprintf(fp,&quot;return req()-1;&quot;);
1659       }
1660       fprintf(fp,&quot; }\n&quot;);
1661     }
1662 
1663     // Allow machine-independent optimization, invert the sense of the IF test
1664     if( instr-&gt;is_ideal_if() ) {
1665       fprintf(fp,&quot;  virtual void           negate() { \n&quot;);
1666       // Identify which operand contains the negate(able) ideal condition code
1667       int   idx = 0;
1668       instr-&gt;_components.reset();
1669       for( Component *comp; (comp = instr-&gt;_components.iter()) != NULL; ) {
1670         // Check that component is an operand
1671         Form *form = (Form*)_globalNames[comp-&gt;_type];
1672         OperandForm *opForm = form ? form-&gt;is_operand() : NULL;
1673         if( opForm == NULL ) continue;
1674 
1675         // Lookup the position of the operand in the instruction.
1676         if( opForm-&gt;is_ideal_bool() ) {
1677           idx = instr-&gt;operand_position(comp-&gt;_name, comp-&gt;_usedef);
1678           assert( idx != NameList::Not_in_list, &quot;Did not find component in list that contained it.&quot;);
1679           break;
1680         }
1681       }
1682       fprintf(fp,&quot;    opnd_array(%d)-&gt;negate();\n&quot;, idx);
1683       fprintf(fp,&quot;    _prob = 1.0f - _prob;\n&quot;);
1684       fprintf(fp,&quot;  };\n&quot;);
1685     }
1686 
1687 
1688     // Identify which input register matches the input register.
1689     uint  matching_input = instr-&gt;two_address(_globalNames);
1690 
1691     // Generate the method if it returns != 0 otherwise use MachNode::two_adr()
1692     if( matching_input != 0 ) {
1693       fprintf(fp,&quot;  virtual uint           two_adr() const  &quot;);
1694       fprintf(fp,&quot;{ return oper_input_base()&quot;);
1695       for( uint i = 2; i &lt;= matching_input; i++ )
1696         fprintf(fp,&quot; + opnd_array(%d)-&gt;num_edges()&quot;,i-1);
1697       fprintf(fp,&quot;; }\n&quot;);
1698     }
1699 
1700     // Declare cisc_version, if applicable
1701     //   MachNode *cisc_version( int offset /* ,... */ );
1702     instr-&gt;declare_cisc_version(*this, fp);
1703 
1704     // If there is an explicit peephole rule, build it
1705     if ( instr-&gt;peepholes() != NULL ) {
1706       fprintf(fp,&quot;  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);\n&quot;);
1707     }
1708 
1709     // Output the declaration for number of relocation entries
1710     if ( instr-&gt;reloc(_globalNames) != 0 ) {
1711       fprintf(fp,&quot;  virtual int            reloc() const;\n&quot;);
1712     }
1713 
1714     if (instr-&gt;alignment() != 1) {
1715       fprintf(fp,&quot;  virtual int            alignment_required() const { return %d; }\n&quot;, instr-&gt;alignment());
1716       fprintf(fp,&quot;  virtual int            compute_padding(int current_offset) const;\n&quot;);
1717     }
1718 
1719     // Starting point for inputs matcher wants.
1720     // Use MachNode::oper_input_base() for nodes based on MachNode class
1721     // if the base == 1.
1722     if ( instr-&gt;oper_input_base(_globalNames) != 1 ||
1723          strcmp(&quot;MachNode&quot;, instr-&gt;mach_base_class(_globalNames)) != 0 ) {
1724       fprintf(fp,&quot;  virtual uint           oper_input_base() const { return %d; }\n&quot;,
1725             instr-&gt;oper_input_base(_globalNames));
1726     }
1727 
1728     // Make the constructor and following methods &#39;public:&#39;
1729     fprintf(fp,&quot;public:\n&quot;);
1730 
1731     // Constructor
1732     if ( instr-&gt;is_ideal_jump() ) {
1733       fprintf(fp,&quot;  %sNode() : _index2label(MinJumpTableSize*2) { &quot;, instr-&gt;_ident);
1734     } else {
1735       fprintf(fp,&quot;  %sNode() { &quot;, instr-&gt;_ident);
1736       if( can_cisc_spill() &amp;&amp; (instr-&gt;cisc_spill_alternate() != NULL) ) {
1737         fprintf(fp,&quot;_cisc_RegMask = NULL; &quot;);
1738       }
1739     }
1740 
1741     fprintf(fp,&quot; _num_opnds = %d; _opnds = _opnd_array; &quot;, instr-&gt;num_opnds());
1742 
1743     bool node_flags_set = false;
1744     // flag: if this instruction matches an ideal &#39;Copy*&#39; node
1745     if ( instr-&gt;is_ideal_copy() != 0 ) {
1746       fprintf(fp,&quot;init_flags(Flag_is_Copy&quot;);
1747       node_flags_set = true;
1748     }
1749 
1750     // Is an instruction is a constant?  If so, get its type
1751     Form::DataType  data_type;
1752     const char     *opType = NULL;
1753     const char     *result = NULL;
1754     data_type    = instr-&gt;is_chain_of_constant(_globalNames, opType, result);
1755     // Check if this instruction is a constant
1756     if ( data_type != Form::none ) {
1757       if ( node_flags_set ) {
1758         fprintf(fp,&quot; | Flag_is_Con&quot;);
1759       } else {
1760         fprintf(fp,&quot;init_flags(Flag_is_Con&quot;);
1761         node_flags_set = true;
1762       }
1763     }
1764 
1765     // flag: if this instruction is cisc alternate
1766     if ( can_cisc_spill() &amp;&amp; instr-&gt;is_cisc_alternate() ) {
1767       if ( node_flags_set ) {
1768         fprintf(fp,&quot; | Flag_is_cisc_alternate&quot;);
1769       } else {
1770         fprintf(fp,&quot;init_flags(Flag_is_cisc_alternate&quot;);
1771         node_flags_set = true;
1772       }
1773     }
1774 
1775     // flag: if this instruction has short branch form
1776     if ( instr-&gt;has_short_branch_form() ) {
1777       if ( node_flags_set ) {
1778         fprintf(fp,&quot; | Flag_may_be_short_branch&quot;);
1779       } else {
1780         fprintf(fp,&quot;init_flags(Flag_may_be_short_branch&quot;);
1781         node_flags_set = true;
1782       }
1783     }
1784 
1785     // flag: if this instruction should not be generated back to back.
1786     if (avoid_back_to_back_attr != NULL) {
1787       if (node_flags_set) {
1788         fprintf(fp,&quot; | (%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1789       } else {
1790         fprintf(fp,&quot;init_flags((%s)&quot;, avoid_back_to_back_attr-&gt;_val);
1791         node_flags_set = true;
1792       }
1793     }
1794 
1795     // Check if machine instructions that USE memory, but do not DEF memory,
1796     // depend upon a node that defines memory in machine-independent graph.
1797     if ( instr-&gt;needs_anti_dependence_check(_globalNames) ) {
1798       if ( node_flags_set ) {
1799         fprintf(fp,&quot; | Flag_needs_anti_dependence_check&quot;);
1800       } else {
1801         fprintf(fp,&quot;init_flags(Flag_needs_anti_dependence_check&quot;);
1802         node_flags_set = true;
1803       }
1804     }
1805 
1806     // flag: if this instruction is implemented with a call
1807     if ( instr-&gt;_has_call ) {
1808       if ( node_flags_set ) {
1809         fprintf(fp,&quot; | Flag_has_call&quot;);
1810       } else {
1811         fprintf(fp,&quot;init_flags(Flag_has_call&quot;);
1812         node_flags_set = true;
1813       }
1814     }
1815 
1816     if ( node_flags_set ) {
1817       fprintf(fp,&quot;); &quot;);
1818     }
1819 
1820     fprintf(fp,&quot;}\n&quot;);
1821 
1822     // size_of, used by base class&#39;s clone to obtain the correct size.
1823     fprintf(fp,&quot;  virtual uint           size_of() const {&quot;);
1824     fprintf(fp,   &quot; return sizeof(%sNode);&quot;, instr-&gt;_ident);
1825     fprintf(fp, &quot; }\n&quot;);
1826 
1827     // Virtual methods which are only generated to override base class
1828     if( instr-&gt;expands() || instr-&gt;needs_projections() ||
1829         instr-&gt;has_temps() ||
1830         instr-&gt;is_mach_constant() ||
1831         instr-&gt;needs_constant_base() ||
1832         (instr-&gt;_matrule != NULL &amp;&amp;
1833          instr-&gt;num_opnds() != instr-&gt;num_unique_opnds()) ) {
1834       fprintf(fp,&quot;  virtual MachNode      *Expand(State *state, Node_List &amp;proj_list, Node* mem);\n&quot;);
1835     }
1836 
1837     if (instr-&gt;is_pinned(_globalNames)) {
1838       fprintf(fp,&quot;  virtual bool           pinned() const { return &quot;);
1839       if (instr-&gt;is_parm(_globalNames)) {
1840         fprintf(fp,&quot;_in[0]-&gt;pinned();&quot;);
1841       } else {
1842         fprintf(fp,&quot;true;&quot;);
1843       }
1844       fprintf(fp,&quot; }\n&quot;);
1845     }
1846     if (instr-&gt;is_projection(_globalNames)) {
1847       fprintf(fp,&quot;  virtual const Node *is_block_proj() const { return this; }\n&quot;);
1848     }
1849     if ( instr-&gt;num_post_match_opnds() != 0
1850          || instr-&gt;is_chain_of_constant(_globalNames) ) {
1851       fprintf(fp,&quot;  friend MachNode *State::MachNodeGenerator(int opcode);\n&quot;);
1852     }
1853     if ( instr-&gt;rematerialize(_globalNames, get_registers()) ) {
1854       fprintf(fp,&quot;  // Rematerialize %s\n&quot;, instr-&gt;_ident);
1855     }
1856 
1857     // Declare short branch methods, if applicable
1858     instr-&gt;declare_short_branch_methods(fp);
1859 
1860     // See if there is an &quot;ins_pipe&quot; declaration for this instruction
1861     if (instr-&gt;_ins_pipe) {
1862       fprintf(fp,&quot;  static  const Pipeline *pipeline_class();\n&quot;);
1863       fprintf(fp,&quot;  virtual const Pipeline *pipeline() const;\n&quot;);
1864     }
1865 
1866     // Generate virtual function for MachNodeX::bottom_type when necessary
1867     //
1868     // Note on accuracy:  Pointer-types of machine nodes need to be accurate,
1869     // or else alias analysis on the matched graph may produce bad code.
1870     // Moreover, the aliasing decisions made on machine-node graph must be
1871     // no less accurate than those made on the ideal graph, or else the graph
1872     // may fail to schedule.  (Reason:  Memory ops which are reordered in
1873     // the ideal graph might look interdependent in the machine graph,
1874     // thereby removing degrees of scheduling freedom that the optimizer
1875     // assumed would be available.)
1876     //
1877     // %%% We should handle many of these cases with an explicit ADL clause:
1878     // instruct foo() %{ ... bottom_type(TypeRawPtr::BOTTOM); ... %}
1879     if( data_type != Form::none ) {
1880       // A constant&#39;s bottom_type returns a Type containing its constant value
1881 
1882       // !!!!!
1883       // Convert all ints, floats, ... to machine-independent TypeXs
1884       // as is done for pointers
1885       //
1886       // Construct appropriate constant type containing the constant value.
1887       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {\n&quot;);
1888       switch( data_type ) {
1889       case Form::idealI:
1890         fprintf(fp,&quot;    return  TypeInt::make(opnd_array(1)-&gt;constant());\n&quot;);
1891         break;
1892       case Form::idealP:
1893       case Form::idealN:
1894       case Form::idealNKlass:
1895         fprintf(fp,&quot;    return  opnd_array(1)-&gt;type();\n&quot;);
1896         break;
1897       case Form::idealD:
1898         fprintf(fp,&quot;    return  TypeD::make(opnd_array(1)-&gt;constantD());\n&quot;);
1899         break;
1900       case Form::idealF:
1901         fprintf(fp,&quot;    return  TypeF::make(opnd_array(1)-&gt;constantF());\n&quot;);
1902         break;
1903       case Form::idealL:
1904         fprintf(fp,&quot;    return  TypeLong::make(opnd_array(1)-&gt;constantL());\n&quot;);
1905         break;
1906       default:
1907         assert( false, &quot;Unimplemented()&quot; );
1908         break;
1909       }
1910       fprintf(fp,&quot;  };\n&quot;);
1911     }
1912 /*    else if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1913         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1914         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
1915       // !!!!! !!!!!
1916       // Provide explicit bottom type for conversions to int
1917       // On Intel the result operand is a stackSlot, untyped.
1918       fprintf(fp,&quot;  virtual const class Type *bottom_type() const {&quot;);
1919       fprintf(fp,   &quot; return  TypeInt::INT;&quot;);
1920       fprintf(fp, &quot; };\n&quot;);
1921     }*/
1922     else if( instr-&gt;is_ideal_copy() &amp;&amp;
1923               !strcmp(instr-&gt;_matrule-&gt;_lChild-&gt;_opType,&quot;stackSlotP&quot;) ) {
1924       // !!!!!
1925       // Special hack for ideal Copy of pointer.  Bottom type is oop or not depending on input.
1926       fprintf(fp,&quot;  const Type            *bottom_type() const { return in(1)-&gt;bottom_type(); } // Copy?\n&quot;);
1927     }
1928     else if( instr-&gt;is_ideal_loadPC() ) {
1929       // LoadPCNode provides the return address of a call to native code.
1930       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1931       // since it is a pointer to an internal VM location and must have a zero offset.
1932       // Allocation detects derived pointers, in part, by their non-zero offsets.
1933       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // LoadPC?\n&quot;);
1934     }
1935     else if( instr-&gt;is_ideal_box() ) {
1936       // BoxNode provides the address of a stack slot.
1937       // Define its bottom type to be TypeRawPtr::BOTTOM instead of TypePtr::BOTTOM
1938       // This prevent s insert_anti_dependencies from complaining. It will
1939       // complain if it sees that the pointer base is TypePtr::BOTTOM since
1940       // it doesn&#39;t understand what that might alias.
1941       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // Box?\n&quot;);
1942     }
1943     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveP&quot;) ) {
1944       int offset = 1;
1945       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1946       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1947       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1948           MatchNode *rlr = rl-&gt;_rChild;
1949           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1950             offset = 2;
1951       }
1952       // Special hack for ideal CMoveP; ideal type depends on inputs
1953       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveP\n&quot;,
1954         offset, offset+1, offset+1);
1955     }
1956     else if( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp; !strcmp(instr-&gt;_matrule-&gt;_rChild-&gt;_opType,&quot;CMoveN&quot;) ) {
1957       int offset = 1;
1958       // Special special hack to see if the Cmp? has been incorporated in the conditional move
1959       MatchNode *rl = instr-&gt;_matrule-&gt;_rChild-&gt;_lChild;
1960       if( rl &amp;&amp; !strcmp(rl-&gt;_opType, &quot;Binary&quot;) ) {
1961           MatchNode *rlr = rl-&gt;_rChild;
1962           if (rlr &amp;&amp; strncmp(rlr-&gt;_opType, &quot;Cmp&quot;, 3) == 0)
1963             offset = 2;
1964       }
1965       // Special hack for ideal CMoveN; ideal type depends on inputs
1966       fprintf(fp,&quot;  const Type            *bottom_type() const { const Type *t = in(oper_input_base()+%d)-&gt;bottom_type(); return (req() &lt;= oper_input_base()+%d) ? t : t-&gt;meet(in(oper_input_base()+%d)-&gt;bottom_type()); } // CMoveN\n&quot;,
1967         offset, offset+1, offset+1);
1968     }
1969     else if (instr-&gt;is_tls_instruction()) {
1970       // Special hack for tlsLoadP
1971       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeRawPtr::BOTTOM; } // tlsLoadP\n&quot;);
1972     }
1973     else if ( instr-&gt;is_ideal_if() ) {
1974       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::IFBOTH; } // matched IfNode\n&quot;);
1975     }
1976     else if ( instr-&gt;is_ideal_membar() ) {
1977       fprintf(fp,&quot;  const Type            *bottom_type() const { return TypeTuple::MEMBAR; } // matched MemBar\n&quot;);
1978     }
1979 
1980     // Check where &#39;ideal_type&#39; must be customized
1981     /*
1982     if ( instr-&gt;_matrule &amp;&amp; instr-&gt;_matrule-&gt;_rChild &amp;&amp;
1983         (  strcmp(&quot;ConvF2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0
1984         || strcmp(&quot;ConvD2I&quot;,instr-&gt;_matrule-&gt;_rChild-&gt;_opType)==0 ) ) {
1985       fprintf(fp,&quot;  virtual uint           ideal_reg() const { return Compile::current()-&gt;matcher()-&gt;base2reg[Type::Int]; }\n&quot;);
1986     }*/
1987 
1988     // Analyze machine instructions that either USE or DEF memory.
1989     int memory_operand = instr-&gt;memory_operand(_globalNames);
1990     if ( memory_operand != InstructForm::NO_MEMORY_OPERAND ) {
1991       if( memory_operand == InstructForm::MANY_MEMORY_OPERANDS ) {
1992         fprintf(fp,&quot;  virtual const TypePtr *adr_type() const;\n&quot;);
1993       }
1994       fprintf(fp,&quot;  virtual const MachOper *memory_operand() const;\n&quot;);
1995     }
1996 
1997     fprintf(fp, &quot;#ifndef PRODUCT\n&quot;);
1998 
1999     // virtual function for generating the user&#39;s assembler output
2000     gen_inst_format(fp, _globalNames,*instr);
2001 
2002     // Machine independent print functionality for debugging
2003     fprintf(fp,&quot;  virtual const char    *Name() const { return \&quot;%s\&quot;;}\n&quot;,
2004             instr-&gt;_ident);
2005 
2006     fprintf(fp, &quot;#endif\n&quot;);
2007 
2008     // Close definition of this XxxMachNode
2009     fprintf(fp,&quot;};\n&quot;);
2010   };
2011 
2012 }
2013 
2014 void ArchDesc::defineStateClass(FILE *fp) {
2015   static const char *state__valid    = &quot;_valid[((uint)index) &gt;&gt; 5] &amp;  (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2016   static const char *state__set_valid= &quot;_valid[((uint)index) &gt;&gt; 5] |= (0x1 &lt;&lt; (((uint)index) &amp; 0x0001F))&quot;;
2017 
2018   fprintf(fp,&quot;\n&quot;);
2019   fprintf(fp,&quot;// MACROS to inline and constant fold State::valid(index)...\n&quot;);
2020   fprintf(fp,&quot;// when given a constant &#39;index&#39; in dfa_&lt;arch&gt;.cpp\n&quot;);
2021   fprintf(fp,&quot;//   uint word   = index &gt;&gt; 5;       // Shift out bit position\n&quot;);
2022   fprintf(fp,&quot;//   uint bitpos = index &amp; 0x0001F;  // Mask off word bits\n&quot;);
2023   fprintf(fp,&quot;#define STATE__VALID(index) &quot;);
2024   fprintf(fp,&quot;    (%s)\n&quot;, state__valid);
2025   fprintf(fp,&quot;\n&quot;);
2026   fprintf(fp,&quot;#define STATE__NOT_YET_VALID(index) &quot;);
2027   fprintf(fp,&quot;  ( (%s) == 0 )\n&quot;, state__valid);
2028   fprintf(fp,&quot;\n&quot;);
2029   fprintf(fp,&quot;#define STATE__VALID_CHILD(state,index) &quot;);
2030   fprintf(fp,&quot;  ( state &amp;&amp; (state-&gt;%s) )\n&quot;, state__valid);
2031   fprintf(fp,&quot;\n&quot;);
2032   fprintf(fp,&quot;#define STATE__SET_VALID(index) &quot;);
2033   fprintf(fp,&quot;  (%s)\n&quot;, state__set_valid);
2034   fprintf(fp,&quot;\n&quot;);
2035   fprintf(fp,
2036           &quot;//---------------------------State-------------------------------------------\n&quot;);
2037   fprintf(fp,&quot;// State contains an integral cost vector, indexed by machine operand opcodes,\n&quot;);
2038   fprintf(fp,&quot;// a rule vector consisting of machine operand/instruction opcodes, and also\n&quot;);
2039   fprintf(fp,&quot;// indexed by machine operand opcodes, pointers to the children in the label\n&quot;);
2040   fprintf(fp,&quot;// tree generated by the Label routines in ideal nodes (currently limited to\n&quot;);
2041   fprintf(fp,&quot;// two for convenience, but this could change).\n&quot;);
2042   fprintf(fp,&quot;class State : public ResourceObj {\n&quot;);
2043   fprintf(fp,&quot;public:\n&quot;);
2044   fprintf(fp,&quot;  int    _id;         // State identifier\n&quot;);
2045   fprintf(fp,&quot;  Node  *_leaf;       // Ideal (non-machine-node) leaf of match tree\n&quot;);
2046   fprintf(fp,&quot;  State *_kids[2];       // Children of state node in label tree\n&quot;);
2047   fprintf(fp,&quot;  unsigned int _cost[_LAST_MACH_OPER];  // Cost vector, indexed by operand opcodes\n&quot;);
2048   fprintf(fp,&quot;  unsigned int _rule[_LAST_MACH_OPER];  // Rule vector, indexed by operand opcodes\n&quot;);
2049   fprintf(fp,&quot;  unsigned int _valid[(_LAST_MACH_OPER/32)+1]; // Bit Map of valid Cost/Rule entries\n&quot;);
2050   fprintf(fp,&quot;\n&quot;);
2051   fprintf(fp,&quot;  State(void);                      // Constructor\n&quot;);
2052   fprintf(fp,&quot;  DEBUG_ONLY( ~State(void); )       // Destructor\n&quot;);
2053   fprintf(fp,&quot;\n&quot;);
2054   fprintf(fp,&quot;  // Methods created by ADLC and invoked by Reduce\n&quot;);
2055   fprintf(fp,&quot;  MachOper *MachOperGenerator(int opcode);\n&quot;);
2056   fprintf(fp,&quot;  MachNode *MachNodeGenerator(int opcode);\n&quot;);
2057   fprintf(fp,&quot;\n&quot;);
2058   fprintf(fp,&quot;  // Assign a state to a node, definition of method produced by ADLC\n&quot;);
2059   fprintf(fp,&quot;  bool DFA( int opcode, const Node *ideal );\n&quot;);
2060   fprintf(fp,&quot;\n&quot;);
2061   fprintf(fp,&quot;  // Access function for _valid bit vector\n&quot;);
2062   fprintf(fp,&quot;  bool valid(uint index) {\n&quot;);
2063   fprintf(fp,&quot;    return( STATE__VALID(index) != 0 );\n&quot;);
2064   fprintf(fp,&quot;  }\n&quot;);
2065   fprintf(fp,&quot;\n&quot;);
2066   fprintf(fp,&quot;  // Set function for _valid bit vector\n&quot;);
2067   fprintf(fp,&quot;  void set_valid(uint index) {\n&quot;);
2068   fprintf(fp,&quot;    STATE__SET_VALID(index);\n&quot;);
2069   fprintf(fp,&quot;  }\n&quot;);
2070   fprintf(fp,&quot;\n&quot;);
2071   fprintf(fp,&quot;#ifndef PRODUCT\n&quot;);
2072   fprintf(fp,&quot;  void dump();                // Debugging prints\n&quot;);
2073   fprintf(fp,&quot;  void dump(int depth);\n&quot;);
2074   fprintf(fp,&quot;#endif\n&quot;);
2075   if (_dfa_small) {
2076     // Generate the routine name we&#39;ll need
2077     for (int i = 1; i &lt; _last_opcode; i++) {
2078       if (_mlistab[i] == NULL) continue;
2079       fprintf(fp, &quot;  void  _sub_Op_%s(const Node *n);\n&quot;, NodeClassNames[i]);
2080     }
2081   }
2082   fprintf(fp,&quot;};\n&quot;);
2083   fprintf(fp,&quot;\n&quot;);
2084   fprintf(fp,&quot;\n&quot;);
2085 
2086 }
2087 
2088 
2089 //---------------------------buildMachOperEnum---------------------------------
2090 // Build enumeration for densely packed operands.
2091 // This enumeration is used to index into the arrays in the State objects
2092 // that indicate cost and a successfull rule match.
2093 
2094 // Information needed to generate the ReduceOp mapping for the DFA
2095 class OutputMachOperands : public OutputMap {
2096 public:
2097   OutputMachOperands(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2098     : OutputMap(hpp, cpp, globals, AD, &quot;MachOperands&quot;) {};
2099 
2100   void declaration() { }
2101   void definition()  { fprintf(_cpp, &quot;enum MachOperands {\n&quot;); }
2102   void closing()     { fprintf(_cpp, &quot;  _LAST_MACH_OPER\n&quot;);
2103                        OutputMap::closing();
2104   }
2105   void map(OpClassForm &amp;opc)  {
2106     const char* opc_ident_to_upper = _AD.machOperEnum(opc._ident);
2107     fprintf(_cpp, &quot;  %s&quot;, opc_ident_to_upper);
2108     delete[] opc_ident_to_upper;
2109   }
2110   void map(OperandForm &amp;oper) {
2111     const char* oper_ident_to_upper = _AD.machOperEnum(oper._ident);
2112     fprintf(_cpp, &quot;  %s&quot;, oper_ident_to_upper);
2113     delete[] oper_ident_to_upper;
2114   }
2115   void map(char *name) {
2116     const char* name_to_upper = _AD.machOperEnum(name);
2117     fprintf(_cpp, &quot;  %s&quot;, name_to_upper);
2118     delete[] name_to_upper;
2119   }
2120 
2121   bool do_instructions()      { return false; }
2122   void map(InstructForm &amp;inst){ assert( false, &quot;ShouldNotCallThis()&quot;); }
2123 };
2124 
2125 
2126 void ArchDesc::buildMachOperEnum(FILE *fp_hpp) {
2127   // Construct the table for MachOpcodes
2128   OutputMachOperands output_mach_operands(fp_hpp, fp_hpp, _globalNames, *this);
2129   build_map(output_mach_operands);
2130 }
2131 
2132 
2133 //---------------------------buildMachEnum----------------------------------
2134 // Build enumeration for all MachOpers and all MachNodes
2135 
2136 // Information needed to generate the ReduceOp mapping for the DFA
2137 class OutputMachOpcodes : public OutputMap {
2138   int begin_inst_chain_rule;
2139   int end_inst_chain_rule;
2140   int begin_rematerialize;
2141   int end_rematerialize;
2142   int end_instructions;
2143 public:
2144   OutputMachOpcodes(FILE *hpp, FILE *cpp, FormDict &amp;globals, ArchDesc &amp;AD)
2145     : OutputMap(hpp, cpp, globals, AD, &quot;MachOpcodes&quot;),
2146       begin_inst_chain_rule(-1), end_inst_chain_rule(-1), end_instructions(-1)
2147   {};
2148 
2149   void declaration() { }
2150   void definition()  { fprintf(_cpp, &quot;enum MachOpcodes {\n&quot;); }
2151   void closing()     {
2152     if( begin_inst_chain_rule != -1 )
2153       fprintf(_cpp, &quot;  _BEGIN_INST_CHAIN_RULE = %d,\n&quot;, begin_inst_chain_rule);
2154     if( end_inst_chain_rule   != -1 )
2155       fprintf(_cpp, &quot;  _END_INST_CHAIN_RULE  = %d,\n&quot;, end_inst_chain_rule);
2156     if( begin_rematerialize   != -1 )
2157       fprintf(_cpp, &quot;  _BEGIN_REMATERIALIZE   = %d,\n&quot;, begin_rematerialize);
2158     if( end_rematerialize     != -1 )
2159       fprintf(_cpp, &quot;  _END_REMATERIALIZE    = %d,\n&quot;, end_rematerialize);
2160     // always execute since do_instructions() is true, and avoids trailing comma
2161     fprintf(_cpp, &quot;  _last_Mach_Node  = %d \n&quot;,  end_instructions);
2162     OutputMap::closing();
2163   }
2164   void map(OpClassForm &amp;opc)  { fprintf(_cpp, &quot;  %s_rule&quot;, opc._ident ); }
2165   void map(OperandForm &amp;oper) { fprintf(_cpp, &quot;  %s_rule&quot;, oper._ident ); }
2166   void map(char        *name) { if (name) fprintf(_cpp, &quot;  %s_rule&quot;, name);
2167                                 else      fprintf(_cpp, &quot;  0&quot;); }
2168   void map(InstructForm &amp;inst) {fprintf(_cpp, &quot;  %s_rule&quot;, inst._ident ); }
2169 
2170   void record_position(OutputMap::position place, int idx ) {
2171     switch(place) {
2172     case OutputMap::BEGIN_INST_CHAIN_RULES :
2173       begin_inst_chain_rule = idx;
2174       break;
2175     case OutputMap::END_INST_CHAIN_RULES :
2176       end_inst_chain_rule   = idx;
2177       break;
2178     case OutputMap::BEGIN_REMATERIALIZE :
2179       begin_rematerialize   = idx;
2180       break;
2181     case OutputMap::END_REMATERIALIZE :
2182       end_rematerialize     = idx;
2183       break;
2184     case OutputMap::END_INSTRUCTIONS :
2185       end_instructions      = idx;
2186       break;
2187     default:
2188       break;
2189     }
2190   }
2191 };
2192 
2193 
2194 void ArchDesc::buildMachOpcodesEnum(FILE *fp_hpp) {
2195   // Construct the table for MachOpcodes
2196   OutputMachOpcodes output_mach_opcodes(fp_hpp, fp_hpp, _globalNames, *this);
2197   build_map(output_mach_opcodes);
2198 }
2199 
2200 
2201 // Generate an enumeration of the pipeline states, and both
2202 // the functional units (resources) and the masks for
2203 // specifying resources
2204 void ArchDesc::build_pipeline_enums(FILE *fp_hpp) {
2205   int stagelen = (int)strlen(&quot;undefined&quot;);
2206   int stagenum = 0;
2207 
2208   if (_pipeline) {              // Find max enum string length
2209     const char *stage;
2210     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; ) {
2211       int len = (int)strlen(stage);
2212       if (stagelen &lt; len) stagelen = len;
2213     }
2214   }
2215 
2216   // Generate a list of stages
2217   fprintf(fp_hpp, &quot;\n&quot;);
2218   fprintf(fp_hpp, &quot;// Pipeline Stages\n&quot;);
2219   fprintf(fp_hpp, &quot;enum machPipelineStages {\n&quot;);
2220   fprintf(fp_hpp, &quot;   stage_%-*s = 0,\n&quot;, stagelen, &quot;undefined&quot;);
2221 
2222   if( _pipeline ) {
2223     const char *stage;
2224     for ( _pipeline-&gt;_stages.reset(); (stage = _pipeline-&gt;_stages.iter()) != NULL; )
2225       fprintf(fp_hpp, &quot;   stage_%-*s = %d,\n&quot;, stagelen, stage, ++stagenum);
2226   }
2227 
2228   fprintf(fp_hpp, &quot;   stage_%-*s = %d\n&quot;, stagelen, &quot;count&quot;, stagenum);
2229   fprintf(fp_hpp, &quot;};\n&quot;);
2230 
2231   fprintf(fp_hpp, &quot;\n&quot;);
2232   fprintf(fp_hpp, &quot;// Pipeline Resources\n&quot;);
2233   fprintf(fp_hpp, &quot;enum machPipelineResources {\n&quot;);
2234   int rescount = 0;
2235 
2236   if( _pipeline ) {
2237     const char *resource;
2238     int reslen = 0;
2239 
2240     // Generate a list of resources, and masks
2241     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2242       int len = (int)strlen(resource);
2243       if (reslen &lt; len)
2244         reslen = len;
2245     }
2246 
2247     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2248       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2249       int mask = resform-&gt;mask();
2250       if ((mask &amp; (mask-1)) == 0)
2251         fprintf(fp_hpp, &quot;   resource_%-*s = %d,\n&quot;, reslen, resource, rescount++);
2252     }
2253     fprintf(fp_hpp, &quot;\n&quot;);
2254     for ( _pipeline-&gt;_reslist.reset(); (resource = _pipeline-&gt;_reslist.iter()) != NULL; ) {
2255       const ResourceForm *resform = _pipeline-&gt;_resdict[resource]-&gt;is_resource();
2256       fprintf(fp_hpp, &quot;   res_mask_%-*s = 0x%08x,\n&quot;, reslen, resource, resform-&gt;mask());
2257     }
2258     fprintf(fp_hpp, &quot;\n&quot;);
2259   }
2260   fprintf(fp_hpp, &quot;   resource_count = %d\n&quot;, rescount);
2261   fprintf(fp_hpp, &quot;};\n&quot;);
2262 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
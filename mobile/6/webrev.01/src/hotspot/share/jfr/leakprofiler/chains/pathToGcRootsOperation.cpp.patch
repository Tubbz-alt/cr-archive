diff a/src/hotspot/share/jfr/leakprofiler/chains/pathToGcRootsOperation.cpp b/src/hotspot/share/jfr/leakprofiler/chains/pathToGcRootsOperation.cpp
--- a/src/hotspot/share/jfr/leakprofiler/chains/pathToGcRootsOperation.cpp
+++ b/src/hotspot/share/jfr/leakprofiler/chains/pathToGcRootsOperation.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -45,12 +45,12 @@
 #include "memory/universe.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/safepoint.hpp"
 #include "utilities/globalDefinitions.hpp"
 
-PathToGcRootsOperation::PathToGcRootsOperation(ObjectSampler* sampler, EdgeStore* edge_store, int64_t cutoff, bool emit_all) :
-  _sampler(sampler),_edge_store(edge_store), _cutoff_ticks(cutoff), _emit_all(emit_all) {}
+PathToGcRootsOperation::PathToGcRootsOperation(ObjectSampler* sampler, EdgeStore* edge_store, int64_t cutoff, bool emit_all, bool skip_bfs) :
+  _sampler(sampler),_edge_store(edge_store), _cutoff_ticks(cutoff), _emit_all(emit_all), _skip_bfs(skip_bfs) {}
 
 /* The EdgeQueue is backed by directly managed virtual memory.
  * We will attempt to dimension an initial reservation
  * in proportion to the size of the heap (represented by heap_region).
  * Initial memory reservation: 5% of the heap OR at least 32 Mb
@@ -111,11 +111,11 @@
   BFSClosure bfs(&edge_queue, _edge_store, &mark_bits);
   RootSetClosure<BFSClosure> roots(&bfs);
 
   GranularTimer::start(_cutoff_ticks, 1000000);
   roots.process();
-  if (edge_queue.is_full()) {
+  if (edge_queue.is_full() || _skip_bfs) {
     // Pathological case where roots don't fit in queue
     // Do a depth-first search, but mark roots first
     // to avoid walking sideways over roots
     DFSClosure::find_leaks_from_root_set(_edge_store, &mark_bits);
   } else {

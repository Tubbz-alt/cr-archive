<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;
  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  63 
  64 #ifdef SPARC
  65   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  66   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
  67   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  68   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  69   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  70 #elif defined(PPC64)
  71   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  72   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  73   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  74   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  75   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  76 #elif defined(S390)
  77   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  78   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  79   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  80   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  81   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  82 #else // all other
  83   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  84   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  85   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  86   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  87   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  88 #endif
  89   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  90   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  91   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  92   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  93   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  94   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  95   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  96   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  97   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  98   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  99   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 100   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 101   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 102   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 103   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 104   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 105   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 106   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 107 };
 108 
 109 // Map ideal registers (machine types) to ideal types
 110 const Type *Type::mreg2type[_last_machine_leaf];
 111 
 112 // Map basic types to canonical Type* pointers.
 113 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 114 
 115 // Map basic types to constant-zero Types.
 116 const Type* Type::            _zero_type[T_CONFLICT+1];
 117 
 118 // Map basic types to array-body alias types.
 119 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 120 
 121 //=============================================================================
 122 // Convenience common pre-built types.
 123 const Type *Type::ABIO;         // State-of-machine only
 124 const Type *Type::BOTTOM;       // All values
 125 const Type *Type::CONTROL;      // Control only
 126 const Type *Type::DOUBLE;       // All doubles
 127 const Type *Type::FLOAT;        // All floats
 128 const Type *Type::HALF;         // Placeholder half of doublewide type
 129 const Type *Type::MEMORY;       // Abstract store only
 130 const Type *Type::RETURN_ADDRESS;
 131 const Type *Type::TOP;          // No values in set
 132 
 133 //------------------------------get_const_type---------------------------
 134 const Type* Type::get_const_type(ciType* type) {
 135   if (type == NULL) {
 136     return NULL;
 137   } else if (type-&gt;is_primitive_type()) {
 138     return get_const_basic_type(type-&gt;basic_type());
 139   } else {
 140     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 141   }
 142 }
 143 
 144 //---------------------------array_element_basic_type---------------------------------
 145 // Mapping to the array element&#39;s basic type.
 146 BasicType Type::array_element_basic_type() const {
 147   BasicType bt = basic_type();
 148   if (bt == T_INT) {
 149     if (this == TypeInt::INT)   return T_INT;
 150     if (this == TypeInt::CHAR)  return T_CHAR;
 151     if (this == TypeInt::BYTE)  return T_BYTE;
 152     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 153     if (this == TypeInt::SHORT) return T_SHORT;
 154     return T_VOID;
 155   }
 156   return bt;
 157 }
 158 
 159 // For two instance arrays of same dimension, return the base element types.
 160 // Otherwise or if the arrays have different dimensions, return NULL.
 161 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 162                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 163 
 164   if (e1) *e1 = NULL;
 165   if (e2) *e2 = NULL;
 166   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 167   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 168 
 169   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 170     // Handle multidimensional arrays
 171     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 172     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 173     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 174       a1tap = a1tp-&gt;is_aryptr();
 175       a2tap = a2tp-&gt;is_aryptr();
 176       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 177       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 178     }
 179     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 180       if (e1) *e1 = a1tp-&gt;is_instptr();
 181       if (e2) *e2 = a2tp-&gt;is_instptr();
 182     }
 183   }
 184 }
 185 
 186 //---------------------------get_typeflow_type---------------------------------
 187 // Import a type produced by ciTypeFlow.
 188 const Type* Type::get_typeflow_type(ciType* type) {
 189   switch (type-&gt;basic_type()) {
 190 
 191   case ciTypeFlow::StateVector::T_BOTTOM:
 192     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 193     return Type::BOTTOM;
 194 
 195   case ciTypeFlow::StateVector::T_TOP:
 196     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 197     return Type::TOP;
 198 
 199   case ciTypeFlow::StateVector::T_NULL:
 200     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 201     return TypePtr::NULL_PTR;
 202 
 203   case ciTypeFlow::StateVector::T_LONG2:
 204     // The ciTypeFlow pass pushes a long, then the half.
 205     // We do the same.
 206     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 207     return TypeInt::TOP;
 208 
 209   case ciTypeFlow::StateVector::T_DOUBLE2:
 210     // The ciTypeFlow pass pushes double, then the half.
 211     // Our convention is the same.
 212     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 213     return Type::TOP;
 214 
 215   case T_ADDRESS:
 216     assert(type-&gt;is_return_address(), &quot;&quot;);
 217     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 218 
 219   default:
 220     // make sure we did not mix up the cases:
 221     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 222     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 223     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 224     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 225     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 226     assert(!type-&gt;is_return_address(), &quot;&quot;);
 227 
 228     return Type::get_const_type(type);
 229   }
 230 }
 231 
 232 
 233 //-----------------------make_from_constant------------------------------------
 234 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 235                                      int stable_dimension, bool is_narrow_oop,
 236                                      bool is_autobox_cache) {
 237   switch (constant.basic_type()) {
 238     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 239     case T_CHAR:     return TypeInt::make(constant.as_char());
 240     case T_BYTE:     return TypeInt::make(constant.as_byte());
 241     case T_SHORT:    return TypeInt::make(constant.as_short());
 242     case T_INT:      return TypeInt::make(constant.as_int());
 243     case T_LONG:     return TypeLong::make(constant.as_long());
 244     case T_FLOAT:    return TypeF::make(constant.as_float());
 245     case T_DOUBLE:   return TypeD::make(constant.as_double());
 246     case T_ARRAY:
 247     case T_OBJECT: {
 248         const Type* con_type = NULL;
 249         ciObject* oop_constant = constant.as_object();
 250         if (oop_constant-&gt;is_null_object()) {
 251           con_type = Type::get_zero_type(T_OBJECT);
 252         } else {
 253           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 254           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 255           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 256             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 257           }
 258           if (stable_dimension &gt; 0) {
 259             assert(FoldStableValues, &quot;sanity&quot;);
 260             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 261             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 262           }
 263         }
 264         if (is_narrow_oop) {
 265           con_type = con_type-&gt;make_narrowoop();
 266         }
 267         return con_type;
 268       }
 269     case T_ILLEGAL:
 270       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 271       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 272       return NULL;
 273     default:
 274       // Fall through to failure
 275       return NULL;
 276   }
 277 }
 278 
 279 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 280   BasicType conbt = con.basic_type();
 281   switch (conbt) {
 282     case T_BOOLEAN: conbt = T_BYTE;   break;
 283     case T_ARRAY:   conbt = T_OBJECT; break;
 284     default:                          break;
 285   }
 286   switch (loadbt) {
 287     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 288     case T_NARROWOOP: loadbt = T_OBJECT; break;
 289     case T_ARRAY:     loadbt = T_OBJECT; break;
 290     case T_ADDRESS:   loadbt = T_OBJECT; break;
 291     default:                             break;
 292   }
 293   if (conbt == loadbt) {
 294     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 295       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 296       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 297     } else {
 298       return con;
 299     }
 300   }
 301   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 302     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 303     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 304   }
 305   return ciConstant(); // T_ILLEGAL
 306 }
 307 
 308 // Try to constant-fold a stable array element.
 309 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 310                                                    BasicType loadbt, bool is_unsigned_load) {
 311   // Decode the results of GraphKit::array_element_address.
 312   ciConstant element_value = array-&gt;element_value_by_offset(off);
 313   if (element_value.basic_type() == T_ILLEGAL) {
 314     return NULL; // wrong offset
 315   }
 316   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 317 
 318   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 319          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 320 
 321   if (con.is_valid() &amp;&amp;          // not a mismatched access
 322       !con.is_null_or_zero()) {  // not a default value
 323     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 324     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 325   }
 326   return NULL;
 327 }
 328 
 329 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 330   ciField* field;
 331   ciType* type = holder-&gt;java_mirror_type();
 332   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 333     // Static field
 334     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 335   } else {
 336     // Instance field
 337     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 338   }
 339   if (field == NULL) {
 340     return NULL; // Wrong offset
 341   }
 342   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 343 }
 344 
 345 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 346                                            BasicType loadbt, bool is_unsigned_load) {
 347   if (!field-&gt;is_constant()) {
 348     return NULL; // Non-constant field
 349   }
 350   ciConstant field_value;
 351   if (field-&gt;is_static()) {
 352     // final static field
 353     field_value = field-&gt;constant_value();
 354   } else if (holder != NULL) {
 355     // final or stable non-static field
 356     // Treat final non-static fields of trusted classes (classes in
 357     // java.lang.invoke and sun.invoke packages and subpackages) as
 358     // compile time constants.
 359     field_value = field-&gt;constant_value_of(holder);
 360   }
 361   if (!field_value.is_valid()) {
 362     return NULL; // Not a constant
 363   }
 364 
 365   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 366 
 367   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 368          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 369 
 370   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 371   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 372   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 373 
 374   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 375                                             stable_dimension, is_narrow_oop,
 376                                             field-&gt;is_autobox_cache());
 377   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 378     ciCallSite* call_site = holder-&gt;as_call_site();
 379     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 380       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 381       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 382     }
 383   }
 384   return con_type;
 385 }
 386 
 387 //------------------------------make-------------------------------------------
 388 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 389 // and look for an existing copy in the type dictionary.
 390 const Type *Type::make( enum TYPES t ) {
 391   return (new Type(t))-&gt;hashcons();
 392 }
 393 
 394 //------------------------------cmp--------------------------------------------
 395 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 396   if( t1-&gt;_base != t2-&gt;_base )
 397     return 1;                   // Missed badly
 398   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 399   return !t1-&gt;eq(t2);           // Return ZERO if equal
 400 }
 401 
 402 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 403   if (!include_speculative) {
 404     return remove_speculative();
 405   }
 406   return this;
 407 }
 408 
 409 //------------------------------hash-------------------------------------------
 410 int Type::uhash( const Type *const t ) {
 411   return t-&gt;hash();
 412 }
 413 
 414 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 415 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 416 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 417 
 418 //--------------------------Initialize_shared----------------------------------
 419 void Type::Initialize_shared(Compile* current) {
 420   // This method does not need to be locked because the first system
 421   // compilations (stub compilations) occur serially.  If they are
 422   // changed to proceed in parallel, then this section will need
 423   // locking.
 424 
 425   Arena* save = current-&gt;type_arena();
 426   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 427 
 428   current-&gt;set_type_arena(shared_type_arena);
 429   _shared_type_dict =
 430     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 431                                   shared_type_arena, 128 );
 432   current-&gt;set_type_dict(_shared_type_dict);
 433 
 434   // Make shared pre-built types.
 435   CONTROL = make(Control);      // Control only
 436   TOP     = make(Top);          // No values in set
 437   MEMORY  = make(Memory);       // Abstract store only
 438   ABIO    = make(Abio);         // State-of-machine only
 439   RETURN_ADDRESS=make(Return_Address);
 440   FLOAT   = make(FloatBot);     // All floats
 441   DOUBLE  = make(DoubleBot);    // All doubles
 442   BOTTOM  = make(Bottom);       // Everything
 443   HALF    = make(Half);         // Placeholder half of doublewide type
 444 
 445   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 446   TypeF::ONE  = TypeF::make(1.0); // Float 1
 447   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 448   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 449 
 450   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 451   TypeD::ONE  = TypeD::make(1.0); // Double 1
 452   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 453   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 454 
 455   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 456   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 457   TypeInt::ONE     = TypeInt::make( 1);  //  1
 458   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 459   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 460   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 461   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 462   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 463   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 464   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 465   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 466   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 467   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 468   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 469   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 470   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 471   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 472   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 473   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 474   // CmpL is overloaded both as the bytecode computation returning
 475   // a trinary (-1,0,+1) integer result AND as an efficient long
 476   // compare returning optimizer ideal-type flags.
 477   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 478   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 479   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 480   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 481   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 482 
 483   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 484   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 485   TypeLong::ONE     = TypeLong::make( 1);        //  1
 486   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 487   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 488   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 489   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 490   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 491 
 492   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 493   fboth[0] = Type::CONTROL;
 494   fboth[1] = Type::CONTROL;
 495   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 496 
 497   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 498   ffalse[0] = Type::CONTROL;
 499   ffalse[1] = Type::TOP;
 500   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 501 
 502   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 503   fneither[0] = Type::TOP;
 504   fneither[1] = Type::TOP;
 505   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 506 
 507   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 508   ftrue[0] = Type::TOP;
 509   ftrue[1] = Type::CONTROL;
 510   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 511 
 512   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 513   floop[0] = Type::CONTROL;
 514   floop[1] = TypeInt::INT;
 515   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 516 
 517   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);
 518   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);
 519   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);
 520 
 521   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 522   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 523 
 524   const Type **fmembar = TypeTuple::fields(0);
 525   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 526 
 527   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 528   fsc[0] = TypeInt::CC;
 529   fsc[1] = Type::MEMORY;
 530   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 531 
 532   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 533   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 534   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 535   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 536                                            false, 0, oopDesc::mark_offset_in_bytes());
 537   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 538                                            false, 0, oopDesc::klass_offset_in_bytes());
 539   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);
 540 
 541   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);
 542 
 543   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 544   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 545 
 546   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 547 
 548   mreg2type[Op_Node] = Type::BOTTOM;
 549   mreg2type[Op_Set ] = 0;
 550   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 551   mreg2type[Op_RegI] = TypeInt::INT;
 552   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 553   mreg2type[Op_RegF] = Type::FLOAT;
 554   mreg2type[Op_RegD] = Type::DOUBLE;
 555   mreg2type[Op_RegL] = TypeLong::LONG;
 556   mreg2type[Op_RegFlags] = TypeInt::CC;
 557 
 558   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());
 559 
 560   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 561 
 562 #ifdef _LP64
 563   if (UseCompressedOops) {
 564     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 565     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 566   } else
 567 #endif
 568   {
 569     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 570     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 571   }
 572   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);
 573   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);
 574   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);
 575   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);
 576   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);
 577   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);
 578   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);
 579 
 580   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 581   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 582   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 583   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 584   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 585   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 586   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 587   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 588   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 589   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 590   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 591   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 592 
 593   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );
 594   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );
 595 
 596   const Type **fi2c = TypeTuple::fields(2);
 597   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 598   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 599   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 600 
 601   const Type **intpair = TypeTuple::fields(2);
 602   intpair[0] = TypeInt::INT;
 603   intpair[1] = TypeInt::INT;
 604   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 605 
 606   const Type **longpair = TypeTuple::fields(2);
 607   longpair[0] = TypeLong::LONG;
 608   longpair[1] = TypeLong::LONG;
 609   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 610 
 611   const Type **intccpair = TypeTuple::fields(2);
 612   intccpair[0] = TypeInt::INT;
 613   intccpair[1] = TypeInt::CC;
 614   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 615 
 616   const Type **longccpair = TypeTuple::fields(2);
 617   longccpair[0] = TypeLong::LONG;
 618   longccpair[1] = TypeInt::CC;
 619   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 620 
 621   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 622   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 623   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 624   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 625   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 626   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 627   _const_basic_type[T_INT]         = TypeInt::INT;
 628   _const_basic_type[T_LONG]        = TypeLong::LONG;
 629   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 630   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 631   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 632   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 633   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 634   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 635   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 636 
 637   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 638   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 639   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 640   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 641   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 642   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 643   _zero_type[T_INT]         = TypeInt::ZERO;
 644   _zero_type[T_LONG]        = TypeLong::ZERO;
 645   _zero_type[T_FLOAT]       = TypeF::ZERO;
 646   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 647   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 648   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 649   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 650   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 651 
 652   // get_zero_type() should not happen for T_CONFLICT
 653   _zero_type[T_CONFLICT]= NULL;
 654 
 655   // Vector predefined types, it needs initialized _const_basic_type[].
 656   if (Matcher::vector_size_supported(T_BYTE,4)) {
 657     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 658   }
 659   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 660     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 661   }
 662   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 663     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 664   }
 665   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 666     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 667   }
 668   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 669     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 670   }
 671   mreg2type[Op_VecS] = TypeVect::VECTS;
 672   mreg2type[Op_VecD] = TypeVect::VECTD;
 673   mreg2type[Op_VecX] = TypeVect::VECTX;
 674   mreg2type[Op_VecY] = TypeVect::VECTY;
 675   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 676 
 677   // Restore working type arena.
 678   current-&gt;set_type_arena(save);
 679   current-&gt;set_type_dict(NULL);
 680 }
 681 
 682 //------------------------------Initialize-------------------------------------
 683 void Type::Initialize(Compile* current) {
 684   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 685 
 686   if (_shared_type_dict == NULL) {
 687     Initialize_shared(current);
 688   }
 689 
 690   Arena* type_arena = current-&gt;type_arena();
 691 
 692   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 693   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 694   current-&gt;set_type_dict(tdic);
 695 
 696   // Transfer the shared types.
 697   DictI i(_shared_type_dict);
 698   for( ; i.test(); ++i ) {
 699     Type* t = (Type*)i._value;
 700     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 701   }
 702 }
 703 
 704 //------------------------------hashcons---------------------------------------
 705 // Do the hash-cons trick.  If the Type already exists in the type table,
 706 // delete the current Type and return the existing Type.  Otherwise stick the
 707 // current Type in the Type table.
 708 const Type *Type::hashcons(void) {
 709   debug_only(base());           // Check the assertion in Type::base().
 710   // Look up the Type in the Type dictionary
 711   Dict *tdic = type_dict();
 712   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 713   if( old ) {                   // Pre-existing Type?
 714     if( old != this )           // Yes, this guy is not the pre-existing?
 715       delete this;              // Yes, Nuke this guy
 716     assert( old-&gt;_dual, &quot;&quot; );
 717     return old;                 // Return pre-existing
 718   }
 719 
 720   // Every type has a dual (to make my lattice symmetric).
 721   // Since we just discovered a new Type, compute its dual right now.
 722   assert( !_dual, &quot;&quot; );         // No dual yet
 723   _dual = xdual();              // Compute the dual
 724   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 725     if (_dual != this) {
 726       delete _dual;
 727       _dual = this;
 728     }
 729     return this;
 730   }
 731   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 732   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 733   // New Type, insert into Type table
 734   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 735   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 736 #ifdef ASSERT
 737   Type *dual_dual = (Type*)_dual-&gt;xdual();
 738   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 739   delete dual_dual;
 740 #endif
 741   return this;                  // Return new Type
 742 }
 743 
 744 //------------------------------eq---------------------------------------------
 745 // Structural equality check for Type representations
 746 bool Type::eq( const Type * ) const {
 747   return true;                  // Nothing else can go wrong
 748 }
 749 
 750 //------------------------------hash-------------------------------------------
 751 // Type-specific hashing function.
 752 int Type::hash(void) const {
 753   return _base;
 754 }
 755 
 756 //------------------------------is_finite--------------------------------------
 757 // Has a finite value
 758 bool Type::is_finite() const {
 759   return false;
 760 }
 761 
 762 //------------------------------is_nan-----------------------------------------
 763 // Is not a number (NaN)
 764 bool Type::is_nan()    const {
 765   return false;
 766 }
 767 
 768 //----------------------interface_vs_oop---------------------------------------
 769 #ifdef ASSERT
 770 bool Type::interface_vs_oop_helper(const Type *t) const {
 771   bool result = false;
 772 
 773   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 774   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 775   if( this_ptr == NULL || t_ptr == NULL )
 776     return result;
 777 
 778   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 779   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 780   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 781     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 782     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 783     result = this_interface ^ t_interface;
 784   }
 785 
 786   return result;
 787 }
 788 
 789 bool Type::interface_vs_oop(const Type *t) const {
 790   if (interface_vs_oop_helper(t)) {
 791     return true;
 792   }
 793   // Now check the speculative parts as well
 794   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 795   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 796   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 797     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 798       return true;
 799     }
 800     return false;
 801   }
 802   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 803     return true;
 804   }
 805   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 806     return true;
 807   }
 808   return false;
 809 }
 810 
 811 #endif
 812 
 813 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 814 #ifdef ASSERT
 815   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 816   const Type* dual_join = mt-&gt;_dual;
 817   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 818   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 819 
 820   // Interface meet Oop is Not Symmetric:
 821   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 822   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 823 
 824   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) ) {
 825     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 826     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 827     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 828     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 829 
 830     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 831     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 832     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 833 
 834     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 835     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 836 
 837     fatal(&quot;meet not symmetric&quot; );
 838   }
 839 #endif
 840 }
 841 
 842 //------------------------------meet-------------------------------------------
 843 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 844 // commutative and the lattice is symmetric.
 845 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 846   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 847     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 848     return result-&gt;make_narrowoop();
 849   }
 850   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 851     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 852     return result-&gt;make_narrowklass();
 853   }
 854 
 855   const Type *this_t = maybe_remove_speculative(include_speculative);
 856   t = t-&gt;maybe_remove_speculative(include_speculative);
 857 
 858   const Type *mt = this_t-&gt;xmeet(t);
 859 #ifdef ASSERT
 860   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 861   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 862   Compile* C = Compile::current();
 863   if (!C-&gt;_type_verify_symmetry) {
 864     return mt;
 865   }
 866   this_t-&gt;check_symmetrical(t, mt);
 867   // In the case of an array, computing the meet above, caused the
 868   // computation of the meet of the elements which at verification
 869   // time caused the computation of the meet of the dual of the
 870   // elements. Computing the meet of the dual of the arrays here
 871   // causes the meet of the dual of the elements to be computed which
 872   // would cause the meet of the dual of the dual of the elements,
 873   // that is the meet of the elements already computed above to be
 874   // computed. Avoid redundant computations by requesting no
 875   // verification.
 876   C-&gt;_type_verify_symmetry = false;
 877   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);
 878   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);
 879   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);
 880   C-&gt;_type_verify_symmetry = true;
 881 #endif
 882   return mt;
 883 }
 884 
 885 //------------------------------xmeet------------------------------------------
 886 // Compute the MEET of two types.  It returns a new Type object.
 887 const Type *Type::xmeet( const Type *t ) const {
 888   // Perform a fast test for common case; meeting the same types together.
 889   if( this == t ) return this;  // Meeting same type-rep?
 890 
 891   // Meeting TOP with anything?
 892   if( _base == Top ) return t;
 893 
 894   // Meeting BOTTOM with anything?
 895   if( _base == Bottom ) return BOTTOM;
 896 
 897   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 898   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 899   switch (t-&gt;base()) {  // Switch on original type
 900 
 901   // Cut in half the number of cases I must handle.  Only need cases for when
 902   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 903   case FloatCon:
 904   case DoubleCon:
 905   case Int:
 906   case Long:
 907     return t-&gt;xmeet(this);
 908 
 909   case OopPtr:
 910     return t-&gt;xmeet(this);
 911 
 912   case InstPtr:
 913     return t-&gt;xmeet(this);
 914 
 915   case MetadataPtr:
 916   case KlassPtr:
 917     return t-&gt;xmeet(this);
 918 
 919   case AryPtr:
 920     return t-&gt;xmeet(this);
 921 
 922   case NarrowOop:
 923     return t-&gt;xmeet(this);
 924 
 925   case NarrowKlass:
 926     return t-&gt;xmeet(this);
 927 
 928   case Bad:                     // Type check
 929   default:                      // Bogus type not in lattice
 930     typerr(t);
 931     return Type::BOTTOM;
 932 
 933   case Bottom:                  // Ye Olde Default
 934     return t;
 935 
 936   case FloatTop:
 937     if( _base == FloatTop ) return this;
 938   case FloatBot:                // Float
 939     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 940     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 941     typerr(t);
 942     return Type::BOTTOM;
 943 
 944   case DoubleTop:
 945     if( _base == DoubleTop ) return this;
 946   case DoubleBot:               // Double
 947     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 948     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 949     typerr(t);
 950     return Type::BOTTOM;
 951 
 952   // These next few cases must match exactly or it is a compile-time error.
 953   case Control:                 // Control of code
 954   case Abio:                    // State of world outside of program
 955   case Memory:
 956     if( _base == t-&gt;_base )  return this;
 957     typerr(t);
 958     return Type::BOTTOM;
 959 
 960   case Top:                     // Top of the lattice
 961     return this;
 962   }
 963 
 964   // The type is unchanged
 965   return this;
 966 }
 967 
 968 //-----------------------------filter------------------------------------------
 969 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
 970   const Type* ft = join_helper(kills, include_speculative);
 971   if (ft-&gt;empty())
 972     return Type::TOP;           // Canonical empty value
 973   return ft;
 974 }
 975 
 976 //------------------------------xdual------------------------------------------
 977 // Compute dual right now.
 978 const Type::TYPES Type::dual_type[Type::lastype] = {
 979   Bad,          // Bad
 980   Control,      // Control
 981   Bottom,       // Top
 982   Bad,          // Int - handled in v-call
 983   Bad,          // Long - handled in v-call
 984   Half,         // Half
 985   Bad,          // NarrowOop - handled in v-call
 986   Bad,          // NarrowKlass - handled in v-call
 987 
 988   Bad,          // Tuple - handled in v-call
 989   Bad,          // Array - handled in v-call
 990   Bad,          // VectorS - handled in v-call
 991   Bad,          // VectorD - handled in v-call
 992   Bad,          // VectorX - handled in v-call
 993   Bad,          // VectorY - handled in v-call
 994   Bad,          // VectorZ - handled in v-call
 995 
 996   Bad,          // AnyPtr - handled in v-call
 997   Bad,          // RawPtr - handled in v-call
 998   Bad,          // OopPtr - handled in v-call
 999   Bad,          // InstPtr - handled in v-call
1000   Bad,          // AryPtr - handled in v-call
1001 
1002   Bad,          //  MetadataPtr - handled in v-call
1003   Bad,          // KlassPtr - handled in v-call
1004 
1005   Bad,          // Function - handled in v-call
1006   Abio,         // Abio
1007   Return_Address,// Return_Address
1008   Memory,       // Memory
1009   FloatBot,     // FloatTop
1010   FloatCon,     // FloatCon
1011   FloatTop,     // FloatBot
1012   DoubleBot,    // DoubleTop
1013   DoubleCon,    // DoubleCon
1014   DoubleTop,    // DoubleBot
1015   Top           // Bottom
1016 };
1017 
1018 const Type *Type::xdual() const {
1019   // Note: the base() accessor asserts the sanity of _base.
1020   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1021   return new Type(_type_info[_base].dual_type);
1022 }
1023 
1024 //------------------------------has_memory-------------------------------------
1025 bool Type::has_memory() const {
1026   Type::TYPES tx = base();
1027   if (tx == Memory) return true;
1028   if (tx == Tuple) {
1029     const TypeTuple *t = is_tuple();
1030     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1031       tx = t-&gt;field_at(i)-&gt;base();
1032       if (tx == Memory)  return true;
1033     }
1034   }
1035   return false;
1036 }
1037 
1038 #ifndef PRODUCT
1039 //------------------------------dump2------------------------------------------
1040 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1041   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1042 }
1043 
1044 //------------------------------dump-------------------------------------------
1045 void Type::dump_on(outputStream *st) const {
1046   ResourceMark rm;
1047   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1048   dump2(d,1, st);
1049   if (is_ptr_to_narrowoop()) {
1050     st-&gt;print(&quot; [narrow]&quot;);
1051   } else if (is_ptr_to_narrowklass()) {
1052     st-&gt;print(&quot; [narrowklass]&quot;);
1053   }
1054 }
1055 
1056 //-----------------------------------------------------------------------------
1057 const char* Type::str(const Type* t) {
1058   stringStream ss;
1059   t-&gt;dump_on(&amp;ss);
1060   return ss.as_string();
1061 }
1062 #endif
1063 
1064 //------------------------------singleton--------------------------------------
1065 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1066 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1067 bool Type::singleton(void) const {
1068   return _base == Top || _base == Half;
1069 }
1070 
1071 //------------------------------empty------------------------------------------
1072 // TRUE if Type is a type with no values, FALSE otherwise.
1073 bool Type::empty(void) const {
1074   switch (_base) {
1075   case DoubleTop:
1076   case FloatTop:
1077   case Top:
1078     return true;
1079 
1080   case Half:
1081   case Abio:
1082   case Return_Address:
1083   case Memory:
1084   case Bottom:
1085   case FloatBot:
1086   case DoubleBot:
1087     return false;  // never a singleton, therefore never empty
1088 
1089   default:
1090     ShouldNotReachHere();
1091     return false;
1092   }
1093 }
1094 
1095 //------------------------------dump_stats-------------------------------------
1096 // Dump collected statistics to stderr
1097 #ifndef PRODUCT
1098 void Type::dump_stats() {
1099   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1100 }
1101 #endif
1102 
1103 //------------------------------typerr-----------------------------------------
1104 void Type::typerr( const Type *t ) const {
1105 #ifndef PRODUCT
1106   tty-&gt;print(&quot;\nError mixing types: &quot;);
1107   dump();
1108   tty-&gt;print(&quot; and &quot;);
1109   t-&gt;dump();
1110   tty-&gt;print(&quot;\n&quot;);
1111 #endif
1112   ShouldNotReachHere();
1113 }
1114 
1115 
1116 //=============================================================================
1117 // Convenience common pre-built types.
1118 const TypeF *TypeF::ZERO;       // Floating point zero
1119 const TypeF *TypeF::ONE;        // Floating point one
1120 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1121 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1122 
1123 //------------------------------make-------------------------------------------
1124 // Create a float constant
1125 const TypeF *TypeF::make(float f) {
1126   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1127 }
1128 
1129 //------------------------------meet-------------------------------------------
1130 // Compute the MEET of two types.  It returns a new Type object.
1131 const Type *TypeF::xmeet( const Type *t ) const {
1132   // Perform a fast test for common case; meeting the same types together.
1133   if( this == t ) return this;  // Meeting same type-rep?
1134 
1135   // Current &quot;this-&gt;_base&quot; is FloatCon
1136   switch (t-&gt;base()) {          // Switch on original type
1137   case AnyPtr:                  // Mixing with oops happens when javac
1138   case RawPtr:                  // reuses local variables
1139   case OopPtr:
1140   case InstPtr:
1141   case AryPtr:
1142   case MetadataPtr:
1143   case KlassPtr:
1144   case NarrowOop:
1145   case NarrowKlass:
1146   case Int:
1147   case Long:
1148   case DoubleTop:
1149   case DoubleCon:
1150   case DoubleBot:
1151   case Bottom:                  // Ye Olde Default
1152     return Type::BOTTOM;
1153 
1154   case FloatBot:
1155     return t;
1156 
1157   default:                      // All else is a mistake
1158     typerr(t);
1159 
1160   case FloatCon:                // Float-constant vs Float-constant?
1161     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1162                                 // must compare bitwise as positive zero, negative zero and NaN have
1163                                 // all the same representation in C++
1164       return FLOAT;             // Return generic float
1165                                 // Equal constants
1166   case Top:
1167   case FloatTop:
1168     break;                      // Return the float constant
1169   }
1170   return this;                  // Return the float constant
1171 }
1172 
1173 //------------------------------xdual------------------------------------------
1174 // Dual: symmetric
1175 const Type *TypeF::xdual() const {
1176   return this;
1177 }
1178 
1179 //------------------------------eq---------------------------------------------
1180 // Structural equality check for Type representations
1181 bool TypeF::eq(const Type *t) const {
1182   // Bitwise comparison to distinguish between +/-0. These values must be treated
1183   // as different to be consistent with C1 and the interpreter.
1184   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1185 }
1186 
1187 //------------------------------hash-------------------------------------------
1188 // Type-specific hashing function.
1189 int TypeF::hash(void) const {
1190   return *(int*)(&amp;_f);
1191 }
1192 
1193 //------------------------------is_finite--------------------------------------
1194 // Has a finite value
1195 bool TypeF::is_finite() const {
1196   return g_isfinite(getf()) != 0;
1197 }
1198 
1199 //------------------------------is_nan-----------------------------------------
1200 // Is not a number (NaN)
1201 bool TypeF::is_nan()    const {
1202   return g_isnan(getf()) != 0;
1203 }
1204 
1205 //------------------------------dump2------------------------------------------
1206 // Dump float constant Type
1207 #ifndef PRODUCT
1208 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1209   Type::dump2(d,depth, st);
1210   st-&gt;print(&quot;%f&quot;, _f);
1211 }
1212 #endif
1213 
1214 //------------------------------singleton--------------------------------------
1215 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1216 // constants (Ldi nodes).  Singletons are integer, float or double constants
1217 // or a single symbol.
1218 bool TypeF::singleton(void) const {
1219   return true;                  // Always a singleton
1220 }
1221 
1222 bool TypeF::empty(void) const {
1223   return false;                 // always exactly a singleton
1224 }
1225 
1226 //=============================================================================
1227 // Convenience common pre-built types.
1228 const TypeD *TypeD::ZERO;       // Floating point zero
1229 const TypeD *TypeD::ONE;        // Floating point one
1230 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1231 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1232 
1233 //------------------------------make-------------------------------------------
1234 const TypeD *TypeD::make(double d) {
1235   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1236 }
1237 
1238 //------------------------------meet-------------------------------------------
1239 // Compute the MEET of two types.  It returns a new Type object.
1240 const Type *TypeD::xmeet( const Type *t ) const {
1241   // Perform a fast test for common case; meeting the same types together.
1242   if( this == t ) return this;  // Meeting same type-rep?
1243 
1244   // Current &quot;this-&gt;_base&quot; is DoubleCon
1245   switch (t-&gt;base()) {          // Switch on original type
1246   case AnyPtr:                  // Mixing with oops happens when javac
1247   case RawPtr:                  // reuses local variables
1248   case OopPtr:
1249   case InstPtr:
1250   case AryPtr:
1251   case MetadataPtr:
1252   case KlassPtr:
1253   case NarrowOop:
1254   case NarrowKlass:
1255   case Int:
1256   case Long:
1257   case FloatTop:
1258   case FloatCon:
1259   case FloatBot:
1260   case Bottom:                  // Ye Olde Default
1261     return Type::BOTTOM;
1262 
1263   case DoubleBot:
1264     return t;
1265 
1266   default:                      // All else is a mistake
1267     typerr(t);
1268 
1269   case DoubleCon:               // Double-constant vs Double-constant?
1270     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1271       return DOUBLE;            // Return generic double
1272   case Top:
1273   case DoubleTop:
1274     break;
1275   }
1276   return this;                  // Return the double constant
1277 }
1278 
1279 //------------------------------xdual------------------------------------------
1280 // Dual: symmetric
1281 const Type *TypeD::xdual() const {
1282   return this;
1283 }
1284 
1285 //------------------------------eq---------------------------------------------
1286 // Structural equality check for Type representations
1287 bool TypeD::eq(const Type *t) const {
1288   // Bitwise comparison to distinguish between +/-0. These values must be treated
1289   // as different to be consistent with C1 and the interpreter.
1290   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1291 }
1292 
1293 //------------------------------hash-------------------------------------------
1294 // Type-specific hashing function.
1295 int TypeD::hash(void) const {
1296   return *(int*)(&amp;_d);
1297 }
1298 
1299 //------------------------------is_finite--------------------------------------
1300 // Has a finite value
1301 bool TypeD::is_finite() const {
1302   return g_isfinite(getd()) != 0;
1303 }
1304 
1305 //------------------------------is_nan-----------------------------------------
1306 // Is not a number (NaN)
1307 bool TypeD::is_nan()    const {
1308   return g_isnan(getd()) != 0;
1309 }
1310 
1311 //------------------------------dump2------------------------------------------
1312 // Dump double constant Type
1313 #ifndef PRODUCT
1314 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1315   Type::dump2(d,depth,st);
1316   st-&gt;print(&quot;%f&quot;, _d);
1317 }
1318 #endif
1319 
1320 //------------------------------singleton--------------------------------------
1321 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1322 // constants (Ldi nodes).  Singletons are integer, float or double constants
1323 // or a single symbol.
1324 bool TypeD::singleton(void) const {
1325   return true;                  // Always a singleton
1326 }
1327 
1328 bool TypeD::empty(void) const {
1329   return false;                 // always exactly a singleton
1330 }
1331 
1332 //=============================================================================
1333 // Convience common pre-built types.
1334 const TypeInt *TypeInt::MINUS_1;// -1
1335 const TypeInt *TypeInt::ZERO;   // 0
1336 const TypeInt *TypeInt::ONE;    // 1
1337 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1338 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1339 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1340 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1341 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1342 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1343 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1344 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1345 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1346 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1347 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1348 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1349 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1350 const TypeInt *TypeInt::INT;    // 32-bit integers
1351 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1352 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1353 
1354 //------------------------------TypeInt----------------------------------------
1355 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1356 }
1357 
1358 //------------------------------make-------------------------------------------
1359 const TypeInt *TypeInt::make( jint lo ) {
1360   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1361 }
1362 
1363 static int normalize_int_widen( jint lo, jint hi, int w ) {
1364   // Certain normalizations keep us sane when comparing types.
1365   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1366   if (lo &lt;= hi) {
1367     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1368     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1369   } else {
1370     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1371     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1372   }
1373   return w;
1374 }
1375 
1376 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1377   w = normalize_int_widen(lo, hi, w);
1378   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1379 }
1380 
1381 //------------------------------meet-------------------------------------------
1382 // Compute the MEET of two types.  It returns a new Type representation object
1383 // with reference count equal to the number of Types pointing at it.
1384 // Caller should wrap a Types around it.
1385 const Type *TypeInt::xmeet( const Type *t ) const {
1386   // Perform a fast test for common case; meeting the same types together.
1387   if( this == t ) return this;  // Meeting same type?
1388 
1389   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1390   switch (t-&gt;base()) {          // Switch on original type
1391   case AnyPtr:                  // Mixing with oops happens when javac
1392   case RawPtr:                  // reuses local variables
1393   case OopPtr:
1394   case InstPtr:
1395   case AryPtr:
1396   case MetadataPtr:
1397   case KlassPtr:
1398   case NarrowOop:
1399   case NarrowKlass:
1400   case Long:
1401   case FloatTop:
1402   case FloatCon:
1403   case FloatBot:
1404   case DoubleTop:
1405   case DoubleCon:
1406   case DoubleBot:
1407   case Bottom:                  // Ye Olde Default
1408     return Type::BOTTOM;
1409   default:                      // All else is a mistake
1410     typerr(t);
1411   case Top:                     // No change
1412     return this;
1413   case Int:                     // Int vs Int?
1414     break;
1415   }
1416 
1417   // Expand covered set
1418   const TypeInt *r = t-&gt;is_int();
1419   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1420 }
1421 
1422 //------------------------------xdual------------------------------------------
1423 // Dual: reverse hi &amp; lo; flip widen
1424 const Type *TypeInt::xdual() const {
1425   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1426   return new TypeInt(_hi,_lo,w);
1427 }
1428 
1429 //------------------------------widen------------------------------------------
1430 // Only happens for optimistic top-down optimizations.
1431 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1432   // Coming from TOP or such; no widening
1433   if( old-&gt;base() != Int ) return this;
1434   const TypeInt *ot = old-&gt;is_int();
1435 
1436   // If new guy is equal to old guy, no widening
1437   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1438     return old;
1439 
1440   // If new guy contains old, then we widened
1441   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1442     // New contains old
1443     // If new guy is already wider than old, no widening
1444     if( _widen &gt; ot-&gt;_widen ) return this;
1445     // If old guy was a constant, do not bother
1446     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1447     // Now widen new guy.
1448     // Check for widening too far
1449     if (_widen == WidenMax) {
1450       int max = max_jint;
1451       int min = min_jint;
1452       if (limit-&gt;isa_int()) {
1453         max = limit-&gt;is_int()-&gt;_hi;
1454         min = limit-&gt;is_int()-&gt;_lo;
1455       }
1456       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1457         // If neither endpoint is extremal yet, push out the endpoint
1458         // which is closer to its respective limit.
1459         if (_lo &gt;= 0 ||                 // easy common case
1460             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1461           // Try to widen to an unsigned range type of 31 bits:
1462           return make(_lo, max, WidenMax);
1463         } else {
1464           return make(min, _hi, WidenMax);
1465         }
1466       }
1467       return TypeInt::INT;
1468     }
1469     // Returned widened new guy
1470     return make(_lo,_hi,_widen+1);
1471   }
1472 
1473   // If old guy contains new, then we probably widened too far &amp; dropped to
1474   // bottom.  Return the wider fellow.
1475   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1476     return old;
1477 
1478   //fatal(&quot;Integer value range is not subset&quot;);
1479   //return this;
1480   return TypeInt::INT;
1481 }
1482 
1483 //------------------------------narrow---------------------------------------
1484 // Only happens for pessimistic optimizations.
1485 const Type *TypeInt::narrow( const Type *old ) const {
1486   if (_lo &gt;= _hi)  return this;   // already narrow enough
1487   if (old == NULL)  return this;
1488   const TypeInt* ot = old-&gt;isa_int();
1489   if (ot == NULL)  return this;
1490   jint olo = ot-&gt;_lo;
1491   jint ohi = ot-&gt;_hi;
1492 
1493   // If new guy is equal to old guy, no narrowing
1494   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1495 
1496   // If old guy was maximum range, allow the narrowing
1497   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1498 
1499   if (_lo &lt; olo || _hi &gt; ohi)
1500     return this;                // doesn&#39;t narrow; pretty wierd
1501 
1502   // The new type narrows the old type, so look for a &quot;death march&quot;.
1503   // See comments on PhaseTransform::saturate.
1504   juint nrange = (juint)_hi - _lo;
1505   juint orange = (juint)ohi - olo;
1506   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1507     // Use the new type only if the range shrinks a lot.
1508     // We do not want the optimizer computing 2^31 point by point.
1509     return old;
1510   }
1511 
1512   return this;
1513 }
1514 
1515 //-----------------------------filter------------------------------------------
1516 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1517   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1518   if (ft == NULL || ft-&gt;empty())
1519     return Type::TOP;           // Canonical empty value
1520   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1521     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1522     // The widen bits must be allowed to run freely through the graph.
1523     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1524   }
1525   return ft;
1526 }
1527 
1528 //------------------------------eq---------------------------------------------
1529 // Structural equality check for Type representations
1530 bool TypeInt::eq( const Type *t ) const {
1531   const TypeInt *r = t-&gt;is_int(); // Handy access
1532   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1533 }
1534 
1535 //------------------------------hash-------------------------------------------
1536 // Type-specific hashing function.
1537 int TypeInt::hash(void) const {
1538   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1539 }
1540 
1541 //------------------------------is_finite--------------------------------------
1542 // Has a finite value
1543 bool TypeInt::is_finite() const {
1544   return true;
1545 }
1546 
1547 //------------------------------dump2------------------------------------------
1548 // Dump TypeInt
1549 #ifndef PRODUCT
1550 static const char* intname(char* buf, jint n) {
1551   if (n == min_jint)
1552     return &quot;min&quot;;
1553   else if (n &lt; min_jint + 10000)
1554     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1555   else if (n == max_jint)
1556     return &quot;max&quot;;
1557   else if (n &gt; max_jint - 10000)
1558     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1559   else
1560     sprintf(buf, INT32_FORMAT, n);
1561   return buf;
1562 }
1563 
1564 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1565   char buf[40], buf2[40];
1566   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1567     st-&gt;print(&quot;int&quot;);
1568   else if (is_con())
1569     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1570   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1571     st-&gt;print(&quot;bool&quot;);
1572   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1573     st-&gt;print(&quot;byte&quot;);
1574   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1575     st-&gt;print(&quot;char&quot;);
1576   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1577     st-&gt;print(&quot;short&quot;);
1578   else if (_hi == max_jint)
1579     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1580   else if (_lo == min_jint)
1581     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1582   else
1583     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1584 
1585   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1586     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1587 }
1588 #endif
1589 
1590 //------------------------------singleton--------------------------------------
1591 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1592 // constants.
1593 bool TypeInt::singleton(void) const {
1594   return _lo &gt;= _hi;
1595 }
1596 
1597 bool TypeInt::empty(void) const {
1598   return _lo &gt; _hi;
1599 }
1600 
1601 //=============================================================================
1602 // Convenience common pre-built types.
1603 const TypeLong *TypeLong::MINUS_1;// -1
1604 const TypeLong *TypeLong::ZERO; // 0
1605 const TypeLong *TypeLong::ONE;  // 1
1606 const TypeLong *TypeLong::POS;  // &gt;=0
1607 const TypeLong *TypeLong::LONG; // 64-bit integers
1608 const TypeLong *TypeLong::INT;  // 32-bit subrange
1609 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1610 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1611 
1612 //------------------------------TypeLong---------------------------------------
1613 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1614 }
1615 
1616 //------------------------------make-------------------------------------------
1617 const TypeLong *TypeLong::make( jlong lo ) {
1618   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1619 }
1620 
1621 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1622   // Certain normalizations keep us sane when comparing types.
1623   // The &#39;SMALLINT&#39; covers constants.
1624   if (lo &lt;= hi) {
1625     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1626     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1627   } else {
1628     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1629     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1630   }
1631   return w;
1632 }
1633 
1634 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1635   w = normalize_long_widen(lo, hi, w);
1636   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1637 }
1638 
1639 
1640 //------------------------------meet-------------------------------------------
1641 // Compute the MEET of two types.  It returns a new Type representation object
1642 // with reference count equal to the number of Types pointing at it.
1643 // Caller should wrap a Types around it.
1644 const Type *TypeLong::xmeet( const Type *t ) const {
1645   // Perform a fast test for common case; meeting the same types together.
1646   if( this == t ) return this;  // Meeting same type?
1647 
1648   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1649   switch (t-&gt;base()) {          // Switch on original type
1650   case AnyPtr:                  // Mixing with oops happens when javac
1651   case RawPtr:                  // reuses local variables
1652   case OopPtr:
1653   case InstPtr:
1654   case AryPtr:
1655   case MetadataPtr:
1656   case KlassPtr:
1657   case NarrowOop:
1658   case NarrowKlass:
1659   case Int:
1660   case FloatTop:
1661   case FloatCon:
1662   case FloatBot:
1663   case DoubleTop:
1664   case DoubleCon:
1665   case DoubleBot:
1666   case Bottom:                  // Ye Olde Default
1667     return Type::BOTTOM;
1668   default:                      // All else is a mistake
1669     typerr(t);
1670   case Top:                     // No change
1671     return this;
1672   case Long:                    // Long vs Long?
1673     break;
1674   }
1675 
1676   // Expand covered set
1677   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1678   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1679 }
1680 
1681 //------------------------------xdual------------------------------------------
1682 // Dual: reverse hi &amp; lo; flip widen
1683 const Type *TypeLong::xdual() const {
1684   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1685   return new TypeLong(_hi,_lo,w);
1686 }
1687 
1688 //------------------------------widen------------------------------------------
1689 // Only happens for optimistic top-down optimizations.
1690 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1691   // Coming from TOP or such; no widening
1692   if( old-&gt;base() != Long ) return this;
1693   const TypeLong *ot = old-&gt;is_long();
1694 
1695   // If new guy is equal to old guy, no widening
1696   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1697     return old;
1698 
1699   // If new guy contains old, then we widened
1700   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1701     // New contains old
1702     // If new guy is already wider than old, no widening
1703     if( _widen &gt; ot-&gt;_widen ) return this;
1704     // If old guy was a constant, do not bother
1705     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1706     // Now widen new guy.
1707     // Check for widening too far
1708     if (_widen == WidenMax) {
1709       jlong max = max_jlong;
1710       jlong min = min_jlong;
1711       if (limit-&gt;isa_long()) {
1712         max = limit-&gt;is_long()-&gt;_hi;
1713         min = limit-&gt;is_long()-&gt;_lo;
1714       }
1715       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1716         // If neither endpoint is extremal yet, push out the endpoint
1717         // which is closer to its respective limit.
1718         if (_lo &gt;= 0 ||                 // easy common case
1719             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1720           // Try to widen to an unsigned range type of 32/63 bits:
1721           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1722             return make(_lo, max_juint, WidenMax);
1723           else
1724             return make(_lo, max, WidenMax);
1725         } else {
1726           return make(min, _hi, WidenMax);
1727         }
1728       }
1729       return TypeLong::LONG;
1730     }
1731     // Returned widened new guy
1732     return make(_lo,_hi,_widen+1);
1733   }
1734 
1735   // If old guy contains new, then we probably widened too far &amp; dropped to
1736   // bottom.  Return the wider fellow.
1737   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1738     return old;
1739 
1740   //  fatal(&quot;Long value range is not subset&quot;);
1741   // return this;
1742   return TypeLong::LONG;
1743 }
1744 
1745 //------------------------------narrow----------------------------------------
1746 // Only happens for pessimistic optimizations.
1747 const Type *TypeLong::narrow( const Type *old ) const {
1748   if (_lo &gt;= _hi)  return this;   // already narrow enough
1749   if (old == NULL)  return this;
1750   const TypeLong* ot = old-&gt;isa_long();
1751   if (ot == NULL)  return this;
1752   jlong olo = ot-&gt;_lo;
1753   jlong ohi = ot-&gt;_hi;
1754 
1755   // If new guy is equal to old guy, no narrowing
1756   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1757 
1758   // If old guy was maximum range, allow the narrowing
1759   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1760 
1761   if (_lo &lt; olo || _hi &gt; ohi)
1762     return this;                // doesn&#39;t narrow; pretty wierd
1763 
1764   // The new type narrows the old type, so look for a &quot;death march&quot;.
1765   // See comments on PhaseTransform::saturate.
1766   julong nrange = _hi - _lo;
1767   julong orange = ohi - olo;
1768   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1769     // Use the new type only if the range shrinks a lot.
1770     // We do not want the optimizer computing 2^31 point by point.
1771     return old;
1772   }
1773 
1774   return this;
1775 }
1776 
1777 //-----------------------------filter------------------------------------------
1778 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1779   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1780   if (ft == NULL || ft-&gt;empty())
1781     return Type::TOP;           // Canonical empty value
1782   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1783     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1784     // The widen bits must be allowed to run freely through the graph.
1785     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1786   }
1787   return ft;
1788 }
1789 
1790 //------------------------------eq---------------------------------------------
1791 // Structural equality check for Type representations
1792 bool TypeLong::eq( const Type *t ) const {
1793   const TypeLong *r = t-&gt;is_long(); // Handy access
1794   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1795 }
1796 
1797 //------------------------------hash-------------------------------------------
1798 // Type-specific hashing function.
1799 int TypeLong::hash(void) const {
1800   return (int)(_lo+_hi+_widen+(int)Type::Long);
1801 }
1802 
1803 //------------------------------is_finite--------------------------------------
1804 // Has a finite value
1805 bool TypeLong::is_finite() const {
1806   return true;
1807 }
1808 
1809 //------------------------------dump2------------------------------------------
1810 // Dump TypeLong
1811 #ifndef PRODUCT
1812 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1813   if (n &gt; x) {
1814     if (n &gt;= x + 10000)  return NULL;
1815     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1816   } else if (n &lt; x) {
1817     if (n &lt;= x - 10000)  return NULL;
1818     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1819   } else {
1820     return xname;
1821   }
1822   return buf;
1823 }
1824 
1825 static const char* longname(char* buf, jlong n) {
1826   const char* str;
1827   if (n == min_jlong)
1828     return &quot;min&quot;;
1829   else if (n &lt; min_jlong + 10000)
1830     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1831   else if (n == max_jlong)
1832     return &quot;max&quot;;
1833   else if (n &gt; max_jlong - 10000)
1834     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1835   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1836     return str;
1837   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1838     return str;
1839   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1840     return str;
1841   else
1842     sprintf(buf, JLONG_FORMAT, n);
1843   return buf;
1844 }
1845 
1846 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1847   char buf[80], buf2[80];
1848   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1849     st-&gt;print(&quot;long&quot;);
1850   else if (is_con())
1851     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1852   else if (_hi == max_jlong)
1853     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1854   else if (_lo == min_jlong)
1855     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1856   else
1857     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1858 
1859   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1860     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1861 }
1862 #endif
1863 
1864 //------------------------------singleton--------------------------------------
1865 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1866 // constants
1867 bool TypeLong::singleton(void) const {
1868   return _lo &gt;= _hi;
1869 }
1870 
1871 bool TypeLong::empty(void) const {
1872   return _lo &gt; _hi;
1873 }
1874 
1875 //=============================================================================
1876 // Convenience common pre-built types.
1877 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1878 const TypeTuple *TypeTuple::IFFALSE;
1879 const TypeTuple *TypeTuple::IFTRUE;
1880 const TypeTuple *TypeTuple::IFNEITHER;
1881 const TypeTuple *TypeTuple::LOOPBODY;
1882 const TypeTuple *TypeTuple::MEMBAR;
1883 const TypeTuple *TypeTuple::STORECONDITIONAL;
1884 const TypeTuple *TypeTuple::START_I2C;
1885 const TypeTuple *TypeTuple::INT_PAIR;
1886 const TypeTuple *TypeTuple::LONG_PAIR;
1887 const TypeTuple *TypeTuple::INT_CC_PAIR;
1888 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1889 
1890 
1891 //------------------------------make-------------------------------------------
1892 // Make a TypeTuple from the range of a method signature
1893 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {
1894   ciType* return_type = sig-&gt;return_type();
1895   uint arg_cnt = return_type-&gt;size();
1896   const Type **field_array = fields(arg_cnt);
1897   switch (return_type-&gt;basic_type()) {
1898   case T_LONG:
1899     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1900     field_array[TypeFunc::Parms+1] = Type::HALF;
1901     break;
1902   case T_DOUBLE:
1903     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1904     field_array[TypeFunc::Parms+1] = Type::HALF;
1905     break;
1906   case T_OBJECT:
1907   case T_ARRAY:
1908   case T_BOOLEAN:
1909   case T_CHAR:
1910   case T_FLOAT:
1911   case T_BYTE:
1912   case T_SHORT:
1913   case T_INT:
1914     field_array[TypeFunc::Parms] = get_const_type(return_type);
1915     break;
1916   case T_VOID:
1917     break;
1918   default:
1919     ShouldNotReachHere();
1920   }
1921   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1922 }
1923 
1924 // Make a TypeTuple from the domain of a method signature
1925 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {
1926   uint arg_cnt = sig-&gt;size();
1927 
1928   uint pos = TypeFunc::Parms;
1929   const Type **field_array;
1930   if (recv != NULL) {
1931     arg_cnt++;
1932     field_array = fields(arg_cnt);
1933     // Use get_const_type here because it respects UseUniqueSubclasses:
1934     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
1935   } else {
1936     field_array = fields(arg_cnt);
1937   }
1938 
1939   int i = 0;
1940   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1941     ciType* type = sig-&gt;type_at(i);
1942 
1943     switch (type-&gt;basic_type()) {
1944     case T_LONG:
1945       field_array[pos++] = TypeLong::LONG;
1946       field_array[pos++] = Type::HALF;
1947       break;
1948     case T_DOUBLE:
1949       field_array[pos++] = Type::DOUBLE;
1950       field_array[pos++] = Type::HALF;
1951       break;
1952     case T_OBJECT:
1953     case T_ARRAY:
1954     case T_FLOAT:
1955     case T_INT:
1956       field_array[pos++] = get_const_type(type);
1957       break;
1958     case T_BOOLEAN:
1959     case T_CHAR:
1960     case T_BYTE:
1961     case T_SHORT:
1962       field_array[pos++] = TypeInt::INT;
1963       break;
1964     default:
1965       ShouldNotReachHere();
1966     }
1967     i++;
1968   }
1969 
1970   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1971 }
1972 
1973 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1974   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1975 }
1976 
1977 //------------------------------fields-----------------------------------------
1978 // Subroutine call type with space allocated for argument types
1979 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1980 const Type **TypeTuple::fields( uint arg_cnt ) {
1981   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1982   flds[TypeFunc::Control  ] = Type::CONTROL;
1983   flds[TypeFunc::I_O      ] = Type::ABIO;
1984   flds[TypeFunc::Memory   ] = Type::MEMORY;
1985   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1986   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1987 
1988   return flds;
1989 }
1990 
1991 //------------------------------meet-------------------------------------------
1992 // Compute the MEET of two types.  It returns a new Type object.
1993 const Type *TypeTuple::xmeet( const Type *t ) const {
1994   // Perform a fast test for common case; meeting the same types together.
1995   if( this == t ) return this;  // Meeting same type-rep?
1996 
1997   // Current &quot;this-&gt;_base&quot; is Tuple
1998   switch (t-&gt;base()) {          // switch on original type
1999 
2000   case Bottom:                  // Ye Olde Default
2001     return t;
2002 
2003   default:                      // All else is a mistake
2004     typerr(t);
2005 
2006   case Tuple: {                 // Meeting 2 signatures?
2007     const TypeTuple *x = t-&gt;is_tuple();
2008     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2009     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2010     for( uint i=0; i&lt;_cnt; i++ )
2011       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2012     return TypeTuple::make(_cnt,fields);
2013   }
2014   case Top:
2015     break;
2016   }
2017   return this;                  // Return the double constant
2018 }
2019 
2020 //------------------------------xdual------------------------------------------
2021 // Dual: compute field-by-field dual
2022 const Type *TypeTuple::xdual() const {
2023   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2024   for( uint i=0; i&lt;_cnt; i++ )
2025     fields[i] = _fields[i]-&gt;dual();
2026   return new TypeTuple(_cnt,fields);
2027 }
2028 
2029 //------------------------------eq---------------------------------------------
2030 // Structural equality check for Type representations
2031 bool TypeTuple::eq( const Type *t ) const {
2032   const TypeTuple *s = (const TypeTuple *)t;
2033   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2034   for (uint i = 0; i &lt; _cnt; i++)
2035     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2036       return false;             // Missed
2037   return true;
2038 }
2039 
2040 //------------------------------hash-------------------------------------------
2041 // Type-specific hashing function.
2042 int TypeTuple::hash(void) const {
2043   intptr_t sum = _cnt;
2044   for( uint i=0; i&lt;_cnt; i++ )
2045     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2046   return sum;
2047 }
2048 
2049 //------------------------------dump2------------------------------------------
2050 // Dump signature Type
2051 #ifndef PRODUCT
2052 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2053   st-&gt;print(&quot;{&quot;);
2054   if( !depth || d[this] ) {     // Check for recursive print
2055     st-&gt;print(&quot;...}&quot;);
2056     return;
2057   }
2058   d.Insert((void*)this, (void*)this);   // Stop recursion
2059   if( _cnt ) {
2060     uint i;
2061     for( i=0; i&lt;_cnt-1; i++ ) {
2062       st-&gt;print(&quot;%d:&quot;, i);
2063       _fields[i]-&gt;dump2(d, depth-1, st);
2064       st-&gt;print(&quot;, &quot;);
2065     }
2066     st-&gt;print(&quot;%d:&quot;, i);
2067     _fields[i]-&gt;dump2(d, depth-1, st);
2068   }
2069   st-&gt;print(&quot;}&quot;);
2070 }
2071 #endif
2072 
2073 //------------------------------singleton--------------------------------------
2074 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2075 // constants (Ldi nodes).  Singletons are integer, float or double constants
2076 // or a single symbol.
2077 bool TypeTuple::singleton(void) const {
2078   return false;                 // Never a singleton
2079 }
2080 
2081 bool TypeTuple::empty(void) const {
2082   for( uint i=0; i&lt;_cnt; i++ ) {
2083     if (_fields[i]-&gt;empty())  return true;
2084   }
2085   return false;
2086 }
2087 
2088 //=============================================================================
2089 // Convenience common pre-built types.
2090 
2091 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2092   // Certain normalizations keep us sane when comparing types.
2093   // We do not want arrayOop variables to differ only by the wideness
2094   // of their index types.  Pick minimum wideness, since that is the
2095   // forced wideness of small ranges anyway.
2096   if (size-&gt;_widen != Type::WidenMin)
2097     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2098   else
2099     return size;
2100 }
2101 
2102 //------------------------------make-------------------------------------------
2103 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {
2104   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2105     elem = elem-&gt;make_narrowoop();
2106   }
2107   size = normalize_array_size(size);
2108   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();
2109 }
2110 
2111 //------------------------------meet-------------------------------------------
2112 // Compute the MEET of two types.  It returns a new Type object.
2113 const Type *TypeAry::xmeet( const Type *t ) const {
2114   // Perform a fast test for common case; meeting the same types together.
2115   if( this == t ) return this;  // Meeting same type-rep?
2116 
2117   // Current &quot;this-&gt;_base&quot; is Ary
2118   switch (t-&gt;base()) {          // switch on original type
2119 
2120   case Bottom:                  // Ye Olde Default
2121     return t;
2122 
2123   default:                      // All else is a mistake
2124     typerr(t);
2125 
2126   case Array: {                 // Meeting 2 arrays?
2127     const TypeAry *a = t-&gt;is_ary();
2128     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2129                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2130                          _stable &amp;&amp; a-&gt;_stable);
2131   }
2132   case Top:
2133     break;
2134   }
2135   return this;                  // Return the double constant
2136 }
2137 
2138 //------------------------------xdual------------------------------------------
2139 // Dual: compute field-by-field dual
2140 const Type *TypeAry::xdual() const {
2141   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2142   size_dual = normalize_array_size(size_dual);
2143   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2144 }
2145 
2146 //------------------------------eq---------------------------------------------
2147 // Structural equality check for Type representations
2148 bool TypeAry::eq( const Type *t ) const {
2149   const TypeAry *a = (const TypeAry*)t;
2150   return _elem == a-&gt;_elem &amp;&amp;
2151     _stable == a-&gt;_stable &amp;&amp;
2152     _size == a-&gt;_size;
2153 }
2154 
2155 //------------------------------hash-------------------------------------------
2156 // Type-specific hashing function.
2157 int TypeAry::hash(void) const {
2158   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2159 }
2160 
2161 /**
2162  * Return same type without a speculative part in the element
2163  */
2164 const Type* TypeAry::remove_speculative() const {
2165   return make(_elem-&gt;remove_speculative(), _size, _stable);
2166 }
2167 
2168 /**
2169  * Return same type with cleaned up speculative part of element
2170  */
2171 const Type* TypeAry::cleanup_speculative() const {
2172   return make(_elem-&gt;cleanup_speculative(), _size, _stable);
2173 }
2174 
2175 /**
2176  * Return same type but with a different inline depth (used for speculation)
2177  *
2178  * @param depth  depth to meet with
2179  */
2180 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2181   if (!UseInlineDepthForSpeculativeTypes) {
2182     return this;
2183   }
2184   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2185 }
2186 
2187 //----------------------interface_vs_oop---------------------------------------
2188 #ifdef ASSERT
2189 bool TypeAry::interface_vs_oop(const Type *t) const {
2190   const TypeAry* t_ary = t-&gt;is_ary();
2191   if (t_ary) {
2192     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2193     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2194     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2195       return this_ptr-&gt;interface_vs_oop(t_ptr);
2196     }
2197   }
2198   return false;
2199 }
2200 #endif
2201 
2202 //------------------------------dump2------------------------------------------
2203 #ifndef PRODUCT
2204 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2205   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2206   _elem-&gt;dump2(d, depth, st);
2207   st-&gt;print(&quot;[&quot;);
2208   _size-&gt;dump2(d, depth, st);
2209   st-&gt;print(&quot;]&quot;);
2210 }
2211 #endif
2212 
2213 //------------------------------singleton--------------------------------------
2214 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2215 // constants (Ldi nodes).  Singletons are integer, float or double constants
2216 // or a single symbol.
2217 bool TypeAry::singleton(void) const {
2218   return false;                 // Never a singleton
2219 }
2220 
2221 bool TypeAry::empty(void) const {
2222   return _elem-&gt;empty() || _size-&gt;empty();
2223 }
2224 
2225 //--------------------------ary_must_be_exact----------------------------------
2226 bool TypeAry::ary_must_be_exact() const {
2227   if (!UseExactTypes)       return false;
2228   // This logic looks at the element type of an array, and returns true
2229   // if the element type is either a primitive or a final instance class.
2230   // In such cases, an array built on this ary must have no subclasses.
2231   if (_elem == BOTTOM)      return false;  // general array not exact
2232   if (_elem == TOP   )      return false;  // inverted general array not exact
2233   const TypeOopPtr*  toop = NULL;
2234   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2235     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2236   } else {
2237     toop = _elem-&gt;isa_oopptr();
2238   }
2239   if (!toop)                return true;   // a primitive type, like int
2240   ciKlass* tklass = toop-&gt;klass();
2241   if (tklass == NULL)       return false;  // unloaded class
2242   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2243   const TypeInstPtr* tinst;
2244   if (_elem-&gt;isa_narrowoop())
2245     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2246   else
2247     tinst = _elem-&gt;isa_instptr();
2248   if (tinst)
2249     return tklass-&gt;as_instance_klass()-&gt;is_final();
2250   const TypeAryPtr*  tap;
2251   if (_elem-&gt;isa_narrowoop())
2252     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2253   else
2254     tap = _elem-&gt;isa_aryptr();
2255   if (tap)
2256     return tap-&gt;ary()-&gt;ary_must_be_exact();
2257   return false;
2258 }
2259 
2260 //==============================TypeVect=======================================
2261 // Convenience common pre-built types.
2262 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2263 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2264 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2265 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2266 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2267 
2268 //------------------------------make-------------------------------------------
2269 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2270   BasicType elem_bt = elem-&gt;array_element_basic_type();
2271   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2272   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2273   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2274   int size = length * type2aelembytes(elem_bt);
2275   switch (Matcher::vector_ideal_reg(size)) {
2276   case Op_VecS:
2277     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2278   case Op_RegL:
2279   case Op_VecD:
2280   case Op_RegD:
2281     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2282   case Op_VecX:
2283     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2284   case Op_VecY:
2285     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2286   case Op_VecZ:
2287     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2288   }
2289  ShouldNotReachHere();
2290   return NULL;
2291 }
2292 
2293 //------------------------------meet-------------------------------------------
2294 // Compute the MEET of two types.  It returns a new Type object.
2295 const Type *TypeVect::xmeet( const Type *t ) const {
2296   // Perform a fast test for common case; meeting the same types together.
2297   if( this == t ) return this;  // Meeting same type-rep?
2298 
2299   // Current &quot;this-&gt;_base&quot; is Vector
2300   switch (t-&gt;base()) {          // switch on original type
2301 
2302   case Bottom:                  // Ye Olde Default
2303     return t;
2304 
2305   default:                      // All else is a mistake
2306     typerr(t);
2307 
2308   case VectorS:
2309   case VectorD:
2310   case VectorX:
2311   case VectorY:
2312   case VectorZ: {                // Meeting 2 vectors?
2313     const TypeVect* v = t-&gt;is_vect();
2314     assert(  base() == v-&gt;base(), &quot;&quot;);
2315     assert(length() == v-&gt;length(), &quot;&quot;);
2316     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2317     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2318   }
2319   case Top:
2320     break;
2321   }
2322   return this;
2323 }
2324 
2325 //------------------------------xdual------------------------------------------
2326 // Dual: compute field-by-field dual
2327 const Type *TypeVect::xdual() const {
2328   return new TypeVect(base(), _elem-&gt;dual(), _length);
2329 }
2330 
2331 //------------------------------eq---------------------------------------------
2332 // Structural equality check for Type representations
2333 bool TypeVect::eq(const Type *t) const {
2334   const TypeVect *v = t-&gt;is_vect();
2335   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2336 }
2337 
2338 //------------------------------hash-------------------------------------------
2339 // Type-specific hashing function.
2340 int TypeVect::hash(void) const {
2341   return (intptr_t)_elem + (intptr_t)_length;
2342 }
2343 
2344 //------------------------------singleton--------------------------------------
2345 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2346 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2347 // constant value (when vector is created with Replicate code).
2348 bool TypeVect::singleton(void) const {
2349 // There is no Con node for vectors yet.
2350 //  return _elem-&gt;singleton();
2351   return false;
2352 }
2353 
2354 bool TypeVect::empty(void) const {
2355   return _elem-&gt;empty();
2356 }
2357 
2358 //------------------------------dump2------------------------------------------
2359 #ifndef PRODUCT
2360 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2361   switch (base()) {
2362   case VectorS:
2363     st-&gt;print(&quot;vectors[&quot;); break;
2364   case VectorD:
2365     st-&gt;print(&quot;vectord[&quot;); break;
2366   case VectorX:
2367     st-&gt;print(&quot;vectorx[&quot;); break;
2368   case VectorY:
2369     st-&gt;print(&quot;vectory[&quot;); break;
2370   case VectorZ:
2371     st-&gt;print(&quot;vectorz[&quot;); break;
2372   default:
2373     ShouldNotReachHere();
2374   }
2375   st-&gt;print(&quot;%d]:{&quot;, _length);
2376   _elem-&gt;dump2(d, depth, st);
2377   st-&gt;print(&quot;}&quot;);
2378 }
2379 #endif
2380 
2381 
2382 //=============================================================================
2383 // Convenience common pre-built types.
2384 const TypePtr *TypePtr::NULL_PTR;
2385 const TypePtr *TypePtr::NOTNULL;
2386 const TypePtr *TypePtr::BOTTOM;
2387 
2388 //------------------------------meet-------------------------------------------
2389 // Meet over the PTR enum
2390 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2391   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2392   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2393   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2394   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2395   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2396   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2397   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2398 };
2399 
2400 //------------------------------make-------------------------------------------
2401 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {
2402   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2403 }
2404 
2405 //------------------------------cast_to_ptr_type-------------------------------
2406 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2407   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2408   if( ptr == _ptr ) return this;
2409   return make(_base, ptr, _offset, _speculative, _inline_depth);
2410 }
2411 
2412 //------------------------------get_con----------------------------------------
2413 intptr_t TypePtr::get_con() const {
2414   assert( _ptr == Null, &quot;&quot; );
2415   return _offset;
2416 }
2417 
2418 //------------------------------meet-------------------------------------------
2419 // Compute the MEET of two types.  It returns a new Type object.
2420 const Type *TypePtr::xmeet(const Type *t) const {
2421   const Type* res = xmeet_helper(t);
2422   if (res-&gt;isa_ptr() == NULL) {
2423     return res;
2424   }
2425 
2426   const TypePtr* res_ptr = res-&gt;is_ptr();
2427   if (res_ptr-&gt;speculative() != NULL) {
2428     // type-&gt;speculative() == NULL means that speculation is no better
2429     // than type, i.e. type-&gt;speculative() == type. So there are 2
2430     // ways to represent the fact that we have no useful speculative
2431     // data and we should use a single one to be able to test for
2432     // equality between types. Check whether type-&gt;speculative() ==
2433     // type and set speculative to NULL if it is the case.
2434     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2435       return res_ptr-&gt;remove_speculative();
2436     }
2437   }
2438 
2439   return res;
2440 }
2441 
2442 const Type *TypePtr::xmeet_helper(const Type *t) const {
2443   // Perform a fast test for common case; meeting the same types together.
2444   if( this == t ) return this;  // Meeting same type-rep?
2445 
2446   // Current &quot;this-&gt;_base&quot; is AnyPtr
2447   switch (t-&gt;base()) {          // switch on original type
2448   case Int:                     // Mixing ints &amp; oops happens when javac
2449   case Long:                    // reuses local variables
2450   case FloatTop:
2451   case FloatCon:
2452   case FloatBot:
2453   case DoubleTop:
2454   case DoubleCon:
2455   case DoubleBot:
2456   case NarrowOop:
2457   case NarrowKlass:
2458   case Bottom:                  // Ye Olde Default
2459     return Type::BOTTOM;
2460   case Top:
2461     return this;
2462 
2463   case AnyPtr: {                // Meeting to AnyPtrs
2464     const TypePtr *tp = t-&gt;is_ptr();
2465     const TypePtr* speculative = xmeet_speculative(tp);
2466     int depth = meet_inline_depth(tp-&gt;inline_depth());
2467     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2468   }
2469   case RawPtr:                  // For these, flip the call around to cut down
2470   case OopPtr:
2471   case InstPtr:                 // on the cases I have to handle.
2472   case AryPtr:
2473   case MetadataPtr:
2474   case KlassPtr:
2475     return t-&gt;xmeet(this);      // Call in reverse direction
2476   default:                      // All else is a mistake
2477     typerr(t);
2478 
2479   }
2480   return this;
2481 }
2482 
2483 //------------------------------meet_offset------------------------------------
2484 int TypePtr::meet_offset( int offset ) const {
2485   // Either is &#39;TOP&#39; offset?  Return the other offset!
2486   if( _offset == OffsetTop ) return offset;
2487   if( offset == OffsetTop ) return _offset;
2488   // If either is different, return &#39;BOTTOM&#39; offset
2489   if( _offset != offset ) return OffsetBot;
2490   return _offset;
2491 }
2492 
2493 //------------------------------dual_offset------------------------------------
2494 int TypePtr::dual_offset( ) const {
2495   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
2496   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
2497   return _offset;               // Map everything else into self
2498 }
2499 
2500 //------------------------------xdual------------------------------------------
2501 // Dual: compute field-by-field dual
2502 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2503   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2504 };
2505 const Type *TypePtr::xdual() const {
2506   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2507 }
2508 
2509 //------------------------------xadd_offset------------------------------------
2510 int TypePtr::xadd_offset( intptr_t offset ) const {
2511   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
2512   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;
2513   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
2514   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;
2515   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
2516   offset += (intptr_t)_offset;
2517   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;
2518 
2519   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
2520   // It is possible to construct a negative offset during PhaseCCP
2521 
2522   return (int)offset;        // Sum valid offsets
2523 }
2524 
2525 //------------------------------add_offset-------------------------------------
2526 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2527   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2528 }
2529 
2530 //------------------------------eq---------------------------------------------
2531 // Structural equality check for Type representations
2532 bool TypePtr::eq( const Type *t ) const {
2533   const TypePtr *a = (const TypePtr*)t;
2534   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2535 }
2536 
2537 //------------------------------hash-------------------------------------------
2538 // Type-specific hashing function.
2539 int TypePtr::hash(void) const {
2540   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));
2541 ;
2542 }
2543 
2544 /**
2545  * Return same type without a speculative part
2546  */
2547 const Type* TypePtr::remove_speculative() const {
2548   if (_speculative == NULL) {
2549     return this;
2550   }
2551   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2552   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2553 }
2554 
2555 /**
2556  * Return same type but drop speculative part if we know we won&#39;t use
2557  * it
2558  */
2559 const Type* TypePtr::cleanup_speculative() const {
2560   if (speculative() == NULL) {
2561     return this;
2562   }
2563   const Type* no_spec = remove_speculative();
2564   // If this is NULL_PTR then we don&#39;t need the speculative type
2565   // (with_inline_depth in case the current type inline depth is
2566   // InlineDepthTop)
2567   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2568     return no_spec;
2569   }
2570   if (above_centerline(speculative()-&gt;ptr())) {
2571     return no_spec;
2572   }
2573   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2574   // If the speculative may be null and is an inexact klass then it
2575   // doesn&#39;t help
2576   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2577       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2578     return no_spec;
2579   }
2580   return this;
2581 }
2582 
2583 /**
2584  * dual of the speculative part of the type
2585  */
2586 const TypePtr* TypePtr::dual_speculative() const {
2587   if (_speculative == NULL) {
2588     return NULL;
2589   }
2590   return _speculative-&gt;dual()-&gt;is_ptr();
2591 }
2592 
2593 /**
2594  * meet of the speculative parts of 2 types
2595  *
2596  * @param other  type to meet with
2597  */
2598 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2599   bool this_has_spec = (_speculative != NULL);
2600   bool other_has_spec = (other-&gt;speculative() != NULL);
2601 
2602   if (!this_has_spec &amp;&amp; !other_has_spec) {
2603     return NULL;
2604   }
2605 
2606   // If we are at a point where control flow meets and one branch has
2607   // a speculative type and the other has not, we meet the speculative
2608   // type of one branch with the actual type of the other. If the
2609   // actual type is exact and the speculative is as well, then the
2610   // result is a speculative type which is exact and we can continue
2611   // speculation further.
2612   const TypePtr* this_spec = _speculative;
2613   const TypePtr* other_spec = other-&gt;speculative();
2614 
2615   if (!this_has_spec) {
2616     this_spec = this;
2617   }
2618 
2619   if (!other_has_spec) {
2620     other_spec = other;
2621   }
2622 
2623   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2624 }
2625 
2626 /**
2627  * dual of the inline depth for this type (used for speculation)
2628  */
2629 int TypePtr::dual_inline_depth() const {
2630   return -inline_depth();
2631 }
2632 
2633 /**
2634  * meet of 2 inline depths (used for speculation)
2635  *
2636  * @param depth  depth to meet with
2637  */
2638 int TypePtr::meet_inline_depth(int depth) const {
2639   return MAX2(inline_depth(), depth);
2640 }
2641 
2642 /**
2643  * Are the speculative parts of 2 types equal?
2644  *
2645  * @param other  type to compare this one to
2646  */
2647 bool TypePtr::eq_speculative(const TypePtr* other) const {
2648   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2649     return _speculative == other-&gt;speculative();
2650   }
2651 
2652   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2653     return false;
2654   }
2655 
2656   return _speculative-&gt;eq(other-&gt;speculative());
2657 }
2658 
2659 /**
2660  * Hash of the speculative part of the type
2661  */
2662 int TypePtr::hash_speculative() const {
2663   if (_speculative == NULL) {
2664     return 0;
2665   }
2666 
2667   return _speculative-&gt;hash();
2668 }
2669 
2670 /**
2671  * add offset to the speculative part of the type
2672  *
2673  * @param offset  offset to add
2674  */
2675 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2676   if (_speculative == NULL) {
2677     return NULL;
2678   }
2679   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2680 }
2681 
2682 /**
2683  * return exact klass from the speculative type if there&#39;s one
2684  */
2685 ciKlass* TypePtr::speculative_type() const {
2686   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2687     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2688     if (speculative-&gt;klass_is_exact()) {
2689       return speculative-&gt;klass();
2690     }
2691   }
2692   return NULL;
2693 }
2694 
2695 /**
2696  * return true if speculative type may be null
2697  */
2698 bool TypePtr::speculative_maybe_null() const {
2699   if (_speculative != NULL) {
2700     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2701     return speculative-&gt;maybe_null();
2702   }
2703   return true;
2704 }
2705 
2706 bool TypePtr::speculative_always_null() const {
2707   if (_speculative != NULL) {
2708     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2709     return speculative == TypePtr::NULL_PTR;
2710   }
2711   return false;
2712 }
2713 
2714 /**
2715  * Same as TypePtr::speculative_type() but return the klass only if
2716  * the speculative tells us is not null
2717  */
2718 ciKlass* TypePtr::speculative_type_not_null() const {
2719   if (speculative_maybe_null()) {
2720     return NULL;
2721   }
2722   return speculative_type();
2723 }
2724 
2725 /**
2726  * Check whether new profiling would improve speculative type
2727  *
2728  * @param   exact_kls    class from profiling
2729  * @param   inline_depth inlining depth of profile point
2730  *
2731  * @return  true if type profile is valuable
2732  */
2733 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2734   // no profiling?
2735   if (exact_kls == NULL) {
2736     return false;
2737   }
2738   if (speculative() == TypePtr::NULL_PTR) {
2739     return false;
2740   }
2741   // no speculative type or non exact speculative type?
2742   if (speculative_type() == NULL) {
2743     return true;
2744   }
2745   // If the node already has an exact speculative type keep it,
2746   // unless it was provided by profiling that is at a deeper
2747   // inlining level. Profiling at a higher inlining depth is
2748   // expected to be less accurate.
2749   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2750     return false;
2751   }
2752   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2753   return inline_depth &lt; _speculative-&gt;inline_depth();
2754 }
2755 
2756 /**
2757  * Check whether new profiling would improve ptr (= tells us it is non
2758  * null)
2759  *
2760  * @param   ptr_kind always null or not null?
2761  *
2762  * @return  true if ptr profile is valuable
2763  */
2764 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
2765   // profiling doesn&#39;t tell us anything useful
2766   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
2767     return false;
2768   }
2769   // We already know this is not null
2770   if (!this-&gt;maybe_null()) {
2771     return false;
2772   }
2773   // We already know the speculative type cannot be null
2774   if (!speculative_maybe_null()) {
2775     return false;
2776   }
2777   // We already know this is always null
2778   if (this == TypePtr::NULL_PTR) {
2779     return false;
2780   }
2781   // We already know the speculative type is always null
2782   if (speculative_always_null()) {
2783     return false;
2784   }
2785   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2786     return false;
2787   }
2788   return true;
2789 }
2790 
2791 //------------------------------dump2------------------------------------------
2792 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2793   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2794 };
2795 
2796 #ifndef PRODUCT
2797 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2798   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2799   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
2800   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);
2801   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);
2802   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);
2803   dump_inline_depth(st);
2804   dump_speculative(st);
2805 }
2806 
2807 /**
2808  *dump the speculative part of the type
2809  */
2810 void TypePtr::dump_speculative(outputStream *st) const {
2811   if (_speculative != NULL) {
2812     st-&gt;print(&quot; (speculative=&quot;);
2813     _speculative-&gt;dump_on(st);
2814     st-&gt;print(&quot;)&quot;);
2815   }
2816 }
2817 
2818 /**
2819  *dump the inline depth of the type
2820  */
2821 void TypePtr::dump_inline_depth(outputStream *st) const {
2822   if (_inline_depth != InlineDepthBottom) {
2823     if (_inline_depth == InlineDepthTop) {
2824       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2825     } else {
2826       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2827     }
2828   }
2829 }
2830 #endif
2831 
2832 //------------------------------singleton--------------------------------------
2833 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2834 // constants
2835 bool TypePtr::singleton(void) const {
2836   // TopPTR, Null, AnyNull, Constant are all singletons
2837   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);
2838 }
2839 
2840 bool TypePtr::empty(void) const {
2841   return (_offset == OffsetTop) || above_centerline(_ptr);
2842 }
2843 
2844 //=============================================================================
2845 // Convenience common pre-built types.
2846 const TypeRawPtr *TypeRawPtr::BOTTOM;
2847 const TypeRawPtr *TypeRawPtr::NOTNULL;
2848 
2849 //------------------------------make-------------------------------------------
2850 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2851   assert( ptr != Constant, &quot;what is the constant?&quot; );
2852   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2853   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2854 }
2855 
2856 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2857   assert( bits, &quot;Use TypePtr for NULL&quot; );
2858   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2859 }
2860 
2861 //------------------------------cast_to_ptr_type-------------------------------
2862 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
2863   assert( ptr != Constant, &quot;what is the constant?&quot; );
2864   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2865   assert( _bits==0, &quot;Why cast a constant address?&quot;);
2866   if( ptr == _ptr ) return this;
2867   return make(ptr);
2868 }
2869 
2870 //------------------------------get_con----------------------------------------
2871 intptr_t TypeRawPtr::get_con() const {
2872   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
2873   return (intptr_t)_bits;
2874 }
2875 
2876 //------------------------------meet-------------------------------------------
2877 // Compute the MEET of two types.  It returns a new Type object.
2878 const Type *TypeRawPtr::xmeet( const Type *t ) const {
2879   // Perform a fast test for common case; meeting the same types together.
2880   if( this == t ) return this;  // Meeting same type-rep?
2881 
2882   // Current &quot;this-&gt;_base&quot; is RawPtr
2883   switch( t-&gt;base() ) {         // switch on original type
2884   case Bottom:                  // Ye Olde Default
2885     return t;
2886   case Top:
2887     return this;
2888   case AnyPtr:                  // Meeting to AnyPtrs
2889     break;
2890   case RawPtr: {                // might be top, bot, any/not or constant
2891     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
2892     enum PTR ptr = meet_ptr( tptr );
2893     if( ptr == Constant ) {     // Cannot be equal constants, so...
2894       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
2895       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
2896       ptr = NotNull;            // Fall down in lattice
2897     }
2898     return make( ptr );
2899   }
2900 
2901   case OopPtr:
2902   case InstPtr:
2903   case AryPtr:
2904   case MetadataPtr:
2905   case KlassPtr:
2906     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
2907   default:                      // All else is a mistake
2908     typerr(t);
2909   }
2910 
2911   // Found an AnyPtr type vs self-RawPtr type
2912   const TypePtr *tp = t-&gt;is_ptr();
2913   switch (tp-&gt;ptr()) {
2914   case TypePtr::TopPTR:  return this;
2915   case TypePtr::BotPTR:  return t;
2916   case TypePtr::Null:
2917     if( _ptr == TypePtr::TopPTR ) return t;
2918     return TypeRawPtr::BOTTOM;
2919   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
2920   case TypePtr::AnyNull:
2921     if( _ptr == TypePtr::Constant) return this;
2922     return make( meet_ptr(TypePtr::AnyNull) );
2923   default: ShouldNotReachHere();
2924   }
2925   return this;
2926 }
2927 
2928 //------------------------------xdual------------------------------------------
2929 // Dual: compute field-by-field dual
2930 const Type *TypeRawPtr::xdual() const {
2931   return new TypeRawPtr( dual_ptr(), _bits );
2932 }
2933 
2934 //------------------------------add_offset-------------------------------------
2935 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
2936   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
2937   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
2938   if( offset == 0 ) return this; // No change
2939   switch (_ptr) {
2940   case TypePtr::TopPTR:
2941   case TypePtr::BotPTR:
2942   case TypePtr::NotNull:
2943     return this;
2944   case TypePtr::Null:
2945   case TypePtr::Constant: {
2946     address bits = _bits+offset;
2947     if ( bits == 0 ) return TypePtr::NULL_PTR;
2948     return make( bits );
2949   }
2950   default:  ShouldNotReachHere();
2951   }
2952   return NULL;                  // Lint noise
2953 }
2954 
2955 //------------------------------eq---------------------------------------------
2956 // Structural equality check for Type representations
2957 bool TypeRawPtr::eq( const Type *t ) const {
2958   const TypeRawPtr *a = (const TypeRawPtr*)t;
2959   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
2960 }
2961 
2962 //------------------------------hash-------------------------------------------
2963 // Type-specific hashing function.
2964 int TypeRawPtr::hash(void) const {
2965   return (intptr_t)_bits + TypePtr::hash();
2966 }
2967 
2968 //------------------------------dump2------------------------------------------
2969 #ifndef PRODUCT
2970 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2971   if( _ptr == Constant )
2972     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2973   else
2974     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2975 }
2976 #endif
2977 
2978 //=============================================================================
2979 // Convenience common pre-built type.
2980 const TypeOopPtr *TypeOopPtr::BOTTOM;
2981 
2982 //------------------------------TypeOopPtr-------------------------------------
2983 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
2984                        int instance_id, const TypePtr* speculative, int inline_depth)
2985   : TypePtr(t, ptr, offset, speculative, inline_depth),
2986     _const_oop(o), _klass(k),
2987     _klass_is_exact(xk),
2988     _is_ptr_to_narrowoop(false),
2989     _is_ptr_to_narrowklass(false),
2990     _is_ptr_to_boxed_value(false),
2991     _instance_id(instance_id) {
2992   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
2993       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
2994     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);
2995   }
2996 #ifdef _LP64
2997   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {
2998     if (_offset == oopDesc::klass_offset_in_bytes()) {
2999       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3000     } else if (klass() == NULL) {
3001       // Array with unknown body type
3002       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3003       _is_ptr_to_narrowoop = UseCompressedOops;
3004     } else if (this-&gt;isa_aryptr()) {
3005       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;
3006                              _offset != arrayOopDesc::length_offset_in_bytes());
3007     } else if (klass()-&gt;is_instance_klass()) {
3008       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3009       ciField* field = NULL;
3010       if (this-&gt;isa_klassptr()) {
3011         // Perm objects don&#39;t use compressed references
3012       } else if (_offset == OffsetBot || _offset == OffsetTop) {
3013         // unsafe access
3014         _is_ptr_to_narrowoop = UseCompressedOops;
3015       } else { // exclude unsafe ops
3016         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3017 
3018         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3019             (_offset == java_lang_Class::klass_offset_in_bytes() ||
3020              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
3021           // Special hidden fields from the Class.
3022           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3023           _is_ptr_to_narrowoop = false;
3024         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3025                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3026           // Static fields
3027           assert(o != NULL, &quot;must be constant&quot;);
3028           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3029           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3030           assert(field != NULL, &quot;missing field&quot;);
3031           BasicType basic_elem_type = field-&gt;layout_type();
3032           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3033         } else {
3034           // Instance fields which contains a compressed oop references.
3035           field = ik-&gt;get_field_by_offset(_offset, false);
3036           if (field != NULL) {
3037             BasicType basic_elem_type = field-&gt;layout_type();
3038             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3039           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3040             // Compile::find_alias_type() cast exactness on all types to verify
3041             // that it does not affect alias type.
3042             _is_ptr_to_narrowoop = UseCompressedOops;
3043           } else {
3044             // Type for the copy start in LibraryCallKit::inline_native_clone().
3045             _is_ptr_to_narrowoop = UseCompressedOops;
3046           }
3047         }
3048       }
3049     }
3050   }
3051 #endif
3052 }
3053 
3054 //------------------------------make-------------------------------------------
3055 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3056                                      const TypePtr* speculative, int inline_depth) {
3057   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3058   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3059   bool      xk = false;
3060   ciObject* o = NULL;
3061   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3062 }
3063 
3064 
3065 //------------------------------cast_to_ptr_type-------------------------------
3066 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3067   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3068   if( ptr == _ptr ) return this;
3069   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3070 }
3071 
3072 //-----------------------------cast_to_instance_id----------------------------
3073 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3074   // There are no instances of a general oop.
3075   // Return self unchanged.
3076   return this;
3077 }
3078 
3079 //-----------------------------cast_to_exactness-------------------------------
3080 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3081   // There is no such thing as an exact general oop.
3082   // Return self unchanged.
3083   return this;
3084 }
3085 
3086 
3087 //------------------------------as_klass_type----------------------------------
3088 // Return the klass type corresponding to this instance or array type.
3089 // It is the type that is loaded from an object of this type.
3090 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3091   ciKlass* k = klass();
3092   bool    xk = klass_is_exact();
3093   if (k == NULL)
3094     return TypeKlassPtr::OBJECT;
3095   else
3096     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3097 }
3098 
3099 //------------------------------meet-------------------------------------------
3100 // Compute the MEET of two types.  It returns a new Type object.
3101 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3102   // Perform a fast test for common case; meeting the same types together.
3103   if( this == t ) return this;  // Meeting same type-rep?
3104 
3105   // Current &quot;this-&gt;_base&quot; is OopPtr
3106   switch (t-&gt;base()) {          // switch on original type
3107 
3108   case Int:                     // Mixing ints &amp; oops happens when javac
3109   case Long:                    // reuses local variables
3110   case FloatTop:
3111   case FloatCon:
3112   case FloatBot:
3113   case DoubleTop:
3114   case DoubleCon:
3115   case DoubleBot:
3116   case NarrowOop:
3117   case NarrowKlass:
3118   case Bottom:                  // Ye Olde Default
3119     return Type::BOTTOM;
3120   case Top:
3121     return this;
3122 
3123   default:                      // All else is a mistake
3124     typerr(t);
3125 
3126   case RawPtr:
3127   case MetadataPtr:
3128   case KlassPtr:
3129     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3130 
3131   case AnyPtr: {
3132     // Found an AnyPtr type vs self-OopPtr type
3133     const TypePtr *tp = t-&gt;is_ptr();
3134     int offset = meet_offset(tp-&gt;offset());
3135     PTR ptr = meet_ptr(tp-&gt;ptr());
3136     const TypePtr* speculative = xmeet_speculative(tp);
3137     int depth = meet_inline_depth(tp-&gt;inline_depth());
3138     switch (tp-&gt;ptr()) {
3139     case Null:
3140       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3141       // else fall through:
3142     case TopPTR:
3143     case AnyNull: {
3144       int instance_id = meet_instance_id(InstanceTop);
3145       return make(ptr, offset, instance_id, speculative, depth);
3146     }
3147     case BotPTR:
3148     case NotNull:
3149       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3150     default: typerr(t);
3151     }
3152   }
3153 
3154   case OopPtr: {                 // Meeting to other OopPtrs
3155     const TypeOopPtr *tp = t-&gt;is_oopptr();
3156     int instance_id = meet_instance_id(tp-&gt;instance_id());
3157     const TypePtr* speculative = xmeet_speculative(tp);
3158     int depth = meet_inline_depth(tp-&gt;inline_depth());
3159     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3160   }
3161 
3162   case InstPtr:                  // For these, flip the call around to cut down
3163   case AryPtr:
3164     return t-&gt;xmeet(this);      // Call in reverse direction
3165 
3166   } // End of switch
3167   return this;                  // Return the double constant
3168 }
3169 
3170 
3171 //------------------------------xdual------------------------------------------
3172 // Dual of a pure heap pointer.  No relevant klass or oop information.
3173 const Type *TypeOopPtr::xdual() const {
3174   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3175   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3176   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3177 }
3178 
3179 //--------------------------make_from_klass_common-----------------------------
3180 // Computes the element-type given a klass.
3181 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3182   if (klass-&gt;is_instance_klass()) {
3183     Compile* C = Compile::current();
3184     Dependencies* deps = C-&gt;dependencies();
3185     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3186     // Element is an instance
3187     bool klass_is_exact = false;
3188     if (klass-&gt;is_loaded()) {
3189       // Try to set klass_is_exact.
3190       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3191       klass_is_exact = ik-&gt;is_final();
3192       if (!klass_is_exact &amp;&amp; klass_change
3193           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3194         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3195         if (sub != NULL) {
3196           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3197           klass = ik = sub;
3198           klass_is_exact = sub-&gt;is_final();
3199         }
3200       }
3201       if (!klass_is_exact &amp;&amp; try_for_exact
3202           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3203         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3204           // Add a dependence; if concrete subclass added we need to recompile
3205           deps-&gt;assert_leaf_type(ik);
3206           klass_is_exact = true;
3207         }
3208       }
3209     }
3210     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);
3211   } else if (klass-&gt;is_obj_array_klass()) {
3212     // Element is an object array. Recursively call ourself.
3213     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);
3214     bool xk = etype-&gt;klass_is_exact();
3215     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3216     // We used to pass NotNull in here, asserting that the sub-arrays
3217     // are all not-null.  This is not true in generally, as code can
3218     // slam NULLs down in the subarrays.
3219     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);
3220     return arr;
3221   } else if (klass-&gt;is_type_array_klass()) {
3222     // Element is an typeArray
3223     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3224     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3225     // We used to pass NotNull in here, asserting that the array pointer
3226     // is not-null. That was not true in general.
3227     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);
3228     return arr;
3229   } else {
3230     ShouldNotReachHere();
3231     return NULL;
3232   }
3233 }
3234 
3235 //------------------------------make_from_constant-----------------------------
3236 // Make a java pointer from an oop constant
3237 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3238   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3239 
3240   const bool make_constant = require_constant || o-&gt;should_be_constant();
3241 
3242   ciKlass* klass = o-&gt;klass();
3243   if (klass-&gt;is_instance_klass()) {
3244     // Element is an instance
3245     if (make_constant) {
3246       return TypeInstPtr::make(o);
3247     } else {
3248       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);
3249     }
3250   } else if (klass-&gt;is_obj_array_klass()) {
3251     // Element is an object array. Recursively call ourself.
3252     const TypeOopPtr *etype =
3253       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());
3254     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3255     // We used to pass NotNull in here, asserting that the sub-arrays
3256     // are all not-null.  This is not true in generally, as code can
3257     // slam NULLs down in the subarrays.
3258     if (make_constant) {
3259       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3260     } else {
3261       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3262     }
3263   } else if (klass-&gt;is_type_array_klass()) {
3264     // Element is an typeArray
3265     const Type* etype =
3266       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3267     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3268     // We used to pass NotNull in here, asserting that the array pointer
3269     // is not-null. That was not true in general.
3270     if (make_constant) {
3271       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3272     } else {
3273       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3274     }
3275   }
3276 
3277   fatal(&quot;unhandled object type&quot;);
3278   return NULL;
3279 }
3280 
3281 //------------------------------get_con----------------------------------------
3282 intptr_t TypeOopPtr::get_con() const {
3283   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3284   assert( _offset &gt;= 0, &quot;&quot; );
3285 
3286   if (_offset != 0) {
3287     // After being ported to the compiler interface, the compiler no longer
3288     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3289     // to a handle at compile time.  This handle is embedded in the generated
3290     // code and dereferenced at the time the nmethod is made.  Until that time,
3291     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3292     // have access to the addresses!).  This does not seem to currently happen,
3293     // but this assertion here is to help prevent its occurence.
3294     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3295     ShouldNotReachHere();
3296   }
3297 
3298   return (intptr_t)const_oop()-&gt;constant_encoding();
3299 }
3300 
3301 
3302 //-----------------------------filter------------------------------------------
3303 // Do not allow interface-vs.-noninterface joins to collapse to top.
3304 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3305 
3306   const Type* ft = join_helper(kills, include_speculative);
3307   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3308   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3309 
3310   if (ft-&gt;empty()) {
3311     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3312     // interface.  This can happen because the bytecodes do not contain
3313     // enough type info to distinguish a Java-level interface variable
3314     // from a Java-level object variable.  If we meet 2 classes which
3315     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3316     // doesn&#39;t implement I, we have no way to tell if the result should
3317     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3318     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3319     // uplift the type.
3320     if (!empty()) {
3321       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3322         return kills;           // Uplift to interface
3323       }
3324       // Also check for evil cases of &#39;this&#39; being a class array
3325       // and &#39;kills&#39; expecting an array of interfaces.
3326       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3327       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3328         return kills;           // Uplift to array of interface
3329       }
3330     }
3331 
3332     return Type::TOP;           // Canonical empty value
3333   }
3334 
3335   // If we have an interface-typed Phi or cast and we narrow to a class type,
3336   // the join should report back the class.  However, if we have a J/L/Object
3337   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3338   // join report an interface back out.  This isn&#39;t possible but happens
3339   // because the type system doesn&#39;t interact well with interfaces.
3340   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3341       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3342       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3343     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3344     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3345   }
3346 
3347   return ft;
3348 }
3349 
3350 //------------------------------eq---------------------------------------------
3351 // Structural equality check for Type representations
3352 bool TypeOopPtr::eq( const Type *t ) const {
3353   const TypeOopPtr *a = (const TypeOopPtr*)t;
3354   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3355       _instance_id != a-&gt;_instance_id)  return false;
3356   ciObject* one = const_oop();
3357   ciObject* two = a-&gt;const_oop();
3358   if (one == NULL || two == NULL) {
3359     return (one == two) &amp;&amp; TypePtr::eq(t);
3360   } else {
3361     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3362   }
3363 }
3364 
3365 //------------------------------hash-------------------------------------------
3366 // Type-specific hashing function.
3367 int TypeOopPtr::hash(void) const {
3368   return
3369     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3370              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3371 }
3372 
3373 //------------------------------dump2------------------------------------------
3374 #ifndef PRODUCT
3375 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3376   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3377   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3378   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3379   switch( _offset ) {
3380   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
3381   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
3382   case         0: break;
3383   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
3384   }
3385   if (_instance_id == InstanceTop)
3386     st-&gt;print(&quot;,iid=top&quot;);
3387   else if (_instance_id != InstanceBot)
3388     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3389 
3390   dump_inline_depth(st);
3391   dump_speculative(st);
3392 }
3393 #endif
3394 
3395 //------------------------------singleton--------------------------------------
3396 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3397 // constants
3398 bool TypeOopPtr::singleton(void) const {
3399   // detune optimizer to not generate constant oop + constant offset as a constant!
3400   // TopPTR, Null, AnyNull, Constant are all singletons
3401   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
3402 }
3403 
3404 //------------------------------add_offset-------------------------------------
3405 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3406   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3407 }
3408 
3409 /**
3410  * Return same type without a speculative part
3411  */
3412 const Type* TypeOopPtr::remove_speculative() const {
3413   if (_speculative == NULL) {
3414     return this;
3415   }
3416   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3417   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3418 }
3419 
3420 /**
3421  * Return same type but drop speculative part if we know we won&#39;t use
3422  * it
3423  */
3424 const Type* TypeOopPtr::cleanup_speculative() const {
3425   // If the klass is exact and the ptr is not null then there&#39;s
3426   // nothing that the speculative type can help us with
3427   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3428     return remove_speculative();
3429   }
3430   return TypePtr::cleanup_speculative();
3431 }
3432 
3433 /**
3434  * Return same type but with a different inline depth (used for speculation)
3435  *
3436  * @param depth  depth to meet with
3437  */
3438 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3439   if (!UseInlineDepthForSpeculativeTypes) {
3440     return this;
3441   }
3442   return make(_ptr, _offset, _instance_id, _speculative, depth);
3443 }
3444 
3445 //------------------------------with_instance_id--------------------------------
3446 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3447   assert(_instance_id != -1, &quot;should be known&quot;);
3448   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3449 }
3450 
3451 //------------------------------meet_instance_id--------------------------------
3452 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3453   // Either is &#39;TOP&#39; instance?  Return the other instance!
3454   if( _instance_id == InstanceTop ) return  instance_id;
3455   if(  instance_id == InstanceTop ) return _instance_id;
3456   // If either is different, return &#39;BOTTOM&#39; instance
3457   if( _instance_id != instance_id ) return InstanceBot;
3458   return _instance_id;
3459 }
3460 
3461 //------------------------------dual_instance_id--------------------------------
3462 int TypeOopPtr::dual_instance_id( ) const {
3463   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3464   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3465   return _instance_id;              // Map everything else into self
3466 }
3467 
3468 /**
3469  * Check whether new profiling would improve speculative type
3470  *
3471  * @param   exact_kls    class from profiling
3472  * @param   inline_depth inlining depth of profile point
3473  *
3474  * @return  true if type profile is valuable
3475  */
3476 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3477   // no way to improve an already exact type
3478   if (klass_is_exact()) {
3479     return false;
3480   }
3481   return TypePtr::would_improve_type(exact_kls, inline_depth);
3482 }
3483 
3484 //=============================================================================
3485 // Convenience common pre-built types.
3486 const TypeInstPtr *TypeInstPtr::NOTNULL;
3487 const TypeInstPtr *TypeInstPtr::BOTTOM;
3488 const TypeInstPtr *TypeInstPtr::MIRROR;
3489 const TypeInstPtr *TypeInstPtr::MARK;
3490 const TypeInstPtr *TypeInstPtr::KLASS;
3491 
3492 //------------------------------TypeInstPtr-------------------------------------
3493 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,
3494                          int instance_id, const TypePtr* speculative, int inline_depth)
3495   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),
3496     _name(k-&gt;name()) {
3497    assert(k != NULL &amp;&amp;
3498           (k-&gt;is_loaded() || o == NULL),
3499           &quot;cannot have constants with non-loaded klass&quot;);
3500 };
3501 
3502 //------------------------------make-------------------------------------------
3503 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3504                                      ciKlass* k,
3505                                      bool xk,
3506                                      ciObject* o,
3507                                      int offset,
3508                                      int instance_id,
3509                                      const TypePtr* speculative,
3510                                      int inline_depth) {
3511   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3512   // Either const_oop() is NULL or else ptr is Constant
3513   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3514           &quot;constant pointers must have a value supplied&quot; );
3515   // Ptr is never Null
3516   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3517 
3518   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3519   if (!UseExactTypes)  xk = false;
3520   if (ptr == Constant) {
3521     // Note:  This case includes meta-object constants, such as methods.
3522     xk = true;
3523   } else if (k-&gt;is_loaded()) {
3524     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3525     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3526     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3527   }
3528 
3529   // Now hash this baby
3530   TypeInstPtr *result =
3531     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3532 
3533   return result;
3534 }
3535 
3536 /**
3537  *  Create constant type for a constant boxed value
3538  */
3539 const Type* TypeInstPtr::get_const_boxed_value() const {
3540   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3541   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3542   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3543   BasicType bt = constant.basic_type();
3544   switch (bt) {
3545     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3546     case T_INT:      return TypeInt::make(constant.as_int());
3547     case T_CHAR:     return TypeInt::make(constant.as_char());
3548     case T_BYTE:     return TypeInt::make(constant.as_byte());
3549     case T_SHORT:    return TypeInt::make(constant.as_short());
3550     case T_FLOAT:    return TypeF::make(constant.as_float());
3551     case T_DOUBLE:   return TypeD::make(constant.as_double());
3552     case T_LONG:     return TypeLong::make(constant.as_long());
3553     default:         break;
3554   }
3555   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3556   return NULL;
3557 }
3558 
3559 //------------------------------cast_to_ptr_type-------------------------------
3560 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3561   if( ptr == _ptr ) return this;
3562   // Reconstruct _sig info here since not a problem with later lazy
3563   // construction, _sig will show up on demand.
3564   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3565 }
3566 
3567 
3568 //-----------------------------cast_to_exactness-------------------------------
3569 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3570   if( klass_is_exact == _klass_is_exact ) return this;
3571   if (!UseExactTypes)  return this;
3572   if (!_klass-&gt;is_loaded())  return this;
3573   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3574   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3575   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3576   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3577 }
3578 
3579 //-----------------------------cast_to_instance_id----------------------------
3580 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3581   if( instance_id == _instance_id ) return this;
3582   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3583 }
3584 
3585 //------------------------------xmeet_unloaded---------------------------------
3586 // Compute the MEET of two InstPtrs when at least one is unloaded.
3587 // Assume classes are different since called after check for same name/class-loader
3588 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3589     int off = meet_offset(tinst-&gt;offset());
3590     PTR ptr = meet_ptr(tinst-&gt;ptr());
3591     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3592     const TypePtr* speculative = xmeet_speculative(tinst);
3593     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3594 
3595     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3596     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3597     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3598       //
3599       // Meet unloaded class with java/lang/Object
3600       //
3601       // Meet
3602       //          |                     Unloaded Class
3603       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3604       //  ===================================================================
3605       //   TOP    | ..........................Unloaded......................|
3606       //  AnyNull |  U-AN    |................Unloaded......................|
3607       // Constant | ... O-NN .................................. |   O-BOT   |
3608       //  NotNull | ... O-NN .................................. |   O-BOT   |
3609       //  BOTTOM  | ........................Object-BOTTOM ..................|
3610       //
3611       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3612       //
3613       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3614       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }
3615       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3616       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3617         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3618         else                                      { return TypeInstPtr::NOTNULL; }
3619       }
3620       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3621 
3622       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3623     }
3624 
3625     // Both are unloaded, not the same class, not Object
3626     // Or meet unloaded with a different loaded class, not java/lang/Object
3627     if( ptr != TypePtr::BotPTR ) {
3628       return TypeInstPtr::NOTNULL;
3629     }
3630     return TypeInstPtr::BOTTOM;
3631 }
3632 
3633 
3634 //------------------------------meet-------------------------------------------
3635 // Compute the MEET of two types.  It returns a new Type object.
3636 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3637   // Perform a fast test for common case; meeting the same types together.
3638   if( this == t ) return this;  // Meeting same type-rep?
3639 
3640   // Current &quot;this-&gt;_base&quot; is Pointer
3641   switch (t-&gt;base()) {          // switch on original type
3642 
3643   case Int:                     // Mixing ints &amp; oops happens when javac
3644   case Long:                    // reuses local variables
3645   case FloatTop:
3646   case FloatCon:
3647   case FloatBot:
3648   case DoubleTop:
3649   case DoubleCon:
3650   case DoubleBot:
3651   case NarrowOop:
3652   case NarrowKlass:
3653   case Bottom:                  // Ye Olde Default
3654     return Type::BOTTOM;
3655   case Top:
3656     return this;
3657 
3658   default:                      // All else is a mistake
3659     typerr(t);
3660 
3661   case MetadataPtr:
3662   case KlassPtr:
3663   case RawPtr: return TypePtr::BOTTOM;
3664 
3665   case AryPtr: {                // All arrays inherit from Object class
3666     const TypeAryPtr *tp = t-&gt;is_aryptr();
3667     int offset = meet_offset(tp-&gt;offset());
3668     PTR ptr = meet_ptr(tp-&gt;ptr());
3669     int instance_id = meet_instance_id(tp-&gt;instance_id());
3670     const TypePtr* speculative = xmeet_speculative(tp);
3671     int depth = meet_inline_depth(tp-&gt;inline_depth());
3672     switch (ptr) {
3673     case TopPTR:
3674     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3675       // For instances when a subclass meets a superclass we fall
3676       // below the centerline when the superclass is exact. We need to
3677       // do the same here.
3678       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3679         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3680       } else {
3681         // cannot subclass, so the meet has to fall badly below the centerline
3682         ptr = NotNull;
3683         instance_id = InstanceBot;
3684         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3685       }
3686     case Constant:
3687     case NotNull:
3688     case BotPTR:                // Fall down to object klass
3689       // LCA is object_klass, but if we subclass from the top we can do better
3690       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3691         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3692         // then we can subclass in the Java class hierarchy.
3693         // For instances when a subclass meets a superclass we fall
3694         // below the centerline when the superclass is exact. We need
3695         // to do the same here.
3696         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3697           // that is, tp&#39;s array type is a subtype of my klass
3698           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3699                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3700         }
3701       }
3702       // The other case cannot happen, since I cannot be a subtype of an array.
3703       // The meet falls down to Object class below centerline.
3704       if( ptr == Constant )
3705          ptr = NotNull;
3706       instance_id = InstanceBot;
3707       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3708     default: typerr(t);
3709     }
3710   }
3711 
3712   case OopPtr: {                // Meeting to OopPtrs
3713     // Found a OopPtr type vs self-InstPtr type
3714     const TypeOopPtr *tp = t-&gt;is_oopptr();
3715     int offset = meet_offset(tp-&gt;offset());
3716     PTR ptr = meet_ptr(tp-&gt;ptr());
3717     switch (tp-&gt;ptr()) {
3718     case TopPTR:
3719     case AnyNull: {
3720       int instance_id = meet_instance_id(InstanceTop);
3721       const TypePtr* speculative = xmeet_speculative(tp);
3722       int depth = meet_inline_depth(tp-&gt;inline_depth());
3723       return make(ptr, klass(), klass_is_exact(),
3724                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3725     }
3726     case NotNull:
3727     case BotPTR: {
3728       int instance_id = meet_instance_id(tp-&gt;instance_id());
3729       const TypePtr* speculative = xmeet_speculative(tp);
3730       int depth = meet_inline_depth(tp-&gt;inline_depth());
3731       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3732     }
3733     default: typerr(t);
3734     }
3735   }
3736 
3737   case AnyPtr: {                // Meeting to AnyPtrs
3738     // Found an AnyPtr type vs self-InstPtr type
3739     const TypePtr *tp = t-&gt;is_ptr();
3740     int offset = meet_offset(tp-&gt;offset());
3741     PTR ptr = meet_ptr(tp-&gt;ptr());
3742     int instance_id = meet_instance_id(InstanceTop);
3743     const TypePtr* speculative = xmeet_speculative(tp);
3744     int depth = meet_inline_depth(tp-&gt;inline_depth());
3745     switch (tp-&gt;ptr()) {
3746     case Null:
3747       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3748       // else fall through to AnyNull
3749     case TopPTR:
3750     case AnyNull: {
3751       return make(ptr, klass(), klass_is_exact(),
3752                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3753     }
3754     case NotNull:
3755     case BotPTR:
3756       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3757     default: typerr(t);
3758     }
3759   }
3760 
3761   /*
3762                  A-top         }
3763                /   |   \       }  Tops
3764            B-top A-any C-top   }
3765               | /  |  \ |      }  Any-nulls
3766            B-any   |   C-any   }
3767               |    |    |
3768            B-con A-con C-con   } constants; not comparable across classes
3769               |    |    |
3770            B-not   |   C-not   }
3771               | \  |  / |      }  not-nulls
3772            B-bot A-not C-bot   }
3773                \   |   /       }  Bottoms
3774                  A-bot         }
3775   */
3776 
3777   case InstPtr: {                // Meeting 2 Oops?
3778     // Found an InstPtr sub-type vs self-InstPtr type
3779     const TypeInstPtr *tinst = t-&gt;is_instptr();
3780     int off = meet_offset( tinst-&gt;offset() );
3781     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3782     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3783     const TypePtr* speculative = xmeet_speculative(tinst);
3784     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3785 
3786     // Check for easy case; klasses are equal (and perhaps not loaded!)
3787     // If we have constants, then we created oops so classes are loaded
3788     // and we can handle the constants further down.  This case handles
3789     // both-not-loaded or both-loaded classes
3790     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {
3791       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);
3792     }
3793 
3794     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3795     ciKlass* tinst_klass = tinst-&gt;klass();
3796     ciKlass* this_klass  = this-&gt;klass();
3797     bool tinst_xk = tinst-&gt;klass_is_exact();
3798     bool this_xk  = this-&gt;klass_is_exact();
3799     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3800       // One of these classes has not been loaded
3801       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3802 #ifndef PRODUCT
3803       if( PrintOpto &amp;&amp; Verbose ) {
3804         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3805         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3806         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3807       }
3808 #endif
3809       return unloaded_meet;
3810     }
3811 
3812     // Handle mixing oops and interfaces first.
3813     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3814                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3815       ciKlass *tmp = tinst_klass; // Swap interface around
3816       tinst_klass = this_klass;
3817       this_klass = tmp;
3818       bool tmp2 = tinst_xk;
3819       tinst_xk = this_xk;
3820       this_xk = tmp2;
3821     }
3822     if (tinst_klass-&gt;is_interface() &amp;&amp;
3823         !(this_klass-&gt;is_interface() ||
3824           // Treat java/lang/Object as an honorary interface,
3825           // because we need a bottom for the interface hierarchy.
3826           this_klass == ciEnv::current()-&gt;Object_klass())) {
3827       // Oop meets interface!
3828 
3829       // See if the oop subtypes (implements) interface.
3830       ciKlass *k;
3831       bool xk;
3832       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3833         // Oop indeed subtypes.  Now keep oop or interface depending
3834         // on whether we are both above the centerline or either is
3835         // below the centerline.  If we are on the centerline
3836         // (e.g., Constant vs. AnyNull interface), use the constant.
3837         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3838         // If we are keeping this_klass, keep its exactness too.
3839         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
3840       } else {                  // Does not implement, fall to Object
3841         // Oop does not implement interface, so mixing falls to Object
3842         // just like the verifier does (if both are above the
3843         // centerline fall to interface)
3844         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3845         xk = above_centerline(ptr) ? tinst_xk : false;
3846         // Watch out for Constant vs. AnyNull interface.
3847         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3848         instance_id = InstanceBot;
3849       }
3850       ciObject* o = NULL;  // the Constant value, if any
3851       if (ptr == Constant) {
3852         // Find out which constant.
3853         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3854       }
3855       return make(ptr, k, xk, o, off, instance_id, speculative, depth);
3856     }
3857 
3858     // Either oop vs oop or interface vs interface or interface vs Object
3859 
3860     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3861     // If we split one up &amp; one down AND they subtype, take the down man.
3862     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3863     // If both are up and they subtype, take the subtype class.
3864     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3865     // If both are down and they subtype, take the supertype class.
3866     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3867     // Constants treated as down.
3868 
3869     // Now, reorder the above list; observe that both-down+subtype is also
3870     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3871     // If we split one up &amp; one down AND they subtype, take the down man.
3872     // If both are up and they subtype, take the subtype class.
3873 
3874     // If both are down and they subtype, &quot;fall hard&quot;.
3875     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3876     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3877     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3878 
3879     // If a proper subtype is exact, and we return it, we return it exactly.
3880     // If a proper supertype is exact, there can be no subtyping relationship!
3881     // If both types are equal to the subtype, exactness is and-ed below the
3882     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3883 
3884     // Check for subtyping:
3885     ciKlass *subtype = NULL;
3886     bool subtype_exact = false;
3887     if( tinst_klass-&gt;equals(this_klass) ) {
3888       subtype = this_klass;
3889       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
3890     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3891       subtype = this_klass;     // Pick subtyping class
3892       subtype_exact = this_xk;
3893     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3894       subtype = tinst_klass;    // Pick subtyping class
3895       subtype_exact = tinst_xk;
3896     }
3897 
3898     if( subtype ) {
3899       if( above_centerline(ptr) ) { // both are up?
3900         this_klass = tinst_klass = subtype;
3901         this_xk = tinst_xk = subtype_exact;
3902       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3903         this_klass = tinst_klass; // tinst is down; keep down man
3904         this_xk = tinst_xk;
3905       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3906         tinst_klass = this_klass; // this is down; keep down man
3907         tinst_xk = this_xk;
3908       } else {
3909         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
3910       }
3911     }
3912 
3913     // Check for classes now being equal
3914     if (tinst_klass-&gt;equals(this_klass)) {
3915       // If the klasses are equal, the constants may still differ.  Fall to
3916       // NotNull if they do (neither constant is NULL; that is a special case
3917       // handled elsewhere).
3918       ciObject* o = NULL;             // Assume not constant when done
3919       ciObject* this_oop  = const_oop();
3920       ciObject* tinst_oop = tinst-&gt;const_oop();
3921       if( ptr == Constant ) {
3922         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3923             this_oop-&gt;equals(tinst_oop) )
3924           o = this_oop;
3925         else if (above_centerline(this -&gt;_ptr))
3926           o = tinst_oop;
3927         else if (above_centerline(tinst -&gt;_ptr))
3928           o = this_oop;
3929         else
3930           ptr = NotNull;
3931       }
3932       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);
3933     } // Else classes are not equal
3934 
3935     // Since klasses are different, we require a LCA in the Java
3936     // class hierarchy - which means we have to fall to at least NotNull.
3937     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3938       ptr = NotNull;
3939 
3940     instance_id = InstanceBot;
3941 
3942     // Now we find the LCA of Java classes
3943     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
3944     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);
3945   } // End of case InstPtr
3946 
3947   } // End of switch
3948   return this;                  // Return the double constant
3949 }
3950 
3951 
3952 //------------------------java_mirror_type--------------------------------------
3953 ciType* TypeInstPtr::java_mirror_type() const {
3954   // must be a singleton type
3955   if( const_oop() == NULL )  return NULL;
3956 
3957   // must be of type java.lang.Class
3958   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
3959 
3960   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3961 }
3962 
3963 
3964 //------------------------------xdual------------------------------------------
3965 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3966 // inheritance mechanism.
3967 const Type *TypeInstPtr::xdual() const {
3968   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3969 }
3970 
3971 //------------------------------eq---------------------------------------------
3972 // Structural equality check for Type representations
3973 bool TypeInstPtr::eq( const Type *t ) const {
3974   const TypeInstPtr *p = t-&gt;is_instptr();
3975   return
3976     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
3977     TypeOopPtr::eq(p);          // Check sub-type stuff
3978 }
3979 
3980 //------------------------------hash-------------------------------------------
3981 // Type-specific hashing function.
3982 int TypeInstPtr::hash(void) const {
3983   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());
3984   return hash;
3985 }
3986 
3987 //------------------------------dump2------------------------------------------
3988 // Dump oop Type
3989 #ifndef PRODUCT
3990 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3991   // Print the name of the klass.
3992   klass()-&gt;print_name_on(st);
3993 
3994   switch( _ptr ) {
3995   case Constant:
3996     // TO DO: Make CI print the hex address of the underlying oop.
3997     if (WizardMode || Verbose) {
3998       const_oop()-&gt;print_oop(st);
3999     }
4000   case BotPTR:
4001     if (!WizardMode &amp;&amp; !Verbose) {
4002       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4003       break;
4004     }
4005   case TopPTR:
4006   case AnyNull:
4007   case NotNull:
4008     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4009     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4010     break;
4011   default:
4012     break;
4013   }
4014 
4015   if( _offset ) {               // Dump offset, if any
4016     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);
4017     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);
4018     else st-&gt;print(&quot;+%d&quot;, _offset);
4019   }
4020 
4021   st-&gt;print(&quot; *&quot;);
4022   if (_instance_id == InstanceTop)
4023     st-&gt;print(&quot;,iid=top&quot;);
4024   else if (_instance_id != InstanceBot)
4025     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4026 
4027   dump_inline_depth(st);
4028   dump_speculative(st);
4029 }
4030 #endif
4031 
4032 //------------------------------add_offset-------------------------------------
4033 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4034   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),
4035               _instance_id, add_offset_speculative(offset), _inline_depth);
4036 }
4037 
4038 const Type *TypeInstPtr::remove_speculative() const {
4039   if (_speculative == NULL) {
4040     return this;
4041   }
4042   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4043   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,
4044               _instance_id, NULL, _inline_depth);
4045 }
4046 
4047 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4048   if (!UseInlineDepthForSpeculativeTypes) {
4049     return this;
4050   }
4051   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);
4052 }
4053 
4054 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4055   assert(is_known_instance(), &quot;should be known&quot;);
4056   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);
4057 }
4058 
4059 //=============================================================================
4060 // Convenience common pre-built types.
4061 const TypeAryPtr *TypeAryPtr::RANGE;
4062 const TypeAryPtr *TypeAryPtr::OOPS;
4063 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4064 const TypeAryPtr *TypeAryPtr::BYTES;
4065 const TypeAryPtr *TypeAryPtr::SHORTS;
4066 const TypeAryPtr *TypeAryPtr::CHARS;
4067 const TypeAryPtr *TypeAryPtr::INTS;
4068 const TypeAryPtr *TypeAryPtr::LONGS;
4069 const TypeAryPtr *TypeAryPtr::FLOATS;
4070 const TypeAryPtr *TypeAryPtr::DOUBLES;
4071 
4072 //------------------------------make-------------------------------------------
4073 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4074                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4075   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4076          &quot;integral arrays must be pre-equipped with a class&quot;);
4077   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4078   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4079   if (!UseExactTypes)  xk = (ptr == Constant);
4080   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4081 }
4082 
4083 //------------------------------make-------------------------------------------
4084 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4085                                    int instance_id, const TypePtr* speculative, int inline_depth,
4086                                    bool is_autobox_cache) {
4087   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4088          &quot;integral arrays must be pre-equipped with a class&quot;);
4089   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4090   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4091   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4092   if (!UseExactTypes)  xk = (ptr == Constant);
4093   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4094 }
4095 
4096 //------------------------------cast_to_ptr_type-------------------------------
4097 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4098   if( ptr == _ptr ) return this;
4099   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4100 }
4101 
4102 
4103 //-----------------------------cast_to_exactness-------------------------------
4104 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4105   if( klass_is_exact == _klass_is_exact ) return this;
4106   if (!UseExactTypes)  return this;
4107   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4108   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4109 }
4110 
4111 //-----------------------------cast_to_instance_id----------------------------
4112 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4113   if( instance_id == _instance_id ) return this;
4114   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4115 }
4116 
4117 
4118 //-----------------------------max_array_length-------------------------------
4119 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4120 jint TypeAryPtr::max_array_length(BasicType etype) {
4121   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4122     if (etype == T_NARROWOOP) {
4123       etype = T_OBJECT;
4124     } else if (etype == T_ILLEGAL) { // bottom[]
4125       etype = T_BYTE; // will produce conservatively high value
4126     } else {
4127       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4128     }
4129   }
4130   return arrayOopDesc::max_array_length(etype);
4131 }
4132 
4133 //-----------------------------narrow_size_type-------------------------------
4134 // Narrow the given size type to the index range for the given array base type.
4135 // Return NULL if the resulting int type becomes empty.
4136 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4137   jint hi = size-&gt;_hi;
4138   jint lo = size-&gt;_lo;
4139   jint min_lo = 0;
4140   jint max_hi = max_array_length(elem()-&gt;basic_type());
4141   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4142   bool chg = false;
4143   if (lo &lt; min_lo) {
4144     lo = min_lo;
4145     if (size-&gt;is_con()) {
4146       hi = lo;
4147     }
4148     chg = true;
4149   }
4150   if (hi &gt; max_hi) {
4151     hi = max_hi;
4152     if (size-&gt;is_con()) {
4153       lo = hi;
4154     }
4155     chg = true;
4156   }
4157   // Negative length arrays will produce weird intermediate dead fast-path code
4158   if (lo &gt; hi)
4159     return TypeInt::ZERO;
4160   if (!chg)
4161     return size;
4162   return TypeInt::make(lo, hi, Type::WidenMin);
4163 }
4164 
4165 //-------------------------------cast_to_size----------------------------------
4166 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4167   assert(new_size != NULL, &quot;&quot;);
4168   new_size = narrow_size_type(new_size);
4169   if (new_size == size())  return this;
4170   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());
4171   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4172 }
4173 
4174 //------------------------------cast_to_stable---------------------------------
4175 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4176   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4177     return this;
4178 
4179   const Type* elem = this-&gt;elem();
4180   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4181 
4182   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4183     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4184     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4185   }
4186 
4187   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);
4188 
4189   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4190 }
4191 
4192 //-----------------------------stable_dimension--------------------------------
4193 int TypeAryPtr::stable_dimension() const {
4194   if (!is_stable())  return 0;
4195   int dim = 1;
4196   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4197   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4198     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4199   return dim;
4200 }
4201 
4202 //----------------------cast_to_autobox_cache-----------------------------------
4203 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4204   if (is_autobox_cache() == cache)  return this;
4205   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4206   if (etype == NULL)  return this;
4207   // The pointers in the autobox arrays are always non-null.
4208   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4209   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4210   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());
4211   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);
4212 }
4213 
4214 //------------------------------eq---------------------------------------------
4215 // Structural equality check for Type representations
4216 bool TypeAryPtr::eq( const Type *t ) const {
4217   const TypeAryPtr *p = t-&gt;is_aryptr();
4218   return
4219     _ary == p-&gt;_ary &amp;&amp;  // Check array
4220     TypeOopPtr::eq(p);  // Check sub-parts
4221 }
4222 
4223 //------------------------------hash-------------------------------------------
4224 // Type-specific hashing function.
4225 int TypeAryPtr::hash(void) const {
4226   return (intptr_t)_ary + TypeOopPtr::hash();
4227 }
4228 
4229 //------------------------------meet-------------------------------------------
4230 // Compute the MEET of two types.  It returns a new Type object.
4231 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4232   // Perform a fast test for common case; meeting the same types together.
4233   if( this == t ) return this;  // Meeting same type-rep?
4234   // Current &quot;this-&gt;_base&quot; is Pointer
4235   switch (t-&gt;base()) {          // switch on original type
4236 
4237   // Mixing ints &amp; oops happens when javac reuses local variables
4238   case Int:
4239   case Long:
4240   case FloatTop:
4241   case FloatCon:
4242   case FloatBot:
4243   case DoubleTop:
4244   case DoubleCon:
4245   case DoubleBot:
4246   case NarrowOop:
4247   case NarrowKlass:
4248   case Bottom:                  // Ye Olde Default
4249     return Type::BOTTOM;
4250   case Top:
4251     return this;
4252 
4253   default:                      // All else is a mistake
4254     typerr(t);
4255 
4256   case OopPtr: {                // Meeting to OopPtrs
4257     // Found a OopPtr type vs self-AryPtr type
4258     const TypeOopPtr *tp = t-&gt;is_oopptr();
4259     int offset = meet_offset(tp-&gt;offset());
4260     PTR ptr = meet_ptr(tp-&gt;ptr());
4261     int depth = meet_inline_depth(tp-&gt;inline_depth());
4262     const TypePtr* speculative = xmeet_speculative(tp);
4263     switch (tp-&gt;ptr()) {
4264     case TopPTR:
4265     case AnyNull: {
4266       int instance_id = meet_instance_id(InstanceTop);
4267       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4268                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4269     }
4270     case BotPTR:
4271     case NotNull: {
4272       int instance_id = meet_instance_id(tp-&gt;instance_id());
4273       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4274     }
4275     default: ShouldNotReachHere();
4276     }
4277   }
4278 
4279   case AnyPtr: {                // Meeting two AnyPtrs
4280     // Found an AnyPtr type vs self-AryPtr type
4281     const TypePtr *tp = t-&gt;is_ptr();
4282     int offset = meet_offset(tp-&gt;offset());
4283     PTR ptr = meet_ptr(tp-&gt;ptr());
4284     const TypePtr* speculative = xmeet_speculative(tp);
4285     int depth = meet_inline_depth(tp-&gt;inline_depth());
4286     switch (tp-&gt;ptr()) {
4287     case TopPTR:
4288       return this;
4289     case BotPTR:
4290     case NotNull:
4291       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4292     case Null:
4293       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4294       // else fall through to AnyNull
4295     case AnyNull: {
4296       int instance_id = meet_instance_id(InstanceTop);
4297       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4298                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4299     }
4300     default: ShouldNotReachHere();
4301     }
4302   }
4303 
4304   case MetadataPtr:
4305   case KlassPtr:
4306   case RawPtr: return TypePtr::BOTTOM;
4307 
4308   case AryPtr: {                // Meeting 2 references?
4309     const TypeAryPtr *tap = t-&gt;is_aryptr();
4310     int off = meet_offset(tap-&gt;offset());
4311     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4312     PTR ptr = meet_ptr(tap-&gt;ptr());
4313     int instance_id = meet_instance_id(tap-&gt;instance_id());
4314     const TypePtr* speculative = xmeet_speculative(tap);
4315     int depth = meet_inline_depth(tap-&gt;inline_depth());
4316     ciKlass* lazy_klass = NULL;
4317     if (tary-&gt;_elem-&gt;isa_int()) {
4318       // Integral array element types have irrelevant lattice relations.
4319       // It is the klass that determines array layout, not the element type.
4320       if (_klass == NULL)
4321         lazy_klass = tap-&gt;_klass;
4322       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4323         lazy_klass = _klass;
4324       } else {
4325         // Something like byte[int+] meets char[int+].
4326         // This must fall to bottom, not (int[-128..65535])[int+].
4327         instance_id = InstanceBot;
4328         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4329       }
4330     } else // Non integral arrays.
4331       // Must fall to bottom if exact klasses in upper lattice
4332       // are not equal or super klass is exact.
4333       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4334           // meet with top[] and bottom[] are processed further down:
4335           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;
4336           // both are exact and not equal:
4337           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4338            // &#39;tap&#39;  is exact and super or unrelated:
4339            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4340            // &#39;this&#39; is exact and super or unrelated:
4341            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4342       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4343         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4344       }
4345       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4346     }
4347 
4348     bool xk = false;
4349     switch (tap-&gt;ptr()) {
4350     case AnyNull:
4351     case TopPTR:
4352       // Compute new klass on demand, do not use tap-&gt;_klass
4353       if (below_centerline(this-&gt;_ptr)) {
4354         xk = this-&gt;_klass_is_exact;
4355       } else {
4356         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4357       }
4358       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4359     case Constant: {
4360       ciObject* o = const_oop();
4361       if( _ptr == Constant ) {
4362         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4363           xk = (klass() == tap-&gt;klass());
4364           ptr = NotNull;
4365           o = NULL;
4366           instance_id = InstanceBot;
4367         } else {
4368           xk = true;
4369         }
4370       } else if(above_centerline(_ptr)) {
4371         o = tap-&gt;const_oop();
4372         xk = true;
4373       } else {
4374         // Only precise for identical arrays
4375         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4376       }
4377       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4378     }
4379     case NotNull:
4380     case BotPTR:
4381       // Compute new klass on demand, do not use tap-&gt;_klass
4382       if (above_centerline(this-&gt;_ptr))
4383             xk = tap-&gt;_klass_is_exact;
4384       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4385               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4386       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4387     default: ShouldNotReachHere();
4388     }
4389   }
4390 
4391   // All arrays inherit from Object class
4392   case InstPtr: {
4393     const TypeInstPtr *tp = t-&gt;is_instptr();
4394     int offset = meet_offset(tp-&gt;offset());
4395     PTR ptr = meet_ptr(tp-&gt;ptr());
4396     int instance_id = meet_instance_id(tp-&gt;instance_id());
4397     const TypePtr* speculative = xmeet_speculative(tp);
4398     int depth = meet_inline_depth(tp-&gt;inline_depth());
4399     switch (ptr) {
4400     case TopPTR:
4401     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4402       // For instances when a subclass meets a superclass we fall
4403       // below the centerline when the superclass is exact. We need to
4404       // do the same here.
4405       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4406         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4407       } else {
4408         // cannot subclass, so the meet has to fall badly below the centerline
4409         ptr = NotNull;
4410         instance_id = InstanceBot;
4411         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4412       }
4413     case Constant:
4414     case NotNull:
4415     case BotPTR:                // Fall down to object klass
4416       // LCA is object_klass, but if we subclass from the top we can do better
4417       if (above_centerline(tp-&gt;ptr())) {
4418         // If &#39;tp&#39;  is above the centerline and it is Object class
4419         // then we can subclass in the Java class hierarchy.
4420         // For instances when a subclass meets a superclass we fall
4421         // below the centerline when the superclass is exact. We need
4422         // to do the same here.
4423         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4424           // that is, my array type is a subtype of &#39;tp&#39; klass
4425           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4426                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4427         }
4428       }
4429       // The other case cannot happen, since t cannot be a subtype of an array.
4430       // The meet falls down to Object class below centerline.
4431       if( ptr == Constant )
4432          ptr = NotNull;
4433       instance_id = InstanceBot;
4434       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4435     default: typerr(t);
4436     }
4437   }
4438   }
4439   return this;                  // Lint noise
4440 }
4441 
4442 //------------------------------xdual------------------------------------------
4443 // Dual: compute field-by-field dual
4444 const Type *TypeAryPtr::xdual() const {
4445   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4446 }
4447 
4448 //----------------------interface_vs_oop---------------------------------------
4449 #ifdef ASSERT
4450 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4451   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4452   if (t_aryptr) {
4453     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4454   }
4455   return false;
4456 }
4457 #endif
4458 
4459 //------------------------------dump2------------------------------------------
4460 #ifndef PRODUCT
4461 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4462   _ary-&gt;dump2(d,depth,st);
4463   switch( _ptr ) {
4464   case Constant:
4465     const_oop()-&gt;print(st);
4466     break;
4467   case BotPTR:
4468     if (!WizardMode &amp;&amp; !Verbose) {
4469       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4470       break;
4471     }
4472   case TopPTR:
4473   case AnyNull:
4474   case NotNull:
4475     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4476     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4477     break;
4478   default:
4479     break;
4480   }
4481 
4482   if( _offset != 0 ) {
4483     int header_size = objArrayOopDesc::header_size() * wordSize;
4484     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);
4485     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);
4486     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);
4487     else {
4488       BasicType basic_elem_type = elem()-&gt;basic_type();
4489       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4490       int elem_size = type2aelembytes(basic_elem_type);
4491       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);
4492     }
4493   }
4494   st-&gt;print(&quot; *&quot;);
4495   if (_instance_id == InstanceTop)
4496     st-&gt;print(&quot;,iid=top&quot;);
4497   else if (_instance_id != InstanceBot)
4498     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4499 
4500   dump_inline_depth(st);
4501   dump_speculative(st);
4502 }
4503 #endif
4504 
4505 bool TypeAryPtr::empty(void) const {
4506   if (_ary-&gt;empty())       return true;
4507   return TypeOopPtr::empty();
4508 }
4509 
4510 //------------------------------add_offset-------------------------------------
4511 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4512   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
4513 }
4514 
4515 const Type *TypeAryPtr::remove_speculative() const {
4516   if (_speculative == NULL) {
4517     return this;
4518   }
4519   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4520   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);
4521 }
4522 
4523 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4524   if (!UseInlineDepthForSpeculativeTypes) {
4525     return this;
4526   }
4527   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);
4528 }
4529 
4530 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4531   assert(is_known_instance(), &quot;should be known&quot;);
4532   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4533 }
4534 
4535 //=============================================================================
4536 
4537 //------------------------------hash-------------------------------------------
4538 // Type-specific hashing function.
4539 int TypeNarrowPtr::hash(void) const {
4540   return _ptrtype-&gt;hash() + 7;
4541 }
4542 
4543 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4544   return _ptrtype-&gt;singleton();
4545 }
4546 
4547 bool TypeNarrowPtr::empty(void) const {
4548   return _ptrtype-&gt;empty();
4549 }
4550 
4551 intptr_t TypeNarrowPtr::get_con() const {
4552   return _ptrtype-&gt;get_con();
4553 }
4554 
4555 bool TypeNarrowPtr::eq( const Type *t ) const {
4556   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
4557   if (tc != NULL) {
4558     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
4559       return false;
4560     }
4561     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
4562   }
4563   return false;
4564 }
4565 
4566 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
4567   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
4568   return make_same_narrowptr(odual);
4569 }
4570 
4571 
4572 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
4573   if (isa_same_narrowptr(kills)) {
4574     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
4575     if (ft-&gt;empty())
4576       return Type::TOP;           // Canonical empty value
4577     if (ft-&gt;isa_ptr()) {
4578       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
4579     }
4580     return ft;
4581   } else if (kills-&gt;isa_ptr()) {
4582     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
4583     if (ft-&gt;empty())
4584       return Type::TOP;           // Canonical empty value
4585     return ft;
4586   } else {
4587     return Type::TOP;
4588   }
4589 }
4590 
4591 //------------------------------xmeet------------------------------------------
4592 // Compute the MEET of two types.  It returns a new Type object.
4593 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
4594   // Perform a fast test for common case; meeting the same types together.
4595   if( this == t ) return this;  // Meeting same type-rep?
4596 
4597   if (t-&gt;base() == base()) {
4598     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
4599     if (result-&gt;isa_ptr()) {
4600       return make_hash_same_narrowptr(result-&gt;is_ptr());
4601     }
4602     return result;
4603   }
4604 
4605   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4606   switch (t-&gt;base()) {          // switch on original type
4607 
4608   case Int:                     // Mixing ints &amp; oops happens when javac
4609   case Long:                    // reuses local variables
4610   case FloatTop:
4611   case FloatCon:
4612   case FloatBot:
4613   case DoubleTop:
4614   case DoubleCon:
4615   case DoubleBot:
4616   case AnyPtr:
4617   case RawPtr:
4618   case OopPtr:
4619   case InstPtr:
4620   case AryPtr:
4621   case MetadataPtr:
4622   case KlassPtr:
4623   case NarrowOop:
4624   case NarrowKlass:
4625 
4626   case Bottom:                  // Ye Olde Default
4627     return Type::BOTTOM;
4628   case Top:
4629     return this;
4630 
4631   default:                      // All else is a mistake
4632     typerr(t);
4633 
4634   } // End of switch
4635 
4636   return this;
4637 }
4638 
4639 #ifndef PRODUCT
4640 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4641   _ptrtype-&gt;dump2(d, depth, st);
4642 }
4643 #endif
4644 
4645 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4646 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4647 
4648 
4649 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4650   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
4651 }
4652 
4653 const Type* TypeNarrowOop::remove_speculative() const {
4654   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
4655 }
4656 
4657 const Type* TypeNarrowOop::cleanup_speculative() const {
4658   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
4659 }
4660 
4661 #ifndef PRODUCT
4662 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4663   st-&gt;print(&quot;narrowoop: &quot;);
4664   TypeNarrowPtr::dump2(d, depth, st);
4665 }
4666 #endif
4667 
4668 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
4669 
4670 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
4671   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
4672 }
4673 
4674 #ifndef PRODUCT
4675 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4676   st-&gt;print(&quot;narrowklass: &quot;);
4677   TypeNarrowPtr::dump2(d, depth, st);
4678 }
4679 #endif
4680 
4681 
4682 //------------------------------eq---------------------------------------------
4683 // Structural equality check for Type representations
4684 bool TypeMetadataPtr::eq( const Type *t ) const {
4685   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
4686   ciMetadata* one = metadata();
4687   ciMetadata* two = a-&gt;metadata();
4688   if (one == NULL || two == NULL) {
4689     return (one == two) &amp;&amp; TypePtr::eq(t);
4690   } else {
4691     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4692   }
4693 }
4694 
4695 //------------------------------hash-------------------------------------------
4696 // Type-specific hashing function.
4697 int TypeMetadataPtr::hash(void) const {
4698   return
4699     (metadata() ? metadata()-&gt;hash() : 0) +
4700     TypePtr::hash();
4701 }
4702 
4703 //------------------------------singleton--------------------------------------
4704 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4705 // constants
4706 bool TypeMetadataPtr::singleton(void) const {
4707   // detune optimizer to not generate constant metadata + constant offset as a constant!
4708   // TopPTR, Null, AnyNull, Constant are all singletons
4709   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4710 }
4711 
4712 //------------------------------add_offset-------------------------------------
4713 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4714   return make( _ptr, _metadata, xadd_offset(offset));
4715 }
4716 
4717 //-----------------------------filter------------------------------------------
4718 // Do not allow interface-vs.-noninterface joins to collapse to top.
4719 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4720   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4721   if (ft == NULL || ft-&gt;empty())
4722     return Type::TOP;           // Canonical empty value
4723   return ft;
4724 }
4725 
4726  //------------------------------get_con----------------------------------------
4727 intptr_t TypeMetadataPtr::get_con() const {
4728   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
4729   assert( _offset &gt;= 0, &quot;&quot; );
4730 
4731   if (_offset != 0) {
4732     // After being ported to the compiler interface, the compiler no longer
4733     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4734     // to a handle at compile time.  This handle is embedded in the generated
4735     // code and dereferenced at the time the nmethod is made.  Until that time,
4736     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4737     // have access to the addresses!).  This does not seem to currently happen,
4738     // but this assertion here is to help prevent its occurence.
4739     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4740     ShouldNotReachHere();
4741   }
4742 
4743   return (intptr_t)metadata()-&gt;constant_encoding();
4744 }
4745 
4746 //------------------------------cast_to_ptr_type-------------------------------
4747 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4748   if( ptr == _ptr ) return this;
4749   return make(ptr, metadata(), _offset);
4750 }
4751 
4752 //------------------------------meet-------------------------------------------
4753 // Compute the MEET of two types.  It returns a new Type object.
4754 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
4755   // Perform a fast test for common case; meeting the same types together.
4756   if( this == t ) return this;  // Meeting same type-rep?
4757 
4758   // Current &quot;this-&gt;_base&quot; is OopPtr
4759   switch (t-&gt;base()) {          // switch on original type
4760 
4761   case Int:                     // Mixing ints &amp; oops happens when javac
4762   case Long:                    // reuses local variables
4763   case FloatTop:
4764   case FloatCon:
4765   case FloatBot:
4766   case DoubleTop:
4767   case DoubleCon:
4768   case DoubleBot:
4769   case NarrowOop:
4770   case NarrowKlass:
4771   case Bottom:                  // Ye Olde Default
4772     return Type::BOTTOM;
4773   case Top:
4774     return this;
4775 
4776   default:                      // All else is a mistake
4777     typerr(t);
4778 
4779   case AnyPtr: {
4780     // Found an AnyPtr type vs self-OopPtr type
4781     const TypePtr *tp = t-&gt;is_ptr();
4782     int offset = meet_offset(tp-&gt;offset());
4783     PTR ptr = meet_ptr(tp-&gt;ptr());
4784     switch (tp-&gt;ptr()) {
4785     case Null:
4786       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4787       // else fall through:
4788     case TopPTR:
4789     case AnyNull: {
4790       return make(ptr, _metadata, offset);
4791     }
4792     case BotPTR:
4793     case NotNull:
4794       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4795     default: typerr(t);
4796     }
4797   }
4798 
4799   case RawPtr:
4800   case KlassPtr:
4801   case OopPtr:
4802   case InstPtr:
4803   case AryPtr:
4804     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4805 
4806   case MetadataPtr: {
4807     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
4808     int offset = meet_offset(tp-&gt;offset());
4809     PTR tptr = tp-&gt;ptr();
4810     PTR ptr = meet_ptr(tptr);
4811     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4812     if (tptr == TopPTR || _ptr == TopPTR ||
4813         metadata()-&gt;equals(tp-&gt;metadata())) {
4814       return make(ptr, md, offset);
4815     }
4816     // metadata is different
4817     if( ptr == Constant ) {  // Cannot be equal constants, so...
4818       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4819       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4820       ptr = NotNull;            // Fall down in lattice
4821     }
4822     return make(ptr, NULL, offset);
4823     break;
4824   }
4825   } // End of switch
4826   return this;                  // Return the double constant
4827 }
4828 
4829 
4830 //------------------------------xdual------------------------------------------
4831 // Dual of a pure metadata pointer.
4832 const Type *TypeMetadataPtr::xdual() const {
4833   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4834 }
4835 
4836 //------------------------------dump2------------------------------------------
4837 #ifndef PRODUCT
4838 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4839   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4840   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
4841   switch( _offset ) {
4842   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4843   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4844   case         0: break;
4845   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
4846   }
4847 }
4848 #endif
4849 
4850 
4851 //=============================================================================
4852 // Convenience common pre-built type.
4853 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4854 
4855 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):
4856   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4857 }
4858 
4859 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
4860   return make(Constant, m, 0);
4861 }
4862 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
4863   return make(Constant, m, 0);
4864 }
4865 
4866 //------------------------------make-------------------------------------------
4867 // Create a meta data constant
4868 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {
4869   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4870   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4871 }
4872 
4873 
4874 //=============================================================================
4875 // Convenience common pre-built types.
4876 
4877 // Not-null object klass or below
4878 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4879 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4880 
4881 //------------------------------TypeKlassPtr-----------------------------------
4882 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )
4883   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {
4884 }
4885 
4886 //------------------------------make-------------------------------------------
4887 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
4888 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {
4889   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);
4890   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
4891   TypeKlassPtr *r =
4892     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();
4893 
4894   return r;
4895 }
4896 
4897 //------------------------------eq---------------------------------------------
4898 // Structural equality check for Type representations
4899 bool TypeKlassPtr::eq( const Type *t ) const {
4900   const TypeKlassPtr *p = t-&gt;is_klassptr();
4901   return
4902     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4903     TypePtr::eq(p);
4904 }
4905 
4906 //------------------------------hash-------------------------------------------
4907 // Type-specific hashing function.
4908 int TypeKlassPtr::hash(void) const {
4909   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());
4910 }
4911 
4912 //------------------------------singleton--------------------------------------
4913 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4914 // constants
4915 bool TypeKlassPtr::singleton(void) const {
4916   // detune optimizer to not generate constant klass + constant offset as a constant!
4917   // TopPTR, Null, AnyNull, Constant are all singletons
4918   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4919 }
4920 
4921 // Do not allow interface-vs.-noninterface joins to collapse to top.
4922 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4923   // logic here mirrors the one from TypeOopPtr::filter. See comments
4924   // there.
4925   const Type* ft = join_helper(kills, include_speculative);
4926   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4927   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4928 
4929   if (ft-&gt;empty()) {
4930     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
4931       return kills;             // Uplift to interface
4932 
4933     return Type::TOP;           // Canonical empty value
4934   }
4935 
4936   // Interface klass type could be exact in opposite to interface type,
4937   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4938   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4939       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4940       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4941       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4942     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4943   }
4944 
4945   return ft;
4946 }
4947 
4948 //----------------------compute_klass------------------------------------------
4949 // Compute the defining klass for this class
4950 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4951   // Compute _klass based on element type.
4952   ciKlass* k_ary = NULL;
4953   const TypeInstPtr *tinst;
4954   const TypeAryPtr *tary;
4955   const Type* el = elem();
4956   if (el-&gt;isa_narrowoop()) {
4957     el = el-&gt;make_ptr();
4958   }
4959 
4960   // Get element klass
4961   if ((tinst = el-&gt;isa_instptr()) != NULL) {
4962     // Compute array klass from element klass
4963     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());
4964   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4965     // Compute array klass from element klass
4966     ciKlass* k_elem = tary-&gt;klass();
4967     // If element type is something like bottom[], k_elem will be null.
4968     if (k_elem != NULL)
4969       k_ary = ciObjArrayKlass::make(k_elem);
4970   } else if ((el-&gt;base() == Type::Top) ||
4971              (el-&gt;base() == Type::Bottom)) {
4972     // element type of Bottom occurs from meet of basic type
4973     // and object; Top occurs when doing join on Bottom.
4974     // Leave k_ary at NULL.
4975   } else {
4976     // Cannot compute array klass directly from basic type,
4977     // since subtypes of TypeInt all have basic type T_INT.
4978 #ifdef ASSERT
4979     if (verify &amp;&amp; el-&gt;isa_int()) {
4980       // Check simple cases when verifying klass.
4981       BasicType bt = T_ILLEGAL;
4982       if (el == TypeInt::BYTE) {
4983         bt = T_BYTE;
4984       } else if (el == TypeInt::SHORT) {
4985         bt = T_SHORT;
4986       } else if (el == TypeInt::CHAR) {
4987         bt = T_CHAR;
4988       } else if (el == TypeInt::INT) {
4989         bt = T_INT;
4990       } else {
4991         return _klass; // just return specified klass
4992       }
4993       return ciTypeArrayKlass::make(bt);
4994     }
4995 #endif
4996     assert(!el-&gt;isa_int(),
4997            &quot;integral arrays must be pre-equipped with a class&quot;);
4998     // Compute array klass directly from basic type
4999     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5000   }
5001   return k_ary;
5002 }
5003 
5004 //------------------------------klass------------------------------------------
5005 // Return the defining klass for this class
5006 ciKlass* TypeAryPtr::klass() const {
5007   if( _klass ) return _klass;   // Return cached value, if possible
5008 
5009   // Oops, need to compute _klass and cache it
5010   ciKlass* k_ary = compute_klass();
5011 
5012   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5013     // The _klass field acts as a cache of the underlying
5014     // ciKlass for this array type.  In order to set the field,
5015     // we need to cast away const-ness.
5016     //
5017     // IMPORTANT NOTE: we *never* set the _klass field for the
5018     // type TypeAryPtr::OOPS.  This Type is shared between all
5019     // active compilations.  However, the ciKlass which represents
5020     // this Type is *not* shared between compilations, so caching
5021     // this value would result in fetching a dangling pointer.
5022     //
5023     // Recomputing the underlying ciKlass for each request is
5024     // a bit less efficient than caching, but calls to
5025     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5026     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5027     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5028         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {
5029       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5030     }
5031   }
5032   return k_ary;
5033 }
5034 
5035 
5036 //------------------------------add_offset-------------------------------------
5037 // Access internals of klass object
5038 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5039   return make( _ptr, klass(), xadd_offset(offset) );
5040 }
5041 
5042 //------------------------------cast_to_ptr_type-------------------------------
5043 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5044   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5045   if( ptr == _ptr ) return this;
5046   return make(ptr, _klass, _offset);
5047 }
5048 
5049 
5050 //-----------------------------cast_to_exactness-------------------------------
5051 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5052   if( klass_is_exact == _klass_is_exact ) return this;
5053   if (!UseExactTypes)  return this;
5054   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);
5055 }
5056 
5057 
5058 //-----------------------------as_instance_type--------------------------------
5059 // Corresponding type for an instance of the given class.
5060 // It will be NotNull, and exact if and only if the klass type is exact.
5061 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5062   ciKlass* k = klass();
5063   bool    xk = klass_is_exact();
5064   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5065   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5066   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5067   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5068   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5069 }
5070 
5071 
5072 //------------------------------xmeet------------------------------------------
5073 // Compute the MEET of two types, return a new Type object.
5074 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5075   // Perform a fast test for common case; meeting the same types together.
5076   if( this == t ) return this;  // Meeting same type-rep?
5077 
5078   // Current &quot;this-&gt;_base&quot; is Pointer
5079   switch (t-&gt;base()) {          // switch on original type
5080 
5081   case Int:                     // Mixing ints &amp; oops happens when javac
5082   case Long:                    // reuses local variables
5083   case FloatTop:
5084   case FloatCon:
5085   case FloatBot:
5086   case DoubleTop:
5087   case DoubleCon:
5088   case DoubleBot:
5089   case NarrowOop:
5090   case NarrowKlass:
5091   case Bottom:                  // Ye Olde Default
5092     return Type::BOTTOM;
5093   case Top:
5094     return this;
5095 
5096   default:                      // All else is a mistake
5097     typerr(t);
5098 
5099   case AnyPtr: {                // Meeting to AnyPtrs
5100     // Found an AnyPtr type vs self-KlassPtr type
5101     const TypePtr *tp = t-&gt;is_ptr();
5102     int offset = meet_offset(tp-&gt;offset());
5103     PTR ptr = meet_ptr(tp-&gt;ptr());
5104     switch (tp-&gt;ptr()) {
5105     case TopPTR:
5106       return this;
5107     case Null:
5108       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5109     case AnyNull:
5110       return make( ptr, klass(), offset );
5111     case BotPTR:
5112     case NotNull:
5113       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5114     default: typerr(t);
5115     }
5116   }
5117 
5118   case RawPtr:
5119   case MetadataPtr:
5120   case OopPtr:
5121   case AryPtr:                  // Meet with AryPtr
5122   case InstPtr:                 // Meet with InstPtr
5123     return TypePtr::BOTTOM;
5124 
5125   //
5126   //             A-top         }
5127   //           /   |   \       }  Tops
5128   //       B-top A-any C-top   }
5129   //          | /  |  \ |      }  Any-nulls
5130   //       B-any   |   C-any   }
5131   //          |    |    |
5132   //       B-con A-con C-con   } constants; not comparable across classes
5133   //          |    |    |
5134   //       B-not   |   C-not   }
5135   //          | \  |  / |      }  not-nulls
5136   //       B-bot A-not C-bot   }
5137   //           \   |   /       }  Bottoms
5138   //             A-bot         }
5139   //
5140 
5141   case KlassPtr: {  // Meet two KlassPtr types
5142     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5143     int  off     = meet_offset(tkls-&gt;offset());
5144     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5145 
5146     // Check for easy case; klasses are equal (and perhaps not loaded!)
5147     // If we have constants, then we created oops so classes are loaded
5148     // and we can handle the constants further down.  This case handles
5149     // not-loaded classes
5150     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {
5151       return make( ptr, klass(), off );
5152     }
5153 
5154     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5155     ciKlass* tkls_klass = tkls-&gt;klass();
5156     ciKlass* this_klass = this-&gt;klass();
5157     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5158     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5159 
5160     // If &#39;this&#39; type is above the centerline and is a superclass of the
5161     // other, we can treat &#39;this&#39; as having the same type as the other.
5162     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5163         tkls_klass-&gt;is_subtype_of(this_klass)) {
5164       this_klass = tkls_klass;
5165     }
5166     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5167     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5168     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5169         this_klass-&gt;is_subtype_of(tkls_klass)) {
5170       tkls_klass = this_klass;
5171     }
5172 
5173     // Check for classes now being equal
5174     if (tkls_klass-&gt;equals(this_klass)) {
5175       // If the klasses are equal, the constants may still differ.  Fall to
5176       // NotNull if they do (neither constant is NULL; that is a special case
5177       // handled elsewhere).
5178       if( ptr == Constant ) {
5179         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5180             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5181         else if (above_centerline(this-&gt;ptr()));
5182         else if (above_centerline(tkls-&gt;ptr()));
5183         else
5184           ptr = NotNull;
5185       }
5186       return make( ptr, this_klass, off );
5187     } // Else classes are not equal
5188 
5189     // Since klasses are different, we require the LCA in the Java
5190     // class hierarchy - which means we have to fall to at least NotNull.
5191     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5192       ptr = NotNull;
5193     // Now we find the LCA of Java classes
5194     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5195     return   make( ptr, k, off );
5196   } // End of case KlassPtr
5197 
5198   } // End of switch
5199   return this;                  // Return the double constant
5200 }
5201 
5202 //------------------------------xdual------------------------------------------
5203 // Dual: compute field-by-field dual
5204 const Type    *TypeKlassPtr::xdual() const {
5205   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );
5206 }
5207 
5208 //------------------------------get_con----------------------------------------
5209 intptr_t TypeKlassPtr::get_con() const {
5210   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5211   assert( _offset &gt;= 0, &quot;&quot; );
5212 
5213   if (_offset != 0) {
5214     // After being ported to the compiler interface, the compiler no longer
5215     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5216     // to a handle at compile time.  This handle is embedded in the generated
5217     // code and dereferenced at the time the nmethod is made.  Until that time,
5218     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5219     // have access to the addresses!).  This does not seem to currently happen,
5220     // but this assertion here is to help prevent its occurence.
5221     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5222     ShouldNotReachHere();
5223   }
5224 
5225   return (intptr_t)klass()-&gt;constant_encoding();
5226 }
5227 //------------------------------dump2------------------------------------------
5228 // Dump Klass Type
5229 #ifndef PRODUCT
5230 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5231   switch( _ptr ) {
5232   case Constant:
5233     st-&gt;print(&quot;precise &quot;);
5234   case NotNull:
5235     {
5236       const char *name = klass()-&gt;name()-&gt;as_utf8();
5237       if( name ) {
5238         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5239       } else {
5240         ShouldNotReachHere();
5241       }
5242     }
5243   case BotPTR:
5244     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5245   case TopPTR:
5246   case AnyNull:
5247     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5248     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5249     break;
5250   default:
5251     break;
5252   }
5253 
5254   if( _offset ) {               // Dump offset, if any
5255     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }
5256     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }
5257     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }
5258   }
5259 
5260   st-&gt;print(&quot; *&quot;);
5261 }
5262 #endif
5263 
5264 
5265 
5266 //=============================================================================
5267 // Convenience common pre-built types.
5268 
5269 //------------------------------make-------------------------------------------
5270 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {
5271   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();
5272 }
5273 
5274 //------------------------------make-------------------------------------------
5275 const TypeFunc *TypeFunc::make(ciMethod* method) {
5276   Compile* C = Compile::current();
5277   const TypeFunc* tf = C-&gt;last_tf(method); // check cache
5278   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5279   const TypeTuple *domain;
5280   if (method-&gt;is_static()) {
5281     domain = TypeTuple::make_domain(NULL, method-&gt;signature());
5282   } else {
5283     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());
5284   }
5285   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());
5286   tf = TypeFunc::make(domain, range);
5287   C-&gt;set_last_tf(method, tf);  // fill cache
5288   return tf;
5289 }
5290 
5291 //------------------------------meet-------------------------------------------
5292 // Compute the MEET of two types.  It returns a new Type object.
5293 const Type *TypeFunc::xmeet( const Type *t ) const {
5294   // Perform a fast test for common case; meeting the same types together.
5295   if( this == t ) return this;  // Meeting same type-rep?
5296 
5297   // Current &quot;this-&gt;_base&quot; is Func
5298   switch (t-&gt;base()) {          // switch on original type
5299 
5300   case Bottom:                  // Ye Olde Default
5301     return t;
5302 
5303   default:                      // All else is a mistake
5304     typerr(t);
5305 
5306   case Top:
5307     break;
5308   }
5309   return this;                  // Return the double constant
5310 }
5311 
5312 //------------------------------xdual------------------------------------------
5313 // Dual: compute field-by-field dual
5314 const Type *TypeFunc::xdual() const {
5315   return this;
5316 }
5317 
5318 //------------------------------eq---------------------------------------------
5319 // Structural equality check for Type representations
5320 bool TypeFunc::eq( const Type *t ) const {
5321   const TypeFunc *a = (const TypeFunc*)t;
5322   return _domain == a-&gt;_domain &amp;&amp;
5323     _range == a-&gt;_range;
5324 }
5325 
5326 //------------------------------hash-------------------------------------------
5327 // Type-specific hashing function.
5328 int TypeFunc::hash(void) const {
5329   return (intptr_t)_domain + (intptr_t)_range;
5330 }
5331 
5332 //------------------------------dump2------------------------------------------
5333 // Dump Function Type
5334 #ifndef PRODUCT
5335 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5336   if( _range-&gt;cnt() &lt;= Parms )
5337     st-&gt;print(&quot;void&quot;);
5338   else {
5339     uint i;
5340     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {
5341       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5342       st-&gt;print(&quot;/&quot;);
5343     }
5344     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5345   }
5346   st-&gt;print(&quot; &quot;);
5347   st-&gt;print(&quot;( &quot;);
5348   if( !depth || d[this] ) {     // Check for recursive dump
5349     st-&gt;print(&quot;...)&quot;);
5350     return;
5351   }
5352   d.Insert((void*)this,(void*)this);    // Stop recursion
5353   if (Parms &lt; _domain-&gt;cnt())
5354     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5355   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {
5356     st-&gt;print(&quot;, &quot;);
5357     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5358   }
5359   st-&gt;print(&quot; )&quot;);
5360 }
5361 #endif
5362 
5363 //------------------------------singleton--------------------------------------
5364 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5365 // constants (Ldi nodes).  Singletons are integer, float or double constants
5366 // or a single symbol.
5367 bool TypeFunc::singleton(void) const {
5368   return false;                 // Never a singleton
5369 }
5370 
5371 bool TypeFunc::empty(void) const {
5372   return false;                 // Never empty
5373 }
5374 
5375 
5376 BasicType TypeFunc::return_type() const{
5377   if (range()-&gt;cnt() == TypeFunc::Parms) {
5378     return T_VOID;
5379   }
5380   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5381 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/generateOptoStub.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="chaitin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/generateOptoStub.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 75   uint i;
 76   for (i = 0; i &lt; parm_cnt; i++) {
 77     map()-&gt;init_req(i, _gvn.transform(new ParmNode(start, i)));
 78   }
 79   for ( ; i&lt;map()-&gt;req(); i++) {
 80     map()-&gt;init_req(i, top());      // For nicer debugging
 81   }
 82 
 83   // GraphKit requires memory to be a MergeMemNode:
 84   set_all_memory(map()-&gt;memory());
 85 
 86   // Get base of thread-local storage area
 87   Node* thread = _gvn.transform(new ThreadLocalNode());
 88 
 89   const int NoAlias = Compile::AliasIdxBot;
 90 
 91   Node* adr_last_Java_pc = basic_plus_adr(top(),
 92                                             thread,
 93                                             in_bytes(JavaThread::frame_anchor_offset()) +
 94                                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));
<span class="line-removed"> 95 #if defined(SPARC)</span>
<span class="line-removed"> 96   Node* adr_flags = basic_plus_adr(top(),</span>
<span class="line-removed"> 97                                    thread,</span>
<span class="line-removed"> 98                                    in_bytes(JavaThread::frame_anchor_offset()) +</span>
<span class="line-removed"> 99                                    in_bytes(JavaFrameAnchor::flags_offset()));</span>
<span class="line-removed">100 #endif /* defined(SPARC) */</span>
<span class="line-removed">101 </span>
102 
103   // Drop in the last_Java_sp.  last_Java_fp is not touched.
104   // Always do this after the other &quot;last_Java_frame&quot; fields are set since
105   // as soon as last_Java_sp != NULL the has_last_Java_frame is true and
106   // users will look at the other fields.
107   //
108   Node *adr_sp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_sp_offset()));
109   Node *last_sp = basic_plus_adr(top(), frameptr(), (intptr_t) STACK_BIAS);
110   store_to_memory(NULL, adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);
111 
112   // Set _thread_in_native
113   // The order of stores into TLS is critical!  Setting _thread_in_native MUST
114   // be last, because a GC is allowed at any time after setting it and the GC
115   // will require last_Java_pc and last_Java_sp.
116 
117   //-----------------------------
118   // Compute signature for C call.  Varies from the Java signature!
119 
120   const Type **fields = TypeTuple::fields(2*parm_cnt+2);
121   uint cnt = TypeFunc::Parms;
</pre>
<hr />
<pre>
212     // C-land is allowed to return sub-word values.  Convert to integer type.
213     assert( retval != Type::TOP, &quot;&quot; );
214     if (retval == TypeInt::BOOL) {
215       retnode = _gvn.transform( new AndINode(retnode, intcon(0xFF)) );
216     } else if (retval == TypeInt::CHAR) {
217       retnode = _gvn.transform( new AndINode(retnode, intcon(0xFFFF)) );
218     } else if (retval == TypeInt::BYTE) {
219       retnode = _gvn.transform( new LShiftINode(retnode, intcon(24)) );
220       retnode = _gvn.transform( new RShiftINode(retnode, intcon(24)) );
221     } else if (retval == TypeInt::SHORT) {
222       retnode = _gvn.transform( new LShiftINode(retnode, intcon(16)) );
223       retnode = _gvn.transform( new RShiftINode(retnode, intcon(16)) );
224     }
225     map()-&gt;set_req( TypeFunc::Parms, retnode );
226   }
227 
228   //-----------------------------
229 
230   // Clear last_Java_sp
231   store_to_memory(NULL, adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);
<span class="line-modified">232   // Clear last_Java_pc and (optionally)_flags</span>
233   store_to_memory(NULL, adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);
<span class="line-removed">234 #if defined(SPARC)</span>
<span class="line-removed">235   store_to_memory(NULL, adr_flags, intcon(0), T_INT, NoAlias, MemNode::unordered);</span>
<span class="line-removed">236 #endif /* defined(SPARC) */</span>
237 #if (defined(IA64) &amp;&amp; !defined(AIX))
238   Node* adr_last_Java_fp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_fp_offset()));
239   store_to_memory(NULL, adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);
240 #endif
241 
242   // For is-fancy-jump, the C-return value is also the branch target
243   Node* target = map()-&gt;in(TypeFunc::Parms);
244   // Runtime call returning oop in TLS?  Fetch it out
245   if( pass_tls ) {
246     Node* adr = basic_plus_adr(top(), thread, in_bytes(JavaThread::vm_result_offset()));
247     Node* vm_result = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);
248     map()-&gt;set_req(TypeFunc::Parms, vm_result); // vm_result passed as result
249     // clear thread-local-storage(tls)
250     store_to_memory(NULL, adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);
251   }
252 
253   //-----------------------------
254   // check exception
255   Node* adr = basic_plus_adr(top(), thread, in_bytes(Thread::pending_exception_offset()));
256   Node* pending = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 75   uint i;
 76   for (i = 0; i &lt; parm_cnt; i++) {
 77     map()-&gt;init_req(i, _gvn.transform(new ParmNode(start, i)));
 78   }
 79   for ( ; i&lt;map()-&gt;req(); i++) {
 80     map()-&gt;init_req(i, top());      // For nicer debugging
 81   }
 82 
 83   // GraphKit requires memory to be a MergeMemNode:
 84   set_all_memory(map()-&gt;memory());
 85 
 86   // Get base of thread-local storage area
 87   Node* thread = _gvn.transform(new ThreadLocalNode());
 88 
 89   const int NoAlias = Compile::AliasIdxBot;
 90 
 91   Node* adr_last_Java_pc = basic_plus_adr(top(),
 92                                             thread,
 93                                             in_bytes(JavaThread::frame_anchor_offset()) +
 94                                             in_bytes(JavaFrameAnchor::last_Java_pc_offset()));







 95 
 96   // Drop in the last_Java_sp.  last_Java_fp is not touched.
 97   // Always do this after the other &quot;last_Java_frame&quot; fields are set since
 98   // as soon as last_Java_sp != NULL the has_last_Java_frame is true and
 99   // users will look at the other fields.
100   //
101   Node *adr_sp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_sp_offset()));
102   Node *last_sp = basic_plus_adr(top(), frameptr(), (intptr_t) STACK_BIAS);
103   store_to_memory(NULL, adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);
104 
105   // Set _thread_in_native
106   // The order of stores into TLS is critical!  Setting _thread_in_native MUST
107   // be last, because a GC is allowed at any time after setting it and the GC
108   // will require last_Java_pc and last_Java_sp.
109 
110   //-----------------------------
111   // Compute signature for C call.  Varies from the Java signature!
112 
113   const Type **fields = TypeTuple::fields(2*parm_cnt+2);
114   uint cnt = TypeFunc::Parms;
</pre>
<hr />
<pre>
205     // C-land is allowed to return sub-word values.  Convert to integer type.
206     assert( retval != Type::TOP, &quot;&quot; );
207     if (retval == TypeInt::BOOL) {
208       retnode = _gvn.transform( new AndINode(retnode, intcon(0xFF)) );
209     } else if (retval == TypeInt::CHAR) {
210       retnode = _gvn.transform( new AndINode(retnode, intcon(0xFFFF)) );
211     } else if (retval == TypeInt::BYTE) {
212       retnode = _gvn.transform( new LShiftINode(retnode, intcon(24)) );
213       retnode = _gvn.transform( new RShiftINode(retnode, intcon(24)) );
214     } else if (retval == TypeInt::SHORT) {
215       retnode = _gvn.transform( new LShiftINode(retnode, intcon(16)) );
216       retnode = _gvn.transform( new RShiftINode(retnode, intcon(16)) );
217     }
218     map()-&gt;set_req( TypeFunc::Parms, retnode );
219   }
220 
221   //-----------------------------
222 
223   // Clear last_Java_sp
224   store_to_memory(NULL, adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);
<span class="line-modified">225   // Clear last_Java_pc</span>
226   store_to_memory(NULL, adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);



227 #if (defined(IA64) &amp;&amp; !defined(AIX))
228   Node* adr_last_Java_fp = basic_plus_adr(top(), thread, in_bytes(JavaThread::last_Java_fp_offset()));
229   store_to_memory(NULL, adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);
230 #endif
231 
232   // For is-fancy-jump, the C-return value is also the branch target
233   Node* target = map()-&gt;in(TypeFunc::Parms);
234   // Runtime call returning oop in TLS?  Fetch it out
235   if( pass_tls ) {
236     Node* adr = basic_plus_adr(top(), thread, in_bytes(JavaThread::vm_result_offset()));
237     Node* vm_result = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);
238     map()-&gt;set_req(TypeFunc::Parms, vm_result); // vm_result passed as result
239     // clear thread-local-storage(tls)
240     store_to_memory(NULL, adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);
241   }
242 
243   //-----------------------------
244   // check exception
245   Node* adr = basic_plus_adr(top(), thread, in_bytes(Thread::pending_exception_offset()));
246   Node* pending = make_load(NULL, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);
</pre>
</td>
</tr>
</table>
<center><a href="chaitin.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
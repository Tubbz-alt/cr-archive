diff a/src/hotspot/share/opto/chaitin.cpp b/src/hotspot/share/opto/chaitin.cpp
--- a/src/hotspot/share/opto/chaitin.cpp
+++ b/src/hotspot/share/opto/chaitin.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -867,24 +867,20 @@
           // IA64     1     1     1          1    1         50          41
           // SPARC    2     2     2          2    2         48 (24)     52 (26)
           // SPARCV9  2     2     2          2    2         48 (24)     52 (26)
           // AMD64    1     1     1          1    1         14          15
           // -----------------------------------------------------
-#if defined(SPARC)
-          lrg.set_reg_pressure(2);  // use for v9 as well
-#else
           lrg.set_reg_pressure(1);  // normally one value per register
-#endif
           if( n_type->isa_oop_ptr() ) {
             lrg._is_oop = 1;
           }
           break;
         case Op_RegL:           // Check for long or double
         case Op_RegD:
           lrg.set_num_regs(2);
           // Define platform specific register pressure
-#if defined(SPARC) || defined(ARM32)
+#if defined(ARM32)
           lrg.set_reg_pressure(2);
 #elif defined(IA32)
           if( ireg == Op_RegL ) {
             lrg.set_reg_pressure(2);
           } else {
@@ -907,15 +903,11 @@
         case Op_RegI:
         case Op_RegN:
         case Op_RegFlags:
         case 0:                 // not an ideal register
           lrg.set_num_regs(1);
-#ifdef SPARC
-          lrg.set_reg_pressure(2);
-#else
           lrg.set_reg_pressure(1);
-#endif
           break;
         case Op_VecS:
           assert(Matcher::vector_size_supported(T_BYTE,4), "sanity");
           assert(RegMask::num_registers(Op_VecS) == RegMask::SlotsPerVecS, "sanity");
           lrg.set_num_regs(RegMask::SlotsPerVecS);
@@ -1484,14 +1476,10 @@
       lrg->clear_to_sets();
     }
 
     // Check if a color is available and if so pick the color
     OptoReg::Name reg = choose_color( *lrg, chunk );
-#ifdef SPARC
-    debug_only(lrg->compute_set_mask_size());
-    assert(lrg->num_regs() < 2 || lrg->is_bound() || is_even(reg-1), "allocate all doubles aligned");
-#endif
 
     //---------------
     // If we fail to color and the AllStack flag is set, trigger
     // a chunk-rollover event
     if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {

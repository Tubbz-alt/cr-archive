<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 438 // LIR_OpLabel
 439     case lir_label:                    // result and info always invalid
 440     {
 441       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 442       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 443       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 444       break;
 445     }
 446 
 447 
 448 // LIR_Op1
 449     case lir_fxch:           // input always valid, result and info always invalid
 450     case lir_fld:            // input always valid, result and info always invalid
 451     case lir_push:           // input always valid, result and info always invalid
 452     case lir_pop:            // input always valid, result and info always invalid
 453     case lir_return:         // input always valid, result and info always invalid
 454     case lir_leal:           // input and result always valid, info always invalid
 455     case lir_monaddr:        // input and result always valid, info always invalid
 456     case lir_null_check:     // input and info always valid, result always invalid
 457     case lir_move:           // input and result always valid, may have info
<span class="line-removed"> 458     case lir_pack64:         // input and result always valid</span>
<span class="line-removed"> 459     case lir_unpack64:       // input and result always valid</span>
 460     {
 461       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 462       LIR_Op1* op1 = (LIR_Op1*)op;
 463 
 464       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 465       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 466       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 467 
 468       break;
 469     }
 470 
 471     case lir_safepoint:
 472     {
 473       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 474       LIR_Op1* op1 = (LIR_Op1*)op;
 475 
 476       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 477       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 478       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 479 
</pre>
<hr />
<pre>
1631      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1632      // LIR_Op1
1633      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1634      case lir_fld:                   s = &quot;fld&quot;;           break;
1635      case lir_push:                  s = &quot;push&quot;;          break;
1636      case lir_pop:                   s = &quot;pop&quot;;           break;
1637      case lir_null_check:            s = &quot;null_check&quot;;    break;
1638      case lir_return:                s = &quot;return&quot;;        break;
1639      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1640      case lir_leal:                  s = &quot;leal&quot;;          break;
1641      case lir_branch:                s = &quot;branch&quot;;        break;
1642      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1643      case lir_move:                  s = &quot;move&quot;;          break;
1644      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1645      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1646      case lir_throw:                 s = &quot;throw&quot;;         break;
1647      case lir_unwind:                s = &quot;unwind&quot;;        break;
1648      case lir_convert:               s = &quot;convert&quot;;       break;
1649      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1650      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
<span class="line-removed">1651      case lir_pack64:                s = &quot;pack64&quot;;        break;</span>
<span class="line-removed">1652      case lir_unpack64:              s = &quot;unpack64&quot;;      break;</span>
1653      // LIR_Op2
1654      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1655      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1656      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1657      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1658      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1659      case lir_add:                   s = &quot;add&quot;;           break;
1660      case lir_sub:                   s = &quot;sub&quot;;           break;
1661      case lir_mul:                   s = &quot;mul&quot;;           break;
1662      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1663      case lir_div:                   s = &quot;div&quot;;           break;
1664      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1665      case lir_rem:                   s = &quot;rem&quot;;           break;
1666      case lir_abs:                   s = &quot;abs&quot;;           break;
1667      case lir_neg:                   s = &quot;neg&quot;;           break;
1668      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1669      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1670      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1671      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1672      case lir_shl:                   s = &quot;shift_left&quot;;    break;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 438 // LIR_OpLabel
 439     case lir_label:                    // result and info always invalid
 440     {
 441       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 442       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 443       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 444       break;
 445     }
 446 
 447 
 448 // LIR_Op1
 449     case lir_fxch:           // input always valid, result and info always invalid
 450     case lir_fld:            // input always valid, result and info always invalid
 451     case lir_push:           // input always valid, result and info always invalid
 452     case lir_pop:            // input always valid, result and info always invalid
 453     case lir_return:         // input always valid, result and info always invalid
 454     case lir_leal:           // input and result always valid, info always invalid
 455     case lir_monaddr:        // input and result always valid, info always invalid
 456     case lir_null_check:     // input and info always valid, result always invalid
 457     case lir_move:           // input and result always valid, may have info


 458     {
 459       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 460       LIR_Op1* op1 = (LIR_Op1*)op;
 461 
 462       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 463       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 464       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 465 
 466       break;
 467     }
 468 
 469     case lir_safepoint:
 470     {
 471       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 472       LIR_Op1* op1 = (LIR_Op1*)op;
 473 
 474       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 475       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 476       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 477 
</pre>
<hr />
<pre>
1629      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1630      // LIR_Op1
1631      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1632      case lir_fld:                   s = &quot;fld&quot;;           break;
1633      case lir_push:                  s = &quot;push&quot;;          break;
1634      case lir_pop:                   s = &quot;pop&quot;;           break;
1635      case lir_null_check:            s = &quot;null_check&quot;;    break;
1636      case lir_return:                s = &quot;return&quot;;        break;
1637      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1638      case lir_leal:                  s = &quot;leal&quot;;          break;
1639      case lir_branch:                s = &quot;branch&quot;;        break;
1640      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1641      case lir_move:                  s = &quot;move&quot;;          break;
1642      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1643      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1644      case lir_throw:                 s = &quot;throw&quot;;         break;
1645      case lir_unwind:                s = &quot;unwind&quot;;        break;
1646      case lir_convert:               s = &quot;convert&quot;;       break;
1647      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1648      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;


1649      // LIR_Op2
1650      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1651      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1652      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1653      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1654      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1655      case lir_add:                   s = &quot;add&quot;;           break;
1656      case lir_sub:                   s = &quot;sub&quot;;           break;
1657      case lir_mul:                   s = &quot;mul&quot;;           break;
1658      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1659      case lir_div:                   s = &quot;div&quot;;           break;
1660      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1661      case lir_rem:                   s = &quot;rem&quot;;           break;
1662      case lir_abs:                   s = &quot;abs&quot;;           break;
1663      case lir_neg:                   s = &quot;neg&quot;;           break;
1664      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1665      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1666      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1667      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1668      case lir_shl:                   s = &quot;shift_left&quot;;    break;
</pre>
</td>
</tr>
</table>
<center><a href="c1_GraphBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
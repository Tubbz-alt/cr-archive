<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2065   // jsr/ret pairs which are not associated with finally clauses and
2066   // do not have exception handlers in the containing method, and are
2067   // therefore not caught early enough to abort the inlining without
2068   // corrupting the graph. (We currently bail out with a non-empty
2069   // stack at a ret in these situations.)
2070   CHECK_BAILOUT();
2071 
2072   // inlining not successful =&gt; standard invoke
2073   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2074   ValueStack* state_before = copy_state_exhandling();
2075 
2076   // The bytecode (code) might change in this method so we are checking this very late.
2077   const bool has_receiver =
2078     code == Bytecodes::_invokespecial   ||
2079     code == Bytecodes::_invokevirtual   ||
2080     code == Bytecodes::_invokeinterface;
2081   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2082   Value recv = has_receiver ? apop() : NULL;
2083   int vtable_index = Method::invalid_vtable_index;
2084 
<span class="line-removed">2085 #ifdef SPARC</span>
<span class="line-removed">2086   // Currently only supported on Sparc.</span>
<span class="line-removed">2087   // The UseInlineCaches only controls dispatch to invokevirtuals for</span>
<span class="line-removed">2088   // loaded classes which we weren&#39;t able to statically bind.</span>
<span class="line-removed">2089   if (!UseInlineCaches &amp;&amp; target-&gt;is_loaded() &amp;&amp; code == Bytecodes::_invokevirtual</span>
<span class="line-removed">2090       &amp;&amp; !target-&gt;can_be_statically_bound()) {</span>
<span class="line-removed">2091     // Find a vtable index if one is available</span>
<span class="line-removed">2092     // For arrays, callee_holder is Object. Resolving the call with</span>
<span class="line-removed">2093     // Object would allow an illegal call to finalize() on an</span>
<span class="line-removed">2094     // array. We use holder instead: illegal calls to finalize() won&#39;t</span>
<span class="line-removed">2095     // be compiled as vtable calls (IC call resolution will catch the</span>
<span class="line-removed">2096     // illegal call) and the few legal calls on array types won&#39;t be</span>
<span class="line-removed">2097     // either.</span>
<span class="line-removed">2098     vtable_index = target-&gt;resolve_vtable_index(calling_klass, holder);</span>
<span class="line-removed">2099   }</span>
<span class="line-removed">2100 #endif</span>
<span class="line-removed">2101 </span>
2102   // A null check is required here (when there is a receiver) for any of the following cases
2103   // - invokespecial, always need a null check.
2104   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2105   //   and require null checking. If the target is loaded a null check is emitted here.
2106   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2107   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2108   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2109   //   potentially fail, and can&#39;t have the null check before the resolution.)
2110   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2111   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2112   //
2113   // Normal invokevirtual will perform the null check during lookup
2114 
2115   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2116       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2117 
2118   if (need_null_check) {
2119     if (recv != NULL) {
2120       null_check(recv);
2121     }
</pre>
</td>
<td>
<hr />
<pre>
2065   // jsr/ret pairs which are not associated with finally clauses and
2066   // do not have exception handlers in the containing method, and are
2067   // therefore not caught early enough to abort the inlining without
2068   // corrupting the graph. (We currently bail out with a non-empty
2069   // stack at a ret in these situations.)
2070   CHECK_BAILOUT();
2071 
2072   // inlining not successful =&gt; standard invoke
2073   ValueType* result_type = as_ValueType(declared_signature-&gt;return_type());
2074   ValueStack* state_before = copy_state_exhandling();
2075 
2076   // The bytecode (code) might change in this method so we are checking this very late.
2077   const bool has_receiver =
2078     code == Bytecodes::_invokespecial   ||
2079     code == Bytecodes::_invokevirtual   ||
2080     code == Bytecodes::_invokeinterface;
2081   Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
2082   Value recv = has_receiver ? apop() : NULL;
2083   int vtable_index = Method::invalid_vtable_index;
2084 

















2085   // A null check is required here (when there is a receiver) for any of the following cases
2086   // - invokespecial, always need a null check.
2087   // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
2088   //   and require null checking. If the target is loaded a null check is emitted here.
2089   //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
2090   //   by using the target methods unverified entry point (see CompiledIC::compute_monomorphic_entry).
2091   //   (The JVM specification requires that LinkageError must be thrown before a NPE. An unloaded target may
2092   //   potentially fail, and can&#39;t have the null check before the resolution.)
2093   // - A call that will be profiled. (But we can&#39;t add a null check when the target is unloaded, by the same
2094   //   reason as above, so calls with a receiver to unloaded targets can&#39;t be profiled.)
2095   //
2096   // Normal invokevirtual will perform the null check during lookup
2097 
2098   bool need_null_check = (code == Bytecodes::_invokespecial) ||
2099       (target-&gt;is_loaded() &amp;&amp; (target-&gt;is_final_method() || (is_profiling() &amp;&amp; profile_calls())));
2100 
2101   if (need_null_check) {
2102     if (recv != NULL) {
2103       null_check(recv);
2104     }
</pre>
</td>
</tr>
</table>
<center><a href="c1_Compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 896       , lir_membar_storeload
 897       , lir_get_thread
 898       , lir_on_spin_wait
 899   , end_op0
 900   , begin_op1
 901       , lir_fxch
 902       , lir_fld
 903       , lir_push
 904       , lir_pop
 905       , lir_null_check
 906       , lir_return
 907       , lir_leal
 908       , lir_branch
 909       , lir_cond_float_branch
 910       , lir_move
 911       , lir_convert
 912       , lir_alloc_object
 913       , lir_monaddr
 914       , lir_roundfp
 915       , lir_safepoint
<span class="line-removed"> 916       , lir_pack64</span>
<span class="line-removed"> 917       , lir_unpack64</span>
 918       , lir_unwind
 919   , end_op1
 920   , begin_op2
 921       , lir_cmp
 922       , lir_cmp_l2i
 923       , lir_ucmp_fd2i
 924       , lir_cmp_fd2i
 925       , lir_cmove
 926       , lir_add
 927       , lir_sub
 928       , lir_mul
 929       , lir_mul_strictfp
 930       , lir_div
 931       , lir_div_strictfp
 932       , lir_rem
 933       , lir_sqrt
 934       , lir_abs
 935       , lir_neg
 936       , lir_tan
 937       , lir_log10
</pre>
<hr />
<pre>
2092     }
2093   }
2094   void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }
2095 
2096   void oop2reg  (jobject o, LIR_Opr reg)         { assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),    reg));   }
2097   void oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info);
2098 
2099   void metadata2reg  (Metadata* o, LIR_Opr reg)  { assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg));   }
2100   void klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info);
2101 
2102   void return_op(LIR_Opr result)                 { append(new LIR_Op1(lir_return, result)); }
2103 
2104   void safepoint(LIR_Opr tmp, CodeEmitInfo* info)  { append(new LIR_Op1(lir_safepoint, tmp, info)); }
2105 
2106   void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = NULL/*, bool is_32bit = false*/) { append(new LIR_OpConvert(code, left, dst, stub)); }
2107 
2108   void logical_and (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_and,  left, right, dst)); }
2109   void logical_or  (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_or,   left, right, dst)); }
2110   void logical_xor (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_xor,  left, right, dst)); }
2111 
<span class="line-removed">2112   void   pack64(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_pack64,   src, dst, T_LONG, lir_patch_none, NULL)); }</span>
<span class="line-removed">2113   void unpack64(LIR_Opr src, LIR_Opr dst) { append(new LIR_Op1(lir_unpack64, src, dst, T_LONG, lir_patch_none, NULL)); }</span>
<span class="line-removed">2114 </span>
2115   void null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null = false);
2116   void throw_exception(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2117     append(new LIR_Op2(lir_throw, exceptionPC, exceptionOop, LIR_OprFact::illegalOpr, info));
2118   }
2119   void unwind_exception(LIR_Opr exceptionOop) {
2120     append(new LIR_Op1(lir_unwind, exceptionOop));
2121   }
2122 
2123   void push(LIR_Opr opr)                                   { append(new LIR_Op1(lir_push, opr)); }
2124   void pop(LIR_Opr reg)                                    { append(new LIR_Op1(lir_pop,  reg)); }
2125 
2126   void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL) {
2127     append(new LIR_Op2(lir_cmp, condition, left, right, info));
2128   }
2129   void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = NULL) {
2130     cmp(condition, left, LIR_OprFact::intConst(right), info);
2131   }
2132 
2133   void cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info);
2134   void cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 896       , lir_membar_storeload
 897       , lir_get_thread
 898       , lir_on_spin_wait
 899   , end_op0
 900   , begin_op1
 901       , lir_fxch
 902       , lir_fld
 903       , lir_push
 904       , lir_pop
 905       , lir_null_check
 906       , lir_return
 907       , lir_leal
 908       , lir_branch
 909       , lir_cond_float_branch
 910       , lir_move
 911       , lir_convert
 912       , lir_alloc_object
 913       , lir_monaddr
 914       , lir_roundfp
 915       , lir_safepoint


 916       , lir_unwind
 917   , end_op1
 918   , begin_op2
 919       , lir_cmp
 920       , lir_cmp_l2i
 921       , lir_ucmp_fd2i
 922       , lir_cmp_fd2i
 923       , lir_cmove
 924       , lir_add
 925       , lir_sub
 926       , lir_mul
 927       , lir_mul_strictfp
 928       , lir_div
 929       , lir_div_strictfp
 930       , lir_rem
 931       , lir_sqrt
 932       , lir_abs
 933       , lir_neg
 934       , lir_tan
 935       , lir_log10
</pre>
<hr />
<pre>
2090     }
2091   }
2092   void volatile_move(LIR_Opr src, LIR_Opr dst, BasicType type, CodeEmitInfo* info = NULL, LIR_PatchCode patch_code = lir_patch_none) { append(new LIR_Op1(lir_move, src, dst, type, patch_code, info, lir_move_volatile)); }
2093 
2094   void oop2reg  (jobject o, LIR_Opr reg)         { assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),    reg));   }
2095   void oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info);
2096 
2097   void metadata2reg  (Metadata* o, LIR_Opr reg)  { assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;); append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg));   }
2098   void klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info);
2099 
2100   void return_op(LIR_Opr result)                 { append(new LIR_Op1(lir_return, result)); }
2101 
2102   void safepoint(LIR_Opr tmp, CodeEmitInfo* info)  { append(new LIR_Op1(lir_safepoint, tmp, info)); }
2103 
2104   void convert(Bytecodes::Code code, LIR_Opr left, LIR_Opr dst, ConversionStub* stub = NULL/*, bool is_32bit = false*/) { append(new LIR_OpConvert(code, left, dst, stub)); }
2105 
2106   void logical_and (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_and,  left, right, dst)); }
2107   void logical_or  (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_or,   left, right, dst)); }
2108   void logical_xor (LIR_Opr left, LIR_Opr right, LIR_Opr dst) { append(new LIR_Op2(lir_logic_xor,  left, right, dst)); }
2109 



2110   void null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null = false);
2111   void throw_exception(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2112     append(new LIR_Op2(lir_throw, exceptionPC, exceptionOop, LIR_OprFact::illegalOpr, info));
2113   }
2114   void unwind_exception(LIR_Opr exceptionOop) {
2115     append(new LIR_Op1(lir_unwind, exceptionOop));
2116   }
2117 
2118   void push(LIR_Opr opr)                                   { append(new LIR_Op1(lir_push, opr)); }
2119   void pop(LIR_Opr reg)                                    { append(new LIR_Op1(lir_pop,  reg)); }
2120 
2121   void cmp(LIR_Condition condition, LIR_Opr left, LIR_Opr right, CodeEmitInfo* info = NULL) {
2122     append(new LIR_Op2(lir_cmp, condition, left, right, info));
2123   }
2124   void cmp(LIR_Condition condition, LIR_Opr left, int right, CodeEmitInfo* info = NULL) {
2125     cmp(condition, left, LIR_OprFact::intConst(right), info);
2126   }
2127 
2128   void cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info);
2129   void cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info);
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIR.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LinearScan.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_CFGPrinter.hpp&quot;
  27 #include &quot;c1/c1_CodeStubs.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_FrameMap.hpp&quot;
  30 #include &quot;c1/c1_IR.hpp&quot;
  31 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  32 #include &quot;c1/c1_LinearScan.hpp&quot;
  33 #include &quot;c1/c1_ValueStack.hpp&quot;
  34 #include &quot;code/vmreg.inline.hpp&quot;
  35 #include &quot;runtime/timerTrace.hpp&quot;
  36 #include &quot;utilities/bitMap.inline.hpp&quot;
  37 
  38 #ifndef PRODUCT
  39 
  40   static LinearScanStatistic _stat_before_alloc;
  41   static LinearScanStatistic _stat_after_asign;
  42   static LinearScanStatistic _stat_final;
  43 
  44   static LinearScanTimers _total_timer;
  45 
  46   // helper macro for short definition of timer
  47   #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(&quot;&quot;, _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);
  48 
  49   // helper macro for short definition of trace-output inside code
  50   #define TRACE_LINEAR_SCAN(level, code)       \
  51     if (TraceLinearScanLevel &gt;= level) {       \
  52       code;                                    \
  53     }
  54 
  55 #else
  56 
  57   #define TIME_LINEAR_SCAN(timer_name)
  58   #define TRACE_LINEAR_SCAN(level, code)
  59 
  60 #endif
  61 
  62 // Map BasicType to spill size in 32-bit words, matching VMReg&#39;s notion of words
  63 #ifdef _LP64
  64 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};
  65 #else
  66 static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};
  67 #endif
  68 
  69 
  70 // Implementation of LinearScan
  71 
  72 LinearScan::LinearScan(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
  73  : _compilation(ir-&gt;compilation())
  74  , _ir(ir)
  75  , _gen(gen)
  76  , _frame_map(frame_map)
  77  , _cached_blocks(*ir-&gt;linear_scan_order())
  78  , _num_virtual_regs(gen-&gt;max_virtual_register_number())
  79  , _has_fpu_registers(false)
  80  , _num_calls(-1)
  81  , _max_spills(0)
  82  , _unused_spill_slot(-1)
  83  , _intervals(0)   // initialized later with correct length
  84  , _new_intervals_from_allocation(NULL)
  85  , _sorted_intervals(NULL)
  86  , _needs_full_resort(false)
  87  , _lir_ops(0)     // initialized later with correct length
  88  , _block_of_op(0) // initialized later with correct length
  89  , _has_info(0)
  90  , _has_call(0)
  91  , _interval_in_loop(0)  // initialized later with correct length
  92  , _scope_value_cache(0) // initialized later with correct length
  93 #ifdef IA32
  94  , _fpu_stack_allocator(NULL)
  95 #endif
  96 {
  97   assert(this-&gt;ir() != NULL,          &quot;check if valid&quot;);
  98   assert(this-&gt;compilation() != NULL, &quot;check if valid&quot;);
  99   assert(this-&gt;gen() != NULL,         &quot;check if valid&quot;);
 100   assert(this-&gt;frame_map() != NULL,   &quot;check if valid&quot;);
 101 }
 102 
 103 
 104 // ********** functions for converting LIR-Operands to register numbers
 105 //
 106 // Emulate a flat register file comprising physical integer registers,
 107 // physical floating-point registers and virtual registers, in that order.
 108 // Virtual registers already have appropriate numbers, since V0 is
 109 // the number of physical registers.
 110 // Returns -1 for hi word if opr is a single word operand.
 111 //
 112 // Note: the inverse operation (calculating an operand for register numbers)
 113 //       is done in calc_operand_for_interval()
 114 
 115 int LinearScan::reg_num(LIR_Opr opr) {
 116   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 117 
 118   if (opr-&gt;is_virtual_register()) {
 119     assert(opr-&gt;vreg_number() &gt;= nof_regs, &quot;found a virtual register with a fixed-register number&quot;);
 120     return opr-&gt;vreg_number();
 121   } else if (opr-&gt;is_single_cpu()) {
 122     return opr-&gt;cpu_regnr();
 123   } else if (opr-&gt;is_double_cpu()) {
 124     return opr-&gt;cpu_regnrLo();
 125 #ifdef X86
 126   } else if (opr-&gt;is_single_xmm()) {
 127     return opr-&gt;fpu_regnr() + pd_first_xmm_reg;
 128   } else if (opr-&gt;is_double_xmm()) {
 129     return opr-&gt;fpu_regnrLo() + pd_first_xmm_reg;
 130 #endif
 131   } else if (opr-&gt;is_single_fpu()) {
 132     return opr-&gt;fpu_regnr() + pd_first_fpu_reg;
 133   } else if (opr-&gt;is_double_fpu()) {
 134     return opr-&gt;fpu_regnrLo() + pd_first_fpu_reg;
 135   } else {
 136     ShouldNotReachHere();
 137     return -1;
 138   }
 139 }
 140 
 141 int LinearScan::reg_numHi(LIR_Opr opr) {
 142   assert(opr-&gt;is_register(), &quot;should not call this otherwise&quot;);
 143 
 144   if (opr-&gt;is_virtual_register()) {
 145     return -1;
 146   } else if (opr-&gt;is_single_cpu()) {
 147     return -1;
 148   } else if (opr-&gt;is_double_cpu()) {
 149     return opr-&gt;cpu_regnrHi();
 150 #ifdef X86
 151   } else if (opr-&gt;is_single_xmm()) {
 152     return -1;
 153   } else if (opr-&gt;is_double_xmm()) {
 154     return -1;
 155 #endif
 156   } else if (opr-&gt;is_single_fpu()) {
 157     return -1;
 158   } else if (opr-&gt;is_double_fpu()) {
 159     return opr-&gt;fpu_regnrHi() + pd_first_fpu_reg;
 160   } else {
 161     ShouldNotReachHere();
 162     return -1;
 163   }
 164 }
 165 
 166 
 167 // ********** functions for classification of intervals
 168 
 169 bool LinearScan::is_precolored_interval(const Interval* i) {
 170   return i-&gt;reg_num() &lt; LinearScan::nof_regs;
 171 }
 172 
 173 bool LinearScan::is_virtual_interval(const Interval* i) {
 174   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 175 }
 176 
 177 bool LinearScan::is_precolored_cpu_interval(const Interval* i) {
 178   return i-&gt;reg_num() &lt; LinearScan::nof_cpu_regs;
 179 }
 180 
 181 bool LinearScan::is_virtual_cpu_interval(const Interval* i) {
 182 #if defined(__SOFTFP__) || defined(E500V2)
 183   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base;
 184 #else
 185   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() != T_FLOAT &amp;&amp; i-&gt;type() != T_DOUBLE);
 186 #endif // __SOFTFP__ or E500V2
 187 }
 188 
 189 bool LinearScan::is_precolored_fpu_interval(const Interval* i) {
 190   return i-&gt;reg_num() &gt;= LinearScan::nof_cpu_regs &amp;&amp; i-&gt;reg_num() &lt; LinearScan::nof_regs;
 191 }
 192 
 193 bool LinearScan::is_virtual_fpu_interval(const Interval* i) {
 194 #if defined(__SOFTFP__) || defined(E500V2)
 195   return false;
 196 #else
 197   return i-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; (i-&gt;type() == T_FLOAT || i-&gt;type() == T_DOUBLE);
 198 #endif // __SOFTFP__ or E500V2
 199 }
 200 
 201 bool LinearScan::is_in_fpu_register(const Interval* i) {
 202   // fixed intervals not needed for FPU stack allocation
 203   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; pd_first_fpu_reg &lt;= i-&gt;assigned_reg() &amp;&amp; i-&gt;assigned_reg() &lt;= pd_last_fpu_reg;
 204 }
 205 
 206 bool LinearScan::is_oop_interval(const Interval* i) {
 207   // fixed intervals never contain oops
 208   return i-&gt;reg_num() &gt;= nof_regs &amp;&amp; i-&gt;type() == T_OBJECT;
 209 }
 210 
 211 
 212 // ********** General helper functions
 213 
 214 // compute next unused stack index that can be used for spilling
 215 int LinearScan::allocate_spill_slot(bool double_word) {
 216   int spill_slot;
 217   if (double_word) {
 218     if ((_max_spills &amp; 1) == 1) {
 219       // alignment of double-word values
 220       // the hole because of the alignment is filled with the next single-word value
 221       assert(_unused_spill_slot == -1, &quot;wasting a spill slot&quot;);
 222       _unused_spill_slot = _max_spills;
 223       _max_spills++;
 224     }
 225     spill_slot = _max_spills;
 226     _max_spills += 2;
 227 
 228   } else if (_unused_spill_slot != -1) {
 229     // re-use hole that was the result of a previous double-word alignment
 230     spill_slot = _unused_spill_slot;
 231     _unused_spill_slot = -1;
 232 
 233   } else {
 234     spill_slot = _max_spills;
 235     _max_spills++;
 236   }
 237 
 238   int result = spill_slot + LinearScan::nof_regs + frame_map()-&gt;argcount();
 239 
 240   // if too many slots used, bailout compilation.
 241   if (result &gt; 2000) {
 242     bailout(&quot;too many stack slots used&quot;);
 243   }
 244 
 245   return result;
 246 }
 247 
 248 void LinearScan::assign_spill_slot(Interval* it) {
 249   // assign the canonical spill slot of the parent (if a part of the interval
 250   // is already spilled) or allocate a new spill slot
 251   if (it-&gt;canonical_spill_slot() &gt;= 0) {
 252     it-&gt;assign_reg(it-&gt;canonical_spill_slot());
 253   } else {
 254     int spill = allocate_spill_slot(type2spill_size[it-&gt;type()] == 2);
 255     it-&gt;set_canonical_spill_slot(spill);
 256     it-&gt;assign_reg(spill);
 257   }
 258 }
 259 
 260 void LinearScan::propagate_spill_slots() {
 261   if (!frame_map()-&gt;finalize_frame(max_spills())) {
 262     bailout(&quot;frame too large&quot;);
 263   }
 264 }
 265 
 266 // create a new interval with a predefined reg_num
 267 // (only used for parent intervals that are created during the building phase)
 268 Interval* LinearScan::create_interval(int reg_num) {
 269   assert(_intervals.at(reg_num) == NULL, &quot;overwriting exisiting interval&quot;);
 270 
 271   Interval* interval = new Interval(reg_num);
 272   _intervals.at_put(reg_num, interval);
 273 
 274   // assign register number for precolored intervals
 275   if (reg_num &lt; LIR_OprDesc::vreg_base) {
 276     interval-&gt;assign_reg(reg_num);
 277   }
 278   return interval;
 279 }
 280 
 281 // assign a new reg_num to the interval and append it to the list of intervals
 282 // (only used for child intervals that are created during register allocation)
 283 void LinearScan::append_interval(Interval* it) {
 284   it-&gt;set_reg_num(_intervals.length());
 285   _intervals.append(it);
 286   IntervalList* new_intervals = _new_intervals_from_allocation;
 287   if (new_intervals == NULL) {
 288     new_intervals = _new_intervals_from_allocation = new IntervalList();
 289   }
 290   new_intervals-&gt;append(it);
 291 }
 292 
 293 // copy the vreg-flags if an interval is split
 294 void LinearScan::copy_register_flags(Interval* from, Interval* to) {
 295   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::byte_reg)) {
 296     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::byte_reg);
 297   }
 298   if (gen()-&gt;is_vreg_flag_set(from-&gt;reg_num(), LIRGenerator::callee_saved)) {
 299     gen()-&gt;set_vreg_flag(to-&gt;reg_num(), LIRGenerator::callee_saved);
 300   }
 301 
 302   // Note: do not copy the must_start_in_memory flag because it is not necessary for child
 303   //       intervals (only the very beginning of the interval must be in memory)
 304 }
 305 
 306 
 307 // ********** spill move optimization
 308 // eliminate moves from register to stack if stack slot is known to be correct
 309 
 310 // called during building of intervals
 311 void LinearScan::change_spill_definition_pos(Interval* interval, int def_pos) {
 312   assert(interval-&gt;is_split_parent(), &quot;can only be called for split parents&quot;);
 313 
 314   switch (interval-&gt;spill_state()) {
 315     case noDefinitionFound:
 316       assert(interval-&gt;spill_definition_pos() == -1, &quot;must no be set before&quot;);
 317       interval-&gt;set_spill_definition_pos(def_pos);
 318       interval-&gt;set_spill_state(oneDefinitionFound);
 319       break;
 320 
 321     case oneDefinitionFound:
 322       assert(def_pos &lt;= interval-&gt;spill_definition_pos(), &quot;positions are processed in reverse order when intervals are created&quot;);
 323       if (def_pos &lt; interval-&gt;spill_definition_pos() - 2) {
 324         // second definition found, so no spill optimization possible for this interval
 325         interval-&gt;set_spill_state(noOptimization);
 326       } else {
 327         // two consecutive definitions (because of two-operand LIR form)
 328         assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval-&gt;spill_definition_pos()), &quot;block must be equal&quot;);
 329       }
 330       break;
 331 
 332     case noOptimization:
 333       // nothing to do
 334       break;
 335 
 336     default:
 337       assert(false, &quot;other states not allowed at this time&quot;);
 338   }
 339 }
 340 
 341 // called during register allocation
 342 void LinearScan::change_spill_state(Interval* interval, int spill_pos) {
 343   switch (interval-&gt;spill_state()) {
 344     case oneDefinitionFound: {
 345       int def_loop_depth = block_of_op_with_id(interval-&gt;spill_definition_pos())-&gt;loop_depth();
 346       int spill_loop_depth = block_of_op_with_id(spill_pos)-&gt;loop_depth();
 347 
 348       if (def_loop_depth &lt; spill_loop_depth) {
 349         // the loop depth of the spilling position is higher then the loop depth
 350         // at the definition of the interval -&gt; move write to memory out of loop
 351         // by storing at definitin of the interval
 352         interval-&gt;set_spill_state(storeAtDefinition);
 353       } else {
 354         // the interval is currently spilled only once, so for now there is no
 355         // reason to store the interval at the definition
 356         interval-&gt;set_spill_state(oneMoveInserted);
 357       }
 358       break;
 359     }
 360 
 361     case oneMoveInserted: {
 362       // the interval is spilled more then once, so it is better to store it to
 363       // memory at the definition
 364       interval-&gt;set_spill_state(storeAtDefinition);
 365       break;
 366     }
 367 
 368     case storeAtDefinition:
 369     case startInMemory:
 370     case noOptimization:
 371     case noDefinitionFound:
 372       // nothing to do
 373       break;
 374 
 375     default:
 376       assert(false, &quot;other states not allowed at this time&quot;);
 377   }
 378 }
 379 
 380 
 381 bool LinearScan::must_store_at_definition(const Interval* i) {
 382   return i-&gt;is_split_parent() &amp;&amp; i-&gt;spill_state() == storeAtDefinition;
 383 }
 384 
 385 // called once before asignment of register numbers
 386 void LinearScan::eliminate_spill_moves() {
 387   TIME_LINEAR_SCAN(timer_eliminate_spill_moves);
 388   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;***** Eliminating unnecessary spill moves&quot;));
 389 
 390   // collect all intervals that must be stored after their definion.
 391   // the list is sorted by Interval::spill_definition_pos
 392   Interval* interval;
 393   Interval* temp_list;
 394   create_unhandled_lists(&amp;interval, &amp;temp_list, must_store_at_definition, NULL);
 395 
 396 #ifdef ASSERT
 397   Interval* prev = NULL;
 398   Interval* temp = interval;
 399   while (temp != Interval::end()) {
 400     assert(temp-&gt;spill_definition_pos() &gt; 0, &quot;invalid spill definition pos&quot;);
 401     if (prev != NULL) {
 402       assert(temp-&gt;from() &gt;= prev-&gt;from(), &quot;intervals not sorted&quot;);
 403       assert(temp-&gt;spill_definition_pos() &gt;= prev-&gt;spill_definition_pos(), &quot;when intervals are sorted by from, then they must also be sorted by spill_definition_pos&quot;);
 404     }
 405 
 406     assert(temp-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;interval has no spill slot assigned&quot;);
 407     assert(temp-&gt;spill_definition_pos() &gt;= temp-&gt;from(), &quot;invalid order&quot;);
 408     assert(temp-&gt;spill_definition_pos() &lt;= temp-&gt;from() + 2, &quot;only intervals defined once at their start-pos can be optimized&quot;);
 409 
 410     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;interval %d (from %d to %d) must be stored at %d&quot;, temp-&gt;reg_num(), temp-&gt;from(), temp-&gt;to(), temp-&gt;spill_definition_pos()));
 411 
 412     temp = temp-&gt;next();
 413   }
 414 #endif
 415 
 416   LIR_InsertionBuffer insertion_buffer;
 417   int num_blocks = block_count();
 418   for (int i = 0; i &lt; num_blocks; i++) {
 419     BlockBegin* block = block_at(i);
 420     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 421     int         num_inst = instructions-&gt;length();
 422     bool        has_new = false;
 423 
 424     // iterate all instructions of the block. skip the first because it is always a label
 425     for (int j = 1; j &lt; num_inst; j++) {
 426       LIR_Op* op = instructions-&gt;at(j);
 427       int op_id = op-&gt;id();
 428 
 429       if (op_id == -1) {
 430         // remove move from register to stack if the stack slot is guaranteed to be correct.
 431         // only moves that have been inserted by LinearScan can be removed.
 432         assert(op-&gt;code() == lir_move, &quot;only moves can have a op_id of -1&quot;);
 433         assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
 434         assert(op-&gt;as_Op1()-&gt;result_opr()-&gt;is_virtual(), &quot;LinearScan inserts only moves to virtual registers&quot;);
 435 
 436         LIR_Op1* op1 = (LIR_Op1*)op;
 437         Interval* interval = interval_at(op1-&gt;result_opr()-&gt;vreg_number());
 438 
 439         if (interval-&gt;assigned_reg() &gt;= LinearScan::nof_regs &amp;&amp; interval-&gt;always_in_memory()) {
 440           // move target is a stack slot that is always correct, so eliminate instruction
 441           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;eliminating move from interval %d to %d&quot;, op1-&gt;in_opr()-&gt;vreg_number(), op1-&gt;result_opr()-&gt;vreg_number()));
 442           instructions-&gt;at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
 443         }
 444 
 445       } else {
 446         // insert move from register to stack just after the beginning of the interval
 447         assert(interval == Interval::end() || interval-&gt;spill_definition_pos() &gt;= op_id, &quot;invalid order&quot;);
 448         assert(interval == Interval::end() || (interval-&gt;is_split_parent() &amp;&amp; interval-&gt;spill_state() == storeAtDefinition), &quot;invalid interval&quot;);
 449 
 450         while (interval != Interval::end() &amp;&amp; interval-&gt;spill_definition_pos() == op_id) {
 451           if (!has_new) {
 452             // prepare insertion buffer (appended when all instructions of the block are processed)
 453             insertion_buffer.init(block-&gt;lir());
 454             has_new = true;
 455           }
 456 
 457           LIR_Opr from_opr = operand_for_interval(interval);
 458           LIR_Opr to_opr = canonical_spill_opr(interval);
 459           assert(from_opr-&gt;is_fixed_cpu() || from_opr-&gt;is_fixed_fpu(), &quot;from operand must be a register&quot;);
 460           assert(to_opr-&gt;is_stack(), &quot;to operand must be a stack slot&quot;);
 461 
 462           insertion_buffer.move(j, from_opr, to_opr);
 463           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting move after definition of interval %d to stack slot %d at op_id %d&quot;, interval-&gt;reg_num(), interval-&gt;canonical_spill_slot() - LinearScan::nof_regs, op_id));
 464 
 465           interval = interval-&gt;next();
 466         }
 467       }
 468     } // end of instruction iteration
 469 
 470     if (has_new) {
 471       block-&gt;lir()-&gt;append(&amp;insertion_buffer);
 472     }
 473   } // end of block iteration
 474 
 475   assert(interval == Interval::end(), &quot;missed an interval&quot;);
 476 }
 477 
 478 
 479 // ********** Phase 1: number all instructions in all blocks
 480 // Compute depth-first and linear scan block orders, and number LIR_Op nodes for linear scan.
 481 
 482 void LinearScan::number_instructions() {
 483   {
 484     // dummy-timer to measure the cost of the timer itself
 485     // (this time is then subtracted from all other timers to get the real value)
 486     TIME_LINEAR_SCAN(timer_do_nothing);
 487   }
 488   TIME_LINEAR_SCAN(timer_number_instructions);
 489 
 490   // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
 491   int num_blocks = block_count();
 492   int num_instructions = 0;
 493   int i;
 494   for (i = 0; i &lt; num_blocks; i++) {
 495     num_instructions += block_at(i)-&gt;lir()-&gt;instructions_list()-&gt;length();
 496   }
 497 
 498   // initialize with correct length
 499   _lir_ops = LIR_OpArray(num_instructions, num_instructions, NULL);
 500   _block_of_op = BlockBeginArray(num_instructions, num_instructions, NULL);
 501 
 502   int op_id = 0;
 503   int idx = 0;
 504 
 505   for (i = 0; i &lt; num_blocks; i++) {
 506     BlockBegin* block = block_at(i);
 507     block-&gt;set_first_lir_instruction_id(op_id);
 508     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 509 
 510     int num_inst = instructions-&gt;length();
 511     for (int j = 0; j &lt; num_inst; j++) {
 512       LIR_Op* op = instructions-&gt;at(j);
 513       op-&gt;set_id(op_id);
 514 
 515       _lir_ops.at_put(idx, op);
 516       _block_of_op.at_put(idx, block);
 517       assert(lir_op_with_id(op_id) == op, &quot;must match&quot;);
 518 
 519       idx++;
 520       op_id += 2; // numbering of lir_ops by two
 521     }
 522     block-&gt;set_last_lir_instruction_id(op_id - 2);
 523   }
 524   assert(idx == num_instructions, &quot;must match&quot;);
 525   assert(idx * 2 == op_id, &quot;must match&quot;);
 526 
 527   _has_call.initialize(num_instructions);
 528   _has_info.initialize(num_instructions);
 529 }
 530 
 531 
 532 // ********** Phase 2: compute local live sets separately for each block
 533 // (sets live_gen and live_kill for each block)
 534 
 535 void LinearScan::set_live_gen_kill(Value value, LIR_Op* op, BitMap&amp; live_gen, BitMap&amp; live_kill) {
 536   LIR_Opr opr = value-&gt;operand();
 537   Constant* con = value-&gt;as_Constant();
 538 
 539   // check some asumptions about debug information
 540   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this local is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 541   assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands&quot;);
 542   assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
 543 
 544   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 545     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 546     int reg = opr-&gt;vreg_number();
 547     if (!live_kill.at(reg)) {
 548       live_gen.set_bit(reg);
 549       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for value %c%d, LIR op_id %d, register number %d&quot;, value-&gt;type()-&gt;tchar(), value-&gt;id(), op-&gt;id(), reg));
 550     }
 551   }
 552 }
 553 
 554 
 555 void LinearScan::compute_local_live_sets() {
 556   TIME_LINEAR_SCAN(timer_compute_local_live_sets);
 557 
 558   int  num_blocks = block_count();
 559   int  live_size = live_set_size();
 560   bool local_has_fpu_registers = false;
 561   int  local_num_calls = 0;
 562   LIR_OpVisitState visitor;
 563 
 564   BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
 565 
 566   // iterate all blocks
 567   for (int i = 0; i &lt; num_blocks; i++) {
 568     BlockBegin* block = block_at(i);
 569 
 570     ResourceBitMap live_gen(live_size);
 571     ResourceBitMap live_kill(live_size);
 572 
 573     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
 574       // Phi functions at the begin of an exception handler are
 575       // implicitly defined (= killed) at the beginning of the block.
 576       for_each_phi_fun(block, phi,
 577         if (!phi-&gt;is_illegal()) { live_kill.set_bit(phi-&gt;operand()-&gt;vreg_number()); }
 578       );
 579     }
 580 
 581     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
 582     int num_inst = instructions-&gt;length();
 583 
 584     // iterate all instructions of the block. skip the first because it is always a label
 585     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
 586     for (int j = 1; j &lt; num_inst; j++) {
 587       LIR_Op* op = instructions-&gt;at(j);
 588 
 589       // visit operation to collect all operands
 590       visitor.visit(op);
 591 
 592       if (visitor.has_call()) {
 593         _has_call.set_bit(op-&gt;id() &gt;&gt; 1);
 594         local_num_calls++;
 595       }
 596       if (visitor.info_count() &gt; 0) {
 597         _has_info.set_bit(op-&gt;id() &gt;&gt; 1);
 598       }
 599 
 600       // iterate input operands of instruction
 601       int k, n, reg;
 602       n = visitor.opr_count(LIR_OpVisitState::inputMode);
 603       for (k = 0; k &lt; n; k++) {
 604         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
 605         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 606 
 607         if (opr-&gt;is_virtual_register()) {
 608           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 609           reg = opr-&gt;vreg_number();
 610           if (!live_kill.at(reg)) {
 611             live_gen.set_bit(reg);
 612             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;  Setting live_gen for register %d at instruction %d&quot;, reg, op-&gt;id()));
 613           }
 614           if (block-&gt;loop_index() &gt;= 0) {
 615             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 616           }
 617           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 618         }
 619 
 620 #ifdef ASSERT
 621         // fixed intervals are never live at block boundaries, so
 622         // they need not be processed in live sets.
 623         // this is checked by these assertions to be sure about it.
 624         // the entry block may have incoming values in registers, which is ok.
 625         if (!opr-&gt;is_virtual_register() &amp;&amp; block != ir()-&gt;start()) {
 626           reg = reg_num(opr);
 627           if (is_processed_reg_num(reg)) {
 628             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 629           }
 630           reg = reg_numHi(opr);
 631           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 632             assert(live_kill.at(reg), &quot;using fixed register that is not defined in this block&quot;);
 633           }
 634         }
 635 #endif
 636       }
 637 
 638       // Add uses of live locals from interpreter&#39;s point of view for proper debug information generation
 639       n = visitor.info_count();
 640       for (k = 0; k &lt; n; k++) {
 641         CodeEmitInfo* info = visitor.info_at(k);
 642         ValueStack* stack = info-&gt;stack();
 643         for_each_state_value(stack, value,
 644           set_live_gen_kill(value, op, live_gen, live_kill)
 645         );
 646       }
 647 
 648       // iterate temp operands of instruction
 649       n = visitor.opr_count(LIR_OpVisitState::tempMode);
 650       for (k = 0; k &lt; n; k++) {
 651         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
 652         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 653 
 654         if (opr-&gt;is_virtual_register()) {
 655           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 656           reg = opr-&gt;vreg_number();
 657           live_kill.set_bit(reg);
 658           if (block-&gt;loop_index() &gt;= 0) {
 659             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 660           }
 661           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 662         }
 663 
 664 #ifdef ASSERT
 665         // fixed intervals are never live at block boundaries, so
 666         // they need not be processed in live sets
 667         // process them only in debug mode so that this can be checked
 668         if (!opr-&gt;is_virtual_register()) {
 669           reg = reg_num(opr);
 670           if (is_processed_reg_num(reg)) {
 671             live_kill.set_bit(reg_num(opr));
 672           }
 673           reg = reg_numHi(opr);
 674           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 675             live_kill.set_bit(reg);
 676           }
 677         }
 678 #endif
 679       }
 680 
 681       // iterate output operands of instruction
 682       n = visitor.opr_count(LIR_OpVisitState::outputMode);
 683       for (k = 0; k &lt; n; k++) {
 684         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
 685         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
 686 
 687         if (opr-&gt;is_virtual_register()) {
 688           assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 689           reg = opr-&gt;vreg_number();
 690           live_kill.set_bit(reg);
 691           if (block-&gt;loop_index() &gt;= 0) {
 692             local_interval_in_loop.set_bit(reg, block-&gt;loop_index());
 693           }
 694           local_has_fpu_registers = local_has_fpu_registers || opr-&gt;is_virtual_fpu();
 695         }
 696 
 697 #ifdef ASSERT
 698         // fixed intervals are never live at block boundaries, so
 699         // they need not be processed in live sets
 700         // process them only in debug mode so that this can be checked
 701         if (!opr-&gt;is_virtual_register()) {
 702           reg = reg_num(opr);
 703           if (is_processed_reg_num(reg)) {
 704             live_kill.set_bit(reg_num(opr));
 705           }
 706           reg = reg_numHi(opr);
 707           if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 708             live_kill.set_bit(reg);
 709           }
 710         }
 711 #endif
 712       }
 713     } // end of instruction iteration
 714 
 715     block-&gt;set_live_gen (live_gen);
 716     block-&gt;set_live_kill(live_kill);
 717     block-&gt;set_live_in  (ResourceBitMap(live_size));
 718     block-&gt;set_live_out (ResourceBitMap(live_size));
 719 
 720     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_gen  B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_gen()));
 721     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;live_kill B%d &quot;, block-&gt;block_id()); print_bitmap(block-&gt;live_kill()));
 722   } // end of block iteration
 723 
 724   // propagate local calculated information into LinearScan object
 725   _has_fpu_registers = local_has_fpu_registers;
 726   compilation()-&gt;set_has_fpu_code(local_has_fpu_registers);
 727 
 728   _num_calls = local_num_calls;
 729   _interval_in_loop = local_interval_in_loop;
 730 }
 731 
 732 
 733 // ********** Phase 3: perform a backward dataflow analysis to compute global live sets
 734 // (sets live_in and live_out for each block)
 735 
 736 void LinearScan::compute_global_live_sets() {
 737   TIME_LINEAR_SCAN(timer_compute_global_live_sets);
 738 
 739   int  num_blocks = block_count();
 740   bool change_occurred;
 741   bool change_occurred_in_block;
 742   int  iteration_count = 0;
 743   ResourceBitMap live_out(live_set_size()); // scratch set for calculations
 744 
 745   // Perform a backward dataflow analysis to compute live_out and live_in for each block.
 746   // The loop is executed until a fixpoint is reached (no changes in an iteration)
 747   // Exception handlers must be processed because not all live values are
 748   // present in the state array, e.g. because of global value numbering
 749   do {
 750     change_occurred = false;
 751 
 752     // iterate all blocks in reverse order
 753     for (int i = num_blocks - 1; i &gt;= 0; i--) {
 754       BlockBegin* block = block_at(i);
 755 
 756       change_occurred_in_block = false;
 757 
 758       // live_out(block) is the union of live_in(sux), for successors sux of block
 759       int n = block-&gt;number_of_sux();
 760       int e = block-&gt;number_of_exception_handlers();
 761       if (n + e &gt; 0) {
 762         // block has successors
 763         if (n &gt; 0) {
 764           live_out.set_from(block-&gt;sux_at(0)-&gt;live_in());
 765           for (int j = 1; j &lt; n; j++) {
 766             live_out.set_union(block-&gt;sux_at(j)-&gt;live_in());
 767           }
 768         } else {
 769           live_out.clear();
 770         }
 771         for (int j = 0; j &lt; e; j++) {
 772           live_out.set_union(block-&gt;exception_handler_at(j)-&gt;live_in());
 773         }
 774 
 775         if (!block-&gt;live_out().is_same(live_out)) {
 776           // A change occurred.  Swap the old and new live out sets to avoid copying.
 777           ResourceBitMap temp = block-&gt;live_out();
 778           block-&gt;set_live_out(live_out);
 779           live_out = temp;
 780 
 781           change_occurred = true;
 782           change_occurred_in_block = true;
 783         }
 784       }
 785 
 786       if (iteration_count == 0 || change_occurred_in_block) {
 787         // live_in(block) is the union of live_gen(block) with (live_out(block) &amp; !live_kill(block))
 788         // note: live_in has to be computed only in first iteration or if live_out has changed!
 789         ResourceBitMap live_in = block-&gt;live_in();
 790         live_in.set_from(block-&gt;live_out());
 791         live_in.set_difference(block-&gt;live_kill());
 792         live_in.set_union(block-&gt;live_gen());
 793       }
 794 
 795 #ifndef PRODUCT
 796       if (TraceLinearScanLevel &gt;= 4) {
 797         char c = &#39; &#39;;
 798         if (iteration_count == 0 || change_occurred_in_block) {
 799           c = &#39;*&#39;;
 800         }
 801         tty-&gt;print(&quot;(%d) live_in%c  B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_in());
 802         tty-&gt;print(&quot;(%d) live_out%c B%d &quot;, iteration_count, c, block-&gt;block_id()); print_bitmap(block-&gt;live_out());
 803       }
 804 #endif
 805     }
 806     iteration_count++;
 807 
 808     if (change_occurred &amp;&amp; iteration_count &gt; 50) {
 809       BAILOUT(&quot;too many iterations in compute_global_live_sets&quot;);
 810     }
 811   } while (change_occurred);
 812 
 813 
 814 #ifdef ASSERT
 815   // check that fixed intervals are not live at block boundaries
 816   // (live set must be empty at fixed intervals)
 817   for (int i = 0; i &lt; num_blocks; i++) {
 818     BlockBegin* block = block_at(i);
 819     for (int j = 0; j &lt; LIR_OprDesc::vreg_base; j++) {
 820       assert(block-&gt;live_in().at(j)  == false, &quot;live_in  set of fixed register must be empty&quot;);
 821       assert(block-&gt;live_out().at(j) == false, &quot;live_out set of fixed register must be empty&quot;);
 822       assert(block-&gt;live_gen().at(j) == false, &quot;live_gen set of fixed register must be empty&quot;);
 823     }
 824   }
 825 #endif
 826 
 827   // check that the live_in set of the first block is empty
 828   ResourceBitMap live_in_args(ir()-&gt;start()-&gt;live_in().size());
 829   if (!ir()-&gt;start()-&gt;live_in().is_same(live_in_args)) {
 830 #ifdef ASSERT
 831     tty-&gt;print_cr(&quot;Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)&quot;);
 832     tty-&gt;print_cr(&quot;affected registers:&quot;);
 833     print_bitmap(ir()-&gt;start()-&gt;live_in());
 834 
 835     // print some additional information to simplify debugging
 836     for (unsigned int i = 0; i &lt; ir()-&gt;start()-&gt;live_in().size(); i++) {
 837       if (ir()-&gt;start()-&gt;live_in().at(i)) {
 838         Instruction* instr = gen()-&gt;instruction_for_vreg(i);
 839         tty-&gt;print_cr(&quot;* vreg %d (HIR instruction %c%d)&quot;, i, instr == NULL ? &#39; &#39; : instr-&gt;type()-&gt;tchar(), instr == NULL ? 0 : instr-&gt;id());
 840 
 841         for (int j = 0; j &lt; num_blocks; j++) {
 842           BlockBegin* block = block_at(j);
 843           if (block-&gt;live_gen().at(i)) {
 844             tty-&gt;print_cr(&quot;  used in block B%d&quot;, block-&gt;block_id());
 845           }
 846           if (block-&gt;live_kill().at(i)) {
 847             tty-&gt;print_cr(&quot;  defined in block B%d&quot;, block-&gt;block_id());
 848           }
 849         }
 850       }
 851     }
 852 
 853 #endif
 854     // when this fails, virtual registers are used before they are defined.
 855     assert(false, &quot;live_in set of first block must be empty&quot;);
 856     // bailout of if this occurs in product mode.
 857     bailout(&quot;live_in set of first block not empty&quot;);
 858   }
 859 }
 860 
 861 
 862 // ********** Phase 4: build intervals
 863 // (fills the list _intervals)
 864 
 865 void LinearScan::add_use(Value value, int from, int to, IntervalUseKind use_kind) {
 866   assert(!value-&gt;type()-&gt;is_illegal(), &quot;if this value is used by the interpreter it shouldn&#39;t be of indeterminate type&quot;);
 867   LIR_Opr opr = value-&gt;operand();
 868   Constant* con = value-&gt;as_Constant();
 869 
 870   if ((con == NULL || con-&gt;is_pinned()) &amp;&amp; opr-&gt;is_register()) {
 871     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 872     add_use(opr, from, to, use_kind);
 873   }
 874 }
 875 
 876 
 877 void LinearScan::add_def(LIR_Opr opr, int def_pos, IntervalUseKind use_kind) {
 878   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; def &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; def_pos %d (%d)&quot;, def_pos, use_kind));
 879   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 880 
 881   if (opr-&gt;is_virtual_register()) {
 882     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 883     add_def(opr-&gt;vreg_number(), def_pos, use_kind, opr-&gt;type_register());
 884 
 885   } else {
 886     int reg = reg_num(opr);
 887     if (is_processed_reg_num(reg)) {
 888       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 889     }
 890     reg = reg_numHi(opr);
 891     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 892       add_def(reg, def_pos, use_kind, opr-&gt;type_register());
 893     }
 894   }
 895 }
 896 
 897 void LinearScan::add_use(LIR_Opr opr, int from, int to, IntervalUseKind use_kind) {
 898   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; use &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; from %d to %d (%d)&quot;, from, to, use_kind));
 899   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 900 
 901   if (opr-&gt;is_virtual_register()) {
 902     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 903     add_use(opr-&gt;vreg_number(), from, to, use_kind, opr-&gt;type_register());
 904 
 905   } else {
 906     int reg = reg_num(opr);
 907     if (is_processed_reg_num(reg)) {
 908       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 909     }
 910     reg = reg_numHi(opr);
 911     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 912       add_use(reg, from, to, use_kind, opr-&gt;type_register());
 913     }
 914   }
 915 }
 916 
 917 void LinearScan::add_temp(LIR_Opr opr, int temp_pos, IntervalUseKind use_kind) {
 918   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot; temp &quot;); opr-&gt;print(tty); tty-&gt;print_cr(&quot; temp_pos %d (%d)&quot;, temp_pos, use_kind));
 919   assert(opr-&gt;is_register(), &quot;should not be called otherwise&quot;);
 920 
 921   if (opr-&gt;is_virtual_register()) {
 922     assert(reg_num(opr) == opr-&gt;vreg_number() &amp;&amp; !is_valid_reg_num(reg_numHi(opr)), &quot;invalid optimization below&quot;);
 923     add_temp(opr-&gt;vreg_number(), temp_pos, use_kind, opr-&gt;type_register());
 924 
 925   } else {
 926     int reg = reg_num(opr);
 927     if (is_processed_reg_num(reg)) {
 928       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 929     }
 930     reg = reg_numHi(opr);
 931     if (is_valid_reg_num(reg) &amp;&amp; is_processed_reg_num(reg)) {
 932       add_temp(reg, temp_pos, use_kind, opr-&gt;type_register());
 933     }
 934   }
 935 }
 936 
 937 
 938 void LinearScan::add_def(int reg_num, int def_pos, IntervalUseKind use_kind, BasicType type) {
 939   Interval* interval = interval_at(reg_num);
 940   if (interval != NULL) {
 941     assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 942 
 943     if (type != T_ILLEGAL) {
 944       interval-&gt;set_type(type);
 945     }
 946 
 947     Range* r = interval-&gt;first();
 948     if (r-&gt;from() &lt;= def_pos) {
 949       // Update the starting point (when a range is first created for a use, its
 950       // start is the beginning of the current block until a def is encountered.)
 951       r-&gt;set_from(def_pos);
 952       interval-&gt;add_use_pos(def_pos, use_kind);
 953 
 954     } else {
 955       // Dead value - make vacuous interval
 956       // also add use_kind for dead intervals
 957       interval-&gt;add_range(def_pos, def_pos + 1);
 958       interval-&gt;add_use_pos(def_pos, use_kind);
 959       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: def of reg %d at %d occurs without use&quot;, reg_num, def_pos));
 960     }
 961 
 962   } else {
 963     // Dead value - make vacuous interval
 964     // also add use_kind for dead intervals
 965     interval = create_interval(reg_num);
 966     if (type != T_ILLEGAL) {
 967       interval-&gt;set_type(type);
 968     }
 969 
 970     interval-&gt;add_range(def_pos, def_pos + 1);
 971     interval-&gt;add_use_pos(def_pos, use_kind);
 972     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;Warning: dead value %d at %d in live intervals&quot;, reg_num, def_pos));
 973   }
 974 
 975   change_spill_definition_pos(interval, def_pos);
 976   if (use_kind == noUse &amp;&amp; interval-&gt;spill_state() &lt;= startInMemory) {
 977         // detection of method-parameters and roundfp-results
 978         // TODO: move this directly to position where use-kind is computed
 979     interval-&gt;set_spill_state(startInMemory);
 980   }
 981 }
 982 
 983 void LinearScan::add_use(int reg_num, int from, int to, IntervalUseKind use_kind, BasicType type) {
 984   Interval* interval = interval_at(reg_num);
 985   if (interval == NULL) {
 986     interval = create_interval(reg_num);
 987   }
 988   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
 989 
 990   if (type != T_ILLEGAL) {
 991     interval-&gt;set_type(type);
 992   }
 993 
 994   interval-&gt;add_range(from, to);
 995   interval-&gt;add_use_pos(to, use_kind);
 996 }
 997 
 998 void LinearScan::add_temp(int reg_num, int temp_pos, IntervalUseKind use_kind, BasicType type) {
 999   Interval* interval = interval_at(reg_num);
1000   if (interval == NULL) {
1001     interval = create_interval(reg_num);
1002   }
1003   assert(interval-&gt;reg_num() == reg_num, &quot;wrong interval&quot;);
1004 
1005   if (type != T_ILLEGAL) {
1006     interval-&gt;set_type(type);
1007   }
1008 
1009   interval-&gt;add_range(temp_pos, temp_pos + 1);
1010   interval-&gt;add_use_pos(temp_pos, use_kind);
1011 }
1012 
1013 
1014 // the results of this functions are used for optimizing spilling and reloading
1015 // if the functions return shouldHaveRegister and the interval is spilled,
1016 // it is not reloaded to a register.
1017 IntervalUseKind LinearScan::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
1018   if (op-&gt;code() == lir_move) {
1019     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1020     LIR_Op1* move = (LIR_Op1*)op;
1021     LIR_Opr res = move-&gt;result_opr();
1022     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1023 
1024     if (result_in_memory) {
1025       // Begin of an interval with must_start_in_memory set.
1026       // This interval will always get a stack slot first, so return noUse.
1027       return noUse;
1028 
1029     } else if (move-&gt;in_opr()-&gt;is_stack()) {
1030       // method argument (condition must be equal to handle_method_arguments)
1031       return noUse;
1032 
1033     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1034       // Move from register to register
1035       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1036         // special handling of phi-function moves inside osr-entry blocks
1037         // input operand must have a register instead of output operand (leads to better register allocation)
1038         return shouldHaveRegister;
1039       }
1040     }
1041   }
1042 
1043   if (opr-&gt;is_virtual() &amp;&amp;
1044       gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::must_start_in_memory)) {
1045     // result is a stack-slot, so prevent immediate reloading
1046     return noUse;
1047   }
1048 
1049   // all other operands require a register
1050   return mustHaveRegister;
1051 }
1052 
1053 IntervalUseKind LinearScan::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
1054   if (op-&gt;code() == lir_move) {
1055     assert(op-&gt;as_Op1() != NULL, &quot;lir_move must be LIR_Op1&quot;);
1056     LIR_Op1* move = (LIR_Op1*)op;
1057     LIR_Opr res = move-&gt;result_opr();
1058     bool result_in_memory = res-&gt;is_virtual() &amp;&amp; gen()-&gt;is_vreg_flag_set(res-&gt;vreg_number(), LIRGenerator::must_start_in_memory);
1059 
1060     if (result_in_memory) {
1061       // Move to an interval with must_start_in_memory set.
1062       // To avoid moves from stack to stack (not allowed) force the input operand to a register
1063       return mustHaveRegister;
1064 
1065     } else if (move-&gt;in_opr()-&gt;is_register() &amp;&amp; move-&gt;result_opr()-&gt;is_register()) {
1066       // Move from register to register
1067       if (block_of_op_with_id(op-&gt;id())-&gt;is_set(BlockBegin::osr_entry_flag)) {
1068         // special handling of phi-function moves inside osr-entry blocks
1069         // input operand must have a register instead of output operand (leads to better register allocation)
1070         return mustHaveRegister;
1071       }
1072 
1073       // The input operand is not forced to a register (moves from stack to register are allowed),
1074       // but it is faster if the input operand is in a register
1075       return shouldHaveRegister;
1076     }
1077   }
1078 
1079 
1080 #if defined(X86) || defined(S390)
1081   if (op-&gt;code() == lir_cmove) {
1082     // conditional moves can handle stack operands
1083     assert(op-&gt;result_opr()-&gt;is_register(), &quot;result must always be in a register&quot;);
1084     return shouldHaveRegister;
1085   }
1086 
1087   // optimizations for second input operand of arithmehtic operations on Intel
1088   // this operand is allowed to be on the stack in some cases
1089   BasicType opr_type = opr-&gt;type_register();
1090   if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
1091     if (IA32_ONLY( (UseSSE == 1 &amp;&amp; opr_type == T_FLOAT) || UseSSE &gt;= 2 ) NOT_IA32( true )) {
1092       // SSE float instruction (T_DOUBLE only supported with SSE2)
1093       switch (op-&gt;code()) {
1094         case lir_cmp:
1095         case lir_add:
1096         case lir_sub:
1097         case lir_mul:
1098         case lir_div:
1099         {
1100           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1101           LIR_Op2* op2 = (LIR_Op2*)op;
1102           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1103             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1104             return shouldHaveRegister;
1105           }
1106         }
1107         default:
1108           break;
1109       }
1110     } else {
1111       // FPU stack float instruction
1112       switch (op-&gt;code()) {
1113         case lir_add:
1114         case lir_sub:
1115         case lir_mul:
1116         case lir_div:
1117         {
1118           assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1119           LIR_Op2* op2 = (LIR_Op2*)op;
1120           if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1121             assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1122             return shouldHaveRegister;
1123           }
1124         }
1125         default:
1126           break;
1127       }
1128     }
1129     // We want to sometimes use logical operations on pointers, in particular in GC barriers.
1130     // Since 64bit logical operations do not current support operands on stack, we have to make sure
1131     // T_OBJECT doesn&#39;t get spilled along with T_LONG.
1132   } else if (opr_type != T_LONG LP64_ONLY(&amp;&amp; opr_type != T_OBJECT)) {
1133     // integer instruction (note: long operands must always be in register)
1134     switch (op-&gt;code()) {
1135       case lir_cmp:
1136       case lir_add:
1137       case lir_sub:
1138       case lir_logic_and:
1139       case lir_logic_or:
1140       case lir_logic_xor:
1141       {
1142         assert(op-&gt;as_Op2() != NULL, &quot;must be LIR_Op2&quot;);
1143         LIR_Op2* op2 = (LIR_Op2*)op;
1144         if (op2-&gt;in_opr1() != op2-&gt;in_opr2() &amp;&amp; op2-&gt;in_opr2() == opr) {
1145           assert((op2-&gt;result_opr()-&gt;is_register() || op-&gt;code() == lir_cmp) &amp;&amp; op2-&gt;in_opr1()-&gt;is_register(), &quot;cannot mark second operand as stack if others are not in register&quot;);
1146           return shouldHaveRegister;
1147         }
1148       }
1149       default:
1150         break;
1151     }
1152   }
1153 #endif // X86 || S390
1154 
1155   // all other operands require a register
1156   return mustHaveRegister;
1157 }
1158 
1159 
1160 void LinearScan::handle_method_arguments(LIR_Op* op) {
1161   // special handling for method arguments (moves from stack to virtual register):
1162   // the interval gets no register assigned, but the stack slot.
1163   // it is split before the first use by the register allocator.
1164 
1165   if (op-&gt;code() == lir_move) {
1166     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1167     LIR_Op1* move = (LIR_Op1*)op;
1168 
1169     if (move-&gt;in_opr()-&gt;is_stack()) {
1170 #ifdef ASSERT
1171       int arg_size = compilation()-&gt;method()-&gt;arg_size();
1172       LIR_Opr o = move-&gt;in_opr();
1173       if (o-&gt;is_single_stack()) {
1174         assert(o-&gt;single_stack_ix() &gt;= 0 &amp;&amp; o-&gt;single_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1175       } else if (o-&gt;is_double_stack()) {
1176         assert(o-&gt;double_stack_ix() &gt;= 0 &amp;&amp; o-&gt;double_stack_ix() &lt; arg_size, &quot;out of range&quot;);
1177       } else {
1178         ShouldNotReachHere();
1179       }
1180 
1181       assert(move-&gt;id() &gt; 0, &quot;invalid id&quot;);
1182       assert(block_of_op_with_id(move-&gt;id())-&gt;number_of_preds() == 0, &quot;move from stack must be in first block&quot;);
1183       assert(move-&gt;result_opr()-&gt;is_virtual(), &quot;result of move must be a virtual register&quot;);
1184 
1185       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;found move from stack slot %d to vreg %d&quot;, o-&gt;is_single_stack() ? o-&gt;single_stack_ix() : o-&gt;double_stack_ix(), reg_num(move-&gt;result_opr())));
1186 #endif
1187 
1188       Interval* interval = interval_at(reg_num(move-&gt;result_opr()));
1189 
1190       int stack_slot = LinearScan::nof_regs + (move-&gt;in_opr()-&gt;is_single_stack() ? move-&gt;in_opr()-&gt;single_stack_ix() : move-&gt;in_opr()-&gt;double_stack_ix());
1191       interval-&gt;set_canonical_spill_slot(stack_slot);
1192       interval-&gt;assign_reg(stack_slot);
1193     }
1194   }
1195 }
1196 
1197 void LinearScan::handle_doubleword_moves(LIR_Op* op) {
1198   // special handling for doubleword move from memory to register:
1199   // in this case the registers of the input address and the result
1200   // registers must not overlap -&gt; add a temp range for the input registers
1201   if (op-&gt;code() == lir_move) {
1202     assert(op-&gt;as_Op1() != NULL, &quot;must be LIR_Op1&quot;);
1203     LIR_Op1* move = (LIR_Op1*)op;
1204 
1205     if (move-&gt;result_opr()-&gt;is_double_cpu() &amp;&amp; move-&gt;in_opr()-&gt;is_pointer()) {
1206       LIR_Address* address = move-&gt;in_opr()-&gt;as_address_ptr();
1207       if (address != NULL) {
1208         if (address-&gt;base()-&gt;is_valid()) {
1209           add_temp(address-&gt;base(), op-&gt;id(), noUse);
1210         }
1211         if (address-&gt;index()-&gt;is_valid()) {
1212           add_temp(address-&gt;index(), op-&gt;id(), noUse);
1213         }
1214       }
1215     }
1216   }
1217 }
1218 
1219 void LinearScan::add_register_hints(LIR_Op* op) {
1220   switch (op-&gt;code()) {
1221     case lir_move:      // fall through
1222     case lir_convert: {
1223       assert(op-&gt;as_Op1() != NULL, &quot;lir_move, lir_convert must be LIR_Op1&quot;);
1224       LIR_Op1* move = (LIR_Op1*)op;
1225 
1226       LIR_Opr move_from = move-&gt;in_opr();
1227       LIR_Opr move_to = move-&gt;result_opr();
1228 
1229       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1230         Interval* from = interval_at(reg_num(move_from));
1231         Interval* to = interval_at(reg_num(move_to));
1232         if (from != NULL &amp;&amp; to != NULL) {
1233           to-&gt;set_register_hint(from);
1234           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, move-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1235         }
1236       }
1237       break;
1238     }
1239     case lir_cmove: {
1240       assert(op-&gt;as_Op2() != NULL, &quot;lir_cmove must be LIR_Op2&quot;);
1241       LIR_Op2* cmove = (LIR_Op2*)op;
1242 
1243       LIR_Opr move_from = cmove-&gt;in_opr1();
1244       LIR_Opr move_to = cmove-&gt;result_opr();
1245 
1246       if (move_to-&gt;is_register() &amp;&amp; move_from-&gt;is_register()) {
1247         Interval* from = interval_at(reg_num(move_from));
1248         Interval* to = interval_at(reg_num(move_to));
1249         if (from != NULL &amp;&amp; to != NULL) {
1250           to-&gt;set_register_hint(from);
1251           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation at op_id %d: added hint from interval %d to %d&quot;, cmove-&gt;id(), from-&gt;reg_num(), to-&gt;reg_num()));
1252         }
1253       }
1254       break;
1255     }
1256     default:
1257       break;
1258   }
1259 }
1260 
1261 
1262 void LinearScan::build_intervals() {
1263   TIME_LINEAR_SCAN(timer_build_intervals);
1264 
1265   // initialize interval list with expected number of intervals
1266   // (32 is added to have some space for split children without having to resize the list)
1267   _intervals = IntervalList(num_virtual_regs() + 32);
1268   // initialize all slots that are used by build_intervals
1269   _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
1270 
1271   // create a list with all caller-save registers (cpu, fpu, xmm)
1272   // when an instruction is a call, a temp range is created for all these registers
1273   int num_caller_save_registers = 0;
1274   int caller_save_registers[LinearScan::nof_regs];
1275 
1276   int i;
1277   for (i = 0; i &lt; FrameMap::nof_caller_save_cpu_regs(); i++) {
1278     LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
1279     assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1280     assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1281     caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1282   }
1283 
1284   // temp ranges for fpu registers are only created when the method has
1285   // virtual fpu operands. Otherwise no allocation for fpu registers is
1286   // performed and so the temp ranges would be useless
1287   if (has_fpu_registers()) {
1288 #ifdef X86
1289     if (UseSSE &lt; 2) {
1290 #endif // X86
1291       for (i = 0; i &lt; FrameMap::nof_caller_save_fpu_regs; i++) {
1292         LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
1293         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1294         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1295         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1296       }
1297 #ifdef X86
1298     }
1299 #endif // X86
1300 
1301 #ifdef X86
1302     if (UseSSE &gt; 0) {
1303       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
1304       for (i = 0; i &lt; num_caller_save_xmm_regs; i ++) {
1305         LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
1306         assert(opr-&gt;is_valid() &amp;&amp; opr-&gt;is_register(), &quot;FrameMap should not return invalid operands&quot;);
1307         assert(reg_numHi(opr) == -1, &quot;missing addition of range for hi-register&quot;);
1308         caller_save_registers[num_caller_save_registers++] = reg_num(opr);
1309       }
1310     }
1311 #endif // X86
1312   }
1313   assert(num_caller_save_registers &lt;= LinearScan::nof_regs, &quot;out of bounds&quot;);
1314 
1315 
1316   LIR_OpVisitState visitor;
1317 
1318   // iterate all blocks in reverse order
1319   for (i = block_count() - 1; i &gt;= 0; i--) {
1320     BlockBegin* block = block_at(i);
1321     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1322     int         block_from =   block-&gt;first_lir_instruction_id();
1323     int         block_to =     block-&gt;last_lir_instruction_id();
1324 
1325     assert(block_from == instructions-&gt;at(0)-&gt;id(), &quot;must be&quot;);
1326     assert(block_to   == instructions-&gt;at(instructions-&gt;length() - 1)-&gt;id(), &quot;must be&quot;);
1327 
1328     // Update intervals for registers live at the end of this block;
1329     ResourceBitMap live = block-&gt;live_out();
1330     int size = (int)live.size();
1331     for (int number = (int)live.get_next_one_offset(0, size); number &lt; size; number = (int)live.get_next_one_offset(number + 1, size)) {
1332       assert(live.at(number), &quot;should not stop here otherwise&quot;);
1333       assert(number &gt;= LIR_OprDesc::vreg_base, &quot;fixed intervals must not be live on block bounds&quot;);
1334       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;live in %d to %d&quot;, number, block_to + 2));
1335 
1336       add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
1337 
1338       // add special use positions for loop-end blocks when the
1339       // interval is used anywhere inside this loop.  It&#39;s possible
1340       // that the block was part of a non-natural loop, so it might
1341       // have an invalid loop index.
1342       if (block-&gt;is_set(BlockBegin::linear_scan_loop_end_flag) &amp;&amp;
1343           block-&gt;loop_index() != -1 &amp;&amp;
1344           is_interval_in_loop(number, block-&gt;loop_index())) {
1345         interval_at(number)-&gt;add_use_pos(block_to + 1, loopEndMarker);
1346       }
1347     }
1348 
1349     // iterate all instructions of the block in reverse order.
1350     // skip the first instruction because it is always a label
1351     // definitions of intervals are processed before uses
1352     assert(visitor.no_operands(instructions-&gt;at(0)), &quot;first operation must always be a label&quot;);
1353     for (int j = instructions-&gt;length() - 1; j &gt;= 1; j--) {
1354       LIR_Op* op = instructions-&gt;at(j);
1355       int op_id = op-&gt;id();
1356 
1357       // visit operation to collect all operands
1358       visitor.visit(op);
1359 
1360       // add a temp range for each register if operation destroys caller-save registers
1361       if (visitor.has_call()) {
1362         for (int k = 0; k &lt; num_caller_save_registers; k++) {
1363           add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
1364         }
1365         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;operation destroys all caller-save registers&quot;));
1366       }
1367 
1368       // Add any platform dependent temps
1369       pd_add_temps(op);
1370 
1371       // visit definitions (output and temp operands)
1372       int k, n;
1373       n = visitor.opr_count(LIR_OpVisitState::outputMode);
1374       for (k = 0; k &lt; n; k++) {
1375         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
1376         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1377         add_def(opr, op_id, use_kind_of_output_operand(op, opr));
1378       }
1379 
1380       n = visitor.opr_count(LIR_OpVisitState::tempMode);
1381       for (k = 0; k &lt; n; k++) {
1382         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
1383         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1384         add_temp(opr, op_id, mustHaveRegister);
1385       }
1386 
1387       // visit uses (input operands)
1388       n = visitor.opr_count(LIR_OpVisitState::inputMode);
1389       for (k = 0; k &lt; n; k++) {
1390         LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
1391         assert(opr-&gt;is_register(), &quot;visitor should only return register operands&quot;);
1392         add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
1393       }
1394 
1395       // Add uses of live locals from interpreter&#39;s point of view for proper
1396       // debug information generation
1397       // Treat these operands as temp values (if the life range is extended
1398       // to a call site, the value would be in a register at the call otherwise)
1399       n = visitor.info_count();
1400       for (k = 0; k &lt; n; k++) {
1401         CodeEmitInfo* info = visitor.info_at(k);
1402         ValueStack* stack = info-&gt;stack();
1403         for_each_state_value(stack, value,
1404           add_use(value, block_from, op_id + 1, noUse);
1405         );
1406       }
1407 
1408       // special steps for some instructions (especially moves)
1409       handle_method_arguments(op);
1410       handle_doubleword_moves(op);
1411       add_register_hints(op);
1412 
1413     } // end of instruction iteration
1414   } // end of block iteration
1415 
1416 
1417   // add the range [0, 1[ to all fixed intervals
1418   // -&gt; the register allocator need not handle unhandled fixed intervals
1419   for (int n = 0; n &lt; LinearScan::nof_regs; n++) {
1420     Interval* interval = interval_at(n);
1421     if (interval != NULL) {
1422       interval-&gt;add_range(0, 1);
1423     }
1424   }
1425 }
1426 
1427 
1428 // ********** Phase 5: actual register allocation
1429 
1430 int LinearScan::interval_cmp(Interval** a, Interval** b) {
1431   if (*a != NULL) {
1432     if (*b != NULL) {
1433       return (*a)-&gt;from() - (*b)-&gt;from();
1434     } else {
1435       return -1;
1436     }
1437   } else {
1438     if (*b != NULL) {
1439       return 1;
1440     } else {
1441       return 0;
1442     }
1443   }
1444 }
1445 
1446 #ifndef PRODUCT
1447 int interval_cmp(Interval* const&amp; l, Interval* const&amp; r) {
1448   return l-&gt;from() - r-&gt;from();
1449 }
1450 
1451 bool find_interval(Interval* interval, IntervalArray* intervals) {
1452   bool found;
1453   int idx = intervals-&gt;find_sorted&lt;Interval*, interval_cmp&gt;(interval, found);
1454 
1455   if (!found) {
1456     return false;
1457   }
1458 
1459   int from = interval-&gt;from();
1460 
1461   // The index we&#39;ve found using binary search is pointing to an interval
1462   // that is defined in the same place as the interval we were looking for.
1463   // So now we have to look around that index and find exact interval.
1464   for (int i = idx; i &gt;= 0; i--) {
1465     if (intervals-&gt;at(i) == interval) {
1466       return true;
1467     }
1468     if (intervals-&gt;at(i)-&gt;from() != from) {
1469       break;
1470     }
1471   }
1472 
1473   for (int i = idx + 1; i &lt; intervals-&gt;length(); i++) {
1474     if (intervals-&gt;at(i) == interval) {
1475       return true;
1476     }
1477     if (intervals-&gt;at(i)-&gt;from() != from) {
1478       break;
1479     }
1480   }
1481 
1482   return false;
1483 }
1484 
1485 bool LinearScan::is_sorted(IntervalArray* intervals) {
1486   int from = -1;
1487   int null_count = 0;
1488 
1489   for (int i = 0; i &lt; intervals-&gt;length(); i++) {
1490     Interval* it = intervals-&gt;at(i);
1491     if (it != NULL) {
1492       assert(from &lt;= it-&gt;from(), &quot;Intervals are unordered&quot;);
1493       from = it-&gt;from();
1494     } else {
1495       null_count++;
1496     }
1497   }
1498 
1499   assert(null_count == 0, &quot;Sorted intervals should not contain nulls&quot;);
1500 
1501   null_count = 0;
1502 
1503   for (int i = 0; i &lt; interval_count(); i++) {
1504     Interval* interval = interval_at(i);
1505     if (interval != NULL) {
1506       assert(find_interval(interval, intervals), &quot;Lists do not contain same intervals&quot;);
1507     } else {
1508       null_count++;
1509     }
1510   }
1511 
1512   assert(interval_count() - null_count == intervals-&gt;length(),
1513       &quot;Sorted list should contain the same amount of non-NULL intervals as unsorted list&quot;);
1514 
1515   return true;
1516 }
1517 #endif
1518 
1519 void LinearScan::add_to_list(Interval** first, Interval** prev, Interval* interval) {
1520   if (*prev != NULL) {
1521     (*prev)-&gt;set_next(interval);
1522   } else {
1523     *first = interval;
1524   }
1525   *prev = interval;
1526 }
1527 
1528 void LinearScan::create_unhandled_lists(Interval** list1, Interval** list2, bool (is_list1)(const Interval* i), bool (is_list2)(const Interval* i)) {
1529   assert(is_sorted(_sorted_intervals), &quot;interval list is not sorted&quot;);
1530 
1531   *list1 = *list2 = Interval::end();
1532 
1533   Interval* list1_prev = NULL;
1534   Interval* list2_prev = NULL;
1535   Interval* v;
1536 
1537   const int n = _sorted_intervals-&gt;length();
1538   for (int i = 0; i &lt; n; i++) {
1539     v = _sorted_intervals-&gt;at(i);
1540     if (v == NULL) continue;
1541 
1542     if (is_list1(v)) {
1543       add_to_list(list1, &amp;list1_prev, v);
1544     } else if (is_list2 == NULL || is_list2(v)) {
1545       add_to_list(list2, &amp;list2_prev, v);
1546     }
1547   }
1548 
1549   if (list1_prev != NULL) list1_prev-&gt;set_next(Interval::end());
1550   if (list2_prev != NULL) list2_prev-&gt;set_next(Interval::end());
1551 
1552   assert(list1_prev == NULL || list1_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1553   assert(list2_prev == NULL || list2_prev-&gt;next() == Interval::end(), &quot;linear list ends not with sentinel&quot;);
1554 }
1555 
1556 
1557 void LinearScan::sort_intervals_before_allocation() {
1558   TIME_LINEAR_SCAN(timer_sort_intervals_before);
1559 
1560   if (_needs_full_resort) {
1561     // There is no known reason why this should occur but just in case...
1562     assert(false, &quot;should never occur&quot;);
1563     // Re-sort existing interval list because an Interval::from() has changed
1564     _sorted_intervals-&gt;sort(interval_cmp);
1565     _needs_full_resort = false;
1566   }
1567 
1568   IntervalList* unsorted_list = &amp;_intervals;
1569   int unsorted_len = unsorted_list-&gt;length();
1570   int sorted_len = 0;
1571   int unsorted_idx;
1572   int sorted_idx = 0;
1573   int sorted_from_max = -1;
1574 
1575   // calc number of items for sorted list (sorted list must not contain NULL values)
1576   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1577     if (unsorted_list-&gt;at(unsorted_idx) != NULL) {
1578       sorted_len++;
1579     }
1580   }
1581   IntervalArray* sorted_list = new IntervalArray(sorted_len, sorted_len, NULL);
1582 
1583   // special sorting algorithm: the original interval-list is almost sorted,
1584   // only some intervals are swapped. So this is much faster than a complete QuickSort
1585   for (unsorted_idx = 0; unsorted_idx &lt; unsorted_len; unsorted_idx++) {
1586     Interval* cur_interval = unsorted_list-&gt;at(unsorted_idx);
1587 
1588     if (cur_interval != NULL) {
1589       int cur_from = cur_interval-&gt;from();
1590 
1591       if (sorted_from_max &lt;= cur_from) {
1592         sorted_list-&gt;at_put(sorted_idx++, cur_interval);
1593         sorted_from_max = cur_interval-&gt;from();
1594       } else {
1595         // the asumption that the intervals are already sorted failed,
1596         // so this interval must be sorted in manually
1597         int j;
1598         for (j = sorted_idx - 1; j &gt;= 0 &amp;&amp; cur_from &lt; sorted_list-&gt;at(j)-&gt;from(); j--) {
1599           sorted_list-&gt;at_put(j + 1, sorted_list-&gt;at(j));
1600         }
1601         sorted_list-&gt;at_put(j + 1, cur_interval);
1602         sorted_idx++;
1603       }
1604     }
1605   }
1606   _sorted_intervals = sorted_list;
1607   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1608 }
1609 
1610 void LinearScan::sort_intervals_after_allocation() {
1611   TIME_LINEAR_SCAN(timer_sort_intervals_after);
1612 
1613   if (_needs_full_resort) {
1614     // Re-sort existing interval list because an Interval::from() has changed
1615     _sorted_intervals-&gt;sort(interval_cmp);
1616     _needs_full_resort = false;
1617   }
1618 
1619   IntervalArray* old_list = _sorted_intervals;
1620   IntervalList* new_list = _new_intervals_from_allocation;
1621   int old_len = old_list-&gt;length();
1622   int new_len = new_list == NULL ? 0 : new_list-&gt;length();
1623 
1624   if (new_len == 0) {
1625     // no intervals have been added during allocation, so sorted list is already up to date
1626     assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1627     return;
1628   }
1629 
1630   // conventional sort-algorithm for new intervals
1631   new_list-&gt;sort(interval_cmp);
1632 
1633   // merge old and new list (both already sorted) into one combined list
1634   int combined_list_len = old_len + new_len;
1635   IntervalArray* combined_list = new IntervalArray(combined_list_len, combined_list_len, NULL);
1636   int old_idx = 0;
1637   int new_idx = 0;
1638 
1639   while (old_idx + new_idx &lt; old_len + new_len) {
1640     if (new_idx &gt;= new_len || (old_idx &lt; old_len &amp;&amp; old_list-&gt;at(old_idx)-&gt;from() &lt;= new_list-&gt;at(new_idx)-&gt;from())) {
1641       combined_list-&gt;at_put(old_idx + new_idx, old_list-&gt;at(old_idx));
1642       old_idx++;
1643     } else {
1644       combined_list-&gt;at_put(old_idx + new_idx, new_list-&gt;at(new_idx));
1645       new_idx++;
1646     }
1647   }
1648 
1649   _sorted_intervals = combined_list;
1650   assert(is_sorted(_sorted_intervals), &quot;intervals unsorted&quot;);
1651 }
1652 
1653 
1654 void LinearScan::allocate_registers() {
1655   TIME_LINEAR_SCAN(timer_allocate_registers);
1656 
1657   Interval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
1658   Interval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
1659 
1660   // allocate cpu registers
1661   create_unhandled_lists(&amp;precolored_cpu_intervals, &amp;not_precolored_cpu_intervals,
1662                          is_precolored_cpu_interval, is_virtual_cpu_interval);
1663 
1664   // allocate fpu registers
1665   create_unhandled_lists(&amp;precolored_fpu_intervals, &amp;not_precolored_fpu_intervals,
1666                          is_precolored_fpu_interval, is_virtual_fpu_interval);
1667 
1668   // the fpu interval allocation cannot be moved down below with the fpu section as
1669   // the cpu_lsw.walk() changes interval positions.
1670 
1671   LinearScanWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
1672   cpu_lsw.walk();
1673   cpu_lsw.finish_allocation();
1674 
1675   if (has_fpu_registers()) {
1676     LinearScanWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
1677     fpu_lsw.walk();
1678     fpu_lsw.finish_allocation();
1679   }
1680 }
1681 
1682 
1683 // ********** Phase 6: resolve data flow
1684 // (insert moves at edges between blocks if intervals have been split)
1685 
1686 // wrapper for Interval::split_child_at_op_id that performs a bailout in product mode
1687 // instead of returning NULL
1688 Interval* LinearScan::split_child_at_op_id(Interval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
1689   Interval* result = interval-&gt;split_child_at_op_id(op_id, mode);
1690   if (result != NULL) {
1691     return result;
1692   }
1693 
1694   assert(false, &quot;must find an interval, but do a clean bailout in product mode&quot;);
1695   result = new Interval(LIR_OprDesc::vreg_base);
1696   result-&gt;assign_reg(0);
1697   result-&gt;set_type(T_INT);
1698   BAILOUT_(&quot;LinearScan: interval is NULL&quot;, result);
1699 }
1700 
1701 
1702 Interval* LinearScan::interval_at_block_begin(BlockBegin* block, int reg_num) {
1703   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1704   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1705 
1706   return split_child_at_op_id(interval_at(reg_num), block-&gt;first_lir_instruction_id(), LIR_OpVisitState::outputMode);
1707 }
1708 
1709 Interval* LinearScan::interval_at_block_end(BlockBegin* block, int reg_num) {
1710   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1711   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1712 
1713   return split_child_at_op_id(interval_at(reg_num), block-&gt;last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
1714 }
1715 
1716 Interval* LinearScan::interval_at_op_id(int reg_num, int op_id) {
1717   assert(LinearScan::nof_regs &lt;= reg_num &amp;&amp; reg_num &lt; num_virtual_regs(), &quot;register number out of bounds&quot;);
1718   assert(interval_at(reg_num) != NULL, &quot;no interval found&quot;);
1719 
1720   return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
1721 }
1722 
1723 
1724 void LinearScan::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1725   DEBUG_ONLY(move_resolver.check_empty());
1726 
1727   const int size = live_set_size();
1728   const ResourceBitMap live_at_edge = to_block-&gt;live_in();
1729 
1730   // visit all registers where the live_at_edge bit is set
1731   for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
1732     assert(r &lt; num_virtual_regs(), &quot;live information set for not exisiting interval&quot;);
1733     assert(from_block-&gt;live_out().at(r) &amp;&amp; to_block-&gt;live_in().at(r), &quot;interval not live at this edge&quot;);
1734 
1735     Interval* from_interval = interval_at_block_end(from_block, r);
1736     Interval* to_interval = interval_at_block_begin(to_block, r);
1737 
1738     if (from_interval != to_interval &amp;&amp; (from_interval-&gt;assigned_reg() != to_interval-&gt;assigned_reg() || from_interval-&gt;assigned_regHi() != to_interval-&gt;assigned_regHi())) {
1739       // need to insert move instruction
1740       move_resolver.add_mapping(from_interval, to_interval);
1741     }
1742   }
1743 }
1744 
1745 
1746 void LinearScan::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, MoveResolver &amp;move_resolver) {
1747   if (from_block-&gt;number_of_sux() &lt;= 1) {
1748     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at end of from_block B%d&quot;, from_block-&gt;block_id()));
1749 
1750     LIR_OpList* instructions = from_block-&gt;lir()-&gt;instructions_list();
1751     LIR_OpBranch* branch = instructions-&gt;last()-&gt;as_OpBranch();
1752     if (branch != NULL) {
1753       // insert moves before branch
1754       assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
1755       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 2);
1756     } else {
1757       move_resolver.set_insert_position(from_block-&gt;lir(), instructions-&gt;length() - 1);
1758     }
1759 
1760   } else {
1761     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;inserting moves at beginning of to_block B%d&quot;, to_block-&gt;block_id()));
1762 #ifdef ASSERT
1763     assert(from_block-&gt;lir()-&gt;instructions_list()-&gt;at(0)-&gt;as_OpLabel() != NULL, &quot;block does not start with a label&quot;);
1764 
1765     // because the number of predecessor edges matches the number of
1766     // successor edges, blocks which are reached by switch statements
1767     // may have be more than one predecessor but it will be guaranteed
1768     // that all predecessors will be the same.
1769     for (int i = 0; i &lt; to_block-&gt;number_of_preds(); i++) {
1770       assert(from_block == to_block-&gt;pred_at(i), &quot;all critical edges must be broken&quot;);
1771     }
1772 #endif
1773 
1774     move_resolver.set_insert_position(to_block-&gt;lir(), 0);
1775   }
1776 }
1777 
1778 
1779 // insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
1780 void LinearScan::resolve_data_flow() {
1781   TIME_LINEAR_SCAN(timer_resolve_data_flow);
1782 
1783   int num_blocks = block_count();
1784   MoveResolver move_resolver(this);
1785   ResourceBitMap block_completed(num_blocks);
1786   ResourceBitMap already_resolved(num_blocks);
1787 
1788   int i;
1789   for (i = 0; i &lt; num_blocks; i++) {
1790     BlockBegin* block = block_at(i);
1791 
1792     // check if block has only one predecessor and only one successor
1793     if (block-&gt;number_of_preds() == 1 &amp;&amp; block-&gt;number_of_sux() == 1 &amp;&amp; block-&gt;number_of_exception_handlers() == 0) {
1794       LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
1795       assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
1796       assert(instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successors must end with branch&quot;);
1797       assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block with successor must end with unconditional branch&quot;);
1798 
1799       // check if block is empty (only label and branch)
1800       if (instructions-&gt;length() == 2) {
1801         BlockBegin* pred = block-&gt;pred_at(0);
1802         BlockBegin* sux = block-&gt;sux_at(0);
1803 
1804         // prevent optimization of two consecutive blocks
1805         if (!block_completed.at(pred-&gt;linear_scan_number()) &amp;&amp; !block_completed.at(sux-&gt;linear_scan_number())) {
1806           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** optimizing empty block B%d (pred: B%d, sux: B%d)&quot;, block-&gt;block_id(), pred-&gt;block_id(), sux-&gt;block_id()));
1807           block_completed.set_bit(block-&gt;linear_scan_number());
1808 
1809           // directly resolve between pred and sux (without looking at the empty block between)
1810           resolve_collect_mappings(pred, sux, move_resolver);
1811           if (move_resolver.has_mappings()) {
1812             move_resolver.set_insert_position(block-&gt;lir(), 0);
1813             move_resolver.resolve_and_append_moves();
1814           }
1815         }
1816       }
1817     }
1818   }
1819 
1820 
1821   for (i = 0; i &lt; num_blocks; i++) {
1822     if (!block_completed.at(i)) {
1823       BlockBegin* from_block = block_at(i);
1824       already_resolved.set_from(block_completed);
1825 
1826       int num_sux = from_block-&gt;number_of_sux();
1827       for (int s = 0; s &lt; num_sux; s++) {
1828         BlockBegin* to_block = from_block-&gt;sux_at(s);
1829 
1830         // check for duplicate edges between the same blocks (can happen with switch blocks)
1831         if (!already_resolved.at(to_block-&gt;linear_scan_number())) {
1832           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;**** processing edge between B%d and B%d&quot;, from_block-&gt;block_id(), to_block-&gt;block_id()));
1833           already_resolved.set_bit(to_block-&gt;linear_scan_number());
1834 
1835           // collect all intervals that have been split between from_block and to_block
1836           resolve_collect_mappings(from_block, to_block, move_resolver);
1837           if (move_resolver.has_mappings()) {
1838             resolve_find_insert_pos(from_block, to_block, move_resolver);
1839             move_resolver.resolve_and_append_moves();
1840           }
1841         }
1842       }
1843     }
1844   }
1845 }
1846 
1847 
1848 void LinearScan::resolve_exception_entry(BlockBegin* block, int reg_num, MoveResolver &amp;move_resolver) {
1849   if (interval_at(reg_num) == NULL) {
1850     // if a phi function is never used, no interval is created -&gt; ignore this
1851     return;
1852   }
1853 
1854   Interval* interval = interval_at_block_begin(block, reg_num);
1855   int reg = interval-&gt;assigned_reg();
1856   int regHi = interval-&gt;assigned_regHi();
1857 
1858   if ((reg &lt; nof_regs &amp;&amp; interval-&gt;always_in_memory()) ||
1859       (use_fpu_stack_allocation() &amp;&amp; reg &gt;= pd_first_fpu_reg &amp;&amp; reg &lt;= pd_last_fpu_reg)) {
1860     // the interval is split to get a short range that is located on the stack
1861     // in the following two cases:
1862     // * the interval started in memory (e.g. method parameter), but is currently in a register
1863     //   this is an optimization for exception handling that reduces the number of moves that
1864     //   are necessary for resolving the states when an exception uses this exception handler
1865     // * the interval would be on the fpu stack at the begin of the exception handler
1866     //   this is not allowed because of the complicated fpu stack handling on Intel
1867 
1868     // range that will be spilled to memory
1869     int from_op_id = block-&gt;first_lir_instruction_id();
1870     int to_op_id = from_op_id + 1;  // short live range of length 1
1871     assert(interval-&gt;from() &lt;= from_op_id &amp;&amp; interval-&gt;to() &gt;= to_op_id,
1872            &quot;no split allowed between exception entry and first instruction&quot;);
1873 
1874     if (interval-&gt;from() != from_op_id) {
1875       // the part before from_op_id is unchanged
1876       interval = interval-&gt;split(from_op_id);
1877       interval-&gt;assign_reg(reg, regHi);
1878       append_interval(interval);
1879     } else {
1880       _needs_full_resort = true;
1881     }
1882     assert(interval-&gt;from() == from_op_id, &quot;must be true now&quot;);
1883 
1884     Interval* spilled_part = interval;
1885     if (interval-&gt;to() != to_op_id) {
1886       // the part after to_op_id is unchanged
1887       spilled_part = interval-&gt;split_from_start(to_op_id);
1888       append_interval(spilled_part);
1889       move_resolver.add_mapping(spilled_part, interval);
1890     }
1891     assign_spill_slot(spilled_part);
1892 
1893     assert(spilled_part-&gt;from() == from_op_id &amp;&amp; spilled_part-&gt;to() == to_op_id, &quot;just checking&quot;);
1894   }
1895 }
1896 
1897 void LinearScan::resolve_exception_entry(BlockBegin* block, MoveResolver &amp;move_resolver) {
1898   assert(block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;should not call otherwise&quot;);
1899   DEBUG_ONLY(move_resolver.check_empty());
1900 
1901   // visit all registers where the live_in bit is set
1902   int size = live_set_size();
1903   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1904     resolve_exception_entry(block, r, move_resolver);
1905   }
1906 
1907   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1908   for_each_phi_fun(block, phi,
1909     if (!phi-&gt;is_illegal()) { resolve_exception_entry(block, phi-&gt;operand()-&gt;vreg_number(), move_resolver); }
1910   );
1911 
1912   if (move_resolver.has_mappings()) {
1913     // insert moves after first instruction
1914     move_resolver.set_insert_position(block-&gt;lir(), 0);
1915     move_resolver.resolve_and_append_moves();
1916   }
1917 }
1918 
1919 
1920 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, MoveResolver &amp;move_resolver) {
1921   if (interval_at(reg_num) == NULL) {
1922     // if a phi function is never used, no interval is created -&gt; ignore this
1923     return;
1924   }
1925 
1926   // the computation of to_interval is equal to resolve_collect_mappings,
1927   // but from_interval is more complicated because of phi functions
1928   BlockBegin* to_block = handler-&gt;entry_block();
1929   Interval* to_interval = interval_at_block_begin(to_block, reg_num);
1930 
1931   if (phi != NULL) {
1932     // phi function of the exception entry block
1933     // no moves are created for this phi function in the LIR_Generator, so the
1934     // interval at the throwing instruction must be searched using the operands
1935     // of the phi function
1936     Value from_value = phi-&gt;operand_at(handler-&gt;phi_operand());
1937 
1938     // with phi functions it can happen that the same from_value is used in
1939     // multiple mappings, so notify move-resolver that this is allowed
1940     move_resolver.set_multiple_reads_allowed();
1941 
1942     Constant* con = from_value-&gt;as_Constant();
1943     if (con != NULL &amp;&amp; !con-&gt;is_pinned()) {
1944       // unpinned constants may have no register, so add mapping from constant to interval
1945       move_resolver.add_mapping(LIR_OprFact::value_type(con-&gt;type()), to_interval);
1946     } else {
1947       // search split child at the throwing op_id
1948       Interval* from_interval = interval_at_op_id(from_value-&gt;operand()-&gt;vreg_number(), throwing_op_id);
1949       move_resolver.add_mapping(from_interval, to_interval);
1950     }
1951 
1952   } else {
1953     // no phi function, so use reg_num also for from_interval
1954     // search split child at the throwing op_id
1955     Interval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
1956     if (from_interval != to_interval) {
1957       // optimization to reduce number of moves: when to_interval is on stack and
1958       // the stack slot is known to be always correct, then no move is necessary
1959       if (!from_interval-&gt;always_in_memory() || from_interval-&gt;canonical_spill_slot() != to_interval-&gt;assigned_reg()) {
1960         move_resolver.add_mapping(from_interval, to_interval);
1961       }
1962     }
1963   }
1964 }
1965 
1966 void LinearScan::resolve_exception_edge(XHandler* handler, int throwing_op_id, MoveResolver &amp;move_resolver) {
1967   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;resolving exception handler B%d: throwing_op_id=%d&quot;, handler-&gt;entry_block()-&gt;block_id(), throwing_op_id));
1968 
1969   DEBUG_ONLY(move_resolver.check_empty());
1970   assert(handler-&gt;lir_op_id() == -1, &quot;already processed this xhandler&quot;);
1971   DEBUG_ONLY(handler-&gt;set_lir_op_id(throwing_op_id));
1972   assert(handler-&gt;entry_code() == NULL, &quot;code already present&quot;);
1973 
1974   // visit all registers where the live_in bit is set
1975   BlockBegin* block = handler-&gt;entry_block();
1976   int size = live_set_size();
1977   for (int r = (int)block-&gt;live_in().get_next_one_offset(0, size); r &lt; size; r = (int)block-&gt;live_in().get_next_one_offset(r + 1, size)) {
1978     resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
1979   }
1980 
1981   // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
1982   for_each_phi_fun(block, phi,
1983     if (!phi-&gt;is_illegal()) { resolve_exception_edge(handler, throwing_op_id, phi-&gt;operand()-&gt;vreg_number(), phi, move_resolver); }
1984   );
1985 
1986   if (move_resolver.has_mappings()) {
1987     LIR_List* entry_code = new LIR_List(compilation());
1988     move_resolver.set_insert_position(entry_code, 0);
1989     move_resolver.resolve_and_append_moves();
1990 
1991     entry_code-&gt;jump(handler-&gt;entry_block());
1992     handler-&gt;set_entry_code(entry_code);
1993   }
1994 }
1995 
1996 
1997 void LinearScan::resolve_exception_handlers() {
1998   MoveResolver move_resolver(this);
1999   LIR_OpVisitState visitor;
2000   int num_blocks = block_count();
2001 
2002   int i;
2003   for (i = 0; i &lt; num_blocks; i++) {
2004     BlockBegin* block = block_at(i);
2005     if (block-&gt;is_set(BlockBegin::exception_entry_flag)) {
2006       resolve_exception_entry(block, move_resolver);
2007     }
2008   }
2009 
2010   for (i = 0; i &lt; num_blocks; i++) {
2011     BlockBegin* block = block_at(i);
2012     LIR_List* ops = block-&gt;lir();
2013     int num_ops = ops-&gt;length();
2014 
2015     // iterate all instructions of the block. skip the first because it is always a label
2016     assert(visitor.no_operands(ops-&gt;at(0)), &quot;first operation must always be a label&quot;);
2017     for (int j = 1; j &lt; num_ops; j++) {
2018       LIR_Op* op = ops-&gt;at(j);
2019       int op_id = op-&gt;id();
2020 
2021       if (op_id != -1 &amp;&amp; has_info(op_id)) {
2022         // visit operation to collect all operands
2023         visitor.visit(op);
2024         assert(visitor.info_count() &gt; 0, &quot;should not visit otherwise&quot;);
2025 
2026         XHandlers* xhandlers = visitor.all_xhandler();
2027         int n = xhandlers-&gt;length();
2028         for (int k = 0; k &lt; n; k++) {
2029           resolve_exception_edge(xhandlers-&gt;handler_at(k), op_id, move_resolver);
2030         }
2031 
2032 #ifdef ASSERT
2033       } else {
2034         visitor.visit(op);
2035         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
2036 #endif
2037       }
2038     }
2039   }
2040 }
2041 
2042 
2043 // ********** Phase 7: assign register numbers back to LIR
2044 // (includes computation of debug information and oop maps)
2045 
2046 VMReg LinearScan::vm_reg_for_interval(Interval* interval) {
2047   VMReg reg = interval-&gt;cached_vm_reg();
2048   if (!reg-&gt;is_valid() ) {
2049     reg = vm_reg_for_operand(operand_for_interval(interval));
2050     interval-&gt;set_cached_vm_reg(reg);
2051   }
2052   assert(reg == vm_reg_for_operand(operand_for_interval(interval)), &quot;wrong cached value&quot;);
2053   return reg;
2054 }
2055 
2056 VMReg LinearScan::vm_reg_for_operand(LIR_Opr opr) {
2057   assert(opr-&gt;is_oop(), &quot;currently only implemented for oop operands&quot;);
2058   return frame_map()-&gt;regname(opr);
2059 }
2060 
2061 
2062 LIR_Opr LinearScan::operand_for_interval(Interval* interval) {
2063   LIR_Opr opr = interval-&gt;cached_opr();
2064   if (opr-&gt;is_illegal()) {
2065     opr = calc_operand_for_interval(interval);
2066     interval-&gt;set_cached_opr(opr);
2067   }
2068 
2069   assert(opr == calc_operand_for_interval(interval), &quot;wrong cached value&quot;);
2070   return opr;
2071 }
2072 
2073 LIR_Opr LinearScan::calc_operand_for_interval(const Interval* interval) {
2074   int assigned_reg = interval-&gt;assigned_reg();
2075   BasicType type = interval-&gt;type();
2076 
2077   if (assigned_reg &gt;= nof_regs) {
2078     // stack slot
2079     assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2080     return LIR_OprFact::stack(assigned_reg - nof_regs, type);
2081 
2082   } else {
2083     // register
2084     switch (type) {
2085       case T_OBJECT: {
2086         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2087         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2088         return LIR_OprFact::single_cpu_oop(assigned_reg);
2089       }
2090 
2091       case T_ADDRESS: {
2092         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2093         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2094         return LIR_OprFact::single_cpu_address(assigned_reg);
2095       }
2096 
2097       case T_METADATA: {
2098         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2099         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2100         return LIR_OprFact::single_cpu_metadata(assigned_reg);
2101       }
2102 
2103 #ifdef __SOFTFP__
2104       case T_FLOAT:  // fall through
2105 #endif // __SOFTFP__
2106       case T_INT: {
2107         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2108         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2109         return LIR_OprFact::single_cpu(assigned_reg);
2110       }
2111 
2112 #ifdef __SOFTFP__
2113       case T_DOUBLE:  // fall through
2114 #endif // __SOFTFP__
2115       case T_LONG: {
2116         int assigned_regHi = interval-&gt;assigned_regHi();
2117         assert(assigned_reg &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg &lt;= pd_last_cpu_reg, &quot;no cpu register&quot;);
2118         assert(num_physical_regs(T_LONG) == 1 ||
2119                (assigned_regHi &gt;= pd_first_cpu_reg &amp;&amp; assigned_regHi &lt;= pd_last_cpu_reg), &quot;no cpu register&quot;);
2120 
2121         assert(assigned_reg != assigned_regHi, &quot;invalid allocation&quot;);
2122         assert(num_physical_regs(T_LONG) == 1 || assigned_reg &lt; assigned_regHi,
2123                &quot;register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)&quot;);
2124         assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), &quot;must be match&quot;);
2125         if (requires_adjacent_regs(T_LONG)) {
2126           assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == assigned_regHi, &quot;must be sequential and even&quot;);
2127         }
2128 
2129 #ifdef _LP64
2130         return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
2131 #else
<a name="2" id="anc2"></a><span class="line-modified">2132 #if defined(SPARC) || defined(PPC32)</span>
2133         return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
2134 #else
2135         return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
<a name="3" id="anc3"></a><span class="line-modified">2136 #endif // SPARC</span>
2137 #endif // LP64
2138       }
2139 
2140 #ifndef __SOFTFP__
2141       case T_FLOAT: {
2142 #ifdef X86
2143         if (UseSSE &gt;= 1) {
2144           int last_xmm_reg = pd_last_xmm_reg;
2145 #ifdef _LP64
2146           if (UseAVX &lt; 3) {
2147             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2148           }
2149 #endif // LP64
2150           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2151           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2152           return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
2153         }
2154 #endif // X86
2155 
2156         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2157         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register&quot;);
2158         return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
2159       }
2160 
2161       case T_DOUBLE: {
2162 #ifdef X86
2163         if (UseSSE &gt;= 2) {
2164           int last_xmm_reg = pd_last_xmm_reg;
2165 #ifdef _LP64
2166           if (UseAVX &lt; 3) {
2167             last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
2168           }
2169 #endif // LP64
2170           assert(assigned_reg &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg &lt;= last_xmm_reg, &quot;no xmm register&quot;);
2171           assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double xmm values are stored in one register)&quot;);
2172           return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
2173         }
2174 #endif // X86
2175 
<a name="4" id="anc4"></a><span class="line-modified">2176 #ifdef SPARC</span>
<span class="line-removed">2177         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);</span>
<span class="line-removed">2178         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);</span>
<span class="line-removed">2179         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);</span>
<span class="line-removed">2180         LIR_Opr result = LIR_OprFact::double_fpu(interval-&gt;assigned_regHi() - pd_first_fpu_reg, assigned_reg - pd_first_fpu_reg);</span>
<span class="line-removed">2181 #elif defined(ARM32)</span>
2182         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2183         assert(interval-&gt;assigned_regHi() &gt;= pd_first_fpu_reg &amp;&amp; interval-&gt;assigned_regHi() &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2184         assert(assigned_reg % 2 == 0 &amp;&amp; assigned_reg + 1 == interval-&gt;assigned_regHi(), &quot;must be sequential and even&quot;);
2185         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval-&gt;assigned_regHi() - pd_first_fpu_reg);
2186 #else
2187         assert(assigned_reg &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg &lt;= pd_last_fpu_reg, &quot;no fpu register&quot;);
2188         assert(interval-&gt;assigned_regHi() == any_reg, &quot;must not have hi register (double fpu values are stored in one register on Intel)&quot;);
2189         LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
2190 #endif
2191         return result;
2192       }
2193 #endif // __SOFTFP__
2194 
2195       default: {
2196         ShouldNotReachHere();
2197         return LIR_OprFact::illegalOpr;
2198       }
2199     }
2200   }
2201 }
2202 
2203 LIR_Opr LinearScan::canonical_spill_opr(Interval* interval) {
2204   assert(interval-&gt;canonical_spill_slot() &gt;= nof_regs, &quot;canonical spill slot not set&quot;);
2205   return LIR_OprFact::stack(interval-&gt;canonical_spill_slot() - nof_regs, interval-&gt;type());
2206 }
2207 
2208 LIR_Opr LinearScan::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
2209   assert(opr-&gt;is_virtual(), &quot;should not call this otherwise&quot;);
2210 
2211   Interval* interval = interval_at(opr-&gt;vreg_number());
2212   assert(interval != NULL, &quot;interval must exist&quot;);
2213 
2214   if (op_id != -1) {
2215 #ifdef ASSERT
2216     BlockBegin* block = block_of_op_with_id(op_id);
2217     if (block-&gt;number_of_sux() &lt;= 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2218       // check if spill moves could have been appended at the end of this block, but
2219       // before the branch instruction. So the split child information for this branch would
2220       // be incorrect.
2221       LIR_OpBranch* branch = block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch();
2222       if (branch != NULL) {
2223         if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2224           assert(branch-&gt;cond() == lir_cond_always, &quot;block does not end with an unconditional jump&quot;);
2225           assert(false, &quot;can&#39;t get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)&quot;);
2226         }
2227       }
2228     }
2229 #endif
2230 
2231     // operands are not changed when an interval is split during allocation,
2232     // so search the right interval here
2233     interval = split_child_at_op_id(interval, op_id, mode);
2234   }
2235 
2236   LIR_Opr res = operand_for_interval(interval);
2237 
2238 #ifdef X86
2239   // new semantic for is_last_use: not only set on definite end of interval,
2240   // but also before hole
2241   // This may still miss some cases (e.g. for dead values), but it is not necessary that the
2242   // last use information is completely correct
2243   // information is only needed for fpu stack allocation
2244   if (res-&gt;is_fpu_register()) {
2245     if (opr-&gt;is_last_use() || op_id == interval-&gt;to() || (op_id != -1 &amp;&amp; interval-&gt;has_hole_between(op_id, op_id + 1))) {
2246       assert(op_id == -1 || !is_block_begin(op_id), &quot;holes at begin of block may also result from control flow&quot;);
2247       res = res-&gt;make_last_use();
2248     }
2249   }
2250 #endif
2251 
2252   assert(!gen()-&gt;is_vreg_flag_set(opr-&gt;vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), &quot;bad allocation&quot;);
2253 
2254   return res;
2255 }
2256 
2257 
2258 #ifdef ASSERT
2259 // some methods used to check correctness of debug information
2260 
2261 void assert_no_register_values(GrowableArray&lt;ScopeValue*&gt;* values) {
2262   if (values == NULL) {
2263     return;
2264   }
2265 
2266   for (int i = 0; i &lt; values-&gt;length(); i++) {
2267     ScopeValue* value = values-&gt;at(i);
2268 
2269     if (value-&gt;is_location()) {
2270       Location location = ((LocationValue*)value)-&gt;location();
2271       assert(location.where() == Location::on_stack, &quot;value is in register&quot;);
2272     }
2273   }
2274 }
2275 
2276 void assert_no_register_values(GrowableArray&lt;MonitorValue*&gt;* values) {
2277   if (values == NULL) {
2278     return;
2279   }
2280 
2281   for (int i = 0; i &lt; values-&gt;length(); i++) {
2282     MonitorValue* value = values-&gt;at(i);
2283 
2284     if (value-&gt;owner()-&gt;is_location()) {
2285       Location location = ((LocationValue*)value-&gt;owner())-&gt;location();
2286       assert(location.where() == Location::on_stack, &quot;owner is in register&quot;);
2287     }
2288     assert(value-&gt;basic_lock().where() == Location::on_stack, &quot;basic_lock is in register&quot;);
2289   }
2290 }
2291 
2292 void assert_equal(Location l1, Location l2) {
2293   assert(l1.where() == l2.where() &amp;&amp; l1.type() == l2.type() &amp;&amp; l1.offset() == l2.offset(), &quot;&quot;);
2294 }
2295 
2296 void assert_equal(ScopeValue* v1, ScopeValue* v2) {
2297   if (v1-&gt;is_location()) {
2298     assert(v2-&gt;is_location(), &quot;&quot;);
2299     assert_equal(((LocationValue*)v1)-&gt;location(), ((LocationValue*)v2)-&gt;location());
2300   } else if (v1-&gt;is_constant_int()) {
2301     assert(v2-&gt;is_constant_int(), &quot;&quot;);
2302     assert(((ConstantIntValue*)v1)-&gt;value() == ((ConstantIntValue*)v2)-&gt;value(), &quot;&quot;);
2303   } else if (v1-&gt;is_constant_double()) {
2304     assert(v2-&gt;is_constant_double(), &quot;&quot;);
2305     assert(((ConstantDoubleValue*)v1)-&gt;value() == ((ConstantDoubleValue*)v2)-&gt;value(), &quot;&quot;);
2306   } else if (v1-&gt;is_constant_long()) {
2307     assert(v2-&gt;is_constant_long(), &quot;&quot;);
2308     assert(((ConstantLongValue*)v1)-&gt;value() == ((ConstantLongValue*)v2)-&gt;value(), &quot;&quot;);
2309   } else if (v1-&gt;is_constant_oop()) {
2310     assert(v2-&gt;is_constant_oop(), &quot;&quot;);
2311     assert(((ConstantOopWriteValue*)v1)-&gt;value() == ((ConstantOopWriteValue*)v2)-&gt;value(), &quot;&quot;);
2312   } else {
2313     ShouldNotReachHere();
2314   }
2315 }
2316 
2317 void assert_equal(MonitorValue* m1, MonitorValue* m2) {
2318   assert_equal(m1-&gt;owner(), m2-&gt;owner());
2319   assert_equal(m1-&gt;basic_lock(), m2-&gt;basic_lock());
2320 }
2321 
2322 void assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
2323   assert(d1-&gt;scope() == d2-&gt;scope(), &quot;not equal&quot;);
2324   assert(d1-&gt;bci() == d2-&gt;bci(), &quot;not equal&quot;);
2325 
2326   if (d1-&gt;locals() != NULL) {
2327     assert(d1-&gt;locals() != NULL &amp;&amp; d2-&gt;locals() != NULL, &quot;not equal&quot;);
2328     assert(d1-&gt;locals()-&gt;length() == d2-&gt;locals()-&gt;length(), &quot;not equal&quot;);
2329     for (int i = 0; i &lt; d1-&gt;locals()-&gt;length(); i++) {
2330       assert_equal(d1-&gt;locals()-&gt;at(i), d2-&gt;locals()-&gt;at(i));
2331     }
2332   } else {
2333     assert(d1-&gt;locals() == NULL &amp;&amp; d2-&gt;locals() == NULL, &quot;not equal&quot;);
2334   }
2335 
2336   if (d1-&gt;expressions() != NULL) {
2337     assert(d1-&gt;expressions() != NULL &amp;&amp; d2-&gt;expressions() != NULL, &quot;not equal&quot;);
2338     assert(d1-&gt;expressions()-&gt;length() == d2-&gt;expressions()-&gt;length(), &quot;not equal&quot;);
2339     for (int i = 0; i &lt; d1-&gt;expressions()-&gt;length(); i++) {
2340       assert_equal(d1-&gt;expressions()-&gt;at(i), d2-&gt;expressions()-&gt;at(i));
2341     }
2342   } else {
2343     assert(d1-&gt;expressions() == NULL &amp;&amp; d2-&gt;expressions() == NULL, &quot;not equal&quot;);
2344   }
2345 
2346   if (d1-&gt;monitors() != NULL) {
2347     assert(d1-&gt;monitors() != NULL &amp;&amp; d2-&gt;monitors() != NULL, &quot;not equal&quot;);
2348     assert(d1-&gt;monitors()-&gt;length() == d2-&gt;monitors()-&gt;length(), &quot;not equal&quot;);
2349     for (int i = 0; i &lt; d1-&gt;monitors()-&gt;length(); i++) {
2350       assert_equal(d1-&gt;monitors()-&gt;at(i), d2-&gt;monitors()-&gt;at(i));
2351     }
2352   } else {
2353     assert(d1-&gt;monitors() == NULL &amp;&amp; d2-&gt;monitors() == NULL, &quot;not equal&quot;);
2354   }
2355 
2356   if (d1-&gt;caller() != NULL) {
2357     assert(d1-&gt;caller() != NULL &amp;&amp; d2-&gt;caller() != NULL, &quot;not equal&quot;);
2358     assert_equal(d1-&gt;caller(), d2-&gt;caller());
2359   } else {
2360     assert(d1-&gt;caller() == NULL &amp;&amp; d2-&gt;caller() == NULL, &quot;not equal&quot;);
2361   }
2362 }
2363 
2364 void check_stack_depth(CodeEmitInfo* info, int stack_end) {
2365   if (info-&gt;stack()-&gt;bci() != SynchronizationEntryBCI &amp;&amp; !info-&gt;scope()-&gt;method()-&gt;is_native()) {
2366     Bytecodes::Code code = info-&gt;scope()-&gt;method()-&gt;java_code_at_bci(info-&gt;stack()-&gt;bci());
2367     switch (code) {
2368       case Bytecodes::_ifnull    : // fall through
2369       case Bytecodes::_ifnonnull : // fall through
2370       case Bytecodes::_ifeq      : // fall through
2371       case Bytecodes::_ifne      : // fall through
2372       case Bytecodes::_iflt      : // fall through
2373       case Bytecodes::_ifge      : // fall through
2374       case Bytecodes::_ifgt      : // fall through
2375       case Bytecodes::_ifle      : // fall through
2376       case Bytecodes::_if_icmpeq : // fall through
2377       case Bytecodes::_if_icmpne : // fall through
2378       case Bytecodes::_if_icmplt : // fall through
2379       case Bytecodes::_if_icmpge : // fall through
2380       case Bytecodes::_if_icmpgt : // fall through
2381       case Bytecodes::_if_icmple : // fall through
2382       case Bytecodes::_if_acmpeq : // fall through
2383       case Bytecodes::_if_acmpne :
2384         assert(stack_end &gt;= -Bytecodes::depth(code), &quot;must have non-empty expression stack at if bytecode&quot;);
2385         break;
2386       default:
2387         break;
2388     }
2389   }
2390 }
2391 
2392 #endif // ASSERT
2393 
2394 
2395 IntervalWalker* LinearScan::init_compute_oop_maps() {
2396   // setup lists of potential oops for walking
2397   Interval* oop_intervals;
2398   Interval* non_oop_intervals;
2399 
2400   create_unhandled_lists(&amp;oop_intervals, &amp;non_oop_intervals, is_oop_interval, NULL);
2401 
2402   // intervals that have no oops inside need not to be processed
2403   // to ensure a walking until the last instruction id, add a dummy interval
2404   // with a high operation id
2405   non_oop_intervals = new Interval(any_reg);
2406   non_oop_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
2407 
2408   return new IntervalWalker(this, oop_intervals, non_oop_intervals);
2409 }
2410 
2411 
2412 OopMap* LinearScan::compute_oop_map(IntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
2413   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating oop map at op_id %d&quot;, op-&gt;id()));
2414 
2415   // walk before the current operation -&gt; intervals that start at
2416   // the operation (= output operands of the operation) are not
2417   // included in the oop map
2418   iw-&gt;walk_before(op-&gt;id());
2419 
2420   int frame_size = frame_map()-&gt;framesize();
2421   int arg_count = frame_map()-&gt;oop_map_arg_count();
2422   OopMap* map = new OopMap(frame_size, arg_count);
2423 
2424   // Iterate through active intervals
2425   for (Interval* interval = iw-&gt;active_first(fixedKind); interval != Interval::end(); interval = interval-&gt;next()) {
2426     int assigned_reg = interval-&gt;assigned_reg();
2427 
2428     assert(interval-&gt;current_from() &lt;= op-&gt;id() &amp;&amp; op-&gt;id() &lt;= interval-&gt;current_to(), &quot;interval should not be active otherwise&quot;);
2429     assert(interval-&gt;assigned_regHi() == any_reg, &quot;oop must be single word&quot;);
2430     assert(interval-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base, &quot;fixed interval found&quot;);
2431 
2432     // Check if this range covers the instruction. Intervals that
2433     // start or end at the current operation are not included in the
2434     // oop map, except in the case of patching moves.  For patching
2435     // moves, any intervals which end at this instruction are included
2436     // in the oop map since we may safepoint while doing the patch
2437     // before we&#39;ve consumed the inputs.
2438     if (op-&gt;is_patching() || op-&gt;id() &lt; interval-&gt;current_to()) {
2439 
2440       // caller-save registers must not be included into oop-maps at calls
2441       assert(!is_call_site || assigned_reg &gt;= nof_regs || !is_caller_save(assigned_reg), &quot;interval is in a caller-save register at a call -&gt; register will be overwritten&quot;);
2442 
2443       VMReg name = vm_reg_for_interval(interval);
2444       set_oop(map, name);
2445 
2446       // Spill optimization: when the stack value is guaranteed to be always correct,
2447       // then it must be added to the oop map even if the interval is currently in a register
2448       if (interval-&gt;always_in_memory() &amp;&amp;
2449           op-&gt;id() &gt; interval-&gt;spill_definition_pos() &amp;&amp;
2450           interval-&gt;assigned_reg() != interval-&gt;canonical_spill_slot()) {
2451         assert(interval-&gt;spill_definition_pos() &gt; 0, &quot;position not set correctly&quot;);
2452         assert(interval-&gt;canonical_spill_slot() &gt;= LinearScan::nof_regs, &quot;no spill slot assigned&quot;);
2453         assert(interval-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;interval is on stack, so stack slot is registered twice&quot;);
2454 
2455         set_oop(map, frame_map()-&gt;slot_regname(interval-&gt;canonical_spill_slot() - LinearScan::nof_regs));
2456       }
2457     }
2458   }
2459 
2460   // add oops from lock stack
2461   assert(info-&gt;stack() != NULL, &quot;CodeEmitInfo must always have a stack&quot;);
2462   int locks_count = info-&gt;stack()-&gt;total_locks_size();
2463   for (int i = 0; i &lt; locks_count; i++) {
2464     set_oop(map, frame_map()-&gt;monitor_object_regname(i));
2465   }
2466 
2467   return map;
2468 }
2469 
2470 
2471 void LinearScan::compute_oop_map(IntervalWalker* iw, const LIR_OpVisitState &amp;visitor, LIR_Op* op) {
2472   assert(visitor.info_count() &gt; 0, &quot;no oop map needed&quot;);
2473 
2474   // compute oop_map only for first CodeEmitInfo
2475   // because it is (in most cases) equal for all other infos of the same operation
2476   CodeEmitInfo* first_info = visitor.info_at(0);
2477   OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
2478 
2479   for (int i = 0; i &lt; visitor.info_count(); i++) {
2480     CodeEmitInfo* info = visitor.info_at(i);
2481     OopMap* oop_map = first_oop_map;
2482 
2483     // compute worst case interpreter size in case of a deoptimization
2484     _compilation-&gt;update_interpreter_frame_size(info-&gt;interpreter_frame_size());
2485 
2486     if (info-&gt;stack()-&gt;locks_size() != first_info-&gt;stack()-&gt;locks_size()) {
2487       // this info has a different number of locks then the precomputed oop map
2488       // (possible for lock and unlock instructions) -&gt; compute oop map with
2489       // correct lock information
2490       oop_map = compute_oop_map(iw, op, info, visitor.has_call());
2491     }
2492 
2493     if (info-&gt;_oop_map == NULL) {
2494       info-&gt;_oop_map = oop_map;
2495     } else {
2496       // a CodeEmitInfo can not be shared between different LIR-instructions
2497       // because interval splitting can occur anywhere between two instructions
2498       // and so the oop maps must be different
2499       // -&gt; check if the already set oop_map is exactly the one calculated for this operation
2500       assert(info-&gt;_oop_map == oop_map, &quot;same CodeEmitInfo used for multiple LIR instructions&quot;);
2501     }
2502   }
2503 }
2504 
2505 
2506 // frequently used constants
2507 // Allocate them with new so they are never destroyed (otherwise, a
2508 // forced exit could destroy these objects while they are still in
2509 // use).
2510 ConstantOopWriteValue* LinearScan::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
2511 ConstantIntValue*      LinearScan::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
2512 ConstantIntValue*      LinearScan::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue((jint)0);
2513 ConstantIntValue*      LinearScan::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
2514 ConstantIntValue*      LinearScan::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
2515 LocationValue*         _illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
2516 
2517 void LinearScan::init_compute_debug_info() {
2518   // cache for frequently used scope values
2519   // (cpu registers and stack slots)
2520   int cache_size = (LinearScan::nof_cpu_regs + frame_map()-&gt;argcount() + max_spills()) * 2;
2521   _scope_value_cache = ScopeValueArray(cache_size, cache_size, NULL);
2522 }
2523 
2524 MonitorValue* LinearScan::location_for_monitor_index(int monitor_index) {
2525   Location loc;
2526   if (!frame_map()-&gt;location_for_monitor_object(monitor_index, &amp;loc)) {
2527     bailout(&quot;too large frame&quot;);
2528   }
2529   ScopeValue* object_scope_value = new LocationValue(loc);
2530 
2531   if (!frame_map()-&gt;location_for_monitor_lock(monitor_index, &amp;loc)) {
2532     bailout(&quot;too large frame&quot;);
2533   }
2534   return new MonitorValue(object_scope_value, loc);
2535 }
2536 
2537 LocationValue* LinearScan::location_for_name(int name, Location::Type loc_type) {
2538   Location loc;
2539   if (!frame_map()-&gt;locations_for_slot(name, loc_type, &amp;loc)) {
2540     bailout(&quot;too large frame&quot;);
2541   }
2542   return new LocationValue(loc);
2543 }
2544 
2545 
2546 int LinearScan::append_scope_value_for_constant(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2547   assert(opr-&gt;is_constant(), &quot;should not be called otherwise&quot;);
2548 
2549   LIR_Const* c = opr-&gt;as_constant_ptr();
2550   BasicType t = c-&gt;type();
2551   switch (t) {
2552     case T_OBJECT: {
2553       jobject value = c-&gt;as_jobject();
2554       if (value == NULL) {
2555         scope_values-&gt;append(_oop_null_scope_value);
2556       } else {
2557         scope_values-&gt;append(new ConstantOopWriteValue(c-&gt;as_jobject()));
2558       }
2559       return 1;
2560     }
2561 
2562     case T_INT: // fall through
2563     case T_FLOAT: {
2564       int value = c-&gt;as_jint_bits();
2565       switch (value) {
2566         case -1: scope_values-&gt;append(_int_m1_scope_value); break;
2567         case 0:  scope_values-&gt;append(_int_0_scope_value); break;
2568         case 1:  scope_values-&gt;append(_int_1_scope_value); break;
2569         case 2:  scope_values-&gt;append(_int_2_scope_value); break;
2570         default: scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_bits())); break;
2571       }
2572       return 1;
2573     }
2574 
2575     case T_LONG: // fall through
2576     case T_DOUBLE: {
2577 #ifdef _LP64
2578       scope_values-&gt;append(_int_0_scope_value);
2579       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jlong_bits()));
2580 #else
2581       if (hi_word_offset_in_bytes &gt; lo_word_offset_in_bytes) {
2582         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2583         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2584       } else {
2585         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_lo_bits()));
2586         scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint_hi_bits()));
2587       }
2588 #endif
2589       return 2;
2590     }
2591 
2592     case T_ADDRESS: {
2593 #ifdef _LP64
2594       scope_values-&gt;append(new ConstantLongValue(c-&gt;as_jint()));
2595 #else
2596       scope_values-&gt;append(new ConstantIntValue(c-&gt;as_jint()));
2597 #endif
2598       return 1;
2599     }
2600 
2601     default:
2602       ShouldNotReachHere();
2603       return -1;
2604   }
2605 }
2606 
2607 int LinearScan::append_scope_value_for_operand(LIR_Opr opr, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2608   if (opr-&gt;is_single_stack()) {
2609     int stack_idx = opr-&gt;single_stack_ix();
2610     bool is_oop = opr-&gt;is_oop_register();
2611     int cache_idx = (stack_idx + LinearScan::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
2612 
2613     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2614     if (sv == NULL) {
2615       Location::Type loc_type = is_oop ? Location::oop : Location::normal;
2616       sv = location_for_name(stack_idx, loc_type);
2617       _scope_value_cache.at_put(cache_idx, sv);
2618     }
2619 
2620     // check if cached value is correct
2621     DEBUG_ONLY(assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
2622 
2623     scope_values-&gt;append(sv);
2624     return 1;
2625 
2626   } else if (opr-&gt;is_single_cpu()) {
2627     bool is_oop = opr-&gt;is_oop_register();
2628     int cache_idx = opr-&gt;cpu_regnr() * 2 + (is_oop ? 1 : 0);
2629     Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
2630 
2631     ScopeValue* sv = _scope_value_cache.at(cache_idx);
2632     if (sv == NULL) {
2633       Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
2634       VMReg rname = frame_map()-&gt;regname(opr);
2635       sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2636       _scope_value_cache.at_put(cache_idx, sv);
2637     }
2638 
2639     // check if cached value is correct
2640     DEBUG_ONLY(assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()-&gt;regname(opr)))));
2641 
2642     scope_values-&gt;append(sv);
2643     return 1;
2644 
2645 #ifdef X86
2646   } else if (opr-&gt;is_single_xmm()) {
2647     VMReg rname = opr-&gt;as_xmm_float_reg()-&gt;as_VMReg();
2648     LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
2649 
2650     scope_values-&gt;append(sv);
2651     return 1;
2652 #endif
2653 
2654   } else if (opr-&gt;is_single_fpu()) {
2655 #ifdef IA32
2656     // the exact location of fpu stack values is only known
2657     // during fpu stack allocation, so the stack allocator object
2658     // must be present
2659     assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2660     assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2661     opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2662 #elif defined(AMD64)
2663     assert(false, &quot;FPU not used on x86-64&quot;);
2664 #endif
2665 
2666     Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
2667     VMReg rname = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnr());
2668 #ifndef __SOFTFP__
2669 #ifndef VM_LITTLE_ENDIAN
2670     // On S390 a (single precision) float value occupies only the high
2671     // word of the full double register. So when the double register is
2672     // stored to memory (e.g. by the RegisterSaver), then the float value
2673     // is found at offset 0. I.e. the code below is not needed on S390.
2674 #ifndef S390
2675     if (! float_saved_as_double) {
2676       // On big endian system, we may have an issue if float registers use only
2677       // the low half of the (same) double registers.
2678       // Both the float and the double could have the same regnr but would correspond
2679       // to two different addresses once saved.
2680 
2681       // get next safely (no assertion checks)
2682       VMReg next = VMRegImpl::as_VMReg(1+rname-&gt;value());
2683       if (next-&gt;is_reg() &amp;&amp;
2684           (next-&gt;as_FloatRegister() == rname-&gt;as_FloatRegister())) {
2685         // the back-end does use the same numbering for the double and the float
2686         rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
2687       }
2688     }
2689 #endif // !S390
2690 #endif
2691 #endif
2692     LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
2693 
2694     scope_values-&gt;append(sv);
2695     return 1;
2696 
2697   } else {
2698     // double-size operands
2699 
2700     ScopeValue* first;
2701     ScopeValue* second;
2702 
2703     if (opr-&gt;is_double_stack()) {
2704 #ifdef _LP64
2705       Location loc1;
2706       Location::Type loc_type = opr-&gt;type() == T_LONG ? Location::lng : Location::dbl;
2707       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), loc_type, &amp;loc1, NULL)) {
2708         bailout(&quot;too large frame&quot;);
2709       }
2710       // Does this reverse on x86 vs. sparc?
2711       first =  new LocationValue(loc1);
2712       second = _int_0_scope_value;
2713 #else
2714       Location loc1, loc2;
2715       if (!frame_map()-&gt;locations_for_slot(opr-&gt;double_stack_ix(), Location::normal, &amp;loc1, &amp;loc2)) {
2716         bailout(&quot;too large frame&quot;);
2717       }
2718       first =  new LocationValue(loc1);
2719       second = new LocationValue(loc2);
2720 #endif // _LP64
2721 
2722     } else if (opr-&gt;is_double_cpu()) {
2723 #ifdef _LP64
2724       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2725       first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
2726       second = _int_0_scope_value;
2727 #else
2728       VMReg rname_first = opr-&gt;as_register_lo()-&gt;as_VMReg();
2729       VMReg rname_second = opr-&gt;as_register_hi()-&gt;as_VMReg();
2730 
2731       if (hi_word_offset_in_bytes &lt; lo_word_offset_in_bytes) {
2732         // lo/hi and swapped relative to first and second, so swap them
2733         VMReg tmp = rname_first;
2734         rname_first = rname_second;
2735         rname_second = tmp;
2736       }
2737 
2738       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2739       second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2740 #endif //_LP64
2741 
2742 
2743 #ifdef X86
2744     } else if (opr-&gt;is_double_xmm()) {
2745       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation&quot;);
2746       VMReg rname_first  = opr-&gt;as_xmm_double_reg()-&gt;as_VMReg();
2747 #  ifdef _LP64
2748       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2749       second = _int_0_scope_value;
2750 #  else
2751       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2752       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2753       if (true) {
2754         VMReg rname_second = rname_first-&gt;next();
2755         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2756       }
2757 #  endif
2758 #endif
2759 
2760     } else if (opr-&gt;is_double_fpu()) {
2761       // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
2762       // the double as float registers in the native ordering. On X86,
2763       // fpu_regnrLo is a FPU stack slot whose VMReg represents
2764       // the low-order word of the double and fpu_regnrLo + 1 is the
2765       // name for the other half.  *first and *second must represent the
2766       // least and most significant words, respectively.
2767 
2768 #ifdef IA32
2769       // the exact location of fpu stack values is only known
2770       // during fpu stack allocation, so the stack allocator object
2771       // must be present
2772       assert(use_fpu_stack_allocation(), &quot;should not have float stack values without fpu stack allocation (all floats must be SSE2)&quot;);
2773       assert(_fpu_stack_allocator != NULL, &quot;must be present&quot;);
2774       opr = _fpu_stack_allocator-&gt;to_fpu_stack(opr);
2775 
2776       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2777 #endif
2778 #ifdef AMD64
2779       assert(false, &quot;FPU not used on x86-64&quot;);
2780 #endif
<a name="5" id="anc5"></a><span class="line-removed">2781 #ifdef SPARC</span>
<span class="line-removed">2782       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi() + 1, &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);</span>
<span class="line-removed">2783 #endif</span>
2784 #ifdef ARM32
2785       assert(opr-&gt;fpu_regnrHi() == opr-&gt;fpu_regnrLo() + 1, &quot;assumed in calculation (only fpu_regnrLo is used)&quot;);
2786 #endif
2787 #ifdef PPC32
2788       assert(opr-&gt;fpu_regnrLo() == opr-&gt;fpu_regnrHi(), &quot;assumed in calculation (only fpu_regnrHi is used)&quot;);
2789 #endif
2790 
2791 #ifdef VM_LITTLE_ENDIAN
2792       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrLo());
2793 #else
2794       VMReg rname_first = frame_map()-&gt;fpu_regname(opr-&gt;fpu_regnrHi());
2795 #endif
2796 
2797 #ifdef _LP64
2798       first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
2799       second = _int_0_scope_value;
2800 #else
2801       first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
2802       // %%% This is probably a waste but we&#39;ll keep things as they were for now
2803       if (true) {
2804         VMReg rname_second = rname_first-&gt;next();
2805         second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
2806       }
2807 #endif
2808 
2809     } else {
2810       ShouldNotReachHere();
2811       first = NULL;
2812       second = NULL;
2813     }
2814 
2815     assert(first != NULL &amp;&amp; second != NULL, &quot;must be set&quot;);
2816     // The convention the interpreter uses is that the second local
2817     // holds the first raw word of the native double representation.
2818     // This is actually reasonable, since locals and stack arrays
2819     // grow downwards in all implementations.
2820     // (If, on some machine, the interpreter&#39;s Java locals or stack
2821     // were to grow upwards, the embedded doubles would be word-swapped.)
2822     scope_values-&gt;append(second);
2823     scope_values-&gt;append(first);
2824     return 2;
2825   }
2826 }
2827 
2828 
2829 int LinearScan::append_scope_value(int op_id, Value value, GrowableArray&lt;ScopeValue*&gt;* scope_values) {
2830   if (value != NULL) {
2831     LIR_Opr opr = value-&gt;operand();
2832     Constant* con = value-&gt;as_Constant();
2833 
2834     assert(con == NULL || opr-&gt;is_virtual() || opr-&gt;is_constant() || opr-&gt;is_illegal(), &quot;asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)&quot;);
2835     assert(con != NULL || opr-&gt;is_virtual(), &quot;asumption: non-Constant instructions have only virtual operands&quot;);
2836 
2837     if (con != NULL &amp;&amp; !con-&gt;is_pinned() &amp;&amp; !opr-&gt;is_constant()) {
2838       // Unpinned constants may have a virtual operand for a part of the lifetime
2839       // or may be illegal when it was optimized away,
2840       // so always use a constant operand
2841       opr = LIR_OprFact::value_type(con-&gt;type());
2842     }
2843     assert(opr-&gt;is_virtual() || opr-&gt;is_constant(), &quot;other cases not allowed here&quot;);
2844 
2845     if (opr-&gt;is_virtual()) {
2846       LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
2847 
2848       BlockBegin* block = block_of_op_with_id(op_id);
2849       if (block-&gt;number_of_sux() == 1 &amp;&amp; op_id == block-&gt;last_lir_instruction_id()) {
2850         // generating debug information for the last instruction of a block.
2851         // if this instruction is a branch, spill moves are inserted before this branch
2852         // and so the wrong operand would be returned (spill moves at block boundaries are not
2853         // considered in the live ranges of intervals)
2854         // Solution: use the first op_id of the branch target block instead.
2855         if (block-&gt;lir()-&gt;instructions_list()-&gt;last()-&gt;as_OpBranch() != NULL) {
2856           if (block-&gt;live_out().at(opr-&gt;vreg_number())) {
2857             op_id = block-&gt;sux_at(0)-&gt;first_lir_instruction_id();
2858             mode = LIR_OpVisitState::outputMode;
2859           }
2860         }
2861       }
2862 
2863       // Get current location of operand
2864       // The operand must be live because debug information is considered when building the intervals
2865       // if the interval is not live, color_lir_opr will cause an assertion failure
2866       opr = color_lir_opr(opr, op_id, mode);
2867       assert(!has_call(op_id) || opr-&gt;is_stack() || !is_caller_save(reg_num(opr)), &quot;can not have caller-save register operands at calls&quot;);
2868 
2869       // Append to ScopeValue array
2870       return append_scope_value_for_operand(opr, scope_values);
2871 
2872     } else {
2873       assert(value-&gt;as_Constant() != NULL, &quot;all other instructions have only virtual operands&quot;);
2874       assert(opr-&gt;is_constant(), &quot;operand must be constant&quot;);
2875 
2876       return append_scope_value_for_constant(opr, scope_values);
2877     }
2878   } else {
2879     // append a dummy value because real value not needed
2880     scope_values-&gt;append(_illegal_value);
2881     return 1;
2882   }
2883 }
2884 
2885 
2886 IRScopeDebugInfo* LinearScan::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
2887   IRScopeDebugInfo* caller_debug_info = NULL;
2888 
2889   ValueStack* caller_state = cur_state-&gt;caller_state();
2890   if (caller_state != NULL) {
2891     // process recursively to compute outermost scope first
2892     caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope-&gt;caller(), caller_state, innermost_state);
2893   }
2894 
2895   // initialize these to null.
2896   // If we don&#39;t need deopt info or there are no locals, expressions or monitors,
2897   // then these get recorded as no information and avoids the allocation of 0 length arrays.
2898   GrowableArray&lt;ScopeValue*&gt;*   locals      = NULL;
2899   GrowableArray&lt;ScopeValue*&gt;*   expressions = NULL;
2900   GrowableArray&lt;MonitorValue*&gt;* monitors    = NULL;
2901 
2902   // describe local variable values
2903   int nof_locals = cur_state-&gt;locals_size();
2904   if (nof_locals &gt; 0) {
2905     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2906 
2907     int pos = 0;
2908     while (pos &lt; nof_locals) {
2909       assert(pos &lt; cur_state-&gt;locals_size(), &quot;why not?&quot;);
2910 
2911       Value local = cur_state-&gt;local_at(pos);
2912       pos += append_scope_value(op_id, local, locals);
2913 
2914       assert(locals-&gt;length() == pos, &quot;must match&quot;);
2915     }
2916     assert(locals-&gt;length() == cur_scope-&gt;method()-&gt;max_locals(), &quot;wrong number of locals&quot;);
2917     assert(locals-&gt;length() == cur_state-&gt;locals_size(), &quot;wrong number of locals&quot;);
2918   } else if (cur_scope-&gt;method()-&gt;max_locals() &gt; 0) {
2919     assert(cur_state-&gt;kind() == ValueStack::EmptyExceptionState, &quot;should be&quot;);
2920     nof_locals = cur_scope-&gt;method()-&gt;max_locals();
2921     locals = new GrowableArray&lt;ScopeValue*&gt;(nof_locals);
2922     for(int i = 0; i &lt; nof_locals; i++) {
2923       locals-&gt;append(_illegal_value);
2924     }
2925   }
2926 
2927   // describe expression stack
2928   int nof_stack = cur_state-&gt;stack_size();
2929   if (nof_stack &gt; 0) {
2930     expressions = new GrowableArray&lt;ScopeValue*&gt;(nof_stack);
2931 
2932     int pos = 0;
2933     while (pos &lt; nof_stack) {
2934       Value expression = cur_state-&gt;stack_at_inc(pos);
2935       append_scope_value(op_id, expression, expressions);
2936 
2937       assert(expressions-&gt;length() == pos, &quot;must match&quot;);
2938     }
2939     assert(expressions-&gt;length() == cur_state-&gt;stack_size(), &quot;wrong number of stack entries&quot;);
2940   }
2941 
2942   // describe monitors
2943   int nof_locks = cur_state-&gt;locks_size();
2944   if (nof_locks &gt; 0) {
2945     int lock_offset = cur_state-&gt;caller_state() != NULL ? cur_state-&gt;caller_state()-&gt;total_locks_size() : 0;
2946     monitors = new GrowableArray&lt;MonitorValue*&gt;(nof_locks);
2947     for (int i = 0; i &lt; nof_locks; i++) {
2948       monitors-&gt;append(location_for_monitor_index(lock_offset + i));
2949     }
2950   }
2951 
2952   return new IRScopeDebugInfo(cur_scope, cur_state-&gt;bci(), locals, expressions, monitors, caller_debug_info);
2953 }
2954 
2955 
2956 void LinearScan::compute_debug_info(CodeEmitInfo* info, int op_id) {
2957   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;creating debug information at op_id %d&quot;, op_id));
2958 
2959   IRScope* innermost_scope = info-&gt;scope();
2960   ValueStack* innermost_state = info-&gt;stack();
2961 
2962   assert(innermost_scope != NULL &amp;&amp; innermost_state != NULL, &quot;why is it missing?&quot;);
2963 
2964   DEBUG_ONLY(check_stack_depth(info, innermost_state-&gt;stack_size()));
2965 
2966   if (info-&gt;_scope_debug_info == NULL) {
2967     // compute debug information
2968     info-&gt;_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
2969   } else {
2970     // debug information already set. Check that it is correct from the current point of view
2971     DEBUG_ONLY(assert_equal(info-&gt;_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
2972   }
2973 }
2974 
2975 
2976 void LinearScan::assign_reg_num(LIR_OpList* instructions, IntervalWalker* iw) {
2977   LIR_OpVisitState visitor;
2978   int num_inst = instructions-&gt;length();
2979   bool has_dead = false;
2980 
2981   for (int j = 0; j &lt; num_inst; j++) {
2982     LIR_Op* op = instructions-&gt;at(j);
2983     if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
2984       has_dead = true;
2985       continue;
2986     }
2987     int op_id = op-&gt;id();
2988 
2989     // visit instruction to get list of operands
2990     visitor.visit(op);
2991 
2992     // iterate all modes of the visitor and process all virtual operands
2993     for_each_visitor_mode(mode) {
2994       int n = visitor.opr_count(mode);
2995       for (int k = 0; k &lt; n; k++) {
2996         LIR_Opr opr = visitor.opr_at(mode, k);
2997         if (opr-&gt;is_virtual_register()) {
2998           visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
2999         }
3000       }
3001     }
3002 
3003     if (visitor.info_count() &gt; 0) {
3004       // exception handling
3005       if (compilation()-&gt;has_exception_handlers()) {
3006         XHandlers* xhandlers = visitor.all_xhandler();
3007         int n = xhandlers-&gt;length();
3008         for (int k = 0; k &lt; n; k++) {
3009           XHandler* handler = xhandlers-&gt;handler_at(k);
3010           if (handler-&gt;entry_code() != NULL) {
3011             assign_reg_num(handler-&gt;entry_code()-&gt;instructions_list(), NULL);
3012           }
3013         }
3014       } else {
3015         assert(visitor.all_xhandler()-&gt;length() == 0, &quot;missed exception handler&quot;);
3016       }
3017 
3018       // compute oop map
3019       assert(iw != NULL, &quot;needed for compute_oop_map&quot;);
3020       compute_oop_map(iw, visitor, op);
3021 
3022       // compute debug information
3023       if (!use_fpu_stack_allocation()) {
3024         // compute debug information if fpu stack allocation is not needed.
3025         // when fpu stack allocation is needed, the debug information can not
3026         // be computed here because the exact location of fpu operands is not known
3027         // -&gt; debug information is created inside the fpu stack allocator
3028         int n = visitor.info_count();
3029         for (int k = 0; k &lt; n; k++) {
3030           compute_debug_info(visitor.info_at(k), op_id);
3031         }
3032       }
3033     }
3034 
3035 #ifdef ASSERT
3036     // make sure we haven&#39;t made the op invalid.
3037     op-&gt;verify();
3038 #endif
3039 
3040     // remove useless moves
3041     if (op-&gt;code() == lir_move) {
3042       assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
3043       LIR_Op1* move = (LIR_Op1*)op;
3044       LIR_Opr src = move-&gt;in_opr();
3045       LIR_Opr dst = move-&gt;result_opr();
3046       if (dst == src ||
3047           (!dst-&gt;is_pointer() &amp;&amp; !src-&gt;is_pointer() &amp;&amp;
3048            src-&gt;is_same_register(dst))) {
3049         instructions-&gt;at_put(j, NULL);
3050         has_dead = true;
3051       }
3052     }
3053   }
3054 
3055   if (has_dead) {
3056     // iterate all instructions of the block and remove all null-values.
3057     int insert_point = 0;
3058     for (int j = 0; j &lt; num_inst; j++) {
3059       LIR_Op* op = instructions-&gt;at(j);
3060       if (op != NULL) {
3061         if (insert_point != j) {
3062           instructions-&gt;at_put(insert_point, op);
3063         }
3064         insert_point++;
3065       }
3066     }
3067     instructions-&gt;trunc_to(insert_point);
3068   }
3069 }
3070 
3071 void LinearScan::assign_reg_num() {
3072   TIME_LINEAR_SCAN(timer_assign_reg_num);
3073 
3074   init_compute_debug_info();
3075   IntervalWalker* iw = init_compute_oop_maps();
3076 
3077   int num_blocks = block_count();
3078   for (int i = 0; i &lt; num_blocks; i++) {
3079     BlockBegin* block = block_at(i);
3080     assign_reg_num(block-&gt;lir()-&gt;instructions_list(), iw);
3081   }
3082 }
3083 
3084 
3085 void LinearScan::do_linear_scan() {
3086   NOT_PRODUCT(_total_timer.begin_method());
3087 
3088   number_instructions();
3089 
3090   NOT_PRODUCT(print_lir(1, &quot;Before Register Allocation&quot;));
3091 
3092   compute_local_live_sets();
3093   compute_global_live_sets();
3094   CHECK_BAILOUT();
3095 
3096   build_intervals();
3097   CHECK_BAILOUT();
3098   sort_intervals_before_allocation();
3099 
3100   NOT_PRODUCT(print_intervals(&quot;Before Register Allocation&quot;));
3101   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_before_alloc));
3102 
3103   allocate_registers();
3104   CHECK_BAILOUT();
3105 
3106   resolve_data_flow();
3107   if (compilation()-&gt;has_exception_handlers()) {
3108     resolve_exception_handlers();
3109   }
3110   // fill in number of spill slots into frame_map
3111   propagate_spill_slots();
3112   CHECK_BAILOUT();
3113 
3114   NOT_PRODUCT(print_intervals(&quot;After Register Allocation&quot;));
3115   NOT_PRODUCT(print_lir(2, &quot;LIR after register allocation:&quot;));
3116 
3117   sort_intervals_after_allocation();
3118 
3119   DEBUG_ONLY(verify());
3120 
3121   eliminate_spill_moves();
3122   assign_reg_num();
3123   CHECK_BAILOUT();
3124 
3125   NOT_PRODUCT(print_lir(2, &quot;LIR after assignment of register numbers:&quot;));
3126   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_after_asign));
3127 
3128   { TIME_LINEAR_SCAN(timer_allocate_fpu_stack);
3129 
3130     if (use_fpu_stack_allocation()) {
3131       allocate_fpu_stack(); // Only has effect on Intel
3132       NOT_PRODUCT(print_lir(2, &quot;LIR after FPU stack allocation:&quot;));
3133     }
3134   }
3135 
3136   { TIME_LINEAR_SCAN(timer_optimize_lir);
3137 
3138     EdgeMoveOptimizer::optimize(ir()-&gt;code());
3139     ControlFlowOptimizer::optimize(ir()-&gt;code());
3140     // check that cfg is still correct after optimizations
3141     ir()-&gt;verify();
3142   }
3143 
3144   NOT_PRODUCT(print_lir(1, &quot;Before Code Generation&quot;, false));
3145   NOT_PRODUCT(LinearScanStatistic::compute(this, _stat_final));
3146   NOT_PRODUCT(_total_timer.end_method(this));
3147 }
3148 
3149 
3150 // ********** Printing functions
3151 
3152 #ifndef PRODUCT
3153 
3154 void LinearScan::print_timers(double total) {
3155   _total_timer.print(total);
3156 }
3157 
3158 void LinearScan::print_statistics() {
3159   _stat_before_alloc.print(&quot;before allocation&quot;);
3160   _stat_after_asign.print(&quot;after assignment of register&quot;);
3161   _stat_final.print(&quot;after optimization&quot;);
3162 }
3163 
3164 void LinearScan::print_bitmap(BitMap&amp; b) {
3165   for (unsigned int i = 0; i &lt; b.size(); i++) {
3166     if (b.at(i)) tty-&gt;print(&quot;%d &quot;, i);
3167   }
3168   tty-&gt;cr();
3169 }
3170 
3171 void LinearScan::print_intervals(const char* label) {
3172   if (TraceLinearScanLevel &gt;= 1) {
3173     int i;
3174     tty-&gt;cr();
3175     tty-&gt;print_cr(&quot;%s&quot;, label);
3176 
3177     for (i = 0; i &lt; interval_count(); i++) {
3178       Interval* interval = interval_at(i);
3179       if (interval != NULL) {
3180         interval-&gt;print();
3181       }
3182     }
3183 
3184     tty-&gt;cr();
3185     tty-&gt;print_cr(&quot;--- Basic Blocks ---&quot;);
3186     for (i = 0; i &lt; block_count(); i++) {
3187       BlockBegin* block = block_at(i);
3188       tty-&gt;print(&quot;B%d [%d, %d, %d, %d] &quot;, block-&gt;block_id(), block-&gt;first_lir_instruction_id(), block-&gt;last_lir_instruction_id(), block-&gt;loop_index(), block-&gt;loop_depth());
3189     }
3190     tty-&gt;cr();
3191     tty-&gt;cr();
3192   }
3193 
3194   if (PrintCFGToFile) {
3195     CFGPrinter::print_intervals(&amp;_intervals, label);
3196   }
3197 }
3198 
3199 void LinearScan::print_lir(int level, const char* label, bool hir_valid) {
3200   if (TraceLinearScanLevel &gt;= level) {
3201     tty-&gt;cr();
3202     tty-&gt;print_cr(&quot;%s&quot;, label);
3203     print_LIR(ir()-&gt;linear_scan_order());
3204     tty-&gt;cr();
3205   }
3206 
3207   if (level == 1 &amp;&amp; PrintCFGToFile) {
3208     CFGPrinter::print_cfg(ir()-&gt;linear_scan_order(), label, hir_valid, true);
3209   }
3210 }
3211 
3212 #endif //PRODUCT
3213 
3214 
3215 // ********** verification functions for allocation
3216 // (check that all intervals have a correct register and that no registers are overwritten)
3217 #ifdef ASSERT
3218 
3219 void LinearScan::verify() {
3220   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying intervals ******************************************&quot;));
3221   verify_intervals();
3222 
3223   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that no oops are in fixed intervals ****************&quot;));
3224   verify_no_oops_in_fixed_intervals();
3225 
3226   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying that unpinned constants are not alive across block boundaries&quot;));
3227   verify_constants();
3228 
3229   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* verifying register allocation ********************************&quot;));
3230   verify_registers();
3231 
3232   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;********* no errors found **********************************************&quot;));
3233 }
3234 
3235 void LinearScan::verify_intervals() {
3236   int len = interval_count();
3237   bool has_error = false;
3238 
3239   for (int i = 0; i &lt; len; i++) {
3240     Interval* i1 = interval_at(i);
3241     if (i1 == NULL) continue;
3242 
3243     i1-&gt;check_split_children();
3244 
3245     if (i1-&gt;reg_num() != i) {
3246       tty-&gt;print_cr(&quot;Interval %d is on position %d in list&quot;, i1-&gt;reg_num(), i); i1-&gt;print(); tty-&gt;cr();
3247       has_error = true;
3248     }
3249 
3250     if (i1-&gt;reg_num() &gt;= LIR_OprDesc::vreg_base &amp;&amp; i1-&gt;type() == T_ILLEGAL) {
3251       tty-&gt;print_cr(&quot;Interval %d has no type assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3252       has_error = true;
3253     }
3254 
3255     if (i1-&gt;assigned_reg() == any_reg) {
3256       tty-&gt;print_cr(&quot;Interval %d has no register assigned&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3257       has_error = true;
3258     }
3259 
3260     if (i1-&gt;assigned_reg() == i1-&gt;assigned_regHi()) {
3261       tty-&gt;print_cr(&quot;Interval %d: low and high register equal&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3262       has_error = true;
3263     }
3264 
3265     if (!is_processed_reg_num(i1-&gt;assigned_reg())) {
3266       tty-&gt;print_cr(&quot;Can not have an Interval for an ignored register&quot;); i1-&gt;print(); tty-&gt;cr();
3267       has_error = true;
3268     }
3269 
3270     // special intervals that are created in MoveResolver
3271     // -&gt; ignore them because the range information has no meaning there
3272     if (i1-&gt;from() == 1 &amp;&amp; i1-&gt;to() == 2) continue;
3273 
3274     if (i1-&gt;first() == Range::end()) {
3275       tty-&gt;print_cr(&quot;Interval %d has no Range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3276       has_error = true;
3277     }
3278 
3279     for (Range* r = i1-&gt;first(); r != Range::end(); r = r-&gt;next()) {
3280       if (r-&gt;from() &gt;= r-&gt;to()) {
3281         tty-&gt;print_cr(&quot;Interval %d has zero length range&quot;, i1-&gt;reg_num()); i1-&gt;print(); tty-&gt;cr();
3282         has_error = true;
3283       }
3284     }
3285 
3286     for (int j = i + 1; j &lt; len; j++) {
3287       Interval* i2 = interval_at(j);
3288       if (i2 == NULL || (i2-&gt;from() == 1 &amp;&amp; i2-&gt;to() == 2)) continue;
3289 
3290       int r1 = i1-&gt;assigned_reg();
3291       int r1Hi = i1-&gt;assigned_regHi();
3292       int r2 = i2-&gt;assigned_reg();
3293       int r2Hi = i2-&gt;assigned_regHi();
3294       if ((r1 == r2 || r1 == r2Hi || (r1Hi != any_reg &amp;&amp; (r1Hi == r2 || r1Hi == r2Hi))) &amp;&amp; i1-&gt;intersects(i2)) {
3295         tty-&gt;print_cr(&quot;Intervals %d and %d overlap and have the same register assigned&quot;, i1-&gt;reg_num(), i2-&gt;reg_num());
3296         i1-&gt;print(); tty-&gt;cr();
3297         i2-&gt;print(); tty-&gt;cr();
3298         has_error = true;
3299       }
3300     }
3301   }
3302 
3303   assert(has_error == false, &quot;register allocation invalid&quot;);
3304 }
3305 
3306 
3307 void LinearScan::verify_no_oops_in_fixed_intervals() {
3308   Interval* fixed_intervals;
3309   Interval* other_intervals;
3310   create_unhandled_lists(&amp;fixed_intervals, &amp;other_intervals, is_precolored_cpu_interval, NULL);
3311 
3312   // to ensure a walking until the last instruction id, add a dummy interval
3313   // with a high operation id
3314   other_intervals = new Interval(any_reg);
3315   other_intervals-&gt;add_range(max_jint - 2, max_jint - 1);
3316   IntervalWalker* iw = new IntervalWalker(this, fixed_intervals, other_intervals);
3317 
3318   LIR_OpVisitState visitor;
3319   for (int i = 0; i &lt; block_count(); i++) {
3320     BlockBegin* block = block_at(i);
3321 
3322     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
3323 
3324     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
3325       LIR_Op* op = instructions-&gt;at(j);
3326       int op_id = op-&gt;id();
3327 
3328       visitor.visit(op);
3329 
3330       if (visitor.info_count() &gt; 0) {
3331         iw-&gt;walk_before(op-&gt;id());
3332         bool check_live = true;
3333         if (op-&gt;code() == lir_move) {
3334           LIR_Op1* move = (LIR_Op1*)op;
3335           check_live = (move-&gt;patch_code() == lir_patch_none);
3336         }
3337         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3338         if (branch != NULL &amp;&amp; branch-&gt;stub() != NULL &amp;&amp; branch-&gt;stub()-&gt;is_exception_throw_stub()) {
3339           // Don&#39;t bother checking the stub in this case since the
3340           // exception stub will never return to normal control flow.
3341           check_live = false;
3342         }
3343 
3344         // Make sure none of the fixed registers is live across an
3345         // oopmap since we can&#39;t handle that correctly.
3346         if (check_live) {
3347           for (Interval* interval = iw-&gt;active_first(fixedKind);
3348                interval != Interval::end();
3349                interval = interval-&gt;next()) {
3350             if (interval-&gt;current_to() &gt; op-&gt;id() + 1) {
3351               // This interval is live out of this op so make sure
3352               // that this interval represents some value that&#39;s
3353               // referenced by this op either as an input or output.
3354               bool ok = false;
3355               for_each_visitor_mode(mode) {
3356                 int n = visitor.opr_count(mode);
3357                 for (int k = 0; k &lt; n; k++) {
3358                   LIR_Opr opr = visitor.opr_at(mode, k);
3359                   if (opr-&gt;is_fixed_cpu()) {
3360                     if (interval_at(reg_num(opr)) == interval) {
3361                       ok = true;
3362                       break;
3363                     }
3364                     int hi = reg_numHi(opr);
3365                     if (hi != -1 &amp;&amp; interval_at(hi) == interval) {
3366                       ok = true;
3367                       break;
3368                     }
3369                   }
3370                 }
3371               }
3372               assert(ok, &quot;fixed intervals should never be live across an oopmap point&quot;);
3373             }
3374           }
3375         }
3376       }
3377 
3378       // oop-maps at calls do not contain registers, so check is not needed
3379       if (!visitor.has_call()) {
3380 
3381         for_each_visitor_mode(mode) {
3382           int n = visitor.opr_count(mode);
3383           for (int k = 0; k &lt; n; k++) {
3384             LIR_Opr opr = visitor.opr_at(mode, k);
3385 
3386             if (opr-&gt;is_fixed_cpu() &amp;&amp; opr-&gt;is_oop()) {
3387               // operand is a non-virtual cpu register and contains an oop
3388               TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty); tty-&gt;print(&quot;checking operand &quot;); opr-&gt;print(); tty-&gt;cr());
3389 
3390               Interval* interval = interval_at(reg_num(opr));
3391               assert(interval != NULL, &quot;no interval&quot;);
3392 
3393               if (mode == LIR_OpVisitState::inputMode) {
3394                 if (interval-&gt;to() &gt;= op_id + 1) {
3395                   assert(interval-&gt;to() &lt; op_id + 2 ||
3396                          interval-&gt;has_hole_between(op_id, op_id + 2),
3397                          &quot;oop input operand live after instruction&quot;);
3398                 }
3399               } else if (mode == LIR_OpVisitState::outputMode) {
3400                 if (interval-&gt;from() &lt;= op_id - 1) {
3401                   assert(interval-&gt;has_hole_between(op_id - 1, op_id),
3402                          &quot;oop input operand live after instruction&quot;);
3403                 }
3404               }
3405             }
3406           }
3407         }
3408       }
3409     }
3410   }
3411 }
3412 
3413 
3414 void LinearScan::verify_constants() {
3415   int num_regs = num_virtual_regs();
3416   int size = live_set_size();
3417   int num_blocks = block_count();
3418 
3419   for (int i = 0; i &lt; num_blocks; i++) {
3420     BlockBegin* block = block_at(i);
3421     ResourceBitMap live_at_edge = block-&gt;live_in();
3422 
3423     // visit all registers where the live_at_edge bit is set
3424     for (int r = (int)live_at_edge.get_next_one_offset(0, size); r &lt; size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
3425       TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;checking interval %d of block B%d&quot;, r, block-&gt;block_id()));
3426 
3427       Value value = gen()-&gt;instruction_for_vreg(r);
3428 
3429       assert(value != NULL, &quot;all intervals live across block boundaries must have Value&quot;);
3430       assert(value-&gt;operand()-&gt;is_register() &amp;&amp; value-&gt;operand()-&gt;is_virtual(), &quot;value must have virtual operand&quot;);
3431       assert(value-&gt;operand()-&gt;vreg_number() == r, &quot;register number must match&quot;);
3432       // TKR assert(value-&gt;as_Constant() == NULL || value-&gt;is_pinned(), &quot;only pinned constants can be alive accross block boundaries&quot;);
3433     }
3434   }
3435 }
3436 
3437 
3438 class RegisterVerifier: public StackObj {
3439  private:
3440   LinearScan*   _allocator;
3441   BlockList     _work_list;      // all blocks that must be processed
3442   IntervalsList _saved_states;   // saved information of previous check
3443 
3444   // simplified access to methods of LinearScan
3445   Compilation*  compilation() const              { return _allocator-&gt;compilation(); }
3446   Interval*     interval_at(int reg_num) const   { return _allocator-&gt;interval_at(reg_num); }
3447   int           reg_num(LIR_Opr opr) const       { return _allocator-&gt;reg_num(opr); }
3448 
3449   // currently, only registers are processed
3450   int           state_size()                     { return LinearScan::nof_regs; }
3451 
3452   // accessors
3453   IntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block-&gt;block_id()); }
3454   void          set_state_for_block(BlockBegin* block, IntervalList* saved_state) { _saved_states.at_put(block-&gt;block_id(), saved_state); }
3455   void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
3456 
3457   // helper functions
3458   IntervalList* copy(IntervalList* input_state);
3459   void          state_put(IntervalList* input_state, int reg, Interval* interval);
3460   bool          check_state(IntervalList* input_state, int reg, Interval* interval);
3461 
3462   void process_block(BlockBegin* block);
3463   void process_xhandler(XHandler* xhandler, IntervalList* input_state);
3464   void process_successor(BlockBegin* block, IntervalList* input_state);
3465   void process_operations(LIR_List* ops, IntervalList* input_state);
3466 
3467  public:
3468   RegisterVerifier(LinearScan* allocator)
3469     : _allocator(allocator)
3470     , _work_list(16)
3471     , _saved_states(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), NULL)
3472   { }
3473 
3474   void verify(BlockBegin* start);
3475 };
3476 
3477 
3478 // entry function from LinearScan that starts the verification
3479 void LinearScan::verify_registers() {
3480   RegisterVerifier verifier(this);
3481   verifier.verify(block_at(0));
3482 }
3483 
3484 
3485 void RegisterVerifier::verify(BlockBegin* start) {
3486   // setup input registers (method arguments) for first block
3487   int input_state_len = state_size();
3488   IntervalList* input_state = new IntervalList(input_state_len, input_state_len, NULL);
3489   CallingConvention* args = compilation()-&gt;frame_map()-&gt;incoming_arguments();
3490   for (int n = 0; n &lt; args-&gt;length(); n++) {
3491     LIR_Opr opr = args-&gt;at(n);
3492     if (opr-&gt;is_register()) {
3493       Interval* interval = interval_at(reg_num(opr));
3494 
3495       if (interval-&gt;assigned_reg() &lt; state_size()) {
3496         input_state-&gt;at_put(interval-&gt;assigned_reg(), interval);
3497       }
3498       if (interval-&gt;assigned_regHi() != LinearScan::any_reg &amp;&amp; interval-&gt;assigned_regHi() &lt; state_size()) {
3499         input_state-&gt;at_put(interval-&gt;assigned_regHi(), interval);
3500       }
3501     }
3502   }
3503 
3504   set_state_for_block(start, input_state);
3505   add_to_work_list(start);
3506 
3507   // main loop for verification
3508   do {
3509     BlockBegin* block = _work_list.at(0);
3510     _work_list.remove_at(0);
3511 
3512     process_block(block);
3513   } while (!_work_list.is_empty());
3514 }
3515 
3516 void RegisterVerifier::process_block(BlockBegin* block) {
3517   TRACE_LINEAR_SCAN(2, tty-&gt;cr(); tty-&gt;print_cr(&quot;process_block B%d&quot;, block-&gt;block_id()));
3518 
3519   // must copy state because it is modified
3520   IntervalList* input_state = copy(state_for_block(block));
3521 
3522   if (TraceLinearScanLevel &gt;= 4) {
3523     tty-&gt;print_cr(&quot;Input-State of intervals:&quot;);
3524     tty-&gt;print(&quot;    &quot;);
3525     for (int i = 0; i &lt; state_size(); i++) {
3526       if (input_state-&gt;at(i) != NULL) {
3527         tty-&gt;print(&quot; %4d&quot;, input_state-&gt;at(i)-&gt;reg_num());
3528       } else {
3529         tty-&gt;print(&quot;   __&quot;);
3530       }
3531     }
3532     tty-&gt;cr();
3533     tty-&gt;cr();
3534   }
3535 
3536   // process all operations of the block
3537   process_operations(block-&gt;lir(), input_state);
3538 
3539   // iterate all successors
3540   for (int i = 0; i &lt; block-&gt;number_of_sux(); i++) {
3541     process_successor(block-&gt;sux_at(i), input_state);
3542   }
3543 }
3544 
3545 void RegisterVerifier::process_xhandler(XHandler* xhandler, IntervalList* input_state) {
3546   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_xhandler B%d&quot;, xhandler-&gt;entry_block()-&gt;block_id()));
3547 
3548   // must copy state because it is modified
3549   input_state = copy(input_state);
3550 
3551   if (xhandler-&gt;entry_code() != NULL) {
3552     process_operations(xhandler-&gt;entry_code(), input_state);
3553   }
3554   process_successor(xhandler-&gt;entry_block(), input_state);
3555 }
3556 
3557 void RegisterVerifier::process_successor(BlockBegin* block, IntervalList* input_state) {
3558   IntervalList* saved_state = state_for_block(block);
3559 
3560   if (saved_state != NULL) {
3561     // this block was already processed before.
3562     // check if new input_state is consistent with saved_state
3563 
3564     bool saved_state_correct = true;
3565     for (int i = 0; i &lt; state_size(); i++) {
3566       if (input_state-&gt;at(i) != saved_state-&gt;at(i)) {
3567         // current input_state and previous saved_state assume a different
3568         // interval in this register -&gt; assume that this register is invalid
3569         if (saved_state-&gt;at(i) != NULL) {
3570           // invalidate old calculation only if it assumed that
3571           // register was valid. when the register was already invalid,
3572           // then the old calculation was correct.
3573           saved_state_correct = false;
3574           saved_state-&gt;at_put(i, NULL);
3575 
3576           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;process_successor B%d: invalidating slot %d&quot;, block-&gt;block_id(), i));
3577         }
3578       }
3579     }
3580 
3581     if (saved_state_correct) {
3582       // already processed block with correct input_state
3583       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: previous visit already correct&quot;, block-&gt;block_id()));
3584     } else {
3585       // must re-visit this block
3586       TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: must re-visit because input state changed&quot;, block-&gt;block_id()));
3587       add_to_work_list(block);
3588     }
3589 
3590   } else {
3591     // block was not processed before, so set initial input_state
3592     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;process_successor B%d: initial visit&quot;, block-&gt;block_id()));
3593 
3594     set_state_for_block(block, copy(input_state));
3595     add_to_work_list(block);
3596   }
3597 }
3598 
3599 
3600 IntervalList* RegisterVerifier::copy(IntervalList* input_state) {
3601   IntervalList* copy_state = new IntervalList(input_state-&gt;length());
3602   copy_state-&gt;appendAll(input_state);
3603   return copy_state;
3604 }
3605 
3606 void RegisterVerifier::state_put(IntervalList* input_state, int reg, Interval* interval) {
3607   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3608     if (interval != NULL) {
3609       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = %d&quot;, reg, interval-&gt;reg_num()));
3610     } else if (input_state-&gt;at(reg) != NULL) {
3611       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;        reg[%d] = NULL&quot;, reg));
3612     }
3613 
3614     input_state-&gt;at_put(reg, interval);
3615   }
3616 }
3617 
3618 bool RegisterVerifier::check_state(IntervalList* input_state, int reg, Interval* interval) {
3619   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; state_size()) {
3620     if (input_state-&gt;at(reg) != interval) {
3621       tty-&gt;print_cr(&quot;!! Error in register allocation: register %d does not contain interval %d&quot;, reg, interval-&gt;reg_num());
3622       return true;
3623     }
3624   }
3625   return false;
3626 }
3627 
3628 void RegisterVerifier::process_operations(LIR_List* ops, IntervalList* input_state) {
3629   // visit all instructions of the block
3630   LIR_OpVisitState visitor;
3631   bool has_error = false;
3632 
3633   for (int i = 0; i &lt; ops-&gt;length(); i++) {
3634     LIR_Op* op = ops-&gt;at(i);
3635     visitor.visit(op);
3636 
3637     TRACE_LINEAR_SCAN(4, op-&gt;print_on(tty));
3638 
3639     // check if input operands are correct
3640     int j;
3641     int n = visitor.opr_count(LIR_OpVisitState::inputMode);
3642     for (j = 0; j &lt; n; j++) {
3643       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
3644       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3645         Interval* interval = interval_at(reg_num(opr));
3646         if (op-&gt;id() != -1) {
3647           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::inputMode);
3648         }
3649 
3650         has_error |= check_state(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3651         has_error |= check_state(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3652 
3653         // When an operand is marked with is_last_use, then the fpu stack allocator
3654         // removes the register from the fpu stack -&gt; the register contains no value
3655         if (opr-&gt;is_last_use()) {
3656           state_put(input_state, interval-&gt;assigned_reg(),   NULL);
3657           state_put(input_state, interval-&gt;assigned_regHi(), NULL);
3658         }
3659       }
3660     }
3661 
3662     // invalidate all caller save registers at calls
3663     if (visitor.has_call()) {
3664       for (j = 0; j &lt; FrameMap::nof_caller_save_cpu_regs(); j++) {
3665         state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
3666       }
3667       for (j = 0; j &lt; FrameMap::nof_caller_save_fpu_regs; j++) {
3668         state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
3669       }
3670 
3671 #ifdef X86
3672       int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();
3673       for (j = 0; j &lt; num_caller_save_xmm_regs; j++) {
3674         state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
3675       }
3676 #endif
3677     }
3678 
3679     // process xhandler before output and temp operands
3680     XHandlers* xhandlers = visitor.all_xhandler();
3681     n = xhandlers-&gt;length();
3682     for (int k = 0; k &lt; n; k++) {
3683       process_xhandler(xhandlers-&gt;handler_at(k), input_state);
3684     }
3685 
3686     // set temp operands (some operations use temp operands also as output operands, so can&#39;t set them NULL)
3687     n = visitor.opr_count(LIR_OpVisitState::tempMode);
3688     for (j = 0; j &lt; n; j++) {
3689       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
3690       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3691         Interval* interval = interval_at(reg_num(opr));
3692         if (op-&gt;id() != -1) {
3693           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::tempMode);
3694         }
3695 
3696         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3697         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3698       }
3699     }
3700 
3701     // set output operands
3702     n = visitor.opr_count(LIR_OpVisitState::outputMode);
3703     for (j = 0; j &lt; n; j++) {
3704       LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
3705       if (opr-&gt;is_register() &amp;&amp; LinearScan::is_processed_reg_num(reg_num(opr))) {
3706         Interval* interval = interval_at(reg_num(opr));
3707         if (op-&gt;id() != -1) {
3708           interval = interval-&gt;split_child_at_op_id(op-&gt;id(), LIR_OpVisitState::outputMode);
3709         }
3710 
3711         state_put(input_state, interval-&gt;assigned_reg(),   interval-&gt;split_parent());
3712         state_put(input_state, interval-&gt;assigned_regHi(), interval-&gt;split_parent());
3713       }
3714     }
3715   }
3716   assert(has_error == false, &quot;Error in register allocation&quot;);
3717 }
3718 
3719 #endif // ASSERT
3720 
3721 
3722 
3723 // **** Implementation of MoveResolver ******************************
3724 
3725 MoveResolver::MoveResolver(LinearScan* allocator) :
3726   _allocator(allocator),
3727   _insert_list(NULL),
3728   _insert_idx(-1),
3729   _insertion_buffer(),
3730   _mapping_from(8),
3731   _mapping_from_opr(8),
3732   _mapping_to(8),
3733   _multiple_reads_allowed(false)
3734 {
3735   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3736     _register_blocked[i] = 0;
3737   }
3738   DEBUG_ONLY(check_empty());
3739 }
3740 
3741 
3742 #ifdef ASSERT
3743 
3744 void MoveResolver::check_empty() {
3745   assert(_mapping_from.length() == 0 &amp;&amp; _mapping_from_opr.length() == 0 &amp;&amp; _mapping_to.length() == 0, &quot;list must be empty before and after processing&quot;);
3746   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
3747     assert(register_blocked(i) == 0, &quot;register map must be empty before and after processing&quot;);
3748   }
3749   assert(_multiple_reads_allowed == false, &quot;must have default value&quot;);
3750 }
3751 
3752 void MoveResolver::verify_before_resolve() {
3753   assert(_mapping_from.length() == _mapping_from_opr.length(), &quot;length must be equal&quot;);
3754   assert(_mapping_from.length() == _mapping_to.length(), &quot;length must be equal&quot;);
3755   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;insert position not set&quot;);
3756 
3757   int i, j;
3758   if (!_multiple_reads_allowed) {
3759     for (i = 0; i &lt; _mapping_from.length(); i++) {
3760       for (j = i + 1; j &lt; _mapping_from.length(); j++) {
3761         assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), &quot;cannot read from same interval twice&quot;);
3762       }
3763     }
3764   }
3765 
3766   for (i = 0; i &lt; _mapping_to.length(); i++) {
3767     for (j = i + 1; j &lt; _mapping_to.length(); j++) {
3768       assert(_mapping_to.at(i) != _mapping_to.at(j), &quot;cannot write to same interval twice&quot;);
3769     }
3770   }
3771 
3772 
3773   ResourceBitMap used_regs(LinearScan::nof_regs + allocator()-&gt;frame_map()-&gt;argcount() + allocator()-&gt;max_spills());
3774   if (!_multiple_reads_allowed) {
3775     for (i = 0; i &lt; _mapping_from.length(); i++) {
3776       Interval* it = _mapping_from.at(i);
3777       if (it != NULL) {
3778         assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot read from same register twice&quot;);
3779         used_regs.set_bit(it-&gt;assigned_reg());
3780 
3781         if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3782           assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot read from same register twice&quot;);
3783           used_regs.set_bit(it-&gt;assigned_regHi());
3784         }
3785       }
3786     }
3787   }
3788 
3789   used_regs.clear();
3790   for (i = 0; i &lt; _mapping_to.length(); i++) {
3791     Interval* it = _mapping_to.at(i);
3792     assert(!used_regs.at(it-&gt;assigned_reg()), &quot;cannot write to same register twice&quot;);
3793     used_regs.set_bit(it-&gt;assigned_reg());
3794 
3795     if (it-&gt;assigned_regHi() != LinearScan::any_reg) {
3796       assert(!used_regs.at(it-&gt;assigned_regHi()), &quot;cannot write to same register twice&quot;);
3797       used_regs.set_bit(it-&gt;assigned_regHi());
3798     }
3799   }
3800 
3801   used_regs.clear();
3802   for (i = 0; i &lt; _mapping_from.length(); i++) {
3803     Interval* it = _mapping_from.at(i);
3804     if (it != NULL &amp;&amp; it-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
3805       used_regs.set_bit(it-&gt;assigned_reg());
3806     }
3807   }
3808   for (i = 0; i &lt; _mapping_to.length(); i++) {
3809     Interval* it = _mapping_to.at(i);
3810     assert(!used_regs.at(it-&gt;assigned_reg()) || it-&gt;assigned_reg() == _mapping_from.at(i)-&gt;assigned_reg(), &quot;stack slots used in _mapping_from must be disjoint to _mapping_to&quot;);
3811   }
3812 }
3813 
3814 #endif // ASSERT
3815 
3816 
3817 // mark assigned_reg and assigned_regHi of the interval as blocked
3818 void MoveResolver::block_registers(Interval* it) {
3819   int reg = it-&gt;assigned_reg();
3820   if (reg &lt; LinearScan::nof_regs) {
3821     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3822     set_register_blocked(reg, 1);
3823   }
3824   reg = it-&gt;assigned_regHi();
3825   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3826     assert(_multiple_reads_allowed || register_blocked(reg) == 0, &quot;register already marked as used&quot;);
3827     set_register_blocked(reg, 1);
3828   }
3829 }
3830 
3831 // mark assigned_reg and assigned_regHi of the interval as unblocked
3832 void MoveResolver::unblock_registers(Interval* it) {
3833   int reg = it-&gt;assigned_reg();
3834   if (reg &lt; LinearScan::nof_regs) {
3835     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3836     set_register_blocked(reg, -1);
3837   }
3838   reg = it-&gt;assigned_regHi();
3839   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3840     assert(register_blocked(reg) &gt; 0, &quot;register already marked as unused&quot;);
3841     set_register_blocked(reg, -1);
3842   }
3843 }
3844 
3845 // check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
3846 bool MoveResolver::save_to_process_move(Interval* from, Interval* to) {
3847   int from_reg = -1;
3848   int from_regHi = -1;
3849   if (from != NULL) {
3850     from_reg = from-&gt;assigned_reg();
3851     from_regHi = from-&gt;assigned_regHi();
3852   }
3853 
3854   int reg = to-&gt;assigned_reg();
3855   if (reg &lt; LinearScan::nof_regs) {
3856     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3857       return false;
3858     }
3859   }
3860   reg = to-&gt;assigned_regHi();
3861   if (reg != LinearScan::any_reg &amp;&amp; reg &lt; LinearScan::nof_regs) {
3862     if (register_blocked(reg) &gt; 1 || (register_blocked(reg) == 1 &amp;&amp; reg != from_reg &amp;&amp; reg != from_regHi)) {
3863       return false;
3864     }
3865   }
3866 
3867   return true;
3868 }
3869 
3870 
3871 void MoveResolver::create_insertion_buffer(LIR_List* list) {
3872   assert(!_insertion_buffer.initialized(), &quot;overwriting existing buffer&quot;);
3873   _insertion_buffer.init(list);
3874 }
3875 
3876 void MoveResolver::append_insertion_buffer() {
3877   if (_insertion_buffer.initialized()) {
3878     _insertion_buffer.lir_list()-&gt;append(&amp;_insertion_buffer);
3879   }
3880   assert(!_insertion_buffer.initialized(), &quot;must be uninitialized now&quot;);
3881 
3882   _insert_list = NULL;
3883   _insert_idx = -1;
3884 }
3885 
3886 void MoveResolver::insert_move(Interval* from_interval, Interval* to_interval) {
3887   assert(from_interval-&gt;reg_num() != to_interval-&gt;reg_num(), &quot;from and to interval equal&quot;);
3888   assert(from_interval-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3889   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3890   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3891 
3892   LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval-&gt;reg_num(), from_interval-&gt;type());
3893   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3894 
3895   if (!_multiple_reads_allowed) {
3896     // the last_use flag is an optimization for FPU stack allocation. When the same
3897     // input interval is used in more than one move, then it is too difficult to determine
3898     // if this move is really the last use.
3899     from_opr = from_opr-&gt;make_last_use();
3900   }
3901   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3902 
3903   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3904 }
3905 
3906 void MoveResolver::insert_move(LIR_Opr from_opr, Interval* to_interval) {
3907   assert(from_opr-&gt;type() == to_interval-&gt;type(), &quot;move between different types&quot;);
3908   assert(_insert_list != NULL &amp;&amp; _insert_idx != -1, &quot;must setup insert position first&quot;);
3909   assert(_insertion_buffer.lir_list() == _insert_list, &quot;wrong insertion buffer&quot;);
3910 
3911   LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval-&gt;reg_num(), to_interval-&gt;type());
3912   _insertion_buffer.move(_insert_idx, from_opr, to_opr);
3913 
3914   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: inserted move from constant &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot;  to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
3915 }
3916 
3917 
3918 void MoveResolver::resolve_mappings() {
3919   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: resolving mappings for Block B%d, index %d&quot;, _insert_list-&gt;block() != NULL ? _insert_list-&gt;block()-&gt;block_id() : -1, _insert_idx));
3920   DEBUG_ONLY(verify_before_resolve());
3921 
3922   // Block all registers that are used as input operands of a move.
3923   // When a register is blocked, no move to this register is emitted.
3924   // This is necessary for detecting cycles in moves.
3925   int i;
3926   for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3927     Interval* from_interval = _mapping_from.at(i);
3928     if (from_interval != NULL) {
3929       block_registers(from_interval);
3930     }
3931   }
3932 
3933   int spill_candidate = -1;
3934   while (_mapping_from.length() &gt; 0) {
3935     bool processed_interval = false;
3936 
3937     for (i = _mapping_from.length() - 1; i &gt;= 0; i--) {
3938       Interval* from_interval = _mapping_from.at(i);
3939       Interval* to_interval = _mapping_to.at(i);
3940 
3941       if (save_to_process_move(from_interval, to_interval)) {
3942         // this inverval can be processed because target is free
3943         if (from_interval != NULL) {
3944           insert_move(from_interval, to_interval);
3945           unblock_registers(from_interval);
3946         } else {
3947           insert_move(_mapping_from_opr.at(i), to_interval);
3948         }
3949         _mapping_from.remove_at(i);
3950         _mapping_from_opr.remove_at(i);
3951         _mapping_to.remove_at(i);
3952 
3953         processed_interval = true;
3954       } else if (from_interval != NULL &amp;&amp; from_interval-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
3955         // this interval cannot be processed now because target is not free
3956         // it starts in a register, so it is a possible candidate for spilling
3957         spill_candidate = i;
3958       }
3959     }
3960 
3961     if (!processed_interval) {
3962       // no move could be processed because there is a cycle in the move list
3963       // (e.g. r1 -&gt; r2, r2 -&gt; r1), so one interval must be spilled to memory
3964       guarantee(spill_candidate != -1, &quot;no interval in register for spilling found&quot;);
3965 
3966       // create a new spill interval and assign a stack slot to it
3967       Interval* from_interval = _mapping_from.at(spill_candidate);
3968       Interval* spill_interval = new Interval(-1);
3969       spill_interval-&gt;set_type(from_interval-&gt;type());
3970 
3971       // add a dummy range because real position is difficult to calculate
3972       // Note: this range is a special case when the integrity of the allocation is checked
3973       spill_interval-&gt;add_range(1, 2);
3974 
3975       //       do not allocate a new spill slot for temporary interval, but
3976       //       use spill slot assigned to from_interval. Otherwise moves from
3977       //       one stack slot to another can happen (not allowed by LIR_Assembler
3978       int spill_slot = from_interval-&gt;canonical_spill_slot();
3979       if (spill_slot &lt; 0) {
3980         spill_slot = allocator()-&gt;allocate_spill_slot(type2spill_size[spill_interval-&gt;type()] == 2);
3981         from_interval-&gt;set_canonical_spill_slot(spill_slot);
3982       }
3983       spill_interval-&gt;assign_reg(spill_slot);
3984       allocator()-&gt;append_interval(spill_interval);
3985 
3986       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;created new Interval %d for spilling&quot;, spill_interval-&gt;reg_num()));
3987 
3988       // insert a move from register to stack and update the mapping
3989       insert_move(from_interval, spill_interval);
3990       _mapping_from.at_put(spill_candidate, spill_interval);
3991       unblock_registers(from_interval);
3992     }
3993   }
3994 
3995   // reset to default value
3996   _multiple_reads_allowed = false;
3997 
3998   // check that all intervals have been processed
3999   DEBUG_ONLY(check_empty());
4000 }
4001 
4002 
4003 void MoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
4004   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: setting insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4005   assert(_insert_list == NULL &amp;&amp; _insert_idx == -1, &quot;use move_insert_position instead of set_insert_position when data already set&quot;);
4006 
4007   create_insertion_buffer(insert_list);
4008   _insert_list = insert_list;
4009   _insert_idx = insert_idx;
4010 }
4011 
4012 void MoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
4013   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: moving insert position to Block B%d, index %d&quot;, insert_list-&gt;block() != NULL ? insert_list-&gt;block()-&gt;block_id() : -1, insert_idx));
4014 
4015   if (_insert_list != NULL &amp;&amp; (insert_list != _insert_list || insert_idx != _insert_idx)) {
4016     // insert position changed -&gt; resolve current mappings
4017     resolve_mappings();
4018   }
4019 
4020   if (insert_list != _insert_list) {
4021     // block changed -&gt; append insertion_buffer because it is
4022     // bound to a specific block and create a new insertion_buffer
4023     append_insertion_buffer();
4024     create_insertion_buffer(insert_list);
4025   }
4026 
4027   _insert_list = insert_list;
4028   _insert_idx = insert_idx;
4029 }
4030 
4031 void MoveResolver::add_mapping(Interval* from_interval, Interval* to_interval) {
4032   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;MoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)&quot;, from_interval-&gt;reg_num(), from_interval-&gt;assigned_reg(), from_interval-&gt;assigned_regHi(), to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4033 
4034   _mapping_from.append(from_interval);
4035   _mapping_from_opr.append(LIR_OprFact::illegalOpr);
4036   _mapping_to.append(to_interval);
4037 }
4038 
4039 
4040 void MoveResolver::add_mapping(LIR_Opr from_opr, Interval* to_interval) {
4041   TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;MoveResolver: adding mapping from &quot;); from_opr-&gt;print(); tty-&gt;print_cr(&quot; to %d (%d, %d)&quot;, to_interval-&gt;reg_num(), to_interval-&gt;assigned_reg(), to_interval-&gt;assigned_regHi()));
4042   assert(from_opr-&gt;is_constant(), &quot;only for constants&quot;);
4043 
4044   _mapping_from.append(NULL);
4045   _mapping_from_opr.append(from_opr);
4046   _mapping_to.append(to_interval);
4047 }
4048 
4049 void MoveResolver::resolve_and_append_moves() {
4050   if (has_mappings()) {
4051     resolve_mappings();
4052   }
4053   append_insertion_buffer();
4054 }
4055 
4056 
4057 
4058 // **** Implementation of Range *************************************
4059 
4060 Range::Range(int from, int to, Range* next) :
4061   _from(from),
4062   _to(to),
4063   _next(next)
4064 {
4065 }
4066 
4067 // initialize sentinel
4068 Range* Range::_end = NULL;
4069 void Range::initialize(Arena* arena) {
4070   _end = new (arena) Range(max_jint, max_jint, NULL);
4071 }
4072 
4073 int Range::intersects_at(Range* r2) const {
4074   const Range* r1 = this;
4075 
4076   assert(r1 != NULL &amp;&amp; r2 != NULL, &quot;null ranges not allowed&quot;);
4077   assert(r1 != _end &amp;&amp; r2 != _end, &quot;empty ranges not allowed&quot;);
4078 
4079   do {
4080     if (r1-&gt;from() &lt; r2-&gt;from()) {
4081       if (r1-&gt;to() &lt;= r2-&gt;from()) {
4082         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4083       } else {
4084         return r2-&gt;from();
4085       }
4086     } else if (r2-&gt;from() &lt; r1-&gt;from()) {
4087       if (r2-&gt;to() &lt;= r1-&gt;from()) {
4088         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4089       } else {
4090         return r1-&gt;from();
4091       }
4092     } else { // r1-&gt;from() == r2-&gt;from()
4093       if (r1-&gt;from() == r1-&gt;to()) {
4094         r1 = r1-&gt;next(); if (r1 == _end) return -1;
4095       } else if (r2-&gt;from() == r2-&gt;to()) {
4096         r2 = r2-&gt;next(); if (r2 == _end) return -1;
4097       } else {
4098         return r1-&gt;from();
4099       }
4100     }
4101   } while (true);
4102 }
4103 
4104 #ifndef PRODUCT
4105 void Range::print(outputStream* out) const {
4106   out-&gt;print(&quot;[%d, %d[ &quot;, _from, _to);
4107 }
4108 #endif
4109 
4110 
4111 
4112 // **** Implementation of Interval **********************************
4113 
4114 // initialize sentinel
4115 Interval* Interval::_end = NULL;
4116 void Interval::initialize(Arena* arena) {
4117   Range::initialize(arena);
4118   _end = new (arena) Interval(-1);
4119 }
4120 
4121 Interval::Interval(int reg_num) :
4122   _reg_num(reg_num),
4123   _type(T_ILLEGAL),
4124   _first(Range::end()),
4125   _use_pos_and_kinds(12),
4126   _current(Range::end()),
4127   _next(_end),
4128   _state(invalidState),
4129   _assigned_reg(LinearScan::any_reg),
4130   _assigned_regHi(LinearScan::any_reg),
4131   _cached_to(-1),
4132   _cached_opr(LIR_OprFact::illegalOpr),
4133   _cached_vm_reg(VMRegImpl::Bad()),
4134   _split_children(NULL),
4135   _canonical_spill_slot(-1),
4136   _insert_move_when_activated(false),
4137   _spill_state(noDefinitionFound),
4138   _spill_definition_pos(-1),
4139   _register_hint(NULL)
4140 {
4141   _split_parent = this;
4142   _current_split_child = this;
4143 }
4144 
4145 int Interval::calc_to() {
4146   assert(_first != Range::end(), &quot;interval has no range&quot;);
4147 
4148   Range* r = _first;
4149   while (r-&gt;next() != Range::end()) {
4150     r = r-&gt;next();
4151   }
4152   return r-&gt;to();
4153 }
4154 
4155 
4156 #ifdef ASSERT
4157 // consistency check of split-children
4158 void Interval::check_split_children() {
4159   if (_split_children != NULL &amp;&amp; _split_children-&gt;length() &gt; 0) {
4160     assert(is_split_parent(), &quot;only split parents can have children&quot;);
4161 
4162     for (int i = 0; i &lt; _split_children-&gt;length(); i++) {
4163       Interval* i1 = _split_children-&gt;at(i);
4164 
4165       assert(i1-&gt;split_parent() == this, &quot;not a split child of this interval&quot;);
4166       assert(i1-&gt;type() == type(), &quot;must be equal for all split children&quot;);
4167       assert(i1-&gt;canonical_spill_slot() == canonical_spill_slot(), &quot;must be equal for all split children&quot;);
4168 
4169       for (int j = i + 1; j &lt; _split_children-&gt;length(); j++) {
4170         Interval* i2 = _split_children-&gt;at(j);
4171 
4172         assert(i1-&gt;reg_num() != i2-&gt;reg_num(), &quot;same register number&quot;);
4173 
4174         if (i1-&gt;from() &lt; i2-&gt;from()) {
4175           assert(i1-&gt;to() &lt;= i2-&gt;from() &amp;&amp; i1-&gt;to() &lt; i2-&gt;to(), &quot;intervals overlapping&quot;);
4176         } else {
4177           assert(i2-&gt;from() &lt; i1-&gt;from(), &quot;intervals start at same op_id&quot;);
4178           assert(i2-&gt;to() &lt;= i1-&gt;from() &amp;&amp; i2-&gt;to() &lt; i1-&gt;to(), &quot;intervals overlapping&quot;);
4179         }
4180       }
4181     }
4182   }
4183 }
4184 #endif // ASSERT
4185 
4186 Interval* Interval::register_hint(bool search_split_child) const {
4187   if (!search_split_child) {
4188     return _register_hint;
4189   }
4190 
4191   if (_register_hint != NULL) {
4192     assert(_register_hint-&gt;is_split_parent(), &quot;ony split parents are valid hint registers&quot;);
4193 
4194     if (_register_hint-&gt;assigned_reg() &gt;= 0 &amp;&amp; _register_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4195       return _register_hint;
4196 
4197     } else if (_register_hint-&gt;_split_children != NULL &amp;&amp; _register_hint-&gt;_split_children-&gt;length() &gt; 0) {
4198       // search the first split child that has a register assigned
4199       int len = _register_hint-&gt;_split_children-&gt;length();
4200       for (int i = 0; i &lt; len; i++) {
4201         Interval* cur = _register_hint-&gt;_split_children-&gt;at(i);
4202 
4203         if (cur-&gt;assigned_reg() &gt;= 0 &amp;&amp; cur-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
4204           return cur;
4205         }
4206       }
4207     }
4208   }
4209 
4210   // no hint interval found that has a register assigned
4211   return NULL;
4212 }
4213 
4214 
4215 Interval* Interval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
4216   assert(is_split_parent(), &quot;can only be called for split parents&quot;);
4217   assert(op_id &gt;= 0, &quot;invalid op_id (method can not be called for spill moves)&quot;);
4218 
4219   Interval* result;
4220   if (_split_children == NULL || _split_children-&gt;length() == 0) {
4221     result = this;
4222   } else {
4223     result = NULL;
4224     int len = _split_children-&gt;length();
4225 
4226     // in outputMode, the end of the interval (op_id == cur-&gt;to()) is not valid
4227     int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
4228 
4229     int i;
4230     for (i = 0; i &lt; len; i++) {
4231       Interval* cur = _split_children-&gt;at(i);
4232       if (cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to() + to_offset) {
4233         if (i &gt; 0) {
4234           // exchange current split child to start of list (faster access for next call)
4235           _split_children-&gt;at_put(i, _split_children-&gt;at(0));
4236           _split_children-&gt;at_put(0, cur);
4237         }
4238 
4239         // interval found
4240         result = cur;
4241         break;
4242       }
4243     }
4244 
4245 #ifdef ASSERT
4246     for (i = 0; i &lt; len; i++) {
4247       Interval* tmp = _split_children-&gt;at(i);
4248       if (tmp != result &amp;&amp; tmp-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; tmp-&gt;to() + to_offset) {
4249         tty-&gt;print_cr(&quot;two valid result intervals found for op_id %d: %d and %d&quot;, op_id, result-&gt;reg_num(), tmp-&gt;reg_num());
4250         result-&gt;print();
4251         tmp-&gt;print();
4252         assert(false, &quot;two valid result intervals found&quot;);
4253       }
4254     }
4255 #endif
4256   }
4257 
4258   assert(result != NULL, &quot;no matching interval found&quot;);
4259   assert(result-&gt;covers(op_id, mode), &quot;op_id not covered by interval&quot;);
4260 
4261   return result;
4262 }
4263 
4264 
4265 // returns the last split child that ends before the given op_id
4266 Interval* Interval::split_child_before_op_id(int op_id) {
4267   assert(op_id &gt;= 0, &quot;invalid op_id&quot;);
4268 
4269   Interval* parent = split_parent();
4270   Interval* result = NULL;
4271 
4272   assert(parent-&gt;_split_children != NULL, &quot;no split children available&quot;);
4273   int len = parent-&gt;_split_children-&gt;length();
4274   assert(len &gt; 0, &quot;no split children available&quot;);
4275 
4276   for (int i = len - 1; i &gt;= 0; i--) {
4277     Interval* cur = parent-&gt;_split_children-&gt;at(i);
4278     if (cur-&gt;to() &lt;= op_id &amp;&amp; (result == NULL || result-&gt;to() &lt; cur-&gt;to())) {
4279       result = cur;
4280     }
4281   }
4282 
4283   assert(result != NULL, &quot;no split child found&quot;);
4284   return result;
4285 }
4286 
4287 
4288 // Note: use positions are sorted descending -&gt; first use has highest index
4289 int Interval::first_usage(IntervalUseKind min_use_kind) const {
4290   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4291 
4292   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4293     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4294       return _use_pos_and_kinds.at(i);
4295     }
4296   }
4297   return max_jint;
4298 }
4299 
4300 int Interval::next_usage(IntervalUseKind min_use_kind, int from) const {
4301   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4302 
4303   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4304     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4305       return _use_pos_and_kinds.at(i);
4306     }
4307   }
4308   return max_jint;
4309 }
4310 
4311 int Interval::next_usage_exact(IntervalUseKind exact_use_kind, int from) const {
4312   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4313 
4314   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4315     if (_use_pos_and_kinds.at(i) &gt;= from &amp;&amp; _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
4316       return _use_pos_and_kinds.at(i);
4317     }
4318   }
4319   return max_jint;
4320 }
4321 
4322 int Interval::previous_usage(IntervalUseKind min_use_kind, int from) const {
4323   assert(LinearScan::is_virtual_interval(this), &quot;cannot access use positions for fixed intervals&quot;);
4324 
4325   int prev = 0;
4326   for (int i = _use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4327     if (_use_pos_and_kinds.at(i) &gt; from) {
4328       return prev;
4329     }
4330     if (_use_pos_and_kinds.at(i + 1) &gt;= min_use_kind) {
4331       prev = _use_pos_and_kinds.at(i);
4332     }
4333   }
4334   return prev;
4335 }
4336 
4337 void Interval::add_use_pos(int pos, IntervalUseKind use_kind) {
4338   assert(covers(pos, LIR_OpVisitState::inputMode), &quot;use position not covered by live range&quot;);
4339 
4340   // do not add use positions for precolored intervals because
4341   // they are never used
4342   if (use_kind != noUse &amp;&amp; reg_num() &gt;= LIR_OprDesc::vreg_base) {
4343 #ifdef ASSERT
4344     assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4345     for (int i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4346       assert(pos &lt;= _use_pos_and_kinds.at(i), &quot;already added a use-position with lower position&quot;);
4347       assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4348       if (i &gt; 0) {
4349         assert(_use_pos_and_kinds.at(i) &lt; _use_pos_and_kinds.at(i - 2), &quot;not sorted descending&quot;);
4350       }
4351     }
4352 #endif
4353 
4354     // Note: add_use is called in descending order, so list gets sorted
4355     //       automatically by just appending new use positions
4356     int len = _use_pos_and_kinds.length();
4357     if (len == 0 || _use_pos_and_kinds.at(len - 2) &gt; pos) {
4358       _use_pos_and_kinds.append(pos);
4359       _use_pos_and_kinds.append(use_kind);
4360     } else if (_use_pos_and_kinds.at(len - 1) &lt; use_kind) {
4361       assert(_use_pos_and_kinds.at(len - 2) == pos, &quot;list not sorted correctly&quot;);
4362       _use_pos_and_kinds.at_put(len - 1, use_kind);
4363     }
4364   }
4365 }
4366 
4367 void Interval::add_range(int from, int to) {
4368   assert(from &lt; to, &quot;invalid range&quot;);
4369   assert(first() == Range::end() || to &lt; first()-&gt;next()-&gt;from(), &quot;not inserting at begin of interval&quot;);
4370   assert(from &lt;= first()-&gt;to(), &quot;not inserting at begin of interval&quot;);
4371 
4372   if (first()-&gt;from() &lt;= to) {
4373     // join intersecting ranges
4374     first()-&gt;set_from(MIN2(from, first()-&gt;from()));
4375     first()-&gt;set_to  (MAX2(to,   first()-&gt;to()));
4376   } else {
4377     // insert new range
4378     _first = new Range(from, to, first());
4379   }
4380 }
4381 
4382 Interval* Interval::new_split_child() {
4383   // allocate new interval
4384   Interval* result = new Interval(-1);
4385   result-&gt;set_type(type());
4386 
4387   Interval* parent = split_parent();
4388   result-&gt;_split_parent = parent;
4389   result-&gt;set_register_hint(parent);
4390 
4391   // insert new interval in children-list of parent
4392   if (parent-&gt;_split_children == NULL) {
4393     assert(is_split_parent(), &quot;list must be initialized at first split&quot;);
4394 
4395     parent-&gt;_split_children = new IntervalList(4);
4396     parent-&gt;_split_children-&gt;append(this);
4397   }
4398   parent-&gt;_split_children-&gt;append(result);
4399 
4400   return result;
4401 }
4402 
4403 // split this interval at the specified position and return
4404 // the remainder as a new interval.
4405 //
4406 // when an interval is split, a bi-directional link is established between the original interval
4407 // (the split parent) and the intervals that are split off this interval (the split children)
4408 // When a split child is split again, the new created interval is also a direct child
4409 // of the original parent (there is no tree of split children stored, but a flat list)
4410 // All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
4411 //
4412 // Note: The new interval has no valid reg_num
4413 Interval* Interval::split(int split_pos) {
4414   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4415 
4416   // allocate new interval
4417   Interval* result = new_split_child();
4418 
4419   // split the ranges
4420   Range* prev = NULL;
4421   Range* cur = _first;
4422   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt;= split_pos) {
4423     prev = cur;
4424     cur = cur-&gt;next();
4425   }
4426   assert(cur != Range::end(), &quot;split interval after end of last range&quot;);
4427 
4428   if (cur-&gt;from() &lt; split_pos) {
4429     result-&gt;_first = new Range(split_pos, cur-&gt;to(), cur-&gt;next());
4430     cur-&gt;set_to(split_pos);
4431     cur-&gt;set_next(Range::end());
4432 
4433   } else {
4434     assert(prev != NULL, &quot;split before start of first range&quot;);
4435     result-&gt;_first = cur;
4436     prev-&gt;set_next(Range::end());
4437   }
4438   result-&gt;_current = result-&gt;_first;
4439   _cached_to = -1; // clear cached value
4440 
4441   // split list of use positions
4442   int total_len = _use_pos_and_kinds.length();
4443   int start_idx = total_len - 2;
4444   while (start_idx &gt;= 0 &amp;&amp; _use_pos_and_kinds.at(start_idx) &lt; split_pos) {
4445     start_idx -= 2;
4446   }
4447 
4448   intStack new_use_pos_and_kinds(total_len - start_idx);
4449   int i;
4450   for (i = start_idx + 2; i &lt; total_len; i++) {
4451     new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
4452   }
4453 
4454   _use_pos_and_kinds.trunc_to(start_idx + 2);
4455   result-&gt;_use_pos_and_kinds = _use_pos_and_kinds;
4456   _use_pos_and_kinds = new_use_pos_and_kinds;
4457 
4458 #ifdef ASSERT
4459   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4460   assert(result-&gt;_use_pos_and_kinds.length() % 2 == 0, &quot;must have use kind for each use pos&quot;);
4461   assert(_use_pos_and_kinds.length() + result-&gt;_use_pos_and_kinds.length() == total_len, &quot;missed some entries&quot;);
4462 
4463   for (i = 0; i &lt; _use_pos_and_kinds.length(); i += 2) {
4464     assert(_use_pos_and_kinds.at(i) &lt; split_pos, &quot;must be&quot;);
4465     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4466   }
4467   for (i = 0; i &lt; result-&gt;_use_pos_and_kinds.length(); i += 2) {
4468     assert(result-&gt;_use_pos_and_kinds.at(i) &gt;= split_pos, &quot;must be&quot;);
4469     assert(result-&gt;_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; result-&gt;_use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4470   }
4471 #endif
4472 
4473   return result;
4474 }
4475 
4476 // split this interval at the specified position and return
4477 // the head as a new interval (the original interval is the tail)
4478 //
4479 // Currently, only the first range can be split, and the new interval
4480 // must not have split positions
4481 Interval* Interval::split_from_start(int split_pos) {
4482   assert(LinearScan::is_virtual_interval(this), &quot;cannot split fixed intervals&quot;);
4483   assert(split_pos &gt; from() &amp;&amp; split_pos &lt; to(), &quot;can only split inside interval&quot;);
4484   assert(split_pos &gt; _first-&gt;from() &amp;&amp; split_pos &lt;= _first-&gt;to(), &quot;can only split inside first range&quot;);
4485   assert(first_usage(noUse) &gt; split_pos, &quot;can not split when use positions are present&quot;);
4486 
4487   // allocate new interval
4488   Interval* result = new_split_child();
4489 
4490   // the new created interval has only one range (checked by assertion above),
4491   // so the splitting of the ranges is very simple
4492   result-&gt;add_range(_first-&gt;from(), split_pos);
4493 
4494   if (split_pos == _first-&gt;to()) {
4495     assert(_first-&gt;next() != Range::end(), &quot;must not be at end&quot;);
4496     _first = _first-&gt;next();
4497   } else {
4498     _first-&gt;set_from(split_pos);
4499   }
4500 
4501   return result;
4502 }
4503 
4504 
4505 // returns true if the op_id is inside the interval
4506 bool Interval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
4507   Range* cur  = _first;
4508 
4509   while (cur != Range::end() &amp;&amp; cur-&gt;to() &lt; op_id) {
4510     cur = cur-&gt;next();
4511   }
4512   if (cur != Range::end()) {
4513     assert(cur-&gt;to() != cur-&gt;next()-&gt;from(), &quot;ranges not separated&quot;);
4514 
4515     if (mode == LIR_OpVisitState::outputMode) {
4516       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt; cur-&gt;to();
4517     } else {
4518       return cur-&gt;from() &lt;= op_id &amp;&amp; op_id &lt;= cur-&gt;to();
4519     }
4520   }
4521   return false;
4522 }
4523 
4524 // returns true if the interval has any hole between hole_from and hole_to
4525 // (even if the hole has only the length 1)
4526 bool Interval::has_hole_between(int hole_from, int hole_to) {
4527   assert(hole_from &lt; hole_to, &quot;check&quot;);
4528   assert(from() &lt;= hole_from &amp;&amp; hole_to &lt;= to(), &quot;index out of interval&quot;);
4529 
4530   Range* cur  = _first;
4531   while (cur != Range::end()) {
4532     assert(cur-&gt;to() &lt; cur-&gt;next()-&gt;from(), &quot;no space between ranges&quot;);
4533 
4534     // hole-range starts before this range -&gt; hole
4535     if (hole_from &lt; cur-&gt;from()) {
4536       return true;
4537 
4538     // hole-range completely inside this range -&gt; no hole
4539     } else if (hole_to &lt;= cur-&gt;to()) {
4540       return false;
4541 
4542     // overlapping of hole-range with this range -&gt; hole
4543     } else if (hole_from &lt;= cur-&gt;to()) {
4544       return true;
4545     }
4546 
4547     cur = cur-&gt;next();
4548   }
4549 
4550   return false;
4551 }
4552 
4553 
4554 #ifndef PRODUCT
4555 void Interval::print(outputStream* out) const {
4556   const char* SpillState2Name[] = { &quot;no definition&quot;, &quot;no spill store&quot;, &quot;one spill store&quot;, &quot;store at definition&quot;, &quot;start in memory&quot;, &quot;no optimization&quot; };
4557   const char* UseKind2Name[] = { &quot;N&quot;, &quot;L&quot;, &quot;S&quot;, &quot;M&quot; };
4558 
4559   const char* type_name;
4560   LIR_Opr opr = LIR_OprFact::illegal();
4561   if (reg_num() &lt; LIR_OprDesc::vreg_base) {
4562     type_name = &quot;fixed&quot;;
4563     // need a temporary operand for fixed intervals because type() cannot be called
4564 #ifdef X86
4565     int last_xmm_reg = pd_last_xmm_reg;
4566 #ifdef _LP64
4567     if (UseAVX &lt; 3) {
4568       last_xmm_reg = pd_first_xmm_reg + (pd_nof_xmm_regs_frame_map / 2) - 1;
4569     }
4570 #endif
4571 #endif
4572     if (assigned_reg() &gt;= pd_first_cpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_cpu_reg) {
4573       opr = LIR_OprFact::single_cpu(assigned_reg());
4574     } else if (assigned_reg() &gt;= pd_first_fpu_reg &amp;&amp; assigned_reg() &lt;= pd_last_fpu_reg) {
4575       opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
4576 #ifdef X86
4577     } else if (assigned_reg() &gt;= pd_first_xmm_reg &amp;&amp; assigned_reg() &lt;= last_xmm_reg) {
4578       opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
4579 #endif
4580     } else {
4581       ShouldNotReachHere();
4582     }
4583   } else {
4584     type_name = type2name(type());
4585     if (assigned_reg() != -1 &amp;&amp;
4586         (LinearScan::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
4587       opr = LinearScan::calc_operand_for_interval(this);
4588     }
4589   }
4590 
4591   out-&gt;print(&quot;%d %s &quot;, reg_num(), type_name);
4592   if (opr-&gt;is_valid()) {
4593     out-&gt;print(&quot;\&quot;&quot;);
4594     opr-&gt;print(out);
4595     out-&gt;print(&quot;\&quot; &quot;);
4596   }
4597   out-&gt;print(&quot;%d %d &quot;, split_parent()-&gt;reg_num(), (register_hint(false) != NULL ? register_hint(false)-&gt;reg_num() : -1));
4598 
4599   // print ranges
4600   Range* cur = _first;
4601   while (cur != Range::end()) {
4602     cur-&gt;print(out);
4603     cur = cur-&gt;next();
4604     assert(cur != NULL, &quot;range list not closed with range sentinel&quot;);
4605   }
4606 
4607   // print use positions
4608   int prev = 0;
4609   assert(_use_pos_and_kinds.length() % 2 == 0, &quot;must be&quot;);
4610   for (int i =_use_pos_and_kinds.length() - 2; i &gt;= 0; i -= 2) {
4611     assert(_use_pos_and_kinds.at(i + 1) &gt;= firstValidKind &amp;&amp; _use_pos_and_kinds.at(i + 1) &lt;= lastValidKind, &quot;invalid use kind&quot;);
4612     assert(prev &lt; _use_pos_and_kinds.at(i), &quot;use positions not sorted&quot;);
4613 
4614     out-&gt;print(&quot;%d %s &quot;, _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
4615     prev = _use_pos_and_kinds.at(i);
4616   }
4617 
4618   out-&gt;print(&quot; \&quot;%s\&quot;&quot;, SpillState2Name[spill_state()]);
4619   out-&gt;cr();
4620 }
4621 #endif
4622 
4623 
4624 
4625 // **** Implementation of IntervalWalker ****************************
4626 
4627 IntervalWalker::IntervalWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4628  : _compilation(allocator-&gt;compilation())
4629  , _allocator(allocator)
4630 {
4631   _unhandled_first[fixedKind] = unhandled_fixed_first;
4632   _unhandled_first[anyKind]   = unhandled_any_first;
4633   _active_first[fixedKind]    = Interval::end();
4634   _inactive_first[fixedKind]  = Interval::end();
4635   _active_first[anyKind]      = Interval::end();
4636   _inactive_first[anyKind]    = Interval::end();
4637   _current_position = -1;
4638   _current = NULL;
4639   next_interval();
4640 }
4641 
4642 
4643 // append interval in order of current range from()
4644 void IntervalWalker::append_sorted(Interval** list, Interval* interval) {
4645   Interval* prev = NULL;
4646   Interval* cur  = *list;
4647   while (cur-&gt;current_from() &lt; interval-&gt;current_from()) {
4648     prev = cur; cur = cur-&gt;next();
4649   }
4650   if (prev == NULL) {
4651     *list = interval;
4652   } else {
4653     prev-&gt;set_next(interval);
4654   }
4655   interval-&gt;set_next(cur);
4656 }
4657 
4658 void IntervalWalker::append_to_unhandled(Interval** list, Interval* interval) {
4659   assert(interval-&gt;from() &gt;= current()-&gt;current_from(), &quot;cannot append new interval before current walk position&quot;);
4660 
4661   Interval* prev = NULL;
4662   Interval* cur  = *list;
4663   while (cur-&gt;from() &lt; interval-&gt;from() || (cur-&gt;from() == interval-&gt;from() &amp;&amp; cur-&gt;first_usage(noUse) &lt; interval-&gt;first_usage(noUse))) {
4664     prev = cur; cur = cur-&gt;next();
4665   }
4666   if (prev == NULL) {
4667     *list = interval;
4668   } else {
4669     prev-&gt;set_next(interval);
4670   }
4671   interval-&gt;set_next(cur);
4672 }
4673 
4674 
4675 inline bool IntervalWalker::remove_from_list(Interval** list, Interval* i) {
4676   while (*list != Interval::end() &amp;&amp; *list != i) {
4677     list = (*list)-&gt;next_addr();
4678   }
4679   if (*list != Interval::end()) {
4680     assert(*list == i, &quot;check&quot;);
4681     *list = (*list)-&gt;next();
4682     return true;
4683   } else {
4684     return false;
4685   }
4686 }
4687 
4688 void IntervalWalker::remove_from_list(Interval* i) {
4689   bool deleted;
4690 
4691   if (i-&gt;state() == activeState) {
4692     deleted = remove_from_list(active_first_addr(anyKind), i);
4693   } else {
4694     assert(i-&gt;state() == inactiveState, &quot;invalid state&quot;);
4695     deleted = remove_from_list(inactive_first_addr(anyKind), i);
4696   }
4697 
4698   assert(deleted, &quot;interval has not been found in list&quot;);
4699 }
4700 
4701 
4702 void IntervalWalker::walk_to(IntervalState state, int from) {
4703   assert (state == activeState || state == inactiveState, &quot;wrong state&quot;);
4704   for_each_interval_kind(kind) {
4705     Interval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
4706     Interval* next   = *prev;
4707     while (next-&gt;current_from() &lt;= from) {
4708       Interval* cur = next;
4709       next = cur-&gt;next();
4710 
4711       bool range_has_changed = false;
4712       while (cur-&gt;current_to() &lt;= from) {
4713         cur-&gt;next_range();
4714         range_has_changed = true;
4715       }
4716 
4717       // also handle move from inactive list to active list
4718       range_has_changed = range_has_changed || (state == inactiveState &amp;&amp; cur-&gt;current_from() &lt;= from);
4719 
4720       if (range_has_changed) {
4721         // remove cur from list
4722         *prev = next;
4723         if (cur-&gt;current_at_end()) {
4724           // move to handled state (not maintained as a list)
4725           cur-&gt;set_state(handledState);
4726           interval_moved(cur, kind, state, handledState);
4727         } else if (cur-&gt;current_from() &lt;= from){
4728           // sort into active list
4729           append_sorted(active_first_addr(kind), cur);
4730           cur-&gt;set_state(activeState);
4731           if (*prev == cur) {
4732             assert(state == activeState, &quot;check&quot;);
4733             prev = cur-&gt;next_addr();
4734           }
4735           interval_moved(cur, kind, state, activeState);
4736         } else {
4737           // sort into inactive list
4738           append_sorted(inactive_first_addr(kind), cur);
4739           cur-&gt;set_state(inactiveState);
4740           if (*prev == cur) {
4741             assert(state == inactiveState, &quot;check&quot;);
4742             prev = cur-&gt;next_addr();
4743           }
4744           interval_moved(cur, kind, state, inactiveState);
4745         }
4746       } else {
4747         prev = cur-&gt;next_addr();
4748         continue;
4749       }
4750     }
4751   }
4752 }
4753 
4754 
4755 void IntervalWalker::next_interval() {
4756   IntervalKind kind;
4757   Interval* any   = _unhandled_first[anyKind];
4758   Interval* fixed = _unhandled_first[fixedKind];
4759 
4760   if (any != Interval::end()) {
4761     // intervals may start at same position -&gt; prefer fixed interval
4762     kind = fixed != Interval::end() &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ? fixedKind : anyKind;
4763 
4764     assert (kind == fixedKind &amp;&amp; fixed-&gt;from() &lt;= any-&gt;from() ||
4765             kind == anyKind   &amp;&amp; any-&gt;from() &lt;= fixed-&gt;from(), &quot;wrong interval!!!&quot;);
4766     assert(any == Interval::end() || fixed == Interval::end() || any-&gt;from() != fixed-&gt;from() || kind == fixedKind, &quot;if fixed and any-Interval start at same position, fixed must be processed first&quot;);
4767 
4768   } else if (fixed != Interval::end()) {
4769     kind = fixedKind;
4770   } else {
4771     _current = NULL; return;
4772   }
4773   _current_kind = kind;
4774   _current = _unhandled_first[kind];
4775   _unhandled_first[kind] = _current-&gt;next();
4776   _current-&gt;set_next(Interval::end());
4777   _current-&gt;rewind_range();
4778 }
4779 
4780 
4781 void IntervalWalker::walk_to(int lir_op_id) {
4782   assert(_current_position &lt;= lir_op_id, &quot;can not walk backwards&quot;);
4783   while (current() != NULL) {
4784     bool is_active = current()-&gt;from() &lt;= lir_op_id;
4785     int id = is_active ? current()-&gt;from() : lir_op_id;
4786 
4787     TRACE_LINEAR_SCAN(2, if (_current_position &lt; id) { tty-&gt;cr(); tty-&gt;print_cr(&quot;walk_to(%d) **************************************************************&quot;, id); })
4788 
4789     // set _current_position prior to call of walk_to
4790     _current_position = id;
4791 
4792     // call walk_to even if _current_position == id
4793     walk_to(activeState, id);
4794     walk_to(inactiveState, id);
4795 
4796     if (is_active) {
4797       current()-&gt;set_state(activeState);
4798       if (activate_current()) {
4799         append_sorted(active_first_addr(current_kind()), current());
4800         interval_moved(current(), current_kind(), unhandledState, activeState);
4801       }
4802 
4803       next_interval();
4804     } else {
4805       return;
4806     }
4807   }
4808 }
4809 
4810 void IntervalWalker::interval_moved(Interval* interval, IntervalKind kind, IntervalState from, IntervalState to) {
4811 #ifndef PRODUCT
4812   if (TraceLinearScanLevel &gt;= 4) {
4813     #define print_state(state) \
4814     switch(state) {\
4815       case unhandledState: tty-&gt;print(&quot;unhandled&quot;); break;\
4816       case activeState: tty-&gt;print(&quot;active&quot;); break;\
4817       case inactiveState: tty-&gt;print(&quot;inactive&quot;); break;\
4818       case handledState: tty-&gt;print(&quot;handled&quot;); break;\
4819       default: ShouldNotReachHere(); \
4820     }
4821 
4822     print_state(from); tty-&gt;print(&quot; to &quot;); print_state(to);
4823     tty-&gt;fill_to(23);
4824     interval-&gt;print();
4825 
4826     #undef print_state
4827   }
4828 #endif
4829 }
4830 
4831 
4832 
4833 // **** Implementation of LinearScanWalker **************************
4834 
4835 LinearScanWalker::LinearScanWalker(LinearScan* allocator, Interval* unhandled_fixed_first, Interval* unhandled_any_first)
4836   : IntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
4837   , _move_resolver(allocator)
4838 {
4839   for (int i = 0; i &lt; LinearScan::nof_regs; i++) {
4840     _spill_intervals[i] = new IntervalList(2);
4841   }
4842 }
4843 
4844 
4845 inline void LinearScanWalker::init_use_lists(bool only_process_use_pos) {
4846   for (int i = _first_reg; i &lt;= _last_reg; i++) {
4847     _use_pos[i] = max_jint;
4848 
4849     if (!only_process_use_pos) {
4850       _block_pos[i] = max_jint;
4851       _spill_intervals[i]-&gt;clear();
4852     }
4853   }
4854 }
4855 
4856 inline void LinearScanWalker::exclude_from_use(int reg) {
4857   assert(reg &lt; LinearScan::nof_regs, &quot;interval must have a register assigned (stack slots not allowed)&quot;);
4858   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4859     _use_pos[reg] = 0;
4860   }
4861 }
4862 inline void LinearScanWalker::exclude_from_use(Interval* i) {
4863   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4864 
4865   exclude_from_use(i-&gt;assigned_reg());
4866   exclude_from_use(i-&gt;assigned_regHi());
4867 }
4868 
4869 inline void LinearScanWalker::set_use_pos(int reg, Interval* i, int use_pos, bool only_process_use_pos) {
4870   assert(use_pos != 0, &quot;must use exclude_from_use to set use_pos to 0&quot;);
4871 
4872   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4873     if (_use_pos[reg] &gt; use_pos) {
4874       _use_pos[reg] = use_pos;
4875     }
4876     if (!only_process_use_pos) {
4877       _spill_intervals[reg]-&gt;append(i);
4878     }
4879   }
4880 }
4881 inline void LinearScanWalker::set_use_pos(Interval* i, int use_pos, bool only_process_use_pos) {
4882   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4883   if (use_pos != -1) {
4884     set_use_pos(i-&gt;assigned_reg(), i, use_pos, only_process_use_pos);
4885     set_use_pos(i-&gt;assigned_regHi(), i, use_pos, only_process_use_pos);
4886   }
4887 }
4888 
4889 inline void LinearScanWalker::set_block_pos(int reg, Interval* i, int block_pos) {
4890   if (reg &gt;= _first_reg &amp;&amp; reg &lt;= _last_reg) {
4891     if (_block_pos[reg] &gt; block_pos) {
4892       _block_pos[reg] = block_pos;
4893     }
4894     if (_use_pos[reg] &gt; block_pos) {
4895       _use_pos[reg] = block_pos;
4896     }
4897   }
4898 }
4899 inline void LinearScanWalker::set_block_pos(Interval* i, int block_pos) {
4900   assert(i-&gt;assigned_reg() != any_reg, &quot;interval has no register assigned&quot;);
4901   if (block_pos != -1) {
4902     set_block_pos(i-&gt;assigned_reg(), i, block_pos);
4903     set_block_pos(i-&gt;assigned_regHi(), i, block_pos);
4904   }
4905 }
4906 
4907 
4908 void LinearScanWalker::free_exclude_active_fixed() {
4909   Interval* list = active_first(fixedKind);
4910   while (list != Interval::end()) {
4911     assert(list-&gt;assigned_reg() &lt; LinearScan::nof_regs, &quot;active interval must have a register assigned&quot;);
4912     exclude_from_use(list);
4913     list = list-&gt;next();
4914   }
4915 }
4916 
4917 void LinearScanWalker::free_exclude_active_any() {
4918   Interval* list = active_first(anyKind);
4919   while (list != Interval::end()) {
4920     exclude_from_use(list);
4921     list = list-&gt;next();
4922   }
4923 }
4924 
4925 void LinearScanWalker::free_collect_inactive_fixed(Interval* cur) {
4926   Interval* list = inactive_first(fixedKind);
4927   while (list != Interval::end()) {
4928     if (cur-&gt;to() &lt;= list-&gt;current_from()) {
4929       assert(list-&gt;current_intersects_at(cur) == -1, &quot;must not intersect&quot;);
4930       set_use_pos(list, list-&gt;current_from(), true);
4931     } else {
4932       set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4933     }
4934     list = list-&gt;next();
4935   }
4936 }
4937 
4938 void LinearScanWalker::free_collect_inactive_any(Interval* cur) {
4939   Interval* list = inactive_first(anyKind);
4940   while (list != Interval::end()) {
4941     set_use_pos(list, list-&gt;current_intersects_at(cur), true);
4942     list = list-&gt;next();
4943   }
4944 }
4945 
4946 void LinearScanWalker::spill_exclude_active_fixed() {
4947   Interval* list = active_first(fixedKind);
4948   while (list != Interval::end()) {
4949     exclude_from_use(list);
4950     list = list-&gt;next();
4951   }
4952 }
4953 
4954 void LinearScanWalker::spill_block_inactive_fixed(Interval* cur) {
4955   Interval* list = inactive_first(fixedKind);
4956   while (list != Interval::end()) {
4957     if (cur-&gt;to() &gt; list-&gt;current_from()) {
4958       set_block_pos(list, list-&gt;current_intersects_at(cur));
4959     } else {
4960       assert(list-&gt;current_intersects_at(cur) == -1, &quot;invalid optimization: intervals intersect&quot;);
4961     }
4962 
4963     list = list-&gt;next();
4964   }
4965 }
4966 
4967 void LinearScanWalker::spill_collect_active_any() {
4968   Interval* list = active_first(anyKind);
4969   while (list != Interval::end()) {
4970     set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4971     list = list-&gt;next();
4972   }
4973 }
4974 
4975 void LinearScanWalker::spill_collect_inactive_any(Interval* cur) {
4976   Interval* list = inactive_first(anyKind);
4977   while (list != Interval::end()) {
4978     if (list-&gt;current_intersects(cur)) {
4979       set_use_pos(list, MIN2(list-&gt;next_usage(loopEndMarker, _current_position), list-&gt;to()), false);
4980     }
4981     list = list-&gt;next();
4982   }
4983 }
4984 
4985 
4986 void LinearScanWalker::insert_move(int op_id, Interval* src_it, Interval* dst_it) {
4987   // output all moves here. When source and target are equal, the move is
4988   // optimized away later in assign_reg_nums
4989 
4990   op_id = (op_id + 1) &amp; ~1;
4991   BlockBegin* op_block = allocator()-&gt;block_of_op_with_id(op_id);
4992   assert(op_id &gt; 0 &amp;&amp; allocator()-&gt;block_of_op_with_id(op_id - 2) == op_block, &quot;cannot insert move at block boundary&quot;);
4993 
4994   // calculate index of instruction inside instruction list of current block
4995   // the minimal index (for a block with no spill moves) can be calculated because the
4996   // numbering of instructions is known.
4997   // When the block already contains spill moves, the index must be increased until the
4998   // correct index is reached.
4999   LIR_OpList* list = op_block-&gt;lir()-&gt;instructions_list();
5000   int index = (op_id - list-&gt;at(0)-&gt;id()) / 2;
5001   assert(list-&gt;at(index)-&gt;id() &lt;= op_id, &quot;error in calculation&quot;);
5002 
5003   while (list-&gt;at(index)-&gt;id() != op_id) {
5004     index++;
5005     assert(0 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5006   }
5007   assert(1 &lt;= index &amp;&amp; index &lt; list-&gt;length(), &quot;index out of bounds&quot;);
5008   assert(list-&gt;at(index)-&gt;id() == op_id, &quot;error in calculation&quot;);
5009 
5010   // insert new instruction before instruction at position index
5011   _move_resolver.move_insert_position(op_block-&gt;lir(), index - 1);
5012   _move_resolver.add_mapping(src_it, dst_it);
5013 }
5014 
5015 
5016 int LinearScanWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
5017   int from_block_nr = min_block-&gt;linear_scan_number();
5018   int to_block_nr = max_block-&gt;linear_scan_number();
5019 
5020   assert(0 &lt;= from_block_nr &amp;&amp; from_block_nr &lt; block_count(), &quot;out of range&quot;);
5021   assert(0 &lt;= to_block_nr &amp;&amp; to_block_nr &lt; block_count(), &quot;out of range&quot;);
5022   assert(from_block_nr &lt; to_block_nr, &quot;must cross block boundary&quot;);
5023 
5024   // Try to split at end of max_block. If this would be after
5025   // max_split_pos, then use the begin of max_block
5026   int optimal_split_pos = max_block-&gt;last_lir_instruction_id() + 2;
5027   if (optimal_split_pos &gt; max_split_pos) {
5028     optimal_split_pos = max_block-&gt;first_lir_instruction_id();
5029   }
5030 
5031   int min_loop_depth = max_block-&gt;loop_depth();
5032   for (int i = to_block_nr - 1; i &gt;= from_block_nr; i--) {
5033     BlockBegin* cur = block_at(i);
5034 
5035     if (cur-&gt;loop_depth() &lt; min_loop_depth) {
5036       // block with lower loop-depth found -&gt; split at the end of this block
5037       min_loop_depth = cur-&gt;loop_depth();
5038       optimal_split_pos = cur-&gt;last_lir_instruction_id() + 2;
5039     }
5040   }
5041   assert(optimal_split_pos &gt; allocator()-&gt;max_lir_op_id() || allocator()-&gt;is_block_begin(optimal_split_pos), &quot;algorithm must move split pos to block boundary&quot;);
5042 
5043   return optimal_split_pos;
5044 }
5045 
5046 
5047 int LinearScanWalker::find_optimal_split_pos(Interval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
5048   int optimal_split_pos = -1;
5049   if (min_split_pos == max_split_pos) {
5050     // trivial case, no optimization of split position possible
5051     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      min-pos and max-pos are equal, no optimization possible&quot;));
5052     optimal_split_pos = min_split_pos;
5053 
5054   } else {
5055     assert(min_split_pos &lt; max_split_pos, &quot;must be true then&quot;);
5056     assert(min_split_pos &gt; 0, &quot;cannot access min_split_pos - 1 otherwise&quot;);
5057 
5058     // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
5059     // beginning of a block, then min_split_pos is also a possible split position.
5060     // Use the block before as min_block, because then min_block-&gt;last_lir_instruction_id() + 2 == min_split_pos
5061     BlockBegin* min_block = allocator()-&gt;block_of_op_with_id(min_split_pos - 1);
5062 
5063     // reason for using max_split_pos - 1: otherwise there would be an assertion failure
5064     // when an interval ends at the end of the last block of the method
5065     // (in this case, max_split_pos == allocator()-&gt;max_lir_op_id() + 2, and there is no
5066     // block at this op_id)
5067     BlockBegin* max_block = allocator()-&gt;block_of_op_with_id(max_split_pos - 1);
5068 
5069     assert(min_block-&gt;linear_scan_number() &lt;= max_block-&gt;linear_scan_number(), &quot;invalid order&quot;);
5070     if (min_block == max_block) {
5071       // split position cannot be moved to block boundary, so split as late as possible
5072       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      cannot move split pos to block boundary because min_pos and max_pos are in same block&quot;));
5073       optimal_split_pos = max_split_pos;
5074 
5075     } else if (it-&gt;has_hole_between(max_split_pos - 1, max_split_pos) &amp;&amp; !allocator()-&gt;is_block_begin(max_split_pos)) {
5076       // Do not move split position if the interval has a hole before max_split_pos.
5077       // Intervals resulting from Phi-Functions have more than one definition (marked
5078       // as mustHaveRegister) with a hole before each definition. When the register is needed
5079       // for the second definition, an earlier reloading is unnecessary.
5080       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has hole just before max_split_pos, so splitting at max_split_pos&quot;));
5081       optimal_split_pos = max_split_pos;
5082 
5083     } else {
5084       // seach optimal block boundary between min_split_pos and max_split_pos
5085       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      moving split pos to optimal block boundary between block B%d and B%d&quot;, min_block-&gt;block_id(), max_block-&gt;block_id()));
5086 
5087       if (do_loop_optimization) {
5088         // Loop optimization: if a loop-end marker is found between min- and max-position,
5089         // then split before this loop
5090         int loop_end_pos = it-&gt;next_usage_exact(loopEndMarker, min_block-&gt;last_lir_instruction_id() + 2);
5091         TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization: loop end found at pos %d&quot;, loop_end_pos));
5092 
5093         assert(loop_end_pos &gt; min_split_pos, &quot;invalid order&quot;);
5094         if (loop_end_pos &lt; max_split_pos) {
5095           // loop-end marker found between min- and max-position
5096           // if it is not the end marker for the same loop as the min-position, then move
5097           // the max-position to this loop block.
5098           // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
5099           // of the interval (normally, only mustHaveRegister causes a reloading)
5100           BlockBegin* loop_block = allocator()-&gt;block_of_op_with_id(loop_end_pos);
5101 
5102           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d&quot;, loop_block-&gt;block_id(), max_block-&gt;block_id(), loop_block-&gt;block_id()));
5103           assert(loop_block != min_block, &quot;loop_block and min_block must be different because block boundary is needed between&quot;);
5104 
5105           optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block-&gt;last_lir_instruction_id() + 2);
5106           if (optimal_split_pos == loop_block-&gt;last_lir_instruction_id() + 2) {
5107             optimal_split_pos = -1;
5108             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization not necessary&quot;));
5109           } else {
5110             TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      loop optimization successful&quot;));
5111           }
5112         }
5113       }
5114 
5115       if (optimal_split_pos == -1) {
5116         // not calculated by loop optimization
5117         optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
5118       }
5119     }
5120   }
5121   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      optimal split position: %d&quot;, optimal_split_pos));
5122 
5123   return optimal_split_pos;
5124 }
5125 
5126 
5127 /*
5128   split an interval at the optimal position between min_split_pos and
5129   max_split_pos in two parts:
5130   1) the left part has already a location assigned
5131   2) the right part is sorted into to the unhandled-list
5132 */
5133 void LinearScanWalker::split_before_usage(Interval* it, int min_split_pos, int max_split_pos) {
5134   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting interval: &quot;); it-&gt;print());
5135   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5136 
5137   assert(it-&gt;from() &lt; min_split_pos,         &quot;cannot split at start of interval&quot;);
5138   assert(current_position() &lt; min_split_pos, &quot;cannot split before current position&quot;);
5139   assert(min_split_pos &lt;= max_split_pos,     &quot;invalid order&quot;);
5140   assert(max_split_pos &lt;= it-&gt;to(),          &quot;cannot split after end of interval&quot;);
5141 
5142   int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
5143 
5144   assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5145   assert(optimal_split_pos &lt;= it-&gt;to(),  &quot;cannot split after end of interval&quot;);
5146   assert(optimal_split_pos &gt; it-&gt;from(), &quot;cannot split at start of interval&quot;);
5147 
5148   if (optimal_split_pos == it-&gt;to() &amp;&amp; it-&gt;next_usage(mustHaveRegister, min_split_pos) == max_jint) {
5149     // the split position would be just before the end of the interval
5150     // -&gt; no split at all necessary
5151     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      no split necessary because optimal split position is at end of interval&quot;));
5152     return;
5153   }
5154 
5155   // must calculate this before the actual split is performed and before split position is moved to odd op_id
5156   bool move_necessary = !allocator()-&gt;is_block_begin(optimal_split_pos) &amp;&amp; !it-&gt;has_hole_between(optimal_split_pos - 1, optimal_split_pos);
5157 
5158   if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5159     // move position before actual instruction (odd op_id)
5160     optimal_split_pos = (optimal_split_pos - 1) | 1;
5161   }
5162 
5163   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5164   assert(allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5165   assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5166 
5167   Interval* split_part = it-&gt;split(optimal_split_pos);
5168 
5169   allocator()-&gt;append_interval(split_part);
5170   allocator()-&gt;copy_register_flags(it, split_part);
5171   split_part-&gt;set_insert_move_when_activated(move_necessary);
5172   append_to_unhandled(unhandled_first_addr(anyKind), split_part);
5173 
5174   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts (insert_move_when_activated: %d)&quot;, move_necessary));
5175   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5176   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); split_part-&gt;print());
5177 }
5178 
5179 /*
5180   split an interval at the optimal position between min_split_pos and
5181   max_split_pos in two parts:
5182   1) the left part has already a location assigned
5183   2) the right part is always on the stack and therefore ignored in further processing
5184 */
5185 void LinearScanWalker::split_for_spilling(Interval* it) {
5186   // calculate allowed range of splitting position
5187   int max_split_pos = current_position();
5188   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, max_split_pos) + 1, it-&gt;from());
5189 
5190   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;----- splitting and spilling interval: &quot;); it-&gt;print());
5191   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      between %d and %d&quot;, min_split_pos, max_split_pos));
5192 
5193   assert(it-&gt;state() == activeState,     &quot;why spill interval that is not active?&quot;);
5194   assert(it-&gt;from() &lt;= min_split_pos,    &quot;cannot split before start of interval&quot;);
5195   assert(min_split_pos &lt;= max_split_pos, &quot;invalid order&quot;);
5196   assert(max_split_pos &lt; it-&gt;to(),       &quot;cannot split at end end of interval&quot;);
5197   assert(current_position() &lt; it-&gt;to(),  &quot;interval must not end before current position&quot;);
5198 
5199   if (min_split_pos == it-&gt;from()) {
5200     // the whole interval is never used, so spill it entirely to memory
5201     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      spilling entire interval because split pos is at beginning of interval&quot;));
5202     assert(it-&gt;first_usage(shouldHaveRegister) &gt; current_position(), &quot;interval must not have use position before current_position&quot;);
5203 
5204     allocator()-&gt;assign_spill_slot(it);
5205     allocator()-&gt;change_spill_state(it, min_split_pos);
5206 
5207     // Also kick parent intervals out of register to memory when they have no use
5208     // position. This avoids short interval in register surrounded by intervals in
5209     // memory -&gt; avoid useless moves from memory to register and back
5210     Interval* parent = it;
5211     while (parent != NULL &amp;&amp; parent-&gt;is_split_child()) {
5212       parent = parent-&gt;split_child_before_op_id(parent-&gt;from());
5213 
5214       if (parent-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5215         if (parent-&gt;first_usage(shouldHaveRegister) == max_jint) {
5216           // parent is never used, so kick it out of its assigned register
5217           TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      kicking out interval %d out of its register because it is never used&quot;, parent-&gt;reg_num()));
5218           allocator()-&gt;assign_spill_slot(parent);
5219         } else {
5220           // do not go further back because the register is actually used by the interval
5221           parent = NULL;
5222         }
5223       }
5224     }
5225 
5226   } else {
5227     // search optimal split pos, split interval and spill only the right hand part
5228     int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
5229 
5230     assert(min_split_pos &lt;= optimal_split_pos &amp;&amp; optimal_split_pos &lt;= max_split_pos, &quot;out of range&quot;);
5231     assert(optimal_split_pos &lt; it-&gt;to(), &quot;cannot split at end of interval&quot;);
5232     assert(optimal_split_pos &gt;= it-&gt;from(), &quot;cannot split before start of interval&quot;);
5233 
5234     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5235       // move position before actual instruction (odd op_id)
5236       optimal_split_pos = (optimal_split_pos - 1) | 1;
5237     }
5238 
5239     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      splitting at position %d&quot;, optimal_split_pos));
5240     assert(allocator()-&gt;is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), &quot;split pos must be odd when not on block boundary&quot;);
5241     assert(!allocator()-&gt;is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), &quot;split pos must be even on block boundary&quot;);
5242 
5243     Interval* spilled_part = it-&gt;split(optimal_split_pos);
5244     allocator()-&gt;append_interval(spilled_part);
5245     allocator()-&gt;assign_spill_slot(spilled_part);
5246     allocator()-&gt;change_spill_state(spilled_part, optimal_split_pos);
5247 
5248     if (!allocator()-&gt;is_block_begin(optimal_split_pos)) {
5249       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      inserting move from interval %d to %d&quot;, it-&gt;reg_num(), spilled_part-&gt;reg_num()));
5250       insert_move(optimal_split_pos, it, spilled_part);
5251     }
5252 
5253     // the current_split_child is needed later when moves are inserted for reloading
5254     assert(spilled_part-&gt;current_split_child() == it, &quot;overwriting wrong current_split_child&quot;);
5255     spilled_part-&gt;make_current_split_child();
5256 
5257     TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;      split interval in two parts&quot;));
5258     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); it-&gt;print());
5259     TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;      &quot;); spilled_part-&gt;print());
5260   }
5261 }
5262 
5263 
5264 void LinearScanWalker::split_stack_interval(Interval* it) {
5265   int min_split_pos = current_position() + 1;
5266   int max_split_pos = MIN2(it-&gt;first_usage(shouldHaveRegister), it-&gt;to());
5267 
5268   split_before_usage(it, min_split_pos, max_split_pos);
5269 }
5270 
5271 void LinearScanWalker::split_when_partial_register_available(Interval* it, int register_available_until) {
5272   int min_split_pos = MAX2(it-&gt;previous_usage(shouldHaveRegister, register_available_until), it-&gt;from() + 1);
5273   int max_split_pos = register_available_until;
5274 
5275   split_before_usage(it, min_split_pos, max_split_pos);
5276 }
5277 
5278 void LinearScanWalker::split_and_spill_interval(Interval* it) {
5279   assert(it-&gt;state() == activeState || it-&gt;state() == inactiveState, &quot;other states not allowed&quot;);
5280 
5281   int current_pos = current_position();
5282   if (it-&gt;state() == inactiveState) {
5283     // the interval is currently inactive, so no spill slot is needed for now.
5284     // when the split part is activated, the interval has a new chance to get a register,
5285     // so in the best case no stack slot is necessary
5286     assert(it-&gt;has_hole_between(current_pos - 1, current_pos + 1), &quot;interval can not be inactive otherwise&quot;);
5287     split_before_usage(it, current_pos + 1, current_pos + 1);
5288 
5289   } else {
5290     // search the position where the interval must have a register and split
5291     // at the optimal position before.
5292     // The new created part is added to the unhandled list and will get a register
5293     // when it is activated
5294     int min_split_pos = current_pos + 1;
5295     int max_split_pos = MIN2(it-&gt;next_usage(mustHaveRegister, min_split_pos), it-&gt;to());
5296 
5297     split_before_usage(it, min_split_pos, max_split_pos);
5298 
5299     assert(it-&gt;next_usage(mustHaveRegister, current_pos) == max_jint, &quot;the remaining part is spilled to stack and therefore has no register&quot;);
5300     split_for_spilling(it);
5301   }
5302 }
5303 
5304 
5305 int LinearScanWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
5306   int min_full_reg = any_reg;
5307   int max_partial_reg = any_reg;
5308 
5309   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5310     if (i == ignore_reg) {
5311       // this register must be ignored
5312 
5313     } else if (_use_pos[i] &gt;= interval_to) {
5314       // this register is free for the full interval
5315       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5316         min_full_reg = i;
5317       }
5318     } else if (_use_pos[i] &gt; reg_needed_until) {
5319       // this register is at least free until reg_needed_until
5320       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5321         max_partial_reg = i;
5322       }
5323     }
5324   }
5325 
5326   if (min_full_reg != any_reg) {
5327     return min_full_reg;
5328   } else if (max_partial_reg != any_reg) {
5329     *need_split = true;
5330     return max_partial_reg;
5331   } else {
5332     return any_reg;
5333   }
5334 }
5335 
5336 int LinearScanWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
5337   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5338 
5339   int min_full_reg = any_reg;
5340   int max_partial_reg = any_reg;
5341 
5342   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5343     if (_use_pos[i] &gt;= interval_to &amp;&amp; _use_pos[i + 1] &gt;= interval_to) {
5344       // this register is free for the full interval
5345       if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] &lt; _use_pos[min_full_reg] &amp;&amp; min_full_reg != hint_reg)) {
5346         min_full_reg = i;
5347       }
5348     } else if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5349       // this register is at least free until reg_needed_until
5350       if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] &gt; _use_pos[max_partial_reg] &amp;&amp; max_partial_reg != hint_reg)) {
5351         max_partial_reg = i;
5352       }
5353     }
5354   }
5355 
5356   if (min_full_reg != any_reg) {
5357     return min_full_reg;
5358   } else if (max_partial_reg != any_reg) {
5359     *need_split = true;
5360     return max_partial_reg;
5361   } else {
5362     return any_reg;
5363   }
5364 }
5365 
5366 
5367 bool LinearScanWalker::alloc_free_reg(Interval* cur) {
5368   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;trying to find free register for &quot;); cur-&gt;print());
5369 
5370   init_use_lists(true);
5371   free_exclude_active_fixed();
5372   free_exclude_active_any();
5373   free_collect_inactive_fixed(cur);
5374   free_collect_inactive_any(cur);
5375   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5376 
5377   // _use_pos contains the start of the next interval that has this register assigned
5378   // (either as a fixed register or a normal allocated register in the past)
5379   // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
5380   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      state of registers:&quot;));
5381   TRACE_LINEAR_SCAN(4, for (int i = _first_reg; i &lt;= _last_reg; i++) tty-&gt;print_cr(&quot;      reg %d: use_pos: %d&quot;, i, _use_pos[i]));
5382 
5383   int hint_reg, hint_regHi;
5384   Interval* register_hint = cur-&gt;register_hint();
5385   if (register_hint != NULL) {
5386     hint_reg = register_hint-&gt;assigned_reg();
5387     hint_regHi = register_hint-&gt;assigned_regHi();
5388 
5389     if (allocator()-&gt;is_precolored_cpu_interval(register_hint)) {
5390       assert(hint_reg != any_reg &amp;&amp; hint_regHi == any_reg, &quot;must be for fixed intervals&quot;);
5391       hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
5392     }
5393     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;      hint registers %d, %d from interval &quot;, hint_reg, hint_regHi); register_hint-&gt;print());
5394 
5395   } else {
5396     hint_reg = any_reg;
5397     hint_regHi = any_reg;
5398   }
5399   assert(hint_reg == any_reg || hint_reg != hint_regHi, &quot;hint reg and regHi equal&quot;);
5400   assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned to interval&quot;);
5401 
5402   // the register must be free at least until this position
5403   int reg_needed_until = cur-&gt;from() + 1;
5404   int interval_to = cur-&gt;to();
5405 
5406   bool need_split = false;
5407   int split_pos;
5408   int reg;
5409   int regHi = any_reg;
5410 
5411   if (_adjacent_regs) {
5412     reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &amp;need_split);
5413     regHi = reg + 1;
5414     if (reg == any_reg) {
5415       return false;
5416     }
5417     split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5418 
5419   } else {
5420     reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &amp;need_split);
5421     if (reg == any_reg) {
5422       return false;
5423     }
5424     split_pos = _use_pos[reg];
5425 
5426     if (_num_phys_regs == 2) {
5427       regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &amp;need_split);
5428 
5429       if (_use_pos[reg] &lt; interval_to &amp;&amp; regHi == any_reg) {
5430         // do not split interval if only one register can be assigned until the split pos
5431         // (when one register is found for the whole interval, split&amp;spill is only
5432         // performed for the hi register)
5433         return false;
5434 
5435       } else if (regHi != any_reg) {
5436         split_pos = MIN2(split_pos, _use_pos[regHi]);
5437 
5438         // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5439         if (reg &gt; regHi) {
5440           int temp = reg;
5441           reg = regHi;
5442           regHi = temp;
5443         }
5444       }
5445     }
5446   }
5447 
5448   cur-&gt;assign_reg(reg, regHi);
5449   TRACE_LINEAR_SCAN(2, tty-&gt;print_cr(&quot;selected register %d, %d&quot;, reg, regHi));
5450 
5451   assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5452   if (need_split) {
5453     // register not available for full interval, so split it
5454     split_when_partial_register_available(cur, split_pos);
5455   }
5456 
5457   // only return true if interval is completely assigned
5458   return _num_phys_regs == 1 || regHi != any_reg;
5459 }
5460 
5461 
5462 int LinearScanWalker::find_locked_reg(int reg_needed_until, int interval_to, int ignore_reg, bool* need_split) {
5463   int max_reg = any_reg;
5464 
5465   for (int i = _first_reg; i &lt;= _last_reg; i++) {
5466     if (i == ignore_reg) {
5467       // this register must be ignored
5468 
5469     } else if (_use_pos[i] &gt; reg_needed_until) {
5470       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5471         max_reg = i;
5472       }
5473     }
5474   }
5475 
5476   if (max_reg != any_reg &amp;&amp; _block_pos[max_reg] &lt;= interval_to) {
5477     *need_split = true;
5478   }
5479 
5480   return max_reg;
5481 }
5482 
5483 int LinearScanWalker::find_locked_double_reg(int reg_needed_until, int interval_to, bool* need_split) {
5484   assert((_last_reg - _first_reg + 1) % 2 == 0, &quot;adjust algorithm&quot;);
5485 
5486   int max_reg = any_reg;
5487 
5488   for (int i = _first_reg; i &lt; _last_reg; i+=2) {
5489     if (_use_pos[i] &gt; reg_needed_until &amp;&amp; _use_pos[i + 1] &gt; reg_needed_until) {
5490       if (max_reg == any_reg || _use_pos[i] &gt; _use_pos[max_reg]) {
5491         max_reg = i;
5492       }
5493     }
5494   }
5495 
5496   if (max_reg != any_reg &amp;&amp;
5497       (_block_pos[max_reg] &lt;= interval_to || _block_pos[max_reg + 1] &lt;= interval_to)) {
5498     *need_split = true;
5499   }
5500 
5501   return max_reg;
5502 }
5503 
5504 void LinearScanWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
5505   assert(reg != any_reg, &quot;no register assigned&quot;);
5506 
5507   for (int i = 0; i &lt; _spill_intervals[reg]-&gt;length(); i++) {
5508     Interval* it = _spill_intervals[reg]-&gt;at(i);
5509     remove_from_list(it);
5510     split_and_spill_interval(it);
5511   }
5512 
5513   if (regHi != any_reg) {
5514     IntervalList* processed = _spill_intervals[reg];
5515     for (int i = 0; i &lt; _spill_intervals[regHi]-&gt;length(); i++) {
5516       Interval* it = _spill_intervals[regHi]-&gt;at(i);
5517       if (processed-&gt;find(it) == -1) {
5518         remove_from_list(it);
5519         split_and_spill_interval(it);
5520       }
5521     }
5522   }
5523 }
5524 
5525 
5526 // Split an Interval and spill it to memory so that cur can be placed in a register
5527 void LinearScanWalker::alloc_locked_reg(Interval* cur) {
5528   TRACE_LINEAR_SCAN(2, tty-&gt;print(&quot;need to split and spill to get register for &quot;); cur-&gt;print());
5529 
5530   // collect current usage of registers
5531   init_use_lists(false);
5532   spill_exclude_active_fixed();
5533   assert(unhandled_first(fixedKind) == Interval::end(), &quot;must not have unhandled fixed intervals because all fixed intervals have a use at position 0&quot;);
5534   spill_block_inactive_fixed(cur);
5535   spill_collect_active_any();
5536   spill_collect_inactive_any(cur);
5537 
5538 #ifndef PRODUCT
5539   if (TraceLinearScanLevel &gt;= 4) {
5540     tty-&gt;print_cr(&quot;      state of registers:&quot;);
5541     for (int i = _first_reg; i &lt;= _last_reg; i++) {
5542       tty-&gt;print(&quot;      reg %d: use_pos: %d, block_pos: %d, intervals: &quot;, i, _use_pos[i], _block_pos[i]);
5543       for (int j = 0; j &lt; _spill_intervals[i]-&gt;length(); j++) {
5544         tty-&gt;print(&quot;%d &quot;, _spill_intervals[i]-&gt;at(j)-&gt;reg_num());
5545       }
5546       tty-&gt;cr();
5547     }
5548   }
5549 #endif
5550 
5551   // the register must be free at least until this position
5552   int reg_needed_until = MIN2(cur-&gt;first_usage(mustHaveRegister), cur-&gt;from() + 1);
5553   int interval_to = cur-&gt;to();
5554   assert (reg_needed_until &gt; 0 &amp;&amp; reg_needed_until &lt; max_jint, &quot;interval has no use&quot;);
5555 
5556   int split_pos = 0;
5557   int use_pos = 0;
5558   bool need_split = false;
5559   int reg, regHi;
5560 
5561   if (_adjacent_regs) {
5562     reg = find_locked_double_reg(reg_needed_until, interval_to, &amp;need_split);
5563     regHi = reg + 1;
5564 
5565     if (reg != any_reg) {
5566       use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
5567       split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
5568     }
5569   } else {
5570     reg = find_locked_reg(reg_needed_until, interval_to, cur-&gt;assigned_reg(), &amp;need_split);
5571     regHi = any_reg;
5572 
5573     if (reg != any_reg) {
5574       use_pos = _use_pos[reg];
5575       split_pos = _block_pos[reg];
5576 
5577       if (_num_phys_regs == 2) {
5578         if (cur-&gt;assigned_reg() != any_reg) {
5579           regHi = reg;
5580           reg = cur-&gt;assigned_reg();
5581         } else {
5582           regHi = find_locked_reg(reg_needed_until, interval_to, reg, &amp;need_split);
5583           if (regHi != any_reg) {
5584             use_pos = MIN2(use_pos, _use_pos[regHi]);
5585             split_pos = MIN2(split_pos, _block_pos[regHi]);
5586           }
5587         }
5588 
5589         if (regHi != any_reg &amp;&amp; reg &gt; regHi) {
5590           // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
5591           int temp = reg;
5592           reg = regHi;
5593           regHi = temp;
5594         }
5595       }
5596     }
5597   }
5598 
5599   if (reg == any_reg || (_num_phys_regs == 2 &amp;&amp; regHi == any_reg) || use_pos &lt;= cur-&gt;first_usage(mustHaveRegister)) {
5600     // the first use of cur is later than the spilling position -&gt; spill cur
5601     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;able to spill current interval. first_usage(register): %d, use_pos: %d&quot;, cur-&gt;first_usage(mustHaveRegister), use_pos));
5602 
5603     if (cur-&gt;first_usage(mustHaveRegister) &lt;= cur-&gt;from() + 1) {
5604       assert(false, &quot;cannot spill interval that is used in first instruction (possible reason: no register found)&quot;);
5605       // assign a reasonable register and do a bailout in product mode to avoid errors
5606       allocator()-&gt;assign_spill_slot(cur);
5607       BAILOUT(&quot;LinearScan: no register found&quot;);
5608     }
5609 
5610     split_and_spill_interval(cur);
5611   } else {
5612     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;decided to use register %d, %d&quot;, reg, regHi));
5613     assert(reg != any_reg &amp;&amp; (_num_phys_regs == 1 || regHi != any_reg), &quot;no register found&quot;);
5614     assert(split_pos &gt; 0, &quot;invalid split_pos&quot;);
5615     assert(need_split == false || split_pos &gt; cur-&gt;from(), &quot;splitting interval at from&quot;);
5616 
5617     cur-&gt;assign_reg(reg, regHi);
5618     if (need_split) {
5619       // register not available for full interval, so split it
5620       split_when_partial_register_available(cur, split_pos);
5621     }
5622 
5623     // perform splitting and spilling for all affected intervalls
5624     split_and_spill_intersecting_intervals(reg, regHi);
5625   }
5626 }
5627 
5628 bool LinearScanWalker::no_allocation_possible(Interval* cur) {
5629 #ifdef X86
5630   // fast calculation of intervals that can never get a register because the
5631   // the next instruction is a call that blocks all registers
5632   // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
5633 
5634   // check if this interval is the result of a split operation
5635   // (an interval got a register until this position)
5636   int pos = cur-&gt;from();
5637   if ((pos &amp; 1) == 1) {
5638     // the current instruction is a call that blocks all registers
5639     if (pos &lt; allocator()-&gt;max_lir_op_id() &amp;&amp; allocator()-&gt;has_call(pos + 1)) {
5640       TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      free register cannot be available because all registers blocked by following call&quot;));
5641 
5642       // safety check that there is really no register available
5643       assert(alloc_free_reg(cur) == false, &quot;found a register for this interval&quot;);
5644       return true;
5645     }
5646 
5647   }
5648 #endif
5649   return false;
5650 }
5651 
5652 void LinearScanWalker::init_vars_for_alloc(Interval* cur) {
5653   BasicType type = cur-&gt;type();
5654   _num_phys_regs = LinearScan::num_physical_regs(type);
5655   _adjacent_regs = LinearScan::requires_adjacent_regs(type);
5656 
5657   if (pd_init_regs_for_alloc(cur)) {
5658     // the appropriate register range was selected.
5659   } else if (type == T_FLOAT || type == T_DOUBLE) {
5660     _first_reg = pd_first_fpu_reg;
5661     _last_reg = pd_last_fpu_reg;
5662   } else {
5663     _first_reg = pd_first_cpu_reg;
5664     _last_reg = FrameMap::last_cpu_reg();
5665   }
5666 
5667   assert(0 &lt;= _first_reg &amp;&amp; _first_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5668   assert(0 &lt;= _last_reg &amp;&amp; _last_reg &lt; LinearScan::nof_regs, &quot;out of range&quot;);
5669 }
5670 
5671 
5672 bool LinearScanWalker::is_move(LIR_Op* op, Interval* from, Interval* to) {
5673   if (op-&gt;code() != lir_move) {
5674     return false;
5675   }
5676   assert(op-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5677 
5678   LIR_Opr in = ((LIR_Op1*)op)-&gt;in_opr();
5679   LIR_Opr res = ((LIR_Op1*)op)-&gt;result_opr();
5680   return in-&gt;is_virtual() &amp;&amp; res-&gt;is_virtual() &amp;&amp; in-&gt;vreg_number() == from-&gt;reg_num() &amp;&amp; res-&gt;vreg_number() == to-&gt;reg_num();
5681 }
5682 
5683 // optimization (especially for phi functions of nested loops):
5684 // assign same spill slot to non-intersecting intervals
5685 void LinearScanWalker::combine_spilled_intervals(Interval* cur) {
5686   if (cur-&gt;is_split_child()) {
5687     // optimization is only suitable for split parents
5688     return;
5689   }
5690 
5691   Interval* register_hint = cur-&gt;register_hint(false);
5692   if (register_hint == NULL) {
5693     // cur is not the target of a move, otherwise register_hint would be set
5694     return;
5695   }
5696   assert(register_hint-&gt;is_split_parent(), &quot;register hint must be split parent&quot;);
5697 
5698   if (cur-&gt;spill_state() != noOptimization || register_hint-&gt;spill_state() != noOptimization) {
5699     // combining the stack slots for intervals where spill move optimization is applied
5700     // is not benefitial and would cause problems
5701     return;
5702   }
5703 
5704   int begin_pos = cur-&gt;from();
5705   int end_pos = cur-&gt;to();
5706   if (end_pos &gt; allocator()-&gt;max_lir_op_id() || (begin_pos &amp; 1) != 0 || (end_pos &amp; 1) != 0) {
5707     // safety check that lir_op_with_id is allowed
5708     return;
5709   }
5710 
5711   if (!is_move(allocator()-&gt;lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()-&gt;lir_op_with_id(end_pos), cur, register_hint)) {
5712     // cur and register_hint are not connected with two moves
5713     return;
5714   }
5715 
5716   Interval* begin_hint = register_hint-&gt;split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
5717   Interval* end_hint = register_hint-&gt;split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
5718   if (begin_hint == end_hint || begin_hint-&gt;to() != begin_pos || end_hint-&gt;from() != end_pos) {
5719     // register_hint must be split, otherwise the re-writing of use positions does not work
5720     return;
5721   }
5722 
5723   assert(begin_hint-&gt;assigned_reg() != any_reg, &quot;must have register assigned&quot;);
5724   assert(end_hint-&gt;assigned_reg() == any_reg, &quot;must not have register assigned&quot;);
5725   assert(cur-&gt;first_usage(mustHaveRegister) == begin_pos, &quot;must have use position at begin of interval because of move&quot;);
5726   assert(end_hint-&gt;first_usage(mustHaveRegister) == end_pos, &quot;must have use position at begin of interval because of move&quot;);
5727 
5728   if (begin_hint-&gt;assigned_reg() &lt; LinearScan::nof_regs) {
5729     // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
5730     return;
5731   }
5732   assert(register_hint-&gt;canonical_spill_slot() != -1, &quot;must be set when part of interval was spilled&quot;);
5733 
5734   // modify intervals such that cur gets the same stack slot as register_hint
5735   // delete use positions to prevent the intervals to get a register at beginning
5736   cur-&gt;set_canonical_spill_slot(register_hint-&gt;canonical_spill_slot());
5737   cur-&gt;remove_first_use_pos();
5738   end_hint-&gt;remove_first_use_pos();
5739 }
5740 
5741 
5742 // allocate a physical register or memory location to an interval
5743 bool LinearScanWalker::activate_current() {
5744   Interval* cur = current();
5745   bool result = true;
5746 
5747   TRACE_LINEAR_SCAN(2, tty-&gt;print   (&quot;+++++ activating interval &quot;); cur-&gt;print());
5748   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      split_parent: %d, insert_move_when_activated: %d&quot;, cur-&gt;split_parent()-&gt;reg_num(), cur-&gt;insert_move_when_activated()));
5749 
5750   if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5751     // activating an interval that has a stack slot assigned -&gt; split it at first use position
5752     // used for method parameters
5753     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval has spill slot assigned (method parameter) -&gt; split it before first use&quot;));
5754 
5755     split_stack_interval(cur);
5756     result = false;
5757 
5758   } else if (allocator()-&gt;gen()-&gt;is_vreg_flag_set(cur-&gt;reg_num(), LIRGenerator::must_start_in_memory)) {
5759     // activating an interval that must start in a stack slot, but may get a register later
5760     // used for lir_roundfp: rounding is done by store to stack and reload later
5761     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      interval must start in stack slot -&gt; split it before first use&quot;));
5762     assert(cur-&gt;assigned_reg() == any_reg &amp;&amp; cur-&gt;assigned_regHi() == any_reg, &quot;register already assigned&quot;);
5763 
5764     allocator()-&gt;assign_spill_slot(cur);
5765     split_stack_interval(cur);
5766     result = false;
5767 
5768   } else if (cur-&gt;assigned_reg() == any_reg) {
5769     // interval has not assigned register -&gt; normal allocation
5770     // (this is the normal case for most intervals)
5771     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;      normal allocation of register&quot;));
5772 
5773     // assign same spill slot to non-intersecting intervals
5774     combine_spilled_intervals(cur);
5775 
5776     init_vars_for_alloc(cur);
5777     if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
5778       // no empty register available.
5779       // split and spill another interval so that this interval gets a register
5780       alloc_locked_reg(cur);
5781     }
5782 
5783     // spilled intervals need not be move to active-list
5784     if (cur-&gt;assigned_reg() &gt;= LinearScan::nof_regs) {
5785       result = false;
5786     }
5787   }
5788 
5789   // load spilled values that become active from stack slot to register
5790   if (cur-&gt;insert_move_when_activated()) {
5791     assert(cur-&gt;is_split_child(), &quot;must be&quot;);
5792     assert(cur-&gt;current_split_child() != NULL, &quot;must be&quot;);
5793     assert(cur-&gt;current_split_child()-&gt;reg_num() != cur-&gt;reg_num(), &quot;cannot insert move between same interval&quot;);
5794     TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;Inserting move from interval %d to %d because insert_move_when_activated is set&quot;, cur-&gt;current_split_child()-&gt;reg_num(), cur-&gt;reg_num()));
5795 
5796     insert_move(cur-&gt;from(), cur-&gt;current_split_child(), cur);
5797   }
5798   cur-&gt;make_current_split_child();
5799 
5800   return result; // true = interval is moved to active list
5801 }
5802 
5803 
5804 // Implementation of EdgeMoveOptimizer
5805 
5806 EdgeMoveOptimizer::EdgeMoveOptimizer() :
5807   _edge_instructions(4),
5808   _edge_instructions_idx(4)
5809 {
5810 }
5811 
5812 void EdgeMoveOptimizer::optimize(BlockList* code) {
5813   EdgeMoveOptimizer optimizer = EdgeMoveOptimizer();
5814 
5815   // ignore the first block in the list (index 0 is not processed)
5816   for (int i = code-&gt;length() - 1; i &gt;= 1; i--) {
5817     BlockBegin* block = code-&gt;at(i);
5818 
5819     if (block-&gt;number_of_preds() &gt; 1 &amp;&amp; !block-&gt;is_set(BlockBegin::exception_entry_flag)) {
5820       optimizer.optimize_moves_at_block_end(block);
5821     }
5822     if (block-&gt;number_of_sux() == 2) {
5823       optimizer.optimize_moves_at_block_begin(block);
5824     }
5825   }
5826 }
5827 
5828 
5829 // clear all internal data structures
5830 void EdgeMoveOptimizer::init_instructions() {
5831   _edge_instructions.clear();
5832   _edge_instructions_idx.clear();
5833 }
5834 
5835 // append a lir-instruction-list and the index of the current operation in to the list
5836 void EdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
5837   _edge_instructions.append(instructions);
5838   _edge_instructions_idx.append(instructions_idx);
5839 }
5840 
5841 // return the current operation of the given edge (predecessor or successor)
5842 LIR_Op* EdgeMoveOptimizer::instruction_at(int edge) {
5843   LIR_OpList* instructions = _edge_instructions.at(edge);
5844   int idx = _edge_instructions_idx.at(edge);
5845 
5846   if (idx &lt; instructions-&gt;length()) {
5847     return instructions-&gt;at(idx);
5848   } else {
5849     return NULL;
5850   }
5851 }
5852 
5853 // removes the current operation of the given edge (predecessor or successor)
5854 void EdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
5855   LIR_OpList* instructions = _edge_instructions.at(edge);
5856   int idx = _edge_instructions_idx.at(edge);
5857   instructions-&gt;remove_at(idx);
5858 
5859   if (decrement_index) {
5860     _edge_instructions_idx.at_put(edge, idx - 1);
5861   }
5862 }
5863 
5864 
5865 bool EdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
5866   if (op1 == NULL || op2 == NULL) {
5867     // at least one block is already empty -&gt; no optimization possible
5868     return true;
5869   }
5870 
5871   if (op1-&gt;code() == lir_move &amp;&amp; op2-&gt;code() == lir_move) {
5872     assert(op1-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5873     assert(op2-&gt;as_Op1() != NULL, &quot;move must be LIR_Op1&quot;);
5874     LIR_Op1* move1 = (LIR_Op1*)op1;
5875     LIR_Op1* move2 = (LIR_Op1*)op2;
5876     if (move1-&gt;info() == move2-&gt;info() &amp;&amp; move1-&gt;in_opr() == move2-&gt;in_opr() &amp;&amp; move1-&gt;result_opr() == move2-&gt;result_opr()) {
5877       // these moves are exactly equal and can be optimized
5878       return false;
5879     }
5880 
5881   } else if (op1-&gt;code() == lir_fxch &amp;&amp; op2-&gt;code() == lir_fxch) {
5882     assert(op1-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5883     assert(op2-&gt;as_Op1() != NULL, &quot;fxch must be LIR_Op1&quot;);
5884     LIR_Op1* fxch1 = (LIR_Op1*)op1;
5885     LIR_Op1* fxch2 = (LIR_Op1*)op2;
5886     if (fxch1-&gt;in_opr()-&gt;as_jint() == fxch2-&gt;in_opr()-&gt;as_jint()) {
5887       // equal FPU stack operations can be optimized
5888       return false;
5889     }
5890 
5891   } else if (op1-&gt;code() == lir_fpop_raw &amp;&amp; op2-&gt;code() == lir_fpop_raw) {
5892     // equal FPU stack operations can be optimized
5893     return false;
5894   }
5895 
5896   // no optimization possible
5897   return true;
5898 }
5899 
5900 void EdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
5901   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimizing moves at end of block B%d&quot;, block-&gt;block_id()));
5902 
5903   if (block-&gt;is_predecessor(block)) {
5904     // currently we can&#39;t handle this correctly.
5905     return;
5906   }
5907 
5908   init_instructions();
5909   int num_preds = block-&gt;number_of_preds();
5910   assert(num_preds &gt; 1, &quot;do not call otherwise&quot;);
5911   assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
5912 
5913   // setup a list with the lir-instructions of all predecessors
5914   int i;
5915   for (i = 0; i &lt; num_preds; i++) {
5916     BlockBegin* pred = block-&gt;pred_at(i);
5917     LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
5918 
5919     if (pred-&gt;number_of_sux() != 1) {
5920       // this can happen with switch-statements where multiple edges are between
5921       // the same blocks.
5922       return;
5923     }
5924 
5925     assert(pred-&gt;number_of_sux() == 1, &quot;can handle only one successor&quot;);
5926     assert(pred-&gt;sux_at(0) == block, &quot;invalid control flow&quot;);
5927     assert(pred_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5928     assert(pred_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5929     assert(pred_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5930 
5931     if (pred_instructions-&gt;last()-&gt;info() != NULL) {
5932       // can not optimize instructions when debug info is needed
5933       return;
5934     }
5935 
5936     // ignore the unconditional branch at the end of the block
5937     append_instructions(pred_instructions, pred_instructions-&gt;length() - 2);
5938   }
5939 
5940 
5941   // process lir-instructions while all predecessors end with the same instruction
5942   while (true) {
5943     LIR_Op* op = instruction_at(0);
5944     for (i = 1; i &lt; num_preds; i++) {
5945       if (operations_different(op, instruction_at(i))) {
5946         // these instructions are different and cannot be optimized -&gt;
5947         // no further optimization possible
5948         return;
5949       }
5950     }
5951 
5952     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;found instruction that is equal in all %d predecessors: &quot;, num_preds); op-&gt;print());
5953 
5954     // insert the instruction at the beginning of the current block
5955     block-&gt;lir()-&gt;insert_before(1, op);
5956 
5957     // delete the instruction at the end of all predecessors
5958     for (i = 0; i &lt; num_preds; i++) {
5959       remove_cur_instruction(i, true);
5960     }
5961   }
5962 }
5963 
5964 
5965 void EdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
5966   TRACE_LINEAR_SCAN(4, tty-&gt;print_cr(&quot;optimization moves at begin of block B%d&quot;, block-&gt;block_id()));
5967 
5968   init_instructions();
5969   int num_sux = block-&gt;number_of_sux();
5970 
5971   LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
5972 
5973   assert(num_sux == 2, &quot;method should not be called otherwise&quot;);
5974   assert(cur_instructions-&gt;last()-&gt;code() == lir_branch, &quot;block with successor must end with branch&quot;);
5975   assert(cur_instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
5976   assert(cur_instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;block must end with unconditional branch&quot;);
5977 
5978   if (cur_instructions-&gt;last()-&gt;info() != NULL) {
5979     // can no optimize instructions when debug info is needed
5980     return;
5981   }
5982 
5983   LIR_Op* branch = cur_instructions-&gt;at(cur_instructions-&gt;length() - 2);
5984   if (branch-&gt;info() != NULL || (branch-&gt;code() != lir_branch &amp;&amp; branch-&gt;code() != lir_cond_float_branch)) {
5985     // not a valid case for optimization
5986     // currently, only blocks that end with two branches (conditional branch followed
5987     // by unconditional branch) are optimized
5988     return;
5989   }
5990 
5991   // now it is guaranteed that the block ends with two branch instructions.
5992   // the instructions are inserted at the end of the block before these two branches
5993   int insert_idx = cur_instructions-&gt;length() - 2;
5994 
5995   int i;
5996 #ifdef ASSERT
5997   for (i = insert_idx - 1; i &gt;= 0; i--) {
5998     LIR_Op* op = cur_instructions-&gt;at(i);
5999     if ((op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) &amp;&amp; ((LIR_OpBranch*)op)-&gt;block() != NULL) {
6000       assert(false, &quot;block with two successors can have only two branch instructions&quot;);
6001     }
6002   }
6003 #endif
6004 
6005   // setup a list with the lir-instructions of all successors
6006   for (i = 0; i &lt; num_sux; i++) {
6007     BlockBegin* sux = block-&gt;sux_at(i);
6008     LIR_OpList* sux_instructions = sux-&gt;lir()-&gt;instructions_list();
6009 
6010     assert(sux_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;block must start with label&quot;);
6011 
6012     if (sux-&gt;number_of_preds() != 1) {
6013       // this can happen with switch-statements where multiple edges are between
6014       // the same blocks.
6015       return;
6016     }
6017     assert(sux-&gt;pred_at(0) == block, &quot;invalid control flow&quot;);
6018     assert(!sux-&gt;is_set(BlockBegin::exception_entry_flag), &quot;exception handlers not allowed&quot;);
6019 
6020     // ignore the label at the beginning of the block
6021     append_instructions(sux_instructions, 1);
6022   }
6023 
6024   // process lir-instructions while all successors begin with the same instruction
6025   while (true) {
6026     LIR_Op* op = instruction_at(0);
6027     for (i = 1; i &lt; num_sux; i++) {
6028       if (operations_different(op, instruction_at(i))) {
6029         // these instructions are different and cannot be optimized -&gt;
6030         // no further optimization possible
6031         return;
6032       }
6033     }
6034 
6035     TRACE_LINEAR_SCAN(4, tty-&gt;print(&quot;----- found instruction that is equal in all %d successors: &quot;, num_sux); op-&gt;print());
6036 
6037     // insert instruction at end of current block
6038     block-&gt;lir()-&gt;insert_before(insert_idx, op);
6039     insert_idx++;
6040 
6041     // delete the instructions at the beginning of all successors
6042     for (i = 0; i &lt; num_sux; i++) {
6043       remove_cur_instruction(i, false);
6044     }
6045   }
6046 }
6047 
6048 
6049 // Implementation of ControlFlowOptimizer
6050 
6051 ControlFlowOptimizer::ControlFlowOptimizer() :
6052   _original_preds(4)
6053 {
6054 }
6055 
6056 void ControlFlowOptimizer::optimize(BlockList* code) {
6057   ControlFlowOptimizer optimizer = ControlFlowOptimizer();
6058 
6059   // push the OSR entry block to the end so that we&#39;re not jumping over it.
6060   BlockBegin* osr_entry = code-&gt;at(0)-&gt;end()-&gt;as_Base()-&gt;osr_entry();
6061   if (osr_entry) {
6062     int index = osr_entry-&gt;linear_scan_number();
6063     assert(code-&gt;at(index) == osr_entry, &quot;wrong index&quot;);
6064     code-&gt;remove_at(index);
6065     code-&gt;append(osr_entry);
6066   }
6067 
6068   optimizer.reorder_short_loops(code);
6069   optimizer.delete_empty_blocks(code);
6070   optimizer.delete_unnecessary_jumps(code);
6071   optimizer.delete_jumps_to_return(code);
6072 }
6073 
6074 void ControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
6075   int i = header_idx + 1;
6076   int max_end = MIN2(header_idx + ShortLoopSize, code-&gt;length());
6077   while (i &lt; max_end &amp;&amp; code-&gt;at(i)-&gt;loop_depth() &gt;= header_block-&gt;loop_depth()) {
6078     i++;
6079   }
6080 
6081   if (i == code-&gt;length() || code-&gt;at(i)-&gt;loop_depth() &lt; header_block-&gt;loop_depth()) {
6082     int end_idx = i - 1;
6083     BlockBegin* end_block = code-&gt;at(end_idx);
6084 
6085     if (end_block-&gt;number_of_sux() == 1 &amp;&amp; end_block-&gt;sux_at(0) == header_block) {
6086       // short loop from header_idx to end_idx found -&gt; reorder blocks such that
6087       // the header_block is the last block instead of the first block of the loop
6088       TRACE_LINEAR_SCAN(1, tty-&gt;print_cr(&quot;Reordering short loop: length %d, header B%d, end B%d&quot;,
6089                                          end_idx - header_idx + 1,
6090                                          header_block-&gt;block_id(), end_block-&gt;block_id()));
6091 
6092       for (int j = header_idx; j &lt; end_idx; j++) {
6093         code-&gt;at_put(j, code-&gt;at(j + 1));
6094       }
6095       code-&gt;at_put(end_idx, header_block);
6096 
6097       // correct the flags so that any loop alignment occurs in the right place.
6098       assert(code-&gt;at(end_idx)-&gt;is_set(BlockBegin::backward_branch_target_flag), &quot;must be backward branch target&quot;);
6099       code-&gt;at(end_idx)-&gt;clear(BlockBegin::backward_branch_target_flag);
6100       code-&gt;at(header_idx)-&gt;set(BlockBegin::backward_branch_target_flag);
6101     }
6102   }
6103 }
6104 
6105 void ControlFlowOptimizer::reorder_short_loops(BlockList* code) {
6106   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6107     BlockBegin* block = code-&gt;at(i);
6108 
6109     if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
6110       reorder_short_loop(code, block, i);
6111     }
6112   }
6113 
6114   DEBUG_ONLY(verify(code));
6115 }
6116 
6117 // only blocks with exactly one successor can be deleted. Such blocks
6118 // must always end with an unconditional branch to this successor
6119 bool ControlFlowOptimizer::can_delete_block(BlockBegin* block) {
6120   if (block-&gt;number_of_sux() != 1 || block-&gt;number_of_exception_handlers() != 0 || block-&gt;is_entry_block()) {
6121     return false;
6122   }
6123 
6124   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6125 
6126   assert(instructions-&gt;length() &gt;= 2, &quot;block must have label and branch&quot;);
6127   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6128   assert(instructions-&gt;last()-&gt;as_OpBranch() != NULL, &quot;last instrcution must always be a branch&quot;);
6129   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;cond() == lir_cond_always, &quot;branch must be unconditional&quot;);
6130   assert(instructions-&gt;last()-&gt;as_OpBranch()-&gt;block() == block-&gt;sux_at(0), &quot;branch target must be the successor&quot;);
6131 
6132   // block must have exactly one successor
6133 
6134   if (instructions-&gt;length() == 2 &amp;&amp; instructions-&gt;last()-&gt;info() == NULL) {
6135     return true;
6136   }
6137   return false;
6138 }
6139 
6140 // substitute branch targets in all branch-instructions of this blocks
6141 void ControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
6142   TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting empty block: substituting from B%d to B%d inside B%d&quot;, target_from-&gt;block_id(), target_to-&gt;block_id(), block-&gt;block_id()));
6143 
6144   LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6145 
6146   assert(instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6147   for (int i = instructions-&gt;length() - 1; i &gt;= 1; i--) {
6148     LIR_Op* op = instructions-&gt;at(i);
6149 
6150     if (op-&gt;code() == lir_branch || op-&gt;code() == lir_cond_float_branch) {
6151       assert(op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6152       LIR_OpBranch* branch = (LIR_OpBranch*)op;
6153 
6154       if (branch-&gt;block() == target_from) {
6155         branch-&gt;change_block(target_to);
6156       }
6157       if (branch-&gt;ublock() == target_from) {
6158         branch-&gt;change_ublock(target_to);
6159       }
6160     }
6161   }
6162 }
6163 
6164 void ControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
6165   int old_pos = 0;
6166   int new_pos = 0;
6167   int num_blocks = code-&gt;length();
6168 
6169   while (old_pos &lt; num_blocks) {
6170     BlockBegin* block = code-&gt;at(old_pos);
6171 
6172     if (can_delete_block(block)) {
6173       BlockBegin* new_target = block-&gt;sux_at(0);
6174 
6175       // propagate backward branch target flag for correct code alignment
6176       if (block-&gt;is_set(BlockBegin::backward_branch_target_flag)) {
6177         new_target-&gt;set(BlockBegin::backward_branch_target_flag);
6178       }
6179 
6180       // collect a list with all predecessors that contains each predecessor only once
6181       // the predecessors of cur are changed during the substitution, so a copy of the
6182       // predecessor list is necessary
6183       int j;
6184       _original_preds.clear();
6185       for (j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6186         BlockBegin* pred = block-&gt;pred_at(j);
6187         if (_original_preds.find(pred) == -1) {
6188           _original_preds.append(pred);
6189         }
6190       }
6191 
6192       for (j = _original_preds.length() - 1; j &gt;= 0; j--) {
6193         BlockBegin* pred = _original_preds.at(j);
6194         substitute_branch_target(pred, block, new_target);
6195         pred-&gt;substitute_sux(block, new_target);
6196       }
6197     } else {
6198       // adjust position of this block in the block list if blocks before
6199       // have been deleted
6200       if (new_pos != old_pos) {
6201         code-&gt;at_put(new_pos, code-&gt;at(old_pos));
6202       }
6203       new_pos++;
6204     }
6205     old_pos++;
6206   }
6207   code-&gt;trunc_to(new_pos);
6208 
6209   DEBUG_ONLY(verify(code));
6210 }
6211 
6212 void ControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
6213   // skip the last block because there a branch is always necessary
6214   for (int i = code-&gt;length() - 2; i &gt;= 0; i--) {
6215     BlockBegin* block = code-&gt;at(i);
6216     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6217 
6218     LIR_Op* last_op = instructions-&gt;last();
6219     if (last_op-&gt;code() == lir_branch) {
6220       assert(last_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6221       LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
6222 
6223       assert(last_branch-&gt;block() != NULL, &quot;last branch must always have a block as target&quot;);
6224       assert(last_branch-&gt;label() == last_branch-&gt;block()-&gt;label(), &quot;must be equal&quot;);
6225 
6226       if (last_branch-&gt;info() == NULL) {
6227         if (last_branch-&gt;block() == code-&gt;at(i + 1)) {
6228 
6229           TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6230 
6231           // delete last branch instruction
6232           instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6233 
6234         } else {
6235           LIR_Op* prev_op = instructions-&gt;at(instructions-&gt;length() - 2);
6236           if (prev_op-&gt;code() == lir_branch || prev_op-&gt;code() == lir_cond_float_branch) {
6237             assert(prev_op-&gt;as_OpBranch() != NULL, &quot;branch must be of type LIR_OpBranch&quot;);
6238             LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
6239 
6240             if (prev_branch-&gt;stub() == NULL) {
6241 
6242               LIR_Op2* prev_cmp = NULL;
6243               // There might be a cmove inserted for profiling which depends on the same
6244               // compare. If we change the condition of the respective compare, we have
6245               // to take care of this cmove as well.
6246               LIR_Op2* prev_cmove = NULL;
6247 
6248               for(int j = instructions-&gt;length() - 3; j &gt;= 0 &amp;&amp; prev_cmp == NULL; j--) {
6249                 prev_op = instructions-&gt;at(j);
6250                 // check for the cmove
6251                 if (prev_op-&gt;code() == lir_cmove) {
6252                   assert(prev_op-&gt;as_Op2() != NULL, &quot;cmove must be of type LIR_Op2&quot;);
6253                   prev_cmove = (LIR_Op2*)prev_op;
6254                   assert(prev_branch-&gt;cond() == prev_cmove-&gt;condition(), &quot;should be the same&quot;);
6255                 }
6256                 if (prev_op-&gt;code() == lir_cmp) {
6257                   assert(prev_op-&gt;as_Op2() != NULL, &quot;branch must be of type LIR_Op2&quot;);
6258                   prev_cmp = (LIR_Op2*)prev_op;
6259                   assert(prev_branch-&gt;cond() == prev_cmp-&gt;condition(), &quot;should be the same&quot;);
6260                 }
6261               }
6262               // Guarantee because it is dereferenced below.
6263               guarantee(prev_cmp != NULL, &quot;should have found comp instruction for branch&quot;);
6264               if (prev_branch-&gt;block() == code-&gt;at(i + 1) &amp;&amp; prev_branch-&gt;info() == NULL) {
6265 
6266                 TRACE_LINEAR_SCAN(3, tty-&gt;print_cr(&quot;Negating conditional branch and deleting unconditional branch at end of block B%d&quot;, block-&gt;block_id()));
6267 
6268                 // eliminate a conditional branch to the immediate successor
6269                 prev_branch-&gt;change_block(last_branch-&gt;block());
6270                 prev_branch-&gt;negate_cond();
6271                 prev_cmp-&gt;set_condition(prev_branch-&gt;cond());
6272                 instructions-&gt;trunc_to(instructions-&gt;length() - 1);
6273                 // if we do change the condition, we have to change the cmove as well
6274                 if (prev_cmove != NULL) {
6275                   prev_cmove-&gt;set_condition(prev_branch-&gt;cond());
6276                   LIR_Opr t = prev_cmove-&gt;in_opr1();
6277                   prev_cmove-&gt;set_in_opr1(prev_cmove-&gt;in_opr2());
6278                   prev_cmove-&gt;set_in_opr2(t);
6279                 }
6280               }
6281             }
6282           }
6283         }
6284       }
6285     }
6286   }
6287 
6288   DEBUG_ONLY(verify(code));
6289 }
6290 
6291 void ControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
6292 #ifdef ASSERT
6293   ResourceBitMap return_converted(BlockBegin::number_of_blocks());
6294 #endif
6295 
6296   for (int i = code-&gt;length() - 1; i &gt;= 0; i--) {
6297     BlockBegin* block = code-&gt;at(i);
6298     LIR_OpList* cur_instructions = block-&gt;lir()-&gt;instructions_list();
6299     LIR_Op*     cur_last_op = cur_instructions-&gt;last();
6300 
6301     assert(cur_instructions-&gt;at(0)-&gt;code() == lir_label, &quot;first instruction must always be a label&quot;);
6302     if (cur_instructions-&gt;length() == 2 &amp;&amp; cur_last_op-&gt;code() == lir_return) {
6303       // the block contains only a label and a return
6304       // if a predecessor ends with an unconditional jump to this block, then the jump
6305       // can be replaced with a return instruction
6306       //
6307       // Note: the original block with only a return statement cannot be deleted completely
6308       //       because the predecessors might have other (conditional) jumps to this block
6309       //       -&gt; this may lead to unnecesary return instructions in the final code
6310 
6311       assert(cur_last_op-&gt;info() == NULL, &quot;return instructions do not have debug information&quot;);
6312       assert(block-&gt;number_of_sux() == 0 ||
6313              (return_converted.at(block-&gt;block_id()) &amp;&amp; block-&gt;number_of_sux() == 1),
6314              &quot;blocks that end with return must not have successors&quot;);
6315 
6316       assert(cur_last_op-&gt;as_Op1() != NULL, &quot;return must be LIR_Op1&quot;);
6317       LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)-&gt;in_opr();
6318 
6319       for (int j = block-&gt;number_of_preds() - 1; j &gt;= 0; j--) {
6320         BlockBegin* pred = block-&gt;pred_at(j);
6321         LIR_OpList* pred_instructions = pred-&gt;lir()-&gt;instructions_list();
6322         LIR_Op*     pred_last_op = pred_instructions-&gt;last();
6323 
6324         if (pred_last_op-&gt;code() == lir_branch) {
6325           assert(pred_last_op-&gt;as_OpBranch() != NULL, &quot;branch must be LIR_OpBranch&quot;);
6326           LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
6327 
6328           if (pred_last_branch-&gt;block() == block &amp;&amp; pred_last_branch-&gt;cond() == lir_cond_always &amp;&amp; pred_last_branch-&gt;info() == NULL) {
6329             // replace the jump to a return with a direct return
6330             // Note: currently the edge between the blocks is not deleted
6331             pred_instructions-&gt;at_put(pred_instructions-&gt;length() - 1, new LIR_Op1(lir_return, return_opr));
6332 #ifdef ASSERT
6333             return_converted.set_bit(pred-&gt;block_id());
6334 #endif
6335           }
6336         }
6337       }
6338     }
6339   }
6340 }
6341 
6342 
6343 #ifdef ASSERT
6344 void ControlFlowOptimizer::verify(BlockList* code) {
6345   for (int i = 0; i &lt; code-&gt;length(); i++) {
6346     BlockBegin* block = code-&gt;at(i);
6347     LIR_OpList* instructions = block-&gt;lir()-&gt;instructions_list();
6348 
6349     int j;
6350     for (j = 0; j &lt; instructions-&gt;length(); j++) {
6351       LIR_OpBranch* op_branch = instructions-&gt;at(j)-&gt;as_OpBranch();
6352 
6353       if (op_branch != NULL) {
6354         assert(op_branch-&gt;block() == NULL || code-&gt;find(op_branch-&gt;block()) != -1, &quot;branch target not valid&quot;);
6355         assert(op_branch-&gt;ublock() == NULL || code-&gt;find(op_branch-&gt;ublock()) != -1, &quot;branch target not valid&quot;);
6356       }
6357     }
6358 
6359     for (j = 0; j &lt; block-&gt;number_of_sux() - 1; j++) {
6360       BlockBegin* sux = block-&gt;sux_at(j);
6361       assert(code-&gt;find(sux) != -1, &quot;successor not valid&quot;);
6362     }
6363 
6364     for (j = 0; j &lt; block-&gt;number_of_preds() - 1; j++) {
6365       BlockBegin* pred = block-&gt;pred_at(j);
6366       assert(code-&gt;find(pred) != -1, &quot;successor not valid&quot;);
6367     }
6368   }
6369 }
6370 #endif
6371 
6372 
6373 #ifndef PRODUCT
6374 
6375 // Implementation of LinearStatistic
6376 
6377 const char* LinearScanStatistic::counter_name(int counter_idx) {
6378   switch (counter_idx) {
6379     case counter_method:          return &quot;compiled methods&quot;;
6380     case counter_fpu_method:      return &quot;methods using fpu&quot;;
6381     case counter_loop_method:     return &quot;methods with loops&quot;;
6382     case counter_exception_method:return &quot;methods with xhandler&quot;;
6383 
6384     case counter_loop:            return &quot;loops&quot;;
6385     case counter_block:           return &quot;blocks&quot;;
6386     case counter_loop_block:      return &quot;blocks inside loop&quot;;
6387     case counter_exception_block: return &quot;exception handler entries&quot;;
6388     case counter_interval:        return &quot;intervals&quot;;
6389     case counter_fixed_interval:  return &quot;fixed intervals&quot;;
6390     case counter_range:           return &quot;ranges&quot;;
6391     case counter_fixed_range:     return &quot;fixed ranges&quot;;
6392     case counter_use_pos:         return &quot;use positions&quot;;
6393     case counter_fixed_use_pos:   return &quot;fixed use positions&quot;;
6394     case counter_spill_slots:     return &quot;spill slots&quot;;
6395 
6396     // counter for classes of lir instructions
6397     case counter_instruction:     return &quot;total instructions&quot;;
6398     case counter_label:           return &quot;labels&quot;;
6399     case counter_entry:           return &quot;method entries&quot;;
6400     case counter_return:          return &quot;method returns&quot;;
6401     case counter_call:            return &quot;method calls&quot;;
6402     case counter_move:            return &quot;moves&quot;;
6403     case counter_cmp:             return &quot;compare&quot;;
6404     case counter_cond_branch:     return &quot;conditional branches&quot;;
6405     case counter_uncond_branch:   return &quot;unconditional branches&quot;;
6406     case counter_stub_branch:     return &quot;branches to stub&quot;;
6407     case counter_alu:             return &quot;artithmetic + logic&quot;;
6408     case counter_alloc:           return &quot;allocations&quot;;
6409     case counter_sync:            return &quot;synchronisation&quot;;
6410     case counter_throw:           return &quot;throw&quot;;
6411     case counter_unwind:          return &quot;unwind&quot;;
6412     case counter_typecheck:       return &quot;type+null-checks&quot;;
6413     case counter_fpu_stack:       return &quot;fpu-stack&quot;;
6414     case counter_misc_inst:       return &quot;other instructions&quot;;
6415     case counter_other_inst:      return &quot;misc. instructions&quot;;
6416 
6417     // counter for different types of moves
6418     case counter_move_total:      return &quot;total moves&quot;;
6419     case counter_move_reg_reg:    return &quot;register-&gt;register&quot;;
6420     case counter_move_reg_stack:  return &quot;register-&gt;stack&quot;;
6421     case counter_move_stack_reg:  return &quot;stack-&gt;register&quot;;
6422     case counter_move_stack_stack:return &quot;stack-&gt;stack&quot;;
6423     case counter_move_reg_mem:    return &quot;register-&gt;memory&quot;;
6424     case counter_move_mem_reg:    return &quot;memory-&gt;register&quot;;
6425     case counter_move_const_any:  return &quot;constant-&gt;any&quot;;
6426 
6427     case blank_line_1:            return &quot;&quot;;
6428     case blank_line_2:            return &quot;&quot;;
6429 
6430     default: ShouldNotReachHere(); return &quot;&quot;;
6431   }
6432 }
6433 
6434 LinearScanStatistic::Counter LinearScanStatistic::base_counter(int counter_idx) {
6435   if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
6436     return counter_method;
6437   } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
6438     return counter_block;
6439   } else if (counter_idx &gt;= counter_instruction &amp;&amp; counter_idx &lt;= counter_other_inst) {
6440     return counter_instruction;
6441   } else if (counter_idx &gt;= counter_move_total &amp;&amp; counter_idx &lt;= counter_move_const_any) {
6442     return counter_move_total;
6443   }
6444   return invalid_counter;
6445 }
6446 
6447 LinearScanStatistic::LinearScanStatistic() {
6448   for (int i = 0; i &lt; number_of_counters; i++) {
6449     _counters_sum[i] = 0;
6450     _counters_max[i] = -1;
6451   }
6452 
6453 }
6454 
6455 // add the method-local numbers to the total sum
6456 void LinearScanStatistic::sum_up(LinearScanStatistic &amp;method_statistic) {
6457   for (int i = 0; i &lt; number_of_counters; i++) {
6458     _counters_sum[i] += method_statistic._counters_sum[i];
6459     _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
6460   }
6461 }
6462 
6463 void LinearScanStatistic::print(const char* title) {
6464   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6465     tty-&gt;cr();
6466     tty-&gt;print_cr(&quot;***** LinearScan statistic - %s *****&quot;, title);
6467 
6468     for (int i = 0; i &lt; number_of_counters; i++) {
6469       if (_counters_sum[i] &gt; 0 || _counters_max[i] &gt;= 0) {
6470         tty-&gt;print(&quot;%25s: %8d&quot;, counter_name(i), _counters_sum[i]);
6471 
6472         LinearScanStatistic::Counter cntr = base_counter(i);
6473         if (cntr != invalid_counter) {
6474           tty-&gt;print(&quot;  (%5.1f%%) &quot;, _counters_sum[i] * 100.0 / _counters_sum[cntr]);
6475         } else {
6476           tty-&gt;print(&quot;           &quot;);
6477         }
6478 
6479         if (_counters_max[i] &gt;= 0) {
6480           tty-&gt;print(&quot;%8d&quot;, _counters_max[i]);
6481         }
6482       }
6483       tty-&gt;cr();
6484     }
6485   }
6486 }
6487 
6488 void LinearScanStatistic::collect(LinearScan* allocator) {
6489   inc_counter(counter_method);
6490   if (allocator-&gt;has_fpu_registers()) {
6491     inc_counter(counter_fpu_method);
6492   }
6493   if (allocator-&gt;num_loops() &gt; 0) {
6494     inc_counter(counter_loop_method);
6495   }
6496   inc_counter(counter_loop, allocator-&gt;num_loops());
6497   inc_counter(counter_spill_slots, allocator-&gt;max_spills());
6498 
6499   int i;
6500   for (i = 0; i &lt; allocator-&gt;interval_count(); i++) {
6501     Interval* cur = allocator-&gt;interval_at(i);
6502 
6503     if (cur != NULL) {
6504       inc_counter(counter_interval);
6505       inc_counter(counter_use_pos, cur-&gt;num_use_positions());
6506       if (LinearScan::is_precolored_interval(cur)) {
6507         inc_counter(counter_fixed_interval);
6508         inc_counter(counter_fixed_use_pos, cur-&gt;num_use_positions());
6509       }
6510 
6511       Range* range = cur-&gt;first();
6512       while (range != Range::end()) {
6513         inc_counter(counter_range);
6514         if (LinearScan::is_precolored_interval(cur)) {
6515           inc_counter(counter_fixed_range);
6516         }
6517         range = range-&gt;next();
6518       }
6519     }
6520   }
6521 
6522   bool has_xhandlers = false;
6523   // Note: only count blocks that are in code-emit order
6524   for (i = 0; i &lt; allocator-&gt;ir()-&gt;code()-&gt;length(); i++) {
6525     BlockBegin* cur = allocator-&gt;ir()-&gt;code()-&gt;at(i);
6526 
6527     inc_counter(counter_block);
6528     if (cur-&gt;loop_depth() &gt; 0) {
6529       inc_counter(counter_loop_block);
6530     }
6531     if (cur-&gt;is_set(BlockBegin::exception_entry_flag)) {
6532       inc_counter(counter_exception_block);
6533       has_xhandlers = true;
6534     }
6535 
6536     LIR_OpList* instructions = cur-&gt;lir()-&gt;instructions_list();
6537     for (int j = 0; j &lt; instructions-&gt;length(); j++) {
6538       LIR_Op* op = instructions-&gt;at(j);
6539 
6540       inc_counter(counter_instruction);
6541 
6542       switch (op-&gt;code()) {
6543         case lir_label:           inc_counter(counter_label); break;
6544         case lir_std_entry:
6545         case lir_osr_entry:       inc_counter(counter_entry); break;
6546         case lir_return:          inc_counter(counter_return); break;
6547 
6548         case lir_rtcall:
6549         case lir_static_call:
6550         case lir_optvirtual_call:
6551         case lir_virtual_call:    inc_counter(counter_call); break;
6552 
6553         case lir_move: {
6554           inc_counter(counter_move);
6555           inc_counter(counter_move_total);
6556 
6557           LIR_Opr in = op-&gt;as_Op1()-&gt;in_opr();
6558           LIR_Opr res = op-&gt;as_Op1()-&gt;result_opr();
6559           if (in-&gt;is_register()) {
6560             if (res-&gt;is_register()) {
6561               inc_counter(counter_move_reg_reg);
6562             } else if (res-&gt;is_stack()) {
6563               inc_counter(counter_move_reg_stack);
6564             } else if (res-&gt;is_address()) {
6565               inc_counter(counter_move_reg_mem);
6566             } else {
6567               ShouldNotReachHere();
6568             }
6569           } else if (in-&gt;is_stack()) {
6570             if (res-&gt;is_register()) {
6571               inc_counter(counter_move_stack_reg);
6572             } else {
6573               inc_counter(counter_move_stack_stack);
6574             }
6575           } else if (in-&gt;is_address()) {
6576             assert(res-&gt;is_register(), &quot;must be&quot;);
6577             inc_counter(counter_move_mem_reg);
6578           } else if (in-&gt;is_constant()) {
6579             inc_counter(counter_move_const_any);
6580           } else {
6581             ShouldNotReachHere();
6582           }
6583           break;
6584         }
6585 
6586         case lir_cmp:             inc_counter(counter_cmp); break;
6587 
6588         case lir_branch:
6589         case lir_cond_float_branch: {
6590           LIR_OpBranch* branch = op-&gt;as_OpBranch();
6591           if (branch-&gt;block() == NULL) {
6592             inc_counter(counter_stub_branch);
6593           } else if (branch-&gt;cond() == lir_cond_always) {
6594             inc_counter(counter_uncond_branch);
6595           } else {
6596             inc_counter(counter_cond_branch);
6597           }
6598           break;
6599         }
6600 
6601         case lir_neg:
6602         case lir_add:
6603         case lir_sub:
6604         case lir_mul:
6605         case lir_mul_strictfp:
6606         case lir_div:
6607         case lir_div_strictfp:
6608         case lir_rem:
6609         case lir_sqrt:
6610         case lir_abs:
6611         case lir_log10:
6612         case lir_logic_and:
6613         case lir_logic_or:
6614         case lir_logic_xor:
6615         case lir_shl:
6616         case lir_shr:
6617         case lir_ushr:            inc_counter(counter_alu); break;
6618 
6619         case lir_alloc_object:
6620         case lir_alloc_array:     inc_counter(counter_alloc); break;
6621 
6622         case lir_monaddr:
6623         case lir_lock:
6624         case lir_unlock:          inc_counter(counter_sync); break;
6625 
6626         case lir_throw:           inc_counter(counter_throw); break;
6627 
6628         case lir_unwind:          inc_counter(counter_unwind); break;
6629 
6630         case lir_null_check:
6631         case lir_leal:
6632         case lir_instanceof:
6633         case lir_checkcast:
6634         case lir_store_check:     inc_counter(counter_typecheck); break;
6635 
6636         case lir_fpop_raw:
6637         case lir_fxch:
6638         case lir_fld:             inc_counter(counter_fpu_stack); break;
6639 
6640         case lir_nop:
6641         case lir_push:
6642         case lir_pop:
6643         case lir_convert:
6644         case lir_roundfp:
6645         case lir_cmove:           inc_counter(counter_misc_inst); break;
6646 
6647         default:                  inc_counter(counter_other_inst); break;
6648       }
6649     }
6650   }
6651 
6652   if (has_xhandlers) {
6653     inc_counter(counter_exception_method);
6654   }
6655 }
6656 
6657 void LinearScanStatistic::compute(LinearScan* allocator, LinearScanStatistic &amp;global_statistic) {
6658   if (CountLinearScan || TraceLinearScanLevel &gt; 0) {
6659 
6660     LinearScanStatistic local_statistic = LinearScanStatistic();
6661 
6662     local_statistic.collect(allocator);
6663     global_statistic.sum_up(local_statistic);
6664 
6665     if (TraceLinearScanLevel &gt; 2) {
6666       local_statistic.print(&quot;current local statistic&quot;);
6667     }
6668   }
6669 }
6670 
6671 
6672 // Implementation of LinearTimers
6673 
6674 LinearScanTimers::LinearScanTimers() {
6675   for (int i = 0; i &lt; number_of_timers; i++) {
6676     timer(i)-&gt;reset();
6677   }
6678 }
6679 
6680 const char* LinearScanTimers::timer_name(int idx) {
6681   switch (idx) {
6682     case timer_do_nothing:               return &quot;Nothing (Time Check)&quot;;
6683     case timer_number_instructions:      return &quot;Number Instructions&quot;;
6684     case timer_compute_local_live_sets:  return &quot;Local Live Sets&quot;;
6685     case timer_compute_global_live_sets: return &quot;Global Live Sets&quot;;
6686     case timer_build_intervals:          return &quot;Build Intervals&quot;;
6687     case timer_sort_intervals_before:    return &quot;Sort Intervals Before&quot;;
6688     case timer_allocate_registers:       return &quot;Allocate Registers&quot;;
6689     case timer_resolve_data_flow:        return &quot;Resolve Data Flow&quot;;
6690     case timer_sort_intervals_after:     return &quot;Sort Intervals After&quot;;
6691     case timer_eliminate_spill_moves:    return &quot;Spill optimization&quot;;
6692     case timer_assign_reg_num:           return &quot;Assign Reg Num&quot;;
6693     case timer_allocate_fpu_stack:       return &quot;Allocate FPU Stack&quot;;
6694     case timer_optimize_lir:             return &quot;Optimize LIR&quot;;
6695     default: ShouldNotReachHere();       return &quot;&quot;;
6696   }
6697 }
6698 
6699 void LinearScanTimers::begin_method() {
6700   if (TimeEachLinearScan) {
6701     // reset all timers to measure only current method
6702     for (int i = 0; i &lt; number_of_timers; i++) {
6703       timer(i)-&gt;reset();
6704     }
6705   }
6706 }
6707 
6708 void LinearScanTimers::end_method(LinearScan* allocator) {
6709   if (TimeEachLinearScan) {
6710 
6711     double c = timer(timer_do_nothing)-&gt;seconds();
6712     double total = 0;
6713     for (int i = 1; i &lt; number_of_timers; i++) {
6714       total += timer(i)-&gt;seconds() - c;
6715     }
6716 
6717     if (total &gt;= 0.0005) {
6718       // print all information in one line for automatic processing
6719       tty-&gt;print(&quot;@&quot;); allocator-&gt;compilation()-&gt;method()-&gt;print_name();
6720 
6721       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;compilation()-&gt;method()-&gt;code_size());
6722       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_at(allocator-&gt;block_count() - 1)-&gt;last_lir_instruction_id() / 2);
6723       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;block_count());
6724       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_virtual_regs());
6725       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;interval_count());
6726       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;_num_calls);
6727       tty-&gt;print(&quot;@ %d &quot;, allocator-&gt;num_loops());
6728 
6729       tty-&gt;print(&quot;@ %6.6f &quot;, total);
6730       for (int i = 1; i &lt; number_of_timers; i++) {
6731         tty-&gt;print(&quot;@ %4.1f &quot;, ((timer(i)-&gt;seconds() - c) / total) * 100);
6732       }
6733       tty-&gt;cr();
6734     }
6735   }
6736 }
6737 
6738 void LinearScanTimers::print(double total_time) {
6739   if (TimeLinearScan) {
6740     // correction value: sum of dummy-timer that only measures the time that
6741     // is necesary to start and stop itself
6742     double c = timer(timer_do_nothing)-&gt;seconds();
6743 
6744     for (int i = 0; i &lt; number_of_timers; i++) {
6745       double t = timer(i)-&gt;seconds();
6746       tty-&gt;print_cr(&quot;    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)&quot;, timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
6747     }
6748   }
6749 }
6750 
6751 #endif // #ifndef PRODUCT
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
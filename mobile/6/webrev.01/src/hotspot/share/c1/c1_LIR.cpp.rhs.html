<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_InstructionPrinter.hpp&quot;
  27 #include &quot;c1/c1_LIR.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_ValueStack.hpp&quot;
  30 #include &quot;ci/ciInstance.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 Register LIR_OprDesc::as_register() const {
  34   return FrameMap::cpu_rnr2reg(cpu_regnr());
  35 }
  36 
  37 Register LIR_OprDesc::as_register_lo() const {
  38   return FrameMap::cpu_rnr2reg(cpu_regnrLo());
  39 }
  40 
  41 Register LIR_OprDesc::as_register_hi() const {
  42   return FrameMap::cpu_rnr2reg(cpu_regnrHi());
  43 }
  44 
  45 LIR_Opr LIR_OprFact::illegalOpr = LIR_OprFact::illegal();
  46 
  47 LIR_Opr LIR_OprFact::value_type(ValueType* type) {
  48   ValueTag tag = type-&gt;tag();
  49   switch (tag) {
  50   case metaDataTag : {
  51     ClassConstant* c = type-&gt;as_ClassConstant();
  52     if (c != NULL &amp;&amp; !c-&gt;value()-&gt;is_loaded()) {
  53       return LIR_OprFact::metadataConst(NULL);
  54     } else if (c != NULL) {
  55       return LIR_OprFact::metadataConst(c-&gt;value()-&gt;constant_encoding());
  56     } else {
  57       MethodConstant* m = type-&gt;as_MethodConstant();
  58       assert (m != NULL, &quot;not a class or a method?&quot;);
  59       return LIR_OprFact::metadataConst(m-&gt;value()-&gt;constant_encoding());
  60     }
  61   }
  62   case objectTag : {
  63       return LIR_OprFact::oopConst(type-&gt;as_ObjectType()-&gt;encoding());
  64     }
  65   case addressTag: return LIR_OprFact::addressConst(type-&gt;as_AddressConstant()-&gt;value());
  66   case intTag    : return LIR_OprFact::intConst(type-&gt;as_IntConstant()-&gt;value());
  67   case floatTag  : return LIR_OprFact::floatConst(type-&gt;as_FloatConstant()-&gt;value());
  68   case longTag   : return LIR_OprFact::longConst(type-&gt;as_LongConstant()-&gt;value());
  69   case doubleTag : return LIR_OprFact::doubleConst(type-&gt;as_DoubleConstant()-&gt;value());
  70   default: ShouldNotReachHere(); return LIR_OprFact::intConst(-1);
  71   }
  72 }
  73 
  74 
  75 //---------------------------------------------------
  76 
  77 
  78 LIR_Address::Scale LIR_Address::scale(BasicType type) {
  79   int elem_size = type2aelembytes(type);
  80   switch (elem_size) {
  81   case 1: return LIR_Address::times_1;
  82   case 2: return LIR_Address::times_2;
  83   case 4: return LIR_Address::times_4;
  84   case 8: return LIR_Address::times_8;
  85   }
  86   ShouldNotReachHere();
  87   return LIR_Address::times_1;
  88 }
  89 
  90 //---------------------------------------------------
  91 
  92 char LIR_OprDesc::type_char(BasicType t) {
  93   switch (t) {
  94     case T_ARRAY:
  95       t = T_OBJECT;
  96     case T_BOOLEAN:
  97     case T_CHAR:
  98     case T_FLOAT:
  99     case T_DOUBLE:
 100     case T_BYTE:
 101     case T_SHORT:
 102     case T_INT:
 103     case T_LONG:
 104     case T_OBJECT:
 105     case T_ADDRESS:
 106     case T_VOID:
 107       return ::type2char(t);
 108     case T_METADATA:
 109       return &#39;M&#39;;
 110     case T_ILLEGAL:
 111       return &#39;?&#39;;
 112 
 113     default:
 114       ShouldNotReachHere();
 115       return &#39;?&#39;;
 116   }
 117 }
 118 
 119 #ifndef PRODUCT
 120 void LIR_OprDesc::validate_type() const {
 121 
 122 #ifdef ASSERT
 123   if (!is_pointer() &amp;&amp; !is_illegal()) {
 124     OprKind kindfield = kind_field(); // Factored out because of compiler bug, see 8002160
 125     switch (as_BasicType(type_field())) {
 126     case T_LONG:
 127       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 128              size_field() == double_size, &quot;must match&quot;);
 129       break;
 130     case T_FLOAT:
 131       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 132       assert((kindfield == fpu_register || kindfield == stack_value
 133              ARM_ONLY(|| kindfield == cpu_register)
 134              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 135              size_field() == single_size, &quot;must match&quot;);
 136       break;
 137     case T_DOUBLE:
 138       // FP return values can be also in CPU registers on ARM and PPC32 (softfp ABI)
 139       assert((kindfield == fpu_register || kindfield == stack_value
 140              ARM_ONLY(|| kindfield == cpu_register)
 141              PPC32_ONLY(|| kindfield == cpu_register) ) &amp;&amp;
 142              size_field() == double_size, &quot;must match&quot;);
 143       break;
 144     case T_BOOLEAN:
 145     case T_CHAR:
 146     case T_BYTE:
 147     case T_SHORT:
 148     case T_INT:
 149     case T_ADDRESS:
 150     case T_OBJECT:
 151     case T_METADATA:
 152     case T_ARRAY:
 153       assert((kindfield == cpu_register || kindfield == stack_value) &amp;&amp;
 154              size_field() == single_size, &quot;must match&quot;);
 155       break;
 156 
 157     case T_ILLEGAL:
 158       // XXX TKR also means unknown right now
 159       // assert(is_illegal(), &quot;must match&quot;);
 160       break;
 161 
 162     default:
 163       ShouldNotReachHere();
 164     }
 165   }
 166 #endif
 167 
 168 }
 169 #endif // PRODUCT
 170 
 171 
 172 bool LIR_OprDesc::is_oop() const {
 173   if (is_pointer()) {
 174     return pointer()-&gt;is_oop_pointer();
 175   } else {
 176     OprType t= type_field();
 177     assert(t != unknown_type, &quot;not set&quot;);
 178     return t == object_type;
 179   }
 180 }
 181 
 182 
 183 
 184 void LIR_Op2::verify() const {
 185 #ifdef ASSERT
 186   switch (code()) {
 187     case lir_cmove:
 188     case lir_xchg:
 189       break;
 190 
 191     default:
 192       assert(!result_opr()-&gt;is_register() || !result_opr()-&gt;is_oop_register(),
 193              &quot;can&#39;t produce oops from arith&quot;);
 194   }
 195 
 196   if (TwoOperandLIRForm) {
 197 
 198 #ifdef ASSERT
 199     bool threeOperandForm = false;
 200 #ifdef S390
 201     // There are 3 operand shifts on S390 (see LIR_Assembler::shift_op()).
 202     threeOperandForm =
 203       code() == lir_shl ||
 204       ((code() == lir_shr || code() == lir_ushr) &amp;&amp; (result_opr()-&gt;is_double_cpu() || in_opr1()-&gt;type() == T_OBJECT));
 205 #endif
 206 #endif
 207 
 208     switch (code()) {
 209     case lir_add:
 210     case lir_sub:
 211     case lir_mul:
 212     case lir_mul_strictfp:
 213     case lir_div:
 214     case lir_div_strictfp:
 215     case lir_rem:
 216     case lir_logic_and:
 217     case lir_logic_or:
 218     case lir_logic_xor:
 219     case lir_shl:
 220     case lir_shr:
 221       assert(in_opr1() == result_opr() || threeOperandForm, &quot;opr1 and result must match&quot;);
 222       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 223       break;
 224 
 225     // special handling for lir_ushr because of write barriers
 226     case lir_ushr:
 227       assert(in_opr1() == result_opr() || in_opr2()-&gt;is_constant() || threeOperandForm, &quot;opr1 and result must match or shift count is constant&quot;);
 228       assert(in_opr1()-&gt;is_valid() &amp;&amp; in_opr2()-&gt;is_valid(), &quot;must be valid&quot;);
 229       break;
 230 
 231     default:
 232       break;
 233     }
 234   }
 235 #endif
 236 }
 237 
 238 
 239 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block)
 240   : LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 241   , _cond(cond)
 242   , _type(type)
 243   , _label(block-&gt;label())
 244   , _block(block)
 245   , _ublock(NULL)
 246   , _stub(NULL) {
 247 }
 248 
 249 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, CodeStub* stub) :
 250   LIR_Op(lir_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 251   , _cond(cond)
 252   , _type(type)
 253   , _label(stub-&gt;entry())
 254   , _block(NULL)
 255   , _ublock(NULL)
 256   , _stub(stub) {
 257 }
 258 
 259 LIR_OpBranch::LIR_OpBranch(LIR_Condition cond, BasicType type, BlockBegin* block, BlockBegin* ublock)
 260   : LIR_Op(lir_cond_float_branch, LIR_OprFact::illegalOpr, (CodeEmitInfo*)NULL)
 261   , _cond(cond)
 262   , _type(type)
 263   , _label(block-&gt;label())
 264   , _block(block)
 265   , _ublock(ublock)
 266   , _stub(NULL)
 267 {
 268 }
 269 
 270 void LIR_OpBranch::change_block(BlockBegin* b) {
 271   assert(_block != NULL, &quot;must have old block&quot;);
 272   assert(_block-&gt;label() == label(), &quot;must be equal&quot;);
 273 
 274   _block = b;
 275   _label = b-&gt;label();
 276 }
 277 
 278 void LIR_OpBranch::change_ublock(BlockBegin* b) {
 279   assert(_ublock != NULL, &quot;must have old block&quot;);
 280   _ublock = b;
 281 }
 282 
 283 void LIR_OpBranch::negate_cond() {
 284   switch (_cond) {
 285     case lir_cond_equal:        _cond = lir_cond_notEqual;     break;
 286     case lir_cond_notEqual:     _cond = lir_cond_equal;        break;
 287     case lir_cond_less:         _cond = lir_cond_greaterEqual; break;
 288     case lir_cond_lessEqual:    _cond = lir_cond_greater;      break;
 289     case lir_cond_greaterEqual: _cond = lir_cond_less;         break;
 290     case lir_cond_greater:      _cond = lir_cond_lessEqual;    break;
 291     default: ShouldNotReachHere();
 292   }
 293 }
 294 
 295 
 296 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr result, LIR_Opr object, ciKlass* klass,
 297                                  LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
 298                                  bool fast_check, CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch,
 299                                  CodeStub* stub)
 300 
 301   : LIR_Op(code, result, NULL)
 302   , _object(object)
 303   , _array(LIR_OprFact::illegalOpr)
 304   , _klass(klass)
 305   , _tmp1(tmp1)
 306   , _tmp2(tmp2)
 307   , _tmp3(tmp3)
 308   , _fast_check(fast_check)
 309   , _info_for_patch(info_for_patch)
 310   , _info_for_exception(info_for_exception)
 311   , _stub(stub)
 312   , _profiled_method(NULL)
 313   , _profiled_bci(-1)
 314   , _should_profile(false)
 315 {
 316   if (code == lir_checkcast) {
 317     assert(info_for_exception != NULL, &quot;checkcast throws exceptions&quot;);
 318   } else if (code == lir_instanceof) {
 319     assert(info_for_exception == NULL, &quot;instanceof throws no exceptions&quot;);
 320   } else {
 321     ShouldNotReachHere();
 322   }
 323 }
 324 
 325 
 326 
 327 LIR_OpTypeCheck::LIR_OpTypeCheck(LIR_Code code, LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, CodeEmitInfo* info_for_exception)
 328   : LIR_Op(code, LIR_OprFact::illegalOpr, NULL)
 329   , _object(object)
 330   , _array(array)
 331   , _klass(NULL)
 332   , _tmp1(tmp1)
 333   , _tmp2(tmp2)
 334   , _tmp3(tmp3)
 335   , _fast_check(false)
 336   , _info_for_patch(NULL)
 337   , _info_for_exception(info_for_exception)
 338   , _stub(NULL)
 339   , _profiled_method(NULL)
 340   , _profiled_bci(-1)
 341   , _should_profile(false)
 342 {
 343   if (code == lir_store_check) {
 344     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
 345     assert(info_for_exception != NULL, &quot;store_check throws exceptions&quot;);
 346   } else {
 347     ShouldNotReachHere();
 348   }
 349 }
 350 
 351 
 352 LIR_OpArrayCopy::LIR_OpArrayCopy(LIR_Opr src, LIR_Opr src_pos, LIR_Opr dst, LIR_Opr dst_pos, LIR_Opr length,
 353                                  LIR_Opr tmp, ciArrayKlass* expected_type, int flags, CodeEmitInfo* info)
 354   : LIR_Op(lir_arraycopy, LIR_OprFact::illegalOpr, info)
 355   , _src(src)
 356   , _src_pos(src_pos)
 357   , _dst(dst)
 358   , _dst_pos(dst_pos)
 359   , _length(length)
 360   , _tmp(tmp)
 361   , _expected_type(expected_type)
 362   , _flags(flags) {
 363   _stub = new ArrayCopyStub(this);
 364 }
 365 
 366 LIR_OpUpdateCRC32::LIR_OpUpdateCRC32(LIR_Opr crc, LIR_Opr val, LIR_Opr res)
 367   : LIR_Op(lir_updatecrc32, res, NULL)
 368   , _crc(crc)
 369   , _val(val) {
 370 }
 371 
 372 //-------------------verify--------------------------
 373 
 374 void LIR_Op1::verify() const {
 375   switch(code()) {
 376   case lir_move:
 377     assert(in_opr()-&gt;is_valid() &amp;&amp; result_opr()-&gt;is_valid(), &quot;must be&quot;);
 378     break;
 379   case lir_null_check:
 380     assert(in_opr()-&gt;is_register(), &quot;must be&quot;);
 381     break;
 382   case lir_return:
 383     assert(in_opr()-&gt;is_register() || in_opr()-&gt;is_illegal(), &quot;must be&quot;);
 384     break;
 385   default:
 386     break;
 387   }
 388 }
 389 
 390 void LIR_OpRTCall::verify() const {
 391   assert(strcmp(Runtime1::name_for_address(addr()), &quot;&lt;unknown function&gt;&quot;) != 0, &quot;unknown function&quot;);
 392 }
 393 
 394 //-------------------visits--------------------------
 395 
 396 // complete rework of LIR instruction visitor.
 397 // The virtual call for each instruction type is replaced by a big
 398 // switch that adds the operands for each instruction
 399 
 400 void LIR_OpVisitState::visit(LIR_Op* op) {
 401   // copy information from the LIR_Op
 402   reset();
 403   set_op(op);
 404 
 405   switch (op-&gt;code()) {
 406 
 407 // LIR_Op0
 408     case lir_backwardbranch_target:    // result and info always invalid
 409     case lir_fpop_raw:                 // result and info always invalid
 410     case lir_breakpoint:               // result and info always invalid
 411     case lir_membar:                   // result and info always invalid
 412     case lir_membar_acquire:           // result and info always invalid
 413     case lir_membar_release:           // result and info always invalid
 414     case lir_membar_loadload:          // result and info always invalid
 415     case lir_membar_storestore:        // result and info always invalid
 416     case lir_membar_loadstore:         // result and info always invalid
 417     case lir_membar_storeload:         // result and info always invalid
 418     case lir_on_spin_wait:
 419     {
 420       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 421       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 422       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 423       break;
 424     }
 425 
 426     case lir_nop:                      // may have info, result always invalid
 427     case lir_std_entry:                // may have result, info always invalid
 428     case lir_osr_entry:                // may have result, info always invalid
 429     case lir_get_thread:               // may have result, info always invalid
 430     {
 431       assert(op-&gt;as_Op0() != NULL, &quot;must be&quot;);
 432       if (op-&gt;_info != NULL)           do_info(op-&gt;_info);
 433       if (op-&gt;_result-&gt;is_valid())     do_output(op-&gt;_result);
 434       break;
 435     }
 436 
 437 
 438 // LIR_OpLabel
 439     case lir_label:                    // result and info always invalid
 440     {
 441       assert(op-&gt;as_OpLabel() != NULL, &quot;must be&quot;);
 442       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 443       assert(op-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 444       break;
 445     }
 446 
 447 
 448 // LIR_Op1
 449     case lir_fxch:           // input always valid, result and info always invalid
 450     case lir_fld:            // input always valid, result and info always invalid
 451     case lir_push:           // input always valid, result and info always invalid
 452     case lir_pop:            // input always valid, result and info always invalid
 453     case lir_return:         // input always valid, result and info always invalid
 454     case lir_leal:           // input and result always valid, info always invalid
 455     case lir_monaddr:        // input and result always valid, info always invalid
 456     case lir_null_check:     // input and info always valid, result always invalid
 457     case lir_move:           // input and result always valid, may have info
<a name="2" id="anc2"></a>

 458     {
 459       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 460       LIR_Op1* op1 = (LIR_Op1*)op;
 461 
 462       if (op1-&gt;_info)                  do_info(op1-&gt;_info);
 463       if (op1-&gt;_opr-&gt;is_valid())       do_input(op1-&gt;_opr);
 464       if (op1-&gt;_result-&gt;is_valid())    do_output(op1-&gt;_result);
 465 
 466       break;
 467     }
 468 
 469     case lir_safepoint:
 470     {
 471       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 472       LIR_Op1* op1 = (LIR_Op1*)op;
 473 
 474       assert(op1-&gt;_info != NULL, &quot;&quot;);  do_info(op1-&gt;_info);
 475       if (op1-&gt;_opr-&gt;is_valid())       do_temp(op1-&gt;_opr); // safepoints on SPARC need temporary register
 476       assert(op1-&gt;_result-&gt;is_illegal(), &quot;safepoint does not produce value&quot;);
 477 
 478       break;
 479     }
 480 
 481 // LIR_OpConvert;
 482     case lir_convert:        // input and result always valid, info always invalid
 483     {
 484       assert(op-&gt;as_OpConvert() != NULL, &quot;must be&quot;);
 485       LIR_OpConvert* opConvert = (LIR_OpConvert*)op;
 486 
 487       assert(opConvert-&gt;_info == NULL, &quot;must be&quot;);
 488       if (opConvert-&gt;_opr-&gt;is_valid())       do_input(opConvert-&gt;_opr);
 489       if (opConvert-&gt;_result-&gt;is_valid())    do_output(opConvert-&gt;_result);
 490 #ifdef PPC32
 491       if (opConvert-&gt;_tmp1-&gt;is_valid())      do_temp(opConvert-&gt;_tmp1);
 492       if (opConvert-&gt;_tmp2-&gt;is_valid())      do_temp(opConvert-&gt;_tmp2);
 493 #endif
 494       do_stub(opConvert-&gt;_stub);
 495 
 496       break;
 497     }
 498 
 499 // LIR_OpBranch;
 500     case lir_branch:                   // may have info, input and result register always invalid
 501     case lir_cond_float_branch:        // may have info, input and result register always invalid
 502     {
 503       assert(op-&gt;as_OpBranch() != NULL, &quot;must be&quot;);
 504       LIR_OpBranch* opBranch = (LIR_OpBranch*)op;
 505 
 506       if (opBranch-&gt;_info != NULL)     do_info(opBranch-&gt;_info);
 507       assert(opBranch-&gt;_result-&gt;is_illegal(), &quot;not used&quot;);
 508       if (opBranch-&gt;_stub != NULL)     opBranch-&gt;stub()-&gt;visit(this);
 509 
 510       break;
 511     }
 512 
 513 
 514 // LIR_OpAllocObj
 515     case lir_alloc_object:
 516     {
 517       assert(op-&gt;as_OpAllocObj() != NULL, &quot;must be&quot;);
 518       LIR_OpAllocObj* opAllocObj = (LIR_OpAllocObj*)op;
 519 
 520       if (opAllocObj-&gt;_info)                     do_info(opAllocObj-&gt;_info);
 521       if (opAllocObj-&gt;_opr-&gt;is_valid()) {        do_input(opAllocObj-&gt;_opr);
 522                                                  do_temp(opAllocObj-&gt;_opr);
 523                                         }
 524       if (opAllocObj-&gt;_tmp1-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp1);
 525       if (opAllocObj-&gt;_tmp2-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp2);
 526       if (opAllocObj-&gt;_tmp3-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp3);
 527       if (opAllocObj-&gt;_tmp4-&gt;is_valid())         do_temp(opAllocObj-&gt;_tmp4);
 528       if (opAllocObj-&gt;_result-&gt;is_valid())       do_output(opAllocObj-&gt;_result);
 529                                                  do_stub(opAllocObj-&gt;_stub);
 530       break;
 531     }
 532 
 533 
 534 // LIR_OpRoundFP;
 535     case lir_roundfp: {
 536       assert(op-&gt;as_OpRoundFP() != NULL, &quot;must be&quot;);
 537       LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;
 538 
 539       assert(op-&gt;_info == NULL, &quot;info not used by this instruction&quot;);
 540       assert(opRoundFP-&gt;_tmp-&gt;is_illegal(), &quot;not used&quot;);
 541       do_input(opRoundFP-&gt;_opr);
 542       do_output(opRoundFP-&gt;_result);
 543 
 544       break;
 545     }
 546 
 547 
 548 // LIR_Op2
 549     case lir_cmp:
 550     case lir_cmp_l2i:
 551     case lir_ucmp_fd2i:
 552     case lir_cmp_fd2i:
 553     case lir_add:
 554     case lir_sub:
 555     case lir_mul:
 556     case lir_div:
 557     case lir_rem:
 558     case lir_sqrt:
 559     case lir_abs:
 560     case lir_neg:
 561     case lir_logic_and:
 562     case lir_logic_or:
 563     case lir_logic_xor:
 564     case lir_shl:
 565     case lir_shr:
 566     case lir_ushr:
 567     case lir_xadd:
 568     case lir_xchg:
 569     case lir_assert:
 570     {
 571       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 572       LIR_Op2* op2 = (LIR_Op2*)op;
 573       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 574              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 575 
 576       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 577       if (op2-&gt;_opr1-&gt;is_valid())         do_input(op2-&gt;_opr1);
 578       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2);
 579       if (op2-&gt;_tmp1-&gt;is_valid())         do_temp(op2-&gt;_tmp1);
 580       if (op2-&gt;_result-&gt;is_valid())       do_output(op2-&gt;_result);
 581       if (op-&gt;code() == lir_xchg || op-&gt;code() == lir_xadd) {
 582         // on ARM and PPC, return value is loaded first so could
 583         // destroy inputs. On other platforms that implement those
 584         // (x86, sparc), the extra constrainsts are harmless.
 585         if (op2-&gt;_opr1-&gt;is_valid())       do_temp(op2-&gt;_opr1);
 586         if (op2-&gt;_opr2-&gt;is_valid())       do_temp(op2-&gt;_opr2);
 587       }
 588 
 589       break;
 590     }
 591 
 592     // special handling for cmove: right input operand must not be equal
 593     // to the result operand, otherwise the backend fails
 594     case lir_cmove:
 595     {
 596       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 597       LIR_Op2* op2 = (LIR_Op2*)op;
 598 
 599       assert(op2-&gt;_info == NULL &amp;&amp; op2-&gt;_tmp1-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp;
 600              op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 601       assert(op2-&gt;_opr1-&gt;is_valid() &amp;&amp; op2-&gt;_opr2-&gt;is_valid() &amp;&amp; op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 602 
 603       do_input(op2-&gt;_opr1);
 604       do_input(op2-&gt;_opr2);
 605       do_temp(op2-&gt;_opr2);
 606       do_output(op2-&gt;_result);
 607 
 608       break;
 609     }
 610 
 611     // vspecial handling for strict operations: register input operands
 612     // as temp to guarantee that they do not overlap with other
 613     // registers
 614     case lir_mul_strictfp:
 615     case lir_div_strictfp:
 616     {
 617       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 618       LIR_Op2* op2 = (LIR_Op2*)op;
 619 
 620       assert(op2-&gt;_info == NULL, &quot;not used&quot;);
 621       assert(op2-&gt;_opr1-&gt;is_valid(), &quot;used&quot;);
 622       assert(op2-&gt;_opr2-&gt;is_valid(), &quot;used&quot;);
 623       assert(op2-&gt;_result-&gt;is_valid(), &quot;used&quot;);
 624       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 625              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 626 
 627       do_input(op2-&gt;_opr1); do_temp(op2-&gt;_opr1);
 628       do_input(op2-&gt;_opr2); do_temp(op2-&gt;_opr2);
 629       if (op2-&gt;_tmp1-&gt;is_valid()) do_temp(op2-&gt;_tmp1);
 630       do_output(op2-&gt;_result);
 631 
 632       break;
 633     }
 634 
 635     case lir_throw: {
 636       assert(op-&gt;as_Op2() != NULL, &quot;must be&quot;);
 637       LIR_Op2* op2 = (LIR_Op2*)op;
 638 
 639       if (op2-&gt;_info)                     do_info(op2-&gt;_info);
 640       if (op2-&gt;_opr1-&gt;is_valid())         do_temp(op2-&gt;_opr1);
 641       if (op2-&gt;_opr2-&gt;is_valid())         do_input(op2-&gt;_opr2); // exception object is input parameter
 642       assert(op2-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 643       assert(op2-&gt;_tmp2-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp3-&gt;is_illegal() &amp;&amp;
 644              op2-&gt;_tmp4-&gt;is_illegal() &amp;&amp; op2-&gt;_tmp5-&gt;is_illegal(), &quot;not used&quot;);
 645 
 646       break;
 647     }
 648 
 649     case lir_unwind: {
 650       assert(op-&gt;as_Op1() != NULL, &quot;must be&quot;);
 651       LIR_Op1* op1 = (LIR_Op1*)op;
 652 
 653       assert(op1-&gt;_info == NULL, &quot;no info&quot;);
 654       assert(op1-&gt;_opr-&gt;is_valid(), &quot;exception oop&quot;);         do_input(op1-&gt;_opr);
 655       assert(op1-&gt;_result-&gt;is_illegal(), &quot;no result&quot;);
 656 
 657       break;
 658     }
 659 
 660 // LIR_Op3
 661     case lir_idiv:
 662     case lir_irem: {
 663       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 664       LIR_Op3* op3= (LIR_Op3*)op;
 665 
 666       if (op3-&gt;_info)                     do_info(op3-&gt;_info);
 667       if (op3-&gt;_opr1-&gt;is_valid())         do_input(op3-&gt;_opr1);
 668 
 669       // second operand is input and temp, so ensure that second operand
 670       // and third operand get not the same register
 671       if (op3-&gt;_opr2-&gt;is_valid())         do_input(op3-&gt;_opr2);
 672       if (op3-&gt;_opr2-&gt;is_valid())         do_temp(op3-&gt;_opr2);
 673       if (op3-&gt;_opr3-&gt;is_valid())         do_temp(op3-&gt;_opr3);
 674 
 675       if (op3-&gt;_result-&gt;is_valid())       do_output(op3-&gt;_result);
 676 
 677       break;
 678     }
 679 
 680     case lir_fmad:
 681     case lir_fmaf: {
 682       assert(op-&gt;as_Op3() != NULL, &quot;must be&quot;);
 683       LIR_Op3* op3= (LIR_Op3*)op;
 684       assert(op3-&gt;_info == NULL, &quot;no info&quot;);
 685       do_input(op3-&gt;_opr1);
 686       do_input(op3-&gt;_opr2);
 687       do_input(op3-&gt;_opr3);
 688       do_output(op3-&gt;_result);
 689       break;
 690     }
 691 
 692 // LIR_OpJavaCall
 693     case lir_static_call:
 694     case lir_optvirtual_call:
 695     case lir_icvirtual_call:
 696     case lir_virtual_call:
 697     case lir_dynamic_call: {
 698       LIR_OpJavaCall* opJavaCall = op-&gt;as_OpJavaCall();
 699       assert(opJavaCall != NULL, &quot;must be&quot;);
 700 
 701       if (opJavaCall-&gt;_receiver-&gt;is_valid())     do_input(opJavaCall-&gt;_receiver);
 702 
 703       // only visit register parameters
 704       int n = opJavaCall-&gt;_arguments-&gt;length();
 705       for (int i = opJavaCall-&gt;_receiver-&gt;is_valid() ? 1 : 0; i &lt; n; i++) {
 706         if (!opJavaCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 707           do_input(*opJavaCall-&gt;_arguments-&gt;adr_at(i));
 708         }
 709       }
 710 
 711       if (opJavaCall-&gt;_info)                     do_info(opJavaCall-&gt;_info);
 712       if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &amp;&amp;
 713           opJavaCall-&gt;is_method_handle_invoke()) {
 714         opJavaCall-&gt;_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();
 715         do_temp(opJavaCall-&gt;_method_handle_invoke_SP_save_opr);
 716       }
 717       do_call();
 718       if (opJavaCall-&gt;_result-&gt;is_valid())       do_output(opJavaCall-&gt;_result);
 719 
 720       break;
 721     }
 722 
 723 
 724 // LIR_OpRTCall
 725     case lir_rtcall: {
 726       assert(op-&gt;as_OpRTCall() != NULL, &quot;must be&quot;);
 727       LIR_OpRTCall* opRTCall = (LIR_OpRTCall*)op;
 728 
 729       // only visit register parameters
 730       int n = opRTCall-&gt;_arguments-&gt;length();
 731       for (int i = 0; i &lt; n; i++) {
 732         if (!opRTCall-&gt;_arguments-&gt;at(i)-&gt;is_pointer()) {
 733           do_input(*opRTCall-&gt;_arguments-&gt;adr_at(i));
 734         }
 735       }
 736       if (opRTCall-&gt;_info)                     do_info(opRTCall-&gt;_info);
 737       if (opRTCall-&gt;_tmp-&gt;is_valid())          do_temp(opRTCall-&gt;_tmp);
 738       do_call();
 739       if (opRTCall-&gt;_result-&gt;is_valid())       do_output(opRTCall-&gt;_result);
 740 
 741       break;
 742     }
 743 
 744 
 745 // LIR_OpArrayCopy
 746     case lir_arraycopy: {
 747       assert(op-&gt;as_OpArrayCopy() != NULL, &quot;must be&quot;);
 748       LIR_OpArrayCopy* opArrayCopy = (LIR_OpArrayCopy*)op;
 749 
 750       assert(opArrayCopy-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 751       assert(opArrayCopy-&gt;_src-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_src);     do_temp(opArrayCopy-&gt;_src);
 752       assert(opArrayCopy-&gt;_src_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_src_pos); do_temp(opArrayCopy-&gt;_src_pos);
 753       assert(opArrayCopy-&gt;_dst-&gt;is_valid(), &quot;used&quot;);          do_input(opArrayCopy-&gt;_dst);     do_temp(opArrayCopy-&gt;_dst);
 754       assert(opArrayCopy-&gt;_dst_pos-&gt;is_valid(), &quot;used&quot;);      do_input(opArrayCopy-&gt;_dst_pos); do_temp(opArrayCopy-&gt;_dst_pos);
 755       assert(opArrayCopy-&gt;_length-&gt;is_valid(), &quot;used&quot;);       do_input(opArrayCopy-&gt;_length);  do_temp(opArrayCopy-&gt;_length);
 756       assert(opArrayCopy-&gt;_tmp-&gt;is_valid(), &quot;used&quot;);          do_temp(opArrayCopy-&gt;_tmp);
 757       if (opArrayCopy-&gt;_info)                     do_info(opArrayCopy-&gt;_info);
 758 
 759       // the implementation of arraycopy always has a call into the runtime
 760       do_call();
 761 
 762       break;
 763     }
 764 
 765 
 766 // LIR_OpUpdateCRC32
 767     case lir_updatecrc32: {
 768       assert(op-&gt;as_OpUpdateCRC32() != NULL, &quot;must be&quot;);
 769       LIR_OpUpdateCRC32* opUp = (LIR_OpUpdateCRC32*)op;
 770 
 771       assert(opUp-&gt;_crc-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_crc);     do_temp(opUp-&gt;_crc);
 772       assert(opUp-&gt;_val-&gt;is_valid(), &quot;used&quot;);          do_input(opUp-&gt;_val);     do_temp(opUp-&gt;_val);
 773       assert(opUp-&gt;_result-&gt;is_valid(), &quot;used&quot;);       do_output(opUp-&gt;_result);
 774       assert(opUp-&gt;_info == NULL, &quot;no info for LIR_OpUpdateCRC32&quot;);
 775 
 776       break;
 777     }
 778 
 779 
 780 // LIR_OpLock
 781     case lir_lock:
 782     case lir_unlock: {
 783       assert(op-&gt;as_OpLock() != NULL, &quot;must be&quot;);
 784       LIR_OpLock* opLock = (LIR_OpLock*)op;
 785 
 786       if (opLock-&gt;_info)                          do_info(opLock-&gt;_info);
 787 
 788       // TODO: check if these operands really have to be temp
 789       // (or if input is sufficient). This may have influence on the oop map!
 790       assert(opLock-&gt;_lock-&gt;is_valid(), &quot;used&quot;);  do_temp(opLock-&gt;_lock);
 791       assert(opLock-&gt;_hdr-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_hdr);
 792       assert(opLock-&gt;_obj-&gt;is_valid(),  &quot;used&quot;);  do_temp(opLock-&gt;_obj);
 793 
 794       if (opLock-&gt;_scratch-&gt;is_valid())           do_temp(opLock-&gt;_scratch);
 795       assert(opLock-&gt;_result-&gt;is_illegal(), &quot;unused&quot;);
 796 
 797       do_stub(opLock-&gt;_stub);
 798 
 799       break;
 800     }
 801 
 802 
 803 // LIR_OpDelay
 804     case lir_delay_slot: {
 805       assert(op-&gt;as_OpDelay() != NULL, &quot;must be&quot;);
 806       LIR_OpDelay* opDelay = (LIR_OpDelay*)op;
 807 
 808       visit(opDelay-&gt;delay_op());
 809       break;
 810     }
 811 
 812 // LIR_OpTypeCheck
 813     case lir_instanceof:
 814     case lir_checkcast:
 815     case lir_store_check: {
 816       assert(op-&gt;as_OpTypeCheck() != NULL, &quot;must be&quot;);
 817       LIR_OpTypeCheck* opTypeCheck = (LIR_OpTypeCheck*)op;
 818 
 819       if (opTypeCheck-&gt;_info_for_exception)       do_info(opTypeCheck-&gt;_info_for_exception);
 820       if (opTypeCheck-&gt;_info_for_patch)           do_info(opTypeCheck-&gt;_info_for_patch);
 821       if (opTypeCheck-&gt;_object-&gt;is_valid())       do_input(opTypeCheck-&gt;_object);
 822       if (op-&gt;code() == lir_store_check &amp;&amp; opTypeCheck-&gt;_object-&gt;is_valid()) {
 823         do_temp(opTypeCheck-&gt;_object);
 824       }
 825       if (opTypeCheck-&gt;_array-&gt;is_valid())        do_input(opTypeCheck-&gt;_array);
 826       if (opTypeCheck-&gt;_tmp1-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp1);
 827       if (opTypeCheck-&gt;_tmp2-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp2);
 828       if (opTypeCheck-&gt;_tmp3-&gt;is_valid())         do_temp(opTypeCheck-&gt;_tmp3);
 829       if (opTypeCheck-&gt;_result-&gt;is_valid())       do_output(opTypeCheck-&gt;_result);
 830                                                   do_stub(opTypeCheck-&gt;_stub);
 831       break;
 832     }
 833 
 834 // LIR_OpCompareAndSwap
 835     case lir_cas_long:
 836     case lir_cas_obj:
 837     case lir_cas_int: {
 838       assert(op-&gt;as_OpCompareAndSwap() != NULL, &quot;must be&quot;);
 839       LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;
 840 
 841       assert(opCompareAndSwap-&gt;_addr-&gt;is_valid(),      &quot;used&quot;);
 842       assert(opCompareAndSwap-&gt;_cmp_value-&gt;is_valid(), &quot;used&quot;);
 843       assert(opCompareAndSwap-&gt;_new_value-&gt;is_valid(), &quot;used&quot;);
 844       if (opCompareAndSwap-&gt;_info)                    do_info(opCompareAndSwap-&gt;_info);
 845                                                       do_input(opCompareAndSwap-&gt;_addr);
 846                                                       do_temp(opCompareAndSwap-&gt;_addr);
 847                                                       do_input(opCompareAndSwap-&gt;_cmp_value);
 848                                                       do_temp(opCompareAndSwap-&gt;_cmp_value);
 849                                                       do_input(opCompareAndSwap-&gt;_new_value);
 850                                                       do_temp(opCompareAndSwap-&gt;_new_value);
 851       if (opCompareAndSwap-&gt;_tmp1-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp1);
 852       if (opCompareAndSwap-&gt;_tmp2-&gt;is_valid())        do_temp(opCompareAndSwap-&gt;_tmp2);
 853       if (opCompareAndSwap-&gt;_result-&gt;is_valid())      do_output(opCompareAndSwap-&gt;_result);
 854 
 855       break;
 856     }
 857 
 858 
 859 // LIR_OpAllocArray;
 860     case lir_alloc_array: {
 861       assert(op-&gt;as_OpAllocArray() != NULL, &quot;must be&quot;);
 862       LIR_OpAllocArray* opAllocArray = (LIR_OpAllocArray*)op;
 863 
 864       if (opAllocArray-&gt;_info)                        do_info(opAllocArray-&gt;_info);
 865       if (opAllocArray-&gt;_klass-&gt;is_valid())           do_input(opAllocArray-&gt;_klass); do_temp(opAllocArray-&gt;_klass);
 866       if (opAllocArray-&gt;_len-&gt;is_valid())             do_input(opAllocArray-&gt;_len);   do_temp(opAllocArray-&gt;_len);
 867       if (opAllocArray-&gt;_tmp1-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp1);
 868       if (opAllocArray-&gt;_tmp2-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp2);
 869       if (opAllocArray-&gt;_tmp3-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp3);
 870       if (opAllocArray-&gt;_tmp4-&gt;is_valid())            do_temp(opAllocArray-&gt;_tmp4);
 871       if (opAllocArray-&gt;_result-&gt;is_valid())          do_output(opAllocArray-&gt;_result);
 872                                                       do_stub(opAllocArray-&gt;_stub);
 873       break;
 874     }
 875 
 876 // LIR_OpProfileCall:
 877     case lir_profile_call: {
 878       assert(op-&gt;as_OpProfileCall() != NULL, &quot;must be&quot;);
 879       LIR_OpProfileCall* opProfileCall = (LIR_OpProfileCall*)op;
 880 
 881       if (opProfileCall-&gt;_recv-&gt;is_valid())              do_temp(opProfileCall-&gt;_recv);
 882       assert(opProfileCall-&gt;_mdo-&gt;is_valid(), &quot;used&quot;);   do_temp(opProfileCall-&gt;_mdo);
 883       assert(opProfileCall-&gt;_tmp1-&gt;is_valid(), &quot;used&quot;);  do_temp(opProfileCall-&gt;_tmp1);
 884       break;
 885     }
 886 
 887 // LIR_OpProfileType:
 888     case lir_profile_type: {
 889       assert(op-&gt;as_OpProfileType() != NULL, &quot;must be&quot;);
 890       LIR_OpProfileType* opProfileType = (LIR_OpProfileType*)op;
 891 
 892       do_input(opProfileType-&gt;_mdp); do_temp(opProfileType-&gt;_mdp);
 893       do_input(opProfileType-&gt;_obj);
 894       do_temp(opProfileType-&gt;_tmp);
 895       break;
 896     }
 897   default:
 898     op-&gt;visit(this);
 899   }
 900 }
 901 
 902 void LIR_Op::visit(LIR_OpVisitState* state) {
 903   ShouldNotReachHere();
 904 }
 905 
 906 void LIR_OpVisitState::do_stub(CodeStub* stub) {
 907   if (stub != NULL) {
 908     stub-&gt;visit(this);
 909   }
 910 }
 911 
 912 XHandlers* LIR_OpVisitState::all_xhandler() {
 913   XHandlers* result = NULL;
 914 
 915   int i;
 916   for (i = 0; i &lt; info_count(); i++) {
 917     if (info_at(i)-&gt;exception_handlers() != NULL) {
 918       result = info_at(i)-&gt;exception_handlers();
 919       break;
 920     }
 921   }
 922 
 923 #ifdef ASSERT
 924   for (i = 0; i &lt; info_count(); i++) {
 925     assert(info_at(i)-&gt;exception_handlers() == NULL ||
 926            info_at(i)-&gt;exception_handlers() == result,
 927            &quot;only one xhandler list allowed per LIR-operation&quot;);
 928   }
 929 #endif
 930 
 931   if (result != NULL) {
 932     return result;
 933   } else {
 934     return new XHandlers();
 935   }
 936 
 937   return result;
 938 }
 939 
 940 
 941 #ifdef ASSERT
 942 bool LIR_OpVisitState::no_operands(LIR_Op* op) {
 943   visit(op);
 944 
 945   return opr_count(inputMode) == 0 &amp;&amp;
 946          opr_count(outputMode) == 0 &amp;&amp;
 947          opr_count(tempMode) == 0 &amp;&amp;
 948          info_count() == 0 &amp;&amp;
 949          !has_call() &amp;&amp;
 950          !has_slow_case();
 951 }
 952 #endif
 953 
 954 //---------------------------------------------------
 955 
 956 
 957 void LIR_OpJavaCall::emit_code(LIR_Assembler* masm) {
 958   masm-&gt;emit_call(this);
 959 }
 960 
 961 void LIR_OpRTCall::emit_code(LIR_Assembler* masm) {
 962   masm-&gt;emit_rtcall(this);
 963 }
 964 
 965 void LIR_OpLabel::emit_code(LIR_Assembler* masm) {
 966   masm-&gt;emit_opLabel(this);
 967 }
 968 
 969 void LIR_OpArrayCopy::emit_code(LIR_Assembler* masm) {
 970   masm-&gt;emit_arraycopy(this);
 971   masm-&gt;append_code_stub(stub());
 972 }
 973 
 974 void LIR_OpUpdateCRC32::emit_code(LIR_Assembler* masm) {
 975   masm-&gt;emit_updatecrc32(this);
 976 }
 977 
 978 void LIR_Op0::emit_code(LIR_Assembler* masm) {
 979   masm-&gt;emit_op0(this);
 980 }
 981 
 982 void LIR_Op1::emit_code(LIR_Assembler* masm) {
 983   masm-&gt;emit_op1(this);
 984 }
 985 
 986 void LIR_OpAllocObj::emit_code(LIR_Assembler* masm) {
 987   masm-&gt;emit_alloc_obj(this);
 988   masm-&gt;append_code_stub(stub());
 989 }
 990 
 991 void LIR_OpBranch::emit_code(LIR_Assembler* masm) {
 992   masm-&gt;emit_opBranch(this);
 993   if (stub()) {
 994     masm-&gt;append_code_stub(stub());
 995   }
 996 }
 997 
 998 void LIR_OpConvert::emit_code(LIR_Assembler* masm) {
 999   masm-&gt;emit_opConvert(this);
1000   if (stub() != NULL) {
1001     masm-&gt;append_code_stub(stub());
1002   }
1003 }
1004 
1005 void LIR_Op2::emit_code(LIR_Assembler* masm) {
1006   masm-&gt;emit_op2(this);
1007 }
1008 
1009 void LIR_OpAllocArray::emit_code(LIR_Assembler* masm) {
1010   masm-&gt;emit_alloc_array(this);
1011   masm-&gt;append_code_stub(stub());
1012 }
1013 
1014 void LIR_OpTypeCheck::emit_code(LIR_Assembler* masm) {
1015   masm-&gt;emit_opTypeCheck(this);
1016   if (stub()) {
1017     masm-&gt;append_code_stub(stub());
1018   }
1019 }
1020 
1021 void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
1022   masm-&gt;emit_compare_and_swap(this);
1023 }
1024 
1025 void LIR_Op3::emit_code(LIR_Assembler* masm) {
1026   masm-&gt;emit_op3(this);
1027 }
1028 
1029 void LIR_OpLock::emit_code(LIR_Assembler* masm) {
1030   masm-&gt;emit_lock(this);
1031   if (stub()) {
1032     masm-&gt;append_code_stub(stub());
1033   }
1034 }
1035 
1036 #ifdef ASSERT
1037 void LIR_OpAssert::emit_code(LIR_Assembler* masm) {
1038   masm-&gt;emit_assert(this);
1039 }
1040 #endif
1041 
1042 void LIR_OpDelay::emit_code(LIR_Assembler* masm) {
1043   masm-&gt;emit_delay(this);
1044 }
1045 
1046 void LIR_OpProfileCall::emit_code(LIR_Assembler* masm) {
1047   masm-&gt;emit_profile_call(this);
1048 }
1049 
1050 void LIR_OpProfileType::emit_code(LIR_Assembler* masm) {
1051   masm-&gt;emit_profile_type(this);
1052 }
1053 
1054 // LIR_List
1055 LIR_List::LIR_List(Compilation* compilation, BlockBegin* block)
1056   : _operations(8)
1057   , _compilation(compilation)
1058 #ifndef PRODUCT
1059   , _block(block)
1060 #endif
1061 #ifdef ASSERT
1062   , _file(NULL)
1063   , _line(0)
1064 #endif
1065 { }
1066 
1067 
1068 #ifdef ASSERT
1069 void LIR_List::set_file_and_line(const char * file, int line) {
1070   const char * f = strrchr(file, &#39;/&#39;);
1071   if (f == NULL) f = strrchr(file, &#39;\\&#39;);
1072   if (f == NULL) {
1073     f = file;
1074   } else {
1075     f++;
1076   }
1077   _file = f;
1078   _line = line;
1079 }
1080 #endif
1081 
1082 
1083 void LIR_List::append(LIR_InsertionBuffer* buffer) {
1084   assert(this == buffer-&gt;lir_list(), &quot;wrong lir list&quot;);
1085   const int n = _operations.length();
1086 
1087   if (buffer-&gt;number_of_ops() &gt; 0) {
1088     // increase size of instructions list
1089     _operations.at_grow(n + buffer-&gt;number_of_ops() - 1, NULL);
1090     // insert ops from buffer into instructions list
1091     int op_index = buffer-&gt;number_of_ops() - 1;
1092     int ip_index = buffer-&gt;number_of_insertion_points() - 1;
1093     int from_index = n - 1;
1094     int to_index = _operations.length() - 1;
1095     for (; ip_index &gt;= 0; ip_index --) {
1096       int index = buffer-&gt;index_at(ip_index);
1097       // make room after insertion point
1098       while (index &lt; from_index) {
1099         _operations.at_put(to_index --, _operations.at(from_index --));
1100       }
1101       // insert ops from buffer
1102       for (int i = buffer-&gt;count_at(ip_index); i &gt; 0; i --) {
1103         _operations.at_put(to_index --, buffer-&gt;op_at(op_index --));
1104       }
1105     }
1106   }
1107 
1108   buffer-&gt;finish();
1109 }
1110 
1111 
1112 void LIR_List::oop2reg_patch(jobject o, LIR_Opr reg, CodeEmitInfo* info) {
1113   assert(reg-&gt;type() == T_OBJECT, &quot;bad reg&quot;);
1114   append(new LIR_Op1(lir_move, LIR_OprFact::oopConst(o),  reg, T_OBJECT, lir_patch_normal, info));
1115 }
1116 
1117 void LIR_List::klass2reg_patch(Metadata* o, LIR_Opr reg, CodeEmitInfo* info) {
1118   assert(reg-&gt;type() == T_METADATA, &quot;bad reg&quot;);
1119   append(new LIR_Op1(lir_move, LIR_OprFact::metadataConst(o), reg, T_METADATA, lir_patch_normal, info));
1120 }
1121 
1122 void LIR_List::load(LIR_Address* addr, LIR_Opr src, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1123   append(new LIR_Op1(
1124             lir_move,
1125             LIR_OprFact::address(addr),
1126             src,
1127             addr-&gt;type(),
1128             patch_code,
1129             info));
1130 }
1131 
1132 
1133 void LIR_List::volatile_load_mem_reg(LIR_Address* address, LIR_Opr dst, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1134   append(new LIR_Op1(
1135             lir_move,
1136             LIR_OprFact::address(address),
1137             dst,
1138             address-&gt;type(),
1139             patch_code,
1140             info, lir_move_volatile));
1141 }
1142 
1143 void LIR_List::volatile_load_unsafe_reg(LIR_Opr base, LIR_Opr offset, LIR_Opr dst, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1144   append(new LIR_Op1(
1145             lir_move,
1146             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1147             dst,
1148             type,
1149             patch_code,
1150             info, lir_move_volatile));
1151 }
1152 
1153 
1154 void LIR_List::store_mem_int(jint v, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1155   append(new LIR_Op1(
1156             lir_move,
1157             LIR_OprFact::intConst(v),
1158             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1159             type,
1160             patch_code,
1161             info));
1162 }
1163 
1164 
1165 void LIR_List::store_mem_oop(jobject o, LIR_Opr base, int offset_in_bytes, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1166   append(new LIR_Op1(
1167             lir_move,
1168             LIR_OprFact::oopConst(o),
1169             LIR_OprFact::address(new LIR_Address(base, offset_in_bytes, type)),
1170             type,
1171             patch_code,
1172             info));
1173 }
1174 
1175 
1176 void LIR_List::store(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1177   append(new LIR_Op1(
1178             lir_move,
1179             src,
1180             LIR_OprFact::address(addr),
1181             addr-&gt;type(),
1182             patch_code,
1183             info));
1184 }
1185 
1186 
1187 void LIR_List::volatile_store_mem_reg(LIR_Opr src, LIR_Address* addr, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1188   append(new LIR_Op1(
1189             lir_move,
1190             src,
1191             LIR_OprFact::address(addr),
1192             addr-&gt;type(),
1193             patch_code,
1194             info,
1195             lir_move_volatile));
1196 }
1197 
1198 void LIR_List::volatile_store_unsafe_reg(LIR_Opr src, LIR_Opr base, LIR_Opr offset, BasicType type, CodeEmitInfo* info, LIR_PatchCode patch_code) {
1199   append(new LIR_Op1(
1200             lir_move,
1201             src,
1202             LIR_OprFact::address(new LIR_Address(base, offset, type)),
1203             type,
1204             patch_code,
1205             info, lir_move_volatile));
1206 }
1207 
1208 
1209 void LIR_List::idiv(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1210   append(new LIR_Op3(
1211                     lir_idiv,
1212                     left,
1213                     right,
1214                     tmp,
1215                     res,
1216                     info));
1217 }
1218 
1219 
1220 void LIR_List::idiv(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1221   append(new LIR_Op3(
1222                     lir_idiv,
1223                     left,
1224                     LIR_OprFact::intConst(right),
1225                     tmp,
1226                     res,
1227                     info));
1228 }
1229 
1230 
1231 void LIR_List::irem(LIR_Opr left, LIR_Opr right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1232   append(new LIR_Op3(
1233                     lir_irem,
1234                     left,
1235                     right,
1236                     tmp,
1237                     res,
1238                     info));
1239 }
1240 
1241 
1242 void LIR_List::irem(LIR_Opr left, int right, LIR_Opr res, LIR_Opr tmp, CodeEmitInfo* info) {
1243   append(new LIR_Op3(
1244                     lir_irem,
1245                     left,
1246                     LIR_OprFact::intConst(right),
1247                     tmp,
1248                     res,
1249                     info));
1250 }
1251 
1252 
1253 void LIR_List::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
1254   append(new LIR_Op2(
1255                     lir_cmp,
1256                     condition,
1257                     LIR_OprFact::address(new LIR_Address(base, disp, T_INT)),
1258                     LIR_OprFact::intConst(c),
1259                     info));
1260 }
1261 
1262 
1263 void LIR_List::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Address* addr, CodeEmitInfo* info) {
1264   append(new LIR_Op2(
1265                     lir_cmp,
1266                     condition,
1267                     reg,
1268                     LIR_OprFact::address(addr),
1269                     info));
1270 }
1271 
1272 void LIR_List::allocate_object(LIR_Opr dst, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4,
1273                                int header_size, int object_size, LIR_Opr klass, bool init_check, CodeStub* stub) {
1274   append(new LIR_OpAllocObj(
1275                            klass,
1276                            dst,
1277                            t1,
1278                            t2,
1279                            t3,
1280                            t4,
1281                            header_size,
1282                            object_size,
1283                            init_check,
1284                            stub));
1285 }
1286 
1287 void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {
1288   append(new LIR_OpAllocArray(
1289                            klass,
1290                            len,
1291                            dst,
1292                            t1,
1293                            t2,
1294                            t3,
1295                            t4,
1296                            type,
1297                            stub));
1298 }
1299 
1300 void LIR_List::shift_left(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1301  append(new LIR_Op2(
1302                     lir_shl,
1303                     value,
1304                     count,
1305                     dst,
1306                     tmp));
1307 }
1308 
1309 void LIR_List::shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1310  append(new LIR_Op2(
1311                     lir_shr,
1312                     value,
1313                     count,
1314                     dst,
1315                     tmp));
1316 }
1317 
1318 
1319 void LIR_List::unsigned_shift_right(LIR_Opr value, LIR_Opr count, LIR_Opr dst, LIR_Opr tmp) {
1320  append(new LIR_Op2(
1321                     lir_ushr,
1322                     value,
1323                     count,
1324                     dst,
1325                     tmp));
1326 }
1327 
1328 void LIR_List::fcmp2int(LIR_Opr left, LIR_Opr right, LIR_Opr dst, bool is_unordered_less) {
1329   append(new LIR_Op2(is_unordered_less ? lir_ucmp_fd2i : lir_cmp_fd2i,
1330                      left,
1331                      right,
1332                      dst));
1333 }
1334 
1335 void LIR_List::lock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub, CodeEmitInfo* info) {
1336   append(new LIR_OpLock(
1337                     lir_lock,
1338                     hdr,
1339                     obj,
1340                     lock,
1341                     scratch,
1342                     stub,
1343                     info));
1344 }
1345 
1346 void LIR_List::unlock_object(LIR_Opr hdr, LIR_Opr obj, LIR_Opr lock, LIR_Opr scratch, CodeStub* stub) {
1347   append(new LIR_OpLock(
1348                     lir_unlock,
1349                     hdr,
1350                     obj,
1351                     lock,
1352                     scratch,
1353                     stub,
1354                     NULL));
1355 }
1356 
1357 
1358 void check_LIR() {
1359   // cannot do the proper checking as PRODUCT and other modes return different results
1360   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1361 }
1362 
1363 
1364 
1365 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1366                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1367                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
1368                           ciMethod* profiled_method, int profiled_bci) {
1369   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1370                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub);
1371   if (profiled_method != NULL) {
1372     c-&gt;set_profiled_method(profiled_method);
1373     c-&gt;set_profiled_bci(profiled_bci);
1374     c-&gt;set_should_profile(true);
1375   }
1376   append(c);
1377 }
1378 
1379 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1380   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1381   if (profiled_method != NULL) {
1382     c-&gt;set_profiled_method(profiled_method);
1383     c-&gt;set_profiled_bci(profiled_bci);
1384     c-&gt;set_should_profile(true);
1385   }
1386   append(c);
1387 }
1388 
1389 
1390 void LIR_List::store_check(LIR_Opr object, LIR_Opr array, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3,
1391                            CodeEmitInfo* info_for_exception, ciMethod* profiled_method, int profiled_bci) {
1392   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_store_check, object, array, tmp1, tmp2, tmp3, info_for_exception);
1393   if (profiled_method != NULL) {
1394     c-&gt;set_profiled_method(profiled_method);
1395     c-&gt;set_profiled_bci(profiled_bci);
1396     c-&gt;set_should_profile(true);
1397   }
1398   append(c);
1399 }
1400 
1401 void LIR_List::null_check(LIR_Opr opr, CodeEmitInfo* info, bool deoptimize_on_null) {
1402   if (deoptimize_on_null) {
1403     // Emit an explicit null check and deoptimize if opr is null
1404     CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_null_check, Deoptimization::Action_none);
1405     cmp(lir_cond_equal, opr, LIR_OprFact::oopConst(NULL));
1406     branch(lir_cond_equal, T_OBJECT, deopt);
1407   } else {
1408     // Emit an implicit null check
1409     append(new LIR_Op1(lir_null_check, opr, info));
1410   }
1411 }
1412 
1413 void LIR_List::cas_long(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1414                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1415   append(new LIR_OpCompareAndSwap(lir_cas_long, addr, cmp_value, new_value, t1, t2, result));
1416 }
1417 
1418 void LIR_List::cas_obj(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1419                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1420   append(new LIR_OpCompareAndSwap(lir_cas_obj, addr, cmp_value, new_value, t1, t2, result));
1421 }
1422 
1423 void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
1424                        LIR_Opr t1, LIR_Opr t2, LIR_Opr result) {
1425   append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
1426 }
1427 
1428 
1429 #ifdef PRODUCT
1430 
1431 void print_LIR(BlockList* blocks) {
1432 }
1433 
1434 #else
1435 // LIR_OprDesc
1436 void LIR_OprDesc::print() const {
1437   print(tty);
1438 }
1439 
1440 void LIR_OprDesc::print(outputStream* out) const {
1441   if (is_illegal()) {
1442     return;
1443   }
1444 
1445   out-&gt;print(&quot;[&quot;);
1446   if (is_pointer()) {
1447     pointer()-&gt;print_value_on(out);
1448   } else if (is_single_stack()) {
1449     out-&gt;print(&quot;stack:%d&quot;, single_stack_ix());
1450   } else if (is_double_stack()) {
1451     out-&gt;print(&quot;dbl_stack:%d&quot;,double_stack_ix());
1452   } else if (is_virtual()) {
1453     out-&gt;print(&quot;R%d&quot;, vreg_number());
1454   } else if (is_single_cpu()) {
1455     out-&gt;print(&quot;%s&quot;, as_register()-&gt;name());
1456   } else if (is_double_cpu()) {
1457     out-&gt;print(&quot;%s&quot;, as_register_hi()-&gt;name());
1458     out-&gt;print(&quot;%s&quot;, as_register_lo()-&gt;name());
1459 #if defined(X86)
1460   } else if (is_single_xmm()) {
1461     out-&gt;print(&quot;%s&quot;, as_xmm_float_reg()-&gt;name());
1462   } else if (is_double_xmm()) {
1463     out-&gt;print(&quot;%s&quot;, as_xmm_double_reg()-&gt;name());
1464   } else if (is_single_fpu()) {
1465     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1466   } else if (is_double_fpu()) {
1467     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1468 #elif defined(AARCH64)
1469   } else if (is_single_fpu()) {
1470     out-&gt;print(&quot;fpu%d&quot;, fpu_regnr());
1471   } else if (is_double_fpu()) {
1472     out-&gt;print(&quot;fpu%d&quot;, fpu_regnrLo());
1473 #elif defined(ARM)
1474   } else if (is_single_fpu()) {
1475     out-&gt;print(&quot;s%d&quot;, fpu_regnr());
1476   } else if (is_double_fpu()) {
1477     out-&gt;print(&quot;d%d&quot;, fpu_regnrLo() &gt;&gt; 1);
1478 #else
1479   } else if (is_single_fpu()) {
1480     out-&gt;print(&quot;%s&quot;, as_float_reg()-&gt;name());
1481   } else if (is_double_fpu()) {
1482     out-&gt;print(&quot;%s&quot;, as_double_reg()-&gt;name());
1483 #endif
1484 
1485   } else if (is_illegal()) {
1486     out-&gt;print(&quot;-&quot;);
1487   } else {
1488     out-&gt;print(&quot;Unknown Operand&quot;);
1489   }
1490   if (!is_illegal()) {
1491     out-&gt;print(&quot;|%c&quot;, type_char());
1492   }
1493   if (is_register() &amp;&amp; is_last_use()) {
1494     out-&gt;print(&quot;(last_use)&quot;);
1495   }
1496   out-&gt;print(&quot;]&quot;);
1497 }
1498 
1499 
1500 // LIR_Address
1501 void LIR_Const::print_value_on(outputStream* out) const {
1502   switch (type()) {
1503     case T_ADDRESS:out-&gt;print(&quot;address:%d&quot;,as_jint());          break;
1504     case T_INT:    out-&gt;print(&quot;int:%d&quot;,   as_jint());           break;
1505     case T_LONG:   out-&gt;print(&quot;lng:&quot; JLONG_FORMAT, as_jlong()); break;
1506     case T_FLOAT:  out-&gt;print(&quot;flt:%f&quot;,   as_jfloat());         break;
1507     case T_DOUBLE: out-&gt;print(&quot;dbl:%f&quot;,   as_jdouble());        break;
1508     case T_OBJECT: out-&gt;print(&quot;obj:&quot; INTPTR_FORMAT, p2i(as_jobject()));        break;
1509     case T_METADATA: out-&gt;print(&quot;metadata:&quot; INTPTR_FORMAT, p2i(as_metadata()));break;
1510     default:       out-&gt;print(&quot;%3d:0x&quot; UINT64_FORMAT_X, type(), (uint64_t)as_jlong()); break;
1511   }
1512 }
1513 
1514 // LIR_Address
1515 void LIR_Address::print_value_on(outputStream* out) const {
1516   out-&gt;print(&quot;Base:&quot;); _base-&gt;print(out);
1517   if (!_index-&gt;is_illegal()) {
1518     out-&gt;print(&quot; Index:&quot;); _index-&gt;print(out);
1519     switch (scale()) {
1520     case times_1: break;
1521     case times_2: out-&gt;print(&quot; * 2&quot;); break;
1522     case times_4: out-&gt;print(&quot; * 4&quot;); break;
1523     case times_8: out-&gt;print(&quot; * 8&quot;); break;
1524     }
1525   }
1526   out-&gt;print(&quot; Disp: &quot; INTX_FORMAT, _disp);
1527 }
1528 
1529 // debug output of block header without InstructionPrinter
1530 //       (because phi functions are not necessary for LIR)
1531 static void print_block(BlockBegin* x) {
1532   // print block id
1533   BlockEnd* end = x-&gt;end();
1534   tty-&gt;print(&quot;B%d &quot;, x-&gt;block_id());
1535 
1536   // print flags
1537   if (x-&gt;is_set(BlockBegin::std_entry_flag))               tty-&gt;print(&quot;std &quot;);
1538   if (x-&gt;is_set(BlockBegin::osr_entry_flag))               tty-&gt;print(&quot;osr &quot;);
1539   if (x-&gt;is_set(BlockBegin::exception_entry_flag))         tty-&gt;print(&quot;ex &quot;);
1540   if (x-&gt;is_set(BlockBegin::subroutine_entry_flag))        tty-&gt;print(&quot;jsr &quot;);
1541   if (x-&gt;is_set(BlockBegin::backward_branch_target_flag))  tty-&gt;print(&quot;bb &quot;);
1542   if (x-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) tty-&gt;print(&quot;lh &quot;);
1543   if (x-&gt;is_set(BlockBegin::linear_scan_loop_end_flag))    tty-&gt;print(&quot;le &quot;);
1544 
1545   // print block bci range
1546   tty-&gt;print(&quot;[%d, %d] &quot;, x-&gt;bci(), (end == NULL ? -1 : end-&gt;printable_bci()));
1547 
1548   // print predecessors and successors
1549   if (x-&gt;number_of_preds() &gt; 0) {
1550     tty-&gt;print(&quot;preds: &quot;);
1551     for (int i = 0; i &lt; x-&gt;number_of_preds(); i ++) {
1552       tty-&gt;print(&quot;B%d &quot;, x-&gt;pred_at(i)-&gt;block_id());
1553     }
1554   }
1555 
1556   if (x-&gt;number_of_sux() &gt; 0) {
1557     tty-&gt;print(&quot;sux: &quot;);
1558     for (int i = 0; i &lt; x-&gt;number_of_sux(); i ++) {
1559       tty-&gt;print(&quot;B%d &quot;, x-&gt;sux_at(i)-&gt;block_id());
1560     }
1561   }
1562 
1563   // print exception handlers
1564   if (x-&gt;number_of_exception_handlers() &gt; 0) {
1565     tty-&gt;print(&quot;xhandler: &quot;);
1566     for (int i = 0; i &lt; x-&gt;number_of_exception_handlers();  i++) {
1567       tty-&gt;print(&quot;B%d &quot;, x-&gt;exception_handler_at(i)-&gt;block_id());
1568     }
1569   }
1570 
1571   tty-&gt;cr();
1572 }
1573 
1574 void print_LIR(BlockList* blocks) {
1575   tty-&gt;print_cr(&quot;LIR:&quot;);
1576   int i;
1577   for (i = 0; i &lt; blocks-&gt;length(); i++) {
1578     BlockBegin* bb = blocks-&gt;at(i);
1579     print_block(bb);
1580     tty-&gt;print(&quot;__id_Instruction___________________________________________&quot;); tty-&gt;cr();
1581     bb-&gt;lir()-&gt;print_instructions();
1582   }
1583 }
1584 
1585 void LIR_List::print_instructions() {
1586   for (int i = 0; i &lt; _operations.length(); i++) {
1587     _operations.at(i)-&gt;print(); tty-&gt;cr();
1588   }
1589   tty-&gt;cr();
1590 }
1591 
1592 // LIR_Ops printing routines
1593 // LIR_Op
1594 void LIR_Op::print_on(outputStream* out) const {
1595   if (id() != -1 || PrintCFGToFile) {
1596     out-&gt;print(&quot;%4d &quot;, id());
1597   } else {
1598     out-&gt;print(&quot;     &quot;);
1599   }
1600   out-&gt;print(&quot;%s &quot;, name());
1601   print_instr(out);
1602   if (info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info()-&gt;stack()-&gt;bci());
1603 #ifdef ASSERT
1604   if (Verbose &amp;&amp; _file != NULL) {
1605     out-&gt;print(&quot; (%s:%d)&quot;, _file, _line);
1606   }
1607 #endif
1608 }
1609 
1610 const char * LIR_Op::name() const {
1611   const char* s = NULL;
1612   switch(code()) {
1613      // LIR_Op0
1614      case lir_membar:                s = &quot;membar&quot;;        break;
1615      case lir_membar_acquire:        s = &quot;membar_acquire&quot;; break;
1616      case lir_membar_release:        s = &quot;membar_release&quot;; break;
1617      case lir_membar_loadload:       s = &quot;membar_loadload&quot;;   break;
1618      case lir_membar_storestore:     s = &quot;membar_storestore&quot;; break;
1619      case lir_membar_loadstore:      s = &quot;membar_loadstore&quot;;  break;
1620      case lir_membar_storeload:      s = &quot;membar_storeload&quot;;  break;
1621      case lir_label:                 s = &quot;label&quot;;         break;
1622      case lir_nop:                   s = &quot;nop&quot;;           break;
1623      case lir_on_spin_wait:          s = &quot;on_spin_wait&quot;;  break;
1624      case lir_backwardbranch_target: s = &quot;backbranch&quot;;    break;
1625      case lir_std_entry:             s = &quot;std_entry&quot;;     break;
1626      case lir_osr_entry:             s = &quot;osr_entry&quot;;     break;
1627      case lir_fpop_raw:              s = &quot;fpop_raw&quot;;      break;
1628      case lir_breakpoint:            s = &quot;breakpoint&quot;;    break;
1629      case lir_get_thread:            s = &quot;get_thread&quot;;    break;
1630      // LIR_Op1
1631      case lir_fxch:                  s = &quot;fxch&quot;;          break;
1632      case lir_fld:                   s = &quot;fld&quot;;           break;
1633      case lir_push:                  s = &quot;push&quot;;          break;
1634      case lir_pop:                   s = &quot;pop&quot;;           break;
1635      case lir_null_check:            s = &quot;null_check&quot;;    break;
1636      case lir_return:                s = &quot;return&quot;;        break;
1637      case lir_safepoint:             s = &quot;safepoint&quot;;     break;
1638      case lir_leal:                  s = &quot;leal&quot;;          break;
1639      case lir_branch:                s = &quot;branch&quot;;        break;
1640      case lir_cond_float_branch:     s = &quot;flt_cond_br&quot;;   break;
1641      case lir_move:                  s = &quot;move&quot;;          break;
1642      case lir_roundfp:               s = &quot;roundfp&quot;;       break;
1643      case lir_rtcall:                s = &quot;rtcall&quot;;        break;
1644      case lir_throw:                 s = &quot;throw&quot;;         break;
1645      case lir_unwind:                s = &quot;unwind&quot;;        break;
1646      case lir_convert:               s = &quot;convert&quot;;       break;
1647      case lir_alloc_object:          s = &quot;alloc_obj&quot;;     break;
1648      case lir_monaddr:               s = &quot;mon_addr&quot;;      break;
<a name="3" id="anc3"></a>

1649      // LIR_Op2
1650      case lir_cmp:                   s = &quot;cmp&quot;;           break;
1651      case lir_cmp_l2i:               s = &quot;cmp_l2i&quot;;       break;
1652      case lir_ucmp_fd2i:             s = &quot;ucomp_fd2i&quot;;    break;
1653      case lir_cmp_fd2i:              s = &quot;comp_fd2i&quot;;     break;
1654      case lir_cmove:                 s = &quot;cmove&quot;;         break;
1655      case lir_add:                   s = &quot;add&quot;;           break;
1656      case lir_sub:                   s = &quot;sub&quot;;           break;
1657      case lir_mul:                   s = &quot;mul&quot;;           break;
1658      case lir_mul_strictfp:          s = &quot;mul_strictfp&quot;;  break;
1659      case lir_div:                   s = &quot;div&quot;;           break;
1660      case lir_div_strictfp:          s = &quot;div_strictfp&quot;;  break;
1661      case lir_rem:                   s = &quot;rem&quot;;           break;
1662      case lir_abs:                   s = &quot;abs&quot;;           break;
1663      case lir_neg:                   s = &quot;neg&quot;;           break;
1664      case lir_sqrt:                  s = &quot;sqrt&quot;;          break;
1665      case lir_logic_and:             s = &quot;logic_and&quot;;     break;
1666      case lir_logic_or:              s = &quot;logic_or&quot;;      break;
1667      case lir_logic_xor:             s = &quot;logic_xor&quot;;     break;
1668      case lir_shl:                   s = &quot;shift_left&quot;;    break;
1669      case lir_shr:                   s = &quot;shift_right&quot;;   break;
1670      case lir_ushr:                  s = &quot;ushift_right&quot;;  break;
1671      case lir_alloc_array:           s = &quot;alloc_array&quot;;   break;
1672      case lir_xadd:                  s = &quot;xadd&quot;;          break;
1673      case lir_xchg:                  s = &quot;xchg&quot;;          break;
1674      // LIR_Op3
1675      case lir_idiv:                  s = &quot;idiv&quot;;          break;
1676      case lir_irem:                  s = &quot;irem&quot;;          break;
1677      case lir_fmad:                  s = &quot;fmad&quot;;          break;
1678      case lir_fmaf:                  s = &quot;fmaf&quot;;          break;
1679      // LIR_OpJavaCall
1680      case lir_static_call:           s = &quot;static&quot;;        break;
1681      case lir_optvirtual_call:       s = &quot;optvirtual&quot;;    break;
1682      case lir_icvirtual_call:        s = &quot;icvirtual&quot;;     break;
1683      case lir_virtual_call:          s = &quot;virtual&quot;;       break;
1684      case lir_dynamic_call:          s = &quot;dynamic&quot;;       break;
1685      // LIR_OpArrayCopy
1686      case lir_arraycopy:             s = &quot;arraycopy&quot;;     break;
1687      // LIR_OpUpdateCRC32
1688      case lir_updatecrc32:           s = &quot;updatecrc32&quot;;   break;
1689      // LIR_OpLock
1690      case lir_lock:                  s = &quot;lock&quot;;          break;
1691      case lir_unlock:                s = &quot;unlock&quot;;        break;
1692      // LIR_OpDelay
1693      case lir_delay_slot:            s = &quot;delay&quot;;         break;
1694      // LIR_OpTypeCheck
1695      case lir_instanceof:            s = &quot;instanceof&quot;;    break;
1696      case lir_checkcast:             s = &quot;checkcast&quot;;     break;
1697      case lir_store_check:           s = &quot;store_check&quot;;   break;
1698      // LIR_OpCompareAndSwap
1699      case lir_cas_long:              s = &quot;cas_long&quot;;      break;
1700      case lir_cas_obj:               s = &quot;cas_obj&quot;;      break;
1701      case lir_cas_int:               s = &quot;cas_int&quot;;      break;
1702      // LIR_OpProfileCall
1703      case lir_profile_call:          s = &quot;profile_call&quot;;  break;
1704      // LIR_OpProfileType
1705      case lir_profile_type:          s = &quot;profile_type&quot;;  break;
1706      // LIR_OpAssert
1707 #ifdef ASSERT
1708      case lir_assert:                s = &quot;assert&quot;;        break;
1709 #endif
1710      case lir_none:                  ShouldNotReachHere();break;
1711     default:                         s = &quot;illegal_op&quot;;    break;
1712   }
1713   return s;
1714 }
1715 
1716 // LIR_OpJavaCall
1717 void LIR_OpJavaCall::print_instr(outputStream* out) const {
1718   out-&gt;print(&quot;call: &quot;);
1719   out-&gt;print(&quot;[addr: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(address()));
1720   if (receiver()-&gt;is_valid()) {
1721     out-&gt;print(&quot; [recv: &quot;);   receiver()-&gt;print(out);   out-&gt;print(&quot;]&quot;);
1722   }
1723   if (result_opr()-&gt;is_valid()) {
1724     out-&gt;print(&quot; [result: &quot;); result_opr()-&gt;print(out); out-&gt;print(&quot;]&quot;);
1725   }
1726 }
1727 
1728 // LIR_OpLabel
1729 void LIR_OpLabel::print_instr(outputStream* out) const {
1730   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(_label));
1731 }
1732 
1733 // LIR_OpArrayCopy
1734 void LIR_OpArrayCopy::print_instr(outputStream* out) const {
1735   src()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1736   src_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1737   dst()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1738   dst_pos()-&gt;print(out); out-&gt;print(&quot; &quot;);
1739   length()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1740   tmp()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1741 }
1742 
1743 // LIR_OpUpdateCRC32
1744 void LIR_OpUpdateCRC32::print_instr(outputStream* out) const {
1745   crc()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1746   val()-&gt;print(out);     out-&gt;print(&quot; &quot;);
1747   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1748 }
1749 
1750 // LIR_OpCompareAndSwap
1751 void LIR_OpCompareAndSwap::print_instr(outputStream* out) const {
1752   addr()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1753   cmp_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1754   new_value()-&gt;print(out); out-&gt;print(&quot; &quot;);
1755   tmp1()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1756   tmp2()-&gt;print(out);      out-&gt;print(&quot; &quot;);
1757 
1758 }
1759 
1760 // LIR_Op0
1761 void LIR_Op0::print_instr(outputStream* out) const {
1762   result_opr()-&gt;print(out);
1763 }
1764 
1765 // LIR_Op1
1766 const char * LIR_Op1::name() const {
1767   if (code() == lir_move) {
1768     switch (move_kind()) {
1769     case lir_move_normal:
1770       return &quot;move&quot;;
1771     case lir_move_unaligned:
1772       return &quot;unaligned move&quot;;
1773     case lir_move_volatile:
1774       return &quot;volatile_move&quot;;
1775     case lir_move_wide:
1776       return &quot;wide_move&quot;;
1777     default:
1778       ShouldNotReachHere();
1779     return &quot;illegal_op&quot;;
1780     }
1781   } else {
1782     return LIR_Op::name();
1783   }
1784 }
1785 
1786 
1787 void LIR_Op1::print_instr(outputStream* out) const {
1788   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1789   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1790   print_patch_code(out, patch_code());
1791 }
1792 
1793 
1794 // LIR_Op1
1795 void LIR_OpRTCall::print_instr(outputStream* out) const {
1796   intx a = (intx)addr();
1797   out-&gt;print(&quot;%s&quot;, Runtime1::name_for_address(addr()));
1798   out-&gt;print(&quot; &quot;);
1799   tmp()-&gt;print(out);
1800 }
1801 
1802 void LIR_Op1::print_patch_code(outputStream* out, LIR_PatchCode code) {
1803   switch(code) {
1804     case lir_patch_none:                                 break;
1805     case lir_patch_low:    out-&gt;print(&quot;[patch_low]&quot;);    break;
1806     case lir_patch_high:   out-&gt;print(&quot;[patch_high]&quot;);   break;
1807     case lir_patch_normal: out-&gt;print(&quot;[patch_normal]&quot;); break;
1808     default: ShouldNotReachHere();
1809   }
1810 }
1811 
1812 // LIR_OpBranch
1813 void LIR_OpBranch::print_instr(outputStream* out) const {
1814   print_condition(out, cond());             out-&gt;print(&quot; &quot;);
1815   if (block() != NULL) {
1816     out-&gt;print(&quot;[B%d] &quot;, block()-&gt;block_id());
1817   } else if (stub() != NULL) {
1818     out-&gt;print(&quot;[&quot;);
1819     stub()-&gt;print_name(out);
1820     out-&gt;print(&quot;: &quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()));
1821     if (stub()-&gt;info() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, stub()-&gt;info()-&gt;stack()-&gt;bci());
1822   } else {
1823     out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;] &quot;, p2i(label()));
1824   }
1825   if (ublock() != NULL) {
1826     out-&gt;print(&quot;unordered: [B%d] &quot;, ublock()-&gt;block_id());
1827   }
1828 }
1829 
1830 void LIR_Op::print_condition(outputStream* out, LIR_Condition cond) {
1831   switch(cond) {
1832     case lir_cond_equal:           out-&gt;print(&quot;[EQ]&quot;);      break;
1833     case lir_cond_notEqual:        out-&gt;print(&quot;[NE]&quot;);      break;
1834     case lir_cond_less:            out-&gt;print(&quot;[LT]&quot;);      break;
1835     case lir_cond_lessEqual:       out-&gt;print(&quot;[LE]&quot;);      break;
1836     case lir_cond_greaterEqual:    out-&gt;print(&quot;[GE]&quot;);      break;
1837     case lir_cond_greater:         out-&gt;print(&quot;[GT]&quot;);      break;
1838     case lir_cond_belowEqual:      out-&gt;print(&quot;[BE]&quot;);      break;
1839     case lir_cond_aboveEqual:      out-&gt;print(&quot;[AE]&quot;);      break;
1840     case lir_cond_always:          out-&gt;print(&quot;[AL]&quot;);      break;
1841     default:                       out-&gt;print(&quot;[%d]&quot;,cond); break;
1842   }
1843 }
1844 
1845 // LIR_OpConvert
1846 void LIR_OpConvert::print_instr(outputStream* out) const {
1847   print_bytecode(out, bytecode());
1848   in_opr()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1849   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1850 #ifdef PPC32
1851   if(tmp1()-&gt;is_valid()) {
1852     tmp1()-&gt;print(out); out-&gt;print(&quot; &quot;);
1853     tmp2()-&gt;print(out); out-&gt;print(&quot; &quot;);
1854   }
1855 #endif
1856 }
1857 
1858 void LIR_OpConvert::print_bytecode(outputStream* out, Bytecodes::Code code) {
1859   switch(code) {
1860     case Bytecodes::_d2f: out-&gt;print(&quot;[d2f] &quot;); break;
1861     case Bytecodes::_d2i: out-&gt;print(&quot;[d2i] &quot;); break;
1862     case Bytecodes::_d2l: out-&gt;print(&quot;[d2l] &quot;); break;
1863     case Bytecodes::_f2d: out-&gt;print(&quot;[f2d] &quot;); break;
1864     case Bytecodes::_f2i: out-&gt;print(&quot;[f2i] &quot;); break;
1865     case Bytecodes::_f2l: out-&gt;print(&quot;[f2l] &quot;); break;
1866     case Bytecodes::_i2b: out-&gt;print(&quot;[i2b] &quot;); break;
1867     case Bytecodes::_i2c: out-&gt;print(&quot;[i2c] &quot;); break;
1868     case Bytecodes::_i2d: out-&gt;print(&quot;[i2d] &quot;); break;
1869     case Bytecodes::_i2f: out-&gt;print(&quot;[i2f] &quot;); break;
1870     case Bytecodes::_i2l: out-&gt;print(&quot;[i2l] &quot;); break;
1871     case Bytecodes::_i2s: out-&gt;print(&quot;[i2s] &quot;); break;
1872     case Bytecodes::_l2i: out-&gt;print(&quot;[l2i] &quot;); break;
1873     case Bytecodes::_l2f: out-&gt;print(&quot;[l2f] &quot;); break;
1874     case Bytecodes::_l2d: out-&gt;print(&quot;[l2d] &quot;); break;
1875     default:
1876       out-&gt;print(&quot;[?%d]&quot;,code);
1877     break;
1878   }
1879 }
1880 
1881 void LIR_OpAllocObj::print_instr(outputStream* out) const {
1882   klass()-&gt;print(out);                      out-&gt;print(&quot; &quot;);
1883   obj()-&gt;print(out);                        out-&gt;print(&quot; &quot;);
1884   tmp1()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1885   tmp2()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1886   tmp3()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1887   tmp4()-&gt;print(out);                       out-&gt;print(&quot; &quot;);
1888   out-&gt;print(&quot;[hdr:%d]&quot;, header_size()); out-&gt;print(&quot; &quot;);
1889   out-&gt;print(&quot;[obj:%d]&quot;, object_size()); out-&gt;print(&quot; &quot;);
1890   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1891 }
1892 
1893 void LIR_OpRoundFP::print_instr(outputStream* out) const {
1894   _opr-&gt;print(out);         out-&gt;print(&quot; &quot;);
1895   tmp()-&gt;print(out);        out-&gt;print(&quot; &quot;);
1896   result_opr()-&gt;print(out); out-&gt;print(&quot; &quot;);
1897 }
1898 
1899 // LIR_Op2
1900 void LIR_Op2::print_instr(outputStream* out) const {
1901   if (code() == lir_cmove || code() == lir_cmp) {
1902     print_condition(out, condition());         out-&gt;print(&quot; &quot;);
1903   }
1904   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1905   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1906   if (tmp1_opr()-&gt;is_valid()) { tmp1_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1907   if (tmp2_opr()-&gt;is_valid()) { tmp2_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1908   if (tmp3_opr()-&gt;is_valid()) { tmp3_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1909   if (tmp4_opr()-&gt;is_valid()) { tmp4_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1910   if (tmp5_opr()-&gt;is_valid()) { tmp5_opr()-&gt;print(out);    out-&gt;print(&quot; &quot;); }
1911   result_opr()-&gt;print(out);
1912 }
1913 
1914 void LIR_OpAllocArray::print_instr(outputStream* out) const {
1915   klass()-&gt;print(out);                   out-&gt;print(&quot; &quot;);
1916   len()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
1917   obj()-&gt;print(out);                     out-&gt;print(&quot; &quot;);
1918   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1919   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1920   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1921   tmp4()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1922   out-&gt;print(&quot;[type:0x%x]&quot;, type());     out-&gt;print(&quot; &quot;);
1923   out-&gt;print(&quot;[label:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1924 }
1925 
1926 
1927 void LIR_OpTypeCheck::print_instr(outputStream* out) const {
1928   object()-&gt;print(out);                  out-&gt;print(&quot; &quot;);
1929   if (code() == lir_store_check) {
1930     array()-&gt;print(out);                 out-&gt;print(&quot; &quot;);
1931   }
1932   if (code() != lir_store_check) {
1933     klass()-&gt;print_name_on(out);         out-&gt;print(&quot; &quot;);
1934     if (fast_check())                 out-&gt;print(&quot;fast_check &quot;);
1935   }
1936   tmp1()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1937   tmp2()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1938   tmp3()-&gt;print(out);                    out-&gt;print(&quot; &quot;);
1939   result_opr()-&gt;print(out);              out-&gt;print(&quot; &quot;);
1940   if (info_for_exception() != NULL) out-&gt;print(&quot; [bci:%d]&quot;, info_for_exception()-&gt;stack()-&gt;bci());
1941 }
1942 
1943 
1944 // LIR_Op3
1945 void LIR_Op3::print_instr(outputStream* out) const {
1946   in_opr1()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1947   in_opr2()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1948   in_opr3()-&gt;print(out);    out-&gt;print(&quot; &quot;);
1949   result_opr()-&gt;print(out);
1950 }
1951 
1952 
1953 void LIR_OpLock::print_instr(outputStream* out) const {
1954   hdr_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1955   obj_opr()-&gt;print(out);   out-&gt;print(&quot; &quot;);
1956   lock_opr()-&gt;print(out);  out-&gt;print(&quot; &quot;);
1957   if (_scratch-&gt;is_valid()) {
1958     _scratch-&gt;print(out);  out-&gt;print(&quot; &quot;);
1959   }
1960   out-&gt;print(&quot;[lbl:&quot; INTPTR_FORMAT &quot;]&quot;, p2i(stub()-&gt;entry()));
1961 }
1962 
1963 #ifdef ASSERT
1964 void LIR_OpAssert::print_instr(outputStream* out) const {
1965   print_condition(out, condition()); out-&gt;print(&quot; &quot;);
1966   in_opr1()-&gt;print(out);             out-&gt;print(&quot; &quot;);
1967   in_opr2()-&gt;print(out);             out-&gt;print(&quot;, \&quot;&quot;);
1968   out-&gt;print(&quot;%s&quot;, msg());          out-&gt;print(&quot;\&quot;&quot;);
1969 }
1970 #endif
1971 
1972 
1973 void LIR_OpDelay::print_instr(outputStream* out) const {
1974   _op-&gt;print_on(out);
1975 }
1976 
1977 
1978 // LIR_OpProfileCall
1979 void LIR_OpProfileCall::print_instr(outputStream* out) const {
1980   profiled_method()-&gt;name()-&gt;print_symbol_on(out);
1981   out-&gt;print(&quot;.&quot;);
1982   profiled_method()-&gt;holder()-&gt;name()-&gt;print_symbol_on(out);
1983   out-&gt;print(&quot; @ %d &quot;, profiled_bci());
1984   mdo()-&gt;print(out);           out-&gt;print(&quot; &quot;);
1985   recv()-&gt;print(out);          out-&gt;print(&quot; &quot;);
1986   tmp1()-&gt;print(out);          out-&gt;print(&quot; &quot;);
1987 }
1988 
1989 // LIR_OpProfileType
1990 void LIR_OpProfileType::print_instr(outputStream* out) const {
1991   out-&gt;print(&quot;exact = &quot;);
1992   if  (exact_klass() == NULL) {
1993     out-&gt;print(&quot;unknown&quot;);
1994   } else {
1995     exact_klass()-&gt;print_name_on(out);
1996   }
1997   out-&gt;print(&quot; current = &quot;); ciTypeEntries::print_ciklass(out, current_klass());
1998   out-&gt;print(&quot; &quot;);
1999   mdp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2000   obj()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2001   tmp()-&gt;print(out);          out-&gt;print(&quot; &quot;);
2002 }
2003 
2004 #endif // PRODUCT
2005 
2006 // Implementation of LIR_InsertionBuffer
2007 
2008 void LIR_InsertionBuffer::append(int index, LIR_Op* op) {
2009   assert(_index_and_count.length() % 2 == 0, &quot;must have a count for each index&quot;);
2010 
2011   int i = number_of_insertion_points() - 1;
2012   if (i &lt; 0 || index_at(i) &lt; index) {
2013     append_new(index, 1);
2014   } else {
2015     assert(index_at(i) == index, &quot;can append LIR_Ops in ascending order only&quot;);
2016     assert(count_at(i) &gt; 0, &quot;check&quot;);
2017     set_count_at(i, count_at(i) + 1);
2018   }
2019   _ops.push(op);
2020 
2021   DEBUG_ONLY(verify());
2022 }
2023 
2024 #ifdef ASSERT
2025 void LIR_InsertionBuffer::verify() {
2026   int sum = 0;
2027   int prev_idx = -1;
2028 
2029   for (int i = 0; i &lt; number_of_insertion_points(); i++) {
2030     assert(prev_idx &lt; index_at(i), &quot;index must be ordered ascending&quot;);
2031     sum += count_at(i);
2032   }
2033   assert(sum == number_of_ops(), &quot;wrong total sum&quot;);
2034 }
2035 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
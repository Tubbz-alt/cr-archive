<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Compiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 2080,27 ***</span>
      code == Bytecodes::_invokeinterface;
    Values* args = state()-&gt;pop_arguments(target-&gt;arg_size_no_receiver() + patching_appendix_arg);
    Value recv = has_receiver ? apop() : NULL;
    int vtable_index = Method::invalid_vtable_index;
  
<span class="line-removed">- #ifdef SPARC</span>
<span class="line-removed">-   // Currently only supported on Sparc.</span>
<span class="line-removed">-   // The UseInlineCaches only controls dispatch to invokevirtuals for</span>
<span class="line-removed">-   // loaded classes which we weren&#39;t able to statically bind.</span>
<span class="line-removed">-   if (!UseInlineCaches &amp;&amp; target-&gt;is_loaded() &amp;&amp; code == Bytecodes::_invokevirtual</span>
<span class="line-removed">-       &amp;&amp; !target-&gt;can_be_statically_bound()) {</span>
<span class="line-removed">-     // Find a vtable index if one is available</span>
<span class="line-removed">-     // For arrays, callee_holder is Object. Resolving the call with</span>
<span class="line-removed">-     // Object would allow an illegal call to finalize() on an</span>
<span class="line-removed">-     // array. We use holder instead: illegal calls to finalize() won&#39;t</span>
<span class="line-removed">-     // be compiled as vtable calls (IC call resolution will catch the</span>
<span class="line-removed">-     // illegal call) and the few legal calls on array types won&#39;t be</span>
<span class="line-removed">-     // either.</span>
<span class="line-removed">-     vtable_index = target-&gt;resolve_vtable_index(calling_klass, holder);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
    // A null check is required here (when there is a receiver) for any of the following cases
    // - invokespecial, always need a null check.
    // - invokevirtual, when the target is final and loaded. Calls to final targets will become optimized
    //   and require null checking. If the target is loaded a null check is emitted here.
    //   If the target isn&#39;t loaded the null check must happen after the call resolution. We achieve that
<span class="line-new-header">--- 2080,10 ---</span>
</pre>
<center><a href="c1_Compiler.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
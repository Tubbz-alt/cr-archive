<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_zero/os_linux_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../linux_x86/os_linux_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_zero/os_linux_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 
 70 frame os::current_frame() {
 71   // The only thing that calls this is the stack printing code in
 72   // VMError::report:
 73   //   - Step 110 (printing stack bounds) uses the sp in the frame
 74   //     to determine the amount of free space on the stack.  We
 75   //     set the sp to a close approximation of the real value in
 76   //     order to allow this step to complete.
 77   //   - Step 120 (printing native stack) tries to walk the stack.
 78   //     The frame we create has a NULL pc, which is ignored as an
 79   //     invalid frame.
 80   frame dummy = frame();
 81   dummy.set_sp((intptr_t *) current_stack_pointer());
 82   return dummy;
 83 }
 84 
 85 char* os::non_memory_address_word() {
 86   // Must never look like an address returned by reserve_memory,
 87   // even in its subfields (as defined by the CPU immediate fields,
 88   // if the CPU splits constants across multiple instructions).
<span class="line-removed"> 89 #ifdef SPARC</span>
<span class="line-removed"> 90   // On SPARC, 0 != %hi(any real address), because there is no</span>
<span class="line-removed"> 91   // allocation in the first 1Kb of the virtual address space.</span>
<span class="line-removed"> 92   return (char *) 0;</span>
<span class="line-removed"> 93 #else</span>
 94   // This is the value for x86; works pretty well for PPC too.
 95   return (char *) -1;
<span class="line-removed"> 96 #endif // SPARC</span>
 97 }
 98 
 99 address os::Linux::ucontext_get_pc(const ucontext_t* uc) {
100   ShouldNotCallThis();
101   return NULL; // silence compile warnings
102 }
103 
104 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
105   ShouldNotCallThis();
106 }
107 
108 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
109                                         intptr_t** ret_sp,
110                                         intptr_t** ret_fp) {
111   ShouldNotCallThis();
112   return NULL; // silence compile warnings
113 }
114 
115 frame os::fetch_frame_from_context(const void* ucVoid) {
116   ShouldNotCallThis();
</pre>
</td>
<td>
<hr />
<pre>
 69 
 70 frame os::current_frame() {
 71   // The only thing that calls this is the stack printing code in
 72   // VMError::report:
 73   //   - Step 110 (printing stack bounds) uses the sp in the frame
 74   //     to determine the amount of free space on the stack.  We
 75   //     set the sp to a close approximation of the real value in
 76   //     order to allow this step to complete.
 77   //   - Step 120 (printing native stack) tries to walk the stack.
 78   //     The frame we create has a NULL pc, which is ignored as an
 79   //     invalid frame.
 80   frame dummy = frame();
 81   dummy.set_sp((intptr_t *) current_stack_pointer());
 82   return dummy;
 83 }
 84 
 85 char* os::non_memory_address_word() {
 86   // Must never look like an address returned by reserve_memory,
 87   // even in its subfields (as defined by the CPU immediate fields,
 88   // if the CPU splits constants across multiple instructions).





 89   // This is the value for x86; works pretty well for PPC too.
 90   return (char *) -1;

 91 }
 92 
 93 address os::Linux::ucontext_get_pc(const ucontext_t* uc) {
 94   ShouldNotCallThis();
 95   return NULL; // silence compile warnings
 96 }
 97 
 98 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
 99   ShouldNotCallThis();
100 }
101 
102 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
103                                         intptr_t** ret_sp,
104                                         intptr_t** ret_fp) {
105   ShouldNotCallThis();
106   return NULL; // silence compile warnings
107 }
108 
109 frame os::fetch_frame_from_context(const void* ucVoid) {
110   ShouldNotCallThis();
</pre>
</td>
</tr>
</table>
<center><a href="../linux_x86/os_linux_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/adlc/formssel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="bytes_linux_x86.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_zero/os_linux_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 78 # include &lt;ucontext.h&gt;
 79 #ifndef AMD64
 80 # include &lt;fpu_control.h&gt;
 81 #endif
 82 
 83 #ifdef AMD64
 84 #define REG_SP REG_RSP
 85 #define REG_PC REG_RIP
 86 #define REG_FP REG_RBP
 87 #define SPELL_REG_SP &quot;rsp&quot;
 88 #define SPELL_REG_FP &quot;rbp&quot;
 89 #else
 90 #define REG_SP REG_UESP
 91 #define REG_PC REG_EIP
 92 #define REG_FP REG_EBP
 93 #define SPELL_REG_SP &quot;esp&quot;
 94 #define SPELL_REG_FP &quot;ebp&quot;
 95 #endif // AMD64
 96 
 97 address os::current_stack_pointer() {
<span class="line-removed"> 98 #ifdef SPARC_WORKS</span>
<span class="line-removed"> 99   void *esp;</span>
<span class="line-removed">100   __asm__(&quot;mov %%&quot; SPELL_REG_SP &quot;, %0&quot;:&quot;=r&quot;(esp));</span>
<span class="line-removed">101   return (address) ((char*)esp + sizeof(long)*2);</span>
<span class="line-removed">102 #else</span>
103   return (address)__builtin_frame_address(0);
<span class="line-removed">104 #endif</span>
105 }
106 
107 char* os::non_memory_address_word() {
108   // Must never look like an address returned by reserve_memory,
109   // even in its subfields (as defined by the CPU immediate fields,
110   // if the CPU splits constants across multiple instructions).
111 
112   return (char*) -1;
113 }
114 
115 address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
116   return (address)uc-&gt;uc_mcontext.gregs[REG_PC];
117 }
118 
119 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
120   uc-&gt;uc_mcontext.gregs[REG_PC] = (intptr_t)pc;
121 }
122 
123 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
124   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
</pre>
<hr />
<pre>
207       intptr_t* sp = os::Linux::ucontext_get_sp(uc);
208       *fr = frame(sp + 1, fp, (address)*sp);
209       if (!fr-&gt;is_java_frame()) {
210         assert(!fr-&gt;is_first_frame(), &quot;Safety check&quot;);
211         // See java_sender() comment above.
212         *fr = fr-&gt;java_sender();
213       }
214     }
215   }
216   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
217   return true;
218 }
219 
220 // By default, gcc always save frame pointer (%ebp/%rbp) on stack. It may get
221 // turned off by -fomit-frame-pointer,
222 frame os::get_sender_for_C_frame(frame* fr) {
223   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
224 }
225 
226 intptr_t* _get_previous_fp() {
<span class="line-modified">227 #ifdef SPARC_WORKS</span>
<span class="line-removed">228   intptr_t **ebp;</span>
<span class="line-removed">229   __asm__(&quot;mov %%&quot; SPELL_REG_FP &quot;, %0&quot;:&quot;=r&quot;(ebp));</span>
<span class="line-removed">230 #elif defined(__clang__)</span>
231   intptr_t **ebp;
232   __asm__ __volatile__ (&quot;mov %%&quot; SPELL_REG_FP &quot;, %0&quot;:&quot;=r&quot;(ebp):);
233 #else
234   register intptr_t **ebp __asm__ (SPELL_REG_FP);
235 #endif
236   // ebp is for this frame (_get_previous_fp). We want the ebp for the
237   // caller of os::current_frame*(), so go up two frames. However, for
238   // optimized builds, _get_previous_fp() will be inlined, so only go
239   // up 1 frame in that case.
240 #ifdef _NMT_NOINLINE_
241   return **(intptr_t***)ebp;
242 #else
243   return *ebp;
244 #endif
245 }
246 
247 
248 frame os::current_frame() {
249   intptr_t* fp = _get_previous_fp();
250   frame myframe((intptr_t*)os::current_stack_pointer(),
</pre>
</td>
<td>
<hr />
<pre>
 78 # include &lt;ucontext.h&gt;
 79 #ifndef AMD64
 80 # include &lt;fpu_control.h&gt;
 81 #endif
 82 
 83 #ifdef AMD64
 84 #define REG_SP REG_RSP
 85 #define REG_PC REG_RIP
 86 #define REG_FP REG_RBP
 87 #define SPELL_REG_SP &quot;rsp&quot;
 88 #define SPELL_REG_FP &quot;rbp&quot;
 89 #else
 90 #define REG_SP REG_UESP
 91 #define REG_PC REG_EIP
 92 #define REG_FP REG_EBP
 93 #define SPELL_REG_SP &quot;esp&quot;
 94 #define SPELL_REG_FP &quot;ebp&quot;
 95 #endif // AMD64
 96 
 97 address os::current_stack_pointer() {





 98   return (address)__builtin_frame_address(0);

 99 }
100 
101 char* os::non_memory_address_word() {
102   // Must never look like an address returned by reserve_memory,
103   // even in its subfields (as defined by the CPU immediate fields,
104   // if the CPU splits constants across multiple instructions).
105 
106   return (char*) -1;
107 }
108 
109 address os::Linux::ucontext_get_pc(const ucontext_t * uc) {
110   return (address)uc-&gt;uc_mcontext.gregs[REG_PC];
111 }
112 
113 void os::Linux::ucontext_set_pc(ucontext_t * uc, address pc) {
114   uc-&gt;uc_mcontext.gregs[REG_PC] = (intptr_t)pc;
115 }
116 
117 intptr_t* os::Linux::ucontext_get_sp(const ucontext_t * uc) {
118   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
</pre>
<hr />
<pre>
201       intptr_t* sp = os::Linux::ucontext_get_sp(uc);
202       *fr = frame(sp + 1, fp, (address)*sp);
203       if (!fr-&gt;is_java_frame()) {
204         assert(!fr-&gt;is_first_frame(), &quot;Safety check&quot;);
205         // See java_sender() comment above.
206         *fr = fr-&gt;java_sender();
207       }
208     }
209   }
210   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
211   return true;
212 }
213 
214 // By default, gcc always save frame pointer (%ebp/%rbp) on stack. It may get
215 // turned off by -fomit-frame-pointer,
216 frame os::get_sender_for_C_frame(frame* fr) {
217   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
218 }
219 
220 intptr_t* _get_previous_fp() {
<span class="line-modified">221 #if defined(__clang__)</span>



222   intptr_t **ebp;
223   __asm__ __volatile__ (&quot;mov %%&quot; SPELL_REG_FP &quot;, %0&quot;:&quot;=r&quot;(ebp):);
224 #else
225   register intptr_t **ebp __asm__ (SPELL_REG_FP);
226 #endif
227   // ebp is for this frame (_get_previous_fp). We want the ebp for the
228   // caller of os::current_frame*(), so go up two frames. However, for
229   // optimized builds, _get_previous_fp() will be inlined, so only go
230   // up 1 frame in that case.
231 #ifdef _NMT_NOINLINE_
232   return **(intptr_t***)ebp;
233 #else
234   return *ebp;
235 #endif
236 }
237 
238 
239 frame os::current_frame() {
240   intptr_t* fp = _get_previous_fp();
241   frame myframe((intptr_t*)os::current_stack_pointer(),
</pre>
</td>
</tr>
</table>
<center><a href="bytes_linux_x86.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_zero/os_linux_zero.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
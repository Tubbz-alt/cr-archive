<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/os_cpu/solaris_sparc/solaris_sparc.il</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //
  2 // Copyright (c) 2002, 2017, Oracle and/or its affiliates. All rights reserved.
  3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 //
  5 // This code is free software; you can redistribute it and/or modify it
  6 // under the terms of the GNU General Public License version 2 only, as
  7 // published by the Free Software Foundation.
  8 //
  9 // This code is distributed in the hope that it will be useful, but WITHOUT
 10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12 // version 2 for more details (a copy is included in the LICENSE file that
 13 // accompanied this code).
 14 //
 15 // You should have received a copy of the GNU General Public License version
 16 // 2 along with this work; if not, write to the Free Software Foundation,
 17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18 //
 19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20 // or visit www.oracle.com if you need additional information or have any
 21 // questions.
 22 //
 23 //
 24 
 25   // Get the raw thread ID from %g7
 26 
 27        .inline  _raw_thread_id, 0
 28        .register %g7,#scratch
 29        .volatile
 30        mov     %g7, %o0
 31        .nonvolatile
 32        .end
 33 
 34 
 35   // Support for jlong Atomic::load and Atomic::store on v9.
 36   //
 37   // void _Atomic_move_long_v9(volatile jlong* src, volatile jlong* dst)
 38   //
 39   // Arguments:
 40   //      src:  O0
 41   //      dest: O1
 42   //
 43   // Overwrites O2
 44 
 45         .inline _Atomic_move_long_v9,2
 46         .volatile
 47         ldx     [%o0], %o2
 48         stx     %o2, [%o1]
 49         .nonvolatile
 50         .end
 51 
 52   // Support for void Prefetch::read(void *loc, intx interval)
 53   //
 54   // Prefetch for several reads.
 55 
 56         .inline _Prefetch_read, 2
 57         .volatile
 58         prefetch [%o0+%o1], 0
 59         .nonvolatile
 60         .end
 61 
 62 
 63   // Support for void Prefetch::write(void *loc, intx interval)
 64   //
 65   // Prefetch for several writes.
 66 
 67         .inline _Prefetch_write, 2
 68         .volatile
 69         prefetch [%o0+%o1], 2
 70         .nonvolatile
 71         .end
 72 
 73 
 74   // Support for void Copy::conjoint_jlongs_atomic(jlong* from, jlong* to, size_t count)
 75   //
 76   // 32-bit
 77   //
 78   // Arguments:
 79   //      from:  O0
 80   //      to:    O1
 81   //      count: O2 treated as signed
 82   //
 83   // Clobbers:
 84   //      long_value: O2, O3
 85   //      count:      O4
 86   //
 87   // if (from &gt; to) {
 88   //   while (--count &gt;= 0) {
 89   //     *to++ = *from++;
 90   //   }
 91   // } else {
 92   //   while (--count &gt;= 0) {
 93   //     to[count] = from[count];
 94   //   }
 95   // }
 96         .inline _Copy_conjoint_jlongs_atomic, 3
 97         .volatile
 98         cmp     %o0, %o1
 99         bleu    4f
100         sll     %o2, 3, %o4
101         ba      2f
102     1:
103         subcc   %o4, 8, %o4
104         std     %o2, [%o1]
105         add     %o0, 8, %o0
106         add     %o1, 8, %o1
107     2:
108         bge,a   1b
109         ldd     [%o0], %o2
110         ba      5f
111         nop
112     3:
113         std     %o2, [%o1+%o4]
114     4:
115         subcc   %o4, 8, %o4
116         bge,a   3b
117         ldd     [%o0+%o4], %o2
118     5:
119         .nonvolatile
120         .end
    </pre>
  </body>
</html>
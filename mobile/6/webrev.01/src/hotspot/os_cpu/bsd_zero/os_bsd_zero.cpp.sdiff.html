<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../bsd_x86/os_bsd_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_x86/bytes_linux_x86.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/bsd_zero/os_bsd_zero.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 73 
 74 frame os::current_frame() {
 75   // The only thing that calls this is the stack printing code in
 76   // VMError::report:
 77   //   - Step 110 (printing stack bounds) uses the sp in the frame
 78   //     to determine the amount of free space on the stack.  We
 79   //     set the sp to a close approximation of the real value in
 80   //     order to allow this step to complete.
 81   //   - Step 120 (printing native stack) tries to walk the stack.
 82   //     The frame we create has a NULL pc, which is ignored as an
 83   //     invalid frame.
 84   frame dummy = frame();
 85   dummy.set_sp((intptr_t *) current_stack_pointer());
 86   return dummy;
 87 }
 88 
 89 char* os::non_memory_address_word() {
 90   // Must never look like an address returned by reserve_memory,
 91   // even in its subfields (as defined by the CPU immediate fields,
 92   // if the CPU splits constants across multiple instructions).
<span class="line-removed"> 93 #ifdef SPARC</span>
<span class="line-removed"> 94   // On SPARC, 0 != %hi(any real address), because there is no</span>
<span class="line-removed"> 95   // allocation in the first 1Kb of the virtual address space.</span>
<span class="line-removed"> 96   return (char *) 0;</span>
<span class="line-removed"> 97 #else</span>
 98   // This is the value for x86; works pretty well for PPC too.
 99   return (char *) -1;
<span class="line-removed">100 #endif // SPARC</span>
101 }
102 
103 address os::Bsd::ucontext_get_pc(const ucontext_t* uc) {
104   ShouldNotCallThis();
105   return NULL;
106 }
107 
108 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
109   ShouldNotCallThis();
110 }
111 
112 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
113                                         intptr_t** ret_sp,
114                                         intptr_t** ret_fp) {
115   ShouldNotCallThis();
116   return ExtendedPC();
117 }
118 
119 frame os::fetch_frame_from_context(const void* ucVoid) {
120   ShouldNotCallThis();
</pre>
</td>
<td>
<hr />
<pre>
 73 
 74 frame os::current_frame() {
 75   // The only thing that calls this is the stack printing code in
 76   // VMError::report:
 77   //   - Step 110 (printing stack bounds) uses the sp in the frame
 78   //     to determine the amount of free space on the stack.  We
 79   //     set the sp to a close approximation of the real value in
 80   //     order to allow this step to complete.
 81   //   - Step 120 (printing native stack) tries to walk the stack.
 82   //     The frame we create has a NULL pc, which is ignored as an
 83   //     invalid frame.
 84   frame dummy = frame();
 85   dummy.set_sp((intptr_t *) current_stack_pointer());
 86   return dummy;
 87 }
 88 
 89 char* os::non_memory_address_word() {
 90   // Must never look like an address returned by reserve_memory,
 91   // even in its subfields (as defined by the CPU immediate fields,
 92   // if the CPU splits constants across multiple instructions).





 93   // This is the value for x86; works pretty well for PPC too.
 94   return (char *) -1;

 95 }
 96 
 97 address os::Bsd::ucontext_get_pc(const ucontext_t* uc) {
 98   ShouldNotCallThis();
 99   return NULL;
100 }
101 
102 void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {
103   ShouldNotCallThis();
104 }
105 
106 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
107                                         intptr_t** ret_sp,
108                                         intptr_t** ret_fp) {
109   ShouldNotCallThis();
110   return ExtendedPC();
111 }
112 
113 frame os::fetch_frame_from_context(const void* ucVoid) {
114   ShouldNotCallThis();
</pre>
</td>
</tr>
</table>
<center><a href="../bsd_x86/os_bsd_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux_x86/bytes_linux_x86.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -642,5 +642,9 @@
 4a485c89d5a08b495961835f5308a96038678aeb jdk-16+1
 06c9f89459daba98395fad726100feb44f89ba71 jdk-15+28
 bcbe7b8a77b8971bc221c0be1bd2abb6fb68c2d0 jdk-16+2
 b58fc60580550a4a587cab729d8fd87223ad6932 jdk-15+29
 76810b3a88c8c641ae3850a8dfd7c40c984aea9d jdk-16+3
+6909e4a1f25bfe9a2727026f5845fc1fc44a36aa jdk-15+30
+78c07dd7240412e60d8694e9dbfd46e57bd42ee0 jdk-16+4
+78c07dd7240412e60d8694e9dbfd46e57bd42ee0 jdk-16+4
+e2622818f0bd30e736252eba101fe7d2c27f400b jdk-16+4
diff a/make/CompileDemos.gmk b/make/CompileDemos.gmk
--- a/make/CompileDemos.gmk
+++ b/make/CompileDemos.gmk
@@ -50,11 +50,10 @@
 # The demo structure and contents should really be cleaned up.
 # Now every other demo has its own quirks where to put the
 # READMEs and other files.
 
 DEMO_SHARE_SRC := $(TOPDIR)/src/demo/share
-GLOBAL_VERSION_INFO_RESOURCE := $(TOPDIR)/src/java.base/windows/native/common/version.rc
 
 DEMO_MANIFEST := $(SUPPORT_OUTPUTDIR)/demos/java-main-manifest.mf
 
 # This rule will be depended on due to the MANIFEST line in SetupBuildDemo
 # and SetupBuildJvmtiDemo.
diff a/make/Main.gmk b/make/Main.gmk
--- a/make/Main.gmk
+++ b/make/Main.gmk
@@ -638,10 +638,24 @@
     MAKEFILE := test/JtregNativeJdk, \
     TARGET := test-image-jdk-jtreg-native, \
     DEPS := build-test-jdk-jtreg-native, \
 ))
 
+# Native files needed by the testlib
+$(eval $(call SetupTarget, build-test-lib-native, \
+    MAKEFILE := test/BuildTestLibNative, \
+    TARGET := build-test-lib-native, \
+    DEPS := buildtools-jdk java.base-libs, \
+))
+
+$(eval $(call SetupTarget, test-image-lib-native, \
+    MAKEFILE := test/BuildTestLibNative, \
+    TARGET := test-image-lib-native, \
+    DEPS := build-test-lib-native, \
+))
+
+# Native files needed when testing the testlib itself
 $(eval $(call SetupTarget, build-test-libtest-jtreg-native, \
     MAKEFILE := test/JtregNativeLibTest, \
     TARGET := build-test-libtest-jtreg-native, \
     DEPS := buildtools-jdk, \
 ))
@@ -1116,11 +1130,13 @@
 
 # This target builds the documentation image
 docs-image: docs-jdk
 
 # This target builds the test image
-test-image: prepare-test-image test-image-jdk-jtreg-native test-image-demos-jdk test-image-libtest-jtreg-native
+test-image: prepare-test-image test-image-jdk-jtreg-native \
+    test-image-demos-jdk test-image-libtest-jtreg-native \
+    test-image-lib-native
 
 ifneq ($(JVM_TEST_IMAGE_TARGETS), )
   # If JVM_TEST_IMAGE_TARGETS is externally defined, use it instead of the
   # standard hotspot set of tests.
   test-image: $(JVM_TEST_IMAGE_TARGETS)
diff a/make/autoconf/flags-other.m4 b/make/autoconf/flags-other.m4
--- a/make/autoconf/flags-other.m4
+++ b/make/autoconf/flags-other.m4
@@ -62,43 +62,16 @@
 
 AC_DEFUN([FLAGS_SETUP_RCFLAGS],
 [
   # On Windows, we need to set RC flags.
   if test "x$TOOLCHAIN_TYPE" = xmicrosoft; then
-    RC_FLAGS="-nologo -l0x409"
-    JVM_RCFLAGS="-nologo"
+    RCFLAGS="-nologo"
     if test "x$DEBUG_LEVEL" = xrelease; then
-      RC_FLAGS="$RC_FLAGS -DNDEBUG"
-      JVM_RCFLAGS="$JVM_RCFLAGS -DNDEBUG"
+      RCFLAGS="$RCFLAGS -DNDEBUG"
     fi
-
-    # The version variables used to create RC_FLAGS may be overridden
-    # in a custom configure script, or possibly the command line.
-    # Let those variables be expanded at make time in spec.gmk.
-    # The \$ are escaped to the shell, and the $(...) variables
-    # are evaluated by make.
-    RC_FLAGS="$RC_FLAGS \
-        -D\"JDK_VERSION_STRING=\$(VERSION_STRING)\" \
-        -D\"JDK_COMPANY=\$(COMPANY_NAME)\" \
-        -D\"JDK_FILEDESC=\$(JDK_RC_NAME) binary\" \
-        -D\"JDK_VER=\$(VERSION_NUMBER)\" \
-        -D\"JDK_COPYRIGHT=Copyright \xA9 $COPYRIGHT_YEAR\" \
-        -D\"JDK_NAME=\$(JDK_RC_NAME) \$(VERSION_FEATURE)\" \
-        -D\"JDK_FVER=\$(subst .,\$(COMMA),\$(VERSION_NUMBER_FOUR_POSITIONS))\""
-
-    JVM_RCFLAGS="$JVM_RCFLAGS \
-        -D\"HS_VERSION_STRING=\$(VERSION_STRING)\" \
-        -D\"HS_COMPANY=\$(COMPANY_NAME)\" \
-        -D\"HS_VER=\$(VERSION_NUMBER_FOUR_POSITIONS)\" \
-        -D\"HS_INTERNAL_NAME=jvm\" \
-        -D\"HS_COPYRIGHT=Copyright $COPYRIGHT_YEAR\" \
-        -D\"HS_FNAME=jvm.dll\" \
-        -D\"HS_NAME=\$(PRODUCT_NAME) \$(VERSION_SHORT)\" \
-        -D\"HS_FVER=\$(subst .,\$(COMMA),\$(VERSION_NUMBER_FOUR_POSITIONS))\""
   fi
-  AC_SUBST(RC_FLAGS)
-  AC_SUBST(JVM_RCFLAGS)
+  AC_SUBST(RCFLAGS)
 ])
 
 ################################################################################
 # platform independent
 AC_DEFUN([FLAGS_SETUP_ASFLAGS],
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -492,11 +492,10 @@
 FDLIBM_CFLAGS := @FDLIBM_CFLAGS@
 JVM_CFLAGS := @JVM_CFLAGS@
 JVM_LDFLAGS := @JVM_LDFLAGS@
 JVM_ASFLAGS := @JVM_ASFLAGS@
 JVM_LIBS := @JVM_LIBS@
-JVM_RCFLAGS := @JVM_RCFLAGS@
 
 # These flags might contain variables set by a custom extension that is included later.
 EXTRA_CFLAGS = @EXTRA_CFLAGS@
 EXTRA_CXXFLAGS = @EXTRA_CXXFLAGS@
 EXTRA_LDFLAGS = @EXTRA_LDFLAGS@
@@ -663,16 +662,11 @@
 NEW_JAVAC   = $(INTERIM_LANGTOOLS_ARGS) $(JAVAC_MAIN_CLASS)
 NEW_JAVADOC = $(INTERIM_LANGTOOLS_ARGS) $(JAVADOC_MAIN_CLASS)
 
 JLINK_KEEP_PACKAGED_MODULES:=@JLINK_KEEP_PACKAGED_MODULES@
 
-# Base flags for RC
-# Guarding this against resetting value. Legacy make files include spec multiple
-# times.
-ifndef RC_FLAGS
-  RC_FLAGS:=@RC_FLAGS@
-endif
+RCFLAGS := @RCFLAGS@
 
 # Tools adhering to a minimal and common standard of posix compliance.
 AWK:=@AWK@
 BASENAME:=@BASENAME@
 CAT:=@CAT@
diff a/make/autoconf/util_windows.m4 b/make/autoconf/util_windows.m4
--- a/make/autoconf/util_windows.m4
+++ b/make/autoconf/util_windows.m4
@@ -56,11 +56,11 @@
     if test $? -ne 0; then
       dir=`dirname "$unix_path"`
       base=`basename "$unix_path"`
       windows_path=`$WSLPATH -m "$dir"`/"$base"
       if test $? -ne 0; then
-        AC_MSG_ERROR([Cannot convert \"$unix_path\" to Windows path])
+        AC_MSG_ERROR([Cannot convert "$unix_path" to Windows path])
       fi
     fi
     $1="$windows_path"
   fi
 ])
diff a/make/common/JdkNativeCompilation.gmk b/make/common/JdkNativeCompilation.gmk
--- a/make/common/JdkNativeCompilation.gmk
+++ b/make/common/JdkNativeCompilation.gmk
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -102,26 +102,37 @@
     , \
       $(call FindSrcDirsForComponent, $(MODULE), $1) \
     ) \
   )
 
+GLOBAL_VERSION_INFO_RESOURCE := $(TOPDIR)/src/java.base/windows/native/common/version.rc
+
+JDK_RCFLAGS=$(RCFLAGS) \
+    -D"JDK_VERSION_STRING=$(VERSION_STRING)" \
+    -D"JDK_COMPANY=$(COMPANY_NAME)" \
+    -D"JDK_VER=$(VERSION_NUMBER_FOUR_POSITIONS)" \
+    -D"JDK_COPYRIGHT=Copyright \xA9 $(COPYRIGHT_YEAR)" \
+    -D"JDK_NAME=$(JDK_RC_NAME) $(VERSION_SHORT)" \
+    -D"JDK_FVER=$(subst .,$(COMMA),$(VERSION_NUMBER_FOUR_POSITIONS))"
+
 # Setup make rules for creating a native shared library with suitable defaults
 # for the OpenJDK project.
 #
 # Parameter 1 is the name of the rule. This name is used as variable prefix,
 # and the targets generated are listed in a variable by that name.
 #
 # Remaining parameters are named arguments. These are all passed on to
 # SetupNativeCompilation, except for
-#   EXTRA_RC_FLAGS -- additional RC_FLAGS to append.
+#   EXTRA_RCFLAGS -- additional RCFLAGS to append.
 #   EXTRA_HEADER_DIRS -- additional directories to look for headers in
 #   EXTRA_SRC -- additional directories to look for source in
 #   EXCLUDE_SRC_PATTERNS -- exclude source dirs matching these patterns from
 #     appearing in SRC.
 #   HEADERS_FROM_SRC -- if false, does not add source dirs automatically as
 #     header include dirs. (Defaults to true.)
 #   SRC -- this is passed on, but preprocessed to accept source dir designations
+#   RC_FILEDESC -- override the default FILEDESC for Windows version.rc
 #     such as "java.base:headers".
 SetupJdkLibrary = $(NamedParamsMacroTemplate)
 define SetupJdkLibraryBody
   ifeq ($$($1_OUTPUT_DIR), )
     $1_OUTPUT_DIR := $$(call FindLibDirForModule, $$(MODULE))
@@ -147,23 +158,24 @@
     $1_SRC := $$(filter-out $$($1_EXCLUDE_SRC), $$($1_SRC))
   endif
 
   ifeq ($$($1_VERSIONINFO_RESOURCE), )
     $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)
-  else ifeq ($$($1_VERSIONINFO_RESOURCE), DISABLE)
-    $1_VERSIONINFO_RESOURCE :=
   endif
 
-  ifeq ($$($1_RC_FLAGS), )
-    $1_RC_FLAGS :=  $(RC_FLAGS) \
-        -D "JDK_FNAME=$$($1_NAME).dll" \
-        -D "JDK_INTERNAL_NAME=$$($1_NAME)" \
-        -D "JDK_FTYPE=0x2L"
-  else ifeq ($$($1_RC_FLAGS), DISABLE)
-    $1_RC_FLAGS :=
+  ifeq ($$($1_RC_FILEDESC), )
+    $1_RC_FILEDESC := $(JDK_RC_NAME) binary
   endif
 
+  $1_RCFLAGS := $(JDK_RCFLAGS) \
+      -D"JDK_FILEDESC=$$(strip $$($1_RC_FILEDESC))" \
+      -D"JDK_FNAME=$$($1_NAME).dll" \
+      -D"JDK_INTERNAL_NAME=$$($1_NAME)" \
+      -D"JDK_FTYPE=0x2L" \
+      -I$(TOPDIR)/src/java.base/windows/native/common \
+      $$($1_EXTRA_RCFLAGS)
+
   ifneq ($$($1_HEADERS_FROM_SRC), false)
     $1_SRC_HEADER_FLAGS := $$(addprefix -I, $$(wildcard $$($1_SRC)))
   endif
   # Always add the java header dir
   $1_SRC_HEADER_FLAGS += $$(addprefix -I, $$(call GetJavaHeaderDir, $$(MODULE)))
@@ -181,11 +193,10 @@
     $1_CXXFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)
   endif
   ifeq ($$($1_CFLAGS)$$($1_CXXFLAGS), )
     $1_CFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)
   endif
-  $1_RC_FLAGS += $$($1_EXTRA_RC_FLAGS)
 
   # Since we reuse the rule name ($1), all our arguments will pass through.
   # We lose in transparency, but gain in brevity in this call...
   $$(eval $$(call SetupNativeCompilation, $1, ))
 endef
@@ -196,11 +207,11 @@
 # Parameter 1 is the name of the rule. This name is used as variable prefix,
 # and the targets generated are listed in a variable by that name.
 #
 # Remaining parameters are named arguments. These are all passed on to
 # SetupNativeCompilation, except for
-#   EXTRA_RC_FLAGS -- additional RC_FLAGS to append.
+#   EXTRA_RCFLAGS -- additional RCFLAGS to append.
 SetupJdkExecutable = $(NamedParamsMacroTemplate)
 define SetupJdkExecutableBody
   $1_TYPE := EXECUTABLE
 
   ifeq ($$($1_OUTPUT_DIR), )
@@ -211,24 +222,19 @@
     $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)/native/$$(MODULE)/$$($1_NAME)
   endif
 
   ifeq ($$($1_VERSIONINFO_RESOURCE), )
     $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)
-  else ifeq ($$($1_VERSIONINFO_RESOURCE), DISABLE)
-    $1_VERSIONINFO_RESOURCE :=
-  endif
-
-  ifeq ($$($1_RC_FLAGS), )
-    $1_RC_FLAGS :=  $(RC_FLAGS) \
-        -D "JDK_FNAME=$$($1_NAME).exe" \
-        -D "JDK_INTERNAL_NAME=$$($1_NAME)" \
-        -D "JDK_FTYPE=0x01L"
-  else ifeq ($$($1_RC_FLAGS), DISABLE)
-    $1_RC_FLAGS :=
   endif
 
-  $1_RC_FLAGS += $$($1_EXTRA_RC_FLAGS)
+  $1_RCFLAGS := $(JDK_RCFLAGS) \
+      -D"JDK_FILEDESC=$(JDK_RC_NAME) binary" \
+      -D"JDK_FNAME=$$($1_NAME).exe" \
+      -D"JDK_INTERNAL_NAME=$$($1_NAME)" \
+      -D"JDK_FTYPE=0x1L" \
+      -I$(TOPDIR)/src/java.base/windows/native/common \
+      $$($1_EXTRA_RCFLAGS)
 
   # Since we reuse the rule name ($1), all our arguments will pass through.
   # We lose in transparency, but gain in brevity in this call...
   $$(eval $$(call SetupNativeCompilation, $1))
 endef
diff a/make/common/NativeCompilation.gmk b/make/common/NativeCompilation.gmk
--- a/make/common/NativeCompilation.gmk
+++ b/make/common/NativeCompilation.gmk
@@ -455,11 +455,11 @@
 #   EXCLUDE_PATTERN exclude files matching any of these substrings
 #   EXTRA_FILES List of extra files not in any of the SRC dirs
 #   EXTRA_OBJECT_FILES List of extra object files to include when linking
 #   EXTRA_DEPS List of extra dependencies to be added to each compiled file
 #   VERSIONINFO_RESOURCE Input file for RC. Setting this implies that RC will be run
-#   RC_FLAGS flags for RC.
+#   RCFLAGS flags for RC.
 #   EMBED_MANIFEST if true, embed manifest on Windows.
 #   MAPFILE mapfile
 #   USE_MAPFILE_FOR_SYMBOLS if true and this is a STATIC_BUILD, just copy the
 #       mapfile for the output symbols file
 #   CC the compiler to use, default is $(CC)
@@ -858,27 +858,27 @@
       $1_RES_DEPS_FILE := $$($1_RES).d
       $1_RES_DEPS_TARGETS_FILE := $$($1_RES).d.targets
       -include $$($1_RES_DEPS_FILE)
       -include $$($1_RES_DEPS_TARGETS_FILE)
 
-      $1_RES_VARDEPS := $$($1_RC) $$($1_RC_FLAGS)
+      $1_RES_VARDEPS := $$($1_RC) $$($1_RCFLAGS)
       $1_RES_VARDEPS_FILE := $$(call DependOnVariable, $1_RES_VARDEPS, \
           $$($1_RES).vardeps)
 
       $$($1_RES): $$($1_VERSIONINFO_RESOURCE) $$($1_RES_VARDEPS_FILE)
 		$$(call LogInfo, Compiling resource $$(notdir $$($1_VERSIONINFO_RESOURCE)) (for $$($1_BASENAME)))
 		$$(call MakeDir, $$(@D) $$($1_OBJECT_DIR))
 		$$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \
-		    $$($1_RC) $$($1_RC_FLAGS) $$($1_SYSROOT_CFLAGS) $(CC_OUT_OPTION)$$@ \
+		    $$($1_RC) $$($1_RCFLAGS) $$($1_SYSROOT_CFLAGS) $(CC_OUT_OPTION)$$@ \
 		    $$($1_VERSIONINFO_RESOURCE) 2>&1 ))
                 # Windows RC compiler does not support -showIncludes, so we mis-use CL
                 # for this. Filter out RC specific arguments that are unknown to CL.
                 # For some unknown reason, in this case CL actually outputs the show
                 # includes to stderr so need to redirect it to hide the output from the
                 # main log.
 		$$(call ExecuteWithLog, $$($1_RES_DEPS_FILE).obj, \
-		    $$($1_CC) $$(filter-out -l%, $$($1_RC_FLAGS)) \
+		    $$($1_CC) $$(filter-out -l%, $$($1_RCFLAGS)) \
 		        $$($1_SYSROOT_CFLAGS) -showIncludes -nologo -TC \
 		        $(CC_OUT_OPTION)$$($1_RES_DEPS_FILE).obj -P -Fi$$($1_RES_DEPS_FILE).pp \
 		        $$($1_VERSIONINFO_RESOURCE)) 2>&1 \
 		    | $(TR) -d '\r' | $(GREP) -v -e "^Note: including file:" \
 		        -e "^$$(notdir $$($1_VERSIONINFO_RESOURCE))$$$$" || test "$$$$?" = "1" ; \
diff a/make/common/modules/LauncherCommon.gmk b/make/common/modules/LauncherCommon.gmk
--- a/make/common/modules/LauncherCommon.gmk
+++ b/make/common/modules/LauncherCommon.gmk
@@ -51,11 +51,10 @@
 
 ifeq ($(call isTargetOs, ios), true)
   LAUNCHER_CFLAGS += -I$(TOPDIR)/src/java.base/macosx/native/libjli
 fi
 
-GLOBAL_VERSION_INFO_RESOURCE := $(TOPDIR)/src/java.base/windows/native/common/version.rc
 MACOSX_PLIST_DIR := $(TOPDIR)/src/java.base/macosx/native/launcher
 JAVA_MANIFEST := $(TOPDIR)/src/java.base/windows/native/launcher/java.manifest
 
 ################################################################################
 # Build standard launcher.
@@ -74,11 +73,11 @@
 # EXTRA_JAVA_ARGS Processed into a -DEXTRA_JAVA_ARGS and is prepended
 #     before JAVA_ARGS to CFLAGS, primarily to allow long string literal
 #     compile time defines exceeding Visual Studio 2013 limitations.
 # CFLAGS   Additional CFLAGS
 # CFLAGS_windows   Additional CFLAGS_windows
-# EXTRA_RC_FLAGS   Additional EXTRA_RC_FLAGS
+# EXTRA_RCFLAGS   Additional EXTRA_RCFLAGS
 # MACOSX_PRIVILEGED   On macosx, allow to access other processes
 # OPTIMIZATION   Override default optimization level (LOW)
 # OUTPUT_DIR   Override default output directory
 # VERSION_INFO_RESOURCE   Override default Windows resource file
 SetupBuildLauncher = $(NamedParamsMacroTemplate)
@@ -163,11 +162,11 @@
       LIBS_aix := -ljli_static, \
       LIBS_windows := $$($1_WINDOWS_JLI_LIB) \
           $(SUPPORT_OUTPUTDIR)/native/java.base/libjava/java.lib, \
       OUTPUT_DIR := $$($1_OUTPUT_DIR), \
       VERSIONINFO_RESOURCE := $$($1_VERSION_INFO_RESOURCE), \
-      EXTRA_RC_FLAGS := $$($1_EXTRA_RC_FLAGS), \
+      EXTRA_RCFLAGS := $$($1_EXTRA_RCFLAGS), \
       MANIFEST := $(JAVA_MANIFEST), \
       MANIFEST_VERSION := $(VERSION_NUMBER_FOUR_POSITIONS), \
   ))
 
   $1 += $$(BUILD_LAUNCHER_$1)
diff a/make/common/modules/LibCommon.gmk b/make/common/modules/LibCommon.gmk
--- a/make/common/modules/LibCommon.gmk
+++ b/make/common/modules/LibCommon.gmk
@@ -25,12 +25,10 @@
 
 include JdkNativeCompilation.gmk
 
 ################################################################################
 
-GLOBAL_VERSION_INFO_RESOURCE := $(TOPDIR)/src/java.base/windows/native/common/version.rc
-
 # Absolute paths to lib files on windows for use in LIBS. Should figure out a more
 # elegant solution to this.
 WIN_JAVA_LIB := $(SUPPORT_OUTPUTDIR)/native/java.base/libjava/java.lib
 
 # Tell the compiler not to export any functions unless declared so in
diff a/make/data/symbols/java.base-F.sym.txt b/make/data/symbols/java.base-F.sym.txt
--- a/make/data/symbols/java.base-F.sym.txt
+++ b/make/data/symbols/java.base-F.sym.txt
@@ -180,10 +180,24 @@
 
 class name java/nio/channels/spi/SelectorProvider
 method name openSocketChannel descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/SocketChannel; thrownTypes java/io/IOException flags 1
 method name openServerSocketChannel descriptor (Ljava/net/ProtocolFamily;)Ljava/nio/channels/ServerSocketChannel; thrownTypes java/io/IOException flags 1
 
+class name java/security/KeyStore
+header extends java/lang/Object nestMembers java/security/KeyStore$Builder,java/security/KeyStore$TrustedCertificateEntry,java/security/KeyStore$SecretKeyEntry,java/security/KeyStore$PrivateKeyEntry,java/security/KeyStore$Entry,java/security/KeyStore$Entry$Attribute,java/security/KeyStore$CallbackHandlerProtection,java/security/KeyStore$PasswordProtection,java/security/KeyStore$ProtectionParameter,java/security/KeyStore$LoadStoreParameter flags 21
+innerclass innerClass java/security/KeyStore$LoadStoreParameter outerClass java/security/KeyStore innerClassName LoadStoreParameter flags 609
+innerclass innerClass java/security/KeyStore$ProtectionParameter outerClass java/security/KeyStore innerClassName ProtectionParameter flags 609
+innerclass innerClass java/security/KeyStore$Entry outerClass java/security/KeyStore innerClassName Entry flags 609
+innerclass innerClass java/security/Provider$Service outerClass java/security/Provider innerClassName Service flags 9
+innerclass innerClass java/security/KeyStore$Builder outerClass java/security/KeyStore innerClassName Builder flags 409
+innerclass innerClass java/security/KeyStore$TrustedCertificateEntry outerClass java/security/KeyStore innerClassName TrustedCertificateEntry flags 19
+innerclass innerClass java/security/KeyStore$SecretKeyEntry outerClass java/security/KeyStore innerClassName SecretKeyEntry flags 19
+innerclass innerClass java/security/KeyStore$PrivateKeyEntry outerClass java/security/KeyStore innerClassName PrivateKeyEntry flags 19
+innerclass innerClass java/security/KeyStore$CallbackHandlerProtection outerClass java/security/KeyStore innerClassName CallbackHandlerProtection flags 9
+innerclass innerClass java/security/KeyStore$PasswordProtection outerClass java/security/KeyStore innerClassName PasswordProtection flags 9
+innerclass innerClass java/security/KeyStore$Entry$Attribute outerClass java/security/KeyStore$Entry innerClassName Attribute flags 609
+
 class name java/security/interfaces/EdECKey
 header extends java/lang/Object flags 601
 method name getParams descriptor ()Ljava/security/spec/NamedParameterSpec; flags 401
 
 class name java/security/interfaces/EdECPrivateKey
diff a/make/hotspot/lib/CompileJvm.gmk b/make/hotspot/lib/CompileJvm.gmk
--- a/make/hotspot/lib/CompileJvm.gmk
+++ b/make/hotspot/lib/CompileJvm.gmk
@@ -122,17 +122,10 @@
   JVM_EXCLUDE_PATTERNS += x86_64
 else ifeq ($(call isTargetCpu, x86_64), true)
   JVM_EXCLUDE_PATTERNS += x86_32
 endif
 
-ifeq ($(call isTargetOs, windows), true)
-  ifeq ($(call isTargetCpuBits, 64), true)
-    RC_DESC := 64-Bit$(SPACE)
-  endif
-  JVM_RCFLAGS += -D"HS_FILEDESC=$(HOTSPOT_VM_DISTRO) $(RC_DESC)$(JVM_VARIANT) VM"
-endif
-
 JVM_OPTIMIZATION ?= HIGHEST_JVM
 
 # Need to set JVM_STRIPFLAGS to the default value from SPEC since the STRIPFLAGS
 # parameter to SetupNativeCompilation allows an empty value to override the
 # default.
@@ -166,12 +159,11 @@
     OBJECT_DIR := $(JVM_OUTPUTDIR)/objs, \
     MAPFILE := $(JVM_MAPFILE), \
     USE_MAPFILE_FOR_SYMBOLS := true, \
     STRIPFLAGS := $(JVM_STRIPFLAGS), \
     EMBED_MANIFEST := true, \
-    RC_FLAGS := $(JVM_RCFLAGS), \
-    VERSIONINFO_RESOURCE := $(TOPDIR)/src/hotspot/os/windows/version.rc, \
+    RC_FILEDESC := $(HOTSPOT_VM_DISTRO) $(OPENJDK_TARGET_CPU_BITS)-Bit $(JVM_VARIANT) VM, \
     PRECOMPILED_HEADER := $(JVM_PRECOMPILED_HEADER), \
     PRECOMPILED_HEADER_EXCLUDE := $(JVM_PRECOMPILED_HEADER_EXCLUDE), \
 ))
 
 # Always recompile abstract_vm_version.cpp if libjvm needs to be relinked. This ensures
diff a/make/modules/java.base/Launcher.gmk b/make/modules/java.base/Launcher.gmk
--- a/make/modules/java.base/Launcher.gmk
+++ b/make/modules/java.base/Launcher.gmk
@@ -28,26 +28,25 @@
 # Hook to include the corresponding custom file, if present.
 $(eval $(call IncludeCustomExtension, modules/java.base/Launcher.gmk))
 
 JAVA_VERSION_INFO_RESOURCE := $(TOPDIR)/src/java.base/windows/native/launcher/java.rc
 
-JAVA_RC_FLAGS += -I$(TOPDIR)/src/java.base/windows/native/common
-JAVA_RC_FLAGS += -I$(TOPDIR)/src/java.base/windows/native/launcher/icons
+JAVA_RCFLAGS ?= -I$(TOPDIR)/src/java.base/windows/native/launcher/icons
 
 ################################################################################
 
 $(eval $(call SetupBuildLauncher, java, \
     CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \
-    EXTRA_RC_FLAGS := $(JAVA_RC_FLAGS), \
+    EXTRA_RCFLAGS := $(JAVA_RCFLAGS), \
     VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \
     OPTIMIZATION := HIGH, \
 ))
 
 ifeq ($(call isTargetOs, windows), true)
   $(eval $(call SetupBuildLauncher, javaw, \
       CFLAGS := -DJAVAW -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \
-      EXTRA_RC_FLAGS := $(JAVA_RC_FLAGS), \
+      EXTRA_RCFLAGS := $(JAVA_RCFLAGS), \
       VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \
   ))
 endif
 
 $(eval $(call SetupBuildLauncher, keytool, \
diff a/make/modules/java.desktop/lib/Awt2dLibraries.gmk b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
--- a/make/modules/java.desktop/lib/Awt2dLibraries.gmk
+++ b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
@@ -114,11 +114,11 @@
   LIBAWT_CFLAGS += -EHsc -DUNICODE -D_UNICODE
   ifeq ($(call isTargetCpuBits, 64), true)
     LIBAWT_CFLAGS += -DMLIB_OS64BIT
   endif
 
-  LIBAWT_RC_FLAGS ?= -I $(TOPDIR)/src/java.base/windows/native/launcher/icons
+  LIBAWT_RCFLAGS ?= -I$(TOPDIR)/src/java.base/windows/native/launcher/icons
   LIBAWT_VERSIONINFO_RESOURCE := $(TOPDIR)/src/$(MODULE)/windows/native/libawt/windows/awt.rc
 endif
 
 ifeq ($(call isTargetOs, linux), true)
   # FIXME: This is probably not what we want to do, but keep it now for compatibility.
@@ -167,14 +167,11 @@
     LIBS_windows := kernel32.lib user32.lib gdi32.lib winspool.lib \
         imm32.lib ole32.lib uuid.lib shell32.lib \
         comdlg32.lib winmm.lib comctl32.lib shlwapi.lib \
         delayimp.lib jvm.lib $(WIN_JAVA_LIB) advapi32.lib, \
     VERSIONINFO_RESOURCE := $(LIBAWT_VERSIONINFO_RESOURCE), \
-    RC_FLAGS := $(RC_FLAGS) $(LIBAWT_RC_FLAGS) \
-        -D "JDK_FNAME=awt.dll" \
-        -D "JDK_INTERNAL_NAME=awt" \
-        -D "JDK_FTYPE=0x2L", \
+    EXTRA_RCFLAGS := $(LIBAWT_RCFLAGS), \
 ))
 
 $(BUILD_LIBAWT): $(call FindLib, java.base, java)
 
 ifeq ($(call isTargetOs, macosx), true)
diff a/make/modules/jdk.accessibility/Launcher.gmk b/make/modules/jdk.accessibility/Launcher.gmk
--- a/make/modules/jdk.accessibility/Launcher.gmk
+++ b/make/modules/jdk.accessibility/Launcher.gmk
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -23,77 +23,74 @@
 # questions.
 #
 
 include LauncherCommon.gmk
 
-################################################################################
-# jabswitch
-
 ifeq ($(call isTargetOs, windows), true)
 
-  JABSWITCH_SRC := $(TOPDIR)/src/jdk.accessibility/windows/native/jabswitch
-  ACCESSBRIDGE_SRC := $(TOPDIR)/src/jdk.accessibility/windows/native/common
+  ACCESSIBILITY_SRCDIR := $(TOPDIR)/src/jdk.accessibility/windows/native
+  TOOLS_CFLAGS := $(addprefix -I, \
+      $(ACCESSIBILITY_SRCDIR)/include/bridge \
+      $(ACCESSIBILITY_SRCDIR)/common \
+      $(ACCESSIBILITY_SRCDIR)/toolscommon)
+
+  ##############################################################################
+  # jabswitch
 
   $(eval $(call SetupJdkExecutable, BUILD_JABSWITCH, \
       NAME := jabswitch, \
-      SRC := $(JABSWITCH_SRC), \
+      SRC := $(ACCESSIBILITY_SRCDIR)/jabswitch, \
       INCLUDE_FILES := jabswitch.cpp, \
       CFLAGS := $(filter-out -Zc:wchar_t-, $(CFLAGS_JDKEXE)) -Zc:wchar_t \
           -analyze- -Od -Gd -D_WINDOWS \
           -D_UNICODE -DUNICODE -RTC1 -EHsc, \
       DISABLED_WARNINGS_microsoft := 4267 4996, \
       LDFLAGS := $(LDFLAGS_JDKEXE), \
       LIBS := advapi32.lib version.lib user32.lib, \
-      VERSIONINFO_RESOURCE := $(ACCESSBRIDGE_SRC)/AccessBridgeStatusWindow.rc, \
-      MANIFEST := $(JABSWITCH_SRC)/jabswitch.manifest, \
+      VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
+      MANIFEST := $(ACCESSIBILITY_SRCDIR)/jabswitch/jabswitch.manifest, \
       MANIFEST_VERSION := $(VERSION_NUMBER_FOUR_POSITIONS), \
   ))
 
   TARGETS += $(BUILD_JABSWITCH)
 
-################################################################################
-# jaccessinspector
-
-  TOPDIR := $(TOPDIR)/src/jdk.accessibility/windows/native
-  TOOLS_CFLAGS := $(addprefix -I, \
-      $(TOPDIR)/include/bridge \
-      $(TOPDIR)/common \
-      $(TOPDIR)/toolscommon)
+  ##############################################################################
+  # jaccessinspector
 
   define SetupInspector
   # Parameter 1 File name suffix
   # Parameter 2 ACCESSBRIDGE_ARCH_ -D suffix
 
     $$(eval $$(call SetupJdkExecutable, BUILD_JACCESSINSPECTOR$1, \
       NAME := jaccessinspector$1, \
-      SRC := $(TOPDIR)/jaccessinspector $(TOPDIR)/common \
-          $(TOPDIR)/toolscommon $(TOPDIR)/bridge, \
+      SRC := $(ACCESSIBILITY_SRCDIR)/jaccessinspector $(ACCESSIBILITY_SRCDIR)/common \
+          $(ACCESSIBILITY_SRCDIR)/toolscommon $(ACCESSIBILITY_SRCDIR)/bridge, \
       CFLAGS := $$(CFLAGS_JDKEXE) $(TOOLS_CFLAGS) -DACCESSBRIDGE_ARCH_$2 -EHsc, \
       LDFLAGS := $$(LDFLAGS_JDKEXE) -stack:655360, \
       LIBS := advapi32.lib user32.lib, \
-      VERSIONINFO_RESOURCE := $(TOPDIR)/jaccessinspector/jaccessinspectorWindow.rc, \
+      VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/jaccessinspector/jaccessinspectorWindow.rc, \
     ))
 
     TARGETS += $$(BUILD_JACCESSINSPECTOR$1)
 
   endef
 
-################################################################################
-# jaccesswalker
+  ##############################################################################
+  # jaccesswalker
 
   define SetupWalker
   # Parameter 1 File name suffix
   # Parameter 2 ACCESSBRIDGE_ARCH_ -D suffix
 
     $$(eval $$(call SetupJdkExecutable, BUILD_JACCESSWALKER$1, \
       NAME := jaccesswalker$1, \
-      SRC := $(TOPDIR)/jaccesswalker $(TOPDIR)/common \
-          $(TOPDIR)/toolscommon $(TOPDIR)/bridge, \
+      SRC := $(ACCESSIBILITY_SRCDIR)/jaccesswalker $(ACCESSIBILITY_SRCDIR)/common \
+          $(ACCESSIBILITY_SRCDIR)/toolscommon $(ACCESSIBILITY_SRCDIR)/bridge, \
       CFLAGS := $$(CFLAGS_JDKEXE) $(TOOLS_CFLAGS) -DACCESSBRIDGE_ARCH_$2 -EHsc, \
       LDFLAGS := $$(LDFLAGS_JDKEXE) -stack:655360, \
       LIBS := advapi32.lib comctl32.lib gdi32.lib user32.lib, \
-      VERSIONINFO_RESOURCE := $(TOPDIR)/jaccesswalker/jaccesswalkerWindow.rc, \
+      VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/jaccesswalker/jaccesswalkerWindow.rc, \
    ))
 
     TARGETS += $$(BUILD_JACCESSWALKER$1)
 
   endef
diff a/make/modules/jdk.accessibility/Lib.gmk b/make/modules/jdk.accessibility/Lib.gmk
--- a/make/modules/jdk.accessibility/Lib.gmk
+++ b/make/modules/jdk.accessibility/Lib.gmk
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -27,11 +27,11 @@
 
 ################################################################################
 
 ifeq ($(call isTargetOs, windows), true)
 
-  ROOT_SRCDIR := $(TOPDIR)/src/jdk.accessibility/windows/native
+  ACCESSIBILITY_SRCDIR := $(TOPDIR)/src/jdk.accessibility/windows/native
 
   define SetupJavaDLL
     # Parameter 1 Suffix
     # Parameter 2 ACCESSBRIDGE_ARCH_ suffix
 
@@ -50,11 +50,11 @@
         LDFLAGS := $(LDFLAGS_JDKLIB), \
         LIBS := kernel32.lib user32.lib gdi32.lib \
             winspool.lib comdlg32.lib advapi32.lib shell32.lib \
             $(SUPPORT_OUTPUTDIR)/native/java.desktop/libjawt/jawt.lib \
             ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib, \
-        VERSIONINFO_RESOURCE := $(ROOT_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
+        VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
     )
 
     $$(BUILD_JAVAACCESSBRIDGE$1): $(call FindStaticLib, java.desktop, jawt, /libjawt)
 
     TARGETS += $$(BUILD_JAVAACCESSBRIDGE$1)
@@ -73,15 +73,15 @@
             -DACCESSBRIDGE_ARCH_$2, \
         EXTRA_HEADER_DIRS := \
             include/bridge \
             java.base:include, \
         LDFLAGS := $(LDFLAGS_JDKLIB) \
-            -def:$(ROOT_SRCDIR)/libwindowsaccessbridge/WinAccessBridge.DEF, \
+            -def:$(ACCESSIBILITY_SRCDIR)/libwindowsaccessbridge/WinAccessBridge.DEF, \
         LIBS := kernel32.lib user32.lib gdi32.lib \
             winspool.lib comdlg32.lib advapi32.lib shell32.lib \
             ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib, \
-        VERSIONINFO_RESOURCE := $(ROOT_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
+        VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
     )
 
     TARGETS += $$(BUILD_WINDOWSACCESSBRIDGE$1)
 
   endef
@@ -91,11 +91,11 @@
     $(call SetupJdkLibrary, BUILD_ACCESSBRIDGESYSINFO, \
         NAME := jabsysinfo, \
         OPTIMIZATION := LOW, \
         CFLAGS := $(CFLAGS_JDKLIB), \
         LDFLAGS := $(LDFLAGS_JDKLIB), \
-        VERSIONINFO_RESOURCE := $(ROOT_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
+        VERSIONINFO_RESOURCE := $(ACCESSIBILITY_SRCDIR)/common/AccessBridgeStatusWindow.rc, \
     )
 
     TARGETS += $$(BUILD_ACCESSBRIDGESYSINFO)
 
   endef
diff a/make/test/BuildTestLib.gmk b/make/test/BuildTestLib.gmk
--- a/make/test/BuildTestLib.gmk
+++ b/make/test/BuildTestLib.gmk
@@ -41,16 +41,18 @@
     JAR := $(TEST_LIB_SUPPORT)/wb.jar, \
 ))
 
 TARGETS += $(BUILD_WB_JAR)
 
-# test-lib.jar will contain only hprof classes until JDK-8081381 is resolved
 $(eval $(call SetupJavaCompilation, BUILD_TEST_LIB_JAR, \
     TARGET_RELEASE := $(TARGET_RELEASE_NEWJDK_UPGRADED), \
-    SRC := $(TEST_LIB_SOURCE_DIR)/jdk/test/lib/hprof, \
+    SRC := $(TEST_LIB_SOURCE_DIR), \
+    EXCLUDES := jdk/test/lib/containers jdk/test/lib/security, \
     BIN := $(TEST_LIB_SUPPORT)/test-lib_classes, \
+    HEADERS := $(TEST_LIB_SUPPORT)/test-lib_headers, \
     JAR := $(TEST_LIB_SUPPORT)/test-lib.jar, \
+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast, \
 ))
 
 TARGETS += $(BUILD_TEST_LIB_JAR)
 
 ##########################################################################################
diff a/make/test/BuildTestLibNative.gmk b/make/test/BuildTestLibNative.gmk
--- /dev/null
+++ b/make/test/BuildTestLibNative.gmk
@@ -0,0 +1,83 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+################################################################################
+# This file builds the native component of testlib.
+# It also covers the test-image part, where the built files are copied to the
+# test image.
+################################################################################
+
+default: all
+
+include $(SPEC)
+include MakeBase.gmk
+include TestFilesCompilation.gmk
+
+################################################################################
+# Targets for building the native tests themselves.
+################################################################################
+
+BUILD_LIBTEST_NATIVE_SRC := $(TOPDIR)/test/lib
+
+BUILD_LIBTEST_OUTPUT_DIR := $(OUTPUTDIR)/support/test/lib/native
+
+BUILD_LIBTEST_IMAGE_DIR := $(TEST_IMAGE_DIR)/lib
+
+# This evaluation is expensive and should only be done if this target was
+# explicitly called.
+ifneq ($(filter build-test-lib-native, $(MAKECMDGOALS)), )
+  $(eval $(call SetupTestFilesCompilation, BUILD_LIBTEST_LIBRARIES, \
+      TYPE := LIBRARY, \
+      SOURCE_DIRS := $(BUILD_LIBTEST_NATIVE_SRC), \
+      OUTPUT_DIR := $(BUILD_LIBTEST_OUTPUT_DIR), \
+  ))
+endif
+
+build-test-lib-native: $(BUILD_LIBTEST_LIBRARIES)
+
+################################################################################
+# Targets for building test-image.
+################################################################################
+
+# Copy to testlib test image. We need it in both hotspot and jdk.
+$(eval $(call SetupCopyFiles, COPY_LIBTEST_NATIVE_TO_HOTSPOT, \
+    SRC := $(BUILD_LIBTEST_OUTPUT_DIR), \
+    DEST := $(TEST_IMAGE_DIR)/hotspot/jtreg/native, \
+    FILES := $(wildcard $(addprefix $(BUILD_LIBTEST_OUTPUT_DIR), /lib/*)), \
+    FLATTEN := true, \
+))
+
+$(eval $(call SetupCopyFiles, COPY_LIBTEST_NATIVE_TO_JDK, \
+    SRC := $(BUILD_LIBTEST_OUTPUT_DIR), \
+    DEST := $(TEST_IMAGE_DIR)/jdk/jtreg/native, \
+    FILES := $(wildcard $(addprefix $(BUILD_LIBTEST_OUTPUT_DIR), /lib/*)), \
+    FLATTEN := true, \
+))
+
+test-image-lib-native: $(COPY_LIBTEST_NATIVE_TO_HOTSPOT) $(COPY_LIBTEST_NATIVE_TO_JDK)
+
+all: build-test-lib-native
+
+.PHONY: default all build-test-lib-native test-image-lib-native
diff a/src/hotspot/cpu/aarch64/jvmciCodeInstaller_aarch64.cpp b/src/hotspot/cpu/aarch64/jvmciCodeInstaller_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/jvmciCodeInstaller_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/jvmciCodeInstaller_aarch64.cpp
@@ -19,11 +19,12 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-#include "jvmci/jvmciCodeInstaller.hpp"
+ #include "jvmci/jvmci.hpp"
+ #include "jvmci/jvmciCodeInstaller.hpp"
 #include "jvmci/jvmciRuntime.hpp"
 #include "jvmci/jvmciCompilerToVM.hpp"
 #include "jvmci/jvmciJavaClasses.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/handles.inline.hpp"
@@ -70,27 +71,27 @@
 void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {
   address pc = _instructions->start() + pc_offset;
   if (jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant)) {
     narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, constant, JVMCI_CHECK);
     MacroAssembler::patch_narrow_klass(pc, narrowOop);
-    TRACE_jvmci_3("relocating (narrow metaspace constant) at " PTR_FORMAT "/0x%x", p2i(pc), narrowOop);
+    JVMCI_event_3("relocating (narrow metaspace constant) at " PTR_FORMAT "/0x%x", p2i(pc), narrowOop);
   } else {
     NativeMovConstReg* move = nativeMovConstReg_at(pc);
     void* reference = record_metadata_reference(_instructions, pc, constant, JVMCI_CHECK);
     move->set_data((intptr_t) reference);
-    TRACE_jvmci_3("relocating (metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(reference));
+    JVMCI_event_3("relocating (metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(reference));
   }
 }
 
 void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {
   address pc = _instructions->start() + pc_offset;
   NativeInstruction* inst = nativeInstruction_at(pc);
   if (inst->is_adr_aligned() || inst->is_ldr_literal()
       || (NativeInstruction::maybe_cpool_ref(pc))) {
     address dest = _constants->start() + data_offset;
     _instructions->relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS));
-    TRACE_jvmci_3("relocating at " PTR_FORMAT " (+%d) with destination at %d", p2i(pc), pc_offset, data_offset);
+    JVMCI_event_3("relocating at " PTR_FORMAT " (+%d) with destination at %d", p2i(pc), pc_offset, data_offset);
   } else {
     JVMCI_ERROR("unknown load or move instruction at " PTR_FORMAT, p2i(pc));
   }
 }
 
@@ -113,11 +114,11 @@
     MacroAssembler::pd_patch_instruction_size((address)inst,
                                               (address)foreign_call_destination);
   } else {
     JVMCI_ERROR("unknown call or jump instruction at " PTR_FORMAT, p2i(pc));
   }
-  TRACE_jvmci_3("relocating (foreign call) at " PTR_FORMAT, p2i(inst));
+  JVMCI_event_3("relocating (foreign call) at " PTR_FORMAT, p2i(inst));
 }
 
 void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, JVMCIObject hotspot_method, jint pc_offset, JVMCI_TRAPS) {
 #ifdef ASSERT
   Method* method = NULL;
diff a/src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp b/src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp
--- a/src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp
+++ b/src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, 2108, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -100,13 +100,10 @@
 
   void wrote(int offset);
 
  public:
 
-  // unit test stuff
-  static void test() {}                 // override for testing
-
   inline friend NativeInstruction* nativeInstruction_at(address address);
 
   static bool is_adrp_at(address instr);
 
   static bool is_ldr_literal_at(address instr);
@@ -319,13 +316,10 @@
   }
 
   void  verify();
   void  print();
 
-  // unit test stuff
-  static void test() {}
-
   // Creation
   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
 };
 
@@ -395,13 +389,10 @@
   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }
 
   void verify();
   void print ();
 
-  // unit test stuff
-  static void test() {}
-
  private:
   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
 };
 
 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
@@ -430,12 +421,10 @@
 
  public:
   void verify();
   void print ();
 
-  // unit test stuff
-  static void test() {}
 };
 
 //   adrp    x16, #page
 //   add     x16, x16, #offset
 //   ldr     x16, [x16]
@@ -486,13 +475,10 @@
   // Creation
   inline friend NativeJump* nativeJump_at(address address);
 
   void verify();
 
-  // Unit testing stuff
-  static void test() {}
-
   // Insertion of native jump instruction
   static void insert(address code_pos, address entry);
   // MT-safe insertion of native jump at verified method entry
   static void check_verified_entry_alignment(address entry, address verified_entry);
   static void patch_verified_entry(address entry, address verified_entry, address dest);
diff a/src/hotspot/cpu/arm/nativeInst_arm_32.hpp b/src/hotspot/cpu/arm/nativeInst_arm_32.hpp
--- a/src/hotspot/cpu/arm/nativeInst_arm_32.hpp
+++ b/src/hotspot/cpu/arm/nativeInst_arm_32.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -143,13 +143,10 @@
   bool is_pc_rel()         const { return is_add_pc() || is_sub_pc(); }
   bool is_movw()           const { return (encoding() & 0x0ff00000) == 0x03000000; }
   bool is_movt()           const { return (encoding() & 0x0ff00000) == 0x03400000; }
   // c2 doesn't use fixed registers for safepoint poll address
   bool is_safepoint_poll() const { return (encoding() & 0xfff0ffff) == 0xe590c000; }
-  // For unit tests
-  static void test() {}
-
 };
 
 inline RawNativeInstruction* rawNativeInstruction_at(address address) {
   return (RawNativeInstruction*)address;
 }
diff a/src/hotspot/cpu/s390/nativeInst_s390.hpp b/src/hotspot/cpu/s390/nativeInst_s390.hpp
--- a/src/hotspot/cpu/s390/nativeInst_s390.hpp
+++ b/src/hotspot/cpu/s390/nativeInst_s390.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2016 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -135,13 +135,10 @@
 
  public:
 
   void verify();
 
-  // unit test stuff
-  static void test() {}                        // Override for testing.
-
   friend NativeInstruction* nativeInstruction_at(address address) {
     NativeInstruction* inst = (NativeInstruction*)address;
     #ifdef ASSERT
       inst->verify();
     #endif
@@ -272,13 +269,10 @@
   void set_destination_mt_safe(address dest);
 
   void verify_alignment() {} // Yet another real do nothing guy :)
   void verify();
 
-  // unit test stuff
-  static void test();
-
   // Creation.
   friend NativeCall* nativeCall_at(address instr) {
     NativeCall* call;
 
     // Make sure not to return garbage.
@@ -441,13 +435,10 @@
     return MacroAssembler::is_call_far_patchable_pcrelative_at(iaddr);
   }
 
   void verify();
 
-  // Unit tests
-  static void test();
-
   // Instantiates a NativeFarCall object starting at the given instruction
   // address and returns the NativeFarCall object.
   inline friend NativeFarCall* nativeFarCall_at(address instr) {
     NativeFarCall* call = (NativeFarCall*)instr;
 #ifdef ASSERT
@@ -498,13 +489,10 @@
   void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = NULL);
   void set_pcrel_data(intptr_t data, CompiledMethod *nm = NULL);
 
   void verify();
 
-  // unit test stuff
-  static void test();
-
   // Creation.
   friend NativeMovConstReg* nativeMovConstReg_at(address address) {
     NativeMovConstReg* test = (NativeMovConstReg*)address;
     #ifdef ASSERT
       test->verify();
@@ -616,13 +604,10 @@
     return b;
   }
 
   void verify();
 
-  // Unit testing stuff
-  static void test();
-
   // Insertion of native jump instruction.
   static void insert(address code_pos, address entry);
 
   // MT-safe insertion of native jump at verified method entry.
   static void check_verified_entry_alignment(address entry, address verified_entry) { }
diff a/src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp b/src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp
--- a/src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp
+++ b/src/hotspot/cpu/x86/jvmciCodeInstaller_x86.cpp
@@ -25,10 +25,11 @@
 #include "compiler/disassembler.hpp"
 #include "oops/oop.inline.hpp"
 #include "runtime/handles.inline.hpp"
 #include "runtime/javaCalls.hpp"
 #include "runtime/sharedRuntime.hpp"
+#include "jvmci/jvmci.hpp"
 #include "jvmci/jvmciEnv.hpp"
 #include "jvmci/jvmciCodeInstaller.hpp"
 #include "jvmci/jvmciJavaClasses.hpp"
 #include "jvmci/jvmciCompilerToVM.hpp"
 #include "jvmci/jvmciRuntime.hpp"
@@ -72,36 +73,36 @@
   if (jvmci_env()->get_HotSpotObjectConstantImpl_compressed(constant)) {
 #ifdef _LP64
     address operand = Assembler::locate_operand(pc, Assembler::narrow_oop_operand);
     int oop_index = _oop_recorder->find_index(value);
     _instructions->relocate(pc, oop_Relocation::spec(oop_index), Assembler::narrow_oop_operand);
-    TRACE_jvmci_3("relocating (narrow oop constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
+    JVMCI_event_3("relocating (narrow oop constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
 #else
     JVMCI_ERROR("compressed oop on 32bit");
 #endif
   } else {
     address operand = Assembler::locate_operand(pc, Assembler::imm_operand);
     *((jobject*) operand) = value;
     _instructions->relocate(pc, oop_Relocation::spec_for_immediate(), Assembler::imm_operand);
-    TRACE_jvmci_3("relocating (oop constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
+    JVMCI_event_3("relocating (oop constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
   }
 }
 
 void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, JVMCIObject constant, JVMCI_TRAPS) {
   address pc = _instructions->start() + pc_offset;
   if (jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant)) {
 #ifdef _LP64
     address operand = Assembler::locate_operand(pc, Assembler::narrow_oop_operand);
     *((narrowKlass*) operand) = record_narrow_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);
-    TRACE_jvmci_3("relocating (narrow metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
+    JVMCI_event_3("relocating (narrow metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
 #else
     JVMCI_ERROR("compressed Klass* on 32bit");
 #endif
   } else {
     address operand = Assembler::locate_operand(pc, Assembler::imm_operand);
     *((void**) operand) = record_metadata_reference(_instructions, operand, constant, JVMCI_CHECK);
-    TRACE_jvmci_3("relocating (metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
+    JVMCI_event_3("relocating (metaspace constant) at " PTR_FORMAT "/" PTR_FORMAT, p2i(pc), p2i(operand));
   }
 }
 
 void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {
   address pc = _instructions->start() + pc_offset;
@@ -113,11 +114,11 @@
   long disp = dest - next_instruction;
   assert(disp == (jint) disp, "disp doesn't fit in 32 bits");
   *((jint*) operand) = (jint) disp;
 
   _instructions->relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS), Assembler::disp32_operand);
-  TRACE_jvmci_3("relocating at " PTR_FORMAT "/" PTR_FORMAT " with destination at " PTR_FORMAT " (%d)", p2i(pc), p2i(operand), p2i(dest), data_offset);
+  JVMCI_event_3("relocating at " PTR_FORMAT "/" PTR_FORMAT " with destination at " PTR_FORMAT " (%d)", p2i(pc), p2i(operand), p2i(dest), data_offset);
 }
 
 void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS) {
   address pc = (address) inst;
   if (inst->is_call()) {
@@ -141,11 +142,11 @@
     _instructions->relocate(pc, runtime_call_Relocation::spec(), Assembler::call32_operand);
   } else {
     JVMCI_ERROR("unsupported relocation for foreign call");
   }
 
-  TRACE_jvmci_3("relocating (foreign call)  at " PTR_FORMAT, p2i(inst));
+  JVMCI_event_3("relocating (foreign call)  at " PTR_FORMAT, p2i(inst));
 }
 
 void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &, JVMCIObject hotspot_method, jint pc_offset, JVMCI_TRAPS) {
 #ifdef ASSERT
   Method* method = NULL;
diff a/src/hotspot/cpu/x86/nativeInst_x86.hpp b/src/hotspot/cpu/x86/nativeInst_x86.hpp
--- a/src/hotspot/cpu/x86/nativeInst_x86.hpp
+++ b/src/hotspot/cpu/x86/nativeInst_x86.hpp
@@ -92,13 +92,10 @@
   // cache invalidation belongs, generically:
   void wrote(int offset);
 
  public:
 
-  // unit test stuff
-  static void test() {}                 // override for testing
-
   inline friend NativeInstruction* nativeInstruction_at(address address);
 };
 
 inline NativeInstruction* nativeInstruction_at(address address) {
   NativeInstruction* inst = (NativeInstruction*)address;
@@ -275,13 +272,10 @@
   void  set_data(intptr_t x)                { set_ptr_at(data_offset, x); }
 
   void  verify();
   void  print();
 
-  // unit test stuff
-  static void test() {}
-
   // Creation
   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
 };
 
@@ -391,13 +385,10 @@
   }
 
   void verify();
   void print ();
 
-  // unit test stuff
-  static void test() {}
-
  private:
   int patch_offset() const;
   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
 };
 
@@ -430,13 +421,10 @@
   };
 
   void verify();
   void print ();
 
-  // unit test stuff
-  static void test() {}
-
  private:
   friend NativeLoadAddress* nativeLoadAddress_at (address address) {
     NativeLoadAddress* test = (NativeLoadAddress*)(address - instruction_offset);
     #ifdef ASSERT
       test->verify();
@@ -534,13 +522,10 @@
   // Creation
   inline friend NativeJump* nativeJump_at(address address);
 
   void verify();
 
-  // Unit testing stuff
-  static void test() {}
-
   // Insertion of native jump instruction
   static void insert(address code_pos, address entry);
   // MT-safe insertion of native jump at verified method entry
   static void check_verified_entry_alignment(address entry, address verified_entry);
   static void patch_verified_entry(address entry, address verified_entry, address dest);
@@ -562,13 +547,10 @@
   // Creation
   inline friend NativeFarJump* nativeFarJump_at(address address);
 
   void verify();
 
-  // Unit testing stuff
-  static void test() {}
-
 };
 
 inline NativeFarJump* nativeFarJump_at(address address) {
   NativeFarJump* jump = (NativeFarJump*)(address);
 #ifdef ASSERT
diff a/src/hotspot/os/windows/version.rc b/src/hotspot/os/windows/version.rc
--- a/src/hotspot/os/windows/version.rc
+++ /dev/null
@@ -1,72 +0,0 @@
-//
-// Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
-// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-//
-// This code is free software; you can redistribute it and/or modify it
-// under the terms of the GNU General Public License version 2 only, as
-// published by the Free Software Foundation.
-//
-// This code is distributed in the hope that it will be useful, but WITHOUT
-// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// version 2 for more details (a copy is included in the LICENSE file that
-// accompanied this code).
-//
-// You should have received a copy of the GNU General Public License version
-// 2 along with this work; if not, write to the Free Software Foundation,
-// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-//
-// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-// or visit www.oracle.com if you need additional information or have any
-// questions.
-//
-//
-
-#include "winresrc.h"
-
-// Need 2 defines so macro argument to XSTR will get expanded before quoting.
-#define XSTR(x) STR(x)
-#define STR(x)  #x
-
-LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    HS_FVER
- PRODUCTVERSION HS_FVER
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- // FILEOS 0x4 is Win32, 0x40004 is Win32 NT only
- FILEOS 0x4L
- // FILETYPE should be 0x1 for .exe and 0x2 for .dll
- FILETYPE 0x2L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "000004b0"
-        BEGIN
-            VALUE "CompanyName",      XSTR(HS_COMPANY)        "\0"
-            VALUE "FileDescription",  XSTR(HS_FILEDESC)       "\0"
-            VALUE "FileVersion",      XSTR(HS_VER)            "\0"
-            VALUE "Full Version",     XSTR(HS_VERSION_STRING) "\0"
-            VALUE "InternalName",     XSTR(HS_INTERNAL_NAME)  "\0"
-            VALUE "LegalCopyright",   XSTR(HS_COPYRIGHT)      "\0"
-            VALUE "OriginalFilename", XSTR(HS_FNAME)          "\0"
-            VALUE "ProductName",      XSTR(HS_NAME)           "\0"
-            VALUE "ProductVersion",   XSTR(HS_VER)            "\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x0, 1200
-    END
-END
diff a/src/hotspot/share/classfile/packageEntry.hpp b/src/hotspot/share/classfile/packageEntry.hpp
--- a/src/hotspot/share/classfile/packageEntry.hpp
+++ b/src/hotspot/share/classfile/packageEntry.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,11 @@
 #ifndef SHARE_CLASSFILE_PACKAGEENTRY_HPP
 #define SHARE_CLASSFILE_PACKAGEENTRY_HPP
 
 #include "classfile/moduleEntry.hpp"
 #include "oops/symbol.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/hashtable.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/ostream.hpp"
 #if INCLUDE_JFR
@@ -112,17 +113,20 @@
   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
 
   // Initial size of a package entry's list of qualified exports.
   enum {QUAL_EXP_SIZE = 43};
 
+  // a bit map indicating which CDS classpath entries have defined classes in this package.
+  volatile int _defined_by_cds_in_class_path;
 public:
   void init() {
     _module = NULL;
     _export_flags = 0;
     _classpath_index = -1;
     _must_walk_exports = false;
     _qualified_exports = NULL;
+    _defined_by_cds_in_class_path = 0;
   }
 
   // package name
   Symbol*            name() const               { return literal(); }
 
@@ -210,10 +214,28 @@
   void purge_qualified_exports();
   void delete_qualified_exports();
 
   void print(outputStream* st = tty);
   void verify();
+
+  static int max_index_for_defined_in_class_path() {
+    return sizeof(int) * BitsPerByte;
+  }
+
+  bool is_defined_by_cds_in_class_path(int idx) const {
+    assert(idx < max_index_for_defined_in_class_path(), "sanity");
+    return((Atomic::load(&_defined_by_cds_in_class_path) & ((int)1 << idx)) != 0);
+  }
+  void set_defined_by_cds_in_class_path(int idx) {
+    assert(idx < max_index_for_defined_in_class_path(), "sanity");
+    int old_val = 0;
+    int new_val = 0;
+    do {
+      old_val = Atomic::load(&_defined_by_cds_in_class_path);
+      new_val = old_val | ((int)1 << idx);
+    } while (Atomic::cmpxchg(&_defined_by_cds_in_class_path, old_val, new_val) != old_val);
+  }
 };
 
 // The PackageEntryTable is a Hashtable containing a list of all packages defined
 // by a particular class loader.  Each package is represented as a PackageEntry node.
 // The PackageEntryTable's lookup is lock free.
diff a/src/hotspot/share/classfile/systemDictionaryShared.cpp b/src/hotspot/share/classfile/systemDictionaryShared.cpp
--- a/src/hotspot/share/classfile/systemDictionaryShared.cpp
+++ b/src/hotspot/share/classfile/systemDictionaryShared.cpp
@@ -870,11 +870,23 @@
       //
       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
       Handle url = get_shared_jar_url(index, CHECK_(pd));
-      define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
+      int index_offset = index - ClassLoaderExt::app_class_paths_start_index();
+      if (index_offset < PackageEntry::max_index_for_defined_in_class_path()) {
+        if (pkg_entry == NULL || !pkg_entry->is_defined_by_cds_in_class_path(index_offset)) {
+          // define_shared_package only needs to be called once for each package in a jar specified
+          // in the shared class path.
+          define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
+          if (pkg_entry != NULL) {
+            pkg_entry->set_defined_by_cds_in_class_path(index_offset);
+          }
+        }
+      } else {
+        define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
+      }
       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
     }
   }
   return pd;
 }
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -1199,11 +1199,11 @@
       }
 
       // Don't allow blocking compilation requests if we are in JVMCIRuntime::shutdown
       // to avoid deadlock between compiler thread(s) and threads run at shutdown
       // such as the DestroyJavaVM thread.
-      if (JVMCI::shutdown_called()) {
+      if (JVMCI::in_shutdown()) {
         blocking = false;
       }
     }
 #endif // INCLUDE_JVMCI
 
@@ -2148,20 +2148,26 @@
     JVMCICompiler* jvmci = (JVMCICompiler*) comp;
 
     TraceTime t1("compilation", &time);
     EventCompilation event;
     JVMCICompileState compile_state(task);
+    JVMCIRuntime *runtime = NULL;
 
-    // Skip redefined methods
-    if (compile_state.target_method_is_old()) {
+    if (JVMCI::in_shutdown()) {
+      failure_reason = "in JVMCI shutdown";
+      retry_message = "not retryable";
+      compilable = ciEnv::MethodCompilable_never;
+    } else if (compile_state.target_method_is_old()) {
+      // Skip redefined methods
       failure_reason = "redefined method";
       retry_message = "not retryable";
       compilable = ciEnv::MethodCompilable_never;
     } else {
       JVMCIEnv env(thread, &compile_state, __FILE__, __LINE__);
       methodHandle method(thread, target_handle);
-      env.runtime()->compile_method(&env, jvmci, method, osr_bci);
+      runtime = env.runtime();
+      runtime->compile_method(&env, jvmci, method, osr_bci);
 
       failure_reason = compile_state.failure_reason();
       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();
       if (!compile_state.retryable()) {
         retry_message = "not retryable";
diff a/src/hotspot/share/gc/g1/g1Analytics.cpp b/src/hotspot/share/gc/g1/g1Analytics.cpp
--- a/src/hotspot/share/gc/g1/g1Analytics.cpp
+++ b/src/hotspot/share/gc/g1/g1Analytics.cpp
@@ -222,15 +222,11 @@
 void G1Analytics::report_rs_length(double rs_length) {
   _rs_length_seq->add(rs_length);
 }
 
 double G1Analytics::predict_alloc_rate_ms() const {
-  if (enough_samples_available(_alloc_rate_ms_seq)) {
-    return predict_zero_bounded(_alloc_rate_ms_seq);
-  } else {
-    return 0.0;
-  }
+  return predict_zero_bounded(_alloc_rate_ms_seq);
 }
 
 double G1Analytics::predict_concurrent_refine_rate_ms() const {
   return predict_zero_bounded(_concurrent_refine_rate_ms_seq);
 }
diff a/src/hotspot/share/gc/g1/g1Policy.cpp b/src/hotspot/share/gc/g1/g1Policy.cpp
--- a/src/hotspot/share/gc/g1/g1Policy.cpp
+++ b/src/hotspot/share/gc/g1/g1Policy.cpp
@@ -44,11 +44,10 @@
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/shared/concurrentGCBreakpoints.hpp"
 #include "gc/shared/gcPolicyCounters.hpp"
 #include "logging/log.hpp"
 #include "runtime/arguments.hpp"
-#include "runtime/globals.hpp"
 #include "runtime/java.hpp"
 #include "runtime/mutexLocker.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/pair.hpp"
@@ -60,12 +59,12 @@
   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
   _ihop_control(create_ihop_control(&_predictor)),
   _policy_counters(new GCPolicyCounters("GarbageFirst", 1, 2)),
   _full_collection_start_sec(0.0),
   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
-  _young_list_desired_length(0),
   _young_list_target_length(0),
+  _young_list_fixed_length(0),
   _young_list_max_length(0),
   _eden_surv_rate_group(new G1SurvRateGroup()),
   _survivor_surv_rate_group(new G1SurvRateGroup()),
   _reserve_factor((double) G1ReservePercent / 100.0),
   _reserve_regions(0),
@@ -106,15 +105,18 @@
   _g1h = g1h;
   _collection_set = collection_set;
 
   assert(Heap_lock->owned_by_self(), "Locking discipline.");
 
+  if (!use_adaptive_young_list_length()) {
+    _young_list_fixed_length = _young_gen_sizer->min_desired_young_length();
+  }
   _young_gen_sizer->adjust_max_new_size(_g1h->max_expandable_regions());
 
   _free_regions_at_end_of_collection = _g1h->num_free_regions();
 
-  update_young_length_bounds();
+  update_young_list_max_and_target_length();
   // We may immediately start allocating regions and placing them on the
   // collection set list. Initialize the per-collection set info
   _collection_set->start_incremental_building();
 }
 
@@ -185,258 +187,162 @@
   _young_gen_sizer->heap_size_changed(new_number_of_regions);
 
   _ihop_control->update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
 }
 
-uint G1Policy::calculate_desired_eden_length_by_mmu() const {
-  // One could argue that any useful eden length to keep any MMU would be 1, but
-  // in theory this is possible. Other constraints enforce a minimum eden of 1
-  // anyway.
+uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {
   uint desired_min_length = 0;
   if (use_adaptive_young_list_length()) {
-    double now_sec = os::elapsedTime();
-    double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;
-    double alloc_rate_ms = _analytics->predict_alloc_rate_ms();
-    desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
+    if (_analytics->num_alloc_rate_ms() > 3) {
+      double now_sec = os::elapsedTime();
+      double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;
+      double alloc_rate_ms = _analytics->predict_alloc_rate_ms();
+      desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
+    } else {
+      // otherwise we don't have enough info to make the prediction
+    }
   }
-  return desired_min_length;
-}
-
-void G1Policy::update_young_length_bounds() {
-  update_young_length_bounds(_analytics->predict_rs_length());
-}
-
-void G1Policy::update_young_length_bounds(size_t rs_length) {
-  _young_list_desired_length = calculate_young_desired_length(rs_length);
-  _young_list_target_length = calculate_young_target_length(_young_list_desired_length);
-  _young_list_max_length = calculate_young_max_length(_young_list_target_length);
-
-  log_debug(gc,ergo,heap)("Young list lengths: desired: %u, target: %u, max: %u",
-                          _young_list_desired_length,
-                          _young_list_target_length,
-                          _young_list_max_length);
-}
-
-// Calculates desired young gen length. It is calculated from:
-//
-// - sizer min/max bounds on young gen
-// - pause time goal for whole young gen evacuation
-// - MMU goal influencing eden to make GCs spaced apart.
-// - a minimum one eden region length.
-//
-// We may enter with already allocated eden and survivor regions, that may be
-// higher than the maximum, or the above goals may result in a desired value
-// smaller than are already allocated.
-// The main reason is revising young length, with our without the GCLocker being
-// active.
-//
-uint G1Policy::calculate_young_desired_length(size_t rs_length) const {
-  uint min_young_length_by_sizer = _young_gen_sizer->min_desired_young_length();
-  uint max_young_length_by_sizer = _young_gen_sizer->max_desired_young_length();
-
-  assert(min_young_length_by_sizer >= 1, "invariant");
-  assert(max_young_length_by_sizer >= min_young_length_by_sizer, "invariant");
-
-  // Absolute minimum eden length.
-  // Enforcing a minimum eden length helps at startup when the predictors are not
-  // yet trained on the application to avoid unnecessary (but very short) full gcs
-  // on very small (initial) heaps.
-  uint const MinDesiredEdenLength = 1;
+  desired_min_length += base_min_length;
+  // make sure we don't go below any user-defined minimum bound
+  return MAX2(_young_gen_sizer->min_desired_young_length(), desired_min_length);
+}
+
+uint G1Policy::calculate_young_list_desired_max_length() const {
+  // Here, we might want to also take into account any additional
+  // constraints (i.e., user-defined minimum bound). Currently, we
+  // effectively don't set this bound.
+  return _young_gen_sizer->max_desired_young_length();
+}
+
+uint G1Policy::update_young_list_max_and_target_length() {
+  return update_young_list_max_and_target_length(_analytics->predict_rs_length());
+}
+
+uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {
+  uint unbounded_target_length = update_young_list_target_length(rs_length);
+  update_max_gc_locker_expansion();
+  return unbounded_target_length;
+}
+
+uint G1Policy::update_young_list_target_length(size_t rs_length) {
+  YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);
+  _young_list_target_length = young_lengths.first;
+
+  return young_lengths.second;
+}
+
+G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {
+  YoungTargetLengths result;
 
   // Calculate the absolute and desired min bounds first.
 
-  // This is how many survivor regions we already have.
-  const uint survivor_length = _g1h->survivor_regions_count();
-  // Size of the already allocated young gen.
-  const uint allocated_young_length = _g1h->young_regions_count();
-  // This is the absolute minimum young length that we can return. Ensure that we
-  // don't go below any user-defined minimum bound; but we might have already
-  // allocated more than that for reasons. In this case, use that.
-  uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);
-  // Calculate the absolute max bounds. After evac failure or when revising the
-  // young length we might have exceeded absolute min length or absolute_max_length,
-  // so adjust the result accordingly.
-  uint absolute_max_young_length = MAX2(max_young_length_by_sizer, absolute_min_young_length);
-
-  uint desired_eden_length_by_mmu = 0;
-  uint desired_eden_length_by_pause = 0;
-  uint desired_eden_length_before_mixed = 0;
-
-  uint desired_young_length = 0;
-  if (use_adaptive_young_list_length()) {
-    desired_eden_length_by_mmu = calculate_desired_eden_length_by_mmu();
+  // This is how many young regions we already have (currently: the survivors).
+  const uint base_min_length = _g1h->survivor_regions_count();
+  uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);
+  // This is the absolute minimum young length. Ensure that we
+  // will at least have one eden region available for allocation.
+  uint absolute_min_length = base_min_length + MAX2(_g1h->eden_regions_count(), (uint)1);
+  // If we shrank the young list target it should not shrink below the current size.
+  desired_min_length = MAX2(desired_min_length, absolute_min_length);
+  // Calculate the absolute and desired max bounds.
 
-    const size_t pending_cards = _analytics->predict_pending_cards();
-    double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);
+  uint desired_max_length = calculate_young_list_desired_max_length();
 
-    if (!next_gc_should_be_mixed(NULL, NULL)) {
-      desired_eden_length_by_pause =
-        calculate_desired_eden_length_by_pause(survivor_base_time_ms,
-                                               absolute_min_young_length - survivor_length,
-                                               absolute_max_young_length - survivor_length);
+  uint young_list_target_length = 0;
+  if (use_adaptive_young_list_length()) {
+    if (collector_state()->in_young_only_phase()) {
+      young_list_target_length =
+                        calculate_young_list_target_length(rs_length,
+                                                           base_min_length,
+                                                           desired_min_length,
+                                                           desired_max_length);
     } else {
-      desired_eden_length_before_mixed =
-        calculate_desired_eden_length_before_mixed(survivor_base_time_ms,
-                                                   absolute_min_young_length - survivor_length,
-                                                   absolute_max_young_length - survivor_length);
+      // Don't calculate anything and let the code below bound it to
+      // the desired_min_length, i.e., do the next GC as soon as
+      // possible to maximize how many old regions we can add to it.
     }
-    // Above either sets desired_eden_length_by_pause or desired_eden_length_before_mixed,
-    // the other is zero. Use the one that has been set below.
-    uint desired_eden_length = MAX2(desired_eden_length_by_pause,
-                                    desired_eden_length_before_mixed);
-
-    // Finally incorporate MMU concerns; assume that it overrides the pause time
-    // goal, as the default value has been chosen to effectively disable it.
-    // Also request at least one eden region, see above for reasons.
-    desired_eden_length = MAX3(desired_eden_length,
-                               desired_eden_length_by_mmu,
-                               MinDesiredEdenLength);
-
-    desired_young_length = desired_eden_length + survivor_length;
   } else {
     // The user asked for a fixed young gen so we'll fix the young gen
     // whether the next GC is young or mixed.
-    desired_young_length = min_young_length_by_sizer;
+    young_list_target_length = _young_list_fixed_length;
   }
-  // Clamp to absolute min/max after we determined desired lengths.
-  desired_young_length = clamp(desired_young_length, absolute_min_young_length, absolute_max_young_length);
-
-  log_trace(gc, ergo, heap)("Young desired length %u "
-                            "survivor length %u "
-                            "allocated young length %u "
-                            "absolute min young length %u "
-                            "absolute max young length %u "
-                            "desired eden length by mmu %u "
-                            "desired eden length by pause %u "
-                            "desired eden length before mixed %u"
-                            "desired eden length by default %u",
-                            desired_young_length, survivor_length,
-                            allocated_young_length, absolute_min_young_length,
-                            absolute_max_young_length, desired_eden_length_by_mmu,
-                            desired_eden_length_by_pause,
-                            desired_eden_length_before_mixed,
-                            MinDesiredEdenLength);
-
-  assert(desired_young_length >= allocated_young_length, "must be");
-  return desired_young_length;
-}
-
-// Limit the desired (wished) young length by current free regions. If the request
-// can be satisfied without using up reserve regions, do so, otherwise eat into
-// the reserve, giving away at most what the heap sizer allows.
-uint G1Policy::calculate_young_target_length(uint desired_young_length) const {
-  uint allocated_young_length = _g1h->young_regions_count();
-
-  uint receiving_additional_eden;
-  if (allocated_young_length >= desired_young_length) {
-    // Already used up all we actually want (may happen as G1 revises the
-    // young list length concurrently, or caused by gclocker). Do not allow more,
-    // potentially resulting in GC.
-    receiving_additional_eden = 0;
-    log_trace(gc, ergo, heap)("Young target length: Already used up desired young %u allocated %u",
-                              desired_young_length,
-                              allocated_young_length);
-  } else {
-    // Now look at how many free regions are there currently, and the heap reserve.
-    // We will try our best not to "eat" into the reserve as long as we can. If we
-    // do, we at most eat the sizer's minimum regions into the reserve or half the
-    // reserve rounded up (if possible; this is an arbitrary value).
-
-    uint max_to_eat_into_reserve = MIN2(_young_gen_sizer->min_desired_young_length(),
-                                        (_reserve_regions + 1) / 2);
-
-    log_trace(gc, ergo, heap)("Young target length: Common "
-                              "free regions at end of collection %u "
-                              "desired young length %u "
-                              "reserve region %u "
-                              "max to eat into reserve %u",
-                              _free_regions_at_end_of_collection,
-                              desired_young_length,
-                              _reserve_regions,
-                              max_to_eat_into_reserve);
-
-    if (_free_regions_at_end_of_collection <= _reserve_regions) {
-      // Fully eat (or already eating) into the reserve, hand back at most absolute_min_length regions.
-      uint receiving_young = MIN3(_free_regions_at_end_of_collection,
-                                  desired_young_length,
-                                  max_to_eat_into_reserve);
-      // We could already have allocated more regions than what we could get
-      // above.
-      receiving_additional_eden = allocated_young_length < receiving_young ?
-                                  receiving_young - allocated_young_length : 0;
-
-      log_trace(gc, ergo, heap)("Young target length: Fully eat into reserve "
-                                "receiving young %u receiving additional eden %u",
-                                receiving_young,
-                                receiving_additional_eden);
-    } else if (_free_regions_at_end_of_collection < (desired_young_length + _reserve_regions)) {
-      // Partially eat into the reserve, at most max_to_eat_into_reserve regions.
-      uint free_outside_reserve = _free_regions_at_end_of_collection - _reserve_regions;
-      assert(free_outside_reserve < desired_young_length,
-             "must be %u %u",
-             free_outside_reserve, desired_young_length);
-
-      uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,
-                                           max_to_eat_into_reserve);
-      uint receiving_young = free_outside_reserve + receiving_within_reserve;
-      // Again, we could have already allocated more than we could get.
-      receiving_additional_eden = allocated_young_length < receiving_young ?
-                                  receiving_young - allocated_young_length : 0;
-
-      log_trace(gc, ergo, heap)("Young target length: Partially eat into reserve "
-                                "free outside reserve %u "
-                                "receiving within reserve %u "
-                                "receiving young %u "
-                                "receiving additional eden %u",
-                                free_outside_reserve, receiving_within_reserve,
-                                receiving_young, receiving_additional_eden);
-    } else {
-      // No need to use the reserve.
-      receiving_additional_eden = desired_young_length - allocated_young_length;
-      log_trace(gc, ergo, heap)("Young target length: No need to use reserve "
-                                "receiving additional eden %u",
-                                receiving_additional_eden);
-    }
+
+  result.second = young_list_target_length;
+
+  // We will try our best not to "eat" into the reserve.
+  uint absolute_max_length = 0;
+  if (_free_regions_at_end_of_collection > _reserve_regions) {
+    absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;
+  }
+  if (desired_max_length > absolute_max_length) {
+    desired_max_length = absolute_max_length;
   }
 
-  uint target_young_length = allocated_young_length + receiving_additional_eden;
+  // Make sure we don't go over the desired max length, nor under the
+  // desired min length. In case they clash, desired_min_length wins
+  // which is why that test is second.
+  if (young_list_target_length > desired_max_length) {
+    young_list_target_length = desired_max_length;
+  }
+  if (young_list_target_length < desired_min_length) {
+    young_list_target_length = desired_min_length;
+  }
 
-  assert(target_young_length >= allocated_young_length, "must be");
+  assert(young_list_target_length > base_min_length,
+         "we should be able to allocate at least one eden region");
+  assert(young_list_target_length >= absolute_min_length, "post-condition");
 
-  log_trace(gc, ergo, heap)("Young target length: "
-                            "young target length %u "
-                            "allocated young length %u "
-                            "received additional eden %u",
-                            target_young_length, allocated_young_length,
-                            receiving_additional_eden);
-  return target_young_length;
+  result.first = young_list_target_length;
+  return result;
 }
 
-uint G1Policy::calculate_desired_eden_length_by_pause(double base_time_ms,
-                                                      uint min_eden_length,
-                                                      uint max_eden_length) const {
+uint G1Policy::calculate_young_list_target_length(size_t rs_length,
+                                                  uint base_min_length,
+                                                  uint desired_min_length,
+                                                  uint desired_max_length) const {
   assert(use_adaptive_young_list_length(), "pre-condition");
+  assert(collector_state()->in_young_only_phase(), "only call this for young GCs");
+
+  // In case some edge-condition makes the desired max length too small...
+  if (desired_max_length <= desired_min_length) {
+    return desired_min_length;
+  }
 
-  assert(min_eden_length <= max_eden_length, "must be %u %u", min_eden_length, max_eden_length);
+  // We'll adjust min_young_length and max_young_length not to include
+  // the already allocated young regions (i.e., so they reflect the
+  // min and max eden regions we'll allocate). The base_min_length
+  // will be reflected in the predictions by the
+  // survivor_regions_evac_time prediction.
+  assert(desired_min_length > base_min_length, "invariant");
+  uint min_young_length = desired_min_length - base_min_length;
+  assert(desired_max_length > base_min_length, "invariant");
+  uint max_young_length = desired_max_length - base_min_length;
+
+  const double target_pause_time_ms = _mmu_tracker->max_gc_time() * 1000.0;
+  const size_t pending_cards = _analytics->predict_pending_cards();
+  const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);
+  const uint available_free_regions = _free_regions_at_end_of_collection;
+  const uint base_free_regions =
+    available_free_regions > _reserve_regions ? available_free_regions - _reserve_regions : 0;
 
   // Here, we will make sure that the shortest young length that
   // makes sense fits within the target pause time.
 
   G1YoungLengthPredictor p(base_time_ms,
-                           _free_regions_at_end_of_collection,
-                           _mmu_tracker->max_gc_time() * 1000.0,
+                           base_free_regions,
+                           target_pause_time_ms,
                            this);
-  if (p.will_fit(min_eden_length)) {
+  if (p.will_fit(min_young_length)) {
     // The shortest young length will fit into the target pause time;
     // we'll now check whether the absolute maximum number of young
     // regions will fit in the target pause time. If not, we'll do
     // a binary search between min_young_length and max_young_length.
-    if (p.will_fit(max_eden_length)) {
+    if (p.will_fit(max_young_length)) {
       // The maximum young length will fit into the target pause time.
       // We are done so set min young length to the maximum length (as
       // the result is assumed to be returned in min_young_length).
-      min_eden_length = max_eden_length;
+      min_young_length = max_young_length;
     } else {
       // The maximum possible number of young regions will not fit within
       // the target pause time so we'll search for the optimal
       // length. The loop invariants are:
       //
@@ -449,60 +355,41 @@
       // the middle value between min_young_length and
       // max_young_length fits into the target pause time. If it
       // does, it becomes the new min. If it doesn't, it becomes
       // the new max. This way we maintain the loop invariants.
 
-      assert(min_eden_length < max_eden_length, "invariant");
-      uint diff = (max_eden_length - min_eden_length) / 2;
+      assert(min_young_length < max_young_length, "invariant");
+      uint diff = (max_young_length - min_young_length) / 2;
       while (diff > 0) {
-        uint eden_length = min_eden_length + diff;
-        if (p.will_fit(eden_length)) {
-          min_eden_length = eden_length;
+        uint young_length = min_young_length + diff;
+        if (p.will_fit(young_length)) {
+          min_young_length = young_length;
         } else {
-          max_eden_length = eden_length;
+          max_young_length = young_length;
         }
-        assert(min_eden_length <  max_eden_length, "invariant");
-        diff = (max_eden_length - min_eden_length) / 2;
+        assert(min_young_length <  max_young_length, "invariant");
+        diff = (max_young_length - min_young_length) / 2;
       }
       // The results is min_young_length which, according to the
       // loop invariants, should fit within the target pause time.
 
       // These are the post-conditions of the binary search above:
-      assert(min_eden_length < max_eden_length,
-             "otherwise we should have discovered that max_eden_length "
+      assert(min_young_length < max_young_length,
+             "otherwise we should have discovered that max_young_length "
              "fits into the pause target and not done the binary search");
-      assert(p.will_fit(min_eden_length),
-             "min_eden_length, the result of the binary search, should "
+      assert(p.will_fit(min_young_length),
+             "min_young_length, the result of the binary search, should "
              "fit into the pause target");
-      assert(!p.will_fit(min_eden_length + 1),
-             "min_eden_length, the result of the binary search, should be "
+      assert(!p.will_fit(min_young_length + 1),
+             "min_young_length, the result of the binary search, should be "
              "optimal, so no larger length should fit into the pause target");
     }
   } else {
     // Even the minimum length doesn't fit into the pause time
     // target, return it as the result nevertheless.
   }
-  return min_eden_length;
-}
-
-uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,
-                                                          uint min_eden_length,
-                                                          uint max_eden_length) const {
-  G1CollectionSetCandidates* candidates = _collection_set->candidates();
-
-  uint min_old_regions_end = MIN2(candidates->cur_idx() + calc_min_old_cset_length(), candidates->num_regions());
-  double predicted_region_evac_time_ms = survivor_base_time_ms;
-  for (uint i = candidates->cur_idx(); i < min_old_regions_end; i++) {
-    HeapRegion* r = candidates->at(i);
-    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);
-  }
-  uint desired_eden_length_by_min_cset_length =
-     calculate_desired_eden_length_by_pause(predicted_region_evac_time_ms,
-                                            min_eden_length,
-                                            max_eden_length);
-
-  return desired_eden_length_by_min_cset_length;
+  return base_min_length + min_young_length;
 }
 
 double G1Policy::predict_survivor_regions_evac_time() const {
   double survivor_regions_evac_time = 0.0;
   const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();
@@ -519,11 +406,12 @@
 
   if (rs_length > _rs_length_prediction) {
     // add 10% to avoid having to recalculate often
     size_t rs_length_prediction = rs_length * 1100 / 1000;
     update_rs_length_prediction(rs_length_prediction);
-    update_young_length_bounds(rs_length_prediction);
+
+    update_young_list_max_and_target_length(rs_length_prediction);
   }
 }
 
 void G1Policy::update_rs_length_prediction() {
   update_rs_length_prediction(_analytics->predict_rs_length());
@@ -567,11 +455,11 @@
   _eden_surv_rate_group->start_adding_regions();
   // also call this on any additional surv rate groups
 
   _free_regions_at_end_of_collection = _g1h->num_free_regions();
   _survivor_surv_rate_group->reset();
-  update_young_length_bounds();
+  update_young_list_max_and_target_length();
   update_rs_length_prediction();
 
   _old_gen_alloc_tracker.reset_after_full_gc();
 
   record_pause(FullGC, _full_collection_start_sec, end_sec);
@@ -897,15 +785,20 @@
   update_rs_length_prediction();
 
   // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
   // that in this case we are not running in a "normal" operating mode.
   if (_g1h->gc_cause() != GCCause::_g1_periodic_collection) {
-    update_young_length_bounds();
+    // IHOP control wants to know the expected young gen length if it were not
+    // restrained by the heap reserve. Using the actual length would make the
+    // prediction too small and the limit the young gen every time we get to the
+    // predicted target occupancy.
+    size_t last_unrestrained_young_length = update_young_list_max_and_target_length();
 
     _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
     update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
                            _old_gen_alloc_tracker.last_cycle_old_bytes(),
+                           last_unrestrained_young_length * HeapRegion::GrainBytes,
                            this_pause_was_young_only);
 
     _ihop_control->send_trace_event(_g1h->gc_tracer_stw());
   } else {
     // Any garbage collection triggered as periodic collection resets the time-to-mixed
@@ -951,10 +844,11 @@
   }
 }
 
 void G1Policy::update_ihop_prediction(double mutator_time_s,
                                       size_t mutator_alloc_bytes,
+                                      size_t young_gen_size,
                                       bool this_gc_was_young_only) {
   // Always try to update IHOP prediction. Even evacuation failures give information
   // about e.g. whether to start IHOP earlier next time.
 
   // Avoid using really small application times that might create samples with
@@ -978,15 +872,10 @@
   // As an approximation for the young gc promotion rates during marking we use
   // all of them. In many applications there are only a few if any young gcs during
   // marking, which makes any prediction useless. This increases the accuracy of the
   // prediction.
   if (this_gc_was_young_only && mutator_time_s > min_valid_time) {
-    // IHOP control wants to know the expected young gen length if it were not
-    // restrained by the heap reserve. Using the actual length would make the
-    // prediction too small and the limit the young gen every time we get to the
-    // predicted target occupancy.
-    size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;
     _ihop_control->update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
     report = true;
   }
 
   if (report) {
@@ -1089,24 +978,23 @@
 
 void G1Policy::print_age_table() {
   _survivors_age_table.print_age_table(_tenuring_threshold);
 }
 
-uint G1Policy::calculate_young_max_length(uint target_young_length) const {
+void G1Policy::update_max_gc_locker_expansion() {
   uint expansion_region_num = 0;
   if (GCLockerEdenExpansionPercent > 0) {
     double perc = (double) GCLockerEdenExpansionPercent / 100.0;
     double expansion_region_num_d = perc * (double) _young_list_target_length;
     // We use ceiling so that if expansion_region_num_d is > 0.0 (but
     // less than 1.0) we'll get 1.
     expansion_region_num = (uint) ceil(expansion_region_num_d);
   } else {
     assert(expansion_region_num == 0, "sanity");
   }
-  uint max_length = target_young_length + expansion_region_num;
-  assert(target_young_length <= max_length, "post-condition");
-  return max_length;
+  _young_list_max_length = _young_list_target_length + expansion_region_num;
+  assert(_young_list_target_length <= _young_list_max_length, "post-condition");
 }
 
 // Calculates survivor space parameters.
 void G1Policy::update_survivors_policy() {
   double max_survivor_regions_d =
@@ -1311,32 +1199,26 @@
 
 bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
                                        const char* false_action_str) const {
   G1CollectionSetCandidates* candidates = _collection_set->candidates();
 
-  if (candidates == NULL || candidates->is_empty()) {
-    if (false_action_str != NULL) {
-      log_debug(gc, ergo)("%s (candidate old regions not available)", false_action_str);
-    }
+  if (candidates->is_empty()) {
+    log_debug(gc, ergo)("%s (candidate old regions not available)", false_action_str);
     return false;
   }
 
   // Is the amount of uncollected reclaimable space above G1HeapWastePercent?
   size_t reclaimable_bytes = candidates->remaining_reclaimable_bytes();
   double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
   double threshold = (double) G1HeapWastePercent;
   if (reclaimable_percent <= threshold) {
-    if (false_action_str != NULL) {
-      log_debug(gc, ergo)("%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: " SIZE_FORMAT " (%1.2f) threshold: " UINTX_FORMAT,
-                          false_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
-    }
+    log_debug(gc, ergo)("%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: " SIZE_FORMAT " (%1.2f) threshold: " UINTX_FORMAT,
+                        false_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
     return false;
   }
-  if (true_action_str != NULL) {
-    log_debug(gc, ergo)("%s (candidate old regions available). candidate old regions: %u reclaimable: " SIZE_FORMAT " (%1.2f) threshold: " UINTX_FORMAT,
-                        true_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
-  }
+  log_debug(gc, ergo)("%s (candidate old regions available). candidate old regions: %u reclaimable: " SIZE_FORMAT " (%1.2f) threshold: " UINTX_FORMAT,
+                      true_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
   return true;
 }
 
 uint G1Policy::calc_min_old_cset_length() const {
   // The min old CSet region bound is based on the maximum desired
diff a/src/hotspot/share/gc/g1/g1Policy.hpp b/src/hotspot/share/gc/g1/g1Policy.hpp
--- a/src/hotspot/share/gc/g1/g1Policy.hpp
+++ b/src/hotspot/share/gc/g1/g1Policy.hpp
@@ -58,10 +58,11 @@
 
   static G1IHOPControl* create_ihop_control(const G1Predictions* predictor);
   // Update the IHOP control with necessary statistics.
   void update_ihop_prediction(double mutator_time_s,
                               size_t mutator_alloc_bytes,
+                              size_t young_gen_size,
                               bool this_gc_was_young_only);
   void report_ihop_statistics();
 
   G1Predictions _predictor;
   G1Analytics* _analytics;
@@ -73,12 +74,12 @@
 
   double _full_collection_start_sec;
 
   jlong _collection_pause_end_millis;
 
-  uint _young_list_desired_length;
   uint _young_list_target_length;
+  uint _young_list_fixed_length;
 
   // The max number of regions we can extend the eden by while the GC
   // locker is active. This should be >= _young_list_target_length;
   uint _young_list_max_length;
 
@@ -167,14 +168,10 @@
     return _mmu_tracker->max_gc_time() * 1000.0;
   }
 
 private:
   G1CollectionSet* _collection_set;
-
-  bool next_gc_should_be_mixed(const char* true_action_str,
-                               const char* false_action_str) const;
-
   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
   double other_time_ms(double pause_time_ms) const;
 
   double young_other_time_ms() const;
   double non_young_other_time_ms() const;
@@ -190,42 +187,48 @@
   // This set of variables tracks the collector efficiency, in order to
   // determine whether we should initiate a new marking.
   double _mark_remark_start_sec;
   double _mark_cleanup_start_sec;
 
-  // Updates the internal young gen maximum and target and desired lengths.
-  // If no rs_length parameter is passed, predict the RS length using the
-  // prediction model, otherwise use the given rs_length as the prediction.
-  void update_young_length_bounds();
-  void update_young_length_bounds(size_t rs_length);
-
-  // Calculate and return the minimum desired eden length based on the MMU target.
-  uint calculate_desired_eden_length_by_mmu() const;
-
-  // Calculate and return the desired eden length that can fit into the pause time goal.
-  // The parameters are: rs_length represents the prediction of how large the
-  // young RSet lengths will be, min_eden_length and max_eden_length are the bounds
-  // (inclusive) within eden can grow.
-  uint calculate_desired_eden_length_by_pause(double base_time_ms,
-                                              uint min_eden_length,
-                                              uint max_eden_length) const;
-
-  // Calculates the desired eden length before mixed gc so that after adding the
-  // minimum amount of old gen regions from the collection set, the eden fits into
-  // the pause time goal.
-  uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,
-                                                  uint min_eden_length,
-                                                  uint max_eden_length) const;
-
-  // Calculate desired young length based on current situation without taking actually
-  // available free regions into account.
-  uint calculate_young_desired_length(size_t rs_length) const;
-  // Limit the given desired young length to available free regions.
-  uint calculate_young_target_length(uint desired_young_length) const;
-  // The GCLocker might cause us to need more regions than the target. Calculate
-  // the maximum number of regions to use in that case.
-  uint calculate_young_max_length(uint target_young_length) const;
+  // Updates the internal young list maximum and target lengths. Returns the
+  // unbounded young list target length. If no rs_length parameter is passed,
+  // predict the RS length using the prediction model, otherwise use the
+  // given rs_length as the prediction.
+  uint update_young_list_max_and_target_length();
+  uint update_young_list_max_and_target_length(size_t rs_length);
+
+  // Update the young list target length either by setting it to the
+  // desired fixed value or by calculating it using G1's pause
+  // prediction model.
+  // Returns the unbounded young list target length.
+  uint update_young_list_target_length(size_t rs_length);
+
+  // Calculate and return the minimum desired young list target
+  // length. This is the minimum desired young list length according
+  // to the user's inputs.
+  uint calculate_young_list_desired_min_length(uint base_min_length) const;
+
+  // Calculate and return the maximum desired young list target
+  // length. This is the maximum desired young list length according
+  // to the user's inputs.
+  uint calculate_young_list_desired_max_length() const;
+
+  // Calculate and return the maximum young list target length that
+  // can fit into the pause time goal. The parameters are: rs_length
+  // represent the prediction of how large the young RSet lengths will
+  // be, base_min_length is the already existing number of regions in
+  // the young list, min_length and max_length are the desired min and
+  // max young list length according to the user's inputs.
+  uint calculate_young_list_target_length(size_t rs_length,
+                                          uint base_min_length,
+                                          uint desired_min_length,
+                                          uint desired_max_length) const;
+
+  // Result of the bounded_young_list_target_length() method, containing both the
+  // bounded as well as the unbounded young list target lengths in this order.
+  typedef Pair<uint, uint, StackObj> YoungTargetLengths;
+  YoungTargetLengths young_list_target_lengths(size_t rs_length) const;
 
   void update_rs_length_prediction();
   void update_rs_length_prediction(size_t prediction);
 
   size_t predict_bytes_to_copy(HeapRegion* hr) const;
@@ -330,10 +333,13 @@
   void record_concurrent_mark_cleanup_start();
   void record_concurrent_mark_cleanup_end();
 
   void print_phases();
 
+  bool next_gc_should_be_mixed(const char* true_action_str,
+                               const char* false_action_str) const;
+
   // Calculate and return the number of initial and optional old gen regions from
   // the given collection set candidates and the remaining time.
   void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
                                             double time_remaining_ms,
                                             uint& num_initial_regions,
@@ -366,11 +372,10 @@
   // marking thread has completed its work during the previous cycle,
   // it will set in_initial_mark_gc() to so that the pause does
   // the initial-mark work and start a marking cycle.
   void decide_on_conc_mark_initiation();
 
-  uint young_list_desired_length() const { return _young_list_desired_length; }
   size_t young_list_target_length() const { return _young_list_target_length; }
 
   bool should_allocate_mutator_region() const;
 
   bool can_expand_young_list() const;
@@ -427,10 +432,12 @@
     _survivors_age_table.merge(age_table);
   }
 
   void print_age_table();
 
+  void update_max_gc_locker_expansion();
+
   void update_survivors_policy();
 
   virtual bool force_upgrade_to_full() {
     return false;
   }
diff a/src/hotspot/share/gc/shenandoah/shenandoahInitLogger.cpp b/src/hotspot/share/gc/shenandoah/shenandoahInitLogger.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahInitLogger.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahInitLogger.cpp
@@ -21,11 +21,11 @@
  * questions.
  *
  */
 
 #include "precompiled.hpp"
-#include "gc/shenandoah/shenandoahHeap.hpp"
+#include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahHeapRegion.hpp"
 #include "gc/shenandoah/shenandoahInitLogger.hpp"
 #include "gc/shenandoah/heuristics/shenandoahHeuristics.hpp"
 #include "gc/shenandoah/mode/shenandoahMode.hpp"
 #include "logging/log.hpp"
diff a/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp b/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.hpp
@@ -91,13 +91,15 @@
 class ShenandoahSerialWeakRoots {
 private:
   JVMTI_ONLY(ShenandoahJVMTIWeakRoot _jvmti_weak_roots;)
   JFR_ONLY(ShenandoahJFRWeakRoot     _jfr_weak_roots;)
 public:
-  ShenandoahSerialWeakRoots(ShenandoahPhaseTimings::Phase phase) :
-  JVMTI_ONLY(_jvmti_weak_roots(phase))
-  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase)) {};
+  ShenandoahSerialWeakRoots(ShenandoahPhaseTimings::Phase phase)
+  JVMTI_ONLY(: _jvmti_weak_roots(phase))
+  JFR_ONLY(NOT_JVMTI(:) JVMTI_ONLY(COMMA) _jfr_weak_roots(phase))
+  {};
+
   void weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id);
   void weak_oops_do(OopClosure* cl, uint worker_id);
 };
 
 template <bool CONCURRENT>
diff a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
--- a/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
+++ b/src/hotspot/share/jvmci/jniAccessMark.inline.hpp
@@ -33,16 +33,16 @@
 // This performs a ThreadToNativeFromVM transition so that the VM
 // will not be blocked if the call takes a long time (e.g., due
 // to a GC in the shared library).
 class JNIAccessMark : public StackObj {
  private:
-  ThreadToNativeFromVM ttnfv;
-  HandleMark hm;
+  ThreadToNativeFromVM _ttnfv;
+  HandleMark _hm;
   JNIEnv* _env;
  public:
-  inline JNIAccessMark(JVMCIEnv* jvmci_env) :
-    ttnfv(JavaThread::current()), hm(JavaThread::current()) {
+  inline JNIAccessMark(JVMCIEnv* jvmci_env, JavaThread* thread=JavaThread::current()) :
+    _ttnfv(thread), _hm(thread) {
     _env = jvmci_env->_env;
   }
   JNIEnv* env() const { return _env; }
   JNIEnv* operator () () const { return _env; }
 };
diff a/src/hotspot/share/jvmci/jvmci.cpp b/src/hotspot/share/jvmci/jvmci.cpp
--- a/src/hotspot/share/jvmci/jvmci.cpp
+++ b/src/hotspot/share/jvmci/jvmci.cpp
@@ -22,21 +22,25 @@
  */
 
 #include "precompiled.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "gc/shared/collectedHeap.hpp"
-#include "gc/shared/oopStorage.hpp"
-#include "gc/shared/oopStorageSet.hpp"
 #include "jvmci/jvmci.hpp"
 #include "jvmci/jvmciJavaClasses.hpp"
 #include "jvmci/jvmciRuntime.hpp"
-#include "jvmci/metadataHandleBlock.hpp"
+#include "jvmci/metadataHandles.hpp"
+#include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 
-MetadataHandleBlock* JVMCI::_metadata_handles = NULL;
 JVMCIRuntime* JVMCI::_compiler_runtime = NULL;
 JVMCIRuntime* JVMCI::_java_runtime = NULL;
+volatile bool JVMCI::_is_initialized = false;
+void* JVMCI::_shared_library_handle = NULL;
+char* JVMCI::_shared_library_path = NULL;
+volatile bool JVMCI::_in_shutdown = false;
+StringEventLog* JVMCI::_events = NULL;
+StringEventLog* JVMCI::_verbose_events = NULL;
 
 void jvmci_vmStructs_init() NOT_DEBUG_RETURN;
 
 bool JVMCI::can_initialize_JVMCI() {
   // Initializing JVMCI requires the module system to be initialized past phase 3.
@@ -48,10 +52,44 @@
   }
   assert(Universe::is_module_initialized(), "must be");
   return true;
 }
 
+void* JVMCI::get_shared_library(char*& path, bool load) {
+  void* sl_handle = _shared_library_handle;
+  if (sl_handle != NULL || !load) {
+    path = _shared_library_path;
+    return sl_handle;
+  }
+  assert(JVMCI_lock->owner() == Thread::current(), "must be");
+  path = NULL;
+  if (_shared_library_handle == NULL) {
+    char path[JVM_MAXPATHLEN];
+    char ebuf[1024];
+    if (JVMCILibPath != NULL) {
+      if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {
+        vm_exit_during_initialization("Unable to locate JVMCI shared library in path specified by -XX:JVMCILibPath value", JVMCILibPath);
+      }
+    } else {
+      if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {
+        vm_exit_during_initialization("Unable to create path to JVMCI shared library");
+      }
+    }
+
+    void* handle = os::dll_load(path, ebuf, sizeof ebuf);
+    if (handle == NULL) {
+      vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);
+    }
+    _shared_library_handle = handle;
+    _shared_library_path = strdup(path);
+
+    JVMCI_event_1("loaded JVMCI shared library from %s", path);
+  }
+  path = _shared_library_path;
+  return _shared_library_handle;
+}
+
 void JVMCI::initialize_compiler(TRAPS) {
   if (JVMCILibDumpJNIConfig) {
     JNIJVMCI::initialize_ids(NULL);
     ShouldNotReachHere();
   }
@@ -59,95 +97,107 @@
   JVMCI::compiler_runtime()->call_getCompiler(CHECK);
 }
 
 void JVMCI::initialize_globals() {
   jvmci_vmStructs_init();
-  _metadata_handles = MetadataHandleBlock::allocate_block();
+  if (LogEvents) {
+    if (JVMCIEventLogLevel > 0) {
+      _events = new StringEventLog("JVMCI Events", "jvmci");
+      if (JVMCIEventLogLevel > 1) {
+        int count = LogEventsBufferEntries;
+        for (int i = 1; i < JVMCIEventLogLevel && i < max_EventLog_level; i++) {
+          // Expand event buffer by 10x for each level above 1
+          count = count * 10;
+        }
+        _verbose_events = new StringEventLog("Verbose JVMCI Events", "verbose-jvmci", count);
+      }
+    }
+  }
   if (UseJVMCINativeLibrary) {
     // There are two runtimes.
-    _compiler_runtime = new JVMCIRuntime();
-    _java_runtime = new JVMCIRuntime();
+    _compiler_runtime = new JVMCIRuntime(0);
+    _java_runtime = new JVMCIRuntime(-1);
   } else {
     // There is only a single runtime
-    _java_runtime = _compiler_runtime = new JVMCIRuntime();
+    _java_runtime = _compiler_runtime = new JVMCIRuntime(0);
   }
 }
 
-// Handles to objects in the Hotspot heap.
-static OopStorage* object_handles() {
-  return OopStorageSet::vm_global();
-}
 
-jobject JVMCI::make_global(const Handle& obj) {
-  assert(!Universe::heap()->is_gc_active(), "can't extend the root set during GC");
-  assert(oopDesc::is_oop(obj()), "not an oop");
-  oop* ptr = object_handles()->allocate();
-  jobject res = NULL;
-  if (ptr != NULL) {
-    assert(*ptr == NULL, "invariant");
-    NativeAccess<>::oop_store(ptr, obj());
-    res = reinterpret_cast<jobject>(ptr);
-  } else {
-    vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,
-                          "Cannot create JVMCI oop handle");
+void JVMCI::metadata_do(void f(Metadata*)) {
+  if (_java_runtime != NULL) {
+    _java_runtime->_metadata_handles->metadata_do(f);
+  }
+  if (_compiler_runtime != NULL && _compiler_runtime != _java_runtime) {
+    _compiler_runtime->_metadata_handles->metadata_do(f);
   }
-  return res;
-}
-
-void JVMCI::destroy_global(jobject handle) {
-  // Assert before nulling out, for better debugging.
-  assert(is_global_handle(handle), "precondition");
-  oop* oop_ptr = reinterpret_cast<oop*>(handle);
-  NativeAccess<>::oop_store(oop_ptr, (oop)NULL);
-  object_handles()->release(oop_ptr);
 }
 
-bool JVMCI::is_global_handle(jobject handle) {
-  const oop* ptr = reinterpret_cast<oop*>(handle);
-  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
+void JVMCI::do_unloading(bool unloading_occurred) {
+  if (unloading_occurred) {
+    if (_java_runtime != NULL) {
+      _java_runtime->_metadata_handles->do_unloading();
+    }
+    if (_compiler_runtime != NULL && _compiler_runtime != _java_runtime) {
+      _compiler_runtime->_metadata_handles->do_unloading();
+    }
+  }
 }
 
-jmetadata JVMCI::allocate_handle(const methodHandle& handle) {
-  assert(_metadata_handles != NULL, "uninitialized");
-  MutexLocker ml(JVMCI_lock);
-  return _metadata_handles->allocate_handle(handle);
+bool JVMCI::is_compiler_initialized() {
+  return _is_initialized;
 }
 
-jmetadata JVMCI::allocate_handle(const constantPoolHandle& handle) {
-  assert(_metadata_handles != NULL, "uninitialized");
-  MutexLocker ml(JVMCI_lock);
-  return _metadata_handles->allocate_handle(handle);
+void JVMCI::shutdown() {
+  ResourceMark rm;
+  {
+    MutexLocker locker(JVMCI_lock);
+    _in_shutdown = true;
+    JVMCI_event_1("shutting down JVMCI");
+  }
+  JVMCIRuntime* java_runtime = _java_runtime;
+  if (java_runtime != compiler_runtime()) {
+    java_runtime->shutdown();
+  }
+  if (compiler_runtime() != NULL) {
+    compiler_runtime()->shutdown();
+  }
 }
 
-void JVMCI::release_handle(jmetadata handle) {
-  MutexLocker ml(JVMCI_lock);
-  _metadata_handles->chain_free_list(handle);
+bool JVMCI::in_shutdown() {
+  return _in_shutdown;
 }
 
-void JVMCI::metadata_do(void f(Metadata*)) {
-  if (_metadata_handles != NULL) {
-    _metadata_handles->metadata_do(f);
+void JVMCI::vlog(int level, const char* format, va_list ap) {
+  if (LogEvents && JVMCIEventLogLevel >= level) {
+    StringEventLog* events = level == 1 ? _events : _verbose_events;
+    guarantee(events != NULL, "JVMCI event log not yet initialized");
+    Thread* thread = Thread::current_or_null_safe();
+    events->logv(thread, format, ap);
   }
 }
 
-void JVMCI::do_unloading(bool unloading_occurred) {
-  if (_metadata_handles != NULL && unloading_occurred) {
-    _metadata_handles->do_unloading();
+void JVMCI::vtrace(int level, const char* format, va_list ap) {
+  if (JVMCITraceLevel >= level) {
+    Thread* thread = Thread::current_or_null_safe();
+    if (thread != NULL) {
+      ResourceMark rm;
+      tty->print("JVMCITrace-%d[%s]:%*c", level, thread->name(), level, ' ');
+    } else {
+      tty->print("JVMCITrace-%d[?]:%*c", level, level, ' ');
+    }
+    tty->vprint_cr(format, ap);
   }
 }
 
-bool JVMCI::is_compiler_initialized() {
-  return compiler_runtime()->is_HotSpotJVMCIRuntime_initialized();
+#define LOG_TRACE(level) { va_list ap; \
+  va_start(ap, format); vlog(level, format, ap); va_end(ap); \
+  va_start(ap, format); vtrace(level, format, ap); va_end(ap); \
 }
 
-void JVMCI::shutdown() {
-  if (compiler_runtime() != NULL) {
-    compiler_runtime()->shutdown();
-  }
-}
+void JVMCI::event(int level, const char* format, ...) LOG_TRACE(level)
+void JVMCI::event1(const char* format, ...) LOG_TRACE(1)
+void JVMCI::event2(const char* format, ...) LOG_TRACE(2)
+void JVMCI::event3(const char* format, ...) LOG_TRACE(3)
+void JVMCI::event4(const char* format, ...) LOG_TRACE(4)
 
-bool JVMCI::shutdown_called() {
-  if (compiler_runtime() != NULL) {
-    return compiler_runtime()->shutdown_called();
-  }
-  return false;
-}
+#undef LOG_TRACE
diff a/src/hotspot/share/jvmci/jvmci.hpp b/src/hotspot/share/jvmci/jvmci.hpp
--- a/src/hotspot/share/jvmci/jvmci.hpp
+++ b/src/hotspot/share/jvmci/jvmci.hpp
@@ -23,10 +23,11 @@
 
 #ifndef SHARE_JVMCI_JVMCI_HPP
 #define SHARE_JVMCI_JVMCI_HPP
 
 #include "compiler/compilerDefinitions.hpp"
+#include "utilities/events.hpp"
 #include "utilities/exceptions.hpp"
 
 class BoolObjectClosure;
 class constantPoolHandle;
 class JavaThread;
@@ -43,36 +44,62 @@
 class JVMCI : public AllStatic {
   friend class JVMCIRuntime;
   friend class JVMCIEnv;
 
  private:
-  // Handles to Metadata objects.
-  static MetadataHandleBlock* _metadata_handles;
-
   // Access to the HotSpotJVMCIRuntime used by the CompileBroker.
   static JVMCIRuntime* _compiler_runtime;
 
-  // Access to the HotSpotJVMCIRuntime used by Java code running on the
-  // HotSpot heap. It will be the same as _compiler_runtime if
-  // UseJVMCINativeLibrary is false
+  // True when at least one JVMCIRuntime::initialize_HotSpotJVMCIRuntime()
+  // execution has completed successfully.
+  static volatile bool _is_initialized;
+
+  // Handle created when loading the JVMCI shared library with os::dll_load.
+  // Must hold JVMCI_lock when initializing.
+  static void* _shared_library_handle;
+
+  // Argument to os::dll_load when loading JVMCI shared library
+  static char* _shared_library_path;
+
+  // Records whether JVMCI::shutdown has been called.
+  static volatile bool _in_shutdown;
+
+  // Access to the HotSpot heap based JVMCIRuntime
   static JVMCIRuntime* _java_runtime;
 
+  // JVMCI event log (shows up in hs_err crash logs).
+  static StringEventLog* _events;
+  static StringEventLog* _verbose_events;
+  enum {
+    max_EventLog_level = 4
+  };
+
+  // Gets the Thread* value for the current thread or NULL if it's not available.
+  static Thread* current_thread_or_null();
+
  public:
   enum CodeInstallResult {
      ok,
      dependencies_failed,
      cache_full,
      code_too_large
   };
 
+  // Gets the handle to the loaded JVMCI shared library, loading it
+  // first if not yet loaded and `load` is true. The path from
+  // which the library is loaded is returned in `path`. If
+  // `load` is true then JVMCI_lock must be locked.
+  static void* get_shared_library(char*& path, bool load);
+
   static void do_unloading(bool unloading_occurred);
 
   static void metadata_do(void f(Metadata*));
 
   static void shutdown();
 
-  static bool shutdown_called();
+  // Returns whether JVMCI::shutdown has been called.
+  static bool in_shutdown();
 
   static bool is_compiler_initialized();
 
   /**
    * Determines if the VM is sufficiently booted to initialize JVMCI.
@@ -81,19 +108,32 @@
 
   static void initialize_globals();
 
   static void initialize_compiler(TRAPS);
 
-  static jobject make_global(const Handle& obj);
-  static void destroy_global(jobject handle);
-  static bool is_global_handle(jobject handle);
+  static JVMCIRuntime* compiler_runtime() { return _compiler_runtime; }
+  // Gets the single runtime for JVMCI on the Java heap. This is the only
+  // JVMCI runtime available when !UseJVMCINativeLibrary.
+  static JVMCIRuntime* java_runtime()     { return _java_runtime; }
 
-  static jmetadata allocate_handle(const methodHandle& handle);
-  static jmetadata allocate_handle(const constantPoolHandle& handle);
+  // Appends an event to the JVMCI event log if JVMCIEventLogLevel >= `level`
+  static void vlog(int level, const char* format, va_list ap) ATTRIBUTE_PRINTF(2, 0);
 
-  static void release_handle(jmetadata handle);
+  // Traces an event to tty if JVMCITraceLevel >= `level`
+  static void vtrace(int level, const char* format, va_list ap) ATTRIBUTE_PRINTF(2, 0);
 
-  static JVMCIRuntime* compiler_runtime() { return _compiler_runtime; }
-  static JVMCIRuntime* java_runtime()     { return _java_runtime; }
+ public:
+  // Log/trace a JVMCI event
+  static void event(int level, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
+  static void event1(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event2(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event3(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event4(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
 };
 
+// JVMCI event macros.
+#define JVMCI_event_1 if (JVMCITraceLevel < 1 && JVMCIEventLogLevel < 1) ; else ::JVMCI::event1
+#define JVMCI_event_2 if (JVMCITraceLevel < 2 && JVMCIEventLogLevel < 2) ; else ::JVMCI::event2
+#define JVMCI_event_3 if (JVMCITraceLevel < 3 && JVMCIEventLogLevel < 3) ; else ::JVMCI::event3
+#define JVMCI_event_4 if (JVMCITraceLevel < 4 && JVMCIEventLogLevel < 4) ; else ::JVMCI::event4
+
 #endif // SHARE_JVMCI_JVMCI_HPP
diff a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
--- a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
+++ b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
@@ -243,18 +243,18 @@
   if (jvmci_env()->isa_HotSpotResolvedObjectTypeImpl(obj)) {
     Klass* klass = JVMCIENV->asKlass(obj);
     assert(!jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant), "unexpected compressed klass pointer %s @ " INTPTR_FORMAT, klass->name()->as_C_string(), p2i(klass));
     int index = _oop_recorder->find_index(klass);
     section->relocate(dest, metadata_Relocation::spec(index));
-    TRACE_jvmci_3("metadata[%d of %d] = %s", index, _oop_recorder->metadata_count(), klass->name()->as_C_string());
+    JVMCI_event_3("metadata[%d of %d] = %s", index, _oop_recorder->metadata_count(), klass->name()->as_C_string());
     return klass;
   } else if (jvmci_env()->isa_HotSpotResolvedJavaMethodImpl(obj)) {
     Method* method = jvmci_env()->asMethod(obj);
     assert(!jvmci_env()->get_HotSpotMetaspaceConstantImpl_compressed(constant), "unexpected compressed method pointer %s @ " INTPTR_FORMAT, method->name()->as_C_string(), p2i(method));
     int index = _oop_recorder->find_index(method);
     section->relocate(dest, metadata_Relocation::spec(index));
-    TRACE_jvmci_3("metadata[%d of %d] = %s", index, _oop_recorder->metadata_count(), method->name()->as_C_string());
+    JVMCI_event_3("metadata[%d of %d] = %s", index, _oop_recorder->metadata_count(), method->name()->as_C_string());
     return method;
   } else {
     JVMCI_ERROR_NULL("unexpected metadata reference for constant of type %s", jvmci_env()->klass_name(obj));
   }
 }
@@ -269,11 +269,11 @@
   }
 
   Klass* klass = JVMCIENV->asKlass(obj);
   int index = _oop_recorder->find_index(klass);
   section->relocate(dest, metadata_Relocation::spec(index));
-  TRACE_jvmci_3("narrowKlass[%d of %d] = %s", index, _oop_recorder->metadata_count(), klass->name()->as_C_string());
+  JVMCI_event_3("narrowKlass[%d of %d] = %s", index, _oop_recorder->metadata_count(), klass->name()->as_C_string());
   return CompressedKlassPointers::encode(klass);
 }
 #endif
 
 Location::Type CodeInstaller::get_oop_type(JVMCIObject value) {
@@ -688,11 +688,11 @@
   if (jvmci_env()->isa_HotSpotCompiledNmethod(compiled_code)) {
     JVMCIObject hotspotJavaMethod = jvmci_env()->get_HotSpotCompiledNmethod_method(compiled_code);
     Thread* thread = Thread::current();
     methodHandle method(thread, jvmci_env()->asMethod(hotspotJavaMethod));
     _parameter_count = method->size_of_parameters();
-    TRACE_jvmci_2("installing code for %s", method->name_and_sig_as_C_string());
+    JVMCI_event_2("installing code for %s", method->name_and_sig_as_C_string());
   } else {
     // Must be a HotSpotCompiledRuntimeStub.
     // Only used in OopMap constructor for non-product builds
     _parameter_count = 0;
   }
@@ -881,39 +881,39 @@
     }
 
     jint pc_offset = jvmci_env()->get_site_Site_pcOffset(site);
 
     if (jvmci_env()->isa_site_Call(site)) {
-      TRACE_jvmci_4("call at %i", pc_offset);
+      JVMCI_event_4("call at %i", pc_offset);
       site_Call(buffer, pc_offset, site, JVMCI_CHECK_OK);
     } else if (jvmci_env()->isa_site_Infopoint(site)) {
       // three reasons for infopoints denote actual safepoints
       JVMCIObject reason = jvmci_env()->get_site_Infopoint_reason(site);
       if (JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_SAFEPOINT()) ||
           JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_CALL()) ||
           JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_IMPLICIT_EXCEPTION())) {
-        TRACE_jvmci_4("safepoint at %i", pc_offset);
+        JVMCI_event_4("safepoint at %i", pc_offset);
         site_Safepoint(buffer, pc_offset, site, JVMCI_CHECK_OK);
         if (_orig_pc_offset < 0) {
           JVMCI_ERROR_OK("method contains safepoint, but has no deopt rescue slot");
         }
         if (JVMCIENV->equals(reason, jvmci_env()->get_site_InfopointReason_IMPLICIT_EXCEPTION())) {
-          TRACE_jvmci_4("implicit exception at %i", pc_offset);
+          JVMCI_event_4("implicit exception at %i", pc_offset);
           _implicit_exception_table.add_deoptimize(pc_offset);
         }
       } else {
-        TRACE_jvmci_4("infopoint at %i", pc_offset);
+        JVMCI_event_4("infopoint at %i", pc_offset);
         site_Infopoint(buffer, pc_offset, site, JVMCI_CHECK_OK);
       }
     } else if (jvmci_env()->isa_site_DataPatch(site)) {
-      TRACE_jvmci_4("datapatch at %i", pc_offset);
+      JVMCI_event_4("datapatch at %i", pc_offset);
       site_DataPatch(buffer, pc_offset, site, JVMCI_CHECK_OK);
     } else if (jvmci_env()->isa_site_Mark(site)) {
-      TRACE_jvmci_4("mark at %i", pc_offset);
+      JVMCI_event_4("mark at %i", pc_offset);
       site_Mark(buffer, pc_offset, site, JVMCI_CHECK_OK);
     } else if (jvmci_env()->isa_site_ExceptionHandler(site)) {
-      TRACE_jvmci_4("exceptionhandler at %i", pc_offset);
+      JVMCI_event_4("exceptionhandler at %i", pc_offset);
       site_ExceptionHandler(pc_offset, site);
     } else {
       JVMCI_ERROR_OK("unexpected site subclass: %s", jvmci_env()->klass_name(site));
     }
     last_pc_offset = pc_offset;
@@ -1098,11 +1098,11 @@
   jint bci = map_jvmci_bci(jvmci_env()->get_BytecodePosition_bci(position));
   if (bci == jvmci_env()->get_BytecodeFrame_BEFORE_BCI()) {
     bci = SynchronizationEntryBCI;
   }
 
-  TRACE_jvmci_2("Recording scope pc_offset=%d bci=%d method=%s", pc_offset, bci, method->name_and_sig_as_C_string());
+  JVMCI_event_2("Recording scope pc_offset=%d bci=%d method=%s", pc_offset, bci, method->name_and_sig_as_C_string());
 
   bool reexecute = false;
   if (frame.is_non_null()) {
     if (bci < 0){
        reexecute = false;
@@ -1139,12 +1139,12 @@
 
     GrowableArray<ScopeValue*>* locals = local_count > 0 ? new GrowableArray<ScopeValue*> (local_count) : NULL;
     GrowableArray<ScopeValue*>* expressions = expression_count > 0 ? new GrowableArray<ScopeValue*> (expression_count) : NULL;
     GrowableArray<MonitorValue*>* monitors = monitor_count > 0 ? new GrowableArray<MonitorValue*> (monitor_count) : NULL;
 
-    TRACE_jvmci_2("Scope at bci %d with %d values", bci, JVMCIENV->get_length(values));
-    TRACE_jvmci_2("%d locals %d expressions, %d monitors", local_count, expression_count, monitor_count);
+    JVMCI_event_2("Scope at bci %d with %d values", bci, JVMCIENV->get_length(values));
+    JVMCI_event_2("%d locals %d expressions, %d monitors", local_count, expression_count, monitor_count);
 
     for (jint i = 0; i < JVMCIENV->get_length(values); i++) {
       // HandleMark hm(THREAD);
       ScopeValue* second = NULL;
       JVMCIObject value = JVMCIENV->get_object_at(values, i);
@@ -1251,11 +1251,11 @@
   } else { // method != NULL
     if (debug_info.is_null()) {
       JVMCI_ERROR("debug info expected at call at %i", pc_offset);
     }
 
-    TRACE_jvmci_3("method call");
+    JVMCI_event_3("method call");
     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, JVMCI_CHECK);
     if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
       // Need a static call stub for transitions from compiled to interpreted.
       CompiledStaticCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset);
     }
diff a/src/hotspot/share/jvmci/jvmciCompiler.cpp b/src/hotspot/share/jvmci/jvmciCompiler.cpp
--- a/src/hotspot/share/jvmci/jvmciCompiler.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompiler.cpp
@@ -97,43 +97,43 @@
   if (PrintBootstrap) {
     tty->print_cr(" in " JLONG_FORMAT " ms (compiled %d methods)",
                   (jlong)nanos_to_millis(os::javaTimeNanos() - start), _methods_compiled);
   }
   _bootstrapping = false;
-  JVMCI::compiler_runtime()->bootstrap_finished(CHECK);
+  JVMCI::java_runtime()->bootstrap_finished(CHECK);
 }
 
 bool JVMCICompiler::force_comp_at_level_simple(const methodHandle& method) {
-  if (UseJVMCINativeLibrary) {
-    // This mechanism exists to force compilation of a JVMCI compiler by C1
-    // to reduces the compilation time spent on the JVMCI compiler itself. In
-    // +UseJVMCINativeLibrary mode, the JVMCI compiler is AOT compiled.
-    return false;
-  }
-
   if (_bootstrapping) {
     // When bootstrapping, the JVMCI compiler can compile its own methods.
     return false;
   }
-
-  JVMCIRuntime* runtime = JVMCI::compiler_runtime();
-  if (runtime != NULL && runtime->is_HotSpotJVMCIRuntime_initialized()) {
-    JavaThread* thread = JavaThread::current();
-    HandleMark hm(thread);
-    THREAD_JVMCIENV(thread);
-    JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(JVMCIENV);
-    objArrayHandle excludeModules(thread, HotSpotJVMCI::HotSpotJVMCIRuntime::excludeFromJVMCICompilation(JVMCIENV, HotSpotJVMCI::resolve(receiver)));
-    if (excludeModules.not_null()) {
-      ModuleEntry* moduleEntry = method->method_holder()->module();
-      for (int i = 0; i < excludeModules->length(); i++) {
-        if (excludeModules->obj_at(i) == moduleEntry->module()) {
-          return true;
+  if (UseJVMCINativeLibrary) {
+    // This mechanism exists to force compilation of a JVMCI compiler by C1
+    // to reduce the compilation time spent on the JVMCI compiler itself. In
+    // +UseJVMCINativeLibrary mode, the JVMCI compiler is AOT compiled.
+    return false;
+  } else {
+    JVMCIRuntime* runtime = JVMCI::java_runtime();
+    if (runtime != NULL) {
+      JVMCIObject receiver = runtime->probe_HotSpotJVMCIRuntime();
+      if (receiver.is_null()) {
+        return false;
+      }
+      JVMCIEnv* ignored_env = NULL;
+      objArrayHandle excludeModules(JavaThread::current(), HotSpotJVMCI::HotSpotJVMCIRuntime::excludeFromJVMCICompilation(ignored_env, HotSpotJVMCI::resolve(receiver)));
+      if (excludeModules.not_null()) {
+        ModuleEntry* moduleEntry = method->method_holder()->module();
+        for (int i = 0; i < excludeModules->length(); i++) {
+          if (excludeModules->obj_at(i) == moduleEntry->module()) {
+            return true;
+          }
         }
       }
     }
+    return false;
   }
-  return false;
 }
 
 // Compilation entry point for methods
 void JVMCICompiler::compile_method(ciEnv* env, ciMethod* target, int entry_bci, DirectiveSet* directive) {
   ShouldNotReachHere();
@@ -144,8 +144,8 @@
   print_compilation_timers();
 }
 
 // Print compilation timers and statistics
 void JVMCICompiler::print_compilation_timers() {
-  TRACE_jvmci_1("JVMCICompiler::print_timers");
+  JVMCI_event_1("JVMCICompiler::print_timers");
   tty->print_cr("       JVMCI code install time:        %6.3f s",    _codeInstallTimer.seconds());
 }
diff a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
--- a/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
+++ b/src/hotspot/share/jvmci/jvmciCompilerToVM.cpp
@@ -101,18 +101,14 @@
 class JVMCITraceMark : public StackObj {
   const char* _msg;
  public:
   JVMCITraceMark(const char* msg) {
     _msg = msg;
-    if (JVMCITraceLevel >= 1) {
-      tty->print_cr(PTR_FORMAT " JVMCITrace-1: Enter %s", p2i(JavaThread::current()), _msg);
-    }
+    JVMCI_event_2("Enter %s", _msg);
   }
   ~JVMCITraceMark() {
-    if (JVMCITraceLevel >= 1) {
-      tty->print_cr(PTR_FORMAT " JVMCITrace-1: Exit %s", p2i(JavaThread::current()), _msg);
-    }
+    JVMCI_event_2(" Exit %s", _msg);
   }
 };
 
 
 Handle JavaArgumentUnboxer::next_arg(BasicType expectedType) {
@@ -135,50 +131,52 @@
   TRACE_CALL(result_type, jvmci_ ## name signature)  \
   JVMCI_VM_ENTRY_MARK;                               \
   ResourceMark rm;                                   \
   JNI_JVMCIENV(thread, env);
 
-static Thread* get_current_thread() {
-  return Thread::current_or_null_safe();
+static JavaThread* get_current_thread(bool allow_null=true) {
+  Thread* thread = Thread::current_or_null_safe();
+  if (thread == NULL) {
+    assert(allow_null, "npe");
+    return NULL;
+  }
+  assert(thread->is_Java_thread(), "must be");
+  return (JavaThread*) thread;
 }
 
 // Entry to native method implementation that transitions
 // current thread to '_thread_in_vm'.
 #define C2V_VMENTRY(result_type, name, signature)        \
   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
-  Thread* base_thread = get_current_thread();            \
-  if (base_thread == NULL) {                             \
+  JavaThread* thread = get_current_thread();             \
+  if (thread == NULL) {                                  \
     env->ThrowNew(JNIJVMCI::InternalError::clazz(),      \
         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
     return;                                              \
   }                                                      \
-  assert(base_thread->is_Java_thread(), "just checking");\
-  JavaThread* thread = (JavaThread*) base_thread;        \
   JVMCITraceMark jtm("CompilerToVM::" #name);            \
   C2V_BLOCK(result_type, name, signature)
 
 #define C2V_VMENTRY_(result_type, name, signature, result) \
   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
-  Thread* base_thread = get_current_thread();            \
-  if (base_thread == NULL) {                             \
+  JavaThread* thread = get_current_thread();             \
+  if (thread == NULL) {                                  \
     env->ThrowNew(JNIJVMCI::InternalError::clazz(),      \
         err_msg("Cannot call into HotSpot from JVMCI shared library without attaching current thread")); \
     return result;                                       \
   }                                                      \
-  assert(base_thread->is_Java_thread(), "just checking");\
-  JavaThread* thread = (JavaThread*) base_thread;        \
   JVMCITraceMark jtm("CompilerToVM::" #name);            \
   C2V_BLOCK(result_type, name, signature)
 
 #define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)
 #define C2V_VMENTRY_0(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, 0)
 
 // Entry to native method implementation that does not transition
 // current thread to '_thread_in_vm'.
 #define C2V_VMENTRY_PREFIX(result_type, name, signature) \
   JNIEXPORT result_type JNICALL c2v_ ## name signature { \
-  Thread* base_thread = get_current_thread();
+  JavaThread* thread = get_current_thread();
 
 #define C2V_END }
 
 #define JNI_THROW(caller, name, msg) do {                                         \
     jint __throw_res = env->ThrowNew(JNIJVMCI::name::clazz(), msg);               \
@@ -1577,11 +1575,11 @@
 // from HotSpot if it wasn't already attached when entering the scope.
 extern "C" void jio_printf(const char *fmt, ...);
 class AttachDetach : public StackObj {
  public:
   bool _attached;
-  AttachDetach(JNIEnv* env, Thread* current_thread) {
+  AttachDetach(JNIEnv* env, JavaThread* current_thread) {
     if (current_thread == NULL) {
       extern struct JavaVM_ main_vm;
       JNIEnv* hotspotEnv;
       jint res = main_vm.AttachCurrentThread((void**)&hotspotEnv, NULL);
       _attached = res == JNI_OK;
@@ -1606,22 +1604,21 @@
     }
   }
 };
 
 C2V_VMENTRY_PREFIX(jint, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length, bool flush, bool can_throw))
-  AttachDetach ad(env, base_thread);
+  AttachDetach ad(env, thread);
   bool use_tty = true;
-  if (base_thread == NULL) {
+  if (thread == NULL) {
     if (!ad._attached) {
       // Can only use tty if the current thread is attached
+      JVMCI_event_1("Cannot write to tty on unattached thread");
       return 0;
     }
-    base_thread = get_current_thread();
+    thread = get_current_thread();
   }
   JVMCITraceMark jtm("writeDebugOutput");
-  assert(base_thread->is_Java_thread(), "just checking");
-  JavaThread* thread = (JavaThread*) base_thread;
   C2V_BLOCK(void, writeDebugOutput, (JNIEnv* env, jobject, jbyteArray bytes, jint offset, jint length))
   if (bytes == NULL) {
     if (can_throw) {
       JVMCI_THROW_0(NullPointerException);
     }
@@ -2227,45 +2224,38 @@
 }
 
 C2V_VMENTRY(void, deleteGlobalHandle, (JNIEnv* env, jobject, jlong h))
   jobject handle = (jobject)(address)h;
   if (handle != NULL) {
-    JVMCI::destroy_global(handle);
+    JVMCIENV->runtime()->destroy_global(handle);
   }
 }
 
 static void requireJVMCINativeLibrary(JVMCI_TRAPS) {
   if (!UseJVMCINativeLibrary) {
     JVMCI_THROW_MSG(UnsupportedOperationException, "JVMCI shared library is not enabled (requires -XX:+UseJVMCINativeLibrary)");
   }
 }
 
-static JavaVM* requireNativeLibraryJavaVM(const char* caller, JVMCI_TRAPS) {
-  JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
-  if (javaVM == NULL) {
-    JVMCI_THROW_MSG_NULL(IllegalStateException, err_msg("Require JVMCI shared library to be initialized in %s", caller));
-  }
-  return javaVM;
-}
-
 C2V_VMENTRY_NULL(jlongArray, registerNativeMethods, (JNIEnv* env, jobject, jclass mirror))
   requireJVMCINativeLibrary(JVMCI_CHECK_NULL);
   requireInHotSpot("registerNativeMethods", JVMCI_CHECK_NULL);
-  void* shared_library = JVMCIEnv::get_shared_library_handle();
-  if (shared_library == NULL) {
+  char* sl_path;
+  void* sl_handle;
+  JVMCIRuntime* runtime = JVMCI::compiler_runtime();
+  {
     // Ensure the JVMCI shared library runtime is initialized.
     JVMCIEnv __peer_jvmci_env__(thread, false, __FILE__, __LINE__);
     JVMCIEnv* peerEnv = &__peer_jvmci_env__;
     HandleMark hm;
-    JVMCIRuntime* runtime = JVMCI::compiler_runtime();
     JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerEnv);
     if (peerEnv->has_pending_exception()) {
       peerEnv->describe_pending_exception(true);
     }
-    shared_library = JVMCIEnv::get_shared_library_handle();
-    if (shared_library == NULL) {
-      JVMCI_THROW_MSG_0(InternalError, "Error initializing JVMCI runtime");
+    sl_handle = JVMCI::get_shared_library(sl_path, false);
+    if (sl_handle == NULL) {
+      JVMCI_THROW_MSG_0(InternalError, err_msg("Error initializing JVMCI runtime %d", runtime->id()));
     }
   }
 
   if (mirror == NULL) {
     JVMCI_THROW_0(NullPointerException);
@@ -2291,144 +2281,147 @@
       os::print_jni_name_prefix_on(&st, args_size);
       st.print_raw(pure_name);
       os::print_jni_name_suffix_on(&st, args_size);
       char* jni_name = st.as_string();
 
-      address entry = (address) os::dll_lookup(shared_library, jni_name);
+      address entry = (address) os::dll_lookup(sl_handle, jni_name);
       if (entry == NULL) {
         // 2) Try JNI long style
         st.reset();
         char* long_name = NativeLookup::long_jni_name(method);
         os::print_jni_name_prefix_on(&st, args_size);
         st.print_raw(pure_name);
         st.print_raw(long_name);
         os::print_jni_name_suffix_on(&st, args_size);
         char* jni_long_name = st.as_string();
-        entry = (address) os::dll_lookup(shared_library, jni_long_name);
+        entry = (address) os::dll_lookup(sl_handle, jni_long_name);
         if (entry == NULL) {
           JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [neither %s nor %s exist in %s]",
               method->name_and_sig_as_C_string(),
-              jni_name, jni_long_name, JVMCIEnv::get_shared_library_path()));
+              jni_name, jni_long_name, sl_path));
         }
       }
 
       if (method->has_native_function() && entry != method->native_function()) {
         JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg("%s [cannot re-link from " PTR_FORMAT " to " PTR_FORMAT "]",
             method->name_and_sig_as_C_string(), p2i(method->native_function()), p2i(entry)));
       }
       method->set_native_function(entry, Method::native_bind_event_is_interesting);
-      log_debug(jni, resolve)("[Dynamic-linking native method %s.%s ... JNI]",
+      log_debug(jni, resolve)("[Dynamic-linking native method %s.%s ... JNI] @ " PTR_FORMAT,
                               method->method_holder()->external_name(),
-                              method->name()->as_C_string());
+                              method->name()->as_C_string(),
+                              p2i((void*) entry));
     }
   }
 
-  JavaVM* javaVM = JVMCIEnv::get_shared_library_javavm();
-  JVMCIPrimitiveArray result = JVMCIENV->new_longArray(4, JVMCI_CHECK_NULL);
-  JVMCIENV->put_long_at(result, 0, (jlong) (address) javaVM);
-  JVMCIENV->put_long_at(result, 1, (jlong) (address) javaVM->functions->reserved0);
-  JVMCIENV->put_long_at(result, 2, (jlong) (address) javaVM->functions->reserved1);
-  JVMCIENV->put_long_at(result, 3, (jlong) (address) javaVM->functions->reserved2);
-  return (jlongArray) JVMCIENV->get_jobject(result);
+  typeArrayOop info_oop = oopFactory::new_longArray(4, CHECK_0);
+  jlongArray info = (jlongArray) JNIHandles::make_local(info_oop);
+  runtime->init_JavaVM_info(info, JVMCI_CHECK_0);
+  return info;
 }
 
 C2V_VMENTRY_PREFIX(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject c2vm))
-  if (base_thread == NULL) {
+  if (thread == NULL) {
     // Called from unattached JVMCI shared library thread
     return false;
   }
   JVMCITraceMark jtm("isCurrentThreadAttached");
-  assert(base_thread->is_Java_thread(), "just checking");
-  JavaThread* thread = (JavaThread*) base_thread;
   if (thread->jni_environment() == env) {
     C2V_BLOCK(jboolean, isCurrentThreadAttached, (JNIEnv* env, jobject))
     requireJVMCINativeLibrary(JVMCI_CHECK_0);
-    JavaVM* javaVM = requireNativeLibraryJavaVM("isCurrentThreadAttached", JVMCI_CHECK_0);
+    JVMCIRuntime* runtime = JVMCI::compiler_runtime();
+    if (runtime == NULL || !runtime->has_shared_library_javavm()) {
+      JVMCI_THROW_MSG_0(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in isCurrentThreadAttached");
+    }
     JNIEnv* peerEnv;
-    return javaVM->GetEnv((void**)&peerEnv, JNI_VERSION_1_2) == JNI_OK;
+    return runtime->GetEnv(thread, (void**) &peerEnv, JNI_VERSION_1_2) == JNI_OK;
   }
   return true;
 C2V_END
 
 C2V_VMENTRY_PREFIX(jlong, getCurrentJavaThread, (JNIEnv* env, jobject c2vm))
-  if (base_thread == NULL) {
+  if (thread == NULL) {
     // Called from unattached JVMCI shared library thread
     return 0L;
   }
   JVMCITraceMark jtm("getCurrentJavaThread");
-  assert(base_thread->is_Java_thread(), "just checking");
-  return (jlong) p2i(base_thread);
+  return (jlong) p2i(thread);
 C2V_END
 
 C2V_VMENTRY_PREFIX(jboolean, attachCurrentThread, (JNIEnv* env, jobject c2vm, jboolean as_daemon))
-  if (base_thread == NULL) {
+  if (thread == NULL) {
     // Called from unattached JVMCI shared library thread
     extern struct JavaVM_ main_vm;
     JNIEnv* hotspotEnv;
-    jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**)&hotspotEnv, NULL) :
-                           main_vm.AttachCurrentThread((void**)&hotspotEnv, NULL);
+    jint res = as_daemon ? main_vm.AttachCurrentThreadAsDaemon((void**) &hotspotEnv, NULL) :
+                           main_vm.AttachCurrentThread((void**) &hotspotEnv, NULL);
     if (res != JNI_OK) {
       JNI_THROW_("attachCurrentThread", InternalError, err_msg("Trying to attach thread returned %d", res), false);
     }
     return true;
   }
   JVMCITraceMark jtm("attachCurrentThread");
-  assert(base_thread->is_Java_thread(), "just checking");\
-  JavaThread* thread = (JavaThread*) base_thread;
   if (thread->jni_environment() == env) {
     // Called from HotSpot
     C2V_BLOCK(jboolean, attachCurrentThread, (JNIEnv* env, jobject, jboolean))
     requireJVMCINativeLibrary(JVMCI_CHECK_0);
-    JavaVM* javaVM = requireNativeLibraryJavaVM("attachCurrentThread", JVMCI_CHECK_0);
+    JVMCIRuntime* runtime = JVMCI::compiler_runtime();
+    if (runtime == NULL || !runtime->has_shared_library_javavm()) {
+        JVMCI_THROW_MSG_0(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in attachCurrentThread");
+    }
+
     JavaVMAttachArgs attach_args;
     attach_args.version = JNI_VERSION_1_2;
     attach_args.name = thread->name();
     attach_args.group = NULL;
-    JNIEnv* peerEnv;
-    if (javaVM->GetEnv((void**)&peerEnv, JNI_VERSION_1_2) == JNI_OK) {
+    JNIEnv* peerJNIEnv;
+    if (runtime->GetEnv(thread, (void**) &peerJNIEnv, JNI_VERSION_1_2) == JNI_OK) {
       return false;
     }
-    jint res = as_daemon ? javaVM->AttachCurrentThreadAsDaemon((void**)&peerEnv, &attach_args) :
-                           javaVM->AttachCurrentThread((void**)&peerEnv, &attach_args);
+    jint res = as_daemon ? runtime->AttachCurrentThreadAsDaemon(thread, (void**) &peerJNIEnv, &attach_args) :
+                           runtime->AttachCurrentThread(thread, (void**) &peerJNIEnv, &attach_args);
+
     if (res == JNI_OK) {
-      guarantee(peerEnv != NULL, "must be");
+      guarantee(peerJNIEnv != NULL, "must be");
+      JVMCI_event_1("attached to JavaVM for JVMCI runtime %d", runtime->id());
       return true;
     }
     JVMCI_THROW_MSG_0(InternalError, err_msg("Error %d while attaching %s", res, attach_args.name));
   }
   // Called from JVMCI shared library
   return false;
 C2V_END
 
 C2V_VMENTRY_PREFIX(void, detachCurrentThread, (JNIEnv* env, jobject c2vm))
-  if (base_thread == NULL) {
+  if (thread == NULL) {
     // Called from unattached JVMCI shared library thread
-    JNI_THROW("detachCurrentThread", IllegalStateException, err_msg("Cannot detach non-attached thread"));
+    JNI_THROW("detachCurrentThread", IllegalStateException, "Cannot detach non-attached thread");
   }
   JVMCITraceMark jtm("detachCurrentThread");
-  assert(base_thread->is_Java_thread(), "just checking");\
-  JavaThread* thread = (JavaThread*) base_thread;
   if (thread->jni_environment() == env) {
     // Called from HotSpot
     C2V_BLOCK(void, detachCurrentThread, (JNIEnv* env, jobject))
     requireJVMCINativeLibrary(JVMCI_CHECK);
     requireInHotSpot("detachCurrentThread", JVMCI_CHECK);
-    JavaVM* javaVM = requireNativeLibraryJavaVM("detachCurrentThread", JVMCI_CHECK);
-    JNIEnv* peerEnv;
-    if (javaVM->GetEnv((void**)&peerEnv, JNI_VERSION_1_2) != JNI_OK) {
+    JVMCIRuntime* runtime = JVMCI::compiler_runtime();
+    if (runtime == NULL || !runtime->has_shared_library_javavm()) {
+      JVMCI_THROW_MSG(IllegalStateException, "Require JVMCI shared library JavaVM to be initialized in detachCurrentThread");
+    }
+    JNIEnv* peerJNIEnv;
+    if (runtime->GetEnv(thread, (void**) &peerJNIEnv, JNI_VERSION_1_2) != JNI_OK) {
       JVMCI_THROW_MSG(IllegalStateException, err_msg("Cannot detach non-attached thread: %s", thread->name()));
     }
-    jint res = javaVM->DetachCurrentThread();
+    jint res = runtime->DetachCurrentThread(thread);
     if (res != JNI_OK) {
       JVMCI_THROW_MSG(InternalError, err_msg("Error %d while attaching %s", res, thread->name()));
     }
   } else {
     // Called from attached JVMCI shared library thread
     extern struct JavaVM_ main_vm;
     jint res = main_vm.DetachCurrentThread();
     if (res != JNI_OK) {
-      JNI_THROW("detachCurrentThread", InternalError, err_msg("Cannot detach non-attached thread"));
+      JNI_THROW("detachCurrentThread", InternalError, "Cannot detach non-attached thread");
     }
   }
 C2V_END
 
 C2V_VMENTRY_0(jlong, translate, (JNIEnv* env, jobject, jobject obj_handle))
diff a/src/hotspot/share/jvmci/jvmciEnv.cpp b/src/hotspot/share/jvmci/jvmciEnv.cpp
--- a/src/hotspot/share/jvmci/jvmciEnv.cpp
+++ b/src/hotspot/share/jvmci/jvmciEnv.cpp
@@ -75,14 +75,10 @@
     return true;
   }
   return false;
 }
 
-JavaVM* JVMCIEnv::_shared_library_javavm = NULL;
-void* JVMCIEnv::_shared_library_handle = NULL;
-char* JVMCIEnv::_shared_library_path = NULL;
-
 void JVMCIEnv::copy_saved_properties() {
   assert(!is_hotspot(), "can only copy saved properties from HotSpot to native image");
 
   JavaThread* THREAD = JavaThread::current();
 
@@ -129,79 +125,26 @@
   }
 
   // Initialize saved properties in shared library
   jclass servicesClass = JNIJVMCI::Services::clazz();
   jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
-  JNIAccessMark jni(this);
+  JNIAccessMark jni(this, THREAD);
   jni()->CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
   if (jni()->ExceptionCheck()) {
     jni()->ExceptionDescribe();
     fatal("Error calling jdk.vm.ci.services.Services.initializeSavedProperties");
   }
 }
 
-JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {
-  if (_shared_library_javavm == NULL) {
-    MutexLocker locker(JVMCI_lock);
-    if (_shared_library_javavm == NULL) {
-      char path[JVM_MAXPATHLEN];
-      char ebuf[1024];
-      if (JVMCILibPath != NULL) {
-        if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {
-          vm_exit_during_initialization("Unable to create JVMCI shared library path from -XX:JVMCILibPath value", JVMCILibPath);
-        }
-      } else {
-        if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {
-          vm_exit_during_initialization("Unable to create path to JVMCI shared library");
-        }
-      }
-
-      void* handle = os::dll_load(path, ebuf, sizeof ebuf);
-      if (handle == NULL) {
-        vm_exit_during_initialization("Unable to load JVMCI shared library", ebuf);
-      }
-      _shared_library_handle = handle;
-      _shared_library_path = strdup(path);
-      jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);
-      typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);
-
-      JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, "JNI_CreateJavaVM"));
-      JNIEnv* env;
-      if (JNI_CreateJavaVM == NULL) {
-        vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", path);
-      }
-
-      ResourceMark rm;
-      JavaVMInitArgs vm_args;
-      vm_args.version = JNI_VERSION_1_2;
-      vm_args.ignoreUnrecognized = JNI_TRUE;
-      vm_args.options = NULL;
-      vm_args.nOptions = 0;
-
-      JavaVM* the_javavm = NULL;
-      int result = (*JNI_CreateJavaVM)(&the_javavm, (void**) &env, &vm_args);
-      if (result == JNI_OK) {
-        guarantee(env != NULL, "missing env");
-        _shared_library_javavm = the_javavm;
-        return env;
-      } else {
-        vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), path);
-      }
-    }
-  }
-  return NULL;
-}
-
 void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
   assert(thread != NULL, "npe");
-  // By default there is only one runtime which is the compiler runtime.
-  _runtime = JVMCI::compiler_runtime();
   _env = NULL;
   _pop_frame_on_close = false;
   _detach_on_close = false;
   if (!UseJVMCINativeLibrary) {
     // In HotSpot mode, JNI isn't used at all.
+    _runtime = JVMCI::java_runtime();
     _is_hotspot = true;
     return;
   }
 
   if (parent_env != NULL) {
@@ -211,24 +154,28 @@
     if (_is_hotspot) {
       // Select the Java runtime
       _runtime = JVMCI::java_runtime();
       return;
     }
+    _runtime = JVMCI::compiler_runtime();
+    assert(_runtime != NULL, "npe");
     _env = parent_env;
     return;
   }
 
   // Running in JVMCI shared library mode so ensure the shared library
   // is loaded and initialized and get a shared library JNIEnv
   _is_hotspot = false;
-  _env = init_shared_library(thread);
+
+  _runtime = JVMCI::compiler_runtime();
+  _env = _runtime->init_shared_library_javavm();
 
   if (_env != NULL) {
     // Creating the JVMCI shared library VM also attaches the current thread
     _detach_on_close = true;
   } else {
-    _shared_library_javavm->GetEnv((void**)&parent_env, JNI_VERSION_1_2);
+    _runtime->GetEnv(thread, (void**)&parent_env, JNI_VERSION_1_2);
     if (parent_env != NULL) {
       // Even though there's a parent JNI env, there's no guarantee
       // it was opened by a JVMCIEnv scope and thus may not have
       // pushed a local JNI frame. As such, we use a new JNI local
       // frame in this scope to ensure local JNI refs are collected
@@ -238,21 +185,21 @@
       ResourceMark rm; // Thread name is resource allocated
       JavaVMAttachArgs attach_args;
       attach_args.version = JNI_VERSION_1_2;
       attach_args.name = thread->name();
       attach_args.group = NULL;
-      if (_shared_library_javavm->AttachCurrentThread((void**)&_env, &attach_args) != JNI_OK) {
+      if (_runtime->AttachCurrentThread(thread, (void**) &_env, &attach_args) != JNI_OK) {
         fatal("Error attaching current thread (%s) to JVMCI shared library JNI interface", attach_args.name);
       }
       _detach_on_close = true;
     }
   }
 
   assert(_env != NULL, "missing env");
   assert(_throw_to_caller == false, "must be");
 
-  JNIAccessMark jni(this);
+  JNIAccessMark jni(this, thread);
   jint result = _env->PushLocalFrame(32);
   if (result != JNI_OK) {
     char message[256];
     jio_snprintf(message, 256, "Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d", _file, _line);
     JVMCIRuntime::exit_on_pending_exception(this, message);
@@ -292,21 +239,21 @@
   }
 }
 
 // Prints a pending exception (if any) and its stack trace.
 void JVMCIEnv::describe_pending_exception(bool clear) {
+  Thread* THREAD = Thread::current();
   if (!is_hotspot()) {
     JNIAccessMark jni(this);
     if (jni()->ExceptionCheck()) {
       jthrowable ex = !clear ? jni()->ExceptionOccurred() : NULL;
       jni()->ExceptionDescribe();
       if (ex != NULL) {
         jni()->Throw(ex);
       }
     }
   } else {
-    Thread* THREAD = Thread::current();
     if (HAS_PENDING_EXCEPTION) {
       JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
     }
   }
 }
@@ -330,11 +277,11 @@
   oop encoded_throwable_string = (oop) result.get_jobject();
 
   ResourceMark rm;
   const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
 
-  JNIAccessMark jni(this);
+  JNIAccessMark jni(this, THREAD);
   jobject jni_encoded_throwable_string = jni()->NewStringUTF(encoded_throwable_chars);
   jthrowable jni_throwable = (jthrowable) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                 JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
                                 jni_encoded_throwable_string);
   jni()->Throw(jni_throwable);
@@ -366,11 +313,11 @@
       jio_snprintf(message, 256, "Uncaught exception exiting JVMCIEnv scope entered at %s:%d", _file, _line);
       JVMCIRuntime::exit_on_pending_exception(this, message);
     }
 
     if (_detach_on_close) {
-      get_shared_library_javavm()->DetachCurrentThread();
+      _runtime->DetachCurrentThread(JavaThread::current());
     }
   }
 }
 
 jboolean JVMCIEnv::has_pending_exception() {
@@ -601,16 +548,16 @@
     case T_DOUBLE:
       break;
     default:
       JVMCI_THROW_MSG_(IllegalArgumentException, "Only boxes for primitive values can be created", JVMCIObject());
   }
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
     return HotSpotJVMCI::wrap(box);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject box = jni()->NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
     assert(box != NULL, "");
     return wrap(box);
   }
 }
@@ -670,17 +617,17 @@
   va_start(ap, format);
   char msg[max_msg_size];
   vsnprintf(msg, max_msg_size, format, ap);
   msg[max_msg_size-1] = '\0';
   va_end(ap);
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     Handle h_loader = Handle();
     Handle h_protection_domain = Handle();
     Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jni()->ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
   }
 }
 
 JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
@@ -733,11 +680,11 @@
     JavaCallArguments jargs;
     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
     JavaValue result(T_VOID);
     JavaCalls::call_special(&result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &jargs, THREAD);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jni()->CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
   }
   if (has_pending_exception()) {
     // This should never happen as HotSpotJVMCIRuntime.shutdown() should
     // handle all exceptions.
@@ -751,11 +698,11 @@
     JavaCallArguments jargs;
     JavaValue result(T_OBJECT);
     JavaCalls::call_static(&result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
@@ -768,11 +715,11 @@
     JavaCallArguments jargs;
     JavaValue result(T_OBJECT);
     JavaCalls::call_static(&result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
@@ -786,11 +733,11 @@
     jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
     JavaValue result(T_OBJECT);
     JavaCalls::call_virtual(&result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
     }
     return wrap(result);
@@ -808,11 +755,11 @@
                            HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
                            vmSymbols::callToString_name(),
                            vmSymbols::callToString_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                                      JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
                                                      object.as_jobject());
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
@@ -833,11 +780,11 @@
                            HotSpotJVMCI::PrimitiveConstant::klass(),
                            vmSymbols::forTypeChar_name(),
                            vmSymbols::forTypeChar_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
                                                      JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
                                                      kind, value);
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
@@ -856,11 +803,11 @@
                            HotSpotJVMCI::JavaConstant::klass(),
                            vmSymbols::forFloat_name(),
                            vmSymbols::forFloat_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                      JNIJVMCI::JavaConstant::forFloat_method(),
                                                      value);
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
@@ -879,11 +826,11 @@
                            HotSpotJVMCI::JavaConstant::klass(),
                            vmSymbols::forDouble_name(),
                            vmSymbols::forDouble_signature(), &jargs, CHECK_(JVMCIObject()));
     return wrap((oop) result.get_jobject());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = (jstring) jni()->CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                      JNIJVMCI::JavaConstant::forDouble_method(),
                                                      value);
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
@@ -924,11 +871,11 @@
       HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
     }
     HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
     return wrap(obj());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject declaring_class = jni()->NewStringUTF(declaring_class_str);
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
     }
     jobject method_name = jni()->NewStringUTF(method_name_sym->as_C_string());
@@ -976,11 +923,11 @@
                             vmSymbols::object_initializer_name(),
                             vmSymbols::method_string_bool_long_signature(),
                             &jargs, CHECK_(JVMCIObject()));
     return wrap(obj_h());
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject nameStr = name == NULL ? NULL : jni()->NewStringUTF(name);
     if (jni()->ExceptionCheck()) {
       return JVMCIObject();
     }
 
@@ -1013,22 +960,10 @@
     JNIAccessMark jni(this);
     return wrap(jni()->NewGlobalRef(object.as_jobject()));
   }
 }
 
-JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {
-  if (object.is_null()) {
-    return JVMCIObject();
-  }
-  if (is_hotspot()) {
-    return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));
-  } else {
-    JNIAccessMark jni(this);
-    return wrap(jni()->NewWeakGlobalRef(object.as_jobject()));
-  }
-}
-
 void JVMCIEnv::destroy_local(JVMCIObject object) {
   if (is_hotspot()) {
     JNIHandles::destroy_local(object.as_jobject());
   } else {
     JNIAccessMark jni(this);
@@ -1043,19 +978,10 @@
     JNIAccessMark jni(this);
     jni()->DeleteGlobalRef(object.as_jobject());
   }
 }
 
-void JVMCIEnv::destroy_weak(JVMCIObject object) {
-  if (is_hotspot()) {
-    JNIHandles::destroy_weak_global(object.as_jweak());
-  } else {
-    JNIAccessMark jni(this);
-    jni()->DeleteWeakGlobalRef(object.as_jweak());
-  }
-}
-
 const char* JVMCIEnv::klass_name(JVMCIObject object) {
   if (is_hotspot()) {
     return HotSpotJVMCI::resolve(object)->klass()->signature_name();
   } else {
     JVMCIObject name;
@@ -1074,11 +1000,11 @@
   if (method() == NULL) {
     return method_object;
   }
 
   Thread* THREAD = Thread::current();
-  jmetadata handle = JVMCI::allocate_handle(method);
+  jmetadata handle = _runtime->allocate_handle(method);
   jboolean exception = false;
   if (is_hotspot()) {
     JavaValue result(T_OBJECT);
     JavaCallArguments args;
     args.push_long((jlong) handle);
@@ -1097,17 +1023,17 @@
                                                                   (jlong) handle));
     exception = jni()->ExceptionCheck();
   }
 
   if (exception) {
-    JVMCI::release_handle(handle);
+    _runtime->release_handle(handle);
     return JVMCIObject();
   }
 
   assert(asMethod(method_object) == method(), "must be");
   if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
-    JVMCI::release_handle(handle);
+    _runtime->release_handle(handle);
   }
   assert(!method_object.is_null(), "must be");
   return method_object;
 }
 
@@ -1135,11 +1061,11 @@
       exception = true;
     } else {
       type = wrap((oop)result.get_jobject());
     }
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
 
     HandleMark hm(THREAD);
     type = JNIJVMCI::wrap(jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
                                                         JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
                                                         pointer, signature.as_jstring()));
@@ -1153,14 +1079,14 @@
   return type;
 }
 
 JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle& cp, JVMCI_TRAPS) {
   JVMCIObject cp_object;
-  jmetadata handle = JVMCI::allocate_handle(cp);
+  jmetadata handle = _runtime->allocate_handle(cp);
   jboolean exception = false;
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     JavaValue result(T_OBJECT);
     JavaCallArguments args;
     args.push_long((jlong) handle);
     JavaCalls::call_static(&result,
                            HotSpotJVMCI::HotSpotConstantPool::klass(),
@@ -1170,139 +1096,139 @@
       exception = true;
     } else {
       cp_object = wrap((oop)result.get_jobject());
     }
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     cp_object = JNIJVMCI::wrap(jni()->CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
                                                              JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
                                                              (jlong) handle));
     exception = jni()->ExceptionCheck();
   }
 
   if (exception) {
-    JVMCI::release_handle(handle);
+    _runtime->release_handle(handle);
     return JVMCIObject();
   }
 
   assert(!cp_object.is_null(), "must be");
   // Constant pools aren't cached so this is always a newly created object using the handle
   assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, "must use same handle");
   return cp_object;
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jbooleanArray result = jni()->NewBooleanArray(length);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jbyteArray result = jni()->NewByteArray(length);
     return wrap(result);
   }
 }
 
 JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())->array_klass(CHECK_(JVMCIObject()));
     objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobjectArray result = jni()->NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jintArray result = jni()->NewIntArray(length);
     return wrap(result);
   }
 }
 
 JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
     return wrap(result);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jlongArray result = jni()->NewLongArray(length);
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     HotSpotJVMCI::VMField::klass()->initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMField::klass()->allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
     HotSpotJVMCI::VMField::set_offset(this, obj, offset);
     HotSpotJVMCI::VMField::set_address(this, obj, address);
     HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
     return wrap(obj);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->NewObject(JNIJVMCI::VMField::clazz(),
                                     JNIJVMCI::VMField::constructor(),
                                     get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     HotSpotJVMCI::VMFlag::klass()->initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMFlag::klass()->allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
     HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
     return wrap(obj);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->NewObject(JNIJVMCI::VMFlag::clazz(),
                                     JNIJVMCI::VMFlag::constructor(),
                                     get_jobject(name), get_jobject(type), get_jobject(value));
     return wrap(result);
   }
 }
 
 JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     HotSpotJVMCI::VMIntrinsicMethod::klass()->initialize(CHECK_(JVMCIObject()));
     oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()->allocate_instance(CHECK_(JVMCIObject()));
     HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
     HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
     HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
     HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
     return wrap(obj);
   } else {
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
                                     JNIJVMCI::VMIntrinsicMethod::constructor(),
                                     get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
     return wrap(result);
   }
@@ -1344,11 +1270,11 @@
     HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
     HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
     return wrap(constant);
   } else {
     jlong handle = make_handle(obj);
-    JNIAccessMark jni(this);
+    JNIAccessMark jni(this, THREAD);
     jobject result = jni()->NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
                                       JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
                                       handle, compressed, dont_register);
     return wrap(result);
   }
@@ -1383,11 +1309,11 @@
   return JVMCIObject::create(object, is_hotspot());
 }
 
 jlong JVMCIEnv::make_handle(const Handle& obj) {
   assert(!obj.is_null(), "should only create handle for non-NULL oops");
-  jobject handle = JVMCI::make_global(obj);
+  jobject handle = _runtime->make_global(obj);
   return (jlong) handle;
 }
 
 oop JVMCIEnv::resolve_handle(jlong objectHandle) {
   assert(objectHandle != 0, "should be a valid handle");
@@ -1397,19 +1323,19 @@
   }
   return obj;
 }
 
 JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
+  JavaThread* THREAD = JavaThread::current();
   if (is_hotspot()) {
-    JavaThread* THREAD = JavaThread::current();
     Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
     return HotSpotJVMCI::wrap(result());
   } else {
     jobject result;
     jboolean exception = false;
     {
-      JNIAccessMark jni(this);
+      JNIAccessMark jni(this, THREAD);
       result = jni()->NewStringUTF(str);
       exception = jni()->ExceptionCheck();
     }
     return wrap(result);
   }
diff a/src/hotspot/share/jvmci/jvmciEnv.hpp b/src/hotspot/share/jvmci/jvmciEnv.hpp
--- a/src/hotspot/share/jvmci/jvmciEnv.hpp
+++ b/src/hotspot/share/jvmci/jvmciEnv.hpp
@@ -42,12 +42,15 @@
 
 // Helper to log more context on a JNI exception
 #define JVMCI_EXCEPTION_CHECK(env, ...) \
   do { \
     if (env->ExceptionCheck()) { \
-      if (env != JavaThread::current()->jni_environment() && JVMCIEnv::get_shared_library_path() != NULL) { \
-        tty->print_cr("In JVMCI shared library (%s):", JVMCIEnv::get_shared_library_path()); \
+      if (env != JavaThread::current()->jni_environment()) { \
+        char* sl_path; \
+        if (::JVMCI::get_shared_library(sl_path, false) != NULL) { \
+          tty->print_cr("In JVMCI shared library (%s):", sl_path); \
+        } \
       } \
       tty->print_cr(__VA_ARGS__); \
       return; \
     } \
   } while(0)
@@ -141,20 +144,10 @@
 // interactions with JVMCI objects so that a single version of the
 // HotSpot C++ code can can work with either runtime.
 class JVMCIEnv : public ResourceObj {
   friend class JNIAccessMark;
 
-  static char*   _shared_library_path;   // argument to os:dll_load
-  static void*   _shared_library_handle; // result of os::dll_load
-  static JavaVM* _shared_library_javavm; // result of calling JNI_CreateJavaVM in shared library
-
-  // Initializes the shared library JavaVM if not already initialized.
-  // Returns the JNI interface pointer for the current thread
-  // if initialization was performed by this call, NULL if
-  // initialization was performed by a previous call.
-  static JNIEnv* init_shared_library(JavaThread* thread);
-
   // Initializes the _env, _mode and _runtime fields.
   void init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env);
 
   void init(JavaThread* thread, bool is_hotspot, const char* file, int line);
 
@@ -381,15 +374,25 @@
   jlong make_handle(const Handle& obj);
   oop resolve_handle(jlong objectHandle);
 
   // These are analagous to the JNI routines
   JVMCIObject make_local(JVMCIObject object);
-  JVMCIObject make_global(JVMCIObject object);
-  JVMCIObject make_weak(JVMCIObject object);
   void destroy_local(JVMCIObject object);
+
+  // Makes a JNI global handle that is not scoped by the
+  // lifetime of a JVMCIRuntime (cf JVMCIRuntime::make_global).
+  // These JNI handles are used when translating an object
+  // between the HotSpot and JVMCI shared library heap via
+  // HotSpotJVMCIRuntime.translate(Object) and
+  // HotSpotJVMCIRuntime.unhand(Class<T>, long). Translation
+  // can happen in either direction so the referenced object
+  // can reside in either heap which is why JVMCIRuntime scoped
+  // handles cannot be used (they are specific to HotSpot heap objects).
+  JVMCIObject make_global(JVMCIObject object);
+
+  // Destroys a JNI global handle created by JVMCIEnv::make_global.
   void destroy_global(JVMCIObject object);
-  void destroy_weak(JVMCIObject object);
 
   // Deoptimizes the nmethod (if any) in the HotSpotNmethod.address
   // field of mirror. The field is subsequently zeroed.
   void invalidate_nmethod_mirror(JVMCIObject mirror, JVMCI_TRAPS);
 
@@ -397,13 +400,10 @@
 
  private:
   JVMCICompileState* _compile_state;
 
  public:
-  static JavaVM* get_shared_library_javavm() { return _shared_library_javavm; }
-  static void* get_shared_library_handle()   { return _shared_library_handle; }
-  static char* get_shared_library_path()     { return _shared_library_path; }
 
   // Determines if this is for the JVMCI runtime in the HotSpot
   // heap (true) or the shared library heap (false).
   bool is_hotspot() { return _is_hotspot; }
 
diff a/src/hotspot/share/jvmci/jvmciJavaClasses.cpp b/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
--- a/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
+++ b/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
@@ -81,10 +81,11 @@
   if (static_field) {
     // Must ensure classes for static fields are initialized as the
     // accessor itself does not include a class initialization check.
     ik->initialize(CHECK);
   }
+  JVMCI_event_2("   field offset for %s %s.%s = %d", signature, ik->external_name(), name, dest_offset);
 }
 
 #ifndef PRODUCT
 static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {
   Method* method;
@@ -115,11 +116,12 @@
 jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;
 jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;
 
 #define START_CLASS(className, fullClassName)                          { \
   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \
-  className::_klass = InstanceKlass::cast(k); \
+  className::_klass = InstanceKlass::cast(k);                                     \
+  JVMCI_event_2(" klass for %s = " PTR_FORMAT, k->external_name(), p2i(k));       \
   className::_klass->initialize(CHECK);
 
 #define END_CLASS }
 
 #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);
@@ -284,17 +286,19 @@
     return;
   }
   if (env->ExceptionCheck()) {
     return;
   }
+  jfieldID current = fieldid;
   if (static_field) {
     // Class initialization barrier
     fieldid = env->GetStaticFieldID(clazz, name, signature);
   } else {
     // Class initialization barrier
     fieldid = env->GetFieldID(clazz, name, signature);
   }
+  JVMCI_event_2("   jfieldID for %s %s.%s = " PTR_FORMAT, signature, class_name, name, p2i(fieldid));
 
   if (env->ExceptionCheck()) {
     env->ExceptionDescribe();
     env->ExceptionClear();
     ResourceMark rm;
@@ -310,11 +314,13 @@
     st->print_cr("class %s", current_class_name);                                           \
   } else {                                                                                  \
     jclass k = env->FindClass(current_class_name);                                          \
     JVMCI_EXCEPTION_CHECK(env, "FindClass(%s)", current_class_name);                        \
     assert(k != NULL, #fullClassName " not initialized");                                   \
-    className::_class = (jclass) env->NewGlobalRef(k);                                      \
+    k = (jclass) env->NewGlobalRef(k);                                                      \
+    JVMCI_event_2(" jclass for %s = " PTR_FORMAT, current_class_name, p2i(k));              \
+    className::_class = k;                                                                  \
   }
 
 #define END_CLASS current_class_name = NULL; }
 
 #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);
@@ -327,18 +333,22 @@
 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
 #define STATIC_INT_FIELD(className, name) FIELD(className, name, "I", true)
 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", true)
 
 #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \
-          if (JVMCILibDumpJNIConfig != NULL) {                                                       \
-            fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \
-            st->print_cr("method %s %s %s", current_class_name, methodName, signature);              \
-          } else {                                                                                   \
-                  dst = env->jniGetMethod(clazz, methodName, signature);                                   \
-                  JVMCI_EXCEPTION_CHECK(env, #jniGetMethod "(%s.%s%s)", current_class_name, methodName, signature); \
-                assert(dst != NULL, "uninitialized");                                          \
-          }
+    if (JVMCILibDumpJNIConfig != NULL) {                                                       \
+      fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \
+      st->print_cr("method %s %s %s", current_class_name, methodName, signature);              \
+    } else {                                                                                   \
+      jmethodID current = dst;                                                                 \
+      dst = env->jniGetMethod(clazz, methodName, signature);                                   \
+      JVMCI_EXCEPTION_CHECK(env, #jniGetMethod "(%s.%s%s)",                                    \
+                  current_class_name, methodName, signature);                                  \
+      assert(dst != NULL, "uninitialized");                                                    \
+      JVMCI_event_2("   jmethodID for %s.%s%s = " PTR_FORMAT,                                  \
+                  current_class_name, methodName, signature, p2i(dst));                        \
+    }
 
 #define GET_JNI_CONSTRUCTOR(clazz, signature) \
   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, "<init>", signature) \
 
 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
@@ -491,34 +501,34 @@
 #undef BOX_CLASSES
 #undef IN_CLASS
 
 #define CC (char*)  /*cast a literal from (const char*)*/
 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &(f))
+}
 
-  if (env != JavaThread::current()->jni_environment()) {
-    jclass clazz = env->FindClass("jdk/vm/ci/hotspot/CompilerToVM");
+static void register_natives_for_class(JNIEnv* env, jclass clazz, const char* name, const JNINativeMethod *methods, jint nMethods) {
+  if (clazz == NULL) {
+    clazz = env->FindClass(name);
     if (env->ExceptionCheck()) {
       env->ExceptionDescribe();
-      guarantee(false, "Could not find class jdk/vm/ci/hotspot/CompilerToVM");
-    }
-    JNINativeMethod CompilerToVM_native_methods[] = {
-      { CC"registerNatives",     CC"()V", FN_PTR(JVM_RegisterJVMCINatives)     },
-    };
-    env->RegisterNatives(clazz, CompilerToVM_native_methods, 1);
-    if (env->ExceptionCheck()) {
-      env->ExceptionDescribe();
-      guarantee(false, "");
+      fatal("Could not find class %s", name);
     }
+  }
+  env->RegisterNatives(clazz, methods, nMethods);
+  if (env->ExceptionCheck()) {
+    env->ExceptionDescribe();
+    fatal("Failure registering natives for %s", name);
+  }
+}
 
-    JNINativeMethod JVMCI_native_methods[] = {
-      { CC"initializeRuntime",   CC"()Ljdk/vm/ci/runtime/JVMCIRuntime;", FN_PTR(JVM_GetJVMCIRuntime) },
-    };
-    env->RegisterNatives(JVMCI::clazz(), JVMCI_native_methods, 1);
-    if (env->ExceptionCheck()) {
-      env->ExceptionDescribe();
-      guarantee(false, "");
-    }
+void JNIJVMCI::register_natives(JNIEnv* env) {
+  if (env != JavaThread::current()->jni_environment()) {
+    JNINativeMethod CompilerToVM_nmethods[] = {{ CC"registerNatives", CC"()V", FN_PTR(JVM_RegisterJVMCINatives) }};
+    JNINativeMethod JVMCI_nmethods[] = {{ CC"initializeRuntime",   CC"()Ljdk/vm/ci/runtime/JVMCIRuntime;", FN_PTR(JVM_GetJVMCIRuntime) }};
+
+    register_natives_for_class(env, NULL, "jdk/vm/ci/hotspot/CompilerToVM", CompilerToVM_nmethods, 1);
+    register_natives_for_class(env, JVMCI::clazz(), "jdk/vm/ci/runtime/JVMCI", JVMCI_nmethods, 1);
   }
 }
 
 #undef METHOD
 #undef CONSTRUCTOR
diff a/src/hotspot/share/jvmci/jvmciJavaClasses.hpp b/src/hotspot/share/jvmci/jvmciJavaClasses.hpp
--- a/src/hotspot/share/jvmci/jvmciJavaClasses.hpp
+++ b/src/hotspot/share/jvmci/jvmciJavaClasses.hpp
@@ -122,11 +122,11 @@
   start_class(HotSpotCompiledNmethod, jdk_vm_ci_hotspot_HotSpotCompiledNmethod)                               \
     object_field(HotSpotCompiledNmethod, method, "Ljdk/vm/ci/hotspot/HotSpotResolvedJavaMethod;")             \
     object_field(HotSpotCompiledNmethod, installationFailureMessage, "Ljava/lang/String;")                    \
     int_field(HotSpotCompiledNmethod, entryBCI)                                                               \
     int_field(HotSpotCompiledNmethod, id)                                                                     \
-    long_field(HotSpotCompiledNmethod, compileState)                                                           \
+    long_field(HotSpotCompiledNmethod, compileState)                                                          \
     boolean_field(HotSpotCompiledNmethod, hasUnsafeAccess)                                                    \
   end_class                                                                                                   \
   start_class(HotSpotForeignCallTarget, jdk_vm_ci_hotspot_HotSpotForeignCallTarget)                           \
     long_field(HotSpotForeignCallTarget, address)                                                             \
   end_class                                                                                                   \
@@ -542,11 +542,11 @@
   friend class JNIJVMCI;                                                                            \
   private:                                                                                          \
   static void check(JVMCIEnv* jvmciEnv, JVMCIObject obj, const char* field_name, jfieldID offset);  \
   static jclass _class;                                                                             \
 public:                                                                                             \
- static jclass clazz() { assert(_class != NULL, #fullClassName " uninitialized"); return _class; }                         \
+ static jclass clazz() { assert(_class != NULL, #fullClassName " uninitialized"); return _class; }  \
  static jclass fullClassName ##_class()  { assert(_class != NULL, "uninit"); return _class; }
 
 #undef METHOD
 #undef CONSTRUCTOR
 #undef FIELD
@@ -637,10 +637,11 @@
   static jmethodID HotSpotResolvedObjectTypeImpl_fromMetaspace_method() { assert(_HotSpotResolvedObjectTypeImpl_fromMetaspace_method != NULL, "uninit"); return _HotSpotResolvedObjectTypeImpl_fromMetaspace_method; }
   static jmethodID HotSpotResolvedPrimitiveType_fromMetaspace_method()  { assert(_HotSpotResolvedPrimitiveType_fromMetaspace_method  != NULL, "uninit"); return _HotSpotResolvedPrimitiveType_fromMetaspace_method; }
 
   static void initialize_ids(JNIEnv* env);
   static void initialize_field_id(JNIEnv* env, jfieldID &dest_offset, jclass klass, const char* klass_name, const char* name, const char* signature, bool static_field);
+  static void register_natives(JNIEnv* env);
 
   static jobject resolve_handle(JVMCIObject obj) { return obj.as_jobject(); }
   static JVMCIObject wrap(jobject obj) { return JVMCIObject(obj, false); }
 
   JVMCI_CLASSES_DO(JNI_START_CLASS, END_CLASS, CHAR_FIELD, INT_FIELD, BOOLEAN_FIELD, LONG_FIELD, FLOAT_FIELD, OBJECT_FIELD, PRIMARRAY_FIELD, OBJECTARRAY_FIELD, STATIC_OBJECT_FIELD, STATIC_OBJECTARRAY_FIELD, STATIC_INT_FIELD, STATIC_BOOLEAN_FIELD, METHOD, CONSTRUCTOR)
diff a/src/hotspot/share/jvmci/jvmciRuntime.cpp b/src/hotspot/share/jvmci/jvmciRuntime.cpp
--- a/src/hotspot/share/jvmci/jvmciRuntime.cpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.cpp
@@ -23,25 +23,30 @@
 
 #include "precompiled.hpp"
 #include "classfile/javaClasses.inline.hpp"
 #include "classfile/symbolTable.hpp"
 #include "compiler/compileBroker.hpp"
+#include "gc/shared/oopStorage.inline.hpp"
+#include "gc/shared/oopStorageSet.hpp"
 #include "jvmci/jniAccessMark.inline.hpp"
 #include "jvmci/jvmciCompilerToVM.hpp"
 #include "jvmci/jvmciRuntime.hpp"
+#include "jvmci/metadataHandles.hpp"
 #include "logging/log.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/universe.hpp"
 #include "oops/constantPool.inline.hpp"
 #include "oops/method.inline.hpp"
 #include "oops/objArrayKlass.hpp"
 #include "oops/oop.inline.hpp"
+#include "oops/typeArrayOop.inline.hpp"
 #include "runtime/atomic.hpp"
 #include "runtime/biasedLocking.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/fieldDescriptor.inline.hpp"
 #include "runtime/frame.inline.hpp"
+#include "runtime/jniHandles.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
 #if INCLUDE_G1GC
 #include "gc/g1/g1ThreadLocalData.hpp"
 #endif // INCLUDE_G1GC
 
@@ -703,10 +708,182 @@
       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
     }
   }
 }
 
+JVMCIRuntime::JVMCIRuntime(int id) {
+  _init_state = uninitialized;
+  _shared_library_javavm = NULL;
+  _id = id;
+  _metadata_handles = new MetadataHandles();
+  JVMCI_event_1("created new JVMCI runtime %d (" PTR_FORMAT ")", id, p2i(this));
+}
+
+// Handles to objects in the Hotspot heap.
+static OopStorage* object_handles() {
+  return OopStorageSet::vm_global();
+}
+
+jobject JVMCIRuntime::make_global(const Handle& obj) {
+  assert(!Universe::heap()->is_gc_active(), "can't extend the root set during GC");
+  assert(oopDesc::is_oop(obj()), "not an oop");
+  oop* ptr = object_handles()->allocate();
+  jobject res = NULL;
+  if (ptr != NULL) {
+    assert(*ptr == NULL, "invariant");
+    NativeAccess<>::oop_store(ptr, obj());
+    res = reinterpret_cast<jobject>(ptr);
+  } else {
+    vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,
+                          "Cannot create JVMCI oop handle");
+  }
+  MutexLocker ml(JVMCI_lock);
+  return res;
+}
+
+void JVMCIRuntime::destroy_global(jobject handle) {
+  // Assert before nulling out, for better debugging.
+  assert(is_global_handle(handle), "precondition");
+  oop* oop_ptr = reinterpret_cast<oop*>(handle);
+  NativeAccess<>::oop_store(oop_ptr, (oop)NULL);
+  object_handles()->release(oop_ptr);
+  MutexLocker ml(JVMCI_lock);
+}
+
+bool JVMCIRuntime::is_global_handle(jobject handle) {
+  const oop* ptr = reinterpret_cast<oop*>(handle);
+  return object_handles()->allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;
+}
+
+jmetadata JVMCIRuntime::allocate_handle(const methodHandle& handle) {
+  MutexLocker ml(JVMCI_lock);
+  return _metadata_handles->allocate_handle(handle);
+}
+
+jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle& handle) {
+  MutexLocker ml(JVMCI_lock);
+  return _metadata_handles->allocate_handle(handle);
+}
+
+void JVMCIRuntime::release_handle(jmetadata handle) {
+  MutexLocker ml(JVMCI_lock);
+  _metadata_handles->chain_free_list(handle);
+}
+
+// Function for redirecting shared library JavaVM output to tty
+static void _log(const char* buf, size_t count) {
+  tty->write((char*) buf, count);
+}
+
+// Function for shared library JavaVM to flush tty
+static void _flush_log() {
+  tty->flush();
+}
+
+// Function for shared library JavaVM to exit HotSpot on a fatal error
+static void _fatal() {
+  fatal("Fatal error in JVMCI shared library");
+}
+
+JNIEnv* JVMCIRuntime::init_shared_library_javavm() {
+  JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
+  if (javaVM == NULL) {
+    MutexLocker locker(JVMCI_lock);
+    // Check again under JVMCI_lock
+    javaVM = (JavaVM*) _shared_library_javavm;
+    if (javaVM != NULL) {
+      return NULL;
+    }
+    char* sl_path;
+    void* sl_handle = JVMCI::get_shared_library(sl_path, true);
+
+    jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);
+    typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);
+
+    JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, "JNI_CreateJavaVM"));
+    if (JNI_CreateJavaVM == NULL) {
+      vm_exit_during_initialization("Unable to find JNI_CreateJavaVM", sl_path);
+    }
+
+    ResourceMark rm;
+    JavaVMInitArgs vm_args;
+    vm_args.version = JNI_VERSION_1_2;
+    vm_args.ignoreUnrecognized = JNI_TRUE;
+    JavaVMOption options[4];
+    jlong javaVM_id = 0;
+
+    // Protocol: JVMCI shared library JavaVM should support a non-standard "_javavm_id"
+    // option whose extraInfo info field is a pointer to which a unique id for the
+    // JavaVM should be written.
+    options[0].optionString = (char*) "_javavm_id";
+    options[0].extraInfo = &javaVM_id;
+
+    options[1].optionString = (char*) "_log";
+    options[1].extraInfo = (void*) _log;
+    options[2].optionString = (char*) "_flush_log";
+    options[2].extraInfo = (void*) _flush_log;
+    options[3].optionString = (char*) "_fatal";
+    options[3].extraInfo = (void*) _fatal;
+
+    vm_args.version = JNI_VERSION_1_2;
+    vm_args.options = options;
+    vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);
+
+    JNIEnv* env = NULL;
+    int result = (*JNI_CreateJavaVM)(&javaVM, (void**) &env, &vm_args);
+    if (result == JNI_OK) {
+      guarantee(env != NULL, "missing env");
+      _shared_library_javavm = javaVM;
+      JVMCI_event_1("created JavaVM[%ld]@" PTR_FORMAT " for JVMCI runtime %d", javaVM_id, p2i(javaVM), _id);
+      return env;
+    } else {
+      vm_exit_during_initialization(err_msg("JNI_CreateJavaVM failed with return value %d", result), sl_path);
+    }
+  }
+  return NULL;
+}
+
+void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {
+  if (info != NULL) {
+    typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);
+    if (info_oop->length() < 4) {
+      JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg("%d < 4", info_oop->length()));
+    }
+    JavaVM* javaVM = (JavaVM*) _shared_library_javavm;
+    info_oop->long_at_put(0, (jlong) (address) javaVM);
+    info_oop->long_at_put(1, (jlong) (address) javaVM->functions->reserved0);
+    info_oop->long_at_put(2, (jlong) (address) javaVM->functions->reserved1);
+    info_oop->long_at_put(3, (jlong) (address) javaVM->functions->reserved2);
+  }
+}
+
+#define JAVAVM_CALL_BLOCK                                             \
+  guarantee(thread != NULL && _shared_library_javavm != NULL, "npe"); \
+  ThreadToNativeFromVM ttnfv(thread);                                 \
+  JavaVM* javavm = (JavaVM*) _shared_library_javavm;
+
+jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {
+  JAVAVM_CALL_BLOCK
+  return javavm->AttachCurrentThread(penv, args);
+}
+
+jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {
+  JAVAVM_CALL_BLOCK
+  return javavm->AttachCurrentThreadAsDaemon(penv, args);
+}
+
+jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {
+  JAVAVM_CALL_BLOCK
+  return javavm->DetachCurrentThread();
+}
+
+jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {
+  JAVAVM_CALL_BLOCK
+  return javavm->GetEnv(penv, version);
+}
+#undef JAVAVM_CALL_BLOCK                                             \
+
 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
   if (is_HotSpotJVMCIRuntime_initialized()) {
     if (JVMCIENV->is_hotspot() && UseJVMCINativeLibrary) {
       JVMCI_THROW_MSG(InternalError, "JVMCI has already been enabled in the JVMCI shared library");
     }
@@ -716,33 +893,36 @@
 
   // This should only be called in the context of the JVMCI class being initialized
   JVMCIObject result = JVMCIENV->call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 
   _HotSpotJVMCIRuntime_instance = JVMCIENV->make_global(result);
+  JVMCI::_is_initialized = true;
 }
 
 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
-  assert(this != NULL, "sanity");
   // Check first without JVMCI_lock
-  if (_initialized) {
+  if (_init_state == fully_initialized) {
     return;
   }
 
   MutexLocker locker(JVMCI_lock);
   // Check again under JVMCI_lock
-  if (_initialized) {
+  if (_init_state == fully_initialized) {
     return;
   }
 
-  while (_being_initialized) {
+  while (_init_state == being_initialized) {
+    JVMCI_event_1("waiting for initialization of JVMCI runtime %d", _id);
     JVMCI_lock->wait();
-    if (_initialized) {
+    if (_init_state == fully_initialized) {
+      JVMCI_event_1("done waiting for initialization of JVMCI runtime %d", _id);
       return;
     }
   }
 
-  _being_initialized = true;
+  JVMCI_event_1("initializing JVMCI runtime %d", _id);
+  _init_state = being_initialized;
 
   {
     MutexUnlocker unlock(JVMCI_lock);
 
     HandleMark hm;
@@ -757,10 +937,15 @@
       if (jni()->ExceptionCheck()) {
         jni()->ExceptionDescribe();
         fatal("JNI exception during init");
       }
     }
+
+    if (!JVMCIENV->is_hotspot()) {
+      JNIAccessMark jni(JVMCIENV, THREAD);
+      JNIJVMCI::register_natives(jni.env());
+    }
     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
@@ -772,12 +957,12 @@
     if (!JVMCIENV->is_hotspot()) {
       JVMCIENV->copy_saved_properties();
     }
   }
 
-  _initialized = true;
-  _being_initialized = false;
+  _init_state = fully_initialized;
+  JVMCI_event_1("initialized JVMCI runtime %d", _id);
   JVMCI_lock->notify_all();
 }
 
 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
   Thread* THREAD = Thread::current();
@@ -815,12 +1000,11 @@
   initialize(JVMCIENV);
   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
   return _HotSpotJVMCIRuntime_instance;
 }
 
-
-// private void CompilerToVM.registerNatives()
+// private static void CompilerToVM.registerNatives()
 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
   JNI_JVMCIENV(thread, env);
 
   if (!EnableJVMCI) {
     JVMCI_THROW_MSG(InternalError, "JVMCI is not enabled");
@@ -852,20 +1036,21 @@
   }
 JVM_END
 
 
 void JVMCIRuntime::shutdown() {
-  if (is_HotSpotJVMCIRuntime_initialized()) {
-    _shutdown_called = true;
-
-    THREAD_JVMCIENV(JavaThread::current());
+  if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
+    JVMCI_event_1("shutting down HotSpotJVMCIRuntime for JVMCI runtime %d", _id);
+    JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);
+    JVMCIEnv* JVMCIENV = &__stack_jvmci_env__;
     JVMCIENV->call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
+    JVMCI_event_1("shut down HotSpotJVMCIRuntime for JVMCI runtime %d", _id);
   }
 }
 
 void JVMCIRuntime::bootstrap_finished(TRAPS) {
-  if (is_HotSpotJVMCIRuntime_initialized()) {
+  if (_HotSpotJVMCIRuntime_instance.is_non_null()) {
     THREAD_JVMCIENV(JavaThread::current());
     JVMCIENV->call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
   }
 }
 
@@ -1288,14 +1473,14 @@
 
   bool is_osr = entry_bci != InvocationEntryBci;
   if (compiler->is_bootstrapping() && is_osr) {
     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
     // and we know that there are no endless loops
-    compile_state->set_failure(true, "No OSR during boostrap");
+    compile_state->set_failure(true, "No OSR during bootstrap");
     return;
   }
-  if (JVMCI::shutdown_called()) {
+  if (JVMCI::in_shutdown()) {
     compile_state->set_failure(false, "Avoiding compilation during shutdown");
     return;
   }
 
   HandleMark hm;
diff a/src/hotspot/share/jvmci/jvmciRuntime.hpp b/src/hotspot/share/jvmci/jvmciRuntime.hpp
--- a/src/hotspot/share/jvmci/jvmciRuntime.hpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.hpp
@@ -26,14 +26,16 @@
 
 #include "code/nmethod.hpp"
 #include "jvmci/jvmci.hpp"
 #include "jvmci/jvmciExceptions.hpp"
 #include "jvmci/jvmciObject.hpp"
+#include "utilities/linkedlist.hpp"
 
 class JVMCIEnv;
 class JVMCICompiler;
 class JVMCICompileState;
+class MetadataHandles;
 
 // Encapsulates the JVMCI metadata for an nmethod.
 // JVMCINMethodData objects are inlined into nmethods
 // at nmethod::_jvmci_data_offset.
 class JVMCINMethodData {
@@ -84,10 +86,11 @@
 };
 
 // A top level class that represents an initialized JVMCI runtime.
 // There is one instance of this class per HotSpotJVMCIRuntime object.
 class JVMCIRuntime: public CHeapObj<mtJVMCI> {
+  friend class JVMCI;
  public:
   // Constants describing whether JVMCI wants to be able to adjust the compilation
   // level selected for a method by the VM compilation policy and if so, based on
   // what information about the method being schedule for compilation.
   enum CompLevelAdjustment {
@@ -95,16 +98,37 @@
      by_holder = 1,        // adjust based on declaring class of method
      by_full_signature = 2 // adjust based on declaring class, name and signature of method
   };
 
  private:
-  volatile bool _being_initialized;
-  volatile bool _initialized;
 
+  enum InitState {
+    uninitialized,
+    being_initialized,
+    fully_initialized
+  };
+
+  // Initialization state of this JVMCIRuntime.
+  InitState _init_state;
+
+  // A wrapper for a VM scoped JNI global handle (i.e. JVMCIEnv::make_global)
+  // to a HotSpotJVMCIRuntime instance. This JNI global handle must never
+  // be explicitly destroyed as it can be accessed in a racy way during
+  // JVMCI shutdown. Furthermore, it will be reclaimed when
+  // the VM or shared library JavaVM managing the handle dies.
   JVMCIObject _HotSpotJVMCIRuntime_instance;
 
-  bool _shutdown_called;
+  // Result of calling JNI_CreateJavaVM in the JVMCI shared library.
+  // Must only be modified under JVMCI_lock.
+  volatile JavaVM* _shared_library_javavm;
+
+  // The HotSpot heap based runtime will have an id of -1 and the
+  // JVMCI shared library runtime will have an id of 0.
+  int _id;
+
+  // Handles to Metadata objects.
+  MetadataHandles* _metadata_handles;
 
   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);
 
   // Implementation methods for loading and constant pool access.
   static Klass* get_klass_by_name_impl(Klass*& accessing_klass,
@@ -129,48 +153,83 @@
                                   Symbol*         sig,
                                   Bytecodes::Code bc,
                                   constantTag     tag);
 
  public:
-  JVMCIRuntime() {
-    _initialized = false;
-    _being_initialized = false;
-    _shutdown_called = false;
-  }
-
-  /**
-   * Compute offsets and construct any state required before executing JVMCI code.
-   */
+  JVMCIRuntime(int id);
+
+  int id() const        { return _id;   }
+
+  // Ensures that a JVMCI shared library JavaVM exists for this runtime.
+  // If the JavaVM was created by this call, then the thread-local JNI
+  // interface pointer for the JavaVM is returned otherwise NULL is returned.
+  JNIEnv* init_shared_library_javavm();
+
+  // Determines if the JVMCI shared library JavaVM exists for this runtime.
+  bool has_shared_library_javavm() { return _shared_library_javavm != NULL; }
+
+  // Copies info about the JVMCI shared library JavaVM associated with this
+  // runtime into `info` as follows:
+  // {
+  //     javaVM, // the {@code JavaVM*} value
+  //     javaVM->functions->reserved0,
+  //     javaVM->functions->reserved1,
+  //     javaVM->functions->reserved2
+  // }
+  void init_JavaVM_info(jlongArray info, JVMCI_TRAPS);
+
+  // Wrappers for calling Invocation Interface functions on the
+  // JVMCI shared library JavaVM associated with this runtime.
+  // These wrappers ensure all required thread state transitions are performed.
+  jint AttachCurrentThread(JavaThread* thread, void **penv, void *args);
+  jint AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args);
+  jint DetachCurrentThread(JavaThread* thread);
+  jint GetEnv(JavaThread* thread, void **penv, jint version);
+
+  // Compute offsets and construct any state required before executing JVMCI code.
   void initialize(JVMCIEnv* jvmciEnv);
 
-  /**
-   * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
-   */
+  // Allocation and management of JNI global object handles
+  // whose lifetime is scoped by this JVMCIRuntime. The lifetime
+  // of these handles is the same as the JVMCI shared library JavaVM
+  // associated with this JVMCIRuntime. These JNI handles are
+  // used when creating a IndirectHotSpotObjectConstantImpl in the
+  // shared library JavaVM.
+  jobject make_global(const Handle& obj);
+  void destroy_global(jobject handle);
+  bool is_global_handle(jobject handle);
+
+  // Allocation and management of metadata handles.
+  jmetadata allocate_handle(const methodHandle& handle);
+  jmetadata allocate_handle(const constantPoolHandle& handle);
+  void release_handle(jmetadata handle);
+
+  // Gets the HotSpotJVMCIRuntime instance for this runtime,
+  // initializing it first if necessary.
   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 
   bool is_HotSpotJVMCIRuntime_initialized() {
     return _HotSpotJVMCIRuntime_instance.is_non_null();
   }
 
-  /**
-   * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
-   */
+  // Gets the current HotSpotJVMCIRuntime instance for this runtime which
+  // may be a "null" JVMCIObject value.
+  JVMCIObject probe_HotSpotJVMCIRuntime() {
+    return _HotSpotJVMCIRuntime_instance;
+  }
+
+  // Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
   void initialize_JVMCI(JVMCI_TRAPS);
 
-  /**
-   * Explicitly initialize HotSpotJVMCIRuntime itself
-   */
+  // Explicitly initialize HotSpotJVMCIRuntime itself
   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 
   void call_getCompiler(TRAPS);
 
+  // Shuts down this runtime by calling HotSpotJVMCIRuntime.shutdown().
   void shutdown();
 
-  bool shutdown_called() {
-    return _shutdown_called;
-  }
-
   void bootstrap_finished(TRAPS);
 
   // Look up a klass by name from a particular class loader (the accessor's).
   // If require_local, result must be defined in that class loader, or NULL.
   // If !require_local, a result from remote class loader may be reported,
@@ -220,11 +279,11 @@
                        int                       orig_pc_offset,
                        CodeBuffer*               code_buffer,
                        int                       frame_words,
                        OopMapSet*                oop_map_set,
                        ExceptionHandlerTable*    handler_table,
-                       ImplicitExceptionTable* implicit_exception_table,
+                       ImplicitExceptionTable*   implicit_exception_table,
                        AbstractCompiler*         compiler,
                        DebugInformationRecorder* debug_info,
                        Dependencies*             dependencies,
                        int                       compile_id,
                        bool                      has_unsafe_access,
@@ -233,13 +292,11 @@
                        JVMCIObject               nmethod_mirror,
                        FailedSpeculation**       failed_speculations,
                        char*                     speculations,
                        int                       speculations_len);
 
-  /**
-   * Exits the VM due to an unexpected exception.
-   */
+  // Exits the VM due to an unexpected exception.
   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);
 
   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);
 
 #define CHECK_EXIT THREAD); \
@@ -338,21 +395,6 @@
   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
 
   // Test only function
   static jint test_deoptimize_call_int(JavaThread* thread, int value);
 };
-
-// Tracing macros.
-
-#define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel >= 1)) ; else
-#define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel >= 2)) ; else
-#define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel >= 3)) ; else
-#define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel >= 4)) ; else
-#define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel >= 5)) ; else
-
-#define TRACE_jvmci_1 if (!(JVMCITraceLevel >= 1 && (tty->print(PTR_FORMAT " JVMCITrace-1: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_2 if (!(JVMCITraceLevel >= 2 && (tty->print(PTR_FORMAT "    JVMCITrace-2: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_3 if (!(JVMCITraceLevel >= 3 && (tty->print(PTR_FORMAT "       JVMCITrace-3: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_4 if (!(JVMCITraceLevel >= 4 && (tty->print(PTR_FORMAT "          JVMCITrace-4: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_5 if (!(JVMCITraceLevel >= 5 && (tty->print(PTR_FORMAT "             JVMCITrace-5: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-
 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
diff a/src/hotspot/share/jvmci/jvmci_globals.cpp b/src/hotspot/share/jvmci/jvmci_globals.cpp
--- a/src/hotspot/share/jvmci/jvmci_globals.cpp
+++ b/src/hotspot/share/jvmci/jvmci_globals.cpp
@@ -106,10 +106,11 @@
       FLAG_SET_DEFAULT(EagerJVMCI, false);
     }
   }
   JVMCI_FLAG_CHECKED(EagerJVMCI)
 
+  CHECK_NOT_SET(JVMCIEventLogLevel,           EnableJVMCI)
   CHECK_NOT_SET(JVMCITraceLevel,              EnableJVMCI)
   CHECK_NOT_SET(JVMCICounterSize,             EnableJVMCI)
   CHECK_NOT_SET(JVMCICountersExcludeCompiler, EnableJVMCI)
   CHECK_NOT_SET(JVMCIUseFastLocking,          EnableJVMCI)
   CHECK_NOT_SET(JVMCINMethodSizeLimit,        EnableJVMCI)
@@ -164,10 +165,12 @@
     "EagerJVMCI",
     "JVMCIThreads",
     "JVMCICounterSize",
     "JVMCICountersExcludeCompiler",
     "JVMCINMethodSizeLimit",
+    "JVMCIEventLogLevel",
+    "JVMCITraceLevel",
     "JVMCILibPath",
     "JVMCILibDumpJNIConfig",
     "UseJVMCINativeLibrary",
     NULL
   };
diff a/src/hotspot/share/jvmci/jvmci_globals.hpp b/src/hotspot/share/jvmci/jvmci_globals.hpp
--- a/src/hotspot/share/jvmci/jvmci_globals.hpp
+++ b/src/hotspot/share/jvmci/jvmci_globals.hpp
@@ -88,15 +88,17 @@
           range(0, max_jint))                                               \
                                                                             \
   NOT_COMPILER2(product(bool, ReduceInitialCardMarks, true,                 \
           "Defer write barriers of young objects"))                         \
                                                                             \
+  experimental(intx, JVMCIEventLogLevel, 1,                                 \
+          "Event log level for JVMCI")                                      \
+          range(0, 4)                                                       \
+                                                                            \
   experimental(intx, JVMCITraceLevel, 0,                                    \
-          "Trace level for JVMCI: "                                         \
-          "1 means emit a message for each CompilerToVM call,"              \
-          "levels greater than 1 provide progressively greater detail")     \
-          range(0, 6)                                                       \
+          "Trace level for JVMCI")                                          \
+          range(0, 4)                                                       \
                                                                             \
   experimental(intx, JVMCICounterSize, 0,                                   \
           "Reserved size for benchmark counters")                           \
           range(0, 1000000)                                                 \
                                                                             \
diff a/src/hotspot/share/jvmci/metadataHandleBlock.cpp b/src/hotspot/share/jvmci/metadataHandleBlock.cpp
--- a/src/hotspot/share/jvmci/metadataHandleBlock.cpp
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "precompiled.hpp"
-#include "jvmci/metadataHandleBlock.hpp"
-#include "runtime/atomic.hpp"
-
-MetadataHandleBlock* MetadataHandleBlock::_last = NULL;
-intptr_t             MetadataHandleBlock::_free_list = 0;
-int                  MetadataHandleBlock::_allocate_before_rebuild = 0;
-
-jmetadata MetadataHandleBlock::allocate_metadata_handle(Metadata* obj) {
-  assert(obj->is_valid() && obj->is_metadata(), "must be");
-
-  if (_last == NULL) {
-    // This is the first allocation.
-    _last = this;
-  }
-
-  HandleRecord* handle = get_handle();
-
-  if (handle != NULL) {
-    handle->set_value(obj);
-#ifdef METADATA_TRACK_NAMES
-    handle->set_name(obj->print_value_string());
-#endif
-    return (jmetadata) handle;
-  }
-
-  // Check if unused block follow last
-  if (_last->_next != NULL) {
-    // update last and retry
-    _last = _last->_next;
-    return allocate_metadata_handle(obj);
-  }
-
-  // No space available, we have to rebuild free list or expand
-  if (_allocate_before_rebuild == 0) {
-    rebuild_free_list();        // updates _allocate_before_rebuild counter
-  } else {
-    // Append new block
-    // This can block, but the caller has a metadata handle around this object.
-    _last->_next = allocate_block();
-    _last = _last->_next;
-    _allocate_before_rebuild--;
-  }
-  return allocate_metadata_handle(obj);  // retry
-}
-
-
-void MetadataHandleBlock::rebuild_free_list() {
-  assert(_allocate_before_rebuild == 0 && _free_list == 0, "just checking");
-  int free = 0;
-  int blocks = 0;
-  for (MetadataHandleBlock* current = this; current != NULL; current = current->_next) {
-    for (int index = 0; index < current->_top; index++) {
-      HandleRecord* handle = &(current->_handles)[index];
-      if (handle->value() == NULL) {
-        // this handle was cleared out by a delete call, reuse it
-        chain_free_list(handle);
-        free++;
-      }
-    }
-    // we should not rebuild free list if there are unused handles at the end
-    assert(current->_top == block_size_in_handles, "just checking");
-    blocks++;
-  }
-  // Heuristic: if more than half of the handles are NOT free we rebuild next time
-  // as well, otherwise we append a corresponding number of new blocks before
-  // attempting a free list rebuild again.
-  int total = blocks * block_size_in_handles;
-  int extra = total - 2*free;
-  if (extra > 0) {
-    // Not as many free handles as we would like - compute number of new blocks to append
-    _allocate_before_rebuild = (extra + block_size_in_handles - 1) / block_size_in_handles;
-  }
-}
-
-void MetadataHandleBlock::metadata_do(void f(Metadata*)) {
-  for (MetadataHandleBlock* current = this; current != NULL; current = current->_next) {
-    for (int index = 0; index < current->_top; index++) {
-      HandleRecord* root = &(current->_handles)[index];
-      Metadata* value = root->value();
-      // traverse heap pointers only, not deleted handles or free list
-      // pointers
-      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {
-        assert(value->is_valid(), "invalid metadata %s", get_name(index));
-        f(value);
-      }
-    }
-    // the next handle block is valid only if current block is full
-    if (current->_top < block_size_in_handles) {
-      break;
-    }
-  }
-}
-
-// Visit any live metadata handles and clean them up.  Since clearing of these handles is driven by
-// weak references they will be cleared at some point in the future when the reference cleaning logic is run.
-void MetadataHandleBlock::do_unloading() {
-  for (MetadataHandleBlock* current = this; current != NULL; current = current->_next) {
-    for (int index = 0; index < current->_top; index++) {
-      HandleRecord* handle = &(current->_handles)[index];
-      Metadata* value = handle->value();
-      // traverse heap pointers only, not deleted handles or free list
-      // pointers
-      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {
-        Klass* klass = NULL;
-        if (value->is_klass()) {
-          klass = (Klass*)value;
-        } else if (value->is_method()) {
-          Method* m = (Method*)value;
-          klass = m->method_holder();
-        } else if (value->is_constantPool()) {
-          ConstantPool* cp = (ConstantPool*)value;
-          klass = cp->pool_holder();
-        } else {
-          ShouldNotReachHere();
-        }
-        if (klass->class_loader_data()->is_unloading()) {
-          // This needs to be marked so that it's no longer scanned
-          // but can't be put on the free list yet. The
-          // HandleCleaner will set this to NULL and
-          // put it on the free list.
-          jlong old_value = Atomic::cmpxchg((jlong*)handle, (jlong) value, (jlong) (ptr_tag));
-          if (old_value == (jlong) value) {
-            // Success
-          } else {
-            guarantee(old_value == 0, "only other possible value");
-          }
-        }
-      }
-    }
-    // the next handle block is valid only if current block is full
-    if (current->_top < block_size_in_handles) {
-      break;
-    }
-  }
-}
diff a/src/hotspot/share/jvmci/metadataHandleBlock.hpp b/src/hotspot/share/jvmci/metadataHandleBlock.hpp
--- a/src/hotspot/share/jvmci/metadataHandleBlock.hpp
+++ /dev/null
@@ -1,170 +0,0 @@
-/*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#ifndef SHARE_JVMCI_METADATAHANDLEBLOCK_HPP
-#define SHARE_JVMCI_METADATAHANDLEBLOCK_HPP
-
-#include "oops/constantPool.hpp"
-#include "oops/metadata.hpp"
-#include "oops/method.hpp"
-#include "runtime/handles.hpp"
-#include "runtime/os.hpp"
-
-#ifdef ASSERT
-#define METADATA_TRACK_NAMES
-#endif
-
-struct _jmetadata {
- private:
-  Metadata* _value;
-#ifdef METADATA_TRACK_NAMES
-  // Debug data for tracking stale metadata
-  const char* _name;
-#endif
-
- public:
-  Metadata* value() { return _value; }
-
-#ifdef METADATA_TRACK_NAMES
-  void initialize() {
-    _value = NULL;
-    _name = NULL;
-  }
-#endif
-
-  void set_value(Metadata* value) {
-    _value = value;
-  }
-
-#ifdef METADATA_TRACK_NAMES
-  const char* name() { return _name; }
-  void set_name(const char* name) {
-    if (_name != NULL) {
-      os::free((void*) _name);
-      _name = NULL;
-    }
-    if (name != NULL) {
-      _name = os::strdup(name);
-    }
-  }
-#endif
-};
-
-typedef struct _jmetadata HandleRecord;
-typedef struct _jmetadata *jmetadata;
-
-// JVMCI maintains direct references to metadata. To make these references safe in the face of
-// class redefinition, they are held in handles so they can be scanned during GC. They are
-// managed in a cooperative way between the Java code and HotSpot. A handle is filled in and
-// passed back to the Java code which is responsible for setting the handle to NULL when it
-// is no longer in use. This is done by jdk.vm.ci.hotspot.HandleCleaner. The
-// rebuild_free_list function notices when the handle is clear and reclaims it for re-use.
-class MetadataHandleBlock : public CHeapObj<mtJVMCI> {
- private:
-  enum SomeConstants {
-    block_size_in_handles  = 32,      // Number of handles per handle block
-    ptr_tag = 1,
-    ptr_mask = ~((intptr_t)ptr_tag)
-  };
-
-
-  // Free handles always have their low bit set so those pointers can
-  // be distinguished from handles which are in use.  The last handle
-  // on the free list has a NULL pointer with the tag bit set, so it's
-  // clear that the handle has been reclaimed.  The _free_list is
-  // always a real pointer to a handle.
-
-  HandleRecord    _handles[block_size_in_handles]; // The handles
-  int             _top;                         // Index of next unused handle
-  MetadataHandleBlock* _next;                   // Link to next block
-
-  // The following instance variables are only used by the first block in a chain.
-  // Having two types of blocks complicates the code and the space overhead is negligible.
-  static MetadataHandleBlock* _last;                   // Last block in use
-  static intptr_t        _free_list;                   // Handle free list
-  static int             _allocate_before_rebuild;     // Number of blocks to allocate before rebuilding free list
-
-  MetadataHandleBlock() {
-    _top = 0;
-    _next = NULL;
-#ifdef METADATA_TRACK_NAMES
-    for (int i = 0; i < block_size_in_handles; i++) {
-      _handles[i].initialize();
-    }
-#endif
-  }
-
-  const char* get_name(int index) {
-#ifdef METADATA_TRACK_NAMES
-    return _handles[index].name();
-#else
-    return "<missing>";
-#endif
-  }
-
-  static HandleRecord* get_free_handle() {
-    assert(_free_list != 0, "should check before calling");
-    HandleRecord* handle = (HandleRecord*) (_free_list & ptr_mask);
-    _free_list = (ptr_mask & (intptr_t) (handle->value()));
-    assert(_free_list != ptr_tag, "should be null");
-    handle->set_value(NULL);
-    return handle;
-  }
-
-  static HandleRecord* get_handle() {
-    assert(_last != NULL, "sanity");
-    // Try last block
-    if (_last->_top < block_size_in_handles) {
-      return &(_last->_handles)[_last->_top++];
-    } else if (_free_list != 0) {
-      // Try free list
-      return get_free_handle();
-    }
-    return NULL;
-  }
-
-  void rebuild_free_list();
-
-  jmetadata allocate_metadata_handle(Metadata* metadata);
-
- public:
-  jmetadata allocate_handle(const methodHandle& handle)       { return allocate_metadata_handle(handle()); }
-  jmetadata allocate_handle(const constantPoolHandle& handle) { return allocate_metadata_handle(handle()); }
-
-  static MetadataHandleBlock* allocate_block() { return new MetadataHandleBlock(); }
-
-  // Adds `handle` to the free list in this block
-  static void chain_free_list(HandleRecord* handle) {
-    handle->set_value((Metadata*) (ptr_tag | _free_list));
-#ifdef METADATA_TRACK_NAMES
-    handle->set_name(NULL);
-#endif
-    _free_list = (intptr_t) handle;
-  }
-
-  void metadata_do(void f(Metadata*));
-
-  void do_unloading();
-};
-
-#endif // SHARE_JVMCI_METADATAHANDLEBLOCK_HPP
diff a/src/hotspot/share/jvmci/metadataHandles.cpp b/src/hotspot/share/jvmci/metadataHandles.cpp
--- /dev/null
+++ b/src/hotspot/share/jvmci/metadataHandles.cpp
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "precompiled.hpp"
+#include "jvmci/metadataHandles.hpp"
+#include "runtime/atomic.hpp"
+
+jmetadata MetadataHandles::allocate_metadata_handle(Metadata* obj) {
+  assert(obj->is_valid() && obj->is_metadata(), "must be");
+
+  if (_head == NULL) {
+    // This is the first allocation.
+    _head = new MetadataHandleBlock();
+    _last = _head;
+    _num_blocks++;
+  }
+
+  HandleRecord* handle = get_handle();
+
+  if (handle != NULL) {
+    handle->set_value(obj);
+#ifdef METADATA_TRACK_NAMES
+    handle->set_name(obj->print_value_string());
+#endif
+    return (jmetadata) handle;
+  }
+
+  // Check if an unused block follows last
+  if (_last->_next != NULL) {
+    // update last and retry
+    _last = _last->_next;
+    return allocate_metadata_handle(obj);
+  }
+
+  // No space available, we have to rebuild free list or expand
+  if (_allocate_before_rebuild == 0) {
+    rebuild_free_list(); // updates _allocate_before_rebuild counter
+  } else {
+    // Append new block
+    _last->_next = new MetadataHandleBlock();
+    _last = _last->_next;
+    _allocate_before_rebuild--;
+    _num_blocks++;
+  }
+  return allocate_metadata_handle(obj);  // retry
+}
+
+
+void MetadataHandles::rebuild_free_list() {
+  assert(_allocate_before_rebuild == 0 && _free_list == 0, "just checking");
+  int free = 0;
+  int blocks = 0;
+  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {
+    for (int index = 0; index < current->_top; index++) {
+      HandleRecord* handle = &(current->_handles)[index];
+      if (handle->value() == NULL) {
+        // this handle was cleared out by a delete call, reuse it
+        chain_free_list(handle);
+        free++;
+      }
+    }
+    // we should not rebuild free list if there are unused handles at the end
+    assert(current->_top == MetadataHandleBlock::block_size_in_handles, "just checking");
+    blocks++;
+  }
+  assert(_num_blocks == blocks, "%d != %d", _num_blocks, blocks);
+  assert(_num_free_handles == free, "%d != %d", _num_free_handles, free);
+  // Heuristic: if more than half of the handles are NOT free we rebuild next time
+  // as well, otherwise we append a corresponding number of new blocks before
+  // attempting a free list rebuild again.
+  int total = blocks * MetadataHandleBlock::block_size_in_handles;
+  int extra = total - 2*free;
+  if (extra > 0) {
+    // Not as many free handles as we would like - compute number of new blocks to append
+    _allocate_before_rebuild = (extra + MetadataHandleBlock::block_size_in_handles - 1) / MetadataHandleBlock::block_size_in_handles;
+  }
+}
+
+void MetadataHandles::clear() {
+  _free_list = 0;
+  _last = _head;
+  if (_head != NULL) {
+    for (MetadataHandleBlock* block = _head; block != NULL; block = block->_next) {
+      block->_top = 0;
+    }
+  }
+  _num_handles = 0;
+  _num_free_handles = 0;
+}
+
+void MetadataHandles::metadata_do(void f(Metadata*)) {
+  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {
+    for (int index = 0; index < current->_top; index++) {
+      HandleRecord* root = &(current->_handles)[index];
+      Metadata* value = root->value();
+      // traverse heap pointers only, not deleted handles or free list
+      // pointers
+      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {
+        assert(value->is_valid(), "invalid metadata %s", current->get_name(index));
+        f(value);
+      }
+    }
+    // the next handle block is valid only if current block is full
+    if (current->_top < MetadataHandleBlock::block_size_in_handles) {
+      break;
+    }
+  }
+}
+
+// Visit any live metadata handles and clean them up.  Since clearing of these handles is driven by
+// weak references they will be cleared at some point in the future when the reference cleaning logic is run.
+void MetadataHandles::do_unloading() {
+  for (MetadataHandleBlock* current = _head; current != NULL; current = current->_next) {
+    for (int index = 0; index < current->_top; index++) {
+      HandleRecord* handle = &(current->_handles)[index];
+      Metadata* value = handle->value();
+      // traverse heap pointers only, not deleted handles or free list
+      // pointers
+      if (value != NULL && ((intptr_t) value & ptr_tag) == 0) {
+        Klass* klass = NULL;
+        if (value->is_klass()) {
+          klass = (Klass*)value;
+        } else if (value->is_method()) {
+          Method* m = (Method*)value;
+          klass = m->method_holder();
+        } else if (value->is_constantPool()) {
+          ConstantPool* cp = (ConstantPool*)value;
+          klass = cp->pool_holder();
+        } else {
+          ShouldNotReachHere();
+        }
+        if (klass->class_loader_data()->is_unloading()) {
+          // This needs to be marked so that it's no longer scanned
+          // but can't be put on the free list yet. The
+          // HandleCleaner will set this to NULL and
+          // put it on the free list.
+          jlong old_value = Atomic::cmpxchg((jlong*)handle, (jlong) value, (jlong) (ptr_tag));
+          if (old_value == (jlong) value) {
+            // Success
+          } else {
+            guarantee(old_value == 0, "only other possible value");
+          }
+        }
+      }
+    }
+    // the next handle block is valid only if current block is full
+    if (current->_top < MetadataHandleBlock::block_size_in_handles) {
+      break;
+    }
+  }
+}
diff a/src/hotspot/share/jvmci/metadataHandles.hpp b/src/hotspot/share/jvmci/metadataHandles.hpp
--- /dev/null
+++ b/src/hotspot/share/jvmci/metadataHandles.hpp
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef SHARE_JVMCI_METADATAHANDLES_HPP
+#define SHARE_JVMCI_METADATAHANDLES_HPP
+
+#include "oops/constantPool.hpp"
+#include "oops/metadata.hpp"
+#include "oops/method.hpp"
+#include "runtime/handles.hpp"
+#include "runtime/os.hpp"
+
+#ifdef ASSERT
+#define METADATA_TRACK_NAMES
+#endif
+
+struct _jmetadata {
+ private:
+  Metadata* _value;
+#ifdef METADATA_TRACK_NAMES
+  // Debug data for tracking stale metadata
+  const char* _name;
+#endif
+
+ public:
+  Metadata* value() { return _value; }
+
+#ifdef METADATA_TRACK_NAMES
+  void initialize() {
+    _value = NULL;
+    _name = NULL;
+  }
+#endif
+
+  void set_value(Metadata* value) {
+    _value = value;
+  }
+
+#ifdef METADATA_TRACK_NAMES
+  const char* name() { return _name; }
+  void set_name(const char* name) {
+    if (_name != NULL) {
+      os::free((void*) _name);
+      _name = NULL;
+    }
+    if (name != NULL) {
+      _name = os::strdup(name);
+    }
+  }
+#endif
+};
+
+typedef struct _jmetadata HandleRecord;
+typedef struct _jmetadata *jmetadata;
+class MetadataHandles;
+
+class MetadataHandleBlock : public CHeapObj<mtJVMCI> {
+  friend class MetadataHandles;
+ private:
+  enum SomeConstants {
+    block_size_in_handles  = 32 // Number of handles per handle block
+  };
+
+  // Free handles always have their low bit set so those pointers can
+  // be distinguished from handles which are in use.  The last handle
+  // on the free list has a NULL pointer with the tag bit set, so it's
+  // clear that the handle has been reclaimed.  The _free_list is
+  // always a real pointer to a handle.
+
+  HandleRecord    _handles[block_size_in_handles]; // The handles
+  int             _top;                         // Index of next unused handle
+  MetadataHandleBlock* _next;                   // Link to next block
+
+  MetadataHandleBlock() {
+    _top = 0;
+    _next = NULL;
+#ifdef METADATA_TRACK_NAMES
+    for (int i = 0; i < block_size_in_handles; i++) {
+      _handles[i].initialize();
+    }
+#endif
+  }
+
+  const char* get_name(int index) {
+#ifdef METADATA_TRACK_NAMES
+    return _handles[index].name();
+#else
+    return "<missing>";
+#endif
+  }
+};
+
+// JVMCI maintains direct references to metadata. To make these references safe in the face of
+// class redefinition, they are held in handles so they can be scanned during GC. They are
+// managed in a cooperative way between the Java code and HotSpot. A handle is filled in and
+// passed back to the Java code which is responsible for setting the handle to NULL when it
+// is no longer in use. This is done by jdk.vm.ci.hotspot.HandleCleaner. The
+// rebuild_free_list function notices when the handle is clear and reclaims it for re-use.
+class MetadataHandles : public CHeapObj<mtJVMCI> {
+ private:
+  enum SomeConstants {
+    ptr_tag = 1,
+    ptr_mask = ~((intptr_t)ptr_tag)
+  };
+
+  MetadataHandleBlock*   _head; // First block
+  MetadataHandleBlock*   _last; // Last block in use
+  intptr_t          _free_list; // Handle free list
+  int _allocate_before_rebuild; // Number of blocks to allocate before rebuilding free list
+  int              _num_blocks; // Number of blocks
+  int             _num_handles;
+  int        _num_free_handles;
+
+  HandleRecord* get_free_handle() {
+    HandleRecord* handle = (HandleRecord*) (_free_list & ptr_mask);
+    _free_list = (ptr_mask & (intptr_t) (handle->value()));
+    assert(_free_list != ptr_tag, "should be null");
+    _num_free_handles--;
+    return handle;
+  }
+
+  HandleRecord* get_handle() {
+    assert(_last != NULL, "sanity");
+    // Try last block
+    if (_last->_top < MetadataHandleBlock::block_size_in_handles) {
+      _num_handles++;
+      return &(_last->_handles)[_last->_top++];
+    } else if (_free_list != 0) {
+      // Try free list
+      return get_free_handle();
+    }
+    return NULL;
+  }
+
+  void rebuild_free_list();
+
+  jmetadata allocate_metadata_handle(Metadata* metadata);
+
+ public:
+  MetadataHandles() {
+    _head = NULL;
+    _last = NULL;
+    _free_list = 0;
+    _allocate_before_rebuild = 0;
+    _num_blocks = 0;
+    _num_handles = 0;
+    _num_free_handles = 0;
+  }
+
+  int num_handles() const { return _num_handles; }
+  int num_free_handles() const { return _num_free_handles; }
+  int num_blocks() const { return _num_blocks; }
+
+  jmetadata allocate_handle(const methodHandle& handle)       { return allocate_metadata_handle(handle()); }
+  jmetadata allocate_handle(const constantPoolHandle& handle) { return allocate_metadata_handle(handle()); }
+
+  // Adds `handle` to the free list
+  void chain_free_list(HandleRecord* handle) {
+    handle->set_value((Metadata*) (ptr_tag | _free_list));
+#ifdef METADATA_TRACK_NAMES
+    handle->set_name(NULL);
+#endif
+    _free_list = (intptr_t) handle;
+    _num_free_handles++;
+  }
+
+  // Clears all handles without releasing any handle memory.
+  void clear();
+
+  void metadata_do(void f(Metadata*));
+
+  void do_unloading();
+};
+
+#endif // SHARE_JVMCI_METADATAHANDLES_HPP
diff a/src/hotspot/share/runtime/java.cpp b/src/hotspot/share/runtime/java.cpp
--- a/src/hotspot/share/runtime/java.cpp
+++ b/src/hotspot/share/runtime/java.cpp
@@ -429,11 +429,13 @@
       }
     }
   }
 
 #if INCLUDE_JVMCI
-  JVMCI::shutdown();
+  if (EnableJVMCI) {
+    JVMCI::shutdown();
+  }
 #endif
 
   // Hang forever on exit if we're reporting an error.
   if (ShowMessageBoxOnError && VMError::is_error_reported()) {
     os::infinite_sleep();
diff a/src/java.base/share/classes/java/util/zip/ZipEntry.java b/src/java.base/share/classes/java/util/zip/ZipEntry.java
--- a/src/java.base/share/classes/java/util/zip/ZipEntry.java
+++ b/src/java.base/share/classes/java/util/zip/ZipEntry.java
@@ -55,11 +55,11 @@
     long csize = -1;    // compressed size of entry data
     int method = -1;    // compression method
     int flag = 0;       // general purpose flag
     byte[] extra;       // optional extra field data for entry
     String comment;     // optional comment string for entry
-
+    int posixPerms = -1;// posix permissions
     /**
      * Compression method for uncompressed entries.
      */
     public static final int STORED = 0;
 
@@ -129,10 +129,11 @@
         csize = e.csize;
         method = e.method;
         flag = e.flag;
         extra = e.extra;
         comment = e.comment;
+        posixPerms = e.posixPerms;
     }
 
     /**
      * Returns the name of the entry.
      * @return the name of the entry
diff a/src/java.base/share/classes/java/util/zip/ZipFile.java b/src/java.base/share/classes/java/util/zip/ZipFile.java
--- a/src/java.base/share/classes/java/util/zip/ZipFile.java
+++ b/src/java.base/share/classes/java/util/zip/ZipFile.java
@@ -655,10 +655,15 @@
         e.xdostime = CENTIM(cen, pos);
         e.crc = CENCRC(cen, pos);
         e.size = CENLEN(cen, pos);
         e.csize = CENSIZ(cen, pos);
         e.method = CENHOW(cen, pos);
+        if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {
+            // 12 bits for setuid, setgid, sticky + perms
+            e.posixPerms = CENATX_PERMS(cen, pos) & 0xFFF;
+        }
+
         if (elen != 0) {
             int start = pos + CENHDR + nlen;
             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
         }
         if (clen != 0) {
@@ -1090,10 +1095,20 @@
                 }
                 @Override
                 public Stream<String> entryNameStream(ZipFile zip) {
                     return zip.entryNameStream();
                 }
+                // only set posix perms value via ZipEntry contructor for now
+                @Override
+                public int getPosixPerms(ZipEntry ze) {
+                    return ze.posixPerms;
+                }
+                @Override
+                public void setPosixPerms(ZipEntry ze, int perms) {
+                    ze.posixPerms = perms;
+                }
+
              }
         );
         isWindows = VM.getSavedProperty("os.name").contains("Windows");
     }
 
diff a/src/java.base/share/classes/java/util/zip/ZipOutputStream.java b/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
--- a/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
+++ b/src/java.base/share/classes/java/util/zip/ZipOutputStream.java
@@ -504,10 +504,19 @@
             writeInt(e.csize);          // compressed size
             writeInt(e.size);           // uncompressed size
         }
     }
 
+    /**
+     * Adds information about compatibility of file attribute information
+     * to a version value.
+     */
+    private int versionMadeBy(ZipEntry e, int version) {
+        return (e.posixPerms < 0) ? version :
+                VERSION_MADE_BY_BASE_UNIX | (version & 0xff);
+    }
+
     /*
      * Write central directory (CEN) header for specified entry.
      * REMIND: add support for file attributes
      */
     private void writeCEN(XEntry xentry) throws IOException {
@@ -535,14 +544,14 @@
             elenZIP64 += 8;              // offset(8)
             hasZip64 = true;
         }
         writeInt(CENSIG);           // CEN header signature
         if (hasZip64) {
-            writeShort(45);         // ver 4.5 for zip64
+            writeShort(versionMadeBy(e,45));         // ver 4.5 for zip64
             writeShort(45);
         } else {
-            writeShort(version);    // version made by
+            writeShort(versionMadeBy(e, version));    // version made by
             writeShort(version);    // version needed to extract
         }
         writeShort(flag);           // general purpose bit flag
         writeShort(e.method);       // compression method
         writeInt(e.xdostime);       // last modification time
@@ -595,11 +604,12 @@
             commentBytes = null;
             writeShort(0);
         }
         writeShort(0);              // starting disk number
         writeShort(0);              // internal file attributes (unused)
-        writeInt(0);                // external file attributes (unused)
+        // external file attributes, used for storing posix permissions
+        writeInt(e.posixPerms > 0 ? e.posixPerms << 16 : 0);
         writeInt(offset);           // relative offset of local header
         writeBytes(nameBytes, 0, nameBytes.length);
 
         // take care of EXTID_ZIP64 and EXTID_EXTT
         if (hasZip64) {
diff a/src/java.base/share/classes/java/util/zip/ZipUtils.java b/src/java.base/share/classes/java/util/zip/ZipUtils.java
--- a/src/java.base/share/classes/java/util/zip/ZipUtils.java
+++ b/src/java.base/share/classes/java/util/zip/ZipUtils.java
@@ -213,10 +213,21 @@
 
     static final long GETSIG(byte[] b) {
         return LG(b, 0);
     }
 
+    /*
+     * File attribute compatibility types of CEN field "version made by"
+     */
+    static final int FILE_ATTRIBUTES_UNIX = 3; // Unix
+
+    /*
+     * Base values for CEN field "version made by"
+     */
+    static final int VERSION_MADE_BY_BASE_UNIX = FILE_ATTRIBUTES_UNIX << 8; // Unix
+
+
     // local file (LOC) header fields
     static final long LOCSIG(byte[] b) { return LG(b, 0); } // signature
     static final int  LOCVER(byte[] b) { return SH(b, 4); } // version needed to extract
     static final int  LOCFLG(byte[] b) { return SH(b, 6); } // general purpose bit flags
     static final int  LOCHOW(byte[] b) { return SH(b, 8); } // compression method
@@ -248,10 +259,11 @@
     static final long ZIP64_LOCOFF(byte[] b) { return LL(b, 8);}   // zip64 end offset
 
     // central directory header (CEN) fields
     static final long CENSIG(byte[] b, int pos) { return LG(b, pos + 0); }
     static final int  CENVEM(byte[] b, int pos) { return SH(b, pos + 4); }
+    static final int  CENVEM_FA(byte[] b, int pos) { return CH(b, pos + 5); } // file attribute compatibility
     static final int  CENVER(byte[] b, int pos) { return SH(b, pos + 6); }
     static final int  CENFLG(byte[] b, int pos) { return SH(b, pos + 8); }
     static final int  CENHOW(byte[] b, int pos) { return SH(b, pos + 10);}
     static final long CENTIM(byte[] b, int pos) { return LG(b, pos + 12);}
     static final long CENCRC(byte[] b, int pos) { return LG(b, pos + 16);}
@@ -261,10 +273,11 @@
     static final int  CENEXT(byte[] b, int pos) { return SH(b, pos + 30);}
     static final int  CENCOM(byte[] b, int pos) { return SH(b, pos + 32);}
     static final int  CENDSK(byte[] b, int pos) { return SH(b, pos + 34);}
     static final int  CENATT(byte[] b, int pos) { return SH(b, pos + 36);}
     static final long CENATX(byte[] b, int pos) { return LG(b, pos + 38);}
+    static final int  CENATX_PERMS(byte[] b, int pos) { return SH(b, pos + 40);} // posix permission data
     static final long CENOFF(byte[] b, int pos) { return LG(b, pos + 42);}
 
     // The END header is followed by a variable length comment of size < 64k.
     static final long END_MAXLEN = 0xFFFF + ENDHDR;
     static final int READBLOCKSZ = 128;
diff a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaUtilZipFileAccess.java
@@ -28,17 +28,20 @@
 import java.util.Enumeration;
 import java.util.List;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 
 public interface JavaUtilZipFileAccess {
     public boolean startsWithLocHeader(ZipFile zip);
     public List<String> getManifestAndSignatureRelatedFiles(JarFile zip);
     public String getManifestName(JarFile zip, boolean onlyIfSignatureRelatedFiles);
     public int[] getMetaInfVersions(JarFile zip);
     public Enumeration<JarEntry> entries(ZipFile zip);
     public Stream<JarEntry> stream(ZipFile zip);
     public Stream<String> entryNameStream(ZipFile zip);
+    public void setPosixPerms(ZipEntry ze, int posixPerms);
+    public int getPosixPerms(ZipEntry ze);
 }
 
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -147,10 +147,11 @@
         java.desktop,
         java.logging,
         java.management,
         java.naming,
         java.rmi,
+        jdk.jartool,
         jdk.jlink,
         jdk.net,
         jdk.incubator.foreign;
     exports jdk.internal.access.foreign to
         jdk.incubator.foreign;
diff a/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java b/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/DistributionPointFetcher.java
@@ -246,11 +246,11 @@
         URI uri = name.getURI();
         if (debug != null) {
             debug.println("Trying to fetch CRL from DP " + uri);
         }
 
-        Event.report("event.crl.check", uri.toString());
+        Event.report(Event.ReporterCategory.CRLCHECK, "event.crl.check", uri.toString());
         CertStore ucs = null;
         try {
             ucs = URICertStore.getInstance(new URICertStoreParameters(uri));
         } catch (InvalidAlgorithmParameterException |
                  NoSuchAlgorithmException e) {
diff a/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java b/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
--- a/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
+++ b/src/java.base/share/classes/sun/security/provider/certpath/OCSP.java
@@ -232,11 +232,11 @@
             URL url = responderURI.toURL();
             if (debug != null) {
                 debug.println("connecting to OCSP service at: " + url);
             }
 
-            Event.report("event.ocsp.check", url.toString());
+            Event.report(Event.ReporterCategory.CRLCHECK, "event.ocsp.check", url.toString());
             HttpURLConnection con = (HttpURLConnection)url.openConnection();
             con.setConnectTimeout(CONNECT_TIMEOUT);
             con.setReadTimeout(CONNECT_TIMEOUT);
             con.setDoOutput(true);
             con.setDoInput(true);
diff a/src/java.base/share/classes/sun/security/util/Event.java b/src/java.base/share/classes/sun/security/util/Event.java
--- a/src/java.base/share/classes/sun/security/util/Event.java
+++ b/src/java.base/share/classes/sun/security/util/Event.java
@@ -33,25 +33,31 @@
  * Listener should implement the event handling of the Reporter interface.
  */
 public final class Event {
     private Event() {}
 
+    public enum ReporterCategory {
+        CRLCHECK(),
+        POSIXPERMS();
+
+        private Reporter reporter;
+    }
+
     public interface Reporter {
         public void handle(String type, Object... args);
     }
 
-    private static Reporter reporter;
-    public static void setReportListener(Reporter re) {
-        reporter = re;
+    public static void setReportListener(ReporterCategory cat, Reporter re) {
+        cat.reporter = re;
     }
 
-    public static void clearReportListener() {
-        reporter = null;
+    public static void clearReportListener(ReporterCategory cat) {
+        cat.reporter = null;
     }
 
-    public static void report(String type, Object... args) {
-        Reporter currentReporter = reporter;
+    public static void report(ReporterCategory cat, String type, Object... args) {
+        Reporter currentReporter = cat.reporter;
 
         if (currentReporter != null) {
             currentReporter.handle(type, args);
         }
     }
diff a/src/java.base/windows/native/common/version.rc b/src/java.base/windows/native/common/version.rc
--- a/src/java.base/windows/native/common/version.rc
+++ b/src/java.base/windows/native/common/version.rc
@@ -1,7 +1,7 @@
 //
-// Copyright (c) 2004, 2019, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2004, 2020, Oracle and/or its affiliates. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.  Oracle designates this
@@ -21,42 +21,47 @@
 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 // or visit www.oracle.com if you need additional information or have any
 // questions.
 //
 
-#include "windows.h"
+#include <windows.h>
 
 // Need 2 defines so macro argument to XSTR will get expanded before quoting.
 #define XSTR(x) STR(x)
 #define STR(x)  #x
 
-LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
 
 /////////////////////////////////////////////////////////////////////////////
 //
 // Version
 //
 
+#ifndef JDK_FILEOS
+#define JDK_FILEOS VOS__WINDOWS32
+#endif
+
 VS_VERSION_INFO VERSIONINFO
  FILEVERSION    JDK_FVER
  PRODUCTVERSION JDK_FVER
- FILEFLAGSMASK 0x3fL
+ FILEFLAGSMASK VS_FF_DEBUG | VS_FF_PRERELEASE
 #ifdef _DEBUG
- FILEFLAGS 0x1L
+ FILEFLAGS VS_FF_DEBUG
 #else
  FILEFLAGS 0x0L
 #endif
- // FILEOS 0x4 is Win32, 0x40004 is Win32 NT only
- FILEOS 0x4L
- // FILETYPE should be 0x1 for .exe and 0x2 for .dll
+ FILEOS JDK_FILEOS
  FILETYPE JDK_FTYPE
  FILESUBTYPE 0x0L
 BEGIN
     BLOCK "StringFileInfo"
     BEGIN
-        BLOCK "000004b0"
+        BLOCK "040904b0"
         BEGIN
+#ifdef JDK_COMMENTS
+            VALUE "Comments",         XSTR(JDK_COMMENTS)       "\0"
+#endif
             VALUE "CompanyName",      XSTR(JDK_COMPANY)        "\0"
             VALUE "FileDescription",  XSTR(JDK_FILEDESC)       "\0"
             VALUE "FileVersion",      XSTR(JDK_VER)            "\0"
             VALUE "Full Version",     XSTR(JDK_VERSION_STRING) "\0"
             VALUE "InternalName",     XSTR(JDK_INTERNAL_NAME)  "\0"
@@ -66,8 +71,8 @@
             VALUE "ProductVersion",   XSTR(JDK_VER)            "\0"
         END
     END
     BLOCK "VarFileInfo"
     BEGIN
-        VALUE "Translation", 0x0, 1200
+        VALUE "Translation", 0x409, 1200
     END
 END
diff a/src/java.desktop/windows/native/libawt/windows/awt.rc b/src/java.desktop/windows/native/libawt/windows/awt.rc
--- a/src/java.desktop/windows/native/libawt/windows/awt.rc
+++ b/src/java.desktop/windows/native/libawt/windows/awt.rc
@@ -1,7 +1,7 @@
 // 
-// Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.  Oracle designates this
@@ -21,63 +21,16 @@
 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 // or visit www.oracle.com if you need additional information or have any
 // questions.
 //
 
-#include "windows.h"
-
-// Need 2 defines so macro argument to XSTR will get expanded before quoting.
-#define XSTR(x) STR(x)
-#define STR(x)  #x
-
-LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
+#include "version.rc"
 
 AWT_ICON     ICON    DISCARDABLE "awt.ico"
 CHECK_BITMAP BITMAP  DISCARDABLE "check.bmp"
 
 // Note: the number of icons used is specified in the
 // securityWarningIconCounter constant in awt_Toolkit.cpp.
 SECURITY_WARNING_0  ICON    DISCARDABLE "security_warning_bw.ico"
 SECURITY_WARNING_1  ICON    DISCARDABLE "security_warning_int.ico"
 SECURITY_WARNING_2  ICON    DISCARDABLE "security_warning.ico"
 
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    JDK_FVER
- PRODUCTVERSION JDK_FVER
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- // FILEOS 0x4 is Win32, 0x40004 is Win32 NT only
- FILEOS 0x4L
- // FILETYPE should be 0x1 for .exe and 0x2 for .dll
- FILETYPE JDK_FTYPE
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "CompanyName",      XSTR(JDK_COMPANY)        "\0"
-            VALUE "FileDescription",  XSTR(JDK_FILEDESC)       "\0"
-            VALUE "FileVersion",      XSTR(JDK_VER)            "\0"
-            VALUE "Full Version",     XSTR(JDK_VERSION_STRING) "\0"
-            VALUE "InternalName",     XSTR(JDK_INTERNAL_NAME)  "\0"
-            VALUE "LegalCopyright",   XSTR(JDK_COPYRIGHT)      "\0"
-            VALUE "OriginalFilename", XSTR(JDK_FNAME)          "\0"
-            VALUE "ProductName",      XSTR(JDK_NAME)           "\0"
-            VALUE "ProductVersion",   XSTR(JDK_VER)            "\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
diff a/src/jdk.accessibility/windows/native/common/AccessBridgeStatusWindow.rc b/src/jdk.accessibility/windows/native/common/AccessBridgeStatusWindow.rc
--- a/src/jdk.accessibility/windows/native/common/AccessBridgeStatusWindow.rc
+++ b/src/jdk.accessibility/windows/native/common/AccessBridgeStatusWindow.rc
@@ -1,174 +1,126 @@
-//Microsoft Developer Studio generated resource script.
-//
-#include "resource.h"
-#include "accessBridgeResource.h"
-
-#define XSTR(x) STR(x)
-#define STR(x)  #x
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#define APSTUDIO_HIDDEN_SYMBOLS
-#include "windows.h"
-#undef APSTUDIO_HIDDEN_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// English (U.S.) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-#ifdef _WIN32
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-#pragma code_page(1252)
-#endif //_WIN32
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Dialog
-//
-
-ACCESSBRIDGESTATUSWINDOW DIALOGEX 160, 78, 209, 163
-STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
-EXSTYLE WS_EX_CLIENTEDGE
-CAPTION "Access Bridge status"
-FONT 8, "MS Sans Serif", 0, 0, 0x1
-BEGIN
-    EDITTEXT        cVMID,67,23,121,13,ES_READONLY
-    EDITTEXT        cStatusText,40,147,162,13,ES_READONLY
-    LTEXT           "Java VM ID:",IDC_STATIC,23,25,40,8
-    LTEXT           "Status:",IDC_STATIC,11,149,23,8
-    EDITTEXT        cWindowsID,67,39,121,13,ES_READONLY
-    LTEXT           "Windows ID:",IDC_STATIC,21,41,42,8
-    EDITTEXT        cCallInfo,12,65,184,75,ES_MULTILINE | ES_AUTOVSCROLL |
-                    ES_AUTOHSCROLL | ES_READONLY | WS_VSCROLL
-    GROUPBOX        "Call info",IDC_STATIC,4,55,197,90
-    EDITTEXT        cInvokedByText,67,1,121,13,ES_READONLY
-    LTEXT           "Invoked by:",IDC_STATIC,25,3,38,8
-END
-
-IDD_DIALOG1 DIALOG DISCARDABLE  0, 0, 186, 95
-STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
-CAPTION "Dialog"
-FONT 8, "MS Sans Serif"
-BEGIN
-    DEFPUSHBUTTON   "OK",IDOK,129,7,50,14
-    PUSHBUTTON      "Cancel",IDCANCEL,129,24,50,14
-END
-
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
-    "#include ""windows.h""\r\n"
-    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE DISCARDABLE
-BEGIN
-    "\r\n"
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// DESIGNINFO
-//
-
-#ifdef APSTUDIO_INVOKED
-GUIDELINES DESIGNINFO DISCARDABLE
-BEGIN
-    "ACCESSBRIDGESTATUSWINDOW", DIALOG
-    BEGIN
-        LEFTMARGIN, 4
-        RIGHTMARGIN, 202
-        BOTTOMMARGIN, 160
-    END
-
-    "IDD_DIALOG1", DIALOG
-    BEGIN
-        LEFTMARGIN, 7
-        RIGHTMARGIN, 179
-        TOPMARGIN, 7
-        BOTTOMMARGIN, 88
-    END
-END
-#endif    // APSTUDIO_INVOKED
-
-
-#ifndef _MAC
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    JDK_FVER
- PRODUCTVERSION JDK_FVER
- FILEFLAGSMASK 0x3fL
-#ifdef DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE JDK_FTYPE
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "Comments",         "Java Access Bridge"     "\0"
-            VALUE "CompanyName",      XSTR(JDK_COMPANY)        "\0"
-            VALUE "FileDescription",  XSTR(JDK_FILEDESC)       "\0"
-            VALUE "FileVersion",      XSTR(JDK_VER)            "\0"
-            VALUE "Full Version",     XSTR(JDK_VERSION_STRING) "\0"
-            VALUE "InternalName",     XSTR(JDK_INTERNAL_NAME)  "\0"
-            VALUE "LegalCopyright",   XSTR(JDK_COPYRIGHT)      "\0"
-            VALUE "OriginalFilename", XSTR(JDK_FNAME)          "\0"
-            VALUE "ProductName",      XSTR(JDK_NAME)           "\0"
-            VALUE "ProductVersion",   XSTR(JDK_VER)            "\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
-
-#endif    // !_MAC
-
-#endif    // English (U.S.) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
+//
+// Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+//
+// This code is free software; you can redistribute it and/or modify it
+// under the terms of the GNU General Public License version 2 only, as
+// published by the Free Software Foundation.  Oracle designates this
+// particular file as subject to the "Classpath" exception as provided
+// by Oracle in the LICENSE file that accompanied this code.
+//
+// This code is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// version 2 for more details (a copy is included in the LICENSE file that
+// accompanied this code).
+//
+// You should have received a copy of the GNU General Public License version
+// 2 along with this work; if not, write to the Free Software Foundation,
+// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+// or visit www.oracle.com if you need additional information or have any
+// questions.
+//
+
+#define JDK_COMMENTS Java Access Bridge
+#define JDK_FILEOS 0x40004L
+
+#include "version.rc"
+
+#include "resource.h"
+#include "accessBridgeResource.h"
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#define APSTUDIO_READONLY_SYMBOLS
+#define APSTUDIO_HIDDEN_SYMBOLS
+#include "windows.h"
+#undef APSTUDIO_HIDDEN_SYMBOLS
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+ACCESSBRIDGESTATUSWINDOW DIALOGEX 160, 78, 209, 163
+STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
+EXSTYLE WS_EX_CLIENTEDGE
+CAPTION "Access Bridge status"
+FONT 8, "MS Sans Serif", 0, 0, 0x1
+BEGIN
+    EDITTEXT        cVMID,67,23,121,13,ES_READONLY
+    EDITTEXT        cStatusText,40,147,162,13,ES_READONLY
+    LTEXT           "Java VM ID:",IDC_STATIC,23,25,40,8
+    LTEXT           "Status:",IDC_STATIC,11,149,23,8
+    EDITTEXT        cWindowsID,67,39,121,13,ES_READONLY
+    LTEXT           "Windows ID:",IDC_STATIC,21,41,42,8
+    EDITTEXT        cCallInfo,12,65,184,75,ES_MULTILINE | ES_AUTOVSCROLL |
+                    ES_AUTOHSCROLL | ES_READONLY | WS_VSCROLL
+    GROUPBOX        "Call info",IDC_STATIC,4,55,197,90
+    EDITTEXT        cInvokedByText,67,1,121,13,ES_READONLY
+    LTEXT           "Invoked by:",IDC_STATIC,25,3,38,8
+END
+
+IDD_DIALOG1 DIALOG DISCARDABLE  0, 0, 186, 95
+STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION "Dialog"
+FONT 8, "MS Sans Serif"
+BEGIN
+    DEFPUSHBUTTON   "OK",IDOK,129,7,50,14
+    PUSHBUTTON      "Cancel",IDCANCEL,129,24,50,14
+END
+
+#ifdef APSTUDIO_INVOKED
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "#define APSTUDIO_HIDDEN_SYMBOLS\r\n"
+    "#include ""windows.h""\r\n"
+    "#undef APSTUDIO_HIDDEN_SYMBOLS\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+GUIDELINES DESIGNINFO DISCARDABLE
+BEGIN
+    "ACCESSBRIDGESTATUSWINDOW", DIALOG
+    BEGIN
+        LEFTMARGIN, 4
+        RIGHTMARGIN, 202
+        BOTTOMMARGIN, 160
+    END
+
+    "IDD_DIALOG1", DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 179
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 88
+    END
+END
+
+#endif    // APSTUDIO_INVOKED
diff a/src/jdk.accessibility/windows/native/jaccessinspector/jaccessinspectorWindow.rc b/src/jdk.accessibility/windows/native/jaccessinspector/jaccessinspectorWindow.rc
--- a/src/jdk.accessibility/windows/native/jaccessinspector/jaccessinspectorWindow.rc
+++ b/src/jdk.accessibility/windows/native/jaccessinspector/jaccessinspectorWindow.rc
@@ -1,30 +1,43 @@
-// Microsoft Visual C++ generated resource script.
 //
 #include "jaccessinspectorResource.h"
+// Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+//
+// This code is free software; you can redistribute it and/or modify it
+// under the terms of the GNU General Public License version 2 only, as
+// published by the Free Software Foundation.  Oracle designates this
+// particular file as subject to the "Classpath" exception as provided
+// by Oracle in the LICENSE file that accompanied this code.
+//
+// This code is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// version 2 for more details (a copy is included in the LICENSE file that
+// accompanied this code).
+//
+// You should have received a copy of the GNU General Public License version
+// 2 along with this work; if not, write to the Free Software Foundation,
+// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+// or visit www.oracle.com if you need additional information or have any
+// questions.
+//
+
+#include "version.rc"
 #include "jaccessinspectorResource.h"
 
-#define APSTUDIO_READONLY_SYMBOLS
 /////////////////////////////////////////////////////////////////////////////
 //
 // Generated from the TEXTINCLUDE 2 resource.
 //
+#define APSTUDIO_READONLY_SYMBOLS
 #define APSTUDIO_HIDDEN_SYMBOLS
 #include "windows.h"
 #undef APSTUDIO_HIDDEN_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
 #undef APSTUDIO_READONLY_SYMBOLS
 
-/////////////////////////////////////////////////////////////////////////////
-// English (U.S.) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-#ifdef _WIN32
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-#pragma code_page(1252)
-#endif //_WIN32
-
 /////////////////////////////////////////////////////////////////////////////
 //
 // Dialog
 //
 
@@ -53,10 +66,11 @@
     PUSHBUTTON      "Cancel",IDCANCEL,101,45,50,14
 END
 
 
 #ifdef APSTUDIO_INVOKED
+
 /////////////////////////////////////////////////////////////////////////////
 //
 // TEXTINCLUDE
 //
 
@@ -77,19 +91,15 @@
 BEGIN
     "\r\n"
     "\0"
 END
 
-#endif    // APSTUDIO_INVOKED
-
-
 /////////////////////////////////////////////////////////////////////////////
 //
 // DESIGNINFO
 //
 
-#ifdef APSTUDIO_INVOKED
 GUIDELINES DESIGNINFO
 BEGIN
     "JACCESSINSPECTORWINDOW", DIALOG
     BEGIN
         LEFTMARGIN, 4
@@ -168,57 +178,10 @@
         MENUITEM "&Go To Message",              cGoToMessage
         MENUITEM "&Clear Message History",      cClearMessageHistory
     END
 END
 
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-// Need 2 defines so macro argument to XSTR will get expanded before quoting.
-#define XSTR(x) STR(x)
-#define STR(x)  #x
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    JDK_FVER
- PRODUCTVERSION JDK_FVER
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- // FILEOS 0x4 is Win32, 0x40004 is Win32 NT only
- FILEOS 0x4L
- // FILETYPE should be 0x1 for .exe and 0x2 for .dll
- FILETYPE JDK_FTYPE
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "000004b0"
-        BEGIN
-            VALUE "CompanyName",      XSTR(JDK_COMPANY)        "\0"
-            VALUE "FileDescription",  XSTR(JDK_FILEDESC)       "\0"
-            VALUE "FileVersion",      XSTR(JDK_VER)            "\0"
-            VALUE "Full Version",     XSTR(JDK_VERSION_STRING) "\0"
-            VALUE "InternalName",     XSTR(JDK_INTERNAL_NAME)  "\0"
-            VALUE "LegalCopyright",   XSTR(JDK_COPYRIGHT)      "\0"
-            VALUE "OriginalFilename", XSTR(JDK_FNAME)          "\0"
-            VALUE "ProductName",      XSTR(JDK_NAME)           "\0"
-            VALUE "ProductVersion",   XSTR(JDK_VER)            "\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x0, 1200
-    END
-END
-
-
 /////////////////////////////////////////////////////////////////////////////
 //
 // Accelerator
 //
 
@@ -229,21 +192,5 @@
     VK_END,         cLastMessage,           VIRTKEY, CONTROL, ALT, NOINVERT
     VK_NEXT,        cNextMessage,           VIRTKEY, CONTROL, NOINVERT
     VK_PRIOR,       cPreviousMessage,       VIRTKEY, CONTROL, NOINVERT
     "X",            cClearMessageHistory,   VIRTKEY, CONTROL, NOINVERT
 END
-
-#endif    // English (U.S.) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
-
diff a/src/jdk.accessibility/windows/native/jaccesswalker/jaccesswalkerWindow.rc b/src/jdk.accessibility/windows/native/jaccesswalker/jaccesswalkerWindow.rc
--- a/src/jdk.accessibility/windows/native/jaccesswalker/jaccesswalkerWindow.rc
+++ b/src/jdk.accessibility/windows/native/jaccesswalker/jaccesswalkerWindow.rc
@@ -1,30 +1,43 @@
-//Microsoft Developer Studio generated resource script.
 //
 #include "jaccesswalkerResource.h"
+// Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
+// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+//
+// This code is free software; you can redistribute it and/or modify it
+// under the terms of the GNU General Public License version 2 only, as
+// published by the Free Software Foundation.  Oracle designates this
+// particular file as subject to the "Classpath" exception as provided
+// by Oracle in the LICENSE file that accompanied this code.
+//
+// This code is distributed in the hope that it will be useful, but WITHOUT
+// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+// version 2 for more details (a copy is included in the LICENSE file that
+// accompanied this code).
+//
+// You should have received a copy of the GNU General Public License version
+// 2 along with this work; if not, write to the Free Software Foundation,
+// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+//
+// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+// or visit www.oracle.com if you need additional information or have any
+// questions.
+//
+
+#include "version.rc"
 #include "jaccesswalkerResource.h"
 
-#define APSTUDIO_READONLY_SYMBOLS
 /////////////////////////////////////////////////////////////////////////////
 //
 // Generated from the TEXTINCLUDE 2 resource.
 //
+#define APSTUDIO_READONLY_SYMBOLS
 #define APSTUDIO_HIDDEN_SYMBOLS
 #include "windows.h"
 #undef APSTUDIO_HIDDEN_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
 #undef APSTUDIO_READONLY_SYMBOLS
 
-/////////////////////////////////////////////////////////////////////////////
-// English (U.S.) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-#ifdef _WIN32
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-#pragma code_page(1252)
-#endif //_WIN32
-
 /////////////////////////////////////////////////////////////////////////////
 //
 // Dialog
 //
 
@@ -49,12 +62,12 @@
 BEGIN
     EDITTEXT        cAccessInfoText,4,0,283,214,ES_MULTILINE | ES_AUTOVSCROLL |
                     ES_READONLY | WS_VSCROLL
 END
 
-
 #ifdef APSTUDIO_INVOKED
+
 /////////////////////////////////////////////////////////////////////////////
 //
 // TEXTINCLUDE
 //
 
@@ -75,19 +88,15 @@
 BEGIN
     "\r\n"
     "\0"
 END
 
-#endif    // APSTUDIO_INVOKED
-
-
 /////////////////////////////////////////////////////////////////////////////
 //
 // DESIGNINFO
 //
 
-#ifdef APSTUDIO_INVOKED
 GUIDELINES DESIGNINFO DISCARDABLE
 BEGIN
     "JACCESSWALKERWINDOW", DIALOG
     BEGIN
         LEFTMARGIN, 4
@@ -98,12 +107,12 @@
     BEGIN
         LEFTMARGIN, 4
         RIGHTMARGIN, 287
     END
 END
-#endif    // APSTUDIO_INVOKED
 
+#endif    // APSTUDIO_INVOKED
 
 /////////////////////////////////////////////////////////////////////////////
 //
 // Menu
 //
@@ -120,63 +129,12 @@
     BEGIN
         MENUITEM "Display Accessibility Information",     cAPIMenuItem
     END
 END
 
-
 PopupMenu MENU
     {
     POPUP ""
         {
         MENUITEM "Display Accessibility Information",     cAPIPopupItem
         }
     }
-
-
-#endif    // English (U.S.) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-// Need 2 defines so macro argument to XSTR will get expanded before quoting.
-#define XSTR(x) STR(x)
-#define STR(x)  #x
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION    JDK_FVER
- PRODUCTVERSION JDK_FVER
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- // FILEOS 0x4 is Win32, 0x40004 is Win32 NT only
- FILEOS 0x4L
- // FILETYPE should be 0x1 for .exe and 0x2 for .dll
- FILETYPE JDK_FTYPE
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "000004b0"
-        BEGIN
-            VALUE "CompanyName",      XSTR(JDK_COMPANY)        "\0"
-            VALUE "FileDescription",  XSTR(JDK_FILEDESC)       "\0"
-            VALUE "FileVersion",      XSTR(JDK_VER)            "\0"
-            VALUE "Full Version",     XSTR(JDK_VERSION_STRING) "\0"
-            VALUE "InternalName",     XSTR(JDK_INTERNAL_NAME)  "\0"
-            VALUE "LegalCopyright",   XSTR(JDK_COPYRIGHT)      "\0"
-            VALUE "OriginalFilename", XSTR(JDK_FNAME)          "\0"
-            VALUE "ProductName",      XSTR(JDK_NAME)           "\0"
-            VALUE "ProductVersion",   XSTR(JDK_VER)            "\0"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x0, 1200
-    END
-END
diff a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
--- a/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
+++ b/src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacDmgBundler.java
@@ -89,11 +89,11 @@
                 }
 
                 return buildDMG(params, appLocation, outdir);
             }
             return null;
-        } catch (IOException ex) {
+        } catch (IOException | PackagerException ex) {
             Log.verbose(ex);
             throw new PackagerException(ex);
         }
     }
 
@@ -260,11 +260,12 @@
 
         return null;
     }
 
     private File buildDMG( Map<String, ? super Object> params,
-            File appLocation, File outdir) throws IOException {
+            File appLocation, File outdir) throws IOException, PackagerException {
+        boolean copyAppImage = false;
         File imagesRoot = IMAGES_ROOT.fetchFrom(params);
         if (!imagesRoot.exists()) imagesRoot.mkdirs();
 
         File protoDMG = new File(imagesRoot,
                 APP_NAME.fetchFrom(params) +"-tmp.dmg");
@@ -320,11 +321,35 @@
                 "-srcfolder", srcFolder.getAbsolutePath(),
                 "-volname", APP_NAME.fetchFrom(params),
                 "-ov", protoDMG.getAbsolutePath(),
                 "-fs", "HFS+",
                 "-format", "UDRW");
-        IOUtils.exec(pb);
+        try {
+            IOUtils.exec(pb);
+        } catch (IOException ex) {
+            Log.verbose(ex); // Log exception
+
+            // Creating DMG from entire app image failed, so lets try to create empty
+            // DMG and copy files manually. See JDK-8248059.
+            copyAppImage = true;
+
+            long size = new PathGroup(Map.of(new Object(), srcFolder.toPath()))
+                    .sizeInBytes();
+            size += 50 * 1024 * 1024; // Add extra 50 megabytes. Actually DMG size will
+            // not be bigger, but it will able to hold additional 50 megabytes of data.
+            // We need extra room for icons and background image. When we providing
+            // actual files to hdiutil, it will create DMG with ~50 megabytes extra room.
+            pb = new ProcessBuilder(
+                hdiutil,
+                "create",
+                hdiUtilVerbosityFlag,
+                "-size", String.valueOf(size),
+                "-volname", APP_NAME.fetchFrom(params),
+                "-ov", protoDMG.getAbsolutePath(),
+                "-fs", "HFS+");
+            IOUtils.exec(pb);
+        }
 
         // mount temp image
         pb = new ProcessBuilder(
                 hdiutil,
                 "attach",
@@ -333,10 +358,27 @@
                 "-mountroot", imagesRoot.getAbsolutePath());
         IOUtils.exec(pb, false, null, true);
 
         File mountedRoot = new File(imagesRoot.getAbsolutePath(),
                     APP_NAME.fetchFrom(params));
+
+        // Copy app image, since we did not create DMG with it, but instead we created
+        // empty one.
+        if (copyAppImage) {
+            // In case of predefine app image srcFolder will point to app bundle, so if
+            // we use it as is we will copy content of app bundle, but we need app bundle
+            // folder as well.
+            if (srcFolder.toPath().toString().toLowerCase().endsWith(".app")) {
+                Path destPath = mountedRoot.toPath()
+                        .resolve(srcFolder.toPath().getFileName());
+                Files.createDirectory(destPath);
+                IOUtils.copyRecursive(srcFolder.toPath(), destPath);
+            } else {
+                IOUtils.copyRecursive(srcFolder.toPath(), mountedRoot.toPath());
+            }
+        }
+
         try {
             // background image
             File bgdir = new File(mountedRoot, BACKGROUND_IMAGE_FOLDER);
             bgdir.mkdirs();
             IOUtils.copyFile(getConfig_VolumeBackground(params),
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HandleCleaner.java
@@ -63,12 +63,12 @@
             // an object on the HotSpot heap so we call into the
             // VM to set the target of an object handle to this value.
             CompilerToVM.compilerToVM().deleteGlobalHandle(handle);
         } else {
             // Setting the target of a jmetadata handle to 0 enables
-            // the handle to be reused. See MetadataHandleBlock in
-            // jvmciRuntime.cpp for more info.
+            // the handle to be reused. See MetadataHandles in
+            // metadataHandles.hpp for more info.
             long value = UNSAFE.getLong(null, handle);
             UNSAFE.compareAndSetLong(null, handle, value, 0);
         }
     }
 
diff a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
--- a/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
+++ b/src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -35,10 +35,11 @@
 import java.lang.invoke.ConstantCallSite;
 import java.lang.invoke.MethodHandle;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Formatter;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.ServiceLoader;
@@ -208,10 +209,19 @@
     @VMEntryPoint
     static String callToString(Object o) {
         return o.toString();
     }
 
+    /**
+     * Set of recognized {@code "jvmci.*"} system properties. Entries not associated with an
+     * {@link Option} have this object as their value.
+     */
+    static final Map<String, Object> options = new HashMap<>();
+    static {
+        options.put("jvmci.class.path.append", options);
+    }
+
     /**
      * A list of all supported JVMCI options.
      */
     public enum Option {
         // @formatter:off
@@ -226,11 +236,11 @@
         AuditHandles(Boolean.class, false, "Record stack trace along with scoped foreign object reference wrappers " +
                 "to debug issue with a wrapper being used after its scope has closed."),
         TraceMethodDataFilter(String.class, null,
                 "Enables tracing of profiling info when read by JVMCI.",
                 "Empty value: trace all methods",
-                "Non-empty value: trace methods whose fully qualified name contains the value."),
+                        "Non-empty value: trace methods whose fully qualified name contains the value."),
         UseProfilingInformation(Boolean.class, true, "");
         // @formatter:on
 
         /**
          * The prefix for system properties that are JVMCI options.
@@ -243,39 +253,49 @@
         private static final String NULL_VALUE = "NULL";
 
         private final Class<?> type;
         @NativeImageReinitialize private Object value;
         private final Object defaultValue;
-        private boolean isDefault;
+        private boolean isDefault = true;
         private final String[] helpLines;
 
         Option(Class<?> type, Object defaultValue, String... helpLines) {
             assert Character.isUpperCase(name().charAt(0)) : "Option name must start with upper-case letter: " + name();
             this.type = type;
             this.defaultValue = defaultValue;
             this.helpLines = helpLines;
+            Object existing = options.put(getPropertyName(), this);
+            assert existing == null : getPropertyName();
         }
 
         @SuppressFBWarnings(value = "ES_COMPARING_STRINGS_WITH_EQ", justification = "sentinel must be String since it's a static final in an enum")
-        private Object getValue() {
-            if (value == null) {
-                String propertyValue = Services.getSavedProperty(getPropertyName());
-                if (propertyValue == null) {
-                    this.value = defaultValue == null ? NULL_VALUE : defaultValue;
-                    this.isDefault = true;
+        private void init(String propertyValue) {
+            assert value == null : "cannot re-initialize " + name();
+            if (propertyValue == null) {
+                this.value = defaultValue == null ? NULL_VALUE : defaultValue;
+                this.isDefault = true;
+            } else {
+                if (type == Boolean.class) {
+                    this.value = Boolean.parseBoolean(propertyValue);
+                } else if (type == String.class) {
+                    this.value = propertyValue;
                 } else {
-                    if (type == Boolean.class) {
-                        this.value = Boolean.parseBoolean(propertyValue);
-                    } else if (type == String.class) {
-                        this.value = propertyValue;
-                    } else {
-                        throw new JVMCIError("Unexpected option type " + type);
-                    }
-                    this.isDefault = false;
+                    throw new JVMCIError("Unexpected option type " + type);
                 }
+                this.isDefault = false;
+            }
+        }
+
+        @SuppressFBWarnings(value = "ES_COMPARING_STRINGS_WITH_EQ", justification = "sentinel must be String since it's a static final in an enum")
+        private Object getValue() {
+            if (value == NULL_VALUE) {
+                return null;
+            }
+            if (value == null) {
+                return defaultValue;
             }
-            return value == NULL_VALUE ? null : value;
+            return value;
         }
 
         /**
          * Gets the name of system property from which this option gets its value.
          */
@@ -332,10 +352,65 @@
                 for (String line : option.helpLines) {
                     out.printf("%" + PROPERTY_HELP_INDENT + "s%s%n", "", line);
                 }
             }
         }
+
+        /**
+         * Compute string similarity based on Dice's coefficient.
+         *
+         * Ported from str_similar() in globals.cpp.
+         */
+        static float stringSimiliarity(String str1, String str2) {
+            int hit = 0;
+            for (int i = 0; i < str1.length() - 1; ++i) {
+                for (int j = 0; j < str2.length() - 1; ++j) {
+                    if ((str1.charAt(i) == str2.charAt(j)) && (str1.charAt(i + 1) == str2.charAt(j + 1))) {
+                        ++hit;
+                        break;
+                    }
+                }
+            }
+            return 2.0f * hit / (str1.length() + str2.length());
+        }
+
+        private static final float FUZZY_MATCH_THRESHOLD = 0.7F;
+
+        /**
+         * Parses all system properties starting with {@value #JVMCI_OPTION_PROPERTY_PREFIX} and
+         * initializes the options based on their values.
+         */
+        static void parse() {
+            Map<String, String> savedProps = jdk.vm.ci.services.Services.getSavedProperties();
+            for (Map.Entry<String, String> e : savedProps.entrySet()) {
+                String name = e.getKey();
+                if (name.startsWith(Option.JVMCI_OPTION_PROPERTY_PREFIX)) {
+                    Object value = options.get(name);
+                    if (value == null) {
+                        List<String> matches = new ArrayList<>();
+                        for (String pn : options.keySet()) {
+                            float score = stringSimiliarity(pn, name);
+                            if (score >= FUZZY_MATCH_THRESHOLD) {
+                                matches.add(pn);
+                            }
+                        }
+                        Formatter msg = new Formatter();
+                        msg.format("Could not find option %s", name);
+                        if (!matches.isEmpty()) {
+                            msg.format("%nDid you mean one of the following?");
+                            for (String match : matches) {
+                                msg.format("%n    %s=<value>", match);
+                            }
+                        }
+                        throw new IllegalArgumentException(msg.toString());
+                    } else if (value instanceof Option) {
+                        Option option = (Option) value;
+                        option.init(e.getValue());
+                    }
+                }
+            }
+        }
     }
 
     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
         Iterable<HotSpotJVMCIBackendFactory> factories = getHotSpotJVMCIBackendFactories();
         assert factories != null : "sanity";
@@ -452,10 +527,13 @@
             vmLogStream = new PrintStream(getLogStream());
             System.setOut(vmLogStream);
             System.setErr(vmLogStream);
         }
 
+        // Initialize the Option values.
+        Option.parse();
+
         String hostArchitecture = config.getHostArchitectureName();
 
         HotSpotJVMCIBackendFactory factory;
         try (InitTimer t = timer("find factory:", hostArchitecture)) {
             factory = findFactory(hostArchitecture);
@@ -710,21 +788,29 @@
             }
         }
         return hsResult;
     }
 
+    /**
+     * Guard to ensure shut down actions are performed at most once.
+     */
+    private boolean isShutdown;
+
     /**
      * Shuts down the runtime.
      */
     @VMEntryPoint
-    private void shutdown() throws Exception {
-        // Cleaners are normally only processed when a new Cleaner is
-        // instantiated so process all remaining cleaners now.
-        Cleaner.clean();
-
-        for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
-            vmEventListener.notifyShutdown();
+    private synchronized void shutdown() throws Exception {
+        if (!isShutdown) {
+            isShutdown = true;
+            // Cleaners are normally only processed when a new Cleaner is
+            // instantiated so process all remaining cleaners now.
+            Cleaner.clean();
+
+            for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
+                vmEventListener.notifyShutdown();
+            }
         }
     }
 
     /**
      * Notify on completion of a bootstrap.
@@ -912,25 +998,34 @@
      *     private static char[] convertToCharArray(String[] a) { ... }
      * }
      * </pre>
      *
      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
-     * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}
-     * implementation will be exported as the following JNI-compatible symbol:
+     * shared library that contains the JVMCI compiler. The {@code JCompile.compile0} implementation
+     * must be exported as the following JNI-compatible symbol:
      *
      * <pre>
      * Java_com_jcompile_JCompile_compile0
      * </pre>
      *
      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names"
      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm"
      * @see "https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions"
      *
      *
-     * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing
-     *         the Java VM in the JVMCI shared library, and the remaining values are the first 3
-     *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})
+     * @return info about the Java VM in the JVMCI shared library {@code JavaVM*}. The info is
+     *         encoded in a long array as follows:
+     *
+     *         <pre>
+     *     long[] info = {
+     *         javaVM, // the {@code JavaVM*} value
+     *         javaVM->functions->reserved0,
+     *         javaVM->functions->reserved1,
+     *         javaVM->functions->reserved2
+     *     }
+     *         </pre>
+     *
      * @throws NullPointerException if {@code clazz == null}
      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
      *             {@code -XX:-UseJVMCINativeLibrary})
      * @throws IllegalStateException if the current execution context is the JVMCI shared library
      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
@@ -1015,10 +1110,12 @@
      *         thread was already attached
      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
      *             {@code -XX:-UseJVMCINativeLibrary})
      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
      *             error while trying to attach the thread
+     * @throws ArrayIndexOutOfBoundsException if {@code javaVMInfo} is non-null and is shorter than
+     *             the length of the array returned by {@link #registerNativeMethods}
      */
     public boolean attachCurrentThread(boolean asDaemon) {
         return compilerToVm.attachCurrentThread(asDaemon);
     }
 
diff a/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java b/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
--- a/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
+++ b/src/jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java
@@ -25,12 +25,15 @@
 
 package jdk.security.jarsigner;
 
 import com.sun.jarsigner.ContentSigner;
 import com.sun.jarsigner.ContentSignerParameters;
+import jdk.internal.access.JavaUtilZipFileAccess;
+import jdk.internal.access.SharedSecrets;
 import sun.security.tools.PathList;
 import sun.security.tools.jarsigner.TimestampedSigner;
+import sun.security.util.Event;
 import sun.security.util.ManifestDigester;
 import sun.security.util.SignatureFileVerifier;
 import sun.security.x509.AlgorithmId;
 
 import java.io.*;
@@ -80,10 +83,12 @@
  *
  * @since 9
  */
 public final class JarSigner {
 
+    static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
+
     /**
      * A mutable builder class that can create an immutable {@code JarSigner}
      * from various signing-related parameters.
      *
      * @since 9
@@ -498,10 +503,11 @@
     private final String tSADigestAlg;
     private final boolean signManifest; // "sign" the whole manifest
     private final boolean externalSF; // leave the .SF out of the PKCS7 block
     private final String altSignerPath;
     private final String altSigner;
+    private boolean posixPermsDetected;
 
     private JarSigner(JarSigner.Builder builder) {
 
         this.privateKey = builder.privateKey;
         this.certChain = builder.certChain;
@@ -941,10 +947,16 @@
         ZipEntry ze2 = new ZipEntry(ze.getName());
         ze2.setMethod(ze.getMethod());
         ze2.setTime(ze.getTime());
         ze2.setComment(ze.getComment());
         ze2.setExtra(ze.getExtra());
+        int perms = JUZFA.getPosixPerms(ze);
+        if (!posixPermsDetected && perms != -1) {
+            posixPermsDetected = true;
+            Event.report(Event.ReporterCategory.POSIXPERMS, "detected");
+        }
+        JUZFA.setPosixPerms(ze2, perms);
         if (ze.getMethod() == ZipEntry.STORED) {
             ze2.setSize(ze.getSize());
             ze2.setCrc(ze.getCrc());
         }
         os.putNextEntry(ze2);
diff a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
--- a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
+++ b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Main.java
@@ -48,10 +48,12 @@
 import java.security.cert.CertificateFactory;
 import java.security.cert.CertificateNotYetValidException;
 import java.security.cert.TrustAnchor;
 import java.util.Map.Entry;
 
+import jdk.internal.access.JavaUtilZipFileAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.security.jarsigner.JarSigner;
 import jdk.security.jarsigner.JarSignerException;
 import sun.security.pkcs.PKCS7;
 import sun.security.pkcs.SignerInfo;
 import sun.security.timestamp.TimestampToken;
@@ -106,17 +108,21 @@
     private static final Set<CryptoPrimitive> DIGEST_PRIMITIVE_SET = Collections
             .unmodifiableSet(EnumSet.of(CryptoPrimitive.MESSAGE_DIGEST));
     private static final Set<CryptoPrimitive> SIG_PRIMITIVE_SET = Collections
             .unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
+    private static boolean permsDetected;
+
     static final String VERSION = "1.0";
 
     static final int IN_KEYSTORE = 0x01;        // signer is in keystore
     static final int NOT_ALIAS = 0x04;          // alias list is NOT empty and
     // signer is not in alias list
     static final int SIGNED_BY_ALIAS = 0x08;    // signer is in alias list
 
+    static final JavaUtilZipFileAccess JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
+
     // Attention:
     // This is the entry that get launched by the security tool jarsigner.
     public static void main(String args[]) throws Exception {
         Main js = new Main();
         js.run(args);
@@ -292,11 +298,11 @@
             // zero-out keystore password
             if (storepass != null) {
                 Arrays.fill(storepass, ' ');
                 storepass = null;
             }
-            Event.clearReportListener();
+            Event.clearReportListener(Event.ReporterCategory.CRLCHECK);
         }
 
         if (strict) {
             int exitCode = 0;
             if (disabledAlg != 0 || chainNotValidated || hasExpiredCert
@@ -774,10 +780,13 @@
 
                 while (e.hasMoreElements()) {
                     JarEntry je = e.nextElement();
                     String name = je.getName();
 
+                    if (!permsDetected && JUZFA.getPosixPerms(je) != -1) {
+                        permsDetected = true;
+                    }
                     hasSignature = hasSignature
                             || SignatureFileVerifier.isBlockOrSF(name);
 
                     CodeSigner[] signers = je.getCodeSigners();
                     boolean isSigned = (signers != null);
@@ -1215,11 +1224,12 @@
         }
 
         if (hasExpiringCert ||
                 (hasExpiringTsaCert  && expireDate != null) ||
                 (noTimestamp && expireDate != null) ||
-                (hasExpiredTsaCert && signerNotExpired)) {
+                (hasExpiredTsaCert && signerNotExpired) ||
+                permsDetected) {
 
             if (hasExpiredTsaCert && signerNotExpired) {
                 if (expireDate != null) {
                     warnings.add(String.format(
                             rb.getString("The.timestamp.expired.1.but.usable.2"),
@@ -1252,10 +1262,13 @@
                     warnings.add(String.format(isSigning
                             ? rb.getString("no.timestamp.signing")
                             : rb.getString("no.timestamp.verifying"), expireDate));
                 }
             }
+            if (permsDetected) {
+                warnings.add(rb.getString("posix.attributes.detected"));
+            }
         }
 
         System.out.println(result);
         if (strict) {
             if (!errors.isEmpty()) {
@@ -1769,10 +1782,12 @@
 
         Throwable failedCause = null;
         String failedMessage = null;
 
         try {
+            Event.setReportListener(Event.ReporterCategory.POSIXPERMS,
+                    (t, o) -> permsDetected = true);
             builder.build().sign(zipFile, fos);
         } catch (JarSignerException e) {
             failedCause = e.getCause();
             if (failedCause instanceof SocketTimeoutException
                     || failedCause instanceof UnknownHostException) {
@@ -1803,10 +1818,11 @@
 
             if (fos != null) {
                 fos.close();
             }
 
+            Event.clearReportListener(Event.ReporterCategory.POSIXPERMS);
         }
 
         if (failedCause != null) {
             signedJarFile.delete();
             error(failedMessage, failedCause);
@@ -2062,11 +2078,12 @@
                             null);
 
                     if (revocationCheck) {
                         Security.setProperty("ocsp.enable", "true");
                         System.setProperty("com.sun.security.enableCRLDP", "true");
-                        Event.setReportListener((t, o) -> System.out.println(String.format(rb.getString(t), o)));
+                        Event.setReportListener(Event.ReporterCategory.CRLCHECK,
+                                (t, o) -> System.out.println(String.format(rb.getString(t), o)));
                     }
                     pkixParameters.setRevocationEnabled(revocationCheck);
                 } catch (InvalidAlgorithmParameterException ex) {
                     // Only if tas is empty
                 }
diff a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
--- a/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
+++ b/src/jdk.jartool/share/classes/sun/security/tools/jarsigner/Resources.java
@@ -168,10 +168,11 @@
         {"with.disabled", "%s (disabled)"},
         {"key.bit", "%d-bit key"},
         {"key.bit.weak", "%d-bit key (weak)"},
         {"key.bit.disabled", "%d-bit key (disabled)"},
         {"unknown.size", "unknown size"},
+        {"posix.attributes.detected", "POSIX file permission attributes detected. These attributes are ignored when signing and are not protected by the signature."},
 
         {"jarsigner.", "jarsigner: "},
         {"signature.filename.must.consist.of.the.following.characters.A.Z.0.9.or.",
                 "signature filename must consist of the following characters: A-Z, 0-9, _ or -"},
         {"unable.to.open.jar.file.", "unable to open jar file: "},
diff a/test/hotspot/jtreg/runtime/7162488/TestUnrecognizedVmOption.java b/test/hotspot/jtreg/runtime/7162488/TestUnrecognizedVmOption.java
--- a/test/hotspot/jtreg/runtime/7162488/TestUnrecognizedVmOption.java
+++ b/test/hotspot/jtreg/runtime/7162488/TestUnrecognizedVmOption.java
@@ -33,12 +33,12 @@
 
 public class TestUnrecognizedVmOption {
     static final String OPTION="this_is_not_an_option";
 
     public static void main(String[] args) throws Exception {
-        ProcessBuilder pb =
-            ProcessTools.createTestJvm("-showversion", "-XX:" + OPTION);
+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
+            "-showversion", "-XX:" + OPTION);
         new OutputAnalyzer(pb.start())
             .shouldNotHaveExitValue(0)
             .shouldContain("Unrecognized VM option")
             .shouldContain(OPTION);
     }
diff a/test/hotspot/jtreg/runtime/cds/appcds/PackageSealing.java b/test/hotspot/jtreg/runtime/cds/appcds/PackageSealing.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/PackageSealing.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/PackageSealing.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,38 +25,69 @@
 /*
  * @test
  * @summary AppCDS handling of package.
  * @requires vm.cds
  * @library /test/lib
- * @compile test-classes/C1.java
- * @compile test-classes/C2.java
- * @compile test-classes/PackageSealingTest.java
- * @compile test-classes/Hello.java
+ * @compile test-classes/C1.java test-classes/C2.java test-classes/C3.java
+ *          test-classes/PackageSealingTest.java test-classes/Hello.java
  * @run driver PackageSealing
  */
 
 import java.io.File;
 import jdk.test.lib.process.OutputAnalyzer;
 
 public class PackageSealing {
     public static void main(String args[]) throws Exception {
-        String[] classList = {"sealed/pkg/C1", "pkg/C2", "PackageSealingTest"};
-        String appJar = ClassFileInstaller.writeJar("pkg_seal.jar",
+        String[] classList = {"foo/C1", "pkg/C2", "PackageSealingTest"};
+        String appJar = ClassFileInstaller.writeJar("foo-sealed.jar",
             ClassFileInstaller.Manifest.fromSourceFile("test-classes/package_seal.mf"),
-            "PackageSealingTest", "sealed/pkg/C1", "pkg/C2");
+            "PackageSealingTest", "foo/C1", "pkg/C2");
 
         String helloJar = JarBuilder.getOrCreateHelloJar();
         String jars = helloJar + File.pathSeparator + appJar;
 
         // test shared package from -cp path
         TestCommon.testDump(jars, TestCommon.list(classList));
         OutputAnalyzer output;
-        output = TestCommon.exec(jars, "PackageSealingTest");
+        output = TestCommon.exec(jars, "PackageSealingTest",
+                                 "foo/C1", "sealed", "pkg/C2", "notSealed");
         TestCommon.checkExec(output, "OK");
 
         // test shared package from -Xbootclasspath/a
         TestCommon.dump(helloJar, TestCommon.list(classList),
                         "-Xbootclasspath/a:" + appJar);
-        output = TestCommon.exec(helloJar, "-Xbootclasspath/a:" + appJar, "PackageSealingTest");
+        output = TestCommon.exec(helloJar, "-Xbootclasspath/a:" + appJar,
+                                 "PackageSealingTest",
+                                 "foo/C1", "sealed", "pkg/C2", "notSealed");
         TestCommon.checkExec(output, "OK");
+
+        // Test loading of two classes from the same package from different jars.
+        // First loaded class is from a non-sealed package, the second loaded
+        // class is from the same package but sealed.
+        // The expected result is a SecurityException with a "sealing violation"
+        // for the second class.
+        classList[1] = "foo/C3"; // C3 is from a non-sealed package
+        String[] classList2 = {"foo/C3", "foo/C1", "PackageSealingTest"};
+        String nonSealedJar = ClassFileInstaller.writeJar("foo-unsealed.jar", "foo/C3");
+        jars = helloJar + File.pathSeparator + nonSealedJar;
+        TestCommon.testDump(jars, TestCommon.list(classList2));
+        jars += File.pathSeparator + appJar;
+        output = TestCommon.exec(jars, "-Xlog:class+load", "PackageSealingTest",
+                                 "foo/C3", "notSealed", "foo/C1", "sealed");
+        TestCommon.checkExec(output,
+                             "foo.C3 source: shared objects file",
+                             "sealing violation: can't seal package foo: already defined");
+
+        // Use the jar with the sealed package during dump time.
+        // Reverse the class loading order during runtime: load the class in the
+        // sealed package following by another class in the same package but unsealed.
+        // Same "sealing violation should result in loading the second class.
+        jars = helloJar + File.pathSeparator + appJar;
+        TestCommon.testDump(jars, TestCommon.list(classList2));
+        jars += File.pathSeparator + nonSealedJar;
+        output = TestCommon.exec(jars, "-Xlog:class+load", "PackageSealingTest",
+                                 "foo/C1", "sealed", "foo/C3", "notSealed");
+        TestCommon.checkExec(output,
+                             "foo.C1 source: shared objects file",
+                             "sealing violation: package foo is sealed");
     }
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C1.java b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C1.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C1.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C1.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,9 +20,9 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  *
  */
 
-package sealed.pkg;
+package foo;
 
 public class C1 {
 }
diff a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C3.java b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C3.java
--- /dev/null
+++ b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/C3.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package foo;
+
+public class C3 {
+}
diff a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/PackageSealingTest.java b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/PackageSealingTest.java
--- a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/PackageSealingTest.java
+++ b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/PackageSealingTest.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -24,25 +24,28 @@
 
 import java.lang.Package;
 
 public class PackageSealingTest {
     public static void main(String args[]) {
+        if (args.length != 4) {
+            throw new RuntimeException("Expecting 4 arguments");
+        }
         try {
-            Class c1 = PackageSealingTest.class.forName("sealed.pkg.C1");
-            Class c2 = PackageSealingTest.class.forName("pkg.C2");
+            Class c1 = PackageSealingTest.class.forName(args[0].replace('/', '.'));
+            Class c2 = PackageSealingTest.class.forName(args[2].replace('/', '.'));
             Package p1 = c1.getPackage();
             System.out.println("Package 1: " + p1.toString());
             Package p2 = c2.getPackage();
             System.out.println("Package 2: " + p2.toString());
 
-            if (!p1.isSealed()) {
-                System.out.println("Failed: sealed.pkg is not sealed.");
+            if (args[1].equals("sealed") && !p1.isSealed()) {
+                System.out.println("Failed: " + p1.toString() + " is not sealed.");
                 System.exit(0);
             }
 
-            if (p2.isSealed()) {
-                System.out.println("Failed: pkg is sealed.");
+            if (args[3].equals("notSealed") && p2.isSealed()) {
+                System.out.println("Failed: " + p2.toString() + " is sealed.");
                 System.exit(0);
             }
 
             System.out.println("OK");
         } catch (Exception e) {
diff a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/package_seal.mf b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/package_seal.mf
--- a/test/hotspot/jtreg/runtime/cds/appcds/test-classes/package_seal.mf
+++ b/test/hotspot/jtreg/runtime/cds/appcds/test-classes/package_seal.mf
@@ -1,6 +1,6 @@
 Manifest-Version: 1.0
 Created-By: 1.9.0-internal (Oracle Corporation)
 
-Name: sealed/pkg/
+Name: foo/
 Sealed: true
 
diff a/test/jdk/ProblemList.txt b/test/jdk/ProblemList.txt
--- a/test/jdk/ProblemList.txt
+++ b/test/jdk/ProblemList.txt
@@ -922,13 +922,8 @@
 
 ############################################################################
 
 # jdk_jpackage
 
-tools/jpackage/share/EmptyFolderPackageTest.java                    8248059 macosx-all
-tools/jpackage/share/IconTest.java                                  8248059 macosx-all
-tools/jpackage/share/AppImagePackageTest.java                       8248059 macosx-all
-tools/jpackage/share/SimplePackageTest.java                         8248059 macosx-all
-tools/jpackage/share/jdk/jpackage/tests/BasicTest.java              8248059 macosx-all
 tools/jpackage/share/jdk/jpackage/tests/ModulePathTest3.java#id0    8248418 generic-all
 
 ############################################################################
diff a/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java b/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java
--- /dev/null
+++ b/test/jdk/sun/security/tools/jarsigner/PosixPermissionsTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8218021
+ * @summary Have jarsigner preserve posix permission attributes
+ * @modules jdk.jartool/sun.security.tools.jarsigner
+ *          java.base/sun.security.tools.keytool
+ * @library /test/lib
+ * @run main/othervm PosixPermissionsTest
+ */
+
+import java.net.URI;
+import java.nio.file.*;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.*;
+
+import jdk.test.lib.SecurityTools;
+
+public class PosixPermissionsTest {
+
+    private static List<String> perms = List.of(
+            "---------",
+            "r--------",
+            "-w-------",
+            "--x------",
+            "rwx------",
+            "---r-----",
+            "----w----",
+            "-----x---",
+            "---rwx---",
+            "------r--",
+            "-------w-",
+            "--------x",
+            "------rwx",
+            "r--r-----",
+            "r--r--r--",
+            "rw-rw----",
+            "rwxrwx---",
+            "rw-rw-r--",
+            "r-xr-x---",
+            "r-xr-xr-x",
+            "rwxrwxrwx");
+
+    private final static String ZIPFILENAME = "8218021-test.zip";
+    private final static String JARFILENAME = "8218021-test.jar";
+    private final static URI JARURI = URI.create("jar:" + Path.of(JARFILENAME).toUri());
+    private final static URI ZIPURI = URI.create("jar:" + Path.of(ZIPFILENAME).toUri());
+    private static Path file;
+    private static int count;
+    private static Set<PosixFilePermission> permsSet;
+    private static String expectedJarPerms;
+    private static final String POSIXWARNING = "POSIX file permission attributes detected. " +
+        "These attributes are ignored when signing and are not protected by the signature.";
+
+    public static void main(String[] args) throws Exception {
+        if (!FileSystems.getDefault().supportedFileAttributeViews().contains("posix")) {
+            System.out.println("No posix support. Skipping");
+            return;
+        }
+
+        createFiles();
+        // check permissions before signing
+        verifyFilePermissions(ZIPURI, true);
+        verifyFilePermissions(JARURI, false);
+
+        SecurityTools.keytool(
+                "-genkey",
+                "-keyalg", "RSA",
+                "-dname", "CN=Coffey, OU=JPG, O=Oracle, L=Santa Clara, ST=California, C=US",
+                "-alias", "examplekey",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-keystore", "examplekeystore",
+                "-validity", "365")
+                .shouldHaveExitValue(0);
+
+        SecurityTools.jarsigner(
+                "-keystore", "examplekeystore",
+                "-verbose", ZIPFILENAME,
+                "-storepass", "password",
+                "-keypass", "password",
+                "examplekey")
+                .shouldHaveExitValue(0)
+                .shouldContain(POSIXWARNING);
+
+        // zip file now signed. Recheck file permissions
+        verifyFilePermissions(ZIPURI, true);
+
+        // sign jar file - no posix warning message expected
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-verbose", JARFILENAME,
+                "-storepass", "password",
+                "-keypass", "password",
+                "examplekey")
+                .shouldHaveExitValue(0)
+                .shouldNotContain(POSIXWARNING);
+
+        // default attributes expected
+        verifyFilePermissions(JARURI, false);
+
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-verbose",
+                "-verify", ZIPFILENAME)
+                .shouldHaveExitValue(0)
+                .shouldContain(POSIXWARNING);
+
+        // no warning expected for regular jar file
+        SecurityTools.jarsigner("-keystore", "examplekeystore",
+                "-storepass", "password",
+                "-keypass", "password",
+                "-verbose",
+                "-verify", JARFILENAME)
+                .shouldHaveExitValue(0)
+                .shouldNotContain(POSIXWARNING);
+    }
+
+    private static void createFiles() throws Exception {
+
+        String fileList = " ";
+        Map<String, String> env = new HashMap<>();
+        env.put("create", "true");
+        env.put("enablePosixFileAttributes", "true");
+
+        try (FileSystem zipfs = FileSystems.newFileSystem(ZIPURI, env)) {
+            for (String s : perms) {
+                file = Path.of("test_" + count++);
+                fileList += file + " ";
+                permsSet = PosixFilePermissions.fromString(s);
+                Files.createFile(file);
+
+                Files.copy(file,
+                        zipfs.getPath(file.toString()),
+                        StandardCopyOption.COPY_ATTRIBUTES);
+                Files.setPosixFilePermissions(zipfs.getPath(file.toString()), permsSet);
+            }
+        }
+
+        // create jar file for testing also
+        SecurityTools.jar("cf " + JARFILENAME + fileList);
+        try (FileSystem jarfs = FileSystems.newFileSystem(JARURI, env)) {
+            expectedJarPerms = PosixFilePermissions.toString(
+                    Files.getPosixFilePermissions(jarfs.getPath("test_1")));
+        }
+    }
+
+    private static void verifyFilePermissions(URI u, boolean containAttributes) throws Exception {
+        count = 0;
+        for (String s : perms) {
+            file = Path.of("test_" + count++);
+            checkEntryAttributes(u, file, s, containAttributes);
+        }
+    }
+
+    private static void checkEntryAttributes(URI uri, Path file,
+                                             String expectedPerms, boolean containAttributes) throws Exception {
+        try (FileSystem zipfs = FileSystems.newFileSystem(uri, Map.of("enablePosixFileAttributes", "true"))) {
+            Path p = zipfs.getPath(file.getFileName().toString());
+            Set<PosixFilePermission> permsSet = Files.getPosixFilePermissions(p);
+            String actualPerms = PosixFilePermissions.toString(permsSet);
+            if (containAttributes) {
+                if (!expectedPerms.equals(actualPerms)) {
+                    throw new RuntimeException("Unexpected permissions for: " + file + ". Received: " + actualPerms);
+                }
+            } else {
+                if (!actualPerms.equals(expectedJarPerms)) {
+                    throw new RuntimeException("Expected default permissions for " + file);
+                }
+            }
+        }
+    }
+}
diff a/test/jdk/sun/security/util/Resources/Usages.java b/test/jdk/sun/security/util/Resources/Usages.java
--- a/test/jdk/sun/security/util/Resources/Usages.java
+++ b/test/jdk/sun/security/util/Resources/Usages.java
@@ -73,11 +73,11 @@
     // rb.getString(). Used by keytool, jarsigner, and KeyStoreUtil.
     static Pattern RB_GETSTRING = Pattern.compile(
             "(?m)rb[ \\n]*\\.getString[ \\n]*\\([ \\n]*\"(.*?)\"\\)");
 
     static Pattern EVENT_OCSP_CRL = Pattern.compile(
-            "Event\\.report\\(\"(.*?)\",");
+            "Event\\.report\\(.*, \"(.*?)\",");
 
     // Command and Option enums in keytool
     static Pattern KT_ENUM = Pattern.compile("\\n +[A-Z]+\\(.*\"(.*)\"");
 
     // ResourceMgr.getAuthResourceString
diff a/test/lib/jdk/test/lib/apps/libLingeredApp.c b/test/lib/jdk/test/lib/apps/libLingeredApp.c
--- /dev/null
+++ b/test/lib/jdk/test/lib/apps/libLingeredApp.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <jni.h>
+
+/*
+ * Class:     jdk_test_lib_apps_LingeredApp
+ * Method:    crashMe
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL
+Java_jdk_test_lib_apps_LingeredApp_crashMe(JNIEnv *env, jclass klass) {
+  *((volatile int*)(1)) = 1;
+}

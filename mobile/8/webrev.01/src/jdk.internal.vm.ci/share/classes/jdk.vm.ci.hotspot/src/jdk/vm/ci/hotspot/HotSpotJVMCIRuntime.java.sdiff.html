<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HandleCleaner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotJVMCIRuntime.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;

  40 import java.util.HashMap;
  41 import java.util.List;
  42 import java.util.Map;
  43 import java.util.Objects;
  44 import java.util.ServiceLoader;
  45 import java.util.function.Predicate;
  46 
  47 import jdk.vm.ci.code.Architecture;
  48 import jdk.vm.ci.code.CompilationRequestResult;
  49 import jdk.vm.ci.code.CompiledCode;
  50 import jdk.vm.ci.code.InstalledCode;
  51 import jdk.vm.ci.common.InitTimer;
  52 import jdk.vm.ci.common.JVMCIError;
  53 import jdk.vm.ci.common.NativeImageReinitialize;
  54 import jdk.vm.ci.meta.JavaKind;
  55 import jdk.vm.ci.meta.JavaType;
  56 import jdk.vm.ci.meta.ResolvedJavaType;
  57 import jdk.vm.ci.meta.UnresolvedJavaType;
  58 import jdk.vm.ci.runtime.JVMCI;
  59 import jdk.vm.ci.runtime.JVMCIBackend;
</pre>
<hr />
<pre>
 193             }
 194         }
 195         return result;
 196     }
 197 
 198     @VMEntryPoint
 199     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 200         return TranslatedException.decodeThrowable(encodedThrowable);
 201     }
 202 
 203     @VMEntryPoint
 204     static String encodeThrowable(Throwable throwable) throws Throwable {
 205         return TranslatedException.encodeThrowable(throwable);
 206     }
 207 
 208     @VMEntryPoint
 209     static String callToString(Object o) {
 210         return o.toString();
 211     }
 212 









 213     /**
 214      * A list of all supported JVMCI options.
 215      */
 216     public enum Option {
 217         // @formatter:off
 218         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 219                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 220                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 221                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 222         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 223         // so that -XX:+JVMCIPrintProperties shows the option.
 224         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 225         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 226         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 227                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 228         TraceMethodDataFilter(String.class, null,
 229                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 230                 &quot;Empty value: trace all methods&quot;,
<span class="line-modified"> 231                 &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 232         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 233         // @formatter:on
 234 
 235         /**
 236          * The prefix for system properties that are JVMCI options.
 237          */
 238         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 239 
 240         /**
 241          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 242          */
 243         private static final String NULL_VALUE = &quot;NULL&quot;;
 244 
 245         private final Class&lt;?&gt; type;
 246         @NativeImageReinitialize private Object value;
 247         private final Object defaultValue;
<span class="line-modified"> 248         private boolean isDefault;</span>
 249         private final String[] helpLines;
 250 
 251         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 252             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 253             this.type = type;
 254             this.defaultValue = defaultValue;
 255             this.helpLines = helpLines;


 256         }
 257 
 258         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
<span class="line-modified"> 259         private Object getValue() {</span>
<span class="line-modified"> 260             if (value == null) {</span>
<span class="line-modified"> 261                 String propertyValue = Services.getSavedProperty(getPropertyName());</span>
<span class="line-modified"> 262                 if (propertyValue == null) {</span>
<span class="line-modified"> 263                     this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
<span class="line-modified"> 264                     this.isDefault = true;</span>




 265                 } else {
<span class="line-modified"> 266                     if (type == Boolean.class) {</span>
<span class="line-removed"> 267                         this.value = Boolean.parseBoolean(propertyValue);</span>
<span class="line-removed"> 268                     } else if (type == String.class) {</span>
<span class="line-removed"> 269                         this.value = propertyValue;</span>
<span class="line-removed"> 270                     } else {</span>
<span class="line-removed"> 271                         throw new JVMCIError(&quot;Unexpected option type &quot; + type);</span>
<span class="line-removed"> 272                     }</span>
<span class="line-removed"> 273                     this.isDefault = false;</span>
 274                 }











 275             }
<span class="line-modified"> 276             return value == NULL_VALUE ? null : value;</span>
 277         }
 278 
 279         /**
 280          * Gets the name of system property from which this option gets its value.
 281          */
 282         public String getPropertyName() {
 283             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 284         }
 285 
 286         /**
 287          * Returns the option&#39;s value as boolean.
 288          *
 289          * @return option&#39;s value
 290          */
 291         public boolean getBoolean() {
 292             return (boolean) getValue();
 293         }
 294 
 295         /**
 296          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 317                 if (value instanceof String) {
 318                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 319                 }
 320 
 321                 String name = option.getPropertyName();
 322                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 323                 String typeName = option.type.getSimpleName();
 324                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 325                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 326                 int linePad = typeStartPos - linePrefix.length();
 327                 if (linePad &gt; 0) {
 328                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 329                 } else {
 330                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 331                 }
 332                 for (String line : option.helpLines) {
 333                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 334                 }
 335             }
 336         }























































 337     }
 338 
 339     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 340         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 341         assert factories != null : &quot;sanity&quot;;
 342         for (HotSpotJVMCIBackendFactory factory : factories) {
 343             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 344                 return factory;
 345             }
 346         }
 347 
 348         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 349     }
 350 
 351     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 352 
 353     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 354     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 355         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 356             return cachedHotSpotJVMCIBackendFactories;
</pre>
<hr />
<pre>
 437 
 438     @SuppressWarnings(&quot;try&quot;)
 439     private HotSpotJVMCIRuntime() {
 440         compilerToVm = new CompilerToVM();
 441 
 442         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 443             configStore = new HotSpotVMConfigStore(compilerToVm);
 444             config = new HotSpotVMConfig(configStore);
 445         }
 446 
 447         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 448 
 449         PrintStream vmLogStream = null;
 450         if (IS_IN_NATIVE_IMAGE) {
 451             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 452             vmLogStream = new PrintStream(getLogStream());
 453             System.setOut(vmLogStream);
 454             System.setErr(vmLogStream);
 455         }
 456 



 457         String hostArchitecture = config.getHostArchitectureName();
 458 
 459         HotSpotJVMCIBackendFactory factory;
 460         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 461             factory = findFactory(hostArchitecture);
 462         }
 463 
 464         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 465             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 466         }
 467 
 468         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 469         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 470             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 471             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 472                 String name = HotSpotJVMCICompilerFactory.class.getName();
 473                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 474                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 475                 throw new UnsupportedOperationException(msg);
 476             }
</pre>
<hr />
<pre>
 695     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 696         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 697         CompilationRequestResult result = getCompiler().compileMethod(request);
 698         assert result != null : &quot;compileMethod must always return something&quot;;
 699         HotSpotCompilationRequestResult hsResult;
 700         if (result instanceof HotSpotCompilationRequestResult) {
 701             hsResult = (HotSpotCompilationRequestResult) result;
 702         } else {
 703             Object failure = result.getFailure();
 704             if (failure != null) {
 705                 boolean retry = false; // Be conservative with unknown compiler
 706                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 707             } else {
 708                 int inlinedBytecodes = -1;
 709                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 710             }
 711         }
 712         return hsResult;
 713     }
 714 





 715     /**
 716      * Shuts down the runtime.
 717      */
 718     @VMEntryPoint
<span class="line-modified"> 719     private void shutdown() throws Exception {</span>
<span class="line-modified"> 720         // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-modified"> 721         // instantiated so process all remaining cleaners now.</span>
<span class="line-modified"> 722         Cleaner.clean();</span>
<span class="line-modified"> 723 </span>
<span class="line-modified"> 724         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {</span>
<span class="line-modified"> 725             vmEventListener.notifyShutdown();</span>



 726         }
 727     }
 728 
 729     /**
 730      * Notify on completion of a bootstrap.
 731      */
 732     @VMEntryPoint
 733     private void bootstrapFinished() throws Exception {
 734         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 735             vmEventListener.notifyBootstrapFinished();
 736         }
 737     }
 738 
 739     /**
 740      * Notify on successful install into the CodeCache.
 741      *
 742      * @param hotSpotCodeCacheProvider
 743      * @param installedCode
 744      * @param compiledCode
 745      */
</pre>
<hr />
<pre>
 897      * import java.lang.reflect.Method;
 898      *
 899      * public static class JCompile {
 900      *     static {
 901      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 902      *     }
 903      *     public static boolean compile(Method method, String[] options) {
 904      *         // Convert to simpler data types for passing/serializing across native interface
 905      *         long metaspaceMethodHandle = getHandle(method);
 906      *         char[] opts = convertToCharArray(options);
 907      *         return compile(metaspaceMethodHandle, opts);
 908      *     }
 909      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 910      *
 911      *     private static long getHandle(Method method) { ... }
 912      *     private static char[] convertToCharArray(String[] a) { ... }
 913      * }
 914      * &lt;/pre&gt;
 915      *
 916      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="line-modified"> 917      * shared library that contains the bulk of the JVMCI compiler. The {@code JCompile.compile0}</span>
<span class="line-modified"> 918      * implementation will be exported as the following JNI-compatible symbol:</span>
 919      *
 920      * &lt;pre&gt;
 921      * Java_com_jcompile_JCompile_compile0
 922      * &lt;/pre&gt;
 923      *
 924      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
 925      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
 926      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
 927      *
 928      *
<span class="line-modified"> 929      * @return an array of 4 longs where the first value is the {@code JavaVM*} value representing</span>
<span class="line-modified"> 930      *         the Java VM in the JVMCI shared library, and the remaining values are the first 3</span>
<span class="line-modified"> 931      *         pointers in the Invocation API function table (i.e., {@code JNIInvokeInterface})</span>









 932      * @throws NullPointerException if {@code clazz == null}
 933      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
 934      *             {@code -XX:-UseJVMCINativeLibrary})
 935      * @throws IllegalStateException if the current execution context is the JVMCI shared library
 936      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
 937      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
 938      *             (no matching JNI symbol or the native method is already linked to a different
 939      *             address)
 940      */
 941     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
 942         return compilerToVm.registerNativeMethods(clazz);
 943     }
 944 
 945     /**
 946      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
 947      * objects can be translated are:
 948      * &lt;ul&gt;
 949      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
 950      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
 951      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
</pre>
<hr />
<pre>
1000     }
1001 
1002     /**
1003      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1004      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1005      */
1006     public long getCurrentJavaThread() {
1007         return compilerToVm.getCurrentJavaThread();
1008     }
1009 
1010     /**
1011      * Ensures the current thread is attached to the peer runtime.
1012      *
1013      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1014      * @return {@code true} if this call attached the current thread, {@code false} if the current
1015      *         thread was already attached
1016      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1017      *             {@code -XX:-UseJVMCINativeLibrary})
1018      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1019      *             error while trying to attach the thread


1020      */
1021     public boolean attachCurrentThread(boolean asDaemon) {
1022         return compilerToVm.attachCurrentThread(asDaemon);
1023     }
1024 
1025     /**
1026      * Detaches the current thread from the peer runtime.
1027      *
1028      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1029      *             {@code -XX:-UseJVMCINativeLibrary})
1030      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1031      *             thread is not attached or if there is an error while trying to detach the thread
1032      */
1033     public void detachCurrentThread() {
1034         compilerToVm.detachCurrentThread();
1035     }
1036 
1037     /**
1038      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1039      * with {@link #compileMethod}.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static jdk.vm.ci.common.InitTimer.timer;
  26 import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;
  27 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 
  30 import java.io.IOException;
  31 import java.io.OutputStream;
  32 import java.io.PrintStream;
  33 import java.io.Serializable;
  34 import java.lang.invoke.CallSite;
  35 import java.lang.invoke.ConstantCallSite;
  36 import java.lang.invoke.MethodHandle;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Collections;
<span class="line-added">  40 import java.util.Formatter;</span>
  41 import java.util.HashMap;
  42 import java.util.List;
  43 import java.util.Map;
  44 import java.util.Objects;
  45 import java.util.ServiceLoader;
  46 import java.util.function.Predicate;
  47 
  48 import jdk.vm.ci.code.Architecture;
  49 import jdk.vm.ci.code.CompilationRequestResult;
  50 import jdk.vm.ci.code.CompiledCode;
  51 import jdk.vm.ci.code.InstalledCode;
  52 import jdk.vm.ci.common.InitTimer;
  53 import jdk.vm.ci.common.JVMCIError;
  54 import jdk.vm.ci.common.NativeImageReinitialize;
  55 import jdk.vm.ci.meta.JavaKind;
  56 import jdk.vm.ci.meta.JavaType;
  57 import jdk.vm.ci.meta.ResolvedJavaType;
  58 import jdk.vm.ci.meta.UnresolvedJavaType;
  59 import jdk.vm.ci.runtime.JVMCI;
  60 import jdk.vm.ci.runtime.JVMCIBackend;
</pre>
<hr />
<pre>
 194             }
 195         }
 196         return result;
 197     }
 198 
 199     @VMEntryPoint
 200     static Throwable decodeThrowable(String encodedThrowable) throws Throwable {
 201         return TranslatedException.decodeThrowable(encodedThrowable);
 202     }
 203 
 204     @VMEntryPoint
 205     static String encodeThrowable(Throwable throwable) throws Throwable {
 206         return TranslatedException.encodeThrowable(throwable);
 207     }
 208 
 209     @VMEntryPoint
 210     static String callToString(Object o) {
 211         return o.toString();
 212     }
 213 
<span class="line-added"> 214     /**</span>
<span class="line-added"> 215      * Set of recognized {@code &quot;jvmci.*&quot;} system properties. Entries not associated with an</span>
<span class="line-added"> 216      * {@link Option} have this object as their value.</span>
<span class="line-added"> 217      */</span>
<span class="line-added"> 218     static final Map&lt;String, Object&gt; options = new HashMap&lt;&gt;();</span>
<span class="line-added"> 219     static {</span>
<span class="line-added"> 220         options.put(&quot;jvmci.class.path.append&quot;, options);</span>
<span class="line-added"> 221     }</span>
<span class="line-added"> 222 </span>
 223     /**
 224      * A list of all supported JVMCI options.
 225      */
 226     public enum Option {
 227         // @formatter:off
 228         Compiler(String.class, null, &quot;Selects the system compiler. This must match the getCompilerName() value returned &quot; +
 229                 &quot;by a jdk.vm.ci.runtime.JVMCICompilerFactory provider. &quot; +
 230                 &quot;An empty string or the value \&quot;null\&quot; selects a compiler &quot; +
 231                 &quot;that will raise an exception upon receiving a compilation request.&quot;),
 232         // Note: The following one is not used (see InitTimer.ENABLED). It is added here
 233         // so that -XX:+JVMCIPrintProperties shows the option.
 234         InitTimer(Boolean.class, false, &quot;Specifies if initialization timing is enabled.&quot;),
 235         PrintConfig(Boolean.class, false, &quot;Prints VM configuration available via JVMCI.&quot;),
 236         AuditHandles(Boolean.class, false, &quot;Record stack trace along with scoped foreign object reference wrappers &quot; +
 237                 &quot;to debug issue with a wrapper being used after its scope has closed.&quot;),
 238         TraceMethodDataFilter(String.class, null,
 239                 &quot;Enables tracing of profiling info when read by JVMCI.&quot;,
 240                 &quot;Empty value: trace all methods&quot;,
<span class="line-modified"> 241                         &quot;Non-empty value: trace methods whose fully qualified name contains the value.&quot;),</span>
 242         UseProfilingInformation(Boolean.class, true, &quot;&quot;);
 243         // @formatter:on
 244 
 245         /**
 246          * The prefix for system properties that are JVMCI options.
 247          */
 248         private static final String JVMCI_OPTION_PROPERTY_PREFIX = &quot;jvmci.&quot;;
 249 
 250         /**
 251          * Sentinel for value initialized to {@code null} since {@code null} means uninitialized.
 252          */
 253         private static final String NULL_VALUE = &quot;NULL&quot;;
 254 
 255         private final Class&lt;?&gt; type;
 256         @NativeImageReinitialize private Object value;
 257         private final Object defaultValue;
<span class="line-modified"> 258         private boolean isDefault = true;</span>
 259         private final String[] helpLines;
 260 
 261         Option(Class&lt;?&gt; type, Object defaultValue, String... helpLines) {
 262             assert Character.isUpperCase(name().charAt(0)) : &quot;Option name must start with upper-case letter: &quot; + name();
 263             this.type = type;
 264             this.defaultValue = defaultValue;
 265             this.helpLines = helpLines;
<span class="line-added"> 266             Object existing = options.put(getPropertyName(), this);</span>
<span class="line-added"> 267             assert existing == null : getPropertyName();</span>
 268         }
 269 
 270         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)
<span class="line-modified"> 271         private void init(String propertyValue) {</span>
<span class="line-modified"> 272             assert value == null : &quot;cannot re-initialize &quot; + name();</span>
<span class="line-modified"> 273             if (propertyValue == null) {</span>
<span class="line-modified"> 274                 this.value = defaultValue == null ? NULL_VALUE : defaultValue;</span>
<span class="line-modified"> 275                 this.isDefault = true;</span>
<span class="line-modified"> 276             } else {</span>
<span class="line-added"> 277                 if (type == Boolean.class) {</span>
<span class="line-added"> 278                     this.value = Boolean.parseBoolean(propertyValue);</span>
<span class="line-added"> 279                 } else if (type == String.class) {</span>
<span class="line-added"> 280                     this.value = propertyValue;</span>
 281                 } else {
<span class="line-modified"> 282                     throw new JVMCIError(&quot;Unexpected option type &quot; + type);</span>







 283                 }
<span class="line-added"> 284                 this.isDefault = false;</span>
<span class="line-added"> 285             }</span>
<span class="line-added"> 286         }</span>
<span class="line-added"> 287 </span>
<span class="line-added"> 288         @SuppressFBWarnings(value = &quot;ES_COMPARING_STRINGS_WITH_EQ&quot;, justification = &quot;sentinel must be String since it&#39;s a static final in an enum&quot;)</span>
<span class="line-added"> 289         private Object getValue() {</span>
<span class="line-added"> 290             if (value == NULL_VALUE) {</span>
<span class="line-added"> 291                 return null;</span>
<span class="line-added"> 292             }</span>
<span class="line-added"> 293             if (value == null) {</span>
<span class="line-added"> 294                 return defaultValue;</span>
 295             }
<span class="line-modified"> 296             return value;</span>
 297         }
 298 
 299         /**
 300          * Gets the name of system property from which this option gets its value.
 301          */
 302         public String getPropertyName() {
 303             return JVMCI_OPTION_PROPERTY_PREFIX + name();
 304         }
 305 
 306         /**
 307          * Returns the option&#39;s value as boolean.
 308          *
 309          * @return option&#39;s value
 310          */
 311         public boolean getBoolean() {
 312             return (boolean) getValue();
 313         }
 314 
 315         /**
 316          * Returns the option&#39;s value as String.
</pre>
<hr />
<pre>
 337                 if (value instanceof String) {
 338                     value = &#39;&quot;&#39; + String.valueOf(value) + &#39;&quot;&#39;;
 339                 }
 340 
 341                 String name = option.getPropertyName();
 342                 String assign = option.isDefault ? &quot;=&quot; : &quot;:=&quot;;
 343                 String typeName = option.type.getSimpleName();
 344                 String linePrefix = String.format(&quot;%s %s %s &quot;, name, assign, value);
 345                 int typeStartPos = PROPERTY_LINE_WIDTH - typeName.length();
 346                 int linePad = typeStartPos - linePrefix.length();
 347                 if (linePad &gt; 0) {
 348                     out.printf(&quot;%s%-&quot; + linePad + &quot;s[%s]%n&quot;, linePrefix, &quot;&quot;, typeName);
 349                 } else {
 350                     out.printf(&quot;%s[%s]%n&quot;, linePrefix, typeName);
 351                 }
 352                 for (String line : option.helpLines) {
 353                     out.printf(&quot;%&quot; + PROPERTY_HELP_INDENT + &quot;s%s%n&quot;, &quot;&quot;, line);
 354                 }
 355             }
 356         }
<span class="line-added"> 357 </span>
<span class="line-added"> 358         /**</span>
<span class="line-added"> 359          * Compute string similarity based on Dice&#39;s coefficient.</span>
<span class="line-added"> 360          *</span>
<span class="line-added"> 361          * Ported from str_similar() in globals.cpp.</span>
<span class="line-added"> 362          */</span>
<span class="line-added"> 363         static float stringSimiliarity(String str1, String str2) {</span>
<span class="line-added"> 364             int hit = 0;</span>
<span class="line-added"> 365             for (int i = 0; i &lt; str1.length() - 1; ++i) {</span>
<span class="line-added"> 366                 for (int j = 0; j &lt; str2.length() - 1; ++j) {</span>
<span class="line-added"> 367                     if ((str1.charAt(i) == str2.charAt(j)) &amp;&amp; (str1.charAt(i + 1) == str2.charAt(j + 1))) {</span>
<span class="line-added"> 368                         ++hit;</span>
<span class="line-added"> 369                         break;</span>
<span class="line-added"> 370                     }</span>
<span class="line-added"> 371                 }</span>
<span class="line-added"> 372             }</span>
<span class="line-added"> 373             return 2.0f * hit / (str1.length() + str2.length());</span>
<span class="line-added"> 374         }</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376         private static final float FUZZY_MATCH_THRESHOLD = 0.7F;</span>
<span class="line-added"> 377 </span>
<span class="line-added"> 378         /**</span>
<span class="line-added"> 379          * Parses all system properties starting with {@value #JVMCI_OPTION_PROPERTY_PREFIX} and</span>
<span class="line-added"> 380          * initializes the options based on their values.</span>
<span class="line-added"> 381          */</span>
<span class="line-added"> 382         static void parse() {</span>
<span class="line-added"> 383             Map&lt;String, String&gt; savedProps = jdk.vm.ci.services.Services.getSavedProperties();</span>
<span class="line-added"> 384             for (Map.Entry&lt;String, String&gt; e : savedProps.entrySet()) {</span>
<span class="line-added"> 385                 String name = e.getKey();</span>
<span class="line-added"> 386                 if (name.startsWith(Option.JVMCI_OPTION_PROPERTY_PREFIX)) {</span>
<span class="line-added"> 387                     Object value = options.get(name);</span>
<span class="line-added"> 388                     if (value == null) {</span>
<span class="line-added"> 389                         List&lt;String&gt; matches = new ArrayList&lt;&gt;();</span>
<span class="line-added"> 390                         for (String pn : options.keySet()) {</span>
<span class="line-added"> 391                             float score = stringSimiliarity(pn, name);</span>
<span class="line-added"> 392                             if (score &gt;= FUZZY_MATCH_THRESHOLD) {</span>
<span class="line-added"> 393                                 matches.add(pn);</span>
<span class="line-added"> 394                             }</span>
<span class="line-added"> 395                         }</span>
<span class="line-added"> 396                         Formatter msg = new Formatter();</span>
<span class="line-added"> 397                         msg.format(&quot;Could not find option %s&quot;, name);</span>
<span class="line-added"> 398                         if (!matches.isEmpty()) {</span>
<span class="line-added"> 399                             msg.format(&quot;%nDid you mean one of the following?&quot;);</span>
<span class="line-added"> 400                             for (String match : matches) {</span>
<span class="line-added"> 401                                 msg.format(&quot;%n    %s=&lt;value&gt;&quot;, match);</span>
<span class="line-added"> 402                             }</span>
<span class="line-added"> 403                         }</span>
<span class="line-added"> 404                         throw new IllegalArgumentException(msg.toString());</span>
<span class="line-added"> 405                     } else if (value instanceof Option) {</span>
<span class="line-added"> 406                         Option option = (Option) value;</span>
<span class="line-added"> 407                         option.init(e.getValue());</span>
<span class="line-added"> 408                     }</span>
<span class="line-added"> 409                 }</span>
<span class="line-added"> 410             }</span>
<span class="line-added"> 411         }</span>
 412     }
 413 
 414     private static HotSpotJVMCIBackendFactory findFactory(String architecture) {
 415         Iterable&lt;HotSpotJVMCIBackendFactory&gt; factories = getHotSpotJVMCIBackendFactories();
 416         assert factories != null : &quot;sanity&quot;;
 417         for (HotSpotJVMCIBackendFactory factory : factories) {
 418             if (factory.getArchitecture().equalsIgnoreCase(architecture)) {
 419                 return factory;
 420             }
 421         }
 422 
 423         throw new JVMCIError(&quot;No JVMCI runtime available for the %s architecture&quot;, architecture);
 424     }
 425 
 426     private static volatile List&lt;HotSpotJVMCIBackendFactory&gt; cachedHotSpotJVMCIBackendFactories;
 427 
 428     @SuppressFBWarnings(value = &quot;LI_LAZY_INIT_UPDATE_STATIC&quot;, justification = &quot;not sure about this&quot;)
 429     private static Iterable&lt;HotSpotJVMCIBackendFactory&gt; getHotSpotJVMCIBackendFactories() {
 430         if (IS_IN_NATIVE_IMAGE || cachedHotSpotJVMCIBackendFactories != null) {
 431             return cachedHotSpotJVMCIBackendFactories;
</pre>
<hr />
<pre>
 512 
 513     @SuppressWarnings(&quot;try&quot;)
 514     private HotSpotJVMCIRuntime() {
 515         compilerToVm = new CompilerToVM();
 516 
 517         try (InitTimer t = timer(&quot;HotSpotVMConfig&lt;init&gt;&quot;)) {
 518             configStore = new HotSpotVMConfigStore(compilerToVm);
 519             config = new HotSpotVMConfig(configStore);
 520         }
 521 
 522         reflection = IS_IN_NATIVE_IMAGE ? new SharedLibraryJVMCIReflection() : new HotSpotJDKReflection();
 523 
 524         PrintStream vmLogStream = null;
 525         if (IS_IN_NATIVE_IMAGE) {
 526             // Redirect System.out and System.err to HotSpot&#39;s TTY stream
 527             vmLogStream = new PrintStream(getLogStream());
 528             System.setOut(vmLogStream);
 529             System.setErr(vmLogStream);
 530         }
 531 
<span class="line-added"> 532         // Initialize the Option values.</span>
<span class="line-added"> 533         Option.parse();</span>
<span class="line-added"> 534 </span>
 535         String hostArchitecture = config.getHostArchitectureName();
 536 
 537         HotSpotJVMCIBackendFactory factory;
 538         try (InitTimer t = timer(&quot;find factory:&quot;, hostArchitecture)) {
 539             factory = findFactory(hostArchitecture);
 540         }
 541 
 542         try (InitTimer t = timer(&quot;create JVMCI backend:&quot;, hostArchitecture)) {
 543             hostBackend = registerBackend(factory.createJVMCIBackend(this, null));
 544         }
 545 
 546         compilerFactory = HotSpotJVMCICompilerConfig.getCompilerFactory();
 547         if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {
 548             hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;
 549             if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {
 550                 String name = HotSpotJVMCICompilerFactory.class.getName();
 551                 String msg = String.format(&quot;%s.getCompilationLevelAdjustment() is no longer supported. &quot; +
 552                                 &quot;Use %s.excludeFromJVMCICompilation() instead.&quot;, name, name);
 553                 throw new UnsupportedOperationException(msg);
 554             }
</pre>
<hr />
<pre>
 773     private HotSpotCompilationRequestResult compileMethod(HotSpotResolvedJavaMethod method, int entryBCI, long compileState, int id) {
 774         HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, compileState, id);
 775         CompilationRequestResult result = getCompiler().compileMethod(request);
 776         assert result != null : &quot;compileMethod must always return something&quot;;
 777         HotSpotCompilationRequestResult hsResult;
 778         if (result instanceof HotSpotCompilationRequestResult) {
 779             hsResult = (HotSpotCompilationRequestResult) result;
 780         } else {
 781             Object failure = result.getFailure();
 782             if (failure != null) {
 783                 boolean retry = false; // Be conservative with unknown compiler
 784                 hsResult = HotSpotCompilationRequestResult.failure(failure.toString(), retry);
 785             } else {
 786                 int inlinedBytecodes = -1;
 787                 hsResult = HotSpotCompilationRequestResult.success(inlinedBytecodes);
 788             }
 789         }
 790         return hsResult;
 791     }
 792 
<span class="line-added"> 793     /**</span>
<span class="line-added"> 794      * Guard to ensure shut down actions are performed at most once.</span>
<span class="line-added"> 795      */</span>
<span class="line-added"> 796     private boolean isShutdown;</span>
<span class="line-added"> 797 </span>
 798     /**
 799      * Shuts down the runtime.
 800      */
 801     @VMEntryPoint
<span class="line-modified"> 802     private synchronized void shutdown() throws Exception {</span>
<span class="line-modified"> 803         if (!isShutdown) {</span>
<span class="line-modified"> 804             isShutdown = true;</span>
<span class="line-modified"> 805             // Cleaners are normally only processed when a new Cleaner is</span>
<span class="line-modified"> 806             // instantiated so process all remaining cleaners now.</span>
<span class="line-modified"> 807             Cleaner.clean();</span>
<span class="line-modified"> 808 </span>
<span class="line-added"> 809             for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {</span>
<span class="line-added"> 810                 vmEventListener.notifyShutdown();</span>
<span class="line-added"> 811             }</span>
 812         }
 813     }
 814 
 815     /**
 816      * Notify on completion of a bootstrap.
 817      */
 818     @VMEntryPoint
 819     private void bootstrapFinished() throws Exception {
 820         for (HotSpotVMEventListener vmEventListener : getVmEventListeners()) {
 821             vmEventListener.notifyBootstrapFinished();
 822         }
 823     }
 824 
 825     /**
 826      * Notify on successful install into the CodeCache.
 827      *
 828      * @param hotSpotCodeCacheProvider
 829      * @param installedCode
 830      * @param compiledCode
 831      */
</pre>
<hr />
<pre>
 983      * import java.lang.reflect.Method;
 984      *
 985      * public static class JCompile {
 986      *     static {
 987      *         HotSpotJVMCIRuntime.runtime().registerNativeMethods(JCompile.class);
 988      *     }
 989      *     public static boolean compile(Method method, String[] options) {
 990      *         // Convert to simpler data types for passing/serializing across native interface
 991      *         long metaspaceMethodHandle = getHandle(method);
 992      *         char[] opts = convertToCharArray(options);
 993      *         return compile(metaspaceMethodHandle, opts);
 994      *     }
 995      *     private static native boolean compile0(long metaspaceMethodHandle, char[] options);
 996      *
 997      *     private static long getHandle(Method method) { ... }
 998      *     private static char[] convertToCharArray(String[] a) { ... }
 999      * }
1000      * &lt;/pre&gt;
1001      *
1002      * The implementation of the native {@code JCompile.compile0} method would be in the JVMCI
<span class="line-modified">1003      * shared library that contains the JVMCI compiler. The {@code JCompile.compile0} implementation</span>
<span class="line-modified">1004      * must be exported as the following JNI-compatible symbol:</span>
1005      *
1006      * &lt;pre&gt;
1007      * Java_com_jcompile_JCompile_compile0
1008      * &lt;/pre&gt;
1009      *
1010      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/design.html#resolving_native_method_names&quot;
1011      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#creating_the_vm&quot;
1012      * @see &quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/invocation.html#invocation_api_functions&quot;
1013      *
1014      *
<span class="line-modified">1015      * @return info about the Java VM in the JVMCI shared library {@code JavaVM*}. The info is</span>
<span class="line-modified">1016      *         encoded in a long array as follows:</span>
<span class="line-modified">1017      *</span>
<span class="line-added">1018      *         &lt;pre&gt;</span>
<span class="line-added">1019      *     long[] info = {</span>
<span class="line-added">1020      *         javaVM, // the {@code JavaVM*} value</span>
<span class="line-added">1021      *         javaVM-&gt;functions-&gt;reserved0,</span>
<span class="line-added">1022      *         javaVM-&gt;functions-&gt;reserved1,</span>
<span class="line-added">1023      *         javaVM-&gt;functions-&gt;reserved2</span>
<span class="line-added">1024      *     }</span>
<span class="line-added">1025      *         &lt;/pre&gt;</span>
<span class="line-added">1026      *</span>
1027      * @throws NullPointerException if {@code clazz == null}
1028      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1029      *             {@code -XX:-UseJVMCINativeLibrary})
1030      * @throws IllegalStateException if the current execution context is the JVMCI shared library
1031      * @throws IllegalArgumentException if {@code clazz} is {@link Class#isPrimitive()}
1032      * @throws UnsatisfiedLinkError if there&#39;s a problem linking a native method in {@code clazz}
1033      *             (no matching JNI symbol or the native method is already linked to a different
1034      *             address)
1035      */
1036     public long[] registerNativeMethods(Class&lt;?&gt; clazz) {
1037         return compilerToVm.registerNativeMethods(clazz);
1038     }
1039 
1040     /**
1041      * Creates or retrieves an object in the peer runtime that mirrors {@code obj}. The types whose
1042      * objects can be translated are:
1043      * &lt;ul&gt;
1044      * &lt;li&gt;{@link HotSpotResolvedJavaMethodImpl},&lt;/li&gt;
1045      * &lt;li&gt;{@link HotSpotResolvedObjectTypeImpl},&lt;/li&gt;
1046      * &lt;li&gt;{@link HotSpotResolvedPrimitiveType},&lt;/li&gt;
</pre>
<hr />
<pre>
1095     }
1096 
1097     /**
1098      * Gets the address of the HotSpot {@code JavaThread} C++ object for the current thread. This
1099      * will return {@code 0} if called from an unattached JVMCI shared library thread.
1100      */
1101     public long getCurrentJavaThread() {
1102         return compilerToVm.getCurrentJavaThread();
1103     }
1104 
1105     /**
1106      * Ensures the current thread is attached to the peer runtime.
1107      *
1108      * @param asDaemon if the thread is not yet attached, should it be attached as a daemon
1109      * @return {@code true} if this call attached the current thread, {@code false} if the current
1110      *         thread was already attached
1111      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1112      *             {@code -XX:-UseJVMCINativeLibrary})
1113      * @throws IllegalStateException if the peer runtime has not been initialized or there is an
1114      *             error while trying to attach the thread
<span class="line-added">1115      * @throws ArrayIndexOutOfBoundsException if {@code javaVMInfo} is non-null and is shorter than</span>
<span class="line-added">1116      *             the length of the array returned by {@link #registerNativeMethods}</span>
1117      */
1118     public boolean attachCurrentThread(boolean asDaemon) {
1119         return compilerToVm.attachCurrentThread(asDaemon);
1120     }
1121 
1122     /**
1123      * Detaches the current thread from the peer runtime.
1124      *
1125      * @throws UnsupportedOperationException if the JVMCI shared library is not enabled (i.e.
1126      *             {@code -XX:-UseJVMCINativeLibrary})
1127      * @throws IllegalStateException if the peer runtime has not been initialized or if the current
1128      *             thread is not attached or if there is an error while trying to detach the thread
1129      */
1130     public void detachCurrentThread() {
1131         compilerToVm.detachCurrentThread();
1132     }
1133 
1134     /**
1135      * Informs HotSpot that no method whose module is in {@code modules} is to be compiled
1136      * with {@link #compileMethod}.
</pre>
</td>
</tr>
</table>
<center><a href="HandleCleaner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jartool/share/classes/jdk/security/jarsigner/JarSigner.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
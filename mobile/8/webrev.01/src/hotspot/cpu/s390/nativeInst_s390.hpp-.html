<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/s390/nativeInst_s390.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * Copyright (c) 2016 SAP SE. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 // Major contributions by AHa, JL, LS
 27 
 28 #ifndef CPU_S390_NATIVEINST_S390_HPP
 29 #define CPU_S390_NATIVEINST_S390_HPP
 30 
 31 #include &quot;asm/macroAssembler.hpp&quot;
 32 #include &quot;runtime/icache.hpp&quot;
 33 #include &quot;runtime/os.hpp&quot;
 34 
 35 class NativeCall;
 36 class NativeFarCall;
 37 class NativeMovConstReg;
 38 class NativeJump;
 39 #ifndef COMPILER2
 40 class NativeGeneralJump;
 41 class NativeMovRegMem;
 42 #endif
 43 class NativeInstruction;
 44 
 45 NativeCall* nativeCall_before(address return_address);
 46 NativeCall* nativeCall_at(address instr);
 47 NativeFarCall* nativeFarCall_before(address return_address);
 48 NativeFarCall* nativeFarCall_at(address instr);
 49 NativeMovConstReg* nativeMovConstReg_at(address address);
 50 NativeMovConstReg* nativeMovConstReg_before(address address);
 51 NativeJump* nativeJump_at(address address);
 52 #ifndef COMPILER2
 53 NativeMovRegMem* nativeMovRegMem_at (address address);
 54 NativeGeneralJump* nativeGeneralJump_at(address address);
 55 #endif
 56 NativeInstruction* nativeInstruction_at(address address);
 57 
 58 // We have interface for the following instructions:
 59 // - NativeInstruction
 60 //   - NativeCall
 61 //   - NativeFarCall
 62 //   - NativeMovConstReg
 63 //   - NativeMovRegMem
 64 //   - NativeJump
 65 //   - NativeGeneralJump
 66 //   - NativeIllegalInstruction
 67 // The base class for different kinds of native instruction abstractions.
 68 // Provides the primitive operations to manipulate code relative to this.
 69 
 70 //-------------------------------------
 71 //  N a t i v e I n s t r u c t i o n
 72 //-------------------------------------
 73 
 74 class NativeInstruction {
 75   friend class Relocation;
 76 
 77  public:
 78 
 79   enum z_specific_constants {
 80     nop_instruction_size = 2
 81   };
 82 
 83   bool is_illegal();
 84 
 85   // Bcrl is currently the only accepted instruction here.
 86   bool is_jump();
 87 
 88   // We use an illtrap for marking a method as not_entrant or zombie.
 89   bool is_sigill_zombie_not_entrant();
 90 
 91   bool is_safepoint_poll() {
 92     // Is the current instruction a POTENTIAL read access to the polling page?
 93     // The instruction&#39;s current arguments are not checked!
 94     return MacroAssembler::is_load_from_polling_page(addr_at(0));
 95   }
 96 
 97   address get_poll_address(void *ucontext) {
 98     // Extract poll address from instruction and ucontext.
 99     return MacroAssembler::get_poll_address(addr_at(0), ucontext);
100   }
101 
102   uint get_poll_register() {
103     // Extract poll register from instruction.
104     return MacroAssembler::get_poll_register(addr_at(0));
105   }
106 
107  public:
108 
109   // The output of __ breakpoint_trap().
110   static int illegal_instruction();
111 
112   // The address of the currently processed instruction.
113   address instruction_address() const { return addr_at(0); }
114 
115  protected:
116   address addr_at(int offset) const { return address(this) + offset; }
117 
118   // z/Architecture terminology
119   //   halfword   = 2 bytes
120   //   word       = 4 bytes
121   //   doubleword = 8 bytes
122   unsigned short halfword_at(int offset) const { return *(unsigned short*)addr_at(offset); }
123   int  word_at(int offset)               const { return *(jint*)addr_at(offset); }
124   long long_at(int offset)               const { return *(jlong*)addr_at(offset); }
125   void set_halfword_at(int offset, short i); // Deals with I-cache.
126   void set_word_at(int offset, int i);       // Deals with I-cache.
127   void set_jlong_at(int offset, jlong i);    // Deals with I-cache.
128   void set_addr_at(int offset, address x);   // Deals with I-cache.
129 
130   void print() const;
131   void print(const char* msg) const;
132   void dump() const;
133   void dump(const unsigned int range) const;
134   void dump(const unsigned int range, const char* msg) const;
135 
136  public:
137 
138   void verify();
139 
140   // unit test stuff
141   static void test() {}                        // Override for testing.
142 
143   friend NativeInstruction* nativeInstruction_at(address address) {
144     NativeInstruction* inst = (NativeInstruction*)address;
145     #ifdef ASSERT
146       inst-&gt;verify();
147     #endif
148     return inst;
149   }
150 };
151 
152 //---------------------------------------------------
153 //  N a t i v e I l l e g a l I n s t r u c t i o n
154 //---------------------------------------------------
155 
156 class NativeIllegalInstruction: public NativeInstruction {
157  public:
158   enum z_specific_constants {
159     instruction_size = 2
160   };
161 
162   // Insert illegal opcode at specific address.
163   static void insert(address code_pos);
164 };
165 
166 //-----------------------
167 //  N a t i v e C a l l
168 //-----------------------
169 
170 // The NativeCall is an abstraction for accessing/manipulating call
171 // instructions. It is used to manipulate inline caches, primitive &amp;
172 // dll calls, etc.
173 
174 // A native call, as defined by this abstraction layer, consists of
175 // all instructions required to set up for and actually make the call.
176 //
177 // On z/Architecture, there exist three different forms of native calls:
178 // 1) Call with pc-relative address, 1 instruction
179 //    The location of the target function is encoded as relative address
180 //    in the call instruction. The short form (BRAS) allows for a
181 //    16-bit signed relative address (in 2-byte units). The long form
182 //    (BRASL) allows for a 32-bit signed relative address (in 2-byte units).
183 // 2) Call with immediate address, 3 or 5 instructions.
184 //    The location of the target function is given by an immediate
185 //    constant which is loaded into a (scratch) register. Depending on
186 //    the hardware capabilities, this takes 2 or 4 instructions.
187 //    The call itself is then a &quot;call by register&quot;(BASR) instruction.
188 // 3) Call with address from constant pool, 2(3) instructions (with dynamic TOC)
189 //    The location of the target function is stored in the constant pool
190 //    during compilation. From there it is loaded into a (scratch) register.
191 //    The call itself is then a &quot;call by register&quot;(BASR) instruction.
192 //
193 // When initially generating a call, the compiler uses form 2) (not
194 // patchable, target address constant, e.g. runtime calls) or 3) (patchable,
195 // target address might eventually get relocated). Later in the process,
196 // a call could be transformed into form 1) (also patchable) during ShortenBranches.
197 //
198 // If a call is/has to be patchable, the instruction sequence generated for it
199 // has to be constant in length. Excessive space, created e.g. by ShortenBranches,
200 // is allocated to lower addresses and filled with nops. That is necessary to
201 // keep the return address constant, no matter what form the call has.
202 // Methods dealing with such calls have &quot;patchable&quot; as part of their name.
203 
204 class NativeCall: public NativeInstruction {
205  public:
206 
207   static int get_IC_pos_in_java_to_interp_stub() {
208     return 0;
209   }
210 
211   enum z_specific_constants {
212     instruction_size                           = 18, // Used in shared code for calls with reloc_info:
213                                                      // value correct if !has_long_displacement_fast().
214     call_far_pcrelative_displacement_offset    =  4, // Includes 2 bytes for the nop.
215     call_far_pcrelative_displacement_alignment =  4
216   };
217 
218 
219   // Maximum size (in bytes) of a call to an absolute address.
220   // Used when emitting call to deopt handler blob, which is a
221   // &quot;load_const_call&quot;. The code pattern is:
222   //   tmpReg := load_const(address);   (* depends on CPU ArchLvl, but is otherwise constant *)
223   //   call(tmpReg);                    (* basr, 2 bytes *)
224   static unsigned int max_instruction_size() {
225     return MacroAssembler::load_const_size() + MacroAssembler::call_byregister_size();
226   }
227 
228   // address instruction_address() const { return addr_at(0); }
229 
230   // For the ordering of the checks see note at nativeCall_before.
231   address next_instruction_address() const  {
232     address iaddr = instruction_address();
233 
234     if (MacroAssembler::is_load_const_call(iaddr)) {
235       // Form 2): load_const, BASR
236       return addr_at(MacroAssembler::load_const_call_size());
237     }
238 
239     if (MacroAssembler::is_load_const_from_toc_call(iaddr)) {
240       // Form 3): load_const_from_toc (LARL+LG/LGRL), BASR.
241       return addr_at(MacroAssembler::load_const_from_toc_call_size());
242     }
243 
244     if (MacroAssembler::is_call_far_pcrelative(iaddr)) {
245       // Form 1): NOP, BRASL
246       // The BRASL (Branch Relative And Save Long) is patched into the space created
247       // by the load_const_from_toc_call sequence (typically (LARL-LG)/LGRL - BASR.
248       // The BRASL must be positioned such that it&#39;s end is FW (4-byte) aligned (for atomic patching).
249       // It is achieved by aligning the end of the entire sequence on a 4byte boundary, by inserting
250       // a nop, if required, at the very beginning of the instruction sequence. The nop needs to
251       // be accounted for when calculating the next instruction address. The alignment takes place
252       // already when generating the original instruction sequence. The alignment requirement
253       // makes the size depend on location.
254       // The return address of the call must always be at the end of the instruction sequence.
255       // Inserting the extra alignment nop (or anything else) at the end is not an option.
256       // The patched-in brasl instruction is prepended with a nop to make it easier to
257       // distinguish from a load_const_from_toc_call sequence.
258       return addr_at(MacroAssembler::call_far_pcrelative_size());
259     }
260 
261     ((NativeCall*)iaddr)-&gt;print();
262     guarantee(false, &quot;Not a NativeCall site&quot;);
263     return NULL;
264   }
265 
266   address return_address() const {
267     return next_instruction_address();
268   }
269 
270   address destination() const;
271 
272   void set_destination_mt_safe(address dest);
273 
274   void verify_alignment() {} // Yet another real do nothing guy :)
275   void verify();
276 
277   // unit test stuff
278   static void test();
279 
280   // Creation.
281   friend NativeCall* nativeCall_at(address instr) {
282     NativeCall* call;
283 
284     // Make sure not to return garbage.
285     if (NativeCall::is_call_at(instr)) {
286       call = (NativeCall*)instr;
287     } else {
288       call = (NativeCall*)instr;
289       call-&gt;print();
290       guarantee(false, &quot;Not a NativeCall site&quot;);
291     }
292 
293 #ifdef ASSERT
294     call-&gt;verify();
295 #endif
296     return call;
297   }
298 
299   // This is a very tricky function to implement. It involves stepping
300   // backwards in the instruction stream. On architectures with variable
301   // instruction length, this is a risky endeavor. From the return address,
302   // you do not know how far to step back to be at a location (your starting
303   // point) that will eventually bring you back to the return address.
304   // Furthermore, it may happen that there are multiple starting points.
305   //
306   // With only a few possible (allowed) code patterns, the risk is lower but
307   // does not diminish completely. Experience shows that there are code patterns
308   // which look like a load_const_from_toc_call @(return address-8), but in
309   // fact are a call_far_pcrelative @(return address-6). The other way around
310   // is possible as well, but was not knowingly observed so far.
311   //
312   // The unpredictability is caused by the pc-relative address field in both
313   // the call_far_pcrelative (BASR) and the load_const_from_toc (LGRL)
314   // instructions. This field can contain an arbitrary bit pattern.
315   //
316   // Here is a real-world example:
317   // Mnemonics: &lt;not a valid sequence&gt;   LGRL r10,&lt;addr&gt; BASR r14,r10
318   // Hex code:  eb01 9008 007a c498 ffff c4a8 c0e5 ffc1 0dea
319   // Mnemonics: AGSI &lt;mem&gt;,I8  LGRL r9,&lt;addr&gt; BRASL r14,&lt;addr&gt;  correct
320   //
321   // If you first check for a load_const_from_toc_call @(-8), you will find
322   // a false positive. In this example, it is obviously false, because the
323   // preceding bytes do not form a valid instruction pattern. If you first
324   // check for call_far_pcrelative @(-6), you get a true positive - in this
325   // case.
326   //
327   // The following remedy has been implemented/enforced:
328   // 1) Everywhere, the permissible code patterns are checked in the same
329   //    sequence: Form 2) - Form 3) - Form 1).
330   // 2) The call_far_pcrelative, which would ideally be just one BRASL
331   //    instruction, is always prepended with a NOP. This measure avoids
332   //    ambiguities with load_const_from_toc_call.
333   friend NativeCall* nativeCall_before(address return_address) {
334     NativeCall *call = NULL;
335 
336     // Make sure not to return garbage
337     address instp = return_address - MacroAssembler::load_const_call_size();
338     if (MacroAssembler::is_load_const_call(instp)) {                 // Form 2)
339       call = (NativeCall*)(instp);                                   // load_const + basr
340     } else {
341       instp = return_address - MacroAssembler::load_const_from_toc_call_size();
342       if (MacroAssembler::is_load_const_from_toc_call(instp)) {      // Form 3)
343         call = (NativeCall*)(instp);                                 // load_const_from_toc + basr
344       } else {
345         instp = return_address - MacroAssembler::call_far_pcrelative_size();
346         if (MacroAssembler::is_call_far_pcrelative(instp)) {         // Form 1)
347           call = (NativeCall*)(instp);                               // brasl (or nop + brasl)
348         } else {
349           call = (NativeCall*)(instp);
350           call-&gt;print();
351           guarantee(false, &quot;Not a NativeCall site&quot;);
352         }
353       }
354     }
355 
356 #ifdef ASSERT
357     call-&gt;verify();
358 #endif
359     return call;
360   }
361 
362   // Ordering of checks 2) 3) 1) is relevant!
363   static bool is_call_at(address a) {
364     // Check plain instruction sequence. Do not care about filler or alignment nops.
365     bool b = MacroAssembler::is_load_const_call(a) ||           // load_const + basr
366              MacroAssembler::is_load_const_from_toc_call(a) ||  // load_const_from_toc + basr
367              MacroAssembler::is_call_far_pcrelative(a);         // nop + brasl
368     return b;
369   }
370 
371   // Ordering of checks 2) 3) 1) is relevant!
372   static bool is_call_before(address a) {
373     // check plain instruction sequence. Do not care about filler or alignment nops.
374     bool b = MacroAssembler::is_load_const_call(         a - MacroAssembler::load_const_call_size()) ||           // load_const + basr
375              MacroAssembler::is_load_const_from_toc_call(a - MacroAssembler::load_const_from_toc_call_size()) ||  // load_const_from_toc + basr
376              MacroAssembler::is_call_far_pcrelative(     a - MacroAssembler::call_far_pcrelative_size());         // nop+brasl
377     return b;
378   }
379 
380   static bool is_call_to(address instr, address target) {
381     // Check whether there is a `NativeCall&#39; at the address `instr&#39;
382     // calling to the address `target&#39;.
383     return is_call_at(instr) &amp;&amp; target == ((NativeCall *)instr)-&gt;destination();
384   }
385 
386   bool is_pcrelative() {
387     return MacroAssembler::is_call_far_pcrelative((address)this);
388   }
389 };
390 
391 //-----------------------------
392 //  N a t i v e F a r C a l l
393 //-----------------------------
394 
395 // The NativeFarCall is an abstraction for accessing/manipulating native
396 // call-anywhere instructions.
397 // Used to call native methods which may be loaded anywhere in the address
398 // space, possibly out of reach of a call instruction.
399 
400 // Refer to NativeCall for a description of the supported call forms.
401 
402 class NativeFarCall: public NativeInstruction {
403 
404  public:
405   // We use MacroAssembler::call_far_patchable() for implementing a
406   // call-anywhere instruction.
407 
408   static int instruction_size()      { return MacroAssembler::call_far_patchable_size(); }
409   static int return_address_offset() { return MacroAssembler::call_far_patchable_ret_addr_offset(); }
410 
411   // address instruction_address() const { return addr_at(0); }
412 
413   address next_instruction_address() const {
414     return addr_at(instruction_size());
415   }
416 
417   address return_address() const {
418     return addr_at(return_address_offset());
419   }
420 
421   // Returns the NativeFarCall&#39;s destination.
422   address destination();
423 
424   // Sets the NativeCall&#39;s destination, not necessarily mt-safe.
425   // Used when relocating code.
426   void set_destination(address dest, int toc_offset);
427 
428   // Checks whether instr points at a NativeFarCall instruction.
429   static bool is_far_call_at(address instr) {
430     // Use compound inspection function which, in addition to instruction sequence,
431     // also checks for expected nops and for instruction alignment.
432     return MacroAssembler::is_call_far_patchable_at(instr);
433   }
434 
435   // Does the NativeFarCall implementation use a pc-relative encoding
436   // of the call destination?
437   // Used when relocating code.
438   bool is_pcrelative() {
439     address iaddr = (address)this;
440     assert(is_far_call_at(iaddr), &quot;unexpected call type&quot;);
441     return MacroAssembler::is_call_far_patchable_pcrelative_at(iaddr);
442   }
443 
444   void verify();
445 
446   // Unit tests
447   static void test();
448 
449   // Instantiates a NativeFarCall object starting at the given instruction
450   // address and returns the NativeFarCall object.
451   inline friend NativeFarCall* nativeFarCall_at(address instr) {
452     NativeFarCall* call = (NativeFarCall*)instr;
453 #ifdef ASSERT
454     call-&gt;verify();
455 #endif
456     return call;
457   }
458 };
459 
460 
461 //-------------------------------------
462 //  N a t i v e M o v C o n s t R e g
463 //-------------------------------------
464 
465 // An interface for accessing/manipulating native set_oop imm, reg instructions.
466 // (Used to manipulate inlined data references, etc.)
467 
468 // A native move of a constant into a register, as defined by this abstraction layer,
469 // deals with instruction sequences that load &quot;quasi constant&quot; oops into registers
470 // for addressing. For multiple causes, those &quot;quasi constant&quot; oops eventually need
471 // to be changed (i.e. patched). The reason is quite simple: objects might get moved
472 // around in storage. Pc-relative oop addresses have to be patched also if the
473 // reference location is moved. That happens when executable code is relocated.
474 
475 class NativeMovConstReg: public NativeInstruction {
476  public:
477 
478   enum z_specific_constants {
479     instruction_size = 10 // Used in shared code for calls with reloc_info.
480   };
481 
482   // address instruction_address() const { return addr_at(0); }
483 
484   // The current instruction might be located at an offset.
485   address next_instruction_address(int offset = 0) const;
486 
487   // (The [set_]data accessor respects oop_type relocs also.)
488   intptr_t data() const;
489 
490   // Patch data in code stream.
491   address set_data_plain(intptr_t x, CodeBlob *code);
492   // Patch data in code stream and oop pool if necessary.
493   void set_data(intptr_t x, relocInfo::relocType expected_type = relocInfo::none);
494 
495   // Patch narrow oop constant in code stream.
496   void set_narrow_oop(intptr_t data);
497   void set_narrow_klass(intptr_t data);
498   void set_pcrel_addr(intptr_t addr, CompiledMethod *nm = NULL);
499   void set_pcrel_data(intptr_t data, CompiledMethod *nm = NULL);
500 
501   void verify();
502 
503   // unit test stuff
504   static void test();
505 
506   // Creation.
507   friend NativeMovConstReg* nativeMovConstReg_at(address address) {
508     NativeMovConstReg* test = (NativeMovConstReg*)address;
509     #ifdef ASSERT
510       test-&gt;verify();
511     #endif
512     return test;
513   }
514 };
515 
516 
517 #ifdef COMPILER1
518 //---------------------------------
519 //  N a t i v e M o v R e g M e m
520 //---------------------------------
521 
522 // Interface to manipulate a code sequence that performs a memory access (load/store).
523 // The code is the patchable version of memory accesses generated by
524 // LIR_Assembler::reg2mem() and LIR_Assembler::mem2reg().
525 //
526 // Loading the offset for the mem access is target of the manipulation.
527 //
528 // The instruction sequence looks like this:
529 //   iihf        %r1,$bits1              ; load offset for mem access
530 //   iilf        %r1,$bits2
531 //   [compress oop]                      ; optional, load only
532 //   load/store  %r2,0(%r1,%r2)          ; memory access
533 
534 class NativeMovRegMem;
535 inline NativeMovRegMem* nativeMovRegMem_at (address address);
536 class NativeMovRegMem: public NativeInstruction {
537  public:
538   enum z_specific_constants {
539     instruction_size = 12 // load_const used with access_field_id
540   };
541 
542   int num_bytes_to_end_of_patch() const { return instruction_size; }
543 
544   intptr_t offset() const {
545     return nativeMovConstReg_at(addr_at(0))-&gt;data();
546   }
547   void set_offset(intptr_t x) {
548     nativeMovConstReg_at(addr_at(0))-&gt;set_data(x);
549   }
550   void add_offset_in_bytes(intptr_t radd_offset) {
551     set_offset(offset() + radd_offset);
552   }
553   void verify();
554 
555  private:
556   friend inline NativeMovRegMem* nativeMovRegMem_at(address address) {
557     NativeMovRegMem* test = (NativeMovRegMem*)address;
558     #ifdef ASSERT
559       test-&gt;verify();
560     #endif
561     return test;
562   }
563 };
564 #endif // COMPILER1
565 
566 
567 //-----------------------
568 //  N a t i v e J u m p
569 //-----------------------
570 
571 
572 // An interface for accessing/manipulating native jumps
573 class NativeJump: public NativeInstruction {
574  public:
575   enum z_constants {
576     instruction_size = 2 // Size of z_illtrap().
577   };
578 
579   // Maximum size (in bytes) of a jump to an absolute address.
580   // Used when emitting branch to an exception handler which is a &quot;load_const_optimized_branch&quot;.
581   // Thus, a pessimistic estimate is obtained when using load_const.
582   // code pattern is:
583   //   tmpReg := load_const(address);   (* varying size *)
584   //   jumpTo(tmpReg);                  (* bcr, 2 bytes *)
585   //
586   static unsigned int max_instruction_size() {
587     return MacroAssembler::load_const_size() + MacroAssembler::jump_byregister_size();
588   }
589 
590 
591 //  address instruction_address() const { return addr_at(0); }
592 
593   address jump_destination() const {
594     return (address)nativeMovConstReg_at(instruction_address())-&gt;data();
595   }
596 
597   void set_jump_destination(address dest) {
598     nativeMovConstReg_at(instruction_address())-&gt;set_data(((intptr_t)dest));
599   }
600 
601   // Creation
602   friend NativeJump* nativeJump_at(address address) {
603     NativeJump* jump = (NativeJump*)address;
604     #ifdef ASSERT
605       jump-&gt;verify();
606     #endif
607     return jump;
608   }
609 
610   static bool is_jump_at(address a) {
611     int off = 0;
612     bool b = (MacroAssembler::is_load_const_from_toc(a+off) &amp;&amp;
613               Assembler::is_z_br(*(short*)(a+off + MacroAssembler::load_const_from_toc_size())));
614     b = b || (MacroAssembler::is_load_const(a+off) &amp;&amp;
615               Assembler::is_z_br(*(short*)(a+off + MacroAssembler::load_const_size())));
616     return b;
617   }
618 
619   void verify();
620 
621   // Unit testing stuff
622   static void test();
623 
624   // Insertion of native jump instruction.
625   static void insert(address code_pos, address entry);
626 
627   // MT-safe insertion of native jump at verified method entry.
628   static void check_verified_entry_alignment(address entry, address verified_entry) { }
629 
630   static void patch_verified_entry(address entry, address verified_entry, address dest);
631 };
632 
633 //-------------------------------------
634 //  N a t i v e G e n e r a l J u m p
635 //-------------------------------------
636 
637 // Despite the name, handles only simple branches.
638 // On ZARCH_64 BRCL only.
639 class NativeGeneralJump;
640 inline NativeGeneralJump* nativeGeneralJump_at(address address);
641 class NativeGeneralJump: public NativeInstruction {
642  public:
643   enum ZARCH_specific_constants {
644     instruction_size = 6
645   };
646 
647   address instruction_address() const { return addr_at(0); }
648   address jump_destination()    const { return addr_at(0) + MacroAssembler::get_pcrel_offset(addr_at(0)); }
649 
650   // Creation
651   friend inline NativeGeneralJump* nativeGeneralJump_at(address addr) {
652     NativeGeneralJump* jump = (NativeGeneralJump*)(addr);
653 #ifdef ASSERT
654     jump-&gt;verify();
655 #endif
656     return jump;
657   }
658 
659   // Insertion of native general jump instruction.
660   static void insert_unconditional(address code_pos, address entry);
661 
662   void set_jump_destination(address dest) {
663     Unimplemented();
664     // set_word_at(MacroAssembler::call_far_pcrelative_size()-4, Assembler::z_pcrel_off(dest, addr_at(0)));
665   }
666 
667   static void replace_mt_safe(address instr_addr, address code_buffer);
668 
669   void verify() PRODUCT_RETURN;
670 };
671 
672 #endif // CPU_S390_NATIVEINST_S390_HPP
    </pre>
  </body>
</html>
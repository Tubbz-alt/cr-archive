<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../arm/nativeInst_arm_32.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/nativeInst_aarch64.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, 2108, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 85   u_char ubyte_at(int offset) const    { return *(u_char*) addr_at(offset); }
 86 
 87   jint int_at(int offset) const        { return *(jint*) addr_at(offset); }
 88   juint uint_at(int offset) const      { return *(juint*) addr_at(offset); }
 89 
 90   address ptr_at(int offset) const     { return *(address*) addr_at(offset); }
 91 
 92   oop  oop_at (int offset) const       { return *(oop*) addr_at(offset); }
 93 
 94 
 95   void set_char_at(int offset, char c)        { *addr_at(offset) = (u_char)c; }
 96   void set_int_at(int offset, jint  i)        { *(jint*)addr_at(offset) = i; }
 97   void set_uint_at(int offset, jint  i)       { *(juint*)addr_at(offset) = i; }
 98   void set_ptr_at (int offset, address  ptr)  { *(address*) addr_at(offset) = ptr; }
 99   void set_oop_at (int offset, oop  o)        { *(oop*) addr_at(offset) = o; }
100 
101   void wrote(int offset);
102 
103  public:
104 
<span class="line-removed">105   // unit test stuff</span>
<span class="line-removed">106   static void test() {}                 // override for testing</span>
<span class="line-removed">107 </span>
108   inline friend NativeInstruction* nativeInstruction_at(address address);
109 
110   static bool is_adrp_at(address instr);
111 
112   static bool is_ldr_literal_at(address instr);
113 
114   bool is_ldr_literal() {
115     return is_ldr_literal_at(addr_at(0));
116   }
117 
118   static bool is_ldrw_to_zr(address instr);
119 
120   static bool is_call_at(address instr) {
121     const uint32_t insn = (*(uint32_t*)instr);
122     return (insn &gt;&gt; 26) == 0b100101;
123   }
124 
125   bool is_call() {
126     return is_call_at(addr_at(0));
127   }
</pre>
<hr />
<pre>
304     else if (is_adrp_at(instruction_address()))
305       return addr_at(2*4);
306     else if (is_ldr_literal_at(instruction_address()))
307       return(addr_at(4));
308     assert(false, &quot;Unknown instruction in NativeMovConstReg&quot;);
309     return NULL;
310   }
311 
312   intptr_t data() const;
313   void  set_data(intptr_t x);
314 
315   void flush() {
316     if (! maybe_cpool_ref(instruction_address())) {
317       ICache::invalidate_range(instruction_address(), instruction_size);
318     }
319   }
320 
321   void  verify();
322   void  print();
323 
<span class="line-removed">324   // unit test stuff</span>
<span class="line-removed">325   static void test() {}</span>
<span class="line-removed">326 </span>
327   // Creation
328   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
329   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
330 };
331 
332 inline NativeMovConstReg* nativeMovConstReg_at(address address) {
333   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_offset);
334 #ifdef ASSERT
335   test-&gt;verify();
336 #endif
337   return test;
338 }
339 
340 inline NativeMovConstReg* nativeMovConstReg_before(address address) {
341   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);
342 #ifdef ASSERT
343   test-&gt;verify();
344 #endif
345   return test;
346 }
</pre>
<hr />
<pre>
380     next_instruction_offset     =    4
381   };
382 
383  public:
384   // helper
385   int instruction_start() const { return instruction_offset; }
386 
387   address instruction_address() const { return addr_at(instruction_offset); }
388 
389   int num_bytes_to_end_of_patch() const { return instruction_offset + instruction_size; }
390 
391   int   offset() const;
392 
393   void  set_offset(int x);
394 
395   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }
396 
397   void verify();
398   void print ();
399 
<span class="line-removed">400   // unit test stuff</span>
<span class="line-removed">401   static void test() {}</span>
<span class="line-removed">402 </span>
403  private:
404   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
405 };
406 
407 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
408   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
409 #ifdef ASSERT
410   test-&gt;verify();
411 #endif
412   return test;
413 }
414 
415 class NativeMovRegMemPatching: public NativeMovRegMem {
416  private:
417   friend NativeMovRegMemPatching* nativeMovRegMemPatching_at (address address) {Unimplemented(); return 0;  }
418 };
419 
420 // An interface for accessing/manipulating native leal instruction of form:
421 //        leal reg, [reg + offset]
422 
423 class NativeLoadAddress: public NativeInstruction {
424   enum AArch64_specific_constants {
425     instruction_size            =    4,
426     instruction_offset          =    0,
427     data_offset                 =    0,
428     next_instruction_offset     =    4
429   };
430 
431  public:
432   void verify();
433   void print ();
434 
<span class="line-removed">435   // unit test stuff</span>
<span class="line-removed">436   static void test() {}</span>
437 };
438 
439 //   adrp    x16, #page
440 //   add     x16, x16, #offset
441 //   ldr     x16, [x16]
442 class NativeLoadGot: public NativeInstruction {
443 public:
444   enum AArch64_specific_constants {
445     instruction_length = 4 * NativeInstruction::instruction_size,
446     offset_offset = 0,
447   };
448 
449   address instruction_address() const { return addr_at(0); }
450   address return_address() const { return addr_at(instruction_length); }
451   address got_address() const;
452   address next_instruction_address() const { return return_address(); }
453   intptr_t data() const;
454   void set_data(intptr_t data) {
455     intptr_t *addr = (intptr_t *) got_address();
456     *addr = data;
</pre>
<hr />
<pre>
471 
472 class NativeJump: public NativeInstruction {
473  public:
474   enum AArch64_specific_constants {
475     instruction_size            =    4,
476     instruction_offset          =    0,
477     data_offset                 =    0,
478     next_instruction_offset     =    4
479   };
480 
481   address instruction_address() const       { return addr_at(instruction_offset); }
482   address next_instruction_address() const  { return addr_at(instruction_size); }
483   address jump_destination() const;
484   void set_jump_destination(address dest);
485 
486   // Creation
487   inline friend NativeJump* nativeJump_at(address address);
488 
489   void verify();
490 
<span class="line-removed">491   // Unit testing stuff</span>
<span class="line-removed">492   static void test() {}</span>
<span class="line-removed">493 </span>
494   // Insertion of native jump instruction
495   static void insert(address code_pos, address entry);
496   // MT-safe insertion of native jump at verified method entry
497   static void check_verified_entry_alignment(address entry, address verified_entry);
498   static void patch_verified_entry(address entry, address verified_entry, address dest);
499 };
500 
501 inline NativeJump* nativeJump_at(address address) {
502   NativeJump* jump = (NativeJump*)(address - NativeJump::instruction_offset);
503 #ifdef ASSERT
504   jump-&gt;verify();
505 #endif
506   return jump;
507 }
508 
509 class NativeGeneralJump: public NativeJump {
510 public:
511   enum AArch64_specific_constants {
512     instruction_size            =    4 * 4,
513     instruction_offset          =    0,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2014, 2108, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
</pre>
<hr />
<pre>
 85   u_char ubyte_at(int offset) const    { return *(u_char*) addr_at(offset); }
 86 
 87   jint int_at(int offset) const        { return *(jint*) addr_at(offset); }
 88   juint uint_at(int offset) const      { return *(juint*) addr_at(offset); }
 89 
 90   address ptr_at(int offset) const     { return *(address*) addr_at(offset); }
 91 
 92   oop  oop_at (int offset) const       { return *(oop*) addr_at(offset); }
 93 
 94 
 95   void set_char_at(int offset, char c)        { *addr_at(offset) = (u_char)c; }
 96   void set_int_at(int offset, jint  i)        { *(jint*)addr_at(offset) = i; }
 97   void set_uint_at(int offset, jint  i)       { *(juint*)addr_at(offset) = i; }
 98   void set_ptr_at (int offset, address  ptr)  { *(address*) addr_at(offset) = ptr; }
 99   void set_oop_at (int offset, oop  o)        { *(oop*) addr_at(offset) = o; }
100 
101   void wrote(int offset);
102 
103  public:
104 



105   inline friend NativeInstruction* nativeInstruction_at(address address);
106 
107   static bool is_adrp_at(address instr);
108 
109   static bool is_ldr_literal_at(address instr);
110 
111   bool is_ldr_literal() {
112     return is_ldr_literal_at(addr_at(0));
113   }
114 
115   static bool is_ldrw_to_zr(address instr);
116 
117   static bool is_call_at(address instr) {
118     const uint32_t insn = (*(uint32_t*)instr);
119     return (insn &gt;&gt; 26) == 0b100101;
120   }
121 
122   bool is_call() {
123     return is_call_at(addr_at(0));
124   }
</pre>
<hr />
<pre>
301     else if (is_adrp_at(instruction_address()))
302       return addr_at(2*4);
303     else if (is_ldr_literal_at(instruction_address()))
304       return(addr_at(4));
305     assert(false, &quot;Unknown instruction in NativeMovConstReg&quot;);
306     return NULL;
307   }
308 
309   intptr_t data() const;
310   void  set_data(intptr_t x);
311 
312   void flush() {
313     if (! maybe_cpool_ref(instruction_address())) {
314       ICache::invalidate_range(instruction_address(), instruction_size);
315     }
316   }
317 
318   void  verify();
319   void  print();
320 



321   // Creation
322   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
323   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
324 };
325 
326 inline NativeMovConstReg* nativeMovConstReg_at(address address) {
327   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_offset);
328 #ifdef ASSERT
329   test-&gt;verify();
330 #endif
331   return test;
332 }
333 
334 inline NativeMovConstReg* nativeMovConstReg_before(address address) {
335   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);
336 #ifdef ASSERT
337   test-&gt;verify();
338 #endif
339   return test;
340 }
</pre>
<hr />
<pre>
374     next_instruction_offset     =    4
375   };
376 
377  public:
378   // helper
379   int instruction_start() const { return instruction_offset; }
380 
381   address instruction_address() const { return addr_at(instruction_offset); }
382 
383   int num_bytes_to_end_of_patch() const { return instruction_offset + instruction_size; }
384 
385   int   offset() const;
386 
387   void  set_offset(int x);
388 
389   void  add_offset_in_bytes(int add_offset)     { set_offset ( ( offset() + add_offset ) ); }
390 
391   void verify();
392   void print ();
393 



394  private:
395   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
396 };
397 
398 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
399   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
400 #ifdef ASSERT
401   test-&gt;verify();
402 #endif
403   return test;
404 }
405 
406 class NativeMovRegMemPatching: public NativeMovRegMem {
407  private:
408   friend NativeMovRegMemPatching* nativeMovRegMemPatching_at (address address) {Unimplemented(); return 0;  }
409 };
410 
411 // An interface for accessing/manipulating native leal instruction of form:
412 //        leal reg, [reg + offset]
413 
414 class NativeLoadAddress: public NativeInstruction {
415   enum AArch64_specific_constants {
416     instruction_size            =    4,
417     instruction_offset          =    0,
418     data_offset                 =    0,
419     next_instruction_offset     =    4
420   };
421 
422  public:
423   void verify();
424   void print ();
425 


426 };
427 
428 //   adrp    x16, #page
429 //   add     x16, x16, #offset
430 //   ldr     x16, [x16]
431 class NativeLoadGot: public NativeInstruction {
432 public:
433   enum AArch64_specific_constants {
434     instruction_length = 4 * NativeInstruction::instruction_size,
435     offset_offset = 0,
436   };
437 
438   address instruction_address() const { return addr_at(0); }
439   address return_address() const { return addr_at(instruction_length); }
440   address got_address() const;
441   address next_instruction_address() const { return return_address(); }
442   intptr_t data() const;
443   void set_data(intptr_t data) {
444     intptr_t *addr = (intptr_t *) got_address();
445     *addr = data;
</pre>
<hr />
<pre>
460 
461 class NativeJump: public NativeInstruction {
462  public:
463   enum AArch64_specific_constants {
464     instruction_size            =    4,
465     instruction_offset          =    0,
466     data_offset                 =    0,
467     next_instruction_offset     =    4
468   };
469 
470   address instruction_address() const       { return addr_at(instruction_offset); }
471   address next_instruction_address() const  { return addr_at(instruction_size); }
472   address jump_destination() const;
473   void set_jump_destination(address dest);
474 
475   // Creation
476   inline friend NativeJump* nativeJump_at(address address);
477 
478   void verify();
479 



480   // Insertion of native jump instruction
481   static void insert(address code_pos, address entry);
482   // MT-safe insertion of native jump at verified method entry
483   static void check_verified_entry_alignment(address entry, address verified_entry);
484   static void patch_verified_entry(address entry, address verified_entry, address dest);
485 };
486 
487 inline NativeJump* nativeJump_at(address address) {
488   NativeJump* jump = (NativeJump*)(address - NativeJump::instruction_offset);
489 #ifdef ASSERT
490   jump-&gt;verify();
491 #endif
492   return jump;
493 }
494 
495 class NativeGeneralJump: public NativeJump {
496 public:
497   enum AArch64_specific_constants {
498     instruction_size            =    4 * 4,
499     instruction_offset          =    0,
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCodeInstaller_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../arm/nativeInst_arm_32.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
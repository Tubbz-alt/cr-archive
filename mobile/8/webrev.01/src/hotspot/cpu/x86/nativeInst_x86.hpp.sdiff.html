<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/nativeInst_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/packageEntry.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/nativeInst_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 77   u_char ubyte_at(int offset) const    { return *(u_char*) addr_at(offset); }
 78 
 79   jint int_at(int offset) const         { return *(jint*) addr_at(offset); }
 80 
 81   intptr_t ptr_at(int offset) const    { return *(intptr_t*) addr_at(offset); }
 82 
 83   oop  oop_at (int offset) const       { return *(oop*) addr_at(offset); }
 84 
 85 
 86   void set_char_at(int offset, char c)        { *addr_at(offset) = (u_char)c; wrote(offset); }
 87   void set_int_at(int offset, jint  i)        { *(jint*)addr_at(offset) = i;  wrote(offset); }
 88   void set_ptr_at (int offset, intptr_t  ptr) { *(intptr_t*) addr_at(offset) = ptr;  wrote(offset); }
 89   void set_oop_at (int offset, oop  o)        { *(oop*) addr_at(offset) = o;  wrote(offset); }
 90 
 91   // This doesn&#39;t really do anything on Intel, but it is the place where
 92   // cache invalidation belongs, generically:
 93   void wrote(int offset);
 94 
 95  public:
 96 
<span class="line-removed"> 97   // unit test stuff</span>
<span class="line-removed"> 98   static void test() {}                 // override for testing</span>
<span class="line-removed"> 99 </span>
100   inline friend NativeInstruction* nativeInstruction_at(address address);
101 };
102 
103 inline NativeInstruction* nativeInstruction_at(address address) {
104   NativeInstruction* inst = (NativeInstruction*)address;
105 #ifdef ASSERT
106   //inst-&gt;verify();
107 #endif
108   return inst;
109 }
110 
111 class NativePltCall: public NativeInstruction {
112 public:
113   enum Intel_specific_constants {
114     instruction_code           = 0xE8,
115     instruction_size           =    5,
116     instruction_offset         =    0,
117     displacement_offset        =    1,
118     return_address_offset      =    5
119   };
</pre>
<hr />
<pre>
260   static const int rex_size = 0;
261 #endif // AMD64
262  public:
263   enum Intel_specific_constants {
264     instruction_code            = 0xB8,
265     instruction_size            =    1 + rex_size + wordSize,
266     instruction_offset          =    0,
267     data_offset                 =    1 + rex_size,
268     next_instruction_offset     =    instruction_size,
269     register_mask               = 0x07
270   };
271 
272   address instruction_address() const       { return addr_at(instruction_offset); }
273   address next_instruction_address() const  { return addr_at(next_instruction_offset); }
274   intptr_t data() const                     { return ptr_at(data_offset); }
275   void  set_data(intptr_t x)                { set_ptr_at(data_offset, x); }
276 
277   void  verify();
278   void  print();
279 
<span class="line-removed">280   // unit test stuff</span>
<span class="line-removed">281   static void test() {}</span>
<span class="line-removed">282 </span>
283   // Creation
284   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
285   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
286 };
287 
288 inline NativeMovConstReg* nativeMovConstReg_at(address address) {
289   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_offset);
290 #ifdef ASSERT
291   test-&gt;verify();
292 #endif
293   return test;
294 }
295 
296 inline NativeMovConstReg* nativeMovConstReg_before(address address) {
297   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);
298 #ifdef ASSERT
299   test-&gt;verify();
300 #endif
301   return test;
302 }
</pre>
<hr />
<pre>
376   int num_bytes_to_end_of_patch() const {
377     return patch_offset() + sizeof(jint);
378   }
379 
380   int offset() const {
381     return int_at(patch_offset());
382   }
383 
384   void set_offset(int x) {
385     set_int_at(patch_offset(), x);
386   }
387 
388   void add_offset_in_bytes(int add_offset) {
389     int patch_off = patch_offset();
390     set_int_at(patch_off, int_at(patch_off) + add_offset);
391   }
392 
393   void verify();
394   void print ();
395 
<span class="line-removed">396   // unit test stuff</span>
<span class="line-removed">397   static void test() {}</span>
<span class="line-removed">398 </span>
399  private:
400   int patch_offset() const;
401   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
402 };
403 
404 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
405   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
406 #ifdef ASSERT
407   test-&gt;verify();
408 #endif
409   return test;
410 }
411 
412 
413 // An interface for accessing/manipulating native leal instruction of form:
414 //        leal reg, [reg + offset]
415 
416 class NativeLoadAddress: public NativeMovRegMem {
417 #ifdef AMD64
418   static const bool has_rex = true;
419   static const int rex_size = 1;
420 #else
421   static const bool has_rex = false;
422   static const int rex_size = 0;
423 #endif // AMD64
424  public:
425   enum Intel_specific_constants {
426     instruction_prefix_wide             = Assembler::REX_W,
427     instruction_prefix_wide_extended    = Assembler::REX_WB,
428     lea_instruction_code                = 0x8D,
429     mov64_instruction_code              = 0xB8
430   };
431 
432   void verify();
433   void print ();
434 
<span class="line-removed">435   // unit test stuff</span>
<span class="line-removed">436   static void test() {}</span>
<span class="line-removed">437 </span>
438  private:
439   friend NativeLoadAddress* nativeLoadAddress_at (address address) {
440     NativeLoadAddress* test = (NativeLoadAddress*)(address - instruction_offset);
441     #ifdef ASSERT
442       test-&gt;verify();
443     #endif
444     return test;
445   }
446 };
447 
448 // destination is rbx or rax
449 // mov rbx, [rip + offset]
450 class NativeLoadGot: public NativeInstruction {
451 #ifdef AMD64
452   static const bool has_rex = true;
453   static const int rex_size = 1;
454 #else
455   static const bool has_rex = false;
456   static const int rex_size = 0;
457 #endif
</pre>
<hr />
<pre>
519     dest = (dest == (address) this) ? (address) -1 : dest;
520     return dest;
521   }
522 
523   void  set_jump_destination(address dest)  {
524     intptr_t val = dest - next_instruction_address();
525     if (dest == (address) -1) {
526       val = -5; // jump to self
527     }
528 #ifdef AMD64
529     assert((labs(val)  &amp; 0xFFFFFFFF00000000) == 0 || dest == (address)-1, &quot;must be 32bit offset or -1&quot;);
530 #endif // AMD64
531     set_int_at(data_offset, (jint)val);
532   }
533 
534   // Creation
535   inline friend NativeJump* nativeJump_at(address address);
536 
537   void verify();
538 
<span class="line-removed">539   // Unit testing stuff</span>
<span class="line-removed">540   static void test() {}</span>
<span class="line-removed">541 </span>
542   // Insertion of native jump instruction
543   static void insert(address code_pos, address entry);
544   // MT-safe insertion of native jump at verified method entry
545   static void check_verified_entry_alignment(address entry, address verified_entry);
546   static void patch_verified_entry(address entry, address verified_entry, address dest);
547 };
548 
549 inline NativeJump* nativeJump_at(address address) {
550   NativeJump* jump = (NativeJump*)(address - NativeJump::instruction_offset);
551 #ifdef ASSERT
552   jump-&gt;verify();
553 #endif
554   return jump;
555 }
556 
557 // far jump reg
558 class NativeFarJump: public NativeInstruction {
559  public:
560   address jump_destination() const;
561 
562   // Creation
563   inline friend NativeFarJump* nativeFarJump_at(address address);
564 
565   void verify();
566 
<span class="line-removed">567   // Unit testing stuff</span>
<span class="line-removed">568   static void test() {}</span>
<span class="line-removed">569 </span>
570 };
571 
572 inline NativeFarJump* nativeFarJump_at(address address) {
573   NativeFarJump* jump = (NativeFarJump*)(address);
574 #ifdef ASSERT
575   jump-&gt;verify();
576 #endif
577   return jump;
578 }
579 
580 // Handles all kinds of jump on Intel. Long/far, conditional/unconditional
581 class NativeGeneralJump: public NativeInstruction {
582  public:
583   enum Intel_specific_constants {
584     // Constants does not apply, since the lengths and offsets depends on the actual jump
585     // used
586     // Instruction codes:
587     //   Unconditional jumps: 0xE9    (rel32off), 0xEB (rel8off)
588     //   Conditional jumps:   0x0F8x  (rel32off), 0x7x (rel8off)
589     unconditional_long_jump  = 0xe9,
</pre>
</td>
<td>
<hr />
<pre>
 77   u_char ubyte_at(int offset) const    { return *(u_char*) addr_at(offset); }
 78 
 79   jint int_at(int offset) const         { return *(jint*) addr_at(offset); }
 80 
 81   intptr_t ptr_at(int offset) const    { return *(intptr_t*) addr_at(offset); }
 82 
 83   oop  oop_at (int offset) const       { return *(oop*) addr_at(offset); }
 84 
 85 
 86   void set_char_at(int offset, char c)        { *addr_at(offset) = (u_char)c; wrote(offset); }
 87   void set_int_at(int offset, jint  i)        { *(jint*)addr_at(offset) = i;  wrote(offset); }
 88   void set_ptr_at (int offset, intptr_t  ptr) { *(intptr_t*) addr_at(offset) = ptr;  wrote(offset); }
 89   void set_oop_at (int offset, oop  o)        { *(oop*) addr_at(offset) = o;  wrote(offset); }
 90 
 91   // This doesn&#39;t really do anything on Intel, but it is the place where
 92   // cache invalidation belongs, generically:
 93   void wrote(int offset);
 94 
 95  public:
 96 



 97   inline friend NativeInstruction* nativeInstruction_at(address address);
 98 };
 99 
100 inline NativeInstruction* nativeInstruction_at(address address) {
101   NativeInstruction* inst = (NativeInstruction*)address;
102 #ifdef ASSERT
103   //inst-&gt;verify();
104 #endif
105   return inst;
106 }
107 
108 class NativePltCall: public NativeInstruction {
109 public:
110   enum Intel_specific_constants {
111     instruction_code           = 0xE8,
112     instruction_size           =    5,
113     instruction_offset         =    0,
114     displacement_offset        =    1,
115     return_address_offset      =    5
116   };
</pre>
<hr />
<pre>
257   static const int rex_size = 0;
258 #endif // AMD64
259  public:
260   enum Intel_specific_constants {
261     instruction_code            = 0xB8,
262     instruction_size            =    1 + rex_size + wordSize,
263     instruction_offset          =    0,
264     data_offset                 =    1 + rex_size,
265     next_instruction_offset     =    instruction_size,
266     register_mask               = 0x07
267   };
268 
269   address instruction_address() const       { return addr_at(instruction_offset); }
270   address next_instruction_address() const  { return addr_at(next_instruction_offset); }
271   intptr_t data() const                     { return ptr_at(data_offset); }
272   void  set_data(intptr_t x)                { set_ptr_at(data_offset, x); }
273 
274   void  verify();
275   void  print();
276 



277   // Creation
278   inline friend NativeMovConstReg* nativeMovConstReg_at(address address);
279   inline friend NativeMovConstReg* nativeMovConstReg_before(address address);
280 };
281 
282 inline NativeMovConstReg* nativeMovConstReg_at(address address) {
283   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_offset);
284 #ifdef ASSERT
285   test-&gt;verify();
286 #endif
287   return test;
288 }
289 
290 inline NativeMovConstReg* nativeMovConstReg_before(address address) {
291   NativeMovConstReg* test = (NativeMovConstReg*)(address - NativeMovConstReg::instruction_size - NativeMovConstReg::instruction_offset);
292 #ifdef ASSERT
293   test-&gt;verify();
294 #endif
295   return test;
296 }
</pre>
<hr />
<pre>
370   int num_bytes_to_end_of_patch() const {
371     return patch_offset() + sizeof(jint);
372   }
373 
374   int offset() const {
375     return int_at(patch_offset());
376   }
377 
378   void set_offset(int x) {
379     set_int_at(patch_offset(), x);
380   }
381 
382   void add_offset_in_bytes(int add_offset) {
383     int patch_off = patch_offset();
384     set_int_at(patch_off, int_at(patch_off) + add_offset);
385   }
386 
387   void verify();
388   void print ();
389 



390  private:
391   int patch_offset() const;
392   inline friend NativeMovRegMem* nativeMovRegMem_at (address address);
393 };
394 
395 inline NativeMovRegMem* nativeMovRegMem_at (address address) {
396   NativeMovRegMem* test = (NativeMovRegMem*)(address - NativeMovRegMem::instruction_offset);
397 #ifdef ASSERT
398   test-&gt;verify();
399 #endif
400   return test;
401 }
402 
403 
404 // An interface for accessing/manipulating native leal instruction of form:
405 //        leal reg, [reg + offset]
406 
407 class NativeLoadAddress: public NativeMovRegMem {
408 #ifdef AMD64
409   static const bool has_rex = true;
410   static const int rex_size = 1;
411 #else
412   static const bool has_rex = false;
413   static const int rex_size = 0;
414 #endif // AMD64
415  public:
416   enum Intel_specific_constants {
417     instruction_prefix_wide             = Assembler::REX_W,
418     instruction_prefix_wide_extended    = Assembler::REX_WB,
419     lea_instruction_code                = 0x8D,
420     mov64_instruction_code              = 0xB8
421   };
422 
423   void verify();
424   void print ();
425 



426  private:
427   friend NativeLoadAddress* nativeLoadAddress_at (address address) {
428     NativeLoadAddress* test = (NativeLoadAddress*)(address - instruction_offset);
429     #ifdef ASSERT
430       test-&gt;verify();
431     #endif
432     return test;
433   }
434 };
435 
436 // destination is rbx or rax
437 // mov rbx, [rip + offset]
438 class NativeLoadGot: public NativeInstruction {
439 #ifdef AMD64
440   static const bool has_rex = true;
441   static const int rex_size = 1;
442 #else
443   static const bool has_rex = false;
444   static const int rex_size = 0;
445 #endif
</pre>
<hr />
<pre>
507     dest = (dest == (address) this) ? (address) -1 : dest;
508     return dest;
509   }
510 
511   void  set_jump_destination(address dest)  {
512     intptr_t val = dest - next_instruction_address();
513     if (dest == (address) -1) {
514       val = -5; // jump to self
515     }
516 #ifdef AMD64
517     assert((labs(val)  &amp; 0xFFFFFFFF00000000) == 0 || dest == (address)-1, &quot;must be 32bit offset or -1&quot;);
518 #endif // AMD64
519     set_int_at(data_offset, (jint)val);
520   }
521 
522   // Creation
523   inline friend NativeJump* nativeJump_at(address address);
524 
525   void verify();
526 



527   // Insertion of native jump instruction
528   static void insert(address code_pos, address entry);
529   // MT-safe insertion of native jump at verified method entry
530   static void check_verified_entry_alignment(address entry, address verified_entry);
531   static void patch_verified_entry(address entry, address verified_entry, address dest);
532 };
533 
534 inline NativeJump* nativeJump_at(address address) {
535   NativeJump* jump = (NativeJump*)(address - NativeJump::instruction_offset);
536 #ifdef ASSERT
537   jump-&gt;verify();
538 #endif
539   return jump;
540 }
541 
542 // far jump reg
543 class NativeFarJump: public NativeInstruction {
544  public:
545   address jump_destination() const;
546 
547   // Creation
548   inline friend NativeFarJump* nativeFarJump_at(address address);
549 
550   void verify();
551 



552 };
553 
554 inline NativeFarJump* nativeFarJump_at(address address) {
555   NativeFarJump* jump = (NativeFarJump*)(address);
556 #ifdef ASSERT
557   jump-&gt;verify();
558 #endif
559   return jump;
560 }
561 
562 // Handles all kinds of jump on Intel. Long/far, conditional/unconditional
563 class NativeGeneralJump: public NativeInstruction {
564  public:
565   enum Intel_specific_constants {
566     // Constants does not apply, since the lengths and offsets depends on the actual jump
567     // used
568     // Instruction codes:
569     //   Unconditional jumps: 0xE9    (rel32off), 0xEB (rel8off)
570     //   Conditional jumps:   0x0F8x  (rel32off), 0x7x (rel8off)
571     unconditional_long_jump  = 0xe9,
</pre>
</td>
</tr>
</table>
<center><a href="jvmciCodeInstaller_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/classfile/packageEntry.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
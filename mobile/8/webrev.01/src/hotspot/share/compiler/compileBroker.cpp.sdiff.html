<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/compileBroker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/g1Analytics.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1184         vframeStream vfst((JavaThread*) thread);
1185         for (; !vfst.at_end(); vfst.next()) {
1186           if (vfst.method()-&gt;is_static_initializer() ||
1187               (vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) &amp;&amp;
1188                   vfst.method()-&gt;name() == vmSymbols::loadClass_name())) {
1189             blocking = false;
1190             break;
1191           }
1192         }
1193       }
1194 
1195       // Don&#39;t allow blocking compilation requests to JVMCI
1196       // if JVMCI itself is not yet initialized
1197       if (!JVMCI::is_compiler_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {
1198         blocking = false;
1199       }
1200 
1201       // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown
1202       // to avoid deadlock between compiler thread(s) and threads run at shutdown
1203       // such as the DestroyJavaVM thread.
<span class="line-modified">1204       if (JVMCI::shutdown_called()) {</span>
1205         blocking = false;
1206       }
1207     }
1208 #endif // INCLUDE_JVMCI
1209 
1210     // We will enter the compilation in the queue.
1211     // 14012000: Note that this sets the queued_for_compile bits in
1212     // the target method. We can now reason that a method cannot be
1213     // queued for compilation more than once, as follows:
1214     // Before a thread queues a task for compilation, it first acquires
1215     // the compile queue lock, then checks if the method&#39;s queued bits
1216     // are set or it has already been compiled. Thus there can not be two
1217     // instances of a compilation task for the same method on the
1218     // compilation queue. Consider now the case where the compilation
1219     // thread has already removed a task for that method from the queue
1220     // and is in the midst of compiling it. In this case, the
1221     // queued_for_compile bits must be set in the method (and these
1222     // will be visible to the current thread, since the bits were set
1223     // under protection of the compile queue lock, which we hold now.
1224     // When the compilation completes, the compiler thread first sets
</pre>
<hr />
<pre>
2133   should_break = directive-&gt;BreakAtExecuteOption || task-&gt;check_break_at_flags();
2134   if (should_log &amp;&amp; !directive-&gt;LogOption) {
2135     should_log = false;
2136   }
2137 
2138   // Allocate a new set of JNI handles.
2139   push_jni_handle_block();
2140   Method* target_handle = task-&gt;method();
2141   int compilable = ciEnv::MethodCompilable;
2142   const char* failure_reason = NULL;
2143   bool failure_reason_on_C_heap = false;
2144   const char* retry_message = NULL;
2145 
2146 #if INCLUDE_JVMCI
2147   if (UseJVMCICompiler &amp;&amp; comp != NULL &amp;&amp; comp-&gt;is_jvmci()) {
2148     JVMCICompiler* jvmci = (JVMCICompiler*) comp;
2149 
2150     TraceTime t1(&quot;compilation&quot;, &amp;time);
2151     EventCompilation event;
2152     JVMCICompileState compile_state(task);

2153 
<span class="line-modified">2154     // Skip redefined methods</span>
<span class="line-modified">2155     if (compile_state.target_method_is_old()) {</span>




2156       failure_reason = &quot;redefined method&quot;;
2157       retry_message = &quot;not retryable&quot;;
2158       compilable = ciEnv::MethodCompilable_never;
2159     } else {
2160       JVMCIEnv env(thread, &amp;compile_state, __FILE__, __LINE__);
2161       methodHandle method(thread, target_handle);
<span class="line-modified">2162       env.runtime()-&gt;compile_method(&amp;env, jvmci, method, osr_bci);</span>

2163 
2164       failure_reason = compile_state.failure_reason();
2165       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();
2166       if (!compile_state.retryable()) {
2167         retry_message = &quot;not retryable&quot;;
2168         compilable = ciEnv::MethodCompilable_not_at_tier;
2169       }
2170       if (task-&gt;code() == NULL) {
2171         assert(failure_reason != NULL, &quot;must specify failure_reason&quot;);
2172       }
2173     }
2174     post_compile(thread, task, task-&gt;code() != NULL, NULL, compilable, failure_reason);
2175     if (event.should_commit()) {
2176       post_compilation_event(event, task);
2177     }
2178 
2179   } else
2180 #endif // INCLUDE_JVMCI
2181   {
2182     NoHandleMark  nhm;
</pre>
</td>
<td>
<hr />
<pre>
1184         vframeStream vfst((JavaThread*) thread);
1185         for (; !vfst.at_end(); vfst.next()) {
1186           if (vfst.method()-&gt;is_static_initializer() ||
1187               (vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) &amp;&amp;
1188                   vfst.method()-&gt;name() == vmSymbols::loadClass_name())) {
1189             blocking = false;
1190             break;
1191           }
1192         }
1193       }
1194 
1195       // Don&#39;t allow blocking compilation requests to JVMCI
1196       // if JVMCI itself is not yet initialized
1197       if (!JVMCI::is_compiler_initialized() &amp;&amp; compiler(comp_level)-&gt;is_jvmci()) {
1198         blocking = false;
1199       }
1200 
1201       // Don&#39;t allow blocking compilation requests if we are in JVMCIRuntime::shutdown
1202       // to avoid deadlock between compiler thread(s) and threads run at shutdown
1203       // such as the DestroyJavaVM thread.
<span class="line-modified">1204       if (JVMCI::in_shutdown()) {</span>
1205         blocking = false;
1206       }
1207     }
1208 #endif // INCLUDE_JVMCI
1209 
1210     // We will enter the compilation in the queue.
1211     // 14012000: Note that this sets the queued_for_compile bits in
1212     // the target method. We can now reason that a method cannot be
1213     // queued for compilation more than once, as follows:
1214     // Before a thread queues a task for compilation, it first acquires
1215     // the compile queue lock, then checks if the method&#39;s queued bits
1216     // are set or it has already been compiled. Thus there can not be two
1217     // instances of a compilation task for the same method on the
1218     // compilation queue. Consider now the case where the compilation
1219     // thread has already removed a task for that method from the queue
1220     // and is in the midst of compiling it. In this case, the
1221     // queued_for_compile bits must be set in the method (and these
1222     // will be visible to the current thread, since the bits were set
1223     // under protection of the compile queue lock, which we hold now.
1224     // When the compilation completes, the compiler thread first sets
</pre>
<hr />
<pre>
2133   should_break = directive-&gt;BreakAtExecuteOption || task-&gt;check_break_at_flags();
2134   if (should_log &amp;&amp; !directive-&gt;LogOption) {
2135     should_log = false;
2136   }
2137 
2138   // Allocate a new set of JNI handles.
2139   push_jni_handle_block();
2140   Method* target_handle = task-&gt;method();
2141   int compilable = ciEnv::MethodCompilable;
2142   const char* failure_reason = NULL;
2143   bool failure_reason_on_C_heap = false;
2144   const char* retry_message = NULL;
2145 
2146 #if INCLUDE_JVMCI
2147   if (UseJVMCICompiler &amp;&amp; comp != NULL &amp;&amp; comp-&gt;is_jvmci()) {
2148     JVMCICompiler* jvmci = (JVMCICompiler*) comp;
2149 
2150     TraceTime t1(&quot;compilation&quot;, &amp;time);
2151     EventCompilation event;
2152     JVMCICompileState compile_state(task);
<span class="line-added">2153     JVMCIRuntime *runtime = NULL;</span>
2154 
<span class="line-modified">2155     if (JVMCI::in_shutdown()) {</span>
<span class="line-modified">2156       failure_reason = &quot;in JVMCI shutdown&quot;;</span>
<span class="line-added">2157       retry_message = &quot;not retryable&quot;;</span>
<span class="line-added">2158       compilable = ciEnv::MethodCompilable_never;</span>
<span class="line-added">2159     } else if (compile_state.target_method_is_old()) {</span>
<span class="line-added">2160       // Skip redefined methods</span>
2161       failure_reason = &quot;redefined method&quot;;
2162       retry_message = &quot;not retryable&quot;;
2163       compilable = ciEnv::MethodCompilable_never;
2164     } else {
2165       JVMCIEnv env(thread, &amp;compile_state, __FILE__, __LINE__);
2166       methodHandle method(thread, target_handle);
<span class="line-modified">2167       runtime = env.runtime();</span>
<span class="line-added">2168       runtime-&gt;compile_method(&amp;env, jvmci, method, osr_bci);</span>
2169 
2170       failure_reason = compile_state.failure_reason();
2171       failure_reason_on_C_heap = compile_state.failure_reason_on_C_heap();
2172       if (!compile_state.retryable()) {
2173         retry_message = &quot;not retryable&quot;;
2174         compilable = ciEnv::MethodCompilable_not_at_tier;
2175       }
2176       if (task-&gt;code() == NULL) {
2177         assert(failure_reason != NULL, &quot;must specify failure_reason&quot;);
2178       }
2179     }
2180     post_compile(thread, task, task-&gt;code() != NULL, NULL, compilable, failure_reason);
2181     if (event.should_commit()) {
2182       post_compilation_event(event, task);
2183     }
2184 
2185   } else
2186 #endif // INCLUDE_JVMCI
2187   {
2188     NoHandleMark  nhm;
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionaryShared.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/g1Analytics.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
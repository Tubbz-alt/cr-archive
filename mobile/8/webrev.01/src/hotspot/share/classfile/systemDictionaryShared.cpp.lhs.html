<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  40 #include &quot;jfr/jfrEvents.hpp&quot;
  41 #include &quot;logging/log.hpp&quot;
  42 #include &quot;memory/allocation.hpp&quot;
  43 #include &quot;memory/archiveUtils.hpp&quot;
  44 #include &quot;memory/dynamicArchive.hpp&quot;
  45 #include &quot;memory/filemap.hpp&quot;
  46 #include &quot;memory/heapShared.hpp&quot;
  47 #include &quot;memory/metadataFactory.hpp&quot;
  48 #include &quot;memory/metaspaceClosure.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/klass.inline.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/oop.inline.hpp&quot;
  56 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/java.hpp&quot;
  59 #include &quot;runtime/javaCalls.hpp&quot;
  60 #include &quot;runtime/mutexLocker.hpp&quot;
  61 #include &quot;utilities/hashtable.inline.hpp&quot;
  62 #include &quot;utilities/resourceHash.hpp&quot;
  63 #include &quot;utilities/stringUtils.hpp&quot;
  64 
  65 
  66 OopHandle SystemDictionaryShared::_shared_protection_domains;
  67 OopHandle SystemDictionaryShared::_shared_jar_urls;
  68 OopHandle SystemDictionaryShared::_shared_jar_manifests;
  69 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  70 
  71 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  72   bool                         _excluded;
  73 public:
  74   struct DTLoaderConstraint {
  75     Symbol* _name;
  76     char _loader_type1;
  77     char _loader_type2;
  78     DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {
  79       _name-&gt;increment_refcount();
  80     }
  81     DTLoaderConstraint() : _name(NULL), _loader_type1(&#39;0&#39;), _loader_type2(&#39;0&#39;) {}
  82     bool equals(const DTLoaderConstraint&amp; t) {
  83       return t._name == _name &amp;&amp;
  84              ((t._loader_type1 == _loader_type1 &amp;&amp; t._loader_type2 == _loader_type2) ||
  85               (t._loader_type2 == _loader_type1 &amp;&amp; t._loader_type1 == _loader_type2));
  86     }
  87   };
  88 
  89   struct DTVerifierConstraint {
  90     Symbol* _name;
  91     Symbol* _from_name;
  92     DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}
  93     DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {
  94       _name-&gt;increment_refcount();
  95       _from_name-&gt;increment_refcount();
  96     }
  97   };
  98 
  99   InstanceKlass*               _klass;
 100   bool                         _failed_verification;
 101   bool                         _is_archived_lambda_proxy;
 102   int                          _id;
 103   int                          _clsfile_size;
 104   int                          _clsfile_crc32;
 105   GrowableArray&lt;DTVerifierConstraint&gt;* _verifier_constraints;
 106   GrowableArray&lt;char&gt;*                 _verifier_constraint_flags;
 107   GrowableArray&lt;DTLoaderConstraint&gt;* _loader_constraints;
 108 
 109   DumpTimeSharedClassInfo() {
 110     _klass = NULL;
 111     _failed_verification = false;
 112     _is_archived_lambda_proxy = false;
 113     _id = -1;
 114     _clsfile_size = -1;
 115     _clsfile_crc32 = -1;
 116     _excluded = false;
 117     _verifier_constraints = NULL;
 118     _verifier_constraint_flags = NULL;
 119     _loader_constraints = NULL;
 120   }
 121 
 122   void add_verification_constraint(InstanceKlass* k, Symbol* name,
 123          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
 124   void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);
 125 
 126   bool is_builtin() {
 127     return SystemDictionaryShared::is_builtin(_klass);
 128   }
 129 
 130   int num_verifier_constraints() {
 131     if (_verifier_constraint_flags != NULL) {
 132       return _verifier_constraint_flags-&gt;length();
 133     } else {
 134       return 0;
 135     }
 136   }
 137 
 138   int num_loader_constraints() {
 139     if (_loader_constraints != NULL) {
 140       return _loader_constraints-&gt;length();
 141     } else {
 142       return 0;
 143     }
 144   }
 145 
 146   void metaspace_pointers_do(MetaspaceClosure* it) {
 147     it-&gt;push(&amp;_klass);
 148     if (_verifier_constraints != NULL) {
 149       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 150         DTVerifierConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 151         it-&gt;push(&amp;cons-&gt;_name);
 152         it-&gt;push(&amp;cons-&gt;_from_name);
 153       }
 154     }
 155     if (_loader_constraints != NULL) {
 156       for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
 157         DTLoaderConstraint* lc = _loader_constraints-&gt;adr_at(i);
 158         it-&gt;push(&amp;lc-&gt;_name);
 159       }
 160     }
 161   }
 162 
 163   void set_excluded() {
 164     _excluded = true;
 165   }
 166 
 167   bool is_excluded() {
 168     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
 169     return _excluded || _failed_verification || _klass == NULL;
 170   }
 171 
 172   void set_failed_verification() {
 173     _failed_verification = true;
 174   }
 175 
 176   bool failed_verification() {
 177     return _failed_verification;
 178   }
 179 };
 180 
 181 inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const&amp; k) {
 182   if (DumpSharedSpaces) {
 183     // Deterministic archive contents
 184     uintx delta = k-&gt;name() - MetaspaceShared::symbol_rs_base();
 185     return primitive_hash&lt;uintx&gt;(delta);
 186   } else {
 187     // Deterministic archive is not possible because classes can be loaded
 188     // in multiple threads.
 189     return primitive_hash&lt;InstanceKlass*&gt;(k);
 190   }
 191 }
 192 
 193 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 194   InstanceKlass*,
 195   DumpTimeSharedClassInfo,
 196   &amp;DumpTimeSharedClassTable_hash,
 197   primitive_equals&lt;InstanceKlass*&gt;,
 198   15889, // prime number
 199   ResourceObj::C_HEAP&gt;
 200 {
 201   int _builtin_count;
 202   int _unregistered_count;
 203 public:
 204   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 205     bool created = false;
 206     DumpTimeSharedClassInfo* p = put_if_absent(k, &amp;created);
 207     if (created) {
 208       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 209              &quot;no new classes can be loaded while dumping archive&quot;);
 210       p-&gt;_klass = k;
 211     } else {
 212       assert(p-&gt;_klass == k, &quot;Sanity&quot;);
 213     }
 214     return p;
 215   }
 216 
 217   class CountClassByCategory : StackObj {
 218     DumpTimeSharedClassTable* _table;
 219   public:
 220     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 221     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 222       if (!info.is_excluded()) {
 223         if (info.is_builtin()) {
 224           ++ _table-&gt;_builtin_count;
 225         } else {
 226           ++ _table-&gt;_unregistered_count;
 227         }
 228       }
 229       return true; // keep on iterating
 230     }
 231   };
 232 
 233   void update_counts() {
 234     _builtin_count = 0;
 235     _unregistered_count = 0;
 236     CountClassByCategory counter(this);
 237     iterate(&amp;counter);
 238   }
 239 
 240   int count_of(bool is_builtin) const {
 241     if (is_builtin) {
 242       return _builtin_count;
 243     } else {
 244       return _unregistered_count;
 245     }
 246   }
 247 };
 248 
 249 class LambdaProxyClassKey {
 250   template &lt;typename T&gt; static void original_to_target(T&amp; field) {
 251     if (field != NULL) {
 252       field = DynamicArchive::original_to_target(field);
 253       ArchivePtrMarker::mark_pointer(&amp;field);
 254     }
 255   }
 256 
 257   InstanceKlass* _caller_ik;
 258   Symbol*        _invoked_name;
 259   Symbol*        _invoked_type;
 260   Symbol*        _method_type;
 261   Method*        _member_method;
 262   Symbol*        _instantiated_method_type;
 263 
 264 public:
 265   LambdaProxyClassKey(InstanceKlass* caller_ik,
 266                       Symbol*        invoked_name,
 267                       Symbol*        invoked_type,
 268                       Symbol*        method_type,
 269                       Method*        member_method,
 270                       Symbol*        instantiated_method_type) :
 271     _caller_ik(caller_ik),
 272     _invoked_name(invoked_name),
 273     _invoked_type(invoked_type),
 274     _method_type(method_type),
 275     _member_method(member_method),
 276     _instantiated_method_type(instantiated_method_type) {}
 277 
 278   void original_to_target() {
 279     original_to_target(_caller_ik);
 280     original_to_target(_instantiated_method_type);
 281     original_to_target(_invoked_name);
 282     original_to_target(_invoked_type);
 283     original_to_target(_member_method);
 284     original_to_target(_method_type);
 285   }
 286 
 287   bool equals(LambdaProxyClassKey const&amp; other) const {
 288     return _caller_ik == other._caller_ik &amp;&amp;
 289            _invoked_name == other._invoked_name &amp;&amp;
 290            _invoked_type == other._invoked_type &amp;&amp;
 291            _method_type == other._method_type &amp;&amp;
 292            _member_method == other._member_method &amp;&amp;
 293            _instantiated_method_type == other._instantiated_method_type;
 294   }
 295 
 296   unsigned int hash() const {
 297     return SystemDictionaryShared::hash_for_shared_dictionary(_caller_ik) +
 298            SystemDictionaryShared::hash_for_shared_dictionary(_invoked_name) +
 299            SystemDictionaryShared::hash_for_shared_dictionary(_invoked_type) +
 300            SystemDictionaryShared::hash_for_shared_dictionary(_method_type) +
 301            SystemDictionaryShared::hash_for_shared_dictionary(_instantiated_method_type);
 302   }
 303 
 304   unsigned int dumptime_hash() const {
 305     return primitive_hash&lt;InstanceKlass*&gt;(_caller_ik) +
 306            primitive_hash&lt;Symbol*&gt;(_invoked_name) +
 307            primitive_hash&lt;Symbol*&gt;(_invoked_type) +
 308            primitive_hash&lt;Symbol*&gt;(_method_type) +
 309            primitive_hash&lt;Symbol*&gt;(_instantiated_method_type);
 310   }
 311 
 312   static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const&amp; key) {
 313     return (key.dumptime_hash());
 314   }
 315 
 316   static inline bool DUMPTIME_EQUALS(
 317       LambdaProxyClassKey const&amp; k1, LambdaProxyClassKey const&amp; k2) {
 318     return (k1.equals(k2));
 319   }
 320 };
 321 
 322 
 323 class DumpTimeLambdaProxyClassInfo {
 324 public:
 325   GrowableArray&lt;InstanceKlass*&gt;* _proxy_klasses;
 326   DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}
 327   void add_proxy_klass(InstanceKlass* proxy_klass) {
 328     if (_proxy_klasses == NULL) {
 329       _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray&lt;InstanceKlass*&gt;(5, mtClassShared);
 330     }
 331     assert(_proxy_klasses != NULL, &quot;sanity&quot;);
 332     _proxy_klasses-&gt;append(proxy_klass);
 333   }
 334 };
 335 
 336 class RunTimeLambdaProxyClassInfo {
 337   LambdaProxyClassKey _key;
 338   InstanceKlass* _proxy_klass_head;
 339 public:
 340   RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass) :
 341     _key(key), _proxy_klass_head(proxy_klass) {}
 342 
 343   InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }
 344 
 345   // Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS
 346   static inline bool EQUALS(
 347        const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {
 348     return (value-&gt;_key.equals(*key));
 349   }
 350   void init(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
 351     _key = key;
 352     _key.original_to_target();
 353     _proxy_klass_head = DynamicArchive::original_to_target(info._proxy_klasses-&gt;at(0));
 354     ArchivePtrMarker::mark_pointer(&amp;_proxy_klass_head);
 355   }
 356 
 357   unsigned int hash() const {
 358     return _key.hash();
 359   }
 360 };
 361 
 362 class LambdaProxyClassDictionary : public OffsetCompactHashtable&lt;
 363   LambdaProxyClassKey*,
 364   const RunTimeLambdaProxyClassInfo*,
 365   RunTimeLambdaProxyClassInfo::EQUALS&gt; {};
 366 
 367 LambdaProxyClassDictionary _lambda_proxy_class_dictionary;
 368 
 369 class DumpTimeLambdaProxyClassDictionary
 370   : public ResourceHashtable&lt;LambdaProxyClassKey,
 371                              DumpTimeLambdaProxyClassInfo,
 372                              LambdaProxyClassKey::DUMPTIME_HASH,
 373                              LambdaProxyClassKey::DUMPTIME_EQUALS,
 374                              137, // prime number
 375                              ResourceObj::C_HEAP&gt; {
 376 public:
 377   int _count;
 378 };
 379 
 380 DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary = NULL;
 381 
 382 static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey key,
 383                                                            InstanceKlass* proxy_klass) {
 384   assert(DumpTimeTable_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 385   if (_dumptime_lambda_proxy_class_dictionary == NULL) {
 386     _dumptime_lambda_proxy_class_dictionary =
 387       new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();
 388   }
 389   DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary-&gt;get(key);
 390   if (lambda_info == NULL) {
 391     DumpTimeLambdaProxyClassInfo info;
 392     info.add_proxy_klass(proxy_klass);
 393     _dumptime_lambda_proxy_class_dictionary-&gt;put(key, info);
 394     //lambda_info = _dumptime_lambda_proxy_class_dictionary-&gt;get(key);
 395     //assert(lambda_info-&gt;_proxy_klass == proxy_klass, &quot;must be&quot;); // debug only -- remove
 396     ++_dumptime_lambda_proxy_class_dictionary-&gt;_count;
 397   } else {
 398     lambda_info-&gt;add_proxy_klass(proxy_klass);
 399   }
 400 }
 401 
 402 class RunTimeSharedClassInfo {
 403 public:
 404   struct CrcInfo {
 405     int _clsfile_size;
 406     int _clsfile_crc32;
 407   };
 408 
 409   // This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use
 410   // u4 instead of Symbol* to save space on 64-bit CPU.
 411   struct RTVerifierConstraint {
 412     u4 _name;
 413     u4 _from_name;
 414     Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}
 415     Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }
 416   };
 417 
 418   struct RTLoaderConstraint {
 419     u4   _name;
 420     char _loader_type1;
 421     char _loader_type2;
 422     Symbol* constraint_name() {
 423       return (Symbol*)(SharedBaseAddress + _name);
 424     }
 425   };
 426 
 427   InstanceKlass* _klass;
 428   int _num_verifier_constraints;
 429   int _num_loader_constraints;
 430 
 431   // optional CrcInfo              _crc;  (only for UNREGISTERED classes)
 432   // optional InstanceKlass*       _nest_host
 433   // optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]
 434   // optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]
 435   // optional char                 _verifier_constraint_flags[_num_verifier_constraints]
 436 
 437 private:
 438   static size_t header_size_size() {
 439     return sizeof(RunTimeSharedClassInfo);
 440   }
 441   static size_t crc_size(InstanceKlass* klass) {
 442     if (!SystemDictionaryShared::is_builtin(klass)) {
 443       return sizeof(CrcInfo);
 444     } else {
 445       return 0;
 446     }
 447   }
 448   static size_t verifier_constraints_size(int num_verifier_constraints) {
 449     return sizeof(RTVerifierConstraint) * num_verifier_constraints;
 450   }
 451   static size_t verifier_constraint_flags_size(int num_verifier_constraints) {
 452     return sizeof(char) * num_verifier_constraints;
 453   }
 454   static size_t loader_constraints_size(int num_loader_constraints) {
 455     return sizeof(RTLoaderConstraint) * num_loader_constraints;
 456   }
 457   static size_t nest_host_size(InstanceKlass* klass) {
 458     if (klass-&gt;is_hidden()) {
 459       return sizeof(InstanceKlass*);
 460     } else {
 461       return 0;
 462     }
 463   }
 464 
 465 public:
 466   static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {
 467     return header_size_size() +
 468            crc_size(klass) +
 469            nest_host_size(klass) +
 470            loader_constraints_size(num_loader_constraints) +
 471            verifier_constraints_size(num_verifier_constraints) +
 472            verifier_constraint_flags_size(num_verifier_constraints);
 473   }
 474 
 475 private:
 476   size_t crc_offset() const {
 477     return header_size_size();
 478   }
 479 
 480   size_t nest_host_offset() const {
 481       return crc_offset() + crc_size(_klass);
 482   }
 483 
 484   size_t loader_constraints_offset() const  {
 485     return nest_host_offset() + nest_host_size(_klass);
 486   }
 487   size_t verifier_constraints_offset() const {
 488     return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);
 489   }
 490   size_t verifier_constraint_flags_offset() const {
 491     return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);
 492   }
 493 
 494   void check_verifier_constraint_offset(int i) const {
 495     assert(0 &lt;= i &amp;&amp; i &lt; _num_verifier_constraints, &quot;sanity&quot;);
 496   }
 497 
 498   void check_loader_constraint_offset(int i) const {
 499     assert(0 &lt;= i &amp;&amp; i &lt; _num_loader_constraints, &quot;sanity&quot;);
 500   }
 501 
 502 public:
 503   CrcInfo* crc() const {
 504     assert(crc_size(_klass) &gt; 0, &quot;must be&quot;);
 505     return (CrcInfo*)(address(this) + crc_offset());
 506   }
 507   RTVerifierConstraint* verifier_constraints() {
 508     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 509     return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());
 510   }
 511   RTVerifierConstraint* verifier_constraint_at(int i) {
 512     check_verifier_constraint_offset(i);
 513     return verifier_constraints() + i;
 514   }
 515 
 516   char* verifier_constraint_flags() {
 517     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 518     return (char*)(address(this) + verifier_constraint_flags_offset());
 519   }
 520 
 521   InstanceKlass** nest_host_addr() {
 522     assert(_klass-&gt;is_hidden(), &quot;sanity&quot;);
 523     return (InstanceKlass**)(address(this) + nest_host_offset());
 524   }
 525   InstanceKlass* nest_host() {
 526     return *nest_host_addr();
 527   }
 528   void set_nest_host(InstanceKlass* k) {
 529     *nest_host_addr() = k;
 530     ArchivePtrMarker::mark_pointer((address*)nest_host_addr());
 531   }
 532 
 533   RTLoaderConstraint* loader_constraints() {
 534     assert(_num_loader_constraints &gt; 0, &quot;sanity&quot;);
 535     return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());
 536   }
 537 
 538   RTLoaderConstraint* loader_constraint_at(int i) {
 539     check_loader_constraint_offset(i);
 540     return loader_constraints() + i;
 541   }
 542 
 543   static u4 object_delta_u4(Symbol* sym) {
 544     if (DynamicDumpSharedSpaces) {
 545       sym = DynamicArchive::original_to_target(sym);
 546     }
 547     return MetaspaceShared::object_delta_u4(sym);
 548   }
 549 
 550   void init(DumpTimeSharedClassInfo&amp; info) {
 551     _klass = info._klass;
 552     if (!SystemDictionaryShared::is_builtin(_klass)) {
 553       CrcInfo* c = crc();
 554       c-&gt;_clsfile_size = info._clsfile_size;
 555       c-&gt;_clsfile_crc32 = info._clsfile_crc32;
 556     }
 557     _num_verifier_constraints = info.num_verifier_constraints();
 558     _num_loader_constraints   = info.num_loader_constraints();
 559     int i;
 560     if (_num_verifier_constraints &gt; 0) {
 561       RTVerifierConstraint* vf_constraints = verifier_constraints();
 562       char* flags = verifier_constraint_flags();
 563       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 564         vf_constraints[i]._name      = object_delta_u4(info._verifier_constraints-&gt;at(i)._name);
 565         vf_constraints[i]._from_name = object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);
 566       }
 567       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 568         flags[i] = info._verifier_constraint_flags-&gt;at(i);
 569       }
 570     }
 571 
 572     if (_num_loader_constraints &gt; 0) {
 573       RTLoaderConstraint* ld_constraints = loader_constraints();
 574       for (i = 0; i &lt; _num_loader_constraints; i++) {
 575         ld_constraints[i]._name = object_delta_u4(info._loader_constraints-&gt;at(i)._name);
 576         ld_constraints[i]._loader_type1 = info._loader_constraints-&gt;at(i)._loader_type1;
 577         ld_constraints[i]._loader_type2 = info._loader_constraints-&gt;at(i)._loader_type2;
 578       }
 579     }
 580     if (DynamicDumpSharedSpaces) {
 581       if (_klass-&gt;is_hidden()) {
 582         Thread* THREAD = Thread::current();
 583         InstanceKlass* n_h = _klass-&gt;nest_host(THREAD);
 584         n_h = DynamicArchive::original_to_target(n_h);
 585         set_nest_host(n_h);
 586       }
 587       _klass = DynamicArchive::original_to_target(info._klass);
 588     }
 589     ArchivePtrMarker::mark_pointer(&amp;_klass);
 590   }
 591 
 592   bool matches(int clsfile_size, int clsfile_crc32) const {
 593     return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
 594            crc()-&gt;_clsfile_crc32 == clsfile_crc32;
 595   }
 596 
 597   char verifier_constraint_flag(int i) {
 598     check_verifier_constraint_offset(i);
 599     return verifier_constraint_flags()[i];
 600   }
 601 
 602 private:
 603   // ArchiveCompactor::allocate() has reserved a pointer immediately before
 604   // archived InstanceKlasses. We can use this slot to do a quick
 605   // lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo* without
 606   // building a new hashtable.
 607   //
 608   //  info_pointer_addr(klass) --&gt; 0x0100   RunTimeSharedClassInfo*
 609   //  InstanceKlass* klass     --&gt; 0x0108   &lt;C++ vtbl&gt;
 610   //                               0x0110   fields from Klass ...
 611   static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {
 612     return &amp;((RunTimeSharedClassInfo**)klass)[-1];
 613   }
 614 
 615 public:
 616   static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
 617     assert(klass-&gt;is_shared(), &quot;don&#39;t call for non-shared class&quot;);
 618     return *info_pointer_addr(klass);
 619   }
 620   static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
 621     if (DynamicDumpSharedSpaces) {
 622       klass = DynamicArchive::original_to_buffer(klass);
 623       *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);
 624     } else {
 625       *info_pointer_addr(klass) = record;
 626     }
 627 
 628     ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));
 629   }
 630 
 631   // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
 632   static inline bool EQUALS(
 633        const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
 634     return (value-&gt;_klass-&gt;name() == key);
 635   }
 636 };
 637 
 638 class RunTimeSharedDictionary : public OffsetCompactHashtable&lt;
 639   Symbol*,
 640   const RunTimeSharedClassInfo*,
 641   RunTimeSharedClassInfo::EQUALS&gt; {};
 642 
 643 static DumpTimeSharedClassTable* _dumptime_table = NULL;
 644 // SystemDictionaries in the base layer static archive
 645 static RunTimeSharedDictionary _builtin_dictionary;
 646 static RunTimeSharedDictionary _unregistered_dictionary;
 647 // SystemDictionaries in the top layer dynamic archive
 648 static RunTimeSharedDictionary _dynamic_builtin_dictionary;
 649 static RunTimeSharedDictionary _dynamic_unregistered_dictionary;
 650 
 651 oop SystemDictionaryShared::shared_protection_domain(int index) {
 652   return ((objArrayOop)_shared_protection_domains.resolve())-&gt;obj_at(index);
 653 }
 654 
 655 oop SystemDictionaryShared::shared_jar_url(int index) {
 656   return ((objArrayOop)_shared_jar_urls.resolve())-&gt;obj_at(index);
 657 }
 658 
 659 oop SystemDictionaryShared::shared_jar_manifest(int index) {
 660   return ((objArrayOop)_shared_jar_manifests.resolve())-&gt;obj_at(index);
 661 }
 662 
 663 Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {
 664   Handle manifest ;
 665   if (shared_jar_manifest(shared_path_index) == NULL) {
 666     SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);
 667     long size = ent-&gt;manifest_size();
 668     if (size &lt;= 0) {
 669       return Handle();
 670     }
 671 
 672     // ByteArrayInputStream bais = new ByteArrayInputStream(buf);
 673     const char* src = ent-&gt;manifest();
 674     assert(src != NULL, &quot;No Manifest data&quot;);
 675     typeArrayOop buf = oopFactory::new_byteArray(size, CHECK_NH);
 676     typeArrayHandle bufhandle(THREAD, buf);
 677     ArrayAccess&lt;&gt;::arraycopy_from_native(reinterpret_cast&lt;const jbyte*&gt;(src),
 678                                          buf, typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), size);
 679 
 680     Handle bais = JavaCalls::construct_new_instance(SystemDictionary::ByteArrayInputStream_klass(),
 681                       vmSymbols::byte_array_void_signature(),
 682                       bufhandle, CHECK_NH);
 683 
 684     // manifest = new Manifest(bais)
 685     manifest = JavaCalls::construct_new_instance(SystemDictionary::Jar_Manifest_klass(),
 686                       vmSymbols::input_stream_void_signature(),
 687                       bais, CHECK_NH);
 688     atomic_set_shared_jar_manifest(shared_path_index, manifest());
 689   }
 690 
 691   manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));
 692   assert(manifest.not_null(), &quot;sanity&quot;);
 693   return manifest;
 694 }
 695 
 696 Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {
 697   Handle url_h;
 698   if (shared_jar_url(shared_path_index) == NULL) {
 699     JavaValue result(T_OBJECT);
 700     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 701     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 702     Klass* classLoaders_klass =
 703         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 704     JavaCalls::call_static(&amp;result, classLoaders_klass,
 705                            vmSymbols::toFileURL_name(),
 706                            vmSymbols::toFileURL_signature(),
 707                            path_string, CHECK_(url_h));
 708 
 709     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 710   }
 711 
 712   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 713   assert(url_h.not_null(), &quot;sanity&quot;);
 714   return url_h;
 715 }
 716 
 717 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 718   ResourceMark rm(THREAD);
 719   Handle pkgname_string;
 720   Symbol* pkg = ClassLoader::package_from_class_name(class_name);
 721   if (pkg != NULL) { // Package prefix found
 722     const char* pkgname = pkg-&gt;as_klass_external_name();
 723     pkgname_string = java_lang_String::create_from_str(pkgname,
 724                                                        CHECK_(pkgname_string));
 725   }
 726   return pkgname_string;
 727 }
 728 
 729 // Define Package for shared app classes from JAR file and also checks for
 730 // package sealing (all done in Java code)
 731 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 732 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 733                                                    Handle class_loader,
 734                                                    Handle manifest,
 735                                                    Handle url,
 736                                                    TRAPS) {
 737   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 738   // get_package_name() returns a NULL handle if the class is in unnamed package
 739   Handle pkgname_string = get_package_name(class_name, CHECK);
 740   if (pkgname_string.not_null()) {
 741     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 742     JavaValue result(T_OBJECT);
 743     JavaCallArguments args(3);
 744     args.set_receiver(class_loader);
 745     args.push_oop(pkgname_string);
 746     args.push_oop(manifest);
 747     args.push_oop(url);
 748     JavaCalls::call_virtual(&amp;result, app_classLoader_klass,
 749                             vmSymbols::defineOrCheckPackage_name(),
 750                             vmSymbols::defineOrCheckPackage_signature(),
 751                             &amp;args,
 752                             CHECK);
 753   }
 754 }
 755 
 756 // Get the ProtectionDomain associated with the CodeSource from the classloader.
 757 Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,
 758                                                                       Handle url, TRAPS) {
 759   // CodeSource cs = new CodeSource(url, null);
 760   Handle cs = JavaCalls::construct_new_instance(SystemDictionary::CodeSource_klass(),
 761                   vmSymbols::url_code_signer_array_void_signature(),
 762                   url, Handle(), CHECK_NH);
 763 
 764   // protection_domain = SecureClassLoader.getProtectionDomain(cs);
 765   Klass* secureClassLoader_klass = SystemDictionary::SecureClassLoader_klass();
 766   JavaValue obj_result(T_OBJECT);
 767   JavaCalls::call_virtual(&amp;obj_result, class_loader, secureClassLoader_klass,
 768                           vmSymbols::getProtectionDomain_name(),
 769                           vmSymbols::getProtectionDomain_signature(),
 770                           cs, CHECK_NH);
 771   return Handle(THREAD, (oop)obj_result.get_jobject());
 772 }
 773 
 774 // Returns the ProtectionDomain associated with the JAR file identified by the url.
 775 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 776                                                             int shared_path_index,
 777                                                             Handle url,
 778                                                             TRAPS) {
 779   Handle protection_domain;
 780   if (shared_protection_domain(shared_path_index) == NULL) {
 781     Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);
 782     atomic_set_shared_protection_domain(shared_path_index, pd());
 783   }
 784 
 785   // Acquire from the cache because if another thread beats the current one to
 786   // set the shared protection_domain and the atomic_set fails, the current thread
 787   // needs to get the updated protection_domain from the cache.
 788   protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));
 789   assert(protection_domain.not_null(), &quot;sanity&quot;);
 790   return protection_domain;
 791 }
 792 
 793 // Returns the ProtectionDomain associated with the moduleEntry.
 794 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 795                                                             ModuleEntry* mod, TRAPS) {
 796   ClassLoaderData *loader_data = mod-&gt;loader_data();
 797   if (mod-&gt;shared_protection_domain() == NULL) {
 798     Symbol* location = mod-&gt;location();
 799     if (location != NULL) {
 800       Handle location_string = java_lang_String::create_from_symbol(
 801                                      location, CHECK_NH);
 802       Handle url;
 803       JavaValue result(T_OBJECT);
 804       if (location-&gt;starts_with(&quot;jrt:/&quot;)) {
 805         url = JavaCalls::construct_new_instance(SystemDictionary::URL_klass(),
 806                                                 vmSymbols::string_void_signature(),
 807                                                 location_string, CHECK_NH);
 808       } else {
 809         Klass* classLoaders_klass =
 810           SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 811         JavaCalls::call_static(&amp;result, classLoaders_klass, vmSymbols::toFileURL_name(),
 812                                vmSymbols::toFileURL_signature(),
 813                                location_string, CHECK_NH);
 814         url = Handle(THREAD, (oop)result.get_jobject());
 815       }
 816 
 817       Handle pd = get_protection_domain_from_classloader(class_loader, url,
 818                                                          CHECK_NH);
 819       mod-&gt;set_shared_protection_domain(loader_data, pd);
 820     }
 821   }
 822 
 823   Handle protection_domain(THREAD, mod-&gt;shared_protection_domain());
 824   assert(protection_domain.not_null(), &quot;sanity&quot;);
 825   return protection_domain;
 826 }
 827 
 828 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 829 // the given InstanceKlass.
 830 // Returns the ProtectionDomain for the InstanceKlass.
 831 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {
 832   Handle pd;
 833 
 834   if (ik != NULL) {
 835     int index = ik-&gt;shared_classpath_index();
 836     assert(index &gt;= 0, &quot;Sanity&quot;);
 837     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 838     Symbol* class_name = ik-&gt;name();
 839 
 840     if (ent-&gt;is_modules_image()) {
 841       // For shared app/platform classes originated from the run-time image:
 842       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 843       //   for fast access by the VM.
 844       // all packages from module image are already created during VM bootstrap in
 845       // Modules::define_module().
 846       assert(pkg_entry != NULL, &quot;archived class in module image cannot be from unnamed package&quot;);
 847       ModuleEntry* mod_entry = pkg_entry-&gt;module();
 848       pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 849     } else {
 850       // For shared app/platform classes originated from JAR files on the class path:
 851       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 852       //   as the shared classpath table in the shared archive (see
 853       //   FileMap::_shared_path_table in filemap.hpp for details).
 854       //
 855       //   If a shared InstanceKlass k is loaded from the class path, let
 856       //
 857       //     index = k-&gt;shared_classpath_index():
 858       //
 859       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 860       //
 861       //   k&#39;s protection domain is:
 862       //
 863       //     ProtectionDomain pd = _shared_protection_domains[index];
 864       //
 865       //   and k&#39;s Package is initialized using
 866       //
 867       //     manifest = _shared_jar_manifests[index];
 868       //     url = _shared_jar_urls[index];
 869       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 870       //
 871       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 872       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 873       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 874       Handle url = get_shared_jar_url(index, CHECK_(pd));
<a name="1" id="anc1"></a><span class="line-modified"> 875       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));</span>












 876       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 877     }
 878   }
 879   return pd;
 880 }
 881 
 882 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 883   oop class_loader = loader_data-&gt;class_loader();
 884   return (class_loader == NULL ||
 885           SystemDictionary::is_system_class_loader(class_loader) ||
 886           SystemDictionary::is_platform_class_loader(class_loader));
 887 }
 888 
 889 bool SystemDictionaryShared::has_platform_or_app_classes() {
 890   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 891     return true;
 892   }
 893   if (DynamicArchive::is_mapped() &amp;&amp;
 894       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
 895     return true;
 896   }
 897   return false;
 898 }
 899 
 900 // The following stack shows how this code is reached:
 901 //
 902 //   [0] SystemDictionaryShared::find_or_load_shared_class()
 903 //   [1] JVM_FindLoadedClass
 904 //   [2] java.lang.ClassLoader.findLoadedClass0()
 905 //   [3] java.lang.ClassLoader.findLoadedClass()
 906 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
 907 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
 908 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
 909 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
 910 //
 911 // AppCDS supports fast class loading for these 2 built-in class loaders:
 912 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
 913 //    jdk.internal.loader.ClassLoaders$AppClassLoader
 914 // with the following assumptions (based on the JDK core library source code):
 915 //
 916 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
 917 //     load the named class.
 918 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
 919 // [c] At this point, if we can find the named class inside the
 920 //     shared_dictionary, we can perform further checks (see
 921 //     SystemDictionary::is_shared_class_visible) to ensure that this class
 922 //     was loaded by the same class loader during dump time.
 923 //
 924 // Given these assumptions, we intercept the findLoadedClass() call to invoke
 925 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
 926 // the archive for the 2 built-in class loaders. This way,
 927 // we can improve start-up because we avoid decoding the classfile,
 928 // and avoid delegating to the parent loader.
 929 //
 930 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
 931 // needs to be redesigned.
 932 
 933 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
 934                  Symbol* name, Handle class_loader, TRAPS) {
 935   InstanceKlass* k = NULL;
 936   if (UseSharedSpaces) {
 937     if (!has_platform_or_app_classes()) {
 938       return NULL;
 939     }
 940 
 941     if (SystemDictionary::is_system_class_loader(class_loader()) ||
 942         SystemDictionary::is_platform_class_loader(class_loader())) {
 943       // Fix for 4474172; see evaluation for more details
 944       class_loader = Handle(
 945         THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 946       ClassLoaderData *loader_data = register_loader(class_loader);
 947       Dictionary* dictionary = loader_data-&gt;dictionary();
 948 
 949       unsigned int d_hash = dictionary-&gt;compute_hash(name);
 950 
 951       bool DoObjectLock = true;
 952       if (is_parallelCapable(class_loader)) {
 953         DoObjectLock = false;
 954       }
 955 
 956       // Make sure we are synchronized on the class loader before we proceed
 957       //
 958       // Note: currently, find_or_load_shared_class is called only from
 959       // JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,
 960       // which are parallel-capable loaders, so this lock is NOT taken.
 961       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 962       check_loader_lock_contention(lockObject, THREAD);
 963       ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 964 
 965       {
 966         MutexLocker mu(THREAD, SystemDictionary_lock);
 967         InstanceKlass* check = find_class(d_hash, name, dictionary);
 968         if (check != NULL) {
 969           return check;
 970         }
 971       }
 972 
 973       k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);
 974       if (k != NULL) {
 975         define_instance_class(k, CHECK_NULL);
 976       }
 977     }
 978   }
 979   return k;
 980 }
 981 
 982 PackageEntry* SystemDictionaryShared::get_package_entry_from_class_name(Handle class_loader, Symbol* class_name) {
 983   PackageEntry* pkg_entry = NULL;
 984   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
 985   if (pkg_name != NULL) {
 986     pkg_entry = class_loader_data(class_loader)-&gt;packages()-&gt;lookup_only(pkg_name);
 987   }
 988   return pkg_entry;
 989 }
 990 
 991 InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(
 992                  Symbol* class_name, Handle class_loader, TRAPS) {
 993   assert(UseSharedSpaces, &quot;must be&quot;);
 994   InstanceKlass* ik = find_builtin_class(class_name);
 995 
 996   if (ik != NULL) {
 997     if ((ik-&gt;is_shared_app_class() &amp;&amp;
 998          SystemDictionary::is_system_class_loader(class_loader()))  ||
 999         (ik-&gt;is_shared_platform_class() &amp;&amp;
1000          SystemDictionary::is_platform_class_loader(class_loader()))) {
1001       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
1002       Handle protection_domain =
1003         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
1004       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
1005     }
1006   }
1007   return NULL;
1008 }
1009 
1010 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
1011   if (_shared_protection_domains.resolve() == NULL) {
1012     oop spd = oopFactory::new_objArray(
1013         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
1014     _shared_protection_domains = OopHandle(OopStorageSet::vm_global(), spd);
1015   }
1016 }
1017 
1018 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
1019   if (_shared_jar_urls.resolve() == NULL) {
1020     oop sju = oopFactory::new_objArray(
1021         SystemDictionary::URL_klass(), size, CHECK);
1022     _shared_jar_urls = OopHandle(OopStorageSet::vm_global(), sju);
1023   }
1024 }
1025 
1026 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
1027   if (_shared_jar_manifests.resolve() == NULL) {
1028     oop sjm = oopFactory::new_objArray(
1029         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
1030     _shared_jar_manifests = OopHandle(OopStorageSet::vm_global(), sjm);
1031   }
1032 }
1033 
1034 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
1035   allocate_shared_protection_domain_array(size, CHECK);
1036   allocate_shared_jar_url_array(size, CHECK);
1037   allocate_shared_jar_manifest_array(size, CHECK);
1038 }
1039 
1040 // This function is called for loading only UNREGISTERED classes
1041 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
1042                                                           Handle class_loader,
1043                                                           Handle protection_domain,
1044                                                           const ClassFileStream* cfs,
1045                                                           TRAPS) {
1046   if (!UseSharedSpaces) {
1047     return NULL;
1048   }
1049   if (class_name == NULL) {  // don&#39;t do this for hidden and unsafe anonymous classes
1050     return NULL;
1051   }
1052   if (class_loader.is_null() ||
1053       SystemDictionary::is_system_class_loader(class_loader()) ||
1054       SystemDictionary::is_platform_class_loader(class_loader())) {
1055     // Do nothing for the BUILTIN loaders.
1056     return NULL;
1057   }
1058 
1059   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, &amp;_dynamic_unregistered_dictionary, class_name);
1060   if (record == NULL) {
1061     return NULL;
1062   }
1063 
1064   int clsfile_size  = cfs-&gt;length();
1065   int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1066 
1067   if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
1068     return NULL;
1069   }
1070 
1071   return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
1072                                           protection_domain, cfs,
1073                                           THREAD);
1074 }
1075 
1076 InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(
1077                    InstanceKlass *ik,
1078                    Handle class_loader,
1079                    Handle protection_domain,
1080                    const ClassFileStream *cfs,
1081                    TRAPS) {
1082   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1083 
1084   {
1085     MutexLocker mu(THREAD, SharedDictionary_lock);
1086     if (ik-&gt;class_loader_data() != NULL) {
1087       //    ik is already loaded (by this loader or by a different loader)
1088       // or ik is being loaded by a different thread (by this loader or by a different loader)
1089       return NULL;
1090     }
1091 
1092     // No other thread has acquired this yet, so give it to *this thread*
1093     ik-&gt;set_class_loader_data(loader_data);
1094   }
1095 
1096   // No longer holding SharedDictionary_lock
1097   // No need to lock, as &lt;ik&gt; can be held only by a single thread.
1098   loader_data-&gt;add_class(ik);
1099 
1100   // Get the package entry.
1101   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, ik-&gt;name());
1102 
1103   // Load and check super/interfaces, restore unsharable info
1104   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
1105                                                   cfs, pkg_entry, THREAD);
1106   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
1107     // TODO: clean up &lt;ik&gt; so it can be used again
1108     return NULL;
1109   }
1110 
1111   return shared_klass;
1112 }
1113 
1114 static ResourceHashtable&lt;
1115   Symbol*, bool,
1116   primitive_hash&lt;Symbol*&gt;,
1117   primitive_equals&lt;Symbol*&gt;,
1118   6661,                             // prime number
1119   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
1120 
1121 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
1122   // We don&#39;t allow duplicated unregistered classes of the same name.
1123   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1124   Symbol* name = k-&gt;name();
1125   bool created = false;
1126   _loaded_unregistered_classes.put_if_absent(name, true, &amp;created);
1127   if (created) {
1128     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1129     SystemDictionary::add_to_hierarchy(k, CHECK_false);
1130   }
1131   return created;
1132 }
1133 
1134 // This function is called to resolve the super/interfaces of shared classes for
1135 // non-built-in loaders. E.g., ChildClass in the below example
1136 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1137 //
1138 // java/lang/Object id: 0
1139 // Interface   id: 2 super: 0 source: cust.jar
1140 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1141 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1142     Symbol* child_name, Symbol* class_name, Handle class_loader,
1143     Handle protection_domain, bool is_superclass, TRAPS) {
1144 
1145   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1146 
1147   ClassListParser* parser = ClassListParser::instance();
1148   if (parser == NULL) {
1149     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1150     return NULL;
1151   }
1152   if (child_name-&gt;equals(parser-&gt;current_class_name())) {
1153     // When this function is called, all the numbered super and interface types
1154     // must have already been loaded. Hence this function is never recursively called.
1155     if (is_superclass) {
1156       return parser-&gt;lookup_super_for_current_class(class_name);
1157     } else {
1158       return parser-&gt;lookup_interface_for_current_class(class_name);
1159     }
1160   } else {
1161     // The VM is not trying to resolve a super type of parser-&gt;current_class_name().
1162     // Instead, it&#39;s resolving an error class (because parser-&gt;current_class_name() has
1163     // failed parsing or verification). Don&#39;t do anything here.
1164     return NULL;
1165   }
1166 }
1167 
1168 DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
1169   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1170   if (_dumptime_table == NULL) {
1171     _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
1172   }
1173   return _dumptime_table-&gt;find_or_allocate_info_for(k);
1174 }
1175 
1176 void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
1177   Arguments::assert_is_dumping_archive();
1178   assert(!is_builtin(k), &quot;must be unregistered class&quot;);
1179   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1180   info-&gt;_clsfile_size  = cfs-&gt;length();
1181   info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1182 }
1183 
1184 void SystemDictionaryShared::init_dumptime_info(InstanceKlass* k) {
1185   (void)find_or_allocate_info_for(k);
1186 }
1187 
1188 void SystemDictionaryShared::remove_dumptime_info(InstanceKlass* k) {
1189   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1190   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(k);
1191   if (p == NULL) {
1192     return;
1193   }
1194   if (p-&gt;_verifier_constraints != NULL) {
1195     for (int i = 0; i &lt; p-&gt;_verifier_constraints-&gt;length(); i++) {
1196       DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p-&gt;_verifier_constraints-&gt;at(i);
1197       if (constraint._name != NULL ) {
1198         constraint._name-&gt;decrement_refcount();
1199       }
1200       if (constraint._from_name != NULL ) {
1201         constraint._from_name-&gt;decrement_refcount();
1202       }
1203     }
1204     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p-&gt;_verifier_constraints);
1205     p-&gt;_verifier_constraints = NULL;
1206     FREE_C_HEAP_ARRAY(char, p-&gt;_verifier_constraint_flags);
1207     p-&gt;_verifier_constraint_flags = NULL;
1208   }
1209   if (p-&gt;_loader_constraints != NULL) {
1210     for (int i = 0; i &lt; p-&gt;_loader_constraints-&gt;length(); i++) {
1211       DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p-&gt;_loader_constraints-&gt;at(i);
1212       if (ld._name != NULL) {
1213         ld._name-&gt;decrement_refcount();
1214       }
1215     }
1216     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p-&gt;_loader_constraints);
1217     p-&gt;_loader_constraints = NULL;
1218   }
1219   _dumptime_table-&gt;remove(k);
1220 }
1221 
1222 bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {
1223   while (k) {
1224     if (k-&gt;name()-&gt;equals(&quot;jdk/internal/event/Event&quot;)) {
1225       return true;
1226     }
1227     k = k-&gt;java_super();
1228   }
1229   return false;
1230 }
1231 
1232 bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {
1233   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(ik);
1234   return (info != NULL) ? info-&gt;_is_archived_lambda_proxy : false;
1235 }
1236 
1237 bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {
1238   assert(ik-&gt;is_shared(), &quot;applicable to only a shared class&quot;);
1239   if (ik-&gt;is_hidden()) {
1240     return true;
1241   } else {
1242     return false;
1243   }
1244 }
1245 
1246 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1247   ResourceMark rm;
1248   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1249 }
1250 
1251 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1252 
1253   if (k-&gt;is_unsafe_anonymous()) {
1254     warn_excluded(k, &quot;Unsafe anonymous class&quot;);
1255     return true; // unsafe anonymous classes are not archived, skip
1256   }
1257 
1258   if (k-&gt;is_in_error_state()) {
1259     warn_excluded(k, &quot;In error state&quot;);
1260     return true;
1261   }
1262   if (k-&gt;has_been_redefined()) {
1263     warn_excluded(k, &quot;Has been redefined&quot;);
1264     return true;
1265   }
1266   if (!k-&gt;is_hidden() &amp;&amp; k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1267     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1268     // agent during dump time).
1269     warn_excluded(k, &quot;Unsupported location&quot;);
1270     return true;
1271   }
1272   if (k-&gt;signers() != NULL) {
1273     // We cannot include signed classes in the archive because the certificates
1274     // used during dump time may be different than those used during
1275     // runtime (due to expiration, etc).
1276     warn_excluded(k, &quot;Signed JAR&quot;);
1277     return true;
1278   }
1279   if (is_jfr_event_class(k)) {
1280     // We cannot include JFR event classes because they need runtime-specific
1281     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1282     // There are only a small number of these classes, so it&#39;s not worthwhile to
1283     // support them and make CDS more complicated.
1284     warn_excluded(k, &quot;JFR event class&quot;);
1285     return true;
1286   }
1287   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
1288     // In CDS dumping, we will attempt to link all classes. Those that fail to link will
1289     // be recorded in DumpTimeSharedClassInfo.
1290     Arguments::assert_is_dumping_archive();
1291 
1292     // TODO -- rethink how this can be handled.
1293     // We should try to link ik, however, we can&#39;t do it here because
1294     // 1. We are at VM exit
1295     // 2. linking a class may cause other classes to be loaded, which means
1296     //    a custom ClassLoader.loadClass() may be called, at a point where the
1297     //    class loader doesn&#39;t expect it.
1298     if (has_class_failed_verification(k)) {
1299       warn_excluded(k, &quot;Failed verification&quot;);
1300     } else {
1301       warn_excluded(k, &quot;Not linked&quot;);
1302     }
1303     return true;
1304   }
1305   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1306     ResourceMark rm;
1307     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1308                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1309     return true;
1310   }
1311 
1312   InstanceKlass* super = k-&gt;java_super();
1313   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1314     ResourceMark rm;
1315     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1316     return true;
1317   }
1318 
1319   if (k-&gt;is_hidden() &amp;&amp; !is_registered_lambda_proxy_class(k)) {
1320     warn_excluded(k, &quot;Hidden class&quot;);
1321     return true;
1322   }
1323 
1324   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1325   int len = interfaces-&gt;length();
1326   for (int i = 0; i &lt; len; i++) {
1327     InstanceKlass* intf = interfaces-&gt;at(i);
1328     if (should_be_excluded(intf)) {
1329       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1330       return true;
1331     }
1332   }
1333 
1334   return false;
1335 }
1336 
1337 // k is a class before relocating by ArchiveCompactor
1338 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1339   ResourceMark rm;
1340   const char* name = k-&gt;name()-&gt;as_C_string();
1341   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1342   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1343   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1344   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1345   if (is_builtin(k)) {
1346     if (k-&gt;is_hidden()) {
1347       assert(is_registered_lambda_proxy_class(k), &quot;unexpected hidden class %s&quot;, name);
1348     }
1349     guarantee(!k-&gt;is_shared_unregistered_class(),
1350               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1351 
1352   } else {
1353     guarantee(k-&gt;is_shared_unregistered_class(),
1354               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1355   }
1356 }
1357 
1358 class ExcludeDumpTimeSharedClasses : StackObj {
1359 public:
1360   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1361     if (SystemDictionaryShared::should_be_excluded(k)) {
1362       info.set_excluded();
1363     }
1364     return true; // keep on iterating
1365   }
1366 };
1367 
1368 void SystemDictionaryShared::check_excluded_classes() {
1369   ExcludeDumpTimeSharedClasses excl;
1370   _dumptime_table-&gt;iterate(&amp;excl);
1371   _dumptime_table-&gt;update_counts();
1372 }
1373 
1374 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1375   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1376   Arguments::assert_is_dumping_archive();
1377   return find_or_allocate_info_for(k)-&gt;is_excluded();
1378 }
1379 
1380 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {
1381   Arguments::assert_is_dumping_archive();
1382   find_or_allocate_info_for(ik)-&gt;set_failed_verification();
1383 }
1384 
1385 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {
1386   Arguments::assert_is_dumping_archive();
1387   if (_dumptime_table == NULL) {
1388     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);
1389     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);
1390     return false;
1391   }
1392   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);
1393   return (p == NULL) ? false : p-&gt;failed_verification();
1394 }
1395 
1396 class IterateDumpTimeSharedClassTable : StackObj {
1397   MetaspaceClosure *_it;
1398 public:
1399   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1400 
1401   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1402     if (!info.is_excluded()) {
1403       info.metaspace_pointers_do(_it);
1404     }
1405     return true; // keep on iterating
1406   }
1407 };
1408 
1409 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1410   IterateDumpTimeSharedClassTable iter(it);
1411   _dumptime_table-&gt;iterate(&amp;iter);
1412 }
1413 
1414 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1415          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1416   Arguments::assert_is_dumping_archive();
1417   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1418   info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
1419                                     from_is_array, from_is_object);
1420 
1421   if (DynamicDumpSharedSpaces) {
1422     // For dynamic dumping, we can resolve all the constraint classes for all class loaders during
1423     // the initial run prior to creating the archive before vm exit. We will also perform verification
1424     // check when running with the archive.
1425     return false;
1426   } else {
1427     if (is_builtin(k)) {
1428       // For builtin class loaders, we can try to complete the verification check at dump time,
1429       // because we can resolve all the constraint classes. We will also perform verification check
1430       // when running with the archive.
1431       return false;
1432     } else {
1433       // For non-builtin class loaders, we cannot complete the verification check at dump time,
1434       // because at dump time we don&#39;t know how to resolve classes for such loaders.
1435       return true;
1436     }
1437   }
1438 }
1439 
1440 void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
1441          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1442   if (_verifier_constraints == NULL) {
1443     _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTVerifierConstraint&gt;(4, mtClass);
1444   }
1445   if (_verifier_constraint_flags == NULL) {
1446     _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;char&gt;(4, mtClass);
1447   }
1448   GrowableArray&lt;DTVerifierConstraint&gt;* vc_array = _verifier_constraints;
1449   for (int i = 0; i &lt; vc_array-&gt;length(); i++) {
1450     DTVerifierConstraint* p = vc_array-&gt;adr_at(i);
1451     if (name == p-&gt;_name &amp;&amp; from_name == p-&gt;_from_name) {
1452       return;
1453     }
1454   }
1455   DTVerifierConstraint cons(name, from_name);
1456   vc_array-&gt;append(cons);
1457 
1458   GrowableArray&lt;char&gt;* vcflags_array = _verifier_constraint_flags;
1459   char c = 0;
1460   c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;
1461   c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;
1462   c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
1463   vcflags_array-&gt;append(c);
1464 
1465   if (log_is_enabled(Trace, cds, verification)) {
1466     ResourceMark rm;
1467     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d&quot;,
1468                                  k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1469                                  name-&gt;as_klass_external_name(), c, vc_array-&gt;length(), vcflags_array-&gt;length());
1470   }
1471 }
1472 
1473 void SystemDictionaryShared::add_lambda_proxy_class(InstanceKlass* caller_ik,
1474                                                     InstanceKlass* lambda_ik,
1475                                                     Symbol* invoked_name,
1476                                                     Symbol* invoked_type,
1477                                                     Symbol* method_type,
1478                                                     Method* member_method,
1479                                                     Symbol* instantiated_method_type) {
1480 
1481   assert(caller_ik-&gt;class_loader() == lambda_ik-&gt;class_loader(), &quot;mismatched class loader&quot;);
1482   assert(caller_ik-&gt;class_loader_data() == lambda_ik-&gt;class_loader_data(), &quot;mismatched class loader data&quot;);
1483   assert(java_lang_Class::class_data(lambda_ik-&gt;java_mirror()) == NULL, &quot;must not have class data&quot;);
1484 
1485   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1486 
1487   lambda_ik-&gt;assign_class_loader_type();
1488   lambda_ik-&gt;set_shared_classpath_index(caller_ik-&gt;shared_classpath_index());
1489 
1490   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(lambda_ik);
1491   if (info != NULL &amp;&amp; !lambda_ik-&gt;is_non_strong_hidden() &amp;&amp; is_builtin(lambda_ik) &amp;&amp; is_builtin(caller_ik)) {
1492     // Set _is_archived_lambda_proxy in DumpTimeSharedClassInfo so that the lambda_ik
1493     // won&#39;t be excluded during dumping of shared archive. See ExcludeDumpTimeSharedClasses.
1494     info-&gt;_is_archived_lambda_proxy = true;
1495 
1496     LambdaProxyClassKey key(caller_ik,
1497                             invoked_name,
1498                             invoked_type,
1499                             method_type,
1500                             member_method,
1501                             instantiated_method_type);
1502     add_to_dump_time_lambda_proxy_class_dictionary(key, lambda_ik);
1503   }
1504 }
1505 
1506 InstanceKlass* SystemDictionaryShared::get_shared_lambda_proxy_class(InstanceKlass* caller_ik,
1507                                                                      Symbol* invoked_name,
1508                                                                      Symbol* invoked_type,
1509                                                                      Symbol* method_type,
1510                                                                      Method* member_method,
1511                                                                      Symbol* instantiated_method_type) {
1512   MutexLocker ml(CDSLambda_lock, Mutex::_no_safepoint_check_flag);
1513   LambdaProxyClassKey key(caller_ik, invoked_name, invoked_type,
1514                           method_type, member_method, instantiated_method_type);
1515   const RunTimeLambdaProxyClassInfo* info = _lambda_proxy_class_dictionary.lookup(&amp;key, key.hash(), 0);
1516   InstanceKlass* proxy_klass = NULL;
1517   if (info != NULL) {
1518     InstanceKlass* curr_klass = info-&gt;proxy_klass_head();
1519     InstanceKlass* prev_klass = curr_klass;
1520     if (curr_klass-&gt;lambda_proxy_is_available()) {
1521       while (curr_klass-&gt;next_link() != NULL) {
1522         prev_klass = curr_klass;
1523         curr_klass = InstanceKlass::cast(curr_klass-&gt;next_link());
1524       }
1525       assert(curr_klass-&gt;is_hidden(), &quot;must be&quot;);
1526       assert(curr_klass-&gt;lambda_proxy_is_available(), &quot;must be&quot;);
1527 
1528       prev_klass-&gt;set_next_link(NULL);
1529       proxy_klass = curr_klass;
1530       proxy_klass-&gt;clear_lambda_proxy_is_available();
1531       if (log_is_enabled(Debug, cds)) {
1532         ResourceMark rm;
1533         log_debug(cds)(&quot;Loaded lambda proxy: %s&quot;, proxy_klass-&gt;external_name());
1534       }
1535     } else {
1536       if (log_is_enabled(Debug, cds)) {
1537         ResourceMark rm;
1538         log_debug(cds)(&quot;Used all archived lambda proxy classes for: %s %s%s&quot;,
1539                        caller_ik-&gt;external_name(), invoked_name-&gt;as_C_string(), invoked_type-&gt;as_C_string());
1540       }
1541     }
1542   }
1543   return proxy_klass;
1544 }
1545 
1546 InstanceKlass* SystemDictionaryShared::get_shared_nest_host(InstanceKlass* lambda_ik) {
1547   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1548   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(lambda_ik);
1549   return record-&gt;nest_host();
1550 }
1551 
1552 InstanceKlass* SystemDictionaryShared::prepare_shared_lambda_proxy_class(InstanceKlass* lambda_ik,
1553                                                                          InstanceKlass* caller_ik,
1554                                                                          bool initialize, TRAPS) {
1555   Handle class_loader(THREAD, caller_ik-&gt;class_loader());
1556   Handle protection_domain;
1557   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, caller_ik-&gt;name());
1558   if (caller_ik-&gt;class_loader() != NULL) {
1559     protection_domain = SystemDictionaryShared::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);
1560   }
1561 
1562   InstanceKlass* shared_nest_host = get_shared_nest_host(lambda_ik);
1563   assert(shared_nest_host != NULL, &quot;unexpected NULL _nest_host&quot;);
1564 
1565   InstanceKlass* loaded_lambda =
1566     SystemDictionary::load_shared_lambda_proxy_class(lambda_ik, class_loader, protection_domain, pkg_entry, CHECK_NULL);
1567 
1568   // Ensures the nest host is the same as the lambda proxy&#39;s
1569   // nest host recorded at dump time.
1570   InstanceKlass* nest_host = caller_ik-&gt;nest_host(THREAD);
1571   assert(nest_host == shared_nest_host, &quot;mismatched nest host&quot;);
1572 
1573   EventClassLoad class_load_start_event;
1574   {
1575     MutexLocker mu_r(THREAD, Compile_lock);
1576 
1577     // Add to class hierarchy, initialize vtables, and do possible
1578     // deoptimizations.
1579     SystemDictionary::add_to_hierarchy(loaded_lambda, CHECK_NULL); // No exception, but can block
1580     // But, do not add to dictionary.
1581   }
1582   loaded_lambda-&gt;link_class(CHECK_NULL);
1583   // notify jvmti
1584   if (JvmtiExport::should_post_class_load()) {
1585     assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1586     JvmtiExport::post_class_load((JavaThread *) THREAD, loaded_lambda);
1587   }
1588   if (class_load_start_event.should_commit()) {
1589     SystemDictionary::post_class_load_event(&amp;class_load_start_event, loaded_lambda, ClassLoaderData::class_loader_data(class_loader()));
1590   }
1591 
1592   if (initialize) {
1593     loaded_lambda-&gt;initialize(CHECK_NULL);
1594   }
1595 
1596   return loaded_lambda;
1597 }
1598 
1599 static char get_loader_type_by(oop  loader) {
1600   assert(SystemDictionary::is_builtin_class_loader(loader), &quot;Must be built-in loader&quot;);
1601   if (SystemDictionary::is_boot_class_loader(loader)) {
1602     return (char)ClassLoader::BOOT_LOADER;
1603   } else if (SystemDictionary::is_platform_class_loader(loader)) {
1604     return (char)ClassLoader::PLATFORM_LOADER;
1605   } else {
1606     assert(SystemDictionary::is_system_class_loader(loader), &quot;Class loader mismatch&quot;);
1607     return (char)ClassLoader::APP_LOADER;
1608   }
1609 }
1610 
1611 static oop get_class_loader_by(char type) {
1612   if (type == (char)ClassLoader::BOOT_LOADER) {
1613     return (oop)NULL;
1614   } else if (type == (char)ClassLoader::PLATFORM_LOADER) {
1615     return SystemDictionary::java_platform_loader();
1616   } else {
1617     assert (type == (char)ClassLoader::APP_LOADER, &quot;Sanity&quot;);
1618     return SystemDictionary::java_system_loader();
1619   }
1620 }
1621 
1622 void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {
1623   assert(loader1 != loader2, &quot;sanity&quot;);
1624   LogTarget(Info, class, loader, constraints) log;
1625   if (_loader_constraints == NULL) {
1626     _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTLoaderConstraint&gt;(4, mtClass);
1627   }
1628   char lt1 = get_loader_type_by(loader1());
1629   char lt2 = get_loader_type_by(loader2());
1630   DTLoaderConstraint lc(name, lt1, lt2);
1631   for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
1632     DTLoaderConstraint dt = _loader_constraints-&gt;at(i);
1633     if (lc.equals(dt)) {
1634       if (log.is_enabled()) {
1635         ResourceMark rm;
1636         // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1637         log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]&quot;,
1638                   _klass-&gt;external_name(), name-&gt;as_C_string(),
1639                   ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1640                   ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1641       }
1642       return;
1643     }
1644   }
1645   _loader_constraints-&gt;append(lc);
1646   if (log.is_enabled()) {
1647     ResourceMark rm;
1648     // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1649     log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]&quot;,
1650               _klass-&gt;external_name(), name-&gt;as_C_string(),
1651               ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1652               ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id(),
1653               _loader_constraints-&gt;length());
1654   }
1655 }
1656 
1657 void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
1658                                                             TRAPS) {
1659   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1660   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);
1661 
1662   int length = record-&gt;_num_verifier_constraints;
1663   if (length &gt; 0) {
1664     for (int i = 0; i &lt; length; i++) {
1665       RunTimeSharedClassInfo::RTVerifierConstraint* vc = record-&gt;verifier_constraint_at(i);
1666       Symbol* name      = vc-&gt;name();
1667       Symbol* from_name = vc-&gt;from_name();
1668       char c            = record-&gt;verifier_constraint_flag(i);
1669 
1670       if (log_is_enabled(Trace, cds, verification)) {
1671         ResourceMark rm(THREAD);
1672         log_trace(cds, verification)(&quot;check_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1673                                      klass-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1674                                      name-&gt;as_klass_external_name(), c);
1675       }
1676 
1677       bool from_field_is_protected = (c &amp; SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;
1678       bool from_is_array           = (c &amp; SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;
1679       bool from_is_object          = (c &amp; SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;
1680 
1681       bool ok = VerificationType::resolve_and_check_assignability(klass, name,
1682          from_name, from_field_is_protected, from_is_array, from_is_object, CHECK);
1683       if (!ok) {
1684         ResourceMark rm(THREAD);
1685         stringStream ss;
1686 
1687         ss.print_cr(&quot;Bad type on operand stack&quot;);
1688         ss.print_cr(&quot;Exception Details:&quot;);
1689         ss.print_cr(&quot;  Location:\n    %s&quot;, klass-&gt;name()-&gt;as_C_string());
1690         ss.print_cr(&quot;  Reason:\n    Type &#39;%s&#39; is not assignable to &#39;%s&#39;&quot;,
1691                     from_name-&gt;as_quoted_ascii(), name-&gt;as_quoted_ascii());
1692         THROW_MSG(vmSymbols::java_lang_VerifyError(), ss.as_string());
1693       }
1694     }
1695   }
1696 }
1697 
1698 // Record class loader constraints that are checked inside
1699 // InstanceKlass::link_class(), so that these can be checked quickly
1700 // at runtime without laying out the vtable/itables.
1701 void SystemDictionaryShared::record_linking_constraint(Symbol* name, InstanceKlass* klass,
1702                                                     Handle loader1, Handle loader2, TRAPS) {
1703   // A linking constraint check is executed when:
1704   //   - klass extends or implements type S
1705   //   - klass overrides method S.M(...) with X.M
1706   //     - If klass defines the method M, X is
1707   //       the same as klass.
1708   //     - If klass does not define the method M,
1709   //       X must be a supertype of klass and X.M is
1710   //       a default method defined by X.
1711   //   - loader1 = X-&gt;class_loader()
1712   //   - loader2 = S-&gt;class_loader()
1713   //   - loader1 != loader2
1714   //   - M&#39;s paramater(s) include an object type T
1715   // We require that
1716   //   - whenever loader1 and loader2 try to
1717   //     resolve the type T, they must always resolve to
1718   //     the same InstanceKlass.
1719   // NOTE: type T may or may not be currently resolved in
1720   // either of these two loaders. The check itself does not
1721   // try to resolve T.
1722   oop klass_loader = klass-&gt;class_loader();
1723   assert(klass_loader != NULL, &quot;should not be called for boot loader&quot;);
1724   assert(loader1 != loader2, &quot;must be&quot;);
1725 
1726   if (!is_system_class_loader(klass_loader) &amp;&amp;
1727       !is_platform_class_loader(klass_loader)) {
1728     // If klass is loaded by system/platform loaders, we can
1729     // guarantee that klass and S must be loaded by the same
1730     // respective loader between dump time and run time, and
1731     // the exact same check on (name, loader1, loader2) will
1732     // be executed. Hence, we can cache this check and execute
1733     // it at runtime without walking the vtable/itables.
1734     //
1735     // This cannot be guaranteed for classes loaded by other
1736     // loaders, so we bail.
1737     return;
1738   }
1739 
1740   if (THREAD-&gt;is_VM_thread()) {
1741     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1742     // We are re-laying out the vtable/itables of the *copy* of
1743     // a class during the final stage of dynamic dumping. The
1744     // linking constraints for this class has already been recorded.
1745     return;
1746   }
1747   Arguments::assert_is_dumping_archive();
1748   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);
1749   info-&gt;record_linking_constraint(name, loader1, loader2);
1750 }
1751 
1752 // returns true IFF there&#39;s no need to re-initialize the i/v-tables for klass for
1753 // the purpose of checking class loader constraints.
1754 bool SystemDictionaryShared::check_linking_constraints(InstanceKlass* klass, TRAPS) {
1755   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1756   LogTarget(Info, class, loader, constraints) log;
1757   if (klass-&gt;is_shared_boot_class()) {
1758     // No class loader constraint check performed for boot classes.
1759     return true;
1760   }
1761   if (klass-&gt;is_shared_platform_class() || klass-&gt;is_shared_app_class()) {
1762     RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);
1763     assert(info != NULL, &quot;Sanity&quot;);
1764     if (info-&gt;_num_loader_constraints &gt; 0) {
1765       HandleMark hm;
1766       for (int i = 0; i &lt; info-&gt;_num_loader_constraints; i++) {
1767         RunTimeSharedClassInfo::RTLoaderConstraint* lc = info-&gt;loader_constraint_at(i);
1768         Symbol* name = lc-&gt;constraint_name();
1769         Handle loader1(THREAD, get_class_loader_by(lc-&gt;_loader_type1));
1770         Handle loader2(THREAD, get_class_loader_by(lc-&gt;_loader_type2));
1771         if (log.is_enabled()) {
1772           ResourceMark rm(THREAD);
1773           log.print(&quot;[CDS add loader constraint for class %s symbol %s loader[0] %s loader[1] %s&quot;,
1774                     klass-&gt;external_name(), name-&gt;as_C_string(),
1775                     ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1776                     ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1777         }
1778         if (!SystemDictionary::add_loader_constraint(name, klass, loader1, loader2, THREAD)) {
1779           // Loader constraint violation has been found. The caller
1780           // will re-layout the vtable/itables to produce the correct
1781           // exception.
1782           if (log.is_enabled()) {
1783             log.print(&quot; failed]&quot;);
1784           }
1785           return false;
1786         }
1787         if (log.is_enabled()) {
1788             log.print(&quot; succeeded]&quot;);
1789         }
1790       }
1791       return true; // for all recorded constraints added successully.
1792     }
1793   }
1794   if (log.is_enabled()) {
1795     ResourceMark rm(THREAD);
1796     log.print(&quot;[CDS has not recorded loader constraint for class %s]&quot;, klass-&gt;external_name());
1797   }
1798   return false;
1799 }
1800 
1801 class EstimateSizeForArchive : StackObj {
1802   size_t _shared_class_info_size;
1803   int _num_builtin_klasses;
1804   int _num_unregistered_klasses;
1805 
1806 public:
1807   EstimateSizeForArchive() {
1808     _shared_class_info_size = 0;
1809     _num_builtin_klasses = 0;
1810     _num_unregistered_klasses = 0;
1811   }
1812 
1813   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1814     if (!info.is_excluded()) {
1815       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
1816       _shared_class_info_size += align_up(byte_size, BytesPerWord);
1817     }
1818     return true; // keep on iterating
1819   }
1820 
1821   size_t total() {
1822     return _shared_class_info_size;
1823   }
1824 };
1825 
1826 size_t SystemDictionaryShared::estimate_size_for_archive() {
1827   EstimateSizeForArchive est;
1828   _dumptime_table-&gt;iterate(&amp;est);
1829   size_t total_size = est.total() +
1830     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(true)) +
1831     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(false));
1832   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
1833     total_size +=
1834       (sizeof(RunTimeLambdaProxyClassInfo) * _dumptime_lambda_proxy_class_dictionary-&gt;_count) +
1835       CompactHashtableWriter::estimate_size(_dumptime_lambda_proxy_class_dictionary-&gt;_count);
1836   } else {
1837     total_size += CompactHashtableWriter::estimate_size(0);
1838   }
1839   return total_size;
1840 }
1841 
1842 class CopyLambdaProxyClassInfoToArchive : StackObj {
1843   CompactHashtableWriter* _writer;
1844 public:
1845   CopyLambdaProxyClassInfoToArchive(CompactHashtableWriter* writer)
1846     : _writer(writer) {}
1847   bool do_entry(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
1848     if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses-&gt;at(0))) {
1849       return true;
1850     }
1851     ResourceMark rm;
1852     log_info(cds,dynamic)(&quot;Archiving hidden %s&quot;, info._proxy_klasses-&gt;at(0)-&gt;external_name());
1853     size_t byte_size = sizeof(RunTimeLambdaProxyClassInfo);
1854     RunTimeLambdaProxyClassInfo* runtime_info =
1855         (RunTimeLambdaProxyClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
1856     runtime_info-&gt;init(key, info);
1857     unsigned int hash = runtime_info-&gt;hash(); // Fields in runtime_info-&gt;_key already point to target space.
1858     u4 delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(runtime_info));
1859     _writer-&gt;add(hash, delta);
1860     return true;
1861   }
1862 };
1863 
1864 class AdjustLambdaProxyClassInfo : StackObj {
1865 public:
1866   AdjustLambdaProxyClassInfo() {}
1867   bool do_entry(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
1868     if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses-&gt;at(0))) {
1869       return true;
1870     }
1871     int len = info._proxy_klasses-&gt;length();
1872     if (len &gt; 1) {
1873       for (int i = 0; i &lt; len-1; i++) {
1874         InstanceKlass* ok0 = info._proxy_klasses-&gt;at(i+0); // this is original klass
1875         InstanceKlass* ok1 = info._proxy_klasses-&gt;at(i+1); // this is original klass
1876         InstanceKlass* bk0 = DynamicArchive::original_to_buffer(ok0);
1877         InstanceKlass* bk1 = DynamicArchive::original_to_buffer(ok1);
1878         assert(bk0-&gt;next_link() == 0, &quot;must be called after Klass::remove_unshareable_info()&quot;);
1879         assert(bk1-&gt;next_link() == 0, &quot;must be called after Klass::remove_unshareable_info()&quot;);
1880         bk0-&gt;set_next_link(bk1);
1881         bk1-&gt;set_lambda_proxy_is_available();
1882         ArchivePtrMarker::mark_pointer(bk0-&gt;next_link_addr());
1883       }
1884     }
1885     DynamicArchive::original_to_buffer(info._proxy_klasses-&gt;at(0))-&gt;set_lambda_proxy_is_available();
1886     return true;
1887   }
1888 };
1889 
1890 class CopySharedClassInfoToArchive : StackObj {
1891   CompactHashtableWriter* _writer;
1892   bool _is_builtin;
1893 public:
1894   CopySharedClassInfoToArchive(CompactHashtableWriter* writer,
1895                                bool is_builtin,
1896                                bool is_static_archive)
1897     : _writer(writer), _is_builtin(is_builtin) {}
1898 
1899   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1900     if (!info.is_excluded() &amp;&amp; info.is_builtin() == _is_builtin) {
1901       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
1902       RunTimeSharedClassInfo* record;
1903       record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
1904       record-&gt;init(info);
1905 
1906       unsigned int hash;
1907       Symbol* name = info._klass-&gt;name();
1908       if (DynamicDumpSharedSpaces) {
1909         name = DynamicArchive::original_to_target(name);
1910       }
1911       hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1912       u4 delta;
1913       if (DynamicDumpSharedSpaces) {
1914         delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));
1915       } else {
1916         delta = MetaspaceShared::object_delta_u4(record);
1917       }
1918       if (_is_builtin &amp;&amp; info._klass-&gt;is_hidden()) {
1919         // skip
1920       } else {
1921         _writer-&gt;add(hash, delta);
1922       }
1923       if (log_is_enabled(Trace, cds, hashtables)) {
1924         ResourceMark rm;
1925         log_trace(cds,hashtables)(&quot;%s dictionary: %s&quot;, (_is_builtin ? &quot;builtin&quot; : &quot;unregistered&quot;), info._klass-&gt;external_name());
1926       }
1927 
1928       // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
1929       RunTimeSharedClassInfo::set_for(info._klass, record);
1930     }
1931     return true; // keep on iterating
1932   }
1933 };
1934 
1935 void SystemDictionaryShared::write_lambda_proxy_class_dictionary(LambdaProxyClassDictionary *dictionary) {
1936   CompactHashtableStats stats;
1937   dictionary-&gt;reset();
1938   CompactHashtableWriter writer(_dumptime_lambda_proxy_class_dictionary-&gt;_count, &amp;stats);
1939   CopyLambdaProxyClassInfoToArchive copy(&amp;writer);
1940   _dumptime_lambda_proxy_class_dictionary-&gt;iterate(&amp;copy);
1941   writer.dump(dictionary, &quot;lambda proxy class dictionary&quot;);
1942 }
1943 
1944 void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary,
1945                                               bool is_builtin,
1946                                               bool is_static_archive) {
1947   CompactHashtableStats stats;
1948   dictionary-&gt;reset();
1949   CompactHashtableWriter writer(_dumptime_table-&gt;count_of(is_builtin), &amp;stats);
1950   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin, is_static_archive);
1951   _dumptime_table-&gt;iterate(&amp;copy);
1952   writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
1953 }
1954 
1955 void SystemDictionaryShared::write_to_archive(bool is_static_archive) {
1956   if (is_static_archive) {
1957     write_dictionary(&amp;_builtin_dictionary, true);
1958     write_dictionary(&amp;_unregistered_dictionary, false);
1959   } else {
1960     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1961     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1962   }
1963   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
1964     write_lambda_proxy_class_dictionary(&amp;_lambda_proxy_class_dictionary);
1965   }
1966 }
1967 
1968 void SystemDictionaryShared::adjust_lambda_proxy_class_dictionary() {
1969   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
1970     AdjustLambdaProxyClassInfo adjuster;
1971     _dumptime_lambda_proxy_class_dictionary-&gt;iterate(&amp;adjuster);
1972   }
1973 }
1974 
1975 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1976                                                           bool is_static_archive) {
1977   if (is_static_archive) {
1978     _builtin_dictionary.serialize_header(soc);
1979     _unregistered_dictionary.serialize_header(soc);
1980   } else {
1981     _dynamic_builtin_dictionary.serialize_header(soc);
1982     _dynamic_unregistered_dictionary.serialize_header(soc);
1983     _lambda_proxy_class_dictionary.serialize_header(soc);
1984   }
1985 }
1986 
1987 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {
1988   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {
1989     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);
1990   }
1991 }
1992 
1993 const RunTimeSharedClassInfo*
1994 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1995   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1996     // The names of all shared classes must also be a shared Symbol.
1997     return NULL;
1998   }
1999 
2000   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
2001   const RunTimeSharedClassInfo* record = NULL;
2002   if (!MetaspaceShared::is_shared_dynamic(name)) {
2003     // The names of all shared classes in the static dict must also be in the
2004     // static archive
2005     record = static_dict-&gt;lookup(name, hash, 0);
2006   }
2007 
2008   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
2009     record = dynamic_dict-&gt;lookup(name, hash, 0);
2010   }
2011 
2012   return record;
2013 }
2014 
2015 InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
2016   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, &amp;_dynamic_builtin_dictionary, name);
2017   if (record != NULL) {
2018     assert(!record-&gt;_klass-&gt;is_hidden(), &quot;hidden class cannot be looked up by name&quot;);
2019     return record-&gt;_klass;
2020   } else {
2021     return NULL;
2022   }
2023 }
2024 
2025 void SystemDictionaryShared::update_shared_entry(InstanceKlass* k, int id) {
2026   assert(DumpSharedSpaces, &quot;supported only when dumping&quot;);
2027   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
2028   info-&gt;_id = id;
2029 }
2030 
2031 class SharedDictionaryPrinter : StackObj {
2032   outputStream* _st;
2033   int _index;
2034 public:
2035   SharedDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
2036 
2037   void do_value(const RunTimeSharedClassInfo* record) {
2038     ResourceMark rm;
2039     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;_klass-&gt;external_name());
2040   }
2041 };
2042 
2043 class SharedLambdaDictionaryPrinter : StackObj {
2044   outputStream* _st;
2045   int _index;
2046 public:
2047   SharedLambdaDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
2048 
2049   void do_value(const RunTimeLambdaProxyClassInfo* record) {
2050     ResourceMark rm;
2051     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;proxy_klass_head()-&gt;external_name());
2052     Klass* k = record-&gt;proxy_klass_head()-&gt;next_link();
2053     while (k != NULL) {
2054       _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), k-&gt;external_name());
2055       k = k-&gt;next_link();
2056     }
2057   }
2058 };
2059 
2060 void SystemDictionaryShared::print_on(outputStream* st) {
2061   if (UseSharedSpaces) {
2062     st-&gt;print_cr(&quot;Shared Dictionary&quot;);
2063     SharedDictionaryPrinter p(st);
2064     _builtin_dictionary.iterate(&amp;p);
2065     _unregistered_dictionary.iterate(&amp;p);
2066     if (DynamicArchive::is_mapped()) {
2067       _dynamic_builtin_dictionary.iterate(&amp;p);
2068       _unregistered_dictionary.iterate(&amp;p);
2069       if (!_lambda_proxy_class_dictionary.empty()) {
2070         st-&gt;print_cr(&quot;Shared Lambda Dictionary&quot;);
2071         SharedLambdaDictionaryPrinter ldp(st);
2072         _lambda_proxy_class_dictionary.iterate(&amp;ldp);
2073       }
2074     }
2075   }
2076 }
2077 
2078 void SystemDictionaryShared::print_table_statistics(outputStream* st) {
2079   if (UseSharedSpaces) {
2080     _builtin_dictionary.print_table_statistics(st, &quot;Builtin Shared Dictionary&quot;);
2081     _unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
2082     if (DynamicArchive::is_mapped()) {
2083       _dynamic_builtin_dictionary.print_table_statistics(st, &quot;Dynamic Builtin Shared Dictionary&quot;);
2084       _dynamic_unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
2085       _lambda_proxy_class_dictionary.print_table_statistics(st, &quot;Lambda Shared Dictionary&quot;);
2086     }
2087   }
2088 }
2089 
2090 bool SystemDictionaryShared::empty_dumptime_table() {
2091   if (_dumptime_table == NULL) {
2092     return true;
2093   }
2094   _dumptime_table-&gt;update_counts();
2095   if (_dumptime_table-&gt;count_of(true) == 0 &amp;&amp; _dumptime_table-&gt;count_of(false) == 0){
2096     return true;
2097   }
2098   return false;
2099 }
2100 
2101 #if INCLUDE_CDS_JAVA_HEAP
2102 
2103 class ArchivedMirrorPatcher {
2104   static void update(Klass* k) {
2105     if (k-&gt;has_raw_archived_mirror()) {
2106       oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
2107       if (m != NULL) {
2108         java_lang_Class::update_archived_mirror_native_pointers(m);
2109       }
2110     }
2111   }
2112 
2113 public:
2114   static void update_array_klasses(Klass* ak) {
2115     while (ak != NULL) {
2116       update(ak);
2117       ak = ArrayKlass::cast(ak)-&gt;higher_dimension();
2118     }
2119   }
2120 
2121   void do_value(const RunTimeSharedClassInfo* info) {
2122     InstanceKlass* ik = info-&gt;_klass;
2123     update(ik);
2124     update_array_klasses(ik-&gt;array_klasses());
2125   }
2126 };
2127 
2128 void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {
2129   ArchivedMirrorPatcher patcher;
2130   dict-&gt;iterate(&amp;patcher);
2131 }
2132 
2133 void SystemDictionaryShared::update_archived_mirror_native_pointers() {
2134   if (!HeapShared::open_archive_heap_region_mapped()) {
2135     return;
2136   }
2137   if (MetaspaceShared::relocation_delta() == 0) {
2138     return;
2139   }
2140   update_archived_mirror_native_pointers_for(&amp;_builtin_dictionary);
2141   update_archived_mirror_native_pointers_for(&amp;_unregistered_dictionary);
2142 
2143   for (int t = T_BOOLEAN; t &lt;= T_LONG; t++) {
2144     Klass* k = Universe::typeArrayKlassObj((BasicType)t);
2145     ArchivedMirrorPatcher::update_array_klasses(k);
2146   }
2147 }
2148 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
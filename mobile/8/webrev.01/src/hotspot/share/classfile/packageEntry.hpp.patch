diff a/src/hotspot/share/classfile/packageEntry.hpp b/src/hotspot/share/classfile/packageEntry.hpp
--- a/src/hotspot/share/classfile/packageEntry.hpp
+++ b/src/hotspot/share/classfile/packageEntry.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,11 @@
 #ifndef SHARE_CLASSFILE_PACKAGEENTRY_HPP
 #define SHARE_CLASSFILE_PACKAGEENTRY_HPP
 
 #include "classfile/moduleEntry.hpp"
 #include "oops/symbol.hpp"
+#include "runtime/atomic.hpp"
 #include "utilities/growableArray.hpp"
 #include "utilities/hashtable.hpp"
 #include "utilities/macros.hpp"
 #include "utilities/ostream.hpp"
 #if INCLUDE_JFR
@@ -112,17 +113,20 @@
   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
 
   // Initial size of a package entry's list of qualified exports.
   enum {QUAL_EXP_SIZE = 43};
 
+  // a bit map indicating which CDS classpath entries have defined classes in this package.
+  volatile int _defined_by_cds_in_class_path;
 public:
   void init() {
     _module = NULL;
     _export_flags = 0;
     _classpath_index = -1;
     _must_walk_exports = false;
     _qualified_exports = NULL;
+    _defined_by_cds_in_class_path = 0;
   }
 
   // package name
   Symbol*            name() const               { return literal(); }
 
@@ -210,10 +214,28 @@
   void purge_qualified_exports();
   void delete_qualified_exports();
 
   void print(outputStream* st = tty);
   void verify();
+
+  static int max_index_for_defined_in_class_path() {
+    return sizeof(int) * BitsPerByte;
+  }
+
+  bool is_defined_by_cds_in_class_path(int idx) const {
+    assert(idx < max_index_for_defined_in_class_path(), "sanity");
+    return((Atomic::load(&_defined_by_cds_in_class_path) & ((int)1 << idx)) != 0);
+  }
+  void set_defined_by_cds_in_class_path(int idx) {
+    assert(idx < max_index_for_defined_in_class_path(), "sanity");
+    int old_val = 0;
+    int new_val = 0;
+    do {
+      old_val = Atomic::load(&_defined_by_cds_in_class_path);
+      new_val = old_val | ((int)1 << idx);
+    } while (Atomic::cmpxchg(&_defined_by_cds_in_class_path, old_val, new_val) != old_val);
+  }
 };
 
 // The PackageEntryTable is a Hashtable containing a list of all packages defined
 // by a particular class loader.  Each package is represented as a PackageEntry node.
 // The PackageEntryTable's lookup is lock free.

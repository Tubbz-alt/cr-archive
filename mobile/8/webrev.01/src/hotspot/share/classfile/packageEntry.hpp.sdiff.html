<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/packageEntry.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/nativeInst_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/packageEntry.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_PACKAGEENTRY_HPP
 26 #define SHARE_CLASSFILE_PACKAGEENTRY_HPP
 27 
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;

 30 #include &quot;utilities/growableArray.hpp&quot;
 31 #include &quot;utilities/hashtable.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 #include &quot;utilities/ostream.hpp&quot;
 34 #if INCLUDE_JFR
 35 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 36 #endif
 37 
 38 
 39 // A PackageEntry basically represents a Java package.  It contains:
 40 //   - Symbol* containing the package&#39;s name.
 41 //   - ModuleEntry* for this package&#39;s containing module.
 42 //   - a field indicating if the package is exported unqualifiedly or to all
 43 //     unnamed modules.
 44 //   - a growable array containing other module entries that this
 45 //     package is exported to.
 46 //
 47 // Packages can be exported in the following 3 ways:
 48 //   - not exported:        the package does not have qualified or unqualified exports.
 49 //   - qualified exports:   the package has been explicitly qualified to at least
</pre>
<hr />
<pre>
 97 class PackageEntry : public HashtableEntry&lt;Symbol*, mtModule&gt; {
 98 private:
 99   ModuleEntry* _module;
100   // Indicates if package is exported unqualifiedly or to all unnamed. Access to
101   // this field is protected by the Module_lock.
102   int _export_flags;
103   // Used to indicate for packages with classes loaded by the boot loader that
104   // a class in that package has been loaded.  And, for packages with classes
105   // loaded by the boot loader from -Xbootclasspath/a in an unnamed module, it
106   // indicates from which class path entry.
107   s2 _classpath_index;
108   bool _must_walk_exports;
109   // Contains list of modules this package is qualifiedly exported to.  Access
110   // to this list is protected by the Module_lock.
111   GrowableArray&lt;ModuleEntry*&gt;* _qualified_exports;
112   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
113 
114   // Initial size of a package entry&#39;s list of qualified exports.
115   enum {QUAL_EXP_SIZE = 43};
116 


117 public:
118   void init() {
119     _module = NULL;
120     _export_flags = 0;
121     _classpath_index = -1;
122     _must_walk_exports = false;
123     _qualified_exports = NULL;

124   }
125 
126   // package name
127   Symbol*            name() const               { return literal(); }
128 
129   // the module containing the package definition
130   ModuleEntry*       module() const             { return _module; }
131   void               set_module(ModuleEntry* m) { _module = m; }
132 
133   // package&#39;s export state
134   bool is_exported() const { // qualifiedly or unqualifiedly exported
135     assert_locked_or_safepoint(Module_lock);
136     return module()-&gt;is_open() ||
137             ((_export_flags &amp; PKG_EXP_UNQUALIFIED_OR_ALL_UNAMED) != 0) ||
138             has_qual_exports_list();
139   }
140   // Returns true if the package has any explicit qualified exports or is exported to all unnamed
141   bool is_qual_exported() const {
142     assert_locked_or_safepoint(Module_lock);
143     return (has_qual_exports_list() || is_exported_allUnnamed());
</pre>
<hr />
<pre>
195 
196   PackageEntry* next() const {
197     return (PackageEntry*)HashtableEntry&lt;Symbol*, mtModule&gt;::next();
198   }
199 
200   PackageEntry** next_addr() {
201     return (PackageEntry**)HashtableEntry&lt;Symbol*, mtModule&gt;::next_addr();
202   }
203 
204   // iteration of qualified exports
205   void package_exports_do(ModuleClosure* f);
206 
207   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
208 
209   // Purge dead weak references out of exported list when any given class loader is unloaded.
210   void purge_qualified_exports();
211   void delete_qualified_exports();
212 
213   void print(outputStream* st = tty);
214   void verify();


















215 };
216 
217 // The PackageEntryTable is a Hashtable containing a list of all packages defined
218 // by a particular class loader.  Each package is represented as a PackageEntry node.
219 // The PackageEntryTable&#39;s lookup is lock free.
220 //
221 class PackageEntryTable : public Hashtable&lt;Symbol*, mtModule&gt; {
222   friend class VMStructs;
223 public:
224   enum Constants {
225     _packagetable_entry_size = 109  // number of entries in package entry table
226   };
227 
228 private:
229   PackageEntry* new_entry(unsigned int hash, Symbol* name, ModuleEntry* module);
230   void add_entry(int index, PackageEntry* new_entry);
231 
232   int entry_size() const { return BasicHashtable&lt;mtModule&gt;::entry_size(); }
233 
234   PackageEntry** bucket_addr(int i) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_PACKAGEENTRY_HPP
 26 #define SHARE_CLASSFILE_PACKAGEENTRY_HPP
 27 
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;oops/symbol.hpp&quot;
<span class="line-added"> 30 #include &quot;runtime/atomic.hpp&quot;</span>
 31 #include &quot;utilities/growableArray.hpp&quot;
 32 #include &quot;utilities/hashtable.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/ostream.hpp&quot;
 35 #if INCLUDE_JFR
 36 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
 37 #endif
 38 
 39 
 40 // A PackageEntry basically represents a Java package.  It contains:
 41 //   - Symbol* containing the package&#39;s name.
 42 //   - ModuleEntry* for this package&#39;s containing module.
 43 //   - a field indicating if the package is exported unqualifiedly or to all
 44 //     unnamed modules.
 45 //   - a growable array containing other module entries that this
 46 //     package is exported to.
 47 //
 48 // Packages can be exported in the following 3 ways:
 49 //   - not exported:        the package does not have qualified or unqualified exports.
 50 //   - qualified exports:   the package has been explicitly qualified to at least
</pre>
<hr />
<pre>
 98 class PackageEntry : public HashtableEntry&lt;Symbol*, mtModule&gt; {
 99 private:
100   ModuleEntry* _module;
101   // Indicates if package is exported unqualifiedly or to all unnamed. Access to
102   // this field is protected by the Module_lock.
103   int _export_flags;
104   // Used to indicate for packages with classes loaded by the boot loader that
105   // a class in that package has been loaded.  And, for packages with classes
106   // loaded by the boot loader from -Xbootclasspath/a in an unnamed module, it
107   // indicates from which class path entry.
108   s2 _classpath_index;
109   bool _must_walk_exports;
110   // Contains list of modules this package is qualifiedly exported to.  Access
111   // to this list is protected by the Module_lock.
112   GrowableArray&lt;ModuleEntry*&gt;* _qualified_exports;
113   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
114 
115   // Initial size of a package entry&#39;s list of qualified exports.
116   enum {QUAL_EXP_SIZE = 43};
117 
<span class="line-added">118   // a bit map indicating which CDS classpath entries have defined classes in this package.</span>
<span class="line-added">119   volatile int _defined_by_cds_in_class_path;</span>
120 public:
121   void init() {
122     _module = NULL;
123     _export_flags = 0;
124     _classpath_index = -1;
125     _must_walk_exports = false;
126     _qualified_exports = NULL;
<span class="line-added">127     _defined_by_cds_in_class_path = 0;</span>
128   }
129 
130   // package name
131   Symbol*            name() const               { return literal(); }
132 
133   // the module containing the package definition
134   ModuleEntry*       module() const             { return _module; }
135   void               set_module(ModuleEntry* m) { _module = m; }
136 
137   // package&#39;s export state
138   bool is_exported() const { // qualifiedly or unqualifiedly exported
139     assert_locked_or_safepoint(Module_lock);
140     return module()-&gt;is_open() ||
141             ((_export_flags &amp; PKG_EXP_UNQUALIFIED_OR_ALL_UNAMED) != 0) ||
142             has_qual_exports_list();
143   }
144   // Returns true if the package has any explicit qualified exports or is exported to all unnamed
145   bool is_qual_exported() const {
146     assert_locked_or_safepoint(Module_lock);
147     return (has_qual_exports_list() || is_exported_allUnnamed());
</pre>
<hr />
<pre>
199 
200   PackageEntry* next() const {
201     return (PackageEntry*)HashtableEntry&lt;Symbol*, mtModule&gt;::next();
202   }
203 
204   PackageEntry** next_addr() {
205     return (PackageEntry**)HashtableEntry&lt;Symbol*, mtModule&gt;::next_addr();
206   }
207 
208   // iteration of qualified exports
209   void package_exports_do(ModuleClosure* f);
210 
211   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
212 
213   // Purge dead weak references out of exported list when any given class loader is unloaded.
214   void purge_qualified_exports();
215   void delete_qualified_exports();
216 
217   void print(outputStream* st = tty);
218   void verify();
<span class="line-added">219 </span>
<span class="line-added">220   static int max_index_for_defined_in_class_path() {</span>
<span class="line-added">221     return sizeof(int) * BitsPerByte;</span>
<span class="line-added">222   }</span>
<span class="line-added">223 </span>
<span class="line-added">224   bool is_defined_by_cds_in_class_path(int idx) const {</span>
<span class="line-added">225     assert(idx &lt; max_index_for_defined_in_class_path(), &quot;sanity&quot;);</span>
<span class="line-added">226     return((Atomic::load(&amp;_defined_by_cds_in_class_path) &amp; ((int)1 &lt;&lt; idx)) != 0);</span>
<span class="line-added">227   }</span>
<span class="line-added">228   void set_defined_by_cds_in_class_path(int idx) {</span>
<span class="line-added">229     assert(idx &lt; max_index_for_defined_in_class_path(), &quot;sanity&quot;);</span>
<span class="line-added">230     int old_val = 0;</span>
<span class="line-added">231     int new_val = 0;</span>
<span class="line-added">232     do {</span>
<span class="line-added">233       old_val = Atomic::load(&amp;_defined_by_cds_in_class_path);</span>
<span class="line-added">234       new_val = old_val | ((int)1 &lt;&lt; idx);</span>
<span class="line-added">235     } while (Atomic::cmpxchg(&amp;_defined_by_cds_in_class_path, old_val, new_val) != old_val);</span>
<span class="line-added">236   }</span>
237 };
238 
239 // The PackageEntryTable is a Hashtable containing a list of all packages defined
240 // by a particular class loader.  Each package is represented as a PackageEntry node.
241 // The PackageEntryTable&#39;s lookup is lock free.
242 //
243 class PackageEntryTable : public Hashtable&lt;Symbol*, mtModule&gt; {
244   friend class VMStructs;
245 public:
246   enum Constants {
247     _packagetable_entry_size = 109  // number of entries in package entry table
248   };
249 
250 private:
251   PackageEntry* new_entry(unsigned int hash, Symbol* name, ModuleEntry* module);
252   void add_entry(int index, PackageEntry* new_entry);
253 
254   int entry_size() const { return BasicHashtable&lt;mtModule&gt;::entry_size(); }
255 
256   PackageEntry** bucket_addr(int i) {
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/nativeInst_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
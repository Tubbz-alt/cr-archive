<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;
  27 #include &quot;gc/g1/g1Arguments.hpp&quot;
  28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  30 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  33 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  34 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;
  35 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  36 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  37 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  38 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  39 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  40 #include &quot;gc/g1/g1Policy.hpp&quot;
  41 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  42 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  43 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  44 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  45 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  46 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  47 #include &quot;logging/log.hpp&quot;
  48 #include &quot;runtime/arguments.hpp&quot;
  49 #include &quot;runtime/globals.hpp&quot;
  50 #include &quot;runtime/java.hpp&quot;
  51 #include &quot;runtime/mutexLocker.hpp&quot;
  52 #include &quot;utilities/debug.hpp&quot;
  53 #include &quot;utilities/growableArray.hpp&quot;
  54 #include &quot;utilities/pair.hpp&quot;
  55 
  56 G1Policy::G1Policy(STWGCTimer* gc_timer) :
  57   _predictor(G1ConfidencePercent / 100.0),
  58   _analytics(new G1Analytics(&amp;_predictor)),
  59   _remset_tracker(),
  60   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  61   _ihop_control(create_ihop_control(&amp;_predictor)),
  62   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  63   _full_collection_start_sec(0.0),
  64   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
  65   _young_list_desired_length(0),
  66   _young_list_target_length(0),
  67   _young_list_max_length(0),
  68   _eden_surv_rate_group(new G1SurvRateGroup()),
  69   _survivor_surv_rate_group(new G1SurvRateGroup()),
  70   _reserve_factor((double) G1ReservePercent / 100.0),
  71   _reserve_regions(0),
  72   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),
  73   _free_regions_at_end_of_collection(0),
  74   _rs_length(0),
  75   _rs_length_prediction(0),
  76   _pending_cards_at_gc_start(0),
  77   _old_gen_alloc_tracker(),
  78   _initial_mark_to_mixed(),
  79   _collection_set(NULL),
  80   _g1h(NULL),
  81   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  82   _mark_remark_start_sec(0),
  83   _mark_cleanup_start_sec(0),
  84   _tenuring_threshold(MaxTenuringThreshold),
  85   _max_survivor_regions(0),
  86   _survivors_age_table(true)
  87 {
  88 }
  89 
  90 G1Policy::~G1Policy() {
  91   delete _ihop_control;
  92   delete _young_gen_sizer;
  93 }
  94 
  95 G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {
  96   if (G1Arguments::is_heterogeneous_heap()) {
  97     return new G1HeterogeneousHeapPolicy(gc_timer_stw);
  98   } else {
  99     return new G1Policy(gc_timer_stw);
 100   }
 101 }
 102 
 103 G1CollectorState* G1Policy::collector_state() const { return _g1h-&gt;collector_state(); }
 104 
 105 void G1Policy::init(G1CollectedHeap* g1h, G1CollectionSet* collection_set) {
 106   _g1h = g1h;
 107   _collection_set = collection_set;
 108 
 109   assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
 110 
 111   _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
 112 
 113   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 114 
 115   update_young_length_bounds();
 116   // We may immediately start allocating regions and placing them on the
 117   // collection set list. Initialize the per-collection set info
 118   _collection_set-&gt;start_incremental_building();
 119 }
 120 
 121 void G1Policy::note_gc_start() {
 122   phase_times()-&gt;note_gc_start();
 123 }
 124 
 125 class G1YoungLengthPredictor {
 126   const double _base_time_ms;
 127   const double _base_free_regions;
 128   const double _target_pause_time_ms;
 129   const G1Policy* const _policy;
 130 
 131  public:
 132   G1YoungLengthPredictor(double base_time_ms,
 133                          double base_free_regions,
 134                          double target_pause_time_ms,
 135                          const G1Policy* policy) :
 136     _base_time_ms(base_time_ms),
 137     _base_free_regions(base_free_regions),
 138     _target_pause_time_ms(target_pause_time_ms),
 139     _policy(policy) {}
 140 
 141   bool will_fit(uint young_length) const {
 142     if (young_length &gt;= _base_free_regions) {
 143       // end condition 1: not enough space for the young regions
 144       return false;
 145     }
 146 
 147     size_t bytes_to_copy = 0;
 148     const double copy_time_ms = _policy-&gt;predict_eden_copy_time_ms(young_length, &amp;bytes_to_copy);
 149     const double young_other_time_ms = _policy-&gt;analytics()-&gt;predict_young_other_time_ms(young_length);
 150     const double pause_time_ms = _base_time_ms + copy_time_ms + young_other_time_ms;
 151     if (pause_time_ms &gt; _target_pause_time_ms) {
 152       // end condition 2: prediction is over the target pause time
 153       return false;
 154     }
 155 
 156     const size_t free_bytes = (_base_free_regions - young_length) * HeapRegion::GrainBytes;
 157 
 158     // When copying, we will likely need more bytes free than is live in the region.
 159     // Add some safety margin to factor in the confidence of our guess, and the
 160     // natural expected waste.
 161     // (100.0 / G1ConfidencePercent) is a scale factor that expresses the uncertainty
 162     // of the calculation: the lower the confidence, the more headroom.
 163     // (100 + TargetPLABWastePct) represents the increase in expected bytes during
 164     // copying due to anticipated waste in the PLABs.
 165     const double safety_factor = (100.0 / G1ConfidencePercent) * (100 + TargetPLABWastePct) / 100.0;
 166     const size_t expected_bytes_to_copy = (size_t)(safety_factor * bytes_to_copy);
 167 
 168     if (expected_bytes_to_copy &gt; free_bytes) {
 169       // end condition 3: out-of-space
 170       return false;
 171     }
 172 
 173     // success!
 174     return true;
 175   }
 176 };
 177 
 178 void G1Policy::record_new_heap_size(uint new_number_of_regions) {
 179   // re-calculate the necessary reserve
 180   double reserve_regions_d = (double) new_number_of_regions * _reserve_factor;
 181   // We use ceiling so that if reserve_regions_d is &gt; 0.0 (but
 182   // smaller than 1.0) we&#39;ll get 1.
 183   _reserve_regions = (uint) ceil(reserve_regions_d);
 184 
 185   _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
 186 
 187   _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
 188 }
 189 
 190 uint G1Policy::calculate_desired_eden_length_by_mmu() const {
 191   // One could argue that any useful eden length to keep any MMU would be 1, but
 192   // in theory this is possible. Other constraints enforce a minimum eden of 1
 193   // anyway.
 194   uint desired_min_length = 0;
 195   if (use_adaptive_young_list_length()) {
 196     double now_sec = os::elapsedTime();
 197     double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;
 198     double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();
 199     desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);
 200   }
 201   return desired_min_length;
 202 }
 203 
 204 void G1Policy::update_young_length_bounds() {
 205   update_young_length_bounds(_analytics-&gt;predict_rs_length());
 206 }
 207 
 208 void G1Policy::update_young_length_bounds(size_t rs_length) {
 209   _young_list_desired_length = calculate_young_desired_length(rs_length);
 210   _young_list_target_length = calculate_young_target_length(_young_list_desired_length);
 211   _young_list_max_length = calculate_young_max_length(_young_list_target_length);
 212 
 213   log_debug(gc,ergo,heap)(&quot;Young list lengths: desired: %u, target: %u, max: %u&quot;,
 214                           _young_list_desired_length,
 215                           _young_list_target_length,
 216                           _young_list_max_length);
 217 }
 218 
 219 // Calculates desired young gen length. It is calculated from:
 220 //
 221 // - sizer min/max bounds on young gen
 222 // - pause time goal for whole young gen evacuation
 223 // - MMU goal influencing eden to make GCs spaced apart.
 224 // - a minimum one eden region length.
 225 //
 226 // We may enter with already allocated eden and survivor regions, that may be
 227 // higher than the maximum, or the above goals may result in a desired value
 228 // smaller than are already allocated.
 229 // The main reason is revising young length, with our without the GCLocker being
 230 // active.
 231 //
 232 uint G1Policy::calculate_young_desired_length(size_t rs_length) const {
 233   uint min_young_length_by_sizer = _young_gen_sizer-&gt;min_desired_young_length();
 234   uint max_young_length_by_sizer = _young_gen_sizer-&gt;max_desired_young_length();
 235 
 236   assert(min_young_length_by_sizer &gt;= 1, &quot;invariant&quot;);
 237   assert(max_young_length_by_sizer &gt;= min_young_length_by_sizer, &quot;invariant&quot;);
 238 
 239   // Absolute minimum eden length.
 240   // Enforcing a minimum eden length helps at startup when the predictors are not
 241   // yet trained on the application to avoid unnecessary (but very short) full gcs
 242   // on very small (initial) heaps.
 243   uint const MinDesiredEdenLength = 1;
 244 
 245   // Calculate the absolute and desired min bounds first.
 246 
 247   // This is how many survivor regions we already have.
 248   const uint survivor_length = _g1h-&gt;survivor_regions_count();
 249   // Size of the already allocated young gen.
 250   const uint allocated_young_length = _g1h-&gt;young_regions_count();
 251   // This is the absolute minimum young length that we can return. Ensure that we
 252   // don&#39;t go below any user-defined minimum bound; but we might have already
 253   // allocated more than that for reasons. In this case, use that.
 254   uint absolute_min_young_length = MAX2(allocated_young_length, min_young_length_by_sizer);
 255   // Calculate the absolute max bounds. After evac failure or when revising the
 256   // young length we might have exceeded absolute min length or absolute_max_length,
 257   // so adjust the result accordingly.
 258   uint absolute_max_young_length = MAX2(max_young_length_by_sizer, absolute_min_young_length);
 259 
 260   uint desired_eden_length_by_mmu = 0;
 261   uint desired_eden_length_by_pause = 0;
 262   uint desired_eden_length_before_mixed = 0;
 263 
 264   uint desired_young_length = 0;
 265   if (use_adaptive_young_list_length()) {
 266     desired_eden_length_by_mmu = calculate_desired_eden_length_by_mmu();
 267 
 268     const size_t pending_cards = _analytics-&gt;predict_pending_cards();
 269     double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);
 270 
 271     if (!next_gc_should_be_mixed(NULL, NULL)) {
 272       desired_eden_length_by_pause =
 273         calculate_desired_eden_length_by_pause(survivor_base_time_ms,
 274                                                absolute_min_young_length - survivor_length,
 275                                                absolute_max_young_length - survivor_length);
 276     } else {
 277       desired_eden_length_before_mixed =
 278         calculate_desired_eden_length_before_mixed(survivor_base_time_ms,
 279                                                    absolute_min_young_length - survivor_length,
 280                                                    absolute_max_young_length - survivor_length);
 281     }
 282     // Above either sets desired_eden_length_by_pause or desired_eden_length_before_mixed,
 283     // the other is zero. Use the one that has been set below.
 284     uint desired_eden_length = MAX2(desired_eden_length_by_pause,
 285                                     desired_eden_length_before_mixed);
 286 
 287     // Finally incorporate MMU concerns; assume that it overrides the pause time
 288     // goal, as the default value has been chosen to effectively disable it.
 289     // Also request at least one eden region, see above for reasons.
 290     desired_eden_length = MAX3(desired_eden_length,
 291                                desired_eden_length_by_mmu,
 292                                MinDesiredEdenLength);
 293 
 294     desired_young_length = desired_eden_length + survivor_length;
 295   } else {
 296     // The user asked for a fixed young gen so we&#39;ll fix the young gen
 297     // whether the next GC is young or mixed.
 298     desired_young_length = min_young_length_by_sizer;
 299   }
 300   // Clamp to absolute min/max after we determined desired lengths.
 301   desired_young_length = clamp(desired_young_length, absolute_min_young_length, absolute_max_young_length);
 302 
 303   log_trace(gc, ergo, heap)(&quot;Young desired length %u &quot;
 304                             &quot;survivor length %u &quot;
 305                             &quot;allocated young length %u &quot;
 306                             &quot;absolute min young length %u &quot;
 307                             &quot;absolute max young length %u &quot;
 308                             &quot;desired eden length by mmu %u &quot;
 309                             &quot;desired eden length by pause %u &quot;
 310                             &quot;desired eden length before mixed %u&quot;
 311                             &quot;desired eden length by default %u&quot;,
 312                             desired_young_length, survivor_length,
 313                             allocated_young_length, absolute_min_young_length,
 314                             absolute_max_young_length, desired_eden_length_by_mmu,
 315                             desired_eden_length_by_pause,
 316                             desired_eden_length_before_mixed,
 317                             MinDesiredEdenLength);
 318 
 319   assert(desired_young_length &gt;= allocated_young_length, &quot;must be&quot;);
 320   return desired_young_length;
 321 }
 322 
 323 // Limit the desired (wished) young length by current free regions. If the request
 324 // can be satisfied without using up reserve regions, do so, otherwise eat into
 325 // the reserve, giving away at most what the heap sizer allows.
 326 uint G1Policy::calculate_young_target_length(uint desired_young_length) const {
 327   uint allocated_young_length = _g1h-&gt;young_regions_count();
 328 
 329   uint receiving_additional_eden;
 330   if (allocated_young_length &gt;= desired_young_length) {
 331     // Already used up all we actually want (may happen as G1 revises the
 332     // young list length concurrently, or caused by gclocker). Do not allow more,
 333     // potentially resulting in GC.
 334     receiving_additional_eden = 0;
 335     log_trace(gc, ergo, heap)(&quot;Young target length: Already used up desired young %u allocated %u&quot;,
 336                               desired_young_length,
 337                               allocated_young_length);
 338   } else {
 339     // Now look at how many free regions are there currently, and the heap reserve.
 340     // We will try our best not to &quot;eat&quot; into the reserve as long as we can. If we
 341     // do, we at most eat the sizer&#39;s minimum regions into the reserve or half the
 342     // reserve rounded up (if possible; this is an arbitrary value).
 343 
 344     uint max_to_eat_into_reserve = MIN2(_young_gen_sizer-&gt;min_desired_young_length(),
 345                                         (_reserve_regions + 1) / 2);
 346 
 347     log_trace(gc, ergo, heap)(&quot;Young target length: Common &quot;
 348                               &quot;free regions at end of collection %u &quot;
 349                               &quot;desired young length %u &quot;
 350                               &quot;reserve region %u &quot;
 351                               &quot;max to eat into reserve %u&quot;,
 352                               _free_regions_at_end_of_collection,
 353                               desired_young_length,
 354                               _reserve_regions,
 355                               max_to_eat_into_reserve);
 356 
 357     if (_free_regions_at_end_of_collection &lt;= _reserve_regions) {
 358       // Fully eat (or already eating) into the reserve, hand back at most absolute_min_length regions.
 359       uint receiving_young = MIN3(_free_regions_at_end_of_collection,
 360                                   desired_young_length,
 361                                   max_to_eat_into_reserve);
 362       // We could already have allocated more regions than what we could get
 363       // above.
 364       receiving_additional_eden = allocated_young_length &lt; receiving_young ?
 365                                   receiving_young - allocated_young_length : 0;
 366 
 367       log_trace(gc, ergo, heap)(&quot;Young target length: Fully eat into reserve &quot;
 368                                 &quot;receiving young %u receiving additional eden %u&quot;,
 369                                 receiving_young,
 370                                 receiving_additional_eden);
 371     } else if (_free_regions_at_end_of_collection &lt; (desired_young_length + _reserve_regions)) {
 372       // Partially eat into the reserve, at most max_to_eat_into_reserve regions.
 373       uint free_outside_reserve = _free_regions_at_end_of_collection - _reserve_regions;
 374       assert(free_outside_reserve &lt; desired_young_length,
 375              &quot;must be %u %u&quot;,
 376              free_outside_reserve, desired_young_length);
 377 
 378       uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,
 379                                            max_to_eat_into_reserve);
 380       uint receiving_young = free_outside_reserve + receiving_within_reserve;
 381       // Again, we could have already allocated more than we could get.
 382       receiving_additional_eden = allocated_young_length &lt; receiving_young ?
 383                                   receiving_young - allocated_young_length : 0;
 384 
 385       log_trace(gc, ergo, heap)(&quot;Young target length: Partially eat into reserve &quot;
 386                                 &quot;free outside reserve %u &quot;
 387                                 &quot;receiving within reserve %u &quot;
 388                                 &quot;receiving young %u &quot;
 389                                 &quot;receiving additional eden %u&quot;,
 390                                 free_outside_reserve, receiving_within_reserve,
 391                                 receiving_young, receiving_additional_eden);
 392     } else {
 393       // No need to use the reserve.
 394       receiving_additional_eden = desired_young_length - allocated_young_length;
 395       log_trace(gc, ergo, heap)(&quot;Young target length: No need to use reserve &quot;
 396                                 &quot;receiving additional eden %u&quot;,
 397                                 receiving_additional_eden);
 398     }
 399   }
 400 
 401   uint target_young_length = allocated_young_length + receiving_additional_eden;
 402 
 403   assert(target_young_length &gt;= allocated_young_length, &quot;must be&quot;);
 404 
 405   log_trace(gc, ergo, heap)(&quot;Young target length: &quot;
 406                             &quot;young target length %u &quot;
 407                             &quot;allocated young length %u &quot;
 408                             &quot;received additional eden %u&quot;,
 409                             target_young_length, allocated_young_length,
 410                             receiving_additional_eden);
 411   return target_young_length;
 412 }
 413 
 414 uint G1Policy::calculate_desired_eden_length_by_pause(double base_time_ms,
 415                                                       uint min_eden_length,
 416                                                       uint max_eden_length) const {
 417   assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);
 418 
 419   assert(min_eden_length &lt;= max_eden_length, &quot;must be %u %u&quot;, min_eden_length, max_eden_length);
 420 
 421   // Here, we will make sure that the shortest young length that
 422   // makes sense fits within the target pause time.
 423 
 424   G1YoungLengthPredictor p(base_time_ms,
 425                            _free_regions_at_end_of_collection,
 426                            _mmu_tracker-&gt;max_gc_time() * 1000.0,
 427                            this);
 428   if (p.will_fit(min_eden_length)) {
 429     // The shortest young length will fit into the target pause time;
 430     // we&#39;ll now check whether the absolute maximum number of young
 431     // regions will fit in the target pause time. If not, we&#39;ll do
 432     // a binary search between min_young_length and max_young_length.
 433     if (p.will_fit(max_eden_length)) {
 434       // The maximum young length will fit into the target pause time.
 435       // We are done so set min young length to the maximum length (as
 436       // the result is assumed to be returned in min_young_length).
 437       min_eden_length = max_eden_length;
 438     } else {
 439       // The maximum possible number of young regions will not fit within
 440       // the target pause time so we&#39;ll search for the optimal
 441       // length. The loop invariants are:
 442       //
 443       // min_young_length &lt; max_young_length
 444       // min_young_length is known to fit into the target pause time
 445       // max_young_length is known not to fit into the target pause time
 446       //
 447       // Going into the loop we know the above hold as we&#39;ve just
 448       // checked them. Every time around the loop we check whether
 449       // the middle value between min_young_length and
 450       // max_young_length fits into the target pause time. If it
 451       // does, it becomes the new min. If it doesn&#39;t, it becomes
 452       // the new max. This way we maintain the loop invariants.
 453 
 454       assert(min_eden_length &lt; max_eden_length, &quot;invariant&quot;);
 455       uint diff = (max_eden_length - min_eden_length) / 2;
 456       while (diff &gt; 0) {
 457         uint eden_length = min_eden_length + diff;
 458         if (p.will_fit(eden_length)) {
 459           min_eden_length = eden_length;
 460         } else {
 461           max_eden_length = eden_length;
 462         }
 463         assert(min_eden_length &lt;  max_eden_length, &quot;invariant&quot;);
 464         diff = (max_eden_length - min_eden_length) / 2;
 465       }
 466       // The results is min_young_length which, according to the
 467       // loop invariants, should fit within the target pause time.
 468 
 469       // These are the post-conditions of the binary search above:
 470       assert(min_eden_length &lt; max_eden_length,
 471              &quot;otherwise we should have discovered that max_eden_length &quot;
 472              &quot;fits into the pause target and not done the binary search&quot;);
 473       assert(p.will_fit(min_eden_length),
 474              &quot;min_eden_length, the result of the binary search, should &quot;
 475              &quot;fit into the pause target&quot;);
 476       assert(!p.will_fit(min_eden_length + 1),
 477              &quot;min_eden_length, the result of the binary search, should be &quot;
 478              &quot;optimal, so no larger length should fit into the pause target&quot;);
 479     }
 480   } else {
 481     // Even the minimum length doesn&#39;t fit into the pause time
 482     // target, return it as the result nevertheless.
 483   }
 484   return min_eden_length;
 485 }
 486 
 487 uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,
 488                                                           uint min_eden_length,
 489                                                           uint max_eden_length) const {
 490   G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
 491 
 492   uint min_old_regions_end = MIN2(candidates-&gt;cur_idx() + calc_min_old_cset_length(), candidates-&gt;num_regions());
 493   double predicted_region_evac_time_ms = survivor_base_time_ms;
 494   for (uint i = candidates-&gt;cur_idx(); i &lt; min_old_regions_end; i++) {
 495     HeapRegion* r = candidates-&gt;at(i);
 496     predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);
 497   }
 498   uint desired_eden_length_by_min_cset_length =
 499      calculate_desired_eden_length_by_pause(predicted_region_evac_time_ms,
 500                                             min_eden_length,
 501                                             max_eden_length);
 502 
 503   return desired_eden_length_by_min_cset_length;
 504 }
 505 
 506 double G1Policy::predict_survivor_regions_evac_time() const {
 507   double survivor_regions_evac_time = 0.0;
 508   const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
 509   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivor_regions-&gt;begin();
 510        it != survivor_regions-&gt;end();
 511        ++it) {
 512     survivor_regions_evac_time += predict_region_total_time_ms(*it, collector_state()-&gt;in_young_only_phase());
 513   }
 514   return survivor_regions_evac_time;
 515 }
 516 
 517 void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_length) {
 518   guarantee(use_adaptive_young_list_length(), &quot;should not call this otherwise&quot; );
 519 
 520   if (rs_length &gt; _rs_length_prediction) {
 521     // add 10% to avoid having to recalculate often
 522     size_t rs_length_prediction = rs_length * 1100 / 1000;
 523     update_rs_length_prediction(rs_length_prediction);
 524     update_young_length_bounds(rs_length_prediction);
 525   }
 526 }
 527 
 528 void G1Policy::update_rs_length_prediction() {
 529   update_rs_length_prediction(_analytics-&gt;predict_rs_length());
 530 }
 531 
 532 void G1Policy::update_rs_length_prediction(size_t prediction) {
 533   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {
 534     _rs_length_prediction = prediction;
 535   }
 536 }
 537 
 538 void G1Policy::record_full_collection_start() {
 539   _full_collection_start_sec = os::elapsedTime();
 540   // Release the future to-space so that it is available for compaction into.
 541   collector_state()-&gt;set_in_young_only_phase(false);
 542   collector_state()-&gt;set_in_full_gc(true);
 543   _collection_set-&gt;clear_candidates();
 544   _pending_cards_at_gc_start = 0;
 545 }
 546 
 547 void G1Policy::record_full_collection_end() {
 548   // Consider this like a collection pause for the purposes of allocation
 549   // since last pause.
 550   double end_sec = os::elapsedTime();
 551   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 552   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 553 
 554   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 555 
 556   collector_state()-&gt;set_in_full_gc(false);
 557 
 558   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 559   // transitions and make sure we start with young GCs after the Full GC.
 560   collector_state()-&gt;set_in_young_only_phase(true);
 561   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 562   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 563   collector_state()-&gt;set_in_initial_mark_gc(false);
 564   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 565   collector_state()-&gt;set_clearing_next_bitmap(false);
 566 
 567   _eden_surv_rate_group-&gt;start_adding_regions();
 568   // also call this on any additional surv rate groups
 569 
 570   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 571   _survivor_surv_rate_group-&gt;reset();
 572   update_young_length_bounds();
 573   update_rs_length_prediction();
 574 
 575   _old_gen_alloc_tracker.reset_after_full_gc();
 576 
 577   record_pause(FullGC, _full_collection_start_sec, end_sec);
 578 }
 579 
 580 static void log_refinement_stats(const char* kind, const G1ConcurrentRefineStats&amp; stats) {
 581   log_debug(gc, refine, stats)
 582            (&quot;%s refinement: %.2fms, refined: &quot; SIZE_FORMAT
 583             &quot;, precleaned: &quot; SIZE_FORMAT &quot;, dirtied: &quot; SIZE_FORMAT,
 584             kind,
 585             stats.refinement_time().seconds() * MILLIUNITS,
 586             stats.refined_cards(),
 587             stats.precleaned_cards(),
 588             stats.dirtied_cards());
 589 }
 590 
 591 void G1Policy::record_concurrent_refinement_stats() {
 592   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
 593   _pending_cards_at_gc_start = dcqs.num_cards();
 594 
 595   // Collect per-thread stats, mostly from mutator activity.
 596   G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();
 597 
 598   // Collect specialized concurrent refinement thread stats.
 599   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();
 600   G1ConcurrentRefineStats cr_stats = cr-&gt;get_and_reset_refinement_stats();
 601 
 602   G1ConcurrentRefineStats total_stats = mut_stats + cr_stats;
 603 
 604   log_refinement_stats(&quot;Mutator&quot;, mut_stats);
 605   log_refinement_stats(&quot;Concurrent&quot;, cr_stats);
 606   log_refinement_stats(&quot;Total&quot;, total_stats);
 607 
 608   // Record the rate at which cards were refined.
 609   // Don&#39;t update the rate if the current sample is empty or time is zero.
 610   Tickspan refinement_time = total_stats.refinement_time();
 611   size_t refined_cards = total_stats.refined_cards();
 612   if ((refined_cards &gt; 0) &amp;&amp; (refinement_time &gt; Tickspan())) {
 613     double rate = refined_cards / (refinement_time.seconds() * MILLIUNITS);
 614     _analytics-&gt;report_concurrent_refine_rate_ms(rate);
 615     log_debug(gc, refine, stats)(&quot;Concurrent refinement rate: %.2f cards/ms&quot;, rate);
 616   }
 617 
 618   // Record mutator&#39;s card logging rate.
 619   double mut_start_time = _analytics-&gt;prev_collection_pause_end_ms();
 620   double mut_end_time = phase_times()-&gt;cur_collection_start_sec() * MILLIUNITS;
 621   double mut_time = mut_end_time - mut_start_time;
 622   // Unlike above for conc-refine rate, here we should not require a
 623   // non-empty sample, since an application could go some time with only
 624   // young-gen or filtered out writes.  But we&#39;ll ignore unusually short
 625   // sample periods, as they may just pollute the predictions.
 626   if (mut_time &gt; 1.0) {   // Require &gt; 1ms sample time.
 627     double dirtied_rate = total_stats.dirtied_cards() / mut_time;
 628     _analytics-&gt;report_dirtied_cards_rate_ms(dirtied_rate);
 629     log_debug(gc, refine, stats)(&quot;Generate dirty cards rate: %.2f cards/ms&quot;, dirtied_rate);
 630   }
 631 }
 632 
 633 void G1Policy::record_collection_pause_start(double start_time_sec) {
 634   // We only need to do this here as the policy will only be applied
 635   // to the GC we&#39;re about to start. so, no point is calculating this
 636   // every time we calculate / recalculate the target young length.
 637   update_survivors_policy();
 638 
 639   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 640          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 641          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
 642   assert_used_and_recalculate_used_equal(_g1h);
 643 
 644   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
 645 
 646   record_concurrent_refinement_stats();
 647 
 648   _collection_set-&gt;reset_bytes_used_before();
 649 
 650   // do that for any other surv rate groups
 651   _eden_surv_rate_group-&gt;stop_adding_regions();
 652   _survivors_age_table.clear();
 653 
 654   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 655 }
 656 
 657 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 658   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 659   collector_state()-&gt;set_in_initial_mark_gc(false);
 660 }
 661 
 662 void G1Policy::record_concurrent_mark_remark_start() {
 663   _mark_remark_start_sec = os::elapsedTime();
 664 }
 665 
 666 void G1Policy::record_concurrent_mark_remark_end() {
 667   double end_time_sec = os::elapsedTime();
 668   double elapsed_time_ms = (end_time_sec - _mark_remark_start_sec)*1000.0;
 669   _analytics-&gt;report_concurrent_mark_remark_times_ms(elapsed_time_ms);
 670   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
 671 
 672   record_pause(Remark, _mark_remark_start_sec, end_time_sec);
 673 }
 674 
 675 void G1Policy::record_concurrent_mark_cleanup_start() {
 676   _mark_cleanup_start_sec = os::elapsedTime();
 677 }
 678 
 679 double G1Policy::average_time_ms(G1GCPhaseTimes::GCParPhases phase) const {
 680   return phase_times()-&gt;average_time_ms(phase);
 681 }
 682 
 683 double G1Policy::young_other_time_ms() const {
 684   return phase_times()-&gt;young_cset_choice_time_ms() +
 685          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::YoungFreeCSet);
 686 }
 687 
 688 double G1Policy::non_young_other_time_ms() const {
 689   return phase_times()-&gt;non_young_cset_choice_time_ms() +
 690          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::NonYoungFreeCSet);
 691 }
 692 
 693 double G1Policy::other_time_ms(double pause_time_ms) const {
 694   return pause_time_ms - phase_times()-&gt;cur_collection_par_time_ms();
 695 }
 696 
 697 double G1Policy::constant_other_time_ms(double pause_time_ms) const {
 698   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms() - phase_times()-&gt;total_rebuild_freelist_time_ms();
 699 }
 700 
 701 bool G1Policy::about_to_start_mixed_phase() const {
 702   return _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle() || collector_state()-&gt;in_young_gc_before_mixed();
 703 }
 704 
 705 bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
 706   if (about_to_start_mixed_phase()) {
 707     return false;
 708   }
 709 
 710   size_t marking_initiating_used_threshold = _ihop_control-&gt;get_conc_mark_start_threshold();
 711 
 712   size_t cur_used_bytes = _g1h-&gt;non_young_capacity_bytes();
 713   size_t alloc_byte_size = alloc_word_size * HeapWordSize;
 714   size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;
 715 
 716   bool result = false;
 717   if (marking_request_bytes &gt; marking_initiating_used_threshold) {
 718     result = collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;in_young_gc_before_mixed();
 719     log_debug(gc, ergo, ihop)(&quot;%s occupancy: &quot; SIZE_FORMAT &quot;B allocation request: &quot; SIZE_FORMAT &quot;B threshold: &quot; SIZE_FORMAT &quot;B (%1.2f) source: %s&quot;,
 720                               result ? &quot;Request concurrent cycle initiation (occupancy higher than threshold)&quot; : &quot;Do not request concurrent cycle initiation (still doing mixed collections)&quot;,
 721                               cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold / _g1h-&gt;capacity() * 100, source);
 722   }
 723 
 724   return result;
 725 }
 726 
 727 double G1Policy::logged_cards_processing_time() const {
 728   double all_cards_processing_time = average_time_ms(G1GCPhaseTimes::ScanHR) + average_time_ms(G1GCPhaseTimes::OptScanHR);
 729   size_t logged_dirty_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);
 730   size_t scan_heap_roots_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
 731                                  phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
 732   // This may happen if there are duplicate cards in different log buffers.
 733   if (logged_dirty_cards &gt; scan_heap_roots_cards) {
 734     return all_cards_processing_time + average_time_ms(G1GCPhaseTimes::MergeLB);
 735   }
 736   return (all_cards_processing_time * logged_dirty_cards / scan_heap_roots_cards) + average_time_ms(G1GCPhaseTimes::MergeLB);
 737 }
 738 
 739 // Anything below that is considered to be zero
 740 #define MIN_TIMER_GRANULARITY 0.0000001
 741 
 742 void G1Policy::record_collection_pause_end(double pause_time_ms) {
 743   G1GCPhaseTimes* p = phase_times();
 744 
 745   double end_time_sec = os::elapsedTime();
 746 
 747   bool this_pause_included_initial_mark = false;
 748   bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();
 749 
 750   bool update_stats = !_g1h-&gt;evacuation_failed();
 751 
 752   record_pause(young_gc_pause_kind(), end_time_sec - pause_time_ms / 1000.0, end_time_sec);
 753 
 754   _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
 755 
 756   this_pause_included_initial_mark = collector_state()-&gt;in_initial_mark_gc();
 757   if (this_pause_included_initial_mark) {
 758     record_concurrent_mark_init_end(0.0);
 759   } else {
 760     maybe_start_marking();
 761   }
 762 
 763   double app_time_ms = (phase_times()-&gt;cur_collection_start_sec() * 1000.0 - _analytics-&gt;prev_collection_pause_end_ms());
 764   if (app_time_ms &lt; MIN_TIMER_GRANULARITY) {
 765     // This usually happens due to the timer not having the required
 766     // granularity. Some Linuxes are the usual culprits.
 767     // We&#39;ll just set it to something (arbitrarily) small.
 768     app_time_ms = 1.0;
 769   }
 770 
 771   if (update_stats) {
 772     // We maintain the invariant that all objects allocated by mutator
 773     // threads will be allocated out of eden regions. So, we can use
 774     // the eden region number allocated since the previous GC to
 775     // calculate the application&#39;s allocate rate. The only exception
 776     // to that is humongous objects that are allocated separately. But
 777     // given that humongous object allocations do not really affect
 778     // either the pause&#39;s duration nor when the next pause will take
 779     // place we can safely ignore them here.
 780     uint regions_allocated = _collection_set-&gt;eden_region_length();
 781     double alloc_rate_ms = (double) regions_allocated / app_time_ms;
 782     _analytics-&gt;report_alloc_rate_ms(alloc_rate_ms);
 783 
 784     _analytics-&gt;compute_pause_time_ratios(end_time_sec, pause_time_ms);
 785     _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
 786   }
 787 
 788   if (collector_state()-&gt;in_young_gc_before_mixed()) {
 789     assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
 790     // This has been the young GC before we start doing mixed GCs. We already
 791     // decided to start mixed GCs much earlier, so there is nothing to do except
 792     // advancing the state.
 793     collector_state()-&gt;set_in_young_only_phase(false);
 794     collector_state()-&gt;set_in_young_gc_before_mixed(false);
 795   } else if (!this_pause_was_young_only) {
 796     // This is a mixed GC. Here we decide whether to continue doing more
 797     // mixed GCs or not.
 798     if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
 799                                  &quot;do not continue mixed GCs&quot;)) {
 800       collector_state()-&gt;set_in_young_only_phase(true);
 801 
 802       clear_collection_set_candidates();
 803       maybe_start_marking();
 804     }
 805   }
 806 
 807   _eden_surv_rate_group-&gt;start_adding_regions();
 808 
 809   double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);
 810   if (update_stats) {
 811     size_t const total_log_buffer_cards = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +
 812                                           p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);
 813     // Update prediction for card merge; MergeRSDirtyCards includes the cards from the Eager Reclaim phase.
 814     size_t const total_cards_merged = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +
 815                                       p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +
 816                                       total_log_buffer_cards;
 817 
 818     // The threshold for the number of cards in a given sampling which we consider
 819     // large enough so that the impact from setup and other costs is negligible.
 820     size_t const CardsNumSamplingThreshold = 10;
 821 
 822     if (total_cards_merged &gt; CardsNumSamplingThreshold) {
 823       double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +
 824                                     average_time_ms(G1GCPhaseTimes::MergeRS) +
 825                                     average_time_ms(G1GCPhaseTimes::MergeHCC) +
 826                                     average_time_ms(G1GCPhaseTimes::MergeLB) +
 827                                     average_time_ms(G1GCPhaseTimes::OptMergeRS);
 828       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged, this_pause_was_young_only);
 829     }
 830 
 831     // Update prediction for card scan
 832     size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
 833                                        p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
 834 
 835     if (total_cards_scanned &gt; CardsNumSamplingThreshold) {
 836       double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +
 837                                         average_time_ms(G1GCPhaseTimes::OptScanHR);
 838 
 839       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned, this_pause_was_young_only);
 840     }
 841 
 842     // Update prediction for the ratio between cards from the remembered
 843     // sets and actually scanned cards from the remembered sets.
 844     // Cards from the remembered sets are all cards not duplicated by cards from
 845     // the logs.
 846     // Due to duplicates in the log buffers, the number of actually scanned cards
 847     // can be smaller than the cards in the log buffers.
 848     const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;
 849     double merge_to_scan_ratio = 0.0;
 850     if (total_cards_scanned &gt; 0) {
 851       merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;
 852     }
 853     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio, this_pause_was_young_only);
 854 
 855     const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();
 856     const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;
 857     _analytics-&gt;report_rs_length_diff(rs_length_diff);
 858 
 859     // Update prediction for copy cost per byte
 860     size_t copied_bytes = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergePSS, G1GCPhaseTimes::MergePSSCopiedBytes);
 861 
 862     if (copied_bytes &gt; 0) {
 863       double cost_per_byte_ms = (average_time_ms(G1GCPhaseTimes::ObjCopy) + average_time_ms(G1GCPhaseTimes::OptObjCopy)) / copied_bytes;
 864       _analytics-&gt;report_cost_per_byte_ms(cost_per_byte_ms, collector_state()-&gt;mark_or_rebuild_in_progress());
 865     }
 866 
 867     if (_collection_set-&gt;young_region_length() &gt; 0) {
 868       _analytics-&gt;report_young_other_cost_per_region_ms(young_other_time_ms() /
 869                                                         _collection_set-&gt;young_region_length());
 870     }
 871 
 872     if (_collection_set-&gt;old_region_length() &gt; 0) {
 873       _analytics-&gt;report_non_young_other_cost_per_region_ms(non_young_other_time_ms() /
 874                                                             _collection_set-&gt;old_region_length());
 875     }
 876 
 877     _analytics-&gt;report_constant_other_time_ms(constant_other_time_ms(pause_time_ms));
 878 
 879     // Do not update RS lengths and the number of pending cards with information from mixed gc:
 880     // these are is wildly different to during young only gc and mess up young gen sizing right
 881     // after the mixed gc phase.
 882     // During mixed gc we do not use them for young gen sizing.
 883     if (this_pause_was_young_only) {
 884       _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);
 885       _analytics-&gt;report_rs_length((double) _rs_length);
 886     }
 887   }
 888 
 889   assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),
 890          &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);
 891   if (this_pause_included_initial_mark) {
 892     collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
 893   }
 894 
 895   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 896 
 897   update_rs_length_prediction();
 898 
 899   // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
 900   // that in this case we are not running in a &quot;normal&quot; operating mode.
 901   if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
 902     update_young_length_bounds();
 903 
 904     _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
 905     update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
 906                            _old_gen_alloc_tracker.last_cycle_old_bytes(),
 907                            this_pause_was_young_only);
 908 
 909     _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
 910   } else {
 911     // Any garbage collection triggered as periodic collection resets the time-to-mixed
 912     // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
 913     // the marking threads may have received an uncharacterisic amount of cpu time
 914     // for completing the marking, i.e. are faster than expected.
 915     // This skews the predicted marking length towards smaller values which might cause
 916     // the mark start being too late.
 917     _initial_mark_to_mixed.reset();
 918   }
 919 
 920   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
 921   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
 922 
 923   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {
 924     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
 925                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,
 926                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);
 927 
 928     scan_logged_cards_time_goal_ms = 0;
 929   } else {
 930     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;
 931   }
 932 
 933   double const logged_cards_time = logged_cards_processing_time();
 934 
 935   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,
 936                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);
 937 
 938   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,
 939                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),
 940                                     scan_logged_cards_time_goal_ms);
 941 }
 942 
 943 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 944   if (G1UseAdaptiveIHOP) {
 945     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 946                                      predictor,
 947                                      G1ReservePercent,
 948                                      G1HeapWastePercent);
 949   } else {
 950     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 951   }
 952 }
 953 
 954 void G1Policy::update_ihop_prediction(double mutator_time_s,
 955                                       size_t mutator_alloc_bytes,
 956                                       bool this_gc_was_young_only) {
 957   // Always try to update IHOP prediction. Even evacuation failures give information
 958   // about e.g. whether to start IHOP earlier next time.
 959 
 960   // Avoid using really small application times that might create samples with
 961   // very high or very low values. They may be caused by e.g. back-to-back gcs.
 962   double const min_valid_time = 1e-6;
 963 
 964   bool report = false;
 965 
 966   double marking_to_mixed_time = -1.0;
 967   if (!this_gc_was_young_only &amp;&amp; _initial_mark_to_mixed.has_result()) {
 968     marking_to_mixed_time = _initial_mark_to_mixed.last_marking_time();
 969     assert(marking_to_mixed_time &gt; 0.0,
 970            &quot;Initial mark to mixed time must be larger than zero but is %.3f&quot;,
 971            marking_to_mixed_time);
 972     if (marking_to_mixed_time &gt; min_valid_time) {
 973       _ihop_control-&gt;update_marking_length(marking_to_mixed_time);
 974       report = true;
 975     }
 976   }
 977 
 978   // As an approximation for the young gc promotion rates during marking we use
 979   // all of them. In many applications there are only a few if any young gcs during
 980   // marking, which makes any prediction useless. This increases the accuracy of the
 981   // prediction.
 982   if (this_gc_was_young_only &amp;&amp; mutator_time_s &gt; min_valid_time) {
 983     // IHOP control wants to know the expected young gen length if it were not
 984     // restrained by the heap reserve. Using the actual length would make the
 985     // prediction too small and the limit the young gen every time we get to the
 986     // predicted target occupancy.
 987     size_t young_gen_size = young_list_desired_length() * HeapRegion::GrainBytes;
 988     _ihop_control-&gt;update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
 989     report = true;
 990   }
 991 
 992   if (report) {
 993     report_ihop_statistics();
 994   }
 995 }
 996 
 997 void G1Policy::report_ihop_statistics() {
 998   _ihop_control-&gt;print();
 999 }
1000 
1001 void G1Policy::print_phases() {
1002   phase_times()-&gt;print();
1003 }
1004 
1005 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,
1006                                               size_t rs_length) const {
1007   size_t effective_scanned_cards = _analytics-&gt;predict_scan_card_num(rs_length, collector_state()-&gt;in_young_only_phase());
1008   return
1009     _analytics-&gt;predict_card_merge_time_ms(pending_cards + rs_length, collector_state()-&gt;in_young_only_phase()) +
1010     _analytics-&gt;predict_card_scan_time_ms(effective_scanned_cards, collector_state()-&gt;in_young_only_phase()) +
1011     _analytics-&gt;predict_constant_other_time_ms() +
1012     predict_survivor_regions_evac_time();
1013 }
1014 
1015 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
1016   size_t rs_length = _analytics-&gt;predict_rs_length();
1017   return predict_base_elapsed_time_ms(pending_cards, rs_length);
1018 }
1019 
1020 size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {
1021   size_t bytes_to_copy;
1022   if (!hr-&gt;is_young()) {
1023     bytes_to_copy = hr-&gt;max_live_bytes();
1024   } else {
1025     bytes_to_copy = (size_t) (hr-&gt;used() * hr-&gt;surv_rate_prediction(_predictor));
1026   }
1027   return bytes_to_copy;
1028 }
1029 
1030 double G1Policy::predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy) const {
1031   if (count == 0) {
1032     return 0.0;
1033   }
1034   size_t const expected_bytes = _eden_surv_rate_group-&gt;accum_surv_rate_pred(count) * HeapRegion::GrainBytes;
1035   if (bytes_to_copy != NULL) {
1036     *bytes_to_copy = expected_bytes;
1037   }
1038   return _analytics-&gt;predict_object_copy_time_ms(expected_bytes, collector_state()-&gt;mark_or_rebuild_in_progress());
1039 }
1040 
1041 double G1Policy::predict_region_copy_time_ms(HeapRegion* hr) const {
1042   size_t const bytes_to_copy = predict_bytes_to_copy(hr);
1043   return _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());
1044 }
1045 
1046 double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,
1047                                                  bool for_young_gc) const {
1048   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
1049   size_t scan_card_num = _analytics-&gt;predict_scan_card_num(rs_length, for_young_gc);
1050 
1051   double region_elapsed_time_ms =
1052     _analytics-&gt;predict_card_merge_time_ms(rs_length, collector_state()-&gt;in_young_only_phase()) +
1053     _analytics-&gt;predict_card_scan_time_ms(scan_card_num, collector_state()-&gt;in_young_only_phase());
1054 
1055   // The prediction of the &quot;other&quot; time for this region is based
1056   // upon the region type and NOT the GC type.
1057   if (hr-&gt;is_young()) {
1058     region_elapsed_time_ms += _analytics-&gt;predict_young_other_time_ms(1);
1059   } else {
1060     region_elapsed_time_ms += _analytics-&gt;predict_non_young_other_time_ms(1);
1061   }
1062   return region_elapsed_time_ms;
1063 }
1064 
1065 double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const {
1066   return predict_region_non_copy_time_ms(hr, for_young_gc) + predict_region_copy_time_ms(hr);
1067 }
1068 
1069 bool G1Policy::should_allocate_mutator_region() const {
1070   uint young_list_length = _g1h-&gt;young_regions_count();
1071   uint young_list_target_length = _young_list_target_length;
1072   return young_list_length &lt; young_list_target_length;
1073 }
1074 
1075 bool G1Policy::can_expand_young_list() const {
1076   uint young_list_length = _g1h-&gt;young_regions_count();
1077   uint young_list_max_length = _young_list_max_length;
1078   return young_list_length &lt; young_list_max_length;
1079 }
1080 
1081 bool G1Policy::use_adaptive_young_list_length() const {
1082   return _young_gen_sizer-&gt;use_adaptive_young_list_length();
1083 }
1084 
1085 size_t G1Policy::desired_survivor_size(uint max_regions) const {
1086   size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;
1087   return (size_t)((((double)survivor_capacity) * TargetSurvivorRatio) / 100);
1088 }
1089 
1090 void G1Policy::print_age_table() {
1091   _survivors_age_table.print_age_table(_tenuring_threshold);
1092 }
1093 
1094 uint G1Policy::calculate_young_max_length(uint target_young_length) const {
1095   uint expansion_region_num = 0;
1096   if (GCLockerEdenExpansionPercent &gt; 0) {
1097     double perc = (double) GCLockerEdenExpansionPercent / 100.0;
1098     double expansion_region_num_d = perc * (double) _young_list_target_length;
1099     // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
1100     // less than 1.0) we&#39;ll get 1.
1101     expansion_region_num = (uint) ceil(expansion_region_num_d);
1102   } else {
1103     assert(expansion_region_num == 0, &quot;sanity&quot;);
1104   }
1105   uint max_length = target_young_length + expansion_region_num;
1106   assert(target_young_length &lt;= max_length, &quot;post-condition&quot;);
1107   return max_length;
1108 }
1109 
1110 // Calculates survivor space parameters.
1111 void G1Policy::update_survivors_policy() {
1112   double max_survivor_regions_d =
1113                  (double) _young_list_target_length / (double) SurvivorRatio;
1114 
1115   // Calculate desired survivor size based on desired max survivor regions (unconstrained
1116   // by remaining heap). Otherwise we may cause undesired promotions as we are
1117   // already getting close to end of the heap, impacting performance even more.
1118   uint const desired_max_survivor_regions = ceil(max_survivor_regions_d);
1119   size_t const survivor_size = desired_survivor_size(desired_max_survivor_regions);
1120 
1121   _tenuring_threshold = _survivors_age_table.compute_tenuring_threshold(survivor_size);
1122   if (UsePerfData) {
1123     _policy_counters-&gt;tenuring_threshold()-&gt;set_value(_tenuring_threshold);
1124     _policy_counters-&gt;desired_survivor_size()-&gt;set_value(survivor_size * oopSize);
1125   }
1126   // The real maximum survivor size is bounded by the number of regions that can
1127   // be allocated into.
1128   _max_survivor_regions = MIN2(desired_max_survivor_regions,
1129                                _g1h-&gt;num_free_or_available_regions());
1130 }
1131 
1132 bool G1Policy::force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause) {
1133   // We actually check whether we are marking here and not if we are in a
1134   // reclamation phase. This means that we will schedule a concurrent mark
1135   // even while we are still in the process of reclaiming memory.
1136   bool during_cycle = _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
1137   if (!during_cycle) {
1138     log_debug(gc, ergo)(&quot;Request concurrent cycle initiation (requested by GC cause). GC cause: %s&quot;, GCCause::to_string(gc_cause));
1139     collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
1140     return true;
1141   } else {
1142     log_debug(gc, ergo)(&quot;Do not request concurrent cycle initiation (concurrent cycle already in progress). GC cause: %s&quot;, GCCause::to_string(gc_cause));
1143     return false;
1144   }
1145 }
1146 
1147 void G1Policy::initiate_conc_mark() {
1148   collector_state()-&gt;set_in_initial_mark_gc(true);
1149   collector_state()-&gt;set_initiate_conc_mark_if_possible(false);
1150 }
1151 
1152 void G1Policy::decide_on_conc_mark_initiation() {
1153   // We are about to decide on whether this pause will be an
1154   // initial-mark pause.
1155 
1156   // First, collector_state()-&gt;in_initial_mark_gc() should not be already set. We
1157   // will set it here if we have to. However, it should be cleared by
1158   // the end of the pause (it&#39;s only set for the duration of an
1159   // initial-mark pause).
1160   assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;pre-condition&quot;);
1161 
1162   if (collector_state()-&gt;initiate_conc_mark_if_possible()) {
1163     // We had noticed on a previous pause that the heap occupancy has
1164     // gone over the initiating threshold and we should start a
1165     // concurrent marking cycle.  Or we&#39;ve been explicitly requested
1166     // to start a concurrent marking cycle.  Either way, we initiate
1167     // one if not inhibited for some reason.
1168 
1169     GCCause::Cause cause = _g1h-&gt;gc_cause();
1170     if ((cause != GCCause::_wb_breakpoint) &amp;&amp;
1171         ConcurrentGCBreakpoints::is_controlled()) {
1172       log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (whitebox controlled)&quot;);
1173     } else if (!about_to_start_mixed_phase() &amp;&amp; collector_state()-&gt;in_young_only_phase()) {
1174       // Initiate a new initial mark if there is no marking or reclamation going on.
1175       initiate_conc_mark();
1176       log_debug(gc, ergo)(&quot;Initiate concurrent cycle (concurrent cycle initiation requested)&quot;);
1177     } else if (_g1h-&gt;is_user_requested_concurrent_full_gc(cause) ||
1178                (cause == GCCause::_wb_breakpoint)) {
1179       // Initiate a user requested initial mark or run_to a breakpoint.
1180       // An initial mark must be young only GC, so the collector state
1181       // must be updated to reflect this.
1182       collector_state()-&gt;set_in_young_only_phase(true);
1183       collector_state()-&gt;set_in_young_gc_before_mixed(false);
1184 
1185       // We might have ended up coming here about to start a mixed phase with a collection set
1186       // active. The following remark might change the change the &quot;evacuation efficiency&quot; of
1187       // the regions in this set, leading to failing asserts later.
1188       // Since the concurrent cycle will recreate the collection set anyway, simply drop it here.
1189       clear_collection_set_candidates();
1190       abort_time_to_mixed_tracking();
1191       initiate_conc_mark();
1192       log_debug(gc, ergo)(&quot;Initiate concurrent cycle (%s requested concurrent cycle)&quot;,
1193                           (cause == GCCause::_wb_breakpoint) ? &quot;run_to breakpoint&quot; : &quot;user&quot;);
1194     } else {
1195       // The concurrent marking thread is still finishing up the
1196       // previous cycle. If we start one right now the two cycles
1197       // overlap. In particular, the concurrent marking thread might
1198       // be in the process of clearing the next marking bitmap (which
1199       // we will use for the next cycle if we start one). Starting a
1200       // cycle now will be bad given that parts of the marking
1201       // information might get cleared by the marking thread. And we
1202       // cannot wait for the marking thread to finish the cycle as it
1203       // periodically yields while clearing the next marking bitmap
1204       // and, if it&#39;s in a yield point, it&#39;s waiting for us to
1205       // finish. So, at this point we will not start a cycle and we&#39;ll
1206       // let the concurrent marking thread complete the last one.
1207       log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (concurrent cycle already in progress)&quot;);
1208     }
1209   }
1210 }
1211 
1212 void G1Policy::record_concurrent_mark_cleanup_end() {
1213   G1CollectionSetCandidates* candidates = G1CollectionSetChooser::build(_g1h-&gt;workers(), _g1h-&gt;num_regions());
1214   _collection_set-&gt;set_candidates(candidates);
1215 
1216   bool mixed_gc_pending = next_gc_should_be_mixed(&quot;request mixed gcs&quot;, &quot;request young-only gcs&quot;);
1217   if (!mixed_gc_pending) {
1218     clear_collection_set_candidates();
1219     abort_time_to_mixed_tracking();
1220   }
1221   collector_state()-&gt;set_in_young_gc_before_mixed(mixed_gc_pending);
1222   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
1223 
1224   double end_sec = os::elapsedTime();
1225   double elapsed_time_ms = (end_sec - _mark_cleanup_start_sec) * 1000.0;
1226   _analytics-&gt;report_concurrent_mark_cleanup_times_ms(elapsed_time_ms);
1227   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
1228 
1229   record_pause(Cleanup, _mark_cleanup_start_sec, end_sec);
1230 }
1231 
1232 double G1Policy::reclaimable_bytes_percent(size_t reclaimable_bytes) const {
1233   return percent_of(reclaimable_bytes, _g1h-&gt;capacity());
1234 }
1235 
1236 class G1ClearCollectionSetCandidateRemSets : public HeapRegionClosure {
1237   virtual bool do_heap_region(HeapRegion* r) {
1238     r-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);
1239     return false;
1240   }
1241 };
1242 
1243 void G1Policy::clear_collection_set_candidates() {
1244   // Clear remembered sets of remaining candidate regions and the actual candidate
1245   // set.
1246   G1ClearCollectionSetCandidateRemSets cl;
1247   _collection_set-&gt;candidates()-&gt;iterate(&amp;cl);
1248   _collection_set-&gt;clear_candidates();
1249 }
1250 
1251 void G1Policy::maybe_start_marking() {
1252   if (need_to_start_conc_mark(&quot;end of GC&quot;)) {
1253     // Note: this might have already been set, if during the last
1254     // pause we decided to start a cycle but at the beginning of
1255     // this pause we decided to postpone it. That&#39;s OK.
1256     collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
1257   }
1258 }
1259 
1260 G1Policy::PauseKind G1Policy::young_gc_pause_kind() const {
1261   assert(!collector_state()-&gt;in_full_gc(), &quot;must be&quot;);
1262   if (collector_state()-&gt;in_initial_mark_gc()) {
1263     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1264     return InitialMarkGC;
1265   } else if (collector_state()-&gt;in_young_gc_before_mixed()) {
1266     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1267     return LastYoungGC;
1268   } else if (collector_state()-&gt;in_mixed_phase()) {
1269     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1270     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1271     return MixedGC;
1272   } else {
1273     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1274     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1275     return YoungOnlyGC;
1276   }
1277 }
1278 
1279 void G1Policy::record_pause(PauseKind kind, double start, double end) {
1280   // Manage the MMU tracker. For some reason it ignores Full GCs.
1281   if (kind != FullGC) {
1282     _mmu_tracker-&gt;add_pause(start, end);
1283   }
1284   // Manage the mutator time tracking from initial mark to first mixed gc.
1285   switch (kind) {
1286     case FullGC:
1287       abort_time_to_mixed_tracking();
1288       break;
1289     case Cleanup:
1290     case Remark:
1291     case YoungOnlyGC:
1292     case LastYoungGC:
1293       _initial_mark_to_mixed.add_pause(end - start);
1294       break;
1295     case InitialMarkGC:
1296       if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
1297         _initial_mark_to_mixed.record_initial_mark_end(end);
1298       }
1299       break;
1300     case MixedGC:
1301       _initial_mark_to_mixed.record_mixed_gc_start(start);
1302       break;
1303     default:
1304       ShouldNotReachHere();
1305   }
1306 }
1307 
1308 void G1Policy::abort_time_to_mixed_tracking() {
1309   _initial_mark_to_mixed.reset();
1310 }
1311 
1312 bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
1313                                        const char* false_action_str) const {
1314   G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
1315 
1316   if (candidates == NULL || candidates-&gt;is_empty()) {
1317     if (false_action_str != NULL) {
1318       log_debug(gc, ergo)(&quot;%s (candidate old regions not available)&quot;, false_action_str);
1319     }
1320     return false;
1321   }
1322 
1323   // Is the amount of uncollected reclaimable space above G1HeapWastePercent?
1324   size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
1325   double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
1326   double threshold = (double) G1HeapWastePercent;
1327   if (reclaimable_percent &lt;= threshold) {
1328     if (false_action_str != NULL) {
1329       log_debug(gc, ergo)(&quot;%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,
1330                           false_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
1331     }
1332     return false;
1333   }
1334   if (true_action_str != NULL) {
1335     log_debug(gc, ergo)(&quot;%s (candidate old regions available). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,
1336                         true_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);
1337   }
1338   return true;
1339 }
1340 
1341 uint G1Policy::calc_min_old_cset_length() const {
1342   // The min old CSet region bound is based on the maximum desired
1343   // number of mixed GCs after a cycle. I.e., even if some old regions
1344   // look expensive, we should add them to the CSet anyway to make
1345   // sure we go through the available old regions in no more than the
1346   // maximum desired number of mixed GCs.
1347   //
1348   // The calculation is based on the number of marked regions we added
1349   // to the CSet candidates in the first place, not how many remain, so
1350   // that the result is the same during all mixed GCs that follow a cycle.
1351 
1352   const size_t region_num = _collection_set-&gt;candidates()-&gt;num_regions();
1353   const size_t gc_num = (size_t) MAX2(G1MixedGCCountTarget, (uintx) 1);
1354   size_t result = region_num / gc_num;
1355   // emulate ceiling
1356   if (result * gc_num &lt; region_num) {
1357     result += 1;
1358   }
1359   return (uint) result;
1360 }
1361 
1362 uint G1Policy::calc_max_old_cset_length() const {
1363   // The max old CSet region bound is based on the threshold expressed
1364   // as a percentage of the heap size. I.e., it should bound the
1365   // number of old regions added to the CSet irrespective of how many
1366   // of them are available.
1367 
1368   const G1CollectedHeap* g1h = G1CollectedHeap::heap();
1369   const size_t region_num = g1h-&gt;num_regions();
1370   const size_t perc = (size_t) G1OldCSetRegionThresholdPercent;
1371   size_t result = region_num * perc / 100;
1372   // emulate ceiling
1373   if (100 * result &lt; region_num * perc) {
1374     result += 1;
1375   }
1376   return (uint) result;
1377 }
1378 
1379 void G1Policy::calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
1380                                                     double time_remaining_ms,
1381                                                     uint&amp; num_initial_regions,
1382                                                     uint&amp; num_optional_regions) {
1383   assert(candidates != NULL, &quot;Must be&quot;);
1384 
1385   num_initial_regions = 0;
1386   num_optional_regions = 0;
1387   uint num_expensive_regions = 0;
1388 
1389   double predicted_old_time_ms = 0.0;
1390   double predicted_initial_time_ms = 0.0;
1391   double predicted_optional_time_ms = 0.0;
1392 
1393   double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();
1394 
1395   const uint min_old_cset_length = calc_min_old_cset_length();
1396   const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());
1397   const uint max_optional_regions = max_old_cset_length - min_old_cset_length;
1398   bool check_time_remaining = use_adaptive_young_list_length();
1399 
1400   uint candidate_idx = candidates-&gt;cur_idx();
1401 
1402   log_debug(gc, ergo, cset)(&quot;Start adding old regions to collection set. Min %u regions, max %u regions, &quot;
1403                             &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,
1404                             min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);
1405 
1406   HeapRegion* hr = candidates-&gt;at(candidate_idx);
1407   while (hr != NULL) {
1408     if (num_initial_regions + num_optional_regions &gt;= max_old_cset_length) {
1409       // Added maximum number of old regions to the CSet.
1410       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Maximum number of regions). &quot;
1411                                 &quot;Initial %u regions, optional %u regions&quot;,
1412                                 num_initial_regions, num_optional_regions);
1413       break;
1414     }
1415 
1416     // Stop adding regions if the remaining reclaimable space is
1417     // not above G1HeapWastePercent.
1418     size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
1419     double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
1420     double threshold = (double) G1HeapWastePercent;
1421     if (reclaimable_percent &lt;= threshold) {
1422       // We&#39;ve added enough old regions that the amount of uncollected
1423       // reclaimable space is at or below the waste threshold. Stop
1424       // adding old regions to the CSet.
1425       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Reclaimable percentage below threshold). &quot;
1426                                 &quot;Reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,
1427                                 byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),
1428                                 reclaimable_percent, G1HeapWastePercent);
1429       break;
1430     }
1431 
1432     double predicted_time_ms = predict_region_total_time_ms(hr, false);
1433     time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
1434     // Add regions to old set until we reach the minimum amount
1435     if (num_initial_regions &lt; min_old_cset_length) {
1436       predicted_old_time_ms += predicted_time_ms;
1437       num_initial_regions++;
1438       // Record the number of regions added with no time remaining
1439       if (time_remaining_ms == 0.0) {
1440         num_expensive_regions++;
1441       }
1442     } else if (!check_time_remaining) {
1443       // In the non-auto-tuning case, we&#39;ll finish adding regions
1444       // to the CSet if we reach the minimum.
1445       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Region amount reached min).&quot;);
1446       break;
1447     } else {
1448       // Keep adding regions to old set until we reach the optional threshold
1449       if (time_remaining_ms &gt; optional_threshold_ms) {
1450         predicted_old_time_ms += predicted_time_ms;
1451         num_initial_regions++;
1452       } else if (time_remaining_ms &gt; 0) {
1453         // Keep adding optional regions until time is up.
1454         assert(num_optional_regions &lt; max_optional_regions, &quot;Should not be possible.&quot;);
1455         predicted_optional_time_ms += predicted_time_ms;
1456         num_optional_regions++;
1457       } else {
1458         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Predicted time too high).&quot;);
1459         break;
1460       }
1461     }
1462     hr = candidates-&gt;at(++candidate_idx);
1463   }
1464   if (hr == NULL) {
1465     log_debug(gc, ergo, cset)(&quot;Old candidate collection set empty.&quot;);
1466   }
1467 
1468   if (num_expensive_regions &gt; 0) {
1469     log_debug(gc, ergo, cset)(&quot;Added %u initial old regions to collection set although the predicted time was too high.&quot;,
1470                               num_expensive_regions);
1471   }
1472 
1473   log_debug(gc, ergo, cset)(&quot;Finish choosing collection set old regions. Initial: %u, optional: %u, &quot;
1474                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,
1475                             num_initial_regions, num_optional_regions,
1476                             predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);
1477 }
1478 
1479 void G1Policy::calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,
1480                                                          uint const max_optional_regions,
1481                                                          double time_remaining_ms,
1482                                                          uint&amp; num_optional_regions) {
1483   assert(_g1h-&gt;collector_state()-&gt;in_mixed_phase(), &quot;Should only be called in mixed phase&quot;);
1484 
1485   num_optional_regions = 0;
1486   double prediction_ms = 0;
1487   uint candidate_idx = candidates-&gt;cur_idx();
1488 
1489   HeapRegion* r = candidates-&gt;at(candidate_idx);
1490   while (num_optional_regions &lt; max_optional_regions) {
1491     assert(r != NULL, &quot;Region must exist&quot;);
1492     prediction_ms += predict_region_total_time_ms(r, false);
1493 
1494     if (prediction_ms &gt; time_remaining_ms) {
1495       log_debug(gc, ergo, cset)(&quot;Prediction %.3fms for region %u does not fit remaining time: %.3fms.&quot;,
1496                                 prediction_ms, r-&gt;hrm_index(), time_remaining_ms);
1497       break;
1498     }
1499     // This region will be included in the next optional evacuation.
1500 
1501     time_remaining_ms -= prediction_ms;
1502     num_optional_regions++;
1503     r = candidates-&gt;at(++candidate_idx);
1504   }
1505 
1506   log_debug(gc, ergo, cset)(&quot;Prepared %u regions out of %u for optional evacuation. Predicted time: %.3fms&quot;,
1507                             num_optional_regions, max_optional_regions, prediction_ms);
1508 }
1509 
1510 void G1Policy::transfer_survivors_to_cset(const G1SurvivorRegions* survivors) {
1511   note_start_adding_survivor_regions();
1512 
1513   HeapRegion* last = NULL;
1514   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivors-&gt;regions()-&gt;begin();
1515        it != survivors-&gt;regions()-&gt;end();
1516        ++it) {
1517     HeapRegion* curr = *it;
1518     set_region_survivor(curr);
1519 
1520     // The region is a non-empty survivor so let&#39;s add it to
1521     // the incremental collection set for the next evacuation
1522     // pause.
1523     _collection_set-&gt;add_survivor_regions(curr);
1524 
1525     last = curr;
1526   }
1527   note_stop_adding_survivor_regions();
1528 
1529   // Don&#39;t clear the survivor list handles until the start of
1530   // the next evacuation pause - we need it in order to re-tag
1531   // the survivor regions from this evacuation pause as &#39;young&#39;
1532   // at the start of the next.
1533 }
    </pre>
  </body>
</html>
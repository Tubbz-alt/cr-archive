<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/g1/g1Policy.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/g1/g1Analytics.hpp&quot;
  27 #include &quot;gc/g1/g1Arguments.hpp&quot;
  28 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  29 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
  30 #include &quot;gc/g1/g1CollectionSetCandidates.hpp&quot;
  31 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  32 #include &quot;gc/g1/g1ConcurrentMarkThread.inline.hpp&quot;
  33 #include &quot;gc/g1/g1ConcurrentRefine.hpp&quot;
  34 #include &quot;gc/g1/g1ConcurrentRefineStats.hpp&quot;
  35 #include &quot;gc/g1/g1CollectionSetChooser.hpp&quot;
  36 #include &quot;gc/g1/g1HeterogeneousHeapPolicy.hpp&quot;
  37 #include &quot;gc/g1/g1HotCardCache.hpp&quot;
  38 #include &quot;gc/g1/g1IHOPControl.hpp&quot;
  39 #include &quot;gc/g1/g1GCPhaseTimes.hpp&quot;
  40 #include &quot;gc/g1/g1Policy.hpp&quot;
  41 #include &quot;gc/g1/g1SurvivorRegions.hpp&quot;
  42 #include &quot;gc/g1/g1YoungGenSizer.hpp&quot;
  43 #include &quot;gc/g1/heapRegion.inline.hpp&quot;
  44 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  45 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  46 #include &quot;gc/shared/gcPolicyCounters.hpp&quot;
  47 #include &quot;logging/log.hpp&quot;
  48 #include &quot;runtime/arguments.hpp&quot;
<a name="1" id="anc1"></a>
  49 #include &quot;runtime/java.hpp&quot;
  50 #include &quot;runtime/mutexLocker.hpp&quot;
  51 #include &quot;utilities/debug.hpp&quot;
  52 #include &quot;utilities/growableArray.hpp&quot;
  53 #include &quot;utilities/pair.hpp&quot;
  54 
  55 G1Policy::G1Policy(STWGCTimer* gc_timer) :
  56   _predictor(G1ConfidencePercent / 100.0),
  57   _analytics(new G1Analytics(&amp;_predictor)),
  58   _remset_tracker(),
  59   _mmu_tracker(new G1MMUTrackerQueue(GCPauseIntervalMillis / 1000.0, MaxGCPauseMillis / 1000.0)),
  60   _ihop_control(create_ihop_control(&amp;_predictor)),
  61   _policy_counters(new GCPolicyCounters(&quot;GarbageFirst&quot;, 1, 2)),
  62   _full_collection_start_sec(0.0),
  63   _collection_pause_end_millis(os::javaTimeNanos() / NANOSECS_PER_MILLISEC),
<a name="2" id="anc2"></a>
  64   _young_list_target_length(0),
<a name="3" id="anc3"></a><span class="line-added">  65   _young_list_fixed_length(0),</span>
  66   _young_list_max_length(0),
  67   _eden_surv_rate_group(new G1SurvRateGroup()),
  68   _survivor_surv_rate_group(new G1SurvRateGroup()),
  69   _reserve_factor((double) G1ReservePercent / 100.0),
  70   _reserve_regions(0),
  71   _young_gen_sizer(G1YoungGenSizer::create_gen_sizer()),
  72   _free_regions_at_end_of_collection(0),
  73   _rs_length(0),
  74   _rs_length_prediction(0),
  75   _pending_cards_at_gc_start(0),
  76   _old_gen_alloc_tracker(),
  77   _initial_mark_to_mixed(),
  78   _collection_set(NULL),
  79   _g1h(NULL),
  80   _phase_times(new G1GCPhaseTimes(gc_timer, ParallelGCThreads)),
  81   _mark_remark_start_sec(0),
  82   _mark_cleanup_start_sec(0),
  83   _tenuring_threshold(MaxTenuringThreshold),
  84   _max_survivor_regions(0),
  85   _survivors_age_table(true)
  86 {
  87 }
  88 
  89 G1Policy::~G1Policy() {
  90   delete _ihop_control;
  91   delete _young_gen_sizer;
  92 }
  93 
  94 G1Policy* G1Policy::create_policy(STWGCTimer* gc_timer_stw) {
  95   if (G1Arguments::is_heterogeneous_heap()) {
  96     return new G1HeterogeneousHeapPolicy(gc_timer_stw);
  97   } else {
  98     return new G1Policy(gc_timer_stw);
  99   }
 100 }
 101 
 102 G1CollectorState* G1Policy::collector_state() const { return _g1h-&gt;collector_state(); }
 103 
 104 void G1Policy::init(G1CollectedHeap* g1h, G1CollectionSet* collection_set) {
 105   _g1h = g1h;
 106   _collection_set = collection_set;
 107 
 108   assert(Heap_lock-&gt;owned_by_self(), &quot;Locking discipline.&quot;);
 109 
<a name="4" id="anc4"></a><span class="line-added"> 110   if (!use_adaptive_young_list_length()) {</span>
<span class="line-added"> 111     _young_list_fixed_length = _young_gen_sizer-&gt;min_desired_young_length();</span>
<span class="line-added"> 112   }</span>
 113   _young_gen_sizer-&gt;adjust_max_new_size(_g1h-&gt;max_expandable_regions());
 114 
 115   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 116 
<a name="5" id="anc5"></a><span class="line-modified"> 117   update_young_list_max_and_target_length();</span>
 118   // We may immediately start allocating regions and placing them on the
 119   // collection set list. Initialize the per-collection set info
 120   _collection_set-&gt;start_incremental_building();
 121 }
 122 
 123 void G1Policy::note_gc_start() {
 124   phase_times()-&gt;note_gc_start();
 125 }
 126 
 127 class G1YoungLengthPredictor {
 128   const double _base_time_ms;
 129   const double _base_free_regions;
 130   const double _target_pause_time_ms;
 131   const G1Policy* const _policy;
 132 
 133  public:
 134   G1YoungLengthPredictor(double base_time_ms,
 135                          double base_free_regions,
 136                          double target_pause_time_ms,
 137                          const G1Policy* policy) :
 138     _base_time_ms(base_time_ms),
 139     _base_free_regions(base_free_regions),
 140     _target_pause_time_ms(target_pause_time_ms),
 141     _policy(policy) {}
 142 
 143   bool will_fit(uint young_length) const {
 144     if (young_length &gt;= _base_free_regions) {
 145       // end condition 1: not enough space for the young regions
 146       return false;
 147     }
 148 
 149     size_t bytes_to_copy = 0;
 150     const double copy_time_ms = _policy-&gt;predict_eden_copy_time_ms(young_length, &amp;bytes_to_copy);
 151     const double young_other_time_ms = _policy-&gt;analytics()-&gt;predict_young_other_time_ms(young_length);
 152     const double pause_time_ms = _base_time_ms + copy_time_ms + young_other_time_ms;
 153     if (pause_time_ms &gt; _target_pause_time_ms) {
 154       // end condition 2: prediction is over the target pause time
 155       return false;
 156     }
 157 
 158     const size_t free_bytes = (_base_free_regions - young_length) * HeapRegion::GrainBytes;
 159 
 160     // When copying, we will likely need more bytes free than is live in the region.
 161     // Add some safety margin to factor in the confidence of our guess, and the
 162     // natural expected waste.
 163     // (100.0 / G1ConfidencePercent) is a scale factor that expresses the uncertainty
 164     // of the calculation: the lower the confidence, the more headroom.
 165     // (100 + TargetPLABWastePct) represents the increase in expected bytes during
 166     // copying due to anticipated waste in the PLABs.
 167     const double safety_factor = (100.0 / G1ConfidencePercent) * (100 + TargetPLABWastePct) / 100.0;
 168     const size_t expected_bytes_to_copy = (size_t)(safety_factor * bytes_to_copy);
 169 
 170     if (expected_bytes_to_copy &gt; free_bytes) {
 171       // end condition 3: out-of-space
 172       return false;
 173     }
 174 
 175     // success!
 176     return true;
 177   }
 178 };
 179 
 180 void G1Policy::record_new_heap_size(uint new_number_of_regions) {
 181   // re-calculate the necessary reserve
 182   double reserve_regions_d = (double) new_number_of_regions * _reserve_factor;
 183   // We use ceiling so that if reserve_regions_d is &gt; 0.0 (but
 184   // smaller than 1.0) we&#39;ll get 1.
 185   _reserve_regions = (uint) ceil(reserve_regions_d);
 186 
 187   _young_gen_sizer-&gt;heap_size_changed(new_number_of_regions);
 188 
 189   _ihop_control-&gt;update_target_occupancy(new_number_of_regions * HeapRegion::GrainBytes);
 190 }
 191 
<a name="6" id="anc6"></a><span class="line-modified"> 192 uint G1Policy::calculate_young_list_desired_min_length(uint base_min_length) const {</span>



 193   uint desired_min_length = 0;
 194   if (use_adaptive_young_list_length()) {
<a name="7" id="anc7"></a><span class="line-modified"> 195     if (_analytics-&gt;num_alloc_rate_ms() &gt; 3) {</span>
<span class="line-modified"> 196       double now_sec = os::elapsedTime();</span>
<span class="line-modified"> 197       double when_ms = _mmu_tracker-&gt;when_max_gc_sec(now_sec) * 1000.0;</span>
<span class="line-modified"> 198       double alloc_rate_ms = _analytics-&gt;predict_alloc_rate_ms();</span>
<span class="line-added"> 199       desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);</span>
<span class="line-added"> 200     } else {</span>
<span class="line-added"> 201       // otherwise we don&#39;t have enough info to make the prediction</span>
<span class="line-added"> 202     }</span>
 203   }
<a name="8" id="anc8"></a><span class="line-modified"> 204   desired_min_length += base_min_length;</span>
<span class="line-modified"> 205   // make sure we don&#39;t go below any user-defined minimum bound</span>
<span class="line-modified"> 206   return MAX2(_young_gen_sizer-&gt;min_desired_young_length(), desired_min_length);</span>
<span class="line-modified"> 207 }</span>
<span class="line-modified"> 208 </span>
<span class="line-modified"> 209 uint G1Policy::calculate_young_list_desired_max_length() const {</span>
<span class="line-modified"> 210   // Here, we might want to also take into account any additional</span>
<span class="line-modified"> 211   // constraints (i.e., user-defined minimum bound). Currently, we</span>
<span class="line-modified"> 212   // effectively don&#39;t set this bound.</span>
<span class="line-modified"> 213   return _young_gen_sizer-&gt;max_desired_young_length();</span>
<span class="line-modified"> 214 }</span>
<span class="line-modified"> 215 </span>
<span class="line-modified"> 216 uint G1Policy::update_young_list_max_and_target_length() {</span>
<span class="line-modified"> 217   return update_young_list_max_and_target_length(_analytics-&gt;predict_rs_length());</span>
<span class="line-modified"> 218 }</span>
<span class="line-modified"> 219 </span>
<span class="line-modified"> 220 uint G1Policy::update_young_list_max_and_target_length(size_t rs_length) {</span>
<span class="line-modified"> 221   uint unbounded_target_length = update_young_list_target_length(rs_length);</span>
<span class="line-modified"> 222   update_max_gc_locker_expansion();</span>
<span class="line-modified"> 223   return unbounded_target_length;</span>
<span class="line-modified"> 224 }</span>
<span class="line-modified"> 225 </span>
<span class="line-modified"> 226 uint G1Policy::update_young_list_target_length(size_t rs_length) {</span>
<span class="line-modified"> 227   YoungTargetLengths young_lengths = young_list_target_lengths(rs_length);</span>
<span class="line-modified"> 228   _young_list_target_length = young_lengths.first;</span>
<span class="line-modified"> 229 </span>
<span class="line-modified"> 230   return young_lengths.second;</span>
<span class="line-modified"> 231 }</span>
<span class="line-modified"> 232 </span>
<span class="line-modified"> 233 G1Policy::YoungTargetLengths G1Policy::young_list_target_lengths(size_t rs_length) const {</span>
<span class="line-modified"> 234   YoungTargetLengths result;</span>












 235 
 236   // Calculate the absolute and desired min bounds first.
 237 
<a name="9" id="anc9"></a><span class="line-modified"> 238   // This is how many young regions we already have (currently: the survivors).</span>
<span class="line-modified"> 239   const uint base_min_length = _g1h-&gt;survivor_regions_count();</span>
<span class="line-modified"> 240   uint desired_min_length = calculate_young_list_desired_min_length(base_min_length);</span>
<span class="line-modified"> 241   // This is the absolute minimum young length. Ensure that we</span>
<span class="line-modified"> 242   // will at least have one eden region available for allocation.</span>
<span class="line-modified"> 243   uint absolute_min_length = base_min_length + MAX2(_g1h-&gt;eden_regions_count(), (uint)1);</span>
<span class="line-modified"> 244   // If we shrank the young list target it should not shrink below the current size.</span>
<span class="line-modified"> 245   desired_min_length = MAX2(desired_min_length, absolute_min_length);</span>
<span class="line-modified"> 246   // Calculate the absolute and desired max bounds.</span>











 247 
<a name="10" id="anc10"></a><span class="line-modified"> 248   uint desired_max_length = calculate_young_list_desired_max_length();</span>

 249 
<a name="11" id="anc11"></a><span class="line-modified"> 250   uint young_list_target_length = 0;</span>
<span class="line-modified"> 251   if (use_adaptive_young_list_length()) {</span>
<span class="line-modified"> 252     if (collector_state()-&gt;in_young_only_phase()) {</span>
<span class="line-modified"> 253       young_list_target_length =</span>
<span class="line-modified"> 254                         calculate_young_list_target_length(rs_length,</span>
<span class="line-added"> 255                                                            base_min_length,</span>
<span class="line-added"> 256                                                            desired_min_length,</span>
<span class="line-added"> 257                                                            desired_max_length);</span>
 258     } else {
<a name="12" id="anc12"></a><span class="line-modified"> 259       // Don&#39;t calculate anything and let the code below bound it to</span>
<span class="line-modified"> 260       // the desired_min_length, i.e., do the next GC as soon as</span>
<span class="line-modified"> 261       // possible to maximize how many old regions we can add to it.</span>

 262     }
<a name="13" id="anc13"></a>












 263   } else {
 264     // The user asked for a fixed young gen so we&#39;ll fix the young gen
 265     // whether the next GC is young or mixed.
<a name="14" id="anc14"></a><span class="line-modified"> 266     young_list_target_length = _young_list_fixed_length;</span>
 267   }
<a name="15" id="anc15"></a><span class="line-modified"> 268 </span>
<span class="line-modified"> 269   result.second = young_list_target_length;</span>
<span class="line-modified"> 270 </span>
<span class="line-modified"> 271   // We will try our best not to &quot;eat&quot; into the reserve.</span>
<span class="line-modified"> 272   uint absolute_max_length = 0;</span>
<span class="line-modified"> 273   if (_free_regions_at_end_of_collection &gt; _reserve_regions) {</span>
<span class="line-modified"> 274     absolute_max_length = _free_regions_at_end_of_collection - _reserve_regions;</span>
<span class="line-modified"> 275   }</span>
<span class="line-modified"> 276   if (desired_max_length &gt; absolute_max_length) {</span>
<span class="line-modified"> 277     desired_max_length = absolute_max_length;</span>

























































































 278   }
 279 
<a name="16" id="anc16"></a><span class="line-modified"> 280   // Make sure we don&#39;t go over the desired max length, nor under the</span>
<span class="line-added"> 281   // desired min length. In case they clash, desired_min_length wins</span>
<span class="line-added"> 282   // which is why that test is second.</span>
<span class="line-added"> 283   if (young_list_target_length &gt; desired_max_length) {</span>
<span class="line-added"> 284     young_list_target_length = desired_max_length;</span>
<span class="line-added"> 285   }</span>
<span class="line-added"> 286   if (young_list_target_length &lt; desired_min_length) {</span>
<span class="line-added"> 287     young_list_target_length = desired_min_length;</span>
<span class="line-added"> 288   }</span>
 289 
<a name="17" id="anc17"></a><span class="line-modified"> 290   assert(young_list_target_length &gt; base_min_length,</span>
<span class="line-added"> 291          &quot;we should be able to allocate at least one eden region&quot;);</span>
<span class="line-added"> 292   assert(young_list_target_length &gt;= absolute_min_length, &quot;post-condition&quot;);</span>
 293 
<a name="18" id="anc18"></a><span class="line-modified"> 294   result.first = young_list_target_length;</span>
<span class="line-modified"> 295   return result;</span>





 296 }
 297 
<a name="19" id="anc19"></a><span class="line-modified"> 298 uint G1Policy::calculate_young_list_target_length(size_t rs_length,</span>
<span class="line-modified"> 299                                                   uint base_min_length,</span>
<span class="line-modified"> 300                                                   uint desired_min_length,</span>
<span class="line-added"> 301                                                   uint desired_max_length) const {</span>
 302   assert(use_adaptive_young_list_length(), &quot;pre-condition&quot;);
<a name="20" id="anc20"></a><span class="line-added"> 303   assert(collector_state()-&gt;in_young_only_phase(), &quot;only call this for young GCs&quot;);</span>
<span class="line-added"> 304 </span>
<span class="line-added"> 305   // In case some edge-condition makes the desired max length too small...</span>
<span class="line-added"> 306   if (desired_max_length &lt;= desired_min_length) {</span>
<span class="line-added"> 307     return desired_min_length;</span>
<span class="line-added"> 308   }</span>
 309 
<a name="21" id="anc21"></a><span class="line-modified"> 310   // We&#39;ll adjust min_young_length and max_young_length not to include</span>
<span class="line-added"> 311   // the already allocated young regions (i.e., so they reflect the</span>
<span class="line-added"> 312   // min and max eden regions we&#39;ll allocate). The base_min_length</span>
<span class="line-added"> 313   // will be reflected in the predictions by the</span>
<span class="line-added"> 314   // survivor_regions_evac_time prediction.</span>
<span class="line-added"> 315   assert(desired_min_length &gt; base_min_length, &quot;invariant&quot;);</span>
<span class="line-added"> 316   uint min_young_length = desired_min_length - base_min_length;</span>
<span class="line-added"> 317   assert(desired_max_length &gt; base_min_length, &quot;invariant&quot;);</span>
<span class="line-added"> 318   uint max_young_length = desired_max_length - base_min_length;</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320   const double target_pause_time_ms = _mmu_tracker-&gt;max_gc_time() * 1000.0;</span>
<span class="line-added"> 321   const size_t pending_cards = _analytics-&gt;predict_pending_cards();</span>
<span class="line-added"> 322   const double base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);</span>
<span class="line-added"> 323   const uint available_free_regions = _free_regions_at_end_of_collection;</span>
<span class="line-added"> 324   const uint base_free_regions =</span>
<span class="line-added"> 325     available_free_regions &gt; _reserve_regions ? available_free_regions - _reserve_regions : 0;</span>
 326 
 327   // Here, we will make sure that the shortest young length that
 328   // makes sense fits within the target pause time.
 329 
 330   G1YoungLengthPredictor p(base_time_ms,
<a name="22" id="anc22"></a><span class="line-modified"> 331                            base_free_regions,</span>
<span class="line-modified"> 332                            target_pause_time_ms,</span>
 333                            this);
<a name="23" id="anc23"></a><span class="line-modified"> 334   if (p.will_fit(min_young_length)) {</span>
 335     // The shortest young length will fit into the target pause time;
 336     // we&#39;ll now check whether the absolute maximum number of young
 337     // regions will fit in the target pause time. If not, we&#39;ll do
 338     // a binary search between min_young_length and max_young_length.
<a name="24" id="anc24"></a><span class="line-modified"> 339     if (p.will_fit(max_young_length)) {</span>
 340       // The maximum young length will fit into the target pause time.
 341       // We are done so set min young length to the maximum length (as
 342       // the result is assumed to be returned in min_young_length).
<a name="25" id="anc25"></a><span class="line-modified"> 343       min_young_length = max_young_length;</span>
 344     } else {
 345       // The maximum possible number of young regions will not fit within
 346       // the target pause time so we&#39;ll search for the optimal
 347       // length. The loop invariants are:
 348       //
 349       // min_young_length &lt; max_young_length
 350       // min_young_length is known to fit into the target pause time
 351       // max_young_length is known not to fit into the target pause time
 352       //
 353       // Going into the loop we know the above hold as we&#39;ve just
 354       // checked them. Every time around the loop we check whether
 355       // the middle value between min_young_length and
 356       // max_young_length fits into the target pause time. If it
 357       // does, it becomes the new min. If it doesn&#39;t, it becomes
 358       // the new max. This way we maintain the loop invariants.
 359 
<a name="26" id="anc26"></a><span class="line-modified"> 360       assert(min_young_length &lt; max_young_length, &quot;invariant&quot;);</span>
<span class="line-modified"> 361       uint diff = (max_young_length - min_young_length) / 2;</span>
 362       while (diff &gt; 0) {
<a name="27" id="anc27"></a><span class="line-modified"> 363         uint young_length = min_young_length + diff;</span>
<span class="line-modified"> 364         if (p.will_fit(young_length)) {</span>
<span class="line-modified"> 365           min_young_length = young_length;</span>
 366         } else {
<a name="28" id="anc28"></a><span class="line-modified"> 367           max_young_length = young_length;</span>
 368         }
<a name="29" id="anc29"></a><span class="line-modified"> 369         assert(min_young_length &lt;  max_young_length, &quot;invariant&quot;);</span>
<span class="line-modified"> 370         diff = (max_young_length - min_young_length) / 2;</span>
 371       }
 372       // The results is min_young_length which, according to the
 373       // loop invariants, should fit within the target pause time.
 374 
 375       // These are the post-conditions of the binary search above:
<a name="30" id="anc30"></a><span class="line-modified"> 376       assert(min_young_length &lt; max_young_length,</span>
<span class="line-modified"> 377              &quot;otherwise we should have discovered that max_young_length &quot;</span>
 378              &quot;fits into the pause target and not done the binary search&quot;);
<a name="31" id="anc31"></a><span class="line-modified"> 379       assert(p.will_fit(min_young_length),</span>
<span class="line-modified"> 380              &quot;min_young_length, the result of the binary search, should &quot;</span>
 381              &quot;fit into the pause target&quot;);
<a name="32" id="anc32"></a><span class="line-modified"> 382       assert(!p.will_fit(min_young_length + 1),</span>
<span class="line-modified"> 383              &quot;min_young_length, the result of the binary search, should be &quot;</span>
 384              &quot;optimal, so no larger length should fit into the pause target&quot;);
 385     }
 386   } else {
 387     // Even the minimum length doesn&#39;t fit into the pause time
 388     // target, return it as the result nevertheless.
 389   }
<a name="33" id="anc33"></a><span class="line-modified"> 390   return base_min_length + min_young_length;</span>



















 391 }
 392 
 393 double G1Policy::predict_survivor_regions_evac_time() const {
 394   double survivor_regions_evac_time = 0.0;
 395   const GrowableArray&lt;HeapRegion*&gt;* survivor_regions = _g1h-&gt;survivor()-&gt;regions();
 396   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivor_regions-&gt;begin();
 397        it != survivor_regions-&gt;end();
 398        ++it) {
 399     survivor_regions_evac_time += predict_region_total_time_ms(*it, collector_state()-&gt;in_young_only_phase());
 400   }
 401   return survivor_regions_evac_time;
 402 }
 403 
 404 void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_length) {
 405   guarantee(use_adaptive_young_list_length(), &quot;should not call this otherwise&quot; );
 406 
 407   if (rs_length &gt; _rs_length_prediction) {
 408     // add 10% to avoid having to recalculate often
 409     size_t rs_length_prediction = rs_length * 1100 / 1000;
 410     update_rs_length_prediction(rs_length_prediction);
<a name="34" id="anc34"></a><span class="line-modified"> 411 </span>
<span class="line-added"> 412     update_young_list_max_and_target_length(rs_length_prediction);</span>
 413   }
 414 }
 415 
 416 void G1Policy::update_rs_length_prediction() {
 417   update_rs_length_prediction(_analytics-&gt;predict_rs_length());
 418 }
 419 
 420 void G1Policy::update_rs_length_prediction(size_t prediction) {
 421   if (collector_state()-&gt;in_young_only_phase() &amp;&amp; use_adaptive_young_list_length()) {
 422     _rs_length_prediction = prediction;
 423   }
 424 }
 425 
 426 void G1Policy::record_full_collection_start() {
 427   _full_collection_start_sec = os::elapsedTime();
 428   // Release the future to-space so that it is available for compaction into.
 429   collector_state()-&gt;set_in_young_only_phase(false);
 430   collector_state()-&gt;set_in_full_gc(true);
 431   _collection_set-&gt;clear_candidates();
 432   _pending_cards_at_gc_start = 0;
 433 }
 434 
 435 void G1Policy::record_full_collection_end() {
 436   // Consider this like a collection pause for the purposes of allocation
 437   // since last pause.
 438   double end_sec = os::elapsedTime();
 439   double full_gc_time_sec = end_sec - _full_collection_start_sec;
 440   double full_gc_time_ms = full_gc_time_sec * 1000.0;
 441 
 442   _analytics-&gt;update_recent_gc_times(end_sec, full_gc_time_ms);
 443 
 444   collector_state()-&gt;set_in_full_gc(false);
 445 
 446   // &quot;Nuke&quot; the heuristics that control the young/mixed GC
 447   // transitions and make sure we start with young GCs after the Full GC.
 448   collector_state()-&gt;set_in_young_only_phase(true);
 449   collector_state()-&gt;set_in_young_gc_before_mixed(false);
 450   collector_state()-&gt;set_initiate_conc_mark_if_possible(need_to_start_conc_mark(&quot;end of Full GC&quot;, 0));
 451   collector_state()-&gt;set_in_initial_mark_gc(false);
 452   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
 453   collector_state()-&gt;set_clearing_next_bitmap(false);
 454 
 455   _eden_surv_rate_group-&gt;start_adding_regions();
 456   // also call this on any additional surv rate groups
 457 
 458   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 459   _survivor_surv_rate_group-&gt;reset();
<a name="35" id="anc35"></a><span class="line-modified"> 460   update_young_list_max_and_target_length();</span>
 461   update_rs_length_prediction();
 462 
 463   _old_gen_alloc_tracker.reset_after_full_gc();
 464 
 465   record_pause(FullGC, _full_collection_start_sec, end_sec);
 466 }
 467 
 468 static void log_refinement_stats(const char* kind, const G1ConcurrentRefineStats&amp; stats) {
 469   log_debug(gc, refine, stats)
 470            (&quot;%s refinement: %.2fms, refined: &quot; SIZE_FORMAT
 471             &quot;, precleaned: &quot; SIZE_FORMAT &quot;, dirtied: &quot; SIZE_FORMAT,
 472             kind,
 473             stats.refinement_time().seconds() * MILLIUNITS,
 474             stats.refined_cards(),
 475             stats.precleaned_cards(),
 476             stats.dirtied_cards());
 477 }
 478 
 479 void G1Policy::record_concurrent_refinement_stats() {
 480   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
 481   _pending_cards_at_gc_start = dcqs.num_cards();
 482 
 483   // Collect per-thread stats, mostly from mutator activity.
 484   G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();
 485 
 486   // Collect specialized concurrent refinement thread stats.
 487   G1ConcurrentRefine* cr = _g1h-&gt;concurrent_refine();
 488   G1ConcurrentRefineStats cr_stats = cr-&gt;get_and_reset_refinement_stats();
 489 
 490   G1ConcurrentRefineStats total_stats = mut_stats + cr_stats;
 491 
 492   log_refinement_stats(&quot;Mutator&quot;, mut_stats);
 493   log_refinement_stats(&quot;Concurrent&quot;, cr_stats);
 494   log_refinement_stats(&quot;Total&quot;, total_stats);
 495 
 496   // Record the rate at which cards were refined.
 497   // Don&#39;t update the rate if the current sample is empty or time is zero.
 498   Tickspan refinement_time = total_stats.refinement_time();
 499   size_t refined_cards = total_stats.refined_cards();
 500   if ((refined_cards &gt; 0) &amp;&amp; (refinement_time &gt; Tickspan())) {
 501     double rate = refined_cards / (refinement_time.seconds() * MILLIUNITS);
 502     _analytics-&gt;report_concurrent_refine_rate_ms(rate);
 503     log_debug(gc, refine, stats)(&quot;Concurrent refinement rate: %.2f cards/ms&quot;, rate);
 504   }
 505 
 506   // Record mutator&#39;s card logging rate.
 507   double mut_start_time = _analytics-&gt;prev_collection_pause_end_ms();
 508   double mut_end_time = phase_times()-&gt;cur_collection_start_sec() * MILLIUNITS;
 509   double mut_time = mut_end_time - mut_start_time;
 510   // Unlike above for conc-refine rate, here we should not require a
 511   // non-empty sample, since an application could go some time with only
 512   // young-gen or filtered out writes.  But we&#39;ll ignore unusually short
 513   // sample periods, as they may just pollute the predictions.
 514   if (mut_time &gt; 1.0) {   // Require &gt; 1ms sample time.
 515     double dirtied_rate = total_stats.dirtied_cards() / mut_time;
 516     _analytics-&gt;report_dirtied_cards_rate_ms(dirtied_rate);
 517     log_debug(gc, refine, stats)(&quot;Generate dirty cards rate: %.2f cards/ms&quot;, dirtied_rate);
 518   }
 519 }
 520 
 521 void G1Policy::record_collection_pause_start(double start_time_sec) {
 522   // We only need to do this here as the policy will only be applied
 523   // to the GC we&#39;re about to start. so, no point is calculating this
 524   // every time we calculate / recalculate the target young length.
 525   update_survivors_policy();
 526 
 527   assert(max_survivor_regions() + _g1h-&gt;num_used_regions() &lt;= _g1h-&gt;max_regions(),
 528          &quot;Maximum survivor regions %u plus used regions %u exceeds max regions %u&quot;,
 529          max_survivor_regions(), _g1h-&gt;num_used_regions(), _g1h-&gt;max_regions());
 530   assert_used_and_recalculate_used_equal(_g1h);
 531 
 532   phase_times()-&gt;record_cur_collection_start_sec(start_time_sec);
 533 
 534   record_concurrent_refinement_stats();
 535 
 536   _collection_set-&gt;reset_bytes_used_before();
 537 
 538   // do that for any other surv rate groups
 539   _eden_surv_rate_group-&gt;stop_adding_regions();
 540   _survivors_age_table.clear();
 541 
 542   assert(_g1h-&gt;collection_set()-&gt;verify_young_ages(), &quot;region age verification failed&quot;);
 543 }
 544 
 545 void G1Policy::record_concurrent_mark_init_end(double mark_init_elapsed_time_ms) {
 546   assert(!collector_state()-&gt;initiate_conc_mark_if_possible(), &quot;we should have cleared it by now&quot;);
 547   collector_state()-&gt;set_in_initial_mark_gc(false);
 548 }
 549 
 550 void G1Policy::record_concurrent_mark_remark_start() {
 551   _mark_remark_start_sec = os::elapsedTime();
 552 }
 553 
 554 void G1Policy::record_concurrent_mark_remark_end() {
 555   double end_time_sec = os::elapsedTime();
 556   double elapsed_time_ms = (end_time_sec - _mark_remark_start_sec)*1000.0;
 557   _analytics-&gt;report_concurrent_mark_remark_times_ms(elapsed_time_ms);
 558   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
 559 
 560   record_pause(Remark, _mark_remark_start_sec, end_time_sec);
 561 }
 562 
 563 void G1Policy::record_concurrent_mark_cleanup_start() {
 564   _mark_cleanup_start_sec = os::elapsedTime();
 565 }
 566 
 567 double G1Policy::average_time_ms(G1GCPhaseTimes::GCParPhases phase) const {
 568   return phase_times()-&gt;average_time_ms(phase);
 569 }
 570 
 571 double G1Policy::young_other_time_ms() const {
 572   return phase_times()-&gt;young_cset_choice_time_ms() +
 573          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::YoungFreeCSet);
 574 }
 575 
 576 double G1Policy::non_young_other_time_ms() const {
 577   return phase_times()-&gt;non_young_cset_choice_time_ms() +
 578          phase_times()-&gt;average_time_ms(G1GCPhaseTimes::NonYoungFreeCSet);
 579 }
 580 
 581 double G1Policy::other_time_ms(double pause_time_ms) const {
 582   return pause_time_ms - phase_times()-&gt;cur_collection_par_time_ms();
 583 }
 584 
 585 double G1Policy::constant_other_time_ms(double pause_time_ms) const {
 586   return other_time_ms(pause_time_ms) - phase_times()-&gt;total_free_cset_time_ms() - phase_times()-&gt;total_rebuild_freelist_time_ms();
 587 }
 588 
 589 bool G1Policy::about_to_start_mixed_phase() const {
 590   return _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle() || collector_state()-&gt;in_young_gc_before_mixed();
 591 }
 592 
 593 bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {
 594   if (about_to_start_mixed_phase()) {
 595     return false;
 596   }
 597 
 598   size_t marking_initiating_used_threshold = _ihop_control-&gt;get_conc_mark_start_threshold();
 599 
 600   size_t cur_used_bytes = _g1h-&gt;non_young_capacity_bytes();
 601   size_t alloc_byte_size = alloc_word_size * HeapWordSize;
 602   size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;
 603 
 604   bool result = false;
 605   if (marking_request_bytes &gt; marking_initiating_used_threshold) {
 606     result = collector_state()-&gt;in_young_only_phase() &amp;&amp; !collector_state()-&gt;in_young_gc_before_mixed();
 607     log_debug(gc, ergo, ihop)(&quot;%s occupancy: &quot; SIZE_FORMAT &quot;B allocation request: &quot; SIZE_FORMAT &quot;B threshold: &quot; SIZE_FORMAT &quot;B (%1.2f) source: %s&quot;,
 608                               result ? &quot;Request concurrent cycle initiation (occupancy higher than threshold)&quot; : &quot;Do not request concurrent cycle initiation (still doing mixed collections)&quot;,
 609                               cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold / _g1h-&gt;capacity() * 100, source);
 610   }
 611 
 612   return result;
 613 }
 614 
 615 double G1Policy::logged_cards_processing_time() const {
 616   double all_cards_processing_time = average_time_ms(G1GCPhaseTimes::ScanHR) + average_time_ms(G1GCPhaseTimes::OptScanHR);
 617   size_t logged_dirty_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);
 618   size_t scan_heap_roots_cards = phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
 619                                  phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
 620   // This may happen if there are duplicate cards in different log buffers.
 621   if (logged_dirty_cards &gt; scan_heap_roots_cards) {
 622     return all_cards_processing_time + average_time_ms(G1GCPhaseTimes::MergeLB);
 623   }
 624   return (all_cards_processing_time * logged_dirty_cards / scan_heap_roots_cards) + average_time_ms(G1GCPhaseTimes::MergeLB);
 625 }
 626 
 627 // Anything below that is considered to be zero
 628 #define MIN_TIMER_GRANULARITY 0.0000001
 629 
 630 void G1Policy::record_collection_pause_end(double pause_time_ms) {
 631   G1GCPhaseTimes* p = phase_times();
 632 
 633   double end_time_sec = os::elapsedTime();
 634 
 635   bool this_pause_included_initial_mark = false;
 636   bool this_pause_was_young_only = collector_state()-&gt;in_young_only_phase();
 637 
 638   bool update_stats = !_g1h-&gt;evacuation_failed();
 639 
 640   record_pause(young_gc_pause_kind(), end_time_sec - pause_time_ms / 1000.0, end_time_sec);
 641 
 642   _collection_pause_end_millis = os::javaTimeNanos() / NANOSECS_PER_MILLISEC;
 643 
 644   this_pause_included_initial_mark = collector_state()-&gt;in_initial_mark_gc();
 645   if (this_pause_included_initial_mark) {
 646     record_concurrent_mark_init_end(0.0);
 647   } else {
 648     maybe_start_marking();
 649   }
 650 
 651   double app_time_ms = (phase_times()-&gt;cur_collection_start_sec() * 1000.0 - _analytics-&gt;prev_collection_pause_end_ms());
 652   if (app_time_ms &lt; MIN_TIMER_GRANULARITY) {
 653     // This usually happens due to the timer not having the required
 654     // granularity. Some Linuxes are the usual culprits.
 655     // We&#39;ll just set it to something (arbitrarily) small.
 656     app_time_ms = 1.0;
 657   }
 658 
 659   if (update_stats) {
 660     // We maintain the invariant that all objects allocated by mutator
 661     // threads will be allocated out of eden regions. So, we can use
 662     // the eden region number allocated since the previous GC to
 663     // calculate the application&#39;s allocate rate. The only exception
 664     // to that is humongous objects that are allocated separately. But
 665     // given that humongous object allocations do not really affect
 666     // either the pause&#39;s duration nor when the next pause will take
 667     // place we can safely ignore them here.
 668     uint regions_allocated = _collection_set-&gt;eden_region_length();
 669     double alloc_rate_ms = (double) regions_allocated / app_time_ms;
 670     _analytics-&gt;report_alloc_rate_ms(alloc_rate_ms);
 671 
 672     _analytics-&gt;compute_pause_time_ratios(end_time_sec, pause_time_ms);
 673     _analytics-&gt;update_recent_gc_times(end_time_sec, pause_time_ms);
 674   }
 675 
 676   if (collector_state()-&gt;in_young_gc_before_mixed()) {
 677     assert(!this_pause_included_initial_mark, &quot;The young GC before mixed is not allowed to be an initial mark GC&quot;);
 678     // This has been the young GC before we start doing mixed GCs. We already
 679     // decided to start mixed GCs much earlier, so there is nothing to do except
 680     // advancing the state.
 681     collector_state()-&gt;set_in_young_only_phase(false);
 682     collector_state()-&gt;set_in_young_gc_before_mixed(false);
 683   } else if (!this_pause_was_young_only) {
 684     // This is a mixed GC. Here we decide whether to continue doing more
 685     // mixed GCs or not.
 686     if (!next_gc_should_be_mixed(&quot;continue mixed GCs&quot;,
 687                                  &quot;do not continue mixed GCs&quot;)) {
 688       collector_state()-&gt;set_in_young_only_phase(true);
 689 
 690       clear_collection_set_candidates();
 691       maybe_start_marking();
 692     }
 693   }
 694 
 695   _eden_surv_rate_group-&gt;start_adding_regions();
 696 
 697   double merge_hcc_time_ms = average_time_ms(G1GCPhaseTimes::MergeHCC);
 698   if (update_stats) {
 699     size_t const total_log_buffer_cards = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +
 700                                           p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);
 701     // Update prediction for card merge; MergeRSDirtyCards includes the cards from the Eager Reclaim phase.
 702     size_t const total_cards_merged = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +
 703                                       p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +
 704                                       total_log_buffer_cards;
 705 
 706     // The threshold for the number of cards in a given sampling which we consider
 707     // large enough so that the impact from setup and other costs is negligible.
 708     size_t const CardsNumSamplingThreshold = 10;
 709 
 710     if (total_cards_merged &gt; CardsNumSamplingThreshold) {
 711       double avg_time_merge_cards = average_time_ms(G1GCPhaseTimes::MergeER) +
 712                                     average_time_ms(G1GCPhaseTimes::MergeRS) +
 713                                     average_time_ms(G1GCPhaseTimes::MergeHCC) +
 714                                     average_time_ms(G1GCPhaseTimes::MergeLB) +
 715                                     average_time_ms(G1GCPhaseTimes::OptMergeRS);
 716       _analytics-&gt;report_cost_per_card_merge_ms(avg_time_merge_cards / total_cards_merged, this_pause_was_young_only);
 717     }
 718 
 719     // Update prediction for card scan
 720     size_t const total_cards_scanned = p-&gt;sum_thread_work_items(G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ScanHRScannedCards) +
 721                                        p-&gt;sum_thread_work_items(G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::ScanHRScannedCards);
 722 
 723     if (total_cards_scanned &gt; CardsNumSamplingThreshold) {
 724       double avg_time_dirty_card_scan = average_time_ms(G1GCPhaseTimes::ScanHR) +
 725                                         average_time_ms(G1GCPhaseTimes::OptScanHR);
 726 
 727       _analytics-&gt;report_cost_per_card_scan_ms(avg_time_dirty_card_scan / total_cards_scanned, this_pause_was_young_only);
 728     }
 729 
 730     // Update prediction for the ratio between cards from the remembered
 731     // sets and actually scanned cards from the remembered sets.
 732     // Cards from the remembered sets are all cards not duplicated by cards from
 733     // the logs.
 734     // Due to duplicates in the log buffers, the number of actually scanned cards
 735     // can be smaller than the cards in the log buffers.
 736     const size_t from_rs_length_cards = (total_cards_scanned &gt; total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;
 737     double merge_to_scan_ratio = 0.0;
 738     if (total_cards_scanned &gt; 0) {
 739       merge_to_scan_ratio = (double) from_rs_length_cards / total_cards_scanned;
 740     }
 741     _analytics-&gt;report_card_merge_to_scan_ratio(merge_to_scan_ratio, this_pause_was_young_only);
 742 
 743     const size_t recorded_rs_length = _collection_set-&gt;recorded_rs_length();
 744     const size_t rs_length_diff = _rs_length &gt; recorded_rs_length ? _rs_length - recorded_rs_length : 0;
 745     _analytics-&gt;report_rs_length_diff(rs_length_diff);
 746 
 747     // Update prediction for copy cost per byte
 748     size_t copied_bytes = p-&gt;sum_thread_work_items(G1GCPhaseTimes::MergePSS, G1GCPhaseTimes::MergePSSCopiedBytes);
 749 
 750     if (copied_bytes &gt; 0) {
 751       double cost_per_byte_ms = (average_time_ms(G1GCPhaseTimes::ObjCopy) + average_time_ms(G1GCPhaseTimes::OptObjCopy)) / copied_bytes;
 752       _analytics-&gt;report_cost_per_byte_ms(cost_per_byte_ms, collector_state()-&gt;mark_or_rebuild_in_progress());
 753     }
 754 
 755     if (_collection_set-&gt;young_region_length() &gt; 0) {
 756       _analytics-&gt;report_young_other_cost_per_region_ms(young_other_time_ms() /
 757                                                         _collection_set-&gt;young_region_length());
 758     }
 759 
 760     if (_collection_set-&gt;old_region_length() &gt; 0) {
 761       _analytics-&gt;report_non_young_other_cost_per_region_ms(non_young_other_time_ms() /
 762                                                             _collection_set-&gt;old_region_length());
 763     }
 764 
 765     _analytics-&gt;report_constant_other_time_ms(constant_other_time_ms(pause_time_ms));
 766 
 767     // Do not update RS lengths and the number of pending cards with information from mixed gc:
 768     // these are is wildly different to during young only gc and mess up young gen sizing right
 769     // after the mixed gc phase.
 770     // During mixed gc we do not use them for young gen sizing.
 771     if (this_pause_was_young_only) {
 772       _analytics-&gt;report_pending_cards((double) _pending_cards_at_gc_start);
 773       _analytics-&gt;report_rs_length((double) _rs_length);
 774     }
 775   }
 776 
 777   assert(!(this_pause_included_initial_mark &amp;&amp; collector_state()-&gt;mark_or_rebuild_in_progress()),
 778          &quot;If the last pause has been an initial mark, we should not have been in the marking window&quot;);
 779   if (this_pause_included_initial_mark) {
 780     collector_state()-&gt;set_mark_or_rebuild_in_progress(true);
 781   }
 782 
 783   _free_regions_at_end_of_collection = _g1h-&gt;num_free_regions();
 784 
 785   update_rs_length_prediction();
 786 
 787   // Do not update dynamic IHOP due to G1 periodic collection as it is highly likely
 788   // that in this case we are not running in a &quot;normal&quot; operating mode.
 789   if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
<a name="36" id="anc36"></a><span class="line-modified"> 790     // IHOP control wants to know the expected young gen length if it were not</span>
<span class="line-added"> 791     // restrained by the heap reserve. Using the actual length would make the</span>
<span class="line-added"> 792     // prediction too small and the limit the young gen every time we get to the</span>
<span class="line-added"> 793     // predicted target occupancy.</span>
<span class="line-added"> 794     size_t last_unrestrained_young_length = update_young_list_max_and_target_length();</span>
 795 
 796     _old_gen_alloc_tracker.reset_after_young_gc(app_time_ms / 1000.0);
 797     update_ihop_prediction(_old_gen_alloc_tracker.last_cycle_duration(),
 798                            _old_gen_alloc_tracker.last_cycle_old_bytes(),
<a name="37" id="anc37"></a><span class="line-added"> 799                            last_unrestrained_young_length * HeapRegion::GrainBytes,</span>
 800                            this_pause_was_young_only);
 801 
 802     _ihop_control-&gt;send_trace_event(_g1h-&gt;gc_tracer_stw());
 803   } else {
 804     // Any garbage collection triggered as periodic collection resets the time-to-mixed
 805     // measurement. Periodic collection typically means that the application is &quot;inactive&quot;, i.e.
 806     // the marking threads may have received an uncharacterisic amount of cpu time
 807     // for completing the marking, i.e. are faster than expected.
 808     // This skews the predicted marking length towards smaller values which might cause
 809     // the mark start being too late.
 810     _initial_mark_to_mixed.reset();
 811   }
 812 
 813   // Note that _mmu_tracker-&gt;max_gc_time() returns the time in seconds.
 814   double scan_logged_cards_time_goal_ms = _mmu_tracker-&gt;max_gc_time() * MILLIUNITS * G1RSetUpdatingPauseTimePercent / 100.0;
 815 
 816   if (scan_logged_cards_time_goal_ms &lt; merge_hcc_time_ms) {
 817     log_debug(gc, ergo, refine)(&quot;Adjust concurrent refinement thresholds (scanning the HCC expected to take longer than Update RS time goal).&quot;
 818                                 &quot;Logged Cards Scan time goal: %1.2fms Scan HCC time: %1.2fms&quot;,
 819                                 scan_logged_cards_time_goal_ms, merge_hcc_time_ms);
 820 
 821     scan_logged_cards_time_goal_ms = 0;
 822   } else {
 823     scan_logged_cards_time_goal_ms -= merge_hcc_time_ms;
 824   }
 825 
 826   double const logged_cards_time = logged_cards_processing_time();
 827 
 828   log_debug(gc, ergo, refine)(&quot;Concurrent refinement times: Logged Cards Scan time goal: %1.2fms Logged Cards Scan time: %1.2fms HCC time: %1.2fms&quot;,
 829                               scan_logged_cards_time_goal_ms, logged_cards_time, merge_hcc_time_ms);
 830 
 831   _g1h-&gt;concurrent_refine()-&gt;adjust(logged_cards_time,
 832                                     phase_times()-&gt;sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards),
 833                                     scan_logged_cards_time_goal_ms);
 834 }
 835 
 836 G1IHOPControl* G1Policy::create_ihop_control(const G1Predictions* predictor){
 837   if (G1UseAdaptiveIHOP) {
 838     return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,
 839                                      predictor,
 840                                      G1ReservePercent,
 841                                      G1HeapWastePercent);
 842   } else {
 843     return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent);
 844   }
 845 }
 846 
 847 void G1Policy::update_ihop_prediction(double mutator_time_s,
 848                                       size_t mutator_alloc_bytes,
<a name="38" id="anc38"></a><span class="line-added"> 849                                       size_t young_gen_size,</span>
 850                                       bool this_gc_was_young_only) {
 851   // Always try to update IHOP prediction. Even evacuation failures give information
 852   // about e.g. whether to start IHOP earlier next time.
 853 
 854   // Avoid using really small application times that might create samples with
 855   // very high or very low values. They may be caused by e.g. back-to-back gcs.
 856   double const min_valid_time = 1e-6;
 857 
 858   bool report = false;
 859 
 860   double marking_to_mixed_time = -1.0;
 861   if (!this_gc_was_young_only &amp;&amp; _initial_mark_to_mixed.has_result()) {
 862     marking_to_mixed_time = _initial_mark_to_mixed.last_marking_time();
 863     assert(marking_to_mixed_time &gt; 0.0,
 864            &quot;Initial mark to mixed time must be larger than zero but is %.3f&quot;,
 865            marking_to_mixed_time);
 866     if (marking_to_mixed_time &gt; min_valid_time) {
 867       _ihop_control-&gt;update_marking_length(marking_to_mixed_time);
 868       report = true;
 869     }
 870   }
 871 
 872   // As an approximation for the young gc promotion rates during marking we use
 873   // all of them. In many applications there are only a few if any young gcs during
 874   // marking, which makes any prediction useless. This increases the accuracy of the
 875   // prediction.
 876   if (this_gc_was_young_only &amp;&amp; mutator_time_s &gt; min_valid_time) {
<a name="39" id="anc39"></a>




 877     _ihop_control-&gt;update_allocation_info(mutator_time_s, mutator_alloc_bytes, young_gen_size);
 878     report = true;
 879   }
 880 
 881   if (report) {
 882     report_ihop_statistics();
 883   }
 884 }
 885 
 886 void G1Policy::report_ihop_statistics() {
 887   _ihop_control-&gt;print();
 888 }
 889 
 890 void G1Policy::print_phases() {
 891   phase_times()-&gt;print();
 892 }
 893 
 894 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,
 895                                               size_t rs_length) const {
 896   size_t effective_scanned_cards = _analytics-&gt;predict_scan_card_num(rs_length, collector_state()-&gt;in_young_only_phase());
 897   return
 898     _analytics-&gt;predict_card_merge_time_ms(pending_cards + rs_length, collector_state()-&gt;in_young_only_phase()) +
 899     _analytics-&gt;predict_card_scan_time_ms(effective_scanned_cards, collector_state()-&gt;in_young_only_phase()) +
 900     _analytics-&gt;predict_constant_other_time_ms() +
 901     predict_survivor_regions_evac_time();
 902 }
 903 
 904 double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {
 905   size_t rs_length = _analytics-&gt;predict_rs_length();
 906   return predict_base_elapsed_time_ms(pending_cards, rs_length);
 907 }
 908 
 909 size_t G1Policy::predict_bytes_to_copy(HeapRegion* hr) const {
 910   size_t bytes_to_copy;
 911   if (!hr-&gt;is_young()) {
 912     bytes_to_copy = hr-&gt;max_live_bytes();
 913   } else {
 914     bytes_to_copy = (size_t) (hr-&gt;used() * hr-&gt;surv_rate_prediction(_predictor));
 915   }
 916   return bytes_to_copy;
 917 }
 918 
 919 double G1Policy::predict_eden_copy_time_ms(uint count, size_t* bytes_to_copy) const {
 920   if (count == 0) {
 921     return 0.0;
 922   }
 923   size_t const expected_bytes = _eden_surv_rate_group-&gt;accum_surv_rate_pred(count) * HeapRegion::GrainBytes;
 924   if (bytes_to_copy != NULL) {
 925     *bytes_to_copy = expected_bytes;
 926   }
 927   return _analytics-&gt;predict_object_copy_time_ms(expected_bytes, collector_state()-&gt;mark_or_rebuild_in_progress());
 928 }
 929 
 930 double G1Policy::predict_region_copy_time_ms(HeapRegion* hr) const {
 931   size_t const bytes_to_copy = predict_bytes_to_copy(hr);
 932   return _analytics-&gt;predict_object_copy_time_ms(bytes_to_copy, collector_state()-&gt;mark_or_rebuild_in_progress());
 933 }
 934 
 935 double G1Policy::predict_region_non_copy_time_ms(HeapRegion* hr,
 936                                                  bool for_young_gc) const {
 937   size_t rs_length = hr-&gt;rem_set()-&gt;occupied();
 938   size_t scan_card_num = _analytics-&gt;predict_scan_card_num(rs_length, for_young_gc);
 939 
 940   double region_elapsed_time_ms =
 941     _analytics-&gt;predict_card_merge_time_ms(rs_length, collector_state()-&gt;in_young_only_phase()) +
 942     _analytics-&gt;predict_card_scan_time_ms(scan_card_num, collector_state()-&gt;in_young_only_phase());
 943 
 944   // The prediction of the &quot;other&quot; time for this region is based
 945   // upon the region type and NOT the GC type.
 946   if (hr-&gt;is_young()) {
 947     region_elapsed_time_ms += _analytics-&gt;predict_young_other_time_ms(1);
 948   } else {
 949     region_elapsed_time_ms += _analytics-&gt;predict_non_young_other_time_ms(1);
 950   }
 951   return region_elapsed_time_ms;
 952 }
 953 
 954 double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const {
 955   return predict_region_non_copy_time_ms(hr, for_young_gc) + predict_region_copy_time_ms(hr);
 956 }
 957 
 958 bool G1Policy::should_allocate_mutator_region() const {
 959   uint young_list_length = _g1h-&gt;young_regions_count();
 960   uint young_list_target_length = _young_list_target_length;
 961   return young_list_length &lt; young_list_target_length;
 962 }
 963 
 964 bool G1Policy::can_expand_young_list() const {
 965   uint young_list_length = _g1h-&gt;young_regions_count();
 966   uint young_list_max_length = _young_list_max_length;
 967   return young_list_length &lt; young_list_max_length;
 968 }
 969 
 970 bool G1Policy::use_adaptive_young_list_length() const {
 971   return _young_gen_sizer-&gt;use_adaptive_young_list_length();
 972 }
 973 
 974 size_t G1Policy::desired_survivor_size(uint max_regions) const {
 975   size_t const survivor_capacity = HeapRegion::GrainWords * max_regions;
 976   return (size_t)((((double)survivor_capacity) * TargetSurvivorRatio) / 100);
 977 }
 978 
 979 void G1Policy::print_age_table() {
 980   _survivors_age_table.print_age_table(_tenuring_threshold);
 981 }
 982 
<a name="40" id="anc40"></a><span class="line-modified"> 983 void G1Policy::update_max_gc_locker_expansion() {</span>
 984   uint expansion_region_num = 0;
 985   if (GCLockerEdenExpansionPercent &gt; 0) {
 986     double perc = (double) GCLockerEdenExpansionPercent / 100.0;
 987     double expansion_region_num_d = perc * (double) _young_list_target_length;
 988     // We use ceiling so that if expansion_region_num_d is &gt; 0.0 (but
 989     // less than 1.0) we&#39;ll get 1.
 990     expansion_region_num = (uint) ceil(expansion_region_num_d);
 991   } else {
 992     assert(expansion_region_num == 0, &quot;sanity&quot;);
 993   }
<a name="41" id="anc41"></a><span class="line-modified"> 994   _young_list_max_length = _young_list_target_length + expansion_region_num;</span>
<span class="line-modified"> 995   assert(_young_list_target_length &lt;= _young_list_max_length, &quot;post-condition&quot;);</span>

 996 }
 997 
 998 // Calculates survivor space parameters.
 999 void G1Policy::update_survivors_policy() {
1000   double max_survivor_regions_d =
1001                  (double) _young_list_target_length / (double) SurvivorRatio;
1002 
1003   // Calculate desired survivor size based on desired max survivor regions (unconstrained
1004   // by remaining heap). Otherwise we may cause undesired promotions as we are
1005   // already getting close to end of the heap, impacting performance even more.
1006   uint const desired_max_survivor_regions = ceil(max_survivor_regions_d);
1007   size_t const survivor_size = desired_survivor_size(desired_max_survivor_regions);
1008 
1009   _tenuring_threshold = _survivors_age_table.compute_tenuring_threshold(survivor_size);
1010   if (UsePerfData) {
1011     _policy_counters-&gt;tenuring_threshold()-&gt;set_value(_tenuring_threshold);
1012     _policy_counters-&gt;desired_survivor_size()-&gt;set_value(survivor_size * oopSize);
1013   }
1014   // The real maximum survivor size is bounded by the number of regions that can
1015   // be allocated into.
1016   _max_survivor_regions = MIN2(desired_max_survivor_regions,
1017                                _g1h-&gt;num_free_or_available_regions());
1018 }
1019 
1020 bool G1Policy::force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause) {
1021   // We actually check whether we are marking here and not if we are in a
1022   // reclamation phase. This means that we will schedule a concurrent mark
1023   // even while we are still in the process of reclaiming memory.
1024   bool during_cycle = _g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
1025   if (!during_cycle) {
1026     log_debug(gc, ergo)(&quot;Request concurrent cycle initiation (requested by GC cause). GC cause: %s&quot;, GCCause::to_string(gc_cause));
1027     collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
1028     return true;
1029   } else {
1030     log_debug(gc, ergo)(&quot;Do not request concurrent cycle initiation (concurrent cycle already in progress). GC cause: %s&quot;, GCCause::to_string(gc_cause));
1031     return false;
1032   }
1033 }
1034 
1035 void G1Policy::initiate_conc_mark() {
1036   collector_state()-&gt;set_in_initial_mark_gc(true);
1037   collector_state()-&gt;set_initiate_conc_mark_if_possible(false);
1038 }
1039 
1040 void G1Policy::decide_on_conc_mark_initiation() {
1041   // We are about to decide on whether this pause will be an
1042   // initial-mark pause.
1043 
1044   // First, collector_state()-&gt;in_initial_mark_gc() should not be already set. We
1045   // will set it here if we have to. However, it should be cleared by
1046   // the end of the pause (it&#39;s only set for the duration of an
1047   // initial-mark pause).
1048   assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;pre-condition&quot;);
1049 
1050   if (collector_state()-&gt;initiate_conc_mark_if_possible()) {
1051     // We had noticed on a previous pause that the heap occupancy has
1052     // gone over the initiating threshold and we should start a
1053     // concurrent marking cycle.  Or we&#39;ve been explicitly requested
1054     // to start a concurrent marking cycle.  Either way, we initiate
1055     // one if not inhibited for some reason.
1056 
1057     GCCause::Cause cause = _g1h-&gt;gc_cause();
1058     if ((cause != GCCause::_wb_breakpoint) &amp;&amp;
1059         ConcurrentGCBreakpoints::is_controlled()) {
1060       log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (whitebox controlled)&quot;);
1061     } else if (!about_to_start_mixed_phase() &amp;&amp; collector_state()-&gt;in_young_only_phase()) {
1062       // Initiate a new initial mark if there is no marking or reclamation going on.
1063       initiate_conc_mark();
1064       log_debug(gc, ergo)(&quot;Initiate concurrent cycle (concurrent cycle initiation requested)&quot;);
1065     } else if (_g1h-&gt;is_user_requested_concurrent_full_gc(cause) ||
1066                (cause == GCCause::_wb_breakpoint)) {
1067       // Initiate a user requested initial mark or run_to a breakpoint.
1068       // An initial mark must be young only GC, so the collector state
1069       // must be updated to reflect this.
1070       collector_state()-&gt;set_in_young_only_phase(true);
1071       collector_state()-&gt;set_in_young_gc_before_mixed(false);
1072 
1073       // We might have ended up coming here about to start a mixed phase with a collection set
1074       // active. The following remark might change the change the &quot;evacuation efficiency&quot; of
1075       // the regions in this set, leading to failing asserts later.
1076       // Since the concurrent cycle will recreate the collection set anyway, simply drop it here.
1077       clear_collection_set_candidates();
1078       abort_time_to_mixed_tracking();
1079       initiate_conc_mark();
1080       log_debug(gc, ergo)(&quot;Initiate concurrent cycle (%s requested concurrent cycle)&quot;,
1081                           (cause == GCCause::_wb_breakpoint) ? &quot;run_to breakpoint&quot; : &quot;user&quot;);
1082     } else {
1083       // The concurrent marking thread is still finishing up the
1084       // previous cycle. If we start one right now the two cycles
1085       // overlap. In particular, the concurrent marking thread might
1086       // be in the process of clearing the next marking bitmap (which
1087       // we will use for the next cycle if we start one). Starting a
1088       // cycle now will be bad given that parts of the marking
1089       // information might get cleared by the marking thread. And we
1090       // cannot wait for the marking thread to finish the cycle as it
1091       // periodically yields while clearing the next marking bitmap
1092       // and, if it&#39;s in a yield point, it&#39;s waiting for us to
1093       // finish. So, at this point we will not start a cycle and we&#39;ll
1094       // let the concurrent marking thread complete the last one.
1095       log_debug(gc, ergo)(&quot;Do not initiate concurrent cycle (concurrent cycle already in progress)&quot;);
1096     }
1097   }
1098 }
1099 
1100 void G1Policy::record_concurrent_mark_cleanup_end() {
1101   G1CollectionSetCandidates* candidates = G1CollectionSetChooser::build(_g1h-&gt;workers(), _g1h-&gt;num_regions());
1102   _collection_set-&gt;set_candidates(candidates);
1103 
1104   bool mixed_gc_pending = next_gc_should_be_mixed(&quot;request mixed gcs&quot;, &quot;request young-only gcs&quot;);
1105   if (!mixed_gc_pending) {
1106     clear_collection_set_candidates();
1107     abort_time_to_mixed_tracking();
1108   }
1109   collector_state()-&gt;set_in_young_gc_before_mixed(mixed_gc_pending);
1110   collector_state()-&gt;set_mark_or_rebuild_in_progress(false);
1111 
1112   double end_sec = os::elapsedTime();
1113   double elapsed_time_ms = (end_sec - _mark_cleanup_start_sec) * 1000.0;
1114   _analytics-&gt;report_concurrent_mark_cleanup_times_ms(elapsed_time_ms);
1115   _analytics-&gt;append_prev_collection_pause_end_ms(elapsed_time_ms);
1116 
1117   record_pause(Cleanup, _mark_cleanup_start_sec, end_sec);
1118 }
1119 
1120 double G1Policy::reclaimable_bytes_percent(size_t reclaimable_bytes) const {
1121   return percent_of(reclaimable_bytes, _g1h-&gt;capacity());
1122 }
1123 
1124 class G1ClearCollectionSetCandidateRemSets : public HeapRegionClosure {
1125   virtual bool do_heap_region(HeapRegion* r) {
1126     r-&gt;rem_set()-&gt;clear_locked(true /* only_cardset */);
1127     return false;
1128   }
1129 };
1130 
1131 void G1Policy::clear_collection_set_candidates() {
1132   // Clear remembered sets of remaining candidate regions and the actual candidate
1133   // set.
1134   G1ClearCollectionSetCandidateRemSets cl;
1135   _collection_set-&gt;candidates()-&gt;iterate(&amp;cl);
1136   _collection_set-&gt;clear_candidates();
1137 }
1138 
1139 void G1Policy::maybe_start_marking() {
1140   if (need_to_start_conc_mark(&quot;end of GC&quot;)) {
1141     // Note: this might have already been set, if during the last
1142     // pause we decided to start a cycle but at the beginning of
1143     // this pause we decided to postpone it. That&#39;s OK.
1144     collector_state()-&gt;set_initiate_conc_mark_if_possible(true);
1145   }
1146 }
1147 
1148 G1Policy::PauseKind G1Policy::young_gc_pause_kind() const {
1149   assert(!collector_state()-&gt;in_full_gc(), &quot;must be&quot;);
1150   if (collector_state()-&gt;in_initial_mark_gc()) {
1151     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1152     return InitialMarkGC;
1153   } else if (collector_state()-&gt;in_young_gc_before_mixed()) {
1154     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1155     return LastYoungGC;
1156   } else if (collector_state()-&gt;in_mixed_phase()) {
1157     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1158     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1159     return MixedGC;
1160   } else {
1161     assert(!collector_state()-&gt;in_initial_mark_gc(), &quot;must be&quot;);
1162     assert(!collector_state()-&gt;in_young_gc_before_mixed(), &quot;must be&quot;);
1163     return YoungOnlyGC;
1164   }
1165 }
1166 
1167 void G1Policy::record_pause(PauseKind kind, double start, double end) {
1168   // Manage the MMU tracker. For some reason it ignores Full GCs.
1169   if (kind != FullGC) {
1170     _mmu_tracker-&gt;add_pause(start, end);
1171   }
1172   // Manage the mutator time tracking from initial mark to first mixed gc.
1173   switch (kind) {
1174     case FullGC:
1175       abort_time_to_mixed_tracking();
1176       break;
1177     case Cleanup:
1178     case Remark:
1179     case YoungOnlyGC:
1180     case LastYoungGC:
1181       _initial_mark_to_mixed.add_pause(end - start);
1182       break;
1183     case InitialMarkGC:
1184       if (_g1h-&gt;gc_cause() != GCCause::_g1_periodic_collection) {
1185         _initial_mark_to_mixed.record_initial_mark_end(end);
1186       }
1187       break;
1188     case MixedGC:
1189       _initial_mark_to_mixed.record_mixed_gc_start(start);
1190       break;
1191     default:
1192       ShouldNotReachHere();
1193   }
1194 }
1195 
1196 void G1Policy::abort_time_to_mixed_tracking() {
1197   _initial_mark_to_mixed.reset();
1198 }
1199 
1200 bool G1Policy::next_gc_should_be_mixed(const char* true_action_str,
1201                                        const char* false_action_str) const {
1202   G1CollectionSetCandidates* candidates = _collection_set-&gt;candidates();
1203 
<a name="42" id="anc42"></a><span class="line-modified">1204   if (candidates-&gt;is_empty()) {</span>
<span class="line-modified">1205     log_debug(gc, ergo)(&quot;%s (candidate old regions not available)&quot;, false_action_str);</span>


1206     return false;
1207   }
1208 
1209   // Is the amount of uncollected reclaimable space above G1HeapWastePercent?
1210   size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
1211   double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
1212   double threshold = (double) G1HeapWastePercent;
1213   if (reclaimable_percent &lt;= threshold) {
<a name="43" id="anc43"></a><span class="line-modified">1214     log_debug(gc, ergo)(&quot;%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-modified">1215                         false_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>


1216     return false;
1217   }
<a name="44" id="anc44"></a><span class="line-modified">1218   log_debug(gc, ergo)(&quot;%s (candidate old regions available). candidate old regions: %u reclaimable: &quot; SIZE_FORMAT &quot; (%1.2f) threshold: &quot; UINTX_FORMAT,</span>
<span class="line-modified">1219                       true_action_str, candidates-&gt;num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);</span>


1220   return true;
1221 }
1222 
1223 uint G1Policy::calc_min_old_cset_length() const {
1224   // The min old CSet region bound is based on the maximum desired
1225   // number of mixed GCs after a cycle. I.e., even if some old regions
1226   // look expensive, we should add them to the CSet anyway to make
1227   // sure we go through the available old regions in no more than the
1228   // maximum desired number of mixed GCs.
1229   //
1230   // The calculation is based on the number of marked regions we added
1231   // to the CSet candidates in the first place, not how many remain, so
1232   // that the result is the same during all mixed GCs that follow a cycle.
1233 
1234   const size_t region_num = _collection_set-&gt;candidates()-&gt;num_regions();
1235   const size_t gc_num = (size_t) MAX2(G1MixedGCCountTarget, (uintx) 1);
1236   size_t result = region_num / gc_num;
1237   // emulate ceiling
1238   if (result * gc_num &lt; region_num) {
1239     result += 1;
1240   }
1241   return (uint) result;
1242 }
1243 
1244 uint G1Policy::calc_max_old_cset_length() const {
1245   // The max old CSet region bound is based on the threshold expressed
1246   // as a percentage of the heap size. I.e., it should bound the
1247   // number of old regions added to the CSet irrespective of how many
1248   // of them are available.
1249 
1250   const G1CollectedHeap* g1h = G1CollectedHeap::heap();
1251   const size_t region_num = g1h-&gt;num_regions();
1252   const size_t perc = (size_t) G1OldCSetRegionThresholdPercent;
1253   size_t result = region_num * perc / 100;
1254   // emulate ceiling
1255   if (100 * result &lt; region_num * perc) {
1256     result += 1;
1257   }
1258   return (uint) result;
1259 }
1260 
1261 void G1Policy::calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
1262                                                     double time_remaining_ms,
1263                                                     uint&amp; num_initial_regions,
1264                                                     uint&amp; num_optional_regions) {
1265   assert(candidates != NULL, &quot;Must be&quot;);
1266 
1267   num_initial_regions = 0;
1268   num_optional_regions = 0;
1269   uint num_expensive_regions = 0;
1270 
1271   double predicted_old_time_ms = 0.0;
1272   double predicted_initial_time_ms = 0.0;
1273   double predicted_optional_time_ms = 0.0;
1274 
1275   double optional_threshold_ms = time_remaining_ms * optional_prediction_fraction();
1276 
1277   const uint min_old_cset_length = calc_min_old_cset_length();
1278   const uint max_old_cset_length = MAX2(min_old_cset_length, calc_max_old_cset_length());
1279   const uint max_optional_regions = max_old_cset_length - min_old_cset_length;
1280   bool check_time_remaining = use_adaptive_young_list_length();
1281 
1282   uint candidate_idx = candidates-&gt;cur_idx();
1283 
1284   log_debug(gc, ergo, cset)(&quot;Start adding old regions to collection set. Min %u regions, max %u regions, &quot;
1285                             &quot;time remaining %1.2fms, optional threshold %1.2fms&quot;,
1286                             min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);
1287 
1288   HeapRegion* hr = candidates-&gt;at(candidate_idx);
1289   while (hr != NULL) {
1290     if (num_initial_regions + num_optional_regions &gt;= max_old_cset_length) {
1291       // Added maximum number of old regions to the CSet.
1292       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Maximum number of regions). &quot;
1293                                 &quot;Initial %u regions, optional %u regions&quot;,
1294                                 num_initial_regions, num_optional_regions);
1295       break;
1296     }
1297 
1298     // Stop adding regions if the remaining reclaimable space is
1299     // not above G1HeapWastePercent.
1300     size_t reclaimable_bytes = candidates-&gt;remaining_reclaimable_bytes();
1301     double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);
1302     double threshold = (double) G1HeapWastePercent;
1303     if (reclaimable_percent &lt;= threshold) {
1304       // We&#39;ve added enough old regions that the amount of uncollected
1305       // reclaimable space is at or below the waste threshold. Stop
1306       // adding old regions to the CSet.
1307       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Reclaimable percentage below threshold). &quot;
1308                                 &quot;Reclaimable: &quot; SIZE_FORMAT &quot;%s (%1.2f%%) threshold: &quot; UINTX_FORMAT &quot;%%&quot;,
1309                                 byte_size_in_proper_unit(reclaimable_bytes), proper_unit_for_byte_size(reclaimable_bytes),
1310                                 reclaimable_percent, G1HeapWastePercent);
1311       break;
1312     }
1313 
1314     double predicted_time_ms = predict_region_total_time_ms(hr, false);
1315     time_remaining_ms = MAX2(time_remaining_ms - predicted_time_ms, 0.0);
1316     // Add regions to old set until we reach the minimum amount
1317     if (num_initial_regions &lt; min_old_cset_length) {
1318       predicted_old_time_ms += predicted_time_ms;
1319       num_initial_regions++;
1320       // Record the number of regions added with no time remaining
1321       if (time_remaining_ms == 0.0) {
1322         num_expensive_regions++;
1323       }
1324     } else if (!check_time_remaining) {
1325       // In the non-auto-tuning case, we&#39;ll finish adding regions
1326       // to the CSet if we reach the minimum.
1327       log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Region amount reached min).&quot;);
1328       break;
1329     } else {
1330       // Keep adding regions to old set until we reach the optional threshold
1331       if (time_remaining_ms &gt; optional_threshold_ms) {
1332         predicted_old_time_ms += predicted_time_ms;
1333         num_initial_regions++;
1334       } else if (time_remaining_ms &gt; 0) {
1335         // Keep adding optional regions until time is up.
1336         assert(num_optional_regions &lt; max_optional_regions, &quot;Should not be possible.&quot;);
1337         predicted_optional_time_ms += predicted_time_ms;
1338         num_optional_regions++;
1339       } else {
1340         log_debug(gc, ergo, cset)(&quot;Finish adding old regions to collection set (Predicted time too high).&quot;);
1341         break;
1342       }
1343     }
1344     hr = candidates-&gt;at(++candidate_idx);
1345   }
1346   if (hr == NULL) {
1347     log_debug(gc, ergo, cset)(&quot;Old candidate collection set empty.&quot;);
1348   }
1349 
1350   if (num_expensive_regions &gt; 0) {
1351     log_debug(gc, ergo, cset)(&quot;Added %u initial old regions to collection set although the predicted time was too high.&quot;,
1352                               num_expensive_regions);
1353   }
1354 
1355   log_debug(gc, ergo, cset)(&quot;Finish choosing collection set old regions. Initial: %u, optional: %u, &quot;
1356                             &quot;predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f&quot;,
1357                             num_initial_regions, num_optional_regions,
1358                             predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms);
1359 }
1360 
1361 void G1Policy::calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,
1362                                                          uint const max_optional_regions,
1363                                                          double time_remaining_ms,
1364                                                          uint&amp; num_optional_regions) {
1365   assert(_g1h-&gt;collector_state()-&gt;in_mixed_phase(), &quot;Should only be called in mixed phase&quot;);
1366 
1367   num_optional_regions = 0;
1368   double prediction_ms = 0;
1369   uint candidate_idx = candidates-&gt;cur_idx();
1370 
1371   HeapRegion* r = candidates-&gt;at(candidate_idx);
1372   while (num_optional_regions &lt; max_optional_regions) {
1373     assert(r != NULL, &quot;Region must exist&quot;);
1374     prediction_ms += predict_region_total_time_ms(r, false);
1375 
1376     if (prediction_ms &gt; time_remaining_ms) {
1377       log_debug(gc, ergo, cset)(&quot;Prediction %.3fms for region %u does not fit remaining time: %.3fms.&quot;,
1378                                 prediction_ms, r-&gt;hrm_index(), time_remaining_ms);
1379       break;
1380     }
1381     // This region will be included in the next optional evacuation.
1382 
1383     time_remaining_ms -= prediction_ms;
1384     num_optional_regions++;
1385     r = candidates-&gt;at(++candidate_idx);
1386   }
1387 
1388   log_debug(gc, ergo, cset)(&quot;Prepared %u regions out of %u for optional evacuation. Predicted time: %.3fms&quot;,
1389                             num_optional_regions, max_optional_regions, prediction_ms);
1390 }
1391 
1392 void G1Policy::transfer_survivors_to_cset(const G1SurvivorRegions* survivors) {
1393   note_start_adding_survivor_regions();
1394 
1395   HeapRegion* last = NULL;
1396   for (GrowableArrayIterator&lt;HeapRegion*&gt; it = survivors-&gt;regions()-&gt;begin();
1397        it != survivors-&gt;regions()-&gt;end();
1398        ++it) {
1399     HeapRegion* curr = *it;
1400     set_region_survivor(curr);
1401 
1402     // The region is a non-empty survivor so let&#39;s add it to
1403     // the incremental collection set for the next evacuation
1404     // pause.
1405     _collection_set-&gt;add_survivor_regions(curr);
1406 
1407     last = curr;
1408   }
1409   note_stop_adding_survivor_regions();
1410 
1411   // Don&#39;t clear the survivor list handles until the start of
1412   // the next evacuation pause - we need it in order to re-tag
1413   // the survivor regions from this evacuation pause as &#39;young&#39;
1414   // at the start of the next.
1415 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
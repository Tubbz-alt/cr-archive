<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1Policy.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/shenandoahInitLogger.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1Policy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 //   * when to collect.
 44 
 45 class HeapRegion;
 46 class G1CollectionSet;
 47 class G1CollectionSetCandidates;
 48 class G1CollectionSetChooser;
 49 class G1IHOPControl;
 50 class G1Analytics;
 51 class G1SurvivorRegions;
 52 class G1YoungGenSizer;
 53 class GCPolicyCounters;
 54 class STWGCTimer;
 55 
 56 class G1Policy: public CHeapObj&lt;mtGC&gt; {
 57  private:
 58 
 59   static G1IHOPControl* create_ihop_control(const G1Predictions* predictor);
 60   // Update the IHOP control with necessary statistics.
 61   void update_ihop_prediction(double mutator_time_s,
 62                               size_t mutator_alloc_bytes,

 63                               bool this_gc_was_young_only);
 64   void report_ihop_statistics();
 65 
 66   G1Predictions _predictor;
 67   G1Analytics* _analytics;
 68   G1RemSetTrackingPolicy _remset_tracker;
 69   G1MMUTracker* _mmu_tracker;
 70   G1IHOPControl* _ihop_control;
 71 
 72   GCPolicyCounters* _policy_counters;
 73 
 74   double _full_collection_start_sec;
 75 
 76   jlong _collection_pause_end_millis;
 77 
<span class="line-removed"> 78   uint _young_list_desired_length;</span>
 79   uint _young_list_target_length;

 80 
 81   // The max number of regions we can extend the eden by while the GC
 82   // locker is active. This should be &gt;= _young_list_target_length;
 83   uint _young_list_max_length;
 84 
 85   // The survivor rate groups below must be initialized after the predictor because they
 86   // indirectly use it through the &quot;this&quot; object passed to their constructor.
 87   G1SurvRateGroup* _eden_surv_rate_group;
 88   G1SurvRateGroup* _survivor_surv_rate_group;
 89 
 90   double _reserve_factor;
 91   // This will be set when the heap is expanded
 92   // for the first time during initialization.
 93   uint   _reserve_regions;
 94 
 95   G1YoungGenSizer* _young_gen_sizer;
 96 
 97   uint _free_regions_at_end_of_collection;
 98 
 99   size_t _rs_length;
</pre>
<hr />
<pre>
152     bool update = should_update_surv_rate_group_predictors();
153 
154     _eden_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
155     _survivor_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
156   }
157 
158   G1MMUTracker* mmu_tracker() {
159     return _mmu_tracker;
160   }
161 
162   const G1MMUTracker* mmu_tracker() const {
163     return _mmu_tracker;
164   }
165 
166   double max_pause_time_ms() const {
167     return _mmu_tracker-&gt;max_gc_time() * 1000.0;
168   }
169 
170 private:
171   G1CollectionSet* _collection_set;
<span class="line-removed">172 </span>
<span class="line-removed">173   bool next_gc_should_be_mixed(const char* true_action_str,</span>
<span class="line-removed">174                                const char* false_action_str) const;</span>
<span class="line-removed">175 </span>
176   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
177   double other_time_ms(double pause_time_ms) const;
178 
179   double young_other_time_ms() const;
180   double non_young_other_time_ms() const;
181   double constant_other_time_ms(double pause_time_ms) const;
182 
183   G1CollectionSetChooser* cset_chooser() const;
184 
185   // Stash a pointer to the g1 heap.
186   G1CollectedHeap* _g1h;
187 
188   G1GCPhaseTimes* _phase_times;
189 
190   // This set of variables tracks the collector efficiency, in order to
191   // determine whether we should initiate a new marking.
192   double _mark_remark_start_sec;
193   double _mark_cleanup_start_sec;
194 
<span class="line-modified">195   // Updates the internal young gen maximum and target and desired lengths.</span>
<span class="line-modified">196   // If no rs_length parameter is passed, predict the RS length using the</span>
<span class="line-modified">197   // prediction model, otherwise use the given rs_length as the prediction.</span>
<span class="line-modified">198   void update_young_length_bounds();</span>
<span class="line-modified">199   void update_young_length_bounds(size_t rs_length);</span>
<span class="line-modified">200 </span>
<span class="line-modified">201   // Calculate and return the minimum desired eden length based on the MMU target.</span>
<span class="line-modified">202   uint calculate_desired_eden_length_by_mmu() const;</span>
<span class="line-modified">203 </span>
<span class="line-modified">204   // Calculate and return the desired eden length that can fit into the pause time goal.</span>
<span class="line-modified">205   // The parameters are: rs_length represents the prediction of how large the</span>
<span class="line-modified">206   // young RSet lengths will be, min_eden_length and max_eden_length are the bounds</span>
<span class="line-modified">207   // (inclusive) within eden can grow.</span>
<span class="line-modified">208   uint calculate_desired_eden_length_by_pause(double base_time_ms,</span>
<span class="line-modified">209                                               uint min_eden_length,</span>
<span class="line-modified">210                                               uint max_eden_length) const;</span>
<span class="line-modified">211 </span>
<span class="line-modified">212   // Calculates the desired eden length before mixed gc so that after adding the</span>
<span class="line-modified">213   // minimum amount of old gen regions from the collection set, the eden fits into</span>
<span class="line-modified">214   // the pause time goal.</span>
<span class="line-modified">215   uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,</span>
<span class="line-modified">216                                                   uint min_eden_length,</span>
<span class="line-modified">217                                                   uint max_eden_length) const;</span>
<span class="line-modified">218 </span>
<span class="line-modified">219   // Calculate desired young length based on current situation without taking actually</span>
<span class="line-modified">220   // available free regions into account.</span>
<span class="line-modified">221   uint calculate_young_desired_length(size_t rs_length) const;</span>
<span class="line-modified">222   // Limit the given desired young length to available free regions.</span>
<span class="line-modified">223   uint calculate_young_target_length(uint desired_young_length) const;</span>
<span class="line-modified">224   // The GCLocker might cause us to need more regions than the target. Calculate</span>
<span class="line-modified">225   // the maximum number of regions to use in that case.</span>
<span class="line-modified">226   uint calculate_young_max_length(uint target_young_length) const;</span>






227 
228   void update_rs_length_prediction();
229   void update_rs_length_prediction(size_t prediction);
230 
231   size_t predict_bytes_to_copy(HeapRegion* hr) const;
232   double predict_survivor_regions_evac_time() const;
233 
234   // Check whether a given young length (young_length) fits into the
235   // given target pause time and whether the prediction for the amount
236   // of objects to be copied for the given length will fit into the
237   // given free space (expressed by base_free_regions).  It is used by
238   // calculate_young_list_target_length().
239   bool predict_will_fit(uint young_length, double base_time_ms,
240                         uint base_free_regions, double target_pause_time_ms) const;
241 
242 public:
243   size_t pending_cards_at_gc_start() const { return _pending_cards_at_gc_start; }
244 
245   // Calculate the minimum number of old regions we&#39;ll add to the CSet
246   // during a mixed GC.
</pre>
<hr />
<pre>
315   void record_collection_pause_start(double start_time_sec);
316   virtual void record_collection_pause_end(double pause_time_ms);
317 
318   // Record the start and end of a full collection.
319   void record_full_collection_start();
320   virtual void record_full_collection_end();
321 
322   // Must currently be called while the world is stopped.
323   void record_concurrent_mark_init_end(double mark_init_elapsed_time_ms);
324 
325   // Record start and end of remark.
326   void record_concurrent_mark_remark_start();
327   void record_concurrent_mark_remark_end();
328 
329   // Record start, end, and completion of cleanup.
330   void record_concurrent_mark_cleanup_start();
331   void record_concurrent_mark_cleanup_end();
332 
333   void print_phases();
334 



335   // Calculate and return the number of initial and optional old gen regions from
336   // the given collection set candidates and the remaining time.
337   void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
338                                             double time_remaining_ms,
339                                             uint&amp; num_initial_regions,
340                                             uint&amp; num_optional_regions);
341 
342   // Calculate the number of optional regions from the given collection set candidates,
343   // the remaining time and the maximum number of these regions and return the number
344   // of actually selected regions in num_optional_regions.
345   void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,
346                                                  uint const max_optional_regions,
347                                                  double time_remaining_ms,
348                                                  uint&amp; num_optional_regions);
349 
350 private:
351   // Set the state to start a concurrent marking cycle and clear
352   // _initiate_conc_mark_if_possible because it has now been
353   // acted on.
354   void initiate_conc_mark();
355 
356 public:
357   // This sets the initiate_conc_mark_if_possible() flag to start a
358   // new cycle, as long as we are not already in one. It&#39;s best if it
359   // is called during a safepoint when the test whether a cycle is in
360   // progress or not is stable.
361   bool force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause);
362 
363   // This is called at the very beginning of an evacuation pause (it
364   // has to be the first thing that the pause does). If
365   // initiate_conc_mark_if_possible() is true, and the concurrent
366   // marking thread has completed its work during the previous cycle,
367   // it will set in_initial_mark_gc() to so that the pause does
368   // the initial-mark work and start a marking cycle.
369   void decide_on_conc_mark_initiation();
370 
<span class="line-removed">371   uint young_list_desired_length() const { return _young_list_desired_length; }</span>
372   size_t young_list_target_length() const { return _young_list_target_length; }
373 
374   bool should_allocate_mutator_region() const;
375 
376   bool can_expand_young_list() const;
377 
378   uint young_list_max_length() const {
379     return _young_list_max_length;
380   }
381 
382   bool use_adaptive_young_list_length() const;
383 
384   void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
385 
386 private:
387   //
388   // Survivor regions policy.
389   //
390 
391   // Current tenuring threshold, set to 0 if the collector reaches the
</pre>
<hr />
<pre>
412   uint tenuring_threshold() const { return _tenuring_threshold; }
413 
414   uint max_survivor_regions() {
415     return _max_survivor_regions;
416   }
417 
418   void note_start_adding_survivor_regions() {
419     _survivor_surv_rate_group-&gt;start_adding_regions();
420   }
421 
422   void note_stop_adding_survivor_regions() {
423     _survivor_surv_rate_group-&gt;stop_adding_regions();
424   }
425 
426   void record_age_table(AgeTable* age_table) {
427     _survivors_age_table.merge(age_table);
428   }
429 
430   void print_age_table();
431 


432   void update_survivors_policy();
433 
434   virtual bool force_upgrade_to_full() {
435     return false;
436   }
437 };
438 
439 #endif // SHARE_GC_G1_G1POLICY_HPP
</pre>
</td>
<td>
<hr />
<pre>
 43 //   * when to collect.
 44 
 45 class HeapRegion;
 46 class G1CollectionSet;
 47 class G1CollectionSetCandidates;
 48 class G1CollectionSetChooser;
 49 class G1IHOPControl;
 50 class G1Analytics;
 51 class G1SurvivorRegions;
 52 class G1YoungGenSizer;
 53 class GCPolicyCounters;
 54 class STWGCTimer;
 55 
 56 class G1Policy: public CHeapObj&lt;mtGC&gt; {
 57  private:
 58 
 59   static G1IHOPControl* create_ihop_control(const G1Predictions* predictor);
 60   // Update the IHOP control with necessary statistics.
 61   void update_ihop_prediction(double mutator_time_s,
 62                               size_t mutator_alloc_bytes,
<span class="line-added"> 63                               size_t young_gen_size,</span>
 64                               bool this_gc_was_young_only);
 65   void report_ihop_statistics();
 66 
 67   G1Predictions _predictor;
 68   G1Analytics* _analytics;
 69   G1RemSetTrackingPolicy _remset_tracker;
 70   G1MMUTracker* _mmu_tracker;
 71   G1IHOPControl* _ihop_control;
 72 
 73   GCPolicyCounters* _policy_counters;
 74 
 75   double _full_collection_start_sec;
 76 
 77   jlong _collection_pause_end_millis;
 78 

 79   uint _young_list_target_length;
<span class="line-added"> 80   uint _young_list_fixed_length;</span>
 81 
 82   // The max number of regions we can extend the eden by while the GC
 83   // locker is active. This should be &gt;= _young_list_target_length;
 84   uint _young_list_max_length;
 85 
 86   // The survivor rate groups below must be initialized after the predictor because they
 87   // indirectly use it through the &quot;this&quot; object passed to their constructor.
 88   G1SurvRateGroup* _eden_surv_rate_group;
 89   G1SurvRateGroup* _survivor_surv_rate_group;
 90 
 91   double _reserve_factor;
 92   // This will be set when the heap is expanded
 93   // for the first time during initialization.
 94   uint   _reserve_regions;
 95 
 96   G1YoungGenSizer* _young_gen_sizer;
 97 
 98   uint _free_regions_at_end_of_collection;
 99 
100   size_t _rs_length;
</pre>
<hr />
<pre>
153     bool update = should_update_surv_rate_group_predictors();
154 
155     _eden_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
156     _survivor_surv_rate_group-&gt;all_surviving_words_recorded(predictor(), update);
157   }
158 
159   G1MMUTracker* mmu_tracker() {
160     return _mmu_tracker;
161   }
162 
163   const G1MMUTracker* mmu_tracker() const {
164     return _mmu_tracker;
165   }
166 
167   double max_pause_time_ms() const {
168     return _mmu_tracker-&gt;max_gc_time() * 1000.0;
169   }
170 
171 private:
172   G1CollectionSet* _collection_set;




173   double average_time_ms(G1GCPhaseTimes::GCParPhases phase) const;
174   double other_time_ms(double pause_time_ms) const;
175 
176   double young_other_time_ms() const;
177   double non_young_other_time_ms() const;
178   double constant_other_time_ms(double pause_time_ms) const;
179 
180   G1CollectionSetChooser* cset_chooser() const;
181 
182   // Stash a pointer to the g1 heap.
183   G1CollectedHeap* _g1h;
184 
185   G1GCPhaseTimes* _phase_times;
186 
187   // This set of variables tracks the collector efficiency, in order to
188   // determine whether we should initiate a new marking.
189   double _mark_remark_start_sec;
190   double _mark_cleanup_start_sec;
191 
<span class="line-modified">192   // Updates the internal young list maximum and target lengths. Returns the</span>
<span class="line-modified">193   // unbounded young list target length. If no rs_length parameter is passed,</span>
<span class="line-modified">194   // predict the RS length using the prediction model, otherwise use the</span>
<span class="line-modified">195   // given rs_length as the prediction.</span>
<span class="line-modified">196   uint update_young_list_max_and_target_length();</span>
<span class="line-modified">197   uint update_young_list_max_and_target_length(size_t rs_length);</span>
<span class="line-modified">198 </span>
<span class="line-modified">199   // Update the young list target length either by setting it to the</span>
<span class="line-modified">200   // desired fixed value or by calculating it using G1&#39;s pause</span>
<span class="line-modified">201   // prediction model.</span>
<span class="line-modified">202   // Returns the unbounded young list target length.</span>
<span class="line-modified">203   uint update_young_list_target_length(size_t rs_length);</span>
<span class="line-modified">204 </span>
<span class="line-modified">205   // Calculate and return the minimum desired young list target</span>
<span class="line-modified">206   // length. This is the minimum desired young list length according</span>
<span class="line-modified">207   // to the user&#39;s inputs.</span>
<span class="line-modified">208   uint calculate_young_list_desired_min_length(uint base_min_length) const;</span>
<span class="line-modified">209 </span>
<span class="line-modified">210   // Calculate and return the maximum desired young list target</span>
<span class="line-modified">211   // length. This is the maximum desired young list length according</span>
<span class="line-modified">212   // to the user&#39;s inputs.</span>
<span class="line-modified">213   uint calculate_young_list_desired_max_length() const;</span>
<span class="line-modified">214 </span>
<span class="line-modified">215   // Calculate and return the maximum young list target length that</span>
<span class="line-modified">216   // can fit into the pause time goal. The parameters are: rs_length</span>
<span class="line-modified">217   // represent the prediction of how large the young RSet lengths will</span>
<span class="line-modified">218   // be, base_min_length is the already existing number of regions in</span>
<span class="line-modified">219   // the young list, min_length and max_length are the desired min and</span>
<span class="line-modified">220   // max young list length according to the user&#39;s inputs.</span>
<span class="line-modified">221   uint calculate_young_list_target_length(size_t rs_length,</span>
<span class="line-modified">222                                           uint base_min_length,</span>
<span class="line-modified">223                                           uint desired_min_length,</span>
<span class="line-added">224                                           uint desired_max_length) const;</span>
<span class="line-added">225 </span>
<span class="line-added">226   // Result of the bounded_young_list_target_length() method, containing both the</span>
<span class="line-added">227   // bounded as well as the unbounded young list target lengths in this order.</span>
<span class="line-added">228   typedef Pair&lt;uint, uint, StackObj&gt; YoungTargetLengths;</span>
<span class="line-added">229   YoungTargetLengths young_list_target_lengths(size_t rs_length) const;</span>
230 
231   void update_rs_length_prediction();
232   void update_rs_length_prediction(size_t prediction);
233 
234   size_t predict_bytes_to_copy(HeapRegion* hr) const;
235   double predict_survivor_regions_evac_time() const;
236 
237   // Check whether a given young length (young_length) fits into the
238   // given target pause time and whether the prediction for the amount
239   // of objects to be copied for the given length will fit into the
240   // given free space (expressed by base_free_regions).  It is used by
241   // calculate_young_list_target_length().
242   bool predict_will_fit(uint young_length, double base_time_ms,
243                         uint base_free_regions, double target_pause_time_ms) const;
244 
245 public:
246   size_t pending_cards_at_gc_start() const { return _pending_cards_at_gc_start; }
247 
248   // Calculate the minimum number of old regions we&#39;ll add to the CSet
249   // during a mixed GC.
</pre>
<hr />
<pre>
318   void record_collection_pause_start(double start_time_sec);
319   virtual void record_collection_pause_end(double pause_time_ms);
320 
321   // Record the start and end of a full collection.
322   void record_full_collection_start();
323   virtual void record_full_collection_end();
324 
325   // Must currently be called while the world is stopped.
326   void record_concurrent_mark_init_end(double mark_init_elapsed_time_ms);
327 
328   // Record start and end of remark.
329   void record_concurrent_mark_remark_start();
330   void record_concurrent_mark_remark_end();
331 
332   // Record start, end, and completion of cleanup.
333   void record_concurrent_mark_cleanup_start();
334   void record_concurrent_mark_cleanup_end();
335 
336   void print_phases();
337 
<span class="line-added">338   bool next_gc_should_be_mixed(const char* true_action_str,</span>
<span class="line-added">339                                const char* false_action_str) const;</span>
<span class="line-added">340 </span>
341   // Calculate and return the number of initial and optional old gen regions from
342   // the given collection set candidates and the remaining time.
343   void calculate_old_collection_set_regions(G1CollectionSetCandidates* candidates,
344                                             double time_remaining_ms,
345                                             uint&amp; num_initial_regions,
346                                             uint&amp; num_optional_regions);
347 
348   // Calculate the number of optional regions from the given collection set candidates,
349   // the remaining time and the maximum number of these regions and return the number
350   // of actually selected regions in num_optional_regions.
351   void calculate_optional_collection_set_regions(G1CollectionSetCandidates* candidates,
352                                                  uint const max_optional_regions,
353                                                  double time_remaining_ms,
354                                                  uint&amp; num_optional_regions);
355 
356 private:
357   // Set the state to start a concurrent marking cycle and clear
358   // _initiate_conc_mark_if_possible because it has now been
359   // acted on.
360   void initiate_conc_mark();
361 
362 public:
363   // This sets the initiate_conc_mark_if_possible() flag to start a
364   // new cycle, as long as we are not already in one. It&#39;s best if it
365   // is called during a safepoint when the test whether a cycle is in
366   // progress or not is stable.
367   bool force_initial_mark_if_outside_cycle(GCCause::Cause gc_cause);
368 
369   // This is called at the very beginning of an evacuation pause (it
370   // has to be the first thing that the pause does). If
371   // initiate_conc_mark_if_possible() is true, and the concurrent
372   // marking thread has completed its work during the previous cycle,
373   // it will set in_initial_mark_gc() to so that the pause does
374   // the initial-mark work and start a marking cycle.
375   void decide_on_conc_mark_initiation();
376 

377   size_t young_list_target_length() const { return _young_list_target_length; }
378 
379   bool should_allocate_mutator_region() const;
380 
381   bool can_expand_young_list() const;
382 
383   uint young_list_max_length() const {
384     return _young_list_max_length;
385   }
386 
387   bool use_adaptive_young_list_length() const;
388 
389   void transfer_survivors_to_cset(const G1SurvivorRegions* survivors);
390 
391 private:
392   //
393   // Survivor regions policy.
394   //
395 
396   // Current tenuring threshold, set to 0 if the collector reaches the
</pre>
<hr />
<pre>
417   uint tenuring_threshold() const { return _tenuring_threshold; }
418 
419   uint max_survivor_regions() {
420     return _max_survivor_regions;
421   }
422 
423   void note_start_adding_survivor_regions() {
424     _survivor_surv_rate_group-&gt;start_adding_regions();
425   }
426 
427   void note_stop_adding_survivor_regions() {
428     _survivor_surv_rate_group-&gt;stop_adding_regions();
429   }
430 
431   void record_age_table(AgeTable* age_table) {
432     _survivors_age_table.merge(age_table);
433   }
434 
435   void print_age_table();
436 
<span class="line-added">437   void update_max_gc_locker_expansion();</span>
<span class="line-added">438 </span>
439   void update_survivors_policy();
440 
441   virtual bool force_upgrade_to_full() {
442     return false;
443   }
444 };
445 
446 #endif // SHARE_GC_G1_G1POLICY_HPP
</pre>
</td>
</tr>
</table>
<center><a href="g1Policy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shenandoah/shenandoahInitLogger.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
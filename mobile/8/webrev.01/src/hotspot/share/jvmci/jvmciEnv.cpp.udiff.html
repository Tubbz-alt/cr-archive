<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/jvmci/jvmciEnv.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciCompilerToVM.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciEnv.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -75,14 +75,10 @@</span>
      return true;
    }
    return false;
  }
  
<span class="udiff-line-removed">- JavaVM* JVMCIEnv::_shared_library_javavm = NULL;</span>
<span class="udiff-line-removed">- void* JVMCIEnv::_shared_library_handle = NULL;</span>
<span class="udiff-line-removed">- char* JVMCIEnv::_shared_library_path = NULL;</span>
<span class="udiff-line-removed">- </span>
  void JVMCIEnv::copy_saved_properties() {
    assert(!is_hotspot(), &quot;can only copy saved properties from HotSpot to native image&quot;);
  
    JavaThread* THREAD = JavaThread::current();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,79 +125,26 @@</span>
    }
  
    // Initialize saved properties in shared library
    jclass servicesClass = JNIJVMCI::Services::clazz();
    jmethodID initializeSavedProperties = JNIJVMCI::Services::initializeSavedProperties_method();
<span class="udiff-line-modified-removed">-   JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+   JNIAccessMark jni(this, THREAD);</span>
    jni()-&gt;CallStaticVoidMethod(servicesClass, initializeSavedProperties, buf.as_jobject());
    if (jni()-&gt;ExceptionCheck()) {
      jni()-&gt;ExceptionDescribe();
      fatal(&quot;Error calling jdk.vm.ci.services.Services.initializeSavedProperties&quot;);
    }
  }
  
<span class="udiff-line-removed">- JNIEnv* JVMCIEnv::init_shared_library(JavaThread* thread) {</span>
<span class="udiff-line-removed">-   if (_shared_library_javavm == NULL) {</span>
<span class="udiff-line-removed">-     MutexLocker locker(JVMCI_lock);</span>
<span class="udiff-line-removed">-     if (_shared_library_javavm == NULL) {</span>
<span class="udiff-line-removed">-       char path[JVM_MAXPATHLEN];</span>
<span class="udiff-line-removed">-       char ebuf[1024];</span>
<span class="udiff-line-removed">-       if (JVMCILibPath != NULL) {</span>
<span class="udiff-line-removed">-         if (!os::dll_locate_lib(path, sizeof(path), JVMCILibPath, JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="udiff-line-removed">-           vm_exit_during_initialization(&quot;Unable to create JVMCI shared library path from -XX:JVMCILibPath value&quot;, JVMCILibPath);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         if (!os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), JVMCI_SHARED_LIBRARY_NAME)) {</span>
<span class="udiff-line-removed">-           vm_exit_during_initialization(&quot;Unable to create path to JVMCI shared library&quot;);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       void* handle = os::dll_load(path, ebuf, sizeof ebuf);</span>
<span class="udiff-line-removed">-       if (handle == NULL) {</span>
<span class="udiff-line-removed">-         vm_exit_during_initialization(&quot;Unable to load JVMCI shared library&quot;, ebuf);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       _shared_library_handle = handle;</span>
<span class="udiff-line-removed">-       _shared_library_path = strdup(path);</span>
<span class="udiff-line-removed">-       jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="udiff-line-removed">-       typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(handle, &quot;JNI_CreateJavaVM&quot;));</span>
<span class="udiff-line-removed">-       JNIEnv* env;</span>
<span class="udiff-line-removed">-       if (JNI_CreateJavaVM == NULL) {</span>
<span class="udiff-line-removed">-         vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, path);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       ResourceMark rm;</span>
<span class="udiff-line-removed">-       JavaVMInitArgs vm_args;</span>
<span class="udiff-line-removed">-       vm_args.version = JNI_VERSION_1_2;</span>
<span class="udiff-line-removed">-       vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="udiff-line-removed">-       vm_args.options = NULL;</span>
<span class="udiff-line-removed">-       vm_args.nOptions = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       JavaVM* the_javavm = NULL;</span>
<span class="udiff-line-removed">-       int result = (*JNI_CreateJavaVM)(&amp;the_javavm, (void**) &amp;env, &amp;vm_args);</span>
<span class="udiff-line-removed">-       if (result == JNI_OK) {</span>
<span class="udiff-line-removed">-         guarantee(env != NULL, &quot;missing env&quot;);</span>
<span class="udiff-line-removed">-         _shared_library_javavm = the_javavm;</span>
<span class="udiff-line-removed">-         return env;</span>
<span class="udiff-line-removed">-       } else {</span>
<span class="udiff-line-removed">-         vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), path);</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   return NULL;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JVMCIEnv::init_env_mode_runtime(JavaThread* thread, JNIEnv* parent_env) {
    assert(thread != NULL, &quot;npe&quot;);
<span class="udiff-line-removed">-   // By default there is only one runtime which is the compiler runtime.</span>
<span class="udiff-line-removed">-   _runtime = JVMCI::compiler_runtime();</span>
    _env = NULL;
    _pop_frame_on_close = false;
    _detach_on_close = false;
    if (!UseJVMCINativeLibrary) {
      // In HotSpot mode, JNI isn&#39;t used at all.
<span class="udiff-line-added">+     _runtime = JVMCI::java_runtime();</span>
      _is_hotspot = true;
      return;
    }
  
    if (parent_env != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,24 +154,28 @@</span>
      if (_is_hotspot) {
        // Select the Java runtime
        _runtime = JVMCI::java_runtime();
        return;
      }
<span class="udiff-line-added">+     _runtime = JVMCI::compiler_runtime();</span>
<span class="udiff-line-added">+     assert(_runtime != NULL, &quot;npe&quot;);</span>
      _env = parent_env;
      return;
    }
  
    // Running in JVMCI shared library mode so ensure the shared library
    // is loaded and initialized and get a shared library JNIEnv
    _is_hotspot = false;
<span class="udiff-line-modified-removed">-   _env = init_shared_library(thread);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   _runtime = JVMCI::compiler_runtime();</span>
<span class="udiff-line-added">+   _env = _runtime-&gt;init_shared_library_javavm();</span>
  
    if (_env != NULL) {
      // Creating the JVMCI shared library VM also attaches the current thread
      _detach_on_close = true;
    } else {
<span class="udiff-line-modified-removed">-     _shared_library_javavm-&gt;GetEnv((void**)&amp;parent_env, JNI_VERSION_1_2);</span>
<span class="udiff-line-modified-added">+     _runtime-&gt;GetEnv(thread, (void**)&amp;parent_env, JNI_VERSION_1_2);</span>
      if (parent_env != NULL) {
        // Even though there&#39;s a parent JNI env, there&#39;s no guarantee
        // it was opened by a JVMCIEnv scope and thus may not have
        // pushed a local JNI frame. As such, we use a new JNI local
        // frame in this scope to ensure local JNI refs are collected
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,21 +185,21 @@</span>
        ResourceMark rm; // Thread name is resource allocated
        JavaVMAttachArgs attach_args;
        attach_args.version = JNI_VERSION_1_2;
        attach_args.name = thread-&gt;name();
        attach_args.group = NULL;
<span class="udiff-line-modified-removed">-       if (_shared_library_javavm-&gt;AttachCurrentThread((void**)&amp;_env, &amp;attach_args) != JNI_OK) {</span>
<span class="udiff-line-modified-added">+       if (_runtime-&gt;AttachCurrentThread(thread, (void**) &amp;_env, &amp;attach_args) != JNI_OK) {</span>
          fatal(&quot;Error attaching current thread (%s) to JVMCI shared library JNI interface&quot;, attach_args.name);
        }
        _detach_on_close = true;
      }
    }
  
    assert(_env != NULL, &quot;missing env&quot;);
    assert(_throw_to_caller == false, &quot;must be&quot;);
  
<span class="udiff-line-modified-removed">-   JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+   JNIAccessMark jni(this, thread);</span>
    jint result = _env-&gt;PushLocalFrame(32);
    if (result != JNI_OK) {
      char message[256];
      jio_snprintf(message, 256, &quot;Uncaught exception pushing local frame for JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
      JVMCIRuntime::exit_on_pending_exception(this, message);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -292,21 +239,21 @@</span>
    }
  }
  
  // Prints a pending exception (if any) and its stack trace.
  void JVMCIEnv::describe_pending_exception(bool clear) {
<span class="udiff-line-added">+   Thread* THREAD = Thread::current();</span>
    if (!is_hotspot()) {
      JNIAccessMark jni(this);
      if (jni()-&gt;ExceptionCheck()) {
        jthrowable ex = !clear ? jni()-&gt;ExceptionOccurred() : NULL;
        jni()-&gt;ExceptionDescribe();
        if (ex != NULL) {
          jni()-&gt;Throw(ex);
        }
      }
    } else {
<span class="udiff-line-removed">-     Thread* THREAD = Thread::current();</span>
      if (HAS_PENDING_EXCEPTION) {
        JVMCIRuntime::describe_pending_hotspot_exception((JavaThread*) THREAD, clear);
      }
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -330,11 +277,11 @@</span>
    oop encoded_throwable_string = (oop) result.get_jobject();
  
    ResourceMark rm;
    const char* encoded_throwable_chars = java_lang_String::as_utf8_string(encoded_throwable_string);
  
<span class="udiff-line-modified-removed">-   JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+   JNIAccessMark jni(this, THREAD);</span>
    jobject jni_encoded_throwable_string = jni()-&gt;NewStringUTF(encoded_throwable_chars);
    jthrowable jni_throwable = (jthrowable) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                  JNIJVMCI::HotSpotJVMCIRuntime::decodeThrowable_method(),
                                  jni_encoded_throwable_string);
    jni()-&gt;Throw(jni_throwable);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -366,11 +313,11 @@</span>
        jio_snprintf(message, 256, &quot;Uncaught exception exiting JVMCIEnv scope entered at %s:%d&quot;, _file, _line);
        JVMCIRuntime::exit_on_pending_exception(this, message);
      }
  
      if (_detach_on_close) {
<span class="udiff-line-modified-removed">-       get_shared_library_javavm()-&gt;DetachCurrentThread();</span>
<span class="udiff-line-modified-added">+       _runtime-&gt;DetachCurrentThread(JavaThread::current());</span>
      }
    }
  }
  
  jboolean JVMCIEnv::has_pending_exception() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -601,16 +548,16 @@</span>
      case T_DOUBLE:
        break;
      default:
        JVMCI_THROW_MSG_(IllegalArgumentException, &quot;Only boxes for primitive values can be created&quot;, JVMCIObject());
    }
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      oop box = java_lang_boxing_object::create(type, value, CHECK_(JVMCIObject()));
      return HotSpotJVMCI::wrap(box);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject box = jni()-&gt;NewObjectA(JNIJVMCI::box_class(type), JNIJVMCI::box_constructor(type), value);
      assert(box != NULL, &quot;&quot;);
      return wrap(box);
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -670,17 +617,17 @@</span>
    va_start(ap, format);
    char msg[max_msg_size];
    vsnprintf(msg, max_msg_size, format, ap);
    msg[max_msg_size-1] = &#39;\0&#39;;
    va_end(ap);
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      Handle h_loader = Handle();
      Handle h_protection_domain = Handle();
      Exceptions::_throw_msg(THREAD, file, line, vmSymbols::jdk_vm_ci_common_JVMCIError(), msg, h_loader, h_protection_domain);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jni()-&gt;ThrowNew(JNIJVMCI::JVMCIError::clazz(), msg);
    }
  }
  
  JVMCIObject JVMCIEnv::call_HotSpotJVMCIRuntime_compileMethod (JVMCIObject runtime, JVMCIObject method, int entry_bci,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -733,11 +680,11 @@</span>
      JavaCallArguments jargs;
      jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
      JavaValue result(T_VOID);
      JavaCalls::call_special(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::shutdown_name(), vmSymbols::void_method_signature(), &amp;jargs, THREAD);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jni()-&gt;CallNonvirtualVoidMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::shutdown_method());
    }
    if (has_pending_exception()) {
      // This should never happen as HotSpotJVMCIRuntime.shutdown() should
      // handle all exceptions.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -751,11 +698,11 @@</span>
      JavaCallArguments jargs;
      JavaValue result(T_OBJECT);
      JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::runtime_name(), vmSymbols::runtime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(), JNIJVMCI::HotSpotJVMCIRuntime::runtime_method());
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
      }
      return wrap(result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -768,11 +715,11 @@</span>
      JavaCallArguments jargs;
      JavaValue result(T_OBJECT);
      JavaCalls::call_static(&amp;result, HotSpotJVMCI::JVMCI::klass(), vmSymbols::getRuntime_name(), vmSymbols::getRuntime_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JVMCI::clazz(), JNIJVMCI::JVMCI::getRuntime_method());
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
      }
      return wrap(result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -786,11 +733,11 @@</span>
      jargs.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(runtime)));
      JavaValue result(T_OBJECT);
      JavaCalls::call_virtual(&amp;result, HotSpotJVMCI::HotSpotJVMCIRuntime::klass(), vmSymbols::getCompiler_name(), vmSymbols::getCompiler_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;CallObjectMethod(runtime.as_jobject(), JNIJVMCI::HotSpotJVMCIRuntime::getCompiler_method());
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
      }
      return wrap(result);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -808,11 +755,11 @@</span>
                             HotSpotJVMCI::HotSpotJVMCIRuntime::klass(),
                             vmSymbols::callToString_name(),
                             vmSymbols::callToString_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotJVMCIRuntime::clazz(),
                                                       JNIJVMCI::HotSpotJVMCIRuntime::callToString_method(),
                                                       object.as_jobject());
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -833,11 +780,11 @@</span>
                             HotSpotJVMCI::PrimitiveConstant::klass(),
                             vmSymbols::forTypeChar_name(),
                             vmSymbols::forTypeChar_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::PrimitiveConstant::clazz(),
                                                       JNIJVMCI::PrimitiveConstant::forTypeChar_method(),
                                                       kind, value);
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -856,11 +803,11 @@</span>
                             HotSpotJVMCI::JavaConstant::klass(),
                             vmSymbols::forFloat_name(),
                             vmSymbols::forFloat_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                       JNIJVMCI::JavaConstant::forFloat_method(),
                                                       value);
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -879,11 +826,11 @@</span>
                             HotSpotJVMCI::JavaConstant::klass(),
                             vmSymbols::forDouble_name(),
                             vmSymbols::forDouble_signature(), &amp;jargs, CHECK_(JVMCIObject()));
      return wrap((oop) result.get_jobject());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = (jstring) jni()-&gt;CallStaticObjectMethod(JNIJVMCI::JavaConstant::clazz(),
                                                       JNIJVMCI::JavaConstant::forDouble_method(),
                                                       value);
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -924,11 +871,11 @@</span>
        HotSpotJVMCI::StackTraceElement::set_fileName(this, obj(), file_name);
      }
      HotSpotJVMCI::StackTraceElement::set_lineNumber(this, obj(), line_number);
      return wrap(obj());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject declaring_class = jni()-&gt;NewStringUTF(declaring_class_str);
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
      }
      jobject method_name = jni()-&gt;NewStringUTF(method_name_sym-&gt;as_C_string());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -976,11 +923,11 @@</span>
                              vmSymbols::object_initializer_name(),
                              vmSymbols::method_string_bool_long_signature(),
                              &amp;jargs, CHECK_(JVMCIObject()));
      return wrap(obj_h());
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject nameStr = name == NULL ? NULL : jni()-&gt;NewStringUTF(name);
      if (jni()-&gt;ExceptionCheck()) {
        return JVMCIObject();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1013,22 +960,10 @@</span>
      JNIAccessMark jni(this);
      return wrap(jni()-&gt;NewGlobalRef(object.as_jobject()));
    }
  }
  
<span class="udiff-line-removed">- JVMCIObject JVMCIEnv::make_weak(JVMCIObject object) {</span>
<span class="udiff-line-removed">-   if (object.is_null()) {</span>
<span class="udiff-line-removed">-     return JVMCIObject();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   if (is_hotspot()) {</span>
<span class="udiff-line-removed">-     return wrap(JNIHandles::make_weak_global(Handle(Thread::current(), HotSpotJVMCI::resolve(object))));</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-removed">-     return wrap(jni()-&gt;NewWeakGlobalRef(object.as_jobject()));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JVMCIEnv::destroy_local(JVMCIObject object) {
    if (is_hotspot()) {
      JNIHandles::destroy_local(object.as_jobject());
    } else {
      JNIAccessMark jni(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1043,19 +978,10 @@</span>
      JNIAccessMark jni(this);
      jni()-&gt;DeleteGlobalRef(object.as_jobject());
    }
  }
  
<span class="udiff-line-removed">- void JVMCIEnv::destroy_weak(JVMCIObject object) {</span>
<span class="udiff-line-removed">-   if (is_hotspot()) {</span>
<span class="udiff-line-removed">-     JNIHandles::destroy_weak_global(object.as_jweak());</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-removed">-     jni()-&gt;DeleteWeakGlobalRef(object.as_jweak());</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  const char* JVMCIEnv::klass_name(JVMCIObject object) {
    if (is_hotspot()) {
      return HotSpotJVMCI::resolve(object)-&gt;klass()-&gt;signature_name();
    } else {
      JVMCIObject name;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1074,11 +1000,11 @@</span>
    if (method() == NULL) {
      return method_object;
    }
  
    Thread* THREAD = Thread::current();
<span class="udiff-line-modified-removed">-   jmetadata handle = JVMCI::allocate_handle(method);</span>
<span class="udiff-line-modified-added">+   jmetadata handle = _runtime-&gt;allocate_handle(method);</span>
    jboolean exception = false;
    if (is_hotspot()) {
      JavaValue result(T_OBJECT);
      JavaCallArguments args;
      args.push_long((jlong) handle);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1097,17 +1023,17 @@</span>
                                                                    (jlong) handle));
      exception = jni()-&gt;ExceptionCheck();
    }
  
    if (exception) {
<span class="udiff-line-modified-removed">-     JVMCI::release_handle(handle);</span>
<span class="udiff-line-modified-added">+     _runtime-&gt;release_handle(handle);</span>
      return JVMCIObject();
    }
  
    assert(asMethod(method_object) == method(), &quot;must be&quot;);
    if (get_HotSpotResolvedJavaMethodImpl_metadataHandle(method_object) != (jlong) handle) {
<span class="udiff-line-modified-removed">-     JVMCI::release_handle(handle);</span>
<span class="udiff-line-modified-added">+     _runtime-&gt;release_handle(handle);</span>
    }
    assert(!method_object.is_null(), &quot;must be&quot;);
    return method_object;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1135,11 +1061,11 @@</span>
        exception = true;
      } else {
        type = wrap((oop)result.get_jobject());
      }
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
  
      HandleMark hm(THREAD);
      type = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedObjectTypeImpl::clazz(),
                                                          JNIJVMCI::HotSpotResolvedObjectTypeImpl_fromMetaspace_method(),
                                                          pointer, signature.as_jstring()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1153,14 +1079,14 @@</span>
    return type;
  }
  
  JVMCIObject JVMCIEnv::get_jvmci_constant_pool(const constantPoolHandle&amp; cp, JVMCI_TRAPS) {
    JVMCIObject cp_object;
<span class="udiff-line-modified-removed">-   jmetadata handle = JVMCI::allocate_handle(cp);</span>
<span class="udiff-line-modified-added">+   jmetadata handle = _runtime-&gt;allocate_handle(cp);</span>
    jboolean exception = false;
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      JavaValue result(T_OBJECT);
      JavaCallArguments args;
      args.push_long((jlong) handle);
      JavaCalls::call_static(&amp;result,
                             HotSpotJVMCI::HotSpotConstantPool::klass(),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1170,139 +1096,139 @@</span>
        exception = true;
      } else {
        cp_object = wrap((oop)result.get_jobject());
      }
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      cp_object = JNIJVMCI::wrap(jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotConstantPool::clazz(),
                                                               JNIJVMCI::HotSpotConstantPool_fromMetaspace_method(),
                                                               (jlong) handle));
      exception = jni()-&gt;ExceptionCheck();
    }
  
    if (exception) {
<span class="udiff-line-modified-removed">-     JVMCI::release_handle(handle);</span>
<span class="udiff-line-modified-added">+     _runtime-&gt;release_handle(handle);</span>
      return JVMCIObject();
    }
  
    assert(!cp_object.is_null(), &quot;must be&quot;);
    // Constant pools aren&#39;t cached so this is always a newly created object using the handle
    assert(get_HotSpotConstantPool_metadataHandle(cp_object) == (jlong) handle, &quot;must use same handle&quot;);
    return cp_object;
  }
  
  JVMCIPrimitiveArray JVMCIEnv::new_booleanArray(int length, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      typeArrayOop result = oopFactory::new_boolArray(length, CHECK_(JVMCIObject()));
      return wrap(result);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jbooleanArray result = jni()-&gt;NewBooleanArray(length);
      return wrap(result);
    }
  }
  
  JVMCIPrimitiveArray JVMCIEnv::new_byteArray(int length, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      typeArrayOop result = oopFactory::new_byteArray(length, CHECK_(JVMCIObject()));
      return wrap(result);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jbyteArray result = jni()-&gt;NewByteArray(length);
      return wrap(result);
    }
  }
  
  JVMCIObjectArray JVMCIEnv::new_byte_array_array(int length, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlassObj  ())-&gt;array_klass(CHECK_(JVMCIObject()));
      objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) -&gt;allocate(length, CHECK_(JVMCIObject()));
      return wrap(result);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobjectArray result = jni()-&gt;NewObjectArray(length, JNIJVMCI::byte_array(), NULL);
      return wrap(result);
    }
  }
  
  JVMCIPrimitiveArray JVMCIEnv::new_intArray(int length, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      typeArrayOop result = oopFactory::new_intArray(length, CHECK_(JVMCIObject()));
      return wrap(result);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jintArray result = jni()-&gt;NewIntArray(length);
      return wrap(result);
    }
  }
  
  JVMCIPrimitiveArray JVMCIEnv::new_longArray(int length, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      typeArrayOop result = oopFactory::new_longArray(length, CHECK_(JVMCIObject()));
      return wrap(result);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jlongArray result = jni()-&gt;NewLongArray(length);
      return wrap(result);
    }
  }
  
  JVMCIObject JVMCIEnv::new_VMField(JVMCIObject name, JVMCIObject type, jlong offset, jlong address, JVMCIObject value, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      HotSpotJVMCI::VMField::klass()-&gt;initialize(CHECK_(JVMCIObject()));
      oop obj = HotSpotJVMCI::VMField::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
      HotSpotJVMCI::VMField::set_name(this, obj, HotSpotJVMCI::resolve(name));
      HotSpotJVMCI::VMField::set_type(this, obj, HotSpotJVMCI::resolve(type));
      HotSpotJVMCI::VMField::set_offset(this, obj, offset);
      HotSpotJVMCI::VMField::set_address(this, obj, address);
      HotSpotJVMCI::VMField::set_value(this, obj, HotSpotJVMCI::resolve(value));
      return wrap(obj);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;NewObject(JNIJVMCI::VMField::clazz(),
                                      JNIJVMCI::VMField::constructor(),
                                      get_jobject(name), get_jobject(type), offset, address, get_jobject(value));
      return wrap(result);
    }
  }
  
  JVMCIObject JVMCIEnv::new_VMFlag(JVMCIObject name, JVMCIObject type, JVMCIObject value, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      HotSpotJVMCI::VMFlag::klass()-&gt;initialize(CHECK_(JVMCIObject()));
      oop obj = HotSpotJVMCI::VMFlag::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
      HotSpotJVMCI::VMFlag::set_name(this, obj, HotSpotJVMCI::resolve(name));
      HotSpotJVMCI::VMFlag::set_type(this, obj, HotSpotJVMCI::resolve(type));
      HotSpotJVMCI::VMFlag::set_value(this, obj, HotSpotJVMCI::resolve(value));
      return wrap(obj);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;NewObject(JNIJVMCI::VMFlag::clazz(),
                                      JNIJVMCI::VMFlag::constructor(),
                                      get_jobject(name), get_jobject(type), get_jobject(value));
      return wrap(result);
    }
  }
  
  JVMCIObject JVMCIEnv::new_VMIntrinsicMethod(JVMCIObject declaringClass, JVMCIObject name, JVMCIObject descriptor, int id, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;initialize(CHECK_(JVMCIObject()));
      oop obj = HotSpotJVMCI::VMIntrinsicMethod::klass()-&gt;allocate_instance(CHECK_(JVMCIObject()));
      HotSpotJVMCI::VMIntrinsicMethod::set_declaringClass(this, obj, HotSpotJVMCI::resolve(declaringClass));
      HotSpotJVMCI::VMIntrinsicMethod::set_name(this, obj, HotSpotJVMCI::resolve(name));
      HotSpotJVMCI::VMIntrinsicMethod::set_descriptor(this, obj, HotSpotJVMCI::resolve(descriptor));
      HotSpotJVMCI::VMIntrinsicMethod::set_id(this, obj, id);
      return wrap(obj);
    } else {
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;NewObject(JNIJVMCI::VMIntrinsicMethod::clazz(),
                                      JNIJVMCI::VMIntrinsicMethod::constructor(),
                                      get_jobject(declaringClass), get_jobject(name), get_jobject(descriptor), id);
      return wrap(result);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1344,11 +1270,11 @@</span>
      HotSpotJVMCI::DirectHotSpotObjectConstantImpl::set_object(this, constant, obj());
      HotSpotJVMCI::HotSpotObjectConstantImpl::set_compressed(this, constant, compressed);
      return wrap(constant);
    } else {
      jlong handle = make_handle(obj);
<span class="udiff-line-modified-removed">-     JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+     JNIAccessMark jni(this, THREAD);</span>
      jobject result = jni()-&gt;NewObject(JNIJVMCI::IndirectHotSpotObjectConstantImpl::clazz(),
                                        JNIJVMCI::IndirectHotSpotObjectConstantImpl::constructor(),
                                        handle, compressed, dont_register);
      return wrap(result);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1383,11 +1309,11 @@</span>
    return JVMCIObject::create(object, is_hotspot());
  }
  
  jlong JVMCIEnv::make_handle(const Handle&amp; obj) {
    assert(!obj.is_null(), &quot;should only create handle for non-NULL oops&quot;);
<span class="udiff-line-modified-removed">-   jobject handle = JVMCI::make_global(obj);</span>
<span class="udiff-line-modified-added">+   jobject handle = _runtime-&gt;make_global(obj);</span>
    return (jlong) handle;
  }
  
  oop JVMCIEnv::resolve_handle(jlong objectHandle) {
    assert(objectHandle != 0, &quot;should be a valid handle&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1397,19 +1323,19 @@</span>
    }
    return obj;
  }
  
  JVMCIObject JVMCIEnv::create_string(const char* str, JVMCI_TRAPS) {
<span class="udiff-line-added">+   JavaThread* THREAD = JavaThread::current();</span>
    if (is_hotspot()) {
<span class="udiff-line-removed">-     JavaThread* THREAD = JavaThread::current();</span>
      Handle result = java_lang_String::create_from_str(str, CHECK_(JVMCIObject()));
      return HotSpotJVMCI::wrap(result());
    } else {
      jobject result;
      jboolean exception = false;
      {
<span class="udiff-line-modified-removed">-       JNIAccessMark jni(this);</span>
<span class="udiff-line-modified-added">+       JNIAccessMark jni(this, THREAD);</span>
        result = jni()-&gt;NewStringUTF(str);
        exception = jni()-&gt;ExceptionCheck();
      }
      return wrap(result);
    }
</pre>
<center><a href="jvmciCompilerToVM.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciEnv.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
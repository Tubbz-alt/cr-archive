diff a/src/hotspot/share/jvmci/jvmci.hpp b/src/hotspot/share/jvmci/jvmci.hpp
--- a/src/hotspot/share/jvmci/jvmci.hpp
+++ b/src/hotspot/share/jvmci/jvmci.hpp
@@ -23,10 +23,11 @@
 
 #ifndef SHARE_JVMCI_JVMCI_HPP
 #define SHARE_JVMCI_JVMCI_HPP
 
 #include "compiler/compilerDefinitions.hpp"
+#include "utilities/events.hpp"
 #include "utilities/exceptions.hpp"
 
 class BoolObjectClosure;
 class constantPoolHandle;
 class JavaThread;
@@ -43,36 +44,62 @@
 class JVMCI : public AllStatic {
   friend class JVMCIRuntime;
   friend class JVMCIEnv;
 
  private:
-  // Handles to Metadata objects.
-  static MetadataHandleBlock* _metadata_handles;
-
   // Access to the HotSpotJVMCIRuntime used by the CompileBroker.
   static JVMCIRuntime* _compiler_runtime;
 
-  // Access to the HotSpotJVMCIRuntime used by Java code running on the
-  // HotSpot heap. It will be the same as _compiler_runtime if
-  // UseJVMCINativeLibrary is false
+  // True when at least one JVMCIRuntime::initialize_HotSpotJVMCIRuntime()
+  // execution has completed successfully.
+  static volatile bool _is_initialized;
+
+  // Handle created when loading the JVMCI shared library with os::dll_load.
+  // Must hold JVMCI_lock when initializing.
+  static void* _shared_library_handle;
+
+  // Argument to os::dll_load when loading JVMCI shared library
+  static char* _shared_library_path;
+
+  // Records whether JVMCI::shutdown has been called.
+  static volatile bool _in_shutdown;
+
+  // Access to the HotSpot heap based JVMCIRuntime
   static JVMCIRuntime* _java_runtime;
 
+  // JVMCI event log (shows up in hs_err crash logs).
+  static StringEventLog* _events;
+  static StringEventLog* _verbose_events;
+  enum {
+    max_EventLog_level = 4
+  };
+
+  // Gets the Thread* value for the current thread or NULL if it's not available.
+  static Thread* current_thread_or_null();
+
  public:
   enum CodeInstallResult {
      ok,
      dependencies_failed,
      cache_full,
      code_too_large
   };
 
+  // Gets the handle to the loaded JVMCI shared library, loading it
+  // first if not yet loaded and `load` is true. The path from
+  // which the library is loaded is returned in `path`. If
+  // `load` is true then JVMCI_lock must be locked.
+  static void* get_shared_library(char*& path, bool load);
+
   static void do_unloading(bool unloading_occurred);
 
   static void metadata_do(void f(Metadata*));
 
   static void shutdown();
 
-  static bool shutdown_called();
+  // Returns whether JVMCI::shutdown has been called.
+  static bool in_shutdown();
 
   static bool is_compiler_initialized();
 
   /**
    * Determines if the VM is sufficiently booted to initialize JVMCI.
@@ -81,19 +108,32 @@
 
   static void initialize_globals();
 
   static void initialize_compiler(TRAPS);
 
-  static jobject make_global(const Handle& obj);
-  static void destroy_global(jobject handle);
-  static bool is_global_handle(jobject handle);
+  static JVMCIRuntime* compiler_runtime() { return _compiler_runtime; }
+  // Gets the single runtime for JVMCI on the Java heap. This is the only
+  // JVMCI runtime available when !UseJVMCINativeLibrary.
+  static JVMCIRuntime* java_runtime()     { return _java_runtime; }
 
-  static jmetadata allocate_handle(const methodHandle& handle);
-  static jmetadata allocate_handle(const constantPoolHandle& handle);
+  // Appends an event to the JVMCI event log if JVMCIEventLogLevel >= `level`
+  static void vlog(int level, const char* format, va_list ap) ATTRIBUTE_PRINTF(2, 0);
 
-  static void release_handle(jmetadata handle);
+  // Traces an event to tty if JVMCITraceLevel >= `level`
+  static void vtrace(int level, const char* format, va_list ap) ATTRIBUTE_PRINTF(2, 0);
 
-  static JVMCIRuntime* compiler_runtime() { return _compiler_runtime; }
-  static JVMCIRuntime* java_runtime()     { return _java_runtime; }
+ public:
+  // Log/trace a JVMCI event
+  static void event(int level, const char* format, ...) ATTRIBUTE_PRINTF(2, 3);
+  static void event1(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event2(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event3(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
+  static void event4(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);
 };
 
+// JVMCI event macros.
+#define JVMCI_event_1 if (JVMCITraceLevel < 1 && JVMCIEventLogLevel < 1) ; else ::JVMCI::event1
+#define JVMCI_event_2 if (JVMCITraceLevel < 2 && JVMCIEventLogLevel < 2) ; else ::JVMCI::event2
+#define JVMCI_event_3 if (JVMCITraceLevel < 3 && JVMCIEventLogLevel < 3) ; else ::JVMCI::event3
+#define JVMCI_event_4 if (JVMCITraceLevel < 4 && JVMCIEventLogLevel < 4) ; else ::JVMCI::event4
+
 #endif // SHARE_JVMCI_JVMCI_HPP

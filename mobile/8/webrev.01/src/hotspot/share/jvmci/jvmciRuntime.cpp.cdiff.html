<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,25 ***</span>
<span class="line-new-header">--- 23,30 ---</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">+ #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="line-added">+ #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-added">+ #include &quot;jvmci/metadataHandles.hpp&quot;</span>
  #include &quot;logging/log.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/constantPool.inline.hpp&quot;
  #include &quot;oops/method.inline.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
  #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
  #include &quot;runtime/atomic.hpp&quot;
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-added">+ #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #if INCLUDE_G1GC
  #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  #endif // INCLUDE_G1GC
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 703,10 ***</span>
<span class="line-new-header">--- 708,182 ---</span>
        HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
      }
    }
  }
  
<span class="line-added">+ JVMCIRuntime::JVMCIRuntime(int id) {</span>
<span class="line-added">+   _init_state = uninitialized;</span>
<span class="line-added">+   _shared_library_javavm = NULL;</span>
<span class="line-added">+   _id = id;</span>
<span class="line-added">+   _metadata_handles = new MetadataHandles();</span>
<span class="line-added">+   JVMCI_event_1(&quot;created new JVMCI runtime %d (&quot; PTR_FORMAT &quot;)&quot;, id, p2i(this));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Handles to objects in the Hotspot heap.</span>
<span class="line-added">+ static OopStorage* object_handles() {</span>
<span class="line-added">+   return OopStorageSet::vm_global();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jobject JVMCIRuntime::make_global(const Handle&amp; obj) {</span>
<span class="line-added">+   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);</span>
<span class="line-added">+   oop* ptr = object_handles()-&gt;allocate();</span>
<span class="line-added">+   jobject res = NULL;</span>
<span class="line-added">+   if (ptr != NULL) {</span>
<span class="line-added">+     assert(*ptr == NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     NativeAccess&lt;&gt;::oop_store(ptr, obj());</span>
<span class="line-added">+     res = reinterpret_cast&lt;jobject&gt;(ptr);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-added">+                           &quot;Cannot create JVMCI oop handle&quot;);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added">+   return res;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIRuntime::destroy_global(jobject handle) {</span>
<span class="line-added">+   // Assert before nulling out, for better debugging.</span>
<span class="line-added">+   assert(is_global_handle(handle), &quot;precondition&quot;);</span>
<span class="line-added">+   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="line-added">+   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);</span>
<span class="line-added">+   object_handles()-&gt;release(oop_ptr);</span>
<span class="line-added">+   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool JVMCIRuntime::is_global_handle(jobject handle) {</span>
<span class="line-added">+   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="line-added">+   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {</span>
<span class="line-added">+   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added">+   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {</span>
<span class="line-added">+   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added">+   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIRuntime::release_handle(jmetadata handle) {</span>
<span class="line-added">+   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added">+   _metadata_handles-&gt;chain_free_list(handle);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Function for redirecting shared library JavaVM output to tty</span>
<span class="line-added">+ static void _log(const char* buf, size_t count) {</span>
<span class="line-added">+   tty-&gt;write((char*) buf, count);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Function for shared library JavaVM to flush tty</span>
<span class="line-added">+ static void _flush_log() {</span>
<span class="line-added">+   tty-&gt;flush();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Function for shared library JavaVM to exit HotSpot on a fatal error</span>
<span class="line-added">+ static void _fatal() {</span>
<span class="line-added">+   fatal(&quot;Fatal error in JVMCI shared library&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JNIEnv* JVMCIRuntime::init_shared_library_javavm() {</span>
<span class="line-added">+   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added">+   if (javaVM == NULL) {</span>
<span class="line-added">+     MutexLocker locker(JVMCI_lock);</span>
<span class="line-added">+     // Check again under JVMCI_lock</span>
<span class="line-added">+     javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added">+     if (javaVM != NULL) {</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     char* sl_path;</span>
<span class="line-added">+     void* sl_handle = JVMCI::get_shared_library(sl_path, true);</span>
<span class="line-added">+ </span>
<span class="line-added">+     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added">+     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, &quot;JNI_CreateJavaVM&quot;));</span>
<span class="line-added">+     if (JNI_CreateJavaVM == NULL) {</span>
<span class="line-added">+       vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, sl_path);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ResourceMark rm;</span>
<span class="line-added">+     JavaVMInitArgs vm_args;</span>
<span class="line-added">+     vm_args.version = JNI_VERSION_1_2;</span>
<span class="line-added">+     vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="line-added">+     JavaVMOption options[4];</span>
<span class="line-added">+     jlong javaVM_id = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Protocol: JVMCI shared library JavaVM should support a non-standard &quot;_javavm_id&quot;</span>
<span class="line-added">+     // option whose extraInfo info field is a pointer to which a unique id for the</span>
<span class="line-added">+     // JavaVM should be written.</span>
<span class="line-added">+     options[0].optionString = (char*) &quot;_javavm_id&quot;;</span>
<span class="line-added">+     options[0].extraInfo = &amp;javaVM_id;</span>
<span class="line-added">+ </span>
<span class="line-added">+     options[1].optionString = (char*) &quot;_log&quot;;</span>
<span class="line-added">+     options[1].extraInfo = (void*) _log;</span>
<span class="line-added">+     options[2].optionString = (char*) &quot;_flush_log&quot;;</span>
<span class="line-added">+     options[2].extraInfo = (void*) _flush_log;</span>
<span class="line-added">+     options[3].optionString = (char*) &quot;_fatal&quot;;</span>
<span class="line-added">+     options[3].extraInfo = (void*) _fatal;</span>
<span class="line-added">+ </span>
<span class="line-added">+     vm_args.version = JNI_VERSION_1_2;</span>
<span class="line-added">+     vm_args.options = options;</span>
<span class="line-added">+     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JNIEnv* env = NULL;</span>
<span class="line-added">+     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);</span>
<span class="line-added">+     if (result == JNI_OK) {</span>
<span class="line-added">+       guarantee(env != NULL, &quot;missing env&quot;);</span>
<span class="line-added">+       _shared_library_javavm = javaVM;</span>
<span class="line-added">+       JVMCI_event_1(&quot;created JavaVM[%ld]@&quot; PTR_FORMAT &quot; for JVMCI runtime %d&quot;, javaVM_id, p2i(javaVM), _id);</span>
<span class="line-added">+       return env;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), sl_path);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {</span>
<span class="line-added">+   if (info != NULL) {</span>
<span class="line-added">+     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);</span>
<span class="line-added">+     if (info_oop-&gt;length() &lt; 4) {</span>
<span class="line-added">+       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg(&quot;%d &lt; 4&quot;, info_oop-&gt;length()));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added">+     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);</span>
<span class="line-added">+     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="line-added">+     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="line-added">+     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define JAVAVM_CALL_BLOCK                                             \</span>
<span class="line-added">+   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, &quot;npe&quot;); \</span>
<span class="line-added">+   ThreadToNativeFromVM ttnfv(thread);                                 \</span>
<span class="line-added">+   JavaVM* javavm = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added">+ </span>
<span class="line-added">+ jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {</span>
<span class="line-added">+   JAVAVM_CALL_BLOCK</span>
<span class="line-added">+   return javavm-&gt;AttachCurrentThread(penv, args);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {</span>
<span class="line-added">+   JAVAVM_CALL_BLOCK</span>
<span class="line-added">+   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {</span>
<span class="line-added">+   JAVAVM_CALL_BLOCK</span>
<span class="line-added">+   return javavm-&gt;DetachCurrentThread();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {</span>
<span class="line-added">+   JAVAVM_CALL_BLOCK</span>
<span class="line-added">+   return javavm-&gt;GetEnv(penv, version);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #undef JAVAVM_CALL_BLOCK                                             \</span>
<span class="line-added">+ </span>
  void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
    if (is_HotSpotJVMCIRuntime_initialized()) {
      if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
        JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 716,33 ***</span>
  
    // This should only be called in the context of the JVMCI class being initialized
    JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
  
    _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
  }
  
  void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
<span class="line-removed">-   assert(this != NULL, &quot;sanity&quot;);</span>
    // Check first without JVMCI_lock
<span class="line-modified">!   if (_initialized) {</span>
      return;
    }
  
    MutexLocker locker(JVMCI_lock);
    // Check again under JVMCI_lock
<span class="line-modified">!   if (_initialized) {</span>
      return;
    }
  
<span class="line-modified">!   while (_being_initialized) {</span>
      JVMCI_lock-&gt;wait();
<span class="line-modified">!     if (_initialized) {</span>
        return;
      }
    }
  
<span class="line-modified">!   _being_initialized = true;</span>
  
    {
      MutexUnlocker unlock(JVMCI_lock);
  
      HandleMark hm;
<span class="line-new-header">--- 893,36 ---</span>
  
    // This should only be called in the context of the JVMCI class being initialized
    JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
  
    _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
<span class="line-added">+   JVMCI::_is_initialized = true;</span>
  }
  
  void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
    // Check first without JVMCI_lock
<span class="line-modified">!   if (_init_state == fully_initialized) {</span>
      return;
    }
  
    MutexLocker locker(JVMCI_lock);
    // Check again under JVMCI_lock
<span class="line-modified">!   if (_init_state == fully_initialized) {</span>
      return;
    }
  
<span class="line-modified">!   while (_init_state == being_initialized) {</span>
<span class="line-added">+     JVMCI_event_1(&quot;waiting for initialization of JVMCI runtime %d&quot;, _id);</span>
      JVMCI_lock-&gt;wait();
<span class="line-modified">!     if (_init_state == fully_initialized) {</span>
<span class="line-added">+       JVMCI_event_1(&quot;done waiting for initialization of JVMCI runtime %d&quot;, _id);</span>
        return;
      }
    }
  
<span class="line-modified">!   JVMCI_event_1(&quot;initializing JVMCI runtime %d&quot;, _id);</span>
<span class="line-added">+   _init_state = being_initialized;</span>
  
    {
      MutexUnlocker unlock(JVMCI_lock);
  
      HandleMark hm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,10 ***</span>
<span class="line-new-header">--- 937,15 ---</span>
        if (jni()-&gt;ExceptionCheck()) {
          jni()-&gt;ExceptionDescribe();
          fatal(&quot;JNI exception during init&quot;);
        }
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added">+       JNIAccessMark jni(JVMCIENV, THREAD);</span>
<span class="line-added">+       JNIJVMCI::register_natives(jni.env());</span>
<span class="line-added">+     }</span>
      create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
      create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
      create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
      create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
      create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 772,12 ***</span>
      if (!JVMCIENV-&gt;is_hotspot()) {
        JVMCIENV-&gt;copy_saved_properties();
      }
    }
  
<span class="line-modified">!   _initialized = true;</span>
<span class="line-modified">!   _being_initialized = false;</span>
    JVMCI_lock-&gt;notify_all();
  }
  
  JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
    Thread* THREAD = Thread::current();
<span class="line-new-header">--- 957,12 ---</span>
      if (!JVMCIENV-&gt;is_hotspot()) {
        JVMCIENV-&gt;copy_saved_properties();
      }
    }
  
<span class="line-modified">!   _init_state = fully_initialized;</span>
<span class="line-modified">!   JVMCI_event_1(&quot;initialized JVMCI runtime %d&quot;, _id);</span>
    JVMCI_lock-&gt;notify_all();
  }
  
  JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
    Thread* THREAD = Thread::current();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,12 ***</span>
    initialize(JVMCIENV);
    initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
    return _HotSpotJVMCIRuntime_instance;
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- // private void CompilerToVM.registerNatives()</span>
  JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
    JNI_JVMCIENV(thread, env);
  
    if (!EnableJVMCI) {
      JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
<span class="line-new-header">--- 1000,11 ---</span>
    initialize(JVMCIENV);
    initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
    return _HotSpotJVMCIRuntime_instance;
  }
  
<span class="line-modified">! // private static void CompilerToVM.registerNatives()</span>
  JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
    JNI_JVMCIENV(thread, env);
  
    if (!EnableJVMCI) {
      JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 852,20 ***</span>
    }
  JVM_END
  
  
  void JVMCIRuntime::shutdown() {
<span class="line-modified">!   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified">!     _shutdown_called = true;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     THREAD_JVMCIENV(JavaThread::current());</span>
      JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
    }
  }
  
  void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="line-modified">!   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
      THREAD_JVMCIENV(JavaThread::current());
      JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
    }
  }
  
<span class="line-new-header">--- 1036,21 ---</span>
    }
  JVM_END
  
  
  void JVMCIRuntime::shutdown() {
<span class="line-modified">!   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
<span class="line-modified">!     JVMCI_event_1(&quot;shutting down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);</span>
<span class="line-modified">!     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);</span>
<span class="line-modified">!     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;</span>
      JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
<span class="line-added">+     JVMCI_event_1(&quot;shut down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);</span>
    }
  }
  
  void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="line-modified">!   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
      THREAD_JVMCIENV(JavaThread::current());
      JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1288,14 ***</span>
  
    bool is_osr = entry_bci != InvocationEntryBci;
    if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
      // no OSR compilations during bootstrap - the compiler is just too slow at this point,
      // and we know that there are no endless loops
<span class="line-modified">!     compile_state-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
      return;
    }
<span class="line-modified">!   if (JVMCI::shutdown_called()) {</span>
      compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
      return;
    }
  
    HandleMark hm;
<span class="line-new-header">--- 1473,14 ---</span>
  
    bool is_osr = entry_bci != InvocationEntryBci;
    if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
      // no OSR compilations during bootstrap - the compiler is just too slow at this point,
      // and we know that there are no endless loops
<span class="line-modified">!     compile_state-&gt;set_failure(true, &quot;No OSR during bootstrap&quot;);</span>
      return;
    }
<span class="line-modified">!   if (JVMCI::in_shutdown()) {</span>
      compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
      return;
    }
  
    HandleMark hm;
</pre>
<center><a href="jvmciJavaClasses.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
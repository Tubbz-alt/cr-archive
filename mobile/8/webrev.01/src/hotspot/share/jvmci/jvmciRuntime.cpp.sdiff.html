<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciJavaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/javaClasses.inline.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;compiler/compileBroker.hpp&quot;


  28 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  29 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  30 #include &quot;jvmci/jvmciRuntime.hpp&quot;

  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/universe.hpp&quot;
  34 #include &quot;oops/constantPool.inline.hpp&quot;
  35 #include &quot;oops/method.inline.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;

  38 #include &quot;runtime/atomic.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/deoptimization.hpp&quot;
  41 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  42 #include &quot;runtime/frame.inline.hpp&quot;

  43 #include &quot;runtime/sharedRuntime.hpp&quot;
  44 #if INCLUDE_G1GC
  45 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  46 #endif // INCLUDE_G1GC
  47 
  48 // Simple helper to see if the caller of a runtime stub which
  49 // entered the VM has been deoptimized
  50 
  51 static bool caller_is_deopted() {
  52   JavaThread* thread = JavaThread::current();
  53   RegisterMap reg_map(thread, false);
  54   frame runtime_frame = thread-&gt;last_frame();
  55   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  56   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  57   return caller_frame.is_deoptimized_frame();
  58 }
  59 
  60 // Stress deoptimization
  61 static void deopt_caller() {
  62   if ( !caller_is_deopted()) {
</pre>
<hr />
<pre>
 688   // We cannot use JVMCIObject to wrap the mirror as this is called
 689   // during GC, forbidding the creation of JNIHandles.
 690   JVMCIEnv* jvmciEnv = NULL;
 691   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 692   if (nm == current) {
 693     if (!nm-&gt;is_alive()) {
 694       // Break the link from the mirror to nm such that
 695       // future invocations via the mirror will result in
 696       // an InvalidInstalledCodeException.
 697       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 698       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 699     } else if (nm-&gt;is_not_entrant()) {
 700       // Zero the entry point so any new invocation will fail but keep
 701       // the address link around that so that existing activations can
 702       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     }
 705   }
 706 }
 707 












































































































































































 708 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 709   if (is_HotSpotJVMCIRuntime_initialized()) {
 710     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 711       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);
 712     }
 713   }
 714 
 715   initialize(JVMCIENV);
 716 
 717   // This should only be called in the context of the JVMCI class being initialized
 718   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 719 
 720   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);

 721 }
 722 
 723 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {
<span class="line-removed"> 724   assert(this != NULL, &quot;sanity&quot;);</span>
 725   // Check first without JVMCI_lock
<span class="line-modified"> 726   if (_initialized) {</span>
 727     return;
 728   }
 729 
 730   MutexLocker locker(JVMCI_lock);
 731   // Check again under JVMCI_lock
<span class="line-modified"> 732   if (_initialized) {</span>
 733     return;
 734   }
 735 
<span class="line-modified"> 736   while (_being_initialized) {</span>

 737     JVMCI_lock-&gt;wait();
<span class="line-modified"> 738     if (_initialized) {</span>

 739       return;
 740     }
 741   }
 742 
<span class="line-modified"> 743   _being_initialized = true;</span>

 744 
 745   {
 746     MutexUnlocker unlock(JVMCI_lock);
 747 
 748     HandleMark hm;
 749     ResourceMark rm;
 750     JavaThread* THREAD = JavaThread::current();
 751     if (JVMCIENV-&gt;is_hotspot()) {
 752       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 753     } else {
 754       JNIAccessMark jni(JVMCIENV);
 755 
 756       JNIJVMCI::initialize_ids(jni.env());
 757       if (jni()-&gt;ExceptionCheck()) {
 758         jni()-&gt;ExceptionDescribe();
 759         fatal(&quot;JNI exception during init&quot;);
 760       }
 761     }





 762     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 763     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 764     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 765     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 766     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 767     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 768     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 769     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 770     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 771 
 772     if (!JVMCIENV-&gt;is_hotspot()) {
 773       JVMCIENV-&gt;copy_saved_properties();
 774     }
 775   }
 776 
<span class="line-modified"> 777   _initialized = true;</span>
<span class="line-modified"> 778   _being_initialized = false;</span>
 779   JVMCI_lock-&gt;notify_all();
 780 }
 781 
 782 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 783   Thread* THREAD = Thread::current();
 784   // These primitive types are long lived and are created before the runtime is fully set up
 785   // so skip registering them for scanning.
 786   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 787   if (JVMCIENV-&gt;is_hotspot()) {
 788     JavaValue result(T_OBJECT);
 789     JavaCallArguments args;
 790     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 791     args.push_int(type2char(type));
 792     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 793 
 794     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 795   } else {
 796     JNIAccessMark jni(JVMCIENV);
 797     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 798                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
</pre>
<hr />
<pre>
 800     if (jni()-&gt;ExceptionCheck()) {
 801       return JVMCIObject();
 802     }
 803     return JVMCIENV-&gt;wrap(result);
 804   }
 805 }
 806 
 807 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 808   if (!is_HotSpotJVMCIRuntime_initialized()) {
 809     initialize(JVMCI_CHECK);
 810     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 811   }
 812 }
 813 
 814 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 815   initialize(JVMCIENV);
 816   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
 817   return _HotSpotJVMCIRuntime_instance;
 818 }
 819 
<span class="line-modified"> 820 </span>
<span class="line-removed"> 821 // private void CompilerToVM.registerNatives()</span>
 822 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
 823   JNI_JVMCIENV(thread, env);
 824 
 825   if (!EnableJVMCI) {
 826     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
 827   }
 828 
 829   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
 830 
 831   {
 832     ResourceMark rm;
 833     HandleMark hm(thread);
 834     ThreadToNativeFromVM trans(thread);
 835 
 836     // Ensure _non_oop_bits is initialized
 837     Universe::non_oop_word();
 838 
 839     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
 840       if (!env-&gt;ExceptionCheck()) {
 841         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
 842           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
 843             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
 844             break;
 845           }
 846         }
 847       } else {
 848         env-&gt;ExceptionDescribe();
 849       }
 850       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);
 851     }
 852   }
 853 JVM_END
 854 
 855 
 856 void JVMCIRuntime::shutdown() {
<span class="line-modified"> 857   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
<span class="line-modified"> 858     _shutdown_called = true;</span>
<span class="line-modified"> 859 </span>
<span class="line-modified"> 860     THREAD_JVMCIENV(JavaThread::current());</span>
 861     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);

 862   }
 863 }
 864 
 865 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="line-modified"> 866   if (is_HotSpotJVMCIRuntime_initialized()) {</span>
 867     THREAD_JVMCIENV(JavaThread::current());
 868     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
 869   }
 870 }
 871 
 872 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
 873   if (HAS_PENDING_EXCEPTION) {
 874     Handle exception(THREAD, PENDING_EXCEPTION);
 875     const char* exception_file = THREAD-&gt;exception_file();
 876     int exception_line = THREAD-&gt;exception_line();
 877     CLEAR_PENDING_EXCEPTION;
 878     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 879       // Don&#39;t print anything if we are being killed.
 880     } else {
 881       java_lang_Throwable::print_stack_trace(exception, tty);
 882 
 883       // Clear and ignore any exceptions raised during printing
 884       CLEAR_PENDING_EXCEPTION;
 885     }
 886     if (!clear) {
</pre>
<hr />
<pre>
1273   // Only report a fatal JVMCI compilation exception once
1274   static volatile int report_init_failure = 0;
1275   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1276       tty-&gt;print_cr(&quot;%s:&quot;, msg);
1277       JVMCIENV-&gt;describe_pending_exception(true);
1278   }
1279   JVMCIENV-&gt;clear_pending_exception();
1280   before_exit(thread);
1281   vm_exit(-1);
1282 }
1283 
1284 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1285   JVMCI_EXCEPTION_CONTEXT
1286 
1287   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1288 
1289   bool is_osr = entry_bci != InvocationEntryBci;
1290   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1291     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1292     // and we know that there are no endless loops
<span class="line-modified">1293     compile_state-&gt;set_failure(true, &quot;No OSR during boostrap&quot;);</span>
1294     return;
1295   }
<span class="line-modified">1296   if (JVMCI::shutdown_called()) {</span>
1297     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
1298     return;
1299   }
1300 
1301   HandleMark hm;
1302   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1303   if (JVMCIENV-&gt;has_pending_exception()) {
1304     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);
1305   }
1306   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1307   if (JVMCIENV-&gt;has_pending_exception()) {
1308     JVMCIENV-&gt;describe_pending_exception(true);
1309     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);
1310     return;
1311   }
1312 
1313   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1314                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1315   if (!JVMCIENV-&gt;has_pending_exception()) {
1316     if (result_object.is_non_null()) {
</pre>
</td>
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;classfile/javaClasses.inline.hpp&quot;
  26 #include &quot;classfile/symbolTable.hpp&quot;
  27 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">  28 #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="line-added">  29 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  30 #include &quot;jvmci/jniAccessMark.inline.hpp&quot;
  31 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  32 #include &quot;jvmci/jvmciRuntime.hpp&quot;
<span class="line-added">  33 #include &quot;jvmci/metadataHandles.hpp&quot;</span>
  34 #include &quot;logging/log.hpp&quot;
  35 #include &quot;memory/oopFactory.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/constantPool.inline.hpp&quot;
  38 #include &quot;oops/method.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  41 #include &quot;oops/typeArrayOop.inline.hpp&quot;</span>
  42 #include &quot;runtime/atomic.hpp&quot;
  43 #include &quot;runtime/biasedLocking.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/frame.inline.hpp&quot;
<span class="line-added">  47 #include &quot;runtime/jniHandles.inline.hpp&quot;</span>
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #if INCLUDE_G1GC
  50 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  51 #endif // INCLUDE_G1GC
  52 
  53 // Simple helper to see if the caller of a runtime stub which
  54 // entered the VM has been deoptimized
  55 
  56 static bool caller_is_deopted() {
  57   JavaThread* thread = JavaThread::current();
  58   RegisterMap reg_map(thread, false);
  59   frame runtime_frame = thread-&gt;last_frame();
  60   frame caller_frame = runtime_frame.sender(&amp;reg_map);
  61   assert(caller_frame.is_compiled_frame(), &quot;must be compiled&quot;);
  62   return caller_frame.is_deoptimized_frame();
  63 }
  64 
  65 // Stress deoptimization
  66 static void deopt_caller() {
  67   if ( !caller_is_deopted()) {
</pre>
<hr />
<pre>
 693   // We cannot use JVMCIObject to wrap the mirror as this is called
 694   // during GC, forbidding the creation of JNIHandles.
 695   JVMCIEnv* jvmciEnv = NULL;
 696   nmethod* current = (nmethod*) HotSpotJVMCI::InstalledCode::address(jvmciEnv, nmethod_mirror);
 697   if (nm == current) {
 698     if (!nm-&gt;is_alive()) {
 699       // Break the link from the mirror to nm such that
 700       // future invocations via the mirror will result in
 701       // an InvalidInstalledCodeException.
 702       HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, 0);
 703       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 704     } else if (nm-&gt;is_not_entrant()) {
 705       // Zero the entry point so any new invocation will fail but keep
 706       // the address link around that so that existing activations can
 707       // be deoptimized via the mirror (i.e. JVMCIEnv::invalidate_installed_code).
 708       HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, 0);
 709     }
 710   }
 711 }
 712 
<span class="line-added"> 713 JVMCIRuntime::JVMCIRuntime(int id) {</span>
<span class="line-added"> 714   _init_state = uninitialized;</span>
<span class="line-added"> 715   _shared_library_javavm = NULL;</span>
<span class="line-added"> 716   _id = id;</span>
<span class="line-added"> 717   _metadata_handles = new MetadataHandles();</span>
<span class="line-added"> 718   JVMCI_event_1(&quot;created new JVMCI runtime %d (&quot; PTR_FORMAT &quot;)&quot;, id, p2i(this));</span>
<span class="line-added"> 719 }</span>
<span class="line-added"> 720 </span>
<span class="line-added"> 721 // Handles to objects in the Hotspot heap.</span>
<span class="line-added"> 722 static OopStorage* object_handles() {</span>
<span class="line-added"> 723   return OopStorageSet::vm_global();</span>
<span class="line-added"> 724 }</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726 jobject JVMCIRuntime::make_global(const Handle&amp; obj) {</span>
<span class="line-added"> 727   assert(!Universe::heap()-&gt;is_gc_active(), &quot;can&#39;t extend the root set during GC&quot;);</span>
<span class="line-added"> 728   assert(oopDesc::is_oop(obj()), &quot;not an oop&quot;);</span>
<span class="line-added"> 729   oop* ptr = object_handles()-&gt;allocate();</span>
<span class="line-added"> 730   jobject res = NULL;</span>
<span class="line-added"> 731   if (ptr != NULL) {</span>
<span class="line-added"> 732     assert(*ptr == NULL, &quot;invariant&quot;);</span>
<span class="line-added"> 733     NativeAccess&lt;&gt;::oop_store(ptr, obj());</span>
<span class="line-added"> 734     res = reinterpret_cast&lt;jobject&gt;(ptr);</span>
<span class="line-added"> 735   } else {</span>
<span class="line-added"> 736     vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR,</span>
<span class="line-added"> 737                           &quot;Cannot create JVMCI oop handle&quot;);</span>
<span class="line-added"> 738   }</span>
<span class="line-added"> 739   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added"> 740   return res;</span>
<span class="line-added"> 741 }</span>
<span class="line-added"> 742 </span>
<span class="line-added"> 743 void JVMCIRuntime::destroy_global(jobject handle) {</span>
<span class="line-added"> 744   // Assert before nulling out, for better debugging.</span>
<span class="line-added"> 745   assert(is_global_handle(handle), &quot;precondition&quot;);</span>
<span class="line-added"> 746   oop* oop_ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="line-added"> 747   NativeAccess&lt;&gt;::oop_store(oop_ptr, (oop)NULL);</span>
<span class="line-added"> 748   object_handles()-&gt;release(oop_ptr);</span>
<span class="line-added"> 749   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added"> 750 }</span>
<span class="line-added"> 751 </span>
<span class="line-added"> 752 bool JVMCIRuntime::is_global_handle(jobject handle) {</span>
<span class="line-added"> 753   const oop* ptr = reinterpret_cast&lt;oop*&gt;(handle);</span>
<span class="line-added"> 754   return object_handles()-&gt;allocation_status(ptr) == OopStorage::ALLOCATED_ENTRY;</span>
<span class="line-added"> 755 }</span>
<span class="line-added"> 756 </span>
<span class="line-added"> 757 jmetadata JVMCIRuntime::allocate_handle(const methodHandle&amp; handle) {</span>
<span class="line-added"> 758   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added"> 759   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="line-added"> 760 }</span>
<span class="line-added"> 761 </span>
<span class="line-added"> 762 jmetadata JVMCIRuntime::allocate_handle(const constantPoolHandle&amp; handle) {</span>
<span class="line-added"> 763   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added"> 764   return _metadata_handles-&gt;allocate_handle(handle);</span>
<span class="line-added"> 765 }</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767 void JVMCIRuntime::release_handle(jmetadata handle) {</span>
<span class="line-added"> 768   MutexLocker ml(JVMCI_lock);</span>
<span class="line-added"> 769   _metadata_handles-&gt;chain_free_list(handle);</span>
<span class="line-added"> 770 }</span>
<span class="line-added"> 771 </span>
<span class="line-added"> 772 // Function for redirecting shared library JavaVM output to tty</span>
<span class="line-added"> 773 static void _log(const char* buf, size_t count) {</span>
<span class="line-added"> 774   tty-&gt;write((char*) buf, count);</span>
<span class="line-added"> 775 }</span>
<span class="line-added"> 776 </span>
<span class="line-added"> 777 // Function for shared library JavaVM to flush tty</span>
<span class="line-added"> 778 static void _flush_log() {</span>
<span class="line-added"> 779   tty-&gt;flush();</span>
<span class="line-added"> 780 }</span>
<span class="line-added"> 781 </span>
<span class="line-added"> 782 // Function for shared library JavaVM to exit HotSpot on a fatal error</span>
<span class="line-added"> 783 static void _fatal() {</span>
<span class="line-added"> 784   fatal(&quot;Fatal error in JVMCI shared library&quot;);</span>
<span class="line-added"> 785 }</span>
<span class="line-added"> 786 </span>
<span class="line-added"> 787 JNIEnv* JVMCIRuntime::init_shared_library_javavm() {</span>
<span class="line-added"> 788   JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added"> 789   if (javaVM == NULL) {</span>
<span class="line-added"> 790     MutexLocker locker(JVMCI_lock);</span>
<span class="line-added"> 791     // Check again under JVMCI_lock</span>
<span class="line-added"> 792     javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added"> 793     if (javaVM != NULL) {</span>
<span class="line-added"> 794       return NULL;</span>
<span class="line-added"> 795     }</span>
<span class="line-added"> 796     char* sl_path;</span>
<span class="line-added"> 797     void* sl_handle = JVMCI::get_shared_library(sl_path, true);</span>
<span class="line-added"> 798 </span>
<span class="line-added"> 799     jint (*JNI_CreateJavaVM)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added"> 800     typedef jint (*JNI_CreateJavaVM_t)(JavaVM **pvm, void **penv, void *args);</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802     JNI_CreateJavaVM = CAST_TO_FN_PTR(JNI_CreateJavaVM_t, os::dll_lookup(sl_handle, &quot;JNI_CreateJavaVM&quot;));</span>
<span class="line-added"> 803     if (JNI_CreateJavaVM == NULL) {</span>
<span class="line-added"> 804       vm_exit_during_initialization(&quot;Unable to find JNI_CreateJavaVM&quot;, sl_path);</span>
<span class="line-added"> 805     }</span>
<span class="line-added"> 806 </span>
<span class="line-added"> 807     ResourceMark rm;</span>
<span class="line-added"> 808     JavaVMInitArgs vm_args;</span>
<span class="line-added"> 809     vm_args.version = JNI_VERSION_1_2;</span>
<span class="line-added"> 810     vm_args.ignoreUnrecognized = JNI_TRUE;</span>
<span class="line-added"> 811     JavaVMOption options[4];</span>
<span class="line-added"> 812     jlong javaVM_id = 0;</span>
<span class="line-added"> 813 </span>
<span class="line-added"> 814     // Protocol: JVMCI shared library JavaVM should support a non-standard &quot;_javavm_id&quot;</span>
<span class="line-added"> 815     // option whose extraInfo info field is a pointer to which a unique id for the</span>
<span class="line-added"> 816     // JavaVM should be written.</span>
<span class="line-added"> 817     options[0].optionString = (char*) &quot;_javavm_id&quot;;</span>
<span class="line-added"> 818     options[0].extraInfo = &amp;javaVM_id;</span>
<span class="line-added"> 819 </span>
<span class="line-added"> 820     options[1].optionString = (char*) &quot;_log&quot;;</span>
<span class="line-added"> 821     options[1].extraInfo = (void*) _log;</span>
<span class="line-added"> 822     options[2].optionString = (char*) &quot;_flush_log&quot;;</span>
<span class="line-added"> 823     options[2].extraInfo = (void*) _flush_log;</span>
<span class="line-added"> 824     options[3].optionString = (char*) &quot;_fatal&quot;;</span>
<span class="line-added"> 825     options[3].extraInfo = (void*) _fatal;</span>
<span class="line-added"> 826 </span>
<span class="line-added"> 827     vm_args.version = JNI_VERSION_1_2;</span>
<span class="line-added"> 828     vm_args.options = options;</span>
<span class="line-added"> 829     vm_args.nOptions = sizeof(options) / sizeof(JavaVMOption);</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831     JNIEnv* env = NULL;</span>
<span class="line-added"> 832     int result = (*JNI_CreateJavaVM)(&amp;javaVM, (void**) &amp;env, &amp;vm_args);</span>
<span class="line-added"> 833     if (result == JNI_OK) {</span>
<span class="line-added"> 834       guarantee(env != NULL, &quot;missing env&quot;);</span>
<span class="line-added"> 835       _shared_library_javavm = javaVM;</span>
<span class="line-added"> 836       JVMCI_event_1(&quot;created JavaVM[%ld]@&quot; PTR_FORMAT &quot; for JVMCI runtime %d&quot;, javaVM_id, p2i(javaVM), _id);</span>
<span class="line-added"> 837       return env;</span>
<span class="line-added"> 838     } else {</span>
<span class="line-added"> 839       vm_exit_during_initialization(err_msg(&quot;JNI_CreateJavaVM failed with return value %d&quot;, result), sl_path);</span>
<span class="line-added"> 840     }</span>
<span class="line-added"> 841   }</span>
<span class="line-added"> 842   return NULL;</span>
<span class="line-added"> 843 }</span>
<span class="line-added"> 844 </span>
<span class="line-added"> 845 void JVMCIRuntime::init_JavaVM_info(jlongArray info, JVMCI_TRAPS) {</span>
<span class="line-added"> 846   if (info != NULL) {</span>
<span class="line-added"> 847     typeArrayOop info_oop = (typeArrayOop) JNIHandles::resolve(info);</span>
<span class="line-added"> 848     if (info_oop-&gt;length() &lt; 4) {</span>
<span class="line-added"> 849       JVMCI_THROW_MSG(ArrayIndexOutOfBoundsException, err_msg(&quot;%d &lt; 4&quot;, info_oop-&gt;length()));</span>
<span class="line-added"> 850     }</span>
<span class="line-added"> 851     JavaVM* javaVM = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added"> 852     info_oop-&gt;long_at_put(0, (jlong) (address) javaVM);</span>
<span class="line-added"> 853     info_oop-&gt;long_at_put(1, (jlong) (address) javaVM-&gt;functions-&gt;reserved0);</span>
<span class="line-added"> 854     info_oop-&gt;long_at_put(2, (jlong) (address) javaVM-&gt;functions-&gt;reserved1);</span>
<span class="line-added"> 855     info_oop-&gt;long_at_put(3, (jlong) (address) javaVM-&gt;functions-&gt;reserved2);</span>
<span class="line-added"> 856   }</span>
<span class="line-added"> 857 }</span>
<span class="line-added"> 858 </span>
<span class="line-added"> 859 #define JAVAVM_CALL_BLOCK                                             \</span>
<span class="line-added"> 860   guarantee(thread != NULL &amp;&amp; _shared_library_javavm != NULL, &quot;npe&quot;); \</span>
<span class="line-added"> 861   ThreadToNativeFromVM ttnfv(thread);                                 \</span>
<span class="line-added"> 862   JavaVM* javavm = (JavaVM*) _shared_library_javavm;</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864 jint JVMCIRuntime::AttachCurrentThread(JavaThread* thread, void **penv, void *args) {</span>
<span class="line-added"> 865   JAVAVM_CALL_BLOCK</span>
<span class="line-added"> 866   return javavm-&gt;AttachCurrentThread(penv, args);</span>
<span class="line-added"> 867 }</span>
<span class="line-added"> 868 </span>
<span class="line-added"> 869 jint JVMCIRuntime::AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args) {</span>
<span class="line-added"> 870   JAVAVM_CALL_BLOCK</span>
<span class="line-added"> 871   return javavm-&gt;AttachCurrentThreadAsDaemon(penv, args);</span>
<span class="line-added"> 872 }</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874 jint JVMCIRuntime::DetachCurrentThread(JavaThread* thread) {</span>
<span class="line-added"> 875   JAVAVM_CALL_BLOCK</span>
<span class="line-added"> 876   return javavm-&gt;DetachCurrentThread();</span>
<span class="line-added"> 877 }</span>
<span class="line-added"> 878 </span>
<span class="line-added"> 879 jint JVMCIRuntime::GetEnv(JavaThread* thread, void **penv, jint version) {</span>
<span class="line-added"> 880   JAVAVM_CALL_BLOCK</span>
<span class="line-added"> 881   return javavm-&gt;GetEnv(penv, version);</span>
<span class="line-added"> 882 }</span>
<span class="line-added"> 883 #undef JAVAVM_CALL_BLOCK                                             \</span>
<span class="line-added"> 884 </span>
 885 void JVMCIRuntime::initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
 886   if (is_HotSpotJVMCIRuntime_initialized()) {
 887     if (JVMCIENV-&gt;is_hotspot() &amp;&amp; UseJVMCINativeLibrary) {
 888       JVMCI_THROW_MSG(InternalError, &quot;JVMCI has already been enabled in the JVMCI shared library&quot;);
 889     }
 890   }
 891 
 892   initialize(JVMCIENV);
 893 
 894   // This should only be called in the context of the JVMCI class being initialized
 895   JVMCIObject result = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_runtime(JVMCI_CHECK);
 896 
 897   _HotSpotJVMCIRuntime_instance = JVMCIENV-&gt;make_global(result);
<span class="line-added"> 898   JVMCI::_is_initialized = true;</span>
 899 }
 900 
 901 void JVMCIRuntime::initialize(JVMCIEnv* JVMCIENV) {

 902   // Check first without JVMCI_lock
<span class="line-modified"> 903   if (_init_state == fully_initialized) {</span>
 904     return;
 905   }
 906 
 907   MutexLocker locker(JVMCI_lock);
 908   // Check again under JVMCI_lock
<span class="line-modified"> 909   if (_init_state == fully_initialized) {</span>
 910     return;
 911   }
 912 
<span class="line-modified"> 913   while (_init_state == being_initialized) {</span>
<span class="line-added"> 914     JVMCI_event_1(&quot;waiting for initialization of JVMCI runtime %d&quot;, _id);</span>
 915     JVMCI_lock-&gt;wait();
<span class="line-modified"> 916     if (_init_state == fully_initialized) {</span>
<span class="line-added"> 917       JVMCI_event_1(&quot;done waiting for initialization of JVMCI runtime %d&quot;, _id);</span>
 918       return;
 919     }
 920   }
 921 
<span class="line-modified"> 922   JVMCI_event_1(&quot;initializing JVMCI runtime %d&quot;, _id);</span>
<span class="line-added"> 923   _init_state = being_initialized;</span>
 924 
 925   {
 926     MutexUnlocker unlock(JVMCI_lock);
 927 
 928     HandleMark hm;
 929     ResourceMark rm;
 930     JavaThread* THREAD = JavaThread::current();
 931     if (JVMCIENV-&gt;is_hotspot()) {
 932       HotSpotJVMCI::compute_offsets(CHECK_EXIT);
 933     } else {
 934       JNIAccessMark jni(JVMCIENV);
 935 
 936       JNIJVMCI::initialize_ids(jni.env());
 937       if (jni()-&gt;ExceptionCheck()) {
 938         jni()-&gt;ExceptionDescribe();
 939         fatal(&quot;JNI exception during init&quot;);
 940       }
 941     }
<span class="line-added"> 942 </span>
<span class="line-added"> 943     if (!JVMCIENV-&gt;is_hotspot()) {</span>
<span class="line-added"> 944       JNIAccessMark jni(JVMCIENV, THREAD);</span>
<span class="line-added"> 945       JNIJVMCI::register_natives(jni.env());</span>
<span class="line-added"> 946     }</span>
 947     create_jvmci_primitive_type(T_BOOLEAN, JVMCI_CHECK_EXIT_((void)0));
 948     create_jvmci_primitive_type(T_BYTE, JVMCI_CHECK_EXIT_((void)0));
 949     create_jvmci_primitive_type(T_CHAR, JVMCI_CHECK_EXIT_((void)0));
 950     create_jvmci_primitive_type(T_SHORT, JVMCI_CHECK_EXIT_((void)0));
 951     create_jvmci_primitive_type(T_INT, JVMCI_CHECK_EXIT_((void)0));
 952     create_jvmci_primitive_type(T_LONG, JVMCI_CHECK_EXIT_((void)0));
 953     create_jvmci_primitive_type(T_FLOAT, JVMCI_CHECK_EXIT_((void)0));
 954     create_jvmci_primitive_type(T_DOUBLE, JVMCI_CHECK_EXIT_((void)0));
 955     create_jvmci_primitive_type(T_VOID, JVMCI_CHECK_EXIT_((void)0));
 956 
 957     if (!JVMCIENV-&gt;is_hotspot()) {
 958       JVMCIENV-&gt;copy_saved_properties();
 959     }
 960   }
 961 
<span class="line-modified"> 962   _init_state = fully_initialized;</span>
<span class="line-modified"> 963   JVMCI_event_1(&quot;initialized JVMCI runtime %d&quot;, _id);</span>
 964   JVMCI_lock-&gt;notify_all();
 965 }
 966 
 967 JVMCIObject JVMCIRuntime::create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS) {
 968   Thread* THREAD = Thread::current();
 969   // These primitive types are long lived and are created before the runtime is fully set up
 970   // so skip registering them for scanning.
 971   JVMCIObject mirror = JVMCIENV-&gt;get_object_constant(java_lang_Class::primitive_mirror(type), false, true);
 972   if (JVMCIENV-&gt;is_hotspot()) {
 973     JavaValue result(T_OBJECT);
 974     JavaCallArguments args;
 975     args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(mirror)));
 976     args.push_int(type2char(type));
 977     JavaCalls::call_static(&amp;result, HotSpotJVMCI::HotSpotResolvedPrimitiveType::klass(), vmSymbols::fromMetaspace_name(), vmSymbols::primitive_fromMetaspace_signature(), &amp;args, CHECK_(JVMCIObject()));
 978 
 979     return JVMCIENV-&gt;wrap(JNIHandles::make_local((oop)result.get_jobject()));
 980   } else {
 981     JNIAccessMark jni(JVMCIENV);
 982     jobject result = jni()-&gt;CallStaticObjectMethod(JNIJVMCI::HotSpotResolvedPrimitiveType::clazz(),
 983                                            JNIJVMCI::HotSpotResolvedPrimitiveType_fromMetaspace_method(),
</pre>
<hr />
<pre>
 985     if (jni()-&gt;ExceptionCheck()) {
 986       return JVMCIObject();
 987     }
 988     return JVMCIENV-&gt;wrap(result);
 989   }
 990 }
 991 
 992 void JVMCIRuntime::initialize_JVMCI(JVMCI_TRAPS) {
 993   if (!is_HotSpotJVMCIRuntime_initialized()) {
 994     initialize(JVMCI_CHECK);
 995     JVMCIENV-&gt;call_JVMCI_getRuntime(JVMCI_CHECK);
 996   }
 997 }
 998 
 999 JVMCIObject JVMCIRuntime::get_HotSpotJVMCIRuntime(JVMCI_TRAPS) {
1000   initialize(JVMCIENV);
1001   initialize_JVMCI(JVMCI_CHECK_(JVMCIObject()));
1002   return _HotSpotJVMCIRuntime_instance;
1003 }
1004 
<span class="line-modified">1005 // private static void CompilerToVM.registerNatives()</span>

1006 JVM_ENTRY_NO_ENV(void, JVM_RegisterJVMCINatives(JNIEnv *env, jclass c2vmClass))
1007   JNI_JVMCIENV(thread, env);
1008 
1009   if (!EnableJVMCI) {
1010     JVMCI_THROW_MSG(InternalError, &quot;JVMCI is not enabled&quot;);
1011   }
1012 
1013   JVMCIENV-&gt;runtime()-&gt;initialize(JVMCIENV);
1014 
1015   {
1016     ResourceMark rm;
1017     HandleMark hm(thread);
1018     ThreadToNativeFromVM trans(thread);
1019 
1020     // Ensure _non_oop_bits is initialized
1021     Universe::non_oop_word();
1022 
1023     if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods, CompilerToVM::methods_count())) {
1024       if (!env-&gt;ExceptionCheck()) {
1025         for (int i = 0; i &lt; CompilerToVM::methods_count(); i++) {
1026           if (JNI_OK != env-&gt;RegisterNatives(c2vmClass, CompilerToVM::methods + i, 1)) {
1027             guarantee(false, &quot;Error registering JNI method %s%s&quot;, CompilerToVM::methods[i].name, CompilerToVM::methods[i].signature);
1028             break;
1029           }
1030         }
1031       } else {
1032         env-&gt;ExceptionDescribe();
1033       }
1034       guarantee(false, &quot;Failed registering CompilerToVM native methods&quot;);
1035     }
1036   }
1037 JVM_END
1038 
1039 
1040 void JVMCIRuntime::shutdown() {
<span class="line-modified">1041   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
<span class="line-modified">1042     JVMCI_event_1(&quot;shutting down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);</span>
<span class="line-modified">1043     JVMCIEnv __stack_jvmci_env__(JavaThread::current(), _HotSpotJVMCIRuntime_instance.is_hotspot(), __FILE__, __LINE__);</span>
<span class="line-modified">1044     JVMCIEnv* JVMCIENV = &amp;__stack_jvmci_env__;</span>
1045     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_shutdown(_HotSpotJVMCIRuntime_instance);
<span class="line-added">1046     JVMCI_event_1(&quot;shut down HotSpotJVMCIRuntime for JVMCI runtime %d&quot;, _id);</span>
1047   }
1048 }
1049 
1050 void JVMCIRuntime::bootstrap_finished(TRAPS) {
<span class="line-modified">1051   if (_HotSpotJVMCIRuntime_instance.is_non_null()) {</span>
1052     THREAD_JVMCIENV(JavaThread::current());
1053     JVMCIENV-&gt;call_HotSpotJVMCIRuntime_bootstrapFinished(_HotSpotJVMCIRuntime_instance, JVMCIENV);
1054   }
1055 }
1056 
1057 void JVMCIRuntime::describe_pending_hotspot_exception(JavaThread* THREAD, bool clear) {
1058   if (HAS_PENDING_EXCEPTION) {
1059     Handle exception(THREAD, PENDING_EXCEPTION);
1060     const char* exception_file = THREAD-&gt;exception_file();
1061     int exception_line = THREAD-&gt;exception_line();
1062     CLEAR_PENDING_EXCEPTION;
1063     if (exception-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
1064       // Don&#39;t print anything if we are being killed.
1065     } else {
1066       java_lang_Throwable::print_stack_trace(exception, tty);
1067 
1068       // Clear and ignore any exceptions raised during printing
1069       CLEAR_PENDING_EXCEPTION;
1070     }
1071     if (!clear) {
</pre>
<hr />
<pre>
1458   // Only report a fatal JVMCI compilation exception once
1459   static volatile int report_init_failure = 0;
1460   if (!report_init_failure &amp;&amp; Atomic::cmpxchg(&amp;report_init_failure, 0, 1) == 0) {
1461       tty-&gt;print_cr(&quot;%s:&quot;, msg);
1462       JVMCIENV-&gt;describe_pending_exception(true);
1463   }
1464   JVMCIENV-&gt;clear_pending_exception();
1465   before_exit(thread);
1466   vm_exit(-1);
1467 }
1468 
1469 void JVMCIRuntime::compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; method, int entry_bci) {
1470   JVMCI_EXCEPTION_CONTEXT
1471 
1472   JVMCICompileState* compile_state = JVMCIENV-&gt;compile_state();
1473 
1474   bool is_osr = entry_bci != InvocationEntryBci;
1475   if (compiler-&gt;is_bootstrapping() &amp;&amp; is_osr) {
1476     // no OSR compilations during bootstrap - the compiler is just too slow at this point,
1477     // and we know that there are no endless loops
<span class="line-modified">1478     compile_state-&gt;set_failure(true, &quot;No OSR during bootstrap&quot;);</span>
1479     return;
1480   }
<span class="line-modified">1481   if (JVMCI::in_shutdown()) {</span>
1482     compile_state-&gt;set_failure(false, &quot;Avoiding compilation during shutdown&quot;);
1483     return;
1484   }
1485 
1486   HandleMark hm;
1487   JVMCIObject receiver = get_HotSpotJVMCIRuntime(JVMCIENV);
1488   if (JVMCIENV-&gt;has_pending_exception()) {
1489     fatal_exception_in_compile(JVMCIENV, thread, &quot;Exception during HotSpotJVMCIRuntime initialization&quot;);
1490   }
1491   JVMCIObject jvmci_method = JVMCIENV-&gt;get_jvmci_method(method, JVMCIENV);
1492   if (JVMCIENV-&gt;has_pending_exception()) {
1493     JVMCIENV-&gt;describe_pending_exception(true);
1494     compile_state-&gt;set_failure(false, &quot;exception getting JVMCI wrapper method&quot;);
1495     return;
1496   }
1497 
1498   JVMCIObject result_object = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_compileMethod(receiver, jvmci_method, entry_bci,
1499                                                                      (jlong) compile_state, compile_state-&gt;task()-&gt;compile_id());
1500   if (!JVMCIENV-&gt;has_pending_exception()) {
1501     if (result_object.is_non_null()) {
</pre>
</td>
</tr>
</table>
<center><a href="jvmciJavaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmciRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
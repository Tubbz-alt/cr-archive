diff a/src/hotspot/share/jvmci/jvmciRuntime.hpp b/src/hotspot/share/jvmci/jvmciRuntime.hpp
--- a/src/hotspot/share/jvmci/jvmciRuntime.hpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.hpp
@@ -26,14 +26,16 @@
 
 #include "code/nmethod.hpp"
 #include "jvmci/jvmci.hpp"
 #include "jvmci/jvmciExceptions.hpp"
 #include "jvmci/jvmciObject.hpp"
+#include "utilities/linkedlist.hpp"
 
 class JVMCIEnv;
 class JVMCICompiler;
 class JVMCICompileState;
+class MetadataHandles;
 
 // Encapsulates the JVMCI metadata for an nmethod.
 // JVMCINMethodData objects are inlined into nmethods
 // at nmethod::_jvmci_data_offset.
 class JVMCINMethodData {
@@ -84,10 +86,11 @@
 };
 
 // A top level class that represents an initialized JVMCI runtime.
 // There is one instance of this class per HotSpotJVMCIRuntime object.
 class JVMCIRuntime: public CHeapObj<mtJVMCI> {
+  friend class JVMCI;
  public:
   // Constants describing whether JVMCI wants to be able to adjust the compilation
   // level selected for a method by the VM compilation policy and if so, based on
   // what information about the method being schedule for compilation.
   enum CompLevelAdjustment {
@@ -95,16 +98,37 @@
      by_holder = 1,        // adjust based on declaring class of method
      by_full_signature = 2 // adjust based on declaring class, name and signature of method
   };
 
  private:
-  volatile bool _being_initialized;
-  volatile bool _initialized;
 
+  enum InitState {
+    uninitialized,
+    being_initialized,
+    fully_initialized
+  };
+
+  // Initialization state of this JVMCIRuntime.
+  InitState _init_state;
+
+  // A wrapper for a VM scoped JNI global handle (i.e. JVMCIEnv::make_global)
+  // to a HotSpotJVMCIRuntime instance. This JNI global handle must never
+  // be explicitly destroyed as it can be accessed in a racy way during
+  // JVMCI shutdown. Furthermore, it will be reclaimed when
+  // the VM or shared library JavaVM managing the handle dies.
   JVMCIObject _HotSpotJVMCIRuntime_instance;
 
-  bool _shutdown_called;
+  // Result of calling JNI_CreateJavaVM in the JVMCI shared library.
+  // Must only be modified under JVMCI_lock.
+  volatile JavaVM* _shared_library_javavm;
+
+  // The HotSpot heap based runtime will have an id of -1 and the
+  // JVMCI shared library runtime will have an id of 0.
+  int _id;
+
+  // Handles to Metadata objects.
+  MetadataHandles* _metadata_handles;
 
   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);
 
   // Implementation methods for loading and constant pool access.
   static Klass* get_klass_by_name_impl(Klass*& accessing_klass,
@@ -129,48 +153,83 @@
                                   Symbol*         sig,
                                   Bytecodes::Code bc,
                                   constantTag     tag);
 
  public:
-  JVMCIRuntime() {
-    _initialized = false;
-    _being_initialized = false;
-    _shutdown_called = false;
-  }
-
-  /**
-   * Compute offsets and construct any state required before executing JVMCI code.
-   */
+  JVMCIRuntime(int id);
+
+  int id() const        { return _id;   }
+
+  // Ensures that a JVMCI shared library JavaVM exists for this runtime.
+  // If the JavaVM was created by this call, then the thread-local JNI
+  // interface pointer for the JavaVM is returned otherwise NULL is returned.
+  JNIEnv* init_shared_library_javavm();
+
+  // Determines if the JVMCI shared library JavaVM exists for this runtime.
+  bool has_shared_library_javavm() { return _shared_library_javavm != NULL; }
+
+  // Copies info about the JVMCI shared library JavaVM associated with this
+  // runtime into `info` as follows:
+  // {
+  //     javaVM, // the {@code JavaVM*} value
+  //     javaVM->functions->reserved0,
+  //     javaVM->functions->reserved1,
+  //     javaVM->functions->reserved2
+  // }
+  void init_JavaVM_info(jlongArray info, JVMCI_TRAPS);
+
+  // Wrappers for calling Invocation Interface functions on the
+  // JVMCI shared library JavaVM associated with this runtime.
+  // These wrappers ensure all required thread state transitions are performed.
+  jint AttachCurrentThread(JavaThread* thread, void **penv, void *args);
+  jint AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args);
+  jint DetachCurrentThread(JavaThread* thread);
+  jint GetEnv(JavaThread* thread, void **penv, jint version);
+
+  // Compute offsets and construct any state required before executing JVMCI code.
   void initialize(JVMCIEnv* jvmciEnv);
 
-  /**
-   * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary
-   */
+  // Allocation and management of JNI global object handles
+  // whose lifetime is scoped by this JVMCIRuntime. The lifetime
+  // of these handles is the same as the JVMCI shared library JavaVM
+  // associated with this JVMCIRuntime. These JNI handles are
+  // used when creating a IndirectHotSpotObjectConstantImpl in the
+  // shared library JavaVM.
+  jobject make_global(const Handle& obj);
+  void destroy_global(jobject handle);
+  bool is_global_handle(jobject handle);
+
+  // Allocation and management of metadata handles.
+  jmetadata allocate_handle(const methodHandle& handle);
+  jmetadata allocate_handle(const constantPoolHandle& handle);
+  void release_handle(jmetadata handle);
+
+  // Gets the HotSpotJVMCIRuntime instance for this runtime,
+  // initializing it first if necessary.
   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 
   bool is_HotSpotJVMCIRuntime_initialized() {
     return _HotSpotJVMCIRuntime_instance.is_non_null();
   }
 
-  /**
-   * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
-   */
+  // Gets the current HotSpotJVMCIRuntime instance for this runtime which
+  // may be a "null" JVMCIObject value.
+  JVMCIObject probe_HotSpotJVMCIRuntime() {
+    return _HotSpotJVMCIRuntime_instance;
+  }
+
+  // Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()
   void initialize_JVMCI(JVMCI_TRAPS);
 
-  /**
-   * Explicitly initialize HotSpotJVMCIRuntime itself
-   */
+  // Explicitly initialize HotSpotJVMCIRuntime itself
   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);
 
   void call_getCompiler(TRAPS);
 
+  // Shuts down this runtime by calling HotSpotJVMCIRuntime.shutdown().
   void shutdown();
 
-  bool shutdown_called() {
-    return _shutdown_called;
-  }
-
   void bootstrap_finished(TRAPS);
 
   // Look up a klass by name from a particular class loader (the accessor's).
   // If require_local, result must be defined in that class loader, or NULL.
   // If !require_local, a result from remote class loader may be reported,
@@ -220,11 +279,11 @@
                        int                       orig_pc_offset,
                        CodeBuffer*               code_buffer,
                        int                       frame_words,
                        OopMapSet*                oop_map_set,
                        ExceptionHandlerTable*    handler_table,
-                       ImplicitExceptionTable* implicit_exception_table,
+                       ImplicitExceptionTable*   implicit_exception_table,
                        AbstractCompiler*         compiler,
                        DebugInformationRecorder* debug_info,
                        Dependencies*             dependencies,
                        int                       compile_id,
                        bool                      has_unsafe_access,
@@ -233,13 +292,11 @@
                        JVMCIObject               nmethod_mirror,
                        FailedSpeculation**       failed_speculations,
                        char*                     speculations,
                        int                       speculations_len);
 
-  /**
-   * Exits the VM due to an unexpected exception.
-   */
+  // Exits the VM due to an unexpected exception.
   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);
 
   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);
 
 #define CHECK_EXIT THREAD); \
@@ -338,21 +395,6 @@
   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
 
   // Test only function
   static jint test_deoptimize_call_int(JavaThread* thread, int value);
 };
-
-// Tracing macros.
-
-#define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel >= 1)) ; else
-#define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel >= 2)) ; else
-#define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel >= 3)) ; else
-#define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel >= 4)) ; else
-#define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel >= 5)) ; else
-
-#define TRACE_jvmci_1 if (!(JVMCITraceLevel >= 1 && (tty->print(PTR_FORMAT " JVMCITrace-1: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_2 if (!(JVMCITraceLevel >= 2 && (tty->print(PTR_FORMAT "    JVMCITrace-2: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_3 if (!(JVMCITraceLevel >= 3 && (tty->print(PTR_FORMAT "       JVMCITrace-3: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_4 if (!(JVMCITraceLevel >= 4 && (tty->print(PTR_FORMAT "          JVMCITrace-4: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-#define TRACE_jvmci_5 if (!(JVMCITraceLevel >= 5 && (tty->print(PTR_FORMAT "             JVMCITrace-5: ", p2i(JavaThread::current())), true))) ; else tty->print_cr
-
 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP

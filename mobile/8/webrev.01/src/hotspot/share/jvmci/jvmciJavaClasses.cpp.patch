diff a/src/hotspot/share/jvmci/jvmciJavaClasses.cpp b/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
--- a/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
+++ b/src/hotspot/share/jvmci/jvmciJavaClasses.cpp
@@ -81,10 +81,11 @@
   if (static_field) {
     // Must ensure classes for static fields are initialized as the
     // accessor itself does not include a class initialization check.
     ik->initialize(CHECK);
   }
+  JVMCI_event_2("   field offset for %s %s.%s = %d", signature, ik->external_name(), name, dest_offset);
 }
 
 #ifndef PRODUCT
 static void check_resolve_method(const char* call_type, Klass* resolved_klass, Symbol* method_name, Symbol* method_signature, TRAPS) {
   Method* method;
@@ -115,11 +116,12 @@
 jmethodID JNIJVMCI::_HotSpotResolvedObjectTypeImpl_fromMetaspace_method;
 jmethodID JNIJVMCI::_HotSpotResolvedPrimitiveType_fromMetaspace_method;
 
 #define START_CLASS(className, fullClassName)                          { \
   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::fullClassName(), true, CHECK); \
-  className::_klass = InstanceKlass::cast(k); \
+  className::_klass = InstanceKlass::cast(k);                                     \
+  JVMCI_event_2(" klass for %s = " PTR_FORMAT, k->external_name(), p2i(k));       \
   className::_klass->initialize(CHECK);
 
 #define END_CLASS }
 
 #define FIELD(className, name, signature, static_field) compute_offset(className::_##name##_offset, className::_klass, #name, signature, static_field, CHECK);
@@ -284,17 +286,19 @@
     return;
   }
   if (env->ExceptionCheck()) {
     return;
   }
+  jfieldID current = fieldid;
   if (static_field) {
     // Class initialization barrier
     fieldid = env->GetStaticFieldID(clazz, name, signature);
   } else {
     // Class initialization barrier
     fieldid = env->GetFieldID(clazz, name, signature);
   }
+  JVMCI_event_2("   jfieldID for %s %s.%s = " PTR_FORMAT, signature, class_name, name, p2i(fieldid));
 
   if (env->ExceptionCheck()) {
     env->ExceptionDescribe();
     env->ExceptionClear();
     ResourceMark rm;
@@ -310,11 +314,13 @@
     st->print_cr("class %s", current_class_name);                                           \
   } else {                                                                                  \
     jclass k = env->FindClass(current_class_name);                                          \
     JVMCI_EXCEPTION_CHECK(env, "FindClass(%s)", current_class_name);                        \
     assert(k != NULL, #fullClassName " not initialized");                                   \
-    className::_class = (jclass) env->NewGlobalRef(k);                                      \
+    k = (jclass) env->NewGlobalRef(k);                                                      \
+    JVMCI_event_2(" jclass for %s = " PTR_FORMAT, current_class_name, p2i(k));              \
+    className::_class = k;                                                                  \
   }
 
 #define END_CLASS current_class_name = NULL; }
 
 #define FIELD(className, name, signature, static_field) initialize_field_id(env, className::_##name##_field_id, className::_class, current_class_name, #name, signature, static_field);
@@ -327,18 +333,22 @@
 #define STATIC_OBJECT_FIELD(className, name, signature) FIELD(className, name, signature, true)
 #define STATIC_INT_FIELD(className, name) FIELD(className, name, "I", true)
 #define STATIC_BOOLEAN_FIELD(className, name) FIELD(className, name, "Z", true)
 
 #define GET_JNI_METHOD(jniGetMethod, dst, clazz, methodName, signature)                        \
-          if (JVMCILibDumpJNIConfig != NULL) {                                                       \
-            fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \
-            st->print_cr("method %s %s %s", current_class_name, methodName, signature);              \
-          } else {                                                                                   \
-                  dst = env->jniGetMethod(clazz, methodName, signature);                                   \
-                  JVMCI_EXCEPTION_CHECK(env, #jniGetMethod "(%s.%s%s)", current_class_name, methodName, signature); \
-                assert(dst != NULL, "uninitialized");                                          \
-          }
+    if (JVMCILibDumpJNIConfig != NULL) {                                                       \
+      fileStream* st = JVMCIGlobals::get_jni_config_file();                                    \
+      st->print_cr("method %s %s %s", current_class_name, methodName, signature);              \
+    } else {                                                                                   \
+      jmethodID current = dst;                                                                 \
+      dst = env->jniGetMethod(clazz, methodName, signature);                                   \
+      JVMCI_EXCEPTION_CHECK(env, #jniGetMethod "(%s.%s%s)",                                    \
+                  current_class_name, methodName, signature);                                  \
+      assert(dst != NULL, "uninitialized");                                                    \
+      JVMCI_event_2("   jmethodID for %s.%s%s = " PTR_FORMAT,                                  \
+                  current_class_name, methodName, signature, p2i(dst));                        \
+    }
 
 #define GET_JNI_CONSTRUCTOR(clazz, signature) \
   GET_JNI_METHOD(GetMethodID, JNIJVMCI::clazz::_constructor, clazz::_class, "<init>", signature) \
 
 #define METHOD(jniCallType, jniGetMethod, hsCallType, returnType, className, methodName, signatureSymbolName, args) \
@@ -491,34 +501,34 @@
 #undef BOX_CLASSES
 #undef IN_CLASS
 
 #define CC (char*)  /*cast a literal from (const char*)*/
 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &(f))
+}
 
-  if (env != JavaThread::current()->jni_environment()) {
-    jclass clazz = env->FindClass("jdk/vm/ci/hotspot/CompilerToVM");
+static void register_natives_for_class(JNIEnv* env, jclass clazz, const char* name, const JNINativeMethod *methods, jint nMethods) {
+  if (clazz == NULL) {
+    clazz = env->FindClass(name);
     if (env->ExceptionCheck()) {
       env->ExceptionDescribe();
-      guarantee(false, "Could not find class jdk/vm/ci/hotspot/CompilerToVM");
-    }
-    JNINativeMethod CompilerToVM_native_methods[] = {
-      { CC"registerNatives",     CC"()V", FN_PTR(JVM_RegisterJVMCINatives)     },
-    };
-    env->RegisterNatives(clazz, CompilerToVM_native_methods, 1);
-    if (env->ExceptionCheck()) {
-      env->ExceptionDescribe();
-      guarantee(false, "");
+      fatal("Could not find class %s", name);
     }
+  }
+  env->RegisterNatives(clazz, methods, nMethods);
+  if (env->ExceptionCheck()) {
+    env->ExceptionDescribe();
+    fatal("Failure registering natives for %s", name);
+  }
+}
 
-    JNINativeMethod JVMCI_native_methods[] = {
-      { CC"initializeRuntime",   CC"()Ljdk/vm/ci/runtime/JVMCIRuntime;", FN_PTR(JVM_GetJVMCIRuntime) },
-    };
-    env->RegisterNatives(JVMCI::clazz(), JVMCI_native_methods, 1);
-    if (env->ExceptionCheck()) {
-      env->ExceptionDescribe();
-      guarantee(false, "");
-    }
+void JNIJVMCI::register_natives(JNIEnv* env) {
+  if (env != JavaThread::current()->jni_environment()) {
+    JNINativeMethod CompilerToVM_nmethods[] = {{ CC"registerNatives", CC"()V", FN_PTR(JVM_RegisterJVMCINatives) }};
+    JNINativeMethod JVMCI_nmethods[] = {{ CC"initializeRuntime",   CC"()Ljdk/vm/ci/runtime/JVMCIRuntime;", FN_PTR(JVM_GetJVMCIRuntime) }};
+
+    register_natives_for_class(env, NULL, "jdk/vm/ci/hotspot/CompilerToVM", CompilerToVM_nmethods, 1);
+    register_natives_for_class(env, JVMCI::clazz(), "jdk/vm/ci/runtime/JVMCI", JVMCI_nmethods, 1);
   }
 }
 
 #undef METHOD
 #undef CONSTRUCTOR

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmciRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmci_globals.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
 25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
 26 
 27 #include &quot;code/nmethod.hpp&quot;
 28 #include &quot;jvmci/jvmci.hpp&quot;
 29 #include &quot;jvmci/jvmciExceptions.hpp&quot;
 30 #include &quot;jvmci/jvmciObject.hpp&quot;

 31 
 32 class JVMCIEnv;
 33 class JVMCICompiler;
 34 class JVMCICompileState;

 35 
 36 // Encapsulates the JVMCI metadata for an nmethod.
 37 // JVMCINMethodData objects are inlined into nmethods
 38 // at nmethod::_jvmci_data_offset.
 39 class JVMCINMethodData {
 40   // Index for the HotSpotNmethod mirror in the nmethod&#39;s oops table.
 41   // This is -1 if there is no mirror in the oops table.
 42   int _nmethod_mirror_index;
 43 
 44   // Is HotSpotNmethod.name non-null? If so, the value is
 45   // embedded in the end of this object.
 46   bool _has_name;
 47 
 48   // Address of the failed speculations list to which a speculation
 49   // is appended when it causes a deoptimization.
 50   FailedSpeculation** _failed_speculations;
 51 
 52 public:
 53   // Computes the size of a JVMCINMethodData object
 54   static int compute_size(const char* nmethod_mirror_name) {
</pre>
<hr />
<pre>
 69   // Gets the JVMCI name of the nmethod (which may be NULL).
 70   const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }
 71 
 72   // Clears the HotSpotNmethod.address field in the  mirror. If nm
 73   // is dead, the HotSpotNmethod.entryPoint field is also cleared.
 74   void invalidate_nmethod_mirror(nmethod* nm);
 75 
 76   // Gets the mirror from nm&#39;s oops table.
 77   oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);
 78 
 79   // Sets the mirror in nm&#39;s oops table.
 80   void set_nmethod_mirror(nmethod* nm, oop mirror);
 81 
 82   // Clears the mirror in nm&#39;s oops table.
 83   void clear_nmethod_mirror(nmethod* nm);
 84 };
 85 
 86 // A top level class that represents an initialized JVMCI runtime.
 87 // There is one instance of this class per HotSpotJVMCIRuntime object.
 88 class JVMCIRuntime: public CHeapObj&lt;mtJVMCI&gt; {

 89  public:
 90   // Constants describing whether JVMCI wants to be able to adjust the compilation
 91   // level selected for a method by the VM compilation policy and if so, based on
 92   // what information about the method being schedule for compilation.
 93   enum CompLevelAdjustment {
 94      none = 0,             // no adjustment
 95      by_holder = 1,        // adjust based on declaring class of method
 96      by_full_signature = 2 // adjust based on declaring class, name and signature of method
 97   };
 98 
 99  private:
<span class="line-removed">100   volatile bool _being_initialized;</span>
<span class="line-removed">101   volatile bool _initialized;</span>
102 














103   JVMCIObject _HotSpotJVMCIRuntime_instance;
104 
<span class="line-modified">105   bool _shutdown_called;</span>









106 
107   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);
108 
109   // Implementation methods for loading and constant pool access.
110   static Klass* get_klass_by_name_impl(Klass*&amp; accessing_klass,
111                                        const constantPoolHandle&amp; cpool,
112                                        Symbol* klass_name,
113                                        bool require_local);
114   static Klass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
115                                           int klass_index,
116                                           bool&amp; is_accessible,
117                                           Klass* loading_klass);
118   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
119                                         int field_index);
120   static Method*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
121                                            int method_index, Bytecodes::Code bc,
122                                            InstanceKlass* loading_klass);
123 
124   // Helper methods
125   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);
126   static Method*    lookup_method(InstanceKlass*  accessor,
127                                   Klass*  holder,
128                                   Symbol*         name,
129                                   Symbol*         sig,
130                                   Bytecodes::Code bc,
131                                   constantTag     tag);
132 
133  public:
<span class="line-modified">134   JVMCIRuntime() {</span>
<span class="line-modified">135     _initialized = false;</span>
<span class="line-modified">136     _being_initialized = false;</span>
<span class="line-modified">137     _shutdown_called = false;</span>
<span class="line-modified">138   }</span>
<span class="line-modified">139 </span>
<span class="line-modified">140   /**</span>
<span class="line-modified">141    * Compute offsets and construct any state required before executing JVMCI code.</span>
<span class="line-modified">142    */</span>






















143   void initialize(JVMCIEnv* jvmciEnv);
144 
<span class="line-modified">145   /**</span>
<span class="line-modified">146    * Gets the singleton HotSpotJVMCIRuntime instance, initializing it if necessary</span>
<span class="line-modified">147    */</span>














148   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);
149 
150   bool is_HotSpotJVMCIRuntime_initialized() {
151     return _HotSpotJVMCIRuntime_instance.is_non_null();
152   }
153 
<span class="line-modified">154   /**</span>
<span class="line-modified">155    * Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()</span>
<span class="line-modified">156    */</span>




157   void initialize_JVMCI(JVMCI_TRAPS);
158 
<span class="line-modified">159   /**</span>
<span class="line-removed">160    * Explicitly initialize HotSpotJVMCIRuntime itself</span>
<span class="line-removed">161    */</span>
162   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);
163 
164   void call_getCompiler(TRAPS);
165 

166   void shutdown();
167 
<span class="line-removed">168   bool shutdown_called() {</span>
<span class="line-removed">169     return _shutdown_called;</span>
<span class="line-removed">170   }</span>
<span class="line-removed">171 </span>
172   void bootstrap_finished(TRAPS);
173 
174   // Look up a klass by name from a particular class loader (the accessor&#39;s).
175   // If require_local, result must be defined in that class loader, or NULL.
176   // If !require_local, a result from remote class loader may be reported,
177   // if sufficient class loader constraints exist such that initiating
178   // a class loading request from the given loader is bound to return
179   // the class defined in the remote loader (or throw an error).
180   //
181   // Return an unloaded klass if !require_local and no class at all is found.
182   //
183   // The CI treats a klass as loaded if it is consistently defined in
184   // another loader, even if it hasn&#39;t yet been loaded in all loaders
185   // that could potentially see it via delegation.
186   static Klass* get_klass_by_name(Klass* accessing_klass,
187                                   Symbol* klass_name,
188                                   bool require_local);
189 
190   // Constant pool access.
191   static Klass*   get_klass_by_index(const constantPoolHandle&amp; cpool,
</pre>
<hr />
<pre>
205   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);
206 
207   // Helper routine for determining the validity of a compilation
208   // with respect to concurrent class loading.
209   static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);
210 
211   // Compiles `target` with the JVMCI compiler.
212   void compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; target, int entry_bci);
213 
214   // Register the result of a compilation.
215   JVMCI::CodeInstallResult register_method(JVMCIEnv* JVMCIENV,
216                        const methodHandle&amp;       target,
217                        nmethod*&amp;                 nm,
218                        int                       entry_bci,
219                        CodeOffsets*              offsets,
220                        int                       orig_pc_offset,
221                        CodeBuffer*               code_buffer,
222                        int                       frame_words,
223                        OopMapSet*                oop_map_set,
224                        ExceptionHandlerTable*    handler_table,
<span class="line-modified">225                        ImplicitExceptionTable* implicit_exception_table,</span>
226                        AbstractCompiler*         compiler,
227                        DebugInformationRecorder* debug_info,
228                        Dependencies*             dependencies,
229                        int                       compile_id,
230                        bool                      has_unsafe_access,
231                        bool                      has_wide_vector,
232                        JVMCIObject               compiled_code,
233                        JVMCIObject               nmethod_mirror,
234                        FailedSpeculation**       failed_speculations,
235                        char*                     speculations,
236                        int                       speculations_len);
237 
<span class="line-modified">238   /**</span>
<span class="line-removed">239    * Exits the VM due to an unexpected exception.</span>
<span class="line-removed">240    */</span>
241   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);
242 
243   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);
244 
245 #define CHECK_EXIT THREAD); \
246   if (HAS_PENDING_EXCEPTION) { \
247     char buf[256]; \
248     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \
249     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
250     return; \
251   } \
252   (void)(0
253 
254 #define CHECK_EXIT_(v) THREAD);                 \
255   if (HAS_PENDING_EXCEPTION) { \
256     char buf[256]; \
257     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \
258     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
259     return v; \
260   } \
</pre>
<hr />
<pre>
323   // Print the passed in object, optionally followed by a newline.  If
324   // as_string is true and the object is a java.lang.String then it
325   // printed as a string, otherwise the type of the object is printed
326   // followed by its address.
327   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
328 #if INCLUDE_G1GC
329   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
330   static void write_barrier_post(JavaThread* thread, void* card);
331 #endif
332   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
333 
334   // used to throw exceptions from compiled JVMCI code
335   static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
336   // helper methods to throw exception with complex messages
337   static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
338   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
339 
340   // Test only function
341   static jint test_deoptimize_call_int(JavaThread* thread, int value);
342 };
<span class="line-removed">343 </span>
<span class="line-removed">344 // Tracing macros.</span>
<span class="line-removed">345 </span>
<span class="line-removed">346 #define IF_TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1)) ; else</span>
<span class="line-removed">347 #define IF_TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2)) ; else</span>
<span class="line-removed">348 #define IF_TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3)) ; else</span>
<span class="line-removed">349 #define IF_TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4)) ; else</span>
<span class="line-removed">350 #define IF_TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5)) ; else</span>
<span class="line-removed">351 </span>
<span class="line-removed">352 #define TRACE_jvmci_1 if (!(JVMCITraceLevel &gt;= 1 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot; JVMCITrace-1: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-removed">353 #define TRACE_jvmci_2 if (!(JVMCITraceLevel &gt;= 2 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;    JVMCITrace-2: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-removed">354 #define TRACE_jvmci_3 if (!(JVMCITraceLevel &gt;= 3 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;       JVMCITrace-3: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-removed">355 #define TRACE_jvmci_4 if (!(JVMCITraceLevel &gt;= 4 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;          JVMCITrace-4: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-removed">356 #define TRACE_jvmci_5 if (!(JVMCITraceLevel &gt;= 5 &amp;&amp; (tty-&gt;print(PTR_FORMAT &quot;             JVMCITrace-5: &quot;, p2i(JavaThread::current())), true))) ; else tty-&gt;print_cr</span>
<span class="line-removed">357 </span>
358 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_JVMCI_JVMCIRUNTIME_HPP
 25 #define SHARE_JVMCI_JVMCIRUNTIME_HPP
 26 
 27 #include &quot;code/nmethod.hpp&quot;
 28 #include &quot;jvmci/jvmci.hpp&quot;
 29 #include &quot;jvmci/jvmciExceptions.hpp&quot;
 30 #include &quot;jvmci/jvmciObject.hpp&quot;
<span class="line-added"> 31 #include &quot;utilities/linkedlist.hpp&quot;</span>
 32 
 33 class JVMCIEnv;
 34 class JVMCICompiler;
 35 class JVMCICompileState;
<span class="line-added"> 36 class MetadataHandles;</span>
 37 
 38 // Encapsulates the JVMCI metadata for an nmethod.
 39 // JVMCINMethodData objects are inlined into nmethods
 40 // at nmethod::_jvmci_data_offset.
 41 class JVMCINMethodData {
 42   // Index for the HotSpotNmethod mirror in the nmethod&#39;s oops table.
 43   // This is -1 if there is no mirror in the oops table.
 44   int _nmethod_mirror_index;
 45 
 46   // Is HotSpotNmethod.name non-null? If so, the value is
 47   // embedded in the end of this object.
 48   bool _has_name;
 49 
 50   // Address of the failed speculations list to which a speculation
 51   // is appended when it causes a deoptimization.
 52   FailedSpeculation** _failed_speculations;
 53 
 54 public:
 55   // Computes the size of a JVMCINMethodData object
 56   static int compute_size(const char* nmethod_mirror_name) {
</pre>
<hr />
<pre>
 71   // Gets the JVMCI name of the nmethod (which may be NULL).
 72   const char* name() { return _has_name ? (char*)(((address) this) + sizeof(JVMCINMethodData)) : NULL; }
 73 
 74   // Clears the HotSpotNmethod.address field in the  mirror. If nm
 75   // is dead, the HotSpotNmethod.entryPoint field is also cleared.
 76   void invalidate_nmethod_mirror(nmethod* nm);
 77 
 78   // Gets the mirror from nm&#39;s oops table.
 79   oop get_nmethod_mirror(nmethod* nm, bool phantom_ref);
 80 
 81   // Sets the mirror in nm&#39;s oops table.
 82   void set_nmethod_mirror(nmethod* nm, oop mirror);
 83 
 84   // Clears the mirror in nm&#39;s oops table.
 85   void clear_nmethod_mirror(nmethod* nm);
 86 };
 87 
 88 // A top level class that represents an initialized JVMCI runtime.
 89 // There is one instance of this class per HotSpotJVMCIRuntime object.
 90 class JVMCIRuntime: public CHeapObj&lt;mtJVMCI&gt; {
<span class="line-added"> 91   friend class JVMCI;</span>
 92  public:
 93   // Constants describing whether JVMCI wants to be able to adjust the compilation
 94   // level selected for a method by the VM compilation policy and if so, based on
 95   // what information about the method being schedule for compilation.
 96   enum CompLevelAdjustment {
 97      none = 0,             // no adjustment
 98      by_holder = 1,        // adjust based on declaring class of method
 99      by_full_signature = 2 // adjust based on declaring class, name and signature of method
100   };
101 
102  private:


103 
<span class="line-added">104   enum InitState {</span>
<span class="line-added">105     uninitialized,</span>
<span class="line-added">106     being_initialized,</span>
<span class="line-added">107     fully_initialized</span>
<span class="line-added">108   };</span>
<span class="line-added">109 </span>
<span class="line-added">110   // Initialization state of this JVMCIRuntime.</span>
<span class="line-added">111   InitState _init_state;</span>
<span class="line-added">112 </span>
<span class="line-added">113   // A wrapper for a VM scoped JNI global handle (i.e. JVMCIEnv::make_global)</span>
<span class="line-added">114   // to a HotSpotJVMCIRuntime instance. This JNI global handle must never</span>
<span class="line-added">115   // be explicitly destroyed as it can be accessed in a racy way during</span>
<span class="line-added">116   // JVMCI shutdown. Furthermore, it will be reclaimed when</span>
<span class="line-added">117   // the VM or shared library JavaVM managing the handle dies.</span>
118   JVMCIObject _HotSpotJVMCIRuntime_instance;
119 
<span class="line-modified">120   // Result of calling JNI_CreateJavaVM in the JVMCI shared library.</span>
<span class="line-added">121   // Must only be modified under JVMCI_lock.</span>
<span class="line-added">122   volatile JavaVM* _shared_library_javavm;</span>
<span class="line-added">123 </span>
<span class="line-added">124   // The HotSpot heap based runtime will have an id of -1 and the</span>
<span class="line-added">125   // JVMCI shared library runtime will have an id of 0.</span>
<span class="line-added">126   int _id;</span>
<span class="line-added">127 </span>
<span class="line-added">128   // Handles to Metadata objects.</span>
<span class="line-added">129   MetadataHandles* _metadata_handles;</span>
130 
131   JVMCIObject create_jvmci_primitive_type(BasicType type, JVMCI_TRAPS);
132 
133   // Implementation methods for loading and constant pool access.
134   static Klass* get_klass_by_name_impl(Klass*&amp; accessing_klass,
135                                        const constantPoolHandle&amp; cpool,
136                                        Symbol* klass_name,
137                                        bool require_local);
138   static Klass*   get_klass_by_index_impl(const constantPoolHandle&amp; cpool,
139                                           int klass_index,
140                                           bool&amp; is_accessible,
141                                           Klass* loading_klass);
142   static void   get_field_by_index_impl(InstanceKlass* loading_klass, fieldDescriptor&amp; fd,
143                                         int field_index);
144   static Method*  get_method_by_index_impl(const constantPoolHandle&amp; cpool,
145                                            int method_index, Bytecodes::Code bc,
146                                            InstanceKlass* loading_klass);
147 
148   // Helper methods
149   static bool       check_klass_accessibility(Klass* accessing_klass, Klass* resolved_klass);
150   static Method*    lookup_method(InstanceKlass*  accessor,
151                                   Klass*  holder,
152                                   Symbol*         name,
153                                   Symbol*         sig,
154                                   Bytecodes::Code bc,
155                                   constantTag     tag);
156 
157  public:
<span class="line-modified">158   JVMCIRuntime(int id);</span>
<span class="line-modified">159 </span>
<span class="line-modified">160   int id() const        { return _id;   }</span>
<span class="line-modified">161 </span>
<span class="line-modified">162   // Ensures that a JVMCI shared library JavaVM exists for this runtime.</span>
<span class="line-modified">163   // If the JavaVM was created by this call, then the thread-local JNI</span>
<span class="line-modified">164   // interface pointer for the JavaVM is returned otherwise NULL is returned.</span>
<span class="line-modified">165   JNIEnv* init_shared_library_javavm();</span>
<span class="line-modified">166 </span>
<span class="line-added">167   // Determines if the JVMCI shared library JavaVM exists for this runtime.</span>
<span class="line-added">168   bool has_shared_library_javavm() { return _shared_library_javavm != NULL; }</span>
<span class="line-added">169 </span>
<span class="line-added">170   // Copies info about the JVMCI shared library JavaVM associated with this</span>
<span class="line-added">171   // runtime into `info` as follows:</span>
<span class="line-added">172   // {</span>
<span class="line-added">173   //     javaVM, // the {@code JavaVM*} value</span>
<span class="line-added">174   //     javaVM-&gt;functions-&gt;reserved0,</span>
<span class="line-added">175   //     javaVM-&gt;functions-&gt;reserved1,</span>
<span class="line-added">176   //     javaVM-&gt;functions-&gt;reserved2</span>
<span class="line-added">177   // }</span>
<span class="line-added">178   void init_JavaVM_info(jlongArray info, JVMCI_TRAPS);</span>
<span class="line-added">179 </span>
<span class="line-added">180   // Wrappers for calling Invocation Interface functions on the</span>
<span class="line-added">181   // JVMCI shared library JavaVM associated with this runtime.</span>
<span class="line-added">182   // These wrappers ensure all required thread state transitions are performed.</span>
<span class="line-added">183   jint AttachCurrentThread(JavaThread* thread, void **penv, void *args);</span>
<span class="line-added">184   jint AttachCurrentThreadAsDaemon(JavaThread* thread, void **penv, void *args);</span>
<span class="line-added">185   jint DetachCurrentThread(JavaThread* thread);</span>
<span class="line-added">186   jint GetEnv(JavaThread* thread, void **penv, jint version);</span>
<span class="line-added">187 </span>
<span class="line-added">188   // Compute offsets and construct any state required before executing JVMCI code.</span>
189   void initialize(JVMCIEnv* jvmciEnv);
190 
<span class="line-modified">191   // Allocation and management of JNI global object handles</span>
<span class="line-modified">192   // whose lifetime is scoped by this JVMCIRuntime. The lifetime</span>
<span class="line-modified">193   // of these handles is the same as the JVMCI shared library JavaVM</span>
<span class="line-added">194   // associated with this JVMCIRuntime. These JNI handles are</span>
<span class="line-added">195   // used when creating a IndirectHotSpotObjectConstantImpl in the</span>
<span class="line-added">196   // shared library JavaVM.</span>
<span class="line-added">197   jobject make_global(const Handle&amp; obj);</span>
<span class="line-added">198   void destroy_global(jobject handle);</span>
<span class="line-added">199   bool is_global_handle(jobject handle);</span>
<span class="line-added">200 </span>
<span class="line-added">201   // Allocation and management of metadata handles.</span>
<span class="line-added">202   jmetadata allocate_handle(const methodHandle&amp; handle);</span>
<span class="line-added">203   jmetadata allocate_handle(const constantPoolHandle&amp; handle);</span>
<span class="line-added">204   void release_handle(jmetadata handle);</span>
<span class="line-added">205 </span>
<span class="line-added">206   // Gets the HotSpotJVMCIRuntime instance for this runtime,</span>
<span class="line-added">207   // initializing it first if necessary.</span>
208   JVMCIObject get_HotSpotJVMCIRuntime(JVMCI_TRAPS);
209 
210   bool is_HotSpotJVMCIRuntime_initialized() {
211     return _HotSpotJVMCIRuntime_instance.is_non_null();
212   }
213 
<span class="line-modified">214   // Gets the current HotSpotJVMCIRuntime instance for this runtime which</span>
<span class="line-modified">215   // may be a &quot;null&quot; JVMCIObject value.</span>
<span class="line-modified">216   JVMCIObject probe_HotSpotJVMCIRuntime() {</span>
<span class="line-added">217     return _HotSpotJVMCIRuntime_instance;</span>
<span class="line-added">218   }</span>
<span class="line-added">219 </span>
<span class="line-added">220   // Trigger initialization of HotSpotJVMCIRuntime through JVMCI.getRuntime()</span>
221   void initialize_JVMCI(JVMCI_TRAPS);
222 
<span class="line-modified">223   // Explicitly initialize HotSpotJVMCIRuntime itself</span>


224   void initialize_HotSpotJVMCIRuntime(JVMCI_TRAPS);
225 
226   void call_getCompiler(TRAPS);
227 
<span class="line-added">228   // Shuts down this runtime by calling HotSpotJVMCIRuntime.shutdown().</span>
229   void shutdown();
230 




231   void bootstrap_finished(TRAPS);
232 
233   // Look up a klass by name from a particular class loader (the accessor&#39;s).
234   // If require_local, result must be defined in that class loader, or NULL.
235   // If !require_local, a result from remote class loader may be reported,
236   // if sufficient class loader constraints exist such that initiating
237   // a class loading request from the given loader is bound to return
238   // the class defined in the remote loader (or throw an error).
239   //
240   // Return an unloaded klass if !require_local and no class at all is found.
241   //
242   // The CI treats a klass as loaded if it is consistently defined in
243   // another loader, even if it hasn&#39;t yet been loaded in all loaders
244   // that could potentially see it via delegation.
245   static Klass* get_klass_by_name(Klass* accessing_klass,
246                                   Symbol* klass_name,
247                                   bool require_local);
248 
249   // Constant pool access.
250   static Klass*   get_klass_by_index(const constantPoolHandle&amp; cpool,
</pre>
<hr />
<pre>
264   static InstanceKlass* get_instance_klass_for_declared_method_holder(Klass* klass);
265 
266   // Helper routine for determining the validity of a compilation
267   // with respect to concurrent class loading.
268   static JVMCI::CodeInstallResult validate_compile_task_dependencies(Dependencies* target, JVMCICompileState* task, char** failure_detail);
269 
270   // Compiles `target` with the JVMCI compiler.
271   void compile_method(JVMCIEnv* JVMCIENV, JVMCICompiler* compiler, const methodHandle&amp; target, int entry_bci);
272 
273   // Register the result of a compilation.
274   JVMCI::CodeInstallResult register_method(JVMCIEnv* JVMCIENV,
275                        const methodHandle&amp;       target,
276                        nmethod*&amp;                 nm,
277                        int                       entry_bci,
278                        CodeOffsets*              offsets,
279                        int                       orig_pc_offset,
280                        CodeBuffer*               code_buffer,
281                        int                       frame_words,
282                        OopMapSet*                oop_map_set,
283                        ExceptionHandlerTable*    handler_table,
<span class="line-modified">284                        ImplicitExceptionTable*   implicit_exception_table,</span>
285                        AbstractCompiler*         compiler,
286                        DebugInformationRecorder* debug_info,
287                        Dependencies*             dependencies,
288                        int                       compile_id,
289                        bool                      has_unsafe_access,
290                        bool                      has_wide_vector,
291                        JVMCIObject               compiled_code,
292                        JVMCIObject               nmethod_mirror,
293                        FailedSpeculation**       failed_speculations,
294                        char*                     speculations,
295                        int                       speculations_len);
296 
<span class="line-modified">297   // Exits the VM due to an unexpected exception.</span>


298   static void exit_on_pending_exception(JVMCIEnv* JVMCIENV, const char* message);
299 
300   static void describe_pending_hotspot_exception(JavaThread* THREAD, bool clear);
301 
302 #define CHECK_EXIT THREAD); \
303   if (HAS_PENDING_EXCEPTION) { \
304     char buf[256]; \
305     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \
306     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
307     return; \
308   } \
309   (void)(0
310 
311 #define CHECK_EXIT_(v) THREAD);                 \
312   if (HAS_PENDING_EXCEPTION) { \
313     char buf[256]; \
314     jio_snprintf(buf, 256, &quot;Uncaught exception at %s:%d&quot;, __FILE__, __LINE__); \
315     JVMCIRuntime::exit_on_pending_exception(NULL, buf); \
316     return v; \
317   } \
</pre>
<hr />
<pre>
380   // Print the passed in object, optionally followed by a newline.  If
381   // as_string is true and the object is a java.lang.String then it
382   // printed as a string, otherwise the type of the object is printed
383   // followed by its address.
384   static void log_object(JavaThread* thread, oopDesc* object, bool as_string, bool newline);
385 #if INCLUDE_G1GC
386   static void write_barrier_pre(JavaThread* thread, oopDesc* obj);
387   static void write_barrier_post(JavaThread* thread, void* card);
388 #endif
389   static jboolean validate_object(JavaThread* thread, oopDesc* parent, oopDesc* child);
390 
391   // used to throw exceptions from compiled JVMCI code
392   static int throw_and_post_jvmti_exception(JavaThread* thread, const char* exception, const char* message);
393   // helper methods to throw exception with complex messages
394   static int throw_klass_external_name_exception(JavaThread* thread, const char* exception, Klass* klass);
395   static int throw_class_cast_exception(JavaThread* thread, const char* exception, Klass* caster_klass, Klass* target_klass);
396 
397   // Test only function
398   static jint test_deoptimize_call_int(JavaThread* thread, int value);
399 };















400 #endif // SHARE_JVMCI_JVMCIRUNTIME_HPP
</pre>
</td>
</tr>
</table>
<center><a href="jvmciRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmci_globals.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
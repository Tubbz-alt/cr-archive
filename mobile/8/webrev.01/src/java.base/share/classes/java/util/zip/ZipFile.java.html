<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.zip;
  27 
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Objects;
  51 import java.util.NoSuchElementException;
  52 import java.util.Set;
  53 import java.util.Spliterator;
  54 import java.util.Spliterators;
  55 import java.util.TreeSet;
  56 import java.util.WeakHashMap;
  57 import java.util.function.Consumer;
  58 import java.util.function.IntFunction;
  59 import java.util.jar.JarEntry;
  60 import java.util.jar.JarFile;
  61 import java.util.stream.Stream;
  62 import java.util.stream.StreamSupport;
  63 import jdk.internal.access.JavaUtilZipFileAccess;
  64 import jdk.internal.access.JavaUtilJarAccess;
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.misc.VM;
  67 import jdk.internal.perf.PerfCounter;
  68 import jdk.internal.ref.CleanerFactory;
  69 import jdk.internal.vm.annotation.Stable;
  70 import sun.nio.cs.UTF_8;
  71 import sun.security.util.SignatureFileVerifier;
  72 
  73 import static java.util.zip.ZipConstants64.*;
  74 import static java.util.zip.ZipUtils.*;
  75 
  76 /**
  77  * This class is used to read entries from a zip file.
  78  *
  79  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  80  * or method in this class will cause a {@link NullPointerException} to be
  81  * thrown.
  82  *
  83  * @apiNote
  84  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  85  * should be called explicitly or by try-with-resources. Subclasses are responsible
  86  * for the cleanup of resources acquired by the subclass. Subclasses that override
  87  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  88  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  89  * {@code finalize} method.
  90  *
  91  * @author      David Connelly
  92  * @since 1.1
  93  */
  94 public class ZipFile implements ZipConstants, Closeable {
  95 
  96     private final String name;     // zip file name
  97     private volatile boolean closeRequested;
  98 
  99     // The &quot;resource&quot; used by this zip file that needs to be
 100     // cleaned after use.
 101     // a) the input streams that need to be closed
 102     // b) the list of cached Inflater objects
 103     // c) the &quot;native&quot; source of this zip file.
 104     private final @Stable CleanableResource res;
 105 
 106     private static final int STORED = ZipEntry.STORED;
 107     private static final int DEFLATED = ZipEntry.DEFLATED;
 108 
 109     /**
 110      * Mode flag to open a zip file for reading.
 111      */
 112     public static final int OPEN_READ = 0x1;
 113 
 114     /**
 115      * Mode flag to open a zip file and mark it for deletion.  The file will be
 116      * deleted some time between the moment that it is opened and the moment
 117      * that it is closed, but its contents will remain accessible via the
 118      * {@code ZipFile} object until either the close method is invoked or the
 119      * virtual machine exits.
 120      */
 121     public static final int OPEN_DELETE = 0x4;
 122 
 123     /**
 124      * Opens a zip file for reading.
 125      *
 126      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 127      * method is called with the {@code name} argument as its argument
 128      * to ensure the read is allowed.
 129      *
 130      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 131      * decode the entry names and comments.
 132      *
 133      * @param name the name of the zip file
 134      * @throws ZipException if a ZIP format error has occurred
 135      * @throws IOException if an I/O error has occurred
 136      * @throws SecurityException if a security manager exists and its
 137      *         {@code checkRead} method doesn&#39;t allow read access to the file.
 138      *
 139      * @see SecurityManager#checkRead(java.lang.String)
 140      */
 141     public ZipFile(String name) throws IOException {
 142         this(new File(name), OPEN_READ);
 143     }
 144 
 145     /**
 146      * Opens a new {@code ZipFile} to read from the specified
 147      * {@code File} object in the specified mode.  The mode argument
 148      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 149      *
 150      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 151      * method is called with the {@code name} argument as its argument to
 152      * ensure the read is allowed.
 153      *
 154      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 155      * decode the entry names and comments
 156      *
 157      * @param file the ZIP file to be opened for reading
 158      * @param mode the mode in which the file is to be opened
 159      * @throws ZipException if a ZIP format error has occurred
 160      * @throws IOException if an I/O error has occurred
 161      * @throws SecurityException if a security manager exists and
 162      *         its {@code checkRead} method
 163      *         doesn&#39;t allow read access to the file,
 164      *         or its {@code checkDelete} method doesn&#39;t allow deleting
 165      *         the file when the {@code OPEN_DELETE} flag is set.
 166      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 167      * @see SecurityManager#checkRead(java.lang.String)
 168      * @since 1.3
 169      */
 170     public ZipFile(File file, int mode) throws IOException {
 171         this(file, mode, UTF_8.INSTANCE);
 172     }
 173 
 174     /**
 175      * Opens a ZIP file for reading given the specified File object.
 176      *
 177      * &lt;p&gt;The UTF-8 {@link java.nio.charset.Charset charset} is used to
 178      * decode the entry names and comments.
 179      *
 180      * @param file the ZIP file to be opened for reading
 181      * @throws ZipException if a ZIP format error has occurred
 182      * @throws IOException if an I/O error has occurred
 183      */
 184     public ZipFile(File file) throws ZipException, IOException {
 185         this(file, OPEN_READ);
 186     }
 187 
 188     /**
 189      * Opens a new {@code ZipFile} to read from the specified
 190      * {@code File} object in the specified mode.  The mode argument
 191      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 192      *
 193      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 194      * method is called with the {@code name} argument as its argument to
 195      * ensure the read is allowed.
 196      *
 197      * @param file the ZIP file to be opened for reading
 198      * @param mode the mode in which the file is to be opened
 199      * @param charset
 200      *        the {@linkplain java.nio.charset.Charset charset} to
 201      *        be used to decode the ZIP entry name and comment that are not
 202      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 203      *        purpose flag).
 204      *
 205      * @throws ZipException if a ZIP format error has occurred
 206      * @throws IOException if an I/O error has occurred
 207      *
 208      * @throws SecurityException
 209      *         if a security manager exists and its {@code checkRead}
 210      *         method doesn&#39;t allow read access to the file,or its
 211      *         {@code checkDelete} method doesn&#39;t allow deleting the
 212      *         file when the {@code OPEN_DELETE} flag is set
 213      *
 214      * @throws IllegalArgumentException if the {@code mode} argument is invalid
 215      *
 216      * @see SecurityManager#checkRead(java.lang.String)
 217      *
 218      * @since 1.7
 219      */
 220     public ZipFile(File file, int mode, Charset charset) throws IOException
 221     {
 222         if (((mode &amp; OPEN_READ) == 0) ||
 223             ((mode &amp; ~(OPEN_READ | OPEN_DELETE)) != 0)) {
 224             throw new IllegalArgumentException(&quot;Illegal mode: 0x&quot;+
 225                                                Integer.toHexString(mode));
 226         }
 227         String name = file.getPath();
 228         SecurityManager sm = System.getSecurityManager();
 229         if (sm != null) {
 230             sm.checkRead(name);
 231             if ((mode &amp; OPEN_DELETE) != 0) {
 232                 sm.checkDelete(name);
 233             }
 234         }
 235         Objects.requireNonNull(charset, &quot;charset&quot;);
 236 
 237         this.name = name;
 238         long t0 = System.nanoTime();
 239 
 240         this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);
 241 
 242         PerfCounter.getZipFileOpenTime().addElapsedTimeFrom(t0);
 243         PerfCounter.getZipFileCount().increment();
 244     }
 245 
 246     /**
 247      * Opens a zip file for reading.
 248      *
 249      * &lt;p&gt;First, if there is a security manager, its {@code checkRead}
 250      * method is called with the {@code name} argument as its argument
 251      * to ensure the read is allowed.
 252      *
 253      * @param name the name of the zip file
 254      * @param charset
 255      *        the {@linkplain java.nio.charset.Charset charset} to
 256      *        be used to decode the ZIP entry name and comment that are not
 257      *        encoded by using UTF-8 encoding (indicated by entry&#39;s general
 258      *        purpose flag).
 259      *
 260      * @throws ZipException if a ZIP format error has occurred
 261      * @throws IOException if an I/O error has occurred
 262      * @throws SecurityException
 263      *         if a security manager exists and its {@code checkRead}
 264      *         method doesn&#39;t allow read access to the file
 265      *
 266      * @see SecurityManager#checkRead(java.lang.String)
 267      *
 268      * @since 1.7
 269      */
 270     public ZipFile(String name, Charset charset) throws IOException
 271     {
 272         this(new File(name), OPEN_READ, charset);
 273     }
 274 
 275     /**
 276      * Opens a ZIP file for reading given the specified File object.
 277      *
 278      * @param file the ZIP file to be opened for reading
 279      * @param charset
 280      *        The {@linkplain java.nio.charset.Charset charset} to be
 281      *        used to decode the ZIP entry name and comment (ignored if
 282      *        the &lt;a href=&quot;package-summary.html#lang_encoding&quot;&gt; language
 283      *        encoding bit&lt;/a&gt; of the ZIP entry&#39;s general purpose bit
 284      *        flag is set).
 285      *
 286      * @throws ZipException if a ZIP format error has occurred
 287      * @throws IOException if an I/O error has occurred
 288      *
 289      * @since 1.7
 290      */
 291     public ZipFile(File file, Charset charset) throws IOException
 292     {
 293         this(file, OPEN_READ, charset);
 294     }
 295 
 296     /**
 297      * Returns the zip file comment, or null if none.
 298      *
 299      * @return the comment string for the zip file, or null if none
 300      *
 301      * @throws IllegalStateException if the zip file has been closed
 302      *
 303      * @since 1.7
 304      */
 305     public String getComment() {
 306         synchronized (this) {
 307             ensureOpen();
 308             if (res.zsrc.comment == null) {
 309                 return null;
 310             }
 311             return res.zsrc.zc.toString(res.zsrc.comment);
 312         }
 313     }
 314 
 315     /**
 316      * Returns the zip file entry for the specified name, or null
 317      * if not found.
 318      *
 319      * @param name the name of the entry
 320      * @return the zip file entry, or null if not found
 321      * @throws IllegalStateException if the zip file has been closed
 322      */
 323     public ZipEntry getEntry(String name) {
 324         Objects.requireNonNull(name, &quot;name&quot;);
 325         ZipEntry entry = null;
 326         synchronized (this) {
 327             ensureOpen();
 328             int pos = res.zsrc.getEntryPos(name, true);
 329             if (pos != -1) {
 330                 entry = getZipEntry(name, pos);
 331             }
 332         }
 333         return entry;
 334     }
 335 
 336     /**
 337      * Returns an input stream for reading the contents of the specified
 338      * zip file entry.
 339      * &lt;p&gt;
 340      * Closing this ZIP file will, in turn, close all input streams that
 341      * have been returned by invocations of this method.
 342      *
 343      * @param entry the zip file entry
 344      * @return the input stream for reading the contents of the specified
 345      * zip file entry.
 346      * @throws ZipException if a ZIP format error has occurred
 347      * @throws IOException if an I/O error has occurred
 348      * @throws IllegalStateException if the zip file has been closed
 349      */
 350     public InputStream getInputStream(ZipEntry entry) throws IOException {
 351         Objects.requireNonNull(entry, &quot;entry&quot;);
 352         int pos;
 353         ZipFileInputStream in;
 354         Source zsrc = res.zsrc;
 355         Set&lt;InputStream&gt; istreams = res.istreams;
 356         synchronized (this) {
 357             ensureOpen();
 358             if (Objects.equals(lastEntryName, entry.name)) {
 359                 pos = lastEntryPos;
 360             } else {
 361                 pos = zsrc.getEntryPos(entry.name, false);
 362             }
 363             if (pos == -1) {
 364                 return null;
 365             }
 366             in = new ZipFileInputStream(zsrc.cen, pos);
 367             switch (CENHOW(zsrc.cen, pos)) {
 368             case STORED:
 369                 synchronized (istreams) {
 370                     istreams.add(in);
 371                 }
 372                 return in;
 373             case DEFLATED:
 374                 // Inflater likes a bit of slack
 375                 // MORE: Compute good size for inflater stream:
 376                 long size = CENLEN(zsrc.cen, pos) + 2;
 377                 if (size &gt; 65536) {
 378                     size = 8192;
 379                 }
 380                 if (size &lt;= 0) {
 381                     size = 4096;
 382                 }
 383                 InputStream is = new ZipFileInflaterInputStream(in, res, (int)size);
 384                 synchronized (istreams) {
 385                     istreams.add(is);
 386                 }
 387                 return is;
 388             default:
 389                 throw new ZipException(&quot;invalid compression method&quot;);
 390             }
 391         }
 392     }
 393 
 394     private static class InflaterCleanupAction implements Runnable {
 395         private final Inflater inf;
 396         private final CleanableResource res;
 397 
 398         InflaterCleanupAction(Inflater inf, CleanableResource res) {
 399             this.inf = inf;
 400             this.res = res;
 401         }
 402 
 403         @Override
 404         public void run() {
 405             res.releaseInflater(inf);
 406         }
 407     }
 408 
 409     private class ZipFileInflaterInputStream extends InflaterInputStream {
 410         private volatile boolean closeRequested;
 411         private boolean eof = false;
 412         private final Cleanable cleanable;
 413 
 414         ZipFileInflaterInputStream(ZipFileInputStream zfin,
 415                                    CleanableResource res, int size) {
 416             this(zfin, res, res.getInflater(), size);
 417         }
 418 
 419         private ZipFileInflaterInputStream(ZipFileInputStream zfin,
 420                                            CleanableResource res,
 421                                            Inflater inf, int size) {
 422             super(zfin, inf, size);
 423             this.cleanable = CleanerFactory.cleaner().register(this,
 424                     new InflaterCleanupAction(inf, res));
 425         }
 426 
 427         public void close() throws IOException {
 428             if (closeRequested)
 429                 return;
 430             closeRequested = true;
 431             super.close();
 432             synchronized (res.istreams) {
 433                 res.istreams.remove(this);
 434             }
 435             cleanable.clean();
 436         }
 437 
 438         // Override fill() method to provide an extra &quot;dummy&quot; byte
 439         // at the end of the input stream. This is required when
 440         // using the &quot;nowrap&quot; Inflater option.
 441         protected void fill() throws IOException {
 442             if (eof) {
 443                 throw new EOFException(&quot;Unexpected end of ZLIB input stream&quot;);
 444             }
 445             len = in.read(buf, 0, buf.length);
 446             if (len == -1) {
 447                 buf[0] = 0;
 448                 len = 1;
 449                 eof = true;
 450             }
 451             inf.setInput(buf, 0, len);
 452         }
 453 
 454         public int available() throws IOException {
 455             if (closeRequested)
 456                 return 0;
 457             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 458             return (avail &gt; (long) Integer.MAX_VALUE ?
 459                     Integer.MAX_VALUE : (int) avail);
 460         }
 461     }
 462 
 463     /**
 464      * Returns the path name of the ZIP file.
 465      * @return the path name of the ZIP file
 466      */
 467     public String getName() {
 468         return name;
 469     }
 470 
 471     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 472             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 473 
 474         private int i = 0;
 475         private final int entryCount;
 476 
 477         public ZipEntryIterator(int entryCount) {
 478             this.entryCount = entryCount;
 479         }
 480 
 481         @Override
 482         public boolean hasMoreElements() {
 483             return hasNext();
 484         }
 485 
 486         @Override
 487         public boolean hasNext() {
 488             return i &lt; entryCount;
 489         }
 490 
 491         @Override
 492         public T nextElement() {
 493             return next();
 494         }
 495 
 496         @Override
 497         @SuppressWarnings(&quot;unchecked&quot;)
 498         public T next() {
 499             synchronized (ZipFile.this) {
 500                 ensureOpen();
 501                 if (!hasNext()) {
 502                     throw new NoSuchElementException();
 503                 }
 504                 // each &quot;entry&quot; has 3 ints in table entries
 505                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));
 506             }
 507         }
 508 
 509         @Override
 510         public Iterator&lt;T&gt; asIterator() {
 511             return this;
 512         }
 513     }
 514 
 515     /**
 516      * Returns an enumeration of the ZIP file entries.
 517      * @return an enumeration of the ZIP file entries
 518      * @throws IllegalStateException if the zip file has been closed
 519      */
 520     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 521         synchronized (this) {
 522             ensureOpen();
 523             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total);
 524         }
 525     }
 526 
 527     private Enumeration&lt;JarEntry&gt; jarEntries() {
 528         synchronized (this) {
 529             ensureOpen();
 530             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total);
 531         }
 532     }
 533 
 534     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 535         private int index;
 536         private final int fence;
 537         private final IntFunction&lt;T&gt; gen;
 538 
 539         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 540             super((long)fence,
 541                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 542                   Spliterator.NONNULL);
 543             this.index = index;
 544             this.fence = fence;
 545             this.gen = gen;
 546         }
 547 
 548         @Override
 549         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 550             if (action == null)
 551                 throw new NullPointerException();
 552             if (index &gt;= 0 &amp;&amp; index &lt; fence) {
 553                 synchronized (ZipFile.this) {
 554                     ensureOpen();
 555                     action.accept(gen.apply(res.zsrc.getEntryPos(index++ * 3)));
 556                 }
 557                 return true;
 558             }
 559             return false;
 560         }
 561     }
 562 
 563     /**
 564      * Returns an ordered {@code Stream} over the ZIP file entries.
 565      *
 566      * Entries appear in the {@code Stream} in the order they appear in
 567      * the central directory of the ZIP file.
 568      *
 569      * @return an ordered {@code Stream} of entries in this ZIP file
 570      * @throws IllegalStateException if the zip file has been closed
 571      * @since 1.8
 572      */
 573     public Stream&lt;? extends ZipEntry&gt; stream() {
 574         synchronized (this) {
 575             ensureOpen();
 576             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 577                 pos -&gt; getZipEntry(null, pos)), false);
 578        }
 579     }
 580 
 581     private String getEntryName(int pos) {
 582         byte[] cen = res.zsrc.cen;
 583         int nlen = CENNAM(cen, pos);
 584         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 585         return zc.toString(cen, pos + CENHDR, nlen);
 586     }
 587 
 588     /*
 589      * Returns an ordered {@code Stream} over the zip file entry names.
 590      *
 591      * Entry names appear in the {@code Stream} in the order they appear in
 592      * the central directory of the ZIP file.
 593      *
 594      * @return an ordered {@code Stream} of entry names in this zip file
 595      * @throws IllegalStateException if the zip file has been closed
 596      * @since 10
 597      */
 598     private Stream&lt;String&gt; entryNameStream() {
 599         synchronized (this) {
 600             ensureOpen();
 601             return StreamSupport.stream(
 602                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 603         }
 604     }
 605 
 606     /*
 607      * Returns an ordered {@code Stream} over the zip file entries.
 608      *
 609      * Entries appear in the {@code Stream} in the order they appear in
 610      * the central directory of the jar file.
 611      *
 612      * @return an ordered {@code Stream} of entries in this zip file
 613      * @throws IllegalStateException if the zip file has been closed
 614      * @since 10
 615      */
 616     private Stream&lt;JarEntry&gt; jarStream() {
 617         synchronized (this) {
 618             ensureOpen();
 619             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
 620                 pos -&gt; (JarEntry)getZipEntry(null, pos)), false);
 621         }
 622     }
 623 
 624     private String lastEntryName;
 625     private int lastEntryPos;
 626 
 627     /* Check ensureOpen() before invoking this method */
 628     private ZipEntry getZipEntry(String name, int pos) {
 629         byte[] cen = res.zsrc.cen;
 630         int nlen = CENNAM(cen, pos);
 631         int elen = CENEXT(cen, pos);
 632         int clen = CENCOM(cen, pos);
 633 
 634         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 635         if (name != null) {
 636             // only need to check for mismatch of trailing slash
 637             if (nlen &gt; 0 &amp;&amp;
 638                 !name.isEmpty() &amp;&amp;
 639                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;
 640                 !name.endsWith(&quot;/&quot;))
 641             {
 642                 name += &#39;/&#39;;
 643             }
 644         } else {
 645             // invoked from iterator, use the entry name stored in cen
 646             name = zc.toString(cen, pos + CENHDR, nlen);
 647         }
 648         ZipEntry e;
 649         if (this instanceof JarFile) {
 650             e = Source.JUJA.entryFor((JarFile)this, name);
 651         } else {
 652             e = new ZipEntry(name);
 653         }
 654         e.flag = CENFLG(cen, pos);
 655         e.xdostime = CENTIM(cen, pos);
 656         e.crc = CENCRC(cen, pos);
 657         e.size = CENLEN(cen, pos);
 658         e.csize = CENSIZ(cen, pos);
 659         e.method = CENHOW(cen, pos);
 660         if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {
 661             // 12 bits for setuid, setgid, sticky + perms
 662             e.posixPerms = CENATX_PERMS(cen, pos) &amp; 0xFFF;
 663         }
 664 
 665         if (elen != 0) {
 666             int start = pos + CENHDR + nlen;
 667             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 668         }
 669         if (clen != 0) {
 670             int start = pos + CENHDR + nlen + elen;
 671             e.comment = zc.toString(cen, start, clen);
 672         }
 673         lastEntryName = e.name;
 674         lastEntryPos = pos;
 675         return e;
 676     }
 677 
 678     /**
 679      * Returns the number of entries in the ZIP file.
 680      *
 681      * @return the number of entries in the ZIP file
 682      * @throws IllegalStateException if the zip file has been closed
 683      */
 684     public int size() {
 685         synchronized (this) {
 686             ensureOpen();
 687             return res.zsrc.total;
 688         }
 689     }
 690 
 691     private static class CleanableResource implements Runnable {
 692         // The outstanding inputstreams that need to be closed
 693         final Set&lt;InputStream&gt; istreams;
 694 
 695         // List of cached Inflater objects for decompression
 696         Deque&lt;Inflater&gt; inflaterCache;
 697 
 698         final Cleanable cleanable;
 699 
 700         Source zsrc;
 701 
 702         CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {
 703             this.cleanable = CleanerFactory.cleaner().register(zf, this);
 704             this.istreams = Collections.newSetFromMap(new WeakHashMap&lt;&gt;());
 705             this.inflaterCache = new ArrayDeque&lt;&gt;();
 706             this.zsrc = Source.get(file, (mode &amp; OPEN_DELETE) != 0, zc);
 707         }
 708 
 709         void clean() {
 710             cleanable.clean();
 711         }
 712 
 713         /*
 714          * Gets an inflater from the list of available inflaters or allocates
 715          * a new one.
 716          */
 717         Inflater getInflater() {
 718             Inflater inf;
 719             synchronized (inflaterCache) {
 720                 if ((inf = inflaterCache.poll()) != null) {
 721                     return inf;
 722                 }
 723             }
 724             return new Inflater(true);
 725         }
 726 
 727         /*
 728          * Releases the specified inflater to the list of available inflaters.
 729          */
 730         void releaseInflater(Inflater inf) {
 731             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 732             if (inflaters != null) {
 733                 synchronized (inflaters) {
 734                     // double checked!
 735                     if (inflaters == this.inflaterCache) {
 736                         inf.reset();
 737                         inflaters.add(inf);
 738                         return;
 739                     }
 740                 }
 741             }
 742             // inflaters cache already closed - just end it.
 743             inf.end();
 744         }
 745 
 746         public void run() {
 747             IOException ioe = null;
 748 
 749             // Release cached inflaters and close the cache first
 750             Deque&lt;Inflater&gt; inflaters = this.inflaterCache;
 751             if (inflaters != null) {
 752                 synchronized (inflaters) {
 753                     // no need to double-check as only one thread gets a
 754                     // chance to execute run() (Cleaner guarantee)...
 755                     Inflater inf;
 756                     while ((inf = inflaters.poll()) != null) {
 757                         inf.end();
 758                     }
 759                     // close inflaters cache
 760                     this.inflaterCache = null;
 761                 }
 762             }
 763 
 764             // Close streams, release their inflaters
 765             if (istreams != null) {
 766                 synchronized (istreams) {
 767                     if (!istreams.isEmpty()) {
 768                         InputStream[] copy = istreams.toArray(new InputStream[0]);
 769                         istreams.clear();
 770                         for (InputStream is : copy) {
 771                             try {
 772                                 is.close();
 773                             } catch (IOException e) {
 774                                 if (ioe == null) ioe = e;
 775                                 else ioe.addSuppressed(e);
 776                             }
 777                         }
 778                     }
 779                 }
 780             }
 781 
 782             // Release zip src
 783             if (zsrc != null) {
 784                 synchronized (zsrc) {
 785                     try {
 786                         Source.release(zsrc);
 787                         zsrc = null;
 788                     } catch (IOException e) {
 789                         if (ioe == null) ioe = e;
 790                         else ioe.addSuppressed(e);
 791                     }
 792                 }
 793             }
 794             if (ioe != null) {
 795                 throw new UncheckedIOException(ioe);
 796             }
 797         }
 798 
 799     }
 800 
 801     /**
 802      * Closes the ZIP file.
 803      *
 804      * &lt;p&gt; Closing this ZIP file will close all of the input streams
 805      * previously returned by invocations of the {@link #getInputStream
 806      * getInputStream} method.
 807      *
 808      * @throws IOException if an I/O error has occurred
 809      */
 810     public void close() throws IOException {
 811         if (closeRequested) {
 812             return;
 813         }
 814         closeRequested = true;
 815 
 816         synchronized (this) {
 817             // Close streams, release their inflaters, release cached inflaters
 818             // and release zip source
 819             try {
 820                 res.clean();
 821             } catch (UncheckedIOException ioe) {
 822                 throw ioe.getCause();
 823             }
 824         }
 825     }
 826 
 827     private void ensureOpen() {
 828         if (closeRequested) {
 829             throw new IllegalStateException(&quot;zip file closed&quot;);
 830         }
 831         if (res.zsrc == null) {
 832             throw new IllegalStateException(&quot;The object is not initialized.&quot;);
 833         }
 834     }
 835 
 836     private void ensureOpenOrZipException() throws IOException {
 837         if (closeRequested) {
 838             throw new ZipException(&quot;ZipFile closed&quot;);
 839         }
 840     }
 841 
 842     /*
 843      * Inner class implementing the input stream used to read a
 844      * (possibly compressed) zip file entry.
 845      */
 846     private class ZipFileInputStream extends InputStream {
 847         private volatile boolean closeRequested;
 848         private   long pos;     // current position within entry data
 849         private   long startingPos; // Start position for the entry data
 850         protected long rem;     // number of remaining bytes within entry
 851         protected long size;    // uncompressed size of this entry
 852 
 853         ZipFileInputStream(byte[] cen, int cenpos) {
 854             rem = CENSIZ(cen, cenpos);
 855             size = CENLEN(cen, cenpos);
 856             pos = CENOFF(cen, cenpos);
 857             // zip64
 858             if (rem == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||
 859                 pos == ZIP64_MAGICVAL) {
 860                 checkZIP64(cen, cenpos);
 861             }
 862             // negative for lazy initialization, see getDataOffset();
 863             pos = - (pos + ZipFile.this.res.zsrc.locpos);
 864         }
 865 
 866         private void checkZIP64(byte[] cen, int cenpos) {
 867             int off = cenpos + CENHDR + CENNAM(cen, cenpos);
 868             int end = off + CENEXT(cen, cenpos);
 869             while (off + 4 &lt; end) {
 870                 int tag = get16(cen, off);
 871                 int sz = get16(cen, off + 2);
 872                 off += 4;
 873                 if (off + sz &gt; end)         // invalid data
 874                     break;
 875                 if (tag == EXTID_ZIP64) {
 876                     if (size == ZIP64_MAGICVAL) {
 877                         if (sz &lt; 8 || (off + 8) &gt; end)
 878                             break;
 879                         size = get64(cen, off);
 880                         sz -= 8;
 881                         off += 8;
 882                     }
 883                     if (rem == ZIP64_MAGICVAL) {
 884                         if (sz &lt; 8 || (off + 8) &gt; end)
 885                             break;
 886                         rem = get64(cen, off);
 887                         sz -= 8;
 888                         off += 8;
 889                     }
 890                     if (pos == ZIP64_MAGICVAL) {
 891                         if (sz &lt; 8 || (off + 8) &gt; end)
 892                             break;
 893                         pos = get64(cen, off);
 894                         sz -= 8;
 895                         off += 8;
 896                     }
 897                     break;
 898                 }
 899                 off += sz;
 900             }
 901         }
 902 
 903         /*
 904          * The Zip file spec explicitly allows the LOC extra data size to
 905          * be different from the CEN extra data size. Since we cannot trust
 906          * the CEN extra data size, we need to read the LOC to determine
 907          * the entry data offset.
 908          */
 909         private long initDataOffset() throws IOException {
 910             if (pos &lt;= 0) {
 911                 byte[] loc = new byte[LOCHDR];
 912                 pos = -pos;
 913                 int len = ZipFile.this.res.zsrc.readFullyAt(loc, 0, loc.length, pos);
 914                 if (len != LOCHDR) {
 915                     throw new ZipException(&quot;ZipFile error reading zip file&quot;);
 916                 }
 917                 if (LOCSIG(loc) != LOCSIG) {
 918                     throw new ZipException(&quot;ZipFile invalid LOC header (bad signature)&quot;);
 919                 }
 920                 pos += LOCHDR + LOCNAM(loc) + LOCEXT(loc);
 921                 startingPos = pos; // Save starting position for the entry
 922             }
 923             return pos;
 924         }
 925 
 926         public int read(byte b[], int off, int len) throws IOException {
 927             synchronized (ZipFile.this) {
 928                 ensureOpenOrZipException();
 929                 initDataOffset();
 930                 if (rem == 0) {
 931                     return -1;
 932                 }
 933                 if (len &gt; rem) {
 934                     len = (int) rem;
 935                 }
 936                 if (len &lt;= 0) {
 937                     return 0;
 938                 }
 939                 len = ZipFile.this.res.zsrc.readAt(b, off, len, pos);
 940                 if (len &gt; 0) {
 941                     pos += len;
 942                     rem -= len;
 943                 }
 944             }
 945             if (rem == 0) {
 946                 close();
 947             }
 948             return len;
 949         }
 950 
 951         public int read() throws IOException {
 952             byte[] b = new byte[1];
 953             if (read(b, 0, 1) == 1) {
 954                 return b[0] &amp; 0xff;
 955             } else {
 956                 return -1;
 957             }
 958         }
 959 
 960         public long skip(long n) throws IOException {
 961             synchronized (ZipFile.this) {
 962                 initDataOffset();
 963                 long newPos = pos + n;
 964                 if (n &gt; 0) {
 965                     // If we overflowed adding the skip value or are moving
 966                     // past EOF, set the skip value to number of bytes remaining
 967                     // to reach EOF
 968                     if (newPos &lt; 0 || n &gt; rem) {
 969                         n = rem;
 970                     }
 971                 } else if (newPos &lt; startingPos) {
 972                     // Tried to position before BOF so set position to the
 973                     // BOF and return the number of bytes we moved backwards
 974                     // to reach BOF
 975                     n = startingPos - pos;
 976                 }
 977                 pos += n;
 978                 rem -= n;
 979             }
 980             if (rem == 0) {
 981                 close();
 982             }
 983             return n;
 984         }
 985 
 986         public int available() {
 987             return rem &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) rem;
 988         }
 989 
 990         public long size() {
 991             return size;
 992         }
 993 
 994         public void close() {
 995             if (closeRequested) {
 996                 return;
 997             }
 998             closeRequested = true;
 999             rem = 0;
1000             synchronized (res.istreams) {
1001                 res.istreams.remove(this);
1002             }
1003         }
1004 
1005     }
1006 
1007     /**
1008      * Returns the names of the META-INF/MANIFEST.MF entry - if exists -
1009      * and any signature-related files under META-INF. This method is used in
1010      * JarFile, via SharedSecrets, as an optimization.
1011      */
1012     private List&lt;String&gt; getManifestAndSignatureRelatedFiles() {
1013         synchronized (this) {
1014             ensureOpen();
1015             Source zsrc = res.zsrc;
1016             int[] metanames = zsrc.signatureMetaNames;
1017             List&lt;String&gt; files = null;
1018             if (zsrc.manifestPos &gt;= 0) {
1019                 files = new ArrayList&lt;&gt;();
1020                 files.add(getEntryName(zsrc.manifestPos));
1021             }
1022             if (metanames != null) {
1023                 if (files == null) {
1024                     files = new ArrayList&lt;&gt;();
1025                 }
1026                 for (int i = 0; i &lt; metanames.length; i++) {
1027                     files.add(getEntryName(metanames[i]));
1028                 }
1029             }
1030             return files == null ? List.of() : files;
1031         }
1032     }
1033 
1034     /**
1035      * Returns the name of the META-INF/MANIFEST.MF entry, ignoring
1036      * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the
1037      * manifest if there is also at least one signature-related file.
1038      * This method is used in JarFile, via SharedSecrets, as an optimization
1039      * when looking up the manifest file.
1040      */
1041     private String getManifestName(boolean onlyIfSignatureRelatedFiles) {
1042         synchronized (this) {
1043             ensureOpen();
1044             Source zsrc = res.zsrc;
1045             int pos = zsrc.manifestPos;
1046             if (pos &gt;= 0 &amp;&amp; (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {
1047                 return getEntryName(pos);
1048             }
1049         }
1050         return null;
1051     }
1052 
1053     /**
1054      * Returns the versions for which there exists a non-directory
1055      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1056      * This method is used in JarFile, via SharedSecrets, as an
1057      * optimization when looking up potentially versioned entries.
1058      * Returns an empty array if no versioned entries exist.
1059      */
1060     private int[] getMetaInfVersions() {
1061         synchronized (this) {
1062             ensureOpen();
1063             return res.zsrc.metaVersions;
1064         }
1065     }
1066 
1067     private static boolean isWindows;
1068 
1069     static {
1070         SharedSecrets.setJavaUtilZipFileAccess(
1071             new JavaUtilZipFileAccess() {
1072                 @Override
1073                 public boolean startsWithLocHeader(ZipFile zip) {
1074                     return zip.res.zsrc.startsWithLoc;
1075                 }
1076                 @Override
1077                 public List&lt;String&gt; getManifestAndSignatureRelatedFiles(JarFile jar) {
1078                     return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();
1079                 }
1080                 @Override
1081                 public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {
1082                     return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);
1083                 }
1084                 @Override
1085                 public int[] getMetaInfVersions(JarFile jar) {
1086                     return ((ZipFile)jar).getMetaInfVersions();
1087                 }
1088                 @Override
1089                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip) {
1090                     return zip.jarEntries();
1091                 }
1092                 @Override
1093                 public Stream&lt;JarEntry&gt; stream(ZipFile zip) {
1094                     return zip.jarStream();
1095                 }
1096                 @Override
1097                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1098                     return zip.entryNameStream();
1099                 }
1100                 // only set posix perms value via ZipEntry contructor for now
1101                 @Override
1102                 public int getPosixPerms(ZipEntry ze) {
1103                     return ze.posixPerms;
1104                 }
1105                 @Override
1106                 public void setPosixPerms(ZipEntry ze, int perms) {
1107                     ze.posixPerms = perms;
1108                 }
1109 
1110              }
1111         );
1112         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1113     }
1114 
1115     private static class Source {
1116         // While this is only used from ZipFile, defining it there would cause
1117         // a bootstrap cycle that would leave this initialized as null
1118         private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();
1119         // &quot;META-INF/&quot;.length()
1120         private static final int META_INF_LENGTH = 9;
1121         private static final int[] EMPTY_META_VERSIONS = new int[0];
1122 
1123         private final Key key;               // the key in files
1124         private final @Stable ZipCoder zc;   // zip coder used to decode/encode
1125 
1126         private int refs = 1;
1127 
1128         private RandomAccessFile zfile;      // zfile of the underlying zip file
1129         private byte[] cen;                  // CEN &amp; ENDHDR
1130         private long locpos;                 // position of first LOC header (usually 0)
1131         private byte[] comment;              // zip file comment
1132                                              // list of meta entries in META-INF dir
1133         private int   manifestPos = -1;      // position of the META-INF/MANIFEST.MF, if exists
1134         private int[] signatureMetaNames;    // positions of signature related entries, if such exist
1135         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1136         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1137 
1138         // A Hashmap for all entries.
1139         //
1140         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1141         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1142         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1143         // entry name and its offset {@code pos} in the central directory hdeader.
1144         //
1145         // private static class Entry {
1146         //     int hash;       // 32 bit hashcode on name
1147         //     int next;       // hash chain: index into entries
1148         //     int pos;        // Offset of central directory file header
1149         // }
1150         // private Entry[] entries;             // array of hashed cen entry
1151         //
1152         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1153         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1154         // referred by their index of their positions in the {@code entries}.
1155         //
1156         private int[] entries;                  // array of hashed cen entry
1157         private int addEntry(int index, int hash, int next, int pos) {
1158             entries[index++] = hash;
1159             entries[index++] = next;
1160             entries[index++] = pos;
1161             return index;
1162         }
1163         private int getEntryHash(int index) { return entries[index]; }
1164         private int getEntryNext(int index) { return entries[index + 1]; }
1165         private int getEntryPos(int index)  { return entries[index + 2]; }
1166         private static final int ZIP_ENDCHAIN  = -1;
1167         private int total;                   // total number of entries
1168         private int[] table;                 // Hash chain heads: indexes into entries
1169         private int tablelen;                // number of hash heads
1170 
1171         private static class Key {
1172             final BasicFileAttributes attrs;
1173             File file;
1174             final boolean utf8;
1175 
1176             public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {
1177                 this.attrs = attrs;
1178                 this.file = file;
1179                 this.utf8 = zc.isUTF8();
1180             }
1181 
1182             public int hashCode() {
1183                 long t = utf8 ? 0 : Long.MAX_VALUE;
1184                 t += attrs.lastModifiedTime().toMillis();
1185                 return ((int)(t ^ (t &gt;&gt;&gt; 32))) + file.hashCode();
1186             }
1187 
1188             public boolean equals(Object obj) {
1189                 if (obj instanceof Key) {
1190                     Key key = (Key)obj;
1191                     if (key.utf8 != utf8) {
1192                         return false;
1193                     }
1194                     if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {
1195                         return false;
1196                     }
1197                     Object fk = attrs.fileKey();
1198                     if (fk != null) {
1199                         return fk.equals(key.attrs.fileKey());
1200                     } else {
1201                         return file.equals(key.file);
1202                     }
1203                 }
1204                 return false;
1205             }
1206         }
1207         private static final HashMap&lt;Key, Source&gt; files = new HashMap&lt;&gt;();
1208 
1209 
1210         static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {
1211             final Key key;
1212             try {
1213                 key = new Key(file,
1214                         Files.readAttributes(file.toPath(), BasicFileAttributes.class),
1215                         zc);
1216             } catch (InvalidPathException ipe) {
1217                 throw new IOException(ipe);
1218             }
1219             Source src;
1220             synchronized (files) {
1221                 src = files.get(key);
1222                 if (src != null) {
1223                     src.refs++;
1224                     return src;
1225                 }
1226             }
1227             src = new Source(key, toDelete, zc);
1228 
1229             synchronized (files) {
1230                 if (files.containsKey(key)) {    // someone else put in first
1231                     src.close();                 // close the newly created one
1232                     src = files.get(key);
1233                     src.refs++;
1234                     return src;
1235                 }
1236                 files.put(key, src);
1237                 return src;
1238             }
1239         }
1240 
1241         static void release(Source src) throws IOException {
1242             synchronized (files) {
1243                 if (src != null &amp;&amp; --src.refs == 0) {
1244                     files.remove(src.key);
1245                     src.close();
1246                 }
1247             }
1248         }
1249 
1250         private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {
1251             this.zc = zc;
1252             this.key = key;
1253             if (toDelete) {
1254                 if (isWindows) {
1255                     this.zfile = SharedSecrets.getJavaIORandomAccessFileAccess()
1256                                               .openAndDelete(key.file, &quot;r&quot;);
1257                 } else {
1258                     this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1259                     key.file.delete();
1260                 }
1261             } else {
1262                 this.zfile = new RandomAccessFile(key.file, &quot;r&quot;);
1263             }
1264             try {
1265                 initCEN(-1);
1266                 byte[] buf = new byte[4];
1267                 readFullyAt(buf, 0, 4, 0);
1268                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1269             } catch (IOException x) {
1270                 try {
1271                     this.zfile.close();
1272                 } catch (IOException xx) {}
1273                 throw x;
1274             }
1275         }
1276 
1277         private void close() throws IOException {
1278             zfile.close();
1279             zfile = null;
1280             cen = null;
1281             entries = null;
1282             table = null;
1283             manifestPos = -1;
1284             signatureMetaNames = null;
1285             metaVersions = EMPTY_META_VERSIONS;
1286         }
1287 
1288         private static final int BUF_SIZE = 8192;
1289         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1290             throws IOException
1291         {
1292             synchronized (zfile) {
1293                 zfile.seek(pos);
1294                 int N = len;
1295                 while (N &gt; 0) {
1296                     int n = Math.min(BUF_SIZE, N);
1297                     zfile.readFully(buf, off, n);
1298                     off += n;
1299                     N -= n;
1300                 }
1301                 return len;
1302             }
1303         }
1304 
1305         private final int readAt(byte[] buf, int off, int len, long pos)
1306             throws IOException
1307         {
1308             synchronized (zfile) {
1309                 zfile.seek(pos);
1310                 return zfile.read(buf, off, len);
1311             }
1312         }
1313 
1314         private static class End {
1315             int  centot;     // 4 bytes
1316             long cenlen;     // 4 bytes
1317             long cenoff;     // 4 bytes
1318             long endpos;     // 4 bytes
1319         }
1320 
1321         /*
1322          * Searches for end of central directory (END) header. The contents of
1323          * the END header will be read and placed in endbuf. Returns the file
1324          * position of the END header, otherwise returns -1 if the END header
1325          * was not found or an error occurred.
1326          */
1327         private End findEND() throws IOException {
1328             long ziplen = zfile.length();
1329             if (ziplen &lt;= 0)
1330                 zerror(&quot;zip file is empty&quot;);
1331             End end = new End();
1332             byte[] buf = new byte[READBLOCKSZ];
1333             long minHDR = (ziplen - END_MAXLEN) &gt; 0 ? ziplen - END_MAXLEN : 0;
1334             long minPos = minHDR - (buf.length - ENDHDR);
1335             for (long pos = ziplen - buf.length; pos &gt;= minPos; pos -= (buf.length - ENDHDR)) {
1336                 int off = 0;
1337                 if (pos &lt; 0) {
1338                     // Pretend there are some NUL bytes before start of file
1339                     off = (int)-pos;
1340                     Arrays.fill(buf, 0, off, (byte)0);
1341                 }
1342                 int len = buf.length - off;
1343                 if (readFullyAt(buf, off, len, pos + off) != len ) {
1344                     zerror(&quot;zip END header not found&quot;);
1345                 }
1346                 // Now scan the block backwards for END header signature
1347                 for (int i = buf.length - ENDHDR; i &gt;= 0; i--) {
1348                     if (buf[i+0] == (byte)&#39;P&#39;    &amp;&amp;
1349                         buf[i+1] == (byte)&#39;K&#39;    &amp;&amp;
1350                         buf[i+2] == (byte)&#39;\005&#39; &amp;&amp;
1351                         buf[i+3] == (byte)&#39;\006&#39;) {
1352                         // Found ENDSIG header
1353                         byte[] endbuf = Arrays.copyOfRange(buf, i, i + ENDHDR);
1354                         end.centot = ENDTOT(endbuf);
1355                         end.cenlen = ENDSIZ(endbuf);
1356                         end.cenoff = ENDOFF(endbuf);
1357                         end.endpos = pos + i;
1358                         int comlen = ENDCOM(endbuf);
1359                         if (end.endpos + ENDHDR + comlen != ziplen) {
1360                             // ENDSIG matched, however the size of file comment in it does
1361                             // not match the real size. One &quot;common&quot; cause for this problem
1362                             // is some &quot;extra&quot; bytes are padded at the end of the zipfile.
1363                             // Let&#39;s do some extra verification, we don&#39;t care about the
1364                             // performance in this situation.
1365                             byte[] sbuf = new byte[4];
1366                             long cenpos = end.endpos - end.cenlen;
1367                             long locpos = cenpos - end.cenoff;
1368                             if  (cenpos &lt; 0 ||
1369                                  locpos &lt; 0 ||
1370                                  readFullyAt(sbuf, 0, sbuf.length, cenpos) != 4 ||
1371                                  GETSIG(sbuf) != CENSIG ||
1372                                  readFullyAt(sbuf, 0, sbuf.length, locpos) != 4 ||
1373                                  GETSIG(sbuf) != LOCSIG) {
1374                                 continue;
1375                             }
1376                         }
1377                         if (comlen &gt; 0) {    // this zip file has comlen
1378                             comment = new byte[comlen];
1379                             if (readFullyAt(comment, 0, comlen, end.endpos + ENDHDR) != comlen) {
1380                                 zerror(&quot;zip comment read failed&quot;);
1381                             }
1382                         }
1383                         // must check for a zip64 end record; it is always permitted to be present
1384                         try {
1385                             byte[] loc64 = new byte[ZIP64_LOCHDR];
1386                             if (end.endpos &lt; ZIP64_LOCHDR ||
1387                                 readFullyAt(loc64, 0, loc64.length, end.endpos - ZIP64_LOCHDR)
1388                                 != loc64.length || GETSIG(loc64) != ZIP64_LOCSIG) {
1389                                 return end;
1390                             }
1391                             long end64pos = ZIP64_LOCOFF(loc64);
1392                             byte[] end64buf = new byte[ZIP64_ENDHDR];
1393                             if (readFullyAt(end64buf, 0, end64buf.length, end64pos)
1394                                 != end64buf.length || GETSIG(end64buf) != ZIP64_ENDSIG) {
1395                                 return end;
1396                             }
1397                             // end64 candidate found,
1398                             long cenlen64 = ZIP64_ENDSIZ(end64buf);
1399                             long cenoff64 = ZIP64_ENDOFF(end64buf);
1400                             long centot64 = ZIP64_ENDTOT(end64buf);
1401                             // double-check
1402                             if (cenlen64 != end.cenlen &amp;&amp; end.cenlen != ZIP64_MAGICVAL ||
1403                                 cenoff64 != end.cenoff &amp;&amp; end.cenoff != ZIP64_MAGICVAL ||
1404                                 centot64 != end.centot &amp;&amp; end.centot != ZIP64_MAGICCOUNT) {
1405                                 return end;
1406                             }
1407                             // to use the end64 values
1408                             end.cenlen = cenlen64;
1409                             end.cenoff = cenoff64;
1410                             end.centot = (int)centot64; // assume total &lt; 2g
1411                             end.endpos = end64pos;
1412                         } catch (IOException x) {}    // no zip64 loc/end
1413                         return end;
1414                     }
1415                 }
1416             }
1417             zerror(&quot;zip END header not found&quot;);
1418             return null; //make compiler happy
1419         }
1420 
1421         // Reads zip file central directory.
1422         private void initCEN(int knownTotal) throws IOException {
1423             // Prefer locals for better performance during startup
1424             byte[] cen;
1425             if (knownTotal == -1) {
1426                 End end = findEND();
1427                 if (end.endpos == 0) {
1428                     locpos = 0;
1429                     total = 0;
1430                     entries = new int[0];
1431                     this.cen = null;
1432                     return;         // only END header present
1433                 }
1434                 if (end.cenlen &gt; end.endpos)
1435                     zerror(&quot;invalid END header (bad central directory size)&quot;);
1436                 long cenpos = end.endpos - end.cenlen;     // position of CEN table
1437                 // Get position of first local file (LOC) header, taking into
1438                 // account that there may be a stub prefixed to the zip file.
1439                 locpos = cenpos - end.cenoff;
1440                 if (locpos &lt; 0) {
1441                     zerror(&quot;invalid END header (bad central directory offset)&quot;);
1442                 }
1443                 // read in the CEN and END
1444                 cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];
1445                 if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {
1446                     zerror(&quot;read CEN tables failed&quot;);
1447                 }
1448                 total = end.centot;
1449             } else {
1450                 cen = this.cen;
1451                 total = knownTotal;
1452             }
1453             // hash table for entries
1454             entries  = new int[total * 3];
1455 
1456             this.tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1457             int tablelen = this.tablelen;
1458 
1459             this.table = new int[tablelen];
1460             int[] table = this.table;
1461 
1462             Arrays.fill(table, ZIP_ENDCHAIN);
1463             int idx = 0;
1464             int hash;
1465             int next;
1466 
1467             // list for all meta entries
1468             ArrayList&lt;Integer&gt; signatureNames = null;
1469             // Set of all version numbers seen in META-INF/versions/
1470             Set&lt;Integer&gt; metaVersionsSet = null;
1471 
1472             // Iterate through the entries in the central directory
1473             int i = 0;
1474             int hsh;
1475             int pos = 0;
1476             int entryPos = CENHDR;
1477             int limit = cen.length - ENDHDR;
1478             while (entryPos &lt;= limit) {
1479                 if (i &gt;= total) {
1480                     // This will only happen if the zip file has an incorrect
1481                     // ENDTOT field, which usually means it contains more than
1482                     // 65535 entries.
1483                     initCEN(countCENHeaders(cen, limit));
1484                     return;
1485                 }
1486                 if (CENSIG(cen, pos) != CENSIG)
1487                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1488                 int method = CENHOW(cen, pos);
1489                 int nlen   = CENNAM(cen, pos);
1490                 int elen   = CENEXT(cen, pos);
1491                 int clen   = CENCOM(cen, pos);
1492                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1493                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1494                 if (method != STORED &amp;&amp; method != DEFLATED)
1495                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1496                 if (entryPos + nlen &gt; limit)
1497                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1498                 // Record the CEN offset and the name hash in our hash cell.
1499                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);
1500                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1501                 next = table[hsh];
1502                 table[hsh] = idx;
1503                 idx = addEntry(idx, hash, next, pos);
1504                 // Adds name to metanames.
1505                 if (isMetaName(cen, entryPos, nlen)) {
1506                     // nlen is at least META_INF_LENGTH
1507                     if (isManifestName(cen, entryPos + META_INF_LENGTH,
1508                             nlen - META_INF_LENGTH)) {
1509                         manifestPos = pos;
1510                     } else {
1511                         if (isSignatureRelated(cen, entryPos, nlen)) {
1512                             if (signatureNames == null)
1513                                 signatureNames = new ArrayList&lt;&gt;(4);
1514                             signatureNames.add(pos);
1515                         }
1516 
1517                         // If this is a versioned entry, parse the version
1518                         // and store it for later. This optimizes lookup
1519                         // performance in multi-release jar files
1520                         int version = getMetaVersion(cen,
1521                             entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);
1522                         if (version &gt; 0) {
1523                             if (metaVersionsSet == null)
1524                                 metaVersionsSet = new TreeSet&lt;&gt;();
1525                             metaVersionsSet.add(version);
1526                         }
1527                     }
1528                 }
1529                 // skip ext and comment
1530                 pos = entryPos + nlen + elen + clen;
1531                 entryPos = pos + CENHDR;
1532                 i++;
1533             }
1534             total = i;
1535             if (signatureNames != null) {
1536                 int len = signatureNames.size();
1537                 signatureMetaNames = new int[len];
1538                 for (int j = 0; j &lt; len; j++) {
1539                     signatureMetaNames[j] = signatureNames.get(j);
1540                 }
1541             }
1542             if (metaVersionsSet != null) {
1543                 metaVersions = new int[metaVersionsSet.size()];
1544                 int c = 0;
1545                 for (Integer version : metaVersionsSet) {
1546                     metaVersions[c++] = version;
1547                 }
1548             } else {
1549                 metaVersions = EMPTY_META_VERSIONS;
1550             }
1551             if (pos + ENDHDR != cen.length) {
1552                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1553             }
1554         }
1555 
1556         private static void zerror(String msg) throws ZipException {
1557             throw new ZipException(msg);
1558         }
1559 
1560         /*
1561          * Returns the {@code pos} of the zip cen entry corresponding to the
1562          * specified entry name, or -1 if not found.
1563          */
1564         private int getEntryPos(String name, boolean addSlash) {
1565             if (total == 0) {
1566                 return -1;
1567             }
1568 
1569             int hsh = ZipCoder.normalizedHash(name);
1570             int idx = table[(hsh &amp; 0x7fffffff) % tablelen];
1571 
1572             // Search down the target hash chain for a entry whose
1573             // 32 bit hash matches the hashed name.
1574             while (idx != ZIP_ENDCHAIN) {
1575                 if (getEntryHash(idx) == hsh) {
1576                     // The CEN name must match the specfied one
1577                     int pos = getEntryPos(idx);
1578 
1579                     try {
1580                         ZipCoder zc = zipCoderForPos(pos);
1581                         String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));
1582 
1583                         // If addSlash is true we&#39;ll test for name+/ in addition to
1584                         // name, unless name is the empty string or already ends with a
1585                         // slash
1586                         int entryLen = entry.length();
1587                         int nameLen = name.length();
1588                         if ((entryLen == nameLen &amp;&amp; entry.equals(name)) ||
1589                                 (addSlash &amp;&amp;
1590                                 nameLen + 1 == entryLen &amp;&amp;
1591                                 entry.startsWith(name) &amp;&amp;
1592                                 entry.charAt(entryLen - 1) == &#39;/&#39;)) {
1593                             return pos;
1594                         }
1595                     } catch (IllegalArgumentException iae) {
1596                         // Ignore
1597                     }
1598                 }
1599                 idx = getEntryNext(idx);
1600             }
1601             return -1;
1602         }
1603 
1604         private ZipCoder zipCoderForPos(int pos) {
1605             if (zc.isUTF8()) {
1606                 return zc;
1607             }
1608             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
1609                 return ZipCoder.UTF8;
1610             }
1611             return zc;
1612         }
1613 
1614         /**
1615          * Returns true if the bytes represent a non-directory name
1616          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1617          */
1618         private static boolean isMetaName(byte[] name, int off, int len) {
1619             // Use the &quot;oldest ASCII trick in the book&quot;:
1620             // ch | 0x20 == Character.toLowerCase(ch)
1621             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1622                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1623                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1624                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1625                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1626                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1627                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1628                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1629                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1630                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1631                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1632         }
1633 
1634         /*
1635          * Check if the bytes represents a name equals to MANIFEST.MF
1636          */
1637         private static boolean isManifestName(byte[] name, int off, int len) {
1638             return (len == 11 // &quot;MANIFEST.MF&quot;.length()
1639                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1640                     &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1641                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1642                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1643                     &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1644                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1645                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1646                     &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1647                     &amp;&amp; (name[off++]       ) == &#39;.&#39;
1648                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1649                     &amp;&amp; (name[off]   | 0x20) == &#39;f&#39;);
1650         }
1651 
1652         private static boolean isSignatureRelated(byte[] name, int off, int len) {
1653             // Only called when isMetaName(name, off, len) is true, which means
1654             // len is at least META_INF_LENGTH
1655             // assert isMetaName(name, off, len)
1656             boolean signatureRelated = false;
1657             if (name[off + len - 3] == &#39;.&#39;) {
1658                 // Check if entry ends with .EC and .SF
1659                 int b1 = name[off + len - 2] | 0x20;
1660                 int b2 = name[off + len - 1] | 0x20;
1661                 if ((b1 == &#39;e&#39; &amp;&amp; b2 == &#39;c&#39;) || (b1 == &#39;s&#39; &amp;&amp; b2 == &#39;f&#39;)) {
1662                     signatureRelated = true;
1663                 }
1664             } else if (name[off + len - 4] == &#39;.&#39;) {
1665                 // Check if entry ends with .DSA and .RSA
1666                 int b1 = name[off + len - 3] | 0x20;
1667                 int b2 = name[off + len - 2] | 0x20;
1668                 int b3 = name[off + len - 1] | 0x20;
1669                 if ((b1 == &#39;r&#39; || b1 == &#39;d&#39;) &amp;&amp; b2 == &#39;s&#39; &amp;&amp; b3 == &#39;a&#39;) {
1670                     signatureRelated = true;
1671                 }
1672             }
1673             // Above logic must match SignatureFileVerifier.isBlockOrSF
1674             assert(signatureRelated == SignatureFileVerifier
1675                 .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)
1676                     .toUpperCase(Locale.ENGLISH)));
1677             return signatureRelated;
1678         }
1679 
1680         /*
1681          * If the bytes represents a non-directory name beginning
1682          * with &quot;versions/&quot;, continuing with a positive integer,
1683          * followed by a &#39;/&#39;, then return that integer value.
1684          * Otherwise, return 0
1685          */
1686         private static int getMetaVersion(byte[] name, int off, int len) {
1687             int nend = off + len;
1688             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1689                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1690                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1691                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1692                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1693                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1694                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1695                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1696                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1697                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1698                     &amp;&amp; (name[off++]       ) == &#39;/&#39;)) {
1699                 return 0;
1700             }
1701             int version = 0;
1702             while (off &lt; nend) {
1703                 final byte c = name[off++];
1704                 if (c == &#39;/&#39;) {
1705                     return version;
1706                 }
1707                 if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
1708                     return 0;
1709                 }
1710                 version = version * 10 + c - &#39;0&#39;;
1711                 // Check for overflow and leading zeros
1712                 if (version &lt;= 0) {
1713                     return 0;
1714                 }
1715             }
1716             return 0;
1717         }
1718 
1719         /**
1720          * Returns the number of CEN headers in a central directory.
1721          * Will not throw, even if the zip file is corrupt.
1722          *
1723          * @param cen copy of the bytes in a zip file&#39;s central directory
1724          * @param size number of bytes in central directory
1725          */
1726         private static int countCENHeaders(byte[] cen, int size) {
1727             int count = 0;
1728             for (int p = 0;
1729                  p + CENHDR &lt;= size;
1730                  p += CENHDR + CENNAM(cen, p) + CENEXT(cen, p) + CENCOM(cen, p))
1731                 count++;
1732             return count;
1733         }
1734     }
1735 }
    </pre>
  </body>
</html>
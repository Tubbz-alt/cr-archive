<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/java/test/javafx/animation/AnimationTest.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,39 ***</span>
   * questions.
   */
  
  package javafx.animation;
  
<span class="line-modified">! import java.util.HashMap;</span>
  
  import com.sun.javafx.tk.Toolkit;
  import com.sun.javafx.util.Utils;
  
  import javafx.beans.property.BooleanProperty;
  import javafx.beans.property.DoubleProperty;
  import javafx.beans.property.DoublePropertyBase;
  import javafx.beans.property.IntegerProperty;
  import javafx.beans.property.IntegerPropertyBase;
  import javafx.beans.property.ObjectProperty;
  import javafx.beans.property.ObjectPropertyBase;
  import javafx.beans.property.ReadOnlyDoubleProperty;
  import javafx.beans.property.ReadOnlyDoublePropertyBase;
  import javafx.beans.property.ReadOnlyObjectProperty;
  import javafx.beans.property.ReadOnlyObjectPropertyBase;
<span class="line-removed">- import javafx.beans.property.SimpleBooleanProperty;</span>
<span class="line-removed">- import javafx.beans.property.SimpleObjectProperty;</span>
  import javafx.collections.FXCollections;
  import javafx.collections.ObservableMap;
  import javafx.event.ActionEvent;
  import javafx.event.EventHandler;
  import javafx.util.Duration;
  import com.sun.javafx.animation.TickCalculation;
  import com.sun.scenario.animation.AbstractMasterTimer;
  import com.sun.scenario.animation.shared.ClipEnvelope;
  import com.sun.scenario.animation.shared.PulseReceiver;
  
<span class="line-removed">- import static com.sun.javafx.animation.TickCalculation.*;</span>
  import java.security.AccessControlContext;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  
  /**
<span class="line-new-header">--- 23,37 ---</span>
   * questions.
   */
  
  package javafx.animation;
  
<span class="line-modified">! import java.util.Objects;</span>
  
  import com.sun.javafx.tk.Toolkit;
  import com.sun.javafx.util.Utils;
  
  import javafx.beans.property.BooleanProperty;
<span class="line-added">+ import javafx.beans.property.BooleanPropertyBase;</span>
  import javafx.beans.property.DoubleProperty;
  import javafx.beans.property.DoublePropertyBase;
  import javafx.beans.property.IntegerProperty;
  import javafx.beans.property.IntegerPropertyBase;
  import javafx.beans.property.ObjectProperty;
  import javafx.beans.property.ObjectPropertyBase;
  import javafx.beans.property.ReadOnlyDoubleProperty;
  import javafx.beans.property.ReadOnlyDoublePropertyBase;
  import javafx.beans.property.ReadOnlyObjectProperty;
  import javafx.beans.property.ReadOnlyObjectPropertyBase;
  import javafx.collections.FXCollections;
  import javafx.collections.ObservableMap;
  import javafx.event.ActionEvent;
  import javafx.event.EventHandler;
  import javafx.util.Duration;
  import com.sun.javafx.animation.TickCalculation;
  import com.sun.scenario.animation.AbstractMasterTimer;
  import com.sun.scenario.animation.shared.ClipEnvelope;
  import com.sun.scenario.animation.shared.PulseReceiver;
  
  import java.security.AccessControlContext;
  import java.security.AccessController;
  import java.security.PrivilegedAction;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,12 ***</span>
      static {
          AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
      }
  
      /**
<span class="line-modified">!      * Used to specify an animation that repeats indefinitely, until the</span>
<span class="line-modified">!      * {@code stop()} method is called.</span>
       */
      public static final int INDEFINITE = -1;
  
      /**
       * The possible states for {@link Animation#statusProperty() status}.
<span class="line-new-header">--- 94,12 ---</span>
      static {
          AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
      }
  
      /**
<span class="line-modified">!      * Used as a  value for {@link #cycleCountProperty() cycleCount} to specify an animation that repeats indefinitely,</span>
<span class="line-modified">!      * until the {@code stop()} method is called.</span>
       */
      public static final int INDEFINITE = -1;
  
      /**
       * The possible states for {@link Animation#statusProperty() status}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,10 ***</span>
<span class="line-new-header">--- 120,28 ---</span>
          STOPPED
      }
  
      private static final double EPSILON = 1e-12;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Checks if the rate is effectively 0.</span>
<span class="line-added">+      * @param rate</span>
<span class="line-added">+      * @return true i.f.f. abs(rate) &lt; EPSILON</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static final boolean isNearZero(double rate) {</span>
<span class="line-added">+         return Math.abs(rate) &lt; EPSILON;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Checks if 2 rates are effectively equal.</span>
<span class="line-added">+      * @param rateMagnitude</span>
<span class="line-added">+      * @return true i.f.f. Math.abs(rate1 - rate2) &lt; EPSILON</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static boolean areNearEqual(double rate1, double rate2) {</span>
<span class="line-added">+         return isNearZero(rate2 - rate1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /*
          These four fields and associated methods were moved here from AnimationPulseReceiver
          when that class was removed. They could probably be integrated much cleaner into Animation,
          but to make sure the change was made without introducing regressions, this code was
          moved pretty much verbatim.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
      private long startTime;
      private long pauseTime;
      private boolean paused = false;
      private final AbstractMasterTimer timer;
  
<span class="line-modified">!     // Access control context, captured whenever we add this pulse reciever to</span>
      // the master timer (which is called when an animation is played or resumed)
      private AccessControlContext accessCtrlCtx = null;
  
      private long now() {
          return TickCalculation.fromNano(timer.nanos());
<span class="line-new-header">--- 149,11 ---</span>
      private long startTime;
      private long pauseTime;
      private boolean paused = false;
      private final AbstractMasterTimer timer;
  
<span class="line-modified">!     // Access control context, captured whenever we add this pulse receiver to</span>
      // the master timer (which is called when an animation is played or resumed)
      private AccessControlContext accessCtrlCtx = null;
  
      private long now() {
          return TickCalculation.fromNano(timer.nanos());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
       *
       * @defaultValue null
       */
      Animation parent = null;
  
<span class="line-modified">!     /* Package-private for testing purposes */</span>
      ClipEnvelope clipEnvelope;
  
      private boolean lastPlayedFinished = true;
  
      private boolean lastPlayedForward = true;
<span class="line-new-header">--- 269,16 ---</span>
       *
       * @defaultValue null
       */
      Animation parent = null;
  
<span class="line-modified">!     /**</span>
<span class="line-added">+      * The type of ClipEnvelope for the animation is determined by its cycleCount and cycleDuration</span>
<span class="line-added">+      * and is updated when these values change.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * Package-private for testing purposes</span>
<span class="line-added">+     */</span>
      ClipEnvelope clipEnvelope;
  
      private boolean lastPlayedFinished = true;
  
      private boolean lastPlayedForward = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,11 ***</span>
       */
      private DoubleProperty rate;
      private static final double DEFAULT_RATE = 1.0;
  
      public final void setRate(double value) {
<span class="line-modified">!         if ((rate != null) || (Math.abs(value - DEFAULT_RATE) &gt; EPSILON)) {</span>
              rateProperty().set(value);
          }
      }
  
      public final double getRate() {
<span class="line-new-header">--- 304,11 ---</span>
       */
      private DoubleProperty rate;
      private static final double DEFAULT_RATE = 1.0;
  
      public final void setRate(double value) {
<span class="line-modified">!         if (rate != null || !areNearEqual(value, DEFAULT_RATE)) {</span>
              rateProperty().set(value);
          }
      }
  
      public final double getRate() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,33 ***</span>
                          if (isBound()) {
                              unbind();
                          }
                          set(oldRate);
                          throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);
                      } else {
<span class="line-modified">!                         if (Math.abs(newRate) &lt; EPSILON) {</span>
<span class="line-modified">!                             if (getStatus() == Status.RUNNING) {</span>
<span class="line-modified">!                                 lastPlayedForward = (Math.abs(getCurrentRate()</span>
<span class="line-modified">!                                         - oldRate) &lt; EPSILON);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             doSetCurrentRate(0.0);</span>
<span class="line-modified">!                             pauseReceiver();</span>
<span class="line-modified">!                         } else {</span>
<span class="line-removed">-                             if (getStatus() == Status.RUNNING) {</span>
<span class="line-removed">-                                 final double currentRate = getCurrentRate();</span>
<span class="line-removed">-                                 if (Math.abs(currentRate) &lt; EPSILON) {</span>
<span class="line-removed">-                                     doSetCurrentRate(lastPlayedForward ? newRate : -newRate);</span>
<span class="line-removed">-                                     resumeReceiver();</span>
<span class="line-removed">-                                 } else {</span>
<span class="line-removed">-                                     final boolean playingForward = Math.abs(currentRate - oldRate) &lt; EPSILON;</span>
<span class="line-removed">-                                     doSetCurrentRate(playingForward ? newRate : -newRate);</span>
<span class="line-removed">-                                 }</span>
                              }
<span class="line-removed">-                             oldRate = newRate;</span>
                          }
<span class="line-modified">!                         clipEnvelope.setRate(newRate);</span>
                      }
                  }
  
                  @Override
                  public Object getBean() {
                      return Animation.this;
<span class="line-new-header">--- 326,31 ---</span>
                          if (isBound()) {
                              unbind();
                          }
                          set(oldRate);
                          throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (isNearZero(newRate)) {</span>
<span class="line-added">+                         if (isRunning()) {</span>
<span class="line-added">+                             lastPlayedForward = areNearEqual(getCurrentRate(), oldRate);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         doSetCurrentRate(0.0);</span>
<span class="line-added">+                         pauseReceiver();</span>
                      } else {
<span class="line-modified">!                         if (isRunning()) {</span>
<span class="line-modified">!                             final double currentRate = getCurrentRate();</span>
<span class="line-modified">!                             if (isNearZero(currentRate)) {</span>
<span class="line-modified">!                                 doSetCurrentRate(lastPlayedForward ? newRate : -newRate);</span>
<span class="line-modified">!                                 resumeReceiver();</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 final boolean playingForward = areNearEqual(currentRate, oldRate);</span>
<span class="line-modified">!                                 doSetCurrentRate(playingForward ? newRate : -newRate);</span>
                              }
                          }
<span class="line-modified">!                         oldRate = newRate;</span>
                      }
<span class="line-added">+                     clipEnvelope.setRate(newRate);</span>
                  }
  
                  @Override
                  public Object getBean() {
                      return Animation.this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,11 ***</span>
  
      private boolean isRunningEmbedded() {
          if (parent == null) {
              return false;
          }
<span class="line-modified">!         return parent.getStatus() != Status.STOPPED || parent.isRunningEmbedded();</span>
      }
  
      private double oldRate = 1.0;
      /**
       * Read-only variable to indicate current direction/speed at which the
<span class="line-new-header">--- 367,11 ---</span>
  
      private boolean isRunningEmbedded() {
          if (parent == null) {
              return false;
          }
<span class="line-modified">!         return !parent.isStopped() || parent.isRunningEmbedded();</span>
      }
  
      private double oldRate = 1.0;
      /**
       * Read-only variable to indicate current direction/speed at which the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,27 ***</span>
       * @defaultValue 0.0
       */
      private ReadOnlyDoubleProperty currentRate;
      private static final double DEFAULT_CURRENT_RATE = 0.0;
  
<span class="line-removed">-     private void doSetCurrentRate(double value) {</span>
<span class="line-removed">-         if ((currentRate != null) || (Math.abs(value - DEFAULT_CURRENT_RATE) &gt; EPSILON)) {</span>
<span class="line-removed">-             ((CurrentRateProperty)currentRateProperty()).set(value);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      public final double getCurrentRate() {
<span class="line-modified">!         return (currentRate == null)? DEFAULT_CURRENT_RATE : currentRate.get();</span>
      }
  
      public final ReadOnlyDoubleProperty currentRateProperty() {
          if (currentRate == null) {
              currentRate = new CurrentRateProperty();
          }
          return currentRate;
      }
  
      /**
       * Read-only variable to indicate the duration of one cycle of this
       * {@code Animation}: the time it takes to play from time 0 to the
       * end of the Animation (at the default {@code rate} of
       * 1.0).
<span class="line-new-header">--- 385,47 ---</span>
       * @defaultValue 0.0
       */
      private ReadOnlyDoubleProperty currentRate;
      private static final double DEFAULT_CURRENT_RATE = 0.0;
  
      public final double getCurrentRate() {
<span class="line-modified">!         return (currentRate == null) ? DEFAULT_CURRENT_RATE : currentRate.get();</span>
      }
  
      public final ReadOnlyDoubleProperty currentRateProperty() {
          if (currentRate == null) {
              currentRate = new CurrentRateProperty();
          }
          return currentRate;
      }
  
<span class="line-added">+     void setCurrentRate(double currentRate) {</span>
<span class="line-added">+ //      if (getStatus() == Status.RUNNING) {</span>
<span class="line-added">+           doSetCurrentRate(currentRate);</span>
<span class="line-added">+ //      }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The current rate changes in 3 cases:</span>
<span class="line-added">+      * &lt;ol&gt;</span>
<span class="line-added">+      * &lt;li&gt; When the rate is changed.</span>
<span class="line-added">+      * &lt;li&gt; When the status is changed (paused/stopped/resumed/started).</span>
<span class="line-added">+      * &lt;li&gt; When switching between a forwards and backwards cycle.</span>
<span class="line-added">+      * &lt;/ol&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * 1 happens when the user changes the rate of the animation or its root parent.</span>
<span class="line-added">+      * 2 happens when the user changes the status or when the animation is finished.</span>
<span class="line-added">+      * 3 happens when the clip envelope flips the rate when the cycle is alternated, through the accessor</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param value the value of the new current rate</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private void doSetCurrentRate(double value) {</span>
<span class="line-added">+         if (currentRate != null || !areNearEqual(value, DEFAULT_CURRENT_RATE)) {</span>
<span class="line-added">+             ((CurrentRateProperty) currentRateProperty()).set(value);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Read-only variable to indicate the duration of one cycle of this
       * {@code Animation}: the time it takes to play from time 0 to the
       * end of the Animation (at the default {@code rate} of
       * 1.0).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 395,26 ***</span>
       */
      private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
      private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
  
      protected final void setCycleDuration(Duration value) {
<span class="line-modified">!         if ((cycleDuration != null) || (!DEFAULT_CYCLE_DURATION.equals(value))) {</span>
              if (value.lessThan(Duration.ZERO)) {
                  throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
              }
<span class="line-modified">!             ((AnimationReadOnlyProperty&lt;Duration&gt;)cycleDurationProperty()).set(value);</span>
              updateTotalDuration();
          }
      }
  
      public final Duration getCycleDuration() {
<span class="line-modified">!         return (cycleDuration == null)? DEFAULT_CYCLE_DURATION : cycleDuration.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
          if (cycleDuration == null) {
<span class="line-modified">!             cycleDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);</span>
          }
          return cycleDuration;
      }
  
      /**
<span class="line-new-header">--- 434,26 ---</span>
       */
      private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
      private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
  
      protected final void setCycleDuration(Duration value) {
<span class="line-modified">!         if (cycleDuration != null || !DEFAULT_CYCLE_DURATION.equals(value)) {</span>
              if (value.lessThan(Duration.ZERO)) {
                  throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
              }
<span class="line-modified">!             ((AnimationReadOnlyProperty&lt;Duration&gt;) cycleDurationProperty()).set(value);</span>
              updateTotalDuration();
          }
      }
  
      public final Duration getCycleDuration() {
<span class="line-modified">!         return (cycleDuration == null) ? DEFAULT_CYCLE_DURATION : cycleDuration.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
          if (cycleDuration == null) {
<span class="line-modified">!             cycleDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);</span>
          }
          return cycleDuration;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,36 ***</span>
       */
      private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
      private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
  
      public final Duration getTotalDuration() {
<span class="line-modified">!         return (totalDuration == null)? DEFAULT_TOTAL_DURATION : totalDuration.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
          if (totalDuration == null) {
<span class="line-modified">!             totalDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);</span>
          }
          return totalDuration;
      }
  
      private void updateTotalDuration() {
          // Implementing the bind eagerly, because cycleCount and
          // cycleDuration should not change that often
          final int cycleCount = getCycleCount();
          final Duration cycleDuration = getCycleDuration();
<span class="line-modified">!         final Duration newTotalDuration = Duration.ZERO.equals(cycleDuration) ? Duration.ZERO</span>
<span class="line-modified">!                 : (cycleCount == Animation.INDEFINITE) ? Duration.INDEFINITE</span>
<span class="line-modified">!                         : (cycleCount &lt;= 1) ? cycleDuration : cycleDuration</span>
<span class="line-modified">!                                 .multiply(cycleCount);</span>
<span class="line-modified">!         if ((totalDuration != null) || (!DEFAULT_TOTAL_DURATION.equals(newTotalDuration))) {</span>
<span class="line-modified">!             ((AnimationReadOnlyProperty&lt;Duration&gt;)totalDurationProperty()).set(newTotalDuration);</span>
          }
<span class="line-modified">!         if (getStatus() == Status.STOPPED) {</span>
              syncClipEnvelope();
              if (newTotalDuration.lessThan(getCurrentTime())) {
<span class="line-modified">!                 clipEnvelope.jumpTo(fromDuration(newTotalDuration));</span>
              }
          }
      }
  
      /**
<span class="line-new-header">--- 469,37 ---</span>
       */
      private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
      private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
  
      public final Duration getTotalDuration() {
<span class="line-modified">!         return (totalDuration == null) ? DEFAULT_TOTAL_DURATION : totalDuration.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
          if (totalDuration == null) {
<span class="line-modified">!             totalDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);</span>
          }
          return totalDuration;
      }
  
      private void updateTotalDuration() {
          // Implementing the bind eagerly, because cycleCount and
          // cycleDuration should not change that often
          final int cycleCount = getCycleCount();
          final Duration cycleDuration = getCycleDuration();
<span class="line-modified">!         final Duration newTotalDuration;</span>
<span class="line-modified">!         if (Duration.ZERO.equals(cycleDuration)) newTotalDuration = Duration.ZERO;</span>
<span class="line-modified">!         else if (cycleCount == INDEFINITE) newTotalDuration = Duration.INDEFINITE;</span>
<span class="line-modified">!         else if (cycleCount &lt;= 1) newTotalDuration = cycleDuration;</span>
<span class="line-modified">!         else newTotalDuration = cycleDuration.multiply(cycleCount);</span>
<span class="line-modified">!         if (totalDuration != null || !DEFAULT_TOTAL_DURATION.equals(newTotalDuration)) {</span>
<span class="line-added">+             ((AnimationReadOnlyProperty&lt;Duration&gt;) totalDurationProperty()).set(newTotalDuration);</span>
          }
<span class="line-modified">!         if (isStopped()) {</span>
              syncClipEnvelope();
              if (newTotalDuration.lessThan(getCurrentTime())) {
<span class="line-modified">!                 clipEnvelope.jumpTo(TickCalculation.fromDuration(newTotalDuration));</span>
              }
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,45 ***</span>
       */
      private ObjectProperty&lt;Duration&gt; delay;
      private static final Duration DEFAULT_DELAY = Duration.ZERO;
  
      public final void setDelay(Duration value) {
<span class="line-modified">!         if ((delay != null) || (!DEFAULT_DELAY.equals(value))) {</span>
              delayProperty().set(value);
          }
      }
  
      public final Duration getDelay() {
<span class="line-modified">!         return (delay == null)? DEFAULT_DELAY : delay.get();</span>
      }
  
      public final ObjectProperty&lt;Duration&gt; delayProperty() {
          if (delay == null) {
<span class="line-modified">!             delay = new ObjectPropertyBase&lt;Duration&gt;(DEFAULT_DELAY) {</span>
  
                  @Override
                  public Object getBean() {
                      return Animation.this;
                  }
  
                  @Override
                  public String getName() {
                      return &quot;delay&quot;;
                  }
<span class="line-removed">- </span>
<span class="line-removed">-                 @Override</span>
<span class="line-removed">-                 protected void invalidated() {</span>
<span class="line-removed">-                         final Duration newDuration = get();</span>
<span class="line-removed">-                         if (newDuration.lessThan(Duration.ZERO)) {</span>
<span class="line-removed">-                             if (isBound()) {</span>
<span class="line-removed">-                                 unbind();</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             set(Duration.ZERO);</span>
<span class="line-removed">-                             throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
              };
          }
          return delay;
      }
  
<span class="line-new-header">--- 553,44 ---</span>
       */
      private ObjectProperty&lt;Duration&gt; delay;
      private static final Duration DEFAULT_DELAY = Duration.ZERO;
  
      public final void setDelay(Duration value) {
<span class="line-modified">!         if (delay != null || !DEFAULT_DELAY.equals(value)) {</span>
              delayProperty().set(value);
          }
      }
  
      public final Duration getDelay() {
<span class="line-modified">!         return (delay == null) ? DEFAULT_DELAY : delay.get();</span>
      }
  
      public final ObjectProperty&lt;Duration&gt; delayProperty() {
          if (delay == null) {
<span class="line-modified">!             delay = new ObjectPropertyBase&lt;&gt;(DEFAULT_DELAY) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 protected void invalidated() {</span>
<span class="line-added">+                     final Duration newDuration = get();</span>
<span class="line-added">+                     if (newDuration.lessThan(Duration.ZERO)) {</span>
<span class="line-added">+                         if (isBound()) {</span>
<span class="line-added">+                             unbind();</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         set(Duration.ZERO);</span>
<span class="line-added">+                         throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
  
                  @Override
                  public Object getBean() {
                      return Animation.this;
                  }
  
                  @Override
                  public String getName() {
                      return &quot;delay&quot;;
                  }
              };
          }
          return delay;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 569,17 ***</span>
       */
      private IntegerProperty cycleCount;
      private static final int DEFAULT_CYCLE_COUNT = 1;
  
      public final void setCycleCount(int value) {
<span class="line-modified">!         if ((cycleCount != null) || (value != DEFAULT_CYCLE_COUNT)) {</span>
              cycleCountProperty().set(value);
          }
      }
  
      public final int getCycleCount() {
<span class="line-modified">!         return (cycleCount == null)? DEFAULT_CYCLE_COUNT : cycleCount.get();</span>
      }
  
      public final IntegerProperty cycleCountProperty() {
          if (cycleCount == null) {
              cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
<span class="line-new-header">--- 608,17 ---</span>
       */
      private IntegerProperty cycleCount;
      private static final int DEFAULT_CYCLE_COUNT = 1;
  
      public final void setCycleCount(int value) {
<span class="line-modified">!         if (cycleCount != null || value != DEFAULT_CYCLE_COUNT) {</span>
              cycleCountProperty().set(value);
          }
      }
  
      public final int getCycleCount() {
<span class="line-modified">!         return (cycleCount == null) ? DEFAULT_CYCLE_COUNT : cycleCount.get();</span>
      }
  
      public final IntegerProperty cycleCountProperty() {
          if (cycleCount == null) {
              cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 620,22 ***</span>
       */
      private BooleanProperty autoReverse;
      private static final boolean DEFAULT_AUTO_REVERSE = false;
  
      public final void setAutoReverse(boolean value) {
<span class="line-modified">!         if ((autoReverse != null) || (value != DEFAULT_AUTO_REVERSE)) {</span>
              autoReverseProperty().set(value);
          }
      }
  
      public final boolean isAutoReverse() {
<span class="line-modified">!         return (autoReverse == null)? DEFAULT_AUTO_REVERSE : autoReverse.get();</span>
      }
  
      public final BooleanProperty autoReverseProperty() {
          if (autoReverse == null) {
<span class="line-modified">!             autoReverse = new SimpleBooleanProperty(this, &quot;autoReverse&quot;, DEFAULT_AUTO_REVERSE);</span>
          }
          return autoReverse;
      }
  
      /**
<span class="line-new-header">--- 659,33 ---</span>
       */
      private BooleanProperty autoReverse;
      private static final boolean DEFAULT_AUTO_REVERSE = false;
  
      public final void setAutoReverse(boolean value) {
<span class="line-modified">!         if (autoReverse != null || value != DEFAULT_AUTO_REVERSE) {</span>
              autoReverseProperty().set(value);
          }
      }
  
      public final boolean isAutoReverse() {
<span class="line-modified">!         return (autoReverse == null) ? DEFAULT_AUTO_REVERSE : autoReverse.get();</span>
      }
  
      public final BooleanProperty autoReverseProperty() {
          if (autoReverse == null) {
<span class="line-modified">!             autoReverse = new BooleanPropertyBase(DEFAULT_AUTO_REVERSE) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public Object getBean() {</span>
<span class="line-added">+                     return Animation.this;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public String getName() {</span>
<span class="line-added">+                     return &quot;autoReverse&quot;;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
          }
          return autoReverse;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,41 ***</span>
       */
      private ReadOnlyObjectProperty&lt;Status&gt; status;
      private static final Status DEFAULT_STATUS = Status.STOPPED;
  
      protected final void setStatus(Status value) {
<span class="line-modified">!         if ((status != null) || (!DEFAULT_STATUS.equals(value))) {</span>
<span class="line-modified">!             ((AnimationReadOnlyProperty&lt;Status&gt;)statusProperty()).set(value);</span>
          }
      }
  
      public final Status getStatus() {
<span class="line-modified">!         return (status == null)? DEFAULT_STATUS : status.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
          if (status == null) {
<span class="line-modified">!             status = new AnimationReadOnlyProperty&lt;Status&gt;(&quot;status&quot;, Status.STOPPED);</span>
          }
          return status;
      }
  
<span class="line-modified">!     private final double targetFramerate;</span>
<span class="line-modified">!     private final int resolution;</span>
<span class="line-modified">!     private long lastPulse;</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * The target framerate is the maximum framerate at which this {@code Animation}</span>
<span class="line-modified">!      * will run, in frames per second. This can be used, for example, to keep</span>
<span class="line-modified">!      * particularly complex {@code Animations} from over-consuming system resources.</span>
<span class="line-modified">!      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning</span>
<span class="line-modified">!      * the {@code Animation} will run at an optimal framerate for the underlying platform.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return the target framerate</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public final double getTargetFramerate() {</span>
<span class="line-removed">-         return targetFramerate;</span>
      }
  
      /**
       * The action to be executed at the conclusion of this {@code Animation}.
       *
<span class="line-new-header">--- 696,36 ---</span>
       */
      private ReadOnlyObjectProperty&lt;Status&gt; status;
      private static final Status DEFAULT_STATUS = Status.STOPPED;
  
      protected final void setStatus(Status value) {
<span class="line-modified">!         if (status != null || !DEFAULT_STATUS.equals(value)) {</span>
<span class="line-modified">!             ((AnimationReadOnlyProperty&lt;Status&gt;) statusProperty()).set(value);</span>
          }
      }
  
      public final Status getStatus() {
<span class="line-modified">!         return (status == null) ? DEFAULT_STATUS : status.get();</span>
      }
  
      public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
          if (status == null) {
<span class="line-modified">!             status = new AnimationReadOnlyProperty&lt;&gt;(&quot;status&quot;, Status.STOPPED);</span>
          }
          return status;
      }
  
<span class="line-modified">!     boolean isStopped() {</span>
<span class="line-modified">!         return getStatus() == Status.STOPPED;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     boolean isPaused() {</span>
<span class="line-modified">!         return getStatus() == Status.PAUSED;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     boolean isRunning() {</span>
<span class="line-modified">!         return getStatus() == Status.RUNNING;</span>
      }
  
      /**
       * The action to be executed at the conclusion of this {@code Animation}.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 688,28 ***</span>
       */
      private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
      private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
  
      public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
<span class="line-modified">!         if ((onFinished != null) || (value != null /* DEFAULT_ON_FINISHED */)) {</span>
              onFinishedProperty().set(value);
          }
      }
  
      public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
<span class="line-modified">!         return (onFinished == null)? DEFAULT_ON_FINISHED : onFinished.get();</span>
      }
  
      public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
          if (onFinished == null) {
<span class="line-modified">!             onFinished = new SimpleObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt;(this, &quot;onFinished&quot;, DEFAULT_ON_FINISHED);</span>
          }
          return onFinished;
      }
  
<span class="line-modified">!     private final ObservableMap&lt;String, Duration&gt; cuePoints = FXCollections</span>
<span class="line-removed">-             .observableMap(new HashMap&lt;String, Duration&gt;(0));</span>
  
      /**
       * The cue points can be
       * used to mark important positions of the {@code Animation}. Once a cue
       * point was defined, it can be used as an argument of
<span class="line-new-header">--- 733,38 ---</span>
       */
      private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
      private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
  
      public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
<span class="line-modified">!         if (onFinished != null || value != DEFAULT_ON_FINISHED) {</span>
              onFinishedProperty().set(value);
          }
      }
  
      public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
<span class="line-modified">!         return (onFinished == null) ? DEFAULT_ON_FINISHED : onFinished.get();</span>
      }
  
      public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
          if (onFinished == null) {
<span class="line-modified">!             onFinished = new ObjectPropertyBase&lt;&gt;(DEFAULT_ON_FINISHED) {</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public Object getBean() {</span>
<span class="line-added">+                     return Animation.this;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public String getName() {</span>
<span class="line-added">+                     return &quot;onFinished&quot;;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             };</span>
          }
          return onFinished;
      }
  
<span class="line-modified">!     private ObservableMap&lt;String, Duration&gt; cuePoints;</span>
  
      /**
       * The cue points can be
       * used to mark important positions of the {@code Animation}. Once a cue
       * point was defined, it can be used as an argument of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,10 ***</span>
<span class="line-new-header">--- 780,13 ---</span>
       * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
       *
       * @return {@link javafx.collections.ObservableMap} of cue points
       */
      public final ObservableMap&lt;String, Duration&gt; getCuePoints() {
<span class="line-added">+         if (cuePoints == null) {</span>
<span class="line-added">+             cuePoints = FXCollections.observableHashMap();</span>
<span class="line-added">+         }</span>
          return cuePoints;
      }
  
      /**
       * Jumps to a given position in this {@code Animation}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 746,13 ***</span>
       * @throws IllegalStateException
       *             if embedded in another animation,
       *                such as {@link SequentialTransition} or {@link ParallelTransition}
       */
      public void jumpTo(Duration time) {
<span class="line-modified">!         if (time == null) {</span>
<span class="line-removed">-             throw new NullPointerException(&quot;Time needs to be specified.&quot;);</span>
<span class="line-removed">-         }</span>
          if (time.isUnknown()) {
              throw new IllegalArgumentException(&quot;The time is invalid&quot;);
          }
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
<span class="line-new-header">--- 804,11 ---</span>
       * @throws IllegalStateException
       *             if embedded in another animation,
       *                such as {@link SequentialTransition} or {@link ParallelTransition}
       */
      public void jumpTo(Duration time) {
<span class="line-modified">!         Objects.requireNonNull(time, &quot;Time needs to be specified&quot;);</span>
          if (time.isUnknown()) {
              throw new IllegalArgumentException(&quot;The time is invalid&quot;);
          }
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,11 ***</span>
  
          double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
              Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
          long ticks = TickCalculation.fromMillis(millis);
  
<span class="line-modified">!         if (getStatus() == Status.STOPPED) {</span>
              syncClipEnvelope();
          }
          clipEnvelope.jumpTo(ticks);
      }
  
<span class="line-new-header">--- 818,11 ---</span>
  
          double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
              Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
          long ticks = TickCalculation.fromMillis(millis);
  
<span class="line-modified">!         if (isStopped()) {</span>
              syncClipEnvelope();
          }
          clipEnvelope.jumpTo(ticks);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 794,13 ***</span>
       *             if embedded in another animation,
       *                such as {@link SequentialTransition} or {@link ParallelTransition}
       * @see #getCuePoints()
       */
      public void jumpTo(String cuePoint) {
<span class="line-modified">!         if (cuePoint == null) {</span>
<span class="line-removed">-             throw new NullPointerException(&quot;CuePoint needs to be specified&quot;);</span>
<span class="line-removed">-         }</span>
          if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
              jumpTo(Duration.ZERO);
          } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
              jumpTo(getTotalDuration());
          } else {
<span class="line-new-header">--- 850,11 ---</span>
       *             if embedded in another animation,
       *                such as {@link SequentialTransition} or {@link ParallelTransition}
       * @see #getCuePoints()
       */
      public void jumpTo(String cuePoint) {
<span class="line-modified">!         Objects.requireNonNull(cuePoint, &quot;CuePoint needs to be specified&quot;);</span>
          if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
              jumpTo(Duration.ZERO);
          } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
              jumpTo(getTotalDuration());
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 867,10 ***</span>
<span class="line-new-header">--- 921,38 ---</span>
      public void playFrom(Duration time) {
          jumpTo(time);
          play();
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Plays an {@code Animation} from initial position in forward direction.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * It is equivalent to</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * &lt;code&gt;</span>
<span class="line-added">+      *      animation.stop();&lt;br&gt;</span>
<span class="line-added">+      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;</span>
<span class="line-added">+      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;</span>
<span class="line-added">+      *      animation.play();&lt;br&gt;</span>
<span class="line-added">+      *  &lt;/code&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * Note: &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may</span>
<span class="line-added">+      * not start immediately. &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @throws IllegalStateException</span>
<span class="line-added">+      *             if embedded in another animation,</span>
<span class="line-added">+      *                such as {@link SequentialTransition} or {@link ParallelTransition}</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void playFromStart() {</span>
<span class="line-added">+         stop();</span>
<span class="line-added">+         setRate(Math.abs(getRate()));</span>
<span class="line-added">+         jumpTo(Duration.ZERO);</span>
<span class="line-added">+         play();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Plays {@code Animation} from current position in the direction indicated
       * by {@code rate}. If the {@code Animation} is running, it has no effect.
       * &lt;p&gt;
       * When {@code rate} {@literal &gt;} 0 (forward play), if an {@code Animation} is already
</pre>
<hr />
<pre>
<span class="line-old-header">*** 905,61 ***</span>
          switch (getStatus()) {
              case STOPPED:
                  if (startable(true)) {
                      final double rate = getRate();
                      if (lastPlayedFinished) {
<span class="line-modified">!                         jumpTo((rate &lt; 0)? getTotalDuration() : Duration.ZERO);</span>
                      }
                      doStart(true);
                      startReceiver(TickCalculation.fromDuration(getDelay()));
<span class="line-modified">!                     if (Math.abs(rate) &lt; EPSILON) {</span>
                          pauseReceiver();
                      } else {
  
                      }
                  } else {
<span class="line-modified">!                     final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();</span>
<span class="line-removed">-                     if (handler != null) {</span>
<span class="line-removed">-                         handler.handle(new ActionEvent(this, null));</span>
<span class="line-removed">-                     }</span>
                  }
                  break;
              case PAUSED:
                  doResume();
<span class="line-modified">!                 if (Math.abs(getRate()) &gt;= EPSILON) {</span>
                      resumeReceiver();
                  }
                  break;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Plays an {@code Animation} from initial position in forward direction.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-modified">!      * It is equivalent to</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-modified">!      * &lt;code&gt;</span>
<span class="line-modified">!      *      animation.stop();&lt;br&gt;</span>
<span class="line-modified">!      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;</span>
<span class="line-modified">!      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;</span>
<span class="line-modified">!      *      animation.play();&lt;br&gt;</span>
<span class="line-modified">!      *  &lt;/code&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;</span>
<span class="line-removed">-      * Note: &lt;ul&gt;</span>
<span class="line-removed">-      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may</span>
<span class="line-removed">-      * not start immediately. &lt;/ul&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @throws IllegalStateException</span>
<span class="line-removed">-      *             if embedded in another animation,</span>
<span class="line-removed">-      *                such as {@link SequentialTransition} or {@link ParallelTransition}</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public void playFromStart() {</span>
<span class="line-removed">-         stop();</span>
<span class="line-removed">-         setRate(Math.abs(getRate()));</span>
<span class="line-removed">-         jumpTo(Duration.ZERO);</span>
<span class="line-removed">-         play();</span>
      }
  
      /**
       * Stops the animation and resets the play head to its initial position. If
       * the animation is already stopped, this method has no effect.
<span class="line-new-header">--- 987,44 ---</span>
          switch (getStatus()) {
              case STOPPED:
                  if (startable(true)) {
                      final double rate = getRate();
                      if (lastPlayedFinished) {
<span class="line-modified">!                         jumpTo(rate &lt; 0 ? getTotalDuration() : Duration.ZERO);</span>
                      }
                      doStart(true);
                      startReceiver(TickCalculation.fromDuration(getDelay()));
<span class="line-modified">!                     if (isNearZero(rate)) {</span>
                          pauseReceiver();
                      } else {
  
                      }
                  } else {
<span class="line-modified">!                     runHandler(getOnFinished());</span>
                  }
                  break;
              case PAUSED:
                  doResume();
<span class="line-modified">!                 if (!isNearZero(getRate())) {</span>
                      resumeReceiver();
                  }
                  break;
<span class="line-added">+             case RUNNING: // no-op</span>
          }
      }
  
<span class="line-modified">!     void doStart(boolean forceSync) {</span>
<span class="line-modified">!         sync(forceSync);</span>
<span class="line-modified">!         setStatus(Status.RUNNING);</span>
<span class="line-modified">!         clipEnvelope.start();</span>
<span class="line-modified">!         doSetCurrentRate(clipEnvelope.getCurrentRate());</span>
<span class="line-modified">!         lastPulse = 0;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     void doResume() {</span>
<span class="line-modified">!         setStatus(Status.RUNNING);</span>
<span class="line-modified">!         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());</span>
      }
  
      /**
       * Stops the animation and resets the play head to its initial position. If
       * the animation is already stopped, this method has no effect.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,18 ***</span>
       */
      public void stop() {
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
          }
<span class="line-modified">!         if (getStatus() != Status.STOPPED) {</span>
              clipEnvelope.abortCurrentPulse();
              doStop();
              jumpTo(Duration.ZERO);
              lastPlayedFinished = true;
          }
      }
  
      /**
       * Pauses the animation. If the animation is not currently running, this
       * method has no effect.
       * &lt;p&gt;
       * Note: &lt;ul&gt;
<span class="line-new-header">--- 1038,26 ---</span>
       */
      public void stop() {
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
          }
<span class="line-modified">!         if (!isStopped()) {</span>
              clipEnvelope.abortCurrentPulse();
              doStop();
              jumpTo(Duration.ZERO);
              lastPlayedFinished = true;
          }
      }
  
<span class="line-added">+     void doStop() {</span>
<span class="line-added">+         if (!paused) {</span>
<span class="line-added">+             timer.removePulseReceiver(pulseReceiver);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         setStatus(Status.STOPPED);</span>
<span class="line-added">+         doSetCurrentRate(0.0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Pauses the animation. If the animation is not currently running, this
       * method has no effect.
       * &lt;p&gt;
       * Note: &lt;ul&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,17 ***</span>
       */
      public void pause() {
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
          }
<span class="line-modified">!         if (getStatus() == Status.RUNNING) {</span>
              clipEnvelope.abortCurrentPulse();
              pauseReceiver();
              doPause();
          }
      }
  
      /**
       * The constructor of {@code Animation}.
       *
       * This constructor allows to define a target framerate.
       *
<span class="line-new-header">--- 1069,59 ---</span>
       */
      public void pause() {
          if (parent != null) {
              throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
          }
<span class="line-modified">!         if (isRunning()) {</span>
              clipEnvelope.abortCurrentPulse();
              pauseReceiver();
              doPause();
          }
      }
  
<span class="line-added">+     void doPause() {</span>
<span class="line-added">+         final double currentRate = getCurrentRate();</span>
<span class="line-added">+         if (!isNearZero(currentRate)) {</span>
<span class="line-added">+             lastPlayedForward = areNearEqual(getCurrentRate(), getRate());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         doSetCurrentRate(0.0);</span>
<span class="line-added">+         setStatus(Status.PAUSED);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     final void finished() {</span>
<span class="line-added">+         lastPlayedFinished = true;</span>
<span class="line-added">+         doStop();</span>
<span class="line-added">+         runHandler(getOnFinished());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void runHandler(EventHandler&lt;ActionEvent&gt; handler) {</span>
<span class="line-added">+         if (handler != null) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 handler.handle(new ActionEvent(this, null));</span>
<span class="line-added">+             } catch (Exception ex) {</span>
<span class="line-added">+                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final double targetFramerate;</span>
<span class="line-added">+     private final int resolution;</span>
<span class="line-added">+     private long lastPulse;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * The target framerate is the maximum framerate at which this {@code Animation}</span>
<span class="line-added">+      * will run, in frames per second. This can be used, for example, to keep</span>
<span class="line-added">+      * particularly complex {@code Animations} from over-consuming system resources.</span>
<span class="line-added">+      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning</span>
<span class="line-added">+      * the {@code Animation} will run at an optimal framerate for the underlying platform.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return the target framerate</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public final double getTargetFramerate() {</span>
<span class="line-added">+         return targetFramerate;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * The constructor of {@code Animation}.
       *
       * This constructor allows to define a target framerate.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1046,12 ***</span>
          this.clipEnvelope = clipEnvelope;
          this.timer = timer;
      }
  
      boolean startable(boolean forceSync) {
<span class="line-modified">!         return (fromDuration(getCycleDuration()) &gt; 0L)</span>
<span class="line-removed">-                 || (!forceSync &amp;&amp; clipEnvelope.wasSynched());</span>
      }
  
      void sync(boolean forceSync) {
          if (forceSync || !clipEnvelope.wasSynched()) {
              syncClipEnvelope();
<span class="line-new-header">--- 1161,11 ---</span>
          this.clipEnvelope = clipEnvelope;
          this.timer = timer;
      }
  
      boolean startable(boolean forceSync) {
<span class="line-modified">!         return (TickCalculation.fromDuration(getCycleDuration()) &gt; 0L) || (!forceSync &amp;&amp; clipEnvelope.wasSynched());</span>
      }
  
      void sync(boolean forceSync) {
          if (forceSync || !clipEnvelope.wasSynched()) {
              syncClipEnvelope();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,40 ***</span>
          clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
          clipEnvelope.setCycleDuration(getCycleDuration());
          clipEnvelope.setAutoReverse(isAutoReverse());
      }
  
<span class="line-removed">-     void doStart(boolean forceSync) {</span>
<span class="line-removed">-         sync(forceSync);</span>
<span class="line-removed">-         setStatus(Status.RUNNING);</span>
<span class="line-removed">-         clipEnvelope.start();</span>
<span class="line-removed">-         doSetCurrentRate(clipEnvelope.getCurrentRate());</span>
<span class="line-removed">-         lastPulse = 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void doPause() {</span>
<span class="line-removed">-         final double currentRate = getCurrentRate();</span>
<span class="line-removed">-         if (Math.abs(currentRate) &gt;= EPSILON) {</span>
<span class="line-removed">-             lastPlayedForward = Math.abs(getCurrentRate() - getRate()) &lt; EPSILON;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         doSetCurrentRate(0.0);</span>
<span class="line-removed">-         setStatus(Status.PAUSED);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void doResume() {</span>
<span class="line-removed">-         setStatus(Status.RUNNING);</span>
<span class="line-removed">-         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void doStop() {</span>
<span class="line-removed">-         if (!paused) {</span>
<span class="line-removed">-             timer.removePulseReceiver(pulseReceiver);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         setStatus(Status.STOPPED);</span>
<span class="line-removed">-         doSetCurrentRate(0.0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void doTimePulse(long elapsedTime) {
          if (resolution == 1) { // fullspeed
              clipEnvelope.timePulse(elapsedTime);
          } else if (elapsedTime - lastPulse &gt;= resolution) {
              lastPulse = (elapsedTime / resolution) * resolution;
<span class="line-new-header">--- 1179,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1114,25 ***</span>
          currentTicks = ticks;
          if (currentTime != null) {
              currentTime.fireValueChangedEvent();
          }
      }
<span class="line-removed">- </span>
<span class="line-removed">-     void setCurrentRate(double currentRate) {</span>
<span class="line-removed">- //        if (getStatus() == Status.RUNNING) {</span>
<span class="line-removed">-             doSetCurrentRate(currentRate);</span>
<span class="line-removed">- //        }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     final void finished() {</span>
<span class="line-removed">-         lastPlayedFinished = true;</span>
<span class="line-removed">-         doStop();</span>
<span class="line-removed">-         final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();</span>
<span class="line-removed">-         if (handler != null) {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 handler.handle(new ActionEvent(this, null));</span>
<span class="line-removed">-             } catch (Exception ex) {</span>
<span class="line-removed">-                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
<span class="line-new-header">--- 1198,6 ---</span>
</pre>
<center><a href="../../com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/java/test/javafx/animation/AnimationTest.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
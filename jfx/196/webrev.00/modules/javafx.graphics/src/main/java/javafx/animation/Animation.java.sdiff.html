<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/java/test/javafx/animation/AnimationTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.animation;
  27 
<span class="line-modified">  28 import java.util.HashMap;</span>
  29 
  30 import com.sun.javafx.tk.Toolkit;
  31 import com.sun.javafx.util.Utils;
  32 
  33 import javafx.beans.property.BooleanProperty;

  34 import javafx.beans.property.DoubleProperty;
  35 import javafx.beans.property.DoublePropertyBase;
  36 import javafx.beans.property.IntegerProperty;
  37 import javafx.beans.property.IntegerPropertyBase;
  38 import javafx.beans.property.ObjectProperty;
  39 import javafx.beans.property.ObjectPropertyBase;
  40 import javafx.beans.property.ReadOnlyDoubleProperty;
  41 import javafx.beans.property.ReadOnlyDoublePropertyBase;
  42 import javafx.beans.property.ReadOnlyObjectProperty;
  43 import javafx.beans.property.ReadOnlyObjectPropertyBase;
<span class="line-removed">  44 import javafx.beans.property.SimpleBooleanProperty;</span>
<span class="line-removed">  45 import javafx.beans.property.SimpleObjectProperty;</span>
  46 import javafx.collections.FXCollections;
  47 import javafx.collections.ObservableMap;
  48 import javafx.event.ActionEvent;
  49 import javafx.event.EventHandler;
  50 import javafx.util.Duration;
  51 import com.sun.javafx.animation.TickCalculation;
  52 import com.sun.scenario.animation.AbstractMasterTimer;
  53 import com.sun.scenario.animation.shared.ClipEnvelope;
  54 import com.sun.scenario.animation.shared.PulseReceiver;
  55 
<span class="line-removed">  56 import static com.sun.javafx.animation.TickCalculation.*;</span>
  57 import java.security.AccessControlContext;
  58 import java.security.AccessController;
  59 import java.security.PrivilegedAction;
  60 
  61 /**
  62  * The class {@code Animation} provides the core functionality of all animations
  63  * used in the JavaFX runtime.
  64  * &lt;p&gt;
  65  * An animation can run in a loop by setting {@link #cycleCountProperty() cycleCount}.
  66  * To make an animation run back and forth while looping, set the
  67  * {@link #autoReverseProperty() autoReverse} -flag.
  68  * &lt;p&gt;
  69  * Call {@link #play()} or {@link #playFromStart()} to play an {@code Animation}
  70  * . The {@code Animation} progresses in the direction and speed specified by
  71  * {@link #rateProperty() rate}, and stops when its duration is elapsed. An {@code Animation}
  72  * with indefinite duration (a {@link #cycleCountProperty() cycleCount} of {@link #INDEFINITE}) runs
  73  * repeatedly until the {@link #stop()} method is explicitly called, which will
  74  * stop the running {@code Animation} and reset its play head to the initial
  75  * position.
  76  * &lt;p&gt;
</pre>
<hr />
<pre>
  81  * An {@code Animation}&#39;s play head can be randomly positioned, whether it is
  82  * running or not. If the {@code Animation} is running, the play head jumps to
  83  * the specified position immediately and continues playing from new position.
  84  * If the {@code Animation} is not running, the next {@link #play()} will start
  85  * the {@code Animation} from the specified position.
  86  * &lt;p&gt;
  87  * Inverting the value of {@link #rateProperty() rate} toggles the play direction.
  88  *
  89  * @see Timeline
  90  * @see Transition
  91  *
  92  * @since JavaFX 2.0
  93  */
  94 public abstract class Animation {
  95 
  96     static {
  97         AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
  98     }
  99 
 100     /**
<span class="line-modified"> 101      * Used to specify an animation that repeats indefinitely, until the</span>
<span class="line-modified"> 102      * {@code stop()} method is called.</span>
 103      */
 104     public static final int INDEFINITE = -1;
 105 
 106     /**
 107      * The possible states for {@link Animation#statusProperty() status}.
 108      * @since JavaFX 2.0
 109      */
 110     public static enum Status {
 111         /**
 112          * The paused state.
 113          */
 114         PAUSED,
 115         /**
 116          * The running state.
 117          */
 118         RUNNING,
 119         /**
 120          * The stopped state.
 121          */
 122         STOPPED
 123     }
 124 
 125     private static final double EPSILON = 1e-12;
 126 


















 127     /*
 128         These four fields and associated methods were moved here from AnimationPulseReceiver
 129         when that class was removed. They could probably be integrated much cleaner into Animation,
 130         but to make sure the change was made without introducing regressions, this code was
 131         moved pretty much verbatim.
 132      */
 133     private long startTime;
 134     private long pauseTime;
 135     private boolean paused = false;
 136     private final AbstractMasterTimer timer;
 137 
<span class="line-modified"> 138     // Access control context, captured whenever we add this pulse reciever to</span>
 139     // the master timer (which is called when an animation is played or resumed)
 140     private AccessControlContext accessCtrlCtx = null;
 141 
 142     private long now() {
 143         return TickCalculation.fromNano(timer.nanos());
 144     }
 145 
 146     private void addPulseReceiver() {
 147         // Capture the Access Control Context to be used during the animation pulse
 148         accessCtrlCtx = AccessController.getContext();
 149 
 150         timer.addPulseReceiver(pulseReceiver);
 151     }
 152 
 153     void startReceiver(long delay) {
 154         paused = false;
 155         startTime = now() + delay;
 156         addPulseReceiver();
 157     }
 158 
</pre>
<hr />
<pre>
 238         @Override
 239         public T get() {
 240             return value;
 241         }
 242 
 243         private void set(T value) {
 244             this.value = value;
 245             fireValueChangedEvent();
 246         }
 247     }
 248 
 249     /**
 250      * The parent of this {@code Animation}. If this animation has not been
 251      * added to another animation, such as {@link ParallelTransition} and
 252      * {@link SequentialTransition}, then parent will be null.
 253      *
 254      * @defaultValue null
 255      */
 256     Animation parent = null;
 257 
<span class="line-modified"> 258     /* Package-private for testing purposes */</span>





 259     ClipEnvelope clipEnvelope;
 260 
 261     private boolean lastPlayedFinished = true;
 262 
 263     private boolean lastPlayedForward = true;
 264     /**
 265      * Defines the direction/speed at which the {@code Animation} is expected to
 266      * be played.
 267      * &lt;p&gt;
 268      * The absolute value of {@code rate} indicates the speed at which the
 269      * {@code Animation} is to be played, while the sign of {@code rate}
 270      * indicates the direction. A positive value of {@code rate} indicates
 271      * forward play, a negative value indicates backward play and {@code 0.0} to
 272      * stop a running {@code Animation}.
 273      * &lt;p&gt;
 274      * Rate {@code 1.0} is normal play, {@code 2.0} is 2 time normal,
 275      * {@code -1.0} is backwards, etc.
 276      *
 277      * &lt;p&gt;
 278      * Inverting the rate of a running {@code Animation} will cause the
 279      * {@code Animation} to reverse direction in place and play back over the
 280      * portion of the {@code Animation} that has already elapsed.
 281      *
 282      * @defaultValue 1.0
 283      */
 284     private DoubleProperty rate;
 285     private static final double DEFAULT_RATE = 1.0;
 286 
 287     public final void setRate(double value) {
<span class="line-modified"> 288         if ((rate != null) || (Math.abs(value - DEFAULT_RATE) &gt; EPSILON)) {</span>
 289             rateProperty().set(value);
 290         }
 291     }
 292 
 293     public final double getRate() {
 294         return (rate == null)? DEFAULT_RATE : rate.get();
 295     }
 296 
 297     public final DoubleProperty rateProperty() {
 298         if (rate == null) {
 299             rate = new DoublePropertyBase(DEFAULT_RATE) {
 300 
 301                 @Override
 302                 public void invalidated() {
 303                     final double newRate = getRate();
 304                     if (isRunningEmbedded()) {
 305                         if (isBound()) {
 306                             unbind();
 307                         }
 308                         set(oldRate);
 309                         throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);







 310                     } else {
<span class="line-modified"> 311                         if (Math.abs(newRate) &lt; EPSILON) {</span>
<span class="line-modified"> 312                             if (getStatus() == Status.RUNNING) {</span>
<span class="line-modified"> 313                                 lastPlayedForward = (Math.abs(getCurrentRate()</span>
<span class="line-modified"> 314                                         - oldRate) &lt; EPSILON);</span>
<span class="line-modified"> 315                             }</span>
<span class="line-modified"> 316                             doSetCurrentRate(0.0);</span>
<span class="line-modified"> 317                             pauseReceiver();</span>
<span class="line-modified"> 318                         } else {</span>
<span class="line-removed"> 319                             if (getStatus() == Status.RUNNING) {</span>
<span class="line-removed"> 320                                 final double currentRate = getCurrentRate();</span>
<span class="line-removed"> 321                                 if (Math.abs(currentRate) &lt; EPSILON) {</span>
<span class="line-removed"> 322                                     doSetCurrentRate(lastPlayedForward ? newRate : -newRate);</span>
<span class="line-removed"> 323                                     resumeReceiver();</span>
<span class="line-removed"> 324                                 } else {</span>
<span class="line-removed"> 325                                     final boolean playingForward = Math.abs(currentRate - oldRate) &lt; EPSILON;</span>
<span class="line-removed"> 326                                     doSetCurrentRate(playingForward ? newRate : -newRate);</span>
<span class="line-removed"> 327                                 }</span>
 328                             }
<span class="line-removed"> 329                             oldRate = newRate;</span>
 330                         }
<span class="line-modified"> 331                         clipEnvelope.setRate(newRate);</span>
 332                     }

 333                 }
 334 
 335                 @Override
 336                 public Object getBean() {
 337                     return Animation.this;
 338                 }
 339 
 340                 @Override
 341                 public String getName() {
 342                     return &quot;rate&quot;;
 343                 }
 344             };
 345         }
 346         return rate;
 347     }
 348 
 349     private boolean isRunningEmbedded() {
 350         if (parent == null) {
 351             return false;
 352         }
<span class="line-modified"> 353         return parent.getStatus() != Status.STOPPED || parent.isRunningEmbedded();</span>
 354     }
 355 
 356     private double oldRate = 1.0;
 357     /**
 358      * Read-only variable to indicate current direction/speed at which the
 359      * {@code Animation} is being played.
 360      * &lt;p&gt;
 361      * {@code currentRate} is not necessarily equal to {@code rate}.
 362      * {@code currentRate} is set to {@code 0.0} when animation is paused or
 363      * stopped. {@code currentRate} may also point in the opposite direction of {@code rate} during
 364      * reverse cycles when {@code autoReverse} is {@code true}.
 365      *
 366      * @defaultValue 0.0
 367      */
 368     private ReadOnlyDoubleProperty currentRate;
 369     private static final double DEFAULT_CURRENT_RATE = 0.0;
 370 












 371     private void doSetCurrentRate(double value) {
<span class="line-modified"> 372         if ((currentRate != null) || (Math.abs(value - DEFAULT_CURRENT_RATE) &gt; EPSILON)) {</span>
<span class="line-modified"> 373             ((CurrentRateProperty)currentRateProperty()).set(value);</span>
 374         }
 375     }
 376 
 377     public final double getCurrentRate() {
<span class="line-modified"> 378         return (currentRate == null)? DEFAULT_CURRENT_RATE : currentRate.get();</span>
 379     }
 380 
 381     public final ReadOnlyDoubleProperty currentRateProperty() {
 382         if (currentRate == null) {
 383             currentRate = new CurrentRateProperty();
 384         }
 385         return currentRate;
 386     }
 387 






 388     /**
 389      * Read-only variable to indicate the duration of one cycle of this
 390      * {@code Animation}: the time it takes to play from time 0 to the
 391      * end of the Animation (at the default {@code rate} of
 392      * 1.0).
 393      *
 394      * @defaultValue 0ms
 395      */
 396     private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
 397     private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
 398 
 399     protected final void setCycleDuration(Duration value) {
<span class="line-modified"> 400         if ((cycleDuration != null) || (!DEFAULT_CYCLE_DURATION.equals(value))) {</span>
 401             if (value.lessThan(Duration.ZERO)) {
 402                 throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
 403             }
<span class="line-modified"> 404             ((AnimationReadOnlyProperty&lt;Duration&gt;)cycleDurationProperty()).set(value);</span>
 405             updateTotalDuration();
 406         }
 407     }
 408 
 409     public final Duration getCycleDuration() {
<span class="line-modified"> 410         return (cycleDuration == null)? DEFAULT_CYCLE_DURATION : cycleDuration.get();</span>
 411     }
 412 
 413     public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
 414         if (cycleDuration == null) {
<span class="line-modified"> 415             cycleDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);</span>
 416         }
 417         return cycleDuration;
 418     }
 419 
 420     /**
 421      * Read-only variable to indicate the total duration of this
 422      * {@code Animation}, including repeats. An {@code Animation} with a {@code cycleCount}
 423      * of {@code Animation.INDEFINITE} will have a {@code totalDuration} of
 424      * {@code Duration.INDEFINITE}.
 425      *
 426      * &lt;p&gt;
 427      * This is set to cycleDuration * cycleCount.
 428      *
 429      * @defaultValue 0ms
 430      */
 431     private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
 432     private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
 433 
 434     public final Duration getTotalDuration() {
<span class="line-modified"> 435         return (totalDuration == null)? DEFAULT_TOTAL_DURATION : totalDuration.get();</span>
 436     }
 437 
 438     public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
 439         if (totalDuration == null) {
<span class="line-modified"> 440             totalDuration = new AnimationReadOnlyProperty&lt;Duration&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);</span>
 441         }
 442         return totalDuration;
 443     }
 444 
 445     private void updateTotalDuration() {
 446         // Implementing the bind eagerly, because cycleCount and
 447         // cycleDuration should not change that often
 448         final int cycleCount = getCycleCount();
 449         final Duration cycleDuration = getCycleDuration();
<span class="line-modified"> 450         final Duration newTotalDuration = Duration.ZERO.equals(cycleDuration) ? Duration.ZERO</span>
<span class="line-modified"> 451                 : (cycleCount == Animation.INDEFINITE) ? Duration.INDEFINITE</span>
<span class="line-modified"> 452                         : (cycleCount &lt;= 1) ? cycleDuration : cycleDuration</span>
<span class="line-modified"> 453                                 .multiply(cycleCount);</span>
<span class="line-modified"> 454         if ((totalDuration != null) || (!DEFAULT_TOTAL_DURATION.equals(newTotalDuration))) {</span>
<span class="line-modified"> 455             ((AnimationReadOnlyProperty&lt;Duration&gt;)totalDurationProperty()).set(newTotalDuration);</span>

 456         }
<span class="line-modified"> 457         if (getStatus() == Status.STOPPED) {</span>
 458             syncClipEnvelope();
 459             if (newTotalDuration.lessThan(getCurrentTime())) {
<span class="line-modified"> 460                 clipEnvelope.jumpTo(fromDuration(newTotalDuration));</span>
 461             }
 462         }
 463     }
 464 
 465     /**
 466      * Defines the {@code Animation}&#39;s play head position.
 467      *
 468      * @defaultValue 0ms
 469      */
 470     private CurrentTimeProperty currentTime;
 471     private long currentTicks;
 472     private class CurrentTimeProperty extends ReadOnlyObjectPropertyBase&lt;Duration&gt; {
 473 
 474         @Override
 475         public Object getBean() {
 476             return Animation.this;
 477         }
 478 
 479         @Override
 480         public String getName() {
</pre>
<hr />
<pre>
 498     }
 499 
 500     public final ReadOnlyObjectProperty&lt;Duration&gt; currentTimeProperty() {
 501         if (currentTime == null) {
 502             currentTime = new CurrentTimeProperty();
 503         }
 504         return currentTime;
 505     }
 506 
 507     /**
 508      * Delays the start of an animation.
 509      *
 510      * Cannot be negative. Setting to a negative number will result in {@link IllegalArgumentException}.
 511      *
 512      * @defaultValue 0ms
 513      */
 514     private ObjectProperty&lt;Duration&gt; delay;
 515     private static final Duration DEFAULT_DELAY = Duration.ZERO;
 516 
 517     public final void setDelay(Duration value) {
<span class="line-modified"> 518         if ((delay != null) || (!DEFAULT_DELAY.equals(value))) {</span>
 519             delayProperty().set(value);
 520         }
 521     }
 522 
 523     public final Duration getDelay() {
<span class="line-modified"> 524         return (delay == null)? DEFAULT_DELAY : delay.get();</span>
 525     }
 526 
 527     public final ObjectProperty&lt;Duration&gt; delayProperty() {
 528         if (delay == null) {
<span class="line-modified"> 529             delay = new ObjectPropertyBase&lt;Duration&gt;(DEFAULT_DELAY) {</span>












 530 
 531                 @Override
 532                 public Object getBean() {
 533                     return Animation.this;
 534                 }
 535 
 536                 @Override
 537                 public String getName() {
 538                     return &quot;delay&quot;;
 539                 }
<span class="line-removed"> 540 </span>
<span class="line-removed"> 541                 @Override</span>
<span class="line-removed"> 542                 protected void invalidated() {</span>
<span class="line-removed"> 543                         final Duration newDuration = get();</span>
<span class="line-removed"> 544                         if (newDuration.lessThan(Duration.ZERO)) {</span>
<span class="line-removed"> 545                             if (isBound()) {</span>
<span class="line-removed"> 546                                 unbind();</span>
<span class="line-removed"> 547                             }</span>
<span class="line-removed"> 548                             set(Duration.ZERO);</span>
<span class="line-removed"> 549                             throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);</span>
<span class="line-removed"> 550                         }</span>
<span class="line-removed"> 551                 }</span>
<span class="line-removed"> 552 </span>
 553             };
 554         }
 555         return delay;
 556     }
 557 
 558     /**
 559      * Defines the number of cycles in this animation. The {@code cycleCount}
 560      * may be {@code INDEFINITE} for animations that repeat indefinitely, but
 561      * must otherwise be {@literal &gt;} 0.
 562      * &lt;p&gt;
 563      * It is not possible to change the {@code cycleCount} of a running
 564      * {@code Animation}. If the value of {@code cycleCount} is changed for a
 565      * running {@code Animation}, the animation has to be stopped and started again to pick
 566      * up the new value.
 567      *
 568      * @defaultValue 1
 569      */
 570     private IntegerProperty cycleCount;
 571     private static final int DEFAULT_CYCLE_COUNT = 1;
 572 
 573     public final void setCycleCount(int value) {
<span class="line-modified"> 574         if ((cycleCount != null) || (value != DEFAULT_CYCLE_COUNT)) {</span>
 575             cycleCountProperty().set(value);
 576         }
 577     }
 578 
 579     public final int getCycleCount() {
<span class="line-modified"> 580         return (cycleCount == null)? DEFAULT_CYCLE_COUNT : cycleCount.get();</span>
 581     }
 582 
 583     public final IntegerProperty cycleCountProperty() {
 584         if (cycleCount == null) {
 585             cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
 586 
 587                 @Override
 588                 public void invalidated() {
 589                     updateTotalDuration();
 590                 }
 591 
 592                 @Override
 593                 public Object getBean() {
 594                     return Animation.this;
 595                 }
 596 
 597                 @Override
 598                 public String getName() {
 599                     return &quot;cycleCount&quot;;
 600                 }
</pre>
<hr />
<pre>
 605 
 606     /**
 607      * Defines whether this
 608      * {@code Animation} reverses direction on alternating cycles. If
 609      * {@code true}, the
 610      * {@code Animation} will proceed forward on the first cycle,
 611      * then reverses on the second cycle, and so on. Otherwise, animation will
 612      * loop such that each cycle proceeds forward from the start.
 613      *
 614      * It is not possible to change the {@code autoReverse} flag of a running
 615      * {@code Animation}. If the value of {@code autoReverse} is changed for a
 616      * running {@code Animation}, the animation has to be stopped and started again to pick
 617      * up the new value.
 618      *
 619      * @defaultValue false
 620      */
 621     private BooleanProperty autoReverse;
 622     private static final boolean DEFAULT_AUTO_REVERSE = false;
 623 
 624     public final void setAutoReverse(boolean value) {
<span class="line-modified"> 625         if ((autoReverse != null) || (value != DEFAULT_AUTO_REVERSE)) {</span>
 626             autoReverseProperty().set(value);
 627         }
 628     }
 629 
 630     public final boolean isAutoReverse() {
<span class="line-modified"> 631         return (autoReverse == null)? DEFAULT_AUTO_REVERSE : autoReverse.get();</span>
 632     }
 633 
 634     public final BooleanProperty autoReverseProperty() {
 635         if (autoReverse == null) {
<span class="line-modified"> 636             autoReverse = new SimpleBooleanProperty(this, &quot;autoReverse&quot;, DEFAULT_AUTO_REVERSE);</span>











 637         }
 638         return autoReverse;
 639     }
 640 
 641     /**
 642      * The status of the {@code Animation}.
 643      *
 644      * An {@code Animation} can be in one of three states:
 645      * {@link Status#STOPPED}, {@link Status#PAUSED} or {@link Status#RUNNING}.
 646      */
 647     private ReadOnlyObjectProperty&lt;Status&gt; status;
 648     private static final Status DEFAULT_STATUS = Status.STOPPED;
 649 
 650     protected final void setStatus(Status value) {
<span class="line-modified"> 651         if ((status != null) || (!DEFAULT_STATUS.equals(value))) {</span>
<span class="line-modified"> 652             ((AnimationReadOnlyProperty&lt;Status&gt;)statusProperty()).set(value);</span>
 653         }
 654     }
 655 
 656     public final Status getStatus() {
<span class="line-modified"> 657         return (status == null)? DEFAULT_STATUS : status.get();</span>
 658     }
 659 
 660     public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
 661         if (status == null) {
<span class="line-modified"> 662             status = new AnimationReadOnlyProperty&lt;Status&gt;(&quot;status&quot;, Status.STOPPED);</span>
 663         }
 664         return status;
 665     }
 666 
<span class="line-modified"> 667     private final double targetFramerate;</span>
<span class="line-modified"> 668     private final int resolution;</span>
<span class="line-modified"> 669     private long lastPulse;</span>
 670 
<span class="line-modified"> 671     /**</span>
<span class="line-modified"> 672      * The target framerate is the maximum framerate at which this {@code Animation}</span>
<span class="line-modified"> 673      * will run, in frames per second. This can be used, for example, to keep</span>
<span class="line-modified"> 674      * particularly complex {@code Animations} from over-consuming system resources.</span>
<span class="line-modified"> 675      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning</span>
<span class="line-modified"> 676      * the {@code Animation} will run at an optimal framerate for the underlying platform.</span>
<span class="line-removed"> 677      *</span>
<span class="line-removed"> 678      * @return the target framerate</span>
<span class="line-removed"> 679      */</span>
<span class="line-removed"> 680     public final double getTargetFramerate() {</span>
<span class="line-removed"> 681         return targetFramerate;</span>
 682     }
 683 
 684     /**
 685      * The action to be executed at the conclusion of this {@code Animation}.
 686      *
 687      * @defaultValue null
 688      */
 689     private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
 690     private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
 691 
 692     public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
<span class="line-modified"> 693         if ((onFinished != null) || (value != null /* DEFAULT_ON_FINISHED */)) {</span>
 694             onFinishedProperty().set(value);
 695         }
 696     }
 697 
 698     public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
<span class="line-modified"> 699         return (onFinished == null)? DEFAULT_ON_FINISHED : onFinished.get();</span>
 700     }
 701 
 702     public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
 703         if (onFinished == null) {
<span class="line-modified"> 704             onFinished = new SimpleObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt;(this, &quot;onFinished&quot;, DEFAULT_ON_FINISHED);</span>











 705         }
 706         return onFinished;
 707     }
 708 
<span class="line-modified"> 709     private final ObservableMap&lt;String, Duration&gt; cuePoints = FXCollections</span>
<span class="line-removed"> 710             .observableMap(new HashMap&lt;String, Duration&gt;(0));</span>
 711 
 712     /**
 713      * The cue points can be
 714      * used to mark important positions of the {@code Animation}. Once a cue
 715      * point was defined, it can be used as an argument of
 716      * {@link #jumpTo(String) jumpTo()} and {@link #playFrom(String) playFrom()}
 717      * to move to the associated position quickly.
 718      * &lt;p&gt;
 719      * Every {@code Animation} has two predefined cue points {@code &quot;start&quot;} and
 720      * {@code &quot;end&quot;}, which are set at the start respectively the end of the
 721      * {@code Animation}. The predefined cuepoints do not appear in the map,
 722      * attempts to override them have no effect.
 723      * &lt;p&gt;
 724      * Another option to define a cue point in a {@code Animation} is to set the
 725      * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
 726      *
 727      * @return {@link javafx.collections.ObservableMap} of cue points
 728      */
 729     public final ObservableMap&lt;String, Duration&gt; getCuePoints() {



 730         return cuePoints;
 731     }
 732 
 733     /**
 734      * Jumps to a given position in this {@code Animation}.
 735      *
 736      * If the given time is less than {@link Duration#ZERO}, this method will
 737      * jump to the start of the animation. If the given time is larger than the
 738      * duration of this {@code Animation}, this method will jump to the end.
 739      *
 740      * @param time
 741      *            the new position
 742      * @throws NullPointerException
 743      *             if {@code time} is {@code null}
 744      * @throws IllegalArgumentException
 745      *             if {@code time} is {@link Duration#UNKNOWN}
 746      * @throws IllegalStateException
 747      *             if embedded in another animation,
 748      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 749      */
 750     public void jumpTo(Duration time) {
<span class="line-modified"> 751         if (time == null) {</span>
<span class="line-removed"> 752             throw new NullPointerException(&quot;Time needs to be specified.&quot;);</span>
<span class="line-removed"> 753         }</span>
 754         if (time.isUnknown()) {
 755             throw new IllegalArgumentException(&quot;The time is invalid&quot;);
 756         }
 757         if (parent != null) {
 758             throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
 759         }
 760 
 761         lastPlayedFinished = false;
 762 
 763         double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
 764             Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
 765         long ticks = TickCalculation.fromMillis(millis);
 766 
<span class="line-modified"> 767         if (getStatus() == Status.STOPPED) {</span>
 768             syncClipEnvelope();
 769         }
 770         clipEnvelope.jumpTo(ticks);
 771     }
 772 
 773     /**
 774      * Jumps to a predefined position in this {@code Animation}. This method
 775      * looks for an entry in cue points and jumps to the associated
 776      * position, if it finds one.
 777      * &lt;p&gt;
 778      * If the cue point is behind the end of this {@code Animation}, calling
 779      * {@code jumpTo} will result in a jump to the end. If the cue point has a
 780      * negative {@link javafx.util.Duration} it will result in a jump to the
 781      * beginning. If the cue point has a value of
 782      * {@link javafx.util.Duration#UNKNOWN} calling {@code jumpTo} will have no
 783      * effect for this cue point.
 784      * &lt;p&gt;
 785      * There are two predefined cue points {@code &quot;start&quot;} and {@code &quot;end&quot;}
 786      * which are defined to be at the start respectively the end of this
 787      * {@code Animation}.
 788      *
 789      * @param cuePoint
 790      *            the name of the cue point
 791      * @throws NullPointerException
 792      *             if {@code cuePoint} is {@code null}
 793      * @throws IllegalStateException
 794      *             if embedded in another animation,
 795      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 796      * @see #getCuePoints()
 797      */
 798     public void jumpTo(String cuePoint) {
<span class="line-modified"> 799         if (cuePoint == null) {</span>
<span class="line-removed"> 800             throw new NullPointerException(&quot;CuePoint needs to be specified&quot;);</span>
<span class="line-removed"> 801         }</span>
 802         if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
 803             jumpTo(Duration.ZERO);
 804         } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
 805             jumpTo(getTotalDuration());
 806         } else {
 807             final Duration target = getCuePoints().get(cuePoint);
 808             if (target != null) {
 809                 jumpTo(target);
 810             }
 811         }
 812     }
 813 
 814     /**
 815      * A convenience method to play this {@code Animation} from a predefined
 816      * position. The position has to be predefined in cue points.
 817      * Calling this method is equivalent to
 818      *
 819      * &lt;pre&gt;
 820      * &lt;code&gt;
 821      * animation.jumpTo(cuePoint);
</pre>
<hr />
<pre>
 852      * &lt;/pre&gt;
 853      *
 854      * Note that unlike {@link #playFromStart()} calling this method will not
 855      * change the playing direction of this {@code Animation}.
 856      *
 857      * @param time
 858      *            position where to play from
 859      * @throws NullPointerException
 860      *             if {@code time} is {@code null}
 861      * @throws IllegalArgumentException
 862      *             if {@code time} is {@link Duration#UNKNOWN}
 863      * @throws IllegalStateException
 864      *             if embedded in another animation,
 865      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 866      */
 867     public void playFrom(Duration time) {
 868         jumpTo(time);
 869         play();
 870     }
 871 




























 872     /**
 873      * Plays {@code Animation} from current position in the direction indicated
 874      * by {@code rate}. If the {@code Animation} is running, it has no effect.
 875      * &lt;p&gt;
 876      * When {@code rate} {@literal &gt;} 0 (forward play), if an {@code Animation} is already
 877      * positioned at the end, the first cycle will not be played, it is
 878      * considered to have already finished. This also applies to a backward (
 879      * {@code rate} {@literal &lt;} 0) cycle if an {@code Animation} is positioned at the beginning.
 880      * However, if the {@code Animation} has {@code cycleCount} {@literal &gt;} 1, following
 881      * cycle(s) will be played as usual.
 882      * &lt;p&gt;
 883      * When the {@code Animation} reaches the end, the {@code Animation} is stopped and
 884      * the play head remains at the end.
 885      * &lt;p&gt;
 886      * To play an {@code Animation} backwards from the end:&lt;br&gt;
 887      * &lt;code&gt;
 888      *  animation.setRate(negative rate);&lt;br&gt;
 889      *  animation.jumpTo(overall duration of animation);&lt;br&gt;
 890      *  animation.play();&lt;br&gt;
 891      * &lt;/code&gt;
 892      * &lt;p&gt;
 893      * Note: &lt;ul&gt;
 894      * &lt;li&gt;{@code play()} is an asynchronous call, the {@code Animation} may not
 895      * start immediately. &lt;/ul&gt;
 896      *
 897      * @throws IllegalStateException
 898      *             if embedded in another animation,
 899      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 900      */
 901     public void play() {
 902         if (parent != null) {
 903             throw new IllegalStateException(&quot;Cannot start when embedded in another animation&quot;);
 904         }
 905         switch (getStatus()) {
 906             case STOPPED:
 907                 if (startable(true)) {
 908                     final double rate = getRate();
 909                     if (lastPlayedFinished) {
<span class="line-modified"> 910                         jumpTo((rate &lt; 0)? getTotalDuration() : Duration.ZERO);</span>
 911                     }
 912                     doStart(true);
 913                     startReceiver(TickCalculation.fromDuration(getDelay()));
<span class="line-modified"> 914                     if (Math.abs(rate) &lt; EPSILON) {</span>
 915                         pauseReceiver();
 916                     } else {
 917 
 918                     }
 919                 } else {
<span class="line-modified"> 920                     final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();</span>
<span class="line-removed"> 921                     if (handler != null) {</span>
<span class="line-removed"> 922                         handler.handle(new ActionEvent(this, null));</span>
<span class="line-removed"> 923                     }</span>
 924                 }
 925                 break;
 926             case PAUSED:
 927                 doResume();
<span class="line-modified"> 928                 if (Math.abs(getRate()) &gt;= EPSILON) {</span>
 929                     resumeReceiver();
 930                 }
 931                 break;

 932         }
 933     }
 934 
<span class="line-modified"> 935     /**</span>
<span class="line-modified"> 936      * Plays an {@code Animation} from initial position in forward direction.</span>
<span class="line-modified"> 937      * &lt;p&gt;</span>
<span class="line-modified"> 938      * It is equivalent to</span>
<span class="line-modified"> 939      * &lt;p&gt;</span>
<span class="line-modified"> 940      * &lt;code&gt;</span>
<span class="line-modified"> 941      *      animation.stop();&lt;br&gt;</span>
<span class="line-modified"> 942      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;</span>
<span class="line-modified"> 943      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;</span>
<span class="line-modified"> 944      *      animation.play();&lt;br&gt;</span>
<span class="line-modified"> 945      *  &lt;/code&gt;</span>
<span class="line-removed"> 946      *</span>
<span class="line-removed"> 947      * &lt;p&gt;</span>
<span class="line-removed"> 948      * Note: &lt;ul&gt;</span>
<span class="line-removed"> 949      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may</span>
<span class="line-removed"> 950      * not start immediately. &lt;/ul&gt;</span>
<span class="line-removed"> 951      *</span>
<span class="line-removed"> 952      * @throws IllegalStateException</span>
<span class="line-removed"> 953      *             if embedded in another animation,</span>
<span class="line-removed"> 954      *                such as {@link SequentialTransition} or {@link ParallelTransition}</span>
<span class="line-removed"> 955      */</span>
<span class="line-removed"> 956     public void playFromStart() {</span>
<span class="line-removed"> 957         stop();</span>
<span class="line-removed"> 958         setRate(Math.abs(getRate()));</span>
<span class="line-removed"> 959         jumpTo(Duration.ZERO);</span>
<span class="line-removed"> 960         play();</span>
 961     }
 962 
 963     /**
 964      * Stops the animation and resets the play head to its initial position. If
 965      * the animation is already stopped, this method has no effect.
 966      * &lt;p&gt;
 967      * Note: &lt;ul&gt;
 968      * &lt;li&gt;{@code stop()} is an asynchronous call, the {@code Animation} may not stop
 969      * immediately. &lt;/ul&gt;
 970      * @throws IllegalStateException
 971      *             if embedded in another animation,
 972      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 973      */
 974     public void stop() {
 975         if (parent != null) {
 976             throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
 977         }
<span class="line-modified"> 978         if (getStatus() != Status.STOPPED) {</span>
 979             clipEnvelope.abortCurrentPulse();
 980             doStop();
 981             jumpTo(Duration.ZERO);
 982             lastPlayedFinished = true;
 983         }
 984     }
 985 








 986     /**
 987      * Pauses the animation. If the animation is not currently running, this
 988      * method has no effect.
 989      * &lt;p&gt;
 990      * Note: &lt;ul&gt;
 991      * &lt;li&gt;{@code pause()} is an asynchronous call, the {@code Animation} may not pause
 992      * immediately. &lt;/ul&gt;
 993      * @throws IllegalStateException
 994      *             if embedded in another animation,
 995      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 996      */
 997     public void pause() {
 998         if (parent != null) {
 999             throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
1000         }
<span class="line-modified">1001         if (getStatus() == Status.RUNNING) {</span>
1002             clipEnvelope.abortCurrentPulse();
1003             pauseReceiver();
1004             doPause();
1005         }
1006     }
1007 










































1008     /**
1009      * The constructor of {@code Animation}.
1010      *
1011      * This constructor allows to define a target framerate.
1012      *
1013      * @param targetFramerate
1014      *            The custom target frame rate for this {@code Animation}
1015      * @see #getTargetFramerate()
1016      */
1017     protected Animation(double targetFramerate) {
1018         this.targetFramerate = targetFramerate;
1019         this.resolution = (int) Math.max(1, Math.round(TickCalculation.TICKS_PER_SECOND / targetFramerate));
1020         this.clipEnvelope = ClipEnvelope.create(this);
1021         this.timer = Toolkit.getToolkit().getMasterTimer();
1022     }
1023 
1024     /**
1025      * The constructor of {@code Animation}.
1026      */
1027     protected Animation() {
</pre>
<hr />
<pre>
1031         this.timer = Toolkit.getToolkit().getMasterTimer();
1032     }
1033 
1034     // These constructors are only for testing purposes
1035     Animation(AbstractMasterTimer timer) {
1036         this.resolution = 1;
1037         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / timer.getDefaultResolution();
1038         this.clipEnvelope = ClipEnvelope.create(this);
1039         this.timer = timer;
1040     }
1041 
1042     // These constructors are only for testing purposes
1043     Animation(AbstractMasterTimer timer, ClipEnvelope clipEnvelope, int resolution) {
1044         this.resolution = resolution;
1045         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / resolution;
1046         this.clipEnvelope = clipEnvelope;
1047         this.timer = timer;
1048     }
1049 
1050     boolean startable(boolean forceSync) {
<span class="line-modified">1051         return (fromDuration(getCycleDuration()) &gt; 0L)</span>
<span class="line-removed">1052                 || (!forceSync &amp;&amp; clipEnvelope.wasSynched());</span>
1053     }
1054 
1055     void sync(boolean forceSync) {
1056         if (forceSync || !clipEnvelope.wasSynched()) {
1057             syncClipEnvelope();
1058         }
1059     }
1060 
1061     private void syncClipEnvelope() {
1062         final int publicCycleCount = getCycleCount();
1063         final int internalCycleCount = (publicCycleCount &lt;= 0)
1064                 &amp;&amp; (publicCycleCount != INDEFINITE) ? 1 : publicCycleCount;
1065         clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
1066         clipEnvelope.setCycleDuration(getCycleDuration());
1067         clipEnvelope.setAutoReverse(isAutoReverse());
1068     }
1069 
<span class="line-removed">1070     void doStart(boolean forceSync) {</span>
<span class="line-removed">1071         sync(forceSync);</span>
<span class="line-removed">1072         setStatus(Status.RUNNING);</span>
<span class="line-removed">1073         clipEnvelope.start();</span>
<span class="line-removed">1074         doSetCurrentRate(clipEnvelope.getCurrentRate());</span>
<span class="line-removed">1075         lastPulse = 0;</span>
<span class="line-removed">1076     }</span>
<span class="line-removed">1077 </span>
<span class="line-removed">1078     void doPause() {</span>
<span class="line-removed">1079         final double currentRate = getCurrentRate();</span>
<span class="line-removed">1080         if (Math.abs(currentRate) &gt;= EPSILON) {</span>
<span class="line-removed">1081             lastPlayedForward = Math.abs(getCurrentRate() - getRate()) &lt; EPSILON;</span>
<span class="line-removed">1082         }</span>
<span class="line-removed">1083         doSetCurrentRate(0.0);</span>
<span class="line-removed">1084         setStatus(Status.PAUSED);</span>
<span class="line-removed">1085     }</span>
<span class="line-removed">1086 </span>
<span class="line-removed">1087     void doResume() {</span>
<span class="line-removed">1088         setStatus(Status.RUNNING);</span>
<span class="line-removed">1089         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());</span>
<span class="line-removed">1090     }</span>
<span class="line-removed">1091 </span>
<span class="line-removed">1092     void doStop() {</span>
<span class="line-removed">1093         if (!paused) {</span>
<span class="line-removed">1094             timer.removePulseReceiver(pulseReceiver);</span>
<span class="line-removed">1095         }</span>
<span class="line-removed">1096         setStatus(Status.STOPPED);</span>
<span class="line-removed">1097         doSetCurrentRate(0.0);</span>
<span class="line-removed">1098     }</span>
<span class="line-removed">1099 </span>
1100     void doTimePulse(long elapsedTime) {
1101         if (resolution == 1) { // fullspeed
1102             clipEnvelope.timePulse(elapsedTime);
1103         } else if (elapsedTime - lastPulse &gt;= resolution) {
1104             lastPulse = (elapsedTime / resolution) * resolution;
1105             clipEnvelope.timePulse(elapsedTime);
1106         }
1107     }
1108 
1109     abstract void doPlayTo(long currentTicks, long cycleTicks);
1110 
1111     abstract void doJumpTo(long currentTicks, long cycleTicks, boolean forceJump);
1112 
1113     void setCurrentTicks(long ticks) {
1114         currentTicks = ticks;
1115         if (currentTime != null) {
1116             currentTime.fireValueChangedEvent();
1117         }
1118     }
<span class="line-removed">1119 </span>
<span class="line-removed">1120     void setCurrentRate(double currentRate) {</span>
<span class="line-removed">1121 //        if (getStatus() == Status.RUNNING) {</span>
<span class="line-removed">1122             doSetCurrentRate(currentRate);</span>
<span class="line-removed">1123 //        }</span>
<span class="line-removed">1124     }</span>
<span class="line-removed">1125 </span>
<span class="line-removed">1126     final void finished() {</span>
<span class="line-removed">1127         lastPlayedFinished = true;</span>
<span class="line-removed">1128         doStop();</span>
<span class="line-removed">1129         final EventHandler&lt;ActionEvent&gt; handler = getOnFinished();</span>
<span class="line-removed">1130         if (handler != null) {</span>
<span class="line-removed">1131             try {</span>
<span class="line-removed">1132                 handler.handle(new ActionEvent(this, null));</span>
<span class="line-removed">1133             } catch (Exception ex) {</span>
<span class="line-removed">1134                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);</span>
<span class="line-removed">1135             }</span>
<span class="line-removed">1136         }</span>
<span class="line-removed">1137     }</span>
1138 }
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.animation;
  27 
<span class="line-modified">  28 import java.util.Objects;</span>
  29 
  30 import com.sun.javafx.tk.Toolkit;
  31 import com.sun.javafx.util.Utils;
  32 
  33 import javafx.beans.property.BooleanProperty;
<span class="line-added">  34 import javafx.beans.property.BooleanPropertyBase;</span>
  35 import javafx.beans.property.DoubleProperty;
  36 import javafx.beans.property.DoublePropertyBase;
  37 import javafx.beans.property.IntegerProperty;
  38 import javafx.beans.property.IntegerPropertyBase;
  39 import javafx.beans.property.ObjectProperty;
  40 import javafx.beans.property.ObjectPropertyBase;
  41 import javafx.beans.property.ReadOnlyDoubleProperty;
  42 import javafx.beans.property.ReadOnlyDoublePropertyBase;
  43 import javafx.beans.property.ReadOnlyObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectPropertyBase;


  45 import javafx.collections.FXCollections;
  46 import javafx.collections.ObservableMap;
  47 import javafx.event.ActionEvent;
  48 import javafx.event.EventHandler;
  49 import javafx.util.Duration;
  50 import com.sun.javafx.animation.TickCalculation;
  51 import com.sun.scenario.animation.AbstractMasterTimer;
  52 import com.sun.scenario.animation.shared.ClipEnvelope;
  53 import com.sun.scenario.animation.shared.PulseReceiver;
  54 

  55 import java.security.AccessControlContext;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 
  59 /**
  60  * The class {@code Animation} provides the core functionality of all animations
  61  * used in the JavaFX runtime.
  62  * &lt;p&gt;
  63  * An animation can run in a loop by setting {@link #cycleCountProperty() cycleCount}.
  64  * To make an animation run back and forth while looping, set the
  65  * {@link #autoReverseProperty() autoReverse} -flag.
  66  * &lt;p&gt;
  67  * Call {@link #play()} or {@link #playFromStart()} to play an {@code Animation}
  68  * . The {@code Animation} progresses in the direction and speed specified by
  69  * {@link #rateProperty() rate}, and stops when its duration is elapsed. An {@code Animation}
  70  * with indefinite duration (a {@link #cycleCountProperty() cycleCount} of {@link #INDEFINITE}) runs
  71  * repeatedly until the {@link #stop()} method is explicitly called, which will
  72  * stop the running {@code Animation} and reset its play head to the initial
  73  * position.
  74  * &lt;p&gt;
</pre>
<hr />
<pre>
  79  * An {@code Animation}&#39;s play head can be randomly positioned, whether it is
  80  * running or not. If the {@code Animation} is running, the play head jumps to
  81  * the specified position immediately and continues playing from new position.
  82  * If the {@code Animation} is not running, the next {@link #play()} will start
  83  * the {@code Animation} from the specified position.
  84  * &lt;p&gt;
  85  * Inverting the value of {@link #rateProperty() rate} toggles the play direction.
  86  *
  87  * @see Timeline
  88  * @see Transition
  89  *
  90  * @since JavaFX 2.0
  91  */
  92 public abstract class Animation {
  93 
  94     static {
  95         AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
  96     }
  97 
  98     /**
<span class="line-modified">  99      * Used as a  value for {@link #cycleCountProperty() cycleCount} to specify an animation that repeats indefinitely,</span>
<span class="line-modified"> 100      * until the {@code stop()} method is called.</span>
 101      */
 102     public static final int INDEFINITE = -1;
 103 
 104     /**
 105      * The possible states for {@link Animation#statusProperty() status}.
 106      * @since JavaFX 2.0
 107      */
 108     public static enum Status {
 109         /**
 110          * The paused state.
 111          */
 112         PAUSED,
 113         /**
 114          * The running state.
 115          */
 116         RUNNING,
 117         /**
 118          * The stopped state.
 119          */
 120         STOPPED
 121     }
 122 
 123     private static final double EPSILON = 1e-12;
 124 
<span class="line-added"> 125     /**</span>
<span class="line-added"> 126      * Checks if the rate is effectively 0.</span>
<span class="line-added"> 127      * @param rate</span>
<span class="line-added"> 128      * @return true i.f.f. abs(rate) &lt; EPSILON</span>
<span class="line-added"> 129      */</span>
<span class="line-added"> 130     static final boolean isNearZero(double rate) {</span>
<span class="line-added"> 131         return Math.abs(rate) &lt; EPSILON;</span>
<span class="line-added"> 132     }</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134     /**</span>
<span class="line-added"> 135      * Checks if 2 rates are effectively equal.</span>
<span class="line-added"> 136      * @param rateMagnitude</span>
<span class="line-added"> 137      * @return true i.f.f. Math.abs(rate1 - rate2) &lt; EPSILON</span>
<span class="line-added"> 138      */</span>
<span class="line-added"> 139     private static boolean areNearEqual(double rate1, double rate2) {</span>
<span class="line-added"> 140         return isNearZero(rate2 - rate1);</span>
<span class="line-added"> 141     }</span>
<span class="line-added"> 142 </span>
 143     /*
 144         These four fields and associated methods were moved here from AnimationPulseReceiver
 145         when that class was removed. They could probably be integrated much cleaner into Animation,
 146         but to make sure the change was made without introducing regressions, this code was
 147         moved pretty much verbatim.
 148      */
 149     private long startTime;
 150     private long pauseTime;
 151     private boolean paused = false;
 152     private final AbstractMasterTimer timer;
 153 
<span class="line-modified"> 154     // Access control context, captured whenever we add this pulse receiver to</span>
 155     // the master timer (which is called when an animation is played or resumed)
 156     private AccessControlContext accessCtrlCtx = null;
 157 
 158     private long now() {
 159         return TickCalculation.fromNano(timer.nanos());
 160     }
 161 
 162     private void addPulseReceiver() {
 163         // Capture the Access Control Context to be used during the animation pulse
 164         accessCtrlCtx = AccessController.getContext();
 165 
 166         timer.addPulseReceiver(pulseReceiver);
 167     }
 168 
 169     void startReceiver(long delay) {
 170         paused = false;
 171         startTime = now() + delay;
 172         addPulseReceiver();
 173     }
 174 
</pre>
<hr />
<pre>
 254         @Override
 255         public T get() {
 256             return value;
 257         }
 258 
 259         private void set(T value) {
 260             this.value = value;
 261             fireValueChangedEvent();
 262         }
 263     }
 264 
 265     /**
 266      * The parent of this {@code Animation}. If this animation has not been
 267      * added to another animation, such as {@link ParallelTransition} and
 268      * {@link SequentialTransition}, then parent will be null.
 269      *
 270      * @defaultValue null
 271      */
 272     Animation parent = null;
 273 
<span class="line-modified"> 274     /**</span>
<span class="line-added"> 275      * The type of ClipEnvelope for the animation is determined by its cycleCount and cycleDuration</span>
<span class="line-added"> 276      * and is updated when these values change.</span>
<span class="line-added"> 277      * &lt;p&gt;</span>
<span class="line-added"> 278      * Package-private for testing purposes</span>
<span class="line-added"> 279     */</span>
 280     ClipEnvelope clipEnvelope;
 281 
 282     private boolean lastPlayedFinished = true;
 283 
 284     private boolean lastPlayedForward = true;
 285     /**
 286      * Defines the direction/speed at which the {@code Animation} is expected to
 287      * be played.
 288      * &lt;p&gt;
 289      * The absolute value of {@code rate} indicates the speed at which the
 290      * {@code Animation} is to be played, while the sign of {@code rate}
 291      * indicates the direction. A positive value of {@code rate} indicates
 292      * forward play, a negative value indicates backward play and {@code 0.0} to
 293      * stop a running {@code Animation}.
 294      * &lt;p&gt;
 295      * Rate {@code 1.0} is normal play, {@code 2.0} is 2 time normal,
 296      * {@code -1.0} is backwards, etc.
 297      *
 298      * &lt;p&gt;
 299      * Inverting the rate of a running {@code Animation} will cause the
 300      * {@code Animation} to reverse direction in place and play back over the
 301      * portion of the {@code Animation} that has already elapsed.
 302      *
 303      * @defaultValue 1.0
 304      */
 305     private DoubleProperty rate;
 306     private static final double DEFAULT_RATE = 1.0;
 307 
 308     public final void setRate(double value) {
<span class="line-modified"> 309         if (rate != null || !areNearEqual(value, DEFAULT_RATE)) {</span>
 310             rateProperty().set(value);
 311         }
 312     }
 313 
 314     public final double getRate() {
 315         return (rate == null)? DEFAULT_RATE : rate.get();
 316     }
 317 
 318     public final DoubleProperty rateProperty() {
 319         if (rate == null) {
 320             rate = new DoublePropertyBase(DEFAULT_RATE) {
 321 
 322                 @Override
 323                 public void invalidated() {
 324                     final double newRate = getRate();
 325                     if (isRunningEmbedded()) {
 326                         if (isBound()) {
 327                             unbind();
 328                         }
 329                         set(oldRate);
 330                         throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);
<span class="line-added"> 331                     }</span>
<span class="line-added"> 332                     if (isNearZero(newRate)) {</span>
<span class="line-added"> 333                         if (isRunning()) {</span>
<span class="line-added"> 334                             lastPlayedForward = areNearEqual(getCurrentRate(), oldRate);</span>
<span class="line-added"> 335                         }</span>
<span class="line-added"> 336                         doSetCurrentRate(0.0);</span>
<span class="line-added"> 337                         pauseReceiver();</span>
 338                     } else {
<span class="line-modified"> 339                         if (isRunning()) {</span>
<span class="line-modified"> 340                             final double currentRate = getCurrentRate();</span>
<span class="line-modified"> 341                             if (isNearZero(currentRate)) {</span>
<span class="line-modified"> 342                                 doSetCurrentRate(lastPlayedForward ? newRate : -newRate);</span>
<span class="line-modified"> 343                                 resumeReceiver();</span>
<span class="line-modified"> 344                             } else {</span>
<span class="line-modified"> 345                                 final boolean playingForward = areNearEqual(currentRate, oldRate);</span>
<span class="line-modified"> 346                                 doSetCurrentRate(playingForward ? newRate : -newRate);</span>









 347                             }

 348                         }
<span class="line-modified"> 349                         oldRate = newRate;</span>
 350                     }
<span class="line-added"> 351                     clipEnvelope.setRate(newRate);</span>
 352                 }
 353 
 354                 @Override
 355                 public Object getBean() {
 356                     return Animation.this;
 357                 }
 358 
 359                 @Override
 360                 public String getName() {
 361                     return &quot;rate&quot;;
 362                 }
 363             };
 364         }
 365         return rate;
 366     }
 367 
 368     private boolean isRunningEmbedded() {
 369         if (parent == null) {
 370             return false;
 371         }
<span class="line-modified"> 372         return !parent.isStopped() || parent.isRunningEmbedded();</span>
 373     }
 374 
 375     private double oldRate = 1.0;
 376     /**
 377      * Read-only variable to indicate current direction/speed at which the
 378      * {@code Animation} is being played.
 379      * &lt;p&gt;
 380      * {@code currentRate} is not necessarily equal to {@code rate}.
 381      * {@code currentRate} is set to {@code 0.0} when animation is paused or
 382      * stopped. {@code currentRate} may also point in the opposite direction of {@code rate} during
 383      * reverse cycles when {@code autoReverse} is {@code true}.
 384      *
 385      * @defaultValue 0.0
 386      */
 387     private ReadOnlyDoubleProperty currentRate;
 388     private static final double DEFAULT_CURRENT_RATE = 0.0;
 389 
<span class="line-added"> 390     /**</span>
<span class="line-added"> 391      * The current rate changes in 3 cases:</span>
<span class="line-added"> 392      * &lt;ol&gt;</span>
<span class="line-added"> 393      * &lt;li&gt; When the rate is changed.</span>
<span class="line-added"> 394      * &lt;li&gt; When the status is changed (paused/stopped/resumed/started).</span>
<span class="line-added"> 395      * &lt;li&gt; When switching between a forwards and backwards cycle.</span>
<span class="line-added"> 396      * &lt;/ol&gt;</span>
<span class="line-added"> 397      *</span>
<span class="line-added"> 398      * 1 happens when the user changes the rate of the animation or its root parent.</span>
<span class="line-added"> 399      * 2 happens when the user changes the status or when the animation is finished.</span>
<span class="line-added"> 400      * 3 happens when the clip envelope flips the rate when the cycle is alternated, through the accessor</span>
<span class="line-added"> 401      */</span>
 402     private void doSetCurrentRate(double value) {
<span class="line-modified"> 403         if (currentRate != null || !areNearEqual(value, DEFAULT_CURRENT_RATE)) {</span>
<span class="line-modified"> 404             ((CurrentRateProperty) currentRateProperty()).set(value);</span>
 405         }
 406     }
 407 
 408     public final double getCurrentRate() {
<span class="line-modified"> 409         return (currentRate == null) ? DEFAULT_CURRENT_RATE : currentRate.get();</span>
 410     }
 411 
 412     public final ReadOnlyDoubleProperty currentRateProperty() {
 413         if (currentRate == null) {
 414             currentRate = new CurrentRateProperty();
 415         }
 416         return currentRate;
 417     }
 418 
<span class="line-added"> 419     void setCurrentRate(double currentRate) {</span>
<span class="line-added"> 420 //      if (getStatus() == Status.RUNNING) {</span>
<span class="line-added"> 421           doSetCurrentRate(currentRate);</span>
<span class="line-added"> 422 //      }</span>
<span class="line-added"> 423   }</span>
<span class="line-added"> 424 </span>
 425     /**
 426      * Read-only variable to indicate the duration of one cycle of this
 427      * {@code Animation}: the time it takes to play from time 0 to the
 428      * end of the Animation (at the default {@code rate} of
 429      * 1.0).
 430      *
 431      * @defaultValue 0ms
 432      */
 433     private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
 434     private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
 435 
 436     protected final void setCycleDuration(Duration value) {
<span class="line-modified"> 437         if (cycleDuration != null || !DEFAULT_CYCLE_DURATION.equals(value)) {</span>
 438             if (value.lessThan(Duration.ZERO)) {
 439                 throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
 440             }
<span class="line-modified"> 441             ((AnimationReadOnlyProperty&lt;Duration&gt;) cycleDurationProperty()).set(value);</span>
 442             updateTotalDuration();
 443         }
 444     }
 445 
 446     public final Duration getCycleDuration() {
<span class="line-modified"> 447         return (cycleDuration == null) ? DEFAULT_CYCLE_DURATION : cycleDuration.get();</span>
 448     }
 449 
 450     public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
 451         if (cycleDuration == null) {
<span class="line-modified"> 452             cycleDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);</span>
 453         }
 454         return cycleDuration;
 455     }
 456 
 457     /**
 458      * Read-only variable to indicate the total duration of this
 459      * {@code Animation}, including repeats. An {@code Animation} with a {@code cycleCount}
 460      * of {@code Animation.INDEFINITE} will have a {@code totalDuration} of
 461      * {@code Duration.INDEFINITE}.
 462      *
 463      * &lt;p&gt;
 464      * This is set to cycleDuration * cycleCount.
 465      *
 466      * @defaultValue 0ms
 467      */
 468     private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
 469     private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
 470 
 471     public final Duration getTotalDuration() {
<span class="line-modified"> 472         return (totalDuration == null) ? DEFAULT_TOTAL_DURATION : totalDuration.get();</span>
 473     }
 474 
 475     public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
 476         if (totalDuration == null) {
<span class="line-modified"> 477             totalDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);</span>
 478         }
 479         return totalDuration;
 480     }
 481 
 482     private void updateTotalDuration() {
 483         // Implementing the bind eagerly, because cycleCount and
 484         // cycleDuration should not change that often
 485         final int cycleCount = getCycleCount();
 486         final Duration cycleDuration = getCycleDuration();
<span class="line-modified"> 487         final Duration newTotalDuration;</span>
<span class="line-modified"> 488         if (Duration.ZERO.equals(cycleDuration)) newTotalDuration = Duration.ZERO;</span>
<span class="line-modified"> 489         else if (cycleCount == INDEFINITE) newTotalDuration = Duration.INDEFINITE;</span>
<span class="line-modified"> 490         else if (cycleCount &lt;= 1) newTotalDuration = cycleDuration;</span>
<span class="line-modified"> 491         else newTotalDuration = cycleDuration.multiply(cycleCount);</span>
<span class="line-modified"> 492         if (totalDuration != null || !DEFAULT_TOTAL_DURATION.equals(newTotalDuration)) {</span>
<span class="line-added"> 493             ((AnimationReadOnlyProperty&lt;Duration&gt;) totalDurationProperty()).set(newTotalDuration);</span>
 494         }
<span class="line-modified"> 495         if (isStopped()) {</span>
 496             syncClipEnvelope();
 497             if (newTotalDuration.lessThan(getCurrentTime())) {
<span class="line-modified"> 498                 clipEnvelope.jumpTo(TickCalculation.fromDuration(newTotalDuration));</span>
 499             }
 500         }
 501     }
 502 
 503     /**
 504      * Defines the {@code Animation}&#39;s play head position.
 505      *
 506      * @defaultValue 0ms
 507      */
 508     private CurrentTimeProperty currentTime;
 509     private long currentTicks;
 510     private class CurrentTimeProperty extends ReadOnlyObjectPropertyBase&lt;Duration&gt; {
 511 
 512         @Override
 513         public Object getBean() {
 514             return Animation.this;
 515         }
 516 
 517         @Override
 518         public String getName() {
</pre>
<hr />
<pre>
 536     }
 537 
 538     public final ReadOnlyObjectProperty&lt;Duration&gt; currentTimeProperty() {
 539         if (currentTime == null) {
 540             currentTime = new CurrentTimeProperty();
 541         }
 542         return currentTime;
 543     }
 544 
 545     /**
 546      * Delays the start of an animation.
 547      *
 548      * Cannot be negative. Setting to a negative number will result in {@link IllegalArgumentException}.
 549      *
 550      * @defaultValue 0ms
 551      */
 552     private ObjectProperty&lt;Duration&gt; delay;
 553     private static final Duration DEFAULT_DELAY = Duration.ZERO;
 554 
 555     public final void setDelay(Duration value) {
<span class="line-modified"> 556         if (delay != null || !DEFAULT_DELAY.equals(value)) {</span>
 557             delayProperty().set(value);
 558         }
 559     }
 560 
 561     public final Duration getDelay() {
<span class="line-modified"> 562         return (delay == null) ? DEFAULT_DELAY : delay.get();</span>
 563     }
 564 
 565     public final ObjectProperty&lt;Duration&gt; delayProperty() {
 566         if (delay == null) {
<span class="line-modified"> 567             delay = new ObjectPropertyBase&lt;&gt;(DEFAULT_DELAY) {</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569                 @Override</span>
<span class="line-added"> 570                 protected void invalidated() {</span>
<span class="line-added"> 571                     final Duration newDuration = get();</span>
<span class="line-added"> 572                     if (newDuration.lessThan(Duration.ZERO)) {</span>
<span class="line-added"> 573                         if (isBound()) {</span>
<span class="line-added"> 574                             unbind();</span>
<span class="line-added"> 575                         }</span>
<span class="line-added"> 576                         set(Duration.ZERO);</span>
<span class="line-added"> 577                         throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);</span>
<span class="line-added"> 578                     }</span>
<span class="line-added"> 579                 }</span>
 580 
 581                 @Override
 582                 public Object getBean() {
 583                     return Animation.this;
 584                 }
 585 
 586                 @Override
 587                 public String getName() {
 588                     return &quot;delay&quot;;
 589                 }













 590             };
 591         }
 592         return delay;
 593     }
 594 
 595     /**
 596      * Defines the number of cycles in this animation. The {@code cycleCount}
 597      * may be {@code INDEFINITE} for animations that repeat indefinitely, but
 598      * must otherwise be {@literal &gt;} 0.
 599      * &lt;p&gt;
 600      * It is not possible to change the {@code cycleCount} of a running
 601      * {@code Animation}. If the value of {@code cycleCount} is changed for a
 602      * running {@code Animation}, the animation has to be stopped and started again to pick
 603      * up the new value.
 604      *
 605      * @defaultValue 1
 606      */
 607     private IntegerProperty cycleCount;
 608     private static final int DEFAULT_CYCLE_COUNT = 1;
 609 
 610     public final void setCycleCount(int value) {
<span class="line-modified"> 611         if (cycleCount != null || value != DEFAULT_CYCLE_COUNT) {</span>
 612             cycleCountProperty().set(value);
 613         }
 614     }
 615 
 616     public final int getCycleCount() {
<span class="line-modified"> 617         return (cycleCount == null) ? DEFAULT_CYCLE_COUNT : cycleCount.get();</span>
 618     }
 619 
 620     public final IntegerProperty cycleCountProperty() {
 621         if (cycleCount == null) {
 622             cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
 623 
 624                 @Override
 625                 public void invalidated() {
 626                     updateTotalDuration();
 627                 }
 628 
 629                 @Override
 630                 public Object getBean() {
 631                     return Animation.this;
 632                 }
 633 
 634                 @Override
 635                 public String getName() {
 636                     return &quot;cycleCount&quot;;
 637                 }
</pre>
<hr />
<pre>
 642 
 643     /**
 644      * Defines whether this
 645      * {@code Animation} reverses direction on alternating cycles. If
 646      * {@code true}, the
 647      * {@code Animation} will proceed forward on the first cycle,
 648      * then reverses on the second cycle, and so on. Otherwise, animation will
 649      * loop such that each cycle proceeds forward from the start.
 650      *
 651      * It is not possible to change the {@code autoReverse} flag of a running
 652      * {@code Animation}. If the value of {@code autoReverse} is changed for a
 653      * running {@code Animation}, the animation has to be stopped and started again to pick
 654      * up the new value.
 655      *
 656      * @defaultValue false
 657      */
 658     private BooleanProperty autoReverse;
 659     private static final boolean DEFAULT_AUTO_REVERSE = false;
 660 
 661     public final void setAutoReverse(boolean value) {
<span class="line-modified"> 662         if (autoReverse != null || value != DEFAULT_AUTO_REVERSE) {</span>
 663             autoReverseProperty().set(value);
 664         }
 665     }
 666 
 667     public final boolean isAutoReverse() {
<span class="line-modified"> 668         return (autoReverse == null) ? DEFAULT_AUTO_REVERSE : autoReverse.get();</span>
 669     }
 670 
 671     public final BooleanProperty autoReverseProperty() {
 672         if (autoReverse == null) {
<span class="line-modified"> 673             autoReverse = new BooleanPropertyBase(DEFAULT_AUTO_REVERSE) {</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675                 @Override</span>
<span class="line-added"> 676                 public Object getBean() {</span>
<span class="line-added"> 677                     return Animation.this;</span>
<span class="line-added"> 678                 }</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680                 @Override</span>
<span class="line-added"> 681                 public String getName() {</span>
<span class="line-added"> 682                     return &quot;autoReverse&quot;;</span>
<span class="line-added"> 683                 }</span>
<span class="line-added"> 684             };</span>
 685         }
 686         return autoReverse;
 687     }
 688 
 689     /**
 690      * The status of the {@code Animation}.
 691      *
 692      * An {@code Animation} can be in one of three states:
 693      * {@link Status#STOPPED}, {@link Status#PAUSED} or {@link Status#RUNNING}.
 694      */
 695     private ReadOnlyObjectProperty&lt;Status&gt; status;
 696     private static final Status DEFAULT_STATUS = Status.STOPPED;
 697 
 698     protected final void setStatus(Status value) {
<span class="line-modified"> 699         if (status != null || !DEFAULT_STATUS.equals(value)) {</span>
<span class="line-modified"> 700             ((AnimationReadOnlyProperty&lt;Status&gt;) statusProperty()).set(value);</span>
 701         }
 702     }
 703 
 704     public final Status getStatus() {
<span class="line-modified"> 705         return (status == null) ? DEFAULT_STATUS : status.get();</span>
 706     }
 707 
 708     public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
 709         if (status == null) {
<span class="line-modified"> 710             status = new AnimationReadOnlyProperty&lt;&gt;(&quot;status&quot;, Status.STOPPED);</span>
 711         }
 712         return status;
 713     }
 714 
<span class="line-modified"> 715     boolean isStopped() {</span>
<span class="line-modified"> 716         return getStatus() == Status.STOPPED;</span>
<span class="line-modified"> 717     }</span>
 718 
<span class="line-modified"> 719     boolean isPaused() {</span>
<span class="line-modified"> 720         return getStatus() == Status.PAUSED;</span>
<span class="line-modified"> 721     }</span>
<span class="line-modified"> 722 </span>
<span class="line-modified"> 723     boolean isRunning() {</span>
<span class="line-modified"> 724         return getStatus() == Status.RUNNING;</span>





 725     }
 726 
 727     /**
 728      * The action to be executed at the conclusion of this {@code Animation}.
 729      *
 730      * @defaultValue null
 731      */
 732     private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
 733     private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
 734 
 735     public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
<span class="line-modified"> 736         if (onFinished != null || value != DEFAULT_ON_FINISHED) {</span>
 737             onFinishedProperty().set(value);
 738         }
 739     }
 740 
 741     public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
<span class="line-modified"> 742         return (onFinished == null) ? DEFAULT_ON_FINISHED : onFinished.get();</span>
 743     }
 744 
 745     public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
 746         if (onFinished == null) {
<span class="line-modified"> 747             onFinished = new ObjectPropertyBase&lt;&gt;(DEFAULT_ON_FINISHED) {</span>
<span class="line-added"> 748 </span>
<span class="line-added"> 749                 @Override</span>
<span class="line-added"> 750                 public Object getBean() {</span>
<span class="line-added"> 751                     return Animation.this;</span>
<span class="line-added"> 752                 }</span>
<span class="line-added"> 753 </span>
<span class="line-added"> 754                 @Override</span>
<span class="line-added"> 755                 public String getName() {</span>
<span class="line-added"> 756                     return &quot;onFinished&quot;;</span>
<span class="line-added"> 757                 }</span>
<span class="line-added"> 758             };</span>
 759         }
 760         return onFinished;
 761     }
 762 
<span class="line-modified"> 763     private ObservableMap&lt;String, Duration&gt; cuePoints;</span>

 764 
 765     /**
 766      * The cue points can be
 767      * used to mark important positions of the {@code Animation}. Once a cue
 768      * point was defined, it can be used as an argument of
 769      * {@link #jumpTo(String) jumpTo()} and {@link #playFrom(String) playFrom()}
 770      * to move to the associated position quickly.
 771      * &lt;p&gt;
 772      * Every {@code Animation} has two predefined cue points {@code &quot;start&quot;} and
 773      * {@code &quot;end&quot;}, which are set at the start respectively the end of the
 774      * {@code Animation}. The predefined cuepoints do not appear in the map,
 775      * attempts to override them have no effect.
 776      * &lt;p&gt;
 777      * Another option to define a cue point in a {@code Animation} is to set the
 778      * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
 779      *
 780      * @return {@link javafx.collections.ObservableMap} of cue points
 781      */
 782     public final ObservableMap&lt;String, Duration&gt; getCuePoints() {
<span class="line-added"> 783         if (cuePoints == null) {</span>
<span class="line-added"> 784             cuePoints = FXCollections.observableHashMap();</span>
<span class="line-added"> 785         }</span>
 786         return cuePoints;
 787     }
 788 
 789     /**
 790      * Jumps to a given position in this {@code Animation}.
 791      *
 792      * If the given time is less than {@link Duration#ZERO}, this method will
 793      * jump to the start of the animation. If the given time is larger than the
 794      * duration of this {@code Animation}, this method will jump to the end.
 795      *
 796      * @param time
 797      *            the new position
 798      * @throws NullPointerException
 799      *             if {@code time} is {@code null}
 800      * @throws IllegalArgumentException
 801      *             if {@code time} is {@link Duration#UNKNOWN}
 802      * @throws IllegalStateException
 803      *             if embedded in another animation,
 804      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 805      */
 806     public void jumpTo(Duration time) {
<span class="line-modified"> 807         Objects.requireNonNull(time, &quot;Time needs to be specified&quot;);</span>


 808         if (time.isUnknown()) {
 809             throw new IllegalArgumentException(&quot;The time is invalid&quot;);
 810         }
 811         if (parent != null) {
 812             throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
 813         }
 814 
 815         lastPlayedFinished = false;
 816 
 817         double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
 818             Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
 819         long ticks = TickCalculation.fromMillis(millis);
 820 
<span class="line-modified"> 821         if (isStopped()) {</span>
 822             syncClipEnvelope();
 823         }
 824         clipEnvelope.jumpTo(ticks);
 825     }
 826 
 827     /**
 828      * Jumps to a predefined position in this {@code Animation}. This method
 829      * looks for an entry in cue points and jumps to the associated
 830      * position, if it finds one.
 831      * &lt;p&gt;
 832      * If the cue point is behind the end of this {@code Animation}, calling
 833      * {@code jumpTo} will result in a jump to the end. If the cue point has a
 834      * negative {@link javafx.util.Duration} it will result in a jump to the
 835      * beginning. If the cue point has a value of
 836      * {@link javafx.util.Duration#UNKNOWN} calling {@code jumpTo} will have no
 837      * effect for this cue point.
 838      * &lt;p&gt;
 839      * There are two predefined cue points {@code &quot;start&quot;} and {@code &quot;end&quot;}
 840      * which are defined to be at the start respectively the end of this
 841      * {@code Animation}.
 842      *
 843      * @param cuePoint
 844      *            the name of the cue point
 845      * @throws NullPointerException
 846      *             if {@code cuePoint} is {@code null}
 847      * @throws IllegalStateException
 848      *             if embedded in another animation,
 849      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 850      * @see #getCuePoints()
 851      */
 852     public void jumpTo(String cuePoint) {
<span class="line-modified"> 853         Objects.requireNonNull(cuePoint, &quot;CuePoint needs to be specified&quot;);</span>


 854         if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
 855             jumpTo(Duration.ZERO);
 856         } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
 857             jumpTo(getTotalDuration());
 858         } else {
 859             final Duration target = getCuePoints().get(cuePoint);
 860             if (target != null) {
 861                 jumpTo(target);
 862             }
 863         }
 864     }
 865 
 866     /**
 867      * A convenience method to play this {@code Animation} from a predefined
 868      * position. The position has to be predefined in cue points.
 869      * Calling this method is equivalent to
 870      *
 871      * &lt;pre&gt;
 872      * &lt;code&gt;
 873      * animation.jumpTo(cuePoint);
</pre>
<hr />
<pre>
 904      * &lt;/pre&gt;
 905      *
 906      * Note that unlike {@link #playFromStart()} calling this method will not
 907      * change the playing direction of this {@code Animation}.
 908      *
 909      * @param time
 910      *            position where to play from
 911      * @throws NullPointerException
 912      *             if {@code time} is {@code null}
 913      * @throws IllegalArgumentException
 914      *             if {@code time} is {@link Duration#UNKNOWN}
 915      * @throws IllegalStateException
 916      *             if embedded in another animation,
 917      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 918      */
 919     public void playFrom(Duration time) {
 920         jumpTo(time);
 921         play();
 922     }
 923 
<span class="line-added"> 924     /**</span>
<span class="line-added"> 925      * Plays an {@code Animation} from initial position in forward direction.</span>
<span class="line-added"> 926      * &lt;p&gt;</span>
<span class="line-added"> 927      * It is equivalent to</span>
<span class="line-added"> 928      * &lt;p&gt;</span>
<span class="line-added"> 929      * &lt;code&gt;</span>
<span class="line-added"> 930      *      animation.stop();&lt;br&gt;</span>
<span class="line-added"> 931      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;</span>
<span class="line-added"> 932      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;</span>
<span class="line-added"> 933      *      animation.play();&lt;br&gt;</span>
<span class="line-added"> 934      *  &lt;/code&gt;</span>
<span class="line-added"> 935      *</span>
<span class="line-added"> 936      * &lt;p&gt;</span>
<span class="line-added"> 937      * Note: &lt;ul&gt;</span>
<span class="line-added"> 938      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may</span>
<span class="line-added"> 939      * not start immediately. &lt;/ul&gt;</span>
<span class="line-added"> 940      *</span>
<span class="line-added"> 941      * @throws IllegalStateException</span>
<span class="line-added"> 942      *             if embedded in another animation,</span>
<span class="line-added"> 943      *                such as {@link SequentialTransition} or {@link ParallelTransition}</span>
<span class="line-added"> 944      */</span>
<span class="line-added"> 945     public void playFromStart() {</span>
<span class="line-added"> 946         stop();</span>
<span class="line-added"> 947         setRate(Math.abs(getRate()));</span>
<span class="line-added"> 948         jumpTo(Duration.ZERO);</span>
<span class="line-added"> 949         play();</span>
<span class="line-added"> 950     }</span>
<span class="line-added"> 951 </span>
 952     /**
 953      * Plays {@code Animation} from current position in the direction indicated
 954      * by {@code rate}. If the {@code Animation} is running, it has no effect.
 955      * &lt;p&gt;
 956      * When {@code rate} {@literal &gt;} 0 (forward play), if an {@code Animation} is already
 957      * positioned at the end, the first cycle will not be played, it is
 958      * considered to have already finished. This also applies to a backward (
 959      * {@code rate} {@literal &lt;} 0) cycle if an {@code Animation} is positioned at the beginning.
 960      * However, if the {@code Animation} has {@code cycleCount} {@literal &gt;} 1, following
 961      * cycle(s) will be played as usual.
 962      * &lt;p&gt;
 963      * When the {@code Animation} reaches the end, the {@code Animation} is stopped and
 964      * the play head remains at the end.
 965      * &lt;p&gt;
 966      * To play an {@code Animation} backwards from the end:&lt;br&gt;
 967      * &lt;code&gt;
 968      *  animation.setRate(negative rate);&lt;br&gt;
 969      *  animation.jumpTo(overall duration of animation);&lt;br&gt;
 970      *  animation.play();&lt;br&gt;
 971      * &lt;/code&gt;
 972      * &lt;p&gt;
 973      * Note: &lt;ul&gt;
 974      * &lt;li&gt;{@code play()} is an asynchronous call, the {@code Animation} may not
 975      * start immediately. &lt;/ul&gt;
 976      *
 977      * @throws IllegalStateException
 978      *             if embedded in another animation,
 979      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 980      */
 981     public void play() {
 982         if (parent != null) {
 983             throw new IllegalStateException(&quot;Cannot start when embedded in another animation&quot;);
 984         }
 985         switch (getStatus()) {
 986             case STOPPED:
 987                 if (startable(true)) {
 988                     final double rate = getRate();
 989                     if (lastPlayedFinished) {
<span class="line-modified"> 990                         jumpTo(rate &lt; 0 ? getTotalDuration() : Duration.ZERO);</span>
 991                     }
 992                     doStart(true);
 993                     startReceiver(TickCalculation.fromDuration(getDelay()));
<span class="line-modified"> 994                     if (isNearZero(rate)) {</span>
 995                         pauseReceiver();
 996                     } else {
 997 
 998                     }
 999                 } else {
<span class="line-modified">1000                     runHandler(getOnFinished());</span>



1001                 }
1002                 break;
1003             case PAUSED:
1004                 doResume();
<span class="line-modified">1005                 if (!isNearZero(getRate())) {</span>
1006                     resumeReceiver();
1007                 }
1008                 break;
<span class="line-added">1009             case RUNNING: // no-op</span>
1010         }
1011     }
1012 
<span class="line-modified">1013     void doStart(boolean forceSync) {</span>
<span class="line-modified">1014         sync(forceSync);</span>
<span class="line-modified">1015         setStatus(Status.RUNNING);</span>
<span class="line-modified">1016         clipEnvelope.start();</span>
<span class="line-modified">1017         doSetCurrentRate(clipEnvelope.getCurrentRate());</span>
<span class="line-modified">1018         lastPulse = 0;</span>
<span class="line-modified">1019     }</span>
<span class="line-modified">1020 </span>
<span class="line-modified">1021     void doResume() {</span>
<span class="line-modified">1022         setStatus(Status.RUNNING);</span>
<span class="line-modified">1023         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());</span>















1024     }
1025 
1026     /**
1027      * Stops the animation and resets the play head to its initial position. If
1028      * the animation is already stopped, this method has no effect.
1029      * &lt;p&gt;
1030      * Note: &lt;ul&gt;
1031      * &lt;li&gt;{@code stop()} is an asynchronous call, the {@code Animation} may not stop
1032      * immediately. &lt;/ul&gt;
1033      * @throws IllegalStateException
1034      *             if embedded in another animation,
1035      *                such as {@link SequentialTransition} or {@link ParallelTransition}
1036      */
1037     public void stop() {
1038         if (parent != null) {
1039             throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
1040         }
<span class="line-modified">1041         if (!isStopped()) {</span>
1042             clipEnvelope.abortCurrentPulse();
1043             doStop();
1044             jumpTo(Duration.ZERO);
1045             lastPlayedFinished = true;
1046         }
1047     }
1048 
<span class="line-added">1049     void doStop() {</span>
<span class="line-added">1050         if (!paused) {</span>
<span class="line-added">1051             timer.removePulseReceiver(pulseReceiver);</span>
<span class="line-added">1052         }</span>
<span class="line-added">1053         setStatus(Status.STOPPED);</span>
<span class="line-added">1054         doSetCurrentRate(0.0);</span>
<span class="line-added">1055     }</span>
<span class="line-added">1056 </span>
1057     /**
1058      * Pauses the animation. If the animation is not currently running, this
1059      * method has no effect.
1060      * &lt;p&gt;
1061      * Note: &lt;ul&gt;
1062      * &lt;li&gt;{@code pause()} is an asynchronous call, the {@code Animation} may not pause
1063      * immediately. &lt;/ul&gt;
1064      * @throws IllegalStateException
1065      *             if embedded in another animation,
1066      *                such as {@link SequentialTransition} or {@link ParallelTransition}
1067      */
1068     public void pause() {
1069         if (parent != null) {
1070             throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
1071         }
<span class="line-modified">1072         if (isRunning()) {</span>
1073             clipEnvelope.abortCurrentPulse();
1074             pauseReceiver();
1075             doPause();
1076         }
1077     }
1078 
<span class="line-added">1079     void doPause() {</span>
<span class="line-added">1080         final double currentRate = getCurrentRate();</span>
<span class="line-added">1081         if (!isNearZero(currentRate)) {</span>
<span class="line-added">1082             lastPlayedForward = areNearEqual(getCurrentRate(), getRate());</span>
<span class="line-added">1083         }</span>
<span class="line-added">1084         doSetCurrentRate(0.0);</span>
<span class="line-added">1085         setStatus(Status.PAUSED);</span>
<span class="line-added">1086     }</span>
<span class="line-added">1087 </span>
<span class="line-added">1088     final void finished() {</span>
<span class="line-added">1089         lastPlayedFinished = true;</span>
<span class="line-added">1090         doStop();</span>
<span class="line-added">1091         runHandler(getOnFinished());</span>
<span class="line-added">1092     }</span>
<span class="line-added">1093 </span>
<span class="line-added">1094     void runHandler(EventHandler&lt;ActionEvent&gt; handler) {</span>
<span class="line-added">1095         if (handler != null) {</span>
<span class="line-added">1096             try {</span>
<span class="line-added">1097                 handler.handle(new ActionEvent(this, null));</span>
<span class="line-added">1098             } catch (Exception ex) {</span>
<span class="line-added">1099                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);</span>
<span class="line-added">1100             }</span>
<span class="line-added">1101         }</span>
<span class="line-added">1102     }</span>
<span class="line-added">1103 </span>
<span class="line-added">1104     private final double targetFramerate;</span>
<span class="line-added">1105     private final int resolution;</span>
<span class="line-added">1106     private long lastPulse;</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     /**</span>
<span class="line-added">1109      * The target framerate is the maximum framerate at which this {@code Animation}</span>
<span class="line-added">1110      * will run, in frames per second. This can be used, for example, to keep</span>
<span class="line-added">1111      * particularly complex {@code Animations} from over-consuming system resources.</span>
<span class="line-added">1112      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning</span>
<span class="line-added">1113      * the {@code Animation} will run at an optimal framerate for the underlying platform.</span>
<span class="line-added">1114      *</span>
<span class="line-added">1115      * @return the target framerate</span>
<span class="line-added">1116      */</span>
<span class="line-added">1117     public final double getTargetFramerate() {</span>
<span class="line-added">1118         return targetFramerate;</span>
<span class="line-added">1119     }</span>
<span class="line-added">1120 </span>
1121     /**
1122      * The constructor of {@code Animation}.
1123      *
1124      * This constructor allows to define a target framerate.
1125      *
1126      * @param targetFramerate
1127      *            The custom target frame rate for this {@code Animation}
1128      * @see #getTargetFramerate()
1129      */
1130     protected Animation(double targetFramerate) {
1131         this.targetFramerate = targetFramerate;
1132         this.resolution = (int) Math.max(1, Math.round(TickCalculation.TICKS_PER_SECOND / targetFramerate));
1133         this.clipEnvelope = ClipEnvelope.create(this);
1134         this.timer = Toolkit.getToolkit().getMasterTimer();
1135     }
1136 
1137     /**
1138      * The constructor of {@code Animation}.
1139      */
1140     protected Animation() {
</pre>
<hr />
<pre>
1144         this.timer = Toolkit.getToolkit().getMasterTimer();
1145     }
1146 
1147     // These constructors are only for testing purposes
1148     Animation(AbstractMasterTimer timer) {
1149         this.resolution = 1;
1150         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / timer.getDefaultResolution();
1151         this.clipEnvelope = ClipEnvelope.create(this);
1152         this.timer = timer;
1153     }
1154 
1155     // These constructors are only for testing purposes
1156     Animation(AbstractMasterTimer timer, ClipEnvelope clipEnvelope, int resolution) {
1157         this.resolution = resolution;
1158         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / resolution;
1159         this.clipEnvelope = clipEnvelope;
1160         this.timer = timer;
1161     }
1162 
1163     boolean startable(boolean forceSync) {
<span class="line-modified">1164         return (TickCalculation.fromDuration(getCycleDuration()) &gt; 0L) || (!forceSync &amp;&amp; clipEnvelope.wasSynched());</span>

1165     }
1166 
1167     void sync(boolean forceSync) {
1168         if (forceSync || !clipEnvelope.wasSynched()) {
1169             syncClipEnvelope();
1170         }
1171     }
1172 
1173     private void syncClipEnvelope() {
1174         final int publicCycleCount = getCycleCount();
1175         final int internalCycleCount = (publicCycleCount &lt;= 0)
1176                 &amp;&amp; (publicCycleCount != INDEFINITE) ? 1 : publicCycleCount;
1177         clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
1178         clipEnvelope.setCycleDuration(getCycleDuration());
1179         clipEnvelope.setAutoReverse(isAutoReverse());
1180     }
1181 






























1182     void doTimePulse(long elapsedTime) {
1183         if (resolution == 1) { // fullspeed
1184             clipEnvelope.timePulse(elapsedTime);
1185         } else if (elapsedTime - lastPulse &gt;= resolution) {
1186             lastPulse = (elapsedTime / resolution) * resolution;
1187             clipEnvelope.timePulse(elapsedTime);
1188         }
1189     }
1190 
1191     abstract void doPlayTo(long currentTicks, long cycleTicks);
1192 
1193     abstract void doJumpTo(long currentTicks, long cycleTicks, boolean forceJump);
1194 
1195     void setCurrentTicks(long ticks) {
1196         currentTicks = ticks;
1197         if (currentTime != null) {
1198             currentTime.fireValueChangedEvent();
1199         }
1200     }



















1201 }
</pre>
</td>
</tr>
</table>
<center><a href="../../com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../test/java/test/javafx/animation/AnimationTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
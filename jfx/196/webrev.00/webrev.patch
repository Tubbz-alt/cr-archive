diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/animation/TickCalculation.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/animation/TickCalculation.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/animation/TickCalculation.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/animation/TickCalculation.java
@@ -27,12 +27,12 @@
 
 import javafx.util.Duration;
 
 public class TickCalculation {
     public static final int TICKS_PER_SECOND = 6000;
-    private static final double TICKS_PER_MILI = TICKS_PER_SECOND / 1000.0;
-    private static final double TICKS_PER_NANO =  TICKS_PER_MILI * 1e-6;
+    private static final double TICKS_PER_MILLI = TICKS_PER_SECOND / 1000.0;
+    private static final double TICKS_PER_NANO =  TICKS_PER_MILLI * 1e-6;
 
     private TickCalculation() {}
 
     public static long add(long op1, long op2) {
         assert (op1 >= 0);
@@ -69,11 +69,11 @@
         }
 
     }
 
     public static long fromMillis(double millis) {
-        return Math.round(TICKS_PER_MILI * millis);
+        return Math.round(TICKS_PER_MILLI * millis);
     }
 
     public static long fromNano(long nano) {
         return Math.round(TICKS_PER_NANO * nano);
     }
@@ -81,18 +81,18 @@
     public static long fromDuration(Duration duration) {
         return fromMillis(duration.toMillis());
     }
 
     public static long fromDuration(Duration duration, double rate) {
-        return Math.round(TICKS_PER_MILI * duration.toMillis() / Math.abs(rate));
+        return Math.round(TICKS_PER_MILLI * duration.toMillis() / Math.abs(rate));
     }
 
     public static Duration toDuration(long ticks) {
         return Duration.millis(toMillis(ticks));
     }
 
     public static double toMillis(long ticks) {
-        return ticks / TICKS_PER_MILI;
+        return ticks / TICKS_PER_MILLI;
     }
 
 
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/javafx/util/Utils.java b/modules/javafx.graphics/src/main/java/com/sun/javafx/util/Utils.java
--- a/modules/javafx.graphics/src/main/java/com/sun/javafx/util/Utils.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/javafx/util/Utils.java
@@ -88,10 +88,20 @@
         if (value < min) return min;
         if (value > max) return max;
         return value;
     }
 
+    /**
+     * Simple utility function which clamps the given value to be strictly
+     * between the min and max values.
+     */
+    public static long clamp(long min, long value, long max) {
+        if (value < min) return min;
+        if (value > max) return max;
+        return value;
+    }
+
     /**
      * Simple utility function which clamps the given value to be strictly
      * above the min value.
      */
     public static double clampMin(double value, double min) {
diff a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/ClipEnvelope.java b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/ClipEnvelope.java
--- a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/ClipEnvelope.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/ClipEnvelope.java
@@ -41,32 +41,42 @@
  * Both classes have an abstract public definition and can only be created using
  * the factory method create(). The intent is to provide a general
  * implementation plus eventually some fast-track implementations for common use
  * cases.
  */
-
 public abstract class ClipEnvelope {
 
     protected static final long INDEFINITE = Long.MAX_VALUE;
     protected static final double EPSILON = 1e-12;
 
     protected Animation animation;
+
+    /**
+     * The rate of the animation that is used to calculate the current rate of an animation.
+     * It is the same as animation.rate, only ignores animation.rate = 0, so can never be 0.
+     */
     protected double rate = 1;
+
+    /**
+     * The number of ticks in a single cycle. Calculated from the cycle duration. Always >=0.
+     */
     protected long cycleTicks = 0;
 
-    // internal state-variables used by all implementations
     protected long deltaTicks = 0;
+
+    /**
+     * The current position of the play head. 0 <= ticks <= totalTicks
+     */
     protected long ticks = 0;
     protected double currentRate = rate;
     protected boolean inTimePulse = false;
     protected boolean aborted = false;
 
     protected ClipEnvelope(Animation animation) {
         this.animation = animation;
         if (animation != null) {
-            final Duration cycleDuration = animation.getCycleDuration();
-            cycleTicks = TickCalculation.fromDuration(cycleDuration);
+            cycleTicks = TickCalculation.fromDuration(animation.getCycleDuration());
             rate = animation.getRate();
         }
     }
 
     public static ClipEnvelope create(Animation animation) {
@@ -77,14 +87,33 @@
         } else {
             return new FiniteClipEnvelope(animation);
         }
     }
 
-    public abstract ClipEnvelope setCycleDuration(Duration cycleDuration);
-    public abstract void setRate(double rate);
     public abstract void setAutoReverse(boolean autoReverse);
+    public abstract ClipEnvelope setCycleDuration(Duration cycleDuration);
     public abstract ClipEnvelope setCycleCount(int cycleCount);
+    public abstract void setRate(double rate);
+
+    protected abstract double calculateCurrentRate();
+
+    protected void setInternalCurrentRate(double currentRate) {
+        this.currentRate = currentRate;
+    }
+
+    protected void setCurrentRate(double currentRate) {
+        this.currentRate = currentRate;
+        AnimationAccessor.getDefault().setCurrentRate(animation, currentRate);
+    }
+
+    public double getCurrentRate() {
+        return currentRate;
+    }
+
+    protected long ticksRateChange(double newRate) {
+        return Math.round((ticks - deltaTicks) * newRate / rate);
+     }
 
     protected void updateCycleTicks(Duration cycleDuration) {
         cycleTicks = TickCalculation.fromDuration(cycleDuration);
     }
 
@@ -99,31 +128,12 @@
 
     public abstract void timePulse(long currentTick);
 
     public abstract void jumpTo(long ticks);
 
-    public void abortCurrentPulse() {
+    public final void abortCurrentPulse() {
         if (inTimePulse) {
             aborted = true;
             inTimePulse = false;
         }
     }
-
-    protected abstract double calculateCurrentRate();
-
-    protected void setInternalCurrentRate(double currentRate) {
-        this.currentRate = currentRate;
-    }
-
-    protected void setCurrentRate(double currentRate) {
-        this.currentRate = currentRate;
-        AnimationAccessor.getDefault().setCurrentRate(animation, currentRate);
-    }
-
-    protected static long checkBounds(long value, long max) {
-        return Math.max(0L, Math.min(value, max));
-    }
-
-    public double getCurrentRate() {
-        return currentRate;
-    }
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/FiniteClipEnvelope.java b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/FiniteClipEnvelope.java
--- a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/FiniteClipEnvelope.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/FiniteClipEnvelope.java
@@ -23,41 +23,33 @@
  * questions.
  */
 
 package com.sun.scenario.animation.shared;
 
+import com.sun.javafx.util.Utils;
+
 import javafx.animation.Animation;
 import javafx.animation.Animation.Status;
 import javafx.util.Duration;
 
-public class FiniteClipEnvelope extends ClipEnvelope {
+/**
+ * Clip envelope implementation for multi-cycles: cycleCount != (1 or indefinite) and cycleDuration != indefinite
+ */
+public class FiniteClipEnvelope extends MultiLoopClipEnvelope {
 
-    private boolean autoReverse;
     private int cycleCount;
     private long totalTicks;
-    private long pos;
 
     protected FiniteClipEnvelope(Animation animation) {
         super(animation);
         if (animation != null) {
             autoReverse = animation.isAutoReverse();
             cycleCount = animation.getCycleCount();
         }
         updateTotalTicks();
     }
 
-    @Override
-    public void setAutoReverse(boolean autoReverse) {
-        this.autoReverse = autoReverse;
-    }
-
-    @Override
-    protected double calculateCurrentRate() {
-        return !autoReverse? rate
-                : (ticks % (2 * cycleTicks) < cycleTicks) == (rate > 0)? rate : -rate;
-    }
-
     @Override
     public ClipEnvelope setCycleDuration(Duration cycleDuration) {
         if (cycleDuration.isIndefinite()) {
             return create(animation);
         }
@@ -75,21 +67,27 @@
         updateTotalTicks();
         return this;
     }
 
     @Override
-    public void setRate(double rate) {
-        final boolean toggled = rate * this.rate < 0;
-        final long newTicks = toggled? totalTicks - ticks : ticks;
+    public void setRate(double newRate) {
+        final boolean toggled = changedDirection(newRate);
+        final long newTicks = toggled ? totalTicks - ticks : ticks;
         final Status status = animation.getStatus();
         if (status != Status.STOPPED) {
-            setInternalCurrentRate((Math.abs(currentRate - this.rate) < EPSILON) ? rate : -rate);
-            deltaTicks = newTicks - Math.round((ticks - deltaTicks) * Math.abs(rate / this.rate));
+            setInternalCurrentRate((Math.abs(currentRate - rate) < EPSILON) ? newRate : -newRate);
+            deltaTicks = newTicks - ticksRateChange(newRate);
             abortCurrentPulse();
         }
         ticks = newTicks;
-        this.rate = rate;
+        rate = newRate;
+    }
+
+    @Override
+    protected double calculateCurrentRate() {
+        return !autoReverse ? rate
+                : isDuringEvenCycle() == (rate > 0) ? rate : -rate;
     }
 
     private void updateTotalTicks() {
         totalTicks = cycleCount * cycleTicks;
     }
@@ -102,45 +100,46 @@
         aborted = false;
         inTimePulse = true;
 
         try {
             final long oldTicks = ticks;
-            ticks = ClipEnvelope.checkBounds(deltaTicks + Math.round(currentTick * Math.abs(rate)), totalTicks);
+            long ticksChange = Math.round(currentTick * Math.abs(rate));
+            ticks = Utils.clamp(0, deltaTicks + ticksChange, totalTicks);
 
             final boolean reachedEnd = ticks >= totalTicks;
 
             long overallDelta = ticks - oldTicks; // overall delta between current position and new position
             if (overallDelta == 0) {
                 return;
             }
 
-            long cycleDelta = (currentRate > 0)? cycleTicks - pos : pos; // delta to reach end of cycle
+            long cycleDelta = (currentRate > 0) ? cycleTicks - cyclePos : cyclePos; // delta to reach end of cycle
 
             while (overallDelta >= cycleDelta) {
                 if (cycleDelta > 0) {
-                    pos = (currentRate > 0)? cycleTicks : 0;
+                    cyclePos = (currentRate > 0)? cycleTicks : 0;
                     overallDelta -= cycleDelta;
-                    AnimationAccessor.getDefault().playTo(animation, pos, cycleTicks);
+                    AnimationAccessor.getDefault().playTo(animation, cyclePos, cycleTicks);
                     if (aborted) {
                         return;
                     }
                 }
 
                 if (!reachedEnd || (overallDelta > 0)) {
                     if (autoReverse) {
                         setCurrentRate(-currentRate);
                     } else {
-                        pos = (currentRate > 0)? 0 : cycleTicks;
-                        AnimationAccessor.getDefault().jumpTo(animation, pos, cycleTicks, false);
+                        cyclePos = (currentRate > 0)? 0 : cycleTicks;
+                        AnimationAccessor.getDefault().jumpTo(animation, cyclePos, cycleTicks, false);
                     }
                 }
                 cycleDelta = cycleTicks;
             }
 
             if (overallDelta > 0 && !reachedEnd) {
-                pos += (currentRate > 0)? overallDelta : -overallDelta;
-                AnimationAccessor.getDefault().playTo(animation, pos, cycleTicks);
+                cyclePos += (currentRate > 0) ? overallDelta : -overallDelta;
+                AnimationAccessor.getDefault().playTo(animation, cyclePos, cycleTicks);
             }
 
             if(reachedEnd && !aborted) {
                 AnimationAccessor.getDefault().finished(animation);
             }
@@ -158,38 +157,37 @@
 
         final long oldTicks = ticks;
         if (rate < 0) {
             newTicks = totalTicks - newTicks;
         }
-        ticks = ClipEnvelope.checkBounds(newTicks, totalTicks);
+        ticks = Utils.clamp(0, newTicks, totalTicks);
         final long delta = ticks - oldTicks;
         if (delta != 0) {
             deltaTicks += delta;
             if (autoReverse) {
                 final boolean forward = ticks % (2 * cycleTicks) < cycleTicks;
                 if (forward == (rate > 0)) {
-                    pos = ticks % cycleTicks;
+                    cyclePos = ticks % cycleTicks;
                     if (animation.getStatus() == Status.RUNNING) {
                         setCurrentRate(Math.abs(rate));
                     }
                 } else {
-                    pos = cycleTicks - (ticks % cycleTicks);
+                    cyclePos = cycleTicks - (ticks % cycleTicks);
                     if (animation.getStatus() == Status.RUNNING) {
                         setCurrentRate(-Math.abs(rate));
                     }
                 }
             } else {
-                pos = ticks % cycleTicks;
+                cyclePos = ticks % cycleTicks;
                 if (rate < 0) {
-                    pos = cycleTicks - pos;
+                    cyclePos = cycleTicks - cyclePos;
                 }
-                if ((pos == 0) && (ticks > 0)) {
-                    pos = cycleTicks;
+                if ((cyclePos == 0) && (ticks > 0)) {
+                    cyclePos = cycleTicks;
                 }
             }
 
-            AnimationAccessor.getDefault().jumpTo(animation, pos, cycleTicks, false);
+            AnimationAccessor.getDefault().jumpTo(animation, cyclePos, cycleTicks, false);
             abortCurrentPulse();
         }
     }
-
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/InfiniteClipEnvelope.java b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/InfiniteClipEnvelope.java
--- a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/InfiniteClipEnvelope.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/InfiniteClipEnvelope.java
@@ -27,33 +27,22 @@
 
 import javafx.animation.Animation;
 import javafx.animation.Animation.Status;
 import javafx.util.Duration;
 
-public class InfiniteClipEnvelope extends ClipEnvelope {
-
-    private boolean autoReverse;
-    private long pos;
+/**
+ * Clip envelope implementation for infinite cycles: cycleCount = indefinite
+ */
+public class InfiniteClipEnvelope extends MultiLoopClipEnvelope {
 
     protected InfiniteClipEnvelope(Animation animation) {
         super(animation);
         if (animation != null) {
             autoReverse = animation.isAutoReverse();
         }
     }
 
-    @Override
-    public void setAutoReverse(boolean autoReverse) {
-        this.autoReverse = autoReverse;
-    }
-
-    @Override
-    protected double calculateCurrentRate() {
-        return !autoReverse? rate
-                : (ticks % (2 * cycleTicks) < cycleTicks)? rate : -rate;
-    }
-
     @Override
     public ClipEnvelope setCycleDuration(Duration cycleDuration) {
         if (cycleDuration.isIndefinite()) {
             return create(animation);
         }
@@ -61,27 +50,33 @@
         return this;
     }
 
     @Override
     public ClipEnvelope setCycleCount(int cycleCount) {
-       return (cycleCount != Animation.INDEFINITE)? create(animation) : this;
+       return (cycleCount != Animation.INDEFINITE) ? create(animation) : this;
     }
 
     @Override
-    public void setRate(double rate) {
+    public void setRate(double newRate) {
         final Status status = animation.getStatus();
         if (status != Status.STOPPED) {
-            setInternalCurrentRate((Math.abs(currentRate - this.rate) < EPSILON) ? rate : -rate);
-            deltaTicks = ticks - Math.round((ticks - deltaTicks) * Math.abs(rate / this.rate));
-            if (rate * this.rate < 0) {
-                final long delta = 2 * cycleTicks - pos;
+            setInternalCurrentRate((Math.abs(currentRate - rate) < EPSILON) ? newRate : -newRate);
+            deltaTicks = ticks - ticksRateChange(newRate);
+            if (changedDirection(newRate)) {
+                final long delta = 2 * cycleTicks - cyclePos;
                 deltaTicks += delta;
                 ticks += delta;
             }
             abortCurrentPulse();
         }
-        this.rate = rate;
+        rate = newRate;
+    }
+
+    @Override
+    protected double calculateCurrentRate() {
+        return !autoReverse ? rate
+                : isDuringEvenCycle() ? rate : -rate;
     }
 
     @Override
     public void timePulse(long currentTick) {
         if (cycleTicks == 0L) {
@@ -90,40 +85,41 @@
         aborted = false;
         inTimePulse = true;
 
         try {
             final long oldTicks = ticks;
-            ticks = Math.max(0, deltaTicks + Math.round(currentTick * Math.abs(rate)));
+            long ticksChange = Math.round(currentTick * Math.abs(rate));
+            ticks = Math.max(0, deltaTicks + ticksChange);
 
             long overallDelta = ticks - oldTicks; // overall delta between current position and new position
             if (overallDelta == 0) {
                 return;
             }
 
-            long cycleDelta = (currentRate > 0)? cycleTicks - pos : pos; // delta to reach end of cycle
+            long cycleDelta = (currentRate > 0) ? cycleTicks - cyclePos : cyclePos; // delta to reach end of cycle
 
             while (overallDelta >= cycleDelta) {
                 if (cycleDelta > 0) {
-                    pos = (currentRate > 0)? cycleTicks : 0;
+                    cyclePos = (currentRate > 0) ? cycleTicks : 0;
                     overallDelta -= cycleDelta;
-                    AnimationAccessor.getDefault().playTo(animation, pos, cycleTicks);
+                    AnimationAccessor.getDefault().playTo(animation, cyclePos, cycleTicks);
                     if (aborted) {
                         return;
                     }
                 }
                 if (autoReverse) {
                     setCurrentRate(-currentRate);
                 } else {
-                    pos = (currentRate > 0)? 0 : cycleTicks;
-                    AnimationAccessor.getDefault().jumpTo(animation, pos, cycleTicks, false);
+                    cyclePos = (currentRate > 0) ? 0 : cycleTicks;
+                    AnimationAccessor.getDefault().jumpTo(animation, cyclePos, cycleTicks, false);
                 }
                 cycleDelta = cycleTicks;
             }
 
             if (overallDelta > 0) {
-                pos += (currentRate > 0)? overallDelta : -overallDelta;
-                AnimationAccessor.getDefault().playTo(animation, pos, cycleTicks);
+                cyclePos += (currentRate > 0) ? overallDelta : -overallDelta;
+                AnimationAccessor.getDefault().playTo(animation, cyclePos, cycleTicks);
             }
 
         } finally {
             inTimePulse = false;
         }
@@ -139,27 +135,27 @@
         final long delta = ticks - oldTicks;
         if (delta != 0) {
             deltaTicks += delta;
             if (autoReverse) {
                 if (ticks > cycleTicks) {
-                    pos = 2 * cycleTicks - ticks;
+                    cyclePos = 2 * cycleTicks - ticks;
                     if (animation.getStatus() == Status.RUNNING) {
                         setCurrentRate(-rate);
                     }
                 } else {
-                    pos = ticks;
+                    cyclePos = ticks;
                     if (animation.getStatus() == Status.RUNNING) {
                         setCurrentRate(rate);
                     }
                 }
             } else {
-                pos = ticks % cycleTicks;
-                if (pos == 0) {
-                    pos = ticks;
+                cyclePos = ticks % cycleTicks;
+                if (cyclePos == 0) {
+                    cyclePos = ticks;
                 }
             }
-            AnimationAccessor.getDefault().jumpTo(animation, pos, cycleTicks, false);
+            AnimationAccessor.getDefault().jumpTo(animation, cyclePos, cycleTicks, false);
             abortCurrentPulse();
         }
     }
 
 }
diff a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/MultiLoopClipEnvelope.java b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/MultiLoopClipEnvelope.java
--- /dev/null
+++ b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/MultiLoopClipEnvelope.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.scenario.animation.shared;
+
+import javafx.animation.Animation;
+
+/**
+ * Clip envelope for multi-cycle animations. In this case, autoReverse and cyclePosition (which can be different from ticks)
+ * are important.
+ */
+abstract class MultiLoopClipEnvelope extends ClipEnvelope {
+
+    protected boolean autoReverse;
+
+    /**
+     * The current position of the play head in its current cycle.
+     * cyclePos = ticks % cycleTicks, so 0 <= cyclePos <= cycleTicks.
+     */
+    protected long cyclePos;
+
+    protected MultiLoopClipEnvelope(Animation animation) {
+        super(animation);
+    }
+
+    protected boolean autoReverse() {
+        return autoReverse;
+    }
+
+    @Override
+    public void setAutoReverse(boolean autoReverse) {
+        this.autoReverse = autoReverse;
+    }
+
+    protected long ticksRateChange(double newRate) {
+        return Math.round((ticks - deltaTicks) * Math.abs(newRate / rate));
+     }
+
+    protected boolean changedDirection(double newRate) {
+        return newRate * rate < 0;
+    }
+
+    protected boolean isDuringEvenCycle() {
+        return ticks % (2 * cycleTicks) < cycleTicks;
+    }
+}
diff a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java
--- a/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/scenario/animation/shared/SingleLoopClipEnvelope.java
@@ -23,49 +23,33 @@
  * questions.
  */
 
 package com.sun.scenario.animation.shared;
 
+import com.sun.javafx.util.Utils;
+
 import javafx.animation.Animation;
 import javafx.animation.Animation.Status;
 import javafx.util.Duration;
 
+/**
+ * Clip envelope implementation for a single cycle: cycleCount = 1 or cycleDuration = indefinite
+ */
 public class SingleLoopClipEnvelope extends ClipEnvelope {
 
     private int cycleCount;
 
-    @Override
-    public void setRate(double rate) {
-        final Status status = animation.getStatus();
-        if (status != Status.STOPPED) {
-            setInternalCurrentRate((Math.abs(currentRate - this.rate) < EPSILON) ? rate : -rate);
-            deltaTicks = ticks - Math.round((ticks - deltaTicks) * rate / this.rate);
-            abortCurrentPulse();
-        }
-        this.rate = rate;
-    }
-
-    @Override
-    public void setAutoReverse(boolean autoReverse) {
-        // ignore autoReverse
-    }
-
-    @Override
-    protected double calculateCurrentRate() {
-        return rate;
-    }
-
     protected SingleLoopClipEnvelope(Animation animation) {
         super(animation);
         if (animation != null) {
             cycleCount = animation.getCycleCount();
         }
     }
 
     @Override
-    public boolean wasSynched() {
-        return super.wasSynched() && cycleCount != 0;
+    public void setAutoReverse(boolean autoReverse) {
+        // ignore autoReverse
     }
 
     @Override
     public ClipEnvelope setCycleDuration(Duration cycleDuration) {
         if ((cycleCount != 1) && !cycleDuration.isIndefinite()) {
@@ -82,20 +66,42 @@
         }
         this.cycleCount = cycleCount;
         return this;
     }
 
+    @Override
+    public void setRate(double newRate) {
+        final Status status = animation.getStatus();
+        if (status != Status.STOPPED) {
+            setInternalCurrentRate((Math.abs(currentRate - rate) < EPSILON) ? newRate : -newRate);
+            deltaTicks = ticks - ticksRateChange(newRate);
+            abortCurrentPulse();
+        }
+        rate = newRate;
+    }
+
+    @Override
+    protected double calculateCurrentRate() {
+        return rate;
+    }
+
+    @Override
+    public boolean wasSynched() {
+        return super.wasSynched() && cycleCount != 0;
+    }
+
     @Override
     public void timePulse(long currentTick) {
         if (cycleTicks == 0L) {
             return;
         }
         aborted = false;
         inTimePulse = true;
 
         try {
-            ticks = ClipEnvelope.checkBounds(deltaTicks + Math.round(currentTick * currentRate), cycleTicks);
+            long ticksChange = Math.round(currentTick * currentRate);
+            ticks = Utils.clamp(0, deltaTicks + ticksChange, cycleTicks);
             AnimationAccessor.getDefault().playTo(animation, ticks, cycleTicks);
 
             final boolean reachedEnd = (currentRate > 0)? (ticks == cycleTicks) : (ticks == 0);
             if(reachedEnd && !aborted) {
                 AnimationAccessor.getDefault().finished(animation);
@@ -108,11 +114,11 @@
     @Override
     public void jumpTo(long ticks) {
         if (cycleTicks == 0L) {
             return;
         }
-        final long newTicks = ClipEnvelope.checkBounds(ticks, cycleTicks);
+        final long newTicks = Utils.clamp(0, ticks, cycleTicks);
         deltaTicks += (newTicks - this.ticks);
         this.ticks = newTicks;
 
         AnimationAccessor.getDefault().jumpTo(animation, newTicks, cycleTicks, false);
 
diff a/modules/javafx.graphics/src/main/java/javafx/animation/Animation.java b/modules/javafx.graphics/src/main/java/javafx/animation/Animation.java
--- a/modules/javafx.graphics/src/main/java/javafx/animation/Animation.java
+++ b/modules/javafx.graphics/src/main/java/javafx/animation/Animation.java
@@ -23,39 +23,37 @@
  * questions.
  */
 
 package javafx.animation;
 
-import java.util.HashMap;
+import java.util.Objects;
 
 import com.sun.javafx.tk.Toolkit;
 import com.sun.javafx.util.Utils;
 
 import javafx.beans.property.BooleanProperty;
+import javafx.beans.property.BooleanPropertyBase;
 import javafx.beans.property.DoubleProperty;
 import javafx.beans.property.DoublePropertyBase;
 import javafx.beans.property.IntegerProperty;
 import javafx.beans.property.IntegerPropertyBase;
 import javafx.beans.property.ObjectProperty;
 import javafx.beans.property.ObjectPropertyBase;
 import javafx.beans.property.ReadOnlyDoubleProperty;
 import javafx.beans.property.ReadOnlyDoublePropertyBase;
 import javafx.beans.property.ReadOnlyObjectProperty;
 import javafx.beans.property.ReadOnlyObjectPropertyBase;
-import javafx.beans.property.SimpleBooleanProperty;
-import javafx.beans.property.SimpleObjectProperty;
 import javafx.collections.FXCollections;
 import javafx.collections.ObservableMap;
 import javafx.event.ActionEvent;
 import javafx.event.EventHandler;
 import javafx.util.Duration;
 import com.sun.javafx.animation.TickCalculation;
 import com.sun.scenario.animation.AbstractMasterTimer;
 import com.sun.scenario.animation.shared.ClipEnvelope;
 import com.sun.scenario.animation.shared.PulseReceiver;
 
-import static com.sun.javafx.animation.TickCalculation.*;
 import java.security.AccessControlContext;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
 /**
@@ -96,12 +94,12 @@
     static {
         AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
     }
 
     /**
-     * Used to specify an animation that repeats indefinitely, until the
-     * {@code stop()} method is called.
+     * Used as a  value for {@link #cycleCountProperty() cycleCount} to specify an animation that repeats indefinitely,
+     * until the {@code stop()} method is called.
      */
     public static final int INDEFINITE = -1;
 
     /**
      * The possible states for {@link Animation#statusProperty() status}.
@@ -122,10 +120,28 @@
         STOPPED
     }
 
     private static final double EPSILON = 1e-12;
 
+    /**
+     * Checks if the rate is effectively 0.
+     * @param rate
+     * @return true i.f.f. abs(rate) < EPSILON
+     */
+    static final boolean isNearZero(double rate) {
+        return Math.abs(rate) < EPSILON;
+    }
+
+    /**
+     * Checks if 2 rates are effectively equal.
+     * @param rateMagnitude
+     * @return true i.f.f. Math.abs(rate1 - rate2) < EPSILON
+     */
+    private static boolean areNearEqual(double rate1, double rate2) {
+        return isNearZero(rate2 - rate1);
+    }
+
     /*
         These four fields and associated methods were moved here from AnimationPulseReceiver
         when that class was removed. They could probably be integrated much cleaner into Animation,
         but to make sure the change was made without introducing regressions, this code was
         moved pretty much verbatim.
@@ -133,11 +149,11 @@
     private long startTime;
     private long pauseTime;
     private boolean paused = false;
     private final AbstractMasterTimer timer;
 
-    // Access control context, captured whenever we add this pulse reciever to
+    // Access control context, captured whenever we add this pulse receiver to
     // the master timer (which is called when an animation is played or resumed)
     private AccessControlContext accessCtrlCtx = null;
 
     private long now() {
         return TickCalculation.fromNano(timer.nanos());
@@ -253,11 +269,16 @@
      *
      * @defaultValue null
      */
     Animation parent = null;
 
-    /* Package-private for testing purposes */
+    /**
+     * The type of ClipEnvelope for the animation is determined by its cycleCount and cycleDuration
+     * and is updated when these values change.
+     * <p>
+     * Package-private for testing purposes
+    */
     ClipEnvelope clipEnvelope;
 
     private boolean lastPlayedFinished = true;
 
     private boolean lastPlayedForward = true;
@@ -283,11 +304,11 @@
      */
     private DoubleProperty rate;
     private static final double DEFAULT_RATE = 1.0;
 
     public final void setRate(double value) {
-        if ((rate != null) || (Math.abs(value - DEFAULT_RATE) > EPSILON)) {
+        if (rate != null || !areNearEqual(value, DEFAULT_RATE)) {
             rateProperty().set(value);
         }
     }
 
     public final double getRate() {
@@ -305,33 +326,31 @@
                         if (isBound()) {
                             unbind();
                         }
                         set(oldRate);
                         throw new IllegalArgumentException("Cannot set rate of embedded animation while running.");
+                    }
+                    if (isNearZero(newRate)) {
+                        if (isRunning()) {
+                            lastPlayedForward = areNearEqual(getCurrentRate(), oldRate);
+                        }
+                        doSetCurrentRate(0.0);
+                        pauseReceiver();
                     } else {
-                        if (Math.abs(newRate) < EPSILON) {
-                            if (getStatus() == Status.RUNNING) {
-                                lastPlayedForward = (Math.abs(getCurrentRate()
-                                        - oldRate) < EPSILON);
-                            }
-                            doSetCurrentRate(0.0);
-                            pauseReceiver();
-                        } else {
-                            if (getStatus() == Status.RUNNING) {
-                                final double currentRate = getCurrentRate();
-                                if (Math.abs(currentRate) < EPSILON) {
-                                    doSetCurrentRate(lastPlayedForward ? newRate : -newRate);
-                                    resumeReceiver();
-                                } else {
-                                    final boolean playingForward = Math.abs(currentRate - oldRate) < EPSILON;
-                                    doSetCurrentRate(playingForward ? newRate : -newRate);
-                                }
+                        if (isRunning()) {
+                            final double currentRate = getCurrentRate();
+                            if (isNearZero(currentRate)) {
+                                doSetCurrentRate(lastPlayedForward ? newRate : -newRate);
+                                resumeReceiver();
+                            } else {
+                                final boolean playingForward = areNearEqual(currentRate, oldRate);
+                                doSetCurrentRate(playingForward ? newRate : -newRate);
                             }
-                            oldRate = newRate;
                         }
-                        clipEnvelope.setRate(newRate);
+                        oldRate = newRate;
                     }
+                    clipEnvelope.setRate(newRate);
                 }
 
                 @Override
                 public Object getBean() {
                     return Animation.this;
@@ -348,11 +367,11 @@
 
     private boolean isRunningEmbedded() {
         if (parent == null) {
             return false;
         }
-        return parent.getStatus() != Status.STOPPED || parent.isRunningEmbedded();
+        return !parent.isStopped() || parent.isRunningEmbedded();
     }
 
     private double oldRate = 1.0;
     /**
      * Read-only variable to indicate current direction/speed at which the
@@ -366,27 +385,45 @@
      * @defaultValue 0.0
      */
     private ReadOnlyDoubleProperty currentRate;
     private static final double DEFAULT_CURRENT_RATE = 0.0;
 
+    /**
+     * The current rate changes in 3 cases:
+     * <ol>
+     * <li> When the rate is changed.
+     * <li> When the status is changed (paused/stopped/resumed/started).
+     * <li> When switching between a forwards and backwards cycle.
+     * </ol>
+     *
+     * 1 happens when the user changes the rate of the animation or its root parent.
+     * 2 happens when the user changes the status or when the animation is finished.
+     * 3 happens when the clip envelope flips the rate when the cycle is alternated, through the accessor
+     */
     private void doSetCurrentRate(double value) {
-        if ((currentRate != null) || (Math.abs(value - DEFAULT_CURRENT_RATE) > EPSILON)) {
-            ((CurrentRateProperty)currentRateProperty()).set(value);
+        if (currentRate != null || !areNearEqual(value, DEFAULT_CURRENT_RATE)) {
+            ((CurrentRateProperty) currentRateProperty()).set(value);
         }
     }
 
     public final double getCurrentRate() {
-        return (currentRate == null)? DEFAULT_CURRENT_RATE : currentRate.get();
+        return (currentRate == null) ? DEFAULT_CURRENT_RATE : currentRate.get();
     }
 
     public final ReadOnlyDoubleProperty currentRateProperty() {
         if (currentRate == null) {
             currentRate = new CurrentRateProperty();
         }
         return currentRate;
     }
 
+    void setCurrentRate(double currentRate) {
+//      if (getStatus() == Status.RUNNING) {
+          doSetCurrentRate(currentRate);
+//      }
+  }
+
     /**
      * Read-only variable to indicate the duration of one cycle of this
      * {@code Animation}: the time it takes to play from time 0 to the
      * end of the Animation (at the default {@code rate} of
      * 1.0).
@@ -395,26 +432,26 @@
      */
     private ReadOnlyObjectProperty<Duration> cycleDuration;
     private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
 
     protected final void setCycleDuration(Duration value) {
-        if ((cycleDuration != null) || (!DEFAULT_CYCLE_DURATION.equals(value))) {
+        if (cycleDuration != null || !DEFAULT_CYCLE_DURATION.equals(value)) {
             if (value.lessThan(Duration.ZERO)) {
                 throw new IllegalArgumentException("Cycle duration cannot be negative");
             }
-            ((AnimationReadOnlyProperty<Duration>)cycleDurationProperty()).set(value);
+            ((AnimationReadOnlyProperty<Duration>) cycleDurationProperty()).set(value);
             updateTotalDuration();
         }
     }
 
     public final Duration getCycleDuration() {
-        return (cycleDuration == null)? DEFAULT_CYCLE_DURATION : cycleDuration.get();
+        return (cycleDuration == null) ? DEFAULT_CYCLE_DURATION : cycleDuration.get();
     }
 
     public final ReadOnlyObjectProperty<Duration> cycleDurationProperty() {
         if (cycleDuration == null) {
-            cycleDuration = new AnimationReadOnlyProperty<Duration>("cycleDuration", DEFAULT_CYCLE_DURATION);
+            cycleDuration = new AnimationReadOnlyProperty<>("cycleDuration", DEFAULT_CYCLE_DURATION);
         }
         return cycleDuration;
     }
 
     /**
@@ -430,36 +467,37 @@
      */
     private ReadOnlyObjectProperty<Duration> totalDuration;
     private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
 
     public final Duration getTotalDuration() {
-        return (totalDuration == null)? DEFAULT_TOTAL_DURATION : totalDuration.get();
+        return (totalDuration == null) ? DEFAULT_TOTAL_DURATION : totalDuration.get();
     }
 
     public final ReadOnlyObjectProperty<Duration> totalDurationProperty() {
         if (totalDuration == null) {
-            totalDuration = new AnimationReadOnlyProperty<Duration>("totalDuration", DEFAULT_TOTAL_DURATION);
+            totalDuration = new AnimationReadOnlyProperty<>("totalDuration", DEFAULT_TOTAL_DURATION);
         }
         return totalDuration;
     }
 
     private void updateTotalDuration() {
         // Implementing the bind eagerly, because cycleCount and
         // cycleDuration should not change that often
         final int cycleCount = getCycleCount();
         final Duration cycleDuration = getCycleDuration();
-        final Duration newTotalDuration = Duration.ZERO.equals(cycleDuration) ? Duration.ZERO
-                : (cycleCount == Animation.INDEFINITE) ? Duration.INDEFINITE
-                        : (cycleCount <= 1) ? cycleDuration : cycleDuration
-                                .multiply(cycleCount);
-        if ((totalDuration != null) || (!DEFAULT_TOTAL_DURATION.equals(newTotalDuration))) {
-            ((AnimationReadOnlyProperty<Duration>)totalDurationProperty()).set(newTotalDuration);
+        final Duration newTotalDuration;
+        if (Duration.ZERO.equals(cycleDuration)) newTotalDuration = Duration.ZERO;
+        else if (cycleCount == INDEFINITE) newTotalDuration = Duration.INDEFINITE;
+        else if (cycleCount <= 1) newTotalDuration = cycleDuration;
+        else newTotalDuration = cycleDuration.multiply(cycleCount);
+        if (totalDuration != null || !DEFAULT_TOTAL_DURATION.equals(newTotalDuration)) {
+            ((AnimationReadOnlyProperty<Duration>) totalDurationProperty()).set(newTotalDuration);
         }
-        if (getStatus() == Status.STOPPED) {
+        if (isStopped()) {
             syncClipEnvelope();
             if (newTotalDuration.lessThan(getCurrentTime())) {
-                clipEnvelope.jumpTo(fromDuration(newTotalDuration));
+                clipEnvelope.jumpTo(TickCalculation.fromDuration(newTotalDuration));
             }
         }
     }
 
     /**
@@ -513,45 +551,44 @@
      */
     private ObjectProperty<Duration> delay;
     private static final Duration DEFAULT_DELAY = Duration.ZERO;
 
     public final void setDelay(Duration value) {
-        if ((delay != null) || (!DEFAULT_DELAY.equals(value))) {
+        if (delay != null || !DEFAULT_DELAY.equals(value)) {
             delayProperty().set(value);
         }
     }
 
     public final Duration getDelay() {
-        return (delay == null)? DEFAULT_DELAY : delay.get();
+        return (delay == null) ? DEFAULT_DELAY : delay.get();
     }
 
     public final ObjectProperty<Duration> delayProperty() {
         if (delay == null) {
-            delay = new ObjectPropertyBase<Duration>(DEFAULT_DELAY) {
+            delay = new ObjectPropertyBase<>(DEFAULT_DELAY) {
+
+                @Override
+                protected void invalidated() {
+                    final Duration newDuration = get();
+                    if (newDuration.lessThan(Duration.ZERO)) {
+                        if (isBound()) {
+                            unbind();
+                        }
+                        set(Duration.ZERO);
+                        throw new IllegalArgumentException("Cannot set delay to negative value. Setting to Duration.ZERO");
+                    }
+                }
 
                 @Override
                 public Object getBean() {
                     return Animation.this;
                 }
 
                 @Override
                 public String getName() {
                     return "delay";
                 }
-
-                @Override
-                protected void invalidated() {
-                        final Duration newDuration = get();
-                        if (newDuration.lessThan(Duration.ZERO)) {
-                            if (isBound()) {
-                                unbind();
-                            }
-                            set(Duration.ZERO);
-                            throw new IllegalArgumentException("Cannot set delay to negative value. Setting to Duration.ZERO");
-                        }
-                }
-
             };
         }
         return delay;
     }
 
@@ -569,17 +606,17 @@
      */
     private IntegerProperty cycleCount;
     private static final int DEFAULT_CYCLE_COUNT = 1;
 
     public final void setCycleCount(int value) {
-        if ((cycleCount != null) || (value != DEFAULT_CYCLE_COUNT)) {
+        if (cycleCount != null || value != DEFAULT_CYCLE_COUNT) {
             cycleCountProperty().set(value);
         }
     }
 
     public final int getCycleCount() {
-        return (cycleCount == null)? DEFAULT_CYCLE_COUNT : cycleCount.get();
+        return (cycleCount == null) ? DEFAULT_CYCLE_COUNT : cycleCount.get();
     }
 
     public final IntegerProperty cycleCountProperty() {
         if (cycleCount == null) {
             cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
@@ -620,22 +657,33 @@
      */
     private BooleanProperty autoReverse;
     private static final boolean DEFAULT_AUTO_REVERSE = false;
 
     public final void setAutoReverse(boolean value) {
-        if ((autoReverse != null) || (value != DEFAULT_AUTO_REVERSE)) {
+        if (autoReverse != null || value != DEFAULT_AUTO_REVERSE) {
             autoReverseProperty().set(value);
         }
     }
 
     public final boolean isAutoReverse() {
-        return (autoReverse == null)? DEFAULT_AUTO_REVERSE : autoReverse.get();
+        return (autoReverse == null) ? DEFAULT_AUTO_REVERSE : autoReverse.get();
     }
 
     public final BooleanProperty autoReverseProperty() {
         if (autoReverse == null) {
-            autoReverse = new SimpleBooleanProperty(this, "autoReverse", DEFAULT_AUTO_REVERSE);
+            autoReverse = new BooleanPropertyBase(DEFAULT_AUTO_REVERSE) {
+
+                @Override
+                public Object getBean() {
+                    return Animation.this;
+                }
+
+                @Override
+                public String getName() {
+                    return "autoReverse";
+                }
+            };
         }
         return autoReverse;
     }
 
     /**
@@ -646,41 +694,36 @@
      */
     private ReadOnlyObjectProperty<Status> status;
     private static final Status DEFAULT_STATUS = Status.STOPPED;
 
     protected final void setStatus(Status value) {
-        if ((status != null) || (!DEFAULT_STATUS.equals(value))) {
-            ((AnimationReadOnlyProperty<Status>)statusProperty()).set(value);
+        if (status != null || !DEFAULT_STATUS.equals(value)) {
+            ((AnimationReadOnlyProperty<Status>) statusProperty()).set(value);
         }
     }
 
     public final Status getStatus() {
-        return (status == null)? DEFAULT_STATUS : status.get();
+        return (status == null) ? DEFAULT_STATUS : status.get();
     }
 
     public final ReadOnlyObjectProperty<Status> statusProperty() {
         if (status == null) {
-            status = new AnimationReadOnlyProperty<Status>("status", Status.STOPPED);
+            status = new AnimationReadOnlyProperty<>("status", Status.STOPPED);
         }
         return status;
     }
 
-    private final double targetFramerate;
-    private final int resolution;
-    private long lastPulse;
+    boolean isStopped() {
+        return getStatus() == Status.STOPPED;
+    }
 
-    /**
-     * The target framerate is the maximum framerate at which this {@code Animation}
-     * will run, in frames per second. This can be used, for example, to keep
-     * particularly complex {@code Animations} from over-consuming system resources.
-     * By default, an {@code Animation}'s framerate is not explicitly limited, meaning
-     * the {@code Animation} will run at an optimal framerate for the underlying platform.
-     *
-     * @return the target framerate
-     */
-    public final double getTargetFramerate() {
-        return targetFramerate;
+    boolean isPaused() {
+        return getStatus() == Status.PAUSED;
+    }
+
+    boolean isRunning() {
+        return getStatus() == Status.RUNNING;
     }
 
     /**
      * The action to be executed at the conclusion of this {@code Animation}.
      *
@@ -688,28 +731,38 @@
      */
     private ObjectProperty<EventHandler<ActionEvent>> onFinished;
     private static final EventHandler<ActionEvent> DEFAULT_ON_FINISHED = null;
 
     public final void setOnFinished(EventHandler<ActionEvent> value) {
-        if ((onFinished != null) || (value != null /* DEFAULT_ON_FINISHED */)) {
+        if (onFinished != null || value != DEFAULT_ON_FINISHED) {
             onFinishedProperty().set(value);
         }
     }
 
     public final EventHandler<ActionEvent> getOnFinished() {
-        return (onFinished == null)? DEFAULT_ON_FINISHED : onFinished.get();
+        return (onFinished == null) ? DEFAULT_ON_FINISHED : onFinished.get();
     }
 
     public final ObjectProperty<EventHandler<ActionEvent>> onFinishedProperty() {
         if (onFinished == null) {
-            onFinished = new SimpleObjectProperty<EventHandler<ActionEvent>>(this, "onFinished", DEFAULT_ON_FINISHED);
+            onFinished = new ObjectPropertyBase<>(DEFAULT_ON_FINISHED) {
+
+                @Override
+                public Object getBean() {
+                    return Animation.this;
+                }
+
+                @Override
+                public String getName() {
+                    return "onFinished";
+                }
+            };
         }
         return onFinished;
     }
 
-    private final ObservableMap<String, Duration> cuePoints = FXCollections
-            .observableMap(new HashMap<String, Duration>(0));
+    private ObservableMap<String, Duration> cuePoints;
 
     /**
      * The cue points can be
      * used to mark important positions of the {@code Animation}. Once a cue
      * point was defined, it can be used as an argument of
@@ -725,10 +778,13 @@
      * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
      *
      * @return {@link javafx.collections.ObservableMap} of cue points
      */
     public final ObservableMap<String, Duration> getCuePoints() {
+        if (cuePoints == null) {
+            cuePoints = FXCollections.observableHashMap();
+        }
         return cuePoints;
     }
 
     /**
      * Jumps to a given position in this {@code Animation}.
@@ -746,13 +802,11 @@
      * @throws IllegalStateException
      *             if embedded in another animation,
      *                such as {@link SequentialTransition} or {@link ParallelTransition}
      */
     public void jumpTo(Duration time) {
-        if (time == null) {
-            throw new NullPointerException("Time needs to be specified.");
-        }
+        Objects.requireNonNull(time, "Time needs to be specified");
         if (time.isUnknown()) {
             throw new IllegalArgumentException("The time is invalid");
         }
         if (parent != null) {
             throw new IllegalStateException("Cannot jump when embedded in another animation");
@@ -762,11 +816,11 @@
 
         double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
             Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
         long ticks = TickCalculation.fromMillis(millis);
 
-        if (getStatus() == Status.STOPPED) {
+        if (isStopped()) {
             syncClipEnvelope();
         }
         clipEnvelope.jumpTo(ticks);
     }
 
@@ -794,13 +848,11 @@
      *             if embedded in another animation,
      *                such as {@link SequentialTransition} or {@link ParallelTransition}
      * @see #getCuePoints()
      */
     public void jumpTo(String cuePoint) {
-        if (cuePoint == null) {
-            throw new NullPointerException("CuePoint needs to be specified");
-        }
+        Objects.requireNonNull(cuePoint, "CuePoint needs to be specified");
         if ("start".equalsIgnoreCase(cuePoint)) {
             jumpTo(Duration.ZERO);
         } else if ("end".equalsIgnoreCase(cuePoint)) {
             jumpTo(getTotalDuration());
         } else {
@@ -867,10 +919,38 @@
     public void playFrom(Duration time) {
         jumpTo(time);
         play();
     }
 
+    /**
+     * Plays an {@code Animation} from initial position in forward direction.
+     * <p>
+     * It is equivalent to
+     * <p>
+     * <code>
+     *      animation.stop();<br>
+     *      animation.setRate = setRate(Math.abs(animation.getRate())); <br>
+     *      animation.jumpTo(Duration.ZERO);<br>
+     *      animation.play();<br>
+     *  </code>
+     *
+     * <p>
+     * Note: <ul>
+     * <li>{@code playFromStart()} is an asynchronous call, {@code Animation} may
+     * not start immediately. </ul>
+     *
+     * @throws IllegalStateException
+     *             if embedded in another animation,
+     *                such as {@link SequentialTransition} or {@link ParallelTransition}
+     */
+    public void playFromStart() {
+        stop();
+        setRate(Math.abs(getRate()));
+        jumpTo(Duration.ZERO);
+        play();
+    }
+
     /**
      * Plays {@code Animation} from current position in the direction indicated
      * by {@code rate}. If the {@code Animation} is running, it has no effect.
      * <p>
      * When {@code rate} {@literal >} 0 (forward play), if an {@code Animation} is already
@@ -905,61 +985,44 @@
         switch (getStatus()) {
             case STOPPED:
                 if (startable(true)) {
                     final double rate = getRate();
                     if (lastPlayedFinished) {
-                        jumpTo((rate < 0)? getTotalDuration() : Duration.ZERO);
+                        jumpTo(rate < 0 ? getTotalDuration() : Duration.ZERO);
                     }
                     doStart(true);
                     startReceiver(TickCalculation.fromDuration(getDelay()));
-                    if (Math.abs(rate) < EPSILON) {
+                    if (isNearZero(rate)) {
                         pauseReceiver();
                     } else {
 
                     }
                 } else {
-                    final EventHandler<ActionEvent> handler = getOnFinished();
-                    if (handler != null) {
-                        handler.handle(new ActionEvent(this, null));
-                    }
+                    runHandler(getOnFinished());
                 }
                 break;
             case PAUSED:
                 doResume();
-                if (Math.abs(getRate()) >= EPSILON) {
+                if (!isNearZero(getRate())) {
                     resumeReceiver();
                 }
                 break;
+            case RUNNING: // no-op
         }
     }
 
-    /**
-     * Plays an {@code Animation} from initial position in forward direction.
-     * <p>
-     * It is equivalent to
-     * <p>
-     * <code>
-     *      animation.stop();<br>
-     *      animation.setRate = setRate(Math.abs(animation.getRate())); <br>
-     *      animation.jumpTo(Duration.ZERO);<br>
-     *      animation.play();<br>
-     *  </code>
-     *
-     * <p>
-     * Note: <ul>
-     * <li>{@code playFromStart()} is an asynchronous call, {@code Animation} may
-     * not start immediately. </ul>
-     *
-     * @throws IllegalStateException
-     *             if embedded in another animation,
-     *                such as {@link SequentialTransition} or {@link ParallelTransition}
-     */
-    public void playFromStart() {
-        stop();
-        setRate(Math.abs(getRate()));
-        jumpTo(Duration.ZERO);
-        play();
+    void doStart(boolean forceSync) {
+        sync(forceSync);
+        setStatus(Status.RUNNING);
+        clipEnvelope.start();
+        doSetCurrentRate(clipEnvelope.getCurrentRate());
+        lastPulse = 0;
+    }
+
+    void doResume() {
+        setStatus(Status.RUNNING);
+        doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());
     }
 
     /**
      * Stops the animation and resets the play head to its initial position. If
      * the animation is already stopped, this method has no effect.
@@ -973,18 +1036,26 @@
      */
     public void stop() {
         if (parent != null) {
             throw new IllegalStateException("Cannot stop when embedded in another animation");
         }
-        if (getStatus() != Status.STOPPED) {
+        if (!isStopped()) {
             clipEnvelope.abortCurrentPulse();
             doStop();
             jumpTo(Duration.ZERO);
             lastPlayedFinished = true;
         }
     }
 
+    void doStop() {
+        if (!paused) {
+            timer.removePulseReceiver(pulseReceiver);
+        }
+        setStatus(Status.STOPPED);
+        doSetCurrentRate(0.0);
+    }
+
     /**
      * Pauses the animation. If the animation is not currently running, this
      * method has no effect.
      * <p>
      * Note: <ul>
@@ -996,17 +1067,59 @@
      */
     public void pause() {
         if (parent != null) {
             throw new IllegalStateException("Cannot pause when embedded in another animation");
         }
-        if (getStatus() == Status.RUNNING) {
+        if (isRunning()) {
             clipEnvelope.abortCurrentPulse();
             pauseReceiver();
             doPause();
         }
     }
 
+    void doPause() {
+        final double currentRate = getCurrentRate();
+        if (!isNearZero(currentRate)) {
+            lastPlayedForward = areNearEqual(getCurrentRate(), getRate());
+        }
+        doSetCurrentRate(0.0);
+        setStatus(Status.PAUSED);
+    }
+
+    final void finished() {
+        lastPlayedFinished = true;
+        doStop();
+        runHandler(getOnFinished());
+    }
+
+    void runHandler(EventHandler<ActionEvent> handler) {
+        if (handler != null) {
+            try {
+                handler.handle(new ActionEvent(this, null));
+            } catch (Exception ex) {
+                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);
+            }
+        }
+    }
+
+    private final double targetFramerate;
+    private final int resolution;
+    private long lastPulse;
+
+    /**
+     * The target framerate is the maximum framerate at which this {@code Animation}
+     * will run, in frames per second. This can be used, for example, to keep
+     * particularly complex {@code Animations} from over-consuming system resources.
+     * By default, an {@code Animation}'s framerate is not explicitly limited, meaning
+     * the {@code Animation} will run at an optimal framerate for the underlying platform.
+     *
+     * @return the target framerate
+     */
+    public final double getTargetFramerate() {
+        return targetFramerate;
+    }
+
     /**
      * The constructor of {@code Animation}.
      *
      * This constructor allows to define a target framerate.
      *
@@ -1046,12 +1159,11 @@
         this.clipEnvelope = clipEnvelope;
         this.timer = timer;
     }
 
     boolean startable(boolean forceSync) {
-        return (fromDuration(getCycleDuration()) > 0L)
-                || (!forceSync && clipEnvelope.wasSynched());
+        return (TickCalculation.fromDuration(getCycleDuration()) > 0L) || (!forceSync && clipEnvelope.wasSynched());
     }
 
     void sync(boolean forceSync) {
         if (forceSync || !clipEnvelope.wasSynched()) {
             syncClipEnvelope();
@@ -1065,40 +1177,10 @@
         clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
         clipEnvelope.setCycleDuration(getCycleDuration());
         clipEnvelope.setAutoReverse(isAutoReverse());
     }
 
-    void doStart(boolean forceSync) {
-        sync(forceSync);
-        setStatus(Status.RUNNING);
-        clipEnvelope.start();
-        doSetCurrentRate(clipEnvelope.getCurrentRate());
-        lastPulse = 0;
-    }
-
-    void doPause() {
-        final double currentRate = getCurrentRate();
-        if (Math.abs(currentRate) >= EPSILON) {
-            lastPlayedForward = Math.abs(getCurrentRate() - getRate()) < EPSILON;
-        }
-        doSetCurrentRate(0.0);
-        setStatus(Status.PAUSED);
-    }
-
-    void doResume() {
-        setStatus(Status.RUNNING);
-        doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());
-    }
-
-    void doStop() {
-        if (!paused) {
-            timer.removePulseReceiver(pulseReceiver);
-        }
-        setStatus(Status.STOPPED);
-        doSetCurrentRate(0.0);
-    }
-
     void doTimePulse(long elapsedTime) {
         if (resolution == 1) { // fullspeed
             clipEnvelope.timePulse(elapsedTime);
         } else if (elapsedTime - lastPulse >= resolution) {
             lastPulse = (elapsedTime / resolution) * resolution;
@@ -1114,25 +1196,6 @@
         currentTicks = ticks;
         if (currentTime != null) {
             currentTime.fireValueChangedEvent();
         }
     }
-
-    void setCurrentRate(double currentRate) {
-//        if (getStatus() == Status.RUNNING) {
-            doSetCurrentRate(currentRate);
-//        }
-    }
-
-    final void finished() {
-        lastPlayedFinished = true;
-        doStop();
-        final EventHandler<ActionEvent> handler = getOnFinished();
-        if (handler != null) {
-            try {
-                handler.handle(new ActionEvent(this, null));
-            } catch (Exception ex) {
-                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);
-            }
-        }
-    }
 }
diff a/modules/javafx.graphics/src/test/java/test/javafx/animation/AnimationTest.java b/modules/javafx.graphics/src/test/java/test/javafx/animation/AnimationTest.java
--- a/modules/javafx.graphics/src/test/java/test/javafx/animation/AnimationTest.java
+++ b/modules/javafx.graphics/src/test/java/test/javafx/animation/AnimationTest.java
@@ -265,10 +265,21 @@
 
     @Test
     public void testJumpTo_IndefiniteCycleDuration() {
         animation.shim_setCycleDuration(Duration.INDEFINITE);
 
+        // TicksCalculation defines TICKS_PER_MILLI == 6
+        //
+        // Jumping to the end of Duration.INDEFINITE, which has Double.POSITIVE_INFINITY millis, sets the ticks to
+        // Math.round(Double.POSITIVE_INFINITY * TICKS_PER_MILLI), which is Long.MAX_VALUE as per Math#round specs.
+        // The multiplication by 6 gets lost here because of the infinity rules of Double.
+        //
+        // getCurrentTime() takes the ticks and returns a duration by calculating millis = ticks / TICKS_PER_MILI,
+        // which is Long.MAX_VALUE / 6.
+        //
+        // This means that the conversion Duration -> ticks -> Duration loses information, and the maximum duration is less
+        // than Long.MAX_VALUE.
         animation.jumpTo("end");
         assertEquals(Duration.millis(Long.MAX_VALUE / 6), animation.getCurrentTime());
     }
 
     @Test

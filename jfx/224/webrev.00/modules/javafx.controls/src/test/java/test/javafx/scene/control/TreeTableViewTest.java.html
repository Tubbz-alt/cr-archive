<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/test/java/test/javafx/scene/control/TreeTableViewTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package test.javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.TableColumnBaseHelper;
  29 import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;
  30 import static javafx.scene.control.TreeTableColumn.SortType.ASCENDING;
  31 import static javafx.scene.control.TreeTableColumn.SortType.DESCENDING;
  32 import static org.junit.Assert.*;
  33 import static org.junit.Assert.assertEquals;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Comparator;
  37 import java.util.List;
  38 import java.util.Objects;
  39 import java.util.concurrent.atomic.AtomicInteger;
  40 import java.util.function.Consumer;
  41 import java.util.function.Supplier;
  42 import java.util.stream.Collectors;
  43 
  44 import com.sun.javafx.scene.control.behavior.TreeTableCellBehavior;
  45 import javafx.beans.property.ReadOnlyIntegerWrapper;
  46 import javafx.collections.transformation.FilteredList;
  47 import javafx.scene.control.TableColumn;
  48 import javafx.scene.control.TableView;
  49 import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;
  50 import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;
  51 import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;
  52 import javafx.scene.control.skin.TreeTableCellSkin;
  53 import test.com.sun.javafx.scene.control.test.Data;
  54 
  55 import javafx.application.Platform;
  56 import javafx.beans.InvalidationListener;
  57 import javafx.beans.Observable;
  58 import javafx.beans.binding.Bindings;
  59 import javafx.beans.binding.ObjectBinding;
  60 import javafx.beans.property.ObjectProperty;
  61 import javafx.beans.property.ReadOnlyBooleanWrapper;
  62 import javafx.beans.property.ReadOnlyObjectWrapper;
  63 import javafx.beans.property.ReadOnlyStringWrapper;
  64 import javafx.beans.property.SimpleObjectProperty;
  65 import javafx.beans.property.SimpleStringProperty;
  66 import javafx.collections.FXCollections;
  67 import javafx.collections.ListChangeListener;
  68 import javafx.collections.ObservableList;
  69 import javafx.event.EventHandler;
  70 import javafx.scene.Group;
  71 import javafx.scene.Node;
  72 import javafx.scene.Scene;
  73 import javafx.scene.control.TreeTableView.TreeTableViewFocusModel;
  74 import javafx.scene.control.cell.*;
  75 import javafx.scene.image.ImageView;
  76 import javafx.scene.input.KeyCode;
  77 import javafx.scene.layout.StackPane;
  78 import javafx.scene.layout.VBox;
  79 import javafx.scene.paint.Color;
  80 import javafx.scene.shape.Circle;
  81 import javafx.scene.shape.Rectangle;
  82 import javafx.stage.Stage;
  83 import javafx.util.Callback;
  84 
  85 import org.junit.After;
  86 import org.junit.Before;
  87 import org.junit.Ignore;
  88 import org.junit.Test;
  89 
  90 import com.sun.javafx.scene.control.TableColumnComparatorBase.TreeTableColumnComparator;
  91 import test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils;
  92 import test.com.sun.javafx.scene.control.infrastructure.StageLoader;
  93 import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;
  94 import com.sun.javafx.scene.control.VirtualScrollBar;
  95 import test.com.sun.javafx.scene.control.test.Person;
  96 import test.com.sun.javafx.scene.control.test.RT_22463_Person;
  97 import com.sun.javafx.tk.Toolkit;
  98 import javafx.scene.control.Button;
  99 import javafx.scene.control.Cell;
 100 import javafx.scene.control.FocusModel;
 101 import javafx.scene.control.IndexedCell;
 102 import javafx.scene.control.MultipleSelectionModel;
 103 import javafx.scene.control.MultipleSelectionModelBaseShim;
 104 import javafx.scene.control.SelectionMode;
 105 import javafx.scene.control.TableColumnBaseShim;
 106 import javafx.scene.control.TableSelectionModel;
 107 import javafx.scene.control.TextField;
 108 import javafx.scene.control.TreeItem;
 109 import javafx.scene.control.TreeTableCell;
 110 import javafx.scene.control.TreeTableCellShim;
 111 import javafx.scene.control.TreeTableColumn;
 112 import javafx.scene.control.TreeTablePosition;
 113 import javafx.scene.control.TreeTableRow;
 114 import javafx.scene.control.TreeTableRowShim;
 115 import javafx.scene.control.TreeTableView;
 116 import javafx.scene.control.TreeTableViewShim;
 117 import javafx.scene.control.TreeView;
 118 
 119 public class TreeTableViewTest {
 120     private TreeTableView&lt;String&gt; treeTableView;
 121     private TreeTableView.TreeTableViewSelectionModel sm;
 122     private TreeTableViewFocusModel&lt;String&gt; fm;
 123 
 124 
 125     // sample data #1
 126     private TreeItem&lt;String&gt; root;
 127     private TreeItem&lt;String&gt; child1;
 128     private TreeItem&lt;String&gt; child2;
 129     private TreeItem&lt;String&gt; child3;
 130 
 131     // sample data #1
 132     private TreeItem&lt;String&gt; myCompanyRootNode;
 133         private TreeItem&lt;String&gt; salesDepartment;
 134             private TreeItem&lt;String&gt; ethanWilliams;
 135             private TreeItem&lt;String&gt; emmaJones;
 136             private TreeItem&lt;String&gt; michaelBrown;
 137             private TreeItem&lt;String&gt; annaBlack;
 138             private TreeItem&lt;String&gt; rodgerYork;
 139             private TreeItem&lt;String&gt; susanCollins;
 140 
 141         private TreeItem&lt;String&gt; itSupport;
 142             private TreeItem&lt;String&gt; mikeGraham;
 143             private TreeItem&lt;String&gt; judyMayer;
 144             private TreeItem&lt;String&gt; gregorySmith;
 145 
 146     @Before public void setup() {
 147         setUncaughtExceptionHandler();
 148 
 149         treeTableView = new TreeTableView&lt;String&gt;();
 150         sm = treeTableView.getSelectionModel();
 151         fm = treeTableView.getFocusModel();
 152 
 153         // build sample data #2, even though it may not be used...
 154         myCompanyRootNode = new TreeItem&lt;String&gt;(&quot;MyCompany Human Resources&quot;);
 155         salesDepartment = new TreeItem&lt;String&gt;(&quot;Sales Department&quot;);
 156             ethanWilliams = new TreeItem&lt;String&gt;(&quot;Ethan Williams&quot;);
 157             emmaJones = new TreeItem&lt;String&gt;(&quot;Emma Jones&quot;);
 158             michaelBrown = new TreeItem&lt;String&gt;(&quot;Michael Brown&quot;);
 159             annaBlack = new TreeItem&lt;String&gt;(&quot;Anna Black&quot;);
 160             rodgerYork = new TreeItem&lt;String&gt;(&quot;Rodger York&quot;);
 161             susanCollins = new TreeItem&lt;String&gt;(&quot;Susan Collins&quot;);
 162 
 163         itSupport = new TreeItem&lt;String&gt;(&quot;IT Support&quot;);
 164             mikeGraham = new TreeItem&lt;String&gt;(&quot;Mike Graham&quot;);
 165             judyMayer = new TreeItem&lt;String&gt;(&quot;Judy Mayer&quot;);
 166             gregorySmith = new TreeItem&lt;String&gt;(&quot;Gregory Smith&quot;);
 167 
 168         myCompanyRootNode.getChildren().setAll(
 169             salesDepartment,
 170             itSupport
 171         );
 172         salesDepartment.getChildren().setAll(
 173             ethanWilliams,
 174             emmaJones,
 175             michaelBrown,
 176             annaBlack,
 177             rodgerYork,
 178             susanCollins
 179         );
 180         itSupport.getChildren().setAll(
 181             mikeGraham,
 182             judyMayer,
 183             gregorySmith
 184         );
 185     }
 186 
 187     @After public void cleanup() {
 188         removeUncaughtExceptionHandler();
 189     }
 190 
 191     private void installChildren() {
 192         root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
 193         child1 = new TreeItem&lt;String&gt;(&quot;Child 1&quot;);
 194         child2 = new TreeItem&lt;String&gt;(&quot;Child 2&quot;);
 195         child3 = new TreeItem&lt;String&gt;(&quot;Child 3&quot;);
 196         root.setExpanded(true);
 197         root.getChildren().setAll(child1, child2, child3);
 198         treeTableView.setRoot(root);
 199     }
 200 
 201     private String debug() {
 202         StringBuilder sb = new StringBuilder(&quot;Selected Cells: [&quot;);
 203 
 204         List&lt;TreeTablePosition&lt;?,?&gt;&gt; cells = sm.getSelectedCells();
 205         for (TreeTablePosition cell : cells) {
 206             sb.append(&quot;(&quot;);
 207             sb.append(cell.getRow());
 208             sb.append(&quot;,&quot;);
 209             sb.append(cell.getColumn());
 210             sb.append(&quot;), &quot;);
 211         }
 212 
 213         sb.append(&quot;] \nFocus: &quot; + fm.getFocusedIndex());
 214 //        sb.append(&quot; \nAnchor: &quot; + getAnchor());
 215         return sb.toString();
 216     }
 217 
 218     private void setUncaughtExceptionHandler() {
 219         Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -&gt; {
 220             if (throwable instanceof RuntimeException) {
 221                 throw (RuntimeException)throwable;
 222             } else {
 223                 Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);
 224             }
 225         });
 226     }
 227 
 228     private void removeUncaughtExceptionHandler() {
 229         Thread.currentThread().setUncaughtExceptionHandler(null);
 230     }
 231 
 232 
 233     @Test public void ensureCorrectInitialState() {
 234         installChildren();
 235         assertEquals(0, treeTableView.getRow(root));
 236         assertEquals(1, treeTableView.getRow(child1));
 237         assertEquals(2, treeTableView.getRow(child2));
 238         assertEquals(3, treeTableView.getRow(child3));
 239     }
 240 
 241 
 242 
 243 
 244 
 245 
 246 
 247 
 248     /***************************************************************************
 249      *
 250      *
 251      * Tests taken from TableViewTest
 252      * (scroll down further for the TreeViewTests)
 253      *
 254      *
 255      **************************************************************************/
 256 
 257     /*********************************************************************
 258      * Tests for the constructors                                        *
 259      ********************************************************************/
 260 
 261     @Test public void noArgConstructorSetsNonNullSelectionModel() {
 262         assertNotNull(sm);
 263     }
 264 
 265     @Test public void noArgConstructor_selectedItemIsNull() {
 266         assertNull(sm.getSelectedItem());
 267     }
 268 
 269     @Test public void noArgConstructor_selectedIndexIsNegativeOne() {
 270         assertEquals(-1, sm.getSelectedIndex());
 271     }
 272 
 273     @Test public void noArgConstructorSetsNonNullSortPolicy() {
 274         assertNotNull(treeTableView.getSortPolicy());
 275     }
 276 
 277     @Test public void noArgConstructorSetsNullComparator() {
 278         assertNull(treeTableView.getComparator());
 279     }
 280 
 281     @Test public void noArgConstructorSetsNullOnSort() {
 282         assertNull(treeTableView.getOnSort());
 283     }
 284 
 285 //    @Test public void singleArgConstructorSetsNonNullSelectionModel() {
 286 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 287 //        assertNotNull(b2.getSelectionModel());
 288 //    }
 289 //
 290 //    @Test public void singleArgConstructorAllowsNullItems() {
 291 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(null);
 292 //        assertNull(b2.getItems());
 293 //    }
 294 //
 295 //    @Test public void singleArgConstructorTakesItems() {
 296 //        ObservableList&lt;String&gt; items = FXCollections.observableArrayList(&quot;Hi&quot;);
 297 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(items);
 298 //        assertSame(items, b2.getItems());
 299 //    }
 300 //
 301 //    @Test public void singleArgConstructor_selectedItemIsNull() {
 302 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 303 //        assertNull(b2.getSelectionModel().getSelectedItem());
 304 //    }
 305 //
 306 //    @Test public void singleArgConstructor_selectedIndexIsNegativeOne() {
 307 //        final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(FXCollections.observableArrayList(&quot;Hi&quot;));
 308 //        assertEquals(-1, b2.getSelectionModel().getSelectedIndex());
 309 //    }
 310 
 311     /*********************************************************************
 312      * Tests for columns                                                 *
 313      ********************************************************************/
 314 
 315     @Test public void testColumns() {
 316         TreeTableColumn col1 = new TreeTableColumn();
 317 
 318         assertNotNull(treeTableView.getColumns());
 319         assertEquals(0, treeTableView.getColumns().size());
 320 
 321         treeTableView.getColumns().add(col1);
 322         assertEquals(1, treeTableView.getColumns().size());
 323 
 324         treeTableView.getColumns().remove(col1);
 325         assertEquals(0, treeTableView.getColumns().size());
 326     }
 327 
 328     @Test public void testVisibleLeafColumns() {
 329         TreeTableColumn col1 = new TreeTableColumn();
 330 
 331         assertNotNull(treeTableView.getColumns());
 332         assertEquals(0, treeTableView.getColumns().size());
 333 
 334         treeTableView.getColumns().add(col1);
 335         assertEquals(1, treeTableView.getVisibleLeafColumns().size());
 336 
 337         treeTableView.getColumns().remove(col1);
 338         assertEquals(0, treeTableView.getVisibleLeafColumns().size());
 339     }
 340 
 341     @Test public void testSortOrderCleanup() {
 342         TreeTableView treeTableView = new TreeTableView();
 343         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 344         first.setCellValueFactory(new PropertyValueFactory(&quot;firstName&quot;));
 345         TreeTableColumn&lt;String,String&gt; second = new TreeTableColumn&lt;String,String&gt;(&quot;second&quot;);
 346         second.setCellValueFactory(new PropertyValueFactory(&quot;lastName&quot;));
 347         treeTableView.getColumns().addAll(first, second);
 348         treeTableView.getSortOrder().setAll(first, second);
 349         treeTableView.getColumns().remove(first);
 350         assertFalse(treeTableView.getSortOrder().contains(first));
 351     }
 352 
 353 
 354     /*********************************************************************
 355      * Tests for new sorting API in JavaFX 8.0                           *
 356      ********************************************************************/
 357 
 358     private TreeItem&lt;String&gt; apple, orange, banana;
 359 
 360     // TODO test for sort policies returning null
 361     // TODO test for changing column sortType out of order
 362 
 363     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; NO_SORT_FAILED_SORT_POLICY =
 364             treeTableView1 -&gt; false;
 365 
 366     private static final Callback&lt;TreeTableView&lt;String&gt;, Boolean&gt; SORT_SUCCESS_ASCENDING_SORT_POLICY =
 367             treeTableView1 -&gt; {
 368                 if (treeTableView1.getSortOrder().isEmpty()) return true;
 369                 FXCollections.sort(treeTableView1.getRoot().getChildren(), new Comparator&lt;TreeItem&lt;String&gt;&gt;() {
 370                     @Override public int compare(TreeItem&lt;String&gt; o1, TreeItem&lt;String&gt; o2) {
 371                         return o1.getValue().compareTo(o2.getValue());
 372                     }
 373                 });
 374                 return true;
 375             };
 376 
 377     private TreeTableColumn&lt;String, String&gt; initSortTestStructure() {
 378         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
 379         col.setSortType(ASCENDING);
 380         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
 381         treeTableView.getColumns().add(col);
 382 
 383         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;root&quot;);
 384         newRoot.setExpanded(true);
 385         newRoot.getChildren().addAll(
 386                 apple  = new TreeItem(&quot;Apple&quot;),
 387                 orange = new TreeItem(&quot;Orange&quot;),
 388                 banana = new TreeItem(&quot;Banana&quot;));
 389 
 390         treeTableView.setRoot(newRoot);
 391 
 392         return col;
 393     }
 394 
 395     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 396     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeSortOrderList() {
 397         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 398         treeTableView.setOnSort(event -&gt; {
 399             event.consume();
 400         });
 401 
 402         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 403         treeTableView.getSortOrder().add(col);
 404         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 405 
 406         // the sort order list should be returned back to its original state
 407         assertTrue(treeTableView.getSortOrder().isEmpty());
 408     }
 409 
 410     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeSortOrderList() {
 411         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 412         treeTableView.setOnSort(event -&gt; {
 413             // do not consume here - this allows the sort to happen
 414         });
 415 
 416         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 417         treeTableView.getSortOrder().add(col);
 418         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 419 
 420         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 421     }
 422 
 423     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 424     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_AscendingToDescending() {
 425         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 426         assertEquals(ASCENDING, col.getSortType());
 427         treeTableView.getSortOrder().add(col);
 428         treeTableView.setOnSort(event -&gt; {
 429             event.consume();
 430         });
 431 
 432         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 433 
 434         // when we change from ASCENDING to DESCENDING we don&#39;t expect the sort
 435         // to actually change (and in fact we expect the sort type to resort
 436         // back to being ASCENDING)
 437         col.setSortType(DESCENDING);
 438         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 439         assertEquals(ASCENDING, col.getSortType());
 440 
 441         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 442     }
 443 
 444     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_AscendingToDescending() {
 445         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 446         assertEquals(ASCENDING, col.getSortType());
 447         treeTableView.getSortOrder().add(col);
 448         treeTableView.setOnSort(event -&gt; {
 449             // do not consume here - this allows the sort to happen
 450         });
 451 
 452         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 453 
 454         col.setSortType(DESCENDING);
 455         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 456         assertEquals(DESCENDING, col.getSortType());
 457 
 458         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 459     }
 460 
 461     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 462     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_DescendingToNull() {
 463         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 464         col.setSortType(DESCENDING);
 465         assertEquals(DESCENDING, col.getSortType());
 466         treeTableView.getSortOrder().add(col);
 467         treeTableView.setOnSort(event -&gt; {
 468             event.consume();
 469         });
 470 
 471         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 472 
 473         col.setSortType(null);
 474         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 475         assertEquals(DESCENDING, col.getSortType());
 476 
 477         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 478     }
 479 
 480     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_DescendingToNull() {
 481         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 482         col.setSortType(DESCENDING);
 483         assertEquals(DESCENDING, col.getSortType());
 484         treeTableView.getSortOrder().add(col);
 485         treeTableView.setOnSort(event -&gt; {
 486             // do not consume here - this allows the sort to happen
 487         });
 488 
 489         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 490 
 491         col.setSortType(null);
 492         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 493         assertNull(col.getSortType());
 494 
 495         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 496     }
 497 
 498     @Ignore(&quot;This test is only valid if sort event consumption should revert changes&quot;)
 499     @Test public void testSortEventCanBeConsumedToStopSortOccurring_changeColumnSortType_NullToAscending() {
 500         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 501         col.setSortType(null);
 502         assertNull(col.getSortType());
 503         treeTableView.getSortOrder().add(col);
 504         treeTableView.setOnSort(event -&gt; {
 505             event.consume();
 506         });
 507 
 508         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 509 
 510         col.setSortType(ASCENDING);
 511         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 512         assertNull(col.getSortType());
 513 
 514         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 515     }
 516 
 517     @Test public void testSortEventCanBeNotConsumedToAllowSortToOccur_changeColumnSortType_NullToAscending() {
 518         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 519         col.setSortType(null);
 520         assertNull(col.getSortType());
 521         treeTableView.getSortOrder().add(col);
 522         treeTableView.setOnSort(event -&gt; {
 523             // do not consume here - this allows the sort to happen
 524         });
 525 
 526         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 527 
 528         col.setSortType(ASCENDING);
 529         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 530         assertEquals(ASCENDING, col.getSortType());
 531 
 532         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 533     }
 534 
 535     @Test public void testSortMethodWithNullSortPolicy() {
 536         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 537         treeTableView.setSortPolicy(null);
 538         assertNull(treeTableView.getSortPolicy());
 539         treeTableView.sort();
 540     }
 541 
 542     @Test public void testChangingSortPolicyUpdatesItemsList() {
 543         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 544         col.setSortType(DESCENDING);
 545         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 546         treeTableView.getSortOrder().add(col);
 547         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 548         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 549         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 550     }
 551 
 552     @Test public void testChangingSortPolicyDoesNotUpdateItemsListWhenTheSortOrderListIsEmpty() {
 553         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 554         col.setSortType(DESCENDING);
 555         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 556 
 557         treeTableView.setSortPolicy(SORT_SUCCESS_ASCENDING_SORT_POLICY);
 558         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 559     }
 560 
 561     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderAddition() {
 562         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 563         col.setSortType(DESCENDING);
 564         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 565         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 566 
 567         treeTableView.getSortOrder().add(col);
 568 
 569         // no sort should be run (as we have a custom sort policy), and the
 570         // sortOrder list should be empty as the sortPolicy failed
 571         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 572         assertTrue(treeTableView.getSortOrder().isEmpty());
 573     }
 574 
 575     @Test public void testFailedSortPolicyBacksOutLastChange_sortOrderRemoval() {
 576         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 577         col.setSortType(DESCENDING);
 578         treeTableView.getSortOrder().add(col);
 579         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 580 
 581         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 582 
 583         // even though we remove the column from the sort order here, because the
 584         // sort policy fails the items list should remain unchanged and the sort
 585         // order list should continue to have the column in it.
 586         treeTableView.getSortOrder().remove(col);
 587         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 588         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getSortOrder(), col);
 589     }
 590 
 591     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_ascendingToDescending() {
 592         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 593         col.setSortType(ASCENDING);
 594         treeTableView.getSortOrder().add(col);
 595         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 596 
 597         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 598 
 599         col.setSortType(DESCENDING);
 600         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, banana, orange);
 601         assertEquals(ASCENDING, col.getSortType());
 602     }
 603 
 604     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_descendingToNull() {
 605         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 606         col.setSortType(DESCENDING);
 607         treeTableView.getSortOrder().add(col);
 608         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 609 
 610         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 611 
 612         col.setSortType(null);
 613         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 614         assertEquals(DESCENDING, col.getSortType());
 615     }
 616 
 617     @Test public void testFailedSortPolicyBacksOutLastChange_sortTypeChange_nullToAscending() {
 618         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 619         col.setSortType(null);
 620         treeTableView.getSortOrder().add(col);
 621         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 622 
 623         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 624 
 625         col.setSortType(ASCENDING);
 626         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 627         assertNull(col.getSortType());
 628     }
 629 
 630     @Test public void testComparatorChangesInSyncWithSortOrder_1() {
 631         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 632         assertNull(treeTableView.getComparator());
 633         assertTrue(treeTableView.getSortOrder().isEmpty());
 634 
 635         treeTableView.getSortOrder().add(col);
 636         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 637         assertNotNull(c);
 638         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 639     }
 640 
 641     @Test public void testComparatorChangesInSyncWithSortOrder_2() {
 642         // same as test above
 643         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 644         assertNull(treeTableView.getComparator());
 645         assertTrue(treeTableView.getSortOrder().isEmpty());
 646 
 647         treeTableView.getSortOrder().add(col);
 648         TreeTableColumnComparator c = (TreeTableColumnComparator)treeTableView.getComparator();
 649         assertNotNull(c);
 650         VirtualFlowTestUtils.assertListContainsItemsInOrder(c.getColumns(), col);
 651 
 652         // now remove column from sort order, and the comparator should go to
 653         // being null
 654         treeTableView.getSortOrder().remove(col);
 655         assertNull(treeTableView.getComparator());
 656     }
 657 
 658     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderAddition() {
 659         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 660         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 661 
 662         col.setSortType(DESCENDING);
 663         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), apple, orange, banana);
 664         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 665 
 666         treeTableView.getSortOrder().add(col);
 667 
 668         assertEquals(oldComparator, treeTableView.getComparator());
 669     }
 670 
 671     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortOrderRemoval() {
 672         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 673         TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 674         assertNull(oldComparator);
 675 
 676         col.setSortType(DESCENDING);
 677         treeTableView.getSortOrder().add(col);
 678         VirtualFlowTestUtils.assertListContainsItemsInOrder(treeTableView.getRoot().getChildren(), orange, banana, apple);
 679         oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 680         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 681 
 682         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 683         treeTableView.getSortOrder().remove(col);
 684 
 685         assertTrue(treeTableView.getSortOrder().contains(col));
 686         VirtualFlowTestUtils.assertListContainsItemsInOrder(oldComparator.getColumns(), col);
 687     }
 688 
 689     @Test public void testFailedSortPolicyBacksOutComparatorChange_sortTypeChange() {
 690         TreeTableColumn&lt;String, String&gt; col = initSortTestStructure();
 691         final TreeTableColumnComparator oldComparator = (TreeTableColumnComparator)treeTableView.getComparator();
 692         assertNull(oldComparator);
 693 
 694         treeTableView.setSortPolicy(NO_SORT_FAILED_SORT_POLICY);
 695         treeTableView.getSortOrder().add(col);
 696         col.setSortType(ASCENDING);
 697 
 698         assertTrue(treeTableView.getSortOrder().isEmpty());
 699         assertNull(oldComparator);
 700     }
 701 
 702 
 703 
 704     /*********************************************************************
 705      * Tests for specific bugs                                           *
 706      ********************************************************************/
 707 //    @Test public void test_rt16019() {
 708 //        // RT-16019: NodeMemory TableView tests fail with
 709 //        // IndexOutOfBoundsException (ObservableListWrapper.java:336)
 710 //        TreeTableView treeTableView = new TreeTableView();
 711 //        for (int i = 0; i &lt; 1000; i++) {
 712 //            treeTableView.getItems().add(&quot;data &quot; + i);
 713 //        }
 714 //    }
 715 //
 716 //    @Test public void test_rt15793() {
 717 //        // ListView/TableView selectedIndex is 0 although the items list is empty
 718 //        final TreeTableView tv = new TreeTableView();
 719 //        final ObservableList list = FXCollections.observableArrayList();
 720 //        tv.setItems(list);
 721 //        list.add(&quot;toto&quot;);
 722 //        tv.getSelectionModel().select(0);
 723 //        assertEquals(0, tv.getSelectionModel().getSelectedIndex());
 724 //        list.remove(0);
 725 //        assertEquals(-1, tv.getSelectionModel().getSelectedIndex());
 726 //    }
 727 //
 728 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex() {
 729 //        final TreeTableView lv = new TreeTableView();
 730 //        FocusModel fm = lv.getFocusModel();
 731 //        lv.getItems().add(&quot;row1&quot;);
 732 //        fm.focus(0);
 733 //        assertTrue(fm.isFocused(0));
 734 //
 735 //        lv.getItems().add(0, &quot;row0&quot;);
 736 //        assertTrue(fm.isFocused(1));
 737 //    }
 738 //
 739 //    @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex() {
 740 //        final TreeTableView lv = new TreeTableView();
 741 //        FocusModel fm = lv.getFocusModel();
 742 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 743 //        fm.focus(1);
 744 //        assertTrue(fm.isFocused(1));
 745 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 746 //
 747 //        lv.getItems().add(1, &quot;row0&quot;);
 748 //        assertTrue(fm.isFocused(2));
 749 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 750 //        assertFalse(fm.isFocused(1));
 751 //    }
 752 //
 753 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex() {
 754 //        final TreeTableView lv = new TreeTableView();
 755 //        FocusModel fm = lv.getFocusModel();
 756 //        lv.getItems().addAll(&quot;row1&quot;);
 757 //        fm.focus(0);
 758 //        assertTrue(fm.isFocused(0));
 759 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 760 //
 761 //        lv.getItems().add(1, &quot;row2&quot;);
 762 //        assertTrue(fm.isFocused(0));
 763 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 764 //        assertFalse(fm.isFocused(1));
 765 //    }
 766 //
 767 //    @Test public void test_rt17522_focusShouldBeResetWhenFocusedItemIsRemoved() {
 768 //        final TreeTableView lv = new TreeTableView();
 769 //        FocusModel fm = lv.getFocusModel();
 770 //        lv.getItems().add(&quot;row1&quot;);
 771 //        fm.focus(0);
 772 //        assertTrue(fm.isFocused(0));
 773 //
 774 //        lv.getItems().remove(&quot;row1&quot;);
 775 //        assertTrue(fm.getFocusedIndex() == -1);
 776 //        assertNull(fm.getFocusedItem());
 777 //    }
 778 //
 779 //    @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex() {
 780 //        final TreeTableView lv = new TreeTableView();
 781 //        FocusModel fm = lv.getFocusModel();
 782 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 783 //        fm.focus(1);
 784 //        assertTrue(fm.isFocused(1));
 785 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 786 //
 787 //        lv.getItems().remove(&quot;row1&quot;);
 788 //        assertTrue(fm.isFocused(0));
 789 //        assertEquals(&quot;row2&quot;, fm.getFocusedItem());
 790 //    }
 791 //
 792 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
 793 //        final TreeTableView lv = new TreeTableView();
 794 //        FocusModel fm = lv.getFocusModel();
 795 //        lv.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;);
 796 //        fm.focus(0);
 797 //        assertTrue(fm.isFocused(0));
 798 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 799 //
 800 //        lv.getItems().remove(&quot;row2&quot;);
 801 //        assertTrue(fm.isFocused(0));
 802 //        assertEquals(&quot;row1&quot;, fm.getFocusedItem());
 803 //    }
 804 //
 805 //    @Test public void test_rt18385() {
 806 //        treeTableView.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
 807 //        sm.select(1);
 808 //        treeTableView.getItems().add(&quot;Another Row&quot;);
 809 //        assertEquals(1, sm.getSelectedIndices().size());
 810 //        assertEquals(1, sm.getSelectedItems().size());
 811 //        assertEquals(1, sm.getSelectedCells().size());
 812 //    }
 813 
 814     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsFalse() {
 815         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 816         first.setEditable(false);
 817         treeTableView.getColumns().add(first);
 818         treeTableView.setEditable(false);
 819         treeTableView.edit(1, first);
 820         assertEquals(null, treeTableView.getEditingCell());
 821     }
 822 
 823     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsFalse_columnEditableIsTrue() {
 824         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 825         first.setEditable(true);
 826         treeTableView.getColumns().add(first);
 827         treeTableView.setEditable(false);
 828         treeTableView.edit(1, first);
 829         assertEquals(null, treeTableView.getEditingCell());
 830     }
 831 
 832     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsFalse() {
 833         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 834         first.setEditable(false);
 835         treeTableView.getColumns().add(first);
 836         treeTableView.setEditable(true);
 837         treeTableView.edit(1, first);
 838         assertEquals(null, treeTableView.getEditingCell());
 839     }
 840 
 841     @Test public void test_rt18339_onlyEditWhenTableViewIsEditable_tableEditableIsTrue_columnEditableIsTrue() {
 842         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;String,String&gt;(&quot;first&quot;);
 843         first.setEditable(true);
 844         treeTableView.getColumns().add(first);
 845         treeTableView.setEditable(true);
 846         treeTableView.edit(1, first);
 847         assertEquals(new TreeTablePosition(treeTableView, 1, first), treeTableView.getEditingCell());
 848     }
 849 
 850 //    @Test public void test_rt14451() {
 851 //        treeTableView.getItems().addAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 852 //        sm.setSelectionMode(SelectionMode.MULTIPLE);
 853 //        sm.selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
 854 //        assertEquals(2, sm.getSelectedIndices().size());
 855 //    }
 856 //
 857 //    @Test public void test_rt21586() {
 858 //        treeTableView.getItems().setAll(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Banana&quot;);
 859 //        treeTableView.getSelectionModel().select(1);
 860 //        assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
 861 //        assertEquals(&quot;Orange&quot;, treeTableView.getSelectionModel().getSelectedItem());
 862 //
 863 //        treeTableView.getItems().setAll(&quot;Kiwifruit&quot;, &quot;Pineapple&quot;, &quot;Grape&quot;);
 864 //        assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 865 //        assertNull(treeTableView.getSelectionModel().getSelectedItem());
 866 //    }
 867 
 868 
 869 
 870 
 871 
 872 
 873 
 874 
 875 
 876 
 877 
 878 
 879 
 880 
 881 
 882     /***************************************************************************
 883      *
 884      *
 885      * Tests taken from TreeViewTest
 886      *
 887      *
 888      **************************************************************************/
 889 
 890 
 891 
 892 
 893     /*********************************************************************
 894      * Tests for the constructors                                        *
 895      ********************************************************************/
 896 
 897     @Test public void noArgConstructorSetsTheStyleClass() {
 898         assertStyleClassContains(treeTableView, &quot;tree-table-view&quot;);
 899     }
 900 
 901     @Test public void noArgConstructorSetsNullItems() {
 902         assertNull(treeTableView.getRoot());
 903     }
 904 
 905     @Test public void singleArgConstructorSetsTheStyleClass() {
 906         final TreeTableView&lt;String&gt; b2 = new TreeTableView&lt;String&gt;(new TreeItem&lt;String&gt;(&quot;Hi&quot;));
 907         assertStyleClassContains(b2, &quot;tree-table-view&quot;);
 908     }
 909 
 910     /*********************************************************************
 911      * Tests for selection model                                         *
 912      ********************************************************************/
 913 
 914     @Test public void selectionModelCanBeNull() {
 915         treeTableView.setSelectionModel(null);
 916         assertNull(treeTableView.getSelectionModel());
 917     }
 918 
 919     @Test public void selectionModelCanBeBound() {
 920         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
 921                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
 922         ObjectProperty&lt;TreeTableView.TreeTableViewSelectionModel&lt;String&gt;&gt; other =
 923                 new SimpleObjectProperty(sm);
 924         treeTableView.selectionModelProperty().bind(other);
 925         assertSame(sm, treeTableView.getSelectionModel());
 926     }
 927 
 928     @Test public void selectionModelCanBeChanged() {
 929         TableSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm =
 930                 TreeTableViewShim.&lt;String&gt;get_TreeTableViewArrayListSelectionModel(treeTableView);
 931         TreeTableViewShim.&lt;String&gt;setSelectionModel(treeTableView, sm);
 932         assertSame(sm, treeTableView.getSelectionModel());
 933     }
 934 
 935     @Test public void canSetSelectedItemToAnItemEvenWhenThereAreNoItems() {
 936         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
 937         treeTableView.getSelectionModel().select(element);
 938         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 939         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
 940     }
 941 
 942     @Test public void canSetSelectedItemToAnItemNotInTheDataModel() {
 943         installChildren();
 944         TreeItem&lt;String&gt; element = new TreeItem&lt;String&gt;(&quot;I AM A CRAZY RANDOM STRING&quot;);
 945         treeTableView.getSelectionModel().select(element);
 946         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 947         assertSame(element, treeTableView.getSelectionModel().getSelectedItem());
 948     }
 949 
 950     @Test public void settingTheSelectedItemToAnItemInItemsResultsInTheCorrectSelectedIndex() {
 951         installChildren();
 952         treeTableView.getSelectionModel().select(child1);
 953         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
 954         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
 955     }
 956 
 957     @Ignore(&quot;Not yet supported&quot;)
 958     @Test public void settingTheSelectedItemToANonexistantItemAndThenSettingItemsWhichContainsItResultsInCorrectSelectedIndex() {
 959         treeTableView.getSelectionModel().select(child1);
 960         installChildren();
 961         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
 962         assertSame(child1, treeTableView.getSelectionModel().getSelectedItem());
 963     }
 964 
 965     @Ignore(&quot;Not yet supported&quot;)
 966     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex0() {
 967         installChildren();
 968         treeTableView.getSelectionModel().select(0);
 969         treeTableView.setRoot(null);
 970         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 971         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
 972     }
 973 
 974     @Ignore(&quot;Not yet supported&quot;)
 975     @Test public void ensureSelectionClearsWhenAllItemsAreRemoved_selectIndex2() {
 976         installChildren();
 977         treeTableView.getSelectionModel().select(2);
 978         treeTableView.setRoot(null);
 979         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 980         assertEquals(null, treeTableView.getSelectionModel().getSelectedItem());
 981     }
 982 
 983     @Ignore(&quot;Not yet supported&quot;)
 984     @Test public void ensureSelectedItemRemainsAccurateWhenItemsAreCleared() {
 985         installChildren();
 986         treeTableView.getSelectionModel().select(2);
 987         treeTableView.setRoot(null);
 988         assertNull(treeTableView.getSelectionModel().getSelectedItem());
 989         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
 990 
 991         TreeItem&lt;String&gt; newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
 992         TreeItem&lt;String&gt; newChild1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
 993         TreeItem&lt;String&gt; newChild2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
 994         TreeItem&lt;String&gt; newChild3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
 995         newRoot.setExpanded(true);
 996         newRoot.getChildren().setAll(newChild1, newChild2, newChild3);
 997         treeTableView.setRoot(root);
 998 
 999         treeTableView.getSelectionModel().select(2);
1000         assertEquals(newChild2, treeTableView.getSelectionModel().getSelectedItem());
1001     }
1002 
1003     @Test public void ensureSelectionIsCorrectWhenItemsChange() {
1004         installChildren();
1005         treeTableView.getSelectionModel().select(0);
1006         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1007 
1008         TreeItem newRoot = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1009         treeTableView.setRoot(newRoot);
1010         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1011         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1012         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1013         assertEquals(newRoot, treeTableView.getFocusModel().getFocusedItem());
1014     }
1015 
1016     @Test public void ensureSelectionRemainsOnBranchWhenExpanded() {
1017         installChildren();
1018         root.setExpanded(false);
1019         treeTableView.getSelectionModel().select(0);
1020         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1021         root.setExpanded(true);
1022         assertTrue(treeTableView.getSelectionModel().isSelected(0));
1023         assertTrue(treeTableView.getSelectionModel().getSelectedItems().contains(root));
1024     }
1025 
1026     /*********************************************************************
1027      * Tests for misc                                                    *
1028      ********************************************************************/
1029     @Test public void ensureRootIndexIsZeroWhenRootIsShowing() {
1030         installChildren();
1031         assertEquals(0, treeTableView.getRow(root));
1032     }
1033 
1034     @Test public void ensureRootIndexIsNegativeOneWhenRootIsNotShowing() {
1035         installChildren();
1036         treeTableView.setShowRoot(false);
1037         assertEquals(-1, treeTableView.getRow(root));
1038     }
1039 
1040     @Test public void ensureCorrectIndexWhenRootTreeItemHasParent() {
1041         installChildren();
1042         treeTableView.setRoot(child1);
1043         assertEquals(-1, treeTableView.getRow(root));
1044         assertEquals(0, treeTableView.getRow(child1));
1045         assertEquals(1, treeTableView.getRow(child2));
1046         assertEquals(2, treeTableView.getRow(child3));
1047     }
1048 
1049     @Test public void ensureCorrectIndexWhenRootTreeItemHasParentAndRootIsNotShowing() {
1050         installChildren();
1051         treeTableView.setRoot(child1);
1052         treeTableView.setShowRoot(false);
1053 
1054         // despite the fact there are children in this tree, in reality none are
1055         // visible as the root node has no children (only siblings), and the
1056         // root node is not visible.
1057         assertEquals(0, treeTableView.getExpandedItemCount());
1058 
1059         assertEquals(-1, treeTableView.getRow(root));
1060         assertEquals(-1, treeTableView.getRow(child1));
1061         assertEquals(-1, treeTableView.getRow(child2));
1062         assertEquals(-1, treeTableView.getRow(child3));
1063     }
1064 
1065     @Test public void ensureCorrectIndexWhenRootTreeItemIsCollapsed() {
1066         installChildren();
1067         root.setExpanded(false);
1068         assertEquals(0, treeTableView.getRow(root));
1069 
1070         // note that the indices are negative, as these children rows are not
1071         // visible in the tree
1072         assertEquals(-1, treeTableView.getRow(child1));
1073         assertEquals(-1, treeTableView.getRow(child2));
1074         assertEquals(-1, treeTableView.getRow(child3));
1075     }
1076 
1077 //    @Test public void removingLastTest() {
1078 //        TreeTableView tree_view = new TreeTableView();
1079 //        MultipleSelectionModel sm = tree_view.getSelectionModel();
1080 //        TreeItem&lt;String&gt; tree_model = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1081 //        TreeItem node = new TreeItem(&quot;Data item&quot;);
1082 //        tree_model.getChildren().add(node);
1083 //        tree_view.setRoot(tree_model);
1084 //        tree_model.setExpanded(true);
1085 //        // select the &#39;Data item&#39; in the selection model
1086 //        sm.select(tree_model.getChildren().get(0));
1087 //        // remove the &#39;Data item&#39; from the root node
1088 //        tree_model.getChildren().remove(sm.getSelectedItem());
1089 //        // assert the there are no selected items any longer
1090 //        assertTrue(&quot;items: &quot; + sm.getSelectedItem(), sm.getSelectedItems().isEmpty());
1091 //    }
1092 
1093     /*********************************************************************
1094      * Tests from bug reports                                            *
1095      ********************************************************************/
1096     @Ignore @Test public void test_rt17112() {
1097         TreeItem&lt;String&gt; root1 = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1098         root1.setExpanded(true);
1099         addChildren(root1, &quot;child&quot;);
1100         for (TreeItem child : root1.getChildren()) {
1101             addChildren(child, (String)child.getValue());
1102             child.setExpanded(true);
1103         }
1104 
1105         final TreeTableView treeTableView1 = new TreeTableView();
1106         final MultipleSelectionModel sm = treeTableView1.getSelectionModel();
1107         sm.setSelectionMode(SelectionMode.MULTIPLE);
1108         treeTableView1.setRoot(root1);
1109 
1110         final TreeItem&lt;String&gt; rt17112_child1 = root1.getChildren().get(1);
1111         final TreeItem&lt;String&gt; rt17112_child1_0 = rt17112_child1.getChildren().get(0);
1112         final TreeItem&lt;String&gt; rt17112_child2 = root1.getChildren().get(2);
1113 
1114         sm.getSelectedItems().addListener(new InvalidationListener() {
1115             int count = 0;
1116             @Override public void invalidated(Observable observable) {
1117                 if (count == 0) {
1118                     assertEquals(rt17112_child1_0, sm.getSelectedItem());
1119                     assertEquals(1, sm.getSelectedIndices().size());
1120                     assertEquals(6, sm.getSelectedIndex());
1121                     assertTrue(treeTableView1.getFocusModel().isFocused(6));
1122                 } else if (count == 1) {
1123                     assertEquals(rt17112_child1, sm.getSelectedItem());
1124                     assertFalse(sm.getSelectedItems().contains(rt17112_child2));
1125                     assertEquals(1, sm.getSelectedIndices().size());
1126                     assertTrue(treeTableView1.getFocusModel().isFocused(5));
1127                 }
1128                 count++;
1129             }
1130         });
1131 
1132         // this triggers the first callback above, so that count == 0
1133         sm.select(rt17112_child1_0);
1134 
1135         // this triggers the second callback above, so that count == 1
1136         rt17112_child1.setExpanded(false);
1137     }
1138     private void addChildren(TreeItem parent, String name) {
1139         for (int i=0; i&lt;3; i++) {
1140             TreeItem&lt;String&gt; ti = new TreeItem&lt;String&gt;(name+&quot;-&quot;+i);
1141             parent.getChildren().add(ti);
1142         }
1143     }
1144 
1145     @Test public void test_rt17522_focusShouldMoveWhenItemAddedAtFocusIndex_1() {
1146         installChildren();
1147         FocusModel fm = treeTableView.getFocusModel();
1148         fm.focus(1);    // focus on child1
1149         assertTrue(fm.isFocused(1));
1150         assertEquals(child1, fm.getFocusedItem());
1151 
1152         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1153         root.getChildren().add(0, child0);  // 0th index == position of child1 in root
1154 
1155         assertEquals(child1, fm.getFocusedItem());
1156         assertTrue(fm.isFocused(2));
1157     }
1158 
1159     @Test public void test_rt17522_focusShouldMoveWhenItemAddedBeforeFocusIndex_1() {
1160         installChildren();
1161         FocusModel fm = treeTableView.getFocusModel();
1162         fm.focus(1);    // focus on child1
1163         assertTrue(fm.isFocused(1));
1164 
1165         TreeItem child0 = new TreeItem(&quot;child0&quot;);
1166         root.getChildren().add(0, child0);
1167         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(2));
1168     }
1169 
1170     @Test public void test_rt17522_focusShouldNotMoveWhenItemAddedAfterFocusIndex_1() {
1171         installChildren();
1172         FocusModel fm = treeTableView.getFocusModel();
1173         fm.focus(1);    // focus on child1
1174         assertTrue(fm.isFocused(1));
1175 
1176         TreeItem child4 = new TreeItem(&quot;child4&quot;);
1177         root.getChildren().add(3, child4);
1178         assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1179     }
1180 
1181     @Test public void test_rt17522_focusShouldBeMovedWhenFocusedItemIsRemoved_1() {
1182         installChildren();
1183         FocusModel fm = treeTableView.getFocusModel();
1184         fm.focus(1);
1185         assertTrue(fm.isFocused(1));
1186 
1187         root.getChildren().remove(child1);
1188         assertEquals(0, fm.getFocusedIndex());
1189         assertEquals(treeTableView.getTreeItem(0), fm.getFocusedItem());
1190     }
1191 
1192     @Test public void test_rt17522_focusShouldMoveWhenItemRemovedBeforeFocusIndex_1() {
1193         installChildren();
1194         FocusModel fm = treeTableView.getFocusModel();
1195         fm.focus(2);
1196         assertTrue(fm.isFocused(2));
1197 
1198         root.getChildren().remove(child1);
1199         assertTrue(fm.isFocused(1));
1200         assertEquals(child2, fm.getFocusedItem());
1201     }
1202 
1203 //    This test fails as, in TreeTableView FocusModel, we do not know the index of the
1204 //    removed tree items, which means we don&#39;t know whether they existed before
1205 //    or after the focused item.
1206 //    @Test public void test_rt17522_focusShouldNotMoveWhenItemRemovedAfterFocusIndex() {
1207 //        installChildren();
1208 //        FocusModel fm = treeTableView.getFocusModel();
1209 //        fm.focus(1);
1210 //        assertTrue(fm.isFocused(1));
1211 //
1212 //        root.getChildren().remove(child3);
1213 //        assertTrue(&quot;Focused index: &quot; + fm.getFocusedIndex(), fm.isFocused(1));
1214 //        assertEquals(child1, fm.getFocusedItem());
1215 //    }
1216 
1217     @Test public void test_rt18385() {
1218         installChildren();
1219 //        table.getItems().addAll(&quot;row1&quot;, &quot;row2&quot;, &quot;row3&quot;);
1220         treeTableView.getSelectionModel().select(1);
1221         treeTableView.getRoot().getChildren().add(new TreeItem(&quot;Another Row&quot;));
1222         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndices().size());
1223         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1224     }
1225 
1226     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsFalse() {
1227         TreeItem root = new TreeItem(&quot;root&quot;);
1228         root.getChildren().setAll(
1229                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1230                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1231                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1232                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1233                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1234         root.setExpanded(true);
1235 
1236         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1237 
1238         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1239         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1240 
1241         table.setEditable(false);
1242         table.edit(0,firstNameCol);
1243         assertNull(table.getEditingCell());
1244     }
1245 
1246     @Test public void test_rt18339_onlyEditWhenTreeTableViewIsEditable_editableIsTrue() {
1247         TreeItem root = new TreeItem(&quot;root&quot;);
1248         root.getChildren().setAll(
1249                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1250                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1251                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1252                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1253                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1254         root.setExpanded(true);
1255 
1256         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1257 
1258         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1259         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1260 
1261         table.setEditable(true);
1262         table.edit(0,firstNameCol);
1263         assertEquals(root, table.getEditingCell().getTreeItem());
1264     }
1265 
1266     @Test public void test_rt14451() {
1267         installChildren();
1268         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
1269         treeTableView.getSelectionModel().selectRange(0, 2); // select from 0 (inclusive) to 2 (exclusive)
1270         assertEquals(2, treeTableView.getSelectionModel().getSelectedIndices().size());
1271     }
1272 
1273     @Test public void test_rt21586() {
1274         installChildren();
1275         treeTableView.getSelectionModel().select(1);
1276         assertEquals(1, treeTableView.getSelectionModel().getSelectedIndex());
1277         assertEquals(child1, treeTableView.getSelectionModel().getSelectedItem());
1278 
1279         TreeItem root = new TreeItem&lt;String&gt;(&quot;New Root&quot;);
1280         TreeItem child1 = new TreeItem&lt;String&gt;(&quot;New Child 1&quot;);
1281         TreeItem child2 = new TreeItem&lt;String&gt;(&quot;New Child 2&quot;);
1282         TreeItem child3 = new TreeItem&lt;String&gt;(&quot;New Child 3&quot;);
1283         root.setExpanded(true);
1284         root.getChildren().setAll(child1, child2, child3);
1285         treeTableView.setRoot(root);
1286         assertEquals(-1, treeTableView.getSelectionModel().getSelectedIndex());
1287         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1288         assertEquals(0, treeTableView.getFocusModel().getFocusedIndex());
1289         assertEquals(root, treeTableView.getFocusModel().getFocusedItem());
1290     }
1291 
1292     @Test public void test_rt27181() {
1293         myCompanyRootNode.setExpanded(true);
1294         treeTableView.setRoot(myCompanyRootNode);
1295 
1296         // start test
1297         salesDepartment.setExpanded(true);
1298         treeTableView.getSelectionModel().select(salesDepartment);
1299 
1300         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1301         itSupport.setExpanded(true);
1302         assertEquals(1, treeTableView.getFocusModel().getFocusedIndex());
1303     }
1304 
1305     @Test public void test_rt27185() {
1306         myCompanyRootNode.setExpanded(true);
1307         treeTableView.setRoot(myCompanyRootNode);
1308 
1309         // start test
1310         itSupport.setExpanded(true);
1311         treeTableView.getSelectionModel().select(mikeGraham);
1312 
1313         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1314         salesDepartment.setExpanded(true);
1315         assertEquals(mikeGraham, treeTableView.getFocusModel().getFocusedItem());
1316     }
1317 
1318     @Ignore(&quot;Bug hasn&#39;t been fixed yet&quot;)
1319     @Test public void test_rt28114() {
1320         myCompanyRootNode.setExpanded(true);
1321         treeTableView.setRoot(myCompanyRootNode);
1322 
1323         // start test
1324         itSupport.setExpanded(true);
1325         treeTableView.getSelectionModel().select(itSupport);
1326         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1327         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1328         assertTrue(! itSupport.isLeaf());
1329         assertTrue(itSupport.isExpanded());
1330 
1331         itSupport.getChildren().remove(mikeGraham);
1332         assertEquals(itSupport, treeTableView.getFocusModel().getFocusedItem());
1333         assertEquals(itSupport, treeTableView.getSelectionModel().getSelectedItem());
1334         assertTrue(itSupport.isLeaf());
1335         assertTrue(!itSupport.isExpanded());
1336     }
1337 
1338     @Test public void test_rt27820_1() {
1339         TreeItem root = new TreeItem(&quot;root&quot;);
1340         root.setExpanded(true);
1341         TreeItem child = new TreeItem(&quot;child&quot;);
1342         root.getChildren().add(child);
1343         treeTableView.setRoot(root);
1344 
1345         treeTableView.getSelectionModel().select(0);
1346         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1347         assertEquals(root, treeTableView.getSelectionModel().getSelectedItem());
1348 
1349         treeTableView.setRoot(null);
1350         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1351         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1352     }
1353 
1354     @Test public void test_rt27820_2() {
1355         TreeItem root = new TreeItem(&quot;root&quot;);
1356         root.setExpanded(true);
1357         TreeItem child = new TreeItem(&quot;child&quot;);
1358         root.getChildren().add(child);
1359         treeTableView.setRoot(root);
1360 
1361         treeTableView.getSelectionModel().select(1);
1362         assertEquals(1, treeTableView.getSelectionModel().getSelectedItems().size());
1363         assertEquals(child, treeTableView.getSelectionModel().getSelectedItem());
1364 
1365         treeTableView.setRoot(null);
1366         assertEquals(0, treeTableView.getSelectionModel().getSelectedItems().size());
1367         assertNull(treeTableView.getSelectionModel().getSelectedItem());
1368     }
1369 
1370     @Test public void test_rt28390() {
1371         // There should be no NPE when a TreeTableView is shown and the disclosure
1372         // node is null in a TreeCell
1373         TreeItem root = new TreeItem(&quot;root&quot;);
1374         treeTableView.setRoot(root);
1375 
1376         // install a custom cell factory that forces the disclosure node to be
1377         // null (because by default a null disclosure node will be replaced by
1378         // a non-null one).
1379         treeTableView.setRowFactory(new Callback() {
1380             @Override public Object call(Object p) {
1381                 TreeTableRow treeCell = new TreeTableRowShim() {
1382                     {
1383                         disclosureNodeProperty().addListener((ov, t, t1) -&gt; {
1384                             setDisclosureNode(null);
1385                         });
1386                     }
1387 
1388                     @Override public void updateItem(Object item, boolean empty) {
1389                         super.updateItem(item, empty);
1390                         setText(item == null ? &quot;&quot; : item.toString());
1391                     }
1392                 };
1393                 treeCell.setDisclosureNode(null);
1394                 return treeCell;
1395             }
1396         });
1397 
1398         try {
1399             Group group = new Group();
1400             group.getChildren().setAll(treeTableView);
1401             Scene scene = new Scene(group);
1402             Stage stage = new Stage();
1403             stage.setScene(scene);
1404             stage.show();
1405         } catch (NullPointerException e) {
1406             System.out.println(&quot;A null disclosure node is valid, so we shouldn&#39;t have an NPE here.&quot;);
1407             e.printStackTrace();
1408             assertTrue(false);
1409         }
1410     }
1411 
1412     @Ignore(&quot;This test begun failing when createDefaultCellImpl was removed from TreeTableViewSkin on 28/3/2013&quot;)
1413     @Test public void test_rt28534() {
1414         TreeItem root = new TreeItem(&quot;root&quot;);
1415         root.getChildren().setAll(
1416                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1417                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1418                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1419                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1420                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1421         root.setExpanded(true);
1422 
1423         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;(root);
1424 
1425         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1426         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1427 
1428         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1429         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1430 
1431         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1432         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1433 
1434         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1435 
1436         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 6); // rows 0 - 6 should be filled
1437         VirtualFlowTestUtils.assertRowsEmpty(table, 6, -1); // rows 6+ should be empty
1438 
1439         // now we replace the data and expect the cells that have no data
1440         // to be empty
1441         root.getChildren().setAll(
1442                 new TreeItem(new Person(&quot;*_*Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1443                 new TreeItem(new Person(&quot;_Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1444 
1445         VirtualFlowTestUtils.assertRowsNotEmpty(table, 0, 3); // rows 0 - 3 should be filled
1446         VirtualFlowTestUtils.assertRowsEmpty(table, 3, -1); // rows 3+ should be empty
1447     }
1448 
1449     @Test public void test_rt22463() {
1450         final TreeTableView&lt;RT_22463_Person&gt; table = new TreeTableView&lt;RT_22463_Person&gt;();
1451         table.setTableMenuButtonVisible(true);
1452         TreeTableColumn c1 = new TreeTableColumn(&quot;Id&quot;);
1453         TreeTableColumn c2 = new TreeTableColumn(&quot;Name&quot;);
1454         c1.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, Long&gt;(&quot;id&quot;));
1455         c2.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;name&quot;));
1456         table.getColumns().addAll(c1, c2);
1457 
1458         RT_22463_Person rootPerson = new RT_22463_Person();
1459         rootPerson.setName(&quot;Root&quot;);
1460         TreeItem&lt;RT_22463_Person&gt; root = new TreeItem&lt;RT_22463_Person&gt;(rootPerson);
1461         root.setExpanded(true);
1462 
1463         table.setRoot(root);
1464 
1465         // before the change things display fine
1466         RT_22463_Person p1 = new RT_22463_Person();
1467         p1.setId(1l);
1468         p1.setName(&quot;name1&quot;);
1469         RT_22463_Person p2 = new RT_22463_Person();
1470         p2.setId(2l);
1471         p2.setName(&quot;name2&quot;);
1472         root.getChildren().addAll(
1473                 new TreeItem&lt;RT_22463_Person&gt;(p1),
1474                 new TreeItem&lt;RT_22463_Person&gt;(p2));
1475         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;name1&quot;);
1476         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;name2&quot;);
1477 
1478         // now we change the persons but they are still equal as the ID&#39;s don&#39;t
1479         // change - but the items list is cleared so the cells should update
1480         RT_22463_Person new_p1 = new RT_22463_Person();
1481         new_p1.setId(1l);
1482         new_p1.setName(&quot;updated name1&quot;);
1483         RT_22463_Person new_p2 = new RT_22463_Person();
1484         new_p2.setId(2l);
1485         new_p2.setName(&quot;updated name2&quot;);
1486         root.getChildren().clear();
1487         root.getChildren().setAll(
1488                 new TreeItem&lt;RT_22463_Person&gt;(new_p1),
1489                 new TreeItem&lt;RT_22463_Person&gt;(new_p2));
1490         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;1&quot;, &quot;updated name1&quot;);
1491         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;2&quot;, &quot;updated name2&quot;);
1492     }
1493 
1494     @Test public void test_rt28637() {
1495         TreeItem&lt;String&gt; s1, s2, s3, s4;
1496         ObservableList&lt;TreeItem&lt;String&gt;&gt; items = FXCollections.observableArrayList(
1497                 s1 = new TreeItem&lt;String&gt;(&quot;String1&quot;),
1498                 s2 = new TreeItem&lt;String&gt;(&quot;String2&quot;),
1499                 s3 = new TreeItem&lt;String&gt;(&quot;String3&quot;),
1500                 s4 = new TreeItem&lt;String&gt;(&quot;String4&quot;));
1501 
1502         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;();
1503 
1504         TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;(&quot;Root&quot;);
1505         root.setExpanded(true);
1506         treeTableView.setRoot(root);
1507         treeTableView.setShowRoot(false);
1508         root.getChildren().addAll(items);
1509 
1510         treeTableView.getSelectionModel().select(0);
1511         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItem());
1512         assertEquals((Object)s1, treeTableView.getSelectionModel().getSelectedItems().get(0));
1513         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1514 
1515         root.getChildren().remove(treeTableView.getSelectionModel().getSelectedItem());
1516         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItem());
1517         assertEquals((Object)s2, treeTableView.getSelectionModel().getSelectedItems().get(0));
1518         assertEquals(0, treeTableView.getSelectionModel().getSelectedIndex());
1519     }
1520 
1521     @Test public void test_rt24844() {
1522         // p1 == lowest first name
1523         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1524 
1525         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1526             p3 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1527             p2 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1528             p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1529             p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1530             p4 = new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1531 
1532         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1533 
1534         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1535         root.setExpanded(true);
1536         table.setRoot(root);
1537         table.setShowRoot(false);
1538         root.getChildren().setAll(persons);
1539 
1540         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1541         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1542 
1543         // set dummy comparator to lock items in place until new comparator is set
1544         firstNameCol.setComparator((t, t1) -&gt; 0);
1545 
1546         table.getColumns().addAll(firstNameCol);
1547         table.getSortOrder().add(firstNameCol);
1548 
1549         // ensure the existing order is as expected
1550         assertEquals(p3, root.getChildren().get(0));
1551         assertEquals(p2, root.getChildren().get(1));
1552         assertEquals(p1, root.getChildren().get(2));
1553         assertEquals(p0, root.getChildren().get(3));
1554         assertEquals(p4, root.getChildren().get(4));
1555 
1556         // set a new comparator
1557         firstNameCol.setComparator((t, t1) -&gt; t.toString().compareTo(t1.toString()));
1558 
1559         // ensure the new order is as expected
1560         assertEquals(p0, root.getChildren().get(0));
1561         assertEquals(p1, root.getChildren().get(1));
1562         assertEquals(p2, root.getChildren().get(2));
1563         assertEquals(p3, root.getChildren().get(3));
1564         assertEquals(p4, root.getChildren().get(4));
1565     }
1566 
1567     @Test public void test_rt29331() {
1568         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;Person&gt;();
1569 
1570         // p1 == lowest first name
1571         TreeItem&lt;Person&gt; p0, p1, p2, p3, p4;
1572 
1573         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1574         firstNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1575 
1576         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1577         lastNameCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1578 
1579         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1580         emailCol.setCellValueFactory(new PropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1581 
1582         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1583         parentColumn.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1584 
1585         table.getColumns().addAll(parentColumn);
1586 
1587         // table is setup, now hide the &#39;last name&#39; column
1588         emailCol.setVisible(false);
1589         assertFalse(emailCol.isVisible());
1590 
1591         // reorder columns inside the parent column
1592         parentColumn.getColumns().setAll(emailCol, firstNameCol, lastNameCol);
1593 
1594         // the email column should not become visible after this, but it does
1595         assertFalse(emailCol.isVisible());
1596     }
1597 
1598     private int rt29330_count = 0;
1599     @Test public void test_rt29330_1() {
1600         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1601                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1602                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1603                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1604                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1605                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1606 
1607         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1608 
1609         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1610         root.setExpanded(true);
1611         table.setRoot(root);
1612         table.setShowRoot(false);
1613         root.getChildren().setAll(persons);
1614 
1615         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1616         table.getColumns().addAll(parentColumn);
1617 
1618         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1619         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1620 
1621         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1622         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1623 
1624         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1625 
1626         table.setOnSort(event -&gt; {
1627             rt29330_count++;
1628         });
1629 
1630         // test preconditions
1631         assertEquals(ASCENDING, lastNameCol.getSortType());
1632         assertEquals(0, rt29330_count);
1633 
1634         table.getSortOrder().add(lastNameCol);
1635         assertEquals(1, rt29330_count);
1636 
1637         lastNameCol.setSortType(DESCENDING);
1638         assertEquals(2, rt29330_count);
1639 
1640         lastNameCol.setSortType(null);
1641         assertEquals(3, rt29330_count);
1642 
1643         lastNameCol.setSortType(ASCENDING);
1644         assertEquals(4, rt29330_count);
1645     }
1646 
1647     @Test public void test_rt29330_2() {
1648         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1649                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1650                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1651                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1652                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1653                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1654 
1655         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1656 
1657         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1658         root.setExpanded(true);
1659         table.setRoot(root);
1660         table.setShowRoot(false);
1661         root.getChildren().setAll(persons);
1662 
1663         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1664         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1665 
1666         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1667         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1668 
1669         // this test differs from the previous one by installing the parent column
1670         // into the tableview after it has the children added into it
1671         TreeTableColumn parentColumn = new TreeTableColumn&lt;&gt;(&quot;Parent&quot;);
1672         parentColumn.getColumns().addAll(firstNameCol, lastNameCol);
1673         table.getColumns().addAll(parentColumn);
1674 
1675         table.setOnSort(event -&gt; {
1676             rt29330_count++;
1677         });
1678 
1679         // test preconditions
1680         assertEquals(ASCENDING, lastNameCol.getSortType());
1681         assertEquals(0, rt29330_count);
1682 
1683         table.getSortOrder().add(lastNameCol);
1684         assertEquals(1, rt29330_count);
1685 
1686         lastNameCol.setSortType(DESCENDING);
1687         assertEquals(2, rt29330_count);
1688 
1689         lastNameCol.setSortType(null);
1690         assertEquals(3, rt29330_count);
1691 
1692         lastNameCol.setSortType(ASCENDING);
1693         assertEquals(4, rt29330_count);
1694     }
1695 
1696     @Test public void test_rt29313_selectedIndices() {
1697         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1698                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1699                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1700                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1701                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1702                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1703 
1704         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1705 
1706         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1707         root.setExpanded(true);
1708         table.setRoot(root);
1709         table.setShowRoot(false);
1710         root.getChildren().setAll(persons);
1711 
1712         TableSelectionModel sm = table.getSelectionModel();
1713 
1714         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1715         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1716 
1717         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1718         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1719 
1720         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1721         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1722 
1723         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1724         sm.setCellSelectionEnabled(true);
1725         sm.setSelectionMode(SelectionMode.MULTIPLE);
1726 
1727         assertTrue(sm.getSelectedIndices().isEmpty());
1728 
1729         // only (0,0) should be selected, so selected indices should be [0]
1730         sm.select(0, firstNameCol);
1731         assertEquals(1, sm.getSelectedIndices().size());
1732 
1733         // now (0,0) and (1,0) should be selected, so selected indices should be [0, 1]
1734         sm.select(1, firstNameCol);
1735         assertEquals(2, sm.getSelectedIndices().size());
1736 
1737         // now (0,0), (1,0) and (1,1) should be selected, but selected indices
1738         // should remain as [0, 1], as we don&#39;t want selected indices to become
1739         // [0,1,1] (which is what RT-29313 is about)
1740         sm.select(1, lastNameCol);
1741         assertEquals(2, sm.getSelectedIndices().size());
1742         assertEquals(0, sm.getSelectedIndices().get(0));
1743         assertEquals(1, sm.getSelectedIndices().get(1));
1744     }
1745 
1746     @Test public void test_rt29313_selectedItems() {
1747         TreeItem&lt;Person&gt; p0, p1;
1748         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1749                 p0 = new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1750                 p1 = new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1751                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1752                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1753                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1754 
1755         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1756 
1757         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1758         root.setExpanded(true);
1759         table.setRoot(root);
1760         table.setShowRoot(false);
1761         root.getChildren().setAll(persons);
1762 
1763         TableSelectionModel sm = table.getSelectionModel();
1764 
1765         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1766         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1767 
1768         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1769         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1770 
1771         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1772         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1773 
1774         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1775         sm.setCellSelectionEnabled(true);
1776         sm.setSelectionMode(SelectionMode.MULTIPLE);
1777 
1778         assertTrue(sm.getSelectedItems().isEmpty());
1779 
1780         // only (0,0) should be selected, so selected items should be [p0]
1781         sm.select(0, firstNameCol);
1782         assertEquals(1, sm.getSelectedItems().size());
1783 
1784         // now (0,0) and (1,0) should be selected, so selected items should be [p0, p1]
1785         sm.select(1, firstNameCol);
1786         assertEquals(2, sm.getSelectedItems().size());
1787 
1788         // now (0,0), (1,0) and (1,1) should be selected, but selected items
1789         // should remain as [p0, p1], as we don&#39;t want selected items to become
1790         // [p0,p1,p1] (which is what RT-29313 is about)
1791         sm.select(1, lastNameCol);
1792         assertEquals(2, sm.getSelectedItems().size());
1793         assertEquals(p0, sm.getSelectedItems().get(0));
1794         assertEquals(p1, sm.getSelectedItems().get(1));
1795     }
1796 
1797     @Test public void test_rt29566() {
1798         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1799                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1800                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1801                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1802                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1803                 new TreeItem&lt;Person&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
1804 
1805         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1806 
1807         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1808         root.setExpanded(true);
1809         table.setRoot(root);
1810         table.setShowRoot(false);
1811         root.getChildren().setAll(persons);
1812 
1813         TableSelectionModel sm = table.getSelectionModel();
1814 
1815         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1816         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1817 
1818         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
1819         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
1820 
1821         TreeTableColumn emailCol = new TreeTableColumn(&quot;Email&quot;);
1822         emailCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
1823 
1824         table.getColumns().addAll(firstNameCol, lastNameCol, emailCol);
1825 
1826         // test the state before we hide and re-add a column
1827         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1828         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1829         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1830         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
1831         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
1832 
1833         // hide the last name column, and test cells again
1834         table.getColumns().remove(lastNameCol);
1835         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;jacob.smith@example.com&quot;);
1836         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;isabella.johnson@example.com&quot;);
1837         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;ethan.williams@example.com&quot;);
1838         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;emma.jones@example.com&quot;);
1839         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;michael.brown@example.com&quot;);
1840 
1841         // re-add the last name column - we should go back to the original state.
1842         // However, what appears to be happening is that, for some reason, some
1843         // of the cells from the removed column do not reappear - meaning in this case
1844         // some of the last name values will not be where we expect them to be.
1845         // This is clearly not ideal!
1846         table.getColumns().add(1, lastNameCol);
1847         VirtualFlowTestUtils.assertCellTextEquals(table, 0, &quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;);
1848         VirtualFlowTestUtils.assertCellTextEquals(table, 1, &quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;);
1849         VirtualFlowTestUtils.assertCellTextEquals(table, 2, &quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;);
1850         VirtualFlowTestUtils.assertCellTextEquals(table, 3, &quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;);
1851         VirtualFlowTestUtils.assertCellTextEquals(table, 4, &quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;);
1852     }
1853 
1854     @Test public void test_rt29390() {
1855         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
1856                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1857                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1858                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1859                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1860                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1861                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1862                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1863                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1864                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1865                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1866                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1867                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
1868                 new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
1869                 new TreeItem&lt;Person&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
1870                 new TreeItem&lt;Person&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
1871                 new TreeItem&lt;Person&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)
1872         ));
1873 
1874         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
1875         table.setMaxHeight(50);
1876         table.setPrefHeight(50);
1877 
1878         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
1879         root.setExpanded(true);
1880         table.setRoot(root);
1881         table.setShowRoot(false);
1882         root.getChildren().setAll(persons);
1883 
1884         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
1885         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
1886 
1887         table.getColumns().add(firstNameCol);
1888 
1889         Toolkit.getToolkit().firePulse();
1890 
1891         // we want the vertical scrollbar
1892         VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(table);
1893 
1894         assertNotNull(scrollBar);
1895         assertTrue(scrollBar.isVisible());
1896         assertTrue(scrollBar.getVisibleAmount() &gt; 0.0);
1897         assertTrue(scrollBar.getVisibleAmount() &lt; 1.0);
1898 
1899         // this next test is likely to be brittle, but we&#39;ll see...If it is the
1900         // cause of failure then it can be commented out
1901         assertEquals(0.0625, scrollBar.getVisibleAmount(), 0.0);
1902     }
1903 
1904     @Test public void test_rt29676_withText() {
1905         // set up test
1906         TreeTableView&lt;Data&gt; treeTableView = new TreeTableView&lt;Data&gt;();
1907         treeTableView.setMaxWidth(100);
1908 
1909         TreeItem&lt;Data&gt; root = new TreeItem&lt;Data&gt;(new Data(&quot;Root&quot;));
1910         treeTableView.setRoot(root);
1911         addLevel(root, 0, 30);
1912 
1913         treeTableView.getRoot().setExpanded(true);
1914         TreeTableColumn&lt;Data, String&gt; column = new TreeTableColumn&lt;Data, String&gt;(&quot;Items&#39; name&quot;);
1915         column.setCellValueFactory(p -&gt; new ReadOnlyStringWrapper(p.getValue().getValue().getData()));
1916         treeTableView.getColumns().add(column);
1917 
1918         // show treeTableView
1919         StageLoader sl = new StageLoader(treeTableView);
1920 
1921         // expand all collapsed branches
1922         root.setExpanded(true);
1923         for (int i = 0; i &lt; root.getChildren().size(); i++) {
1924             TreeItem&lt;Data&gt; child = root.getChildren().get(i);
1925             child.setExpanded(true);
1926         }
1927 
1928         // get all cells and ensure their content is as expected
1929         int cellCount = VirtualFlowTestUtils.getCellCount(treeTableView);
1930         for (int i = 0; i &lt; cellCount; i++) {
1931             // get the TreeTableRow
1932             final TreeTableRow rowCell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, i);
1933             final TreeItem treeItem = rowCell.getTreeItem();
1934             if (treeItem == null) continue;
1935 
1936             final boolean isBranch = ! treeItem.isLeaf();
1937 
1938             // then check its children
1939             List&lt;Node&gt; children = rowCell.getChildrenUnmodifiable();
1940             for (int j = 0; j &lt; children.size(); j++) {
1941                 final Node child = children.get(j);
1942 
1943                 assertTrue(child.isVisible());
1944                 assertNotNull(child.getParent());
1945                 assertNotNull(child.getScene());
1946 
1947                 if (child.getStyleClass().contains(&quot;tree-disclosure-node&quot;)) {
1948                     // no-op
1949                 }
1950 
1951                 if (child.getStyleClass().contains(&quot;tree-table-cell&quot;)) {
1952                     TreeTableCell cell = (TreeTableCell) child;
1953                     assertNotNull(cell.getText());
1954                     assertFalse(cell.getText().isEmpty());
1955                 }
1956             }
1957         }
1958 
1959         sl.dispose();
1960     }
1961     private void addLevel(TreeItem&lt;Data&gt; item, int level, int length) {
1962         for (int i = 0; i &lt; 3; i++) {
1963             StringBuilder builder = new StringBuilder();
1964             builder.append(&quot;Level &quot; + level + &quot; Item &quot; + item);
1965             if (length &gt; 0) {
1966                 builder.append(&quot; l&quot;);
1967                 for (int j = 0; j &lt; length; j++) {
1968                     builder.append(&quot;o&quot;);
1969                 }
1970                 builder.append(&quot;ng&quot;);
1971             }
1972             String itemString = builder.toString();
1973             TreeItem&lt;Data&gt; child = new TreeItem&lt;Data&gt;(new Data(itemString));
1974             if (level &lt; 3 - 1) {
1975                 addLevel(child, level + 1, length);
1976             }
1977             item.getChildren().add(child);
1978         }
1979     }
1980 
1981     @Test public void test_rt27180_collapseBranch_childSelected_singleSelection() {
1982         sm.setCellSelectionEnabled(false);
1983         sm.setSelectionMode(SelectionMode.SINGLE);
1984 
1985         treeTableView.setRoot(myCompanyRootNode);
1986         myCompanyRootNode.setExpanded(true);
1987         salesDepartment.setExpanded(true);
1988         itSupport.setExpanded(true);
1989         sm.select(2);                   // ethanWilliams
1990         assertFalse(sm.isSelected(1));  // salesDepartment
1991         assertTrue(sm.isSelected(2));   // ethanWilliams
1992         assertTrue(treeTableView.getFocusModel().isFocused(2));
1993         assertEquals(1, sm.getSelectedCells().size());
1994 
1995         // now collapse the salesDepartment, selection should
1996         // not jump down to the itSupport people
1997         salesDepartment.setExpanded(false);
1998         assertTrue(sm.getSelectedIndices().toString(), sm.isSelected(1));   // salesDepartment
1999         assertTrue(treeTableView.getFocusModel().isFocused(1));
2000         assertEquals(1, sm.getSelectedCells().size());
2001     }
2002 
2003     @Test public void test_rt27180_collapseBranch_laterSiblingSelected_singleSelection() {
2004         sm.setCellSelectionEnabled(false);
2005         sm.setSelectionMode(SelectionMode.SINGLE);
2006 
2007         treeTableView.setRoot(myCompanyRootNode);
2008         myCompanyRootNode.setExpanded(true);
2009         salesDepartment.setExpanded(true);
2010         itSupport.setExpanded(true);
2011         sm.select(8);                   // itSupport
2012         assertFalse(sm.isSelected(1));  // salesDepartment
2013         assertTrue(sm.isSelected(8));   // itSupport
2014         assertTrue(treeTableView.getFocusModel().isFocused(8));
2015         assertEquals(1, sm.getSelectedIndices().size());
2016 
2017         salesDepartment.setExpanded(false);
2018         assertTrue(debug(), sm.isSelected(2));   // itSupport
2019         assertTrue(treeTableView.getFocusModel().isFocused(2));
2020         assertEquals(1, sm.getSelectedIndices().size());
2021     }
2022 
2023     @Test public void test_rt27180_collapseBranch_laterSiblingAndChildrenSelected() {
2024         sm.setSelectionMode(SelectionMode.MULTIPLE);
2025         sm.setCellSelectionEnabled(false);
2026 
2027         treeTableView.setRoot(myCompanyRootNode);
2028         myCompanyRootNode.setExpanded(true);
2029         salesDepartment.setExpanded(true);
2030         itSupport.setExpanded(true);
2031         sm.clearSelection();
2032         sm.selectIndices(8, 9, 10);     // itSupport, and two people
2033         assertFalse(sm.isSelected(1));  // salesDepartment
2034         assertTrue(sm.isSelected(8));   // itSupport
2035         assertTrue(sm.isSelected(9));   // mikeGraham
2036         assertTrue(sm.isSelected(10));  // judyMayer
2037         assertTrue(treeTableView.getFocusModel().isFocused(10));
2038         assertEquals(debug(), 3, sm.getSelectedIndices().size());
2039 
2040         salesDepartment.setExpanded(false);
2041         assertTrue(debug(), sm.isSelected(2));   // itSupport
2042         assertTrue(sm.isSelected(3));   // mikeGraham
2043         assertTrue(sm.isSelected(4));   // judyMayer
2044         assertTrue(treeTableView.getFocusModel().isFocused(4));
2045         assertEquals(3, sm.getSelectedIndices().size());
2046     }
2047 
2048     @Test public void test_rt27180_expandBranch_laterSiblingSelected_singleSelection() {
2049         sm.setCellSelectionEnabled(false);
2050         sm.setSelectionMode(SelectionMode.SINGLE);
2051 
2052         treeTableView.setRoot(myCompanyRootNode);
2053         myCompanyRootNode.setExpanded(true);
2054         salesDepartment.setExpanded(false);
2055         itSupport.setExpanded(true);
2056         sm.select(2);                   // itSupport
2057         assertFalse(sm.isSelected(1));  // salesDepartment
2058         assertTrue(sm.isSelected(2));   // itSupport
2059         assertTrue(treeTableView.getFocusModel().isFocused(2));
2060         assertEquals(1, sm.getSelectedIndices().size());
2061 
2062         salesDepartment.setExpanded(true);
2063         assertTrue(debug(), sm.isSelected(8));   // itSupport
2064         assertTrue(treeTableView.getFocusModel().isFocused(8));
2065         assertEquals(1, sm.getSelectedIndices().size());
2066     }
2067 
2068     @Test public void test_rt27180_expandBranch_laterSiblingAndChildrenSelected() {
2069         sm.setSelectionMode(SelectionMode.MULTIPLE);
2070         sm.setCellSelectionEnabled(false);
2071 
2072         treeTableView.setRoot(myCompanyRootNode);
2073         myCompanyRootNode.setExpanded(true);
2074         salesDepartment.setExpanded(false);
2075         itSupport.setExpanded(true);
2076         sm.clearSelection();
2077         sm.selectIndices(2,3,4);     // itSupport, and two people
2078         assertFalse(sm.isSelected(1));  // salesDepartment
2079         assertTrue(sm.isSelected(2));   // itSupport
2080         assertTrue(sm.isSelected(3));   // mikeGraham
2081         assertTrue(sm.isSelected(4));  // judyMayer
2082         assertTrue(treeTableView.getFocusModel().isFocused(4));
2083         assertEquals(3, sm.getSelectedIndices().size());
2084 
2085         salesDepartment.setExpanded(true);
2086         assertTrue(debug(), sm.isSelected(8));   // itSupport
2087         assertTrue(sm.isSelected(9));   // mikeGraham
2088         assertTrue(sm.isSelected(10));   // judyMayer
2089         assertTrue(treeTableView.getFocusModel().isFocused(10));
2090         assertEquals(3, sm.getSelectedIndices().size());
2091     }
2092 
2093     @Test public void test_rt30400() {
2094         // create a treetableview that&#39;ll render cells using the check box cell factory
2095         TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
2096         final TreeTableView&lt;String&gt; tableView = new TreeTableView&lt;String&gt;(rootItem);
2097         tableView.setMinHeight(100);
2098         tableView.setPrefHeight(100);
2099 
2100         TreeTableColumn&lt;String, String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2101         firstNameCol.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
2102         firstNameCol.setCellFactory(CheckBoxTreeTableCell.forTreeTableColumn(param -&gt; new ReadOnlyBooleanWrapper(true)));
2103         tableView.getColumns().add(firstNameCol);
2104 
2105         // because only the first row has data, all other rows should be
2106         // empty (and not contain check boxes - we just check the first four here)
2107         VirtualFlowTestUtils.assertRowsNotEmpty(tableView, 0, 1);
2108         VirtualFlowTestUtils.assertCellNotEmpty(VirtualFlowTestUtils.getCell(tableView, 0));
2109         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 1));
2110         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 2));
2111         VirtualFlowTestUtils.assertCellEmpty(VirtualFlowTestUtils.getCell(tableView, 3));
2112     }
2113 
2114     @Ignore(&quot;This bug is not yet fixed&quot;)
2115     @Test public void test_rt31165() {
2116         installChildren();
2117         treeTableView.setEditable(true);
2118 
2119         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2120         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2121         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2122         firstNameCol.setEditable(true);
2123 
2124         treeTableView.getColumns().add(firstNameCol);
2125 
2126         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 1, 0);
2127         assertEquals(&quot;TEST&quot;, cell.getText());
2128         assertFalse(cell.isEditing());
2129 
2130         treeTableView.edit(1, firstNameCol);
2131 
2132         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2133         assertTrue(cell.isEditing());
2134 
2135         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2136         Toolkit.getToolkit().firePulse();
2137 
2138         assertEquals(child1, treeTableView.getEditingCell().getTreeItem());
2139         assertTrue(cell.isEditing());
2140     }
2141 
2142     @Test public void test_rt31404() {
2143         installChildren();
2144 
2145         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2146         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2147 
2148         treeTableView.getColumns().add(firstNameCol);
2149 
2150         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2151         assertEquals(&quot;Root&quot;, cell.getText());
2152 
2153         treeTableView.setShowRoot(false);
2154         assertEquals(&quot;Child 1&quot;, cell.getText());
2155     }
2156 
2157     @Test public void test_rt31471() {
2158         installChildren();
2159 
2160         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2161         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2162 
2163         treeTableView.getColumns().add(firstNameCol);
2164 
2165         IndexedCell cell = VirtualFlowTestUtils.getCell(treeTableView, 0);
2166         assertEquals(&quot;Root&quot;, cell.getItem());
2167 
2168         treeTableView.setFixedCellSize(50);
2169 
2170         VirtualFlowTestUtils.getVirtualFlow(treeTableView).requestLayout();
2171         Toolkit.getToolkit().firePulse();
2172 
2173         assertEquals(&quot;Root&quot;, cell.getItem());
2174         assertEquals(50, cell.getHeight(), 0.00);
2175     }
2176 
2177     @Test public void test_rt30466() {
2178         final Node graphic1 = new Circle(6.75, Color.RED);
2179         final Node graphic2 = new Circle(6.75, Color.GREEN);
2180 
2181         installChildren();
2182 
2183         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2184         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2185 
2186         treeTableView.getColumns().add(firstNameCol);
2187 
2188         TreeTableRow cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2189         assertEquals(&quot;Root&quot;, cell.getItem());
2190 
2191         // set the first graphic - which we expect to see as a child of the cell
2192         root.setGraphic(graphic1);
2193         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2194         boolean matchGraphic1 = false;
2195         boolean matchGraphic2 = false;
2196         for (Node n : cell.getChildrenUnmodifiable()) {
2197             if (n == graphic1) {
2198                 matchGraphic1 = true;
2199             }
2200             if (n == graphic2) {
2201                 matchGraphic2 = true;
2202             }
2203         }
2204         assertTrue(matchGraphic1);
2205         assertFalse(matchGraphic2);
2206 
2207         // set the second graphic - which we also expect to see - but of course graphic1 should not be a child any longer
2208         root.setGraphic(graphic2);
2209         cell = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2210         matchGraphic1 = false;
2211         matchGraphic2 = false;
2212         for (Node n : cell.getChildrenUnmodifiable()) {
2213             if (n == graphic1) {
2214                 matchGraphic1 = true;
2215             }
2216             if (n == graphic2) {
2217                 matchGraphic2 = true;
2218             }
2219         }
2220         assertFalse(matchGraphic1);
2221         assertTrue(matchGraphic2);
2222     }
2223 
2224     private int rt_31200_count = 0;
2225     @Test public void test_rt_31200_tableCell() {
2226         rt_31200_count = 0;
2227 
2228         installChildren();
2229         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2230         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2231         treeTableView.getColumns().add(firstNameCol);
2232 
2233         firstNameCol.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2234             @Override
2235             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2236                 return new TreeTableCellShim&lt;String, String&gt;() {
2237                     ImageView view = new ImageView();
2238 
2239                     {
2240                         setGraphic(view);
2241                     }
2242 
2243                     ;
2244 
2245                     @Override
2246                     public void updateItem(String item, boolean empty) {
2247                         if (getItem() == null ? item == null : getItem().equals(item)) {
2248                             rt_31200_count++;
2249                         }
2250                         super.updateItem(item, empty);
2251                         if (item == null || empty) {
2252                             view.setImage(null);
2253                             setText(null);
2254                         } else {
2255                             setText(item);
2256                         }
2257                     }
2258                 };
2259             }
2260         });
2261 
2262         StageLoader sl = new StageLoader(treeTableView);
2263 
2264         assertEquals(12, rt_31200_count);
2265 
2266         // resize the stage
2267         sl.getStage().setHeight(250);
2268         Toolkit.getToolkit().firePulse();
2269         sl.getStage().setHeight(50);
2270         Toolkit.getToolkit().firePulse();
2271         assertEquals(12, rt_31200_count);
2272 
2273         sl.dispose();
2274     }
2275 
2276     @Test public void test_rt_31200_tableRow() {
2277         rt_31200_count = 0;
2278 
2279         installChildren();
2280         TreeTableColumn&lt;String,String&gt; firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
2281         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
2282         treeTableView.getColumns().add(firstNameCol);
2283 
2284         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2285             @Override
2286             public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2287                 return new TreeTableRowShim&lt;String&gt;() {
2288                     ImageView view = new ImageView();
2289 
2290                     {
2291                         setGraphic(view);
2292                     }
2293 
2294                     ;
2295 
2296                     @Override
2297                     public void updateItem(String item, boolean empty) {
2298                         if (getItem() == null ? item == null : getItem().equals(item)) {
2299                             rt_31200_count++;
2300                         }
2301                         super.updateItem(item, empty);
2302                         if (item == null || empty) {
2303                             view.setImage(null);
2304                             setText(null);
2305                         } else {
2306                             setText(item.toString());
2307                         }
2308                     }
2309                 };
2310             }
2311         });
2312 
2313         StageLoader sl = new StageLoader(treeTableView);
2314 
2315         assertEquals(21, rt_31200_count);
2316 
2317         // resize the stage
2318         sl.getStage().setHeight(250);
2319         Toolkit.getToolkit().firePulse();
2320         sl.getStage().setHeight(50);
2321         Toolkit.getToolkit().firePulse();
2322         assertEquals(21, rt_31200_count);
2323 
2324         sl.dispose();
2325     }
2326 
2327     @Test public void test_rt_31727() {
2328         installChildren();
2329         treeTableView.setEditable(true);
2330 
2331         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
2332         firstNameCol.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(&quot;TEST&quot;));
2333         firstNameCol.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2334         firstNameCol.setEditable(true);
2335 
2336         treeTableView.getColumns().add(firstNameCol);
2337 
2338         treeTableView.setEditable(true);
2339         firstNameCol.setEditable(true);
2340 
2341         // do a normal edit
2342         treeTableView.edit(0, firstNameCol);
2343         TreeTablePosition editingCell = treeTableView.getEditingCell();
2344         assertNotNull(editingCell);
2345         assertEquals(0, editingCell.getRow());
2346         assertEquals(0, editingCell.getColumn());
2347         assertEquals(firstNameCol, editingCell.getTableColumn());
2348         assertEquals(treeTableView, editingCell.getTreeTableView());
2349 
2350         // cancel editing
2351         treeTableView.edit(-1, null);
2352         editingCell = treeTableView.getEditingCell();
2353         assertNull(editingCell);
2354     }
2355 
2356     @Test public void test_rt_21517() {
2357         installChildren();
2358 
2359 //        final TableSelectionModel sm = t.getSelectionModel();
2360         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2361         col.setSortType(ASCENDING);
2362         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2363         treeTableView.getColumns().add(col);
2364 
2365         // test pre-conditions
2366         assertEquals(0, sm.getSelectedCells().size());
2367         assertEquals(0, sm.getSelectedItems().size());
2368         assertEquals(0, sm.getSelectedIndices().size());
2369 
2370         // select the 4th row (that is, the third child of the root)
2371         sm.select(3);
2372         assertTrue(sm.isSelected(3));
2373         assertEquals(3, sm.getSelectedIndex());
2374         assertEquals(1, sm.getSelectedIndices().size());
2375         assertTrue(sm.getSelectedIndices().contains(3));
2376         assertEquals(child3, sm.getSelectedItem());
2377         assertEquals(1, sm.getSelectedItems().size());
2378         assertTrue(sm.getSelectedItems().contains(child3));
2379 
2380         // we also want to test visually
2381         TreeTableRow rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2382         assertFalse(rootRow.isSelected());
2383         TreeTableRow child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2384         assertTrue(child3Row.isSelected());
2385 
2386         // sort tableview by firstname column in ascending (default) order
2387         // (so aaa continues to come first)
2388         treeTableView.getSortOrder().add(col);
2389 
2390         // nothing should have changed
2391         assertTrue(sm.isSelected(3));
2392         assertEquals(3, sm.getSelectedIndex());
2393         assertEquals(1, sm.getSelectedIndices().size());
2394         assertTrue(sm.getSelectedIndices().contains(3));
2395         assertEquals(child3, sm.getSelectedItem());
2396         assertEquals(1, sm.getSelectedItems().size());
2397         assertTrue(sm.getSelectedItems().contains(child3));
2398         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2399         assertFalse(rootRow.isSelected());
2400         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 3);
2401         assertTrue(child3Row.isSelected());
2402 
2403         // continue to sort tableview by firstname column, but now in descending
2404         // order, (so ccc to come first)
2405         col.setSortType(TreeTableColumn.SortType.DESCENDING);
2406 
2407         // now test to ensure that CCC is still the only selected item, but now
2408         // located in index 1 (as the first child of the root)
2409         assertTrue(debug(), sm.isSelected(1));
2410         assertEquals(1, sm.getSelectedIndex());
2411         assertEquals(1, sm.getSelectedIndices().size());
2412         assertTrue(sm.getSelectedIndices().contains(1));
2413         assertEquals(child3, sm.getSelectedItem());
2414         assertEquals(1, sm.getSelectedItems().size());
2415         assertTrue(sm.getSelectedItems().contains(child3));
2416 
2417         // we also want to test visually
2418         rootRow = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 0);
2419         assertFalse(rootRow.isSelected());
2420         child3Row = (TreeTableRow) VirtualFlowTestUtils.getCell(treeTableView, 1);
2421         assertTrue(child3Row.isSelected());
2422     }
2423 
2424     @Test public void test_rt_30484_treeTableCell() {
2425         installChildren();
2426 
2427         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2428         col.setSortType(ASCENDING);
2429         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2430         treeTableView.getColumns().add(col);
2431 
2432         col.setCellFactory(new Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2433             @Override
2434             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; param) {
2435                 return new TreeTableCellShim&lt;String, String&gt;() {
2436                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2437                     { setGraphic(graphic); };
2438 
2439                     @Override public void updateItem(String item, boolean empty) {
2440                         super.updateItem(item, empty);
2441                         if (item == null || empty) {
2442                             graphic.setVisible(false);
2443                             setText(null);
2444                         } else {
2445                             graphic.setVisible(true);
2446                             setText(item);
2447                         }
2448                     }
2449                 };
2450             }
2451         });
2452 
2453         // First four rows have content, so the graphic should show.
2454         // All other rows have no content, so graphic should not show.
2455 
2456         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0, 0);
2457         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1, 0);
2458         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2, 0);
2459         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3, 0);
2460         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4, 0);
2461         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5, 0);
2462     }
2463 
2464     @Test public void test_rt_30484_treeTableRow() {
2465         installChildren();
2466 
2467         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2468         col.setSortType(ASCENDING);
2469         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2470         treeTableView.getColumns().add(col);
2471 
2472         treeTableView.setRowFactory(new Callback&lt;TreeTableView&lt;String&gt;, TreeTableRow&lt;String&gt;&gt;() {
2473             @Override public TreeTableRow&lt;String&gt; call(TreeTableView&lt;String&gt; param) {
2474                 return new TreeTableRowShim&lt;String&gt;() {
2475                     Rectangle graphic = new Rectangle(10, 10, Color.RED);
2476                     { setGraphic(graphic); };
2477 
2478                     @Override public void updateItem(String item, boolean empty) {
2479                         super.updateItem(item, empty);
2480                         if (item == null || empty) {
2481                             graphic.setVisible(false);
2482                             setText(null);
2483                         } else {
2484                             graphic.setVisible(true);
2485                             setText(item.toString());
2486                         }
2487                     }
2488                 };
2489             }
2490         });
2491 
2492         // First two rows have content, so the graphic should show.
2493         // All other rows have no content, so graphic should not show.
2494 
2495         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    0);
2496         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    1);
2497         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    2);
2498         VirtualFlowTestUtils.assertGraphicIsVisible(treeTableView,    3);
2499         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 4);
2500         VirtualFlowTestUtils.assertGraphicIsNotVisible(treeTableView, 5);
2501     }
2502 
2503     private int rt_31015_count = 0;
2504     @Test public void test_rt_31015() {
2505         installChildren();
2506         root.getChildren().clear();
2507         treeTableView.setEditable(true);
2508 
2509         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;String, String&gt;(&quot;column&quot;);
2510         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;String&gt;(param.getValue().getValue()));
2511         treeTableView.getColumns().add(col);
2512 
2513         //Set cell factory for cells that allow editing
2514         Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt; cellFactory = new Callback&lt;TreeTableColumn&lt;String,String&gt;, TreeTableCell&lt;String, String&gt;&gt;() {
2515             public TreeTableCell&lt;String, String&gt; call(TreeTableColumn&lt;String, String&gt; p) {
2516                 return new TreeTableCell&lt;String, String&gt;() {
2517                     @Override public void cancelEdit() {
2518                         super.cancelEdit();
2519                         rt_31015_count++;
2520                     }
2521                 };
2522             }
2523         };
2524         col.setCellFactory(cellFactory);
2525 
2526         StageLoader sl = new StageLoader(treeTableView);
2527 
2528         assertEquals(0, rt_31015_count);
2529 
2530         treeTableView.edit(0, col);
2531         assertEquals(0, rt_31015_count);
2532 
2533         treeTableView.edit(-1, null);
2534         assertEquals(1, rt_31015_count);
2535 
2536         sl.dispose();
2537     }
2538 
2539     @Test public void test_rt_30688() {
2540         installChildren();
2541         root.getChildren().clear();
2542         treeTableView.setColumnResizePolicy(TreeTableView.CONSTRAINED_RESIZE_POLICY);
2543 
2544         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2545         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2546         treeTableView.getColumns().add(col);
2547 
2548         StageLoader sl = new StageLoader(treeTableView);
2549 
2550         assertEquals(TreeTableViewShim.get_contentWidth(treeTableView),
2551                 TableColumnBaseShim.getWidth(col), 0.0);
2552 
2553         sl.dispose();
2554     }
2555 
2556     private int rt_29650_start_count = 0;
2557     private int rt_29650_commit_count = 0;
2558     private int rt_29650_cancel_count = 0;
2559     @Test public void test_rt_29650() {
2560         installChildren();
2561         treeTableView.setEditable(true);
2562 
2563         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2564         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2565         col.setCellFactory(factory);
2566         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2567         treeTableView.getColumns().add(col);
2568 
2569         col.setOnEditStart(t -&gt; {
2570             rt_29650_start_count++;
2571         });
2572         col.setOnEditCommit(t -&gt; {
2573             rt_29650_commit_count++;
2574         });
2575         col.setOnEditCancel(t -&gt; {
2576             rt_29650_cancel_count++;
2577         });
2578 
2579         StageLoader sl = new StageLoader(treeTableView);
2580 
2581         treeTableView.edit(0, col);
2582 
2583         Toolkit.getToolkit().firePulse();
2584 
2585         TreeTableCell rootCell = (TreeTableCell) VirtualFlowTestUtils.getCell(treeTableView, 0, 0);
2586         TextField textField = (TextField) rootCell.getGraphic();
2587         textField.setText(&quot;Testing!&quot;);
2588         KeyEventFirer keyboard = new KeyEventFirer(textField);
2589         keyboard.doKeyPress(KeyCode.ENTER);
2590 
2591         // TODO should the following assert be enabled?
2592 //        assertEquals(&quot;Testing!&quot;, listView.getItems().get(0));
2593         assertEquals(1, rt_29650_start_count);
2594         assertEquals(1, rt_29650_commit_count);
2595         assertEquals(0, rt_29650_cancel_count);
2596 
2597         sl.dispose();
2598     }
2599 
2600     private int rt_29849_start_count = 0;
2601     @Test public void test_rt_29849() {
2602         installChildren();
2603         treeTableView.setEditable(true);
2604 
2605         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2606         col.setEditable(true);
2607         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2608         treeTableView.getColumns().add(col);
2609 
2610         col.setOnEditStart(t -&gt; {
2611             rt_29849_start_count++;
2612         });
2613 
2614         // load the table so the default cells are created
2615         StageLoader sl = new StageLoader(treeTableView);
2616 
2617         // now replace the cell factory
2618         Callback&lt;TreeTableColumn&lt;String, String&gt;, TreeTableCell&lt;String, String&gt;&gt; factory = TextFieldTreeTableCell.forTreeTableColumn();
2619         col.setCellFactory(factory);
2620 
2621         Toolkit.getToolkit().firePulse();
2622 
2623         // now start an edit and count the start edit events - it should be just 1
2624         treeTableView.edit(0, col);
2625         assertEquals(1, rt_29849_start_count);
2626 
2627         sl.dispose();
2628     }
2629 
2630     @Test public void test_rt_34327() {
2631         // by default the comparator is null.
2632         // NOTE: this method (prior to the fix as part of RT-34327) would have
2633         // returned Comparator&lt;String&gt;, but after the fix it correctly returns
2634         // a Comparator&lt;TreeItem&lt;String&gt;&gt;
2635         Comparator nonGenericComparator = treeTableView.getComparator();
2636         Comparator&lt;TreeItem&lt;String&gt;&gt; genericComparator = treeTableView.getComparator();
2637         assertNull(nonGenericComparator);
2638         assertNull(genericComparator);
2639 
2640         // add in a column and some data
2641         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;column&quot;);
2642         col.setEditable(true);
2643         col.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper&lt;&gt;(param.getValue().getValue()));
2644         treeTableView.getColumns().add(col);
2645 
2646         installChildren();
2647 
2648         // sort by that column
2649         treeTableView.getSortOrder().add(col);
2650 
2651         // get the new comparator, which should no longer be null
2652         nonGenericComparator = treeTableView.getComparator();
2653         genericComparator = treeTableView.getComparator();
2654         assertNotNull(nonGenericComparator);
2655         assertNotNull(genericComparator);
2656 
2657         // now, as noted above, previously we would use the Comparator to compare
2658         // two String instances, which would fail at runtime as the Comparator
2659         // was actually expecting to compare two TreeItem&lt;String&gt;, but the API
2660         // was failing us.
2661         try {
2662             nonGenericComparator.compare(&quot;abc&quot;, &quot;def&quot;);
2663             fail(&quot;This should not work!&quot;);
2664         } catch (ClassCastException e) {
2665             // if we get the exception, we&#39;re happy
2666         }
2667 
2668         try {
2669             Object string1 = &quot;abc&quot;;
2670             Object string2 = &quot;def&quot;;
2671             genericComparator.compare((TreeItem&lt;String&gt;)string1, (TreeItem&lt;String&gt;)string2);
2672             fail(&quot;This should not work!&quot;);
2673         } catch (ClassCastException e) {
2674             // if we get the exception, we&#39;re happy
2675         }
2676     }
2677 
2678     @Test public void test_rt26718() {
2679         treeTableView.setRoot(new TreeItem(&quot;Root&quot;));
2680         treeTableView.getRoot().setExpanded(true);
2681 
2682         for (int i = 0; i &lt; 4; i++) {
2683             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2684             treeTableView.getRoot().getChildren().add(parent);
2685 
2686             for (int j = 0; j &lt; 4; j++) {
2687                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2688                 parent.getChildren().add(child);
2689             }
2690         }
2691 
2692         treeTableView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2693 
2694         final TreeItem item0 = treeTableView.getTreeItem(1);
2695         final TreeItem item1 = treeTableView.getTreeItem(2);
2696 
2697         assertEquals(&quot;item - 0&quot;, item0.getValue());
2698         assertEquals(&quot;item - 1&quot;, item1.getValue());
2699 
2700         item0.setExpanded(true);
2701         item1.setExpanded(true);
2702         Toolkit.getToolkit().firePulse();
2703 
2704         treeTableView.getSelectionModel().selectRange(0, 8);
2705         assertEquals(8, treeTableView.getSelectionModel().getSelectedIndices().size());
2706         assertEquals(7, treeTableView.getSelectionModel().getSelectedIndex());
2707         assertEquals(7, treeTableView.getFocusModel().getFocusedIndex());
2708 
2709         // collapse item0 - but because the selected and focused indices are
2710         // not children of item 0, they should remain where they are (but of
2711         // course be shifted up). The bug was that focus was moving up to item0,
2712         // which makes no sense
2713         item0.setExpanded(false);
2714         Toolkit.getToolkit().firePulse();
2715         assertEquals(3, treeTableView.getSelectionModel().getSelectedIndex());
2716         assertEquals(3, treeTableView.getFocusModel().getFocusedIndex());
2717     }
2718 
2719 //    @Ignore(&quot;Test started intermittently failing, most probably due to RT-36855 changeset&quot;)
2720     @Test public void test_rt_34493() {
2721         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2722             new TreeItem&lt;Person&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;))
2723         );
2724 
2725         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2726 
2727         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2728         root.setExpanded(true);
2729         table.setRoot(root);
2730         table.setShowRoot(false);
2731         root.getChildren().setAll(persons);
2732 
2733         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2734         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2735 
2736         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
2737         last.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
2738 
2739         TreeTableColumn email = new TreeTableColumn(&quot;Email&quot;);
2740         email.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;email&quot;));
2741 
2742         table.getColumns().addAll(first, last, email);
2743 
2744         // load the table
2745         StageLoader sl = new StageLoader(table);
2746 
2747         // resize the last column
2748         TableColumnBaseHelper.setWidth(last, 400);
2749         assertEquals(400, last.getWidth(), 0.0);
2750 
2751         // hide the first column
2752         table.getColumns().remove(first);
2753         Toolkit.getToolkit().firePulse();
2754 
2755         // the last column should still be 400px, not the default width or any
2756         // other value (based on the width of the content in that column)
2757         assertEquals(400, last.getWidth(), 0.0);
2758 
2759         sl.dispose();
2760     }
2761 
2762     @Test public void test_rt26721_collapseParent_firstRootChild() {
2763         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2764         table.setRoot(new TreeItem(&quot;Root&quot;));
2765         table.getRoot().setExpanded(true);
2766 
2767         for (int i = 0; i &lt; 4; i++) {
2768             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2769             table.getRoot().getChildren().add(parent);
2770 
2771             for (int j = 0; j &lt; 4; j++) {
2772                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2773                 parent.getChildren().add(child);
2774             }
2775         }
2776 
2777         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2778 
2779         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2780         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2781         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2782 
2783         assertEquals(&quot;item - 0&quot;, item0.getValue());
2784         assertEquals(&quot;item - 1&quot;, item1.getValue());
2785 
2786         item0.setExpanded(true);
2787         item1.setExpanded(true);
2788         Toolkit.getToolkit().firePulse();
2789 
2790         // select the first child of item0
2791         table.getSelectionModel().select(item0child0);
2792 
2793         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
2794         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
2795 
2796         // collapse item0 - we expect the selection / focus to move up to item0
2797         item0.setExpanded(false);
2798         Toolkit.getToolkit().firePulse();
2799         assertEquals(item0, table.getSelectionModel().getSelectedItem());
2800         assertEquals(item0, table.getFocusModel().getFocusedItem());
2801     }
2802 
2803     @Test public void test_rt26721_collapseParent_lastRootChild() {
2804         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2805         table.setRoot(new TreeItem(&quot;Root&quot;));
2806         table.getRoot().setExpanded(true);
2807 
2808         for (int i = 0; i &lt; 4; i++) {
2809             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2810             table.getRoot().getChildren().add(parent);
2811 
2812             for (int j = 0; j &lt; 4; j++) {
2813                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2814                 parent.getChildren().add(child);
2815             }
2816         }
2817 
2818         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2819 
2820         final TreeItem&lt;String&gt; item3 = table.getTreeItem(4);
2821         final TreeItem&lt;String&gt; item3child0 = item3.getChildren().get(0);
2822 
2823         assertEquals(&quot;item - 3&quot;, item3.getValue());
2824         assertEquals(&quot;item - 3 0&quot;, item3child0.getValue());
2825 
2826         item3.setExpanded(true);
2827         Toolkit.getToolkit().firePulse();
2828 
2829         // select the first child of item0
2830         table.getSelectionModel().select(item3child0);
2831 
2832         assertEquals(item3child0, table.getSelectionModel().getSelectedItem());
2833         assertEquals(item3child0, table.getFocusModel().getFocusedItem());
2834 
2835         // collapse item3 - we expect the selection / focus to move up to item3
2836         item3.setExpanded(false);
2837         Toolkit.getToolkit().firePulse();
2838         assertEquals(item3, table.getSelectionModel().getSelectedItem());
2839         assertEquals(item3, table.getFocusModel().getFocusedItem());
2840     }
2841 
2842     @Test public void test_rt26721_collapseGrandParent() {
2843         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2844         table.setRoot(new TreeItem(&quot;Root&quot;));
2845         table.getRoot().setExpanded(true);
2846 
2847         for (int i = 0; i &lt; 4; i++) {
2848             TreeItem parent = new TreeItem(&quot;item - &quot; + i);
2849             table.getRoot().getChildren().add(parent);
2850 
2851             for (int j = 0; j &lt; 4; j++) {
2852                 TreeItem child = new TreeItem(&quot;item - &quot; + i + &quot; &quot; + j);
2853                 parent.getChildren().add(child);
2854             }
2855         }
2856 
2857         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
2858 
2859         final TreeItem&lt;String&gt; item0 = table.getTreeItem(1);
2860         final TreeItem&lt;String&gt; item0child0 = item0.getChildren().get(0);
2861         final TreeItem&lt;String&gt; item1 = table.getTreeItem(2);
2862 
2863         assertEquals(&quot;item - 0&quot;, item0.getValue());
2864         assertEquals(&quot;item - 1&quot;, item1.getValue());
2865 
2866         item0.setExpanded(true);
2867         item1.setExpanded(true);
2868         Toolkit.getToolkit().firePulse();
2869 
2870         // select the first child of item0
2871         table.getSelectionModel().select(item0child0);
2872 
2873         assertEquals(item0child0, table.getSelectionModel().getSelectedItem());
2874         assertEquals(item0child0, table.getFocusModel().getFocusedItem());
2875 
2876         // collapse root - we expect the selection / focus to move up to root
2877         table.getRoot().setExpanded(false);
2878         Toolkit.getToolkit().firePulse();
2879         assertEquals(table.getRoot(), table.getSelectionModel().getSelectedItem());
2880         assertEquals(table.getRoot(), table.getFocusModel().getFocusedItem());
2881     }
2882 
2883     @Test public void test_rt_34685_directEditCall_cellSelectionMode() {
2884         test_rt_34685_commitCount = 0;
2885         test_rt_34685(false, true);
2886     }
2887 
2888     @Test public void test_rt_34685_directEditCall_rowSelectionMode() {
2889         test_rt_34685_commitCount = 0;
2890         test_rt_34685(false, false);
2891     }
2892 
2893     @Test public void test_rt_34685_mouseDoubleClick_cellSelectionMode() {
2894         test_rt_34685_commitCount = 0;
2895         test_rt_34685(true, true);
2896     }
2897 
2898     @Test public void test_rt_34685_mouseDoubleClick_rowSelectionMode() {
2899         test_rt_34685_commitCount = 0;
2900         test_rt_34685(true, false);
2901     }
2902 
2903     private int test_rt_34685_commitCount = 0;
2904     private void test_rt_34685(boolean useMouseToInitiateEdit, boolean cellSelectionModeEnabled) {
2905         assertEquals(0, test_rt_34685_commitCount);
2906 
2907         Person person1;
2908         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
2909             new TreeItem&lt;&gt;(person1 = new Person(&quot;John&quot;, &quot;Smith&quot;, &quot;john.smith@example.com&quot;))
2910         );
2911 
2912         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
2913         table.getSelectionModel().setCellSelectionEnabled(cellSelectionModeEnabled);
2914         table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
2915         table.setEditable(true);
2916 
2917         TreeItem&lt;Person&gt; root = new TreeItem&lt;Person&gt;(new Person(&quot;Root&quot;, null, null));
2918         root.setExpanded(true);
2919         table.setRoot(root);
2920         table.setShowRoot(false);
2921         root.getChildren().setAll(persons);
2922 
2923         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
2924         first.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
2925         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
2926 
2927         EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt; onEditCommit = first.getOnEditCommit();
2928         first.setOnEditCommit(new EventHandler&lt;TreeTableColumn.CellEditEvent&lt;Person, String&gt;&gt;() {
2929             @Override public void handle(TreeTableColumn.CellEditEvent&lt;Person, String&gt; event) {
2930                 test_rt_34685_commitCount++;
2931                 onEditCommit.handle(event);
2932             }
2933         });
2934 
2935         table.getColumns().addAll(first);
2936 
2937         // get the cell at (0,0) - we&#39;re hiding the root row
2938         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;
2939         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, 0, 0);
2940         VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;
2941         assertTrue(cell.getSkin() instanceof TreeTableCellSkin);
2942         assertNull(cell.getGraphic());
2943         assertEquals(&quot;John&quot;, cell.getText());
2944         assertEquals(&quot;John&quot;, person1.getFirstName());
2945 
2946         // set the table to be editing the first cell at 0,0
2947         if (useMouseToInitiateEdit) {
2948             MouseEventFirer mouse = new MouseEventFirer(cell);
2949             mouse.fireMousePressAndRelease(2, 10, 10);  // click 10 pixels in and 10 pixels down
2950             mouse.dispose();
2951         } else {
2952             table.edit(0,first);
2953         }
2954 
2955         Toolkit.getToolkit().firePulse();
2956         assertNotNull(cell.getGraphic());
2957         assertTrue(cell.getGraphic() instanceof TextField);
2958 
2959         TextField textField = (TextField) cell.getGraphic();
2960         assertEquals(&quot;John&quot;, textField.getText());
2961 
2962         textField.setText(&quot;Andrew&quot;);
2963         textField.requestFocus();
2964         Toolkit.getToolkit().firePulse();
2965 
2966         KeyEventFirer keyboard = new KeyEventFirer(textField);
2967         keyboard.doKeyPress(KeyCode.ENTER);
2968 
2969         VirtualFlowTestUtils.getVirtualFlow(table).requestLayout();
2970         Toolkit.getToolkit().firePulse();
2971 
2972         VirtualFlowTestUtils.assertTableCellTextEquals(table, 0, 0, &quot;Andrew&quot;);
2973         assertEquals(&quot;Andrew&quot;, cell.getText());
2974         assertEquals(&quot;Andrew&quot;, person1.getFirstName());
2975         assertEquals(1, test_rt_34685_commitCount);
2976     }
2977 
2978     @Test public void test_rt34694() {
2979         TreeItem treeNode = new TreeItem(&quot;Controls&quot;);
2980         treeNode.getChildren().addAll(
2981                 new TreeItem(&quot;Button&quot;),
2982                 new TreeItem(&quot;ButtonBar&quot;),
2983                 new TreeItem(&quot;LinkBar&quot;),
2984                 new TreeItem(&quot;LinkButton&quot;),
2985                 new TreeItem(&quot;PopUpButton&quot;),
2986                 new TreeItem(&quot;ToggleButtonBar&quot;)
2987         );
2988 
2989         final TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
2990         table.setRoot(treeNode);
2991         treeNode.setExpanded(true);
2992 
2993         table.getSelectionModel().select(0);
2994         assertTrue(table.getSelectionModel().isSelected(0));
2995         assertTrue(table.getFocusModel().isFocused(0));
2996 
2997         treeNode.getChildren().clear();
2998         treeNode.getChildren().addAll(
2999                 new TreeItem(&quot;Button1&quot;),
3000                 new TreeItem(&quot;ButtonBar1&quot;),
3001                 new TreeItem(&quot;LinkBar1&quot;),
3002                 new TreeItem(&quot;LinkButton1&quot;),
3003                 new TreeItem(&quot;PopUpButton1&quot;),
3004                 new TreeItem(&quot;ToggleButtonBar1&quot;)
3005         );
3006         Toolkit.getToolkit().firePulse();
3007 
3008         assertTrue(table.getSelectionModel().isSelected(0));
3009         assertTrue(table.getFocusModel().isFocused(0));
3010     }
3011 
3012     private int test_rt_35213_eventCount = 0;
3013     @Test public void test_rt35213() {
3014         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
3015 
3016         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Boss&quot;);
3017         view.setRoot(root);
3018 
3019         TreeItem&lt;String&gt; group1 = new TreeItem&lt;&gt;(&quot;Group 1&quot;);
3020         TreeItem&lt;String&gt; group2 = new TreeItem&lt;&gt;(&quot;Group 2&quot;);
3021         TreeItem&lt;String&gt; group3 = new TreeItem&lt;&gt;(&quot;Group 3&quot;);
3022 
3023         root.getChildren().addAll(group1, group2, group3);
3024 
3025         TreeItem&lt;String&gt; employee1 = new TreeItem&lt;&gt;(&quot;Employee 1&quot;);
3026         TreeItem&lt;String&gt; employee2 = new TreeItem&lt;&gt;(&quot;Employee 2&quot;);
3027 
3028         group2.getChildren().addAll(employee1, employee2);
3029 
3030         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;Name&quot;);
3031         nameColumn.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
3032         view.getColumns().add(nameColumn);
3033 
3034         view.expandedItemCountProperty().addListener((observableValue, oldCount, newCount) -&gt; {
3035 
3036             // DEBUG OUTPUT
3037 //                System.out.println(&quot;new expanded item count: &quot; + newCount.intValue());
3038 //                for (int i = 0; i &lt; newCount.intValue(); i++) {
3039 //                    TreeItem&lt;String&gt; item = view.getTreeItem(i);
3040 //                    String text = item.getValue();
3041 //                    System.out.println(&quot;person found at index &quot; + i + &quot; is &quot; + text);
3042 //                }
3043 //                System.out.println(&quot;------------------------------------------&quot;);
3044 
3045             if (test_rt_35213_eventCount == 0) {
3046                 assertEquals(4, newCount);
3047                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3048                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3049                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3050                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3051             } else if (test_rt_35213_eventCount == 1) {
3052                 assertEquals(6, newCount);
3053                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3054                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3055                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3056                 assertEquals(&quot;Employee 1&quot;, view.getTreeItem(3).getValue());
3057                 assertEquals(&quot;Employee 2&quot;, view.getTreeItem(4).getValue());
3058                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(5).getValue());
3059             } else if (test_rt_35213_eventCount == 2) {
3060                 assertEquals(4, newCount);
3061                 assertEquals(&quot;Boss&quot;, view.getTreeItem(0).getValue());
3062                 assertEquals(&quot;Group 1&quot;, view.getTreeItem(1).getValue());
3063                 assertEquals(&quot;Group 2&quot;, view.getTreeItem(2).getValue());
3064                 assertEquals(&quot;Group 3&quot;, view.getTreeItem(3).getValue());
3065             }
3066 
3067             test_rt_35213_eventCount++;
3068         });
3069 
3070         StageLoader sl = new StageLoader(view);
3071 
3072         root.setExpanded(true);
3073         Toolkit.getToolkit().firePulse();
3074 
3075         group2.setExpanded(true);
3076         Toolkit.getToolkit().firePulse();
3077 
3078         group2.setExpanded(false);
3079         Toolkit.getToolkit().firePulse();
3080 
3081         sl.dispose();
3082     }
3083 
3084     @Test public void test_rt23245_itemIsInTree() {
3085         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;String&gt;();
3086         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3087         for (int i = 0; i &lt; 10; i++) {
3088             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3089             item.setExpanded(true);
3090             items.add(item);
3091         }
3092 
3093         // link the items up so that the next item is the child of the current item
3094         for (int i = 0; i &lt; 9; i++) {
3095             items.get(i).getChildren().add(items.get(i + 1));
3096         }
3097 
3098         view.setRoot(items.get(0));
3099 
3100         for (int i = 0; i &lt; 10; i++) {
3101             // we expect the level of the tree item at the ith position to be
3102             // 0, as every iteration we are setting the ith item as the root.
3103             assertEquals(0, view.getTreeItemLevel(items.get(i)));
3104 
3105             // whilst we are testing, we should also ensure that the ith item
3106             // is indeed the root item, and that the ith item is indeed the item
3107             // at the 0th position
3108             assertEquals(items.get(i), view.getRoot());
3109             assertEquals(items.get(i), view.getTreeItem(0));
3110 
3111             // shuffle the next item into the root position (keeping its parent
3112             // chain intact - which is what exposes this issue in the first place).
3113             if (i &lt; 9) {
3114                 view.setRoot(items.get(i + 1));
3115             }
3116         }
3117     }
3118 
3119     @Test public void test_rt23245_itemIsNotInTree_noRootNode() {
3120         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3121         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3122         for (int i = 0; i &lt; 10; i++) {
3123             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3124             item.setExpanded(true);
3125             items.add(item);
3126         }
3127 
3128         // link the items up so that the next item is the child of the current item
3129         for (int i = 0; i &lt; 9; i++) {
3130             items.get(i).getChildren().add(items.get(i + 1));
3131         }
3132 
3133         for (int i = 0; i &lt; 10; i++) {
3134             // because we have no root (and we are not changing the root like
3135             // the previous test), we expect the tree item level of the item
3136             // in the ith position to be i.
3137             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3138 
3139             // all items requested from the TreeView should be null, as the
3140             // TreeView does not have a root item
3141             assertNull(view.getTreeItem(i));
3142         }
3143     }
3144 
3145     @Test public void test_rt23245_itemIsNotInTree_withUnrelatedRootNode() {
3146         final TreeView&lt;String&gt; view = new TreeView&lt;String&gt;();
3147         final List&lt;TreeItem&lt;String&gt;&gt; items = new ArrayList&lt;&gt;();
3148         for (int i = 0; i &lt; 10; i++) {
3149             final TreeItem&lt;String&gt; item = new TreeItem&lt;String&gt;(&quot;Item&quot; + i);
3150             item.setExpanded(true);
3151             items.add(item);
3152         }
3153 
3154         // link the items up so that the next item is the child of the current item
3155         for (int i = 0; i &lt; 9; i++) {
3156             items.get(i).getChildren().add(items.get(i + 1));
3157         }
3158 
3159         view.setRoot(new TreeItem(&quot;Unrelated root node&quot;));
3160 
3161         for (int i = 0; i &lt; 10; i++) {
3162             // because we have no root (and we are not changing the root like
3163             // the previous test), we expect the tree item level of the item
3164             // in the ith position to be i.
3165             assertEquals(i, view.getTreeItemLevel(items.get(i)));
3166 
3167             // all items requested from the TreeView should be null except for
3168             // the root node
3169             assertNull(view.getTreeItem(i + 1));
3170         }
3171     }
3172 
3173     @Test public void test_rt35039_setRoot() {
3174         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3175         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3176 
3177         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3178         root.setExpanded(true);
3179         root.getChildren().setAll(aabbaa, bbc);
3180 
3181         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3182         treeView.setRoot(root);
3183 
3184         StageLoader sl = new StageLoader(treeView);
3185 
3186         // Selection starts in row -1
3187         assertNull(treeView.getSelectionModel().getSelectedItem());
3188 
3189         // select &quot;bbc&quot; and ensure everything is set to that
3190         treeView.getSelectionModel().select(2);
3191         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3192 
3193         // change the items list - but retain the same content. We expect
3194         // that &quot;bbc&quot; remains selected as it is still in the list
3195         treeView.setRoot(root);
3196         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3197 
3198         sl.dispose();
3199     }
3200 
3201     @Test public void test_rt35039_resetRootChildren() {
3202         TreeItem aabbaa = new TreeItem(&quot;aabbaa&quot;);
3203         TreeItem bbc = new TreeItem(&quot;bbc&quot;);
3204 
3205         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3206         root.setExpanded(true);
3207         root.getChildren().setAll(aabbaa, bbc);
3208 
3209         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3210         treeView.setRoot(root);
3211 
3212         StageLoader sl = new StageLoader(treeView);
3213 
3214         // Selection starts in row -1
3215         assertNull(treeView.getSelectionModel().getSelectedItem());
3216 
3217         // select &quot;bbc&quot; and ensure everything is set to that
3218         treeView.getSelectionModel().select(2);
3219         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3220 
3221         // change the items list - but retain the same content. We expect
3222         // that &quot;bbc&quot; remains selected as it is still in the list
3223         root.getChildren().setAll(aabbaa, bbc);
3224         assertEquals(&quot;bbc&quot;, treeView.getSelectionModel().getSelectedItem().getValue());
3225 
3226         sl.dispose();
3227     }
3228 
3229     @Test public void test_rt35763() {
3230         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3231         root.setExpanded(true);
3232         TreeItem aaa = new TreeItem(&quot;aaa&quot;);
3233         TreeItem bbb = new TreeItem(&quot;bbb&quot;);
3234         root.getChildren().setAll(bbb, aaa);
3235 
3236         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;();
3237 
3238         TreeTableColumn&lt;String, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3239         col.setCellValueFactory(param -&gt; param.getValue().valueProperty());
3240 
3241         treeView.getColumns().add(col);
3242         treeView.setRoot(root);
3243 
3244         assertEquals(root, treeView.getTreeItem(0));
3245         assertEquals(bbb, treeView.getTreeItem(1));
3246         assertEquals(aaa,treeView.getTreeItem(2));
3247 
3248         // change sort order - expect items to be sorted
3249         treeView.getSortOrder().setAll(col);
3250 
3251         assertEquals(1, treeView.getSortOrder().size());
3252         assertEquals(col, treeView.getSortOrder().get(0));
3253 
3254         Toolkit.getToolkit().firePulse();
3255 
3256         assertEquals(root, treeView.getTreeItem(0));
3257         assertEquals(bbb, treeView.getTreeItem(2));
3258         assertEquals(aaa,treeView.getTreeItem(1));
3259 
3260         // set new items into items list - expect sortOrder list to be reset
3261         // and the items list to remain unsorted
3262         TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root&quot;);
3263         root2.setExpanded(true);
3264         TreeItem ccc = new TreeItem(&quot;ccc&quot;);
3265         TreeItem ddd = new TreeItem(&quot;ddd&quot;);
3266         root2.getChildren().setAll(ddd, ccc);
3267         treeView.setRoot(root2);
3268 
3269         assertEquals(root2, treeView.getTreeItem(0));
3270         assertEquals(ddd, treeView.getTreeItem(1));
3271         assertEquals(ccc,treeView.getTreeItem(2));
3272 
3273         assertTrue(treeView.getSortOrder().isEmpty());
3274     }
3275 
3276     @Test public void test_rt35857() {
3277         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3278         root.setExpanded(true);
3279         TreeItem a = new TreeItem(&quot;A&quot;);
3280         TreeItem b = new TreeItem(&quot;B&quot;);
3281         TreeItem c = new TreeItem(&quot;C&quot;);
3282         root.getChildren().setAll(a, b, c);
3283 
3284         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;String&gt;(root);
3285 
3286         treeTableView.getSelectionModel().select(1);
3287 
3288         ObservableList&lt;TreeItem&lt;String&gt;&gt; selectedItems = treeTableView.getSelectionModel().getSelectedItems();
3289         assertEquals(1, selectedItems.size());
3290         assertEquals(&quot;A&quot;, selectedItems.get(0).getValue());
3291 
3292         root.getChildren().removeAll(selectedItems);
3293         assertEquals(2, root.getChildren().size());
3294         assertEquals(&quot;B&quot;, root.getChildren().get(0).getValue());
3295         assertEquals(&quot;C&quot;, root.getChildren().get(1).getValue());
3296     }
3297 
3298     private int rt36452_instanceCount = 0;
3299     @Test public void test_rt36452() {
3300         TreeTableColumn&lt;String, String&gt; myColumn = new TreeTableColumn&lt;String,String&gt;();
3301         myColumn.setCellValueFactory((item)-&gt;(new ReadOnlyObjectWrapper&lt;&gt;(item.getValue().getValue())));
3302         myColumn.setCellFactory(column -&gt; new TreeTableCell&lt;String, String&gt;() {
3303             {
3304                 rt36452_instanceCount++;
3305             }
3306         });
3307 
3308         TreeTableView&lt;String&gt; ttv = new TreeTableView&lt;&gt;();
3309         ttv.setShowRoot(false);
3310         ttv.getColumns().add(myColumn);
3311 
3312         TreeItem&lt;String&gt; treeRootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
3313         treeRootItem.setExpanded(true);
3314 
3315         for (int i = 0; i &lt; 100; i++) {
3316             treeRootItem.getChildren().add(new TreeItem&lt;&gt;(&quot;Child: &quot; + i));
3317         }
3318 
3319         ttv.setRoot(treeRootItem);
3320         ttv.setFixedCellSize(25);
3321 
3322         StackPane root = new StackPane();
3323         root.getChildren().add(ttv);
3324 
3325         StageLoader sl = new StageLoader(root);
3326 
3327         final int cellCountAtStart = rt36452_instanceCount;
3328 
3329         // start scrolling
3330         for (int i = 0; i &lt; 100; i++) {
3331             ttv.scrollTo(i);
3332             Toolkit.getToolkit().firePulse();
3333         }
3334 
3335         // we don&#39;t mind if an extra few cells are created. What we are really
3336         // testing for here is that we don&#39;t end up with an order of magnitude
3337         // extra cells.
3338         // On my machine the cellCountAtStart is 16. Before this issue was fixed
3339         // I would end up with 102 instances after running this test. Once the
3340         // bug was fixed, I would consistently see that 17 cells had been
3341         // created in total.
3342         // However, for now, we&#39;ll test on the assumption that across all
3343         // platforms we only get one extra cell created, and we can loosen this
3344         // up if necessary.
3345         assertEquals(cellCountAtStart + 1, rt36452_instanceCount);
3346 
3347         sl.dispose();
3348     }
3349 
3350     @Test public void test_rt25679_rowSelection() {
3351         test_rt25679(true);
3352     }
3353 
3354     @Test public void test_rt25679_cellSelection() {
3355         test_rt25679(false);
3356     }
3357 
3358     private void test_rt25679(boolean rowSelection) {
3359         Button focusBtn = new Button(&quot;Focus here&quot;);
3360 
3361         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
3362         root.getChildren().setAll(new TreeItem(&quot;a&quot;), new TreeItem(&quot;b&quot;));
3363         root.setExpanded(true);
3364 
3365         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3366         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3367         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3368         treeView.getColumns().add(tableColumn);
3369 
3370         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3371         sm.setCellSelectionEnabled(! rowSelection);
3372 
3373         VBox vbox = new VBox(focusBtn, treeView);
3374 
3375         StageLoader sl = new StageLoader(vbox);
3376         sl.getStage().requestFocus();
3377         focusBtn.requestFocus();
3378         Toolkit.getToolkit().firePulse();
3379 
3380         // test initial state
3381         assertEquals(sl.getStage().getScene().getFocusOwner(), focusBtn);
3382         assertTrue(focusBtn.isFocused());
3383         assertEquals(-1, sm.getSelectedIndex());
3384         assertNull(sm.getSelectedItem());
3385 
3386         // move focus to the TreeTableView
3387         treeView.requestFocus();
3388 
3389         // ensure that there is a selection (where previously there was not one)
3390         assertEquals(sl.getStage().getScene().getFocusOwner(), treeView);
3391         assertTrue(treeView.isFocused());
3392 
3393         if (rowSelection) {
3394             assertEquals(0, sm.getSelectedIndices().size());
3395             assertNull(sm.getSelectedItem());
3396             assertFalse(sm.isSelected(0));
3397             assertEquals(0, sm.getSelectedCells().size());
3398         } else {
3399             assertFalse(sm.isSelected(0, tableColumn));
3400             assertEquals(0, sm.getSelectedCells().size());
3401         }
3402 
3403         sl.dispose();
3404     }
3405 
3406     @Test public void test_rt36885() {
3407         test_rt36885(false);
3408     }
3409 
3410     @Test public void test_rt36885_addChildAfterSelection() {
3411         test_rt36885(true);
3412     }
3413 
3414     private void test_rt36885(boolean addChildToAAfterSelection) {
3415         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);         // 0
3416                 TreeItem&lt;String&gt; a = new TreeItem&lt;&gt;(&quot;a&quot;);       // 1
3417                     TreeItem&lt;String&gt; a1 = new TreeItem&lt;&gt;(&quot;a1&quot;); // a expanded = 2, a collapsed = -1
3418             TreeItem&lt;String&gt; b = new TreeItem&lt;&gt;(&quot;b&quot;);           // a expanded = 3, a collapsed = 2
3419                 TreeItem&lt;String&gt; b1 = new TreeItem&lt;&gt;(&quot;b1&quot;);     // a expanded = 4, a collapsed = 3
3420                 TreeItem&lt;String&gt; b2 = new TreeItem&lt;&gt;(&quot;b2&quot;);     // a expanded = 5, a collapsed = 4
3421 
3422         root.setExpanded(true);
3423         root.getChildren().setAll(a, b);
3424 
3425         a.setExpanded(false);
3426         if (!addChildToAAfterSelection) {
3427             a.getChildren().add(a1);
3428         }
3429 
3430         b.setExpanded(true);
3431         b.getChildren().addAll(b1, b2);
3432 
3433         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
3434         TreeTableColumn&lt;String, String&gt; tableColumn = new TreeTableColumn&lt;&gt;();
3435         tableColumn.setCellValueFactory(rowValue -&gt; new SimpleStringProperty(rowValue.getValue().getValue()));
3436         treeView.getColumns().add(tableColumn);
3437 
3438         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = treeView.getSelectionModel();
3439         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = treeView.getFocusModel();
3440 
3441         sm.select(b1);
3442         assertEquals(3, sm.getSelectedIndex());
3443         assertEquals(b1, sm.getSelectedItem());
3444         assertEquals(3, fm.getFocusedIndex());
3445         assertEquals(b1, fm.getFocusedItem());
3446 
3447         if (addChildToAAfterSelection) {
3448             a.getChildren().add(a1);
3449         }
3450 
3451         a.setExpanded(true);
3452         assertEquals(4, sm.getSelectedIndex());
3453         assertEquals(b1, sm.getSelectedItem());
3454         assertEquals(4, fm.getFocusedIndex());
3455         assertEquals(b1, fm.getFocusedItem());
3456     }
3457 
3458     private int rt_37061_index_counter = 0;
3459     private int rt_37061_item_counter = 0;
3460     @Test public void test_rt_37061() {
3461         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3462         root.setExpanded(true);
3463         TreeTableView&lt;Integer&gt; tv = new TreeTableView&lt;&gt;();
3464         tv.setRoot(root);
3465         tv.getSelectionModel().select(0);
3466 
3467         // note we add the listeners after the selection is made, so the counters
3468         // at this point are still both at zero.
3469         tv.getSelectionModel().selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; {
3470             rt_37061_index_counter++;
3471         });
3472 
3473         tv.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; {
3474             rt_37061_item_counter++;
3475         });
3476 
3477         // add a new item. This does not impact the selected index or selected item
3478         // so the counters should remain at zero.
3479         tv.getRoot().getChildren().add(new TreeItem(&quot;1&quot;));
3480         assertEquals(0, rt_37061_index_counter);
3481         assertEquals(0, rt_37061_item_counter);
3482     }
3483 
3484     @Test public void test_rt_37054_noScroll() {
3485         test_rt_37054(false);
3486     }
3487 
3488     @Test public void test_rt_37054_scroll() {
3489         test_rt_37054(true);
3490     }
3491 
3492     private void test_rt_37054(boolean scroll) {
3493         ObjectProperty&lt;Integer&gt; offset = new SimpleObjectProperty&lt;Integer&gt;(0);
3494 
3495         // create table with a bunch of rows and 1 column...
3496         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3497         root.setExpanded(true);
3498         for (int i = 1; i &lt;= 50; i++) {
3499             root.getChildren().add(new TreeItem&lt;&gt;(i));
3500         }
3501 
3502         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3503 
3504         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3505         table.getColumns().add( column );
3506         column.setPrefWidth( 150 );
3507 
3508         // each cell displays x, where x = &quot;cell row number + offset&quot;
3509         column.setCellValueFactory( cdf -&gt; new ObjectBinding&lt;Integer&gt;() {
3510             { super.bind( offset ); }
3511 
3512             @Override protected Integer computeValue() {
3513                 return cdf.getValue().getValue() + offset.get();
3514             }
3515         });
3516 
3517         StackPane stack = new StackPane();
3518         stack.getChildren().add(table);
3519         StageLoader sl = new StageLoader(stack);
3520 
3521         int index = scroll ? 0 : 25;
3522 
3523         if (scroll) {
3524             // we scroll to force the table cells to update the objects they observe
3525             table.scrollTo(index);
3526             Toolkit.getToolkit().firePulse();
3527         }
3528 
3529         TreeTableCell cell = (TreeTableCell) VirtualFlowTestUtils.getCell(table, index + 3, 0);
3530         final int initialValue = (Integer) cell.getItem();
3531 
3532         // increment the offset value
3533         offset.setValue(offset.get() + 1);
3534         Toolkit.getToolkit().firePulse();
3535 
3536         final int incrementedValue = (Integer) cell.getItem();
3537         assertEquals(initialValue + 1, incrementedValue);
3538 
3539         sl.dispose();
3540     }
3541 
3542     private int rt_37395_index_addCount = 0;
3543     private int rt_37395_index_removeCount = 0;
3544     private int rt_37395_index_permutationCount = 0;
3545     private int rt_37395_item_addCount = 0;
3546     private int rt_37395_item_removeCount = 0;
3547     private int rt_37395_item_permutationCount = 0;
3548 
3549     @Test public void test_rt_37395() {
3550         // table items - 3 items, 2nd item has 2 children
3551         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3552 
3553         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3554         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3555         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3556 
3557         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3558         root.getChildren().add(two);
3559         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3560 
3561         // table columns - 1 column; name
3562         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3563         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3564         nameColumn.setPrefWidth(200);
3565 
3566         // table
3567         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3568         table.setShowRoot(false);
3569         table.setRoot(root);
3570         table.getColumns().addAll(nameColumn);
3571 
3572         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
3573         sm.getSelectedIndices().addListener(new ListChangeListener&lt;Integer&gt;() {
3574             @Override public void onChanged(Change&lt;? extends Integer&gt; c) {
3575                 while (c.next()) {
3576                     if (c.wasRemoved()) {
3577                         c.getRemoved().forEach(item -&gt; {
3578                             if (item == null) {
3579                                 fail(&quot;Removed index should never be null&quot;);
3580                             } else {
3581                                 rt_37395_index_removeCount++;
3582                             }
3583                         });
3584                     }
3585                     if (c.wasAdded()) {
3586                         c.getAddedSubList().forEach(item -&gt; {
3587                             rt_37395_index_addCount++;
3588                         });
3589                     }
3590                     if (c.wasPermutated()) {
3591                         rt_37395_index_permutationCount++;
3592                     }
3593                 }
3594             }
3595         });
3596         sm.getSelectedItems().addListener(new ListChangeListener&lt;TreeItem&lt;String&gt;&gt;() {
3597             @Override public void onChanged(Change&lt;? extends TreeItem&lt;String&gt;&gt; c) {
3598                 while (c.next()) {
3599                     if (c.wasRemoved()) {
3600                         c.getRemoved().forEach(item -&gt; {
3601                             if (item == null) {
3602                                 fail(&quot;Removed item should never be null&quot;);
3603                             } else {
3604                                 rt_37395_item_removeCount++;
3605                             }
3606                         });
3607                     }
3608                     if (c.wasAdded()) {
3609                         c.getAddedSubList().forEach(item -&gt; {
3610                             rt_37395_item_addCount++;
3611                         });
3612                     }
3613                     if (c.wasPermutated()) {
3614                         rt_37395_item_permutationCount++;
3615                     }
3616                 }
3617             }
3618         });
3619 
3620         assertEquals(0, rt_37395_index_removeCount);
3621         assertEquals(0, rt_37395_index_addCount);
3622         assertEquals(0, rt_37395_index_permutationCount);
3623         assertEquals(0, rt_37395_item_removeCount);
3624         assertEquals(0, rt_37395_item_addCount);
3625         assertEquals(0, rt_37395_item_permutationCount);
3626 
3627         StageLoader sl = new StageLoader(table);
3628 
3629         // step one: select item &#39;three&#39; in index 2
3630         sm.select(2);
3631         assertEquals(0, rt_37395_index_removeCount);
3632         assertEquals(1, rt_37395_index_addCount);
3633         assertEquals(0, rt_37395_index_permutationCount);
3634         assertEquals(0, rt_37395_item_removeCount);
3635         assertEquals(1, rt_37395_item_addCount);
3636         assertEquals(0, rt_37395_item_permutationCount);
3637 
3638         // step two: expand item &#39;two&#39;
3639         // The first part of the bug report was that we received add/remove
3640         // change events here, when in reality we shouldn&#39;t have, so lets enforce
3641         // that. We do expect a permutation event on the index, as it has been
3642         // pushed down, but this should not result in an item permutation event,
3643         // as it remains unchanged
3644         two.setExpanded(true);
3645         assertEquals(1, rt_37395_index_removeCount);
3646         assertEquals(2, rt_37395_index_addCount);
3647         assertEquals(0, rt_37395_index_permutationCount);
3648         assertEquals(0, rt_37395_item_removeCount);
3649         assertEquals(1, rt_37395_item_addCount);
3650         assertEquals(0, rt_37395_item_permutationCount);
3651 
3652         // step three: collapse item &#39;two&#39;
3653         // Same argument as in step two above: no addition or removal, just a
3654         // permutation on the index
3655         two.setExpanded(false);
3656         assertEquals(2, rt_37395_index_removeCount);
3657         assertEquals(3, rt_37395_index_addCount);
3658         assertEquals(0, rt_37395_index_permutationCount);
3659         assertEquals(0, rt_37395_item_removeCount);
3660         assertEquals(1, rt_37395_item_addCount);
3661         assertEquals(0, rt_37395_item_permutationCount);
3662 
3663         sl.dispose();
3664     }
3665 
3666     @Test public void test_rt_37429() {
3667         // table items - 3 items, 2nd item has 2 children
3668         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3669 
3670         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3671         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3672         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3673         two.setExpanded(true);
3674 
3675         root.getChildren().add(new TreeItem&lt;&gt;(&quot;one&quot;));
3676         root.getChildren().add(two);
3677         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3678 
3679         // table columns - 1 column; name
3680         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3681         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3682         nameColumn.setPrefWidth(200);
3683 
3684         // table
3685         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3686         table.setShowRoot(false);
3687         table.setRoot(root);
3688         table.getColumns().addAll(nameColumn);
3689 
3690         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3691             while (c.next()) {
3692                 if(c.wasRemoved()) {
3693                     // The removed list of items must be iterated or the AIOOBE will
3694                     // not be thrown when getAddedSubList is called.
3695                     c.getRemoved().forEach(item -&gt; {});
3696                 }
3697 
3698                 if (c.wasAdded()) {
3699                     c.getAddedSubList();
3700                 }
3701             }
3702         });
3703 
3704         StageLoader sl = new StageLoader(table);
3705 
3706         ControlTestUtils.runWithExceptionHandler(() -&gt; {
3707             table.getSelectionModel().select(0);
3708             table.getSortOrder().add(nameColumn);
3709         });
3710 
3711         sl.dispose();
3712     }
3713 
3714     private int rt_37429_items_change_count = 0;
3715     private int rt_37429_cells_change_count = 0;
3716     @Test public void test_rt_37429_sortEventsShouldNotFireExtraChangeEvents() {
3717         // table items - 3 items, 2nd item has 2 children
3718         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3719 
3720         root.getChildren().add(new TreeItem&lt;&gt;(&quot;a&quot;));
3721         root.getChildren().add(new TreeItem&lt;&gt;(&quot;c&quot;));
3722         root.getChildren().add(new TreeItem&lt;&gt;(&quot;b&quot;));
3723 
3724         // table columns - 1 column; name
3725         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3726         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3727         nameColumn.setPrefWidth(200);
3728 
3729         // table
3730         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
3731         table.setShowRoot(false);
3732         table.setRoot(root);
3733         table.getColumns().addAll(nameColumn);
3734 
3735         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
3736             while (c.next()) {
3737                 rt_37429_items_change_count++;
3738             }
3739         });
3740         table.getSelectionModel().getSelectedCells().addListener((ListChangeListener&lt;TreeTablePosition&lt;String, ?&gt;&gt;) c -&gt; {
3741             while (c.next()) {
3742                 rt_37429_cells_change_count++;
3743             }
3744         });
3745 
3746         StageLoader sl = new StageLoader(table);
3747 
3748         assertEquals(0, rt_37429_items_change_count);
3749         assertEquals(0, rt_37429_cells_change_count);
3750 
3751         table.getSelectionModel().select(0);
3752         assertEquals(1, rt_37429_items_change_count);
3753         assertEquals(1, rt_37429_cells_change_count);
3754 
3755         table.getSortOrder().add(nameColumn);
3756         assertEquals(1, rt_37429_items_change_count);
3757         assertEquals(1, rt_37429_cells_change_count);
3758 
3759         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3760         assertEquals(1, rt_37429_items_change_count);
3761         assertEquals(2, rt_37429_cells_change_count);
3762 
3763         nameColumn.setSortType(TreeTableColumn.SortType.ASCENDING);
3764         assertEquals(1, rt_37429_items_change_count);
3765         assertEquals(3, rt_37429_cells_change_count);
3766 
3767         sl.dispose();
3768     }
3769 
3770     private int rt_37538_count = 0;
3771     @Test public void test_rt_37538_noCNextCall() {
3772         test_rt_37538(false, false);
3773     }
3774 
3775     @Test public void test_rt_37538_callCNextOnce() {
3776         test_rt_37538(true, false);
3777     }
3778 
3779     @Test public void test_rt_37538_callCNextInLoop() {
3780         test_rt_37538(false, true);
3781     }
3782 
3783     private void test_rt_37538(boolean callCNextOnce, boolean callCNextInLoop) {
3784         // create table with a bunch of rows and 1 column...
3785         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(0);
3786         root.setExpanded(true);
3787         for (int i = 1; i &lt;= 50; i++) {
3788             root.getChildren().add(new TreeItem&lt;&gt;(i));
3789         }
3790 
3791         final TreeTableColumn&lt;Integer, Integer&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3792         column.setCellValueFactory( cdf -&gt; new ReadOnlyObjectWrapper&lt;Integer&gt;(cdf.getValue().getValue()));
3793 
3794         final TreeTableView&lt;Integer&gt; table = new TreeTableView&lt;&gt;(root);
3795         table.getColumns().add( column );
3796 
3797         table.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;Integer&gt;&gt; c) -&gt; {
3798             if (callCNextOnce) {
3799                 c.next();
3800             } else if (callCNextInLoop) {
3801                 while (c.next()) {
3802                     // no-op
3803                 }
3804             }
3805 
3806             if (rt_37538_count &gt;= 1) {
3807                 Thread.dumpStack();
3808                 fail(&quot;This method should only be called once&quot;);
3809             }
3810 
3811             rt_37538_count++;
3812         });
3813 
3814         StageLoader sl = new StageLoader(table);
3815         assertEquals(0, rt_37538_count);
3816         table.getSelectionModel().select(0);
3817         assertEquals(1, rt_37538_count);
3818         sl.dispose();
3819     }
3820 
3821     @Test public void test_rt_37593() {
3822         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;();
3823 
3824         TreeItem&lt;String&gt; one = new TreeItem&lt;&gt;(&quot;one&quot;);
3825         root.getChildren().add(one);
3826 
3827         TreeItem&lt;String&gt; two = new TreeItem&lt;&gt;(&quot;two&quot;);
3828         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childOne&quot;));
3829         two.getChildren().add(new TreeItem&lt;&gt;(&quot;childTwo&quot;));
3830         root.getChildren().add(two);
3831 
3832         root.getChildren().add(new TreeItem&lt;&gt;(&quot;three&quot;));
3833 
3834         TreeTableColumn&lt;String, String&gt; nameColumn = new TreeTableColumn&lt;&gt;(&quot;name&quot;);
3835         nameColumn.setCellValueFactory(param -&gt; new ReadOnlyObjectWrapper(param.getValue().getValue()));
3836 
3837         treeTableView.setShowRoot(false);
3838         treeTableView.setRoot(root);
3839         treeTableView.getColumns().addAll(nameColumn);
3840 
3841         treeTableView.getSortOrder().add(nameColumn);
3842         nameColumn.setSortType(TreeTableColumn.SortType.DESCENDING);
3843         sm.select(one);
3844 
3845         // at this point, the &#39;one&#39; item should be in row 2
3846         assertTrue(sm.isSelected(2));
3847         assertEquals(one, sm.getSelectedItem());
3848 
3849         two.setExpanded(true);
3850 
3851         // we should end up with the selection being on index 4, which is the
3852         // final location of the &#39;one&#39; tree item, after sorting and expanding &#39;two&#39;
3853         assertEquals(one, sm.getSelectedItem());
3854         assertTrue(debug(), sm.isSelected(4));
3855 
3856         // this line would create a NPE
3857         VirtualFlowTestUtils.clickOnRow(treeTableView, 4, true);
3858 
3859         // The mouse click should not change selection at all
3860         assertEquals(one, sm.getSelectedItem());
3861         assertTrue(debug(), sm.isSelected(4));
3862     }
3863 
3864     @Test public void test_rt_35395_testCell_fixedCellSize() {
3865         test_rt_35395(true, true);
3866     }
3867 
3868     @Test public void test_rt_35395_testCell_notFixedCellSize() {
3869         test_rt_35395(true, false);
3870     }
3871 
3872     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
3873     @Test public void test_rt_35395_testRow_fixedCellSize() {
3874         test_rt_35395(false, true);
3875     }
3876 
3877     @Ignore(&quot;Fix not yet developed for TreeTableView&quot;)
3878     @Test public void test_rt_35395_testRow_notFixedCellSize() {
3879         test_rt_35395(false, false);
3880     }
3881 
3882     private int rt_35395_counter;
3883     private void test_rt_35395(boolean testCell, boolean useFixedCellSize) {
3884         rt_35395_counter = 0;
3885 
3886         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;green&quot;);
3887         root.setExpanded(true);
3888         for (int i = 0; i &lt; 20; i++) {
3889             root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;red&quot;), new TreeItem&lt;&gt;(&quot;green&quot;), new TreeItem&lt;&gt;(&quot;blue&quot;), new TreeItem&lt;&gt;(&quot;purple&quot;));
3890         }
3891 
3892         TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
3893         if (useFixedCellSize) {
3894             treeTableView.setFixedCellSize(24);
3895         }
3896         treeTableView.setRowFactory(tv -&gt; new TreeTableRowShim&lt;String&gt;() {
3897             @Override public void updateItem(String color, boolean empty) {
3898                 rt_35395_counter += testCell ? 0 : 1;
3899                 super.updateItem(color, empty);
3900             }
3901         });
3902 
3903         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
3904         column.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue()));
3905         column.setCellFactory(tv -&gt; new TreeTableCellShim&lt;String,String&gt;() {
3906             @Override public void updateItem(String color, boolean empty) {
3907                 rt_35395_counter += testCell ? 1 : 0;
3908                 super.updateItem(color, empty);
3909                 setText(null);
3910                 if (empty) {
3911                     setGraphic(null);
3912                 } else {
3913                     Rectangle rect = new Rectangle(16, 16);
3914                     rect.setStyle(&quot;-fx-fill: &quot; + color);
3915                     setGraphic(rect);
3916                 }
3917             }
3918         });
3919         treeTableView.getColumns().addAll(column);
3920 
3921         StageLoader sl = new StageLoader(treeTableView);
3922 
3923         Platform.runLater(() -&gt; {
3924             rt_35395_counter = 0;
3925             root.getChildren().set(10, new TreeItem&lt;&gt;(&quot;yellow&quot;));
3926             Platform.runLater(() -&gt; {
3927                 Toolkit.getToolkit().firePulse();
3928                 assertEquals(1, rt_35395_counter);
3929                 rt_35395_counter = 0;
3930                 root.getChildren().set(30, new TreeItem&lt;&gt;(&quot;yellow&quot;));
3931                 Platform.runLater(() -&gt; {
3932                     Toolkit.getToolkit().firePulse();
3933                     assertEquals(0, rt_35395_counter);
3934                     rt_35395_counter = 0;
3935                     treeTableView.scrollTo(5);
3936                     Platform.runLater(() -&gt; {
3937                         Toolkit.getToolkit().firePulse();
3938                         assertEquals(useFixedCellSize ? 5 : 5, rt_35395_counter);
3939                         rt_35395_counter = 0;
3940                         treeTableView.scrollTo(55);
3941                         Platform.runLater(() -&gt; {
3942                             Toolkit.getToolkit().firePulse();
3943 
3944                             assertEquals(useFixedCellSize ? 7 : 59, rt_35395_counter);
3945                             sl.dispose();
3946                         });
3947                     });
3948                 });
3949             });
3950         });
3951     }
3952 
3953     @Test public void test_rt_37632() {
3954         final TreeItem&lt;String&gt; rootOne = new TreeItem&lt;&gt;(&quot;Root 1&quot;);
3955         final TreeItem&lt;String&gt; rootTwo = new TreeItem&lt;&gt;(&quot;Root 2&quot;);
3956 
3957         TreeTableColumn&lt;String,String&gt; tableColumn = new TreeTableColumn(&quot;column&quot;);
3958         tableColumn.setCellValueFactory(c -&gt; new ReadOnlyStringWrapper(c.getValue().getValue()));
3959 
3960         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;();
3961         treeTableView.getColumns().addAll(tableColumn);
3962         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
3963         treeTableView.setRoot(rootOne);
3964         treeTableView.getSelectionModel().selectFirst();
3965 
3966         assertEquals(0, sm.getSelectedIndex());
3967         assertEquals(rootOne, sm.getSelectedItem());
3968         assertEquals(1, sm.getSelectedIndices().size());
3969         assertEquals(0, (int) sm.getSelectedIndices().get(0));
3970         assertEquals(1, sm.getSelectedItems().size());
3971         assertEquals(rootOne, sm.getSelectedItems().get(0));
3972 
3973         treeTableView.setRoot(rootTwo);
3974 
3975         assertEquals(-1, sm.getSelectedIndex());
3976         assertNull(sm.getSelectedItem());
3977         assertEquals(0, sm.getSelectedIndices().size());
3978         assertEquals(0, sm.getSelectedItems().size());
3979     }
3980 
3981     private TreeTableView&lt;Person&gt; test_rt_38464_createControl() {
3982         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
3983                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
3984                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
3985                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
3986                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
3987                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
3988 
3989         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
3990         table.setShowRoot(false);
3991 
3992         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
3993         root.setExpanded(true);
3994         root.getChildren().setAll(persons);
3995         table.setRoot(root);
3996 
3997 
3998 
3999         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
4000         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
4001 
4002         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
4003         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
4004 
4005         table.getColumns().addAll(firstNameCol, lastNameCol);
4006 
4007         return table;
4008     }
4009 
4010     @Test public void test_rt_38464_rowSelection_selectFirstRowOnly() {
4011         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4012         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4013         sm.setCellSelectionEnabled(false);
4014         sm.setSelectionMode(SelectionMode.MULTIPLE);
4015 
4016         sm.select(0);
4017 
4018         assertTrue(sm.isSelected(0));
4019         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4020         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4021 
4022         assertEquals(1, sm.getSelectedIndices().size());
4023         assertEquals(1, sm.getSelectedItems().size());
4024         assertEquals(1, sm.getSelectedCells().size());
4025     }
4026 
4027     @Test public void test_rt_38464_rowSelection_selectFirstRowAndThenCallNoOpMethods() {
4028         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4029         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4030         sm.setCellSelectionEnabled(false);
4031         sm.setSelectionMode(SelectionMode.MULTIPLE);
4032 
4033         sm.select(0);               // select first row
4034         sm.select(0);               // this should be a no-op
4035         sm.select(0, table.getColumns().get(0)); // so should this, as we are in row selection mode
4036         sm.select(0, table.getColumns().get(1));  // and same here
4037 
4038         assertTrue(sm.isSelected(0));
4039         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4040         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4041 
4042         assertEquals(1, sm.getSelectedIndices().size());
4043         assertEquals(1, sm.getSelectedItems().size());
4044         assertEquals(1, sm.getSelectedCells().size());
4045     }
4046 
4047 
4048     @Test public void test_rt_38464_cellSelection_selectFirstRowOnly() {
4049         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4050         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4051         sm.setCellSelectionEnabled(true);
4052         sm.setSelectionMode(SelectionMode.MULTIPLE);
4053 
4054         // select first row. This should be translated into selection of all
4055         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4056         // considered selected.
4057         sm.select(0);
4058 
4059         assertTrue(sm.isSelected(0));
4060         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4061         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4062 
4063         assertEquals(1, sm.getSelectedIndices().size());
4064         assertEquals(1, sm.getSelectedItems().size());
4065         assertEquals(2, sm.getSelectedCells().size());
4066     }
4067 
4068     @Test public void test_rt_38464_cellSelection_selectFirstRowAndThenCallNoOpMethods() {
4069         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4070         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4071         sm.setCellSelectionEnabled(true);
4072         sm.setSelectionMode(SelectionMode.MULTIPLE);
4073 
4074         // select first row. This should be translated into selection of all
4075         // cells in this row, and (as of JDK 9) _does_ result in the row itself being
4076         // considered selected.
4077         sm.select(0);                            // select first row
4078         sm.select(0, table.getColumns().get(0)); // This line and the next should be no-ops
4079         sm.select(0, table.getColumns().get(1));
4080 
4081         assertTrue(sm.isSelected(0));
4082         assertTrue(sm.isSelected(0, table.getColumns().get(0)));
4083         assertTrue(sm.isSelected(0, table.getColumns().get(1)));
4084 
4085         assertEquals(1, sm.getSelectedIndices().size());
4086         assertEquals(1, sm.getSelectedItems().size());
4087         assertEquals(2, sm.getSelectedCells().size());
4088     }
4089 
4090     @Test public void test_rt38464_selectCellMultipleTimes() {
4091         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4092         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4093         sm.setCellSelectionEnabled(true);
4094         sm.setSelectionMode(SelectionMode.MULTIPLE);
4095 
4096         // default selection when in cell selection mode
4097         assertEquals(0, sm.getSelectedCells().size());
4098         assertEquals(0, sm.getSelectedItems().size());
4099         assertEquals(0, sm.getSelectedIndices().size());
4100 
4101         // select the first cell
4102         sm.select(0, table.getColumns().get(0));
4103         assertEquals(1, sm.getSelectedCells().size());
4104         assertEquals(1, sm.getSelectedItems().size());
4105         assertEquals(1, sm.getSelectedIndices().size());
4106 
4107         // select the first cell....again
4108         sm.select(0, table.getColumns().get(0));
4109         assertEquals(1, sm.getSelectedCells().size());
4110         assertEquals(1, sm.getSelectedItems().size());
4111         assertEquals(1, sm.getSelectedIndices().size());
4112     }
4113 
4114     @Test public void test_rt38464_selectCellThenRow() {
4115         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4116         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4117         sm.setCellSelectionEnabled(true);
4118         sm.setSelectionMode(SelectionMode.MULTIPLE);
4119 
4120         // default selection when in cell selection mode
4121         assertEquals(0, sm.getSelectedCells().size());
4122         assertEquals(0, sm.getSelectedItems().size());
4123         assertEquals(0, sm.getSelectedIndices().size());
4124 
4125         // select the first cell
4126         sm.select(0, table.getColumns().get(0));
4127         assertEquals(1, sm.getSelectedCells().size());
4128         assertEquals(1, sm.getSelectedItems().size());
4129         assertEquals(1, sm.getSelectedIndices().size());
4130 
4131         // select the first row
4132         sm.select(0);
4133 
4134         // we go to 2 here as all cells in the row become selected. What we do
4135         // not expect is to go to 3, as that would mean duplication
4136         assertEquals(2, sm.getSelectedCells().size());
4137         assertEquals(1, sm.getSelectedItems().size());
4138         assertEquals(1, sm.getSelectedIndices().size());
4139     }
4140 
4141     @Test public void test_rt38464_selectRowThenCell() {
4142         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4143         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4144         sm.setCellSelectionEnabled(true);
4145         sm.setSelectionMode(SelectionMode.MULTIPLE);
4146 
4147         // default selection when in cell selection mode
4148         assertEquals(0, sm.getSelectedCells().size());
4149         assertEquals(0, sm.getSelectedItems().size());
4150         assertEquals(0, sm.getSelectedIndices().size());
4151 
4152         // select the first row
4153         sm.select(0);
4154 
4155         // we go to 2 here as all cells in the row become selected.
4156         assertEquals(2, sm.getSelectedCells().size());
4157         assertEquals(1, sm.getSelectedItems().size());
4158         assertEquals(1, sm.getSelectedIndices().size());
4159 
4160         // select the first cell - no change is expected
4161         sm.select(0, table.getColumns().get(0));
4162         assertEquals(2, sm.getSelectedCells().size());
4163         assertEquals(1, sm.getSelectedItems().size());
4164         assertEquals(1, sm.getSelectedIndices().size());
4165     }
4166 
4167     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsOneRow() {
4168         test_rt38464_selectTests(true, true, true);
4169     }
4170 
4171     @Test public void test_rt38464_selectTests_cellSelection_singleSelection_selectsTwoRows() {
4172         test_rt38464_selectTests(true, true, false);
4173     }
4174 
4175     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsOneRow() {
4176         test_rt38464_selectTests(true, false, true);
4177     }
4178 
4179     @Test public void test_rt38464_selectTests_cellSelection_multipleSelection_selectsTwoRows() {
4180         test_rt38464_selectTests(true, false, false);
4181     }
4182 
4183     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsOneRow() {
4184         test_rt38464_selectTests(false, true, true);
4185     }
4186 
4187     @Test public void test_rt38464_selectTests_rowSelection_singleSelection_selectsTwoRows() {
4188         test_rt38464_selectTests(false, true, false);
4189     }
4190 
4191     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsOneRow() {
4192         test_rt38464_selectTests(false, false, true);
4193     }
4194 
4195     @Test public void test_rt38464_selectTests_rowSelection_multipleSelection_selectsTwoRows() {
4196         test_rt38464_selectTests(false, false, false);
4197     }
4198 
4199     private void test_rt38464_selectTests(boolean cellSelection, boolean singleSelection, boolean selectsOneRow) {
4200         TreeTableView&lt;Person&gt; table = test_rt_38464_createControl();
4201         TreeTableView.TreeTableViewSelectionModel&lt;Person&gt; sm = table.getSelectionModel();
4202         sm.setCellSelectionEnabled(cellSelection);
4203         sm.setSelectionMode(singleSelection ? SelectionMode.SINGLE : SelectionMode.MULTIPLE);
4204 
4205         // default selection when in cell selection mode
4206         assertEquals(0, sm.getSelectedCells().size());
4207         assertEquals(0, sm.getSelectedItems().size());
4208         assertEquals(0, sm.getSelectedIndices().size());
4209 
4210         if (selectsOneRow) {
4211             sm.select(0);
4212         } else {
4213             // select the first two rows
4214             sm.selectIndices(0, 1);
4215         }
4216 
4217         final int expectedCells = singleSelection                    ? 1 :
4218                                   selectsOneRow   &amp;&amp; cellSelection   ? 2 :
4219                                   selectsOneRow   &amp;&amp; !cellSelection  ? 1 :
4220                                   !selectsOneRow  &amp;&amp; cellSelection   ? 4 :
4221                                /* !selectsOneRow  &amp;&amp; !cellSelection */ 2;
4222 
4223         final int expectedItems = singleSelection ? 1 :
4224                 selectsOneRow   ? 1 : 2;
4225 
4226         assertEquals(expectedCells, sm.getSelectedCells().size());
4227         assertEquals(expectedItems, sm.getSelectedItems().size());
4228         assertEquals(expectedItems, sm.getSelectedIndices().size());
4229 
4230         // we expect the table column of all selected cells, in this instance,
4231         // to be null as we have not explicitly stated a column, nor have we clicked
4232         // on a column. The only alternative is to use the first column.
4233         for (TreeTablePosition&lt;?,?&gt; tp : sm.getSelectedCells()) {
4234             if (cellSelection) {
4235                 assertNotNull(tp.getTableColumn());
4236             } else {
4237                 assertNull(tp.getTableColumn());
4238             }
4239         }
4240     }
4241 
4242     @Test public void test_rt_37853_replaceRoot() {
4243         test_rt_37853(true);
4244     }
4245 
4246     @Test public void test_rt_37853_replaceRootChildren() {
4247         test_rt_37853(false);
4248     }
4249 
4250     private int rt_37853_cancelCount;
4251     private int rt_37853_commitCount;
4252     public void test_rt_37853(boolean replaceRoot) {
4253         TreeTableColumn&lt;String,String&gt; first = new TreeTableColumn&lt;&gt;(&quot;first&quot;);
4254         first.setEditable(true);
4255         first.setCellFactory(TextFieldTreeTableCell.forTreeTableColumn());
4256         treeTableView.getColumns().add(first);
4257         treeTableView.setEditable(true);
4258         treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;Root&quot;));
4259         treeTableView.getRoot().setExpanded(true);
4260 
4261         for (int i = 0; i &lt; 10; i++) {
4262             treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;&quot; + i));
4263         }
4264 
4265         StageLoader sl = new StageLoader(treeTableView);
4266 
4267         first.setOnEditCancel(editEvent -&gt; rt_37853_cancelCount++);
4268         first.setOnEditCommit(editEvent -&gt; rt_37853_commitCount++);
4269 
4270         assertEquals(0, rt_37853_cancelCount);
4271         assertEquals(0, rt_37853_commitCount);
4272 
4273         treeTableView.edit(1, first);
4274         assertNotNull(treeTableView.getEditingCell());
4275 
4276         if (replaceRoot) {
4277             treeTableView.setRoot(new TreeItem&lt;&gt;(&quot;New Root&quot;));
4278         } else {
4279             treeTableView.getRoot().getChildren().clear();
4280             for (int i = 0; i &lt; 10; i++) {
4281                 treeTableView.getRoot().getChildren().add(new TreeItem&lt;&gt;(&quot;new item &quot; + i));
4282             }
4283         }
4284         assertEquals(1, rt_37853_cancelCount);
4285         assertEquals(0, rt_37853_commitCount);
4286 
4287         sl.dispose();
4288     }
4289 
4290 
4291     /**************************************************************************
4292      *
4293      * Tests (and related code) for RT-38892
4294      *
4295      *************************************************************************/
4296 
4297     private final Supplier&lt;TreeTableColumn&lt;Person,String&gt;&gt; columnCallable = () -&gt; {
4298         TreeTableColumn&lt;Person,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Last Name&quot;);
4299         column.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person,String&gt;(&quot;lastName&quot;));
4300         return column;
4301     };
4302 
4303     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_firstNameCol;
4304     private TreeTableColumn&lt;Person, String&gt; test_rt_38892_lastNameCol;
4305 
4306     private TreeTableView&lt;Person&gt; init_test_rt_38892() {
4307         ObservableList&lt;TreeItem&lt;Person&gt;&gt; persons = FXCollections.observableArrayList(
4308                 new TreeItem&lt;&gt;(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
4309                 new TreeItem&lt;&gt;(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
4310                 new TreeItem&lt;&gt;(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
4311                 new TreeItem&lt;&gt;(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
4312                 new TreeItem&lt;&gt;(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
4313 
4314         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;();
4315         table.setShowRoot(false);
4316         table.getSelectionModel().setCellSelectionEnabled(true);
4317         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
4318 
4319         TreeItem&lt;Person&gt; root = new TreeItem&lt;&gt;(new Person(&quot;Root&quot;, null, null));
4320         root.setExpanded(true);
4321         root.getChildren().setAll(persons);
4322         table.setRoot(root);
4323 
4324         test_rt_38892_firstNameCol = new TreeTableColumn&lt;&gt;(&quot;First Name&quot;);
4325         test_rt_38892_firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(&quot;firstName&quot;));
4326         test_rt_38892_lastNameCol = columnCallable.get();
4327         table.getColumns().addAll(test_rt_38892_firstNameCol, test_rt_38892_lastNameCol);
4328 
4329         return table;
4330     }
4331 
4332     @Test public void test_rt_38892_focusMovesToLeftWhenPossible() {
4333         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4334 
4335         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4336         fm.focus(0, test_rt_38892_lastNameCol);
4337 
4338         // assert pre-conditions
4339         assertEquals(0, fm.getFocusedIndex());
4340         assertEquals(0, fm.getFocusedCell().getRow());
4341         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4342         assertEquals(1, fm.getFocusedCell().getColumn());
4343 
4344         // now remove column where focus is and replace it with a new column.
4345         // We expect focus to move to the left one cell.
4346         table.getColumns().remove(1);
4347         table.getColumns().add(columnCallable.get());
4348 
4349         assertEquals(0, fm.getFocusedIndex());
4350         assertEquals(0, fm.getFocusedCell().getRow());
4351         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4352         assertEquals(0, fm.getFocusedCell().getColumn());
4353     }
4354 
4355     @Test public void test_rt_38892_removeLeftMostColumn() {
4356         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4357 
4358         TreeTableView.TreeTableViewFocusModel&lt;Person&gt; fm = table.getFocusModel();
4359         fm.focus(0, test_rt_38892_firstNameCol);
4360 
4361         // assert pre-conditions
4362         assertEquals(0, fm.getFocusedIndex());
4363         assertEquals(0, fm.getFocusedCell().getRow());
4364         assertEquals(test_rt_38892_firstNameCol, fm.getFocusedCell().getTableColumn());
4365         assertEquals(0, fm.getFocusedCell().getColumn());
4366 
4367         // now remove column where focus is and replace it with a new column.
4368         // In the current (non-specified) behavior, this results in focus being
4369         // shifted to a cell in the remaining column, even when we add a new column
4370         // as we index based on the column, not on its index.
4371         table.getColumns().remove(0);
4372         TreeTableColumn&lt;Person,String&gt; newColumn = columnCallable.get();
4373         table.getColumns().add(0, newColumn);
4374 
4375         assertEquals(0, fm.getFocusedIndex());
4376         assertEquals(0, fm.getFocusedCell().getRow());
4377         assertEquals(test_rt_38892_lastNameCol, fm.getFocusedCell().getTableColumn());
4378         assertEquals(0, fm.getFocusedCell().getColumn());
4379     }
4380 
4381     @Test public void test_rt_38892_removeSelectionFromCellsInRemovedColumn() {
4382         TreeTableView&lt;Person&gt; table = init_test_rt_38892();
4383 
4384         TreeTableView.TreeTableViewSelectionModel sm = table.getSelectionModel();
4385         sm.select(0, test_rt_38892_firstNameCol);
4386         sm.select(1, test_rt_38892_lastNameCol);    // this should go
4387         sm.select(2, test_rt_38892_firstNameCol);
4388         sm.select(3, test_rt_38892_lastNameCol);    // so should this
4389         sm.select(4, test_rt_38892_firstNameCol);
4390 
4391         assertEquals(5, sm.getSelectedCells().size());
4392 
4393         table.getColumns().remove(1);
4394 
4395         assertEquals(3, sm.getSelectedCells().size());
4396         assertTrue(sm.isSelected(0, test_rt_38892_firstNameCol));
4397         assertFalse(sm.isSelected(1, test_rt_38892_lastNameCol));
4398         assertTrue(sm.isSelected(2, test_rt_38892_firstNameCol));
4399         assertFalse(sm.isSelected(3, test_rt_38892_lastNameCol));
4400         assertTrue(sm.isSelected(4, test_rt_38892_firstNameCol));
4401     }
4402 
4403     @Test public void test_rt_38787_remove_b() {
4404         // Remove &#39;b&#39;, selection moves to &#39;a&#39;
4405         test_rt_38787(&quot;a&quot;, 0, 1);
4406     }
4407 
4408     @Test public void test_rt_38787_remove_b_c() {
4409         // Remove &#39;b&#39; and &#39;c&#39;, selection moves to &#39;a&#39;
4410         test_rt_38787(&quot;a&quot;, 0, 1, 2);
4411     }
4412 
4413     @Test public void test_rt_38787_remove_c_d() {
4414         // Remove &#39;c&#39; and &#39;d&#39;, selection moves to &#39;b&#39;
4415         test_rt_38787(&quot;b&quot;, 1, 2, 3);
4416     }
4417 
4418     @Test public void test_rt_38787_remove_a() {
4419         // Remove &#39;a&#39;, selection moves to &#39;b&#39;, now in index 0
4420         test_rt_38787(&quot;b&quot;, 0, 0);
4421     }
4422 
4423     private void test_rt_38787(String expectedItem, int expectedIndex, int... indicesToRemove) {
4424         TreeItem&lt;String&gt; a, b, c, d;
4425         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4426         root.setExpanded(true);
4427         root.getChildren().addAll(
4428                 a = new TreeItem&lt;String&gt;(&quot;a&quot;),
4429                 b = new TreeItem&lt;String&gt;(&quot;b&quot;),
4430                 c = new TreeItem&lt;String&gt;(&quot;c&quot;),
4431                 d = new TreeItem&lt;String&gt;(&quot;d&quot;)
4432         );
4433 
4434         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4435         stringTreeTableView.setShowRoot(false);
4436 
4437         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4438         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4439         stringTreeTableView.getColumns().add(column);
4440 
4441         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4442         sm.select(b);
4443 
4444         // test pre-conditions
4445         assertEquals(1, sm.getSelectedIndex());
4446         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4447         assertEquals(b, sm.getSelectedItem());
4448         assertEquals(b, sm.getSelectedItems().get(0));
4449         assertFalse(sm.isSelected(0));
4450         assertTrue(sm.isSelected(1));
4451         assertFalse(sm.isSelected(2));
4452 
4453         // removing items
4454         List&lt;TreeItem&lt;String&gt;&gt; itemsToRemove = new ArrayList&lt;&gt;(indicesToRemove.length);
4455         for (int index : indicesToRemove) {
4456             itemsToRemove.add(root.getChildren().get(index));
4457         }
4458         root.getChildren().removeAll(itemsToRemove);
4459 
4460         // testing against expectations
4461         assertEquals(expectedIndex, sm.getSelectedIndex());
4462         assertEquals(expectedIndex, (int)sm.getSelectedIndices().get(0));
4463         assertEquals(expectedItem, sm.getSelectedItem().getValue());
4464         assertEquals(expectedItem, sm.getSelectedItems().get(0).getValue());
4465     }
4466 
4467     private int rt_38341_indices_count = 0;
4468     private int rt_38341_items_count = 0;
4469     @Test public void test_rt_38341() {
4470         Callback&lt;Integer, TreeItem&lt;String&gt;&gt; callback = number -&gt; {
4471             final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root &quot; + number);
4472             final TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;Child &quot; + number);
4473 
4474             root.getChildren().add(child);
4475             return root;
4476         };
4477 
4478         final TreeItem&lt;String&gt; root = new TreeItem&lt;String&gt;();
4479         root.setExpanded(true);
4480         root.getChildren().addAll(callback.call(1), callback.call(2));
4481 
4482         final TreeTableView&lt;String&gt; treeTableView = new TreeTableView&lt;&gt;(root);
4483         treeTableView.setShowRoot(false);
4484 
4485         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4486         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4487         treeTableView.getColumns().add(column);
4488 
4489         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeTableView.getSelectionModel();
4490         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) c -&gt; rt_38341_indices_count++);
4491         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; rt_38341_items_count++);
4492 
4493         assertEquals(0, rt_38341_indices_count);
4494         assertEquals(0, rt_38341_items_count);
4495 
4496         // expand the first child of root, and select it (note: root isn&#39;t visible)
4497         root.getChildren().get(0).setExpanded(true);
4498         sm.select(1);
4499         assertEquals(1, sm.getSelectedIndex());
4500         assertEquals(1, sm.getSelectedIndices().size());
4501         assertEquals(1, (int)sm.getSelectedIndices().get(0));
4502         assertEquals(1, sm.getSelectedItems().size());
4503         assertEquals(&quot;Child 1&quot;, sm.getSelectedItem().getValue());
4504         assertEquals(&quot;Child 1&quot;, sm.getSelectedItems().get(0).getValue());
4505 
4506         assertEquals(1, rt_38341_indices_count);
4507         assertEquals(1, rt_38341_items_count);
4508 
4509         // now delete it
4510         root.getChildren().get(0).getChildren().remove(0);
4511 
4512         // selection should move to the childs parent in index 0
4513         assertEquals(0, sm.getSelectedIndex());
4514         assertEquals(1, sm.getSelectedIndices().size());
4515         assertEquals(0, (int)sm.getSelectedIndices().get(0));
4516         assertEquals(1, sm.getSelectedItems().size());
4517         assertEquals(&quot;Root 1&quot;, sm.getSelectedItem().getValue());
4518         assertEquals(&quot;Root 1&quot;, sm.getSelectedItems().get(0).getValue());
4519 
4520         // we also expect there to be an event in the selection model for
4521         // selected indices and selected items
4522         assertEquals(2, rt_38341_indices_count);
4523         assertEquals(2, rt_38341_items_count);
4524     }
4525 
4526     private int rt_38943_index_count = 0;
4527     private int rt_38943_item_count = 0;
4528     @Test public void test_rt_38943() {
4529         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4530         root.setExpanded(true);
4531         root.getChildren().addAll(
4532             new TreeItem&lt;&gt;(&quot;a&quot;),
4533             new TreeItem&lt;&gt;(&quot;b&quot;),
4534             new TreeItem&lt;&gt;(&quot;c&quot;),
4535             new TreeItem&lt;&gt;(&quot;d&quot;)
4536         );
4537 
4538         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4539         stringTreeTableView.setShowRoot(false);
4540 
4541         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4542         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4543         stringTreeTableView.getColumns().add(column);
4544 
4545         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4546 
4547         sm.selectedIndexProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_index_count++);
4548         sm.selectedItemProperty().addListener((observable, oldValue, newValue) -&gt; rt_38943_item_count++);
4549 
4550         assertEquals(-1, sm.getSelectedIndex());
4551         assertNull(sm.getSelectedItem());
4552         assertEquals(0, rt_38943_index_count);
4553         assertEquals(0, rt_38943_item_count);
4554 
4555         sm.select(0);
4556         assertEquals(0, sm.getSelectedIndex());
4557         assertEquals(&quot;a&quot;, sm.getSelectedItem().getValue());
4558         assertEquals(1, rt_38943_index_count);
4559         assertEquals(1, rt_38943_item_count);
4560 
4561         sm.clearSelection(0);
4562         assertEquals(-1, sm.getSelectedIndex());
4563         assertNull(sm.getSelectedItem());
4564         assertEquals(2, rt_38943_index_count);
4565         assertEquals(2, rt_38943_item_count);
4566     }
4567 
4568     @Test public void test_rt_38884() {
4569         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4570         final TreeItem&lt;String&gt; foo = new TreeItem&lt;&gt;(&quot;foo&quot;);
4571 
4572         TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(root);
4573         treeView.setShowRoot(false);
4574         root.setExpanded(true);
4575 
4576         treeView.getSelectionModel().getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4577             while (c.next()) {
4578                 if (c.wasRemoved()) {
4579                     assertTrue(c.getRemovedSize() &gt; 0);
4580 
4581                     List&lt;? extends TreeItem&lt;String&gt;&gt; removed = c.getRemoved();
4582                     TreeItem&lt;String&gt; removedItem = null;
4583                     try {
4584                         removedItem = removed.get(0);
4585                     } catch (Exception e) {
4586                         fail();
4587                     }
4588 
4589                     assertEquals(foo, removedItem);
4590                 }
4591             }
4592         });
4593 
4594         root.getChildren().add(foo);
4595         treeView.getSelectionModel().select(0);
4596         root.getChildren().clear();
4597     }
4598 
4599     private int rt_37360_add_count = 0;
4600     private int rt_37360_remove_count = 0;
4601     @Test public void test_rt_37360() {
4602         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4603         root.setExpanded(true);
4604         root.getChildren().addAll(
4605                 new TreeItem&lt;&gt;(&quot;a&quot;),
4606                 new TreeItem&lt;&gt;(&quot;b&quot;)
4607         );
4608 
4609         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4610         stringTreeTableView.setShowRoot(false);
4611 
4612         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4613         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4614         stringTreeTableView.getColumns().add(column);
4615 
4616         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4617         sm.setSelectionMode(SelectionMode.MULTIPLE);
4618         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) c -&gt; {
4619             while (c.next()) {
4620                 if (c.wasAdded()) {
4621                     rt_37360_add_count += c.getAddedSize();
4622                 }
4623                 if (c.wasRemoved()) {
4624                     rt_37360_remove_count += c.getRemovedSize();
4625                 }
4626             }
4627         });
4628 
4629         assertEquals(0, sm.getSelectedItems().size());
4630         assertEquals(0, rt_37360_add_count);
4631         assertEquals(0, rt_37360_remove_count);
4632 
4633         sm.select(0);
4634         assertEquals(1, sm.getSelectedItems().size());
4635         assertEquals(1, rt_37360_add_count);
4636         assertEquals(0, rt_37360_remove_count);
4637 
4638         sm.select(1);
4639         assertEquals(2, sm.getSelectedItems().size());
4640         assertEquals(2, rt_37360_add_count);
4641         assertEquals(0, rt_37360_remove_count);
4642 
4643         sm.clearAndSelect(1);
4644         assertEquals(1, sm.getSelectedItems().size());
4645         assertEquals(2, rt_37360_add_count);
4646         assertEquals(1, rt_37360_remove_count);
4647     }
4648 
4649     private int rt_37366_count = 0;
4650     @Test public void test_rt_37366() {
4651         final TreeItem&lt;String&gt; treeItem2 = new TreeItem&lt;&gt;(&quot;Item 2&quot;);
4652         treeItem2.getChildren().addAll(new TreeItem&lt;&gt;(&quot;Item 21&quot;), new TreeItem&lt;&gt;(&quot;Item 22&quot;));
4653 
4654         final TreeItem&lt;String&gt; root1 = new TreeItem&lt;&gt;(&quot;Root Node 1&quot;);
4655         TreeItem&lt;String&gt; treeItem1 = new TreeItem&lt;&gt;(&quot;Item 1&quot;);
4656         root1.getChildren().addAll(treeItem1, treeItem2, new TreeItem&lt;&gt;(&quot;Item 3&quot;));
4657         root1.setExpanded(true);
4658 
4659         final TreeItem&lt;String&gt; root2 = new TreeItem&lt;&gt;(&quot;Root Node 2&quot;);
4660 
4661         final TreeItem&lt;String&gt; hiddenRoot = new TreeItem&lt;&gt;(&quot;Hidden Root Node&quot;);
4662         hiddenRoot.getChildren().add(root1);
4663         hiddenRoot.getChildren().add(root2);
4664 
4665         final TreeTableView&lt;String&gt; treeView = new TreeTableView&lt;&gt;(hiddenRoot);
4666         treeView.setShowRoot(false);
4667 
4668         AtomicInteger step = new AtomicInteger();
4669         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = treeView.getSelectionModel();
4670         sm.setSelectionMode(SelectionMode.MULTIPLE);
4671         sm.getSelectedItems().addListener((ListChangeListener.Change&lt;? extends TreeItem&lt;String&gt;&gt; c) -&gt; {
4672             switch (step.get()) {
4673                 case 0: {
4674                     // we expect treeItem1 to be the only item added
4675                     while (c.next()) {
4676                         assertFalse(c.wasRemoved());
4677                         assertTrue(c.wasAdded());
4678                         assertEquals(1, c.getAddedSize());
4679                         assertTrue(c.getAddedSubList().contains(treeItem1));
4680                     }
4681                     break;
4682                 }
4683                 case 1: {
4684                     // we expect treeItem2 to be the only item added
4685                     while (c.next()) {
4686                         assertFalse(c.wasRemoved());
4687                         assertTrue(c.wasAdded());
4688                         assertEquals(1, c.getAddedSize());
4689                         assertTrue(c.getAddedSubList().contains(treeItem2));
4690                     }
4691                     break;
4692                 }
4693                 case 2: {
4694                     // we expect treeItem1 and treeItem2 to be removed in one separate event,
4695                     // and then we expect a separate event for root1 to be added. Therefore,
4696                     // once the remove event is received, we will increment the step to test for
4697                     // the addition
4698                     boolean wasRemoved = false;
4699                     while (c.next()) {
4700                         if (c.wasAdded()) {
4701                             fail(&quot;no addition expected yet&quot;);
4702                         }
4703                         if (c.wasRemoved()) {
4704                             assertTrue(c.getRemoved().containsAll(FXCollections.observableArrayList(treeItem1, treeItem2)));
4705                             wasRemoved = true;
4706                         }
4707                     }
4708                     if (!wasRemoved) {
4709                         fail(&quot;Expected a remove operation&quot;);
4710                     }
4711                     step.incrementAndGet();
4712                     break;
4713                 }
4714                 case 3: {
4715                     boolean wasAdded = false;
4716                     while (c.next()) {
4717                         if (c.wasAdded()) {
4718                             assertEquals(1, c.getAddedSize());
4719                             assertTrue(c.getAddedSubList().contains(root1));
4720                             wasAdded = true;
4721                         }
4722                         if (c.wasRemoved()) {
4723                             fail(&quot;no removal expected now&quot;);
4724                         }
4725                     }
4726                     if (!wasAdded) {
4727                         fail(&quot;Expected an add operation&quot;);
4728                     }
4729                     break;
4730                 }
4731             }
4732             rt_37366_count++;
4733         });
4734 
4735         assertEquals(0, rt_37366_count);
4736 
4737         step.set(0);
4738         sm.select(1); // select &quot;Item 1&quot;
4739         assertEquals(1, rt_37366_count);
4740         assertFalse(sm.isSelected(0));
4741         assertTrue(sm.isSelected(1));
4742         assertFalse(sm.isSelected(2));
4743 
4744         step.set(1);
4745         sm.select(2); // select &quot;Item 2&quot;
4746         assertEquals(2, rt_37366_count);
4747         assertFalse(sm.isSelected(0));
4748         assertTrue(sm.isSelected(1));
4749         assertTrue(sm.isSelected(2));
4750 
4751         step.set(2);
4752         root1.setExpanded(false); // collapse &quot;Root Node 1&quot; and deselect the two children, moving selection up to &quot;Root Node 1&quot;
4753         assertEquals(4, rt_37366_count);
4754         assertTrue(sm.isSelected(0));
4755         assertFalse(sm.isSelected(1));
4756         assertFalse(sm.isSelected(2));
4757     }
4758 
4759     @Test public void test_rt_38491() {
4760         TreeItem&lt;String&gt; a;
4761         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4762         root.setExpanded(true);
4763         root.getChildren().addAll(
4764                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4765                 new TreeItem&lt;&gt;(&quot;b&quot;)
4766         );
4767 
4768         TreeTableView&lt;String&gt; stringTreeView = new TreeTableView&lt;&gt;(root);
4769         stringTreeView.setShowRoot(false);
4770 
4771         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4772         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4773         stringTreeView.getColumns().add(column);
4774 
4775         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeView.getSelectionModel();
4776         sm.setSelectionMode(SelectionMode.MULTIPLE);
4777 
4778         TreeTableViewFocusModel&lt;String&gt; fm = stringTreeView.getFocusModel();
4779 
4780         StageLoader sl = new StageLoader(stringTreeView);
4781 
4782         // test pre-conditions
4783         assertTrue(sm.isEmpty());
4784         assertEquals(a, fm.getFocusedItem());
4785         assertEquals(0, fm.getFocusedIndex());
4786 
4787         // click on row 0
4788 //        VirtualFlowTestUtils.clickOnRow(stringTreeView, 0);
4789         sm.select(0, column);
4790         assertTrue(sm.isSelected(0));
4791         assertEquals(a, sm.getSelectedItem());
4792         assertTrue(fm.isFocused(0));
4793         assertEquals(a, fm.getFocusedItem());
4794         assertEquals(0, fm.getFocusedIndex());
4795         assertEquals(0, fm.getFocusedCell().getRow());
4796         assertEquals(column, fm.getFocusedCell().getTableColumn());
4797 
4798         TreeTablePosition&lt;String, ?&gt; anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4799         assertNotNull(anchor);
4800         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4801         assertEquals(0, anchor.getRow());
4802 
4803         // now add a new item at row 0. This has the effect of pushing down
4804         // the selected item into row 1.
4805         root.getChildren().add(0, new TreeItem(&quot;z&quot;));
4806 
4807         // The first bug was that selection and focus were not moving down to
4808         // be on row 1, so we test that now
4809         assertFalse(sm.isSelected(0));
4810         assertFalse(fm.isFocused(0));
4811         assertTrue(sm.isSelected(1));
4812         assertEquals(a, sm.getSelectedItem());
4813         assertTrue(fm.isFocused(1));
4814         assertEquals(a, fm.getFocusedItem());
4815         assertEquals(1, fm.getFocusedIndex());
4816         assertEquals(1, fm.getFocusedCell().getRow());
4817         assertEquals(column, fm.getFocusedCell().getTableColumn());
4818 
4819         // The second bug was that the anchor was not being pushed down as well
4820         // (when it should).
4821         anchor = TreeTableCellBehavior.getAnchor(stringTreeView, null);
4822         assertNotNull(anchor);
4823         assertTrue(TreeTableCellBehavior.hasNonDefaultAnchor(stringTreeView));
4824         assertEquals(1, anchor.getRow());
4825         assertEquals(column, anchor.getTableColumn());
4826 
4827         sl.dispose();
4828     }
4829 
4830     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39256_list = FXCollections.observableArrayList();
4831     @Test public void test_rt_39256() {
4832         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4833         root.setExpanded(true);
4834         root.getChildren().addAll(
4835                 new TreeItem&lt;&gt;(&quot;a&quot;),
4836                 new TreeItem&lt;&gt;(&quot;b&quot;),
4837                 new TreeItem&lt;&gt;(&quot;c&quot;),
4838                 new TreeItem&lt;&gt;(&quot;d&quot;)
4839         );
4840 
4841         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4842         stringTreeTableView.setShowRoot(false);
4843 
4844         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4845         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4846         stringTreeTableView.getColumns().add(column);
4847 
4848         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = stringTreeTableView.getSelectionModel();
4849         sm.setSelectionMode(SelectionMode.MULTIPLE);
4850 
4851 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
4852 //            while (change.next()) {
4853 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
4854 //            }
4855 //        });
4856 
4857         Bindings.bindContent(rt_39256_list, sm.getSelectedItems());
4858 
4859         assertEquals(0, sm.getSelectedItems().size());
4860         assertEquals(0, rt_39256_list.size());
4861 
4862         sm.selectAll();
4863         assertEquals(4, sm.getSelectedItems().size());
4864         assertEquals(4, rt_39256_list.size());
4865 
4866         sm.selectAll();
4867         assertEquals(4, sm.getSelectedItems().size());
4868         assertEquals(4, rt_39256_list.size());
4869 
4870         sm.selectAll();
4871         assertEquals(4, sm.getSelectedItems().size());
4872         assertEquals(4, rt_39256_list.size());
4873     }
4874 
4875     private final ObservableList&lt;TreeItem&lt;String&gt;&gt; rt_39482_list = FXCollections.observableArrayList();
4876     @Test public void test_rt_39482() {
4877         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4878         root.setExpanded(true);
4879         root.getChildren().addAll(
4880                 new TreeItem&lt;&gt;(&quot;a&quot;),
4881                 new TreeItem&lt;&gt;(&quot;b&quot;),
4882                 new TreeItem&lt;&gt;(&quot;c&quot;),
4883                 new TreeItem&lt;&gt;(&quot;d&quot;)
4884         );
4885 
4886         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4887         stringTreeTableView.setShowRoot(false);
4888 
4889         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4890         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4891         stringTreeTableView.getColumns().add(column);
4892 
4893         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
4894         sm.setSelectionMode(SelectionMode.MULTIPLE);
4895 
4896 //        rt_39256_list.addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;) change -&gt; {
4897 //            while (change.next()) {
4898 //                System.err.println(&quot;number of selected persons (in bound list): &quot; + change.getList().size());
4899 //            }
4900 //        });
4901 
4902         Bindings.bindContent(rt_39482_list, sm.getSelectedItems());
4903 
4904         assertEquals(0, sm.getSelectedItems().size());
4905         assertEquals(0, rt_39482_list.size());
4906 
4907         test_rt_39482_selectRow(&quot;a&quot;, sm, 0, column);
4908         test_rt_39482_selectRow(&quot;b&quot;, sm, 1, column);
4909         test_rt_39482_selectRow(&quot;c&quot;, sm, 2, column);
4910         test_rt_39482_selectRow(&quot;d&quot;, sm, 3, column);
4911     }
4912 
4913     private void test_rt_39482_selectRow(String expectedString,
4914                                          TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm,
4915                                          int rowToSelect,
4916                                          TreeTableColumn&lt;String,String&gt; columnToSelect) {
4917         sm.selectAll();
4918         assertEquals(4, sm.getSelectedCells().size());
4919         assertEquals(4, sm.getSelectedIndices().size());
4920         assertEquals(4, sm.getSelectedItems().size());
4921         assertEquals(4, rt_39482_list.size());
4922 
4923         sm.clearAndSelect(rowToSelect, columnToSelect);
4924         assertEquals(1, sm.getSelectedCells().size());
4925         assertEquals(1, sm.getSelectedIndices().size());
4926         assertEquals(1, sm.getSelectedItems().size());
4927         assertEquals(expectedString, sm.getSelectedItem().getValue());
4928         assertEquals(expectedString, rt_39482_list.get(0).getValue());
4929         assertEquals(1, rt_39482_list.size());
4930     }
4931 
4932     @Test public void test_rt_39559_useSM_selectAll() {
4933         test_rt_39559(true);
4934     }
4935 
4936     @Test public void test_rt_39559_useKeyboard_selectAll() {
4937         test_rt_39559(false);
4938     }
4939 
4940     private void test_rt_39559(boolean useSMSelectAll) {
4941         TreeItem&lt;String&gt; a, b;
4942         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
4943         root.setExpanded(true);
4944         root.getChildren().addAll(
4945                 a = new TreeItem&lt;&gt;(&quot;a&quot;),
4946                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
4947                 new TreeItem&lt;&gt;(&quot;c&quot;),
4948                 new TreeItem&lt;&gt;(&quot;d&quot;)
4949         );
4950 
4951         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
4952         stringTreeTableView.setShowRoot(false);
4953 
4954         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
4955         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
4956         stringTreeTableView.getColumns().add(column);
4957 
4958         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
4959         sm.setSelectionMode(SelectionMode.MULTIPLE);
4960 
4961         StageLoader sl = new StageLoader(stringTreeTableView);
4962         KeyEventFirer keyboard = new KeyEventFirer(stringTreeTableView);
4963 
4964         assertEquals(0, sm.getSelectedItems().size());
4965 
4966         sm.clearAndSelect(0);
4967 
4968         if (useSMSelectAll) {
4969             sm.selectAll();
4970         } else {
4971             keyboard.doKeyPress(KeyCode.A, KeyModifier.getShortcutKey());
4972         }
4973 
4974         assertEquals(4, sm.getSelectedItems().size());
4975         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
4976 
4977         keyboard.doKeyPress(KeyCode.DOWN, KeyModifier.SHIFT);
4978 
4979         assertEquals(0, ((TreeTablePosition) TreeTableCellBehavior.getAnchor(stringTreeTableView, null)).getRow());
4980         assertEquals(2, sm.getSelectedItems().size());
4981         assertEquals(a, sm.getSelectedItems().get(0));
4982         assertEquals(b, sm.getSelectedItems().get(1));
4983 
4984         sl.dispose();
4985     }
4986 
4987     @Test public void test_rt_16068_firstElement_selectAndRemoveSameRow() {
4988         // select and then remove the &#39;a&#39; item, selection and focus should both
4989         // stay at the first row, now &#39;b&#39;
4990         test_rt_16068(0, 0, 0);
4991     }
4992 
4993     @Test public void test_rt_16068_firstElement_selectRowAndRemoveLaterSibling() {
4994         // select row &#39;a&#39;, and remove row &#39;c&#39;, selection and focus should not change
4995         test_rt_16068(0, 2, 0);
4996     }
4997 
4998     @Test public void test_rt_16068_middleElement_selectAndRemoveSameRow() {
4999         // select and then remove the &#39;b&#39; item, selection and focus should both
5000         // move up one row to the &#39;a&#39; item
5001         test_rt_16068(1, 1, 0);
5002     }
5003 
5004     @Test public void test_rt_16068_middleElement_selectRowAndRemoveLaterSibling() {
5005         // select row &#39;b&#39;, and remove row &#39;c&#39;, selection and focus should not change
5006         test_rt_16068(1, 2, 1);
5007     }
5008 
5009     @Test public void test_rt_16068_middleElement_selectRowAndRemoveEarlierSibling() {
5010         // select row &#39;b&#39;, and remove row &#39;a&#39;, selection and focus should move up
5011         // one row, remaining on &#39;b&#39;
5012         test_rt_16068(1, 0, 0);
5013     }
5014 
5015     @Test public void test_rt_16068_lastElement_selectAndRemoveSameRow() {
5016         // select and then remove the &#39;d&#39; item, selection and focus should both
5017         // move up one row to the &#39;c&#39; item
5018         test_rt_16068(3, 3, 2);
5019     }
5020 
5021     @Test public void test_rt_16068_lastElement_selectRowAndRemoveEarlierSibling() {
5022         // select row &#39;d&#39;, and remove row &#39;a&#39;, selection and focus should move up
5023         // one row, remaining on &#39;d&#39;
5024         test_rt_16068(3, 0, 2);
5025     }
5026 
5027     private void test_rt_16068(int indexToSelect, int indexToRemove, int expectedIndex) {
5028         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5029         root.setExpanded(true);
5030         root.getChildren().addAll(
5031                 new TreeItem&lt;&gt;(&quot;a&quot;), // 0
5032                 new TreeItem&lt;&gt;(&quot;b&quot;), // 1
5033                 new TreeItem&lt;&gt;(&quot;c&quot;), // 2
5034                 new TreeItem&lt;&gt;(&quot;d&quot;)  // 3
5035         );
5036 
5037         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5038         stringTreeTableView.setShowRoot(false);
5039 
5040         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5041         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5042         stringTreeTableView.getColumns().add(column);
5043 
5044         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5045         FocusModel&lt;TreeItem&lt;String&gt;&gt; fm = stringTreeTableView.getFocusModel();
5046 
5047         sm.select(indexToSelect);
5048         assertEquals(indexToSelect, sm.getSelectedIndex());
5049         assertEquals(root.getChildren().get(indexToSelect).getValue(), sm.getSelectedItem().getValue());
5050         assertEquals(indexToSelect, fm.getFocusedIndex());
5051         assertEquals(root.getChildren().get(indexToSelect).getValue(), fm.getFocusedItem().getValue());
5052 
5053         root.getChildren().remove(indexToRemove);
5054         assertEquals(expectedIndex, sm.getSelectedIndex());
5055         assertEquals(root.getChildren().get(expectedIndex).getValue(), sm.getSelectedItem().getValue());
5056         assertEquals(debug(), expectedIndex, fm.getFocusedIndex());
5057         assertEquals(root.getChildren().get(expectedIndex).getValue(), fm.getFocusedItem().getValue());
5058     }
5059 
5060     @Test public void test_rt_39675() {
5061         TreeItem&lt;String&gt; b;
5062         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5063         root.setExpanded(true);
5064         root.getChildren().addAll(
5065                 new TreeItem&lt;&gt;(&quot;a&quot;),
5066                 b = new TreeItem&lt;&gt;(&quot;b&quot;),
5067                 new TreeItem&lt;&gt;(&quot;c&quot;),
5068                 new TreeItem&lt;&gt;(&quot;d&quot;)
5069         );
5070 
5071         b.setExpanded(true);
5072         b.getChildren().addAll(
5073                 new TreeItem&lt;&gt;(&quot;b1&quot;),
5074                 new TreeItem&lt;&gt;(&quot;b2&quot;),
5075                 new TreeItem&lt;&gt;(&quot;b3&quot;),
5076                 new TreeItem&lt;&gt;(&quot;b4&quot;)
5077         );
5078 
5079         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5080 
5081         TreeTableColumn&lt;String,String&gt; column0 = new TreeTableColumn&lt;&gt;(&quot;Column1&quot;);
5082         column0.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5083 
5084         TreeTableColumn&lt;String,String&gt; column1 = new TreeTableColumn&lt;&gt;(&quot;Column2&quot;);
5085         column1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5086 
5087         TreeTableColumn&lt;String,String&gt; column2 = new TreeTableColumn&lt;&gt;(&quot;Column3&quot;);
5088         column2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5089 
5090         stringTreeTableView.getColumns().addAll(column0, column1, column2);
5091 
5092         sm = stringTreeTableView.getSelectionModel();
5093         sm.setSelectionMode(SelectionMode.SINGLE);
5094         sm.setCellSelectionEnabled(true);
5095 
5096         StageLoader sl = new StageLoader(stringTreeTableView);
5097 
5098         assertEquals(0, sm.getSelectedItems().size());
5099 
5100         sm.clearAndSelect(4, column0);  // select &#39;b2&#39; in row 4, column 0
5101         assertTrue(sm.isSelected(4, column0));
5102         assertEquals(1, sm.getSelectedCells().size());
5103         assertEquals(&quot;b2&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5104 
5105         // collapse the &#39;b&#39; tree item, selection and focus should go to
5106         // the &#39;b&#39; tree item in row 2, column 0
5107         b.setExpanded(false);
5108         assertTrue(sm.isSelected(2, column0));
5109         assertEquals(1, sm.getSelectedCells().size());
5110         assertEquals(&quot;b&quot;, ((TreeItem)sm.getSelectedItem()).getValue());
5111 
5112         sl.dispose();
5113     }
5114 
5115 
5116     private ObservableList&lt;String&gt; test_rt_39661_setup() {
5117         ObservableList&lt;String&gt;  rawItems = FXCollections.observableArrayList(
5118                 &quot;9-item&quot;, &quot;8-item&quot;, &quot;7-item&quot;, &quot;6-item&quot;,
5119                 &quot;5-item&quot;, &quot;4-item&quot;, &quot;3-item&quot;, &quot;2-item&quot;, &quot;1-item&quot;);
5120         root = createSubTree(&quot;root&quot;, rawItems);
5121         root.setExpanded(true);
5122         treeTableView = new TreeTableView(root);
5123         return rawItems;
5124     }
5125 
5126     private TreeItem createSubTree(Object item, ObservableList&lt;String&gt; rawItems) {
5127         TreeItem child = new TreeItem(item);
5128         child.getChildren().setAll(rawItems.stream()
5129                 .map(rawItem -&gt; new TreeItem(rawItem))
5130                 .collect(Collectors.toList()));
5131         return child;
5132     }
5133 
5134     @Test public void test_rt_39661_rowLessThanExpandedItemCount() {
5135         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5136         TreeItem child = createSubTree(&quot;child&quot;, rawItems);
5137         TreeItem grandChild = (TreeItem) child.getChildren().get(rawItems.size() - 1);
5138         root.getChildren().add(child);
5139         assertTrue(&quot;row of item must be less than expandedItemCount, but was: &quot; + treeTableView.getRow(grandChild),
5140                 treeTableView.getRow(grandChild) &lt; treeTableView.getExpandedItemCount());
5141     }
5142 
5143     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAbove() {
5144         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5145         int grandIndex = 2;
5146         int childIndex = 3;
5147 
5148         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5149         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5150         root.getChildren().add(childIndex, child);
5151 
5152         int rowOfGrand = treeTableView.getRow(grandChild);
5153         root.getChildren().add(childIndex - 1, createSubTree(&quot;other&quot;, rawItems));
5154 
5155         assertEquals(-1, treeTableView.getRow(grandChild));
5156     }
5157 
5158     @Test public void test_rt_39661_rowOfGrandChildParentCollapsedUpdatedOnInsertAboveWithoutAccess() {
5159         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5160         int grandIndex = 2;
5161         int childIndex = 3;
5162 
5163         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5164         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5165         root.getChildren().add(childIndex, child);
5166 
5167         int rowOfGrand = 7; //treeTableView.getRow(grandChild);
5168         root.getChildren().add(childIndex, createSubTree(&quot;other&quot;, rawItems));
5169 
5170         assertEquals(-1, treeTableView.getRow(grandChild));
5171     }
5172 
5173     @Test public void test_rt_39661_rowOfGrandChildParentExpandedUpdatedOnInsertAbove() {
5174         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5175         int grandIndex = 2;
5176         int childIndex = 3;
5177         TreeItem child = createSubTree(&quot;addedChild2&quot;, rawItems);
5178         TreeItem grandChild = (TreeItem) child.getChildren().get(grandIndex);
5179         child.setExpanded(true);
5180         root.getChildren().add(childIndex, child);
5181         int rowOfGrand = treeTableView.getRow(grandChild);
5182         root.getChildren().add(childIndex -1, createSubTree(&quot;other&quot;, rawItems));
5183         assertEquals(rowOfGrand + 1, treeTableView.getRow(grandChild));
5184     }
5185 
5186     /**
5187      * Testing getRow on grandChild: compare collapsed/expanded parent.
5188      */
5189     @Test public void test_rt_39661_rowOfGrandChildDependsOnParentExpansion() {
5190         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5191         int grandIndex = 2;
5192         int childIndex = 3;
5193 
5194         TreeItem collapsedChild = createSubTree(&quot;addedChild&quot;, rawItems);
5195         TreeItem collapsedGrandChild = (TreeItem) collapsedChild.getChildren().get(grandIndex);
5196         root.getChildren().add(childIndex, collapsedChild);
5197 
5198         int collapedGrandIndex = treeTableView.getRow(collapsedGrandChild);
5199         int collapsedRowCount = treeTableView.getExpandedItemCount();
5200 
5201         // start again
5202         test_rt_39661_setup();
5203         assertEquals(collapsedRowCount - 1, treeTableView.getExpandedItemCount());
5204         TreeItem expandedChild = createSubTree(&quot;addedChild2&quot;, rawItems);
5205         TreeItem expandedGrandChild = (TreeItem) expandedChild.getChildren().get(grandIndex);
5206         expandedChild.setExpanded(true);
5207 
5208         root.getChildren().add(childIndex, expandedChild);
5209         assertNotSame(&quot;getRow must depend on expansionState &quot; + collapedGrandIndex,
5210                 collapedGrandIndex, treeTableView.getRow(expandedGrandChild));
5211     }
5212 
5213     @Test public void test_rt_39661_rowOfGrandChildInCollapsedChild() {
5214         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5215 
5216         // create a collapsed new child to insert into the root
5217         TreeItem newChild = createSubTree(&quot;added-child&quot;, rawItems);
5218         TreeItem grandChild = (TreeItem) newChild.getChildren().get(2);
5219         root.getChildren().add(6, newChild);
5220 
5221         // query the row of a grand-child
5222         int row = treeTableView.getRow(grandChild);
5223 
5224         // grandChild not visible, row coordinate in tree is not available
5225         assertEquals(&quot;grandChild not visible&quot;, -1, row);
5226 
5227         // the other way round: if we get a row, expect the item at the row be the grandChild
5228         if (row &gt; -1) {
5229             assertEquals(grandChild, treeTableView.getTreeItem(row));
5230         }
5231     }
5232 
5233     @Test public void test_rt_39661_rowOfRootChild() {
5234         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5235         int index = 2;
5236 
5237         TreeItem child = (TreeItem) root.getChildren().get(index);
5238         assertEquals(index + 1, treeTableView.getRow(child));
5239     }
5240 
5241     @Test public void test_rt_39661_expandedItemCount() {
5242         ObservableList&lt;String&gt; rawItems = test_rt_39661_setup();
5243         int initialRowCount = treeTableView.getExpandedItemCount();
5244         assertEquals(root.getChildren().size() + 1, initialRowCount);
5245 
5246         TreeItem collapsedChild = createSubTree(&quot;collapsed-child&quot;, rawItems);
5247         root.getChildren().add(collapsedChild);
5248         assertEquals(initialRowCount + 1, treeTableView.getExpandedItemCount());
5249 
5250         TreeItem expandedChild = createSubTree(&quot;expanded-child&quot;, rawItems);
5251         expandedChild.setExpanded(true);
5252         root.getChildren().add(0, expandedChild);
5253         assertEquals(2 * initialRowCount + 1, treeTableView.getExpandedItemCount());
5254     }
5255 
5256     private int test_rt_39822_count = 0;
5257     @Test public void test_rt_39822() {
5258         // get the current exception handler before replacing with our own,
5259         // as ListListenerHelp intercepts the exception otherwise
5260         final Thread.UncaughtExceptionHandler exceptionHandler = Thread.currentThread().getUncaughtExceptionHandler();
5261         Thread.currentThread().setUncaughtExceptionHandler((t, e) -&gt; {
5262 
5263             if (test_rt_39822_count == 0) {
5264                 test_rt_39822_count++;
5265                 if (! (e instanceof IllegalStateException)) {
5266                     e.printStackTrace();
5267                     fail(&quot;Expected IllegalStateException, instead got &quot; + e);
5268                 }
5269             } else {
5270                 // don&#39;t care
5271                 test_rt_39822_count++;
5272             }
5273         });
5274 
5275         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;();
5276         TreeTableColumn&lt;String, String&gt; col1 = new TreeTableColumn&lt;&gt;(&quot;Foo&quot;);
5277         table.getColumns().addAll(col1, col1);  // add column twice
5278 
5279         StageLoader sl = null;
5280         try {
5281             sl = new StageLoader(table);
5282         } finally {
5283             if (sl != null) {
5284                 sl.dispose();
5285             }
5286 
5287             // reset the exception handler
5288             Thread.currentThread().setUncaughtExceptionHandler(exceptionHandler);
5289         }
5290     }
5291 
5292     private int test_rt_39842_count = 0;
5293     @Test public void test_rt_39842_selectLeftDown() {
5294         test_rt_39842(true, false);
5295     }
5296 
5297     @Test public void test_rt_39842_selectLeftUp() {
5298         test_rt_39842(true, true);
5299     }
5300 
5301     @Test public void test_rt_39842_selectRightDown() {
5302         test_rt_39842(false, false);
5303     }
5304 
5305     @Test public void test_rt_39842_selectRightUp() {
5306         test_rt_39842(false, true);
5307     }
5308 
5309     private void test_rt_39842(boolean selectToLeft, boolean selectUpwards) {
5310         test_rt_39842_count = 0;
5311 
5312         TreeTableColumn firstNameCol = new TreeTableColumn(&quot;First Name&quot;);
5313         firstNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;firstName&quot;));
5314 
5315         TreeTableColumn lastNameCol = new TreeTableColumn(&quot;Last Name&quot;);
5316         lastNameCol.setCellValueFactory(new TreeItemPropertyValueFactory&lt;Person, String&gt;(&quot;lastName&quot;));
5317 
5318         TreeItem root = new TreeItem(&quot;root&quot;);
5319         root.getChildren().setAll(
5320                 new TreeItem(new Person(&quot;Jacob&quot;, &quot;Smith&quot;, &quot;jacob.smith@example.com&quot;)),
5321                 new TreeItem(new Person(&quot;Isabella&quot;, &quot;Johnson&quot;, &quot;isabella.johnson@example.com&quot;)),
5322                 new TreeItem(new Person(&quot;Ethan&quot;, &quot;Williams&quot;, &quot;ethan.williams@example.com&quot;)),
5323                 new TreeItem(new Person(&quot;Emma&quot;, &quot;Jones&quot;, &quot;emma.jones@example.com&quot;)),
5324                 new TreeItem(new Person(&quot;Michael&quot;, &quot;Brown&quot;, &quot;michael.brown@example.com&quot;)));
5325         root.setExpanded(true);
5326 
5327         TreeTableView&lt;Person&gt; table = new TreeTableView&lt;&gt;(root);
5328         table.setShowRoot(false);
5329         table.getColumns().addAll(firstNameCol, lastNameCol);
5330 
5331         sm = table.getSelectionModel();
5332         sm.setCellSelectionEnabled(true);
5333         sm.setSelectionMode(SelectionMode.MULTIPLE);
5334         sm.getSelectedCells().addListener((ListChangeListener) c -&gt; test_rt_39842_count++);
5335 
5336         StageLoader sl = new StageLoader(table);
5337 
5338         assertEquals(0, test_rt_39842_count);
5339 
5340         if (selectToLeft) {
5341             if (selectUpwards) {
5342                 sm.selectRange(3, lastNameCol, 0, firstNameCol);
5343             } else {
5344                 sm.selectRange(0, lastNameCol, 3, firstNameCol);
5345             }
5346         } else {
5347             if (selectUpwards) {
5348                 sm.selectRange(3, firstNameCol, 0, lastNameCol);
5349             } else {
5350                 sm.selectRange(0, firstNameCol, 3, lastNameCol);
5351             }
5352         }
5353 
5354         // test model state
5355         assertEquals(8, sm.getSelectedCells().size());
5356         assertEquals(1, test_rt_39842_count);
5357 
5358         // test visual state
5359         for (int row = 0; row &lt;= 3; row++) {
5360             for (int column = 0; column &lt;= 1; column++) {
5361                 IndexedCell cell = VirtualFlowTestUtils.getCell(table, row, column);
5362                 assertTrue(cell.isSelected());
5363             }
5364         }
5365 
5366         sl.dispose();
5367     }
5368 
5369     @Test public void test_rt_22599() {
5370         TreeItem&lt;RT22599_DataType&gt; root = new TreeItem&lt;&gt;();
5371         root.getChildren().setAll(
5372                 new TreeItem&lt;&gt;(new RT22599_DataType(1, &quot;row1&quot;)),
5373                 new TreeItem&lt;&gt;(new RT22599_DataType(2, &quot;row2&quot;)),
5374                 new TreeItem&lt;&gt;(new RT22599_DataType(3, &quot;row3&quot;)));
5375         root.setExpanded(true);
5376 
5377         TreeTableColumn&lt;RT22599_DataType, String&gt; col = new TreeTableColumn&lt;&gt;(&quot;Header&quot;);
5378         col.setCellValueFactory(param -&gt; new ReadOnlyStringWrapper(param.getValue().getValue().text));
5379 
5380         TreeTableView&lt;RT22599_DataType&gt; table = new TreeTableView&lt;&gt;(root);
5381         table.setShowRoot(false);
5382         table.getColumns().addAll(col);
5383 
5384         StageLoader sl = new StageLoader(table);
5385 
5386         // testing initial state
5387         assertNotNull(table.getSkin());
5388         assertEquals(&quot;row1&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5389         assertEquals(&quot;row2&quot;, VirtualFlowTestUtils.getCell(table, 1, 0).getText());
5390         assertEquals(&quot;row3&quot;, VirtualFlowTestUtils.getCell(table, 2, 0).getText());
5391 
5392         // change row 0 (where &quot;row1&quot; currently resides), keeping same id.
5393         // Because &#39;set&#39; is called, the control should update to the new content
5394         // without any user interaction
5395         TreeItem&lt;RT22599_DataType&gt; data;
5396         root.getChildren().set(0, data = new TreeItem&lt;&gt;(new RT22599_DataType(0, &quot;row1a&quot;)));
5397         Toolkit.getToolkit().firePulse();
5398         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5399 
5400         // change the row 0 (where we currently have &quot;row1a&quot;) value directly.
5401         // Because there is no associated property, this won&#39;t be observed, so
5402         // the control should still show &quot;row1a&quot; rather than &quot;row1b&quot;
5403         data.getValue().text = &quot;row1b&quot;;
5404         Toolkit.getToolkit().firePulse();
5405         assertEquals(&quot;row1a&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5406 
5407         // call refresh() to force a refresh of all visible cells
5408         table.refresh();
5409         Toolkit.getToolkit().firePulse();
5410         assertEquals(&quot;row1b&quot;, VirtualFlowTestUtils.getCell(table, 0, 0).getText());
5411 
5412         sl.dispose();
5413     }
5414 
5415     private static class RT22599_DataType {
5416         public int id = 0;
5417         public String text = &quot;&quot;;
5418 
5419         public RT22599_DataType(int id, String text) {
5420             this.id = id;
5421             this.text = text;
5422         }
5423 
5424         @Override public boolean equals(Object obj) {
5425             if (obj == null) return false;
5426             return id == ((RT22599_DataType)obj).id;
5427         }
5428     }
5429 
5430     private int rt_39966_count = 0;
5431     @Test public void test_rt_39966() {
5432         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5433         TreeTableView&lt;String&gt; table = new TreeTableView&lt;&gt;(root);
5434         table.setShowRoot(true);
5435 
5436         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5437         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5438         table.getColumns().add(column);
5439 
5440         StageLoader sl = new StageLoader(table);
5441 
5442         // initially there is no selection
5443         assertTrue(table.getSelectionModel().isEmpty());
5444 
5445         table.getSelectionModel().selectedItemProperty().addListener((value, s1, s2) -&gt; {
5446             if (rt_39966_count == 0) {
5447                 rt_39966_count++;
5448                 assertFalse(table.getSelectionModel().isEmpty());
5449             } else {
5450                 assertTrue(table.getSelectionModel().isEmpty());
5451             }
5452         });
5453 
5454         // our assertion two lines down always succeeds. What fails is our
5455         // assertion above within the listener.
5456         table.getSelectionModel().select(0);
5457         assertFalse(table.getSelectionModel().isEmpty());
5458 
5459         table.setRoot(null);
5460         assertTrue(table.getSelectionModel().isEmpty());
5461 
5462         sl.dispose();
5463     }
5464 
5465     /**
5466      * Bullet 1: selected index must be updated
5467      * Corner case: last selected. Fails for core
5468      */
5469     @Test public void test_rt_40012_selectedAtLastOnDisjointRemoveItemsAbove() {
5470         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5471         root.setExpanded(true);
5472         root.getChildren().addAll(
5473             new TreeItem&lt;&gt;(&quot;0&quot;),
5474             new TreeItem&lt;&gt;(&quot;1&quot;),
5475             new TreeItem&lt;&gt;(&quot;2&quot;),
5476             new TreeItem&lt;&gt;(&quot;3&quot;),
5477             new TreeItem&lt;&gt;(&quot;4&quot;),
5478             new TreeItem&lt;&gt;(&quot;5&quot;)
5479         );
5480 
5481         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5482         stringTreeTableView.setShowRoot(false);
5483         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5484 
5485         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5486         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5487         stringTreeTableView.getColumns().add(column);
5488 
5489         int last = root.getChildren().size() - 1;
5490 
5491         // selecting item &quot;5&quot;
5492         sm.select(last);
5493 
5494         // disjoint remove of 2 elements above the last selected
5495         // Removing &quot;1&quot; and &quot;3&quot;
5496         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5497 
5498         // selection should move up two places such that it remains on item &quot;5&quot;,
5499         // but in index (last - 2).
5500         int expected = last - 2;
5501         assertEquals(&quot;5&quot;, sm.getSelectedItem().getValue());
5502         assertEquals(&quot;selected index after disjoint removes above&quot;, expected, sm.getSelectedIndex());
5503     }
5504 
5505     /**
5506      * Variant of 1: if selectedIndex is not updated,
5507      * the old index is no longer valid
5508      * for accessing the items.
5509      */
5510     @Test public void test_rt_40012_accessSelectedAtLastOnDisjointRemoveItemsAbove() {
5511         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5512         root.setExpanded(true);
5513         root.getChildren().addAll(
5514                 new TreeItem&lt;&gt;(&quot;0&quot;),
5515                 new TreeItem&lt;&gt;(&quot;1&quot;),
5516                 new TreeItem&lt;&gt;(&quot;2&quot;),
5517                 new TreeItem&lt;&gt;(&quot;3&quot;),
5518                 new TreeItem&lt;&gt;(&quot;4&quot;),
5519                 new TreeItem&lt;&gt;(&quot;5&quot;)
5520         );
5521 
5522         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5523         stringTreeTableView.setShowRoot(false);
5524         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5525 
5526         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5527         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5528         stringTreeTableView.getColumns().add(column);
5529 
5530         int last = root.getChildren().size() - 1;
5531 
5532         // selecting item &quot;5&quot;
5533         sm.select(last);
5534 
5535         // disjoint remove of 2 elements above the last selected
5536         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5537         int selected = sm.getSelectedIndex();
5538         if (selected &gt; -1) {
5539             root.getChildren().get(selected);
5540         }
5541     }
5542 
5543     /**
5544      * Bullet 2: selectedIndex notification count
5545      *
5546      * Note that we don&#39;t use the corner case of having the last index selected
5547      * (which fails already on updating the index)
5548      */
5549     private int rt_40012_count = 0;
5550     @Test public void test_rt_40012_selectedIndexNotificationOnDisjointRemovesAbove() {
5551         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5552         root.setExpanded(true);
5553         root.getChildren().addAll(
5554                 new TreeItem&lt;&gt;(&quot;0&quot;),
5555                 new TreeItem&lt;&gt;(&quot;1&quot;),
5556                 new TreeItem&lt;&gt;(&quot;2&quot;),
5557                 new TreeItem&lt;&gt;(&quot;3&quot;),
5558                 new TreeItem&lt;&gt;(&quot;4&quot;),
5559                 new TreeItem&lt;&gt;(&quot;5&quot;)
5560         );
5561 
5562         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5563         stringTreeTableView.setShowRoot(false);
5564         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5565 
5566         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5567         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5568         stringTreeTableView.getColumns().add(column);
5569 
5570         int last = root.getChildren().size() - 2;
5571         sm.select(last);
5572         assertEquals(last, sm.getSelectedIndex());
5573 
5574         rt_40012_count = 0;
5575         sm.selectedIndexProperty().addListener(o -&gt; rt_40012_count++);
5576 
5577         // disjoint remove of 2 elements above the last selected
5578         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5579         assertEquals(&quot;sanity: selectedIndex must be shifted by -2&quot;, last - 2, sm.getSelectedIndex());
5580         assertEquals(&quot;must fire single event on removes above&quot;, 1, rt_40012_count);
5581     }
5582 
5583     /**
5584      * Bullet 3: unchanged selectedItem must not fire change
5585      */
5586     @Test
5587     public void test_rt_40012_selectedItemNotificationOnDisjointRemovesAbove() {
5588         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5589         root.setExpanded(true);
5590         root.getChildren().addAll(
5591                 new TreeItem&lt;&gt;(&quot;0&quot;),
5592                 new TreeItem&lt;&gt;(&quot;1&quot;),
5593                 new TreeItem&lt;&gt;(&quot;2&quot;),
5594                 new TreeItem&lt;&gt;(&quot;3&quot;),
5595                 new TreeItem&lt;&gt;(&quot;4&quot;),
5596                 new TreeItem&lt;&gt;(&quot;5&quot;)
5597         );
5598 
5599         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5600         stringTreeTableView.setShowRoot(false);
5601         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5602 
5603         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5604         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5605         stringTreeTableView.getColumns().add(column);
5606 
5607         int last = root.getChildren().size() - 2;
5608         Object lastItem = root.getChildren().get(last);
5609         sm.select(last);
5610         assertEquals(lastItem, sm.getSelectedItem());
5611 
5612         rt_40012_count = 0;
5613         sm.selectedItemProperty().addListener(o -&gt; rt_40012_count++);
5614 
5615         // disjoint remove of 2 elements above the last selected
5616         root.getChildren().removeAll(root.getChildren().get(1), root.getChildren().get(3));
5617         assertEquals(&quot;sanity: selectedItem unchanged&quot;, lastItem, sm.getSelectedItem());
5618         assertEquals(&quot;must not fire on unchanged selected item&quot;, 0, rt_40012_count);
5619     }
5620 
5621     private int rt_40010_count = 0;
5622     @Test public void test_rt_40010() {
5623         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5624         TreeItem&lt;String&gt; child = new TreeItem&lt;&gt;(&quot;child&quot;);
5625         root.setExpanded(true);
5626         root.getChildren().addAll(child);
5627 
5628         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5629         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5630 
5631         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5632         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5633         stringTreeTableView.getColumns().add(column);
5634 
5635         sm.getSelectedIndices().addListener((ListChangeListener&lt;? super Integer&gt;) l -&gt; rt_40010_count++);
5636         sm.getSelectedItems().addListener((ListChangeListener&lt;? super TreeItem&lt;String&gt;&gt;) l -&gt; rt_40010_count++);
5637 
5638         assertEquals(0, rt_40010_count);
5639 
5640         sm.select(1);
5641         assertEquals(1, sm.getSelectedIndex());
5642         assertEquals(child, sm.getSelectedItem());
5643         assertEquals(2, rt_40010_count);
5644 
5645         root.getChildren().remove(child);
5646         assertEquals(0, sm.getSelectedIndex());
5647         assertEquals(root, sm.getSelectedItem());
5648         assertEquals(4, rt_40010_count);
5649     }
5650 
5651     /**
5652      * ClearAndSelect fires invalid change event if selectedIndex is unchanged.
5653      */
5654     private int rt_40212_count = 0;
5655     @Test public void test_rt_40212() {
5656         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5657         root.setExpanded(true);
5658         root.getChildren().addAll(
5659                 new TreeItem&lt;&gt;(&quot;0&quot;),
5660                 new TreeItem&lt;&gt;(&quot;1&quot;),
5661                 new TreeItem&lt;&gt;(&quot;2&quot;),
5662                 new TreeItem&lt;&gt;(&quot;3&quot;),
5663                 new TreeItem&lt;&gt;(&quot;4&quot;),
5664                 new TreeItem&lt;&gt;(&quot;5&quot;)
5665         );
5666 
5667         TreeTableView&lt;String&gt; stringTreeTableView = new TreeTableView&lt;&gt;(root);
5668         stringTreeTableView.setShowRoot(false);
5669 
5670         TreeTableView.TreeTableViewSelectionModel&lt;String&gt; sm = stringTreeTableView.getSelectionModel();
5671         sm.setSelectionMode(SelectionMode.MULTIPLE);
5672 
5673         TreeTableColumn&lt;String,String&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5674         column.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5675         stringTreeTableView.getColumns().add(column);
5676 
5677         sm.selectRange(3, 5);
5678         int selected = sm.getSelectedIndex();
5679 
5680         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {
5681             assertEquals(&quot;sanity: selectedIndex unchanged&quot;, selected, sm.getSelectedIndex());
5682             while(change.next()) {
5683                 assertEquals(&quot;single event on clearAndSelect already selected&quot;, 1, ++rt_40212_count);
5684 
5685                 boolean type = change.wasAdded() || change.wasRemoved() || change.wasPermutated() || change.wasUpdated();
5686                 assertTrue(&quot;at least one of the change types must be true&quot;, type);
5687             }
5688         });
5689 
5690         sm.clearAndSelect(selected);
5691     }
5692 
5693     @Test public void test_rt_40280() {
5694         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;();
5695         StageLoader sl = new StageLoader(view);
5696         MultipleSelectionModelBaseShim.getFocusedIndex(view.getSelectionModel());
5697         view.getFocusModel().getFocusedIndex();
5698         sl.dispose();
5699     }
5700 
5701     @Test public void test_rt_40278_showRoot() {
5702         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5703         root.setExpanded(true);
5704         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5705 
5706         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5707         view.setShowRoot(false);
5708         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5709 
5710         assertFalse(&quot;sanity: test setup such that root is not showing&quot;, view.isShowRoot());
5711         sm.select(0);
5712         assertEquals(0, sm.getSelectedIndex());
5713         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5714         view.setShowRoot(true);
5715         assertEquals(1, sm.getSelectedIndex());
5716         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5717     }
5718 
5719     @Test public void test_rt_40278_hideRoot_selectionOnChild() {
5720         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5721         root.setExpanded(true);
5722         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5723 
5724         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5725         view.setShowRoot(true);
5726         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5727 
5728         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5729         sm.select(1);
5730         assertEquals(1, sm.getSelectedIndex());
5731         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5732         view.setShowRoot(false);
5733         assertEquals(0, sm.getSelectedIndex());
5734         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5735     }
5736 
5737     @Test public void test_rt_40278_hideRoot_selectionOnRoot() {
5738         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5739         root.setExpanded(true);
5740         root.getChildren().addAll(new TreeItem&lt;&gt;(&quot;0&quot;),new TreeItem&lt;&gt;(&quot;1&quot;));
5741 
5742         TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
5743         view.setShowRoot(true);
5744         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
5745 
5746         assertTrue(&quot;sanity: test setup such that root is showing&quot;, view.isShowRoot());
5747         sm.select(0);
5748         assertEquals(0, sm.getSelectedIndex());
5749         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5750         view.setShowRoot(false);
5751         assertEquals(0, sm.getSelectedIndex());
5752         assertEquals(view.getTreeItem(sm.getSelectedIndex()), sm.getSelectedItem());
5753     }
5754 
5755     /**
5756      * Test list change of selectedIndices on setIndices. Fails for core ..
5757      */
5758     @Test public void test_rt_40263() {
5759         TreeItem&lt;Integer&gt; root = new TreeItem&lt;&gt;(-1);
5760         root.setExpanded(true);
5761 
5762         for (int i = 0; i &lt; 10; i++) {
5763             root.getChildren().add(new TreeItem&lt;Integer&gt;(i));
5764         }
5765 
5766         final TreeTableView&lt;Integer&gt; view = new TreeTableView&lt;&gt;(root);
5767         TreeTableView.TreeTableViewSelectionModel&lt;Integer&gt; sm = view.getSelectionModel();
5768         sm.setSelectionMode(SelectionMode.MULTIPLE);
5769 
5770         int[] indices = new int[]{2, 5, 7};
5771         ListChangeListener&lt;Integer&gt; l = c -&gt; {
5772             // firstly, we expect only one change
5773             int subChanges = 0;
5774             while(c.next()) {
5775                 subChanges++;
5776             }
5777             assertEquals(1, subChanges);
5778 
5779             // secondly, we expect the added size to be three, as that is the
5780             // number of items selected
5781             c.reset();
5782             c.next();
5783             assertEquals(indices.length, c.getAddedSize());
5784             assertArrayEquals(indices, c.getAddedSubList().stream().mapToInt(i -&gt; i).toArray());
5785         };
5786         sm.getSelectedIndices().addListener(l);
5787         sm.selectIndices(indices[0], indices);
5788     }
5789 
5790     @Test public void test_rt_40319_toRight_toBottom()          { test_rt_40319(true, true, false);   }
5791     @Test public void test_rt_40319_toRight_toTop()             { test_rt_40319(true, false, false);  }
5792     @Test public void test_rt_40319_toLeft_toBottom()           { test_rt_40319(false, true, false);  }
5793     @Test public void test_rt_40319_toLeft_toTop()              { test_rt_40319(false, false, false); }
5794     @Test public void test_rt_40319_toRight_toBottom_useMouse() { test_rt_40319(true, true, true);    }
5795     @Test public void test_rt_40319_toRight_toTop_useMouse()    { test_rt_40319(true, false, true);   }
5796     @Test public void test_rt_40319_toLeft_toBottom_useMouse()  { test_rt_40319(false, true, true);   }
5797     @Test public void test_rt_40319_toLeft_toTop_useMouse()     { test_rt_40319(false, false, true);  }
5798 
5799     private void test_rt_40319(boolean toRight, boolean toBottom, boolean useMouse) {
5800         TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root&quot;);
5801         root.setExpanded(true);
5802         root.getChildren().addAll(
5803                 new TreeItem&lt;&gt;(&quot;0&quot;),
5804                 new TreeItem&lt;&gt;(&quot;1&quot;),
5805                 new TreeItem&lt;&gt;(&quot;2&quot;),
5806                 new TreeItem&lt;&gt;(&quot;3&quot;),
5807                 new TreeItem&lt;&gt;(&quot;4&quot;),
5808                 new TreeItem&lt;&gt;(&quot;5&quot;)
5809         );
5810 
5811         TreeTableView&lt;String&gt; t = new TreeTableView&lt;&gt;(root);
5812         t.setShowRoot(false);
5813 
5814         sm = t.getSelectionModel();
5815         sm.setSelectionMode(SelectionMode.MULTIPLE);
5816 
5817         TreeTableColumn&lt;String,String&gt; c1 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5818         c1.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5819         TreeTableColumn&lt;String,String&gt; c2 = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5820         c2.setCellValueFactory(cdf -&gt; new ReadOnlyStringWrapper(cdf.getValue().getValue()));
5821         t.getColumns().addAll(c1, c2);
5822 
5823         final int startIndex = toRight ? 0 : 2;
5824         final int endIndex = toRight ? 2 : 0;
5825         final TreeTableColumn&lt;String,String&gt; startColumn = toBottom ? c1 : c2;
5826         final TreeTableColumn&lt;String,String&gt; endColumn = toBottom ? c2 : c1;
5827 
5828         sm.select(startIndex, startColumn);
5829 
5830         if (useMouse) {
5831             Cell endCell = VirtualFlowTestUtils.getCell(t, endIndex, toRight ? 1 : 0);
5832             MouseEventFirer mouse = new MouseEventFirer(endCell);
5833             mouse.fireMousePressAndRelease(KeyModifier.SHIFT);
5834         } else {
5835             t.getSelectionModel().selectRange(startIndex, startColumn, endIndex, endColumn);
5836         }
5837 
5838         assertEquals(3, sm.getSelectedItems().size());
5839         assertEquals(3, sm.getSelectedIndices().size());
5840         assertEquals(3, sm.getSelectedCells().size());
5841     }
5842 
5843     @Test public void test_jdk_8147483() {
5844         TreeItem&lt;Number&gt; root = new TreeItem&lt;&gt;(0);
5845         root.setExpanded(true);
5846 
5847         final TreeTableView&lt;Number&gt; view = new TreeTableView&lt;&gt;(root);
5848         view.setShowRoot(false);
5849 
5850         AtomicInteger cellUpdateCount = new AtomicInteger();
5851         AtomicInteger rowCreateCount = new AtomicInteger();
5852 
5853         TreeTableColumn&lt;Number, Number&gt; column = new TreeTableColumn&lt;&gt;(&quot;Column&quot;);
5854         column.setCellValueFactory(cdf -&gt; new ReadOnlyIntegerWrapper(0));
5855         column.setCellFactory( ttc -&gt; new TreeTableCell&lt;Number,Number&gt;() {
5856             @Override protected void updateItem(Number item, boolean empty) {
5857                 cellUpdateCount.incrementAndGet();
5858                 super.updateItem(item, empty);
5859             }
5860         });
5861         view.getColumns().add(column);
5862 
5863         view.setRowFactory(t -&gt; {
5864             rowCreateCount.incrementAndGet();
5865             return new TreeTableRow&lt;&gt;();
5866         });
5867 
5868         assertEquals(0, cellUpdateCount.get());
5869         assertEquals(0, rowCreateCount.get());
5870 
5871         StageLoader sl = new StageLoader(view);
5872 
5873         // Before the fix, we got cellUpdateCount = 18 and rowCreateCount = 17 for the first add below.
5874         // After the second add, these numbers went to 53 and 17 respectively.
5875         // Because these numbers might differ on other systems, we simply record the values after
5876         // the first add, and then we expect the cellUpdateCount to increase by one, and rowCreateCount to
5877         // not increase at all.
5878         root.getChildren().add(new TreeItem(1));
5879         Toolkit.getToolkit().firePulse();
5880         final int firstCellUpdateCount = cellUpdateCount.get();
5881         final int firstRowCreateCount = rowCreateCount.get();
5882 
5883         root.getChildren().add(new TreeItem(2));
5884         Toolkit.getToolkit().firePulse();
5885         assertEquals(firstCellUpdateCount+1, cellUpdateCount.get());
5886         assertEquals(firstRowCreateCount, rowCreateCount.get());
5887 
5888         root.getChildren().add(new TreeItem(3));
5889         Toolkit.getToolkit().firePulse();
5890         assertEquals(firstCellUpdateCount+2, cellUpdateCount.get());
5891         assertEquals(firstRowCreateCount, rowCreateCount.get());
5892 
5893         sl.dispose();
5894     }
5895 
5896     @Test public void test_jdk_8144681_removeColumn() {
5897         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
5898 
5899         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
5900         root.getChildren().addAll(
5901                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
5902                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
5903                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
5904                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
5905         table.setRoot(root);
5906 
5907         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
5908         for (String prop : columns) {
5909             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
5910             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
5911             table.getColumns().add(col);
5912         }
5913         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
5914         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
5915         table.getSelectionModel().setCellSelectionEnabled(true);
5916 
5917         table.getSelectionModel().selectAll();
5918 
5919         ControlTestUtils.runWithExceptionHandler(() -&gt; table.getColumns().remove(2));
5920     }
5921 
5922     @Test public void test_jdk_8144681_moveColumn() {
5923         TreeTableView&lt;Book&gt; table = new TreeTableView&lt;&gt;();
5924 
5925         TreeItem&lt;Book&gt; root = new TreeItem&lt;&gt;();
5926         root.getChildren().addAll(
5927                 new TreeItem&lt;&gt;(new Book(&quot;Book 1&quot;, &quot;Author 1&quot;, &quot;Remark 1&quot;))
5928                 , new TreeItem&lt;&gt;(new Book(&quot;Book 2&quot;, &quot;Author 2&quot;, &quot;Remark 2&quot;))
5929                 , new TreeItem&lt;&gt;(new Book(&quot;Book 3&quot;, &quot;Author 3&quot;, &quot;Remark 3&quot;))
5930                 , new TreeItem&lt;&gt;(new Book(&quot;Book 4&quot;, &quot;Author 4&quot;, &quot;Remark 4&quot;)));
5931         table.setRoot(root);
5932 
5933         String[] columns = { &quot;title&quot;, &quot;author&quot;, &quot;remark&quot; };
5934         for (String prop : columns) {
5935             TreeTableColumn&lt;Book, String&gt; col = new TreeTableColumn&lt;&gt;(prop);
5936             col.setCellValueFactory(new TreeItemPropertyValueFactory&lt;&gt;(prop));
5937             table.getColumns().add(col);
5938         }
5939         table.setColumnResizePolicy(TreeTableView.UNCONSTRAINED_RESIZE_POLICY);
5940         table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
5941         table.getSelectionModel().setCellSelectionEnabled(true);
5942 
5943         table.getSelectionModel().selectAll();
5944 
5945         ControlTestUtils.runWithExceptionHandler(() -&gt; {
5946             table.getColumns().setAll(table.getColumns().get(0), table.getColumns().get(2), table.getColumns().get(1));
5947         });
5948     }
5949 
5950     private static class Book {
5951         private SimpleStringProperty title = new SimpleStringProperty();
5952         private SimpleStringProperty author = new SimpleStringProperty();
5953         private SimpleStringProperty remark = new SimpleStringProperty();
5954 
5955         public Book(String title, String author, String remark) {
5956             super();
5957             setTitle(title);
5958             setAuthor(author);
5959             setRemark(remark);
5960         }
5961 
5962         public SimpleStringProperty titleProperty() {
5963             return this.title;
5964         }
5965 
5966         public java.lang.String getTitle() {
5967             return this.titleProperty().get();
5968         }
5969 
5970         public void setTitle(final java.lang.String title) {
5971             this.titleProperty().set(title);
5972         }
5973 
5974         public SimpleStringProperty authorProperty() {
5975             return this.author;
5976         }
5977 
5978         public java.lang.String getAuthor() {
5979             return this.authorProperty().get();
5980         }
5981 
5982         public void setAuthor(final java.lang.String author) {
5983             this.authorProperty().set(author);
5984         }
5985 
5986         public SimpleStringProperty remarkProperty() {
5987             return this.remark;
5988         }
5989 
5990         public java.lang.String getRemark() {
5991             return this.remarkProperty().get();
5992         }
5993 
5994         public void setRemark(final java.lang.String remark) {
5995             this.remarkProperty().set(remark);
5996         }
5997 
5998         @Override
5999         public String toString() {
6000             return String.format(&quot;%s(%s) - %s&quot;, getTitle(), getAuthor(), getRemark());
6001         }
6002     }
6003 
6004     @Test public void test_jdk_8157205() {
6005         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6006         childNode1.setExpanded(true);
6007         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6008         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6009         childNode1.getChildren().addAll(item1, item2);
6010 
6011         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6012         root.setExpanded(true);
6013         root.getChildren().add(childNode1);
6014 
6015         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6016         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6017         sm.setSelectionMode(SelectionMode.MULTIPLE);
6018 
6019         AtomicInteger step = new AtomicInteger();
6020 
6021         AtomicInteger indicesEventCount = new AtomicInteger();
6022         sm.getSelectedIndices().addListener((ListChangeListener&lt;Integer&gt;)c -&gt; {
6023             switch (step.get()) {
6024                 case 0: {
6025                     // expect to see [1,2,3] added at index 0
6026                     c.next();
6027                     assertEquals(3, c.getAddedSize());
6028                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6029                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(1,2,3)));
6030                     assertEquals(0, c.getFrom());
6031                     break;
6032                 }
6033                 case 1: {
6034                     // expect to see [2,3] removed
6035                     List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
6036                     while (c.next()) {
6037                         if (c.wasRemoved()) {
6038                             removed.addAll(c.getRemoved());
6039                         } else {
6040                             fail(&quot;Unexpected state&quot;);
6041                         }
6042                     }
6043                     if (!removed.isEmpty()) {
6044                         assertTrue(removed.containsAll(FXCollections.observableArrayList(2,3)));
6045                     }
6046                     break;
6047                 }
6048             }
6049 
6050             indicesEventCount.incrementAndGet();
6051         });
6052 
6053         AtomicInteger itemsEventCount = new AtomicInteger();
6054         sm.getSelectedItems().addListener((ListChangeListener&lt;TreeItem&lt;String&gt;&gt;)c -&gt; {
6055             switch (step.get()) {
6056                 case 0: {
6057                     // expect to see [1,2,3] added at index 0
6058                     c.next();
6059                     assertEquals(3, c.getAddedSize());
6060                     assertTrue(&quot;added: &quot; + c.getAddedSubList(),
6061                             c.getAddedSubList().containsAll(FXCollections.observableArrayList(childNode1, item1, item2)));
6062                     assertEquals(0, c.getFrom());
6063                     break;
6064                 }
6065                 case 1: {
6066                     // expect to see [2,3] removed
6067                     List&lt;TreeItem&lt;String&gt;&gt; removed = new ArrayList&lt;&gt;();
6068                     while (c.next()) {
6069                         if (c.wasRemoved()) {
6070                             removed.addAll(c.getRemoved());
6071                         } else {
6072                             fail(&quot;Unexpected state&quot;);
6073                         }
6074                     }
6075                     if (!removed.isEmpty()) {
6076                         assertTrue(removed.containsAll(FXCollections.observableArrayList(item1, item2)));
6077                     }
6078                     break;
6079                 }
6080             }
6081 
6082             itemsEventCount.incrementAndGet();
6083         });
6084 
6085         assertEquals(0, indicesEventCount.get());
6086         assertEquals(0, itemsEventCount.get());
6087 
6088         step.set(0);
6089         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6090         assertTrue(sm.isSelected(1));
6091         assertTrue(sm.isSelected(2));
6092         assertTrue(sm.isSelected(3));
6093         assertEquals(3, sm.getSelectedIndices().size());
6094         assertEquals(3, sm.getSelectedItems().size());
6095         assertEquals(1, indicesEventCount.get());
6096         assertEquals(1, itemsEventCount.get());
6097 
6098         step.set(1);
6099         childNode1.setExpanded(false); // collapse Child Node 1 and expect both children to be deselected
6100         assertTrue(sm.isSelected(1));
6101         assertFalse(sm.isSelected(2));
6102         assertFalse(sm.isSelected(3));
6103         assertEquals(1, sm.getSelectedIndices().size());
6104         assertEquals(1, sm.getSelectedItems().size());
6105         assertEquals(2, indicesEventCount.get());
6106         assertEquals(2, itemsEventCount.get());
6107 
6108         step.set(2);
6109         childNode1.setExpanded(true); // expand Child Node 1 and expect both children to still be deselected
6110         assertTrue(sm.isSelected(1));
6111         assertFalse(sm.isSelected(2));
6112         assertFalse(sm.isSelected(3));
6113         assertEquals(1, sm.getSelectedIndices().size());
6114         assertEquals(1, sm.getSelectedItems().size());
6115         assertEquals(2, indicesEventCount.get());
6116         assertEquals(2, itemsEventCount.get());
6117     }
6118 
6119     @Test public void test_jdk_8157285() {
6120         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6121         childNode1.setExpanded(true);
6122         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6123         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6124         childNode1.getChildren().addAll(item1, item2);
6125 
6126         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6127         root.setExpanded(true);
6128         root.getChildren().add(childNode1);
6129 
6130         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6131         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6132         sm.setSelectionMode(SelectionMode.MULTIPLE);
6133 
6134         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6135             if (childNode1.isExpanded()) return;
6136             assertTrue(sm.isSelected(1));
6137             assertFalse(sm.isSelected(2));
6138             assertFalse(sm.isSelected(3));
6139             assertEquals(1, sm.getSelectedIndices().size());
6140             assertEquals(1, sm.getSelectedItems().size());
6141         });
6142 
6143         sm.selectIndices(1,2,3); // select Child Node 1 and both children
6144         assertTrue(sm.isSelected(1));
6145         assertTrue(sm.isSelected(2));
6146         assertTrue(sm.isSelected(3));
6147         assertEquals(3, sm.getSelectedIndices().size());
6148         assertEquals(3, sm.getSelectedItems().size());
6149 
6150         // collapse Child Node 1 and expect both children to be deselected,
6151         // and that in the expandedItemCount listener that we get the right values
6152         // in the selectedIndices and selectedItems list
6153         childNode1.setExpanded(false);
6154     }
6155 
6156     @Test public void test_jdk_8152396() {
6157         final TreeItem&lt;String&gt; childNode1 = new TreeItem&lt;&gt;(&quot;Child Node 1&quot;);
6158         TreeItem&lt;String&gt; item1 = new TreeItem&lt;&gt;(&quot;Node 1-1&quot;);
6159         TreeItem&lt;String&gt; item2 = new TreeItem&lt;&gt;(&quot;Node 1-2&quot;);
6160         childNode1.getChildren().addAll(item1, item2);
6161 
6162         final TreeItem&lt;String&gt; root = new TreeItem&lt;&gt;(&quot;Root node&quot;);
6163         root.setExpanded(true);
6164         root.getChildren().add(childNode1);
6165 
6166         final TreeTableView&lt;String&gt; view = new TreeTableView&lt;&gt;(root);
6167         MultipleSelectionModel&lt;TreeItem&lt;String&gt;&gt; sm = view.getSelectionModel();
6168         sm.setSelectionMode(SelectionMode.MULTIPLE);
6169 
6170         view.expandedItemCountProperty().addListener((observable, oldCount, newCount) -&gt; {
6171             if (newCount.intValue() &gt; oldCount.intValue()) {
6172                 for (int index: sm.getSelectedIndices()) {
6173                     TreeItem&lt;String&gt; item = view.getTreeItem(index);
6174 
6175                     if (item != null &amp;&amp; item.isExpanded() &amp;&amp; !item.getChildren().isEmpty()) {
6176                         int startIndex = index + 1;
6177                         int maxCount = startIndex + item.getChildren().size();
6178 
6179                         sm.selectRange(startIndex, maxCount);
6180                     }
6181                 }
6182             }
6183         });
6184 
6185         FilteredList filteredList = sm.getSelectedItems().filtered(Objects::nonNull);
6186 
6187         StageLoader sl = new StageLoader(view);
6188 
6189         sm.select(1);
6190         childNode1.setExpanded(true);
6191         Toolkit.getToolkit().firePulse();
6192 
6193         // collapse Child Node 1 and expect both children to be deselected,
6194         // and that the filtered list does not throw an exception
6195         assertEquals(3, filteredList.size());
6196         ControlTestUtils.runWithExceptionHandler(() -&gt; childNode1.setExpanded(false));
6197 
6198         Toolkit.getToolkit().firePulse();
6199         assertEquals(1, filteredList.size());
6200 
6201         sl.dispose();
6202     }
6203 
6204     @Test public void test_jdk_8160771() {
6205         TreeTableView table = new TreeTableView();
6206         TreeTableColumn first = new TreeTableColumn(&quot;First Name&quot;);
6207         table.getColumns().add(first);
6208         table.getVisibleLeafColumns().addListener((ListChangeListener) c -&gt; {
6209             c.next();
6210             assertTrue(c.wasAdded());
6211             assertSame(table, ((TreeTableColumn) c.getAddedSubList().get(0)).getTreeTableView());
6212         });
6213         TreeTableColumn last = new TreeTableColumn(&quot;Last Name&quot;);
6214         table.getColumns().add(0, last);
6215     }
6216 
6217     private void test_jdk_8169642(Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; before,
6218                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterDescending,
6219                                   Consumer&lt;TreeTableView.TreeTableViewSelectionModel&gt; afterAscending) {
6220         final TreeItem&lt;String&gt; rootItem = new TreeItem&lt;&gt;(&quot;root&quot;);
6221         rootItem.setExpanded(true);
6222         rootItem.getChildren().addAll(new TreeItem&lt;&gt;(&quot;first child&quot;), new TreeItem&lt;&gt;(&quot;second child&quot;), new TreeItem&lt;&gt;(&quot;third child&quot;));
6223 
6224         final TreeTableView&lt;String&gt; tree = new TreeTableView&lt;&gt;(rootItem);
6225         final TreeTableColumn&lt;String, String&gt; column = new TreeTableColumn&lt;&gt;(&quot;first column&quot;);
6226         column.setCellValueFactory(param -&gt; new SimpleStringProperty(param.getValue().getValue()));
6227         tree.getColumns().add(column);
6228 
6229         TreeTableView.TreeTableViewSelectionModel sm = tree.getSelectionModel();
6230         sm.setSelectionMode(SelectionMode.MULTIPLE);
6231 
6232         assertTrue(sm.isEmpty());
6233         before.accept(sm);
6234 
6235         tree.getSortOrder().add(column);
6236         column.setSortType(TreeTableColumn.SortType.DESCENDING);
6237         afterDescending.accept(sm);
6238 
6239         column.setSortType(TreeTableColumn.SortType.ASCENDING);
6240         afterAscending.accept(sm);
6241     }
6242 
6243     @Test public void test_jdk_8169642_1_only() {
6244         test_jdk_8169642(
6245             sm -&gt; {
6246                 // select &#39;first&#39;
6247                 sm.select(1);
6248                 assertTrue(sm.isSelected(1));
6249                 assertEquals(1, sm.getSelectedCells().size());
6250             },
6251             sm -&gt; {
6252                 assertTrue(sm.isSelected(3));
6253                 assertEquals(1, sm.getSelectedCells().size());
6254             },
6255             sm -&gt; {
6256                 assertTrue(sm.isSelected(1));
6257                 assertEquals(1, sm.getSelectedCells().size());
6258             }
6259         );
6260     }
6261 
6262     @Test public void test_jdk_8169642_2_only() {
6263         test_jdk_8169642(
6264             sm -&gt; {
6265                 // select &#39;second&#39;
6266                 sm.select(2);
6267                 assertTrue(sm.isSelected(2));
6268                 assertEquals(1, sm.getSelectedCells().size());
6269             },
6270             sm -&gt; {
6271                 assertTrue(sm.isSelected(2));
6272                 assertEquals(1, sm.getSelectedCells().size());
6273             },
6274             sm -&gt; {
6275                 assertTrue(sm.isSelected(2));
6276                 assertEquals(1, sm.getSelectedCells().size());
6277             }
6278         );
6279     }
6280 
6281     @Test public void test_jdk_8169642_1_and_3() {
6282         test_jdk_8169642(
6283             sm -&gt; {
6284                 // select &#39;first&#39; and &#39;third&#39;, they should flip positions
6285                 sm.select(1);
6286                 sm.select(3);
6287                 assertTrue(sm.isSelected(1));
6288                 assertTrue(sm.isSelected(3));
6289                 assertEquals(2, sm.getSelectedCells().size());
6290             },
6291             sm -&gt; {
6292                 assertTrue(sm.isSelected(1));
6293                 assertTrue(sm.isSelected(3));
6294                 assertEquals(2, sm.getSelectedCells().size());
6295             },
6296             sm -&gt; {
6297                 assertTrue(sm.isSelected(1));
6298                 assertTrue(sm.isSelected(3));
6299                 assertEquals(2, sm.getSelectedCells().size());
6300             }
6301         );
6302     }
6303 
6304     @Test public void test_jdk_8169642_0_and_3() {
6305         test_jdk_8169642(
6306                 sm -&gt; {
6307                     // select &#39;root&#39; and &#39;third&#39;
6308                     sm.select(0);
6309                     sm.select(3);
6310                     assertTrue(sm.isSelected(0));
6311                     assertTrue(sm.isSelected(3));
6312                     assertEquals(2, sm.getSelectedCells().size());
6313                 },
6314                 sm -&gt; {
6315                     assertTrue(sm.isSelected(0));
6316                     assertTrue(sm.isSelected(1));
6317                     assertEquals(2, sm.getSelectedCells().size());
6318                 },
6319                 sm -&gt; {
6320                     assertTrue(sm.isSelected(0));
6321                     assertTrue(sm.isSelected(3));
6322                     assertEquals(2, sm.getSelectedCells().size());
6323                 }
6324         );
6325     }
6326 }
    </pre>
  </body>
</html>
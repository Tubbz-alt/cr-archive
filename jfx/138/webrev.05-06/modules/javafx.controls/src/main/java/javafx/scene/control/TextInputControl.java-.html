<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/TextInputControl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.FormatterAccessor;
  29 import javafx.beans.DefaultProperty;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.beans.binding.IntegerBinding;
  33 import javafx.beans.binding.StringBinding;
  34 import javafx.beans.property.BooleanProperty;
  35 import javafx.beans.property.ObjectProperty;
  36 import javafx.beans.property.ObjectPropertyBase;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.property.ReadOnlyBooleanWrapper;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.ReadOnlyStringProperty;
  44 import javafx.beans.property.ReadOnlyStringWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.beans.value.ObservableStringValue;
  50 import javafx.beans.value.ObservableValue;
  51 import javafx.beans.value.WritableValue;
  52 import javafx.css.CssMetaData;
  53 import javafx.css.FontCssMetaData;
  54 import javafx.css.PseudoClass;
  55 import javafx.css.StyleOrigin;
  56 import javafx.css.Styleable;
  57 import javafx.css.StyleableObjectProperty;
  58 import javafx.css.StyleableProperty;
  59 import javafx.scene.AccessibleAction;
  60 import javafx.scene.AccessibleAttribute;
  61 import javafx.scene.input.Clipboard;
  62 import javafx.scene.input.ClipboardContent;
  63 import javafx.scene.text.Font;
  64 
  65 import java.text.BreakIterator;
  66 import java.util.ArrayList;
  67 import java.util.Collections;
  68 import java.util.List;
  69 
  70 import com.sun.javafx.util.Utils;
  71 import com.sun.javafx.binding.ExpressionHelper;
  72 import com.sun.javafx.scene.NodeHelper;
  73 import javafx.util.StringConverter;
  74 
  75 /**
  76  * Abstract base class for text input controls.
  77  * @since JavaFX 2.0
  78  */
  79 @DefaultProperty(&quot;text&quot;)
  80 public abstract class TextInputControl extends Control {
  81     /**
  82      * Interface representing a text input&#39;s content. Since it is an ObservableStringValue,
  83      * you can also bind to, or observe the content.
  84      * @since JavaFX 2.0
  85      */
  86     protected interface Content extends ObservableStringValue {
  87         /**
  88          * Retrieves a subset of the content.
  89          *
  90          * @param start the start
  91          * @param end the end
  92          * @return a subset of the content
  93          */
  94         public String get(int start, int end);
  95 
  96         /**
  97          * Inserts a sequence of characters into the content.
  98          *
  99          * @param index the index
 100          * @param text the text string
 101          * @param notifyListeners the notify listener flag
 102          * @since JavaFX 2.1
 103          */
 104         public void insert(int index, String text, boolean notifyListeners);
 105 
 106         /**
 107          * Removes a sequence of characters from the content.
 108          *
 109          * @param start the start
 110          * @param end the end
 111          * @param notifyListeners the notify listener flag
 112          * @since JavaFX 2.1
 113          */
 114         public void delete(int start, int end, boolean notifyListeners);
 115 
 116         /**
 117          * Returns the number of characters represented by the content.
 118          * @return the number of characters
 119          */
 120         public int length();
 121     }
 122 
 123     private boolean blockSelectedTextUpdate;
 124 
 125     /***************************************************************************
 126      *                                                                         *
 127      * Constructors                                                            *
 128      *                                                                         *
 129      **************************************************************************/
 130 
 131     /**
 132      * Creates a new TextInputControl. The content is an immutable property and
 133      * must be specified (as non-null) at the time of construction.
 134      *
 135      * @param content a non-null implementation of Content.
 136      */
 137     protected TextInputControl(final Content content) {
 138         this.content = content;
 139 
 140         // Add a listener so that whenever the Content is changed, we notify
 141         // listeners of the text property that it is invalid.
 142         content.addListener(observable -&gt; {
 143             if (content.length() &gt; 0) {
 144                 text.textIsNull = false;
 145             }
 146             text.controlContentHasChanged();
 147         });
 148 
 149         // Bind the length to be based on the length of the text property
 150         length.bind(new IntegerBinding() {
 151             { bind(text); }
 152             @Override protected int computeValue() {
 153                 String txt = text.get();
 154                 return txt == null ? 0 : txt.length();
 155             }
 156         });
 157 
 158         // Bind the selected text to be based on the selection and text properties
 159         selection.addListener((ob, o, n) -&gt; updateSelectedText());
 160         text.addListener((ob, o, n) -&gt; updateSelectedText());
 161 
 162         focusedProperty().addListener((ob, o, n) -&gt; {
 163             if (n) {
 164                 if (getTextFormatter() != null) {
 165                     updateText(getTextFormatter());
 166                 }
 167             } else {
 168                 commitValue();
 169             }
 170         });
 171 
 172         // Specify the default style class
 173         getStyleClass().add(&quot;text-input&quot;);
 174     }
 175 
 176     private void updateSelectedText() {
 177         if (!blockSelectedTextUpdate) {
 178             String txt = text.get();
 179             IndexRange sel = selection.get();
 180             if (txt == null || sel == null) {
 181                 selectedText.set(&quot;&quot;);
 182             } else {
 183                 int start = sel.getStart();
 184                 int end = sel.getEnd();
 185                 int length = txt.length();
 186                 if (end &gt; start + length) end = length;
 187                 if (start &gt; length-1) start = end = 0;
 188                 selectedText.set(txt.substring(start, end));
 189             }
 190         }
 191     }
 192 
 193     /***************************************************************************
 194      *                                                                         *
 195      * Properties                                                              *
 196      *                                                                         *
 197      **************************************************************************/
 198 
 199     /**
 200      * The default font to use for text in the TextInputControl. If the TextInputControl&#39;s text is
 201      * rich text then this font may or may not be used depending on the font
 202      * information embedded in the rich text, but in any case where a default
 203      * font is required, this font will be used.
 204      * @return the font property
 205      * @since JavaFX 8.0
 206      */
 207     public final ObjectProperty&lt;Font&gt; fontProperty() {
 208         if (font == null) {
 209             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 210 
 211 
 212                 private boolean fontSetByCss = false;
 213 
 214                 @Override
 215                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 216 
 217                     //
 218                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 219                     //
 220                     try {
 221                         // super.applyStyle calls set which might throw if value is bound.
 222                         // Have to make sure fontSetByCss is reset.
 223                         fontSetByCss = true;
 224                         super.applyStyle(newOrigin, value);
 225                     } catch(Exception e) {
 226                         throw e;
 227                     } finally {
 228                         fontSetByCss = false;
 229                     }
 230 
 231                 }
 232 
 233 
 234                 @Override
 235                 public void set(Font value) {
 236                     final Font oldValue = get();
 237                     if (value == null ? oldValue == null : value.equals(oldValue)) {
 238                         return;
 239                     }
 240                     super.set(value);
 241                 }
 242 
 243                 @Override
 244                 protected void invalidated() {
 245                     // RT-20727 - if font is changed by calling setFont, then
 246                     // css might need to be reapplied since font size affects
 247                     // calculated values for styles with relative values
 248                     if(fontSetByCss == false) {
 249                         NodeHelper.reapplyCSS(TextInputControl.this);
 250                     }
 251                 }
 252 
 253                 @Override
 254                 public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
 255                     return StyleableProperties.FONT;
 256                 }
 257 
 258                 @Override
 259                 public Object getBean() {
 260                     return TextInputControl.this;
 261                 }
 262 
 263                 @Override
 264                 public String getName() {
 265                     return &quot;font&quot;;
 266                 }
 267             };
 268         }
 269         return font;
 270     }
 271 
 272     private ObjectProperty&lt;Font&gt; font;
 273     public final void setFont(Font value) { fontProperty().setValue(value); }
 274     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 275 
 276     /**
 277      * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
 278      * prompt text is displayed.
 279      *
 280      * @defaultValue An empty String
 281      * @since JavaFX 2.2
 282      */
 283     private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
 284         @Override protected void invalidated() {
 285             // Strip out newlines
 286             String txt = get();
 287             if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
 288                 txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
 289                 set(txt);
 290             }
 291         }
 292     };
 293     public final StringProperty promptTextProperty() { return promptText; }
 294     public final String getPromptText() { return promptText.get(); }
 295     public final void setPromptText(String value) { promptText.set(value); }
 296 
 297 
 298     /**
 299      * The property contains currently attached {@link TextFormatter}.
 300      * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
 301      *
 302      * @defaultValue null
 303      * @since JavaFX 8u40
 304      */
 305     private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {
 306 
 307         private TextFormatter&lt;?&gt; oldFormatter = null;
 308 
 309         @Override
 310         public Object getBean() {
 311             return TextInputControl.this;
 312         }
 313 
 314         @Override
 315         public String getName() {
 316             return &quot;textFormatter&quot;;
 317         }
 318 
 319         @Override
 320         protected void invalidated() {
 321             final TextFormatter&lt;?&gt; formatter = get();
 322             try {
 323                 if (formatter != null) {
 324                     try {
 325                         formatter.bindToControl(f -&gt; updateText(f));
 326                     } catch (IllegalStateException e) {
 327                         if (isBound()) {
 328                             unbind();
 329                         }
 330                         set(null);
 331                         throw e;
 332                     }
 333                     if (!isFocused()) {
 334                         updateText(get());
 335                     }
 336                 }
 337 
 338                 if (oldFormatter != null) {
 339                     oldFormatter.unbindFromControl();
 340                 }
 341             } finally {
 342                 oldFormatter = formatter;
 343             }
 344         }
 345     };
 346     public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
 347     public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
 348     public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }
 349 
 350     private final Content content;
 351     /**
 352      * Returns the text input&#39;s content model.
 353      * @return the text input&#39;s content model
 354      */
 355     protected final Content getContent() {
 356         return content;
 357     }
 358 
 359     /**
 360      * The textual content of this TextInputControl.
 361      */
 362     private TextProperty text = new TextProperty();
 363     public final String getText() { return text.get(); }
 364     public final void setText(String value) { text.set(value); }
 365     public final StringProperty textProperty() { return text; }
 366 
 367     /**
 368      * The number of characters in the text input.
 369      */
 370     private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
 371     public final int getLength() { return length.get(); }
 372     public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }
 373 
 374     /**
 375      * Indicates whether this TextInputControl can be edited by the user.
 376      */
 377     private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
 378         @Override protected void invalidated() {
 379             pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
 380         }
 381     };
 382     public final boolean isEditable() { return editable.getValue(); }
 383     public final void setEditable(boolean value) { editable.setValue(value); }
 384     public final BooleanProperty editableProperty() { return editable; }
 385 
 386     /**
 387      * The current selection.
 388      */
 389     private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
 390     public final IndexRange getSelection() { return selection.getValue(); }
 391     public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }
 392 
 393     /**
 394      * Defines the characters in the TextInputControl which are selected
 395      */
 396     private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
 397     public final String getSelectedText() { return selectedText.get(); }
 398     public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }
 399 
 400     /**
 401      * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
 402      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 403      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 404      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 405      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 406      * the anchor might represent the lower or upper bound of the selection.
 407      */
 408     private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
 409     public final int getAnchor() { return anchor.get(); }
 410     public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }
 411 
 412     /**
 413      * The current position of the caret within the text.
 414      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 415      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 416      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 417      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 418      * the caretPosition might represent the lower or upper bound of the selection.
 419      */
 420     private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
 421     public final int getCaretPosition() { return caretPosition.get(); }
 422     public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }
 423 
 424     private UndoRedoChange undoChangeHead = new UndoRedoChange();
 425     private UndoRedoChange undoChange = undoChangeHead;
 426     private boolean createNewUndoRecord = false;
 427 
 428     /**
 429      * The property describes if it&#39;s currently possible to undo the latest change of the content that was done.
 430      * @defaultValue false
 431      * @since JavaFX 8u40
 432      */
 433     private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
 434     public final boolean isUndoable() { return undoable.get(); }
 435     public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }
 436 
 437 
 438     /**
 439      * The property describes if it&#39;s currently possible to redo the latest change of the content that was undone.
 440      * @defaultValue false
 441      * @since JavaFX 8u40
 442      */
 443     private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
 444     public final boolean isRedoable() { return redoable.get(); }
 445     public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }
 446 
 447     /***************************************************************************
 448      *                                                                         *
 449      * Methods                                                                 *
 450      *                                                                         *
 451      **************************************************************************/
 452 
 453     /**
 454      * Returns a subset of the text input&#39;s content.
 455      *
 456      * @param start must be a value between 0 and end - 1.
 457      * @param end must be less than or equal to the length
 458      * @return the subset of the text input&#39;s content
 459      */
 460     public String getText(int start, int end) {
 461         if (start &gt; end) {
 462             throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
 463         }
 464 
 465         if (start &lt; 0
 466             || end &gt; getLength()) {
 467             throw new IndexOutOfBoundsException();
 468         }
 469 
 470         return getContent().get(start, end);
 471     }
 472 
 473     /**
 474      * Appends a sequence of characters to the content.
 475      *
 476      * @param text a non null String
 477      */
 478     public void appendText(String text) {
 479         insertText(getLength(), text);
 480     }
 481 
 482     /**
 483      * Inserts a sequence of characters into the content.
 484      *
 485      * @param index The location to insert the text.
 486      * @param text The text to insert.
 487      */
 488     public void insertText(int index, String text) {
 489         replaceText(index, index, text);
 490     }
 491 
 492     /**
 493      * Removes a range of characters from the content.
 494      *
 495      * @param range The range of text to delete. The range object must not be null.
 496      *
 497      * @see #deleteText(int, int)
 498      */
 499     public void deleteText(IndexRange range) {
 500         replaceText(range, &quot;&quot;);
 501     }
 502 
 503     /**
 504      * Removes a range of characters from the content.
 505      *
 506      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 507      * @param end The ending index in the range, exclusive. This is one-past the last character to
 508      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 509      *            and &amp;lt;= the length of the text.
 510      */
 511     public void deleteText(int start, int end) {
 512         replaceText(start, end, &quot;&quot;);
 513     }
 514 
 515     /**
 516      * Replaces a range of characters with the given text.
 517      *
 518      * @param range The range of text to replace. The range object must not be null.
 519      * @param text The text that is to replace the range. This must not be null.
 520      *
 521      * @see #replaceText(int, int, String)
 522      */
 523     public void replaceText(IndexRange range, String text) {
 524         final int start = range.getStart();
 525         final int end = start + range.getLength();
 526         replaceText(start, end, text);
 527     }
 528 
 529     /**
 530      * Replaces a range of characters with the given text.
 531      *
 532      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 533      * @param end The ending index in the range, exclusive. This is one-past the last character to
 534      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 535      *            and &amp;lt;= the length of the text.
 536      * @param text The text that is to replace the range. This must not be null.
 537      */
 538     public void replaceText(final int start, final int end, final String text) {
 539         if (start &gt; end) {
 540             throw new IllegalArgumentException();
 541         }
 542 
 543         if (text == null) {
 544             throw new NullPointerException();
 545         }
 546 
 547         if (start &lt; 0
 548             || end &gt; getLength()) {
 549             throw new IndexOutOfBoundsException();
 550         }
 551 
 552         if (!this.text.isBound()) {
 553             final int oldLength = getLength();
 554             TextFormatter&lt;?&gt; formatter = getTextFormatter();
 555             TextFormatter.Change change;
 556             if (formatter != null &amp;&amp; formatter.getFilter() != null) {
 557                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
 558                 change = formatter.getFilter().apply(change);
 559                 if (change == null) {
 560                     return;
 561                 }
 562             } else {
 563                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, filterInput(text));
 564             }
 565 
 566             // Update the content
 567             updateContent(change, oldLength == 0);
 568 
 569         }
 570     }
 571 
 572     private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
 573         final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
 574         String oldText = getText(change.start, change.end);
 575         int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
 576         String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
 577         if (newText.equals(oldText)) {
 578             // Undo record not required as there is no change in the text.
 579             return;
 580         }
 581 
 582         /*
 583          * A new undo record is created, if
 584          * 1. createNewUndoRecord is true, currently it is set to true for paste operation
 585          * 2. Text is selected and a character is typed
 586          * 3. This is the first operation to be added to undo record
 587          * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
 588          * 5. Space character is typed
 589          * 6. 2500 milliseconds are elapsed since the undo record was created
 590          * 7. Cursor position is changed and a character is typed
 591          * 8. A range of text is replaced programmatically using replaceText()
 592          * Otherwise, the last undo record is updated or discarded.
 593          */
 594 
 595         int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
 596         boolean isNewSpaceChar = false;
 597         if (newText.equals(&quot; &quot;)) {
 598             if (!UndoRedoChange.isSpaceCharSequence()) {
 599                 isNewSpaceChar = true;
 600                 UndoRedoChange.setSpaceCharSequence(true);
 601             }
 602         } else {
 603             UndoRedoChange.setSpaceCharSequence(false);
 604         }
 605         if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
 606                 isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
 607                 (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
 608             undoChange = undoChange.add(change.start, oldText, newText);
 609         } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
 610             // I know I am deleting, and am located at the end of the range of the current undo record
 611             if (undoChange.newText.length() &gt; 0) {
 612                 undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
 613                 if (undoChange.newText.isEmpty()) {
 614                     // throw away this undo change record
 615                     undoChange = undoChange.discard();
 616                 }
 617             } else {
 618                 if (change.start == endOfUndoChange) {
 619                     undoChange.oldText += oldText;
 620                 } else { // end == endOfUndoChange
 621                     undoChange.oldText = oldText + undoChange.oldText;
 622                     undoChange.start--;
 623                 }
 624             }
 625         } else {
 626             // I know I am adding, and am located at the end of the range of the current undo record
 627             undoChange.newText += newText;
 628         }
 629         updateUndoRedoState();
 630     }
 631 
 632     /**
 633      * Transfers the currently selected range in the text to the clipboard,
 634      * removing the current selection.
 635      */
 636     public void cut() {
 637         copy();
 638         IndexRange selection = getSelection();
 639         deleteText(selection.getStart(), selection.getEnd());
 640     }
 641 
 642     /**
 643      * Transfers the currently selected range in the text to the clipboard,
 644      * leaving the current selection.
 645      */
 646      public void copy() {
 647         final String selectedText = getSelectedText();
 648         if (selectedText.length() &gt; 0) {
 649             final ClipboardContent content = new ClipboardContent();
 650             content.putString(selectedText);
 651             Clipboard.getSystemClipboard().setContent(content);
 652         }
 653     }
 654 
 655     /**
 656      * Transfers the contents in the clipboard into this text,
 657      * replacing the current selection.  If there is no selection, the contents
 658      * in the clipboard is inserted at the current caret position.
 659      */
 660     public void paste() {
 661         final Clipboard clipboard = Clipboard.getSystemClipboard();
 662         if (clipboard.hasString()) {
 663             final String text = clipboard.getString();
 664             if (text != null) {
 665                 createNewUndoRecord = true;
 666                 try {
 667                     replaceSelection(text);
 668                 } finally {
 669                     createNewUndoRecord = false;
 670                 }
 671             }
 672         }
 673     }
 674 
 675     /**
 676      * Moves the selection backward one char in the text. This may have the
 677      * effect of deselecting, depending on the location of the anchor relative
 678      * to the caretPosition. This function effectively just moves the caretPosition.
 679      */
 680     public void selectBackward() {
 681         if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
 682             // because the anchor stays put, by moving the caret to the left
 683             // we ensure that a selection is registered and that it is correct
 684             if (charIterator == null) {
 685                 charIterator = BreakIterator.getCharacterInstance();
 686             }
 687             charIterator.setText(getText());
 688             selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
 689         }
 690     }
 691 
 692     /**
 693      * Moves the selection forward one char in the text. This may have the
 694      * effect of deselecting, depending on the location of the anchor relative
 695      * to the caretPosition. This function effectively just moves the caret forward.
 696      */
 697     public void selectForward() {
 698         final int textLength = getLength();
 699         if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
 700             if (charIterator == null) {
 701                 charIterator = BreakIterator.getCharacterInstance();
 702             }
 703             charIterator.setText(getText());
 704             selectRange(getAnchor(), charIterator.following(getCaretPosition()));
 705         }
 706     }
 707 
 708     /**
 709      * The break iterator instances for navigation over words and complex characters.
 710      */
 711     private BreakIterator charIterator;
 712     private BreakIterator wordIterator;
 713 
 714     /**
 715      * Moves the caret to the beginning of previous word. This function
 716      * also has the effect of clearing the selection.
 717      */
 718     public void previousWord() {
 719         previousWord(false);
 720     }
 721 
 722     /**
 723      * Moves the caret to the beginning of next word. This function
 724      * also has the effect of clearing the selection.
 725      */
 726     public void nextWord() {
 727         nextWord(false);
 728     }
 729 
 730     /**
 731      * Moves the caret to the end of the next word. This function
 732      * also has the effect of clearing the selection.
 733      */
 734     public void endOfNextWord() {
 735         endOfNextWord(false);
 736     }
 737 
 738     /**
 739      * Moves the caret to the beginning of previous word. This does not cause
 740      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 741      * moved to the beginning of previous word.
 742      */
 743     public void selectPreviousWord() {
 744         previousWord(true);
 745     }
 746 
 747     /**
 748      * Moves the caret to the beginning of next word. This does not cause
 749      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 750      * moved to the beginning of next word.
 751      */
 752     public void selectNextWord() {
 753         nextWord(true);
 754     }
 755 
 756     /**
 757      * Moves the caret to the end of the next word. This does not cause
 758      * the selection to be cleared.
 759      */
 760     public void selectEndOfNextWord() {
 761         endOfNextWord(true);
 762     }
 763 
 764     private void previousWord(boolean select) {
 765         final int textLength = getLength();
 766         final String text = getText();
 767         if (textLength &lt;= 0) {
 768             return;
 769         }
 770 
 771         if (wordIterator == null) {
 772             wordIterator = BreakIterator.getWordInstance();
 773         }
 774         wordIterator.setText(text);
 775 
 776         int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));
 777 
 778         // Skip the non-word region, then move/select to the beginning of the word.
 779         while (pos != BreakIterator.DONE &amp;&amp;
 780                !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
 781             pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
 782         }
 783 
 784         // move/select
 785         selectRange(select ? getAnchor() : pos, pos);
 786     }
 787 
 788     private void nextWord(boolean select) {
 789         final int textLength = getLength();
 790         final String text = getText();
 791         if (textLength &lt;= 0) {
 792             return;
 793         }
 794 
 795         if (wordIterator == null) {
 796             wordIterator = BreakIterator.getWordInstance();
 797         }
 798         wordIterator.setText(text);
 799 
 800         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
 801         int current = wordIterator.next();
 802 
 803         // Skip whitespace characters to the beginning of next word, but
 804         // stop at newline. Then move the caret or select a range.
 805         while (current != BreakIterator.DONE) {
 806             for (int p=last; p&lt;=current; p++) {
 807                 char ch = text.charAt(Utils.clamp(0, p, textLength-1));
 808                 // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
 809                 // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
 810                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39;) {
 811                     if (select) {
 812                         selectRange(getAnchor(), p);
 813                     } else {
 814                         selectRange(p, p);
 815                     }
 816                     return;
 817                 }
 818             }
 819             last = current;
 820             current = wordIterator.next();
 821         }
 822 
 823         // move/select to the end
 824         if (select) {
 825             selectRange(getAnchor(), textLength);
 826         } else {
 827             end();
 828         }
 829     }
 830 
 831     private void endOfNextWord(boolean select) {
 832         final int textLength = getLength();
 833         final String text = getText();
 834         if (textLength &lt;= 0) {
 835             return;
 836         }
 837 
 838         if (wordIterator == null) {
 839             wordIterator = BreakIterator.getWordInstance();
 840         }
 841         wordIterator.setText(text);
 842 
 843         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
 844         int current = wordIterator.next();
 845 
 846         // skip the non-word region, then move/select to the end of the word.
 847         while (current != BreakIterator.DONE) {
 848             for (int p=last; p&lt;=current; p++) {
 849                 if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
 850                     if (select) {
 851                         selectRange(getAnchor(), p);
 852                     } else {
 853                         selectRange(p, p);
 854                     }
 855                     return;
 856                 }
 857             }
 858             last = current;
 859             current = wordIterator.next();
 860         }
 861 
 862         // move/select to the end
 863         if (select) {
 864             selectRange(getAnchor(), textLength);
 865         } else {
 866             end();
 867         }
 868     }
 869 
 870     /**
 871      * Selects all text in the text input.
 872      */
 873     public void selectAll() {
 874         selectRange(0, getLength());
 875     }
 876 
 877     /**
 878      * Moves the caret to before the first char of the text. This function
 879      * also has the effect of clearing the selection.
 880      */
 881     public void home() {
 882         // user wants to go to start
 883         selectRange(0, 0);
 884     }
 885 
 886     /**
 887      * Moves the caret to after the last char of the text. This function
 888      * also has the effect of clearing the selection.
 889      */
 890     public void end() {
 891         // user wants to go to end
 892         final int textLength = getLength();
 893         if (textLength &gt; 0) {
 894             selectRange(textLength, textLength);
 895         }
 896     }
 897 
 898     /**
 899      * Moves the caret to before the first char of text. This does not cause
 900      * the selection to be cleared. Rather, the anchor stays put and the
 901      * caretPosition is moved to before the first char.
 902      */
 903     public void selectHome() {
 904         selectRange(getAnchor(), 0);
 905     }
 906 
 907     /**
 908      * Moves the caret to after the last char of text. This does not cause
 909      * the selection to be cleared. Rather, the anchor stays put and the
 910      * caretPosition is moved to after the last char.
 911      */
 912     public void selectEnd() {
 913         final int textLength = getLength();
 914         if (textLength &gt; 0) selectRange(getAnchor(), textLength);
 915     }
 916 
 917     /**
 918      * Deletes the character that precedes the current caret position from the
 919      * text if there is no selection, or deletes the selection if there is one.
 920      * This function returns true if the deletion succeeded, false otherwise.
 921      * @return true if the deletion succeeded, false otherwise
 922      */
 923     public boolean deletePreviousChar() {
 924         boolean failed = true;
 925         if (isEditable() &amp;&amp; !isDisabled()) {
 926             final String text = getText();
 927             final int dot = getCaretPosition();
 928             final int mark = getAnchor();
 929             if (dot != mark) {
 930                 // there is a selection of text to remove
 931                 replaceSelection(&quot;&quot;);
 932                 failed = false;
 933             } else if (dot &gt; 0) {
 934                 // The caret is not at the beginning, so remove some characters.
 935                 // Typically you&#39;d only be removing a single character, but
 936                 // in some cases you must remove two depending on the unicode
 937                 // characters
 938                 // Note: Do not use charIterator here, because we do want to
 939                 // break up clusters when deleting backwards.
 940                 int p = Character.offsetByCodePoints(text, dot, -1);
 941                 deleteText(p, dot);
 942                 failed = false;
 943             }
 944         }
 945         return !failed;
 946     }
 947 
 948     /**
 949      * Deletes the character that follows the current caret position from the
 950      * text if there is no selection, or deletes the selection if there is one.
 951      * This function returns true if the deletion succeeded, false otherwise.
 952      * @return true if the deletion succeeded, false otherwise
 953      */
 954     public boolean deleteNextChar() {
 955         boolean failed = true;
 956         if (isEditable() &amp;&amp; !isDisabled()) {
 957             final int textLength = getLength();
 958             final String text = getText();
 959             final int dot = getCaretPosition();
 960             final int mark = getAnchor();
 961             if (dot != mark) {
 962                 // there is a selection of text to remove
 963                 replaceSelection(&quot;&quot;);
 964                 failed = false;
 965             } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
 966                 // The caret is not at the end, so remove some characters.
 967                 // Typically you&#39;d only be removing a single character, but
 968                 // in some cases you must remove two depending on the unicode
 969                 // characters
 970                 if (charIterator == null) {
 971                     charIterator = BreakIterator.getCharacterInstance();
 972                 }
 973                 charIterator.setText(text);
 974                 int p = charIterator.following(dot);
 975                 deleteText(dot, p);
 976                 failed = false;
 977             }
 978         }
 979         return !failed;
 980     }
 981 
 982     /**
 983      * Moves the caret position forward. If there is no selection, then the
 984      * caret position is moved one character forward. If there is a selection,
 985      * then the caret position is moved to the end of the selection and
 986      * the selection cleared.
 987      */
 988     public void forward() {
 989         // user has moved caret to the right
 990         final int textLength = getLength();
 991         final int dot = getCaretPosition();
 992         final int mark = getAnchor();
 993         if (dot != mark) {
 994             int pos = Math.max(dot, mark);
 995             selectRange(pos, pos);
 996         } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
 997             if (charIterator == null) {
 998                 charIterator = BreakIterator.getCharacterInstance();
 999             }
1000             charIterator.setText(getText());
1001             int pos = charIterator.following(dot);
1002             selectRange(pos, pos);
1003         }
1004         deselect();
1005     }
1006 
1007     /**
1008      * Moves the caret position backward. If there is no selection, then the
1009      * caret position is moved one character backward. If there is a selection,
1010      * then the caret position is moved to the beginning of the selection and
1011      * the selection cleared.
1012      *
1013      * Note: This function is intended to be used by experts, primarily
1014      *       by those implementing new Skins or Behaviors. It is not common
1015      *       for developers or designers to access this function directly.
1016      */
1017     public void backward() {
1018         // user has moved caret to the left
1019         final int textLength = getLength();
1020         final int dot = getCaretPosition();
1021         final int mark = getAnchor();
1022         if (dot != mark) {
1023             int pos = Math.min(dot, mark);
1024             selectRange(pos, pos);
1025         } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
1026             if (charIterator == null) {
1027                 charIterator = BreakIterator.getCharacterInstance();
1028             }
1029             charIterator.setText(getText());
1030             int pos = charIterator.preceding(dot);
1031             selectRange(pos, pos);
1032         }
1033         deselect();
1034     }
1035 
1036     /**
1037      * Positions the caret to the position indicated by {@code pos}. This
1038      * function will also clear the selection.
1039      * @param pos the position
1040      */
1041     public void positionCaret(int pos) {
1042         final int p = Utils.clamp(0, pos, getLength());
1043         selectRange(p, p);
1044     }
1045 
1046     /**
1047      * Positions the caret to the position indicated by {@code pos} and extends
1048      * the selection, if there is one. If there is no selection, then a
1049      * selection is formed where the anchor is at the current caret position
1050      * and the caretPosition is moved to pos.
1051      * @param pos the position
1052      */
1053     public void selectPositionCaret(int pos) {
1054         selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
1055     }
1056 
1057     /**
1058      * Positions the anchor and caretPosition explicitly.
1059      * @param anchor the anchor
1060      * @param caretPosition the caretPosition
1061      */
1062     public void selectRange(int anchor, int caretPosition) {
1063         caretPosition = Utils.clamp(0, caretPosition, getLength());
1064         anchor = Utils.clamp(0, anchor, getLength());
1065 
1066         TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
1067         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1068         if (formatter != null &amp;&amp; formatter.getFilter() != null) {
1069             change = formatter.getFilter().apply(change);
1070             if (change == null) {
1071                 return;
1072             }
1073         }
1074 
1075         updateContent(change, false);
1076     }
1077 
1078     private void doSelectRange(int anchor, int caretPosition) {
1079         this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
1080         this.anchor.set(Utils.clamp(0, anchor, getLength()));
1081         this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
1082         notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1083     }
1084 
1085     /**
1086      * This function will extend the selection to include the specified pos.
1087      * This is different from selectPositionCaret in that it does not simply
1088      * move the caret. Rather, it will reposition the caret and anchor as necessary
1089      * to ensure that pos becomes the new caret and the far other end of the
1090      * selection becomes the anchor.
1091      * @param pos the position
1092      */
1093     public void extendSelection(int pos) {
1094         final int p = Utils.clamp(0, pos, getLength());
1095         final int dot = getCaretPosition();
1096         final int mark = getAnchor();
1097         int start = Math.min(dot, mark);
1098         int end = Math.max(dot, mark);
1099         if (p &lt; start) {
1100             selectRange(end, p);
1101         } else {
1102             selectRange(start, p);
1103         }
1104     }
1105 
1106     /**
1107      * Clears the text.
1108      */
1109     public void clear() {
1110         deselect();
1111         if (!text.isBound()) {
1112             setText(&quot;&quot;);
1113         }
1114     }
1115 
1116     /**
1117      * Clears the selection.
1118      */
1119     public void deselect() {
1120         // set the anchor equal to the caret position, which clears the selection
1121         // while also preserving the caret position
1122         selectRange(getCaretPosition(), getCaretPosition());
1123     }
1124 
1125     /**
1126      * Replaces the selection with the given replacement String. If there is
1127      * no selection, then the replacement text is simply inserted at the current
1128      * caret position. If there was a selection, then the selection is cleared
1129      * and the given replacement text inserted.
1130      * @param replacement the replacement string
1131      */
1132     public void replaceSelection(String replacement) {
1133         replaceText(getSelection(), replacement);
1134     }
1135 
1136     /**
1137      * If possible, undoes the last modification. If {@link #isUndoable()} returns
1138      * false, then calling this method has no effect.
1139      * @since JavaFX 8u40
1140      */
1141     public final void undo() {
1142         if (isUndoable()) {
1143             // Apply reverse change here
1144             final int start = undoChange.start;
1145             final String newText = undoChange.newText;
1146             final String oldText = undoChange.oldText;
1147 
1148             blockSelectedTextUpdate = true;
1149             try {
1150                 if (newText != null) {
1151                     getContent().delete(start, start + newText.length(), oldText.isEmpty());
1152                 }
1153 
1154                 if (oldText != null) {
1155                     getContent().insert(start, oldText, true);
1156                     doSelectRange(start, start + oldText.length());
1157                 } else {
1158                     doSelectRange(start, start + newText.length());
1159                 }
1160 
1161                 undoChange = undoChange.prev;
1162             } finally {
1163                 blockSelectedTextUpdate = false;
1164                 updateSelectedText();
1165             }
1166         }
1167         updateUndoRedoState();
1168     }
1169 
1170     /**
1171      * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
1172      * false, then calling this method has no effect.
1173      * @since JavaFX 8u40
1174      */
1175     public final void redo() {
1176         if (isRedoable()) {
1177             // Apply change here
1178             undoChange = undoChange.next;
1179             final int start = undoChange.start;
1180             final String newText = undoChange.newText;
1181             final String oldText = undoChange.oldText;
1182 
1183             blockSelectedTextUpdate = true;
1184             try {
1185                 if (oldText != null) {
1186                     getContent().delete(start, start + oldText.length(), newText.isEmpty());
1187                 }
1188 
1189                 if (newText != null) {
1190                     getContent().insert(start, newText, true);
1191                     doSelectRange(start + newText.length(), start + newText.length());
1192                 } else {
1193                     doSelectRange(start, start);
1194                 }
1195             } finally {
1196                 blockSelectedTextUpdate = false;
1197                 updateSelectedText();
1198             }
1199         }
1200         updateUndoRedoState();
1201         // else beep ?
1202     }
1203 
1204     // Used by TextArea, although there are probably other better ways of
1205     // doing this.
1206     void textUpdated() { }
1207 
1208     private void resetUndoRedoState() {
1209         undoChange = undoChangeHead;
1210         undoChange.next = null;
1211         updateUndoRedoState();
1212     }
1213 
1214     private void updateUndoRedoState() {
1215         undoable.set(undoChange != undoChangeHead);
1216         redoable.set(undoChange.next != null);
1217     }
1218 
1219     private boolean filterAndSet(String value) {
1220         // Send the new value through the textFormatter, if one exists.
1221         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1222         int length = content.length();
1223         if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
1224             TextFormatter.Change change = new TextFormatter.Change(
1225                     TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
1226             change = formatter.getFilter().apply(change);
1227             if (change == null) {
1228                 return false;
1229             }
1230             replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
1231         } else {
1232             replaceText(0, length, value, 0, 0);
1233         }
1234         return true;
1235     }
1236 
1237     /**
1238      * This is what is ultimately called by every code path that will update
1239      * the content (except for undo / redo). The input into this method has
1240      * already run through the textFormatter where appropriate.
1241      *
1242      * @param start            The start index into the existing text which
1243      *                         will be replaced by the new value
1244      * @param end              The end index into the existing text which will
1245      *                         be replaced by the new value. As with
1246      *                         String.replace this is a lastIndex+1 value
1247      * @param value            The new text value
1248      * @param anchor           The new selection anchor after the change is made
1249      * @param caretPosition    The new selection caretPosition after the change
1250      *                         is made.
1251      * @return The amount of adjustment made to the end / anchor / caretPosition to
1252      *         accommodate for subsequent filtering (such as the filtering of
1253      *         new lines by the TextField)
1254      */
1255     private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
1256         // RT-16566: Need to take into account stripping of chars into the
1257         // final anchor &amp; caret position
1258         blockSelectedTextUpdate = true;
1259         try {
1260             int length = getLength();
1261             int adjustmentAmount = 0;
1262             if (end != start) {
1263                 getContent().delete(start, end, value.isEmpty());
1264                 length -= (end - start);
1265             }
1266             if (value != null) {
1267                 getContent().insert(start, value, true);
1268                 adjustmentAmount = value.length() - (getLength() - length);
1269                 anchor -= adjustmentAmount;
1270                 caretPosition -= adjustmentAmount;
1271             }
1272             doSelectRange(anchor, caretPosition);
1273             return adjustmentAmount;
1274         } finally {
1275             blockSelectedTextUpdate = false;
1276             updateSelectedText();
1277         }
1278     }
1279 
1280     private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
1281         T value = formatter.getValue();
1282         StringConverter&lt;T&gt; converter = formatter.getValueConverter();
1283         if (converter != null) {
1284             String text = converter.toString(value);
1285             if (text == null) text = &quot;&quot;;
1286             replaceText(0, getLength(), text, text.length(), text.length());
1287         }
1288     }
1289 
1290     /**
1291      * Commit the current text and convert it to a value.
1292      * @since JavaFX 8u40
1293      */
1294     public final void commitValue() {
1295         if (getTextFormatter() != null) {
1296             getTextFormatter().updateValue(getText());
1297         }
1298     }
1299 
1300     /**
1301      * If the field is currently being edited, this call will set text to the last commited value.
1302      * @since JavaFX 8u40
1303      */
1304     public final void cancelEdit() {
1305         if (getTextFormatter() != null) {
1306             updateText(getTextFormatter());
1307         }
1308     }
1309 
1310     private FormatterAccessor accessor;
1311 
1312     private FormatterAccessor getFormatterAccessor() {
1313         if (accessor == null) {
1314             accessor = new TextInputControlFromatterAccessor();
1315         }
1316         return accessor;
1317     }
1318 
1319     String filterInput(String text) {
1320         // This method should be overridden by child classes.
1321         // It is overridden in TextField and TextArea as needed.
1322         return text;
1323     }
1324 
1325     /**
1326      * A little utility method for stripping out unwanted characters.
1327      *
1328      * @param txt
1329      * @param stripNewlines
1330      * @param stripTabs
1331      * @return The string after having the unwanted characters stripped out.
1332      */
1333     static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
1334         // Most of the time, when text is inserted, there are no illegal
1335         // characters. So we&#39;ll do a &quot;cheap&quot; check for illegal characters.
1336         // If we find one, we&#39;ll do a longer replace algorithm. In the
1337         // case of illegal characters, this may at worst be an O(2n) solution.
1338         // Strip out any characters that are outside the printed range
1339         if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
1340             StringBuilder s = new StringBuilder(txt.length());
1341             for (int i=0; i&lt;txt.length(); i++) {
1342                 final char c = txt.charAt(i);
1343                 if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
1344                     s.append(c);
1345                 }
1346             }
1347             txt = s.toString();
1348         }
1349         return txt;
1350     }
1351 
1352     static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
1353         for (int i=0; i&lt;txt.length(); i++) {
1354             final char c = txt.charAt(i);
1355             if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
1356         }
1357         return false;
1358     }
1359 
1360     private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
1361         if (c == 0x7F) return true;
1362         if (c == 0xA) return newlineIllegal;
1363         if (c == 0x9) return tabIllegal;
1364         if (c &lt; 0x20) return true;
1365         return false;
1366     }
1367 
1368     // It can be bound, in which case we will force it to be an eager
1369     // binding so that we update the content eagerly
1370     // It can be bidirectionally bound, which basically will just work
1371     // If somebody changes the content directly, it will be notified and
1372     // send an invalidation event.
1373     private class TextProperty extends StringProperty {
1374         // This is used only when the property is bound
1375         private ObservableValue&lt;? extends String&gt; observable = null;
1376         // Added to the observable when bound
1377         private InvalidationListener listener = null;
1378         // Used for event handling
1379         private ExpressionHelper&lt;String&gt; helper = null;
1380         // The developer my set the Text property to null. Although
1381         // the Content must be given an empty String, we must still
1382         // treat the value as though it were null, so that a subsequent
1383         // getText() will return null.
1384         private boolean textIsNull = false;
1385 
1386         @Override public String get() {
1387             // Since we force eager binding and content is always up to date,
1388             // we just need to get it from content and not through the binding
1389             return textIsNull ? null : content.get();
1390         }
1391 
1392         @Override public void set(String value) {
1393             if (isBound()) {
1394                 throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
1395             }
1396             doSet(value);
1397             markInvalid();
1398         }
1399 
1400         /**
1401          * Called whenever the content on the control has changed (as determined
1402          * by a listener on the content).
1403          */
1404         private void controlContentHasChanged() {
1405             markInvalid();
1406             notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
1407         }
1408 
1409         @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
1410             if (observable == null) {
1411                 throw new NullPointerException(&quot;Cannot bind to null&quot;);
1412             }
1413             if (!observable.equals(this.observable)) {
1414                 unbind();
1415                 this.observable = observable;
1416                 if (listener == null) {
1417                     listener = new Listener();
1418                 }
1419                 this.observable.addListener(listener);
1420                 markInvalid();
1421                 doSet(observable.getValue());
1422             }
1423         }
1424 
1425         @Override public void unbind() {
1426             if (observable != null) {
1427                 doSet(observable.getValue());
1428                 observable.removeListener(listener);
1429                 observable = null;
1430             }
1431         }
1432 
1433         @Override public boolean isBound() {
1434             return observable != null;
1435         }
1436 
1437         @Override public void addListener(InvalidationListener listener) {
1438             helper = ExpressionHelper.addListener(helper, this, listener);
1439         }
1440 
1441         @Override public void removeListener(InvalidationListener listener) {
1442             helper = ExpressionHelper.removeListener(helper, listener);
1443         }
1444 
1445         @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
1446             helper = ExpressionHelper.addListener(helper, this, listener);
1447         }
1448 
1449         @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
1450             helper = ExpressionHelper.removeListener(helper, listener);
1451         }
1452 
1453         @Override public Object getBean() {
1454             return TextInputControl.this;
1455         }
1456 
1457         @Override public String getName() {
1458             return &quot;text&quot;;
1459         }
1460 
1461         private void fireValueChangedEvent() {
1462             ExpressionHelper.fireValueChangedEvent(helper);
1463         }
1464 
1465         private void markInvalid() {
1466             fireValueChangedEvent();
1467         }
1468 
1469         /**
1470          * doSet is called whenever the setText() method was called directly
1471          * on the TextInputControl, or when the text property was bound,
1472          * unbound, or reacted to a binding invalidation. It is *not* called
1473          * when modifications to the content happened indirectly, such as
1474          * through the replaceText / replaceSelection methods.
1475          *
1476          * @param value The new value
1477          */
1478         private void doSet(String value) {
1479             // Guard against the null value.
1480             textIsNull = value == null;
1481             if (value == null) value = &quot;&quot;;
1482 
1483             if (!filterAndSet(value)) return;
1484 
1485             if (getTextFormatter() != null) {
1486                 getTextFormatter().updateValue(getText());
1487             }
1488 
1489             textUpdated();
1490 
1491             // If the programmer has directly manipulated the text property
1492             // or has it bound up, then we will clear out any modifications
1493             // from the undo manager as we must suppose that the control is
1494             // being reused, for example, between forms.
1495             resetUndoRedoState();
1496         }
1497 
1498         private class Listener implements InvalidationListener {
1499             @Override
1500             public void invalidated(Observable valueModel) {
1501                 // We now need to force it to be eagerly recomputed
1502                 // because we need to push these changes to the
1503                 // content model. Because changing the model ends
1504                 // up calling invalidate and markInvalid, the
1505                 // listeners will all be notified.
1506                 doSet(observable.getValue());
1507             }
1508         }
1509     }
1510 
1511     /**
1512      * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
1513      * records the old and new text, and the start index. It also has
1514      * the links to the previous and next Changes in the chain. There
1515      * are two special UndoRedoChange objects in this chain representing the
1516      * head and the tail so we can have beforeFirst and afterLast
1517      * behavior as necessary.
1518      */
1519     static class UndoRedoChange {
1520         static long prevRecordTime;
1521         static final long CHANGE_DURATION = 2500; // milliseconds
1522         static boolean spaceCharSequence = false;
1523         int start;
1524         String oldText;
1525         String newText;
1526         UndoRedoChange prev;
1527         UndoRedoChange next;
1528 
1529         UndoRedoChange() { }
1530 
1531         public UndoRedoChange add(int start, String oldText, String newText) {
1532             UndoRedoChange c = new UndoRedoChange();
1533             c.start = start;
1534             c.oldText = oldText;
1535             c.newText = newText;
1536             c.prev = this;
1537             next = c;
1538             prevRecordTime = System.currentTimeMillis();
1539             return c;
1540         }
1541 
1542         static boolean hasChangeDurationElapsed() {
1543             return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
1544         }
1545 
1546         static void setSpaceCharSequence(boolean value) {
1547             spaceCharSequence = value;
1548         }
1549         static boolean isSpaceCharSequence() {
1550             return spaceCharSequence;
1551         }
1552 
1553         public UndoRedoChange discard() {
1554             prev.next = next;
1555             return prev;
1556         }
1557 
1558         // Handy to use when debugging, just put it in undo or redo
1559         // method or replaceText to see what is happening to the undo
1560         // history as it occurs.
1561         void debugPrint() {
1562             UndoRedoChange c = this;
1563             System.out.print(&quot;[&quot;);
1564             while (c != null) {
1565                 System.out.print(c.toString());
1566                 if (c.next != null) System.out.print(&quot;, &quot;);
1567                 c = c.next;
1568             }
1569             System.out.println(&quot;]&quot;);
1570         }
1571 
1572         @Override public String toString() {
1573             if (oldText == null &amp;&amp; newText == null) {
1574                 return &quot;head&quot;;
1575             }
1576             if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1577                 return &quot;added &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1578             } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1579                 return &quot;replaced &#39;&quot; + oldText + &quot;&#39; with &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1580             } else {
1581                 return &quot;deleted &#39;&quot; + oldText + &quot;&#39; at index &quot; + start;
1582             }
1583         }
1584     }
1585 
1586     /***************************************************************************
1587      *                                                                         *
1588      * Stylesheet Handling                                                     *
1589      *                                                                         *
1590      **************************************************************************/
1591 
1592 
1593     private static final PseudoClass PSEUDO_CLASS_READONLY
1594             = PseudoClass.getPseudoClass(&quot;readonly&quot;);
1595 
1596     private static class StyleableProperties {
1597         private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
1598             new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1599 
1600             @Override
1601             public boolean isSettable(TextInputControl n) {
1602                 return n.font == null || !n.font.isBound();
1603             }
1604 
1605             @Override
1606             public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
1607                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
1608             }
1609         };
1610 
1611         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1612         static {
1613             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1614                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1615             styleables.add(FONT);
1616             STYLEABLES = Collections.unmodifiableList(styleables);
1617         }
1618     }
1619 
1620     /**
1621      * @return The CssMetaData associated with this class, which may include the
1622      * CssMetaData of its superclasses.
1623      * @since JavaFX 8.0
1624      */
1625     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1626         return StyleableProperties.STYLEABLES;
1627     }
1628 
1629     /**
1630      * {@inheritDoc}
1631      * @since JavaFX 8.0
1632      */
1633     @Override
1634     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1635         return getClassCssMetaData();
1636     }
1637 
1638 
1639     /***************************************************************************
1640      *                                                                         *
1641      * Accessibility handling                                                  *
1642      *                                                                         *
1643      **************************************************************************/
1644 
1645     /** {@inheritDoc} */
1646     @Override
1647     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1648         switch (attribute) {
1649             case TEXT: {
1650                 String accText = getAccessibleText();
1651                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1652 
1653                 String text = getText();
1654                 if (text == null || text.isEmpty()) {
1655                     text = getPromptText();
1656                 }
1657                 return text;
1658             }
1659             case EDITABLE: return isEditable();
1660             case SELECTION_START: return getSelection().getStart();
1661             case SELECTION_END: return getSelection().getEnd();
1662             case CARET_OFFSET: return getCaretPosition();
1663             case FONT: return getFont();
1664             default: return super.queryAccessibleAttribute(attribute, parameters);
1665         }
1666     }
1667 
1668     /** {@inheritDoc} */
1669     @Override
1670     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1671         switch (action) {
1672             case SET_TEXT: {
1673                 String value = (String) parameters[0];
1674                 if (value != null) setText(value);
1675                 break;
1676             }
1677             case SET_TEXT_SELECTION: {
1678                 Integer start = (Integer) parameters[0];
1679                 Integer end = (Integer) parameters[1];
1680                 if (start != null &amp;&amp; end != null) {
1681                     selectRange(start,  end);
1682                 }
1683                 break;
1684             }
1685             default: super.executeAccessibleAction(action, parameters);
1686         }
1687     }
1688 
1689     private class TextInputControlFromatterAccessor implements FormatterAccessor {
1690         @Override
1691         public int getTextLength() {
1692             return TextInputControl.this.getLength();
1693         }
1694 
1695         @Override
1696         public String getText(int begin, int end) {
1697             return TextInputControl.this.getText(begin, end);
1698         }
1699 
1700         @Override
1701         public int getCaret() {
1702             return TextInputControl.this.getCaretPosition();
1703         }
1704 
1705         @Override
1706         public int getAnchor() {
1707             return TextInputControl.this.getAnchor();
1708         }
1709     }
1710 
1711 }
    </pre>
  </body>
</html>
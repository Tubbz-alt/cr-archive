<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TextInputControl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import com.sun.javafx.scene.control.FormatterAccessor;
  29 import javafx.beans.DefaultProperty;
  30 import javafx.beans.InvalidationListener;
  31 import javafx.beans.Observable;
  32 import javafx.beans.binding.IntegerBinding;
  33 import javafx.beans.binding.StringBinding;
  34 import javafx.beans.property.BooleanProperty;
  35 import javafx.beans.property.ObjectProperty;
  36 import javafx.beans.property.ObjectPropertyBase;
  37 import javafx.beans.property.ReadOnlyBooleanProperty;
  38 import javafx.beans.property.ReadOnlyBooleanWrapper;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.ReadOnlyStringProperty;
  44 import javafx.beans.property.ReadOnlyStringWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleStringProperty;
  47 import javafx.beans.property.StringProperty;
  48 import javafx.beans.value.ChangeListener;
  49 import javafx.beans.value.ObservableStringValue;
  50 import javafx.beans.value.ObservableValue;
  51 import javafx.beans.value.WritableValue;
  52 import javafx.css.CssMetaData;
  53 import javafx.css.FontCssMetaData;
  54 import javafx.css.PseudoClass;
  55 import javafx.css.StyleOrigin;
  56 import javafx.css.Styleable;
  57 import javafx.css.StyleableObjectProperty;
  58 import javafx.css.StyleableProperty;
  59 import javafx.scene.AccessibleAction;
  60 import javafx.scene.AccessibleAttribute;
  61 import javafx.scene.input.Clipboard;
  62 import javafx.scene.input.ClipboardContent;
  63 import javafx.scene.text.Font;
  64 
  65 import java.text.BreakIterator;
  66 import java.util.ArrayList;
  67 import java.util.Collections;
  68 import java.util.List;
  69 
  70 import com.sun.javafx.util.Utils;
  71 import com.sun.javafx.binding.ExpressionHelper;
  72 import com.sun.javafx.scene.NodeHelper;
  73 import javafx.util.StringConverter;
  74 
  75 /**
  76  * Abstract base class for text input controls.
  77  * @since JavaFX 2.0
  78  */
  79 @DefaultProperty(&quot;text&quot;)
  80 public abstract class TextInputControl extends Control {
  81     /**
  82      * Interface representing a text input&#39;s content. Since it is an ObservableStringValue,
  83      * you can also bind to, or observe the content.
  84      * @since JavaFX 2.0
  85      */
  86     protected interface Content extends ObservableStringValue {
  87         /**
  88          * Retrieves a subset of the content.
  89          *
  90          * @param start the start
  91          * @param end the end
  92          * @return a subset of the content
  93          */
  94         public String get(int start, int end);
  95 
  96         /**
  97          * Inserts a sequence of characters into the content.
  98          *
  99          * @param index the index
 100          * @param text the text string
 101          * @param notifyListeners the notify listener flag
 102          * @since JavaFX 2.1
 103          */
 104         public void insert(int index, String text, boolean notifyListeners);
 105 
 106         /**
 107          * Removes a sequence of characters from the content.
 108          *
 109          * @param start the start
 110          * @param end the end
 111          * @param notifyListeners the notify listener flag
 112          * @since JavaFX 2.1
 113          */
 114         public void delete(int start, int end, boolean notifyListeners);
 115 
 116         /**
 117          * Returns the number of characters represented by the content.
 118          * @return the number of characters
 119          */
 120         public int length();
 121     }
 122 
<a name="1" id="anc1"></a><span class="line-added"> 123     private boolean blockSelectedTextUpdate;</span>
<span class="line-added"> 124 </span>
 125     /***************************************************************************
 126      *                                                                         *
 127      * Constructors                                                            *
 128      *                                                                         *
 129      **************************************************************************/
 130 
 131     /**
 132      * Creates a new TextInputControl. The content is an immutable property and
 133      * must be specified (as non-null) at the time of construction.
 134      *
 135      * @param content a non-null implementation of Content.
 136      */
 137     protected TextInputControl(final Content content) {
 138         this.content = content;
 139 
 140         // Add a listener so that whenever the Content is changed, we notify
 141         // listeners of the text property that it is invalid.
 142         content.addListener(observable -&gt; {
 143             if (content.length() &gt; 0) {
 144                 text.textIsNull = false;
 145             }
 146             text.controlContentHasChanged();
 147         });
 148 
 149         // Bind the length to be based on the length of the text property
 150         length.bind(new IntegerBinding() {
 151             { bind(text); }
 152             @Override protected int computeValue() {
 153                 String txt = text.get();
 154                 return txt == null ? 0 : txt.length();
 155             }
 156         });
 157 
 158         // Bind the selected text to be based on the selection and text properties
<a name="2" id="anc2"></a><span class="line-modified"> 159         selection.addListener((ob, o, n) -&gt; updateSelectedText());</span>
<span class="line-modified"> 160         text.addListener((ob, o, n) -&gt; updateSelectedText());</span>













 161 
 162         focusedProperty().addListener((ob, o, n) -&gt; {
 163             if (n) {
 164                 if (getTextFormatter() != null) {
 165                     updateText(getTextFormatter());
 166                 }
 167             } else {
 168                 commitValue();
 169             }
 170         });
 171 
 172         // Specify the default style class
 173         getStyleClass().add(&quot;text-input&quot;);
 174     }
 175 
<a name="3" id="anc3"></a><span class="line-added"> 176     private void updateSelectedText() {</span>
<span class="line-added"> 177         if (!blockSelectedTextUpdate) {</span>
<span class="line-added"> 178             String txt = text.get();</span>
<span class="line-added"> 179             IndexRange sel = selection.get();</span>
<span class="line-added"> 180             if (txt == null || sel == null) {</span>
<span class="line-added"> 181                 selectedText.set(&quot;&quot;);</span>
<span class="line-added"> 182             } else {</span>
<span class="line-added"> 183                 int start = sel.getStart();</span>
<span class="line-added"> 184                 int end = sel.getEnd();</span>
<span class="line-added"> 185                 int length = txt.length();</span>
<span class="line-added"> 186                 if (end &gt; start + length) end = length;</span>
<span class="line-added"> 187                 if (start &gt; length-1) start = end = 0;</span>
<span class="line-added"> 188                 selectedText.set(txt.substring(start, end));</span>
<span class="line-added"> 189             }</span>
<span class="line-added"> 190         }</span>
<span class="line-added"> 191     }</span>
<span class="line-added"> 192 </span>
 193     /***************************************************************************
 194      *                                                                         *
 195      * Properties                                                              *
 196      *                                                                         *
 197      **************************************************************************/
 198 
 199     /**
 200      * The default font to use for text in the TextInputControl. If the TextInputControl&#39;s text is
 201      * rich text then this font may or may not be used depending on the font
 202      * information embedded in the rich text, but in any case where a default
 203      * font is required, this font will be used.
 204      * @return the font property
 205      * @since JavaFX 8.0
 206      */
 207     public final ObjectProperty&lt;Font&gt; fontProperty() {
 208         if (font == null) {
 209             font = new StyleableObjectProperty&lt;Font&gt;(Font.getDefault()) {
 210 
 211 
 212                 private boolean fontSetByCss = false;
 213 
 214                 @Override
 215                 public void applyStyle(StyleOrigin newOrigin, Font value) {
 216 
 217                     //
 218                     // RT-20727 - if CSS is setting the font, then make sure invalidate doesn&#39;t call NodeHelper.reapplyCSS
 219                     //
 220                     try {
 221                         // super.applyStyle calls set which might throw if value is bound.
 222                         // Have to make sure fontSetByCss is reset.
 223                         fontSetByCss = true;
 224                         super.applyStyle(newOrigin, value);
 225                     } catch(Exception e) {
 226                         throw e;
 227                     } finally {
 228                         fontSetByCss = false;
 229                     }
 230 
 231                 }
 232 
 233 
 234                 @Override
 235                 public void set(Font value) {
 236                     final Font oldValue = get();
 237                     if (value == null ? oldValue == null : value.equals(oldValue)) {
 238                         return;
 239                     }
 240                     super.set(value);
 241                 }
 242 
 243                 @Override
 244                 protected void invalidated() {
 245                     // RT-20727 - if font is changed by calling setFont, then
 246                     // css might need to be reapplied since font size affects
 247                     // calculated values for styles with relative values
 248                     if(fontSetByCss == false) {
 249                         NodeHelper.reapplyCSS(TextInputControl.this);
 250                     }
 251                 }
 252 
 253                 @Override
 254                 public CssMetaData&lt;TextInputControl,Font&gt; getCssMetaData() {
 255                     return StyleableProperties.FONT;
 256                 }
 257 
 258                 @Override
 259                 public Object getBean() {
 260                     return TextInputControl.this;
 261                 }
 262 
 263                 @Override
 264                 public String getName() {
 265                     return &quot;font&quot;;
 266                 }
 267             };
 268         }
 269         return font;
 270     }
 271 
 272     private ObjectProperty&lt;Font&gt; font;
 273     public final void setFont(Font value) { fontProperty().setValue(value); }
 274     public final Font getFont() { return font == null ? Font.getDefault() : font.getValue(); }
 275 
 276     /**
 277      * The prompt text to display in the {@code TextInputControl}. If set to null or an empty string, no
 278      * prompt text is displayed.
 279      *
 280      * @defaultValue An empty String
 281      * @since JavaFX 2.2
 282      */
 283     private StringProperty promptText = new SimpleStringProperty(this, &quot;promptText&quot;, &quot;&quot;) {
 284         @Override protected void invalidated() {
 285             // Strip out newlines
 286             String txt = get();
 287             if (txt != null &amp;&amp; txt.contains(&quot;\n&quot;)) {
 288                 txt = txt.replace(&quot;\n&quot;, &quot;&quot;);
 289                 set(txt);
 290             }
 291         }
 292     };
 293     public final StringProperty promptTextProperty() { return promptText; }
 294     public final String getPromptText() { return promptText.get(); }
 295     public final void setPromptText(String value) { promptText.set(value); }
 296 
 297 
 298     /**
 299      * The property contains currently attached {@link TextFormatter}.
 300      * Since the value is part of the {@code Formatter}, changing the TextFormatter will update the text based on the new textFormatter.
 301      *
 302      * @defaultValue null
 303      * @since JavaFX 8u40
 304      */
 305     private final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatter = new ObjectPropertyBase&lt;TextFormatter&lt;?&gt;&gt;() {
 306 
 307         private TextFormatter&lt;?&gt; oldFormatter = null;
 308 
 309         @Override
 310         public Object getBean() {
 311             return TextInputControl.this;
 312         }
 313 
 314         @Override
 315         public String getName() {
 316             return &quot;textFormatter&quot;;
 317         }
 318 
 319         @Override
 320         protected void invalidated() {
 321             final TextFormatter&lt;?&gt; formatter = get();
 322             try {
 323                 if (formatter != null) {
 324                     try {
 325                         formatter.bindToControl(f -&gt; updateText(f));
 326                     } catch (IllegalStateException e) {
 327                         if (isBound()) {
 328                             unbind();
 329                         }
 330                         set(null);
 331                         throw e;
 332                     }
 333                     if (!isFocused()) {
 334                         updateText(get());
 335                     }
 336                 }
 337 
 338                 if (oldFormatter != null) {
 339                     oldFormatter.unbindFromControl();
 340                 }
 341             } finally {
 342                 oldFormatter = formatter;
 343             }
 344         }
 345     };
 346     public final ObjectProperty&lt;TextFormatter&lt;?&gt;&gt; textFormatterProperty() { return textFormatter; }
 347     public final TextFormatter&lt;?&gt; getTextFormatter() { return textFormatter.get(); }
 348     public final void setTextFormatter(TextFormatter&lt;?&gt; value) { textFormatter.set(value); }
 349 
 350     private final Content content;
 351     /**
 352      * Returns the text input&#39;s content model.
 353      * @return the text input&#39;s content model
 354      */
 355     protected final Content getContent() {
 356         return content;
 357     }
 358 
 359     /**
 360      * The textual content of this TextInputControl.
 361      */
 362     private TextProperty text = new TextProperty();
 363     public final String getText() { return text.get(); }
 364     public final void setText(String value) { text.set(value); }
 365     public final StringProperty textProperty() { return text; }
 366 
 367     /**
 368      * The number of characters in the text input.
 369      */
 370     private ReadOnlyIntegerWrapper length = new ReadOnlyIntegerWrapper(this, &quot;length&quot;);
 371     public final int getLength() { return length.get(); }
 372     public final ReadOnlyIntegerProperty lengthProperty() { return length.getReadOnlyProperty(); }
 373 
 374     /**
 375      * Indicates whether this TextInputControl can be edited by the user.
 376      */
 377     private BooleanProperty editable = new SimpleBooleanProperty(this, &quot;editable&quot;, true) {
 378         @Override protected void invalidated() {
 379             pseudoClassStateChanged(PSEUDO_CLASS_READONLY, ! get());
 380         }
 381     };
 382     public final boolean isEditable() { return editable.getValue(); }
 383     public final void setEditable(boolean value) { editable.setValue(value); }
 384     public final BooleanProperty editableProperty() { return editable; }
 385 
 386     /**
 387      * The current selection.
 388      */
 389     private ReadOnlyObjectWrapper&lt;IndexRange&gt; selection = new ReadOnlyObjectWrapper&lt;IndexRange&gt;(this, &quot;selection&quot;, new IndexRange(0, 0));
 390     public final IndexRange getSelection() { return selection.getValue(); }
 391     public final ReadOnlyObjectProperty&lt;IndexRange&gt; selectionProperty() { return selection.getReadOnlyProperty(); }
 392 
 393     /**
 394      * Defines the characters in the TextInputControl which are selected
 395      */
 396     private ReadOnlyStringWrapper selectedText = new ReadOnlyStringWrapper(this, &quot;selectedText&quot;);
 397     public final String getSelectedText() { return selectedText.get(); }
 398     public final ReadOnlyStringProperty selectedTextProperty() { return selectedText.getReadOnlyProperty(); }
 399 
 400     /**
 401      * The &lt;code&gt;anchor&lt;/code&gt; of the text selection.
 402      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 403      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 404      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 405      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 406      * the anchor might represent the lower or upper bound of the selection.
 407      */
 408     private ReadOnlyIntegerWrapper anchor = new ReadOnlyIntegerWrapper(this, &quot;anchor&quot;, 0);
 409     public final int getAnchor() { return anchor.get(); }
 410     public final ReadOnlyIntegerProperty anchorProperty() { return anchor.getReadOnlyProperty(); }
 411 
 412     /**
 413      * The current position of the caret within the text.
 414      * The &lt;code&gt;anchor&lt;/code&gt; and &lt;code&gt;caretPosition&lt;/code&gt; make up the selection
 415      * range. Selection must always be specified in terms of begin &amp;lt;= end, but
 416      * &lt;code&gt;anchor&lt;/code&gt; may be less than, equal to, or greater than the
 417      * &lt;code&gt;caretPosition&lt;/code&gt;. Depending on how the user selects text,
 418      * the caretPosition might represent the lower or upper bound of the selection.
 419      */
 420     private ReadOnlyIntegerWrapper caretPosition = new ReadOnlyIntegerWrapper(this, &quot;caretPosition&quot;, 0);
 421     public final int getCaretPosition() { return caretPosition.get(); }
 422     public final ReadOnlyIntegerProperty caretPositionProperty() { return caretPosition.getReadOnlyProperty(); }
 423 
 424     private UndoRedoChange undoChangeHead = new UndoRedoChange();
 425     private UndoRedoChange undoChange = undoChangeHead;
 426     private boolean createNewUndoRecord = false;
 427 
 428     /**
 429      * The property describes if it&#39;s currently possible to undo the latest change of the content that was done.
 430      * @defaultValue false
 431      * @since JavaFX 8u40
 432      */
 433     private final ReadOnlyBooleanWrapper undoable = new ReadOnlyBooleanWrapper(this, &quot;undoable&quot;, false);
 434     public final boolean isUndoable() { return undoable.get(); }
 435     public final ReadOnlyBooleanProperty undoableProperty() { return undoable.getReadOnlyProperty(); }
 436 
 437 
 438     /**
 439      * The property describes if it&#39;s currently possible to redo the latest change of the content that was undone.
 440      * @defaultValue false
 441      * @since JavaFX 8u40
 442      */
 443     private final ReadOnlyBooleanWrapper redoable = new ReadOnlyBooleanWrapper(this, &quot;redoable&quot;, false);
 444     public final boolean isRedoable() { return redoable.get(); }
 445     public final ReadOnlyBooleanProperty redoableProperty() { return redoable.getReadOnlyProperty(); }
 446 
 447     /***************************************************************************
 448      *                                                                         *
 449      * Methods                                                                 *
 450      *                                                                         *
 451      **************************************************************************/
 452 
 453     /**
 454      * Returns a subset of the text input&#39;s content.
 455      *
 456      * @param start must be a value between 0 and end - 1.
 457      * @param end must be less than or equal to the length
 458      * @return the subset of the text input&#39;s content
 459      */
 460     public String getText(int start, int end) {
 461         if (start &gt; end) {
 462             throw new IllegalArgumentException(&quot;The start must be &lt;= the end&quot;);
 463         }
 464 
 465         if (start &lt; 0
 466             || end &gt; getLength()) {
 467             throw new IndexOutOfBoundsException();
 468         }
 469 
 470         return getContent().get(start, end);
 471     }
 472 
 473     /**
 474      * Appends a sequence of characters to the content.
 475      *
 476      * @param text a non null String
 477      */
 478     public void appendText(String text) {
 479         insertText(getLength(), text);
 480     }
 481 
 482     /**
 483      * Inserts a sequence of characters into the content.
 484      *
 485      * @param index The location to insert the text.
 486      * @param text The text to insert.
 487      */
 488     public void insertText(int index, String text) {
 489         replaceText(index, index, text);
 490     }
 491 
 492     /**
 493      * Removes a range of characters from the content.
 494      *
 495      * @param range The range of text to delete. The range object must not be null.
 496      *
 497      * @see #deleteText(int, int)
 498      */
 499     public void deleteText(IndexRange range) {
 500         replaceText(range, &quot;&quot;);
 501     }
 502 
 503     /**
 504      * Removes a range of characters from the content.
 505      *
 506      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 507      * @param end The ending index in the range, exclusive. This is one-past the last character to
 508      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 509      *            and &amp;lt;= the length of the text.
 510      */
 511     public void deleteText(int start, int end) {
 512         replaceText(start, end, &quot;&quot;);
 513     }
 514 
 515     /**
 516      * Replaces a range of characters with the given text.
 517      *
 518      * @param range The range of text to replace. The range object must not be null.
 519      * @param text The text that is to replace the range. This must not be null.
 520      *
 521      * @see #replaceText(int, int, String)
 522      */
 523     public void replaceText(IndexRange range, String text) {
 524         final int start = range.getStart();
 525         final int end = start + range.getLength();
 526         replaceText(start, end, text);
 527     }
 528 
 529     /**
 530      * Replaces a range of characters with the given text.
 531      *
 532      * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end.
 533      * @param end The ending index in the range, exclusive. This is one-past the last character to
 534      *            delete (consistent with the String manipulation methods). This must be &amp;gt; the start,
 535      *            and &amp;lt;= the length of the text.
 536      * @param text The text that is to replace the range. This must not be null.
 537      */
 538     public void replaceText(final int start, final int end, final String text) {
 539         if (start &gt; end) {
 540             throw new IllegalArgumentException();
 541         }
 542 
 543         if (text == null) {
 544             throw new NullPointerException();
 545         }
 546 
 547         if (start &lt; 0
 548             || end &gt; getLength()) {
 549             throw new IndexOutOfBoundsException();
 550         }
 551 
 552         if (!this.text.isBound()) {
 553             final int oldLength = getLength();
 554             TextFormatter&lt;?&gt; formatter = getTextFormatter();
 555             TextFormatter.Change change;
 556             if (formatter != null &amp;&amp; formatter.getFilter() != null) {
 557                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);
 558                 change = formatter.getFilter().apply(change);
 559                 if (change == null) {
 560                     return;
 561                 }
 562             } else {
 563                 change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, filterInput(text));
 564             }
 565 
 566             // Update the content
 567             updateContent(change, oldLength == 0);
 568 
 569         }
 570     }
 571 
 572     private void updateContent(TextFormatter.Change change, boolean forceNewUndoRecord) {
 573         final boolean nonEmptySelection = getSelection().getLength() &gt; 0;
 574         String oldText = getText(change.start, change.end);
 575         int adjustmentAmount = replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
 576         String newText = getText(change.start, change.start + change.text.length() - adjustmentAmount);
 577         if (newText.equals(oldText)) {
 578             // Undo record not required as there is no change in the text.
 579             return;
 580         }
 581 
 582         /*
 583          * A new undo record is created, if
 584          * 1. createNewUndoRecord is true, currently it is set to true for paste operation
 585          * 2. Text is selected and a character is typed
 586          * 3. This is the first operation to be added to undo record
 587          * 4. forceNewUndoRecord is true, currently it is set to true if there is no text present
 588          * 5. Space character is typed
 589          * 6. 2500 milliseconds are elapsed since the undo record was created
 590          * 7. Cursor position is changed and a character is typed
 591          * 8. A range of text is replaced programmatically using replaceText()
 592          * Otherwise, the last undo record is updated or discarded.
 593          */
 594 
 595         int endOfUndoChange = undoChange == undoChangeHead ? -1 : undoChange.start + undoChange.newText.length();
 596         boolean isNewSpaceChar = false;
 597         if (newText.equals(&quot; &quot;)) {
 598             if (!UndoRedoChange.isSpaceCharSequence()) {
 599                 isNewSpaceChar = true;
 600                 UndoRedoChange.setSpaceCharSequence(true);
 601             }
 602         } else {
 603             UndoRedoChange.setSpaceCharSequence(false);
 604         }
 605         if (createNewUndoRecord || nonEmptySelection || endOfUndoChange == -1 || forceNewUndoRecord ||
 606                 isNewSpaceChar || UndoRedoChange.hasChangeDurationElapsed() ||
 607                 (endOfUndoChange != change.start &amp;&amp; endOfUndoChange != change.end) || change.end - change.start &gt; 0) {
 608             undoChange = undoChange.add(change.start, oldText, newText);
 609         } else if (change.start != change.end &amp;&amp; change.text.isEmpty()) {
 610             // I know I am deleting, and am located at the end of the range of the current undo record
 611             if (undoChange.newText.length() &gt; 0) {
 612                 undoChange.newText = undoChange.newText.substring(0, change.start - undoChange.start);
 613                 if (undoChange.newText.isEmpty()) {
 614                     // throw away this undo change record
 615                     undoChange = undoChange.discard();
 616                 }
 617             } else {
 618                 if (change.start == endOfUndoChange) {
 619                     undoChange.oldText += oldText;
 620                 } else { // end == endOfUndoChange
 621                     undoChange.oldText = oldText + undoChange.oldText;
 622                     undoChange.start--;
 623                 }
 624             }
 625         } else {
 626             // I know I am adding, and am located at the end of the range of the current undo record
 627             undoChange.newText += newText;
 628         }
 629         updateUndoRedoState();
 630     }
 631 
 632     /**
 633      * Transfers the currently selected range in the text to the clipboard,
 634      * removing the current selection.
 635      */
 636     public void cut() {
 637         copy();
 638         IndexRange selection = getSelection();
 639         deleteText(selection.getStart(), selection.getEnd());
 640     }
 641 
 642     /**
 643      * Transfers the currently selected range in the text to the clipboard,
 644      * leaving the current selection.
 645      */
 646      public void copy() {
 647         final String selectedText = getSelectedText();
 648         if (selectedText.length() &gt; 0) {
 649             final ClipboardContent content = new ClipboardContent();
 650             content.putString(selectedText);
 651             Clipboard.getSystemClipboard().setContent(content);
 652         }
 653     }
 654 
 655     /**
 656      * Transfers the contents in the clipboard into this text,
 657      * replacing the current selection.  If there is no selection, the contents
 658      * in the clipboard is inserted at the current caret position.
 659      */
 660     public void paste() {
 661         final Clipboard clipboard = Clipboard.getSystemClipboard();
 662         if (clipboard.hasString()) {
 663             final String text = clipboard.getString();
 664             if (text != null) {
 665                 createNewUndoRecord = true;
 666                 try {
 667                     replaceSelection(text);
 668                 } finally {
 669                     createNewUndoRecord = false;
 670                 }
 671             }
 672         }
 673     }
 674 
 675     /**
 676      * Moves the selection backward one char in the text. This may have the
 677      * effect of deselecting, depending on the location of the anchor relative
 678      * to the caretPosition. This function effectively just moves the caretPosition.
 679      */
 680     public void selectBackward() {
 681         if (getCaretPosition() &gt; 0 &amp;&amp; getLength() &gt; 0) {
 682             // because the anchor stays put, by moving the caret to the left
 683             // we ensure that a selection is registered and that it is correct
 684             if (charIterator == null) {
 685                 charIterator = BreakIterator.getCharacterInstance();
 686             }
 687             charIterator.setText(getText());
 688             selectRange(getAnchor(), charIterator.preceding(getCaretPosition()));
 689         }
 690     }
 691 
 692     /**
 693      * Moves the selection forward one char in the text. This may have the
 694      * effect of deselecting, depending on the location of the anchor relative
 695      * to the caretPosition. This function effectively just moves the caret forward.
 696      */
 697     public void selectForward() {
 698         final int textLength = getLength();
 699         if (textLength &gt; 0 &amp;&amp; getCaretPosition() &lt; textLength) {
 700             if (charIterator == null) {
 701                 charIterator = BreakIterator.getCharacterInstance();
 702             }
 703             charIterator.setText(getText());
 704             selectRange(getAnchor(), charIterator.following(getCaretPosition()));
 705         }
 706     }
 707 
 708     /**
 709      * The break iterator instances for navigation over words and complex characters.
 710      */
 711     private BreakIterator charIterator;
 712     private BreakIterator wordIterator;
 713 
 714     /**
 715      * Moves the caret to the beginning of previous word. This function
 716      * also has the effect of clearing the selection.
 717      */
 718     public void previousWord() {
 719         previousWord(false);
 720     }
 721 
 722     /**
 723      * Moves the caret to the beginning of next word. This function
 724      * also has the effect of clearing the selection.
 725      */
 726     public void nextWord() {
 727         nextWord(false);
 728     }
 729 
 730     /**
 731      * Moves the caret to the end of the next word. This function
 732      * also has the effect of clearing the selection.
 733      */
 734     public void endOfNextWord() {
 735         endOfNextWord(false);
 736     }
 737 
 738     /**
 739      * Moves the caret to the beginning of previous word. This does not cause
 740      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 741      * moved to the beginning of previous word.
 742      */
 743     public void selectPreviousWord() {
 744         previousWord(true);
 745     }
 746 
 747     /**
 748      * Moves the caret to the beginning of next word. This does not cause
 749      * the selection to be cleared. Rather, the anchor stays put and the caretPosition is
 750      * moved to the beginning of next word.
 751      */
 752     public void selectNextWord() {
 753         nextWord(true);
 754     }
 755 
 756     /**
 757      * Moves the caret to the end of the next word. This does not cause
 758      * the selection to be cleared.
 759      */
 760     public void selectEndOfNextWord() {
 761         endOfNextWord(true);
 762     }
 763 
 764     private void previousWord(boolean select) {
 765         final int textLength = getLength();
 766         final String text = getText();
 767         if (textLength &lt;= 0) {
 768             return;
 769         }
 770 
 771         if (wordIterator == null) {
 772             wordIterator = BreakIterator.getWordInstance();
 773         }
 774         wordIterator.setText(text);
 775 
 776         int pos = wordIterator.preceding(Utils.clamp(0, getCaretPosition(), textLength));
 777 
 778         // Skip the non-word region, then move/select to the beginning of the word.
 779         while (pos != BreakIterator.DONE &amp;&amp;
 780                !Character.isLetterOrDigit(text.charAt(Utils.clamp(0, pos, textLength-1)))) {
 781             pos = wordIterator.preceding(Utils.clamp(0, pos, textLength));
 782         }
 783 
 784         // move/select
 785         selectRange(select ? getAnchor() : pos, pos);
 786     }
 787 
 788     private void nextWord(boolean select) {
 789         final int textLength = getLength();
 790         final String text = getText();
 791         if (textLength &lt;= 0) {
 792             return;
 793         }
 794 
 795         if (wordIterator == null) {
 796             wordIterator = BreakIterator.getWordInstance();
 797         }
 798         wordIterator.setText(text);
 799 
 800         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength-1));
 801         int current = wordIterator.next();
 802 
 803         // Skip whitespace characters to the beginning of next word, but
 804         // stop at newline. Then move the caret or select a range.
 805         while (current != BreakIterator.DONE) {
 806             for (int p=last; p&lt;=current; p++) {
 807                 char ch = text.charAt(Utils.clamp(0, p, textLength-1));
 808                 // Avoid using Character.isSpaceChar() and Character.isWhitespace(),
 809                 // because they include LINE_SEPARATOR, PARAGRAPH_SEPARATOR, etc.
 810                 if (ch != &#39; &#39; &amp;&amp; ch != &#39;\t&#39;) {
 811                     if (select) {
 812                         selectRange(getAnchor(), p);
 813                     } else {
 814                         selectRange(p, p);
 815                     }
 816                     return;
 817                 }
 818             }
 819             last = current;
 820             current = wordIterator.next();
 821         }
 822 
 823         // move/select to the end
 824         if (select) {
 825             selectRange(getAnchor(), textLength);
 826         } else {
 827             end();
 828         }
 829     }
 830 
 831     private void endOfNextWord(boolean select) {
 832         final int textLength = getLength();
 833         final String text = getText();
 834         if (textLength &lt;= 0) {
 835             return;
 836         }
 837 
 838         if (wordIterator == null) {
 839             wordIterator = BreakIterator.getWordInstance();
 840         }
 841         wordIterator.setText(text);
 842 
 843         int last = wordIterator.following(Utils.clamp(0, getCaretPosition(), textLength));
 844         int current = wordIterator.next();
 845 
 846         // skip the non-word region, then move/select to the end of the word.
 847         while (current != BreakIterator.DONE) {
 848             for (int p=last; p&lt;=current; p++) {
 849                 if (!Character.isLetterOrDigit(text.charAt(Utils.clamp(0, p, textLength-1)))) {
 850                     if (select) {
 851                         selectRange(getAnchor(), p);
 852                     } else {
 853                         selectRange(p, p);
 854                     }
 855                     return;
 856                 }
 857             }
 858             last = current;
 859             current = wordIterator.next();
 860         }
 861 
 862         // move/select to the end
 863         if (select) {
 864             selectRange(getAnchor(), textLength);
 865         } else {
 866             end();
 867         }
 868     }
 869 
 870     /**
 871      * Selects all text in the text input.
 872      */
 873     public void selectAll() {
 874         selectRange(0, getLength());
 875     }
 876 
 877     /**
 878      * Moves the caret to before the first char of the text. This function
 879      * also has the effect of clearing the selection.
 880      */
 881     public void home() {
 882         // user wants to go to start
 883         selectRange(0, 0);
 884     }
 885 
 886     /**
 887      * Moves the caret to after the last char of the text. This function
 888      * also has the effect of clearing the selection.
 889      */
 890     public void end() {
 891         // user wants to go to end
 892         final int textLength = getLength();
 893         if (textLength &gt; 0) {
 894             selectRange(textLength, textLength);
 895         }
 896     }
 897 
 898     /**
 899      * Moves the caret to before the first char of text. This does not cause
 900      * the selection to be cleared. Rather, the anchor stays put and the
 901      * caretPosition is moved to before the first char.
 902      */
 903     public void selectHome() {
 904         selectRange(getAnchor(), 0);
 905     }
 906 
 907     /**
 908      * Moves the caret to after the last char of text. This does not cause
 909      * the selection to be cleared. Rather, the anchor stays put and the
 910      * caretPosition is moved to after the last char.
 911      */
 912     public void selectEnd() {
 913         final int textLength = getLength();
 914         if (textLength &gt; 0) selectRange(getAnchor(), textLength);
 915     }
 916 
 917     /**
 918      * Deletes the character that precedes the current caret position from the
 919      * text if there is no selection, or deletes the selection if there is one.
 920      * This function returns true if the deletion succeeded, false otherwise.
 921      * @return true if the deletion succeeded, false otherwise
 922      */
 923     public boolean deletePreviousChar() {
 924         boolean failed = true;
 925         if (isEditable() &amp;&amp; !isDisabled()) {
 926             final String text = getText();
 927             final int dot = getCaretPosition();
 928             final int mark = getAnchor();
 929             if (dot != mark) {
 930                 // there is a selection of text to remove
 931                 replaceSelection(&quot;&quot;);
 932                 failed = false;
 933             } else if (dot &gt; 0) {
 934                 // The caret is not at the beginning, so remove some characters.
 935                 // Typically you&#39;d only be removing a single character, but
 936                 // in some cases you must remove two depending on the unicode
 937                 // characters
 938                 // Note: Do not use charIterator here, because we do want to
 939                 // break up clusters when deleting backwards.
 940                 int p = Character.offsetByCodePoints(text, dot, -1);
 941                 deleteText(p, dot);
 942                 failed = false;
 943             }
 944         }
 945         return !failed;
 946     }
 947 
 948     /**
 949      * Deletes the character that follows the current caret position from the
 950      * text if there is no selection, or deletes the selection if there is one.
 951      * This function returns true if the deletion succeeded, false otherwise.
 952      * @return true if the deletion succeeded, false otherwise
 953      */
 954     public boolean deleteNextChar() {
 955         boolean failed = true;
 956         if (isEditable() &amp;&amp; !isDisabled()) {
 957             final int textLength = getLength();
 958             final String text = getText();
 959             final int dot = getCaretPosition();
 960             final int mark = getAnchor();
 961             if (dot != mark) {
 962                 // there is a selection of text to remove
 963                 replaceSelection(&quot;&quot;);
 964                 failed = false;
 965             } else if (textLength &gt; 0 &amp;&amp; dot &lt; textLength) {
 966                 // The caret is not at the end, so remove some characters.
 967                 // Typically you&#39;d only be removing a single character, but
 968                 // in some cases you must remove two depending on the unicode
 969                 // characters
 970                 if (charIterator == null) {
 971                     charIterator = BreakIterator.getCharacterInstance();
 972                 }
 973                 charIterator.setText(text);
 974                 int p = charIterator.following(dot);
 975                 deleteText(dot, p);
 976                 failed = false;
 977             }
 978         }
 979         return !failed;
 980     }
 981 
 982     /**
 983      * Moves the caret position forward. If there is no selection, then the
 984      * caret position is moved one character forward. If there is a selection,
 985      * then the caret position is moved to the end of the selection and
 986      * the selection cleared.
 987      */
 988     public void forward() {
 989         // user has moved caret to the right
 990         final int textLength = getLength();
 991         final int dot = getCaretPosition();
 992         final int mark = getAnchor();
 993         if (dot != mark) {
 994             int pos = Math.max(dot, mark);
 995             selectRange(pos, pos);
 996         } else if (dot &lt; textLength &amp;&amp; textLength &gt; 0) {
 997             if (charIterator == null) {
 998                 charIterator = BreakIterator.getCharacterInstance();
 999             }
1000             charIterator.setText(getText());
1001             int pos = charIterator.following(dot);
1002             selectRange(pos, pos);
1003         }
1004         deselect();
1005     }
1006 
1007     /**
1008      * Moves the caret position backward. If there is no selection, then the
1009      * caret position is moved one character backward. If there is a selection,
1010      * then the caret position is moved to the beginning of the selection and
1011      * the selection cleared.
1012      *
1013      * Note: This function is intended to be used by experts, primarily
1014      *       by those implementing new Skins or Behaviors. It is not common
1015      *       for developers or designers to access this function directly.
1016      */
1017     public void backward() {
1018         // user has moved caret to the left
1019         final int textLength = getLength();
1020         final int dot = getCaretPosition();
1021         final int mark = getAnchor();
1022         if (dot != mark) {
1023             int pos = Math.min(dot, mark);
1024             selectRange(pos, pos);
1025         } else if (dot &gt; 0 &amp;&amp; textLength &gt; 0) {
1026             if (charIterator == null) {
1027                 charIterator = BreakIterator.getCharacterInstance();
1028             }
1029             charIterator.setText(getText());
1030             int pos = charIterator.preceding(dot);
1031             selectRange(pos, pos);
1032         }
1033         deselect();
1034     }
1035 
1036     /**
1037      * Positions the caret to the position indicated by {@code pos}. This
1038      * function will also clear the selection.
1039      * @param pos the position
1040      */
1041     public void positionCaret(int pos) {
1042         final int p = Utils.clamp(0, pos, getLength());
1043         selectRange(p, p);
1044     }
1045 
1046     /**
1047      * Positions the caret to the position indicated by {@code pos} and extends
1048      * the selection, if there is one. If there is no selection, then a
1049      * selection is formed where the anchor is at the current caret position
1050      * and the caretPosition is moved to pos.
1051      * @param pos the position
1052      */
1053     public void selectPositionCaret(int pos) {
1054         selectRange(getAnchor(), Utils.clamp(0, pos, getLength()));
1055     }
1056 
1057     /**
1058      * Positions the anchor and caretPosition explicitly.
1059      * @param anchor the anchor
1060      * @param caretPosition the caretPosition
1061      */
1062     public void selectRange(int anchor, int caretPosition) {
1063         caretPosition = Utils.clamp(0, caretPosition, getLength());
1064         anchor = Utils.clamp(0, anchor, getLength());
1065 
1066         TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition);
1067         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1068         if (formatter != null &amp;&amp; formatter.getFilter() != null) {
1069             change = formatter.getFilter().apply(change);
1070             if (change == null) {
1071                 return;
1072             }
1073         }
1074 
1075         updateContent(change, false);
1076     }
1077 
1078     private void doSelectRange(int anchor, int caretPosition) {
1079         this.caretPosition.set(Utils.clamp(0, caretPosition, getLength()));
1080         this.anchor.set(Utils.clamp(0, anchor, getLength()));
1081         this.selection.set(IndexRange.normalize(getAnchor(), getCaretPosition()));
1082         notifyAccessibleAttributeChanged(AccessibleAttribute.SELECTION_START);
1083     }
1084 
1085     /**
1086      * This function will extend the selection to include the specified pos.
1087      * This is different from selectPositionCaret in that it does not simply
1088      * move the caret. Rather, it will reposition the caret and anchor as necessary
1089      * to ensure that pos becomes the new caret and the far other end of the
1090      * selection becomes the anchor.
1091      * @param pos the position
1092      */
1093     public void extendSelection(int pos) {
1094         final int p = Utils.clamp(0, pos, getLength());
1095         final int dot = getCaretPosition();
1096         final int mark = getAnchor();
1097         int start = Math.min(dot, mark);
1098         int end = Math.max(dot, mark);
1099         if (p &lt; start) {
1100             selectRange(end, p);
1101         } else {
1102             selectRange(start, p);
1103         }
1104     }
1105 
1106     /**
1107      * Clears the text.
1108      */
1109     public void clear() {
1110         deselect();
1111         if (!text.isBound()) {
1112             setText(&quot;&quot;);
1113         }
1114     }
1115 
1116     /**
1117      * Clears the selection.
1118      */
1119     public void deselect() {
1120         // set the anchor equal to the caret position, which clears the selection
1121         // while also preserving the caret position
1122         selectRange(getCaretPosition(), getCaretPosition());
1123     }
1124 
1125     /**
1126      * Replaces the selection with the given replacement String. If there is
1127      * no selection, then the replacement text is simply inserted at the current
1128      * caret position. If there was a selection, then the selection is cleared
1129      * and the given replacement text inserted.
1130      * @param replacement the replacement string
1131      */
1132     public void replaceSelection(String replacement) {
1133         replaceText(getSelection(), replacement);
1134     }
1135 
1136     /**
1137      * If possible, undoes the last modification. If {@link #isUndoable()} returns
1138      * false, then calling this method has no effect.
1139      * @since JavaFX 8u40
1140      */
1141     public final void undo() {
1142         if (isUndoable()) {
1143             // Apply reverse change here
1144             final int start = undoChange.start;
1145             final String newText = undoChange.newText;
1146             final String oldText = undoChange.oldText;
1147 
1148             if (newText != null) {
1149                 getContent().delete(start, start + newText.length(), oldText.isEmpty());
1150             }
1151 
1152             if (oldText != null) {
1153                 getContent().insert(start, oldText, true);
1154                 doSelectRange(start, start + oldText.length());
1155             } else {
1156                 doSelectRange(start, start + newText.length());
1157             }
1158 
1159             undoChange = undoChange.prev;
1160         }
1161         updateUndoRedoState();
1162     }
1163 
1164     /**
1165      * If possible, redoes the last undone modification. If {@link #isRedoable()} returns
1166      * false, then calling this method has no effect.
1167      * @since JavaFX 8u40
1168      */
1169     public final void redo() {
1170         if (isRedoable()) {
1171             // Apply change here
1172             undoChange = undoChange.next;
1173             final int start = undoChange.start;
1174             final String newText = undoChange.newText;
1175             final String oldText = undoChange.oldText;
1176 
1177             if (oldText != null) {
1178                 getContent().delete(start, start + oldText.length(), newText.isEmpty());
1179             }
1180 
1181             if (newText != null) {
1182                 getContent().insert(start, newText, true);
1183                 doSelectRange(start + newText.length(), start + newText.length());
1184             } else {
1185                 doSelectRange(start, start);
1186             }
1187         }
1188         updateUndoRedoState();
1189         // else beep ?
1190     }
1191 
1192     // Used by TextArea, although there are probably other better ways of
1193     // doing this.
1194     void textUpdated() { }
1195 
1196     private void resetUndoRedoState() {
1197         undoChange = undoChangeHead;
1198         undoChange.next = null;
1199         updateUndoRedoState();
1200     }
1201 
1202     private void updateUndoRedoState() {
1203         undoable.set(undoChange != undoChangeHead);
1204         redoable.set(undoChange.next != null);
1205     }
1206 
1207     private boolean filterAndSet(String value) {
1208         // Send the new value through the textFormatter, if one exists.
1209         TextFormatter&lt;?&gt; formatter = getTextFormatter();
1210         int length = content.length();
1211         if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) {
1212             TextFormatter.Change change = new TextFormatter.Change(
1213                     TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0);
1214             change = formatter.getFilter().apply(change);
1215             if (change == null) {
1216                 return false;
1217             }
1218             replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition());
1219         } else {
1220             replaceText(0, length, value, 0, 0);
1221         }
1222         return true;
1223     }
1224 
1225     /**
1226      * This is what is ultimately called by every code path that will update
1227      * the content (except for undo / redo). The input into this method has
1228      * already run through the textFormatter where appropriate.
1229      *
1230      * @param start            The start index into the existing text which
1231      *                         will be replaced by the new value
1232      * @param end              The end index into the existing text which will
1233      *                         be replaced by the new value. As with
1234      *                         String.replace this is a lastIndex+1 value
1235      * @param value            The new text value
1236      * @param anchor           The new selection anchor after the change is made
1237      * @param caretPosition    The new selection caretPosition after the change
1238      *                         is made.
1239      * @return The amount of adjustment made to the end / anchor / caretPosition to
1240      *         accommodate for subsequent filtering (such as the filtering of
1241      *         new lines by the TextField)
1242      */
1243     private int replaceText(int start, int end, String value, int anchor, int caretPosition) {
1244         // RT-16566: Need to take into account stripping of chars into the
1245         // final anchor &amp; caret position
<a name="4" id="anc4"></a><span class="line-modified">1246         blockSelectedTextUpdate = true;</span>
<span class="line-modified">1247         try {</span>
<span class="line-modified">1248             int length = getLength();</span>
<span class="line-modified">1249             int adjustmentAmount = 0;</span>
<span class="line-modified">1250             if (end != start) {</span>
<span class="line-modified">1251                 getContent().delete(start, end, value.isEmpty());</span>
<span class="line-modified">1252                 length -= (end - start);</span>
<span class="line-modified">1253             }</span>
<span class="line-modified">1254             if (value != null) {</span>
<span class="line-modified">1255                 getContent().insert(start, value, true);</span>
<span class="line-modified">1256                 adjustmentAmount = value.length() - (getLength() - length);</span>
<span class="line-added">1257                 anchor -= adjustmentAmount;</span>
<span class="line-added">1258                 caretPosition -= adjustmentAmount;</span>
<span class="line-added">1259             }</span>
<span class="line-added">1260             doSelectRange(anchor, caretPosition);</span>
<span class="line-added">1261             return adjustmentAmount;</span>
<span class="line-added">1262         } finally {</span>
<span class="line-added">1263             blockSelectedTextUpdate = false;</span>
<span class="line-added">1264             updateSelectedText();</span>
1265         }
<a name="5" id="anc5"></a>

1266     }
1267 
1268     private &lt;T&gt; void updateText(TextFormatter&lt;T&gt; formatter) {
1269         T value = formatter.getValue();
1270         StringConverter&lt;T&gt; converter = formatter.getValueConverter();
1271         if (converter != null) {
1272             String text = converter.toString(value);
1273             if (text == null) text = &quot;&quot;;
1274             replaceText(0, getLength(), text, text.length(), text.length());
1275         }
1276     }
1277 
1278     /**
1279      * Commit the current text and convert it to a value.
1280      * @since JavaFX 8u40
1281      */
1282     public final void commitValue() {
1283         if (getTextFormatter() != null) {
1284             getTextFormatter().updateValue(getText());
1285         }
1286     }
1287 
1288     /**
1289      * If the field is currently being edited, this call will set text to the last commited value.
1290      * @since JavaFX 8u40
1291      */
1292     public final void cancelEdit() {
1293         if (getTextFormatter() != null) {
1294             updateText(getTextFormatter());
1295         }
1296     }
1297 
1298     private FormatterAccessor accessor;
1299 
1300     private FormatterAccessor getFormatterAccessor() {
1301         if (accessor == null) {
1302             accessor = new TextInputControlFromatterAccessor();
1303         }
1304         return accessor;
1305     }
1306 
1307     String filterInput(String text) {
1308         // This method should be overridden by child classes.
1309         // It is overridden in TextField and TextArea as needed.
1310         return text;
1311     }
1312 
1313     /**
1314      * A little utility method for stripping out unwanted characters.
1315      *
1316      * @param txt
1317      * @param stripNewlines
1318      * @param stripTabs
1319      * @return The string after having the unwanted characters stripped out.
1320      */
1321     static String filterInput(String txt, boolean stripNewlines, boolean stripTabs) {
1322         // Most of the time, when text is inserted, there are no illegal
1323         // characters. So we&#39;ll do a &quot;cheap&quot; check for illegal characters.
1324         // If we find one, we&#39;ll do a longer replace algorithm. In the
1325         // case of illegal characters, this may at worst be an O(2n) solution.
1326         // Strip out any characters that are outside the printed range
1327         if (containsInvalidCharacters(txt, stripNewlines, stripTabs)) {
1328             StringBuilder s = new StringBuilder(txt.length());
1329             for (int i=0; i&lt;txt.length(); i++) {
1330                 final char c = txt.charAt(i);
1331                 if (!isInvalidCharacter(c, stripNewlines, stripTabs)) {
1332                     s.append(c);
1333                 }
1334             }
1335             txt = s.toString();
1336         }
1337         return txt;
1338     }
1339 
1340     static boolean containsInvalidCharacters(String txt, boolean newlineIllegal, boolean tabIllegal) {
1341         for (int i=0; i&lt;txt.length(); i++) {
1342             final char c = txt.charAt(i);
1343             if (isInvalidCharacter(c, newlineIllegal, tabIllegal)) return true;
1344         }
1345         return false;
1346     }
1347 
1348     private static boolean isInvalidCharacter(char c, boolean newlineIllegal, boolean tabIllegal) {
1349         if (c == 0x7F) return true;
1350         if (c == 0xA) return newlineIllegal;
1351         if (c == 0x9) return tabIllegal;
1352         if (c &lt; 0x20) return true;
1353         return false;
1354     }
1355 
1356     // It can be bound, in which case we will force it to be an eager
1357     // binding so that we update the content eagerly
1358     // It can be bidirectionally bound, which basically will just work
1359     // If somebody changes the content directly, it will be notified and
1360     // send an invalidation event.
1361     private class TextProperty extends StringProperty {
1362         // This is used only when the property is bound
1363         private ObservableValue&lt;? extends String&gt; observable = null;
1364         // Added to the observable when bound
1365         private InvalidationListener listener = null;
1366         // Used for event handling
1367         private ExpressionHelper&lt;String&gt; helper = null;
1368         // The developer my set the Text property to null. Although
1369         // the Content must be given an empty String, we must still
1370         // treat the value as though it were null, so that a subsequent
1371         // getText() will return null.
1372         private boolean textIsNull = false;
1373 
1374         @Override public String get() {
1375             // Since we force eager binding and content is always up to date,
1376             // we just need to get it from content and not through the binding
1377             return textIsNull ? null : content.get();
1378         }
1379 
1380         @Override public void set(String value) {
1381             if (isBound()) {
1382                 throw new java.lang.RuntimeException(&quot;A bound value cannot be set.&quot;);
1383             }
1384             doSet(value);
1385             markInvalid();
1386         }
1387 
1388         /**
1389          * Called whenever the content on the control has changed (as determined
1390          * by a listener on the content).
1391          */
1392         private void controlContentHasChanged() {
1393             markInvalid();
1394             notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);
1395         }
1396 
1397         @Override public void bind(ObservableValue&lt;? extends String&gt; observable) {
1398             if (observable == null) {
1399                 throw new NullPointerException(&quot;Cannot bind to null&quot;);
1400             }
1401             if (!observable.equals(this.observable)) {
1402                 unbind();
1403                 this.observable = observable;
1404                 if (listener == null) {
1405                     listener = new Listener();
1406                 }
1407                 this.observable.addListener(listener);
1408                 markInvalid();
1409                 doSet(observable.getValue());
1410             }
1411         }
1412 
1413         @Override public void unbind() {
1414             if (observable != null) {
1415                 doSet(observable.getValue());
1416                 observable.removeListener(listener);
1417                 observable = null;
1418             }
1419         }
1420 
1421         @Override public boolean isBound() {
1422             return observable != null;
1423         }
1424 
1425         @Override public void addListener(InvalidationListener listener) {
1426             helper = ExpressionHelper.addListener(helper, this, listener);
1427         }
1428 
1429         @Override public void removeListener(InvalidationListener listener) {
1430             helper = ExpressionHelper.removeListener(helper, listener);
1431         }
1432 
1433         @Override public void addListener(ChangeListener&lt;? super String&gt; listener) {
1434             helper = ExpressionHelper.addListener(helper, this, listener);
1435         }
1436 
1437         @Override public void removeListener(ChangeListener&lt;? super String&gt; listener) {
1438             helper = ExpressionHelper.removeListener(helper, listener);
1439         }
1440 
1441         @Override public Object getBean() {
1442             return TextInputControl.this;
1443         }
1444 
1445         @Override public String getName() {
1446             return &quot;text&quot;;
1447         }
1448 
1449         private void fireValueChangedEvent() {
1450             ExpressionHelper.fireValueChangedEvent(helper);
1451         }
1452 
1453         private void markInvalid() {
1454             fireValueChangedEvent();
1455         }
1456 
1457         /**
1458          * doSet is called whenever the setText() method was called directly
1459          * on the TextInputControl, or when the text property was bound,
1460          * unbound, or reacted to a binding invalidation. It is *not* called
1461          * when modifications to the content happened indirectly, such as
1462          * through the replaceText / replaceSelection methods.
1463          *
1464          * @param value The new value
1465          */
1466         private void doSet(String value) {
1467             // Guard against the null value.
1468             textIsNull = value == null;
1469             if (value == null) value = &quot;&quot;;
1470 
1471             if (!filterAndSet(value)) return;
1472 
1473             if (getTextFormatter() != null) {
1474                 getTextFormatter().updateValue(getText());
1475             }
1476 
1477             textUpdated();
1478 
1479             // If the programmer has directly manipulated the text property
1480             // or has it bound up, then we will clear out any modifications
1481             // from the undo manager as we must suppose that the control is
1482             // being reused, for example, between forms.
1483             resetUndoRedoState();
1484         }
1485 
1486         private class Listener implements InvalidationListener {
1487             @Override
1488             public void invalidated(Observable valueModel) {
1489                 // We now need to force it to be eagerly recomputed
1490                 // because we need to push these changes to the
1491                 // content model. Because changing the model ends
1492                 // up calling invalidate and markInvalid, the
1493                 // listeners will all be notified.
1494                 doSet(observable.getValue());
1495             }
1496         }
1497     }
1498 
1499     /**
1500      * Used to form a linked-list of Undo / Redo changes. Each UndoRedoChange
1501      * records the old and new text, and the start index. It also has
1502      * the links to the previous and next Changes in the chain. There
1503      * are two special UndoRedoChange objects in this chain representing the
1504      * head and the tail so we can have beforeFirst and afterLast
1505      * behavior as necessary.
1506      */
1507     static class UndoRedoChange {
1508         static long prevRecordTime;
1509         static final long CHANGE_DURATION = 2500; // milliseconds
1510         static boolean spaceCharSequence = false;
1511         int start;
1512         String oldText;
1513         String newText;
1514         UndoRedoChange prev;
1515         UndoRedoChange next;
1516 
1517         UndoRedoChange() { }
1518 
1519         public UndoRedoChange add(int start, String oldText, String newText) {
1520             UndoRedoChange c = new UndoRedoChange();
1521             c.start = start;
1522             c.oldText = oldText;
1523             c.newText = newText;
1524             c.prev = this;
1525             next = c;
1526             prevRecordTime = System.currentTimeMillis();
1527             return c;
1528         }
1529 
1530         static boolean hasChangeDurationElapsed() {
1531             return (System.currentTimeMillis() - prevRecordTime &gt; CHANGE_DURATION) ;
1532         }
1533 
1534         static void setSpaceCharSequence(boolean value) {
1535             spaceCharSequence = value;
1536         }
1537         static boolean isSpaceCharSequence() {
1538             return spaceCharSequence;
1539         }
1540 
1541         public UndoRedoChange discard() {
1542             prev.next = next;
1543             return prev;
1544         }
1545 
1546         // Handy to use when debugging, just put it in undo or redo
1547         // method or replaceText to see what is happening to the undo
1548         // history as it occurs.
1549         void debugPrint() {
1550             UndoRedoChange c = this;
1551             System.out.print(&quot;[&quot;);
1552             while (c != null) {
1553                 System.out.print(c.toString());
1554                 if (c.next != null) System.out.print(&quot;, &quot;);
1555                 c = c.next;
1556             }
1557             System.out.println(&quot;]&quot;);
1558         }
1559 
1560         @Override public String toString() {
1561             if (oldText == null &amp;&amp; newText == null) {
1562                 return &quot;head&quot;;
1563             }
1564             if (oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1565                 return &quot;added &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1566             } else if (!oldText.isEmpty() &amp;&amp; !newText.isEmpty()) {
1567                 return &quot;replaced &#39;&quot; + oldText + &quot;&#39; with &#39;&quot; + newText + &quot;&#39; at index &quot; + start;
1568             } else {
1569                 return &quot;deleted &#39;&quot; + oldText + &quot;&#39; at index &quot; + start;
1570             }
1571         }
1572     }
1573 
1574     /***************************************************************************
1575      *                                                                         *
1576      * Stylesheet Handling                                                     *
1577      *                                                                         *
1578      **************************************************************************/
1579 
1580 
1581     private static final PseudoClass PSEUDO_CLASS_READONLY
1582             = PseudoClass.getPseudoClass(&quot;readonly&quot;);
1583 
1584     private static class StyleableProperties {
1585         private static final FontCssMetaData&lt;TextInputControl&gt; FONT =
1586             new FontCssMetaData&lt;TextInputControl&gt;(&quot;-fx-font&quot;, Font.getDefault()) {
1587 
1588             @Override
1589             public boolean isSettable(TextInputControl n) {
1590                 return n.font == null || !n.font.isBound();
1591             }
1592 
1593             @Override
1594             public StyleableProperty&lt;Font&gt; getStyleableProperty(TextInputControl n) {
1595                 return (StyleableProperty&lt;Font&gt;)(WritableValue&lt;Font&gt;)n.fontProperty();
1596             }
1597         };
1598 
1599         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1600         static {
1601             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1602                 new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1603             styleables.add(FONT);
1604             STYLEABLES = Collections.unmodifiableList(styleables);
1605         }
1606     }
1607 
1608     /**
1609      * @return The CssMetaData associated with this class, which may include the
1610      * CssMetaData of its superclasses.
1611      * @since JavaFX 8.0
1612      */
1613     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1614         return StyleableProperties.STYLEABLES;
1615     }
1616 
1617     /**
1618      * {@inheritDoc}
1619      * @since JavaFX 8.0
1620      */
1621     @Override
1622     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1623         return getClassCssMetaData();
1624     }
1625 
1626 
1627     /***************************************************************************
1628      *                                                                         *
1629      * Accessibility handling                                                  *
1630      *                                                                         *
1631      **************************************************************************/
1632 
1633     /** {@inheritDoc} */
1634     @Override
1635     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1636         switch (attribute) {
1637             case TEXT: {
1638                 String accText = getAccessibleText();
1639                 if (accText != null &amp;&amp; !accText.isEmpty()) return accText;
1640 
1641                 String text = getText();
1642                 if (text == null || text.isEmpty()) {
1643                     text = getPromptText();
1644                 }
1645                 return text;
1646             }
1647             case EDITABLE: return isEditable();
1648             case SELECTION_START: return getSelection().getStart();
1649             case SELECTION_END: return getSelection().getEnd();
1650             case CARET_OFFSET: return getCaretPosition();
1651             case FONT: return getFont();
1652             default: return super.queryAccessibleAttribute(attribute, parameters);
1653         }
1654     }
1655 
1656     /** {@inheritDoc} */
1657     @Override
1658     public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1659         switch (action) {
1660             case SET_TEXT: {
1661                 String value = (String) parameters[0];
1662                 if (value != null) setText(value);
1663                 break;
1664             }
1665             case SET_TEXT_SELECTION: {
1666                 Integer start = (Integer) parameters[0];
1667                 Integer end = (Integer) parameters[1];
1668                 if (start != null &amp;&amp; end != null) {
1669                     selectRange(start,  end);
1670                 }
1671                 break;
1672             }
1673             default: super.executeAccessibleAction(action, parameters);
1674         }
1675     }
1676 
1677     private class TextInputControlFromatterAccessor implements FormatterAccessor {
1678         @Override
1679         public int getTextLength() {
1680             return TextInputControl.this.getLength();
1681         }
1682 
1683         @Override
1684         public String getText(int begin, int end) {
1685             return TextInputControl.this.getText(begin, end);
1686         }
1687 
1688         @Override
1689         public int getCaret() {
1690             return TextInputControl.this.getCaretPosition();
1691         }
1692 
1693         @Override
1694         public int getAnchor() {
1695             return TextInputControl.this.getAnchor();
1696         }
1697     }
1698 
1699 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/EPDScreen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package com.sun.glass.ui.monocle;
 26 
 27 import com.sun.glass.ui.Pixels;
 28 import com.sun.javafx.logging.PlatformLogger;
 29 import com.sun.javafx.util.Logging;
 30 import java.io.IOException;
 31 import java.nio.Buffer;
 32 import java.nio.ByteBuffer;
 33 import java.nio.ByteOrder;
 34 import java.nio.channels.FileChannel;
 35 import java.nio.file.FileSystems;
 36 import java.nio.file.Path;
 37 import java.nio.file.StandardOpenOption;
 38 import java.security.AccessController;
 39 import java.security.PrivilegedAction;
 40 import java.text.MessageFormat;
 41 
 42 /**
 43  * A native screen for an electrophoretic display, also called an e-paper
 44  * display. This class uploads pixels directly into the Linux frame buffer if it
 45  * is configured with a color depth of 32 bits per pixel. Otherwise, this class
 46  * uploads pixels into a 32-bit off-screen composition buffer and converts the
 47  * pixels to the correct format when writing them to the Linux frame buffer.
 48  */
 49 class EPDScreen implements NativeScreen {
 50 
 51     /**
 52      * The system property for setting the frame buffer device path.
 53      */
 54     private static final String FB_PATH_KEY = &quot;monocle.screen.fb&quot;;
 55 
 56     /**
 57      * The default value for the frame buffer device path.
 58      */
 59     private static final String FB_PATH_DEFAULT = &quot;/dev/fb0&quot;;
 60 
 61     /**
 62      * The density of this screen in pixels per inch. For now, the value is
 63      * hard-coded to the density of a 6-inch display panel with 800 x 600 px at
 64      * 167 ppi.
 65      */
 66     private static final int DPI = 167;
 67 
 68     /**
 69      * The ratio of physical pixels to logical pixels on this screen. For now,
 70      * the value is hard-coded to a ratio of 1.0.
 71      */
 72     private static final float SCALE = 1.0f;
 73 
 74     private final PlatformLogger logger = Logging.getJavaFXLogger();
 75 
 76     private final String fbPath;
 77     private final EPDFrameBuffer fbDevice;
 78     private final ByteBuffer fbMapping;
 79     private final FileChannel fbChannel;
 80     private final Framebuffer pixels;
 81     private final int width;
 82     private final int height;
 83     private final int bitDepth;
 84 
 85     private boolean isShutdown;
 86 
 87     /**
 88      * Creates a native screen for the electrophoretic display.
 89      *
 90      * @throws IllegalStateException if an error occurs opening the frame buffer
 91      */
 92     EPDScreen() {
 93         fbPath = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) ()
 94                 -&gt; System.getProperty(FB_PATH_KEY, FB_PATH_DEFAULT));
 95         try {
 96             fbDevice = new EPDFrameBuffer(fbPath);
 97             fbDevice.init();
 98 
 99             width = fbDevice.getWidth();
100             height = fbDevice.getHeight();
101             bitDepth = fbDevice.getBitDepth();
102             logger.fine(&quot;Native screen geometry: {0} px x {1} px x {2} bpp&quot;,
103                     width, height, bitDepth);
104 
105             /*
106              * If the Linux frame buffer is configured for 32-bit color, compose
107              * the pixels directly into it. Otherwise, compose the pixels into
108              * an off-screen buffer and write them to the frame buffer when
109              * swapping buffers.
110              *
111              * With an LCD display, there must be space for two full screens to
112              * be able to write directly into the frame buffer, displaying one
113              * while updating the other. The Snapshot update mode of an e-paper
114              * display, though, allows us to reuse the same frame buffer region
115              * immediately after sending an update.
116              */
117             ByteBuffer mapping = null;
118             if (bitDepth == Integer.SIZE) {
119                 mapping = fbDevice.getMappedBuffer();
120             }
121             if (mapping != null) {
122                 fbMapping = mapping;
123                 fbChannel = null;
124             } else {
125                 Path path = FileSystems.getDefault().getPath(fbPath);
126                 fbChannel = FileChannel.open(path, StandardOpenOption.WRITE);
127                 fbMapping = null;
128             }
129         } catch (IOException e) {
130             String msg = MessageFormat.format(&quot;Failed opening frame buffer: {0}&quot;, fbPath);
131             logger.severe(msg, e);
132             throw new IllegalStateException(msg, e);
133         }
134 
135         /*
136          * Note that pixels.clearBufferContents() throws a NullPointerException
137          * if the last parameter of its constructor (&quot;clear&quot;) is false.
138          */
139         ByteBuffer buffer = fbMapping != null ? fbMapping : fbDevice.getOffscreenBuffer();
140         buffer.order(ByteOrder.nativeOrder());
141         pixels = new FramebufferY8(buffer, width, height, bitDepth, true);
142         clearScreen();
143     }
144 
145     /**
146      * Closes the Linux frame buffer device and related resources. Called only
147      * from the {@link #shutdown} method, which is called only once.
148      */
149     private void close() {
150         try {
151             if (fbChannel != null) {
152                 fbChannel.close();
153             }
154         } catch (IOException e) {
155             logger.severe(&quot;Failed closing frame buffer channel&quot;, e);
156         } finally {
157             if (fbMapping != null) {
158                 fbDevice.releaseMappedBuffer(fbMapping);
159             }
160             fbDevice.close();
161         }
162     }
163 
164     /**
165      * Writes the content of the off-screen buffer to the Linux frame buffer, if
166      * necessary. If the frame buffer is mapped, the content to display is
167      * already there, and this method does nothing.
168      */
169     private void writeBuffer() {
170         if (fbChannel != null) {
171             try {
172                 fbChannel.position(fbDevice.getByteOffset());
173                 pixels.write(fbChannel);
174             } catch (IOException e) {
175                 logger.severe(&quot;Failed writing to frame buffer channel&quot;, e);
176             }
177         }
178     }
179 
180     /**
181      * Clears the screen.
182      */
183     private void clearScreen() {
184         pixels.clearBufferContents();
185         writeBuffer();
186         fbDevice.clear();
187     }
188 
189     @Override
190     public int getDepth() {
191         return bitDepth;
192     }
193 
194     @Override
195     public int getNativeFormat() {
196         /*
197          * The native pixel format must be one of either
198          * Pixels.Format.BYTE_BGRA_PRE when the system byte order is
199          * ByteOrder.LITTLE_ENDIAN, or Pixels.Format.BYTE_ARGB when the system
200          * byte order is ByteOrder.BIG_ENDIAN. The ARMv7-A architecture is
201          * little endian by default.
202          */
203         return Pixels.Format.BYTE_BGRA_PRE;
204     }
205 
206     @Override
207     public int getWidth() {
208         return width;
209     }
210 
211     @Override
212     public int getHeight() {
213         return height;
214     }
215 
216     @Override
217     public int getDPI() {
218         return DPI;
219     }
220 
221     @Override
222     public long getNativeHandle() {
223         return fbDevice.getNativeHandle();
224     }
225 
226     @Override
227     public synchronized void shutdown() {
228         close();
229         isShutdown = true;
230     }
231 
232     @Override
233     public synchronized void uploadPixels(Buffer b, int x, int y, int width, int height, float alpha) {
234         assert b.mark() == b;
235         pixels.composePixels(b, x, y, width, height, alpha);
236         /*
237          * When enabled, throws an InvalidMarkException if the buffer is
238          * modified by a clear, flip, or rewind operation on another thread
239          * while in use by this method on the JavaFX Application Thread.
240          */
241         assert b.reset() == b;
242     }
243 
244     @Override
245     public synchronized void swapBuffers() {
246         if (!isShutdown &amp;&amp; pixels.hasReceivedData()) {
247             writeBuffer();
248             fbDevice.sync();
249             pixels.reset();
250         }
251     }
252 
253     @Override
254     public synchronized ByteBuffer getScreenCapture() {
255         return pixels.getBuffer().asReadOnlyBuffer();
256     }
257 
258     @Override
259     public float getScale() {
260         return SCALE;
261     }
262 
263     @Override
264     public String toString() {
265         return MessageFormat.format(&quot;{0}[width={1} height={2} depth={3} DPI={4} scale={5,number,0.0#}]&quot;,
266                 getClass().getName(), getWidth(), getHeight(), getDepth(), getDPI(), getScale());
267     }
268 }
    </pre>
  </body>
</html>
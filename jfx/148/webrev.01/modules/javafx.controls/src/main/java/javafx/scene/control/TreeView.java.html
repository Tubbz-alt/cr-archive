<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import javafx.css.converter.SizeConverter;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.behavior.TreeCellBehavior;
  31 import javafx.scene.control.skin.TreeViewSkin;
  32 
  33 import javafx.application.Platform;
  34 import javafx.beans.DefaultProperty;
  35 import javafx.beans.InvalidationListener;
  36 import javafx.beans.WeakInvalidationListener;
  37 import javafx.beans.property.BooleanProperty;
  38 import javafx.beans.property.DoubleProperty;
  39 import javafx.beans.property.ObjectProperty;
  40 import javafx.beans.property.ObjectPropertyBase;
  41 import javafx.beans.property.ReadOnlyIntegerProperty;
  42 import javafx.beans.property.ReadOnlyIntegerWrapper;
  43 import javafx.beans.property.ReadOnlyObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectWrapper;
  45 import javafx.beans.property.SimpleBooleanProperty;
  46 import javafx.beans.property.SimpleObjectProperty;
  47 import javafx.beans.value.ChangeListener;
  48 import javafx.beans.value.WeakChangeListener;
  49 import javafx.beans.value.WritableValue;
  50 import javafx.collections.ListChangeListener;
  51 import javafx.css.CssMetaData;
  52 import javafx.css.Styleable;
  53 import javafx.css.StyleableDoubleProperty;
  54 import javafx.css.StyleableProperty;
  55 import javafx.event.Event;
  56 import javafx.event.EventHandler;
  57 import javafx.event.EventType;
  58 import javafx.event.WeakEventHandler;
  59 import javafx.scene.AccessibleAttribute;
  60 import javafx.scene.AccessibleRole;
  61 import javafx.scene.control.TreeItem.TreeModificationEvent;
  62 import javafx.scene.layout.Region;
  63 import javafx.util.Callback;
  64 
  65 import java.lang.ref.SoftReference;
  66 import java.lang.ref.WeakReference;
  67 import java.util.ArrayList;
  68 import java.util.Collections;
  69 import java.util.HashMap;
  70 import java.util.List;
  71 import java.util.Map;
  72 
  73 /**
  74  * The TreeView control provides a view on to a tree root (of type
  75  * {@link TreeItem}). By using a TreeView, it is possible to drill down into the
  76  * children of a TreeItem, recursively until a TreeItem has no children (that is,
  77  * it is a &lt;i&gt;leaf&lt;/i&gt; node in the tree). To facilitate this, unlike controls
  78  * like {@link ListView}, in TreeView it is necessary to &lt;strong&gt;only&lt;/strong&gt;
  79  * specify the {@link #rootProperty() root} node.
  80  *
  81  * &lt;p&gt;
  82  * For more information on building up a tree using this approach, refer to the
  83  * {@link TreeItem} class documentation. Briefly however, to create a TreeView,
  84  * you should do something along the lines of the following:
  85  *
  86  * &lt;pre&gt;&lt;code&gt; TreeItem&amp;lt;String&amp;gt; root = new TreeItem&amp;lt;&amp;gt;(&quot;Root Node&quot;);
  87  * root.setExpanded(true);
  88  * root.getChildren().addAll(
  89  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 1&quot;),
  90  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 2&quot;),
  91  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 3&quot;)
  92  * );
  93  * TreeView&amp;lt;String&amp;gt; treeView = new TreeView&amp;lt;&amp;gt;(root);&lt;/code&gt;&lt;/pre&gt;
  94  *
  95  * &lt;img src=&quot;doc-files/TreeView.png&quot; alt=&quot;Image of the TreeView control&quot;&gt;
  96  *
  97  * &lt;p&gt;
  98  * A TreeView may be configured to optionally hide the root node by setting the
  99  * {@link #setShowRoot(boolean) showRoot} property to {@code false}. If the root
 100  * node is hidden, there is one less level of indentation, and all children
 101  * nodes of the root node are shown. By default, the root node is shown in the
 102  * TreeView.
 103  *
 104  * &lt;h2&gt;TreeView Selection / Focus APIs&lt;/h2&gt;
 105  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 106  * {@link SelectionModel} and {@link FocusModel} classes. A TreeView has at most
 107  * one instance of each of these classes, available from
 108  * {@link #selectionModelProperty() selectionModel} and
 109  * {@link #focusModelProperty() focusModel} properties respectively.
 110  * Whilst it is possible to use this API to set a new selection model, in
 111  * most circumstances this is not necessary - the default selection and focus
 112  * models should work in most circumstances.
 113  *
 114  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeView is
 115  * an implementation of the {@link MultipleSelectionModel} abstract class.
 116  * However, as noted in the API documentation for
 117  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 118  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 119  * multiple selection in a default TreeView instance, it is therefore necessary
 120  * to do the following:
 121  *
 122  * &lt;pre&gt; {@code treeView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 123  *
 124  * &lt;h2&gt;Customizing TreeView Visuals&lt;/h2&gt;
 125  * &lt;p&gt;The visuals of the TreeView can be entirely customized by replacing the
 126  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 127  * generate {@link TreeCell} instances, which are used to represent an item in the
 128  * TreeView. See the {@link Cell} class documentation for a more complete
 129  * description of how to write custom Cells.
 130  *
 131  * &lt;h2&gt;Editing&lt;/h2&gt;
 132  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 133  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 134  *
 135  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 136  * than when a cell is not being edited. This is the responsibility of the
 137  * {@link Cell} implementation being used. For TreeView, this is the responsibility
 138  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 139  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 140  * or to switch to a different UI when editing begins (e.g. when a double-click
 141  * is received on a cell).&lt;/p&gt;
 142  *
 143  * &lt;p&gt;To know when editing has been requested on a cell,
 144  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 145  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 146  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 147  * appropriate (e.g. set the text to null and set the graphic to be a
 148  * {@link TextField}). Additionally, you should also override
 149  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 150  * when the editing concludes. In both cases it is important that you also
 151  * ensure that you call the super method to have the cell perform all duties it
 152  * must do to enter or exit its editing mode.&lt;/p&gt;
 153  *
 154  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 155  * interested in is how to commit or cancel the editing that is taking place. This is your
 156  * responsibility as the cell factory provider. Your cell implementation will know
 157  * when the editing is over, based on the user input (e.g. when the user presses
 158  * the Enter or ESC keys on their keyboard). When this happens, it is your
 159  * responsibility to call {@link Cell#commitEdit(Object)} or
 160  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 161  *
 162  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 163  * TreeView, which you can observe by adding an {@link EventHandler} via
 164  * {@link TreeView#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 165  * you can also observe edit events for
 166  * {@link TreeView#setOnEditStart(javafx.event.EventHandler) edit start}
 167  * and {@link TreeView#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 168  *
 169  * &lt;p&gt;By default the TreeView edit commit handler is non-null, with a default
 170  * handler that attempts to overwrite the property value for the
 171  * item in the currently-being-edited row. It is able to do this as the
 172  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 173  * is passed along to the edit commit handler via the
 174  * {@link EditEvent} that is fired. It is simply a matter of calling
 175  * {@link EditEvent#getNewValue()} to retrieve this value.
 176  *
 177  * &lt;p&gt;It is very important to note that if you call
 178  * {@link TreeView#setOnEditCommit(javafx.event.EventHandler)} with your own
 179  * {@link EventHandler}, then you will be removing the default handler. Unless
 180  * you then handle the writeback to the property (or the relevant data source),
 181  * nothing will happen. You can work around this by using the
 182  * {@link TreeView#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 183  * method to add a {@link TreeView#editCommitEvent()} {@link EventType} with
 184  * your desired {@link EventHandler} as the second argument. Using this method,
 185  * you will not replace the default implementation, but you will be notified when
 186  * an edit commit has occurred.&lt;/p&gt;
 187  *
 188  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 189  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 190  * handle all the editing requirements on your behalf. You can find these
 191  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 192  *
 193  * @see TreeItem
 194  * @see TreeCell
 195  * @param &lt;T&gt; The type of the item contained within the {@link TreeItem} value
 196  *      property for all tree items in this TreeView.
 197  * @since JavaFX 2.0
 198  */
 199 @DefaultProperty(&quot;root&quot;)
 200 public class TreeView&lt;T&gt; extends Control {
 201 
 202     /***************************************************************************
 203      *                                                                         *
 204      * Static properties and methods                                           *
 205      *                                                                         *
 206      **************************************************************************/
 207 
 208     /**
 209      * An EventType that indicates some edit event has occurred. It is the parent
 210      * type of all other edit events: {@link #editStartEvent()},
 211      *  {@link #editCommitEvent()} and {@link #editCancelEvent()}.
 212      *
 213      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 214      * @return An EventType that indicates some edit event has occurred.
 215      */
 216     @SuppressWarnings(&quot;unchecked&quot;)
 217     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editAnyEvent() {
 218         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_ANY_EVENT;
 219     }
 220     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 221             new EventType&lt;&gt;(Event.ANY, &quot;TREE_VIEW_EDIT&quot;);
 222 
 223     /**
 224      * An EventType used to indicate that an edit event has started within the
 225      * TreeView upon which the event was fired.
 226      *
 227      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 228      * @return An EventType used to indicate that an edit event has started.
 229      */
 230     @SuppressWarnings(&quot;unchecked&quot;)
 231     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editStartEvent() {
 232         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_START_EVENT;
 233     }
 234     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 235             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 236 
 237     /**
 238      * An EventType used to indicate that an edit event has just been canceled
 239      * within the TreeView upon which the event was fired.
 240      *
 241      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 242      * @return An EventType used to indicate that an edit event has just been
 243      *      canceled.
 244      */
 245     @SuppressWarnings(&quot;unchecked&quot;)
 246     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editCancelEvent() {
 247         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_CANCEL_EVENT;
 248     }
 249     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 250             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 251 
 252     /**
 253      * An EventType that is used to indicate that an edit in a TreeView has been
 254      * committed. This means that user has made changes to the data of a
 255      * TreeItem, and that the UI should be updated.
 256      *
 257      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 258      * @return An EventType that is used to indicate that an edit in a TreeView
 259      *      has been committed.
 260      */
 261     @SuppressWarnings(&quot;unchecked&quot;)
 262     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editCommitEvent() {
 263         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_COMMIT_EVENT;
 264     }
 265     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 266             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 267 
 268     /**
 269      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 270      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 271      * can be recursively called. If the TreeItem does not have any parent set,
 272      * the returned value will be zero. For each time getParent() is recursively
 273      * called, the returned value is incremented by one.
 274      *
 275      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 276      * not consider the root node. This means that this method will iterate
 277      * past the root node of the TreeView control, if the root node has a parent.
 278      * If this is important, call {@link TreeView#getTreeItemLevel(TreeItem)}
 279      * instead.
 280      *
 281      * @param node The TreeItem for which the level is needed.
 282      * @return An integer representing the number of parents above the given node,
 283      *          or -1 if the given TreeItem is null.
 284      * @deprecated This method does not correctly calculate the distance from the
 285      *          given TreeItem to the root of the TreeView. As of JavaFX 8.0_20,
 286      *          the proper way to do this is via
 287      *          {@link TreeView#getTreeItemLevel(TreeItem)}
 288      */
 289     @Deprecated(since=&quot;8u20&quot;)
 290     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 291         if (node == null) return -1;
 292 
 293         int level = 0;
 294         TreeItem&lt;?&gt; parent = node.getParent();
 295         while (parent != null) {
 296             level++;
 297             parent = parent.getParent();
 298         }
 299 
 300         return level;
 301     }
 302 
 303 
 304     /***************************************************************************
 305      *                                                                         *
 306      * Constructors                                                            *
 307      *                                                                         *
 308      **************************************************************************/
 309 
 310     /**
 311      * Creates an empty TreeView.
 312      *
 313      * &lt;p&gt;Refer to the {@link TreeView} class documentation for details on the
 314      * default state of other properties.
 315      */
 316     public TreeView() {
 317         this(null);
 318     }
 319 
 320     /**
 321      * Creates a TreeView with the provided root node.
 322      *
 323      * &lt;p&gt;Refer to the {@link TreeView} class documentation for details on the
 324      * default state of other properties.
 325      *
 326      * @param root The node to be the root in this TreeView.
 327      */
 328     public TreeView(TreeItem&lt;T&gt; root) {
 329         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 330         setAccessibleRole(AccessibleRole.TREE_VIEW);
 331 
 332         setRoot(root);
 333         updateExpandedItemCount(root);
 334 
 335         // install default selection and focus models - it&#39;s unlikely this will be changed
 336         // by many users.
 337         MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = new TreeViewBitSetSelectionModel&lt;T&gt;(this);
 338         setSelectionModel(sm);
 339         setFocusModel(new TreeViewFocusModel&lt;T&gt;(this));
 340     }
 341 
 342 
 343 
 344     /***************************************************************************
 345      *                                                                         *
 346      * Instance Variables                                                      *
 347      *                                                                         *
 348      **************************************************************************/
 349 
 350     // used in the tree item modification event listener. Used by the
 351     // layoutChildren method to determine whether the tree item count should
 352     // be recalculated.
 353     private boolean expandedItemCountDirty = true;
 354 
 355     // Used in the getTreeItem(int row) method to act as a cache.
 356     // See RT-26716 for the justification and performance gains.
 357     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;T&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 358 
 359 
 360     /***************************************************************************
 361      *                                                                         *
 362      * Callbacks and Events                                                    *
 363      *                                                                         *
 364      **************************************************************************/
 365 
 366     // we use this to forward events that have bubbled up TreeItem instances
 367     // to the TreeViewSkin, to force it to recalculate teh item count and redraw
 368     // if necessary
 369     private final EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; rootEvent = e -&gt; {
 370         // this forces layoutChildren at the next pulse, and therefore
 371         // updates the item count if necessary
 372         EventType&lt;?&gt; eventType = e.getEventType();
 373         boolean match = false;
 374         while (eventType != null) {
 375             if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
 376                 match = true;
 377                 break;
 378             }
 379             eventType = eventType.getSuperType();
 380         }
 381 
 382         if (match) {
 383             expandedItemCountDirty = true;
 384             requestLayout();
 385         }
 386     };
 387 
 388     private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootEventListener;
 389 
 390 
 391 
 392     /***************************************************************************
 393      *                                                                         *
 394      * Properties                                                              *
 395      *                                                                         *
 396      **************************************************************************/
 397 
 398 
 399     // --- Cell Factory
 400     private ObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt; cellFactory;
 401 
 402     /**
 403      * Sets the cell factory that will be used for creating TreeCells,
 404      * which are used to represent items in the
 405      * TreeView. The factory works identically to the cellFactory in ListView
 406      * and other complex composite controls. It is called to create a new
 407      * TreeCell only when the system has determined that it doesn&#39;t have enough
 408      * cells to represent the currently visible items. The TreeCell is reused
 409      * by the system to represent different items in the tree when possible.
 410      *
 411      * &lt;p&gt;Refer to the {@link Cell} class documentation for more details.
 412      *
 413      * @param value The {@link Callback} to use for generating TreeCell instances,
 414      *      or null if the default cell factory should be used.
 415      */
 416     public final void setCellFactory(Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; value) {
 417         cellFactoryProperty().set(value);
 418     }
 419 
 420     /**
 421      * &lt;p&gt;Returns the cell factory that will be used for creating TreeCells,
 422      * which are used to represent items in the TreeView, or null if no custom
 423      * cell factory has been set.
 424      * @return the cell factory
 425      */
 426     public final Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; getCellFactory() {
 427         return cellFactory == null ? null : cellFactory.get();
 428     }
 429 
 430     /**
 431      * Represents the cell factory that will be used for creating TreeCells,
 432      * which are used to represent items in the TreeView.
 433      * @return the cell factory property
 434      */
 435     public final ObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt; cellFactoryProperty() {
 436         if (cellFactory == null) {
 437             cellFactory = new SimpleObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt;(this, &quot;cellFactory&quot;);
 438         }
 439         return cellFactory;
 440     }
 441 
 442 
 443     // --- Root
 444     private ObjectProperty&lt;TreeItem&lt;T&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;T&gt;&gt;(this, &quot;root&quot;) {
 445         private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakOldItem;
 446 
 447         @Override protected void invalidated() {
 448             TreeItem&lt;T&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 449             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 450                 oldTreeItem.removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootEventListener);
 451             }
 452 
 453             TreeItem&lt;T&gt; root = getRoot();
 454             if (root != null) {
 455                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 456                 getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootEventListener);
 457                 weakOldItem = new WeakReference&lt;&gt;(root);
 458             }
 459 
 460             // Fix for RT-37853
 461             edit(null);
 462 
 463             expandedItemCountDirty = true;
 464             updateRootExpanded();
 465         }
 466     };
 467 
 468     /**
 469      * Sets the root node in this TreeView. See the {@link TreeItem} class level
 470      * documentation for more details.
 471      *
 472      * @param value The {@link TreeItem} that will be placed at the root of the
 473      *      TreeView.
 474      */
 475     public final void setRoot(TreeItem&lt;T&gt; value) {
 476         rootProperty().set(value);
 477     }
 478 
 479     /**
 480      * Returns the current root node of this TreeView, or null if no root node
 481      * is specified.
 482      * @return The current root node, or null if no root node exists.
 483      */
 484     public final TreeItem&lt;T&gt; getRoot() {
 485         return root == null ? null : root.get();
 486     }
 487 
 488     /**
 489      * Property representing the root node of the TreeView.
 490      * @return the root node property
 491      */
 492     public final ObjectProperty&lt;TreeItem&lt;T&gt;&gt; rootProperty() {
 493         return root;
 494     }
 495 
 496 
 497 
 498     // --- Show Root
 499     private BooleanProperty showRoot;
 500 
 501     /**
 502      * Specifies whether the root {@code TreeItem} should be shown within this
 503      * TreeView.
 504      *
 505      * @param value If true, the root TreeItem will be shown, and if false it
 506      *      will be hidden.
 507      */
 508     public final void setShowRoot(boolean value) {
 509         showRootProperty().set(value);
 510     }
 511 
 512     /**
 513      * Returns true if the root of the TreeView should be shown, and false if
 514      * it should not. By default, the root TreeItem is visible in the TreeView.
 515      * @return true if the root of the TreeView should be shown
 516      */
 517     public final boolean isShowRoot() {
 518         return showRoot == null ? true : showRoot.get();
 519     }
 520 
 521     /**
 522      * Property that represents whether or not the TreeView root node is visible.
 523      * @return the show root property
 524      */
 525     public final BooleanProperty showRootProperty() {
 526         if (showRoot == null) {
 527             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 528                 @Override protected void invalidated() {
 529                     updateRootExpanded();
 530                     updateExpandedItemCount(getRoot());
 531                 }
 532             };
 533         }
 534         return showRoot;
 535     }
 536 
 537 
 538     // --- Selection Model
 539     private ObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; selectionModel;
 540 
 541     /**
 542      * Sets the {@link MultipleSelectionModel} to be used in the TreeView.
 543      * Despite a TreeView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
 544      * it is possible to configure it to only allow single selection (see
 545      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
 546      * for more information).
 547      * @param value the {@link MultipleSelectionModel} to be used
 548      */
 549     public final void setSelectionModel(MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; value) {
 550         selectionModelProperty().set(value);
 551     }
 552 
 553     /**
 554      * Returns the currently installed selection model.
 555      * @return the currently installed selection model
 556      */
 557     public final MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; getSelectionModel() {
 558         return selectionModel == null ? null : selectionModel.get();
 559     }
 560 
 561     /**
 562      * The SelectionModel provides the API through which it is possible
 563      * to select single or multiple items within a TreeView, as  well as inspect
 564      * which rows have been selected by the user. Note that it has a generic
 565      * type that must match the type of the TreeView itself.
 566      * @return the selection model property
 567      */
 568     public final ObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; selectionModelProperty() {
 569         if (selectionModel == null) {
 570             selectionModel = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt;(this, &quot;selectionModel&quot;);
 571         }
 572         return selectionModel;
 573     }
 574 
 575 
 576     // --- Focus Model
 577     private ObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; focusModel;
 578 
 579     /**
 580      * Sets the {@link FocusModel} to be used in the TreeView.
 581      * @param value the {@link FocusModel} to be used
 582      */
 583     public final void setFocusModel(FocusModel&lt;TreeItem&lt;T&gt;&gt; value) {
 584         focusModelProperty().set(value);
 585     }
 586 
 587     /**
 588      * Returns the currently installed {@link FocusModel}.
 589      * @return the currently installed {@link FocusModel}
 590      */
 591     public final FocusModel&lt;TreeItem&lt;T&gt;&gt; getFocusModel() {
 592         return focusModel == null ? null : focusModel.get();
 593     }
 594 
 595     /**
 596      * The FocusModel provides the API through which it is possible
 597      * to control focus on zero or one rows of the TreeView. Generally the
 598      * default implementation should be more than sufficient.
 599      * @return the focus model property
 600      */
 601     public final ObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; focusModelProperty() {
 602         if (focusModel == null) {
 603             focusModel = new SimpleObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt;(this, &quot;focusModel&quot;);
 604         }
 605         return focusModel;
 606     }
 607 
 608 
 609     // --- Expanded node count
 610     /**
 611      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
 612      * TreeView. This is essentially the count of all expanded tree items, and
 613      * their children.
 614      *
 615      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
 616      * be one. If the root had three children and the root was expanded, the value
 617      * will be four.
 618      * @since JavaFX 8.0
 619      */
 620     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
 621     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
 622         return expandedItemCount.getReadOnlyProperty();
 623     }
 624     private void setExpandedItemCount(int value) {
 625         expandedItemCount.set(value);
 626     }
 627     public final int getExpandedItemCount() {
 628         if (expandedItemCountDirty) {
 629             updateExpandedItemCount(getRoot());
 630         }
 631         return expandedItemCount.get();
 632     }
 633 
 634 
 635     // --- Fixed cell size
 636     private DoubleProperty fixedCellSize;
 637 
 638     /**
 639      * Sets the new fixed cell size for this control. Any value greater than
 640      * zero will enable fixed cell size mode, whereas a zero or negative value
 641      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
 642      * mode.
 643      *
 644      * @param value The new fixed cell size value, or a value less than or equal
 645      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
 646      * @since JavaFX 8.0
 647      */
 648     public final void setFixedCellSize(double value) {
 649         fixedCellSizeProperty().set(value);
 650     }
 651 
 652     /**
 653      * Returns the fixed cell size value. A value less than or equal to zero is
 654      * used to represent that fixed cell size mode is disabled, and a value
 655      * greater than zero represents the size of all cells in this control.
 656      *
 657      * @return A double representing the fixed cell size of this control, or a
 658      *      value less than or equal to zero if fixed cell size mode is disabled.
 659      * @since JavaFX 8.0
 660      */
 661     public final double getFixedCellSize() {
 662         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
 663     }
 664     /**
 665      * Specifies whether this control has cells that are a fixed height (of the
 666      * specified value). If this value is less than or equal to zero,
 667      * then all cells are individually sized and positioned. This is a slow
 668      * operation. Therefore, when performance matters and developers are not
 669      * dependent on variable cell sizes it is a good idea to set the fixed cell
 670      * size value. Generally cells are around 24px, so setting a fixed cell size
 671      * of 24 is likely to result in very little difference in visuals, but a
 672      * improvement to performance.
 673      *
 674      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
 675      * This should not be confused with the -fx-cell-size property. The difference
 676      * between these two CSS properties is that -fx-cell-size will size all
 677      * cells to the specified size, but it will not enforce that this is the
 678      * only size (thus allowing for variable cell sizes, and preventing the
 679      * performance gains from being possible). Therefore, when performance matters
 680      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
 681      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
 682      *
 683      * @return the fixed cell size property
 684      * @since JavaFX 8.0
 685      */
 686     public final DoubleProperty fixedCellSizeProperty() {
 687         if (fixedCellSize == null) {
 688             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
 689                 @Override public CssMetaData&lt;TreeView&lt;?&gt;,Number&gt; getCssMetaData() {
 690                     return StyleableProperties.FIXED_CELL_SIZE;
 691                 }
 692 
 693                 @Override public Object getBean() {
 694                     return TreeView.this;
 695                 }
 696 
 697                 @Override public String getName() {
 698                     return &quot;fixedCellSize&quot;;
 699                 }
 700             };
 701         }
 702         return fixedCellSize;
 703     }
 704 
 705 
 706     // --- Editable
 707     private BooleanProperty editable;
 708     public final void setEditable(boolean value) {
 709         editableProperty().set(value);
 710     }
 711     public final boolean isEditable() {
 712         return editable == null ? false : editable.get();
 713     }
 714     /**
 715      * Specifies whether this TreeView is editable - only if the TreeView and
 716      * the TreeCells within it are both editable will a TreeCell be able to go
 717      * into their editing state.
 718      * @return the editable property
 719      */
 720     public final BooleanProperty editableProperty() {
 721         if (editable == null) {
 722             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
 723         }
 724         return editable;
 725     }
 726 
 727 
 728     // --- Editing Item
 729     private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; editingItem;
 730 
 731     private void setEditingItem(TreeItem&lt;T&gt; value) {
 732         editingItemPropertyImpl().set(value);
 733     }
 734 
 735     /**
 736      * Returns the TreeItem that is currently being edited in the TreeView,
 737      * or null if no item is being edited.
 738      * @return the TreeItem that is currently being edited in the TreeView
 739      */
 740     public final TreeItem&lt;T&gt; getEditingItem() {
 741         return editingItem == null ? null : editingItem.get();
 742     }
 743 
 744     /**
 745      * &lt;p&gt;A property used to represent the TreeItem currently being edited
 746      * in the TreeView, if editing is taking place, or null if no item is being edited.
 747      *
 748      * &lt;p&gt;It is not possible to set the editing item, instead it is required that
 749      * you call {@link #edit(javafx.scene.control.TreeItem)}.
 750      * @return the editing item property
 751      */
 752     public final ReadOnlyObjectProperty&lt;TreeItem&lt;T&gt;&gt; editingItemProperty() {
 753         return editingItemPropertyImpl().getReadOnlyProperty();
 754     }
 755 
 756     private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; editingItemPropertyImpl() {
 757         if (editingItem == null) {
 758             editingItem = new ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt;(this, &quot;editingItem&quot;);
 759         }
 760         return editingItem;
 761     }
 762 
 763 
 764     // --- On Edit Start
 765     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditStart;
 766 
 767     /**
 768      * Sets the {@link EventHandler} that will be called when the user begins
 769      * an edit.
 770      * @param value the {@link EventHandler} that will be called when the user
 771      * begins an edit
 772      */
 773     public final void setOnEditStart(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 774         onEditStartProperty().set(value);
 775     }
 776 
 777     /**
 778      * Returns the {@link EventHandler} that will be called when the user begins
 779      * an edit.
 780      * @return the {@link EventHandler} when the user begins an edit
 781      */
 782     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditStart() {
 783         return onEditStart == null ? null : onEditStart.get();
 784     }
 785 
 786     /**
 787      * This event handler will be fired when the user successfully initiates
 788      * editing.
 789      * @return the event handler when the user successfully initiates editing
 790      */
 791     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditStartProperty() {
 792         if (onEditStart == null) {
 793             onEditStart = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditStart&quot;) {
 794                 @Override protected void invalidated() {
 795                     setEventHandler(TreeView.&lt;T&gt;editStartEvent(), get());
 796                 }
 797             };
 798         }
 799         return onEditStart;
 800     }
 801 
 802 
 803     // --- On Edit Commit
 804     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCommit;
 805 
 806     /**
 807      * Sets the {@link EventHandler} that will be called when the user commits
 808      * an edit.
 809      * @param value the {@link EventHandler} that will be called when the user
 810      * commits an edit
 811      */
 812     public final void setOnEditCommit(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 813         onEditCommitProperty().set(value);
 814     }
 815 
 816     /**
 817      * Returns the {@link EventHandler} that will be called when the user commits
 818      * an edit.
 819      * @return the {@link EventHandler} that will be called when the user commits
 820      * an edit
 821      */
 822     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditCommit() {
 823         return onEditCommit == null ? null : onEditCommit.get();
 824     }
 825 
 826     /**
 827      * &lt;p&gt;This property is used when the user performs an action that should
 828      * result in their editing input being persisted.&lt;/p&gt;
 829      *
 830      * &lt;p&gt;The EventHandler in this property should not be called directly -
 831      * instead call {@link TreeCell#commitEdit(java.lang.Object)} from within
 832      * your custom TreeCell. This will handle firing this event, updating the
 833      * view, and switching out of the editing state.&lt;/p&gt;
 834      * @return the event handler when the user performs an action that result in
 835      * their editing input being persisted
 836      */
 837     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCommitProperty() {
 838         if (onEditCommit == null) {
 839             onEditCommit = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditCommit&quot;) {
 840                 @Override protected void invalidated() {
 841                     setEventHandler(TreeView.&lt;T&gt;editCommitEvent(), get());
 842                 }
 843             };
 844         }
 845         return onEditCommit;
 846     }
 847 
 848 
 849     // --- On Edit Cancel
 850     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCancel;
 851 
 852     /**
 853      * Sets the {@link EventHandler} that will be called when the user cancels
 854      * an edit.
 855      * @param value the {@link EventHandler} that will be called when the user
 856      * cancels an edit
 857      */
 858     public final void setOnEditCancel(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 859         onEditCancelProperty().set(value);
 860     }
 861 
 862     /**
 863      * Returns the {@link EventHandler} that will be called when the user cancels
 864      * an edit.
 865      * @return the {@link EventHandler} that will be called when the user cancels
 866      * an edit
 867      */
 868     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditCancel() {
 869         return onEditCancel == null ? null : onEditCancel.get();
 870     }
 871 
 872     /**
 873      * This event handler will be fired when the user cancels editing a cell.
 874      * @return the event handler will be fired when the user cancels editing a
 875      * cell
 876      */
 877     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCancelProperty() {
 878         if (onEditCancel == null) {
 879             onEditCancel = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditCancel&quot;) {
 880                 @Override protected void invalidated() {
 881                     setEventHandler(TreeView.&lt;T&gt;editCancelEvent(), get());
 882                 }
 883             };
 884         }
 885         return onEditCancel;
 886     }
 887 
 888 
 889 
 890     /***************************************************************************
 891      *                                                                         *
 892      * Public API                                                              *
 893      *                                                                         *
 894      **************************************************************************/
 895 
 896 
 897     /** {@inheritDoc} */
 898     @Override protected void layoutChildren() {
 899         if (expandedItemCountDirty) {
 900             updateExpandedItemCount(getRoot());
 901         }
 902 
 903         super.layoutChildren();
 904     }
 905 
 906 
 907     /**
 908      * Instructs the TreeView to begin editing the given TreeItem, if
 909      * the TreeView is {@link #editableProperty() editable}. Once
 910      * this method is called, if the current
 911      * {@link #cellFactoryProperty() cell factory} is set up to support editing,
 912      * the Cell will switch its visual state to enable the user input to take place.
 913      *
 914      * @param item The TreeItem in the TreeView that should be edited.
 915      */
 916     public void edit(TreeItem&lt;T&gt; item) {
 917         if (!isEditable()) return;
 918         setEditingItem(item);
 919     }
 920 
 921 
 922     /**
 923      * Scrolls the TreeView such that the item in the given index is visible to
 924      * the end user.
 925      *
 926      * @param index The index that should be made visible to the user, assuming
 927      *      of course that it is greater than, or equal to 0, and less than the
 928      *      number of the visible items in the TreeView.
 929      */
 930     public void scrollTo(int index) {
 931         ControlUtils.scrollToIndex(this, index);
 932     }
 933 
 934     /**
 935      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
 936      * @since JavaFX 8.0
 937      */
 938     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
 939 
 940     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
 941         onScrollToProperty().set(value);
 942     }
 943 
 944     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
 945         if( onScrollTo != null ) {
 946             return onScrollTo.get();
 947         }
 948         return null;
 949     }
 950 
 951     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
 952         if( onScrollTo == null ) {
 953             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
 954                 @Override
 955                 protected void invalidated() {
 956                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
 957                 }
 958                 @Override
 959                 public Object getBean() {
 960                     return TreeView.this;
 961                 }
 962 
 963                 @Override
 964                 public String getName() {
 965                     return &quot;onScrollTo&quot;;
 966                 }
 967             };
 968         }
 969         return onScrollTo;
 970     }
 971 
 972     /**
 973      * Returns the index position of the given TreeItem, assuming that it is
 974      * currently accessible through the tree hierarchy (most notably, that all
 975      * parent tree items are expanded). If a parent tree item is collapsed,
 976      * the result is that this method will return -1 to indicate that the
 977      * given tree item is not accessible in the tree.
 978      *
 979      * @param item The TreeItem for which the index is sought.
 980      * @return An integer representing the location in the current TreeView of the
 981      *      first instance of the given TreeItem, or -1 if it is null or can not
 982      *      be found (for example, if a parent (all the way up to the root) is
 983      *      collapsed).
 984      */
 985     public int getRow(TreeItem&lt;T&gt; item) {
 986         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
 987     }
 988 
 989     /**
 990      * Returns the TreeItem in the given index, or null if it is out of bounds.
 991      *
 992      * @param row The index of the TreeItem being sought.
 993      * @return The TreeItem in the given index, or null if it is out of bounds.
 994      */
 995     public TreeItem&lt;T&gt; getTreeItem(int row) {
 996         if (row &lt; 0) return null;
 997 
 998         // normalize the requested row based on whether showRoot is set
 999         final int _row = isShowRoot() ? row : (row + 1);
1000 
1001         if (expandedItemCountDirty) {
1002             updateExpandedItemCount(getRoot());
1003         } else {
1004             if (treeItemCacheMap.containsKey(_row)) {
1005                 SoftReference&lt;TreeItem&lt;T&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1006                 TreeItem&lt;T&gt; treeItem = treeItemRef.get();
1007                 if (treeItem != null) {
1008                     return treeItem;
1009                 }
1010             }
1011         }
1012 
1013         TreeItem&lt;T&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1014         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1015         return treeItem;
1016     }
1017 
1018     /**
1019      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1020      * based on how many times getParent() can be recursively called. If the
1021      * given TreeItem is the root node of this TreeView, or if the TreeItem does
1022      * not have any parent set, the returned value will be zero. For each time
1023      * getParent() is recursively called, the returned value is incremented by one.
1024      *
1025      * @param node The TreeItem for which the level is needed.
1026      * @return An integer representing the number of parents above the given node,
1027      *         or -1 if the given TreeItem is null.
1028      */
1029     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1030         final TreeItem&lt;?&gt; root = getRoot();
1031 
1032         if (node == null) return -1;
1033         if (node == root) return 0;
1034 
1035         int level = 0;
1036         TreeItem&lt;?&gt; parent = node.getParent();
1037         while (parent != null) {
1038             level++;
1039 
1040             if (parent == root) {
1041                 break;
1042             }
1043 
1044             parent = parent.getParent();
1045         }
1046 
1047         return level;
1048     }
1049 
1050     /** {@inheritDoc} */
1051     @Override protected Skin&lt;?&gt; createDefaultSkin() {
1052         return new TreeViewSkin&lt;T&gt;(this);
1053     }
1054 
1055     /**
1056      * Calling {@code refresh()} forces the TreeView control to recreate and
1057      * repopulate the cells necessary to populate the visual bounds of the control.
1058      * In other words, this forces the TreeView to update what it is showing to
1059      * the user. This is useful in cases where the underlying data source has
1060      * changed in a way that is not observed by the TreeView itself.
1061      *
1062      * @since JavaFX 8u60
1063      */
1064     public void refresh() {
1065         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1066     }
1067 
1068 
1069 
1070     /***************************************************************************
1071      *                                                                         *
1072      * Private Implementation                                                  *
1073      *                                                                         *
1074      **************************************************************************/
1075 
1076     private void updateExpandedItemCount(TreeItem&lt;T&gt; treeItem) {
1077         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1078 
1079         if (expandedItemCountDirty) {
1080             // this is a very inefficient thing to do, but for now having a cache
1081             // is better than nothing at all...
1082             treeItemCacheMap.clear();
1083         }
1084 
1085         expandedItemCountDirty = false;
1086     }
1087 
1088     private void updateRootExpanded() {
1089         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1090         // it now so that something is shown.
1091         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1092             getRoot().setExpanded(true);
1093         }
1094     }
1095 
1096 
1097 
1098     /***************************************************************************
1099      *                                                                         *
1100      * Stylesheet Handling                                                     *
1101      *                                                                         *
1102      **************************************************************************/
1103 
1104     private static final String DEFAULT_STYLE_CLASS = &quot;tree-view&quot;;
1105 
1106     private static class StyleableProperties {
1107         private static final CssMetaData&lt;TreeView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
1108                 new CssMetaData&lt;TreeView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
1109                                                      SizeConverter.getInstance(),
1110                                                      Region.USE_COMPUTED_SIZE) {
1111 
1112                     @Override public Double getInitialValue(TreeView&lt;?&gt; node) {
1113                         return node.getFixedCellSize();
1114                     }
1115 
1116                     @Override public boolean isSettable(TreeView&lt;?&gt; n) {
1117                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
1118                     }
1119 
1120                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeView&lt;?&gt; n) {
1121                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
1122                     }
1123                 };
1124 
1125         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1126         static {
1127             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1128                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1129             styleables.add(FIXED_CELL_SIZE);
1130             STYLEABLES = Collections.unmodifiableList(styleables);
1131         }
1132     }
1133 
1134     /**
1135      * @return The CssMetaData associated with this class, which may include the
1136      * CssMetaData of its superclasses.
1137      * @since JavaFX 8.0
1138      */
1139     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1140         return StyleableProperties.STYLEABLES;
1141     }
1142 
1143     /**
1144      * {@inheritDoc}
1145      * @since JavaFX 8.0
1146      */
1147     @Override
1148     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1149         return getClassCssMetaData();
1150     }
1151 
1152 
1153 
1154     /***************************************************************************
1155      *                                                                         *
1156      * Accessibility handling                                                  *
1157      *                                                                         *
1158      **************************************************************************/
1159 
1160     /** {@inheritDoc} */
1161     @Override
1162     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1163         switch (attribute) {
1164             case MULTIPLE_SELECTION: {
1165                 MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSelectionModel();
1166                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
1167             }
1168             case ROW_COUNT: return getExpandedItemCount();
1169             default: return super.queryAccessibleAttribute(attribute, parameters);
1170         }
1171     }
1172 
1173 
1174 
1175     /***************************************************************************
1176      *                                                                         *
1177      * Support Interfaces                                                      *
1178      *                                                                         *
1179      **************************************************************************/
1180 
1181 
1182 
1183     /***************************************************************************
1184      *                                                                         *
1185      * Support Classes                                                         *
1186      *                                                                         *
1187      **************************************************************************/
1188 
1189 
1190     /**
1191      * An {@link Event} subclass used specifically in TreeView for representing
1192      * edit-related events. It provides additional API to easily access the
1193      * TreeItem that the edit event took place on, as well as the input provided
1194      * by the end user.
1195      *
1196      * @param &lt;T&gt; The type of the input, which is the same type as the TreeView
1197      *      itself.
1198      * @since JavaFX 2.0
1199      */
1200     public static class EditEvent&lt;T&gt; extends Event {
1201         private static final long serialVersionUID = -4437033058917528976L;
1202 
1203         /**
1204          * Common supertype for all edit event types.
1205          * @since JavaFX 8.0
1206          */
1207         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
1208 
1209         private final TreeView&lt;T&gt; source;
1210         private final T oldValue;
1211         private final T newValue;
1212         private transient final TreeItem&lt;T&gt; treeItem;
1213 
1214         /**
1215          * Creates a new EditEvent instance to represent an edit event. This
1216          * event is used for {@link #editStartEvent()},
1217          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
1218          * @param source the source
1219          * @param eventType the eventType
1220          * @param treeItem the treeItem
1221          * @param oldValue the oldValue
1222          * @param newValue the newValue
1223          */
1224         public EditEvent(TreeView&lt;T&gt; source,
1225                          EventType&lt;? extends EditEvent&gt; eventType,
1226                          TreeItem&lt;T&gt; treeItem, T oldValue, T newValue) {
1227             super(source, Event.NULL_SOURCE_TARGET, eventType);
1228             this.source = source;
1229             this.oldValue = oldValue;
1230             this.newValue = newValue;
1231             this.treeItem = treeItem;
1232         }
1233 
1234         /**
1235          * Returns the TreeView upon which the edit took place.
1236          */
1237         @Override public TreeView&lt;T&gt; getSource() {
1238             return source;
1239         }
1240 
1241         /**
1242          * Returns the {@link TreeItem} upon which the edit took place.
1243          * @return the {@link TreeItem} upon which the edit took place
1244          */
1245         public TreeItem&lt;T&gt; getTreeItem() {
1246             return treeItem;
1247         }
1248 
1249         /**
1250          * Returns the new value input into the TreeItem by the end user.
1251          * @return the new value input into the TreeItem by the end user
1252          */
1253         public T getNewValue() {
1254             return newValue;
1255         }
1256 
1257         /**
1258          * Returns the old value that existed in the TreeItem prior to the current
1259          * edit event.
1260          * @return the old value that existed in the TreeItem prior to the current
1261          * edit event
1262          */
1263         public T getOldValue() {
1264             return oldValue;
1265         }
1266     }
1267 
1268 
1269 
1270 
1271 
1272 
1273 
1274     // package for testing
1275     static class TreeViewBitSetSelectionModel&lt;T&gt; extends MultipleSelectionModelBase&lt;TreeItem&lt;T&gt;&gt; {
1276 
1277         /***********************************************************************
1278          *                                                                     *
1279          * Internal fields                                                     *
1280          *                                                                     *
1281          **********************************************************************/
1282 
1283         private TreeView&lt;T&gt; treeView = null;
1284 
1285 
1286 
1287         /***********************************************************************
1288          *                                                                     *
1289          * Constructors                                                        *
1290          *                                                                     *
1291          **********************************************************************/
1292 
1293         public TreeViewBitSetSelectionModel(final TreeView&lt;T&gt; treeView) {
1294             if (treeView == null) {
1295                 throw new IllegalArgumentException(&quot;TreeView can not be null&quot;);
1296             }
1297 
1298             this.treeView = treeView;
1299             this.treeView.rootProperty().addListener(weakRootPropertyListener);
1300             showRootListener = o -&gt; {
1301                 shiftSelection(0, treeView.isShowRoot() ? 1 : -1, null);
1302             };
1303             this.treeView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
1304 
1305             updateTreeEventListener(null, treeView.getRoot());
1306 
1307             updateDefaultSelection();
1308         }
1309 
1310         private void updateTreeEventListener(TreeItem&lt;T&gt; oldRoot, TreeItem&lt;T&gt; newRoot) {
1311             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
1312                 oldRoot.removeEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1313             }
1314 
1315             if (newRoot != null) {
1316                 //PENDING why create a new weak eventHandler?
1317                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
1318                 newRoot.addEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1319             }
1320         }
1321 
1322         private ChangeListener&lt;TreeItem&lt;T&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
1323             updateDefaultSelection();
1324             updateTreeEventListener(oldValue, newValue);
1325         };
1326 
1327         private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; treeItemListener = e -&gt; {
1328             if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
1329 
1330             final TreeItem&lt;T&gt; treeItem = e.getTreeItem();
1331             if (treeItem == null) return;
1332 
1333             treeView.expandedItemCountDirty = true;
1334 
1335             // we only shift selection from this row - everything before it
1336             // is safe. We might change this below based on certain criteria
1337             int startRow = treeView.getRow(treeItem);
1338 
1339             int shift = 0;
1340             ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
1341             if (change != null) {
1342                 change.next();
1343             }
1344 
1345             do {
1346                 final int addedSize = change == null ? 0 : change.getAddedSize();
1347                 final int removedSize = change == null ? 0 : change.getRemovedSize();
1348 
1349                 if (e.wasExpanded()) {
1350                     // need to shuffle selection by the number of visible children
1351                     shift += treeItem.getExpandedDescendentCount(false) - 1;
1352                     startRow++;
1353                 } else if (e.wasCollapsed()) {
1354                     // remove selection from any child treeItem, and also determine
1355                     // if any child item was selected (in which case the parent
1356                     // takes the selection on collapse)
1357                     treeItem.getExpandedDescendentCount(false);
1358                     final int count = treeItem.previousExpandedDescendentCount;
1359 
1360                     final int selectedIndex = getSelectedIndex();
1361                     final boolean wasPrimarySelectionInChild =
1362                             selectedIndex &gt;= (startRow + 1) &amp;&amp;
1363                                     selectedIndex &lt; (startRow + count);
1364 
1365                     boolean wasAnyChildSelected = false;
1366 
1367                     selectedIndices._beginChange();
1368                     final int from = startRow + 1;
1369                     final int to = startRow + count;
1370                     final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
1371                     for (int i = from; i &lt; to; i++) {
1372                         if (isSelected(i)) {
1373                             wasAnyChildSelected = true;
1374                             removed.add(i);
1375                         }
1376                     }
1377 
1378                     ControlUtils.reducingChange(selectedIndices, removed);
1379 
1380                     for (int index : removed) {
1381                         startAtomic();
1382                         clearSelection(index);
1383                         stopAtomic();
1384                     }
1385                     selectedIndices._endChange();
1386 
1387                     // put selection onto the newly-collapsed tree item
1388                     if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
1389                         select(startRow);
1390                     }
1391 
1392                     shift += -count + 1;
1393                     startRow++;
1394                 } else if (e.wasPermutated()) {
1395                     // no-op
1396                 } else if (e.wasAdded()) {
1397                     // shuffle selection by the number of added items
1398                     shift += treeItem.isExpanded() ? addedSize : 0;
1399 
1400                     // RT-32963: We were taking the startRow from the TreeItem
1401                     // in which the children were added, rather than from the
1402                     // actual position of the new child. This led to selection
1403                     // being moved off the parent TreeItem by mistake.
1404                     // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
1405                     // subsequently commented out due to RT-33894.
1406                     startRow = treeView.getRow(e.getChange().getAddedSubList().get(0));
1407                 } else if (e.wasRemoved()) {
1408                     // shuffle selection by the number of removed items
1409                     shift += treeItem.isExpanded() ? -removedSize : 0;
1410 
1411                     // the start row is incorrect - it is _not_ the index of the
1412                     // TreeItem in which the children were removed from (which is
1413                     // what it currently represents). We need to take the &#39;from&#39;
1414                     // value out of the event and make use of that to understand
1415                     // what actually changed inside the children list.
1416                     startRow += e.getFrom() + 1;
1417 
1418                     // whilst we are here, we should check if the removed items
1419                     // are part of the selectedItems list - and remove them
1420                     // from selection if they are (as per RT-15446)
1421                     final List&lt;Integer&gt; selectedIndices1 = getSelectedIndices();
1422                     final int selectedIndex = getSelectedIndex();
1423                     final List&lt;TreeItem&lt;T&gt;&gt; selectedItems = getSelectedItems();
1424                     final TreeItem&lt;T&gt; selectedItem = getSelectedItem();
1425                     final List&lt;? extends TreeItem&lt;T&gt;&gt; removedChildren = e.getChange().getRemoved();
1426 
1427                     for (int i = 0; i &lt; selectedIndices1.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
1428                         int index = selectedIndices1.get(i);
1429                         if (index &gt; selectedItems.size()) break;
1430 
1431                         if (removedChildren.size() == 1 &amp;&amp;
1432                                 selectedItems.size() == 1 &amp;&amp;
1433                                 selectedItem != null &amp;&amp;
1434                                 selectedItem.equals(removedChildren.get(0))) {
1435                             // Bug fix for RT-28637
1436                             if (selectedIndex &lt; getItemCount()) {
1437                                 final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
1438                                 TreeItem&lt;T&gt; newSelectedItem = getModelItem(previousRow);
1439                                 if (!selectedItem.equals(newSelectedItem)) {
1440                                     select(newSelectedItem);
1441                                 }
1442                             }
1443                         }
1444                     }
1445                 }
1446             } while (e.getChange() != null &amp;&amp; e.getChange().next());
1447 
1448             shiftSelection(startRow, shift, null);
1449 
1450             if (e.wasAdded() || e.wasRemoved()) {
1451                 Integer anchor = TreeCellBehavior.getAnchor(treeView, null);
1452                 if (anchor != null &amp;&amp; isSelected(anchor + shift)) {
1453                     TreeCellBehavior.setAnchor(treeView, anchor + shift, false);
1454                 }
1455             }
1456         };
1457 
1458         private WeakChangeListener&lt;TreeItem&lt;T&gt;&gt; weakRootPropertyListener =
1459                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
1460 
1461         private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakTreeItemListener;
1462 
1463         private InvalidationListener showRootListener;
1464 
1465 
1466         /***********************************************************************
1467          *                                                                     *
1468          * Public selection API                                                *
1469          *                                                                     *
1470          **********************************************************************/
1471 
1472         /** {@inheritDoc} */
1473         @Override public void selectAll() {
1474             // when a selectAll happens, the anchor should not change, so we store it
1475             // before, and restore it afterwards
1476             final int anchor = TreeCellBehavior.getAnchor(treeView, -1);
1477             super.selectAll();
1478             TreeCellBehavior.setAnchor(treeView, anchor, false);
1479         }
1480 
1481         /** {@inheritDoc} */
1482         @Override public void select(TreeItem&lt;T&gt; obj) {
1483 //        if (getRowCount() &lt;= 0) return;
1484 
1485             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
1486                 clearSelection();
1487                 return;
1488             }
1489 
1490             // we firstly expand the path down such that the given object is
1491             // visible. This fixes RT-14456, where selection was not happening
1492             // correctly on TreeItems that are not visible.
1493 
1494             if (obj != null) {
1495                 TreeItem&lt;?&gt; item = obj.getParent();
1496                 while (item != null) {
1497                     item.setExpanded(true);
1498                     item = item.getParent();
1499                 }
1500             }
1501 
1502             // Fix for RT-15419. We eagerly update the tree item count, such that
1503             // selection occurs on the row
1504             treeView.updateExpandedItemCount(treeView.getRoot());
1505 
1506             // We have no option but to iterate through the model and select the
1507             // first occurrence of the given object. Once we find the first one, we
1508             // don&#39;t proceed to select any others.
1509             int row = treeView.getRow(obj);
1510 
1511             if (row == -1) {
1512                 // if we are here, we did not find the item in the entire data model.
1513                 // Even still, we allow for this item to be set to the give object.
1514                 // We expect that in concrete subclasses of this class we observe the
1515                 // data model such that we check to see if the given item exists in it,
1516                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
1517                 setSelectedIndex(-1);
1518                 setSelectedItem(obj);
1519             } else {
1520                 select(row);
1521             }
1522         }
1523 
1524         /** {@inheritDoc} */
1525         @Override public void clearAndSelect(int row) {
1526             TreeCellBehavior.setAnchor(treeView, row, false);
1527             super.clearAndSelect(row);
1528         }
1529 
1530 
1531         /***********************************************************************
1532          *                                                                     *
1533          * Support code                                                        *
1534          *                                                                     *
1535          **********************************************************************/
1536 
1537         /** {@inheritDoc} */
1538         @Override protected void focus(int itemIndex) {
1539             if (treeView.getFocusModel() != null) {
1540                 treeView.getFocusModel().focus(itemIndex);
1541             }
1542 
1543             // FIXME this is not the correct location for fire selection events (and does not take into account multiple selection)
1544             treeView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1545         }
1546 
1547         /** {@inheritDoc} */
1548         @Override protected int getFocusedIndex() {
1549             if (treeView.getFocusModel() == null) return -1;
1550             return treeView.getFocusModel().getFocusedIndex();
1551         }
1552 
1553         /** {@inheritDoc} */
1554         @Override protected int getItemCount() {
1555             return treeView == null ? 0 : treeView.getExpandedItemCount();
1556         }
1557 
1558         /** {@inheritDoc} */
1559         @Override public TreeItem&lt;T&gt; getModelItem(int index) {
1560             if (treeView == null) return null;
1561 
1562             if (index &lt; 0 || index &gt;= treeView.getExpandedItemCount()) return null;
1563 
1564             return treeView.getTreeItem(index);
1565         }
1566 
1567 
1568 
1569         /***********************************************************************
1570          *                                                                     *
1571          * Private implementation                                              *
1572          *                                                                     *
1573          **********************************************************************/
1574 
1575         private void updateDefaultSelection() {
1576             clearSelection();
1577 
1578             // we put focus onto the first item, if there is at least
1579             // one item in the list
1580             focus(getItemCount() &gt; 0 ? 0 : -1);
1581         }
1582     }
1583 
1584 
1585 
1586     /**
1587      *
1588      * @param &lt;T&gt;
1589      */
1590     static class TreeViewFocusModel&lt;T&gt; extends FocusModel&lt;TreeItem&lt;T&gt;&gt; {
1591 
1592         private final TreeView&lt;T&gt; treeView;
1593 
1594         public TreeViewFocusModel(final TreeView&lt;T&gt; treeView) {
1595             this.treeView = treeView;
1596             this.treeView.rootProperty().addListener(weakRootPropertyListener);
1597             updateTreeEventListener(null, treeView.getRoot());
1598 
1599             if (treeView.getExpandedItemCount() &gt; 0) {
1600                 focus(0);
1601             }
1602 
1603             showRootListener = obs -&gt; {
1604                 if (isFocused(0)) {
1605                     focus(-1);
1606                     focus(0);
1607                 }
1608             };
1609             treeView.showRootProperty().addListener(new WeakInvalidationListener(showRootListener));
1610 
1611             focusedIndexProperty().addListener(o -&gt; {
1612                 treeView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1613             });
1614         }
1615 
1616         private final ChangeListener&lt;TreeItem&lt;T&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
1617             updateTreeEventListener(oldValue, newValue);
1618         };
1619 
1620         private final WeakChangeListener&lt;TreeItem&lt;T&gt;&gt; weakRootPropertyListener =
1621                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
1622 
1623         private final InvalidationListener showRootListener;
1624 
1625         private void updateTreeEventListener(TreeItem&lt;T&gt; oldRoot, TreeItem&lt;T&gt; newRoot) {
1626             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
1627                 oldRoot.removeEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1628             }
1629 
1630             if (newRoot != null) {
1631                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
1632                 newRoot.addEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1633             }
1634         }
1635 
1636         private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; treeItemListener = new EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt;() {
1637             @Override public void handle(TreeModificationEvent&lt;T&gt; e) {
1638                 // don&#39;t shift focus if the event occurred on a tree item after
1639                 // the focused row, or if there is no focus index at present
1640                 if (getFocusedIndex() == -1) return;
1641 
1642                 int row = treeView.getRow(e.getTreeItem());
1643 
1644                 int shift = 0;
1645                 if (e.getChange() != null) {
1646                     e.getChange().next();
1647                 }
1648 
1649                 do {
1650                     if (e.wasExpanded()) {
1651                         if (row &lt; getFocusedIndex()) {
1652                             // need to shuffle selection by the number of visible children
1653                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
1654                         }
1655                     } else if (e.wasCollapsed()) {
1656                         if (row &lt; getFocusedIndex()) {
1657                             // need to shuffle selection by the number of visible children
1658                             // that were just hidden
1659                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
1660                         }
1661                     } else if (e.wasAdded()) {
1662                         // get the TreeItem the event occurred on - we only need to
1663                         // shift if the tree item is expanded
1664                         TreeItem&lt;T&gt; eventTreeItem = e.getTreeItem();
1665                         if (eventTreeItem.isExpanded()) {
1666                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
1667                                 // get the added item and determine the row it is in
1668                                 TreeItem&lt;T&gt; item = e.getAddedChildren().get(i);
1669                                 row = treeView.getRow(item);
1670 
1671                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
1672                                     shift += item.getExpandedDescendentCount(false);
1673                                 }
1674                             }
1675                         }
1676                     } else if (e.wasRemoved()) {
1677                         row += e.getFrom() + 1;
1678 
1679                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
1680                             TreeItem&lt;T&gt; item = e.getRemovedChildren().get(i);
1681                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
1682                                 focus(Math.max(0, getFocusedIndex() - 1));
1683                                 return;
1684                             }
1685                         }
1686 
1687                         if (row &lt;= getFocusedIndex()) {
1688                             // shuffle selection by the number of removed items
1689                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
1690                         }
1691                     }
1692                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
1693 
1694                 if(shift != 0) {
1695                     final int newFocus = getFocusedIndex() + shift;
1696                     if (newFocus &gt;= 0) {
1697                         Platform.runLater(() -&gt; focus(newFocus));
1698                     }
1699                 }
1700             }
1701         };
1702 
1703         private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakTreeItemListener;
1704 
1705         @Override protected int getItemCount() {
1706             return treeView == null ? -1 : treeView.getExpandedItemCount();
1707         }
1708 
1709         @Override protected TreeItem&lt;T&gt; getModelItem(int index) {
1710             if (treeView == null) return null;
1711 
1712             if (index &lt; 0 || index &gt;= treeView.getExpandedItemCount()) return null;
1713 
1714             return treeView.getTreeItem(index);
1715         }
1716 
1717         /** {@inheritDoc} */
1718         @Override public void focus(int index) {
1719             if (treeView.expandedItemCountDirty) {
1720                 treeView.updateExpandedItemCount(treeView.getRoot());
1721             }
1722 
1723             super.focus(index);
1724         }
1725     }
1726 }
    </pre>
  </body>
</html>
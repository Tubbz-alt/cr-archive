<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.controls/src/main/java/javafx/scene/control/TreeView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control;
  27 
  28 import javafx.css.converter.SizeConverter;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.behavior.TreeCellBehavior;
  31 import javafx.scene.control.skin.TreeViewSkin;
  32 
  33 import javafx.application.Platform;
  34 import javafx.beans.DefaultProperty;
<a name="2" id="anc2"></a>

  35 import javafx.beans.property.BooleanProperty;
  36 import javafx.beans.property.DoubleProperty;
  37 import javafx.beans.property.ObjectProperty;
  38 import javafx.beans.property.ObjectPropertyBase;
  39 import javafx.beans.property.ReadOnlyIntegerProperty;
  40 import javafx.beans.property.ReadOnlyIntegerWrapper;
  41 import javafx.beans.property.ReadOnlyObjectProperty;
  42 import javafx.beans.property.ReadOnlyObjectWrapper;
  43 import javafx.beans.property.SimpleBooleanProperty;
  44 import javafx.beans.property.SimpleObjectProperty;
  45 import javafx.beans.value.ChangeListener;
  46 import javafx.beans.value.WeakChangeListener;
  47 import javafx.beans.value.WritableValue;
  48 import javafx.collections.ListChangeListener;
  49 import javafx.css.CssMetaData;
  50 import javafx.css.Styleable;
  51 import javafx.css.StyleableDoubleProperty;
  52 import javafx.css.StyleableProperty;
  53 import javafx.event.Event;
  54 import javafx.event.EventHandler;
  55 import javafx.event.EventType;
  56 import javafx.event.WeakEventHandler;
  57 import javafx.scene.AccessibleAttribute;
  58 import javafx.scene.AccessibleRole;
  59 import javafx.scene.control.TreeItem.TreeModificationEvent;
  60 import javafx.scene.layout.Region;
  61 import javafx.util.Callback;
  62 
  63 import java.lang.ref.SoftReference;
  64 import java.lang.ref.WeakReference;
  65 import java.util.ArrayList;
  66 import java.util.Collections;
  67 import java.util.HashMap;
  68 import java.util.List;
  69 import java.util.Map;
  70 
  71 /**
  72  * The TreeView control provides a view on to a tree root (of type
  73  * {@link TreeItem}). By using a TreeView, it is possible to drill down into the
  74  * children of a TreeItem, recursively until a TreeItem has no children (that is,
  75  * it is a &lt;i&gt;leaf&lt;/i&gt; node in the tree). To facilitate this, unlike controls
  76  * like {@link ListView}, in TreeView it is necessary to &lt;strong&gt;only&lt;/strong&gt;
  77  * specify the {@link #rootProperty() root} node.
  78  *
  79  * &lt;p&gt;
  80  * For more information on building up a tree using this approach, refer to the
  81  * {@link TreeItem} class documentation. Briefly however, to create a TreeView,
  82  * you should do something along the lines of the following:
  83  *
  84  * &lt;pre&gt;&lt;code&gt; TreeItem&amp;lt;String&amp;gt; root = new TreeItem&amp;lt;&amp;gt;(&quot;Root Node&quot;);
  85  * root.setExpanded(true);
  86  * root.getChildren().addAll(
  87  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 1&quot;),
  88  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 2&quot;),
  89  *     new TreeItem&amp;lt;&amp;gt;(&quot;Item 3&quot;)
  90  * );
  91  * TreeView&amp;lt;String&amp;gt; treeView = new TreeView&amp;lt;&amp;gt;(root);&lt;/code&gt;&lt;/pre&gt;
  92  *
  93  * &lt;img src=&quot;doc-files/TreeView.png&quot; alt=&quot;Image of the TreeView control&quot;&gt;
  94  *
  95  * &lt;p&gt;
  96  * A TreeView may be configured to optionally hide the root node by setting the
  97  * {@link #setShowRoot(boolean) showRoot} property to {@code false}. If the root
  98  * node is hidden, there is one less level of indentation, and all children
  99  * nodes of the root node are shown. By default, the root node is shown in the
 100  * TreeView.
 101  *
 102  * &lt;h2&gt;TreeView Selection / Focus APIs&lt;/h2&gt;
 103  * &lt;p&gt;To track selection and focus, it is necessary to become familiar with the
 104  * {@link SelectionModel} and {@link FocusModel} classes. A TreeView has at most
 105  * one instance of each of these classes, available from
 106  * {@link #selectionModelProperty() selectionModel} and
 107  * {@link #focusModelProperty() focusModel} properties respectively.
 108  * Whilst it is possible to use this API to set a new selection model, in
 109  * most circumstances this is not necessary - the default selection and focus
 110  * models should work in most circumstances.
 111  *
 112  * &lt;p&gt;The default {@link SelectionModel} used when instantiating a TreeView is
 113  * an implementation of the {@link MultipleSelectionModel} abstract class.
 114  * However, as noted in the API documentation for
 115  * the {@link MultipleSelectionModel#selectionModeProperty() selectionMode}
 116  * property, the default value is {@link SelectionMode#SINGLE}. To enable
 117  * multiple selection in a default TreeView instance, it is therefore necessary
 118  * to do the following:
 119  *
 120  * &lt;pre&gt; {@code treeView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);}&lt;/pre&gt;
 121  *
 122  * &lt;h2&gt;Customizing TreeView Visuals&lt;/h2&gt;
 123  * &lt;p&gt;The visuals of the TreeView can be entirely customized by replacing the
 124  * default {@link #cellFactoryProperty() cell factory}. A cell factory is used to
 125  * generate {@link TreeCell} instances, which are used to represent an item in the
 126  * TreeView. See the {@link Cell} class documentation for a more complete
 127  * description of how to write custom Cells.
 128  *
 129  * &lt;h2&gt;Editing&lt;/h2&gt;
 130  * &lt;p&gt;This control supports inline editing of values, and this section attempts to
 131  * give an overview of the available APIs and how you should use them.&lt;/p&gt;
 132  *
 133  * &lt;p&gt;Firstly, cell editing most commonly requires a different user interface
 134  * than when a cell is not being edited. This is the responsibility of the
 135  * {@link Cell} implementation being used. For TreeView, this is the responsibility
 136  * of the {@link #cellFactoryProperty() cell factory}. It is your choice whether the cell is
 137  * permanently in an editing state (e.g. this is common for {@link CheckBox} cells),
 138  * or to switch to a different UI when editing begins (e.g. when a double-click
 139  * is received on a cell).&lt;/p&gt;
 140  *
 141  * &lt;p&gt;To know when editing has been requested on a cell,
 142  * simply override the {@link javafx.scene.control.Cell#startEdit()} method, and
 143  * update the cell {@link javafx.scene.control.Cell#textProperty() text} and
 144  * {@link javafx.scene.control.Cell#graphicProperty() graphic} properties as
 145  * appropriate (e.g. set the text to null and set the graphic to be a
 146  * {@link TextField}). Additionally, you should also override
 147  * {@link Cell#cancelEdit()} to reset the UI back to its original visual state
 148  * when the editing concludes. In both cases it is important that you also
 149  * ensure that you call the super method to have the cell perform all duties it
 150  * must do to enter or exit its editing mode.&lt;/p&gt;
 151  *
 152  * &lt;p&gt;Once your cell is in an editing state, the next thing you are most probably
 153  * interested in is how to commit or cancel the editing that is taking place. This is your
 154  * responsibility as the cell factory provider. Your cell implementation will know
 155  * when the editing is over, based on the user input (e.g. when the user presses
 156  * the Enter or ESC keys on their keyboard). When this happens, it is your
 157  * responsibility to call {@link Cell#commitEdit(Object)} or
 158  * {@link Cell#cancelEdit()}, as appropriate.&lt;/p&gt;
 159  *
 160  * &lt;p&gt;When you call {@link Cell#commitEdit(Object)} an event is fired to the
 161  * TreeView, which you can observe by adding an {@link EventHandler} via
 162  * {@link TreeView#setOnEditCommit(javafx.event.EventHandler)}. Similarly,
 163  * you can also observe edit events for
 164  * {@link TreeView#setOnEditStart(javafx.event.EventHandler) edit start}
 165  * and {@link TreeView#setOnEditCancel(javafx.event.EventHandler) edit cancel}.&lt;/p&gt;
 166  *
 167  * &lt;p&gt;By default the TreeView edit commit handler is non-null, with a default
 168  * handler that attempts to overwrite the property value for the
 169  * item in the currently-being-edited row. It is able to do this as the
 170  * {@link Cell#commitEdit(Object)} method is passed in the new value, and this
 171  * is passed along to the edit commit handler via the
 172  * {@link EditEvent} that is fired. It is simply a matter of calling
 173  * {@link EditEvent#getNewValue()} to retrieve this value.
 174  *
 175  * &lt;p&gt;It is very important to note that if you call
 176  * {@link TreeView#setOnEditCommit(javafx.event.EventHandler)} with your own
 177  * {@link EventHandler}, then you will be removing the default handler. Unless
 178  * you then handle the writeback to the property (or the relevant data source),
 179  * nothing will happen. You can work around this by using the
 180  * {@link TreeView#addEventHandler(javafx.event.EventType, javafx.event.EventHandler)}
 181  * method to add a {@link TreeView#editCommitEvent()} {@link EventType} with
 182  * your desired {@link EventHandler} as the second argument. Using this method,
 183  * you will not replace the default implementation, but you will be notified when
 184  * an edit commit has occurred.&lt;/p&gt;
 185  *
 186  * &lt;p&gt;Hopefully this summary answers some of the commonly asked questions.
 187  * Fortunately, JavaFX ships with a number of pre-built cell factories that
 188  * handle all the editing requirements on your behalf. You can find these
 189  * pre-built cell factories in the javafx.scene.control.cell package.&lt;/p&gt;
 190  *
 191  * @see TreeItem
 192  * @see TreeCell
 193  * @param &lt;T&gt; The type of the item contained within the {@link TreeItem} value
 194  *      property for all tree items in this TreeView.
 195  * @since JavaFX 2.0
 196  */
 197 @DefaultProperty(&quot;root&quot;)
 198 public class TreeView&lt;T&gt; extends Control {
 199 
 200     /***************************************************************************
 201      *                                                                         *
 202      * Static properties and methods                                           *
 203      *                                                                         *
 204      **************************************************************************/
 205 
 206     /**
 207      * An EventType that indicates some edit event has occurred. It is the parent
 208      * type of all other edit events: {@link #editStartEvent()},
 209      *  {@link #editCommitEvent()} and {@link #editCancelEvent()}.
 210      *
 211      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 212      * @return An EventType that indicates some edit event has occurred.
 213      */
 214     @SuppressWarnings(&quot;unchecked&quot;)
 215     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editAnyEvent() {
 216         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_ANY_EVENT;
 217     }
 218     private static final EventType&lt;?&gt; EDIT_ANY_EVENT =
 219             new EventType&lt;&gt;(Event.ANY, &quot;TREE_VIEW_EDIT&quot;);
 220 
 221     /**
 222      * An EventType used to indicate that an edit event has started within the
 223      * TreeView upon which the event was fired.
 224      *
 225      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 226      * @return An EventType used to indicate that an edit event has started.
 227      */
 228     @SuppressWarnings(&quot;unchecked&quot;)
 229     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editStartEvent() {
 230         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_START_EVENT;
 231     }
 232     private static final EventType&lt;?&gt; EDIT_START_EVENT =
 233             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_START&quot;);
 234 
 235     /**
 236      * An EventType used to indicate that an edit event has just been canceled
 237      * within the TreeView upon which the event was fired.
 238      *
 239      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 240      * @return An EventType used to indicate that an edit event has just been
 241      *      canceled.
 242      */
 243     @SuppressWarnings(&quot;unchecked&quot;)
 244     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editCancelEvent() {
 245         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_CANCEL_EVENT;
 246     }
 247     private static final EventType&lt;?&gt; EDIT_CANCEL_EVENT =
 248             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_CANCEL&quot;);
 249 
 250     /**
 251      * An EventType that is used to indicate that an edit in a TreeView has been
 252      * committed. This means that user has made changes to the data of a
 253      * TreeItem, and that the UI should be updated.
 254      *
 255      * @param &lt;T&gt; the type of the TreeItem instances used in this TreeView
 256      * @return An EventType that is used to indicate that an edit in a TreeView
 257      *      has been committed.
 258      */
 259     @SuppressWarnings(&quot;unchecked&quot;)
 260     public static &lt;T&gt; EventType&lt;EditEvent&lt;T&gt;&gt; editCommitEvent() {
 261         return (EventType&lt;EditEvent&lt;T&gt;&gt;) EDIT_COMMIT_EVENT;
 262     }
 263     private static final EventType&lt;?&gt; EDIT_COMMIT_EVENT =
 264             new EventType&lt;&gt;(editAnyEvent(), &quot;EDIT_COMMIT&quot;);
 265 
 266     /**
 267      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
 268      * based on how many times {@link javafx.scene.control.TreeItem#getParent()}
 269      * can be recursively called. If the TreeItem does not have any parent set,
 270      * the returned value will be zero. For each time getParent() is recursively
 271      * called, the returned value is incremented by one.
 272      *
 273      * &lt;p&gt;&lt;strong&gt;Important note: &lt;/strong&gt;This method is deprecated as it does
 274      * not consider the root node. This means that this method will iterate
 275      * past the root node of the TreeView control, if the root node has a parent.
 276      * If this is important, call {@link TreeView#getTreeItemLevel(TreeItem)}
 277      * instead.
 278      *
 279      * @param node The TreeItem for which the level is needed.
 280      * @return An integer representing the number of parents above the given node,
 281      *          or -1 if the given TreeItem is null.
 282      * @deprecated This method does not correctly calculate the distance from the
 283      *          given TreeItem to the root of the TreeView. As of JavaFX 8.0_20,
 284      *          the proper way to do this is via
 285      *          {@link TreeView#getTreeItemLevel(TreeItem)}
 286      */
 287     @Deprecated(since=&quot;8u20&quot;)
 288     public static int getNodeLevel(TreeItem&lt;?&gt; node) {
 289         if (node == null) return -1;
 290 
 291         int level = 0;
 292         TreeItem&lt;?&gt; parent = node.getParent();
 293         while (parent != null) {
 294             level++;
 295             parent = parent.getParent();
 296         }
 297 
 298         return level;
 299     }
 300 
 301 
 302     /***************************************************************************
 303      *                                                                         *
 304      * Constructors                                                            *
 305      *                                                                         *
 306      **************************************************************************/
 307 
 308     /**
 309      * Creates an empty TreeView.
 310      *
 311      * &lt;p&gt;Refer to the {@link TreeView} class documentation for details on the
 312      * default state of other properties.
 313      */
 314     public TreeView() {
 315         this(null);
 316     }
 317 
 318     /**
 319      * Creates a TreeView with the provided root node.
 320      *
 321      * &lt;p&gt;Refer to the {@link TreeView} class documentation for details on the
 322      * default state of other properties.
 323      *
 324      * @param root The node to be the root in this TreeView.
 325      */
 326     public TreeView(TreeItem&lt;T&gt; root) {
 327         getStyleClass().setAll(DEFAULT_STYLE_CLASS);
 328         setAccessibleRole(AccessibleRole.TREE_VIEW);
 329 
 330         setRoot(root);
 331         updateExpandedItemCount(root);
 332 
 333         // install default selection and focus models - it&#39;s unlikely this will be changed
 334         // by many users.
 335         MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = new TreeViewBitSetSelectionModel&lt;T&gt;(this);
 336         setSelectionModel(sm);
 337         setFocusModel(new TreeViewFocusModel&lt;T&gt;(this));
 338     }
 339 
 340 
 341 
 342     /***************************************************************************
 343      *                                                                         *
 344      * Instance Variables                                                      *
 345      *                                                                         *
 346      **************************************************************************/
 347 
 348     // used in the tree item modification event listener. Used by the
 349     // layoutChildren method to determine whether the tree item count should
 350     // be recalculated.
 351     private boolean expandedItemCountDirty = true;
 352 
 353     // Used in the getTreeItem(int row) method to act as a cache.
 354     // See RT-26716 for the justification and performance gains.
 355     private Map&lt;Integer, SoftReference&lt;TreeItem&lt;T&gt;&gt;&gt; treeItemCacheMap = new HashMap&lt;&gt;();
 356 
 357 
 358     /***************************************************************************
 359      *                                                                         *
 360      * Callbacks and Events                                                    *
 361      *                                                                         *
 362      **************************************************************************/
 363 
 364     // we use this to forward events that have bubbled up TreeItem instances
 365     // to the TreeViewSkin, to force it to recalculate teh item count and redraw
 366     // if necessary
 367     private final EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; rootEvent = e -&gt; {
 368         // this forces layoutChildren at the next pulse, and therefore
 369         // updates the item count if necessary
 370         EventType&lt;?&gt; eventType = e.getEventType();
 371         boolean match = false;
 372         while (eventType != null) {
 373             if (eventType.equals(TreeItem.&lt;T&gt;expandedItemCountChangeEvent())) {
 374                 match = true;
 375                 break;
 376             }
 377             eventType = eventType.getSuperType();
 378         }
 379 
 380         if (match) {
 381             expandedItemCountDirty = true;
 382             requestLayout();
 383         }
 384     };
 385 
 386     private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakRootEventListener;
 387 
 388 
 389 
 390     /***************************************************************************
 391      *                                                                         *
 392      * Properties                                                              *
 393      *                                                                         *
 394      **************************************************************************/
 395 
 396 
 397     // --- Cell Factory
 398     private ObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt; cellFactory;
 399 
 400     /**
 401      * Sets the cell factory that will be used for creating TreeCells,
 402      * which are used to represent items in the
 403      * TreeView. The factory works identically to the cellFactory in ListView
 404      * and other complex composite controls. It is called to create a new
 405      * TreeCell only when the system has determined that it doesn&#39;t have enough
 406      * cells to represent the currently visible items. The TreeCell is reused
 407      * by the system to represent different items in the tree when possible.
 408      *
 409      * &lt;p&gt;Refer to the {@link Cell} class documentation for more details.
 410      *
 411      * @param value The {@link Callback} to use for generating TreeCell instances,
 412      *      or null if the default cell factory should be used.
 413      */
 414     public final void setCellFactory(Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; value) {
 415         cellFactoryProperty().set(value);
 416     }
 417 
 418     /**
 419      * &lt;p&gt;Returns the cell factory that will be used for creating TreeCells,
 420      * which are used to represent items in the TreeView, or null if no custom
 421      * cell factory has been set.
 422      * @return the cell factory
 423      */
 424     public final Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt; getCellFactory() {
 425         return cellFactory == null ? null : cellFactory.get();
 426     }
 427 
 428     /**
 429      * Represents the cell factory that will be used for creating TreeCells,
 430      * which are used to represent items in the TreeView.
 431      * @return the cell factory property
 432      */
 433     public final ObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt; cellFactoryProperty() {
 434         if (cellFactory == null) {
 435             cellFactory = new SimpleObjectProperty&lt;Callback&lt;TreeView&lt;T&gt;, TreeCell&lt;T&gt;&gt;&gt;(this, &quot;cellFactory&quot;);
 436         }
 437         return cellFactory;
 438     }
 439 
 440 
 441     // --- Root
 442     private ObjectProperty&lt;TreeItem&lt;T&gt;&gt; root = new SimpleObjectProperty&lt;TreeItem&lt;T&gt;&gt;(this, &quot;root&quot;) {
 443         private WeakReference&lt;TreeItem&lt;T&gt;&gt; weakOldItem;
 444 
 445         @Override protected void invalidated() {
 446             TreeItem&lt;T&gt; oldTreeItem = weakOldItem == null ? null : weakOldItem.get();
 447             if (oldTreeItem != null &amp;&amp; weakRootEventListener != null) {
 448                 oldTreeItem.removeEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootEventListener);
 449             }
 450 
 451             TreeItem&lt;T&gt; root = getRoot();
 452             if (root != null) {
 453                 weakRootEventListener = new WeakEventHandler&lt;&gt;(rootEvent);
 454                 getRoot().addEventHandler(TreeItem.&lt;T&gt;treeNotificationEvent(), weakRootEventListener);
 455                 weakOldItem = new WeakReference&lt;&gt;(root);
 456             }
 457 
 458             // Fix for RT-37853
 459             edit(null);
 460 
 461             expandedItemCountDirty = true;
 462             updateRootExpanded();
 463         }
 464     };
 465 
 466     /**
 467      * Sets the root node in this TreeView. See the {@link TreeItem} class level
 468      * documentation for more details.
 469      *
 470      * @param value The {@link TreeItem} that will be placed at the root of the
 471      *      TreeView.
 472      */
 473     public final void setRoot(TreeItem&lt;T&gt; value) {
 474         rootProperty().set(value);
 475     }
 476 
 477     /**
 478      * Returns the current root node of this TreeView, or null if no root node
 479      * is specified.
 480      * @return The current root node, or null if no root node exists.
 481      */
 482     public final TreeItem&lt;T&gt; getRoot() {
 483         return root == null ? null : root.get();
 484     }
 485 
 486     /**
 487      * Property representing the root node of the TreeView.
 488      * @return the root node property
 489      */
 490     public final ObjectProperty&lt;TreeItem&lt;T&gt;&gt; rootProperty() {
 491         return root;
 492     }
 493 
 494 
 495 
 496     // --- Show Root
 497     private BooleanProperty showRoot;
 498 
 499     /**
 500      * Specifies whether the root {@code TreeItem} should be shown within this
 501      * TreeView.
 502      *
 503      * @param value If true, the root TreeItem will be shown, and if false it
 504      *      will be hidden.
 505      */
 506     public final void setShowRoot(boolean value) {
 507         showRootProperty().set(value);
 508     }
 509 
 510     /**
 511      * Returns true if the root of the TreeView should be shown, and false if
 512      * it should not. By default, the root TreeItem is visible in the TreeView.
 513      * @return true if the root of the TreeView should be shown
 514      */
 515     public final boolean isShowRoot() {
 516         return showRoot == null ? true : showRoot.get();
 517     }
 518 
 519     /**
 520      * Property that represents whether or not the TreeView root node is visible.
 521      * @return the show root property
 522      */
 523     public final BooleanProperty showRootProperty() {
 524         if (showRoot == null) {
 525             showRoot = new SimpleBooleanProperty(this, &quot;showRoot&quot;, true) {
 526                 @Override protected void invalidated() {
 527                     updateRootExpanded();
 528                     updateExpandedItemCount(getRoot());
 529                 }
 530             };
 531         }
 532         return showRoot;
 533     }
 534 
 535 
 536     // --- Selection Model
 537     private ObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; selectionModel;
 538 
 539     /**
 540      * Sets the {@link MultipleSelectionModel} to be used in the TreeView.
 541      * Despite a TreeView requiring a &lt;code&gt;&lt;b&gt;Multiple&lt;/b&gt;SelectionModel&lt;/code&gt;,
 542      * it is possible to configure it to only allow single selection (see
 543      * {@link MultipleSelectionModel#setSelectionMode(javafx.scene.control.SelectionMode)}
 544      * for more information).
 545      * @param value the {@link MultipleSelectionModel} to be used
 546      */
 547     public final void setSelectionModel(MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; value) {
 548         selectionModelProperty().set(value);
 549     }
 550 
 551     /**
 552      * Returns the currently installed selection model.
 553      * @return the currently installed selection model
 554      */
 555     public final MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; getSelectionModel() {
 556         return selectionModel == null ? null : selectionModel.get();
 557     }
 558 
 559     /**
 560      * The SelectionModel provides the API through which it is possible
 561      * to select single or multiple items within a TreeView, as  well as inspect
 562      * which rows have been selected by the user. Note that it has a generic
 563      * type that must match the type of the TreeView itself.
 564      * @return the selection model property
 565      */
 566     public final ObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt; selectionModelProperty() {
 567         if (selectionModel == null) {
 568             selectionModel = new SimpleObjectProperty&lt;MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt;&gt;(this, &quot;selectionModel&quot;);
 569         }
 570         return selectionModel;
 571     }
 572 
 573 
 574     // --- Focus Model
 575     private ObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; focusModel;
 576 
 577     /**
 578      * Sets the {@link FocusModel} to be used in the TreeView.
 579      * @param value the {@link FocusModel} to be used
 580      */
 581     public final void setFocusModel(FocusModel&lt;TreeItem&lt;T&gt;&gt; value) {
 582         focusModelProperty().set(value);
 583     }
 584 
 585     /**
 586      * Returns the currently installed {@link FocusModel}.
 587      * @return the currently installed {@link FocusModel}
 588      */
 589     public final FocusModel&lt;TreeItem&lt;T&gt;&gt; getFocusModel() {
 590         return focusModel == null ? null : focusModel.get();
 591     }
 592 
 593     /**
 594      * The FocusModel provides the API through which it is possible
 595      * to control focus on zero or one rows of the TreeView. Generally the
 596      * default implementation should be more than sufficient.
 597      * @return the focus model property
 598      */
 599     public final ObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt; focusModelProperty() {
 600         if (focusModel == null) {
 601             focusModel = new SimpleObjectProperty&lt;FocusModel&lt;TreeItem&lt;T&gt;&gt;&gt;(this, &quot;focusModel&quot;);
 602         }
 603         return focusModel;
 604     }
 605 
 606 
 607     // --- Expanded node count
 608     /**
 609      * &lt;p&gt;Represents the number of tree nodes presently able to be visible in the
 610      * TreeView. This is essentially the count of all expanded tree items, and
 611      * their children.
 612      *
 613      * &lt;p&gt;For example, if just the root node is visible, the expandedItemCount will
 614      * be one. If the root had three children and the root was expanded, the value
 615      * will be four.
 616      * @since JavaFX 8.0
 617      */
 618     private ReadOnlyIntegerWrapper expandedItemCount = new ReadOnlyIntegerWrapper(this, &quot;expandedItemCount&quot;, 0);
 619     public final ReadOnlyIntegerProperty expandedItemCountProperty() {
 620         return expandedItemCount.getReadOnlyProperty();
 621     }
 622     private void setExpandedItemCount(int value) {
 623         expandedItemCount.set(value);
 624     }
 625     public final int getExpandedItemCount() {
 626         if (expandedItemCountDirty) {
 627             updateExpandedItemCount(getRoot());
 628         }
 629         return expandedItemCount.get();
 630     }
 631 
 632 
 633     // --- Fixed cell size
 634     private DoubleProperty fixedCellSize;
 635 
 636     /**
 637      * Sets the new fixed cell size for this control. Any value greater than
 638      * zero will enable fixed cell size mode, whereas a zero or negative value
 639      * (or Region.USE_COMPUTED_SIZE) will be used to disabled fixed cell size
 640      * mode.
 641      *
 642      * @param value The new fixed cell size value, or a value less than or equal
 643      *              to zero (or Region.USE_COMPUTED_SIZE) to disable.
 644      * @since JavaFX 8.0
 645      */
 646     public final void setFixedCellSize(double value) {
 647         fixedCellSizeProperty().set(value);
 648     }
 649 
 650     /**
 651      * Returns the fixed cell size value. A value less than or equal to zero is
 652      * used to represent that fixed cell size mode is disabled, and a value
 653      * greater than zero represents the size of all cells in this control.
 654      *
 655      * @return A double representing the fixed cell size of this control, or a
 656      *      value less than or equal to zero if fixed cell size mode is disabled.
 657      * @since JavaFX 8.0
 658      */
 659     public final double getFixedCellSize() {
 660         return fixedCellSize == null ? Region.USE_COMPUTED_SIZE : fixedCellSize.get();
 661     }
 662     /**
 663      * Specifies whether this control has cells that are a fixed height (of the
 664      * specified value). If this value is less than or equal to zero,
 665      * then all cells are individually sized and positioned. This is a slow
 666      * operation. Therefore, when performance matters and developers are not
 667      * dependent on variable cell sizes it is a good idea to set the fixed cell
 668      * size value. Generally cells are around 24px, so setting a fixed cell size
 669      * of 24 is likely to result in very little difference in visuals, but a
 670      * improvement to performance.
 671      *
 672      * &lt;p&gt;To set this property via CSS, use the -fx-fixed-cell-size property.
 673      * This should not be confused with the -fx-cell-size property. The difference
 674      * between these two CSS properties is that -fx-cell-size will size all
 675      * cells to the specified size, but it will not enforce that this is the
 676      * only size (thus allowing for variable cell sizes, and preventing the
 677      * performance gains from being possible). Therefore, when performance matters
 678      * use -fx-fixed-cell-size, instead of -fx-cell-size. If both properties are
 679      * specified in CSS, -fx-fixed-cell-size takes precedence.&lt;/p&gt;
 680      *
 681      * @return the fixed cell size property
 682      * @since JavaFX 8.0
 683      */
 684     public final DoubleProperty fixedCellSizeProperty() {
 685         if (fixedCellSize == null) {
 686             fixedCellSize = new StyleableDoubleProperty(Region.USE_COMPUTED_SIZE) {
 687                 @Override public CssMetaData&lt;TreeView&lt;?&gt;,Number&gt; getCssMetaData() {
 688                     return StyleableProperties.FIXED_CELL_SIZE;
 689                 }
 690 
 691                 @Override public Object getBean() {
 692                     return TreeView.this;
 693                 }
 694 
 695                 @Override public String getName() {
 696                     return &quot;fixedCellSize&quot;;
 697                 }
 698             };
 699         }
 700         return fixedCellSize;
 701     }
 702 
 703 
 704     // --- Editable
 705     private BooleanProperty editable;
 706     public final void setEditable(boolean value) {
 707         editableProperty().set(value);
 708     }
 709     public final boolean isEditable() {
 710         return editable == null ? false : editable.get();
 711     }
 712     /**
 713      * Specifies whether this TreeView is editable - only if the TreeView and
 714      * the TreeCells within it are both editable will a TreeCell be able to go
 715      * into their editing state.
 716      * @return the editable property
 717      */
 718     public final BooleanProperty editableProperty() {
 719         if (editable == null) {
 720             editable = new SimpleBooleanProperty(this, &quot;editable&quot;, false);
 721         }
 722         return editable;
 723     }
 724 
 725 
 726     // --- Editing Item
 727     private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; editingItem;
 728 
 729     private void setEditingItem(TreeItem&lt;T&gt; value) {
 730         editingItemPropertyImpl().set(value);
 731     }
 732 
 733     /**
 734      * Returns the TreeItem that is currently being edited in the TreeView,
 735      * or null if no item is being edited.
 736      * @return the TreeItem that is currently being edited in the TreeView
 737      */
 738     public final TreeItem&lt;T&gt; getEditingItem() {
 739         return editingItem == null ? null : editingItem.get();
 740     }
 741 
 742     /**
 743      * &lt;p&gt;A property used to represent the TreeItem currently being edited
 744      * in the TreeView, if editing is taking place, or null if no item is being edited.
 745      *
 746      * &lt;p&gt;It is not possible to set the editing item, instead it is required that
 747      * you call {@link #edit(javafx.scene.control.TreeItem)}.
 748      * @return the editing item property
 749      */
 750     public final ReadOnlyObjectProperty&lt;TreeItem&lt;T&gt;&gt; editingItemProperty() {
 751         return editingItemPropertyImpl().getReadOnlyProperty();
 752     }
 753 
 754     private ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt; editingItemPropertyImpl() {
 755         if (editingItem == null) {
 756             editingItem = new ReadOnlyObjectWrapper&lt;TreeItem&lt;T&gt;&gt;(this, &quot;editingItem&quot;);
 757         }
 758         return editingItem;
 759     }
 760 
 761 
 762     // --- On Edit Start
 763     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditStart;
 764 
 765     /**
 766      * Sets the {@link EventHandler} that will be called when the user begins
 767      * an edit.
 768      * @param value the {@link EventHandler} that will be called when the user
 769      * begins an edit
 770      */
 771     public final void setOnEditStart(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 772         onEditStartProperty().set(value);
 773     }
 774 
 775     /**
 776      * Returns the {@link EventHandler} that will be called when the user begins
 777      * an edit.
 778      * @return the {@link EventHandler} when the user begins an edit
 779      */
 780     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditStart() {
 781         return onEditStart == null ? null : onEditStart.get();
 782     }
 783 
 784     /**
 785      * This event handler will be fired when the user successfully initiates
 786      * editing.
 787      * @return the event handler when the user successfully initiates editing
 788      */
 789     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditStartProperty() {
 790         if (onEditStart == null) {
 791             onEditStart = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditStart&quot;) {
 792                 @Override protected void invalidated() {
 793                     setEventHandler(TreeView.&lt;T&gt;editStartEvent(), get());
 794                 }
 795             };
 796         }
 797         return onEditStart;
 798     }
 799 
 800 
 801     // --- On Edit Commit
 802     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCommit;
 803 
 804     /**
 805      * Sets the {@link EventHandler} that will be called when the user commits
 806      * an edit.
 807      * @param value the {@link EventHandler} that will be called when the user
 808      * commits an edit
 809      */
 810     public final void setOnEditCommit(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 811         onEditCommitProperty().set(value);
 812     }
 813 
 814     /**
 815      * Returns the {@link EventHandler} that will be called when the user commits
 816      * an edit.
 817      * @return the {@link EventHandler} that will be called when the user commits
 818      * an edit
 819      */
 820     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditCommit() {
 821         return onEditCommit == null ? null : onEditCommit.get();
 822     }
 823 
 824     /**
 825      * &lt;p&gt;This property is used when the user performs an action that should
 826      * result in their editing input being persisted.&lt;/p&gt;
 827      *
 828      * &lt;p&gt;The EventHandler in this property should not be called directly -
 829      * instead call {@link TreeCell#commitEdit(java.lang.Object)} from within
 830      * your custom TreeCell. This will handle firing this event, updating the
 831      * view, and switching out of the editing state.&lt;/p&gt;
 832      * @return the event handler when the user performs an action that result in
 833      * their editing input being persisted
 834      */
 835     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCommitProperty() {
 836         if (onEditCommit == null) {
 837             onEditCommit = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditCommit&quot;) {
 838                 @Override protected void invalidated() {
 839                     setEventHandler(TreeView.&lt;T&gt;editCommitEvent(), get());
 840                 }
 841             };
 842         }
 843         return onEditCommit;
 844     }
 845 
 846 
 847     // --- On Edit Cancel
 848     private ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCancel;
 849 
 850     /**
 851      * Sets the {@link EventHandler} that will be called when the user cancels
 852      * an edit.
 853      * @param value the {@link EventHandler} that will be called when the user
 854      * cancels an edit
 855      */
 856     public final void setOnEditCancel(EventHandler&lt;EditEvent&lt;T&gt;&gt; value) {
 857         onEditCancelProperty().set(value);
 858     }
 859 
 860     /**
 861      * Returns the {@link EventHandler} that will be called when the user cancels
 862      * an edit.
 863      * @return the {@link EventHandler} that will be called when the user cancels
 864      * an edit
 865      */
 866     public final EventHandler&lt;EditEvent&lt;T&gt;&gt; getOnEditCancel() {
 867         return onEditCancel == null ? null : onEditCancel.get();
 868     }
 869 
 870     /**
 871      * This event handler will be fired when the user cancels editing a cell.
 872      * @return the event handler will be fired when the user cancels editing a
 873      * cell
 874      */
 875     public final ObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt; onEditCancelProperty() {
 876         if (onEditCancel == null) {
 877             onEditCancel = new SimpleObjectProperty&lt;EventHandler&lt;EditEvent&lt;T&gt;&gt;&gt;(this, &quot;onEditCancel&quot;) {
 878                 @Override protected void invalidated() {
 879                     setEventHandler(TreeView.&lt;T&gt;editCancelEvent(), get());
 880                 }
 881             };
 882         }
 883         return onEditCancel;
 884     }
 885 
 886 
 887 
 888     /***************************************************************************
 889      *                                                                         *
 890      * Public API                                                              *
 891      *                                                                         *
 892      **************************************************************************/
 893 
 894 
 895     /** {@inheritDoc} */
 896     @Override protected void layoutChildren() {
 897         if (expandedItemCountDirty) {
 898             updateExpandedItemCount(getRoot());
 899         }
 900 
 901         super.layoutChildren();
 902     }
 903 
 904 
 905     /**
 906      * Instructs the TreeView to begin editing the given TreeItem, if
 907      * the TreeView is {@link #editableProperty() editable}. Once
 908      * this method is called, if the current
 909      * {@link #cellFactoryProperty() cell factory} is set up to support editing,
 910      * the Cell will switch its visual state to enable the user input to take place.
 911      *
 912      * @param item The TreeItem in the TreeView that should be edited.
 913      */
 914     public void edit(TreeItem&lt;T&gt; item) {
 915         if (!isEditable()) return;
 916         setEditingItem(item);
 917     }
 918 
 919 
 920     /**
 921      * Scrolls the TreeView such that the item in the given index is visible to
 922      * the end user.
 923      *
 924      * @param index The index that should be made visible to the user, assuming
 925      *      of course that it is greater than, or equal to 0, and less than the
 926      *      number of the visible items in the TreeView.
 927      */
 928     public void scrollTo(int index) {
 929         ControlUtils.scrollToIndex(this, index);
 930     }
 931 
 932     /**
 933      * Called when there&#39;s a request to scroll an index into view using {@link #scrollTo(int)}
 934      * @since JavaFX 8.0
 935      */
 936     private ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollTo;
 937 
 938     public void setOnScrollTo(EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; value) {
 939         onScrollToProperty().set(value);
 940     }
 941 
 942     public EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt; getOnScrollTo() {
 943         if( onScrollTo != null ) {
 944             return onScrollTo.get();
 945         }
 946         return null;
 947     }
 948 
 949     public ObjectProperty&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt; onScrollToProperty() {
 950         if( onScrollTo == null ) {
 951             onScrollTo = new ObjectPropertyBase&lt;EventHandler&lt;ScrollToEvent&lt;Integer&gt;&gt;&gt;() {
 952                 @Override
 953                 protected void invalidated() {
 954                     setEventHandler(ScrollToEvent.scrollToTopIndex(), get());
 955                 }
 956                 @Override
 957                 public Object getBean() {
 958                     return TreeView.this;
 959                 }
 960 
 961                 @Override
 962                 public String getName() {
 963                     return &quot;onScrollTo&quot;;
 964                 }
 965             };
 966         }
 967         return onScrollTo;
 968     }
 969 
 970     /**
 971      * Returns the index position of the given TreeItem, assuming that it is
 972      * currently accessible through the tree hierarchy (most notably, that all
 973      * parent tree items are expanded). If a parent tree item is collapsed,
 974      * the result is that this method will return -1 to indicate that the
 975      * given tree item is not accessible in the tree.
 976      *
 977      * @param item The TreeItem for which the index is sought.
 978      * @return An integer representing the location in the current TreeView of the
 979      *      first instance of the given TreeItem, or -1 if it is null or can not
 980      *      be found (for example, if a parent (all the way up to the root) is
 981      *      collapsed).
 982      */
 983     public int getRow(TreeItem&lt;T&gt; item) {
 984         return TreeUtil.getRow(item, getRoot(), expandedItemCountDirty, isShowRoot());
 985     }
 986 
 987     /**
 988      * Returns the TreeItem in the given index, or null if it is out of bounds.
 989      *
 990      * @param row The index of the TreeItem being sought.
 991      * @return The TreeItem in the given index, or null if it is out of bounds.
 992      */
 993     public TreeItem&lt;T&gt; getTreeItem(int row) {
 994         if (row &lt; 0) return null;
 995 
 996         // normalize the requested row based on whether showRoot is set
 997         final int _row = isShowRoot() ? row : (row + 1);
 998 
 999         if (expandedItemCountDirty) {
1000             updateExpandedItemCount(getRoot());
1001         } else {
1002             if (treeItemCacheMap.containsKey(_row)) {
1003                 SoftReference&lt;TreeItem&lt;T&gt;&gt; treeItemRef = treeItemCacheMap.get(_row);
1004                 TreeItem&lt;T&gt; treeItem = treeItemRef.get();
1005                 if (treeItem != null) {
1006                     return treeItem;
1007                 }
1008             }
1009         }
1010 
1011         TreeItem&lt;T&gt; treeItem = TreeUtil.getItem(getRoot(), _row, expandedItemCountDirty);
1012         treeItemCacheMap.put(_row, new SoftReference&lt;&gt;(treeItem));
1013         return treeItem;
1014     }
1015 
1016     /**
1017      * Returns the number of levels of &#39;indentation&#39; of the given TreeItem,
1018      * based on how many times getParent() can be recursively called. If the
1019      * given TreeItem is the root node of this TreeView, or if the TreeItem does
1020      * not have any parent set, the returned value will be zero. For each time
1021      * getParent() is recursively called, the returned value is incremented by one.
1022      *
1023      * @param node The TreeItem for which the level is needed.
1024      * @return An integer representing the number of parents above the given node,
1025      *         or -1 if the given TreeItem is null.
1026      */
1027     public int getTreeItemLevel(TreeItem&lt;?&gt; node) {
1028         final TreeItem&lt;?&gt; root = getRoot();
1029 
1030         if (node == null) return -1;
1031         if (node == root) return 0;
1032 
1033         int level = 0;
1034         TreeItem&lt;?&gt; parent = node.getParent();
1035         while (parent != null) {
1036             level++;
1037 
1038             if (parent == root) {
1039                 break;
1040             }
1041 
1042             parent = parent.getParent();
1043         }
1044 
1045         return level;
1046     }
1047 
1048     /** {@inheritDoc} */
1049     @Override protected Skin&lt;?&gt; createDefaultSkin() {
1050         return new TreeViewSkin&lt;T&gt;(this);
1051     }
1052 
1053     /**
1054      * Calling {@code refresh()} forces the TreeView control to recreate and
1055      * repopulate the cells necessary to populate the visual bounds of the control.
1056      * In other words, this forces the TreeView to update what it is showing to
1057      * the user. This is useful in cases where the underlying data source has
1058      * changed in a way that is not observed by the TreeView itself.
1059      *
1060      * @since JavaFX 8u60
1061      */
1062     public void refresh() {
1063         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1064     }
1065 
1066 
1067 
1068     /***************************************************************************
1069      *                                                                         *
1070      * Private Implementation                                                  *
1071      *                                                                         *
1072      **************************************************************************/
1073 
1074     private void updateExpandedItemCount(TreeItem&lt;T&gt; treeItem) {
1075         setExpandedItemCount(TreeUtil.updateExpandedItemCount(treeItem, expandedItemCountDirty, isShowRoot()));
1076 
1077         if (expandedItemCountDirty) {
1078             // this is a very inefficient thing to do, but for now having a cache
1079             // is better than nothing at all...
1080             treeItemCacheMap.clear();
1081         }
1082 
1083         expandedItemCountDirty = false;
1084     }
1085 
1086     private void updateRootExpanded() {
1087         // if we aren&#39;t showing the root, and the root isn&#39;t expanded, we expand
1088         // it now so that something is shown.
1089         if (!isShowRoot() &amp;&amp; getRoot() != null &amp;&amp; ! getRoot().isExpanded()) {
1090             getRoot().setExpanded(true);
1091         }
1092     }
1093 
1094 
1095 
1096     /***************************************************************************
1097      *                                                                         *
1098      * Stylesheet Handling                                                     *
1099      *                                                                         *
1100      **************************************************************************/
1101 
1102     private static final String DEFAULT_STYLE_CLASS = &quot;tree-view&quot;;
1103 
1104     private static class StyleableProperties {
1105         private static final CssMetaData&lt;TreeView&lt;?&gt;,Number&gt; FIXED_CELL_SIZE =
1106                 new CssMetaData&lt;TreeView&lt;?&gt;,Number&gt;(&quot;-fx-fixed-cell-size&quot;,
1107                                                      SizeConverter.getInstance(),
1108                                                      Region.USE_COMPUTED_SIZE) {
1109 
1110                     @Override public Double getInitialValue(TreeView&lt;?&gt; node) {
1111                         return node.getFixedCellSize();
1112                     }
1113 
1114                     @Override public boolean isSettable(TreeView&lt;?&gt; n) {
1115                         return n.fixedCellSize == null || !n.fixedCellSize.isBound();
1116                     }
1117 
1118                     @Override public StyleableProperty&lt;Number&gt; getStyleableProperty(TreeView&lt;?&gt; n) {
1119                         return (StyleableProperty&lt;Number&gt;)(WritableValue&lt;Number&gt;) n.fixedCellSizeProperty();
1120                     }
1121                 };
1122 
1123         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
1124         static {
1125             final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
1126                     new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(Control.getClassCssMetaData());
1127             styleables.add(FIXED_CELL_SIZE);
1128             STYLEABLES = Collections.unmodifiableList(styleables);
1129         }
1130     }
1131 
1132     /**
1133      * @return The CssMetaData associated with this class, which may include the
1134      * CssMetaData of its superclasses.
1135      * @since JavaFX 8.0
1136      */
1137     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
1138         return StyleableProperties.STYLEABLES;
1139     }
1140 
1141     /**
1142      * {@inheritDoc}
1143      * @since JavaFX 8.0
1144      */
1145     @Override
1146     public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getControlCssMetaData() {
1147         return getClassCssMetaData();
1148     }
1149 
1150 
1151 
1152     /***************************************************************************
1153      *                                                                         *
1154      * Accessibility handling                                                  *
1155      *                                                                         *
1156      **************************************************************************/
1157 
1158     /** {@inheritDoc} */
1159     @Override
1160     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1161         switch (attribute) {
1162             case MULTIPLE_SELECTION: {
1163                 MultipleSelectionModel&lt;TreeItem&lt;T&gt;&gt; sm = getSelectionModel();
1164                 return sm != null &amp;&amp; sm.getSelectionMode() == SelectionMode.MULTIPLE;
1165             }
1166             case ROW_COUNT: return getExpandedItemCount();
1167             default: return super.queryAccessibleAttribute(attribute, parameters);
1168         }
1169     }
1170 
1171 
1172 
1173     /***************************************************************************
1174      *                                                                         *
1175      * Support Interfaces                                                      *
1176      *                                                                         *
1177      **************************************************************************/
1178 
1179 
1180 
1181     /***************************************************************************
1182      *                                                                         *
1183      * Support Classes                                                         *
1184      *                                                                         *
1185      **************************************************************************/
1186 
1187 
1188     /**
1189      * An {@link Event} subclass used specifically in TreeView for representing
1190      * edit-related events. It provides additional API to easily access the
1191      * TreeItem that the edit event took place on, as well as the input provided
1192      * by the end user.
1193      *
1194      * @param &lt;T&gt; The type of the input, which is the same type as the TreeView
1195      *      itself.
1196      * @since JavaFX 2.0
1197      */
1198     public static class EditEvent&lt;T&gt; extends Event {
1199         private static final long serialVersionUID = -4437033058917528976L;
1200 
1201         /**
1202          * Common supertype for all edit event types.
1203          * @since JavaFX 8.0
1204          */
1205         public static final EventType&lt;?&gt; ANY = EDIT_ANY_EVENT;
1206 
1207         private final TreeView&lt;T&gt; source;
1208         private final T oldValue;
1209         private final T newValue;
1210         private transient final TreeItem&lt;T&gt; treeItem;
1211 
1212         /**
1213          * Creates a new EditEvent instance to represent an edit event. This
1214          * event is used for {@link #editStartEvent()},
1215          * {@link #editCommitEvent()} and {@link #editCancelEvent()} types.
1216          * @param source the source
1217          * @param eventType the eventType
1218          * @param treeItem the treeItem
1219          * @param oldValue the oldValue
1220          * @param newValue the newValue
1221          */
1222         public EditEvent(TreeView&lt;T&gt; source,
1223                          EventType&lt;? extends EditEvent&gt; eventType,
1224                          TreeItem&lt;T&gt; treeItem, T oldValue, T newValue) {
1225             super(source, Event.NULL_SOURCE_TARGET, eventType);
1226             this.source = source;
1227             this.oldValue = oldValue;
1228             this.newValue = newValue;
1229             this.treeItem = treeItem;
1230         }
1231 
1232         /**
1233          * Returns the TreeView upon which the edit took place.
1234          */
1235         @Override public TreeView&lt;T&gt; getSource() {
1236             return source;
1237         }
1238 
1239         /**
1240          * Returns the {@link TreeItem} upon which the edit took place.
1241          * @return the {@link TreeItem} upon which the edit took place
1242          */
1243         public TreeItem&lt;T&gt; getTreeItem() {
1244             return treeItem;
1245         }
1246 
1247         /**
1248          * Returns the new value input into the TreeItem by the end user.
1249          * @return the new value input into the TreeItem by the end user
1250          */
1251         public T getNewValue() {
1252             return newValue;
1253         }
1254 
1255         /**
1256          * Returns the old value that existed in the TreeItem prior to the current
1257          * edit event.
1258          * @return the old value that existed in the TreeItem prior to the current
1259          * edit event
1260          */
1261         public T getOldValue() {
1262             return oldValue;
1263         }
1264     }
1265 
1266 
1267 
1268 
1269 
1270 
1271 
1272     // package for testing
1273     static class TreeViewBitSetSelectionModel&lt;T&gt; extends MultipleSelectionModelBase&lt;TreeItem&lt;T&gt;&gt; {
1274 
1275         /***********************************************************************
1276          *                                                                     *
1277          * Internal fields                                                     *
1278          *                                                                     *
1279          **********************************************************************/
1280 
1281         private TreeView&lt;T&gt; treeView = null;
1282 
1283 
1284 
1285         /***********************************************************************
1286          *                                                                     *
1287          * Constructors                                                        *
1288          *                                                                     *
1289          **********************************************************************/
1290 
1291         public TreeViewBitSetSelectionModel(final TreeView&lt;T&gt; treeView) {
1292             if (treeView == null) {
1293                 throw new IllegalArgumentException(&quot;TreeView can not be null&quot;);
1294             }
1295 
1296             this.treeView = treeView;
1297             this.treeView.rootProperty().addListener(weakRootPropertyListener);
<a name="3" id="anc3"></a><span class="line-modified">1298             this.treeView.showRootProperty().addListener(o -&gt; {</span>
1299                 shiftSelection(0, treeView.isShowRoot() ? 1 : -1, null);
<a name="4" id="anc4"></a><span class="line-modified">1300             });</span>

1301 
1302             updateTreeEventListener(null, treeView.getRoot());
1303 
1304             updateDefaultSelection();
1305         }
1306 
1307         private void updateTreeEventListener(TreeItem&lt;T&gt; oldRoot, TreeItem&lt;T&gt; newRoot) {
1308             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
1309                 oldRoot.removeEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1310             }
1311 
1312             if (newRoot != null) {
<a name="5" id="anc5"></a>
1313                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
1314                 newRoot.addEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1315             }
1316         }
1317 
1318         private ChangeListener&lt;TreeItem&lt;T&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
1319             updateDefaultSelection();
1320             updateTreeEventListener(oldValue, newValue);
1321         };
1322 
1323         private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; treeItemListener = e -&gt; {
1324             if (getSelectedIndex() == -1 &amp;&amp; getSelectedItem() == null) return;
1325 
1326             final TreeItem&lt;T&gt; treeItem = e.getTreeItem();
1327             if (treeItem == null) return;
1328 
1329             treeView.expandedItemCountDirty = true;
1330 
1331             // we only shift selection from this row - everything before it
1332             // is safe. We might change this below based on certain criteria
1333             int startRow = treeView.getRow(treeItem);
1334 
1335             int shift = 0;
1336             ListChangeListener.Change&lt;? extends TreeItem&lt;?&gt;&gt; change = e.getChange();
1337             if (change != null) {
1338                 change.next();
1339             }
1340 
1341             do {
1342                 final int addedSize = change == null ? 0 : change.getAddedSize();
1343                 final int removedSize = change == null ? 0 : change.getRemovedSize();
1344 
1345                 if (e.wasExpanded()) {
1346                     // need to shuffle selection by the number of visible children
1347                     shift += treeItem.getExpandedDescendentCount(false) - 1;
1348                     startRow++;
1349                 } else if (e.wasCollapsed()) {
1350                     // remove selection from any child treeItem, and also determine
1351                     // if any child item was selected (in which case the parent
1352                     // takes the selection on collapse)
1353                     treeItem.getExpandedDescendentCount(false);
1354                     final int count = treeItem.previousExpandedDescendentCount;
1355 
1356                     final int selectedIndex = getSelectedIndex();
1357                     final boolean wasPrimarySelectionInChild =
1358                             selectedIndex &gt;= (startRow + 1) &amp;&amp;
1359                                     selectedIndex &lt; (startRow + count);
1360 
1361                     boolean wasAnyChildSelected = false;
1362 
1363                     selectedIndices._beginChange();
1364                     final int from = startRow + 1;
1365                     final int to = startRow + count;
1366                     final List&lt;Integer&gt; removed = new ArrayList&lt;&gt;();
1367                     for (int i = from; i &lt; to; i++) {
1368                         if (isSelected(i)) {
1369                             wasAnyChildSelected = true;
1370                             removed.add(i);
1371                         }
1372                     }
1373 
1374                     ControlUtils.reducingChange(selectedIndices, removed);
1375 
1376                     for (int index : removed) {
1377                         startAtomic();
1378                         clearSelection(index);
1379                         stopAtomic();
1380                     }
1381                     selectedIndices._endChange();
1382 
1383                     // put selection onto the newly-collapsed tree item
1384                     if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
1385                         select(startRow);
1386                     }
1387 
1388                     shift += -count + 1;
1389                     startRow++;
1390                 } else if (e.wasPermutated()) {
1391                     // no-op
1392                 } else if (e.wasAdded()) {
1393                     // shuffle selection by the number of added items
1394                     shift += treeItem.isExpanded() ? addedSize : 0;
1395 
1396                     // RT-32963: We were taking the startRow from the TreeItem
1397                     // in which the children were added, rather than from the
1398                     // actual position of the new child. This led to selection
1399                     // being moved off the parent TreeItem by mistake.
1400                     // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
1401                     // subsequently commented out due to RT-33894.
1402                     startRow = treeView.getRow(e.getChange().getAddedSubList().get(0));
1403                 } else if (e.wasRemoved()) {
1404                     // shuffle selection by the number of removed items
1405                     shift += treeItem.isExpanded() ? -removedSize : 0;
1406 
1407                     // the start row is incorrect - it is _not_ the index of the
1408                     // TreeItem in which the children were removed from (which is
1409                     // what it currently represents). We need to take the &#39;from&#39;
1410                     // value out of the event and make use of that to understand
1411                     // what actually changed inside the children list.
1412                     startRow += e.getFrom() + 1;
1413 
1414                     // whilst we are here, we should check if the removed items
1415                     // are part of the selectedItems list - and remove them
1416                     // from selection if they are (as per RT-15446)
1417                     final List&lt;Integer&gt; selectedIndices1 = getSelectedIndices();
1418                     final int selectedIndex = getSelectedIndex();
1419                     final List&lt;TreeItem&lt;T&gt;&gt; selectedItems = getSelectedItems();
1420                     final TreeItem&lt;T&gt; selectedItem = getSelectedItem();
1421                     final List&lt;? extends TreeItem&lt;T&gt;&gt; removedChildren = e.getChange().getRemoved();
1422 
1423                     for (int i = 0; i &lt; selectedIndices1.size() &amp;&amp; !selectedItems.isEmpty(); i++) {
1424                         int index = selectedIndices1.get(i);
1425                         if (index &gt; selectedItems.size()) break;
1426 
1427                         if (removedChildren.size() == 1 &amp;&amp;
1428                                 selectedItems.size() == 1 &amp;&amp;
1429                                 selectedItem != null &amp;&amp;
1430                                 selectedItem.equals(removedChildren.get(0))) {
1431                             // Bug fix for RT-28637
1432                             if (selectedIndex &lt; getItemCount()) {
1433                                 final int previousRow = selectedIndex == 0 ? 0 : selectedIndex - 1;
1434                                 TreeItem&lt;T&gt; newSelectedItem = getModelItem(previousRow);
1435                                 if (!selectedItem.equals(newSelectedItem)) {
1436                                     select(newSelectedItem);
1437                                 }
1438                             }
1439                         }
1440                     }
1441                 }
1442             } while (e.getChange() != null &amp;&amp; e.getChange().next());
1443 
1444             shiftSelection(startRow, shift, null);
1445 
1446             if (e.wasAdded() || e.wasRemoved()) {
1447                 Integer anchor = TreeCellBehavior.getAnchor(treeView, null);
1448                 if (anchor != null &amp;&amp; isSelected(anchor + shift)) {
1449                     TreeCellBehavior.setAnchor(treeView, anchor + shift, false);
1450                 }
1451             }
1452         };
1453 
1454         private WeakChangeListener&lt;TreeItem&lt;T&gt;&gt; weakRootPropertyListener =
1455                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
1456 
1457         private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakTreeItemListener;
1458 
<a name="6" id="anc6"></a>
1459 
1460 
1461         /***********************************************************************
1462          *                                                                     *
1463          * Public selection API                                                *
1464          *                                                                     *
1465          **********************************************************************/
1466 
1467         /** {@inheritDoc} */
1468         @Override public void selectAll() {
1469             // when a selectAll happens, the anchor should not change, so we store it
1470             // before, and restore it afterwards
1471             final int anchor = TreeCellBehavior.getAnchor(treeView, -1);
1472             super.selectAll();
1473             TreeCellBehavior.setAnchor(treeView, anchor, false);
1474         }
1475 
1476         /** {@inheritDoc} */
1477         @Override public void select(TreeItem&lt;T&gt; obj) {
1478 //        if (getRowCount() &lt;= 0) return;
1479 
1480             if (obj == null &amp;&amp; getSelectionMode() == SelectionMode.SINGLE) {
1481                 clearSelection();
1482                 return;
1483             }
1484 
1485             // we firstly expand the path down such that the given object is
1486             // visible. This fixes RT-14456, where selection was not happening
1487             // correctly on TreeItems that are not visible.
1488 
1489             if (obj != null) {
1490                 TreeItem&lt;?&gt; item = obj.getParent();
1491                 while (item != null) {
1492                     item.setExpanded(true);
1493                     item = item.getParent();
1494                 }
1495             }
1496 
1497             // Fix for RT-15419. We eagerly update the tree item count, such that
1498             // selection occurs on the row
1499             treeView.updateExpandedItemCount(treeView.getRoot());
1500 
1501             // We have no option but to iterate through the model and select the
1502             // first occurrence of the given object. Once we find the first one, we
1503             // don&#39;t proceed to select any others.
1504             int row = treeView.getRow(obj);
1505 
1506             if (row == -1) {
1507                 // if we are here, we did not find the item in the entire data model.
1508                 // Even still, we allow for this item to be set to the give object.
1509                 // We expect that in concrete subclasses of this class we observe the
1510                 // data model such that we check to see if the given item exists in it,
1511                 // whilst SelectedIndex == -1 &amp;&amp; SelectedItem != null.
1512                 setSelectedIndex(-1);
1513                 setSelectedItem(obj);
1514             } else {
1515                 select(row);
1516             }
1517         }
1518 
1519         /** {@inheritDoc} */
1520         @Override public void clearAndSelect(int row) {
1521             TreeCellBehavior.setAnchor(treeView, row, false);
1522             super.clearAndSelect(row);
1523         }
1524 
1525 
1526         /***********************************************************************
1527          *                                                                     *
1528          * Support code                                                        *
1529          *                                                                     *
1530          **********************************************************************/
1531 
1532         /** {@inheritDoc} */
1533         @Override protected void focus(int itemIndex) {
1534             if (treeView.getFocusModel() != null) {
1535                 treeView.getFocusModel().focus(itemIndex);
1536             }
1537 
1538             // FIXME this is not the correct location for fire selection events (and does not take into account multiple selection)
1539             treeView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1540         }
1541 
1542         /** {@inheritDoc} */
1543         @Override protected int getFocusedIndex() {
1544             if (treeView.getFocusModel() == null) return -1;
1545             return treeView.getFocusModel().getFocusedIndex();
1546         }
1547 
1548         /** {@inheritDoc} */
1549         @Override protected int getItemCount() {
1550             return treeView == null ? 0 : treeView.getExpandedItemCount();
1551         }
1552 
1553         /** {@inheritDoc} */
1554         @Override public TreeItem&lt;T&gt; getModelItem(int index) {
1555             if (treeView == null) return null;
1556 
1557             if (index &lt; 0 || index &gt;= treeView.getExpandedItemCount()) return null;
1558 
1559             return treeView.getTreeItem(index);
1560         }
1561 
1562 
1563 
1564         /***********************************************************************
1565          *                                                                     *
1566          * Private implementation                                              *
1567          *                                                                     *
1568          **********************************************************************/
1569 
1570         private void updateDefaultSelection() {
1571             clearSelection();
1572 
1573             // we put focus onto the first item, if there is at least
1574             // one item in the list
1575             focus(getItemCount() &gt; 0 ? 0 : -1);
1576         }
1577     }
1578 
1579 
1580 
1581     /**
1582      *
1583      * @param &lt;T&gt;
1584      */
1585     static class TreeViewFocusModel&lt;T&gt; extends FocusModel&lt;TreeItem&lt;T&gt;&gt; {
1586 
1587         private final TreeView&lt;T&gt; treeView;
1588 
1589         public TreeViewFocusModel(final TreeView&lt;T&gt; treeView) {
1590             this.treeView = treeView;
1591             this.treeView.rootProperty().addListener(weakRootPropertyListener);
1592             updateTreeEventListener(null, treeView.getRoot());
1593 
1594             if (treeView.getExpandedItemCount() &gt; 0) {
1595                 focus(0);
1596             }
1597 
<a name="7" id="anc7"></a><span class="line-modified">1598             treeView.showRootProperty().addListener(o -&gt; {</span>
1599                 if (isFocused(0)) {
1600                     focus(-1);
1601                     focus(0);
1602                 }
<a name="8" id="anc8"></a><span class="line-modified">1603             });</span>

1604 
1605             focusedIndexProperty().addListener(o -&gt; {
1606                 treeView.notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUS_ITEM);
1607             });
1608         }
1609 
1610         private final ChangeListener&lt;TreeItem&lt;T&gt;&gt; rootPropertyListener = (observable, oldValue, newValue) -&gt; {
1611             updateTreeEventListener(oldValue, newValue);
1612         };
1613 
1614         private final WeakChangeListener&lt;TreeItem&lt;T&gt;&gt; weakRootPropertyListener =
1615                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
1616 
<a name="9" id="anc9"></a>

1617         private void updateTreeEventListener(TreeItem&lt;T&gt; oldRoot, TreeItem&lt;T&gt; newRoot) {
1618             if (oldRoot != null &amp;&amp; weakTreeItemListener != null) {
1619                 oldRoot.removeEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1620             }
1621 
1622             if (newRoot != null) {
1623                 weakTreeItemListener = new WeakEventHandler&lt;&gt;(treeItemListener);
1624                 newRoot.addEventHandler(TreeItem.&lt;T&gt;expandedItemCountChangeEvent(), weakTreeItemListener);
1625             }
1626         }
1627 
1628         private EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; treeItemListener = new EventHandler&lt;TreeModificationEvent&lt;T&gt;&gt;() {
1629             @Override public void handle(TreeModificationEvent&lt;T&gt; e) {
1630                 // don&#39;t shift focus if the event occurred on a tree item after
1631                 // the focused row, or if there is no focus index at present
1632                 if (getFocusedIndex() == -1) return;
1633 
1634                 int row = treeView.getRow(e.getTreeItem());
1635 
1636                 int shift = 0;
1637                 if (e.getChange() != null) {
1638                     e.getChange().next();
1639                 }
1640 
1641                 do {
1642                     if (e.wasExpanded()) {
1643                         if (row &lt; getFocusedIndex()) {
1644                             // need to shuffle selection by the number of visible children
1645                             shift += e.getTreeItem().getExpandedDescendentCount(false) - 1;
1646                         }
1647                     } else if (e.wasCollapsed()) {
1648                         if (row &lt; getFocusedIndex()) {
1649                             // need to shuffle selection by the number of visible children
1650                             // that were just hidden
1651                             shift += -e.getTreeItem().previousExpandedDescendentCount + 1;
1652                         }
1653                     } else if (e.wasAdded()) {
1654                         // get the TreeItem the event occurred on - we only need to
1655                         // shift if the tree item is expanded
1656                         TreeItem&lt;T&gt; eventTreeItem = e.getTreeItem();
1657                         if (eventTreeItem.isExpanded()) {
1658                             for (int i = 0; i &lt; e.getAddedChildren().size(); i++) {
1659                                 // get the added item and determine the row it is in
1660                                 TreeItem&lt;T&gt; item = e.getAddedChildren().get(i);
1661                                 row = treeView.getRow(item);
1662 
1663                                 if (item != null &amp;&amp; row &lt;= (shift+getFocusedIndex())) {
1664                                     shift += item.getExpandedDescendentCount(false);
1665                                 }
1666                             }
1667                         }
1668                     } else if (e.wasRemoved()) {
1669                         row += e.getFrom() + 1;
1670 
1671                         for (int i = 0; i &lt; e.getRemovedChildren().size(); i++) {
1672                             TreeItem&lt;T&gt; item = e.getRemovedChildren().get(i);
1673                             if (item != null &amp;&amp; item.equals(getFocusedItem())) {
1674                                 focus(Math.max(0, getFocusedIndex() - 1));
1675                                 return;
1676                             }
1677                         }
1678 
1679                         if (row &lt;= getFocusedIndex()) {
1680                             // shuffle selection by the number of removed items
1681                             shift += e.getTreeItem().isExpanded() ? -e.getRemovedSize() : 0;
1682                         }
1683                     }
1684                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
1685 
1686                 if(shift != 0) {
1687                     final int newFocus = getFocusedIndex() + shift;
1688                     if (newFocus &gt;= 0) {
1689                         Platform.runLater(() -&gt; focus(newFocus));
1690                     }
1691                 }
1692             }
1693         };
1694 
1695         private WeakEventHandler&lt;TreeModificationEvent&lt;T&gt;&gt; weakTreeItemListener;
1696 
1697         @Override protected int getItemCount() {
1698             return treeView == null ? -1 : treeView.getExpandedItemCount();
1699         }
1700 
1701         @Override protected TreeItem&lt;T&gt; getModelItem(int index) {
1702             if (treeView == null) return null;
1703 
1704             if (index &lt; 0 || index &gt;= treeView.getExpandedItemCount()) return null;
1705 
1706             return treeView.getTreeItem(index);
1707         }
1708 
1709         /** {@inheritDoc} */
1710         @Override public void focus(int index) {
1711             if (treeView.expandedItemCountDirty) {
1712                 treeView.updateExpandedItemCount(treeView.getRoot());
1713             }
1714 
1715             super.focus(index);
1716         }
1717     }
1718 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/javafx/tk/quantum/QuantumToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.javafx.tk.quantum;
  27 
<a name="1" id="anc1"></a>


















































  28 import com.sun.glass.ui.Clipboard;
<a name="2" id="anc2"></a><span class="line-modified">  29 import com.sun.glass.ui.*;</span>
<span class="line-modified">  30 import com.sun.glass.ui.Timer;</span>
  31 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
<a name="3" id="anc3"></a>




  32 import com.sun.javafx.PlatformUtil;
  33 import com.sun.javafx.application.PlatformImpl;
  34 import com.sun.javafx.embed.HostInterface;
  35 import com.sun.javafx.geom.Path2D;
  36 import com.sun.javafx.geom.PathIterator;
  37 import com.sun.javafx.geom.Shape;
  38 import com.sun.javafx.geom.transform.BaseTransform;
<a name="4" id="anc4"></a><span class="line-removed">  39 import com.sun.javafx.logging.PulseLogger;</span>
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.runtime.async.AbstractRemoteResource;
  42 import com.sun.javafx.runtime.async.AsyncOperationListener;
<a name="5" id="anc5"></a><span class="line-removed">  43 import com.sun.javafx.scene.input.DragboardHelper;</span>
  44 import com.sun.javafx.scene.text.TextLayoutFactory;
  45 import com.sun.javafx.sg.prism.NGNode;
<a name="6" id="anc6"></a><span class="line-modified">  46 import com.sun.javafx.tk.*;</span>
<span class="line-modified">  47 import com.sun.prism.*;</span>






















  48 import com.sun.prism.Texture.WrapMode;
  49 import com.sun.prism.impl.Disposer;
  50 import com.sun.prism.impl.PrismSettings;
  51 import com.sun.scenario.DelayedRunnable;
  52 import com.sun.scenario.animation.AbstractMasterTimer;
  53 import com.sun.scenario.effect.FilterContext;
  54 import com.sun.scenario.effect.Filterable;
  55 import com.sun.scenario.effect.impl.prism.PrFilterContext;
  56 import com.sun.scenario.effect.impl.prism.PrImage;
<a name="7" id="anc7"></a><span class="line-modified">  57 import javafx.application.ConditionalFeature;</span>
<span class="line-removed">  58 import javafx.geometry.Dimension2D;</span>
<span class="line-removed">  59 import javafx.scene.image.Image;</span>
<span class="line-removed">  60 import javafx.scene.image.PixelBuffer;</span>
<span class="line-removed">  61 import javafx.scene.input.*;</span>
<span class="line-removed">  62 import javafx.scene.paint.*;</span>
<span class="line-removed">  63 import javafx.scene.shape.*;</span>
<span class="line-removed">  64 import javafx.stage.FileChooser;</span>
<span class="line-removed">  65 import javafx.stage.Modality;</span>
<span class="line-removed">  66 import javafx.stage.StageStyle;</span>
<span class="line-removed">  67 import javafx.stage.Window;</span>
<span class="line-removed">  68 </span>
<span class="line-removed">  69 import java.io.File;</span>
<span class="line-removed">  70 import java.io.InputStream;</span>
<span class="line-removed">  71 import java.nio.Buffer;</span>
<span class="line-removed">  72 import java.nio.ByteBuffer;</span>
<span class="line-removed">  73 import java.nio.IntBuffer;</span>
<span class="line-removed">  74 import java.security.AccessControlContext;</span>
<span class="line-removed">  75 import java.security.AccessController;</span>
<span class="line-removed">  76 import java.security.PrivilegedAction;</span>
<span class="line-removed">  77 import java.util.*;</span>
<span class="line-removed">  78 import java.util.concurrent.CountDownLatch;</span>
<span class="line-removed">  79 import java.util.concurrent.Future;</span>
<span class="line-removed">  80 import java.util.concurrent.TimeUnit;</span>
<span class="line-removed">  81 import java.util.concurrent.atomic.AtomicBoolean;</span>
<span class="line-removed">  82 import java.util.function.Supplier;</span>
<span class="line-removed">  83 </span>
  84 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
<a name="8" id="anc8"></a>
  85 
  86 public final class QuantumToolkit extends Toolkit {
  87 
  88     public static final boolean verbose =
  89             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.verbose&quot;));
  90 
  91     public static final boolean pulseDebug =
  92             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.pulse&quot;));
  93 
  94     private static final boolean multithreaded =
  95             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
  96                 // If it is not specified, or it is true, then it should
  97                 // be true. Otherwise it should be false.
  98                 String value = System.getProperty(&quot;quantum.multithreaded&quot;);
  99                 if (value == null) return true;
 100                 final boolean result = Boolean.parseBoolean(value);
 101                 if (verbose) {
 102                     System.out.println(result ? &quot;Multi-Threading Enabled&quot; : &quot;Multi-Threading Disabled&quot;);
 103                 }
 104                 return result;
 105             });
 106 
 107     private static boolean debug =
 108             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;quantum.debug&quot;));
 109 
 110     private static Integer pulseHZ =
 111             AccessController.doPrivileged((PrivilegedAction&lt;Integer&gt;) () -&gt; Integer.getInteger(&quot;javafx.animation.pulse&quot;));
 112 
 113     static final boolean liveResize =
 114             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
 115                 boolean isSWT = &quot;swt&quot;.equals(System.getProperty(&quot;glass.platform&quot;));
 116                 String result = (PlatformUtil.isMac() || PlatformUtil.isWindows()) &amp;&amp; !isSWT ? &quot;true&quot; : &quot;false&quot;;
 117                 return &quot;true&quot;.equals(System.getProperty(&quot;javafx.live.resize&quot;, result));
 118             });
 119 
 120     static final boolean drawInPaint =
 121             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
 122                 boolean isSWT = &quot;swt&quot;.equals(System.getProperty(&quot;glass.platform&quot;));
 123                 String result = PlatformUtil.isMac() &amp;&amp; isSWT ? &quot;true&quot; : &quot;false&quot;;
 124                 return &quot;true&quot;.equals(System.getProperty(&quot;javafx.draw.in.paint&quot;, result));});
 125 
 126     private static boolean singleThreaded =
 127             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
 128                 Boolean result = Boolean.getBoolean(&quot;quantum.singlethreaded&quot;);
 129                 if (/*verbose &amp;&amp;*/ result) {
 130                     System.out.println(&quot;Warning: Single GUI Threadiong is enabled, FPS should be slower&quot;);
 131                 }
 132                 return result;
 133             });
 134 
 135     private static boolean noRenderJobs =
 136             AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;) () -&gt; {
 137                 Boolean result = Boolean.getBoolean(&quot;quantum.norenderjobs&quot;);
 138                 if (/*verbose &amp;&amp;*/ result) {
 139                     System.out.println(&quot;Warning: Quantum will not submit render jobs, nothing should draw&quot;);
 140                 }
 141                 return result;
 142             });
 143 
 144     private class PulseTask {
 145         private volatile boolean isRunning;
 146         PulseTask(boolean state) {
 147             isRunning = state;
 148         }
 149 
 150         synchronized void set(boolean state) {
 151             isRunning = state;
 152             if (isRunning) {
 153                 resumeTimer();
 154             }
 155         }
 156 
 157         boolean get() {
 158             return isRunning;
 159         }
 160     }
 161 
 162     private AtomicBoolean           toolkitRunning = new AtomicBoolean(false);
 163     private PulseTask               animationRunning = new PulseTask(false);
 164     private PulseTask               nextPulseRequested = new PulseTask(false);
 165     private AtomicBoolean           pulseRunning = new AtomicBoolean(false);
 166     private int                     inPulse = 0;
 167     private CountDownLatch          launchLatch = new CountDownLatch(1);
 168 
 169     final int                       PULSE_INTERVAL = (int)(TimeUnit.SECONDS.toMillis(1L) / getRefreshRate());
 170     final int                       FULLSPEED_INTERVAL = 1;     // ms
 171     boolean                         nativeSystemVsync = false;
 172     private long                    firstPauseRequestTime = 0;
 173     private boolean                 pauseRequested = false;
 174     private static final long       PAUSE_THRESHOLD_DURATION = 250;
 175     private float                   _maxPixelScale;
 176     private Runnable                pulseRunnable, userRunnable, timerRunnable;
 177     private Timer                   pulseTimer = null;
 178     private Thread                  shutdownHook = null;
 179     private PaintCollector          collector;
 180     private QuantumRenderer         renderer;
 181     private GraphicsPipeline        pipeline;
 182 
 183     private ClassLoader             ccl;
 184 
 185     private HashMap&lt;Object,EventLoop&gt; eventLoopMap = null;
 186 
 187     private final PerformanceTracker perfTracker = new PerformanceTrackerImpl();
 188 
 189     @Override public boolean init() {
 190         /*
 191          * Glass Mac, X11 need Application.setDeviceDetails to happen prior to Glass Application.Run
 192          */
 193         renderer = QuantumRenderer.getInstance();
 194         collector = PaintCollector.createInstance(this);
 195         pipeline = GraphicsPipeline.getPipeline();
 196 
 197         /* shutdown the pipeline on System.exit, ^c
 198          * needed with X11 and Windows, see RT-32501
 199          */
 200         shutdownHook = new Thread(&quot;Glass/Prism Shutdown Hook&quot;) {
 201             @Override public void run() {
 202                 dispose();
 203             }
 204         };
 205         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 206             Runtime.getRuntime().addShutdownHook(shutdownHook);
 207             return null;
 208         });
 209         return true;
 210     }
 211 
 212     /**
 213      * This method is invoked by PlatformImpl. It is typically called on the main
 214      * thread, NOT the JavaFX Application Thread. The userStartupRunnable will
 215      * be invoked on the JavaFX Application Thread.
 216      *
 217      * @param userStartupRunnable A runnable invoked on the JavaFX Application Thread
 218      *                            that allows the system to perform some startup
 219      *                            functionality after the toolkit has been initialized.
 220      */
 221     @Override public void startup(final Runnable userStartupRunnable) {
 222         // Save the context class loader of the launcher thread
 223         ccl = Thread.currentThread().getContextClassLoader();
 224 
 225         try {
 226             this.userRunnable = userStartupRunnable;
 227 
 228             // Ensure that the toolkit can only be started here
 229             Application.run(() -&gt; runToolkit());
 230         } catch (RuntimeException ex) {
 231             if (verbose) {
 232                 ex.printStackTrace();
 233             }
 234             throw ex;
 235         } catch (Throwable t) {
 236             if (verbose) {
 237                 t.printStackTrace();
 238             }
 239             throw new RuntimeException(t);
 240         }
 241 
 242         try {
 243             launchLatch.await();
 244         } catch (InterruptedException ie) {
 245             ie.printStackTrace();
 246         }
 247     }
 248 
 249     // restart the toolkit if previously terminated
 250     private void assertToolkitRunning() {
 251         // not implemented
 252     }
 253 
 254     boolean shouldWaitForRenderingToComplete() {
 255         return !multithreaded;
 256     }
 257 
 258     /**
 259      * Method to initialize the Scene Graph on the JavaFX application thread.
 260      * Specifically, we will do static initialization for those classes in
 261      * the javafx.stage, javafx.scene, and javafx.controls packages necessary
 262      * to allow subsequent construction of the Scene or any Node, including
 263      * a PopupControl, on a background thread.
 264      *
 265      * This method is called on the JavaFX application thread.
 266      */
 267     private static void initSceneGraph() {
 268         // It is both necessary and sufficient to call a static method on the
 269         // Screen class to allow PopupControl instances to be created on any thread.
 270         javafx.stage.Screen.getPrimary();
 271     }
 272 
 273     // Called by Glass from Application.run()
 274     void runToolkit() {
 275         Thread user = Thread.currentThread();
 276 
 277         if (!toolkitRunning.getAndSet(true)) {
 278             user.setName(&quot;JavaFX Application Thread&quot;);
 279             // Set context class loader to the same as the thread that called startup
 280             user.setContextClassLoader(ccl);
 281             setFxUserThread(user);
 282 
 283             // Glass screens were inited in Application.run(), assign adapters
 284             assignScreensAdapters();
 285             /*
 286              *  Glass Application instance is now valid - create the ResourceFactory
 287              *  on the render thread
 288              */
 289             renderer.createResourceFactory();
 290 
 291             pulseRunnable = () -&gt; QuantumToolkit.this.pulseFromQueue();
 292             timerRunnable = () -&gt; {
 293                 try {
 294                     QuantumToolkit.this.postPulse();
 295                 } catch (Throwable th) {
 296                     th.printStackTrace(System.err);
 297                 }
 298             };
 299             pulseTimer = Application.GetApplication().createTimer(timerRunnable);
 300 
 301             Application.GetApplication().setEventHandler(new Application.EventHandler() {
 302                 @Override public void handleQuitAction(Application app, long time) {
 303                     GlassStage.requestClosingAllWindows();
 304                 }
 305 
 306                 @Override public boolean handleThemeChanged(String themeName) {
 307                     return PlatformImpl.setAccessibilityTheme(themeName);
 308                 }
 309             });
 310         }
 311         // Initialize JavaFX scene graph
 312         initSceneGraph();
 313         launchLatch.countDown();
 314         try {
 315             Application.invokeAndWait(this.userRunnable);
 316 
 317             if (getMasterTimer().isFullspeed()) {
 318                 /*
 319                  * FULLSPEED_INTVERVAL workaround
 320                  *
 321                  * Application.invokeLater(pulseRunnable);
 322                  */
 323                 pulseTimer.start(FULLSPEED_INTERVAL);
 324             } else {
 325                 nativeSystemVsync = Screen.getVideoRefreshPeriod() != 0.0;
 326                 if (nativeSystemVsync) {
 327                     // system supports vsync
 328                     pulseTimer.start();
 329                 } else {
 330                     // rely on millisecond resolution timer to provide
 331                     // nominal pulse sync and use pulse hinting on
 332                     // synchronous pipelines to fine tune the interval
 333                     pulseTimer.start(PULSE_INTERVAL);
 334                 }
 335             }
 336         } catch (Throwable th) {
 337             th.printStackTrace(System.err);
 338         } finally {
 339             if (PrismSettings.verbose) {
 340                 System.err.println(&quot; vsync: &quot; + PrismSettings.isVsyncEnabled +
 341                                    &quot; vpipe: &quot; + pipeline.isVsyncSupported());
 342             }
 343             PerformanceTracker.logEvent(&quot;Toolkit.startup - finished&quot;);
 344         }
 345     }
 346 
 347     /**
 348      * Runs the specified supplier, releasing the renderLock if needed.
 349      * This is called by glass event handlers for Window, View, and
 350      * Accessible.
 351      * @param &lt;T&gt; the type of the return value
 352      * @param supplier the supplier to be run
 353      * @return the return value from calling supplier.get()
 354      */
 355     public static &lt;T&gt; T runWithoutRenderLock(Supplier&lt;T&gt; supplier) {
 356         final boolean locked = ViewPainter.renderLock.isHeldByCurrentThread();
 357         try {
 358             if (locked) {
 359                 ViewPainter.renderLock.unlock();
 360             }
 361             return supplier.get();
 362         } finally {
 363             if (locked) {
 364                 ViewPainter.renderLock.lock();
 365             }
 366         }
 367     }
 368 
 369     /**
 370      * Runs the specified supplier, first acquiring the renderLock.
 371      * The lock is released when done.
 372      * @param &lt;T&gt; the type of the return value
 373      * @param supplier the supplier to be run
 374      * @return the return value from calling supplier.get()
 375      */
 376     public static &lt;T&gt; T runWithRenderLock(Supplier&lt;T&gt; supplier) {
 377         ViewPainter.renderLock.lock();
 378         try {
 379             return supplier.get();
 380         } finally {
 381             ViewPainter.renderLock.unlock();
 382         }
 383     }
 384 
 385     boolean hasNativeSystemVsync() {
 386         return nativeSystemVsync;
 387     }
 388 
 389     boolean isVsyncEnabled() {
 390         return (PrismSettings.isVsyncEnabled &amp;&amp;
 391                 pipeline.isVsyncSupported());
 392     }
 393 
 394     @Override public void checkFxUserThread() {
 395         super.checkFxUserThread();
 396         renderer.checkRendererIdle();
 397     }
 398 
 399     protected static Thread getFxUserThread() {
 400         return Toolkit.getFxUserThread();
 401     }
 402 
 403     @Override public Future addRenderJob(RenderJob r) {
 404         // Do not run any render jobs (this is for benchmarking only)
 405         if (noRenderJobs) {
 406             CompletionListener listener = r.getCompletionListener();
 407             if (r instanceof PaintRenderJob) {
 408                 ((PaintRenderJob)r).getScene().setPainting(false);
 409             }
 410             if (listener != null) {
 411                 try {
 412                     listener.done(r);
 413                 } catch (Throwable th) {
 414                     th.printStackTrace();
 415                 }
 416             }
 417             return null;
 418         }
 419         // Run the render job in the UI thread (this is for benchmarking only)
 420         if (singleThreaded) {
 421             r.run();
 422             return null;
 423         }
 424         return (renderer.submitRenderJob(r));
 425     }
 426 
 427     void postPulse() {
 428         if (toolkitRunning.get() &amp;&amp;
 429             (animationRunning.get() || nextPulseRequested.get()) &amp;&amp;
 430             !setPulseRunning()) {
 431 
 432             Application.invokeLater(pulseRunnable);
 433 
 434             if (debug) {
 435                 System.err.println(&quot;QT.postPulse@(&quot; + System.nanoTime() + &quot;): &quot; + pulseString());
 436             }
 437         } else if (!animationRunning.get() &amp;&amp; !nextPulseRequested.get() &amp;&amp; !pulseRunning.get()) {
 438             pauseTimer();
 439         } else if (debug) {
 440             System.err.println(&quot;QT.postPulse#(&quot; + System.nanoTime() + &quot;): DROP : &quot; + pulseString());
 441         }
 442     }
 443 
 444     private synchronized void pauseTimer() {
 445         if (!pauseRequested) {
 446             pauseRequested = true;
 447             firstPauseRequestTime = System.currentTimeMillis();
 448         }
 449 
 450         if (System.currentTimeMillis() - firstPauseRequestTime &gt;= PAUSE_THRESHOLD_DURATION) {
 451             pulseTimer.pause();
 452             if (debug) {
 453                 System.err.println(&quot;QT.pauseTimer#(&quot; + System.nanoTime() + &quot;): Pausing Timer : &quot; + pulseString());
 454             }
 455         } else if (debug) {
 456             System.err.println(&quot;QT.pauseTimer#(&quot; + System.nanoTime() + &quot;): Pause Timer : DROP : &quot; + pulseString());
 457         }
 458     }
 459 
 460     private synchronized void resumeTimer() {
 461         pauseRequested = false;
 462         pulseTimer.resume();
 463     }
 464 
 465     private String pulseString() {
 466         return ((toolkitRunning.get() ? &quot;T&quot; : &quot;t&quot;) +
 467                 (animationRunning.get() ? &quot;A&quot; : &quot;a&quot;) +
 468                 (pulseRunning.get() ? &quot;P&quot; : &quot;p&quot;) +
 469                 (nextPulseRequested.get() ? &quot;N&quot; : &quot;n&quot;));
 470     }
 471 
 472     private boolean setPulseRunning() {
 473         return (pulseRunning.getAndSet(true));
 474     }
 475 
 476     private void endPulseRunning() {
 477         pulseRunning.set(false);
 478         if (debug) {
 479             System.err.println(&quot;QT.endPulse: &quot; + System.nanoTime());
 480         }
 481     }
 482 
 483     void pulseFromQueue() {
 484         try {
 485             pulse();
 486         } finally {
 487             endPulseRunning();
 488         }
 489     }
 490 
 491     protected void pulse() {
 492         pulse(true);
 493     }
 494 
 495     void pulse(boolean collect) {
 496         try {
 497             inPulse++;
 498             if (PULSE_LOGGING_ENABLED) {
 499                 PulseLogger.pulseStart();
 500             }
 501 
 502             if (!toolkitRunning.get()) {
 503                 return;
 504             }
 505             nextPulseRequested.set(false);
 506             if (animationRunnable != null) {
 507                 animationRunning.set(true);
 508                 animationRunnable.run();
 509             } else {
 510                 animationRunning.set(false);
 511             }
 512             firePulse();
 513             if (collect) collector.renderAll();
 514         } finally {
 515             inPulse--;
 516             if (PULSE_LOGGING_ENABLED) {
 517                 PulseLogger.pulseEnd();
 518             }
 519         }
 520     }
 521 
 522     void vsyncHint() {
 523         if (isVsyncEnabled()) {
 524             if (debug) {
 525                 System.err.println(&quot;QT.vsyncHint: postPulse: &quot; + System.nanoTime());
 526             }
 527             postPulse();
 528         }
 529     }
 530 
 531     @Override  public AppletWindow createAppletWindow(long parent, String serverName) {
 532         GlassAppletWindow parentWindow = new GlassAppletWindow(parent, serverName);
 533         // Make this the parent window for all future Stages
 534         WindowStage.setAppletWindow(parentWindow);
 535         return parentWindow;
 536     }
 537 
 538     @Override public void closeAppletWindow() {
 539         GlassAppletWindow gaw = WindowStage.getAppletWindow();
 540         if (null != gaw) {
 541             gaw.dispose();
 542             WindowStage.setAppletWindow(null);
 543             // any further strong refs will be in the applet itself
 544         }
 545     }
 546 
 547     @Override public TKStage createTKStage(Window peerWindow, boolean securityDialog, StageStyle stageStyle, boolean primary, Modality modality, TKStage owner, boolean rtl, AccessControlContext acc) {
 548         assertToolkitRunning();
 549         WindowStage stage = new WindowStage(peerWindow, securityDialog, stageStyle, modality, owner);
 550         stage.setSecurityContext(acc);
 551         if (primary) {
 552             stage.setIsPrimary();
 553         }
 554         stage.setRTL(rtl);
 555         stage.init(systemMenu);
 556         return stage;
 557     }
 558 
 559     @Override public boolean canStartNestedEventLoop() {
 560         return inPulse == 0;
 561     }
 562 
 563     @Override public Object enterNestedEventLoop(Object key) {
 564         checkFxUserThread();
 565 
 566         if (key == null) {
 567             throw new NullPointerException();
 568         }
 569 
 570         if (!canStartNestedEventLoop()) {
 571             throw new IllegalStateException(&quot;Cannot enter nested loop during animation or layout processing&quot;);
 572         }
 573 
 574         if (eventLoopMap == null) {
 575             eventLoopMap = new HashMap&lt;&gt;();
 576         }
 577         if (eventLoopMap.containsKey(key)) {
 578             throw new IllegalArgumentException(
 579                     &quot;Key already associated with a running event loop: &quot; + key);
 580         }
 581         EventLoop eventLoop = Application.GetApplication().createEventLoop();
 582         eventLoopMap.put(key, eventLoop);
 583 
 584         Object ret = eventLoop.enter();
 585 
 586         if (!isNestedLoopRunning()) {
 587             notifyLastNestedLoopExited();
 588         }
 589 
 590         return ret;
 591     }
 592 
 593     @Override public void exitNestedEventLoop(Object key, Object rval) {
 594         checkFxUserThread();
 595 
 596         if (key == null) {
 597             throw new NullPointerException();
 598         }
 599         if (eventLoopMap == null || !eventLoopMap.containsKey(key)) {
 600             throw new IllegalArgumentException(
 601                     &quot;Key not associated with a running event loop: &quot; + key);
 602         }
 603         EventLoop eventLoop = eventLoopMap.get(key);
 604         eventLoopMap.remove(key);
 605         eventLoop.leave(rval);
 606     }
 607 
 608     @Override public void exitAllNestedEventLoops() {
 609         checkFxUserThread();
 610         for (EventLoop eventLoop : eventLoopMap.values()) {
 611             eventLoop.leave(null);
 612         }
 613         eventLoopMap.clear();
 614         eventLoopMap = null;
 615     }
 616 
 617     @Override public TKStage createTKPopupStage(Window peerWindow,
 618                                                 StageStyle popupStyle,
 619                                                 TKStage owner,
 620                                                 AccessControlContext acc) {
 621         assertToolkitRunning();
 622         boolean securityDialog = owner instanceof WindowStage ?
 623                 ((WindowStage)owner).isSecurityDialog() : false;
 624         WindowStage stage = new WindowStage(peerWindow, securityDialog, popupStyle, null, owner);
 625         stage.setSecurityContext(acc);
 626         stage.setIsPopup();
 627         stage.init(systemMenu);
 628         return stage;
 629     }
 630 
 631     @Override public TKStage createTKEmbeddedStage(HostInterface host, AccessControlContext acc) {
 632         assertToolkitRunning();
 633         EmbeddedStage stage = new EmbeddedStage(host);
 634         stage.setSecurityContext(acc);
 635         return stage;
 636     }
 637 
 638     private static ScreenConfigurationAccessor screenAccessor =
 639         new ScreenConfigurationAccessor() {
 640             @Override public int getMinX(Object obj) {
 641                return ((Screen)obj).getX();
 642             }
 643             @Override public int getMinY(Object obj) {
 644                 return ((Screen)obj).getY();
 645             }
 646             @Override public int getWidth(Object obj) {
 647                 return ((Screen)obj).getWidth();
 648             }
 649             @Override public int getHeight(Object obj) {
 650                 return ((Screen)obj).getHeight();
 651             }
 652             @Override public int getVisualMinX(Object obj) {
 653                 return ((Screen)obj).getVisibleX();
 654             }
 655             @Override public int getVisualMinY(Object obj) {
 656                 return ((Screen)obj).getVisibleY();
 657             }
 658             @Override public int getVisualWidth(Object obj) {
 659                 return ((Screen)obj).getVisibleWidth();
 660             }
 661             @Override public int getVisualHeight(Object obj) {
 662                 return ((Screen)obj).getVisibleHeight();
 663             }
 664             @Override public float getDPI(Object obj) {
 665                 return ((Screen)obj).getResolutionX();
 666             }
 667             @Override public float getRecommendedOutputScaleX(Object obj) {
 668                 return ((Screen)obj).getRecommendedOutputScaleX();
 669             }
 670             @Override public float getRecommendedOutputScaleY(Object obj) {
 671                 return ((Screen)obj).getRecommendedOutputScaleY();
 672             }
 673         };
 674 
 675     @Override public ScreenConfigurationAccessor
 676                     setScreenConfigurationListener(final TKScreenConfigurationListener listener) {
 677         Screen.setEventHandler(new Screen.EventHandler() {
 678             @Override public void handleSettingsChanged() {
 679                 notifyScreenListener(listener);
 680             }
 681         });
 682         return screenAccessor;
 683     }
 684 
 685     private static void assignScreensAdapters() {
 686         GraphicsPipeline pipeline = GraphicsPipeline.getPipeline();
 687         for (Screen screen : Screen.getScreens()) {
 688             screen.setAdapterOrdinal(pipeline.getAdapterOrdinal(screen));
 689         }
 690     }
 691 
 692     private static void notifyScreenListener(TKScreenConfigurationListener listener) {
 693         assignScreensAdapters();
 694         listener.screenConfigurationChanged();
 695     }
 696 
 697     @Override public Object getPrimaryScreen() {
 698         return Screen.getMainScreen();
 699     }
 700 
 701     @Override public List&lt;?&gt; getScreens() {
 702         return Screen.getScreens();
 703     }
 704 
 705     @Override
 706     public ScreenConfigurationAccessor getScreenConfigurationAccessor() {
 707         return screenAccessor;
 708     }
 709 
 710     @Override
 711     public PerformanceTracker getPerformanceTracker() {
 712         return perfTracker;
 713     }
 714 
 715     @Override
 716     public PerformanceTracker createPerformanceTracker() {
 717         return new PerformanceTrackerImpl();
 718     }
 719 
 720     // Only currently called from the loadImage method below.  We do not
 721     // necessarily know what the worst render scale we will ever see is
 722     // because the user has control over that, but we should be loading
 723     // all dpi variants of an image at all times anyway and then using
 724     // whichever one is needed to respond to a given rendering request
 725     // rather than predetermining which one to use up front.  If we switch
 726     // to making that decision at render time then this method can go away.
 727     private float getMaxRenderScale() {
 728         if (_maxPixelScale == 0) {
 729             for (Object o : getScreens()) {
 730                 _maxPixelScale = Math.max(_maxPixelScale, ((Screen) o).getRecommendedOutputScaleX());
 731                 _maxPixelScale = Math.max(_maxPixelScale, ((Screen) o).getRecommendedOutputScaleY());
 732             }
 733         }
 734         return _maxPixelScale;
 735     }
 736 
 737     @Override public ImageLoader loadImage(String url, double width, double height, boolean preserveRatio, boolean smooth) {
 738         return new PrismImageLoader2(url, width, height, preserveRatio, getMaxRenderScale(), smooth);
 739     }
 740 
 741     @Override public ImageLoader loadImage(InputStream stream, double width, double height,
 742                                            boolean preserveRatio, boolean smooth) {
 743         return new PrismImageLoader2(stream, width, height, preserveRatio, smooth);
 744     }
 745 
 746     @Override public AbstractRemoteResource&lt;? extends ImageLoader&gt; loadImageAsync(
 747             AsyncOperationListener listener, String url,
 748             double width, double height, boolean preserveRatio, boolean smooth) {
 749         return new PrismImageLoader2.AsyncImageLoader(listener, url, width, height, preserveRatio, smooth);
 750     }
 751 
 752     // Note that this method should only be called by PlatformImpl.runLater
 753     // It should not be called directly by other FX code since the underlying
 754     // glass invokeLater method is not thread-safe with respect to toolkit
 755     // shutdown. Calling Platform.runLater *is* thread-safe even when the
 756     // toolkit is shutting down.
 757     @Override public void defer(Runnable runnable) {
 758         if (!toolkitRunning.get()) return;
 759 
 760         Application.invokeLater(runnable);
 761     }
 762 
 763     @Override public void exit() {
 764         // This method must run on the FX application thread
 765         checkFxUserThread();
 766 
 767         // Turn off pulses so no extraneous runnables are submitted
 768         pulseTimer.stop();
 769 
 770         // We need to wait for the last frame to finish so that the renderer
 771         // is not running while we are shutting down glass.
 772         PaintCollector.getInstance().waitForRenderingToComplete();
 773 
 774         notifyShutdownHooks();
 775 
 776         runWithRenderLock(() -&gt; {
 777             //TODO - should update glass scene view state
 778             //TODO - doesn&#39;t matter because we are exiting
 779             Application app = Application.GetApplication();
 780             app.terminate();
 781             return null;
 782         });
 783 
 784         dispose();
 785 
 786         super.exit();
 787     }
 788 
 789     public void dispose() {
 790         if (toolkitRunning.compareAndSet(true, false)) {
 791             pulseTimer.stop();
 792             renderer.stopRenderer();
 793 
 794             try {
 795                 AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 796                     Runtime.getRuntime().removeShutdownHook(shutdownHook);
 797                     return null;
 798                 });
 799             } catch (IllegalStateException ignore) {
 800                 // throw when shutdown hook already removed
 801             }
 802         }
 803     }
 804 
 805     @Override public boolean isForwardTraversalKey(KeyEvent e) {
 806         return (e.getCode() == KeyCode.TAB)
 807                    &amp;&amp; (e.getEventType() == KeyEvent.KEY_PRESSED)
 808                    &amp;&amp; !e.isShiftDown();
 809     }
 810 
 811     @Override public boolean isBackwardTraversalKey(KeyEvent e) {
 812         return (e.getCode() == KeyCode.TAB)
 813                    &amp;&amp; (e.getEventType() == KeyEvent.KEY_PRESSED)
 814                    &amp;&amp; e.isShiftDown();
 815     }
 816 
 817     private Map&lt;Object, Object&gt; contextMap = Collections.synchronizedMap(new HashMap&lt;&gt;());
 818     @Override public Map&lt;Object, Object&gt; getContextMap() {
 819         return contextMap;
 820     }
 821 
 822     @Override public int getRefreshRate() {
 823         if (pulseHZ == null) {
 824             return 60;
 825         } else {
 826             return pulseHZ;
 827         }
 828     }
 829 
 830     private DelayedRunnable animationRunnable;
 831     @Override public void setAnimationRunnable(DelayedRunnable animationRunnable) {
 832         if (animationRunnable != null) {
 833             animationRunning.set(true);
 834         }
 835         this.animationRunnable = animationRunnable;
 836     }
 837 
 838     @Override public void requestNextPulse() {
 839         nextPulseRequested.set(true);
 840     }
 841 
 842     @Override public void waitFor(Task t) {
 843         if (t.isFinished()) {
 844             return;
 845         }
 846     }
 847 
 848     @Override protected Object createColorPaint(Color color) {
 849         return new com.sun.prism.paint.Color(
 850                 (float)color.getRed(), (float)color.getGreen(),
 851                 (float)color.getBlue(), (float)color.getOpacity());
 852     }
 853 
 854     private com.sun.prism.paint.Color toPrismColor(Color color) {
 855         return (com.sun.prism.paint.Color) Toolkit.getPaintAccessor().getPlatformPaint(color);
 856     }
 857 
 858     private List&lt;com.sun.prism.paint.Stop&gt; convertStops(List&lt;Stop&gt; paintStops) {
 859         List&lt;com.sun.prism.paint.Stop&gt; stops =
 860             new ArrayList&lt;&gt;(paintStops.size());
 861         for (Stop s : paintStops) {
 862             stops.add(new com.sun.prism.paint.Stop(toPrismColor(s.getColor()),
 863                                                    (float) s.getOffset()));
 864         }
 865         return stops;
 866     }
 867 
 868     @Override protected Object createLinearGradientPaint(LinearGradient paint) {
 869         int cmi = com.sun.prism.paint.Gradient.REPEAT;
 870         CycleMethod cycleMethod = paint.getCycleMethod();
 871         if (cycleMethod == CycleMethod.NO_CYCLE) {
 872             cmi = com.sun.prism.paint.Gradient.PAD;
 873         } else if (cycleMethod == CycleMethod.REFLECT) {
 874             cmi = com.sun.prism.paint.Gradient.REFLECT;
 875         }
 876         // TODO: extract colors/offsets and pass them in directly...
 877         List&lt;com.sun.prism.paint.Stop&gt; stops = convertStops(paint.getStops());
 878         return new com.sun.prism.paint.LinearGradient(
 879             (float)paint.getStartX(), (float)paint.getStartY(), (float)paint.getEndX(), (float)paint.getEndY(),
 880             null, paint.isProportional(), cmi, stops);
 881     }
 882 
 883     @Override
 884     protected Object createRadialGradientPaint(RadialGradient paint) {
 885         float cx = (float)paint.getCenterX();
 886         float cy = (float)paint.getCenterY();
 887         float fa = (float)paint.getFocusAngle();
 888         float fd = (float)paint.getFocusDistance();
 889 
 890         int cmi = 0;
 891         if (paint.getCycleMethod() == CycleMethod.NO_CYCLE) {
 892             cmi = com.sun.prism.paint.Gradient.PAD;
 893         } else if (paint.getCycleMethod() == CycleMethod.REFLECT) {
 894             cmi = com.sun.prism.paint.Gradient.REFLECT;
 895         } else {
 896             cmi = com.sun.prism.paint.Gradient.REPEAT;
 897         }
 898 
 899         // TODO: extract colors/offsets and pass them in directly...
 900         List&lt;com.sun.prism.paint.Stop&gt; stops = convertStops(paint.getStops());
 901         return new com.sun.prism.paint.RadialGradient(cx, cy, fa, fd,
 902                 (float)paint.getRadius(), null, paint.isProportional(), cmi, stops);
 903     }
 904 
 905     @Override
 906     protected Object createImagePatternPaint(ImagePattern paint) {
 907         if (paint.getImage() == null) {
 908             return com.sun.prism.paint.Color.TRANSPARENT;
 909         } else {
 910             return new com.sun.prism.paint.ImagePattern(
 911                     (com.sun.prism.Image) Toolkit.getImageAccessor().getPlatformImage(paint.getImage()),
 912                     (float)paint.getX(),
 913                     (float)paint.getY(),
 914                     (float)paint.getWidth(),
 915                     (float)paint.getHeight(),
 916                     paint.isProportional(),
 917                     Toolkit.getPaintAccessor().isMutable(paint));
 918         }
 919     }
 920 
 921     static BasicStroke tmpStroke = new BasicStroke();
 922     private void initStroke(StrokeType pgtype, double strokewidth,
 923                             StrokeLineCap pgcap,
 924                             StrokeLineJoin pgjoin, float miterLimit,
 925                             float[] dashArray, float dashOffset)
 926     {
 927         int type;
 928         if (pgtype == StrokeType.CENTERED) {
 929             type = BasicStroke.TYPE_CENTERED;
 930         } else if (pgtype == StrokeType.INSIDE) {
 931             type = BasicStroke.TYPE_INNER;
 932         } else {
 933             type = BasicStroke.TYPE_OUTER;
 934         }
 935 
 936         int cap;
 937         if (pgcap == StrokeLineCap.BUTT) {
 938             cap = BasicStroke.CAP_BUTT;
 939         } else if (pgcap == StrokeLineCap.SQUARE) {
 940             cap = BasicStroke.CAP_SQUARE;
 941         } else {
 942             cap = BasicStroke.CAP_ROUND;
 943         }
 944 
 945         int join;
 946         if (pgjoin == StrokeLineJoin.BEVEL) {
 947             join = BasicStroke.JOIN_BEVEL;
 948         } else if (pgjoin == StrokeLineJoin.MITER) {
 949             join = BasicStroke.JOIN_MITER;
 950         } else {
 951             join = BasicStroke.JOIN_ROUND;
 952         }
 953 
 954         tmpStroke.set(type, (float) strokewidth, cap, join, miterLimit);
 955         if ((dashArray != null) &amp;&amp; (dashArray.length &gt; 0)) {
 956             tmpStroke.set(dashArray, dashOffset);
 957         } else {
 958             tmpStroke.set((float[])null, 0);
 959         }
 960     }
 961 
 962     @Override
 963     public void accumulateStrokeBounds(Shape shape, float bbox[],
 964                                        StrokeType pgtype,
 965                                        double strokewidth,
 966                                        StrokeLineCap pgcap,
 967                                        StrokeLineJoin pgjoin,
 968                                        float miterLimit,
 969                                        BaseTransform tx)
 970     {
 971 
 972         initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit, null, 0);
 973         if (tx.isTranslateOrIdentity()) {
 974             tmpStroke.accumulateShapeBounds(bbox, shape, tx);
 975         } else {
 976             Shape.accumulate(bbox, tmpStroke.createStrokedShape(shape), tx);
 977         }
 978     }
 979 
 980     @Override
 981     public boolean strokeContains(Shape shape, double x, double y,
 982                                   StrokeType pgtype,
 983                                   double strokewidth,
 984                                   StrokeLineCap pgcap,
 985                                   StrokeLineJoin pgjoin,
 986                                   float miterLimit)
 987     {
 988         initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit, null, 0);
 989         // TODO: The contains testing could be done directly without creating a Shape
 990         return tmpStroke.createStrokedShape(shape).contains((float) x, (float) y);
 991     }
 992 
 993     @Override
 994     public Shape createStrokedShape(Shape shape,
 995                                     StrokeType pgtype,
 996                                     double strokewidth,
 997                                     StrokeLineCap pgcap,
 998                                     StrokeLineJoin pgjoin,
 999                                     float miterLimit,
1000                                     float[] dashArray,
1001                                     float dashOffset) {
1002         initStroke(pgtype, strokewidth, pgcap, pgjoin, miterLimit,
1003                    dashArray, dashOffset);
1004         return tmpStroke.createStrokedShape(shape);
1005     }
1006 
1007     @Override public Dimension2D getBestCursorSize(int preferredWidth, int preferredHeight) {
1008         return CursorUtils.getBestCursorSize(preferredWidth, preferredHeight);
1009     }
1010 
1011     @Override public int getMaximumCursorColors() {
1012         return 2;
1013     }
1014 
1015     @Override public int getKeyCodeForChar(String character) {
1016         return (character.length() == 1)
1017                 ? com.sun.glass.events.KeyEvent.getKeyCodeForChar(
1018                           character.charAt(0))
1019                 : com.sun.glass.events.KeyEvent.VK_UNDEFINED;
1020     }
1021 
1022     @Override public PathElement[] convertShapeToFXPath(Object shape) {
1023         if (shape == null) {
1024             return new PathElement[0];
1025         }
1026         List&lt;PathElement&gt; elements = new ArrayList&lt;&gt;();
1027         // iterate over the shape and turn it into a series of path
1028         // elements
1029         com.sun.javafx.geom.Shape geomShape = (com.sun.javafx.geom.Shape) shape;
1030         PathIterator itr = geomShape.getPathIterator(null);
1031         PathIteratorHelper helper = new PathIteratorHelper(itr);
1032         PathIteratorHelper.Struct struct = new PathIteratorHelper.Struct();
1033 
1034         while (!helper.isDone()) {
1035             // true if WIND_EVEN_ODD, false if WIND_NON_ZERO
1036             boolean windEvenOdd = helper.getWindingRule() == PathIterator.WIND_EVEN_ODD;
1037             int type = helper.currentSegment(struct);
1038             PathElement el;
1039             if (type == PathIterator.SEG_MOVETO) {
1040                 el = new MoveTo(struct.f0, struct.f1);
1041             } else if (type == PathIterator.SEG_LINETO) {
1042                 el = new LineTo(struct.f0, struct.f1);
1043             } else if (type == PathIterator.SEG_QUADTO) {
1044                 el = new QuadCurveTo(
1045                     struct.f0,
1046                     struct.f1,
1047                     struct.f2,
1048                     struct.f3);
1049             } else if (type == PathIterator.SEG_CUBICTO) {
1050                 el = new CubicCurveTo (
1051                     struct.f0,
1052                     struct.f1,
1053                     struct.f2,
1054                     struct.f3,
1055                     struct.f4,
1056                     struct.f5);
1057             } else if (type == PathIterator.SEG_CLOSE) {
1058                 el = new ClosePath();
1059             } else {
1060                 throw new IllegalStateException(&quot;Invalid element type: &quot; + type);
1061             }
1062             helper.next();
1063             elements.add(el);
1064         }
1065 
1066         return elements.toArray(new PathElement[elements.size()]);
1067     }
1068 
1069     @Override public Filterable toFilterable(Image img) {
1070         return PrImage.create((com.sun.prism.Image) Toolkit.getImageAccessor().getPlatformImage(img));
1071     }
1072 
1073     @Override public FilterContext getFilterContext(Object config) {
1074         if (config == null || (!(config instanceof com.sun.glass.ui.Screen))) {
1075             return PrFilterContext.getDefaultInstance();
1076         }
1077         Screen screen = (Screen)config;
1078         return PrFilterContext.getInstance(screen);
1079     }
1080 
1081     @Override public AbstractMasterTimer getMasterTimer() {
1082         return MasterTimer.getInstance();
1083     }
1084 
1085     @Override public FontLoader getFontLoader() {
1086         return com.sun.javafx.font.PrismFontLoader.getInstance();
1087     }
1088 
1089     @Override public TextLayoutFactory getTextLayoutFactory() {
1090         return com.sun.javafx.text.PrismTextLayoutFactory.getFactory();
1091     }
1092 
1093     @Override public Object createSVGPathObject(SVGPath svgpath) {
1094         int windingRule = svgpath.getFillRule() == FillRule.NON_ZERO ? PathIterator.WIND_NON_ZERO : PathIterator.WIND_EVEN_ODD;
1095         Path2D path = new Path2D(windingRule);
1096         path.appendSVGPath(svgpath.getContent());
1097         return path;
1098     }
1099 
1100     @Override public Path2D createSVGPath2D(SVGPath svgpath) {
1101         int windingRule = svgpath.getFillRule() == FillRule.NON_ZERO ? PathIterator.WIND_NON_ZERO : PathIterator.WIND_EVEN_ODD;
1102         Path2D path = new Path2D(windingRule);
1103         path.appendSVGPath(svgpath.getContent());
1104         return path;
1105     }
1106 
1107     @Override public boolean imageContains(Object image, float x, float y) {
1108         if (image == null) {
1109             return false;
1110         }
1111 
1112         com.sun.prism.Image pImage = (com.sun.prism.Image)image;
1113         int intX = (int)x + pImage.getMinX();
1114         int intY = (int)y + pImage.getMinY();
1115 
1116         if (pImage.isOpaque()) {
1117             return true;
1118         }
1119 
1120         if (pImage.getPixelFormat() == PixelFormat.INT_ARGB_PRE) {
1121             IntBuffer ib = (IntBuffer) pImage.getPixelBuffer();
1122             int index = intX + intY * pImage.getRowLength();
1123             if (index &gt;= ib.limit()) {
1124                 return false;
1125             } else {
1126                 return (ib.get(index) &amp; 0xff000000) != 0;
1127             }
1128         } else if (pImage.getPixelFormat() == PixelFormat.BYTE_BGRA_PRE) {
1129             ByteBuffer bb = (ByteBuffer) pImage.getPixelBuffer();
1130             int index = intX * pImage.getBytesPerPixelUnit() + intY * pImage.getScanlineStride() + 3;
1131             if (index &gt;= bb.limit()) {
1132                 return false;
1133             } else {
1134                 return (bb.get(index) &amp; 0xff) != 0;
1135             }
1136         } else if (pImage.getPixelFormat() == PixelFormat.BYTE_ALPHA) {
1137             ByteBuffer bb = (ByteBuffer) pImage.getPixelBuffer();
1138             int index = intX * pImage.getBytesPerPixelUnit() + intY * pImage.getScanlineStride();
1139             if (index &gt;= bb.limit()) {
1140                 return false;
1141             } else {
1142                 return (bb.get(index) &amp; 0xff) != 0;
1143             }
1144         }
1145         return true;
1146     }
1147 
1148     @Override
1149     public boolean isNestedLoopRunning() {
1150         return Application.isNestedLoopRunning();
1151     }
1152 
1153     @Override
1154     public boolean isSupported(ConditionalFeature feature) {
1155         switch (feature) {
1156             case SCENE3D:
1157                 return GraphicsPipeline.getPipeline().is3DSupported();
1158             case EFFECT:
1159                 return GraphicsPipeline.getPipeline().isEffectSupported();
1160             case SHAPE_CLIP:
1161                 return true;
1162             case INPUT_METHOD:
1163                 return Application.GetApplication().supportsInputMethods();
1164             case TRANSPARENT_WINDOW:
1165                 return Application.GetApplication().supportsTransparentWindows();
1166             case UNIFIED_WINDOW:
1167                 return Application.GetApplication().supportsUnifiedWindows();
1168             case TWO_LEVEL_FOCUS:
1169                 return Application.GetApplication().hasTwoLevelFocus();
1170             case VIRTUAL_KEYBOARD:
1171                 return Application.GetApplication().hasVirtualKeyboard();
1172             case INPUT_TOUCH:
1173                 return Application.GetApplication().hasTouch();
1174             case INPUT_MULTITOUCH:
1175                 return Application.GetApplication().hasMultiTouch();
1176             case INPUT_POINTER:
1177                 return Application.GetApplication().hasPointer();
1178             default:
1179                 return false;
1180         }
1181     }
1182 
1183     @Override
1184     public boolean isMSAASupported() {
1185         return  GraphicsPipeline.getPipeline().isMSAASupported();
1186     }
1187 
1188     static TransferMode clipboardActionToTransferMode(final int action) {
1189         switch (action) {
1190             case Clipboard.ACTION_NONE:
1191                 return null;
1192             case Clipboard.ACTION_COPY:
1193             //IE drop action for URL copy
1194             case Clipboard.ACTION_COPY | Clipboard.ACTION_REFERENCE:
1195                 return TransferMode.COPY;
1196             case Clipboard.ACTION_MOVE:
1197             //IE drop action for URL move
1198             case Clipboard.ACTION_MOVE | Clipboard.ACTION_REFERENCE:
1199                 return TransferMode.MOVE;
1200             case Clipboard.ACTION_REFERENCE:
1201                 return TransferMode.LINK;
1202             case Clipboard.ACTION_ANY:
1203                 return TransferMode.COPY; // select a reasonable trasnfer mode as workaround until RT-22840
1204         }
1205         return null;
1206     }
1207 
1208     private QuantumClipboard clipboard;
1209     @Override public TKClipboard getSystemClipboard() {
1210         if (clipboard == null) {
1211             clipboard = QuantumClipboard.getClipboardInstance(new ClipboardAssistance(com.sun.glass.ui.Clipboard.SYSTEM));
1212         }
1213         return clipboard;
1214     }
1215 
1216     private GlassSystemMenu systemMenu = new GlassSystemMenu();
1217     @Override public TKSystemMenu getSystemMenu() {
1218         return systemMenu;
1219     }
1220 
1221     @Override public TKClipboard getNamedClipboard(String name) {
1222         return null;
1223     }
1224 
1225     @Override public void startDrag(TKScene scene, Set&lt;TransferMode&gt; tm, TKDragSourceListener l, Dragboard dragboard) {
1226         if (dragboard == null) {
1227             throw new IllegalArgumentException(&quot;dragboard should not be null&quot;);
1228         }
1229 
1230         GlassScene view = (GlassScene)scene;
1231         view.setTKDragSourceListener(l);
1232 
1233         QuantumClipboard gc = (QuantumClipboard) DragboardHelper.getPeer(dragboard);
1234         gc.setSupportedTransferMode(tm);
1235         gc.flush();
1236 
1237         // flush causes a modal DnD event loop, when we return, close the clipboard
1238         gc.close();
1239     }
1240 
1241     @Override public void enableDrop(TKScene s, TKDropTargetListener l) {
1242 
1243         assert s instanceof GlassScene;
1244 
1245         GlassScene view = (GlassScene)s;
1246         view.setTKDropTargetListener(l);
1247     }
1248 
1249     @Override public void registerDragGestureListener(TKScene s, Set&lt;TransferMode&gt; tm, TKDragGestureListener l) {
1250 
1251         assert s instanceof GlassScene;
1252 
1253         GlassScene view = (GlassScene)s;
1254         view.setTKDragGestureListener(l);
1255     }
1256 
1257     @Override
1258     public void installInputMethodRequests(TKScene scene, InputMethodRequests requests) {
1259 
1260         assert scene instanceof GlassScene;
1261 
1262         GlassScene view = (GlassScene)scene;
1263         view.setInputMethodRequests(requests);
1264     }
1265 
1266     static class QuantumImage implements com.sun.javafx.tk.ImageLoader, ResourceFactoryListener {
1267 
1268         // cache rt here
1269         private com.sun.prism.RTTexture rt;
1270         private com.sun.prism.Image image;
1271         private ResourceFactory rf;
1272 
1273         QuantumImage(com.sun.prism.Image image) {
1274             this.image = image;
1275         }
1276 
1277         QuantumImage(PixelBuffer&lt;Buffer&gt; pixelBuffer) {
1278             switch (pixelBuffer.getPixelFormat().getType()) {
1279                 case INT_ARGB_PRE:
1280                     image = com.sun.prism.Image.fromPixelBufferPreData(PixelFormat.INT_ARGB_PRE,
1281                             pixelBuffer.getBuffer(), pixelBuffer.getWidth(), pixelBuffer.getHeight());
1282                     break;
1283 
1284                 case BYTE_BGRA_PRE:
1285                     image = com.sun.prism.Image.fromPixelBufferPreData(PixelFormat.BYTE_BGRA_PRE,
1286                             pixelBuffer.getBuffer(), pixelBuffer.getWidth(), pixelBuffer.getHeight());
1287                     break;
1288 
1289                 default:
1290                     throw new InternalError(&quot;Unsupported PixelFormat: &quot; + pixelBuffer.getPixelFormat().getType());
1291             }
1292         }
1293 
1294         RTTexture getRT(int w, int h, ResourceFactory rfNew) {
1295             boolean rttOk = rt != null &amp;&amp; rf == rfNew &amp;&amp;
1296                     rt.getContentWidth() == w &amp;&amp; rt.getContentHeight() == h;
1297             if (rttOk) {
1298                 rt.lock();
1299                 if (rt.isSurfaceLost()) {
1300                     rttOk = false;
1301                 }
1302             }
1303 
1304             if (!rttOk) {
1305                 if (rt != null) {
1306                     rt.dispose();
1307                 }
1308                 if (rf != null) {
1309                     rf.removeFactoryListener(this);
1310                     rf = null;
1311                 }
1312                 rt = rfNew.createRTTexture(w, h, WrapMode.CLAMP_TO_ZERO);
1313                 if (rt != null) {
1314                     rf = rfNew;
1315                     rf.addFactoryListener(this);
1316                 }
1317             }
1318 
1319             return rt;
1320         }
1321 
1322         void dispose() {
1323             if (rt != null) {
1324                 rt.dispose();
1325                 rt = null;
1326             }
1327         }
1328 
1329         void setImage(com.sun.prism.Image img) {
1330             image = img;
1331         }
1332 
1333         @Override
1334         public Exception getException() {
1335             return (image == null)
1336                     ? new IllegalStateException(&quot;Unitialized image&quot;)
1337                     : null;
1338         }
1339         @Override
1340         public int getFrameCount() { return 1; }
1341         @Override
1342         public PlatformImage getFrame(int index) { return image; }
1343         @Override
1344         public int getFrameDelay(int index) { return 0; }
1345         @Override
1346         public int getLoopCount() { return 0; }
1347         @Override
1348         public double getWidth() { return image.getWidth(); }
1349         @Override
1350         public double getHeight() { return image.getHeight(); }
1351         @Override
1352         public void factoryReset() { dispose(); }
1353         @Override
1354         public void factoryReleased() { dispose(); }
1355     }
1356 
1357     @Override public ImageLoader loadPlatformImage(Object platformImage) {
1358         if (platformImage instanceof QuantumImage) {
1359             return (QuantumImage)platformImage;
1360         }
1361 
1362         if (platformImage instanceof com.sun.prism.Image) {
1363             return new QuantumImage((com.sun.prism.Image) platformImage);
1364         }
1365 
1366         if (platformImage instanceof PixelBuffer) {
1367             return new QuantumImage((PixelBuffer&lt;Buffer&gt;) platformImage);
1368         }
1369 
1370         throw new UnsupportedOperationException(&quot;unsupported class for loadPlatformImage&quot;);
1371     }
1372 
1373     @Override
1374     public PlatformImage createPlatformImage(int w, int h) {
1375         ByteBuffer bytebuf = ByteBuffer.allocate(w * h * 4);
1376         return com.sun.prism.Image.fromByteBgraPreData(bytebuf, w, h);
1377     }
1378 
1379     @Override
1380     public Object renderToImage(ImageRenderingContext p) {
1381         Object saveImage = p.platformImage;
1382         final ImageRenderingContext params = p;
1383         final com.sun.prism.paint.Paint currentPaint = p.platformPaint instanceof com.sun.prism.paint.Paint ?
1384                 (com.sun.prism.paint.Paint)p.platformPaint : null;
1385 
1386         RenderJob re = new RenderJob(new Runnable() {
1387 
1388             private com.sun.prism.paint.Color getClearColor() {
1389                 if (currentPaint == null) {
1390                     return com.sun.prism.paint.Color.WHITE;
1391                 } else if (currentPaint.getType() == com.sun.prism.paint.Paint.Type.COLOR) {
1392                     return (com.sun.prism.paint.Color) currentPaint;
1393                 } else if (currentPaint.isOpaque()) {
1394                     return com.sun.prism.paint.Color.TRANSPARENT;
1395                 } else {
1396                     return com.sun.prism.paint.Color.WHITE;
1397                 }
1398             }
1399 
1400             private void draw(Graphics g, int x, int y, int w, int h) {
1401                 g.setLights(params.lights);
1402                 g.setDepthBuffer(params.depthBuffer);
1403 
1404                 g.clear(getClearColor());
1405                 if (currentPaint != null &amp;&amp;
1406                         currentPaint.getType() != com.sun.prism.paint.Paint.Type.COLOR) {
1407                     g.getRenderTarget().setOpaque(currentPaint.isOpaque());
1408                     g.setPaint(currentPaint);
1409                     g.fillQuad(0, 0, w, h);
1410                 }
1411 
1412                 // Set up transform
1413                 if (x != 0 || y != 0) {
1414                     g.translate(-x, -y);
1415                 }
1416                 if (params.transform != null) {
1417                     g.transform(params.transform);
1418                 }
1419 
1420                 if (params.root != null) {
1421                     if (params.camera != null) {
1422                         g.setCamera(params.camera);
1423                     }
1424                     NGNode ngNode = params.root;
1425                     ngNode.render(g);
1426                 }
1427 
1428             }
1429 
1430             private void renderTile(int x, int xOffset, int y, int yOffset, int w, int h,
1431                                     IntBuffer buffer, ResourceFactory rf, QuantumImage tileImg, QuantumImage targetImg) {
1432                 RTTexture rt = tileImg.getRT(w, h, rf);
1433                 if (rt == null) {
1434                     return;
1435                 }
1436                 Graphics g = rt.createGraphics();
1437                 draw(g, x + xOffset, y + yOffset, w, h);
1438                 int[] pixels = rt.getPixels();
1439                 if (pixels != null) {
1440                     buffer.put(pixels);
1441                 } else {
1442                     rt.readPixels(buffer, rt.getContentX(), rt.getContentY(), w, h);
1443                 }
1444                 //Copy tile&#39;s pixels into the target image
1445                 targetImg.image.setPixels(xOffset, yOffset, w, h,
1446                         javafx.scene.image.PixelFormat.getIntArgbPreInstance(), buffer, w);
1447                 rt.unlock();
1448             }
1449 
1450             private void renderWholeImage(int x, int y, int w, int h, ResourceFactory rf, QuantumImage pImage) {
1451                 RTTexture rt = pImage.getRT(w, h, rf);
1452                 if (rt == null) {
1453                     return;
1454                 }
1455                 Graphics g = rt.createGraphics();
1456                 draw(g, x, y, w, h);
1457                 int[] pixels = rt.getPixels();
1458                 if (pixels != null) {
1459                     pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(pixels, w, h));
1460                 } else {
1461                     IntBuffer ib = IntBuffer.allocate(w * h);
1462                     if (rt.readPixels(ib, rt.getContentX(), rt.getContentY(), w, h)) {
1463                         pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(ib, w, h));
1464                     } else {
1465                         pImage.dispose();
1466                         pImage = null;
1467                     }
1468                 }
1469                 rt.unlock();
1470             }
1471 
1472             private int computeOptimumTileSize(int size, int maxSize) {
1473                 return computeOptimumTileSize(size, maxSize, null);
1474             }
1475 
1476             private int computeOptimumTileSize(int size, int maxSize, boolean[] isDivExact) {
1477                 // This method attempts to find the smallest exact divider for the provided `size`
1478                 // while the result of the division is less than `maxSize`.
1479                 // It tests all potential dividers from 2 to 6 and returns the result of the division
1480                 // if all conditions can be satisfied or, failing that, `maxSize`.
1481                 // If non-null, the value for `isDivExact` is set so as to reflect whether or not
1482                 // an exact divider could be found.
1483                 for (int n = 2; n &lt;= 6; n++) {
1484                     int optimumSize = size / n;
1485                     if (optimumSize &lt;= maxSize &amp;&amp; optimumSize * n == size) {
1486                         if (isDivExact != null &amp;&amp; isDivExact.length &gt; 0) {
1487                             isDivExact[0] = true;
1488                         }
1489                         return optimumSize;
1490                     }
1491                 }
1492                 if (isDivExact != null &amp;&amp; isDivExact.length &gt; 0) {
1493                     isDivExact[0]= false;
1494                 }
1495                 return maxSize;
1496             }
1497 
1498             @Override
1499             public void run() {
1500 
1501                 ResourceFactory rf = GraphicsPipeline.getDefaultResourceFactory();
1502 
1503                 if (!rf.isDeviceReady()) {
1504                     return;
1505                 }
1506 
1507                 int x = params.x;
1508                 int y = params.y;
1509                 int w = params.width;
1510                 int h = params.height;
1511 
1512                 if (w &lt;= 0 || h &lt;= 0) {
1513                     return;
1514                 }
1515 
1516                 boolean errored = false;
1517                 // A temp QuantumImage used only as a RTT cache for rendering tiles.
1518                 var tileRttCache = new QuantumImage((com.sun.prism.Image) null);
1519                 try {
1520                     QuantumImage pImage = (params.platformImage instanceof QuantumImage) ?
1521                             (QuantumImage) params.platformImage : new QuantumImage((com.sun.prism.Image) null);
1522 
1523                     int maxTextureSize = rf.getMaximumTextureSize();
1524                     if (h &gt; maxTextureSize || w &gt; maxTextureSize) {
1525                         // The requested size for the screenshot is too big to fit a single texture,
1526                         // so we need to take several snapshot tiles and merge them into pImage
1527                         if (pImage.image == null) {
1528                             pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(IntBuffer.allocate(w * h), w, h));
1529                         }
1530                         // Find out if it is possible to divide up the image in tiles of the same size
1531                         int tileWidth = computeOptimumTileSize(w, maxTextureSize);
1532                         var exactHeightDivFound = new boolean[]{false};
1533                         int tileHeight = computeOptimumTileSize(h, maxTextureSize, exactHeightDivFound);
1534                         IntBuffer buffer = IntBuffer.allocate(tileWidth * tileHeight);
1535                         // In order to minimize the number of time we have to resize the underlying
1536                         // surface for capturing a tile, choose a dimension that has an exact divider
1537                         // (if any) to be processed in the inner most loop.
1538                         // E.g. looping on width then height in the example bellow requires four
1539                         // surface resizing, whereas the opposite requires only two:
1540                         //
1541                         //       for (w;;)                    for (h;;)
1542                         //           for(h;;)                     for(w;;)
1543                         //       -----------------           -----------------
1544                         //       |       |       |           |       |       |
1545                         //       |   1   |   3   |           |   1   |   2   |
1546                         //    h  |       |       |        h  |       |       |
1547                         //       -----------------           -----------------
1548                         //       |   2   |   4   |           |   3   |   4   |
1549                         //       -----------------           -----------------
1550                         //               w                           w
1551 
1552 
1553 
1554                         if (exactHeightDivFound[0]) {
1555                             for (int xOffset = 0; xOffset &lt; w; xOffset += tileWidth) {
1556                                 tileWidth = Math.min(tileWidth, w - xOffset);
1557                                 for (int yOffset = 0; yOffset &lt; h; yOffset += tileHeight) {
1558                                     tileHeight = Math.min(tileHeight, h - yOffset);
1559                                     renderTile(x, xOffset, y, yOffset, tileWidth, tileHeight,
1560                                             buffer, rf, tileRttCache, pImage);
1561                                 }
1562                             }
1563                         } else {
1564                             for (int yOffset = 0; yOffset &lt; h; yOffset += tileHeight) {
1565                                 tileHeight = Math.min(tileHeight, h - yOffset);
1566                                 for (int xOffset = 0; xOffset &lt; w; xOffset += tileWidth) {
1567                                     tileWidth = Math.min(tileWidth, w - xOffset);
1568                                     renderTile(x, xOffset, y, yOffset, tileWidth, tileHeight,
1569                                             buffer, rf, tileRttCache, pImage);
1570                                 }
1571                             }
1572                         }
1573                     } else {
1574                         // The requested size for the screenshot fits max texture size,
1575                         // so we can directly render it in the target image.
1576                         renderWholeImage(x, y, w, h, rf, pImage);
1577                     }
1578                     params.platformImage = pImage;
1579                 } catch (Throwable t) {
1580                     errored = true;
1581                     t.printStackTrace(System.err);
1582                 } finally {
1583                     tileRttCache.dispose();
1584                     Disposer.cleanUp();
1585                     rf.getTextureResourcePool().freeDisposalRequestedAndCheckResources(errored);
1586                 }
1587             }
1588         });
1589 
1590         final CountDownLatch latch = new CountDownLatch(1);
1591         re.setCompletionListener(job -&gt; latch.countDown());
1592         addRenderJob(re);
1593 
1594         do {
1595             try {
1596                 latch.await();
1597                 break;
1598             } catch (InterruptedException ex) {
1599                 ex.printStackTrace();
1600             }
1601         } while (true);
1602 
1603         Object image = params.platformImage;
1604         params.platformImage = saveImage;
1605 
1606         return image;
1607     }
1608 
1609     @Override
1610     public FileChooserResult showFileChooser(final TKStage ownerWindow,
1611                                       final String title,
1612                                       final File initialDirectory,
1613                                       final String initialFileName,
1614                                       final FileChooserType fileChooserType,
1615                                       final List&lt;FileChooser.ExtensionFilter&gt;
1616                                               extensionFilters,
1617                                       final FileChooser.ExtensionFilter selectedFilter) {
1618         WindowStage blockedStage = null;
1619         try {
1620             // NOTE: we block the owner of the owner deliberately.
1621             //       The native system blocks the nearest owner itself.
1622             //       Otherwise sheets on Mac are unusable.
1623             blockedStage = blockOwnerStage(ownerWindow);
1624 
1625             return CommonDialogs.showFileChooser(
1626                     (ownerWindow instanceof WindowStage)
1627                             ? ((WindowStage) ownerWindow).getPlatformWindow()
1628                             : null,
1629                     initialDirectory,
1630                     initialFileName,
1631                     title,
1632                     (fileChooserType == FileChooserType.SAVE)
1633                             ? CommonDialogs.Type.SAVE
1634                             : CommonDialogs.Type.OPEN,
1635                     (fileChooserType == FileChooserType.OPEN_MULTIPLE),
1636                     convertExtensionFilters(extensionFilters),
1637                     extensionFilters.indexOf(selectedFilter));
1638         } finally {
1639             if (blockedStage != null) {
1640                 blockedStage.setEnabled(true);
1641             }
1642         }
1643     }
1644 
1645     @Override
1646     public File showDirectoryChooser(final TKStage ownerWindow,
1647                                      final String title,
1648                                      final File initialDirectory) {
1649         WindowStage blockedStage = null;
1650         try {
1651             // NOTE: we block the owner of the owner deliberately.
1652             //       The native system blocks the nearest owner itself.
1653             //       Otherwise sheets on Mac are unusable.
1654             blockedStage = blockOwnerStage(ownerWindow);
1655 
1656             return CommonDialogs.showFolderChooser(
1657                     (ownerWindow instanceof WindowStage)
1658                             ? ((WindowStage) ownerWindow).getPlatformWindow()
1659                             : null,
1660                     initialDirectory, title);
1661         } finally {
1662             if (blockedStage != null) {
1663                 blockedStage.setEnabled(true);
1664             }
1665         }
1666     }
1667 
1668     private WindowStage blockOwnerStage(final TKStage stage) {
1669         if (stage instanceof WindowStage) {
1670             final TKStage ownerStage = ((WindowStage) stage).getOwner();
1671             if (ownerStage instanceof WindowStage) {
1672                 final WindowStage ownerWindowStage = (WindowStage) ownerStage;
1673                 ownerWindowStage.setEnabled(false);
1674                 return ownerWindowStage;
1675             }
1676         }
1677 
1678         return null;
1679     }
1680 
1681     private static List&lt;CommonDialogs.ExtensionFilter&gt;
1682             convertExtensionFilters(final List&lt;FileChooser.ExtensionFilter&gt;
1683                                             extensionFilters) {
1684         final CommonDialogs.ExtensionFilter[] glassExtensionFilters =
1685                 new CommonDialogs.ExtensionFilter[extensionFilters.size()];
1686 
1687         int i = 0;
1688         for (final FileChooser.ExtensionFilter extensionFilter:
1689                  extensionFilters) {
1690             glassExtensionFilters[i++] =
1691                     new CommonDialogs.ExtensionFilter(
1692                             extensionFilter.getDescription(),
1693                             extensionFilter.getExtensions());
1694         }
1695 
1696         return Arrays.asList(glassExtensionFilters);
1697     }
1698 
1699     @Override
1700     public long getMultiClickTime() {
1701         return View.getMultiClickTime();
1702     }
1703 
1704     @Override
1705     public int getMultiClickMaxX() {
1706         return View.getMultiClickMaxX();
1707     }
1708 
1709     @Override
1710     public int getMultiClickMaxY() {
1711         return View.getMultiClickMaxY();
1712     }
1713 
1714     @Override
1715     public String getThemeName() {
1716         return Application.GetApplication().getHighContrastTheme();
1717     }
1718 
1719     @Override
1720     public GlassRobot createRobot() {
1721         return com.sun.glass.ui.Application.GetApplication().createRobot();
1722     }
1723 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/scene/Scene.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene;
  27 
  28 import com.sun.glass.ui.Application;
  29 import com.sun.glass.ui.Accessible;
  30 import com.sun.javafx.util.Logging;
  31 import com.sun.javafx.util.Utils;
  32 import com.sun.javafx.application.PlatformImpl;
  33 import com.sun.javafx.collections.TrackableObservableList;
  34 import com.sun.javafx.css.StyleManager;
  35 import com.sun.javafx.cursor.CursorFrame;
  36 import com.sun.javafx.event.EventQueue;
  37 import com.sun.javafx.geom.PickRay;
  38 import com.sun.javafx.geom.Vec3d;
  39 import com.sun.javafx.geom.transform.BaseTransform;
  40 import com.sun.javafx.perf.PerformanceTracker;
  41 import com.sun.javafx.scene.CssFlags;
  42 import com.sun.javafx.scene.LayoutFlags;
  43 import com.sun.javafx.scene.SceneEventDispatcher;
  44 import com.sun.javafx.scene.SceneHelper;
  45 import com.sun.javafx.scene.input.DragboardHelper;
  46 import com.sun.javafx.scene.input.ExtendedInputMethodRequests;
  47 import com.sun.javafx.scene.input.InputEventUtils;
  48 import com.sun.javafx.scene.input.PickResultChooser;
  49 import com.sun.javafx.scene.traversal.Direction;
  50 import com.sun.javafx.scene.traversal.SceneTraversalEngine;
  51 import com.sun.javafx.scene.traversal.TopMostTraversalEngine;
  52 import com.sun.javafx.sg.prism.NGCamera;
  53 import com.sun.javafx.sg.prism.NGLightBase;
  54 import com.sun.javafx.tk.*;
  55 import com.sun.prism.impl.PrismSettings;
  56 
  57 import javafx.animation.KeyFrame;
  58 import javafx.animation.Timeline;
  59 import javafx.application.ConditionalFeature;
  60 import javafx.application.Platform;
  61 import javafx.beans.DefaultProperty;
  62 import javafx.beans.InvalidationListener;
  63 import javafx.beans.NamedArg;
  64 import javafx.beans.property.*;
  65 import javafx.collections.FXCollections;
  66 import javafx.collections.ListChangeListener.Change;
  67 import javafx.collections.ObservableList;
  68 import javafx.collections.ObservableMap;
  69 import javafx.css.CssMetaData;
  70 import javafx.css.StyleableObjectProperty;
  71 import javafx.event.*;
  72 import javafx.geometry.*;
  73 import javafx.scene.image.WritableImage;
  74 import javafx.scene.input.*;
  75 import javafx.scene.paint.Color;
  76 import javafx.scene.paint.Paint;
  77 import javafx.stage.PopupWindow;
  78 import javafx.stage.Stage;
  79 import javafx.stage.StageStyle;
  80 import javafx.stage.Window;
  81 import javafx.util.Callback;
  82 import javafx.util.Duration;
  83 import com.sun.javafx.logging.PlatformLogger;
  84 import com.sun.javafx.logging.PlatformLogger.Level;
  85 
  86 import java.security.AccessControlContext;
  87 import java.security.AccessController;
  88 import java.security.PrivilegedAction;
  89 import java.util.*;
  90 import java.util.concurrent.CopyOnWriteArrayList;
  91 
  92 import com.sun.javafx.logging.PulseLogger;
  93 
  94 import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;
  95 import com.sun.javafx.scene.NodeHelper;
  96 import com.sun.javafx.stage.WindowHelper;
  97 import com.sun.javafx.scene.input.ClipboardHelper;
  98 import com.sun.javafx.scene.input.TouchPointHelper;
  99 import java.lang.ref.WeakReference;
 100 
 101 /**
 102  * The JavaFX {@code Scene} class is the container for all content in a scene graph.
 103  * The background of the scene is filled as specified by the {@code fill} property.
 104  * &lt;p&gt;
 105  * The application must specify the root {@code Node} for the scene graph by setting
 106  * the {@code root} property.   If a {@code Group} is used as the root, the
 107  * contents of the scene graph will be clipped by the scene&#39;s width and height and
 108  * changes to the scene&#39;s size (if user resizes the stage) will not alter the
 109  * layout of the scene graph. If a resizable node (layout {@code Region} or
 110  * {@code Control}) is set as the root, then the root&#39;s size will track the
 111  * scene&#39;s size, causing the contents to be relayed out as necessary.
 112  * &lt;p&gt;
 113  * The scene&#39;s size may be initialized by the application during construction.
 114  * If no size is specified, the scene will automatically compute its initial
 115  * size based on the preferred size of its content. If only one dimension is specified,
 116  * the other dimension is computed using the specified dimension, respecting content bias
 117  * of a root.
 118  * &lt;p&gt;
 119  * An application may request depth buffer support or scene anti-aliasing
 120  * support at the creation of a {@code Scene}. A scene with only 2D shapes and
 121  * without any 3D transforms does not need a depth buffer nor scene
 122  * anti-aliasing support. A scene containing 3D shapes or 2D shapes with 3D
 123  * transforms may use depth buffer support for proper depth sorted rendering; to
 124  * avoid depth fighting (also known as Z fighting), disable depth testing on 2D
 125  * shapes that have no 3D transforms. See
 126  * {@link Node#depthTestProperty() depthTest} for more information. A scene with
 127  * 3D shapes may enable scene anti-aliasing to improve its rendering quality.
 128  * &lt;p&gt;
 129  * The depthBuffer and antiAliasing flags are conditional features. With the
 130  * respective default values of: false and {@code SceneAntialiasing.DISABLED}.
 131  * See {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 132  * for more information.
 133  * &lt;p&gt;
 134  * A default headlight will be added to a scene that contains one or more
 135  * {@code Shape3D} nodes, but no light nodes. This light source is a
 136  * {@code Color.WHITE} {@code PointLight} placed at the camera position.
 137  *
 138  * &lt;p&gt;
 139  * A {@code Scene} may be created and modified on any thread until it is attached
 140  * to a {@link Window} that is {@link Window#isShowing() showing}.
 141  * After that, it must be modified only on the JavaFX Application Thread.
 142  * Note that {@code Scene} is not thread-safe; modifying a {@code Scene} on
 143  * multiple threads at the same time will lead to unpredictable results and
 144  * must be avoided.
 145  * &lt;/p&gt;
 146  *
 147  * &lt;p&gt;
 148  * The JavaFX Application Thread is created as part of the startup process for
 149  * the JavaFX runtime. See the {@link javafx.application.Application} class and
 150  * the {@link Platform#startup(Runnable)} method for more information.
 151  * &lt;/p&gt;
 152  *
 153  * &lt;p&gt;Example:&lt;/p&gt;
 154  *
 155  * &lt;pre&gt;
 156 import javafx.scene.*;
 157 import javafx.scene.paint.*;
 158 import javafx.scene.shape.*;
 159 
 160 Group root = new Group();
 161 Scene s = new Scene(root, 300, 300, Color.BLACK);
 162 
 163 Rectangle r = new Rectangle(25,25,250,250);
 164 r.setFill(Color.BLUE);
 165 
 166 root.getChildren().add(r);
 167  * &lt;/pre&gt;
 168  *
 169  * @since JavaFX 2.0
 170  */
 171 @DefaultProperty(&quot;root&quot;)
 172 public class Scene implements EventTarget {
 173 
 174     private double widthSetByUser = -1.0;
 175     private double heightSetByUser = -1.0;
 176     private boolean sizeInitialized = false;
 177     private final boolean depthBuffer;
 178     private final SceneAntialiasing antiAliasing;
 179 
 180     private EnumSet&lt;DirtyBits&gt; dirtyBits = EnumSet.noneOf(DirtyBits.class);
 181 
 182     final AccessControlContext acc = AccessController.getContext();
 183 
 184     private Camera defaultCamera;
 185 
 186     /**
 187      * A node that is temporarily responsible for the FOCUS_NODE
 188      * accessibility attribute. E.g. a currently active MenuBar.
 189      */
 190     private Node transientFocusContainer;
 191 
 192     //Neither width nor height are initialized and will be calculated according to content when this Scene
 193     //is shown for the first time.
 194 //    public Scene() {
 195 //        //this(-1, -1, (Parent) new Group());
 196 //        this(-1, -1, (Parent)null);
 197 //    }
 198 
 199     /**
 200      * Creates a Scene for a specific root Node.
 201      *
 202      * @param root The root node of the scene graph
 203      *
 204      * @throws NullPointerException if root is null
 205      */
 206     public Scene(@NamedArg(&quot;root&quot;) Parent root) {
 207         this(root, -1, -1, Color.WHITE, false, SceneAntialiasing.DISABLED);
 208     }
 209 
 210 //Public constructor initializing public-init properties
 211 //When width &lt; 0, and or height &lt; 0 is passed, then width and/or height are understood as unitialized
 212 //Unitialized dimension is calculated when Scene is shown for the first time.
 213 //    public Scene(
 214 //            @Default(&quot;-1&quot;) double width,
 215 //            @Default(&quot;-1&quot;) double height) {
 216 //        //this(width, height, (Parent)new Group());
 217 //        this(width, height, (Parent)null);
 218 //    }
 219 //
 220 //    public Scene(double width, double height, Paint fill) {
 221 //        //this(width, height, (Parent) new Group());
 222 //        this(width, height, (Parent)null);
 223 //        setFill(fill);
 224 //    }
 225 
 226     /**
 227      * Creates a Scene for a specific root Node with a specific size.
 228      *
 229      * @param root The root node of the scene graph
 230      * @param width The width of the scene
 231      * @param height The height of the scene
 232      *
 233      * @throws NullPointerException if root is null
 234      */
 235     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height) {
 236         this(root, width, height, Color.WHITE, false, SceneAntialiasing.DISABLED);
 237     }
 238 
 239     /**
 240      * Creates a Scene for a specific root Node with a fill.
 241      *
 242      * @param root The parent
 243      * @param fill The fill
 244      *
 245      * @throws NullPointerException if root is null
 246      */
 247     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 248         this(root, -1, -1, fill, false, SceneAntialiasing.DISABLED);
 249     }
 250 
 251     /**
 252      * Creates a Scene for a specific root Node with a specific size and fill.
 253      *
 254      * @param root The root node of the scene graph
 255      * @param width The width of the scene
 256      * @param height The height of the scene
 257      * @param fill The fill
 258      *
 259      * @throws NullPointerException if root is null
 260      */
 261     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(&quot;width&quot;) double width, @NamedArg(&quot;height&quot;) double height,
 262             @NamedArg(value=&quot;fill&quot;, defaultValue=&quot;WHITE&quot;) Paint fill) {
 263         this(root, width, height, fill, false, SceneAntialiasing.DISABLED);
 264     }
 265 
 266     /**
 267      * Constructs a scene consisting of a root, with a dimension of width and
 268      * height, and specifies whether a depth buffer is created for this scene.
 269      * &lt;p&gt;
 270      * A scene with only 2D shapes and without any 3D transforms does not need a
 271      * depth buffer. A scene containing 3D shapes or 2D shapes with 3D
 272      * transforms may use depth buffer support for proper depth sorted
 273      * rendering; to avoid depth fighting (also known as Z fighting), disable
 274      * depth testing on 2D shapes that have no 3D transforms. See
 275      * {@link Node#depthTestProperty() depthTest} for more information.
 276      *
 277      * @param root The root node of the scene graph
 278      * @param width The width of the scene
 279      * @param height The height of the scene
 280      * @param depthBuffer The depth buffer flag
 281      * &lt;p&gt;
 282      * The depthBuffer flag is a conditional feature and its default value is
 283      * false. See
 284      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 285      * for more information.
 286      *
 287      * @throws NullPointerException if root is null
 288      *
 289      * @see javafx.scene.Node#setDepthTest(DepthTest)
 290      */
 291     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height, @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer) {
 292         this(root, width, height, Color.WHITE, depthBuffer, SceneAntialiasing.DISABLED);
 293     }
 294 
 295     /**
 296      * Constructs a scene consisting of a root, with a dimension of width and
 297      * height, specifies whether a depth buffer is created for this scene and
 298      * specifies whether scene anti-aliasing is requested.
 299      * &lt;p&gt;
 300      * A scene with only 2D shapes and without any 3D transforms does not need a
 301      * depth buffer nor scene anti-aliasing support. A scene containing 3D
 302      * shapes or 2D shapes with 3D transforms may use depth buffer support for
 303      * proper depth sorted rendering; to avoid depth fighting (also known as Z
 304      * fighting), disable depth testing on 2D shapes that have no 3D transforms.
 305      * See {@link Node#depthTestProperty() depthTest} for more information. A
 306      * scene with 3D shapes may enable scene anti-aliasing to improve its
 307      * rendering quality.
 308      *
 309      * @param root The root node of the scene graph
 310      * @param width The width of the scene
 311      * @param height The height of the scene
 312      * @param depthBuffer The depth buffer flag
 313      * @param antiAliasing The scene anti-aliasing attribute. A value of
 314      * {@code null} is treated as DISABLED.
 315      * &lt;p&gt;
 316      * The depthBuffer and antiAliasing are conditional features. With the
 317      * respective default values of: false and {@code SceneAntialiasing.DISABLED}. See
 318      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 319      * for more information.
 320      *
 321      * @throws NullPointerException if root is null
 322      *
 323      * @see javafx.scene.Node#setDepthTest(DepthTest)
 324      * @since JavaFX 8.0
 325      */
 326     public Scene(@NamedArg(&quot;root&quot;) Parent root, @NamedArg(value=&quot;width&quot;, defaultValue=&quot;-1&quot;) double width, @NamedArg(value=&quot;height&quot;, defaultValue=&quot;-1&quot;) double height,
 327             @NamedArg(&quot;depthBuffer&quot;) boolean depthBuffer,
 328             @NamedArg(value=&quot;antiAliasing&quot;, defaultValue=&quot;DISABLED&quot;) SceneAntialiasing antiAliasing) {
 329         this(root, width, height, Color.WHITE, depthBuffer, antiAliasing);
 330 
 331         if (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED &amp;&amp;
 332                 !Toolkit.getToolkit().isMSAASupported())
 333         {
 334             String logname = Scene.class.getName();
 335             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 336                 + &quot;antiAliasing&quot;);
 337         }
 338     }
 339 
 340     private Scene(Parent root, double width, double height, Paint fill,
 341             boolean depthBuffer, SceneAntialiasing antiAliasing) {
 342         this.depthBuffer = depthBuffer;
 343         this.antiAliasing = antiAliasing;
 344         if (root == null) {
 345             throw new NullPointerException(&quot;Root cannot be null&quot;);
 346         }
 347 
 348         if ((depthBuffer || (antiAliasing != null &amp;&amp; antiAliasing != SceneAntialiasing.DISABLED))
 349                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
 350             String logname = Scene.class.getName();
 351             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
 352                     + &quot;ConditionalFeature.SCENE3D&quot;);
 353         }
 354 
 355         init();
 356         setRoot(root);
 357         init(width, height);
 358         setFill(fill);
 359     }
 360 
 361     static {
 362             PerformanceTracker.setSceneAccessor(new PerformanceTracker.SceneAccessor() {
 363                 public void setPerfTracker(Scene scene, PerformanceTracker tracker) {
 364                     synchronized (trackerMonitor) {
 365                         scene.tracker = tracker;
 366                     }
 367                 }
 368                 public PerformanceTracker getPerfTracker(Scene scene) {
 369                     synchronized (trackerMonitor) {
 370                         return scene.tracker;
 371                     }
 372                 }
 373             });
 374             SceneHelper.setSceneAccessor(
 375                     new SceneHelper.SceneAccessor() {
 376                         @Override
 377                         public void enableInputMethodEvents(Scene scene, boolean enable) {
 378                             scene.enableInputMethodEvents(enable);
 379                         }
 380 
 381                         @Override
 382                         public void processKeyEvent(Scene scene, KeyEvent e) {
 383                             scene.processKeyEvent(e);
 384                         }
 385 
 386                         @Override
 387                         public void processMouseEvent(Scene scene, MouseEvent e) {
 388                             scene.processMouseEvent(e);
 389                         }
 390 
 391                         @Override
 392                         public void preferredSize(Scene scene) {
 393                             scene.preferredSize();
 394                         }
 395 
 396                         @Override
 397                         public void disposePeer(Scene scene) {
 398                             scene.disposePeer();
 399                         }
 400 
 401                         @Override
 402                         public void initPeer(Scene scene) {
 403                             scene.initPeer();
 404                         }
 405 
 406                         @Override
 407                         public void setWindow(Scene scene, Window window) {
 408                             scene.setWindow(window);
 409                         }
 410 
 411                         @Override
 412                         public TKScene getPeer(Scene scene) {
 413                             return scene.getPeer();
 414                         }
 415 
 416                         @Override
 417                         public void setAllowPGAccess(boolean flag) {
 418                             Scene.setAllowPGAccess(flag);
 419                         }
 420 
 421                         @Override
 422                         public void parentEffectiveOrientationInvalidated(
 423                                 final Scene scene) {
 424                             scene.parentEffectiveOrientationInvalidated();
 425                         }
 426 
 427                         @Override
 428                         public Camera getEffectiveCamera(Scene scene) {
 429                             return scene.getEffectiveCamera();
 430                         }
 431 
 432                         @Override
 433                         public Scene createPopupScene(Parent root) {
 434                             return new Scene(root) {
 435                                        @Override
 436                                        void doLayoutPass() {
 437                                            resizeRootToPreferredSize(getRoot());
 438                                            super.doLayoutPass();
 439                                        }
 440 
 441                                        @Override
 442                                        void resizeRootOnSceneSizeChange(
 443                                                double newWidth,
 444                                                double newHeight) {
 445                                            // don&#39;t resize
 446                                        }
 447                                    };
 448                         }
 449 
 450                         @Override
 451                         public void setTransientFocusContainer(Scene scene, Node node) {
 452                             if (scene != null) {
 453                                 scene.transientFocusContainer = node;
 454                             }
 455                         }
 456 
 457                         @Override
 458                         public Accessible getAccessible(Scene scene) {
 459                             return scene.getAccessible();
 460                         }
 461                     });
 462         }
 463 
 464         // Reserve space for 30 nodes in the dirtyNodes set.
 465         private static final int MIN_DIRTY_CAPACITY = 30;
 466 
 467         // For debugging
 468         private static boolean inSynchronizer = false;
 469         private static boolean inMousePick = false;
 470         private static boolean allowPGAccess = false;
 471         private static int pgAccessCount = 0;
 472 
 473         /**
 474          * Used for debugging purposes. Returns true if we are in either the
 475          * mouse event code (picking) or the synchronizer, or if the scene is
 476          * not yet initialized,
 477          *
 478          */
 479         static boolean isPGAccessAllowed() {
 480             return inSynchronizer || inMousePick || allowPGAccess;
 481         }
 482 
 483         static void setAllowPGAccess(boolean flag) {
 484             if (Utils.assertionEnabled()) {
 485                 if (flag) {
 486                     pgAccessCount++;
 487                     allowPGAccess = true;
 488                 }
 489                 else {
 490                     if (pgAccessCount &lt;= 0) {
 491                         throw new java.lang.AssertionError(&quot;*** pgAccessCount underflow&quot;);
 492                     }
 493                     if (--pgAccessCount == 0) {
 494                         allowPGAccess = false;
 495                     }
 496                 }
 497             }
 498         }
 499 
 500         /**
 501          * If true, use the platform&#39;s drag gesture detection
 502          * else use Scene-level detection as per DnDGesture.process(MouseEvent, List)
 503          */
 504         private static final boolean PLATFORM_DRAG_GESTURE_INITIATION = false;
 505 
 506     /**
 507      * Set of dirty nodes; processed once per frame by the synchronizer.
 508      * When a node&#39;s state changes such that it becomes &quot;dirty&quot; with respect
 509      * to the graphics stack and requires synchronization, then that node
 510      * is added to this list. Note that if state on the Node changes, but it
 511      * was already dirty, then the Node doesn&#39;t add itself again.
 512      * &lt;p&gt;
 513      * Because at initialization time every node in the scene graph is dirty,
 514      * we have a special state and special code path during initialization
 515      * that does not involve adding each node to the dirtyNodes list. When
 516      * dirtyNodes is null, that means this Scene has not yet been synchronized.
 517      * A good default size is then created for the dirtyNodes list.
 518      * &lt;p&gt;
 519      * We double-buffer the set so that we can add new nodes to the
 520      * set while processing the existing set. This avoids our having to
 521      * take a snapshot of the set (e.g., with toArray()) and reduces garbage.
 522      */
 523     private Node[] dirtyNodes;
 524     private int dirtyNodesSize;
 525 
 526     /**
 527      * Add the specified node to this scene&#39;s dirty list. Called by the
 528      * markDirty method in Node or when the Node&#39;s scene changes.
 529      */
 530     void addToDirtyList(Node n) {
 531         if (dirtyNodes == null || dirtyNodesSize == 0) {
 532             if (peer != null) {
 533                 Toolkit.getToolkit().requestNextPulse();
 534             }
 535         }
 536 
 537         if (dirtyNodes != null) {
 538             if (dirtyNodesSize == dirtyNodes.length) {
 539                 Node[] tmp = new Node[dirtyNodesSize + (dirtyNodesSize &gt;&gt; 1)];
 540                 System.arraycopy(dirtyNodes, 0, tmp, 0, dirtyNodesSize);
 541                 dirtyNodes = tmp;
 542             }
 543             dirtyNodes[dirtyNodesSize++] = n;
 544         }
 545     }
 546 
 547     private void doCSSPass() {
 548         final Parent sceneRoot = getRoot();
 549         //
 550         // RT-17547: when the tree is synchronized, the dirty bits are
 551         // are cleared but the cssFlag might still be something other than
 552         // clean.
 553         //
 554         // Before RT-17547, the code checked the dirty bit. But this is
 555         // superfluous since the dirty bit will be set if the flag is not clean,
 556         // but the flag will never be anything other than clean if the dirty
 557         // bit is not set. The dirty bit is still needed, however, since setting
 558         // it ensures a pulse if no other dirty bits have been set.
 559         //
 560         // For the purpose of showing the change, the dirty bit
 561         // check code was commented out and not removed.
 562         //
 563 //        if (sceneRoot.isDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS)) {
 564         if (sceneRoot.cssFlag != CssFlags.CLEAN) {
 565             // The dirty bit isn&#39;t checked but we must ensure it is cleared.
 566             // The cssFlag is set to clean in either Node.processCSS or
 567             // NodeHelper.processCSS
 568             sceneRoot.clearDirty(com.sun.javafx.scene.DirtyBits.NODE_CSS);
 569             sceneRoot.processCSS();
 570         }
 571     }
 572 
 573     void doLayoutPass() {
 574         final Parent r = getRoot();
 575         if (r != null) {
 576             r.layout();
 577         }
 578     }
 579 
 580     /**
 581      * The peer of this scene
 582      */
 583     private TKScene peer;
 584 
 585     /*
 586      * Get Scene&#39;s peer
 587      */
 588     TKScene getPeer() {
 589         return peer;
 590     }
 591 
 592     /**
 593      * The scene pulse listener that gets called on toolkit pulses
 594      */
 595     ScenePulseListener scenePulseListener = new ScenePulseListener();
 596 
 597     private List&lt;Runnable&gt; preLayoutPulseListeners;
 598     private List&lt;Runnable&gt; postLayoutPulseListeners;
 599 
 600     /**
 601      * Adds a new scene pre layout pulse listener to this scene. Every time a pulse occurs,
 602      * this listener will be called on the JavaFX Application Thread directly
 603      * &lt;strong&gt;before&lt;/strong&gt; the CSS and layout passes, and also before
 604      * any rendering is done for
 605      * this frame. This scene pulse listener is suitable for knowing when a
 606      * scenegraph pulse is happening and also for modifying the scenegraph
 607      * (as it is called before CSS and layout, so any changes made will be properly
 608      * styled and positioned).
 609      *
 610      * This method must be called on the JavaFX Application thread.
 611      *
 612      * @param r The Runnable to be called when the pulse occurs.
 613      *
 614      * @throws IllegalStateException if this method is called on a thread
 615      * other than the JavaFX Application Thread.
 616      *
 617      * @throws NullPointerException if the provided Runnable is null.
 618      *
 619      * @since 9
 620      */
 621     public final void addPreLayoutPulseListener(Runnable r) {
 622         Toolkit.getToolkit().checkFxUserThread();
 623 
 624         if (r == null) {
 625             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 626         }
 627         if (preLayoutPulseListeners == null) {
 628             preLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 629         }
 630         preLayoutPulseListeners.add(r);
 631     }
 632 
 633     /**
 634      * Removes a previously registered scene pre layout pulse listener from listening to
 635      * pulses in this scene. This method does nothing if the specified Runnable is
 636      * not already in the list.
 637      *
 638      * This method must be called on the JavaFX Application thread.
 639      *
 640      * @param r The Runnable that should no longer be called when the pulse
 641      * occurs for this scene.
 642      *
 643      * @throws IllegalStateException if this method is called on a thread
 644      * other than the JavaFX Application Thread.
 645      *
 646      * @since 9
 647      */
 648     public final void removePreLayoutPulseListener(Runnable r) {
 649         Toolkit.getToolkit().checkFxUserThread();
 650 
 651         if (preLayoutPulseListeners == null) {
 652             return;
 653         }
 654         preLayoutPulseListeners.remove(r);
 655     }
 656 
 657     /**
 658      * Adds a new scene post layout pulse listener to this scene. Every time a pulse occurs,
 659      * this listener will be called on the JavaFX Application Thread directly
 660      * &lt;strong&gt;after&lt;/strong&gt; the CSS and layout passes, but before any rendering is done for
 661      * this frame. This scene pulse listener is suitable for knowing when a
 662      * scenegraph pulse is happening, but it is not suited to use cases related
 663      * to modifying the scenegraph (as it is called after CSS and layout, so
 664      * any changes will possibly be incorrect until the next pulse is run).
 665      * An alternative (and better) solution for situations where a scenegraph
 666      * modification is required to happen is to use either the
 667      * {@link #addPreLayoutPulseListener(Runnable)} API or the the
 668      * {@link javafx.animation.AnimationTimer} API.
 669      *
 670      * This method must be called on the JavaFX Application thread.
 671      *
 672      * @param r The Runnable to be called when the pulse occurs.
 673      *
 674      * @throws IllegalStateException if this method is called on a thread
 675      * other than the JavaFX Application Thread.
 676      *
 677      * @throws NullPointerException if the provided Runnable is null.
 678      *
 679      * @since 9
 680      */
 681     public final void addPostLayoutPulseListener(Runnable r) {
 682         Toolkit.getToolkit().checkFxUserThread();
 683 
 684         if (r == null) {
 685             throw new NullPointerException(&quot;Scene pulse listener should not be null&quot;);
 686         }
 687         if (postLayoutPulseListeners == null) {
 688             postLayoutPulseListeners = new CopyOnWriteArrayList&lt;&gt;();
 689         }
 690         postLayoutPulseListeners.add(r);
 691     }
 692 
 693     /**
 694      * Removes a previously registered scene post layout pulse listener from listening to
 695      * pulses in this scene. This method does nothing if the specified Runnable is
 696      * not already in the list.
 697      *
 698      * This method must be called on the JavaFX Application thread.
 699      *
 700      * @param r The Runnable that should no longer be called when the pulse
 701      * occurs for this scene.
 702      *
 703      * @throws IllegalStateException if this method is called on a thread
 704      * other than the JavaFX Application Thread.
 705      *
 706      * @since 9
 707      */
 708     public final void removePostLayoutPulseListener(Runnable r) {
 709         Toolkit.getToolkit().checkFxUserThread();
 710 
 711         if (postLayoutPulseListeners == null) {
 712             return;
 713         }
 714         postLayoutPulseListeners.remove(r);
 715     }
 716 
 717     /**
 718      * Return the defined {@code SceneAntialiasing} for this {@code Scene}.
 719      * &lt;p&gt;
 720      * Note: this is a conditional feature. See
 721      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
 722      * and {@link javafx.scene.SceneAntialiasing SceneAntialiasing}
 723      * for more information.
 724      * @return the SceneAntialiasing for this scene
 725      * @since JavaFX 8.0
 726      */
 727     public final SceneAntialiasing getAntiAliasing() {
 728         return antiAliasing;
 729     }
 730 
 731     private boolean getAntiAliasingInternal() {
 732         return (antiAliasing != null &amp;&amp;
 733                 Toolkit.getToolkit().isMSAASupported() &amp;&amp;
 734                 Platform.isSupported(ConditionalFeature.SCENE3D)) ?
 735                 antiAliasing != SceneAntialiasing.DISABLED : false;
 736     }
 737 
 738     /**
 739      * The {@code Window} for this {@code Scene}
 740      */
 741     private ReadOnlyObjectWrapper&lt;Window&gt; window;
 742 
 743     void setWindow(Window value) {
 744         windowPropertyImpl().set(value);
 745     }
 746 
 747     public final Window getWindow() {
 748         return window == null ? null : window.get();
 749     }
 750 
 751     public final ReadOnlyObjectProperty&lt;Window&gt; windowProperty() {
 752         return windowPropertyImpl().getReadOnlyProperty();
 753     }
 754 
 755     private ReadOnlyObjectWrapper&lt;Window&gt; windowPropertyImpl() {
 756         if (window == null) {
 757             window = new ReadOnlyObjectWrapper&lt;Window&gt;() {
 758                 private Window oldWindow;
 759 
 760                 @Override protected void invalidated() {
 761                     final Window newWindow = get();
 762                     getKeyHandler().windowForSceneChanged(oldWindow, newWindow);
 763                     if (oldWindow != null) {
 764                         disposePeer();
 765                     }
 766                     if (newWindow != null) {
 767                         initPeer();
 768                     }
 769                     parentEffectiveOrientationInvalidated();
 770 
 771                     oldWindow = newWindow;
 772                 }
 773 
 774                 @Override
 775                 public Object getBean() {
 776                     return Scene.this;
 777                 }
 778 
 779                 @Override
 780                 public String getName() {
 781                     return &quot;window&quot;;
 782                 }
 783             };
 784         }
 785         return window;
 786     }
 787 
 788     void initPeer() {
 789         assert peer == null;
 790 
 791         Window window = getWindow();
 792         // initPeer() is only called from Window, either when the window
 793         // is being shown, or the window scene is being changed. In any case
 794         // this scene&#39;s window cannot be null.
 795         assert window != null;
 796 
 797         TKStage windowPeer = WindowHelper.getPeer(window);
 798         if (windowPeer == null) {
 799             // This is fine, the window is not visible. initPeer() will
 800             // be called again later, when the window is being shown.
 801             return;
 802         }
 803 
 804         final boolean isTransparentWindowsSupported = Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW);
 805         if (!isTransparentWindowsSupported) {
 806             PlatformImpl.addNoTransparencyStylesheetToScene(this);
 807         }
 808 
 809         PerformanceTracker.logEvent(&quot;Scene.initPeer started&quot;);
 810 
 811         setAllowPGAccess(true);
 812 
 813         Toolkit tk = Toolkit.getToolkit();
 814         peer = windowPeer.createTKScene(isDepthBufferInternal(), getAntiAliasingInternal(), acc);
 815         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene created&quot;);
 816         peer.setTKSceneListener(new ScenePeerListener());
 817         peer.setTKScenePaintListener(new ScenePeerPaintListener());
 818         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene set&quot;);
 819         peer.setRoot(getRoot().getPeer());
 820         peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
 821         NodeHelper.updatePeer(getEffectiveCamera());
 822         peer.setCamera((NGCamera) getEffectiveCamera().getPeer());
 823         peer.markDirty();
 824         PerformanceTracker.logEvent(&quot;Scene.initPeer TKScene initialized&quot;);
 825 
 826         setAllowPGAccess(false);
 827 
 828         tk.addSceneTkPulseListener(scenePulseListener);
 829         // listen to dnd gestures coming from the platform
 830         if (PLATFORM_DRAG_GESTURE_INITIATION) {
 831             if (dragGestureListener == null) {
 832                 dragGestureListener = new DragGestureListener();
 833             }
 834             tk.registerDragGestureListener(peer, EnumSet.allOf(TransferMode.class), dragGestureListener);
 835         }
 836         tk.enableDrop(peer, new DropTargetListener());
 837         tk.installInputMethodRequests(peer, new InputMethodRequestsDelegate());
 838 
 839         PerformanceTracker.logEvent(&quot;Scene.initPeer finished&quot;);
 840     }
 841 
 842     public void disposePeer() {
 843         if (peer == null) {
 844             // This is fine, the window is either not shown yet and there is no
 845             // need in disposing scene peer, or is hidden and disposePeer()
 846             // has already been called.
 847             return;
 848         }
 849 
 850         PerformanceTracker.logEvent(&quot;Scene.disposePeer started&quot;);
 851 
 852         Toolkit tk = Toolkit.getToolkit();
 853         tk.removeSceneTkPulseListener(scenePulseListener);
 854         if (accessible != null) {
 855             disposeAccessibles();
 856             Node root = getRoot();
 857             if (root != null) root.releaseAccessible();
 858             accessible.dispose();
 859             accessible = null;
 860         }
 861         peer.dispose();
 862         peer = null;
 863 
 864         PerformanceTracker.logEvent(&quot;Scene.disposePeer finished&quot;);
 865     }
 866 
 867     DnDGesture dndGesture = null;
 868     DragGestureListener dragGestureListener;
 869     /**
 870      * The horizontal location of this {@code Scene} on the {@code Window}.
 871      */
 872     private ReadOnlyDoubleWrapper x;
 873 
 874     private final void setX(double value) {
 875         xPropertyImpl().set(value);
 876     }
 877 
 878     public final double getX() {
 879         return x == null ? 0.0 : x.get();
 880     }
 881 
 882     public final ReadOnlyDoubleProperty xProperty() {
 883         return xPropertyImpl().getReadOnlyProperty();
 884     }
 885 
 886     private ReadOnlyDoubleWrapper xPropertyImpl() {
 887         if (x == null) {
 888             x = new ReadOnlyDoubleWrapper(this, &quot;x&quot;);
 889         }
 890         return x;
 891     }
 892 
 893     /**
 894      * The vertical location of this {@code Scene} on the {@code Window}.
 895      */
 896     private ReadOnlyDoubleWrapper y;
 897 
 898     private final void setY(double value) {
 899         yPropertyImpl().set(value);
 900     }
 901 
 902     public final double getY() {
 903         return y == null ? 0.0 : y.get();
 904     }
 905 
 906     public final ReadOnlyDoubleProperty yProperty() {
 907         return yPropertyImpl().getReadOnlyProperty();
 908     }
 909 
 910     private ReadOnlyDoubleWrapper yPropertyImpl() {
 911         if (y == null) {
 912             y = new ReadOnlyDoubleWrapper(this, &quot;y&quot;);
 913         }
 914         return y;
 915     }
 916 
 917     /**
 918      * The width of this {@code Scene}
 919      */
 920     private ReadOnlyDoubleWrapper width;
 921 
 922     private final void setWidth(double value) {
 923         widthPropertyImpl().set(value);
 924     }
 925 
 926     public final double getWidth() {
 927         return width == null ? 0.0 : width.get();
 928     }
 929 
 930     public final ReadOnlyDoubleProperty widthProperty() {
 931         return widthPropertyImpl().getReadOnlyProperty();
 932     }
 933 
 934     private ReadOnlyDoubleWrapper widthPropertyImpl() {
 935         if (width == null) {
 936             width = new ReadOnlyDoubleWrapper() {
 937 
 938                 @Override
 939                 protected void invalidated() {
 940                     final Parent _root = getRoot();
 941                     //TODO - use a better method to update mirroring
 942                     if (_root.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT) {
 943                         NodeHelper.transformsChanged(_root);
 944                     }
 945                     if (_root.isResizable()) {
 946                         resizeRootOnSceneSizeChange(get() - _root.getLayoutX() - _root.getTranslateX(), _root.getLayoutBounds().getHeight());
 947                     }
 948 
 949                     getEffectiveCamera().setViewWidth(get());
 950                 }
 951 
 952                 @Override
 953                 public Object getBean() {
 954                     return Scene.this;
 955                 }
 956 
 957                 @Override
 958                 public String getName() {
 959                     return &quot;width&quot;;
 960                 }
 961             };
 962         }
 963         return width;
 964     }
 965 
 966     /**
 967      * The height of this {@code Scene}
 968      */
 969     private ReadOnlyDoubleWrapper height;
 970 
 971     private final void setHeight(double value) {
 972         heightPropertyImpl().set(value);
 973     }
 974 
 975     public final double getHeight() {
 976         return height == null ? 0.0 : height.get();
 977     }
 978 
 979     public final ReadOnlyDoubleProperty heightProperty() {
 980         return heightPropertyImpl().getReadOnlyProperty();
 981     }
 982 
 983     private ReadOnlyDoubleWrapper heightPropertyImpl() {
 984         if (height == null) {
 985             height = new ReadOnlyDoubleWrapper() {
 986 
 987                 @Override
 988                 protected void invalidated() {
 989                     final Parent _root = getRoot();
 990                     if (_root.isResizable()) {
 991                         resizeRootOnSceneSizeChange(_root.getLayoutBounds().getWidth(), get() - _root.getLayoutY() - _root.getTranslateY());
 992                     }
 993 
 994                     getEffectiveCamera().setViewHeight(get());
 995                 }
 996 
 997                 @Override
 998                 public Object getBean() {
 999                     return Scene.this;
1000                 }
1001 
1002                 @Override
1003                 public String getName() {
1004                     return &quot;height&quot;;
1005                 }
1006             };
1007         }
1008         return height;
1009     }
1010 
1011     void resizeRootOnSceneSizeChange(double newWidth, double newHeight) {
1012         getRoot().resize(newWidth, newHeight);
1013     }
1014 
1015     // Reusable target wrapper (to avoid creating new one for each picking)
1016     private TargetWrapper tmpTargetWrapper = new TargetWrapper();
1017 
1018     /**
1019      * Specifies the type of camera use for rendering this {@code Scene}.
1020      * If {@code camera} is null, a parallel camera is used for rendering.
1021      * It is illegal to set a camera that belongs to other {@code Scene}
1022      * or {@code SubScene}.
1023      * &lt;p&gt;
1024      * Note: this is a conditional feature. See
1025      * {@link javafx.application.ConditionalFeature#SCENE3D ConditionalFeature.SCENE3D}
1026      * for more information.
1027      *
1028      * @defaultValue null
1029      */
1030     private ObjectProperty&lt;Camera&gt; camera;
1031 
1032     public final void setCamera(Camera value) {
1033         cameraProperty().set(value);
1034     }
1035 
1036     public final Camera getCamera() {
1037         return camera == null ? null : camera.get();
1038     }
1039 
1040     public final ObjectProperty&lt;Camera&gt; cameraProperty() {
1041         if (camera == null) {
1042             camera = new ObjectPropertyBase&lt;Camera&gt;() {
1043                 Camera oldCamera = null;
1044 
1045                 @Override
1046                 protected void invalidated() {
1047                     Camera _value = get();
1048                     if (_value != null) {
1049                         if (_value instanceof PerspectiveCamera
1050                                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D)) {
1051                             String logname = Scene.class.getName();
1052                             PlatformLogger.getLogger(logname).warning(&quot;System can&#39;t support &quot;
1053                                     + &quot;ConditionalFeature.SCENE3D&quot;);
1054                         }
1055                         // Illegal value if it belongs to other scene or any subscene
1056                         if ((_value.getScene() != null &amp;&amp; _value.getScene() != Scene.this)
1057                                 || _value.getSubScene() != null) {
1058                             throw new IllegalArgumentException(_value
1059                                     + &quot;is already part of other scene or subscene&quot;);
1060                         }
1061                         // throws exception if the camera already has a different owner
1062                         _value.setOwnerScene(Scene.this);
1063                         _value.setViewWidth(getWidth());
1064                         _value.setViewHeight(getHeight());
1065                     }
1066                     if (oldCamera != null &amp;&amp; oldCamera != _value) {
1067                         oldCamera.setOwnerScene(null);
1068                     }
1069                     oldCamera = _value;
1070                 }
1071 
1072                 @Override
1073                 public Object getBean() {
1074                     return Scene.this;
1075                 }
1076 
1077                 @Override
1078                 public String getName() {
1079                     return &quot;camera&quot;;
1080                 }
1081             };
1082         }
1083         return camera;
1084     }
1085 
1086     Camera getEffectiveCamera() {
1087         final Camera cam = getCamera();
1088         if (cam == null
1089                 || (cam instanceof PerspectiveCamera
1090                 &amp;&amp; !Platform.isSupported(ConditionalFeature.SCENE3D))) {
1091             if (defaultCamera == null) {
1092                 defaultCamera = new ParallelCamera();
1093                 defaultCamera.setOwnerScene(this);
1094                 defaultCamera.setViewWidth(getWidth());
1095                 defaultCamera.setViewHeight(getHeight());
1096             }
1097             return defaultCamera;
1098         }
1099 
1100         return cam;
1101     }
1102 
1103     // Used by the camera
1104     void markCameraDirty() {
1105         markDirty(DirtyBits.CAMERA_DIRTY);
1106         setNeedsRepaint();
1107     }
1108 
1109     void markCursorDirty() {
1110         markDirty(DirtyBits.CURSOR_DIRTY);
1111     }
1112 
1113     /**
1114      * Defines the background fill of this {@code Scene}. Both a {@code null}
1115      * value meaning &#39;paint no background&#39; and a {@link javafx.scene.paint.Paint}
1116      * with transparency are supported. The default fill of the Scene is
1117      * {@link Color#WHITE}, but it is more commonly the case that the initial
1118      * color shown to users is the background fill of the
1119      * {@link #rootProperty() root node} of the {@code Scene}, as it typically is
1120      * stretched to take up all available space in the {@code Scene}. The
1121      * root node of the {@code Scene} is given the CSS style class &#39;root&#39;, and
1122      * the default user agent stylesheets that ship with JavaFX (presently
1123      * Caspian and Modena) apply styling on to this root style class. In the
1124      * case of Caspian this does not impact the background fill color of the
1125      * root node, but in the case of Modena the default fill is set to be a
1126      * light gray color.
1127      *
1128      * @defaultValue WHITE
1129      */
1130     private ObjectProperty&lt;Paint&gt; fill;
1131 
1132     public final void setFill(Paint value) {
1133         fillProperty().set(value);
1134     }
1135 
1136     public final Paint getFill() {
1137         return fill == null ? Color.WHITE : fill.get();
1138     }
1139 
1140     public final ObjectProperty&lt;Paint&gt; fillProperty() {
1141         if (fill == null) {
1142             fill = new ObjectPropertyBase&lt;Paint&gt;(Color.WHITE) {
1143 
1144                 @Override
1145                 protected void invalidated() {
1146                     markDirty(DirtyBits.FILL_DIRTY);
1147                 }
1148 
1149                 @Override
1150                 public Object getBean() {
1151                     return Scene.this;
1152                 }
1153 
1154                 @Override
1155                 public String getName() {
1156                     return &quot;fill&quot;;
1157                 }
1158             };
1159         }
1160         return fill;
1161     }
1162 
1163     /**
1164      * Defines the root {@code Node} of the scene graph.
1165      * If a {@code Group} is used as the root, the
1166      * contents of the scene graph will be clipped by the scene&#39;s width and height and
1167      * changes to the scene&#39;s size (if user resizes the stage) will not alter the
1168      * layout of the scene graph.    If a resizable node (layout {@code Region} or
1169      * {@code Control}) is set as the root, then the root&#39;s size will track the
1170      * scene&#39;s size, causing the contents to be relayed out as necessary.
1171      *
1172      * Scene doesn&#39;t accept null root.
1173      *
1174      */
1175     private ObjectProperty&lt;Parent&gt; root;
1176 
1177     public final void setRoot(Parent value) {
1178         rootProperty().set(value);
1179     }
1180 
1181     public final Parent getRoot() {
1182         return root == null ? null : root.get();
1183     }
1184 
1185     Parent oldRoot;
1186     public final ObjectProperty&lt;Parent&gt; rootProperty() {
1187         if (root == null) {
1188             root = new ObjectPropertyBase&lt;Parent&gt;() {
1189 
1190                 private void forceUnbind() {
1191                     System.err.println(&quot;Unbinding illegal root.&quot;);
1192                     unbind();
1193                 }
1194 
1195                 @Override
1196                 protected void invalidated() {
1197                     Parent _value = get();
1198 
1199                     if (_value == null) {
1200                         if (isBound()) forceUnbind();
1201                         throw new NullPointerException(&quot;Scene&#39;s root cannot be null&quot;);
1202                     }
1203 
1204                     if (_value.getParent() != null) {
1205                         if (isBound()) forceUnbind();
1206                         throw new IllegalArgumentException(_value +
1207                                 &quot;is already inside a scene-graph and cannot be set as root&quot;);
1208                     }
1209                     if (_value.getClipParent() != null) {
1210                         if (isBound()) forceUnbind();
1211                         throw new IllegalArgumentException(_value +
1212                                 &quot;is set as a clip on another node, so cannot be set as root&quot;);
1213                     }
1214                     if (_value.getScene() != null &amp;&amp; _value.getScene().getRoot() == _value &amp;&amp; _value.getScene() != Scene.this) {
1215                         if (isBound()) forceUnbind();
1216                         throw new IllegalArgumentException(_value +
1217                                 &quot;is already set as root of another scene&quot;);
1218                     }
1219 
1220                     if (oldRoot != null) {
1221                         oldRoot.setScenes(null, null);
1222                     }
1223                     oldRoot = _value;
1224                     _value.getStyleClass().add(0, &quot;root&quot;);
1225                     _value.setScenes(Scene.this, null);
1226                     markDirty(DirtyBits.ROOT_DIRTY);
1227                     _value.resize(getWidth(), getHeight()); // maybe no-op if root is not resizable
1228                     _value.requestLayout();
1229                 }
1230 
1231                 @Override
1232                 public Object getBean() {
1233                     return Scene.this;
1234                 }
1235 
1236                 @Override
1237                 public String getName() {
1238                     return &quot;root&quot;;
1239                 }
1240             };
1241         }
1242         return root;
1243     }
1244 
1245     void setNeedsRepaint() {
1246         if (this.peer != null) {
1247             peer.entireSceneNeedsRepaint();
1248         }
1249     }
1250 
1251     // Process CSS and layout and sync the scene prior to the snapshot
1252     // operation of the given node for this scene (currently the node
1253     // is unused but could possibly be used in the future to optimize this)
1254     void doCSSLayoutSyncForSnapshot(Node node) {
1255         if (!sizeInitialized) {
1256             preferredSize();
1257         } else {
1258             doCSSPass();
1259         }
1260 
1261         // we do not need pulse in the snapshot code
1262         // because this scene can be stage-less
1263         doLayoutPass();
1264 
1265         getRoot().updateBounds();
1266         if (peer != null) {
1267             peer.waitForRenderingToComplete();
1268             peer.waitForSynchronization();
1269             try {
1270                 // Run the synchronizer while holding the render lock
1271                 scenePulseListener.synchronizeSceneNodes();
1272             } finally {
1273                 peer.releaseSynchronization(false);
1274             }
1275         } else {
1276             scenePulseListener.synchronizeSceneNodes();
1277         }
1278 
1279     }
1280 
1281     // Shared method for Scene.snapshot and Node.snapshot. It is static because
1282     // we might be doing a Node snapshot with a null scene
1283     static WritableImage doSnapshot(Scene scene,
1284             double x, double y, double w, double h,
1285             Node root, BaseTransform transform, boolean depthBuffer,
1286             Paint fill, Camera camera, WritableImage wimg) {
1287 
1288         Toolkit tk = Toolkit.getToolkit();
1289         Toolkit.ImageRenderingContext context = new Toolkit.ImageRenderingContext();
1290 
1291         int xMin = (int)Math.floor(x);
1292         int yMin = (int)Math.floor(y);
1293         int width;
1294         int height;
1295         if (wimg == null) {
1296             int xMax = (int)Math.ceil(x + w);
1297             int yMax = (int)Math.ceil(y + h);
1298             width = Math.max(xMax - xMin, 1);
1299             height = Math.max(yMax - yMin, 1);
1300             wimg = new WritableImage(width, height);
1301         } else {
1302             width = (int)wimg.getWidth();
1303             height = (int)wimg.getHeight();
1304         }
1305 
1306         setAllowPGAccess(true);
1307         context.x = xMin;
1308         context.y = yMin;
1309         context.width = width;
1310         context.height = height;
1311         context.transform = transform;
1312         context.depthBuffer = depthBuffer;
1313         context.root = root.getPeer();
1314         context.platformPaint = fill == null ? null : tk.getPaint(fill);
1315         double cameraViewWidth = 1.0;
1316         double cameraViewHeight = 1.0;
1317         if (camera != null) {
1318             // temporarily adjust camera viewport to the snapshot size
1319             cameraViewWidth = camera.getViewWidth();
1320             cameraViewHeight = camera.getViewHeight();
1321             camera.setViewWidth(width);
1322             camera.setViewHeight(height);
1323             NodeHelper.updatePeer(camera);
1324             context.camera = camera.getPeer();
1325         } else {
1326             context.camera = null;
1327         }
1328 
1329         // Grab the lights from the scene
1330         context.lights = null;
1331         if (scene != null &amp;&amp; !scene.lights.isEmpty()) {
1332             context.lights = new NGLightBase[scene.lights.size()];
1333             for (int i = 0; i &lt; scene.lights.size(); i++) {
1334                 context.lights[i] = scene.lights.get(i).getPeer();
1335             }
1336         }
1337 
1338         Toolkit.WritableImageAccessor accessor = Toolkit.getWritableImageAccessor();
1339         context.platformImage = accessor.getTkImageLoader(wimg);
1340         setAllowPGAccess(false);
1341         Object tkImage = tk.renderToImage(context);
1342         accessor.loadTkImage(wimg, tkImage);
1343 
1344         if (camera != null) {
1345             setAllowPGAccess(true);
1346             camera.setViewWidth(cameraViewWidth);
1347             camera.setViewHeight(cameraViewHeight);
1348             NodeHelper.updatePeer(camera);
1349             setAllowPGAccess(false);
1350         }
1351 
1352         // if this scene belongs to some stage
1353         // we need to mark the entire scene as dirty
1354         // because dirty logic is buggy
1355         if (scene != null &amp;&amp; scene.peer != null) {
1356             scene.setNeedsRepaint();
1357         }
1358 
1359         return wimg;
1360     }
1361 
1362     /**
1363      * Implementation method for snapshot
1364      */
1365     private WritableImage doSnapshot(WritableImage img) {
1366         // TODO: no need to do CSS, layout or sync in the deferred case,
1367         // if this scene is attached to a visible stage
1368         doCSSLayoutSyncForSnapshot(getRoot());
1369 
1370         double w = getWidth();
1371         double h = getHeight();
1372         BaseTransform transform = BaseTransform.IDENTITY_TRANSFORM;
1373 
1374         return doSnapshot(this, 0, 0, w, h,
1375                 getRoot(), transform, isDepthBufferInternal(),
1376                 getFill(), getEffectiveCamera(), img);
1377     }
1378 
1379     // Pulse listener used to run all deferred (async) snapshot requests
1380     private static TKPulseListener snapshotPulseListener = null;
1381 
1382     private static List&lt;Runnable&gt; snapshotRunnableListA;
1383     private static List&lt;Runnable&gt; snapshotRunnableListB;
1384     private static List&lt;Runnable&gt; snapshotRunnableList;
1385 
1386     static void addSnapshotRunnable(final Runnable runnable) {
1387         Toolkit.getToolkit().checkFxUserThread();
1388 
1389         if (snapshotPulseListener == null) {
1390             snapshotRunnableListA = new ArrayList&lt;Runnable&gt;();
1391             snapshotRunnableListB = new ArrayList&lt;Runnable&gt;();
1392             snapshotRunnableList = snapshotRunnableListA;
1393 
1394             snapshotPulseListener = () -&gt; {
1395                 if (snapshotRunnableList.size() &gt; 0) {
1396                     List&lt;Runnable&gt; runnables = snapshotRunnableList;
1397                     if (snapshotRunnableList == snapshotRunnableListA) {
1398                         snapshotRunnableList = snapshotRunnableListB;
1399                     } else {
1400                         snapshotRunnableList = snapshotRunnableListA;
1401                     }
1402                     for (Runnable r : runnables) {
1403                         try {
1404                             r.run();
1405                         } catch (Throwable th) {
1406                             System.err.println(&quot;Exception in snapshot runnable&quot;);
1407                             th.printStackTrace(System.err);
1408                         }
1409                     }
1410                     runnables.clear();
1411                 }
1412             };
1413 
1414             // Add listener that will be called after all of the scenes have
1415             // had layout and CSS processing, and have been synced
1416             Toolkit.getToolkit().addPostSceneTkPulseListener(snapshotPulseListener);
1417         }
1418 
1419         final AccessControlContext acc = AccessController.getContext();
1420         snapshotRunnableList.add(() -&gt; {
1421             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
1422                 runnable.run();
1423                 return null;
1424             }, acc);
1425         });
1426         Toolkit.getToolkit().requestNextPulse();
1427     }
1428 
1429     /**
1430      * Takes a snapshot of this scene and returns the rendered image when
1431      * it is ready.
1432      * CSS and layout processing will be done for the scene prior to
1433      * rendering it.
1434      * The entire destination image is cleared using the fill {@code Paint}
1435      * of this scene. The nodes in the scene are then rendered to the image.
1436      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1437      * If the image is smaller than the size of the scene, then the rendering
1438      * will be clipped by the image.
1439      *
1440      * &lt;p&gt;
1441      * When taking a snapshot of a scene that is being animated, either
1442      * explicitly by the application or implicitly (such as chart animation),
1443      * the snapshot will be rendered based on the state of the scene graph at
1444      * the moment the snapshot is taken and will not reflect any subsequent
1445      * animation changes.
1446      * &lt;/p&gt;
1447      *
1448      * @param image the writable image that will be used to hold the rendered scene.
1449      * It may be null in which case a new WritableImage will be constructed.
1450      * If the image is non-null, the scene will be rendered into the
1451      * existing image.
1452      * In this case, the width and height of the image determine the area
1453      * that is rendered instead of the width and height of the scene.
1454      *
1455      * @throws IllegalStateException if this method is called on a thread
1456      *     other than the JavaFX Application Thread.
1457      *
1458      * @return the rendered image
1459      * @since JavaFX 2.2
1460      */
1461     public WritableImage snapshot(WritableImage image) {
1462         Toolkit.getToolkit().checkFxUserThread();
1463 
1464         return doSnapshot(image);
1465     }
1466 
1467     /**
1468      * Takes a snapshot of this scene at the next frame and calls the
1469      * specified callback method when the image is ready.
1470      * CSS and layout processing will be done for the scene prior to
1471      * rendering it.
1472      * The entire destination image is cleared using the fill {@code Paint}
1473      * of this scene. The nodes in the scene are then rendered to the image.
1474      * The point (0,0) in scene coordinates is mapped to (0,0) in the image.
1475      * If the image is smaller than the size of the scene, then the rendering
1476      * will be clipped by the image.
1477      *
1478      * &lt;p&gt;
1479      * This is an asynchronous call, which means that other
1480      * events or animation might be processed before the scene is rendered.
1481      * If any such events modify a node in the scene that modification will
1482      * be reflected in the rendered image (as it will also be reflected in
1483      * the frame rendered to the Stage).
1484      * &lt;/p&gt;
1485      *
1486      * &lt;p&gt;
1487      * When taking a snapshot of a scene that is being animated, either
1488      * explicitly by the application or implicitly (such as chart animation),
1489      * the snapshot will be rendered based on the state of the scene graph at
1490      * the moment the snapshot is taken and will not reflect any subsequent
1491      * animation changes.
1492      * &lt;/p&gt;
1493      *
1494      * @param callback a class whose call method will be called when the image
1495      * is ready. The SnapshotResult that is passed into the call method of
1496      * the callback will contain the rendered image and the source scene
1497      * that was rendered. The callback parameter must not be null.
1498      *
1499      * @param image the writable image that will be used to hold the rendered scene.
1500      * It may be null in which case a new WritableImage will be constructed.
1501      * If the image is non-null, the scene will be rendered into the
1502      * existing image.
1503      * In this case, the width and height of the image determine the area
1504      * that is rendered instead of the width and height of the scene.
1505      *
1506      * @throws IllegalStateException if this method is called on a thread
1507      *     other than the JavaFX Application Thread.
1508      *
1509      * @throws NullPointerException if the callback parameter is null.
1510      * @since JavaFX 2.2
1511      */
1512     public void snapshot(Callback&lt;SnapshotResult, Void&gt; callback, WritableImage image) {
1513         Toolkit.getToolkit().checkFxUserThread();
1514         if (callback == null) {
1515             throw new NullPointerException(&quot;The callback must not be null&quot;);
1516         }
1517 
1518         final Callback&lt;SnapshotResult, Void&gt; theCallback = callback;
1519         final WritableImage theImage = image;
1520 
1521         // Create a deferred runnable that will be run from a pulse listener
1522         // that is called after all of the scenes have been synced but before
1523         // any of them have been rendered.
1524         final Runnable snapshotRunnable = () -&gt; {
1525             WritableImage img = doSnapshot(theImage);
1526 //                System.err.println(&quot;Calling snapshot callback&quot;);
1527             SnapshotResult result = new SnapshotResult(img, Scene.this, null);
1528             try {
1529                 Void v = theCallback.call(result);
1530             } catch (Throwable th) {
1531                 System.err.println(&quot;Exception in snapshot callback&quot;);
1532                 th.printStackTrace(System.err);
1533             }
1534         };
1535 //        System.err.println(&quot;Schedule a snapshot in the future&quot;);
1536         addSnapshotRunnable(snapshotRunnable);
1537     }
1538 
1539     /**
1540      * Defines the mouse cursor for this {@code Scene}.
1541      */
1542     private ObjectProperty&lt;Cursor&gt; cursor;
1543 
1544     public final void setCursor(Cursor value) {
1545         cursorProperty().set(value);
1546     }
1547 
1548     public final Cursor getCursor() {
1549         return cursor == null ? null : cursor.get();
1550     }
1551 
1552     public final ObjectProperty&lt;Cursor&gt; cursorProperty() {
1553         if (cursor == null) {
1554             cursor = new ObjectPropertyBase&lt;Cursor&gt;() {
1555                          @Override
1556                          protected void invalidated() {
1557                              markCursorDirty();
1558                          }
1559 
1560                          @Override
1561                          public Object getBean() {
1562                              return Scene.this;
1563                          }
1564 
1565                          @Override
1566                          public String getName() {
1567                              return &quot;cursor&quot;;
1568                          }
1569                      };
1570         }
1571         return cursor;
1572     }
1573 
1574     /**
1575      * Looks for any node within the scene graph based on the specified CSS selector.
1576      * If more than one node matches the specified selector, this function
1577      * returns the first of them.
1578      * If no nodes are found with this id, then null is returned.
1579      *
1580      * @param selector The css selector to look up
1581      * @return the {@code Node} in the scene which matches the CSS {@code selector},
1582      * or {@code null} if none is found.
1583      */
1584      public Node lookup(String selector) {
1585          return getRoot().lookup(selector);
1586      }
1587     /**
1588      * A ObservableList of string URLs linking to the stylesheets to use with this scene&#39;s
1589      * contents. For additional information about using CSS with the
1590      * scene graph, see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference
1591      * Guide&lt;/a&gt;.
1592      */
1593     private final ObservableList&lt;String&gt; stylesheets  = new TrackableObservableList&lt;String&gt;() {
1594         @Override
1595         protected void onChanged(Change&lt;String&gt; c) {
1596             StyleManager.getInstance().stylesheetsChanged(Scene.this, c);
1597             // RT-9784 - if stylesheet is removed, reset styled properties to
1598             // their initial value.
1599             c.reset();
1600             while(c.next()) {
1601                 if (c.wasRemoved() == false) {
1602                     continue;
1603                 }
1604                 break; // no point in resetting more than once...
1605             }
1606             getRoot().reapplyCSS();
1607         }
1608     };
1609 
1610     /**
1611      * Gets an observable list of string URLs linking to the stylesheets to use
1612      * with this scene&#39;s contents.
1613      * &lt;p&gt;
1614      * The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1615      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1616      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1617      * the root of the application&#39;s classpath.
1618      * &lt;/p&gt;
1619      * &lt;pre&gt;&lt;code&gt;
1620      *
1621      * package com.example.javafx.app;
1622      *
1623      * import javafx.application.Application;
1624      * import javafx.scene.Group;
1625      * import javafx.scene.Scene;
1626      * import javafx.stage.Stage;
1627      *
1628      * public class MyApp extends Application {
1629      *
1630      *     {@literal @}Override public void start(Stage stage) {
1631      *         Scene scene = new Scene(new Group());
1632      *         scene.getStylesheets().add(&quot;/com/example/javafx/app/mystyles.css&quot;);
1633      *         stage.setScene(scene);
1634      *         stage.show();
1635      *     }
1636      *
1637      *     public static void main(String[] args) {
1638      *         launch(args);
1639      *     }
1640      * }
1641      * &lt;/code&gt;&lt;/pre&gt;
1642      * For additional information about using CSS with the scene graph,
1643      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1644      *
1645      * @return the list of stylesheets to use with this scene
1646      */
1647     public final ObservableList&lt;String&gt; getStylesheets() { return stylesheets; }
1648 
1649     private ObjectProperty&lt;String&gt; userAgentStylesheet = null;
1650 
1651     /**
1652      * @return the userAgentStylesheet property.
1653      * @see #getUserAgentStylesheet()
1654      * @see #setUserAgentStylesheet(String)
1655      * @since  JavaFX 8u20
1656      */
1657     public final ObjectProperty&lt;String&gt; userAgentStylesheetProperty() {
1658         if (userAgentStylesheet == null) {
1659             userAgentStylesheet = new SimpleObjectProperty&lt;String&gt;(Scene.this, &quot;userAgentStylesheet&quot;, null) {
1660                 @Override protected void invalidated() {
1661                     StyleManager.getInstance().forget(Scene.this);
1662                     getRoot().reapplyCSS();
1663                 }
1664             };
1665         }
1666         return userAgentStylesheet;
1667     }
1668 
1669     /**
1670      * Get the URL of the user-agent stylesheet that will be used by this Scene. If the URL has not been set,
1671      * the platform-default user-agent stylesheet will be used.
1672      * &lt;p&gt;
1673      * For additional information about using CSS with the scene graph,
1674      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1675      * &lt;/p&gt;
1676      * @return The URL of the user-agent stylesheet that will be used by this Scene,
1677      * or null if has not been set.
1678      * @since  JavaFX 8u20
1679      */
1680     public final String getUserAgentStylesheet() {
1681         return userAgentStylesheet == null ? null : userAgentStylesheet.get();
1682     }
1683 
1684     /**
1685      * Set the URL of the user-agent stylesheet that will be used by this Scene in place of the
1686      * the platform-default user-agent stylesheet. If the URL does not resolve to a valid location,
1687      * the platform-default user-agent stylesheet will be used.
1688      * &lt;p&gt;
1689      * For additional information about using CSS with the scene graph,
1690      * see the &lt;a href=&quot;doc-files/cssref.html&quot;&gt;CSS Reference Guide&lt;/a&gt;.
1691      * &lt;/p&gt;
1692      * @param url The URL is a hierarchical URI of the form [scheme:][//authority][path]. If the URL
1693      * does not have a [scheme:] component, the URL is considered to be the [path] component only.
1694      * Any leading &#39;/&#39; character of the [path] is ignored and the [path] is treated as a path relative to
1695      * the root of the application&#39;s classpath.
1696      * @since  JavaFX 8u20
1697      */
1698     public final void setUserAgentStylesheet(String url) {
1699         userAgentStylesheetProperty().set(url);
1700     }
1701 
1702     /**
1703      * Retrieves the depth buffer attribute for this scene.
1704      * @return the depth buffer attribute.
1705      */
1706     public final boolean isDepthBuffer() {
1707         return depthBuffer;
1708     }
1709 
1710     boolean isDepthBufferInternal() {
1711         if (!Platform.isSupported(ConditionalFeature.SCENE3D)) {
1712             return false;
1713         }
1714         return depthBuffer;
1715     }
1716 
1717     private void init(double width, double height) {
1718         if (width &gt;= 0) {
1719             widthSetByUser = width;
1720             setWidth((float)width);
1721         }
1722         if (height &gt;= 0) {
1723             heightSetByUser = height;
1724             setHeight((float)height);
1725         }
1726         sizeInitialized = (widthSetByUser &gt;= 0 &amp;&amp; heightSetByUser &gt;= 0);
1727     }
1728 
1729     private void init() {
1730         if (PerformanceTracker.isLoggingEnabled()) {
1731             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;]&quot;);
1732         }
1733         mouseHandler = new MouseHandler();
1734         clickGenerator = new ClickGenerator();
1735 
1736         if (PerformanceTracker.isLoggingEnabled()) {
1737             PerformanceTracker.logEvent(&quot;Scene.init for [&quot; + this + &quot;] - finished&quot;);
1738         }
1739     }
1740 
1741     void preferredSize() {
1742         final Parent root = getRoot();
1743 
1744         // one or the other isn&#39;t initialized, need to perform layout in
1745         // order to ensure we can properly measure the preferred size of the
1746         // scene
1747         doCSSPass();
1748 
1749         resizeRootToPreferredSize(root);
1750         doLayoutPass();
1751 
1752         if (widthSetByUser &lt; 0) {
1753             setWidth(root.isResizable()? root.getLayoutX() + root.getTranslateX() + root.getLayoutBounds().getWidth() :
1754                             root.getBoundsInParent().getMaxX());
1755         } else {
1756             setWidth(widthSetByUser);
1757         }
1758 
1759         if (heightSetByUser &lt; 0) {
1760             setHeight(root.isResizable()? root.getLayoutY() + root.getTranslateY() + root.getLayoutBounds().getHeight() :
1761                             root.getBoundsInParent().getMaxY());
1762         } else {
1763             setHeight(heightSetByUser);
1764         }
1765 
1766         sizeInitialized = (getWidth() &gt; 0) &amp;&amp; (getHeight() &gt; 0);
1767 
1768         PerformanceTracker.logEvent(&quot;Scene preferred bounds computation complete&quot;);
1769     }
1770 
1771     final void resizeRootToPreferredSize(Parent root) {
1772         final double preferredWidth;
1773         final double preferredHeight;
1774 
1775         final Orientation contentBias = root.getContentBias();
1776         if (contentBias == null) {
1777             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1778             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1779         } else if (contentBias == Orientation.HORIZONTAL) {
1780             // height depends on width
1781             preferredWidth = getPreferredWidth(root, widthSetByUser, -1);
1782             preferredHeight = getPreferredHeight(root, heightSetByUser,
1783                                                        preferredWidth);
1784         } else /* if (contentBias == Orientation.VERTICAL) */ {
1785             // width depends on height
1786             preferredHeight = getPreferredHeight(root, heightSetByUser, -1);
1787             preferredWidth = getPreferredWidth(root, widthSetByUser,
1788                                                      preferredHeight);
1789         }
1790 
1791         root.resize(preferredWidth, preferredHeight);
1792     }
1793 
1794     private static double getPreferredWidth(Parent root,
1795                                             double forcedWidth,
1796                                             double height) {
1797         if (forcedWidth &gt;= 0) {
1798             return forcedWidth;
1799         }
1800         final double normalizedHeight = (height &gt;= 0) ? height : -1;
1801         return root.boundedSize(root.prefWidth(normalizedHeight),
1802                                 root.minWidth(normalizedHeight),
1803                                 root.maxWidth(normalizedHeight));
1804     }
1805 
1806     private static double getPreferredHeight(Parent root,
1807                                              double forcedHeight,
1808                                              double width) {
1809         if (forcedHeight &gt;= 0) {
1810             return forcedHeight;
1811         }
1812         final double normalizedWidth = (width &gt;= 0) ? width : -1;
1813         return root.boundedSize(root.prefHeight(normalizedWidth),
1814                                 root.minHeight(normalizedWidth),
1815                                 root.maxHeight(normalizedWidth));
1816     }
1817 
1818     private PerformanceTracker tracker;
1819     private static final Object trackerMonitor = new Object();
1820 
1821     // mouse events handling
1822     private MouseHandler mouseHandler;
1823     private ClickGenerator clickGenerator;
1824 
1825     // gesture events handling
1826     private Point2D cursorScreenPos;
1827     private Point2D cursorScenePos;
1828 
1829     private static class TouchGesture {
1830         WeakReference&lt;EventTarget&gt; target;
1831         Point2D sceneCoords;
1832         Point2D screenCoords;
1833         boolean finished;
1834     }
1835 
1836     private final TouchGesture scrollGesture = new TouchGesture();
1837     private final TouchGesture zoomGesture = new TouchGesture();
1838     private final TouchGesture rotateGesture = new TouchGesture();
1839     private final TouchGesture swipeGesture = new TouchGesture();
1840 
1841     // touch events handling
1842     private TouchMap touchMap = new TouchMap();
1843     private TouchEvent nextTouchEvent = null;
1844     private TouchPoint[] touchPoints = null;
1845     private int touchEventSetId = 0;
1846     private int touchPointIndex = 0;
1847     private Map&lt;Integer, EventTarget&gt; touchTargets =
1848             new HashMap&lt;Integer, EventTarget&gt;();
1849 
1850     void processMouseEvent(MouseEvent e) {
1851         mouseHandler.process(e, false);
1852     }
1853 
1854     private void processMenuEvent(double x2, double y2, double xAbs, double yAbs, boolean isKeyboardTrigger) {
1855         EventTarget eventTarget = null;
1856         Scene.inMousePick = true;
1857         if (isKeyboardTrigger) {
1858             Node sceneFocusOwner = getFocusOwner();
1859 
1860             // for keyboard triggers set coordinates inside focus owner
1861             final double xOffset = xAbs - x2;
1862             final double yOffset = yAbs - y2;
1863             if (sceneFocusOwner != null) {
1864                 final Bounds bounds = sceneFocusOwner.localToScene(
1865                         sceneFocusOwner.getBoundsInLocal());
1866                 x2 = bounds.getMinX() + bounds.getWidth() / 4;
1867                 y2 = bounds.getMinY() + bounds.getHeight() / 2;
1868                 eventTarget = sceneFocusOwner;
1869             } else {
1870                 x2 = Scene.this.getWidth() / 4;
1871                 y2 = Scene.this.getWidth() / 2;
1872                 eventTarget = Scene.this;
1873             }
1874 
1875             xAbs = x2 + xOffset;
1876             yAbs = y2 + yOffset;
1877         }
1878 
1879         final PickResult res = pick(x2, y2);
1880 
1881         if (!isKeyboardTrigger) {
1882             eventTarget = res.getIntersectedNode();
1883             if (eventTarget == null) {
1884                 eventTarget = this;
1885             }
1886         }
1887 
1888         if (eventTarget != null) {
1889             ContextMenuEvent context = new ContextMenuEvent(ContextMenuEvent.CONTEXT_MENU_REQUESTED,
1890                     x2, y2, xAbs, yAbs, isKeyboardTrigger, res);
1891             Event.fireEvent(eventTarget, context);
1892         }
1893         Scene.inMousePick = false;
1894     }
1895 
1896     private void processGestureEvent(GestureEvent e, TouchGesture gesture) {
1897         EventTarget pickedTarget = null;
1898 
1899         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1900                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1901                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1902             gesture.target = null;
1903             gesture.finished = false;
1904         }
1905 
1906         if (gesture.target != null &amp;&amp; (!gesture.finished || e.isInertia())) {
1907             pickedTarget = gesture.target.get();
1908         } else {
1909             pickedTarget = e.getPickResult().getIntersectedNode();
1910             if (pickedTarget == null) {
1911                 pickedTarget = this;
1912             }
1913         }
1914 
1915         if (e.getEventType() == ZoomEvent.ZOOM_STARTED ||
1916                 e.getEventType() == RotateEvent.ROTATION_STARTED ||
1917                 e.getEventType() == ScrollEvent.SCROLL_STARTED) {
1918             gesture.target = new WeakReference&lt;&gt;(pickedTarget);
1919         }
1920         if (e.getEventType() != ZoomEvent.ZOOM_FINISHED &amp;&amp;
1921                 e.getEventType() != RotateEvent.ROTATION_FINISHED &amp;&amp;
1922                 e.getEventType() != ScrollEvent.SCROLL_FINISHED &amp;&amp;
1923                 !e.isInertia()) {
1924             gesture.sceneCoords = new Point2D(e.getSceneX(), e.getSceneY());
1925             gesture.screenCoords = new Point2D(e.getScreenX(), e.getScreenY());
1926         }
1927 
1928         if (pickedTarget != null) {
1929             Event.fireEvent(pickedTarget, e);
1930         }
1931 
1932         if (e.getEventType() == ZoomEvent.ZOOM_FINISHED ||
1933                 e.getEventType() == RotateEvent.ROTATION_FINISHED ||
1934                 e.getEventType() == ScrollEvent.SCROLL_FINISHED) {
1935             gesture.finished = true;
1936         }
1937     }
1938 
1939     private void processTouchEvent(TouchEvent e, TouchPoint[] touchPoints) {
1940         inMousePick = true;
1941         touchEventSetId++;
1942 
1943         List&lt;TouchPoint&gt; touchList = Arrays.asList(touchPoints);
1944 
1945         // fire all the events
1946         for (TouchPoint tp : touchPoints) {
1947             if (tp.getTarget() != null) {
1948                 EventType&lt;TouchEvent&gt; type = null;
1949                 switch (tp.getState()) {
1950                     case MOVED:
1951                         type = TouchEvent.TOUCH_MOVED;
1952                         break;
1953                     case PRESSED:
1954                         type = TouchEvent.TOUCH_PRESSED;
1955                         break;
1956                     case RELEASED:
1957                         type = TouchEvent.TOUCH_RELEASED;
1958                         break;
1959                     case STATIONARY:
1960                         type = TouchEvent.TOUCH_STATIONARY;
1961                         break;
1962                 }
1963 
1964                 for (TouchPoint t : touchPoints) {
1965                     TouchPointHelper.reset(t);
1966                 }
1967 
1968                 TouchEvent te = new TouchEvent(type, tp, touchList,
1969                         touchEventSetId, e.isShiftDown(), e.isControlDown(),
1970                         e.isAltDown(), e.isMetaDown());
1971 
1972                 Event.fireEvent(tp.getTarget(), te);
1973             }
1974         }
1975 
1976         // process grabbing
1977         for (TouchPoint tp : touchPoints) {
1978             EventTarget grabbed = tp.getGrabbed();
1979             if (grabbed != null) {
1980                 touchTargets.put(tp.getId(), grabbed);
1981             };
1982 
1983             if (grabbed == null || tp.getState() == TouchPoint.State.RELEASED) {
1984                 touchTargets.remove(tp.getId());
1985             }
1986         }
1987 
1988         inMousePick = false;
1989     }
1990 
1991     /**
1992      * Note: The only user of this method is in unit test: PickAndContainTest.
1993      */
1994     Node test_pick(double x, double y) {
1995         inMousePick = true;
1996         PickResult result = mouseHandler.pickNode(new PickRay(x, y, 1,
1997                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY));
1998         inMousePick = false;
1999         if (result != null) {
2000             return result.getIntersectedNode();
2001         }
2002         return null;
2003     }
2004 
2005     private PickResult pick(final double x, final double y) {
2006         pick(tmpTargetWrapper, x, y);
2007         return tmpTargetWrapper.getResult();
2008     }
2009 
2010     private boolean isInScene(double x, double y) {
2011         if (x &lt; 0 || y &lt; 0 || x &gt; getWidth() || y &gt; getHeight())  {
2012             return false;
2013         }
2014 
2015         Window w = getWindow();
2016         if (w instanceof Stage
2017                 &amp;&amp; ((Stage) w).getStyle() == StageStyle.TRANSPARENT
2018                 &amp;&amp; getFill() == null) {
2019             return false;
2020         }
2021 
2022         return true;
2023     }
2024 
2025     private void pick(TargetWrapper target, final double x, final double y) {
2026         final PickRay pickRay = getEffectiveCamera().computePickRay(
2027                 x, y, null);
2028 
2029         final double mag = pickRay.getDirectionNoClone().length();
2030         pickRay.getDirectionNoClone().normalize();
2031         final PickResult res = mouseHandler.pickNode(pickRay);
2032         if (res != null) {
2033             target.setNodeResult(res);
2034         } else {
2035             //TODO: is this the intersection with projection plane?
2036             Vec3d o = pickRay.getOriginNoClone();
2037             Vec3d d = pickRay.getDirectionNoClone();
2038             target.setSceneResult(new PickResult(
2039                     null, new Point3D(
2040                     o.x + mag * d.x,
2041                     o.y + mag * d.y,
2042                     o.z + mag * d.z),
2043                     mag),
2044                     isInScene(x, y) ? this : null);
2045         }
2046     }
2047 
2048     /***************************************************************************
2049      *                                                                         *
2050      * Key Events and Focus Traversal                                          *
2051      *                                                                         *
2052      **************************************************************************/
2053 
2054     /*
2055      * We cannot initialize keyHandler in init because some of the triggers
2056      * access it before the init block.
2057      * No clue why def keyHandler = bind lazy {KeyHandler{scene:this};}
2058      * does not compile.
2059      */
2060     private KeyHandler keyHandler = null;
2061     private KeyHandler getKeyHandler() {
2062         if (keyHandler == null) {
2063             keyHandler = new KeyHandler();
2064         }
2065         return keyHandler;
2066     }
2067     /**
2068      * Set to true if something has happened to the focused node that makes
2069      * it no longer eligible to have the focus.
2070      *
2071      */
2072     private boolean focusDirty = true;
2073 
2074     final void setFocusDirty(boolean value) {
2075         if (!focusDirty) {
2076             Toolkit.getToolkit().requestNextPulse();
2077         }
2078         focusDirty = value;
2079     }
2080 
2081     final boolean isFocusDirty() {
2082         return focusDirty;
2083     }
2084 
2085     private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);
2086 
2087     /**
2088      * Traverses focus from the given node in the given direction.
2089      */
2090     boolean traverse(Node node, Direction dir) {
2091         if (node.getSubScene() != null) {
2092             return node.getSubScene().traverse(node, dir);
2093         }
2094         return traversalEngine.trav(node, dir) != null;
2095     }
2096 
2097     /**
2098      * Moves the focus to a reasonable initial location. Called when a scene&#39;s
2099      * focus is dirty and there&#39;s no current owner, or if the owner has been
2100      * removed from the scene.
2101      */
2102     private void focusInitial() {
2103         traversalEngine.traverseToFirst();
2104     }
2105 
2106     /**
2107      * Moves the focus to a reasonble location &quot;near&quot; the given node.
2108      * Called when the focused node is no longer eligible to have
2109      * the focus because it has become invisible or disabled. This
2110      * function assumes that it is still a member of the same scene.
2111      */
2112     private void focusIneligible(Node node) {
2113         traverse(node, Direction.NEXT);
2114     }
2115 
2116     public void processKeyEvent(KeyEvent e) {
2117         if (dndGesture != null) {
2118             if (!dndGesture.processKey(e)) {
2119                 dndGesture = null;
2120             }
2121         }
2122 
2123         getKeyHandler().process(e);
2124     }
2125 
2126     void requestFocus(Node node) {
2127         getKeyHandler().requestFocus(node);
2128     }
2129 
2130     private Node oldFocusOwner;
2131 
2132     /**
2133       * The scene&#39;s current focus owner node. This node&#39;s &quot;focused&quot;
2134       * variable might be false if this scene has no window, or if the
2135       * window is inactive (window.focused == false).
2136       * @since JavaFX 2.2
2137       */
2138     private ReadOnlyObjectWrapper&lt;Node&gt; focusOwner = new ReadOnlyObjectWrapper&lt;Node&gt;(this, &quot;focusOwner&quot;) {
2139 
2140         @Override
2141         protected void invalidated() {
2142             if (oldFocusOwner != null) {
2143                 ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);
2144             }
2145             Node value = get();
2146             if (value != null) {
2147                 ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);
2148                 if (value != oldFocusOwner) {
2149                     value.getScene().enableInputMethodEvents(
2150                             value.getInputMethodRequests() != null
2151                             &amp;&amp; value.getOnInputMethodTextChanged() != null);
2152                 }
2153             }
2154             // for the rest of the method we need to update the oldFocusOwner
2155             // and use a local copy of it because the user handlers can cause
2156             // recurrent calls of requestFocus
2157             Node localOldOwner = oldFocusOwner;
2158             oldFocusOwner = value;
2159             if (localOldOwner != null) {
2160                 ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();
2161             }
2162             if (value != null) {
2163                 ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();
2164             }
2165             PlatformLogger logger = Logging.getFocusLogger();
2166             if (logger.isLoggable(Level.FINE)) {
2167                 if (value == get()) {
2168                     logger.fine(&quot;Changed focus from &quot;
2169                             + localOldOwner + &quot; to &quot; + value);
2170                 } else {
2171                     logger.fine(&quot;Changing focus from &quot;
2172                             + localOldOwner + &quot; to &quot; + value
2173                             + &quot; canceled by nested requestFocus&quot;);
2174                 }
2175             }
2176             if (accessible != null) {
2177                 accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
2178             }
2179         }
2180     };
2181 
2182     public final Node getFocusOwner() {
2183         return focusOwner.get();
2184     }
2185 
2186     public final ReadOnlyObjectProperty&lt;Node&gt; focusOwnerProperty() {
2187         return focusOwner.getReadOnlyProperty();
2188     }
2189 
2190     // For testing.
2191     void focusCleanup() {
2192         scenePulseListener.focusCleanup();
2193     }
2194 
2195     private void processInputMethodEvent(InputMethodEvent e) {
2196         Node node = getFocusOwner();
2197         if (node != null) {
2198             node.fireEvent(e);
2199         }
2200     }
2201 
2202     public void enableInputMethodEvents(boolean enable) {
2203        if (peer != null) {
2204            peer.enableInputMethodEvents(enable);
2205        }
2206     }
2207 
2208     /**
2209      * Returns true if this scene is quiescent, i.e. it has no activity
2210      * pending on it such as CSS processing or layout requests.
2211      *
2212      * Intended to be used for tests only
2213      *
2214      * @return boolean indicating whether the scene is quiescent
2215      */
2216     boolean isQuiescent() {
2217         final Parent r = getRoot();
2218         return !isFocusDirty()
2219                &amp;&amp; (r == null || (r.cssFlag == CssFlags.CLEAN &amp;&amp;
2220                 r.layoutFlag == LayoutFlags.CLEAN));
2221     }
2222 
2223     /**
2224      * A listener for pulses, used for testing. If non-null, this is called at
2225      * the very end of ScenePulseListener.pulse().
2226      *
2227      * Intended to be used for tests only
2228      */
2229     Runnable testPulseListener = null;
2230 
2231     /**
2232      * Set the specified dirty bit and mark the peer as dirty
2233      */
2234     private void markDirty(DirtyBits dirtyBit) {
2235         setDirty(dirtyBit);
2236         if (peer != null) {
2237             Toolkit.getToolkit().requestNextPulse();
2238         }
2239     }
2240 
2241     /**
2242      * Set the specified dirty bit
2243      */
2244     private void setDirty(DirtyBits dirtyBit) {
2245         dirtyBits.add(dirtyBit);
2246     }
2247 
2248     /**
2249      * Test the specified dirty bit
2250      */
2251     private boolean isDirty(DirtyBits dirtyBit) {
2252         return dirtyBits.contains(dirtyBit);
2253     }
2254 
2255     /**
2256      * Test whether the dirty bits are empty
2257      */
2258     private boolean isDirtyEmpty() {
2259         return dirtyBits.isEmpty();
2260     }
2261 
2262     /**
2263      * Clear all dirty bits
2264      */
2265     private void clearDirty() {
2266         dirtyBits.clear();
2267     }
2268 
2269     private enum DirtyBits {
2270         FILL_DIRTY,
2271         ROOT_DIRTY,
2272         CAMERA_DIRTY,
2273         LIGHTS_DIRTY,
2274         CURSOR_DIRTY;
2275     }
2276 
2277     private List&lt;LightBase&gt; lights = new ArrayList&lt;&gt;();
2278 
2279     // @param light must not be null
2280     final void addLight(LightBase light) {
2281         if (!lights.contains(light)) {
2282             lights.add(light);
2283             markDirty(DirtyBits.LIGHTS_DIRTY);
2284         }
2285     }
2286 
2287     final void removeLight(LightBase light) {
2288         if (lights.remove(light)) {
2289             markDirty(DirtyBits.LIGHTS_DIRTY);
2290         }
2291     }
2292 
2293     /**
2294      * PG Light synchronizer.
2295      */
2296     private void syncLights() {
2297         if (!isDirty(DirtyBits.LIGHTS_DIRTY)) {
2298             return;
2299         }
2300         inSynchronizer = true;
2301         NGLightBase peerLights[] = peer.getLights();
2302         if (!lights.isEmpty() || (peerLights != null)) {
2303             if (lights.isEmpty()) {
2304                 peer.setLights(null);
2305             } else {
2306                 if (peerLights == null || peerLights.length &lt; lights.size()) {
2307                     peerLights = new NGLightBase[lights.size()];
2308                 }
2309                 int i = 0;
2310                 for (; i &lt; lights.size(); i++) {
2311                     peerLights[i] = lights.get(i).getPeer();
2312                 }
2313                 // Clear the rest of the list
2314                 while (i &lt; peerLights.length &amp;&amp; peerLights[i] != null) {
2315                     peerLights[i++] = null;
2316                 }
2317                 peer.setLights(peerLights);
2318             }
2319         }
2320         inSynchronizer = false;
2321     }
2322 
2323     //INNER CLASSES
2324 
2325     /*******************************************************************************
2326      *                                                                             *
2327      * Scene Pulse Listener                                                        *
2328      *                                                                             *
2329      ******************************************************************************/
2330 
2331     class ScenePulseListener implements TKPulseListener {
2332 
2333         private boolean firstPulse = true;
2334 
2335         /**
2336          * PG synchronizer. Called once per frame from the pulse listener.
2337          * This function calls the synchronizePGNode method on each node in
2338          * the dirty list.
2339          */
2340         private void synchronizeSceneNodes() {
2341             Toolkit.getToolkit().checkFxUserThread();
2342 
2343             Scene.inSynchronizer = true;
2344 
2345             // if dirtyNodes is null then that means this Scene has not yet been
2346             // synchronized, and so we will simply synchronize every node in the
2347             // scene and then create the dirty nodes array list
2348             if (Scene.this.dirtyNodes == null) {
2349                 // must do this recursively
2350                 syncAll(getRoot());
2351                 dirtyNodes = new Node[MIN_DIRTY_CAPACITY];
2352 
2353             } else {
2354                 // This is not the first time this scene has been synchronized,
2355                 // so we will only synchronize those nodes that need it
2356                 for (int i = 0 ; i &lt; dirtyNodesSize; ++i) {
2357                     Node node = dirtyNodes[i];
2358                     dirtyNodes[i] = null;
2359                     if (node.getScene() == Scene.this) {
2360                             node.syncPeer();
2361                         }
2362                     }
2363                 dirtyNodesSize = 0;
2364             }
2365 
2366             Scene.inSynchronizer = false;
2367         }
2368 
2369         /**
2370          * Recursive function for synchronizing every node in the scenegraph.
2371          * The return value is the number of nodes in the graph.
2372          */
2373         private int syncAll(Node node) {
2374             node.syncPeer();
2375             int size = 1;
2376             if (node instanceof Parent) {
2377                 Parent p = (Parent) node;
2378                 final int childrenCount = p.getChildren().size();
2379 
2380                 for (int i = 0; i &lt; childrenCount; i++) {
2381                     Node n = p.getChildren().get(i);
2382                     if (n != null) {
2383                         size += syncAll(n);
2384                     }
2385                 }
2386             } else if (node instanceof SubScene) {
2387                 SubScene subScene = (SubScene)node;
2388                 size += syncAll(subScene.getRoot());
2389             }
2390             if (node.getClip() != null) {
2391                 size += syncAll(node.getClip());
2392             }
2393 
2394             return size;
2395         }
2396 
2397         private void synchronizeSceneProperties() {
2398             inSynchronizer = true;
2399             if (isDirty(DirtyBits.ROOT_DIRTY)) {
2400                 peer.setRoot(getRoot().getPeer());
2401             }
2402 
2403             if (isDirty(DirtyBits.FILL_DIRTY)) {
2404                 Toolkit tk = Toolkit.getToolkit();
2405                 peer.setFillPaint(getFill() == null ? null : tk.getPaint(getFill()));
2406             }
2407 
2408             // new camera was set on the scene or old camera changed
2409             final Camera cam = getEffectiveCamera();
2410             if (isDirty(DirtyBits.CAMERA_DIRTY)) {
2411                 NodeHelper.updatePeer(cam);
2412                 peer.setCamera((NGCamera) cam.getPeer());
2413             }
2414 
2415             if (isDirty(DirtyBits.CURSOR_DIRTY)) {
2416                 mouseHandler.updateCursor(getCursor());
2417                 mouseHandler.updateCursorFrame();
2418             }
2419 
2420             clearDirty();
2421             inSynchronizer = false;
2422         }
2423 
2424         /**
2425          * The focus is considered dirty if something happened to
2426          * the scene graph that may require the focus to be moved.
2427          * This must handle cases where (a) the focus owner may have
2428          * become ineligible to have the focus, and (b) where the focus
2429          * owner is null and a node may have become traversable and eligible.
2430          */
2431         private void focusCleanup() {
2432             if (Scene.this.isFocusDirty()) {
2433                 final Node oldOwner = Scene.this.getFocusOwner();
2434                 if (oldOwner == null) {
2435                     Scene.this.focusInitial();
2436                 } else if (oldOwner.getScene() != Scene.this) {
2437                     Scene.this.requestFocus(null);
2438                     Scene.this.focusInitial();
2439                 } else if (!oldOwner.isCanReceiveFocus()) {
2440                     Scene.this.requestFocus(null);
2441                     Scene.this.focusIneligible(oldOwner);
2442                 }
2443                 Scene.this.setFocusDirty(false);
2444             }
2445         }
2446 
2447         @Override
2448         public void pulse() {
2449             if (Scene.this.tracker != null) {
2450                 Scene.this.tracker.pulse();
2451             }
2452             if (firstPulse) {
2453                 PerformanceTracker.logEvent(&quot;Scene - first repaint&quot;);
2454             }
2455 
2456             focusCleanup();
2457 
2458             disposeAccessibles();
2459 
2460             // run any scene pre pulse listeners immediately _before_ css / layout,
2461             // and before scene synchronization
2462             if (preLayoutPulseListeners != null) {
2463                 for (Runnable r : preLayoutPulseListeners) {
2464                     r.run();
2465                 }
2466             }
2467 
2468             if (PULSE_LOGGING_ENABLED) {
2469                 PulseLogger.newPhase(&quot;CSS Pass&quot;);
2470             }
2471             Scene.this.doCSSPass();
2472 
2473             if (PULSE_LOGGING_ENABLED) {
2474                 PulseLogger.newPhase(&quot;Layout Pass&quot;);
2475             }
2476             Scene.this.doLayoutPass();
2477 
2478             // run any scene post pulse listeners immediately _after_ css / layout,
2479             // and before scene synchronization
2480             if (postLayoutPulseListeners != null) {
2481                 for (Runnable r : postLayoutPulseListeners) {
2482                     r.run();
2483                 }
2484             }
2485 
2486             boolean dirty = dirtyNodes == null || dirtyNodesSize != 0 || !isDirtyEmpty();
2487             if (dirty) {
2488                 if (PULSE_LOGGING_ENABLED) {
2489                     PulseLogger.newPhase(&quot;Update bounds&quot;);
2490                 }
2491                 getRoot().updateBounds();
2492                 if (peer != null) {
2493                     try {
2494                         if (PULSE_LOGGING_ENABLED) {
2495                             PulseLogger.newPhase(&quot;Waiting for previous rendering&quot;);
2496                         }
2497                         peer.waitForRenderingToComplete();
2498                         peer.waitForSynchronization();
2499                         // synchronize scene properties
2500                         if (PULSE_LOGGING_ENABLED) {
2501                             PulseLogger.newPhase(&quot;Copy state to render graph&quot;);
2502                         }
2503                         syncLights();
2504                         synchronizeSceneProperties();
2505                         // Run the synchronizer
2506                         synchronizeSceneNodes();
2507                         Scene.this.mouseHandler.pulse();
2508                         // Tell the scene peer that it needs to repaint
2509                         peer.markDirty();
2510                     } finally {
2511                         peer.releaseSynchronization(true);
2512                     }
2513                 } else {
2514                     if (PULSE_LOGGING_ENABLED) {
2515                         PulseLogger.newPhase(&quot;Synchronize with null peer&quot;);
2516                     }
2517                     synchronizeSceneNodes();
2518                     Scene.this.mouseHandler.pulse();
2519                 }
2520 
2521                 if (Scene.this.getRoot().cssFlag != CssFlags.CLEAN) {
2522                     NodeHelper.markDirty(Scene.this.getRoot(),
2523                             com.sun.javafx.scene.DirtyBits.NODE_CSS);
2524                 }
2525             }
2526 
2527             // required for image cursor created from animated image
2528             Scene.this.mouseHandler.updateCursorFrame();
2529 
2530             if (firstPulse) {
2531                 if (PerformanceTracker.isLoggingEnabled()) {
2532                     PerformanceTracker.logEvent(&quot;Scene - first repaint - layout complete&quot;);
2533                     if (PrismSettings.perfLogFirstPaintFlush) {
2534                         PerformanceTracker.outputLog();
2535                     }
2536                     if (PrismSettings.perfLogFirstPaintExit) {
2537                         System.exit(0);
2538                     }
2539                 }
2540                 firstPulse = false;
2541             }
2542 
2543             if (testPulseListener != null) {
2544                 testPulseListener.run();
2545             }
2546         }
2547     }
2548 
2549     /*******************************************************************************
2550      *                                                                             *
2551      * Scene Peer Listener                                                         *
2552      *                                                                             *
2553      ******************************************************************************/
2554 
2555     class ScenePeerListener implements TKSceneListener {
2556         @Override
2557         public void changedLocation(float x, float y) {
2558             if (x != Scene.this.getX()) {
2559                 Scene.this.setX(x);
2560             }
2561             if (y != Scene.this.getY()) {
2562                 Scene.this.setY(y);
2563             }
2564         }
2565 
2566         @Override
2567         public void changedSize(float w, float h) {
2568             if (w != Scene.this.getWidth()) Scene.this.setWidth(w);
2569             if (h != Scene.this.getHeight()) Scene.this.setHeight(h);
2570         }
2571 
2572         @Override
2573         public void mouseEvent(EventType&lt;MouseEvent&gt; type, double x, double y, double screenX, double screenY,
2574                                MouseButton button, boolean popupTrigger, boolean synthesized,
2575                                boolean shiftDown, boolean controlDown, boolean altDown, boolean metaDown,
2576                                boolean primaryDown, boolean middleDown, boolean secondaryDown,
2577                                boolean backDown, boolean forwardDown)
2578         {
2579             MouseEvent mouseEvent = new MouseEvent(type, x, y, screenX, screenY, button,
2580                     0, // click count will be adjusted by clickGenerator later anyway
2581                     shiftDown, controlDown, altDown, metaDown,
2582                     primaryDown, middleDown, secondaryDown, backDown, forwardDown,
2583                     synthesized, popupTrigger, false, null);
2584             processMouseEvent(mouseEvent);
2585         }
2586 
2587 
2588         @Override
2589         public void keyEvent(KeyEvent keyEvent)
2590         {
2591             processKeyEvent(keyEvent);
2592         }
2593 
2594         @Override
2595         public void inputMethodEvent(EventType&lt;InputMethodEvent&gt; type,
2596                                      ObservableList&lt;InputMethodTextRun&gt; composed, String committed,
2597                                      int caretPosition)
2598         {
2599             InputMethodEvent inputMethodEvent = new InputMethodEvent(
2600                type, composed, committed, caretPosition);
2601             processInputMethodEvent(inputMethodEvent);
2602         }
2603 
2604         public void menuEvent(double x, double y, double xAbs, double yAbs,
2605                 boolean isKeyboardTrigger) {
2606             Scene.this.processMenuEvent(x, y, xAbs,yAbs, isKeyboardTrigger);
2607         }
2608 
2609         @Override
2610         public void scrollEvent(
2611                 EventType&lt;ScrollEvent&gt; eventType,
2612                 double scrollX, double scrollY,
2613                 double totalScrollX, double totalScrollY,
2614                 double xMultiplier, double yMultiplier,
2615                 int touchCount,
2616                 int scrollTextX, int scrollTextY,
2617                 int defaultTextX, int defaultTextY,
2618                 double x, double y, double screenX, double screenY,
2619                 boolean _shiftDown, boolean _controlDown,
2620                 boolean _altDown, boolean _metaDown,
2621                 boolean _direct, boolean _inertia) {
2622 
2623             ScrollEvent.HorizontalTextScrollUnits xUnits = scrollTextX &gt; 0 ?
2624                     ScrollEvent.HorizontalTextScrollUnits.CHARACTERS :
2625                     ScrollEvent.HorizontalTextScrollUnits.NONE;
2626 
2627             double xText = scrollTextX &lt; 0 ? 0 : scrollTextX * scrollX;
2628 
2629             ScrollEvent.VerticalTextScrollUnits yUnits = scrollTextY &gt; 0 ?
2630                     ScrollEvent.VerticalTextScrollUnits.LINES :
2631                     (scrollTextY &lt; 0 ?
2632                         ScrollEvent.VerticalTextScrollUnits.PAGES :
2633                         ScrollEvent.VerticalTextScrollUnits.NONE);
2634 
2635             double yText = scrollTextY &lt; 0 ? scrollY : scrollTextY * scrollY;
2636 
2637             xMultiplier = defaultTextX &gt; 0 &amp;&amp; scrollTextX &gt;= 0
2638                     ? Math.round(xMultiplier * scrollTextX / defaultTextX)
2639                     : xMultiplier;
2640 
2641             yMultiplier = defaultTextY &gt; 0 &amp;&amp; scrollTextY &gt;= 0
2642                     ? Math.round(yMultiplier * scrollTextY / defaultTextY)
2643                     : yMultiplier;
2644 
2645             if (eventType == ScrollEvent.SCROLL_FINISHED) {
2646                 x = scrollGesture.sceneCoords.getX();
2647                 y = scrollGesture.sceneCoords.getY();
2648                 screenX = scrollGesture.screenCoords.getX();
2649                 screenY = scrollGesture.screenCoords.getY();
2650             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2651                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2652                 if (cursorScenePos == null || cursorScreenPos == null) {
2653                     return;
2654                 }
2655                 x = cursorScenePos.getX();
2656                 y = cursorScenePos.getY();
2657                 screenX = cursorScreenPos.getX();
2658                 screenY = cursorScreenPos.getY();
2659             }
2660 
2661             inMousePick = true;
2662             Scene.this.processGestureEvent(new ScrollEvent(
2663                     eventType,
2664                     x, y, screenX, screenY,
2665                     _shiftDown, _controlDown, _altDown, _metaDown,
2666                     _direct, _inertia,
2667                     scrollX * xMultiplier, scrollY * yMultiplier,
2668                     totalScrollX * xMultiplier, totalScrollY * yMultiplier,
2669                     xMultiplier, yMultiplier,
2670                     xUnits, xText, yUnits, yText, touchCount, pick(x, y)),
2671                     scrollGesture);
2672             inMousePick = false;
2673         }
2674 
2675         @Override
2676         public void zoomEvent(
2677                 EventType&lt;ZoomEvent&gt; eventType,
2678                 double zoomFactor, double totalZoomFactor,
2679                 double x, double y, double screenX, double screenY,
2680                 boolean _shiftDown, boolean _controlDown,
2681                 boolean _altDown, boolean _metaDown,
2682                 boolean _direct, boolean _inertia) {
2683 
2684             if (eventType == ZoomEvent.ZOOM_FINISHED) {
2685                 x = zoomGesture.sceneCoords.getX();
2686                 y = zoomGesture.sceneCoords.getY();
2687                 screenX = zoomGesture.screenCoords.getX();
2688                 screenY = zoomGesture.screenCoords.getY();
2689             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2690                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2691                 if (cursorScenePos == null || cursorScreenPos == null) {
2692                     return;
2693                 }
2694                 x = cursorScenePos.getX();
2695                 y = cursorScenePos.getY();
2696                 screenX = cursorScreenPos.getX();
2697                 screenY = cursorScreenPos.getY();
2698             }
2699 
2700             inMousePick = true;
2701             Scene.this.processGestureEvent(new ZoomEvent(eventType,
2702                     x, y, screenX, screenY,
2703                     _shiftDown, _controlDown, _altDown, _metaDown,
2704                     _direct, _inertia,
2705                     zoomFactor, totalZoomFactor, pick(x, y)),
2706                     zoomGesture);
2707             inMousePick = false;
2708         }
2709 
2710         @Override
2711         public void rotateEvent(
2712                 EventType&lt;RotateEvent&gt; eventType, double angle, double totalAngle,
2713                 double x, double y, double screenX, double screenY,
2714                 boolean _shiftDown, boolean _controlDown,
2715                 boolean _altDown, boolean _metaDown,
2716                 boolean _direct, boolean _inertia) {
2717 
2718             if (eventType == RotateEvent.ROTATION_FINISHED) {
2719                 x = rotateGesture.sceneCoords.getX();
2720                 y = rotateGesture.sceneCoords.getY();
2721                 screenX = rotateGesture.screenCoords.getX();
2722                 screenY = rotateGesture.screenCoords.getY();
2723             } else if (Double.isNaN(x) || Double.isNaN(y) ||
2724                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2725                 if (cursorScenePos == null || cursorScreenPos == null) {
2726                     return;
2727                 }
2728                 x = cursorScenePos.getX();
2729                 y = cursorScenePos.getY();
2730                 screenX = cursorScreenPos.getX();
2731                 screenY = cursorScreenPos.getY();
2732             }
2733 
2734             inMousePick = true;
2735             Scene.this.processGestureEvent(new RotateEvent(
2736                     eventType, x, y, screenX, screenY,
2737                     _shiftDown, _controlDown, _altDown, _metaDown,
2738                     _direct, _inertia, angle, totalAngle, pick(x, y)),
2739                     rotateGesture);
2740             inMousePick = false;
2741 
2742         }
2743 
2744         @Override
2745         public void swipeEvent(
2746                 EventType&lt;SwipeEvent&gt; eventType, int touchCount,
2747                 double x, double y, double screenX, double screenY,
2748                 boolean _shiftDown, boolean _controlDown,
2749                 boolean _altDown, boolean _metaDown, boolean _direct) {
2750 
2751             if (Double.isNaN(x) || Double.isNaN(y) ||
2752                     Double.isNaN(screenX) || Double.isNaN(screenY)) {
2753                 if (cursorScenePos == null || cursorScreenPos == null) {
2754                     return;
2755                 }
2756                 x = cursorScenePos.getX();
2757                 y = cursorScenePos.getY();
2758                 screenX = cursorScreenPos.getX();
2759                 screenY = cursorScreenPos.getY();
2760             }
2761 
2762             inMousePick = true;
2763             Scene.this.processGestureEvent(new SwipeEvent(
2764                     eventType, x, y, screenX, screenY,
2765                     _shiftDown, _controlDown, _altDown, _metaDown, _direct,
2766                     touchCount, pick(x, y)),
2767                     swipeGesture);
2768             inMousePick = false;
2769         }
2770 
2771         @Override
2772         public void touchEventBegin(
2773                 long time, int touchCount, boolean isDirect,
2774                 boolean _shiftDown, boolean _controlDown,
2775                 boolean _altDown, boolean _metaDown) {
2776 
2777             if (!isDirect) {
2778                 nextTouchEvent = null;
2779                 return;
2780             }
2781             nextTouchEvent = new TouchEvent(
2782                     TouchEvent.ANY, null, null, 0,
2783                     _shiftDown, _controlDown, _altDown, _metaDown);
2784             if (touchPoints == null || touchPoints.length != touchCount) {
2785                 touchPoints = new TouchPoint[touchCount];
2786             }
2787             touchPointIndex = 0;
2788         }
2789 
2790         @Override
2791         public void touchEventNext(
2792                 TouchPoint.State state, long touchId,
2793                 double x, double y, double screenX, double screenY) {
2794 
2795             inMousePick = true;
2796             if (nextTouchEvent == null) {
2797                 // ignore indirect touch events
2798                 return;
2799             }
2800             touchPointIndex++;
2801             int id = (state == TouchPoint.State.PRESSED
2802                     ? touchMap.add(touchId) :  touchMap.get(touchId));
2803             if (state == TouchPoint.State.RELEASED) {
2804                 touchMap.remove(touchId);
2805             }
2806             int order = touchMap.getOrder(id);
2807 
2808             if (order &gt;= touchPoints.length) {
2809                 throw new RuntimeException(&quot;Too many touch points reported&quot;);
2810             }
2811 
2812             // pick target
2813             boolean isGrabbed = false;
2814             PickResult pickRes = pick(x, y);
2815             EventTarget pickedTarget = touchTargets.get(id);
2816             if (pickedTarget == null) {
2817                 pickedTarget = pickRes.getIntersectedNode();
2818                 if (pickedTarget == null) {
2819                     pickedTarget = Scene.this;
2820                 }
2821             } else {
2822                 isGrabbed = true;
2823             }
2824 
2825             TouchPoint tp = new TouchPoint(id, state,
2826                     x, y, screenX, screenY, pickedTarget, pickRes);
2827 
2828             touchPoints[order] = tp;
2829 
2830             if (isGrabbed) {
2831                 tp.grab(pickedTarget);
2832             }
2833             if (tp.getState() == TouchPoint.State.PRESSED) {
2834                 tp.grab(pickedTarget);
2835                 touchTargets.put(tp.getId(), pickedTarget);
2836             } else if (tp.getState() == TouchPoint.State.RELEASED) {
2837                 touchTargets.remove(tp.getId());
2838             }
2839             inMousePick = false;
2840         }
2841 
2842         @Override
2843         public void touchEventEnd() {
2844             if (nextTouchEvent == null) {
2845                 // ignore indirect touch events
2846                 return;
2847             }
2848 
2849             if (touchPointIndex != touchPoints.length) {
2850                 throw new RuntimeException(&quot;Wrong number of touch points reported&quot;);
2851             }
2852 
2853             Scene.this.processTouchEvent(nextTouchEvent, touchPoints);
2854 
2855             if (touchMap.cleanup()) {
2856                 // gesture finished
2857                 touchEventSetId = 0;
2858             }
2859         }
2860 
2861         @Override
2862         public Accessible getSceneAccessible() {
2863             return getAccessible();
2864         }
2865     }
2866 
2867     private class ScenePeerPaintListener implements TKScenePaintListener {
2868         @Override
2869         public void frameRendered() {
2870             // must use tracker with synchronization since this method is called on render thread
2871             synchronized (trackerMonitor) {
2872                 if (Scene.this.tracker != null) {
2873                     Scene.this.tracker.frameRendered();
2874                 }
2875             }
2876         }
2877     }
2878 
2879     /*******************************************************************************
2880      *                                                                             *
2881      * Drag and Drop                                                               *
2882      *                                                                             *
2883      ******************************************************************************/
2884 
2885     class DropTargetListener implements TKDropTargetListener {
2886 
2887         /*
2888          * This function is called when an drag operation enters a valid drop target.
2889          * This may be from either an internal or external dnd operation.
2890          */
2891         @Override
2892         public TransferMode dragEnter(double x, double y, double screenX, double screenY,
2893                                       TransferMode transferMode, TKClipboard dragboard)
2894         {
2895             if (dndGesture == null) {
2896                 dndGesture = new DnDGesture();
2897             }
2898             Dragboard db = DragboardHelper.createDragboard(dragboard);
2899             dndGesture.dragboard = db;
2900             DragEvent dragEvent =
2901                     new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2902                             transferMode, null, null, pick(x, y));
2903             return dndGesture.processTargetEnterOver(dragEvent);
2904         }
2905 
2906         @Override
2907         public TransferMode dragOver(double x, double y, double screenX, double screenY,
2908                                      TransferMode transferMode)
2909         {
2910             if (Scene.this.dndGesture == null) {
2911                 System.err.println(&quot;GOT A dragOver when dndGesture is null!&quot;);
2912                 return null;
2913             } else {
2914                 if (dndGesture.dragboard == null) {
2915                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragOver&quot;);
2916                 }
2917                 DragEvent dragEvent =
2918                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2919                                 transferMode, null, null, pick(x, y));
2920                 return dndGesture.processTargetEnterOver(dragEvent);
2921             }
2922         }
2923 
2924         @Override
2925         public void dragExit(double x, double y, double screenX, double screenY) {
2926             if (dndGesture == null) {
2927                 System.err.println(&quot;GOT A dragExit when dndGesture is null!&quot;);
2928             } else {
2929                 if (dndGesture.dragboard == null) {
2930                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragExit&quot;);
2931                 }
2932                 DragEvent dragEvent =
2933                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2934                                 null, null, null, pick(x, y));
2935                 dndGesture.processTargetExit(dragEvent);
2936                 if (dndGesture.source == null) {
2937                     dndGesture.dragboard = null;
2938                     dndGesture = null;
2939                 }
2940             }
2941         }
2942 
2943 
2944         @Override
2945         public TransferMode drop(double x, double y, double screenX, double screenY,
2946                                   TransferMode transferMode)
2947         {
2948             if (dndGesture == null) {
2949                 System.err.println(&quot;GOT A drop when dndGesture is null!&quot;);
2950                 return null;
2951             } else {
2952                 if (dndGesture.dragboard == null) {
2953                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDrop&quot;);
2954                 }
2955                 DragEvent dragEvent =
2956                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
2957                                 transferMode, null, null, pick(x, y));
2958                 // Data dropped to the app can be accessed without restriction
2959                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
2960 
2961                 TransferMode tm;
2962                 try {
2963                     tm = dndGesture.processTargetDrop(dragEvent);
2964                 } finally {
2965                     DragboardHelper.setDataAccessRestriction(
2966                             dndGesture.dragboard, true);
2967                 }
2968 
2969                 if (dndGesture.source == null) {
2970                     dndGesture.dragboard = null;
2971                     dndGesture = null;
2972                 }
2973                 return tm;
2974             }
2975         }
2976     }
2977 
2978     class DragGestureListener implements TKDragGestureListener {
2979 
2980        @Override
2981        public void dragGestureRecognized(double x, double y, double screenX, double screenY,
2982                                          int button, TKClipboard dragboard)
2983        {
2984            Dragboard db = DragboardHelper.createDragboard(dragboard);
2985            dndGesture = new DnDGesture();
2986            dndGesture.dragboard = db;
2987            // TODO: support mouse buttons in DragEvent
2988            DragEvent dragEvent = new DragEvent(DragEvent.ANY, db, x, y, screenX, screenY,
2989                    null, null, null, pick(x, y));
2990            dndGesture.processRecognized(dragEvent);
2991            dndGesture = null;
2992         }
2993     }
2994 
2995     /**
2996      * A Drag and Drop gesture has a lifespan that lasts from mouse
2997      * PRESSED event to mouse RELEASED event.
2998      */
2999     class DnDGesture {
3000         private final double hysteresisSizeX =
3001                 Toolkit.getToolkit().getMultiClickMaxX();
3002         private final double hysteresisSizeY =
3003                 Toolkit.getToolkit().getMultiClickMaxY();
3004 
3005         private EventTarget source = null;
3006         private Set&lt;TransferMode&gt; sourceTransferModes = null;
3007         private TransferMode acceptedTransferMode = null;
3008         private Dragboard dragboard = null;
3009         private EventTarget potentialTarget = null;
3010         private EventTarget target = null;
3011         private DragDetectedState dragDetected = DragDetectedState.NOT_YET;
3012         private double pressedX;
3013         private double pressedY;
3014         private List&lt;EventTarget&gt; currentTargets = new ArrayList&lt;EventTarget&gt;();
3015         private List&lt;EventTarget&gt; newTargets = new ArrayList&lt;EventTarget&gt;();
3016         private EventTarget fullPDRSource = null;
3017 
3018         /**
3019          * Fires event on a given target or on scene if the node is null
3020          */
3021         private void fireEvent(EventTarget target, Event e) {
3022             if (target != null) {
3023                 Event.fireEvent(target, e);
3024             }
3025         }
3026 
3027         /**
3028          * Called when DRAG_DETECTED event is going to be processed by
3029          * application
3030          */
3031         private void processingDragDetected() {
3032             dragDetected = DragDetectedState.PROCESSING;
3033         }
3034 
3035         /**
3036          * Called after DRAG_DETECTED event has been processed by application
3037          */
3038         private void dragDetectedProcessed() {
3039             dragDetected = DragDetectedState.DONE;
3040             final boolean hasContent = (dragboard != null) &amp;&amp; (ClipboardHelper.contentPut(dragboard));
3041             if (hasContent) {
3042                 /* start DnD */
3043                 Toolkit.getToolkit().startDrag(Scene.this.peer,
3044                                                 sourceTransferModes,
3045                                                 new DragSourceListener(),
3046                                                 dragboard);
3047             } else if (fullPDRSource != null) {
3048                 /* start PDR */
3049                 Scene.this.mouseHandler.enterFullPDR(fullPDRSource);
3050             }
3051 
3052             fullPDRSource = null;
3053         }
3054 
3055         /**
3056          * Sets the default dragDetect value
3057          */
3058         private void processDragDetection(MouseEvent mouseEvent) {
3059 
3060             if (dragDetected != DragDetectedState.NOT_YET) {
3061                 mouseEvent.setDragDetect(false);
3062                 return;
3063             }
3064 
3065             if (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED) {
3066                 pressedX = mouseEvent.getSceneX();
3067                 pressedY = mouseEvent.getSceneY();
3068 
3069                 mouseEvent.setDragDetect(false);
3070 
3071             } else if (mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3072 
3073                 double deltaX = Math.abs(mouseEvent.getSceneX() - pressedX);
3074                 double deltaY = Math.abs(mouseEvent.getSceneY() - pressedY);
3075                 mouseEvent.setDragDetect(deltaX &gt; hysteresisSizeX ||
3076                                          deltaY &gt; hysteresisSizeY);
3077 
3078             }
3079         }
3080 
3081         /**
3082          * This function is useful for drag gesture recognition from
3083          * within this Scene (as opposed to in the TK implementation... by the platform)
3084          */
3085         private boolean process(MouseEvent mouseEvent, EventTarget target) {
3086             boolean continueProcessing = true;
3087             if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3088 
3089                 if (dragDetected != DragDetectedState.DONE &amp;&amp;
3090                         (mouseEvent.getEventType() == MouseEvent.MOUSE_PRESSED ||
3091                         mouseEvent.getEventType() == MouseEvent.MOUSE_DRAGGED) &amp;&amp;
3092                         mouseEvent.isDragDetect()) {
3093 
3094                     processingDragDetected();
3095 
3096                     if (target != null) {
3097                         final MouseEvent detectedEvent = mouseEvent.copyFor(
3098                                 mouseEvent.getSource(), target,
3099                                 MouseEvent.DRAG_DETECTED);
3100 
3101                         try {
3102                             fireEvent(target, detectedEvent);
3103                         } finally {
3104                             // Putting data to dragboard finished, restrict access to them
3105                             if (dragboard != null) {
3106                                 DragboardHelper.setDataAccessRestriction(
3107                                         dragboard, true);
3108                             }
3109                         }
3110                     }
3111 
3112                     dragDetectedProcessed();
3113                 }
3114 
3115                 if (mouseEvent.getEventType() == MouseEvent.MOUSE_RELEASED) {
3116                     continueProcessing = false;
3117                 }
3118             }
3119             return continueProcessing;
3120         }
3121 
3122         /*
3123          * Called when a drag source is recognized. This occurs at the very start of
3124          * the publicly visible drag and drop API, as it is responsible for calling
3125          * the Node.onDragSourceRecognized function.
3126          */
3127         private boolean processRecognized(DragEvent de) {
3128             MouseEvent me = new MouseEvent(
3129                     MouseEvent.DRAG_DETECTED, de.getX(), de.getY(),
3130                     de.getSceneX(), de.getScreenY(), MouseButton.PRIMARY, 1,
3131                     false, false, false, false, false, true, false, false, false,
3132                     false, de.getPickResult());
3133 
3134             processingDragDetected();
3135 
3136             final EventTarget target = de.getPickResult().getIntersectedNode();
3137             try {
3138                 fireEvent(target != null ? target : Scene.this, me);
3139             } finally {
3140                 // Putting data to dragboard finished, restrict access to them
3141                 if (dragboard != null) {
3142                     DragboardHelper.setDataAccessRestriction(
3143                             dragboard, true);
3144                 }
3145             }
3146 
3147             dragDetectedProcessed();
3148 
3149             final boolean hasContent = dragboard != null
3150                     &amp;&amp; !dragboard.getContentTypes().isEmpty();
3151             return hasContent;
3152         }
3153 
3154         private void processDropEnd(DragEvent de) {
3155             if (source == null) {
3156                 System.out.println(&quot;Scene.DnDGesture.processDropEnd() - UNEXPECTD - source is NULL&quot;);
3157                 return;
3158             }
3159 
3160             de = new DragEvent(de.getSource(), source, DragEvent.DRAG_DONE,
3161                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3162                     de.getScreenX(), de.getScreenY(),
3163                     de.getTransferMode(), source, target, de.getPickResult());
3164 
3165             Event.fireEvent(source, de);
3166 
3167             tmpTargetWrapper.clear();
3168             handleExitEnter(de, tmpTargetWrapper);
3169 
3170             // at this point the drag and drop operation is completely over, so we
3171             // can tell the toolkit that it can clean up if needs be.
3172             Toolkit.getToolkit().stopDrag(dragboard);
3173         }
3174 
3175         private TransferMode processTargetEnterOver(DragEvent de) {
3176             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3177             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3178 
3179             if (dragboard == null) {
3180                 dragboard = createDragboard(de, false);
3181             }
3182 
3183             de = new DragEvent(de.getSource(), pickedTarget, de.getEventType(),
3184                     dragboard, de.getSceneX(), de.getSceneY(),
3185                     de.getScreenX(), de.getScreenY(),
3186                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3187 
3188             handleExitEnter(de, tmpTargetWrapper);
3189 
3190             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_OVER,
3191                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3192                     de.getScreenX(), de.getScreenY(),
3193                     de.getTransferMode(), source, potentialTarget, de.getPickResult());
3194 
3195             fireEvent(pickedTarget, de);
3196 
3197             Object acceptingObject = de.getAcceptingObject();
3198             potentialTarget = acceptingObject instanceof EventTarget
3199                     ? (EventTarget) acceptingObject : null;
3200             acceptedTransferMode = de.getAcceptedTransferMode();
3201             return acceptedTransferMode;
3202         }
3203 
3204         private void processTargetActionChanged(DragEvent de) {
3205             // Do we want DRAG_TRANSFER_MODE_CHANGED event?
3206 //            final Node pickedNode = Scene.this.mouseHandler.pickNode(de.getX(), de.getY());
3207 //            if (pickedNode != null &amp;&amp; pickedNode.isTreeVisible()) {
3208 //                de = DragEvent.copy(de.getSource(), pickedNode, source,
3209 //                        pickedNode, de, DragEvent.DRAG_TRANSFER_MODE_CHANGED);
3210 //
3211 //                if (dragboard == null) {
3212 //                    dragboard = createDragboard(de);
3213 //                }
3214 //                dragboard = de.getPlatformDragboard();
3215 //
3216 //                fireEvent(pickedNode, de);
3217 //            }
3218         }
3219 
3220         private void processTargetExit(DragEvent de) {
3221             if (dragboard == null) {
3222                 // dragboard should have been created in processTargetEnterOver()
3223                 throw new NullPointerException(&quot;dragboard is null in processTargetExit()&quot;);
3224             }
3225 
3226             if (currentTargets.size() &gt; 0) {
3227                 potentialTarget = null;
3228                 tmpTargetWrapper.clear();
3229                 handleExitEnter(de, tmpTargetWrapper);
3230             }
3231         }
3232 
3233         private TransferMode processTargetDrop(DragEvent de) {
3234             pick(tmpTargetWrapper, de.getSceneX(), de.getSceneY());
3235             final EventTarget pickedTarget = tmpTargetWrapper.getEventTarget();
3236 
3237             de = new DragEvent(de.getSource(), pickedTarget, DragEvent.DRAG_DROPPED,
3238                     de.getDragboard(), de.getSceneX(), de.getSceneY(),
3239                     de.getScreenX(), de.getScreenY(),
3240                     acceptedTransferMode, source, potentialTarget, de.getPickResult());
3241 
3242             if (dragboard == null) {
3243                 // dragboard should have been created in processTargetEnterOver()
3244                 throw new NullPointerException(&quot;dragboard is null in processTargetDrop()&quot;);
3245             }
3246 
3247             handleExitEnter(de, tmpTargetWrapper);
3248 
3249             fireEvent(pickedTarget, de);
3250 
3251             Object acceptingObject = de.getAcceptingObject();
3252             potentialTarget = acceptingObject instanceof EventTarget
3253                     ? (EventTarget) acceptingObject : null;
3254             target = potentialTarget;
3255 
3256             TransferMode result = de.isDropCompleted() ?
3257                 de.getAcceptedTransferMode() : null;
3258 
3259             tmpTargetWrapper.clear();
3260             handleExitEnter(de, tmpTargetWrapper);
3261 
3262             return result;
3263         }
3264 
3265         private void handleExitEnter(DragEvent e, TargetWrapper target) {
3266             EventTarget currentTarget =
3267                     currentTargets.size() &gt; 0 ? currentTargets.get(0) : null;
3268 
3269             if (target.getEventTarget() != currentTarget) {
3270 
3271                 target.fillHierarchy(newTargets);
3272 
3273                 int i = currentTargets.size() - 1;
3274                 int j = newTargets.size() - 1;
3275 
3276                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentTargets.get(i) == newTargets.get(j)) {
3277                     i--;
3278                     j--;
3279                 }
3280 
3281                 for (; i &gt;= 0; i--) {
3282                     EventTarget t = currentTargets.get(i);
3283                     if (potentialTarget == t) {
3284                         potentialTarget = null;
3285                     }
3286                     e = e.copyFor(e.getSource(), t, source,
3287                             potentialTarget, DragEvent.DRAG_EXITED_TARGET);
3288                     Event.fireEvent(t, e);
3289                 }
3290 
3291                 potentialTarget = null;
3292                 for (; j &gt;= 0; j--) {
3293                     EventTarget t = newTargets.get(j);
3294                     e = e.copyFor(e.getSource(), t, source,
3295                             potentialTarget, DragEvent.DRAG_ENTERED_TARGET);
3296                     Object acceptingObject = e.getAcceptingObject();
3297                     if (acceptingObject instanceof EventTarget) {
3298                         potentialTarget = (EventTarget) acceptingObject;
3299                     }
3300                     Event.fireEvent(t, e);
3301                 }
3302 
3303                 currentTargets.clear();
3304                 currentTargets.addAll(newTargets);
3305                 newTargets.clear();
3306             }
3307         }
3308 
3309 //        function getIntendedTransferMode(e:MouseEvent):TransferMode {
3310 //            return if (e.altDown) TransferMode.COPY else TransferMode.MOVE;
3311 //        }
3312 
3313         /*
3314          * Function that hooks into the key processing code in Scene to handle the
3315          * situation where a drag and drop event is taking place and the user presses
3316          * the escape key to cancel the drag and drop operation.
3317          */
3318         private boolean processKey(KeyEvent e) {
3319             //note: this seems not to be called, the DnD cancelation is provided by platform
3320             if ((e.getEventType() == KeyEvent.KEY_PRESSED) &amp;&amp; (e.getCode() == KeyCode.ESCAPE)) {
3321 
3322                 // cancel drag and drop
3323                 DragEvent de = new DragEvent(
3324                         source, source, DragEvent.DRAG_DONE, dragboard, 0, 0, 0, 0,
3325                         null, source, null, null);
3326                 if (source != null) {
3327                     Event.fireEvent(source, de);
3328                 }
3329 
3330                 tmpTargetWrapper.clear();
3331                 handleExitEnter(de, tmpTargetWrapper);
3332 
3333                 return false;
3334             }
3335             return true;
3336         }
3337 
3338         /*
3339          * This starts the drag gesture running, creating the dragboard used for
3340          * the remainder of this drag and drop operation.
3341          */
3342         private Dragboard startDrag(EventTarget source, Set&lt;TransferMode&gt; t) {
3343             if (dragDetected != DragDetectedState.PROCESSING) {
3344                 throw new IllegalStateException(&quot;Cannot start drag and drop &quot;
3345                         + &quot;outside of DRAG_DETECTED event handler&quot;);
3346             }
3347 
3348             if (t.isEmpty()) {
3349                 dragboard = null;
3350             } else if (dragboard == null) {
3351                 dragboard = createDragboard(null, true);
3352             }
3353 
3354             // The app can see what it puts to dragboard without restriction
3355             DragboardHelper.setDataAccessRestriction(dragboard, false);
3356 
3357             this.source = source;
3358             potentialTarget = source;
3359             sourceTransferModes = t;
3360             return dragboard;
3361         }
3362 
3363         /*
3364          * This starts the full PDR gesture.
3365          */
3366         private void startFullPDR(EventTarget source) {
3367             fullPDRSource = source;
3368         }
3369 
3370         private Dragboard createDragboard(final DragEvent de, boolean isDragSource) {
3371             Dragboard dragboard = null;
3372             if (de != null) {
3373                 dragboard = de.getDragboard();
3374                 if (dragboard != null) {
3375                     return dragboard;
3376                 }
3377             }
3378             TKClipboard dragboardPeer = peer.createDragboard(isDragSource);
3379             return DragboardHelper.createDragboard(dragboardPeer);
3380         }
3381     }
3382 
3383     /**
3384      * State of a drag gesture with regards to DRAG_DETECTED event.
3385      */
3386     private enum DragDetectedState {
3387         NOT_YET,
3388         PROCESSING,
3389         DONE
3390     }
3391 
3392     class DragSourceListener implements TKDragSourceListener {
3393 
3394         @Override
3395         public void dragDropEnd(double x, double y, double screenX, double screenY,
3396                                 TransferMode transferMode)
3397         {
3398             if (dndGesture != null) {
3399                 if (dndGesture.dragboard == null) {
3400                     throw new RuntimeException(&quot;dndGesture.dragboard is null in dragDropEnd&quot;);
3401                 }
3402                 DragEvent dragEvent =
3403                         new DragEvent(DragEvent.ANY, dndGesture.dragboard, x, y, screenX, screenY,
3404                         transferMode, null, null, null);
3405 
3406                 // DRAG_DONE event is delivered to gesture source, it can access
3407                 // its own data without restriction
3408                 DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, false);
3409                 try {
3410                     dndGesture.processDropEnd(dragEvent);
3411                 } finally {
3412                     DragboardHelper.setDataAccessRestriction(dndGesture.dragboard, true);
3413                 }
3414                 dndGesture = null;
3415             }
3416         }
3417     }
3418 
3419     /*******************************************************************************
3420      *                                                                             *
3421      * Mouse Event Handling                                                        *
3422      *                                                                             *
3423      ******************************************************************************/
3424 
3425     static class ClickCounter {
3426         Toolkit toolkit = Toolkit.getToolkit();
3427         private int count;
3428         private boolean out;
3429         private boolean still;
3430         private Timeline timeout;
3431         private double pressedX, pressedY;
3432 
3433         private void inc() { count++; }
3434         private int get() { return count; }
3435         private boolean isStill() { return still; }
3436 
3437         private void clear() {
3438             count = 0;
3439             stopTimeout();
3440         }
3441 
3442         private void out() {
3443             out = true;
3444             stopTimeout();
3445         }
3446 
3447         private void applyOut() {
3448             if (out) clear();
3449             out = false;
3450         }
3451 
3452         private void moved(double x, double y) {
3453             if (Math.abs(x - pressedX) &gt; toolkit.getMultiClickMaxX() ||
3454                     Math.abs(y - pressedY) &gt; toolkit.getMultiClickMaxY()) {
3455                 out();
3456                 still = false;
3457             }
3458         }
3459 
3460         private void start(double x, double y) {
3461             pressedX = x;
3462             pressedY = y;
3463             out = false;
3464 
3465             if (timeout != null) {
3466                 timeout.stop();
3467             }
3468             timeout = new Timeline();
3469             timeout.getKeyFrames().add(
3470                     new KeyFrame(new Duration(toolkit.getMultiClickTime()),
3471                             event -&gt; {
3472                                 out = true;
3473                                 timeout = null;
3474                             }
3475                     ));
3476             timeout.play();
3477             still = true;
3478         }
3479 
3480         private void stopTimeout() {
3481             if (timeout != null) {
3482                 timeout.stop();
3483                 timeout = null;
3484             }
3485         }
3486     }
3487 
3488     static class ClickGenerator {
3489         private ClickCounter lastPress = null;
3490 
3491         private Map&lt;MouseButton, ClickCounter&gt; counters =
3492                 new EnumMap&lt;MouseButton, ClickCounter&gt;(MouseButton.class);
3493         private List&lt;EventTarget&gt; pressedTargets = new ArrayList&lt;EventTarget&gt;();
3494         private List&lt;EventTarget&gt; releasedTargets = new ArrayList&lt;EventTarget&gt;();
3495 
3496         public ClickGenerator() {
3497             for (MouseButton mb : MouseButton.values()) {
3498                 if (mb != MouseButton.NONE) {
3499                     counters.put(mb, new ClickCounter());
3500                 }
3501             }
3502         }
3503 
3504         private MouseEvent preProcess(MouseEvent e) {
3505             for (ClickCounter cc : counters.values()) {
3506                 cc.moved(e.getSceneX(), e.getSceneY());
3507             }
3508 
3509             ClickCounter cc = counters.get(e.getButton());
3510             boolean still = lastPress != null ? lastPress.isStill() : false;
3511 
3512             if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3513 
3514                 if (! e.isPrimaryButtonDown()) { counters.get(MouseButton.PRIMARY).clear(); }
3515                 if (! e.isSecondaryButtonDown()) { counters.get(MouseButton.SECONDARY).clear(); }
3516                 if (! e.isMiddleButtonDown()) { counters.get(MouseButton.MIDDLE).clear(); }
3517                 if (! e.isBackButtonDown()) { counters.get(MouseButton.BACK).clear(); }
3518                 if (! e.isForwardButtonDown()) { counters.get(MouseButton.FORWARD).clear(); }
3519                 cc.applyOut();
3520                 cc.inc();
3521                 cc.start(e.getSceneX(), e.getSceneY());
3522                 lastPress = cc;
3523             }
3524 
3525             return new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3526                     e.getScreenX(), e.getScreenY(), e.getButton(),
3527                     cc != null &amp;&amp; e.getEventType() != MouseEvent.MOUSE_MOVED ? cc.get() : 0,
3528                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3529                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3530                     e.isBackButtonDown(), e.isForwardButtonDown(),
3531                     e.isSynthesized(), e.isPopupTrigger(), still, e.getPickResult());
3532         }
3533 
3534         private void postProcess(MouseEvent e, TargetWrapper target, TargetWrapper pickedTarget) {
3535 
3536             if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3537                 ClickCounter cc = counters.get(e.getButton());
3538 
3539                 target.fillHierarchy(pressedTargets);
3540                 pickedTarget.fillHierarchy(releasedTargets);
3541                 int i = pressedTargets.size() - 1;
3542                 int j = releasedTargets.size() - 1;
3543 
3544                 EventTarget clickedTarget = null;
3545                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; pressedTargets.get(i) == releasedTargets.get(j)) {
3546                     clickedTarget = pressedTargets.get(i);
3547                     i--;
3548                     j--;
3549                 }
3550 
3551                 pressedTargets.clear();
3552                 releasedTargets.clear();
3553 
3554                 if (clickedTarget != null &amp;&amp; lastPress != null) {
3555                     MouseEvent click = new MouseEvent(null, clickedTarget,
3556                             MouseEvent.MOUSE_CLICKED, e.getSceneX(), e.getSceneY(),
3557                             e.getScreenX(), e.getScreenY(), e.getButton(),
3558                             cc.get(),
3559                             e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3560                             e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3561                             e.isBackButtonDown(), e.isForwardButtonDown(),
3562                             e.isSynthesized(), e.isPopupTrigger(), lastPress.isStill(), e.getPickResult());
3563                     Event.fireEvent(clickedTarget, click);
3564                 }
3565             }
3566         }
3567     }
3568 
3569     /**
3570      * Generates mouse exited event for a node which is going to be removed
3571      * and its children, where appropriate.
3572      * @param removing Node which is going to be removed
3573      */
3574     void generateMouseExited(Node removing) {
3575         mouseHandler.handleNodeRemoval(removing);
3576     }
3577 
3578     class MouseHandler {
3579         private TargetWrapper pdrEventTarget = new TargetWrapper(); // pdr - press-drag-release
3580         private boolean pdrInProgress = false;
3581         private boolean fullPDREntered = false;
3582 
3583         private EventTarget currentEventTarget = null;
3584         private MouseEvent lastEvent;
3585         private boolean hover = false;
3586 
3587         private boolean primaryButtonDown = false;
3588         private boolean secondaryButtonDown = false;
3589         private boolean middleButtonDown = false;
3590         private boolean backButtonDown = false;
3591         private boolean forwardButtonDown = false;
3592 
3593         private EventTarget fullPDRSource = null;
3594         private TargetWrapper fullPDRTmpTargetWrapper = new TargetWrapper();
3595 
3596         /* lists needed for enter/exit events generation */
3597         private final List&lt;EventTarget&gt; pdrEventTargets = new ArrayList&lt;EventTarget&gt;();
3598         private final List&lt;EventTarget&gt; currentEventTargets = new ArrayList&lt;EventTarget&gt;();
3599         private final List&lt;EventTarget&gt; newEventTargets = new ArrayList&lt;EventTarget&gt;();
3600 
3601         private final List&lt;EventTarget&gt; fullPDRCurrentEventTargets = new ArrayList&lt;EventTarget&gt;();
3602         private final List&lt;EventTarget&gt; fullPDRNewEventTargets = new ArrayList&lt;EventTarget&gt;();
3603         private EventTarget fullPDRCurrentTarget = null;
3604 
3605         private Cursor currCursor;
3606         private CursorFrame currCursorFrame;
3607         private EventQueue queue = new EventQueue();
3608 
3609         private Runnable pickProcess = new Runnable() {
3610 
3611             @Override
3612             public void run() {
3613                 // Make sure this is run only if the peer is still alive
3614                 // and there is an event to deliver
3615                 if (Scene.this.peer != null &amp;&amp; lastEvent != null) {
3616                     process(lastEvent, true);
3617                 }
3618             }
3619         };
3620 
3621         private void pulse() {
3622             if (hover &amp;&amp; lastEvent != null) {
3623                 //Shouldn&#39;t run user code directly. User can call stage.showAndWait() and block the pulse.
3624                 Platform.runLater(pickProcess);
3625             }
3626         }
3627 
3628         private void clearPDREventTargets() {
3629             pdrInProgress = false;
3630             currentEventTarget = currentEventTargets.size() &gt; 0
3631                     ? currentEventTargets.get(0) : null;
3632             pdrEventTarget.clear();
3633         }
3634 
3635         public void enterFullPDR(EventTarget gestureSource) {
3636             fullPDREntered = true;
3637             fullPDRSource = gestureSource;
3638             fullPDRCurrentTarget = null;
3639             fullPDRCurrentEventTargets.clear();
3640         }
3641 
3642         public void exitFullPDR(MouseEvent e) {
3643             if (!fullPDREntered) {
3644                 return;
3645             }
3646             fullPDREntered = false;
3647             for (int i = fullPDRCurrentEventTargets.size() - 1; i &gt;= 0; i--) {
3648                 EventTarget entered = fullPDRCurrentEventTargets.get(i);
3649                 Event.fireEvent(entered, MouseEvent.copyForMouseDragEvent(e,
3650                         entered, entered,
3651                         MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3652                         fullPDRSource, e.getPickResult()));
3653             }
3654             fullPDRSource = null;
3655             fullPDRCurrentEventTargets.clear();
3656             fullPDRCurrentTarget = null;
3657         }
3658 
3659         private void handleNodeRemoval(Node removing) {
3660             if (lastEvent == null) {
3661                 // this can happen only if everything has been exited anyway
3662                 return;
3663             }
3664 
3665 
3666             if (currentEventTargets.contains(removing)) {
3667                 int i = 0;
3668                 EventTarget trg = null;
3669                 while(trg != removing) {
3670                     trg = currentEventTargets.get(i++);
3671 
3672                     queue.postEvent(lastEvent.copyFor(trg, trg,
3673                             MouseEvent.MOUSE_EXITED_TARGET));
3674                 }
3675                 currentEventTargets.subList(0, i).clear();
3676             }
3677 
3678             if (fullPDREntered &amp;&amp; fullPDRCurrentEventTargets.contains(removing)) {
3679                 int i = 0;
3680                 EventTarget trg = null;
3681                 while (trg != removing) {
3682                     trg = fullPDRCurrentEventTargets.get(i++);
3683 
3684                     queue.postEvent(
3685                             MouseEvent.copyForMouseDragEvent(lastEvent, trg, trg,
3686                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3687                             fullPDRSource, lastEvent.getPickResult()));
3688                 }
3689 
3690                 fullPDRCurrentEventTargets.subList(0, i).clear();
3691             }
3692 
3693             queue.fire();
3694 
3695             if (pdrInProgress &amp;&amp; pdrEventTargets.contains(removing)) {
3696                 int i = 0;
3697                 EventTarget trg = null;
3698                 while (trg != removing) {
3699                     trg = pdrEventTargets.get(i++);
3700 
3701                     // trg.setHover(false) - already taken care of
3702                     // by the code above which sent a mouse exited event
3703                     ((Node) trg).setPressed(false);
3704                 }
3705                 pdrEventTargets.subList(0, i).clear();
3706 
3707                 trg = pdrEventTargets.get(0);
3708                 final PickResult res = pdrEventTarget.getResult();
3709                 if (trg instanceof Node) {
3710                     pdrEventTarget.setNodeResult(new PickResult((Node) trg,
3711                             res.getIntersectedPoint(), res.getIntersectedDistance()));
3712                 } else {
3713                     pdrEventTarget.setSceneResult(new PickResult(null,
3714                             res.getIntersectedPoint(), res.getIntersectedDistance()),
3715                             (Scene) trg);
3716                 }
3717             }
3718         }
3719 
3720         private void handleEnterExit(MouseEvent e, TargetWrapper pickedTarget) {
3721             if (pickedTarget.getEventTarget() != currentEventTarget ||
3722                     e.getEventType() == MouseEvent.MOUSE_EXITED) {
3723 
3724                 if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3725                     newEventTargets.clear();
3726                 } else {
3727                     pickedTarget.fillHierarchy(newEventTargets);
3728                 }
3729 
3730                 int newTargetsSize = newEventTargets.size();
3731                 int i = currentEventTargets.size() - 1;
3732                 int j = newTargetsSize - 1;
3733                 int k = pdrEventTargets.size() - 1;
3734 
3735                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; currentEventTargets.get(i) == newEventTargets.get(j)) {
3736                     i--;
3737                     j--;
3738                     k--;
3739                 }
3740 
3741                 final int memk = k;
3742                 for (; i &gt;= 0; i--, k--) {
3743                     final EventTarget exitedEventTarget = currentEventTargets.get(i);
3744                     if (pdrInProgress &amp;&amp;
3745                             (k &lt; 0 || exitedEventTarget != pdrEventTargets.get(k))) {
3746                          break;
3747                     }
3748                     queue.postEvent(e.copyFor(
3749                             exitedEventTarget, exitedEventTarget,
3750                             MouseEvent.MOUSE_EXITED_TARGET));
3751                 }
3752 
3753                 k = memk;
3754                 for (; j &gt;= 0; j--, k--) {
3755                     final EventTarget enteredEventTarget = newEventTargets.get(j);
3756                     if (pdrInProgress &amp;&amp;
3757                             (k &lt; 0 || enteredEventTarget != pdrEventTargets.get(k))) {
3758                         break;
3759                     }
3760                     queue.postEvent(e.copyFor(
3761                             enteredEventTarget, enteredEventTarget,
3762                             MouseEvent.MOUSE_ENTERED_TARGET));
3763                 }
3764 
3765                 currentEventTarget = pickedTarget.getEventTarget();
3766                 currentEventTargets.clear();
3767                 for (j++; j &lt; newTargetsSize; j++) {
3768                     currentEventTargets.add(newEventTargets.get(j));
3769                 }
3770             }
3771             queue.fire();
3772         }
3773 
3774         private void process(MouseEvent e, boolean onPulse) {
3775             Toolkit.getToolkit().checkFxUserThread();
3776             Scene.inMousePick = true;
3777 
3778             cursorScreenPos = new Point2D(e.getScreenX(), e.getScreenY());
3779             cursorScenePos = new Point2D(e.getSceneX(), e.getSceneY());
3780 
3781             boolean gestureStarted = false;
3782             if (!onPulse) {
3783                 if (e.getEventType() == MouseEvent.MOUSE_PRESSED) {
3784                     if (!(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3785                             backButtonDown || forwardButtonDown)) {
3786                         //old gesture ended and new one started
3787                         gestureStarted = true;
3788                         if (!PLATFORM_DRAG_GESTURE_INITIATION) {
3789                             Scene.this.dndGesture = new DnDGesture();
3790                         }
3791                         clearPDREventTargets();
3792                     }
3793                 } else if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
3794                     // gesture ended
3795                     clearPDREventTargets();
3796                 } else if (e.getEventType() == MouseEvent.MOUSE_ENTERED) {
3797                     hover = true;
3798                 } else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3799                     hover = false;
3800                 }
3801 
3802                 primaryButtonDown = e.isPrimaryButtonDown();
3803                 secondaryButtonDown = e.isSecondaryButtonDown();
3804                 middleButtonDown = e.isMiddleButtonDown();
3805                 backButtonDown = e.isBackButtonDown();
3806                 forwardButtonDown = e.isForwardButtonDown();
3807             }
3808 
3809             pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3810             PickResult res = tmpTargetWrapper.getResult();
3811             if (res != null) {
3812                 e = new MouseEvent(e.getEventType(), e.getSceneX(), e.getSceneY(),
3813                     e.getScreenX(), e.getScreenY(), e.getButton(), e.getClickCount(),
3814                     e.isShiftDown(), e.isControlDown(), e.isAltDown(), e.isMetaDown(),
3815                     e.isPrimaryButtonDown(), e.isMiddleButtonDown(), e.isSecondaryButtonDown(),
3816                     e.isBackButtonDown(), e.isForwardButtonDown(),
3817                     e.isSynthesized(), e.isPopupTrigger(), e.isStillSincePress(), res);
3818             }
3819 
3820             if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
3821                 tmpTargetWrapper.clear();
3822             }
3823 
3824             TargetWrapper target;
3825             if (pdrInProgress) {
3826                 target = pdrEventTarget;
3827             } else {
3828                 target = tmpTargetWrapper;
3829             }
3830 
3831             if (gestureStarted) {
3832                 pdrEventTarget.copy(target);
3833                 pdrEventTarget.fillHierarchy(pdrEventTargets);
3834             }
3835 
3836             if (!onPulse) {
3837                 e = clickGenerator.preProcess(e);
3838             }
3839 
3840             // enter/exit handling
3841             handleEnterExit(e, tmpTargetWrapper);
3842 
3843             //deliver event to the target node
3844             if (Scene.this.dndGesture != null) {
3845                 Scene.this.dndGesture.processDragDetection(e);
3846             }
3847 
3848             if (fullPDREntered &amp;&amp; e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3849                 processFullPDR(e, onPulse);
3850             }
3851 
3852             if (target.getEventTarget() != null) {
3853                 if (e.getEventType() != MouseEvent.MOUSE_ENTERED
3854                         &amp;&amp; e.getEventType() != MouseEvent.MOUSE_EXITED
3855                         &amp;&amp; !onPulse) {
3856                     Event.fireEvent(target.getEventTarget(), e);
3857                 }
3858             }
3859 
3860             if (fullPDREntered &amp;&amp; e.getEventType() != MouseEvent.MOUSE_RELEASED) {
3861                 processFullPDR(e, onPulse);
3862             }
3863 
3864             if (!onPulse) {
3865                 clickGenerator.postProcess(e, target, tmpTargetWrapper);
3866             }
3867 
3868             // handle drag and drop
3869 
3870             if (!PLATFORM_DRAG_GESTURE_INITIATION &amp;&amp; !onPulse) {
3871                 if (Scene.this.dndGesture != null) {
3872                     if (!Scene.this.dndGesture.process(e, target.getEventTarget())) {
3873                         dndGesture = null;
3874                     }
3875                 }
3876             }
3877 
3878             Cursor cursor = target.getCursor();
3879             if (e.getEventType() != MouseEvent.MOUSE_EXITED) {
3880                 if (cursor == null &amp;&amp; hover) {
3881                     cursor = Scene.this.getCursor();
3882                 }
3883 
3884                 updateCursor(cursor);
3885                 updateCursorFrame();
3886             }
3887 
3888             if (gestureStarted) {
3889                 pdrInProgress = true;
3890             }
3891 
3892             if (pdrInProgress &amp;&amp;
3893                     !(primaryButtonDown || secondaryButtonDown || middleButtonDown ||
3894                             backButtonDown || forwardButtonDown)) {
3895                 clearPDREventTargets();
3896                 exitFullPDR(e);
3897                 // we need to do new picking in case the originally picked node
3898                 // was moved or removed by the event handlers
3899                 pick(tmpTargetWrapper, e.getSceneX(), e.getSceneY());
3900                 handleEnterExit(e, tmpTargetWrapper);
3901             }
3902 
3903             lastEvent = e.getEventType() == MouseEvent.MOUSE_EXITED ? null : e;
3904             Scene.inMousePick = false;
3905         }
3906 
3907         private void processFullPDR(MouseEvent e, boolean onPulse) {
3908 
3909             pick(fullPDRTmpTargetWrapper, e.getSceneX(), e.getSceneY());
3910             final PickResult result = fullPDRTmpTargetWrapper.getResult();
3911 
3912             final EventTarget eventTarget = fullPDRTmpTargetWrapper.getEventTarget();
3913 
3914             // enter/exit handling
3915             if (eventTarget != fullPDRCurrentTarget) {
3916 
3917                 fullPDRTmpTargetWrapper.fillHierarchy(fullPDRNewEventTargets);
3918 
3919                 int newTargetsSize = fullPDRNewEventTargets.size();
3920                 int i = fullPDRCurrentEventTargets.size() - 1;
3921                 int j = newTargetsSize - 1;
3922 
3923                 while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp;
3924                         fullPDRCurrentEventTargets.get(i) == fullPDRNewEventTargets.get(j)) {
3925                     i--;
3926                     j--;
3927                 }
3928 
3929                 for (; i &gt;= 0; i--) {
3930                     final EventTarget exitedEventTarget = fullPDRCurrentEventTargets.get(i);
3931                     Event.fireEvent(exitedEventTarget, MouseEvent.copyForMouseDragEvent(e,
3932                             exitedEventTarget, exitedEventTarget,
3933                             MouseDragEvent.MOUSE_DRAG_EXITED_TARGET,
3934                             fullPDRSource, result));
3935                 }
3936 
3937                 for (; j &gt;= 0; j--) {
3938                     final EventTarget enteredEventTarget = fullPDRNewEventTargets.get(j);
3939                     Event.fireEvent(enteredEventTarget, MouseEvent.copyForMouseDragEvent(e,
3940                             enteredEventTarget, enteredEventTarget,
3941                             MouseDragEvent.MOUSE_DRAG_ENTERED_TARGET,
3942                             fullPDRSource, result));
3943                 }
3944 
3945                 fullPDRCurrentTarget = eventTarget;
3946                 fullPDRCurrentEventTargets.clear();
3947                 fullPDRCurrentEventTargets.addAll(fullPDRNewEventTargets);
3948                 fullPDRNewEventTargets.clear();
3949             }
3950             // done enter/exit handling
3951 
3952             // event delivery
3953             if (eventTarget != null &amp;&amp; !onPulse) {
3954                 if (e.getEventType() == MouseEvent.MOUSE_DRAGGED) {
3955                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3956                             eventTarget, eventTarget,
3957                             MouseDragEvent.MOUSE_DRAG_OVER,
3958                             fullPDRSource, result));
3959                 }
3960                 if (e.getEventType() == MouseEvent.MOUSE_RELEASED) {
3961                     Event.fireEvent(eventTarget, MouseEvent.copyForMouseDragEvent(e,
3962                             eventTarget, eventTarget,
3963                             MouseDragEvent.MOUSE_DRAG_RELEASED,
3964                             fullPDRSource, result));
3965                 }
3966             }
3967         }
3968 
3969         private void updateCursor(Cursor newCursor) {
3970             if (currCursor != newCursor) {
3971                 if (currCursor != null) {
3972                     currCursor.deactivate();
3973                 }
3974 
3975                 if (newCursor != null) {
3976                     newCursor.activate();
3977                 }
3978 
3979                 currCursor = newCursor;
3980             }
3981         }
3982 
3983         public void updateCursorFrame() {
3984             final CursorFrame newCursorFrame =
3985                     (currCursor != null)
3986                            ? currCursor.getCurrentFrame()
3987                            : Cursor.DEFAULT.getCurrentFrame();
3988             if (currCursorFrame != newCursorFrame) {
3989                 if (Scene.this.peer != null) {
3990                     Scene.this.peer.setCursor(newCursorFrame);
3991                 }
3992 
3993                 currCursorFrame = newCursorFrame;
3994             }
3995         }
3996 
3997         private PickResult pickNode(PickRay pickRay) {
3998             PickResultChooser r = new PickResultChooser();
3999             Scene.this.getRoot().pickNode(pickRay, r);
4000             return r.toPickResult();
4001         }
4002     }
4003 
4004     /*******************************************************************************
4005      *                                                                             *
4006      * Key Event Handling                                                          *
4007      *                                                                             *
4008      ******************************************************************************/
4009 
4010     class KeyHandler {
4011         private void setFocusOwner(final Node value) {
4012             // Cancel IM composition if there is one in progress.
4013             // This needs to be done before the focus owner is switched as it
4014             // generates event that needs to be delivered to the old focus owner.
4015             if (oldFocusOwner != null) {
4016                 final Scene s = oldFocusOwner.getScene();
4017                 if (s != null) {
4018                     final TKScene peer = s.getPeer();
4019                     if (peer != null) {
4020                         peer.finishInputMethodComposition();
4021                     }
4022                 }
4023             }
4024             focusOwner.set(value);
4025         }
4026 
4027         private boolean windowFocused;
4028         protected boolean isWindowFocused() { return windowFocused; }
4029         protected void setWindowFocused(boolean value) {
4030             windowFocused = value;
4031             if (getFocusOwner() != null) {
4032                 getFocusOwner().setFocused(windowFocused);
4033             }
4034             if (windowFocused) {
4035                 if (accessible != null) {
4036                     accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);
4037                 }
4038             }
4039         }
4040 
4041         private void windowForSceneChanged(Window oldWindow, Window window) {
4042             if (oldWindow != null) {
4043                 oldWindow.focusedProperty().removeListener(sceneWindowFocusedListener);
4044             }
4045 
4046             if (window != null) {
4047                 window.focusedProperty().addListener(sceneWindowFocusedListener);
4048                 setWindowFocused(window.isFocused());
4049             } else {
4050                 setWindowFocused(false);
4051             }
4052         }
4053 
4054         private final InvalidationListener sceneWindowFocusedListener = valueModel -&gt; setWindowFocused(((ReadOnlyBooleanProperty)valueModel).get());
4055 
4056         private void process(KeyEvent e) {
4057             final Node sceneFocusOwner = getFocusOwner();
4058             final EventTarget eventTarget =
4059                     (sceneFocusOwner != null &amp;&amp; sceneFocusOwner.getScene() == Scene.this) ? sceneFocusOwner
4060                                               : Scene.this;
4061 
4062             // send the key event to the current focus owner or to scene if
4063             // the focus owner is not set
4064             Event.fireEvent(eventTarget, e);
4065         }
4066 
4067         private void requestFocus(Node node) {
4068             if (getFocusOwner() == node || (node != null &amp;&amp; !node.isCanReceiveFocus())) {
4069                 return;
4070             }
4071             setFocusOwner(node);
4072         }
4073     }
4074     /***************************************************************************
4075      *                                                                         *
4076      *                         Event Dispatch                                  *
4077      *                                                                         *
4078      **************************************************************************/
4079     // PENDING_DOC_REVIEW
4080     /**
4081      * Specifies the event dispatcher for this scene. When replacing the value
4082      * with a new {@code EventDispatcher}, the new dispatcher should forward
4083      * events to the replaced dispatcher to keep the scene&#39;s default event
4084      * handling behavior.
4085      */
4086     private ObjectProperty&lt;EventDispatcher&gt; eventDispatcher;
4087 
4088     public final void setEventDispatcher(EventDispatcher value) {
4089         eventDispatcherProperty().set(value);
4090     }
4091 
4092     public final EventDispatcher getEventDispatcher() {
4093         return eventDispatcherProperty().get();
4094     }
4095 
4096     public final ObjectProperty&lt;EventDispatcher&gt;
4097             eventDispatcherProperty() {
4098         initializeInternalEventDispatcher();
4099         return eventDispatcher;
4100     }
4101 
4102     private SceneEventDispatcher internalEventDispatcher;
4103 
4104     // Delegates requests from platform input method to the focused
4105     // node&#39;s one, if any.
4106     class InputMethodRequestsDelegate implements ExtendedInputMethodRequests {
4107         @Override
4108         public Point2D getTextLocation(int offset) {
4109             InputMethodRequests requests = getClientRequests();
4110             if (requests != null) {
4111                 return requests.getTextLocation(offset);
4112             } else {
4113                 return new Point2D(0, 0);
4114             }
4115         }
4116 
4117         @Override
4118         public int getLocationOffset(int x, int y) {
4119             InputMethodRequests requests = getClientRequests();
4120             if (requests != null) {
4121                 return requests.getLocationOffset(x, y);
4122             } else {
4123                 return 0;
4124             }
4125         }
4126 
4127         @Override
4128         public void cancelLatestCommittedText() {
4129             InputMethodRequests requests = getClientRequests();
4130             if (requests != null) {
4131                 requests.cancelLatestCommittedText();
4132             }
4133         }
4134 
4135         @Override
4136         public String getSelectedText() {
4137             InputMethodRequests requests = getClientRequests();
4138             if (requests != null) {
4139                 return requests.getSelectedText();
4140             }
4141             return null;
4142         }
4143 
4144         @Override
4145         public int getInsertPositionOffset() {
4146             InputMethodRequests requests = getClientRequests();
4147             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4148                 return ((ExtendedInputMethodRequests)requests).getInsertPositionOffset();
4149             }
4150             return 0;
4151         }
4152 
4153         @Override
4154         public String getCommittedText(int begin, int end) {
4155             InputMethodRequests requests = getClientRequests();
4156             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4157                 return ((ExtendedInputMethodRequests)requests).getCommittedText(begin, end);
4158             }
4159             return null;
4160         }
4161 
4162         @Override
4163         public int getCommittedTextLength() {
4164             InputMethodRequests requests = getClientRequests();
4165             if (requests != null &amp;&amp; requests instanceof ExtendedInputMethodRequests) {
4166                 return ((ExtendedInputMethodRequests)requests).getCommittedTextLength();
4167             }
4168             return 0;
4169         }
4170 
4171         private InputMethodRequests getClientRequests() {
4172             Node focusOwner = getFocusOwner();
4173             if (focusOwner != null) {
4174                 return focusOwner.getInputMethodRequests();
4175             }
4176             return null;
4177         }
4178     }
4179 
4180     // PENDING_DOC_REVIEW
4181     /**
4182      * Registers an event handler to this scene. The handler is called when the
4183      * scene receives an {@code Event} of the specified type during the bubbling
4184      * phase of event delivery.
4185      *
4186      * @param &lt;T&gt; the specific event class of the handler
4187      * @param eventType the type of the events to receive by the handler
4188      * @param eventHandler the handler to register
4189      * @throws NullPointerException if the event type or handler is null
4190      */
4191     public final &lt;T extends Event&gt; void addEventHandler(
4192             final EventType&lt;T&gt; eventType,
4193             final EventHandler&lt;? super T&gt; eventHandler) {
4194         getInternalEventDispatcher().getEventHandlerManager()
4195                                     .addEventHandler(eventType, eventHandler);
4196     }
4197 
4198     // PENDING_DOC_REVIEW
4199     /**
4200      * Unregisters a previously registered event handler from this scene. One
4201      * handler might have been registered for different event types, so the
4202      * caller needs to specify the particular event type from which to
4203      * unregister the handler.
4204      *
4205      * @param &lt;T&gt; the specific event class of the handler
4206      * @param eventType the event type from which to unregister
4207      * @param eventHandler the handler to unregister
4208      * @throws NullPointerException if the event type or handler is null
4209      */
4210     public final &lt;T extends Event&gt; void removeEventHandler(
4211             final EventType&lt;T&gt; eventType,
4212             final EventHandler&lt;? super T&gt; eventHandler) {
4213         getInternalEventDispatcher().getEventHandlerManager()
4214                                     .removeEventHandler(eventType,
4215                                                         eventHandler);
4216     }
4217 
4218     // PENDING_DOC_REVIEW
4219     /**
4220      * Registers an event filter to this scene. The filter is called when the
4221      * scene receives an {@code Event} of the specified type during the
4222      * capturing phase of event delivery.
4223      *
4224      * @param &lt;T&gt; the specific event class of the filter
4225      * @param eventType the type of the events to receive by the filter
4226      * @param eventFilter the filter to register
4227      * @throws NullPointerException if the event type or filter is null
4228      */
4229     public final &lt;T extends Event&gt; void addEventFilter(
4230             final EventType&lt;T&gt; eventType,
4231             final EventHandler&lt;? super T&gt; eventFilter) {
4232         getInternalEventDispatcher().getEventHandlerManager()
4233                                     .addEventFilter(eventType, eventFilter);
4234     }
4235 
4236     // PENDING_DOC_REVIEW
4237     /**
4238      * Unregisters a previously registered event filter from this scene. One
4239      * filter might have been registered for different event types, so the
4240      * caller needs to specify the particular event type from which to
4241      * unregister the filter.
4242      *
4243      * @param &lt;T&gt; the specific event class of the filter
4244      * @param eventType the event type from which to unregister
4245      * @param eventFilter the filter to unregister
4246      * @throws NullPointerException if the event type or filter is null
4247      */
4248     public final &lt;T extends Event&gt; void removeEventFilter(
4249             final EventType&lt;T&gt; eventType,
4250             final EventHandler&lt;? super T&gt; eventFilter) {
4251         getInternalEventDispatcher().getEventHandlerManager()
4252                                     .removeEventFilter(eventType, eventFilter);
4253     }
4254 
4255     /**
4256      * Sets the handler to use for this event type. There can only be one such
4257      * handler specified at a time. This handler is guaranteed to be called
4258      * first. This is used for registering the user-defined onFoo event
4259      * handlers.
4260      *
4261      * @param &lt;T&gt; the specific event class of the handler
4262      * @param eventType the event type to associate with the given eventHandler
4263      * @param eventHandler the handler to register, or null to unregister
4264      * @throws NullPointerException if the event type is null
4265      */
4266     protected final &lt;T extends Event&gt; void setEventHandler(
4267             final EventType&lt;T&gt; eventType,
4268             final EventHandler&lt;? super T&gt; eventHandler) {
4269         getInternalEventDispatcher().getEventHandlerManager()
4270                                     .setEventHandler(eventType, eventHandler);
4271     }
4272 
4273     private SceneEventDispatcher getInternalEventDispatcher() {
4274         initializeInternalEventDispatcher();
4275         return internalEventDispatcher;
4276     }
4277 
4278     final void initializeInternalEventDispatcher() {
4279         if (internalEventDispatcher == null) {
4280             internalEventDispatcher = createInternalEventDispatcher();
4281             eventDispatcher = new SimpleObjectProperty&lt;EventDispatcher&gt;(
4282                                           this,
4283                                           &quot;eventDispatcher&quot;,
4284                                           internalEventDispatcher);
4285         }
4286     }
4287 
4288     private SceneEventDispatcher createInternalEventDispatcher() {
4289         return new SceneEventDispatcher(this);
4290     }
4291 
4292     /**
4293      * Registers the specified mnemonic.
4294      *
4295      * @param m The mnemonic
4296      */
4297     public void addMnemonic(Mnemonic m) {
4298         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4299                                     .addMnemonic(m);
4300     }
4301 
4302 
4303     /**
4304      * Unregisters the specified mnemonic.
4305      *
4306      * @param m The mnemonic
4307      */
4308     public void removeMnemonic(Mnemonic m) {
4309         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4310                                     .removeMnemonic(m);
4311     }
4312 
4313     final void clearNodeMnemonics(Node node) {
4314         getInternalEventDispatcher().getKeyboardShortcutsHandler()
4315                 .clearNodeMnemonics(node);
4316     }
4317 
4318 
4319     /**
4320      * Gets the list of mnemonics for this {@code Scene}.
4321      *
4322      * @return the list of mnemonics
4323      */
4324     public ObservableMap&lt;KeyCombination, ObservableList&lt;Mnemonic&gt;&gt; getMnemonics() {
4325         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4326                                            .getMnemonics();
4327     }
4328 
4329     /**
4330      * Gets the list of accelerators for this {@code Scene}.
4331      *
4332      * @return the list of accelerators
4333      */
4334     public ObservableMap&lt;KeyCombination, Runnable&gt; getAccelerators() {
4335         return getInternalEventDispatcher().getKeyboardShortcutsHandler()
4336                                            .getAccelerators();
4337     }
4338 
4339     // PENDING_DOC_REVIEW
4340     /**
4341      * Construct an event dispatch chain for this scene. The event dispatch
4342      * chain contains all event dispatchers from the stage to this scene.
4343      *
4344      * @param tail the initial chain to build from
4345      * @return the resulting event dispatch chain for this scene
4346      */
4347     @Override
4348     public EventDispatchChain buildEventDispatchChain(
4349             EventDispatchChain tail) {
4350         if (eventDispatcher != null) {
4351             final EventDispatcher eventDispatcherValue = eventDispatcher.get();
4352             if (eventDispatcherValue != null) {
4353                 tail = tail.prepend(eventDispatcherValue);
4354             }
4355         }
4356 
4357         if (getWindow() != null) {
4358             tail = getWindow().buildEventDispatchChain(tail);
4359         }
4360 
4361         return tail;
4362     }
4363 
4364     /***************************************************************************
4365      *                                                                         *
4366      *                             Context Menus                               *
4367      *                                                                         *
4368      **************************************************************************/
4369 
4370     /**
4371      * Defines a function to be called when a mouse button has been clicked
4372      * (pressed and released) on this {@code Scene}.
4373      * @since JavaFX 2.1
4374      */
4375 
4376     private ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequested;
4377 
4378     public final void setOnContextMenuRequested(EventHandler&lt;? super ContextMenuEvent&gt; value) {
4379         onContextMenuRequestedProperty().set(value);
4380     }
4381 
4382     public final EventHandler&lt;? super ContextMenuEvent&gt; getOnContextMenuRequested() {
4383         return onContextMenuRequested == null ? null : onContextMenuRequested.get();
4384     }
4385 
4386     public final ObjectProperty&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt; onContextMenuRequestedProperty() {
4387         if (onContextMenuRequested == null) {
4388             onContextMenuRequested = new ObjectPropertyBase&lt;EventHandler&lt;? super ContextMenuEvent&gt;&gt;() {
4389 
4390                 @Override
4391                 protected void invalidated() {
4392                     setEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, get());
4393                 }
4394 
4395                 @Override
4396                 public Object getBean() {
4397                     return Scene.this;
4398                 }
4399 
4400                 @Override
4401                 public String getName() {
4402                     return &quot;onContextMenuRequested&quot;;
4403                 }
4404             };
4405         }
4406         return onContextMenuRequested;
4407     }
4408 
4409     /***************************************************************************
4410      *                                                                         *
4411      *                             Mouse Handling                              *
4412      *                                                                         *
4413      **************************************************************************/
4414 
4415     /**
4416      * Defines a function to be called when a mouse button has been clicked
4417      * (pressed and released) on this {@code Scene}.
4418      */
4419     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClicked;
4420 
4421     public final void setOnMouseClicked(EventHandler&lt;? super MouseEvent&gt; value) {
4422         onMouseClickedProperty().set(value);
4423     }
4424 
4425     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseClicked() {
4426         return onMouseClicked == null ? null : onMouseClicked.get();
4427     }
4428 
4429     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseClickedProperty() {
4430         if (onMouseClicked == null) {
4431             onMouseClicked = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4432 
4433                 @Override
4434                 protected void invalidated() {
4435                     setEventHandler(MouseEvent.MOUSE_CLICKED, get());
4436                 }
4437 
4438                 @Override
4439                 public Object getBean() {
4440                     return Scene.this;
4441                 }
4442 
4443                 @Override
4444                 public String getName() {
4445                     return &quot;onMouseClicked&quot;;
4446                 }
4447             };
4448         }
4449         return onMouseClicked;
4450     }
4451 
4452     /**
4453      * Defines a function to be called when a mouse button is pressed
4454      * on this {@code Scene} and then dragged.
4455      */
4456     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDragged;
4457 
4458     public final void setOnMouseDragged(EventHandler&lt;? super MouseEvent&gt; value) {
4459         onMouseDraggedProperty().set(value);
4460     }
4461 
4462     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseDragged() {
4463         return onMouseDragged == null ? null : onMouseDragged.get();
4464     }
4465 
4466     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseDraggedProperty() {
4467         if (onMouseDragged == null) {
4468             onMouseDragged = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4469 
4470                 @Override
4471                 protected void invalidated() {
4472                     setEventHandler(MouseEvent.MOUSE_DRAGGED, get());
4473                 }
4474 
4475                 @Override
4476                 public Object getBean() {
4477                     return Scene.this;
4478                 }
4479 
4480                 @Override
4481                 public String getName() {
4482                     return &quot;onMouseDragged&quot;;
4483                 }
4484             };
4485         }
4486         return onMouseDragged;
4487     }
4488 
4489     /**
4490      * Defines a function to be called when the mouse enters this {@code Scene}.
4491      */
4492     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEntered;
4493 
4494     public final void setOnMouseEntered(EventHandler&lt;? super MouseEvent&gt; value) {
4495         onMouseEnteredProperty().set(value);
4496     }
4497 
4498     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseEntered() {
4499         return onMouseEntered == null ? null : onMouseEntered.get();
4500     }
4501 
4502     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseEnteredProperty() {
4503         if (onMouseEntered == null) {
4504             onMouseEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4505 
4506                 @Override
4507                 protected void invalidated() {
4508                     setEventHandler(MouseEvent.MOUSE_ENTERED, get());
4509                 }
4510 
4511                 @Override
4512                 public Object getBean() {
4513                     return Scene.this;
4514                 }
4515 
4516                 @Override
4517                 public String getName() {
4518                     return &quot;onMouseEntered&quot;;
4519                 }
4520             };
4521         }
4522         return onMouseEntered;
4523     }
4524 
4525     /**
4526      * Defines a function to be called when the mouse exits this {@code Scene}.
4527      */
4528     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExited;
4529 
4530     public final void setOnMouseExited(EventHandler&lt;? super MouseEvent&gt; value) {
4531         onMouseExitedProperty().set(value);
4532     }
4533 
4534     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseExited() {
4535         return onMouseExited == null ? null : onMouseExited.get();
4536     }
4537 
4538     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseExitedProperty() {
4539         if (onMouseExited == null) {
4540             onMouseExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4541 
4542                 @Override
4543                 protected void invalidated() {
4544                     setEventHandler(MouseEvent.MOUSE_EXITED, get());
4545                 }
4546 
4547                 @Override
4548                 public Object getBean() {
4549                     return Scene.this;
4550                 }
4551 
4552                 @Override
4553                 public String getName() {
4554                     return &quot;onMouseExited&quot;;
4555                 }
4556             };
4557         }
4558         return onMouseExited;
4559     }
4560 
4561     /**
4562      * Defines a function to be called when mouse cursor moves within
4563      * this {@code Scene} but no buttons have been pushed.
4564      */
4565     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMoved;
4566 
4567     public final void setOnMouseMoved(EventHandler&lt;? super MouseEvent&gt; value) {
4568         onMouseMovedProperty().set(value);
4569     }
4570 
4571     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseMoved() {
4572         return onMouseMoved == null ? null : onMouseMoved.get();
4573     }
4574 
4575     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseMovedProperty() {
4576         if (onMouseMoved == null) {
4577             onMouseMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4578 
4579                 @Override
4580                 protected void invalidated() {
4581                     setEventHandler(MouseEvent.MOUSE_MOVED, get());
4582                 }
4583 
4584                 @Override
4585                 public Object getBean() {
4586                     return Scene.this;
4587                 }
4588 
4589                 @Override
4590                 public String getName() {
4591                     return &quot;onMouseMoved&quot;;
4592                 }
4593             };
4594         }
4595         return onMouseMoved;
4596     }
4597 
4598     /**
4599      * Defines a function to be called when a mouse button
4600      * has been pressed on this {@code Scene}.
4601      */
4602     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressed;
4603 
4604     public final void setOnMousePressed(EventHandler&lt;? super MouseEvent&gt; value) {
4605         onMousePressedProperty().set(value);
4606     }
4607 
4608     public final EventHandler&lt;? super MouseEvent&gt; getOnMousePressed() {
4609         return onMousePressed == null ? null : onMousePressed.get();
4610     }
4611 
4612     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMousePressedProperty() {
4613         if (onMousePressed == null) {
4614             onMousePressed = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4615 
4616                 @Override
4617                 protected void invalidated() {
4618                     setEventHandler(MouseEvent.MOUSE_PRESSED, get());
4619                 }
4620 
4621                 @Override
4622                 public Object getBean() {
4623                     return Scene.this;
4624                 }
4625 
4626                 @Override
4627                 public String getName() {
4628                     return &quot;onMousePressed&quot;;
4629                 }
4630             };
4631         }
4632         return onMousePressed;
4633     }
4634 
4635     /**
4636      * Defines a function to be called when a mouse button
4637      * has been released on this {@code Scene}.
4638      */
4639     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleased;
4640 
4641     public final void setOnMouseReleased(EventHandler&lt;? super MouseEvent&gt; value) {
4642         onMouseReleasedProperty().set(value);
4643     }
4644 
4645     public final EventHandler&lt;? super MouseEvent&gt; getOnMouseReleased() {
4646         return onMouseReleased == null ? null : onMouseReleased.get();
4647     }
4648 
4649     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onMouseReleasedProperty() {
4650         if (onMouseReleased == null) {
4651             onMouseReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4652 
4653                 @Override
4654                 protected void invalidated() {
4655                     setEventHandler(MouseEvent.MOUSE_RELEASED, get());
4656                 }
4657 
4658                 @Override
4659                 public Object getBean() {
4660                     return Scene.this;
4661                 }
4662 
4663                 @Override
4664                 public String getName() {
4665                     return &quot;onMouseReleased&quot;;
4666                 }
4667             };
4668         }
4669         return onMouseReleased;
4670     }
4671 
4672     /**
4673      * Defines a function to be called when drag gesture has been
4674      * detected. This is the right place to start drag and drop operation.
4675      */
4676     private ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetected;
4677 
4678     public final void setOnDragDetected(EventHandler&lt;? super MouseEvent&gt; value) {
4679         onDragDetectedProperty().set(value);
4680     }
4681 
4682     public final EventHandler&lt;? super MouseEvent&gt; getOnDragDetected() {
4683         return onDragDetected == null ? null : onDragDetected.get();
4684     }
4685 
4686     public final ObjectProperty&lt;EventHandler&lt;? super MouseEvent&gt;&gt; onDragDetectedProperty() {
4687         if (onDragDetected == null) {
4688             onDragDetected = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseEvent&gt;&gt;() {
4689 
4690                 @Override
4691                 protected void invalidated() {
4692                     setEventHandler(MouseEvent.DRAG_DETECTED, get());
4693                 }
4694 
4695                 @Override
4696                 public Object getBean() {
4697                     return Scene.this;
4698                 }
4699 
4700                 @Override
4701                 public String getName() {
4702                     return &quot;onDragDetected&quot;;
4703                 }
4704             };
4705         }
4706         return onDragDetected;
4707     }
4708 
4709     /**
4710      * Defines a function to be called when a full press-drag-release gesture
4711      * progresses within this {@code Scene}.
4712      * @since JavaFX 2.1
4713      */
4714     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOver;
4715 
4716     public final void setOnMouseDragOver(EventHandler&lt;? super MouseDragEvent&gt; value) {
4717         onMouseDragOverProperty().set(value);
4718     }
4719 
4720     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragOver() {
4721         return onMouseDragOver == null ? null : onMouseDragOver.get();
4722     }
4723 
4724     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragOverProperty() {
4725         if (onMouseDragOver == null) {
4726             onMouseDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4727 
4728                 @Override
4729                 protected void invalidated() {
4730                     setEventHandler(MouseDragEvent.MOUSE_DRAG_OVER, get());
4731                 }
4732 
4733                 @Override
4734                 public Object getBean() {
4735                     return Scene.this;
4736                 }
4737 
4738                 @Override
4739                 public String getName() {
4740                     return &quot;onMouseDragOver&quot;;
4741                 }
4742             };
4743         }
4744         return onMouseDragOver;
4745     }
4746 
4747     /**
4748      * Defines a function to be called when a full press-drag-release gesture
4749      * ends within this {@code Scene}.
4750      * @since JavaFX 2.1
4751      */
4752     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleased;
4753 
4754     public final void setOnMouseDragReleased(EventHandler&lt;? super MouseDragEvent&gt; value) {
4755         onMouseDragReleasedProperty().set(value);
4756     }
4757 
4758     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragReleased() {
4759         return onMouseDragReleased == null ? null : onMouseDragReleased.get();
4760     }
4761 
4762     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragReleasedProperty() {
4763         if (onMouseDragReleased == null) {
4764             onMouseDragReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4765 
4766                 @Override
4767                 protected void invalidated() {
4768                     setEventHandler(MouseDragEvent.MOUSE_DRAG_RELEASED, get());
4769                 }
4770 
4771                 @Override
4772                 public Object getBean() {
4773                     return Scene.this;
4774                 }
4775 
4776                 @Override
4777                 public String getName() {
4778                     return &quot;onMouseDragReleased&quot;;
4779                 }
4780             };
4781         }
4782         return onMouseDragReleased;
4783     }
4784 
4785     /**
4786      * Defines a function to be called when a full press-drag-release gesture
4787      * enters this {@code Scene}.
4788      * @since JavaFX 2.1
4789      */
4790     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEntered;
4791 
4792     public final void setOnMouseDragEntered(EventHandler&lt;? super MouseDragEvent&gt; value) {
4793         onMouseDragEnteredProperty().set(value);
4794     }
4795 
4796     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragEntered() {
4797         return onMouseDragEntered == null ? null : onMouseDragEntered.get();
4798     }
4799 
4800     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragEnteredProperty() {
4801         if (onMouseDragEntered == null) {
4802             onMouseDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4803 
4804                 @Override
4805                 protected void invalidated() {
4806                     setEventHandler(MouseDragEvent.MOUSE_DRAG_ENTERED, get());
4807                 }
4808 
4809                 @Override
4810                 public Object getBean() {
4811                     return Scene.this;
4812                 }
4813 
4814                 @Override
4815                 public String getName() {
4816                     return &quot;onMouseDragEntered&quot;;
4817                 }
4818             };
4819         }
4820         return onMouseDragEntered;
4821     }
4822 
4823     /**
4824      * Defines a function to be called when a full press-drag-release gesture
4825      * exits this {@code Scene}.
4826      * @since JavaFX 2.1
4827      */
4828     private ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExited;
4829 
4830     public final void setOnMouseDragExited(EventHandler&lt;? super MouseDragEvent&gt; value) {
4831         onMouseDragExitedProperty().set(value);
4832     }
4833 
4834     public final EventHandler&lt;? super MouseDragEvent&gt; getOnMouseDragExited() {
4835         return onMouseDragExited == null ? null : onMouseDragExited.get();
4836     }
4837 
4838     public final ObjectProperty&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt; onMouseDragExitedProperty() {
4839         if (onMouseDragExited == null) {
4840             onMouseDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super MouseDragEvent&gt;&gt;() {
4841 
4842                 @Override
4843                 protected void invalidated() {
4844                     setEventHandler(MouseDragEvent.MOUSE_DRAG_EXITED, get());
4845                 }
4846 
4847                 @Override
4848                 public Object getBean() {
4849                     return Scene.this;
4850                 }
4851 
4852                 @Override
4853                 public String getName() {
4854                     return &quot;onMouseDragExited&quot;;
4855                 }
4856             };
4857         }
4858         return onMouseDragExited;
4859     }
4860 
4861 
4862     /***************************************************************************
4863      *                                                                         *
4864      *                           Gestures Handling                             *
4865      *                                                                         *
4866      **************************************************************************/
4867 
4868     /**
4869      * Defines a function to be called when a scrolling gesture is detected.
4870      * @since JavaFX 2.2
4871      */
4872     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStarted;
4873 
4874     public final void setOnScrollStarted(EventHandler&lt;? super ScrollEvent&gt; value) {
4875         onScrollStartedProperty().set(value);
4876     }
4877 
4878     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollStarted() {
4879         return onScrollStarted == null ? null : onScrollStarted.get();
4880     }
4881 
4882     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollStartedProperty() {
4883         if (onScrollStarted == null) {
4884             onScrollStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4885 
4886                 @Override
4887                 protected void invalidated() {
4888                     setEventHandler(ScrollEvent.SCROLL_STARTED, get());
4889                 }
4890 
4891                 @Override
4892                 public Object getBean() {
4893                     return Scene.this;
4894                 }
4895 
4896                 @Override
4897                 public String getName() {
4898                     return &quot;onScrollStarted&quot;;
4899                 }
4900             };
4901         }
4902         return onScrollStarted;
4903     }
4904 
4905     /**
4906      * Defines a function to be called when user performs a scrolling action.
4907      */
4908     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScroll;
4909 
4910     public final void setOnScroll(EventHandler&lt;? super ScrollEvent&gt; value) {
4911         onScrollProperty().set(value);
4912     }
4913 
4914     public final EventHandler&lt;? super ScrollEvent&gt; getOnScroll() {
4915         return onScroll == null ? null : onScroll.get();
4916     }
4917 
4918     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollProperty() {
4919         if (onScroll == null) {
4920             onScroll = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4921 
4922                 @Override
4923                 protected void invalidated() {
4924                     setEventHandler(ScrollEvent.SCROLL, get());
4925                 }
4926 
4927                 @Override
4928                 public Object getBean() {
4929                     return Scene.this;
4930                 }
4931 
4932                 @Override
4933                 public String getName() {
4934                     return &quot;onScroll&quot;;
4935                 }
4936             };
4937         }
4938         return onScroll;
4939     }
4940 
4941     /**
4942      * Defines a function to be called when a scrolling gesture ends.
4943      * @since JavaFX 2.2
4944      */
4945     private ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinished;
4946 
4947     public final void setOnScrollFinished(EventHandler&lt;? super ScrollEvent&gt; value) {
4948         onScrollFinishedProperty().set(value);
4949     }
4950 
4951     public final EventHandler&lt;? super ScrollEvent&gt; getOnScrollFinished() {
4952         return onScrollFinished == null ? null : onScrollFinished.get();
4953     }
4954 
4955     public final ObjectProperty&lt;EventHandler&lt;? super ScrollEvent&gt;&gt; onScrollFinishedProperty() {
4956         if (onScrollFinished == null) {
4957             onScrollFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ScrollEvent&gt;&gt;() {
4958 
4959                 @Override
4960                 protected void invalidated() {
4961                     setEventHandler(ScrollEvent.SCROLL_FINISHED, get());
4962                 }
4963 
4964                 @Override
4965                 public Object getBean() {
4966                     return Scene.this;
4967                 }
4968 
4969                 @Override
4970                 public String getName() {
4971                     return &quot;onScrollFinished&quot;;
4972                 }
4973             };
4974         }
4975         return onScrollFinished;
4976     }
4977 
4978     /**
4979      * Defines a function to be called when a rotating gesture is detected.
4980      * @since JavaFX 2.2
4981      */
4982     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStarted;
4983 
4984     public final void setOnRotationStarted(EventHandler&lt;? super RotateEvent&gt; value) {
4985         onRotationStartedProperty().set(value);
4986     }
4987 
4988     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationStarted() {
4989         return onRotationStarted == null ? null : onRotationStarted.get();
4990     }
4991 
4992     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationStartedProperty() {
4993         if (onRotationStarted == null) {
4994             onRotationStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
4995 
4996                 @Override
4997                 protected void invalidated() {
4998                     setEventHandler(RotateEvent.ROTATION_STARTED, get());
4999                 }
5000 
5001                 @Override
5002                 public Object getBean() {
5003                     return Scene.this;
5004                 }
5005 
5006                 @Override
5007                 public String getName() {
5008                     return &quot;onRotationStarted&quot;;
5009                 }
5010             };
5011         }
5012         return onRotationStarted;
5013     }
5014 
5015     /**
5016      * Defines a function to be called when user performs a rotating action.
5017      * @since JavaFX 2.2
5018      */
5019     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotate;
5020 
5021     public final void setOnRotate(EventHandler&lt;? super RotateEvent&gt; value) {
5022         onRotateProperty().set(value);
5023     }
5024 
5025     public final EventHandler&lt;? super RotateEvent&gt; getOnRotate() {
5026         return onRotate == null ? null : onRotate.get();
5027     }
5028 
5029     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotateProperty() {
5030         if (onRotate == null) {
5031             onRotate = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5032 
5033                 @Override
5034                 protected void invalidated() {
5035                     setEventHandler(RotateEvent.ROTATE, get());
5036                 }
5037 
5038                 @Override
5039                 public Object getBean() {
5040                     return Scene.this;
5041                 }
5042 
5043                 @Override
5044                 public String getName() {
5045                     return &quot;onRotate&quot;;
5046                 }
5047             };
5048         }
5049         return onRotate;
5050     }
5051 
5052     /**
5053      * Defines a function to be called when a rotating gesture ends.
5054      * @since JavaFX 2.2
5055      */
5056     private ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinished;
5057 
5058     public final void setOnRotationFinished(EventHandler&lt;? super RotateEvent&gt; value) {
5059         onRotationFinishedProperty().set(value);
5060     }
5061 
5062     public final EventHandler&lt;? super RotateEvent&gt; getOnRotationFinished() {
5063         return onRotationFinished == null ? null : onRotationFinished.get();
5064     }
5065 
5066     public final ObjectProperty&lt;EventHandler&lt;? super RotateEvent&gt;&gt; onRotationFinishedProperty() {
5067         if (onRotationFinished == null) {
5068             onRotationFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super RotateEvent&gt;&gt;() {
5069 
5070                 @Override
5071                 protected void invalidated() {
5072                     setEventHandler(RotateEvent.ROTATION_FINISHED, get());
5073                 }
5074 
5075                 @Override
5076                 public Object getBean() {
5077                     return Scene.this;
5078                 }
5079 
5080                 @Override
5081                 public String getName() {
5082                     return &quot;onRotationFinished&quot;;
5083                 }
5084             };
5085         }
5086         return onRotationFinished;
5087     }
5088 
5089     /**
5090      * Defines a function to be called when a zooming gesture is detected.
5091      * @since JavaFX 2.2
5092      */
5093     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStarted;
5094 
5095     public final void setOnZoomStarted(EventHandler&lt;? super ZoomEvent&gt; value) {
5096         onZoomStartedProperty().set(value);
5097     }
5098 
5099     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomStarted() {
5100         return onZoomStarted == null ? null : onZoomStarted.get();
5101     }
5102 
5103     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomStartedProperty() {
5104         if (onZoomStarted == null) {
5105             onZoomStarted = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5106 
5107                 @Override
5108                 protected void invalidated() {
5109                     setEventHandler(ZoomEvent.ZOOM_STARTED, get());
5110                 }
5111 
5112                 @Override
5113                 public Object getBean() {
5114                     return Scene.this;
5115                 }
5116 
5117                 @Override
5118                 public String getName() {
5119                     return &quot;onZoomStarted&quot;;
5120                 }
5121             };
5122         }
5123         return onZoomStarted;
5124     }
5125 
5126     /**
5127      * Defines a function to be called when user performs a zooming action.
5128      * @since JavaFX 2.2
5129      */
5130     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoom;
5131 
5132     public final void setOnZoom(EventHandler&lt;? super ZoomEvent&gt; value) {
5133         onZoomProperty().set(value);
5134     }
5135 
5136     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoom() {
5137         return onZoom == null ? null : onZoom.get();
5138     }
5139 
5140     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomProperty() {
5141         if (onZoom == null) {
5142             onZoom = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5143 
5144                 @Override
5145                 protected void invalidated() {
5146                     setEventHandler(ZoomEvent.ZOOM, get());
5147                 }
5148 
5149                 @Override
5150                 public Object getBean() {
5151                     return Scene.this;
5152                 }
5153 
5154                 @Override
5155                 public String getName() {
5156                     return &quot;onZoom&quot;;
5157                 }
5158             };
5159         }
5160         return onZoom;
5161     }
5162 
5163     /**
5164      * Defines a function to be called when a zooming gesture ends.
5165      * @since JavaFX 2.2
5166      */
5167     private ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinished;
5168 
5169     public final void setOnZoomFinished(EventHandler&lt;? super ZoomEvent&gt; value) {
5170         onZoomFinishedProperty().set(value);
5171     }
5172 
5173     public final EventHandler&lt;? super ZoomEvent&gt; getOnZoomFinished() {
5174         return onZoomFinished == null ? null : onZoomFinished.get();
5175     }
5176 
5177     public final ObjectProperty&lt;EventHandler&lt;? super ZoomEvent&gt;&gt; onZoomFinishedProperty() {
5178         if (onZoomFinished == null) {
5179             onZoomFinished = new ObjectPropertyBase&lt;EventHandler&lt;? super ZoomEvent&gt;&gt;() {
5180 
5181                 @Override
5182                 protected void invalidated() {
5183                     setEventHandler(ZoomEvent.ZOOM_FINISHED, get());
5184                 }
5185 
5186                 @Override
5187                 public Object getBean() {
5188                     return Scene.this;
5189                 }
5190 
5191                 @Override
5192                 public String getName() {
5193                     return &quot;onZoomFinished&quot;;
5194                 }
5195             };
5196         }
5197         return onZoomFinished;
5198     }
5199 
5200     /**
5201      * Defines a function to be called when an upward swipe gesture
5202      * happens in this scene.
5203      * @since JavaFX 2.2
5204      */
5205     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUp;
5206 
5207     public final void setOnSwipeUp(EventHandler&lt;? super SwipeEvent&gt; value) {
5208         onSwipeUpProperty().set(value);
5209     }
5210 
5211     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeUp() {
5212         return onSwipeUp == null ? null : onSwipeUp.get();
5213     }
5214 
5215     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeUpProperty() {
5216         if (onSwipeUp == null) {
5217             onSwipeUp = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5218 
5219                 @Override
5220                 protected void invalidated() {
5221                     setEventHandler(SwipeEvent.SWIPE_UP, get());
5222                 }
5223 
5224                 @Override
5225                 public Object getBean() {
5226                     return Scene.this;
5227                 }
5228 
5229                 @Override
5230                 public String getName() {
5231                     return &quot;onSwipeUp&quot;;
5232                 }
5233             };
5234         }
5235         return onSwipeUp;
5236     }
5237 
5238     /**
5239      * Defines a function to be called when an downward swipe gesture
5240      * happens in this scene.
5241      * @since JavaFX 2.2
5242      */
5243     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDown;
5244 
5245     public final void setOnSwipeDown(EventHandler&lt;? super SwipeEvent&gt; value) {
5246         onSwipeDownProperty().set(value);
5247     }
5248 
5249     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeDown() {
5250         return onSwipeDown == null ? null : onSwipeDown.get();
5251     }
5252 
5253     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeDownProperty() {
5254         if (onSwipeDown == null) {
5255             onSwipeDown = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5256 
5257                 @Override
5258                 protected void invalidated() {
5259                     setEventHandler(SwipeEvent.SWIPE_DOWN, get());
5260                 }
5261 
5262                 @Override
5263                 public Object getBean() {
5264                     return Scene.this;
5265                 }
5266 
5267                 @Override
5268                 public String getName() {
5269                     return &quot;onSwipeDown&quot;;
5270                 }
5271             };
5272         }
5273         return onSwipeDown;
5274     }
5275 
5276     /**
5277      * Defines a function to be called when an leftward swipe gesture
5278      * happens in this scene.
5279      * @since JavaFX 2.2
5280      */
5281     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeft;
5282 
5283     public final void setOnSwipeLeft(EventHandler&lt;? super SwipeEvent&gt; value) {
5284         onSwipeLeftProperty().set(value);
5285     }
5286 
5287     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeLeft() {
5288         return onSwipeLeft == null ? null : onSwipeLeft.get();
5289     }
5290 
5291     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeLeftProperty() {
5292         if (onSwipeLeft == null) {
5293             onSwipeLeft = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5294 
5295                 @Override
5296                 protected void invalidated() {
5297                     setEventHandler(SwipeEvent.SWIPE_LEFT, get());
5298                 }
5299 
5300                 @Override
5301                 public Object getBean() {
5302                     return Scene.this;
5303                 }
5304 
5305                 @Override
5306                 public String getName() {
5307                     return &quot;onSwipeLeft&quot;;
5308                 }
5309             };
5310         }
5311         return onSwipeLeft;
5312     }
5313 
5314     /**
5315      * Defines a function to be called when an rightward swipe gesture
5316      * happens in this scene.
5317      * @since JavaFX 2.2
5318      */
5319     private ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRight;
5320 
5321     public final void setOnSwipeRight(EventHandler&lt;? super SwipeEvent&gt; value) {
5322         onSwipeRightProperty().set(value);
5323     }
5324 
5325     public final EventHandler&lt;? super SwipeEvent&gt; getOnSwipeRight() {
5326         return onSwipeRight == null ? null : onSwipeRight.get();
5327     }
5328 
5329     public final ObjectProperty&lt;EventHandler&lt;? super SwipeEvent&gt;&gt; onSwipeRightProperty() {
5330         if (onSwipeRight == null) {
5331             onSwipeRight = new ObjectPropertyBase&lt;EventHandler&lt;? super SwipeEvent&gt;&gt;() {
5332 
5333                 @Override
5334                 protected void invalidated() {
5335                     setEventHandler(SwipeEvent.SWIPE_RIGHT, get());
5336                 }
5337 
5338                 @Override
5339                 public Object getBean() {
5340                     return Scene.this;
5341                 }
5342 
5343                 @Override
5344                 public String getName() {
5345                     return &quot;onSwipeRight&quot;;
5346                 }
5347             };
5348         }
5349         return onSwipeRight;
5350     }
5351 
5352     /***************************************************************************
5353      *                                                                         *
5354      *                            Touch Handling                               *
5355      *                                                                         *
5356      **************************************************************************/
5357 
5358     /**
5359      * Defines a function to be called when a new touch point is pressed.
5360      * @since JavaFX 2.2
5361      */
5362     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressed;
5363 
5364     public final void setOnTouchPressed(EventHandler&lt;? super TouchEvent&gt; value) {
5365         onTouchPressedProperty().set(value);
5366     }
5367 
5368     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchPressed() {
5369         return onTouchPressed == null ? null : onTouchPressed.get();
5370     }
5371 
5372     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchPressedProperty() {
5373         if (onTouchPressed == null) {
5374             onTouchPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5375 
5376                 @Override
5377                 protected void invalidated() {
5378                     setEventHandler(TouchEvent.TOUCH_PRESSED, get());
5379                 }
5380 
5381                 @Override
5382                 public Object getBean() {
5383                     return Scene.this;
5384                 }
5385 
5386                 @Override
5387                 public String getName() {
5388                     return &quot;onTouchPressed&quot;;
5389                 }
5390             };
5391         }
5392         return onTouchPressed;
5393     }
5394 
5395     /**
5396      * Defines a function to be called when a touch point is moved.
5397      * @since JavaFX 2.2
5398      */
5399     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMoved;
5400 
5401     public final void setOnTouchMoved(EventHandler&lt;? super TouchEvent&gt; value) {
5402         onTouchMovedProperty().set(value);
5403     }
5404 
5405     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchMoved() {
5406         return onTouchMoved == null ? null : onTouchMoved.get();
5407     }
5408 
5409     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchMovedProperty() {
5410         if (onTouchMoved == null) {
5411             onTouchMoved = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5412 
5413                 @Override
5414                 protected void invalidated() {
5415                     setEventHandler(TouchEvent.TOUCH_MOVED, get());
5416                 }
5417 
5418                 @Override
5419                 public Object getBean() {
5420                     return Scene.this;
5421                 }
5422 
5423                 @Override
5424                 public String getName() {
5425                     return &quot;onTouchMoved&quot;;
5426                 }
5427             };
5428         }
5429         return onTouchMoved;
5430     }
5431 
5432     /**
5433      * Defines a function to be called when a new touch point is pressed.
5434      * @since JavaFX 2.2
5435      */
5436     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleased;
5437 
5438     public final void setOnTouchReleased(EventHandler&lt;? super TouchEvent&gt; value) {
5439         onTouchReleasedProperty().set(value);
5440     }
5441 
5442     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchReleased() {
5443         return onTouchReleased == null ? null : onTouchReleased.get();
5444     }
5445 
5446     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchReleasedProperty() {
5447         if (onTouchReleased == null) {
5448             onTouchReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5449 
5450                 @Override
5451                 protected void invalidated() {
5452                     setEventHandler(TouchEvent.TOUCH_RELEASED, get());
5453                 }
5454 
5455                 @Override
5456                 public Object getBean() {
5457                     return Scene.this;
5458                 }
5459 
5460                 @Override
5461                 public String getName() {
5462                     return &quot;onTouchReleased&quot;;
5463                 }
5464             };
5465         }
5466         return onTouchReleased;
5467     }
5468 
5469     /**
5470      * Defines a function to be called when a touch point stays pressed and
5471      * still.
5472      * @since JavaFX 2.2
5473      */
5474     private ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationary;
5475 
5476     public final void setOnTouchStationary(EventHandler&lt;? super TouchEvent&gt; value) {
5477         onTouchStationaryProperty().set(value);
5478     }
5479 
5480     public final EventHandler&lt;? super TouchEvent&gt; getOnTouchStationary() {
5481         return onTouchStationary == null ? null : onTouchStationary.get();
5482     }
5483 
5484     public final ObjectProperty&lt;EventHandler&lt;? super TouchEvent&gt;&gt; onTouchStationaryProperty() {
5485         if (onTouchStationary == null) {
5486             onTouchStationary = new ObjectPropertyBase&lt;EventHandler&lt;? super TouchEvent&gt;&gt;() {
5487 
5488                 @Override
5489                 protected void invalidated() {
5490                     setEventHandler(TouchEvent.TOUCH_STATIONARY, get());
5491                 }
5492 
5493                 @Override
5494                 public Object getBean() {
5495                     return Scene.this;
5496                 }
5497 
5498                 @Override
5499                 public String getName() {
5500                     return &quot;onTouchStationary&quot;;
5501                 }
5502             };
5503         }
5504         return onTouchStationary;
5505     }
5506 
5507     /*
5508      * This class provides reordering and ID mapping of particular touch points.
5509      * Platform may report arbitrary touch point IDs and they may be reused
5510      * during one gesture. This class keeps track of it and provides
5511      * sequentially sorted IDs, unique in scope of a gesture.
5512      *
5513      * Some platforms report always small numbers, these take fast paths through
5514      * the algorithm, directly indexing an array. Bigger numbers take a slow
5515      * path using a hash map.
5516      *
5517      * The algorithm performance was measured and it doesn&#39;t impose
5518      * any significant slowdown on the event delivery.
5519      */
5520     private static class TouchMap {
5521         private static final int FAST_THRESHOLD = 10;
5522         int[] fastMap = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
5523         Map&lt;Long, Integer&gt; slowMap = new HashMap&lt;Long, Integer&gt;();
5524         List&lt;Integer&gt; order = new LinkedList&lt;Integer&gt;();
5525         List&lt;Long&gt; removed = new ArrayList&lt;Long&gt;(10);
5526         int counter = 0;
5527         int active = 0;
5528 
5529         public int add(long id) {
5530             counter++;
5531             active++;
5532             if (id &lt; FAST_THRESHOLD) {
5533                 fastMap[(int) id] = counter;
5534             } else {
5535                 slowMap.put(id, counter);
5536             }
5537             order.add(counter);
5538             return counter;
5539         }
5540 
5541         public void remove(long id) {
5542             // book the removal - it needs to be done after all touch points
5543             // of an event are processed - see cleanup()
5544             removed.add(id);
5545         }
5546 
5547         public int get(long id) {
5548             if (id &lt; FAST_THRESHOLD) {
5549                 int result = fastMap[(int) id];
5550                 if (result == 0) {
5551                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5552                             + &quot;touch point ID&quot;);
5553                 }
5554                 return result;
5555             } else {
5556                 try {
5557                     return slowMap.get(id);
5558                 } catch (NullPointerException e) {
5559                     throw new RuntimeException(&quot;Platform reported wrong &quot;
5560                             + &quot;touch point ID&quot;);
5561                 }
5562             }
5563         }
5564 
5565         public int getOrder(int id) {
5566             return order.indexOf(id);
5567         }
5568 
5569         // returns true if gesture finished (no finger is touched)
5570         public boolean cleanup() {
5571             for (long id : removed) {
5572                 active--;
5573                 order.remove(Integer.valueOf(get(id)));
5574                 if (id &lt; FAST_THRESHOLD) {
5575                     fastMap[(int) id] = 0;
5576                 } else {
5577                     slowMap.remove(id);
5578                 }
5579                 if (active == 0) {
5580                     // gesture finished
5581                     counter = 0;
5582                 }
5583             }
5584             removed.clear();
5585             return active == 0;
5586         }
5587     }
5588 
5589 
5590     /***************************************************************************
5591      *                                                                         *
5592      *                         Drag and Drop Handling                          *
5593      *                                                                         *
5594      **************************************************************************/
5595 
5596     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEntered;
5597 
5598     public final void setOnDragEntered(EventHandler&lt;? super DragEvent&gt; value) {
5599         onDragEnteredProperty().set(value);
5600     }
5601 
5602     public final EventHandler&lt;? super DragEvent&gt; getOnDragEntered() {
5603         return onDragEntered == null ? null : onDragEntered.get();
5604     }
5605 
5606     /**
5607      * Defines a function to be called when drag gesture
5608      * enters this {@code Scene}.
5609      * @return function to be called when drag gesture enters this scene
5610      */
5611     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragEnteredProperty() {
5612         if (onDragEntered == null) {
5613             onDragEntered = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5614 
5615                 @Override
5616                 protected void invalidated() {
5617                     setEventHandler(DragEvent.DRAG_ENTERED, get());
5618                 }
5619 
5620                 @Override
5621                 public Object getBean() {
5622                     return Scene.this;
5623                 }
5624 
5625                 @Override
5626                 public String getName() {
5627                     return &quot;onDragEntered&quot;;
5628                 }
5629             };
5630         }
5631         return onDragEntered;
5632     }
5633 
5634     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExited;
5635 
5636     public final void setOnDragExited(EventHandler&lt;? super DragEvent&gt; value) {
5637         onDragExitedProperty().set(value);
5638     }
5639 
5640     public final EventHandler&lt;? super DragEvent&gt; getOnDragExited() {
5641         return onDragExited == null ? null : onDragExited.get();
5642     }
5643 
5644     /**
5645      * Defines a function to be called when drag gesture
5646      * exits this {@code Scene}.
5647      * @return the function to be called when drag gesture exits this scene
5648      */
5649     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragExitedProperty() {
5650         if (onDragExited == null) {
5651             onDragExited = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5652 
5653                 @Override
5654                 protected void invalidated() {
5655                     setEventHandler(DragEvent.DRAG_EXITED, get());
5656                 }
5657 
5658                 @Override
5659                 public Object getBean() {
5660                     return Scene.this;
5661                 }
5662 
5663                 @Override
5664                 public String getName() {
5665                     return &quot;onDragExited&quot;;
5666                 }
5667             };
5668         }
5669         return onDragExited;
5670     }
5671 
5672     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOver;
5673 
5674     public final void setOnDragOver(EventHandler&lt;? super DragEvent&gt; value) {
5675         onDragOverProperty().set(value);
5676     }
5677 
5678     public final EventHandler&lt;? super DragEvent&gt; getOnDragOver() {
5679         return onDragOver == null ? null : onDragOver.get();
5680     }
5681 
5682     /**
5683      * Defines a function to be called when drag gesture progresses
5684      * within this {@code Scene}.
5685      * @return the function to be called when drag gesture progresses within
5686      * this scene
5687      */
5688     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragOverProperty() {
5689         if (onDragOver == null) {
5690             onDragOver = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5691 
5692                 @Override
5693                 protected void invalidated() {
5694                     setEventHandler(DragEvent.DRAG_OVER, get());
5695                 }
5696 
5697                 @Override
5698                 public Object getBean() {
5699                     return Scene.this;
5700                 }
5701 
5702                 @Override
5703                 public String getName() {
5704                     return &quot;onDragOver&quot;;
5705                 }
5706             };
5707         }
5708         return onDragOver;
5709     }
5710 
5711     // Do we want DRAG_TRANSFER_MODE_CHANGED event?
5712 //    private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChanged;
5713 //
5714 //    public final void setOnDragTransferModeChanged(EventHandler&lt;? super DragEvent&gt; value) {
5715 //        onDragTransferModeChangedProperty().set(value);
5716 //    }
5717 //
5718 //    public final EventHandler&lt;? super DragEvent&gt; getOnDragTransferModeChanged() {
5719 //        return onDragTransferModeChanged == null ? null : onDragTransferModeChanged.get();
5720 //    }
5721 //
5722 //    /**
5723 //     * Defines a function to be called this {@code Scene} if it is a potential
5724 //     * drag-and-drop target when the user takes action to change the intended
5725 //     * {@code TransferMode}.
5726 //     * The user can change the intended {@link TransferMode} by holding down
5727 //     * or releasing key modifiers.
5728 //     */
5729 //    public ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragTransferModeChangedProperty() {
5730 //        if (onDragTransferModeChanged == null) {
5731 //            onDragTransferModeChanged = new SimpleObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5732 //
5733 //                @Override
5734 //                protected void invalidated() {
5735 //                    setEventHandler(DragEvent.DRAG_TRANSFER_MODE_CHANGED, get());
5736 //                }
5737 //            };
5738 //        }
5739 //        return onDragTransferModeChanged;
5740 //    }
5741 
5742     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDropped;
5743 
5744     public final void setOnDragDropped(EventHandler&lt;? super DragEvent&gt; value) {
5745         onDragDroppedProperty().set(value);
5746     }
5747 
5748     public final EventHandler&lt;? super DragEvent&gt; getOnDragDropped() {
5749         return onDragDropped == null ? null : onDragDropped.get();
5750     }
5751 
5752     /**
5753      * Defines a function to be called when the mouse button is released
5754      * on this {@code Scene} during drag and drop gesture. Transfer of data from
5755      * the {@link DragEvent}&#39;s {@link DragEvent#getDragboard() dragboard} should
5756      * happen in this function.
5757      * @return the function to be called when the mouse button is released on
5758      * this scene during drag and drop gesture
5759      */
5760     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDroppedProperty() {
5761         if (onDragDropped == null) {
5762             onDragDropped = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5763 
5764                 @Override
5765                 protected void invalidated() {
5766                     setEventHandler(DragEvent.DRAG_DROPPED, get());
5767                 }
5768 
5769                 @Override
5770                 public Object getBean() {
5771                     return Scene.this;
5772                 }
5773 
5774                 @Override
5775                 public String getName() {
5776                     return &quot;onDragDropped&quot;;
5777                 }
5778             };
5779         }
5780         return onDragDropped;
5781     }
5782 
5783     private ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDone;
5784 
5785     public final void setOnDragDone(EventHandler&lt;? super DragEvent&gt; value) {
5786         onDragDoneProperty().set(value);
5787     }
5788 
5789     public final EventHandler&lt;? super DragEvent&gt; getOnDragDone() {
5790         return onDragDone == null ? null : onDragDone.get();
5791     }
5792 
5793     /**
5794      * Defines a function to be called when this {@code Scene} is a
5795      * drag and drop gesture source after its data has
5796      * been dropped on a drop target. The {@code transferMode} of the
5797      * event shows what just happened at the drop target.
5798      * If {@code transferMode} has the value {@code MOVE}, then the source can
5799      * clear out its data. Clearing the source&#39;s data gives the appropriate
5800      * appearance to a user that the data has been moved by the drag and drop
5801      * gesture. A {@code transferMode} that has the value {@code NONE}
5802      * indicates that no data was transferred during the drag and drop gesture.
5803      * Positional data for the {@code DragEvent} is invalid.  Valid positional
5804      * data for the {@code DragEvent} is presented in the
5805      * {@link #onDragDroppedProperty() onDragDropped} event handler.
5806      * @return the function to be called when this scene is a drag and drop
5807      * gesture source after its data has been dropped on a drop target
5808      */
5809     public final ObjectProperty&lt;EventHandler&lt;? super DragEvent&gt;&gt; onDragDoneProperty() {
5810         if (onDragDone == null) {
5811             onDragDone = new ObjectPropertyBase&lt;EventHandler&lt;? super DragEvent&gt;&gt;() {
5812 
5813                 @Override
5814                 protected void invalidated() {
5815                     setEventHandler(DragEvent.DRAG_DONE, get());
5816                 }
5817 
5818                 @Override
5819                 public Object getBean() {
5820                     return Scene.this;
5821                 }
5822 
5823                 @Override
5824                 public String getName() {
5825                     return &quot;onDragDone&quot;;
5826                 }
5827             };
5828         }
5829         return onDragDone;
5830     }
5831 
5832     /**
5833      * Confirms a potential drag and drop gesture that is recognized over this
5834      * {@code Scene}.
5835      * Can be called only from a DRAG_DETECTED event handler. The returned
5836      * {@link Dragboard} is used to transfer data during
5837      * the drag and drop gesture. Placing this {@code Scene}&#39;s data on the
5838      * {@link Dragboard} also identifies this {@code Scene} as the source of
5839      * the drag and drop gesture.
5840      * More detail about drag and drop gestures is described in the overivew
5841      * of {@link DragEvent}.
5842      *
5843      * @see DragEvent
5844      * @param transferModes The supported {@code TransferMode}(s) of this {@code Node}
5845      * @return A {@code Dragboard} to place this {@code Scene}&#39;s data on
5846      * @throws IllegalStateException if drag and drop cannot be started at this
5847      * moment (it&#39;s called outside of {@code DRAG_DETECTED} event handling).
5848      */
5849     public Dragboard startDragAndDrop(TransferMode... transferModes) {
5850         return startDragAndDrop(this, transferModes);
5851     }
5852 
5853     /**
5854      * Starts a full press-drag-release gesture with this scene as gesture
5855      * source. This method can be called only from a {@code DRAG_DETECTED} mouse
5856      * event handler. More detail about dragging gestures can be found
5857      * in the overview of {@link MouseEvent} and {@link MouseDragEvent}.
5858      *
5859      * @see MouseEvent
5860      * @see MouseDragEvent
5861      * @throws IllegalStateException if the full press-drag-release gesture
5862      * cannot be started at this moment (it&#39;s called outside of
5863      * {@code DRAG_DETECTED} event handling).
5864      * @since JavaFX 2.1
5865      */
5866     public void startFullDrag() {
5867         startFullDrag(this);
5868     }
5869 
5870 
5871     Dragboard startDragAndDrop(EventTarget source, TransferMode... transferModes) {
5872         Toolkit.getToolkit().checkFxUserThread();
5873         if (dndGesture == null ||
5874             (dndGesture.dragDetected != DragDetectedState.PROCESSING))
5875         {
5876             throw new IllegalStateException(&quot;Cannot start drag and drop &quot; +
5877                     &quot;outside of DRAG_DETECTED event handler&quot;);
5878         }
5879 
5880         Set&lt;TransferMode&gt; set = EnumSet.noneOf(TransferMode.class);
5881         for (TransferMode tm : InputEventUtils.safeTransferModes(transferModes)) {
5882             set.add(tm);
5883         }
5884         return dndGesture.startDrag(source, set);
5885     }
5886 
5887     void startFullDrag(EventTarget source) {
5888         Toolkit.getToolkit().checkFxUserThread();
5889         if (dndGesture.dragDetected != DragDetectedState.PROCESSING) {
5890             throw new IllegalStateException(&quot;Cannot start full drag &quot; +
5891                     &quot;outside of DRAG_DETECTED event handler&quot;);
5892         }
5893 
5894         if (dndGesture != null) {
5895             dndGesture.startFullPDR(source);
5896             return;
5897         }
5898 
5899         throw new IllegalStateException(&quot;Cannot start full drag when &quot;
5900                 + &quot;mouse button is not pressed&quot;);
5901     }
5902 
5903     /***************************************************************************
5904      *                                                                         *
5905      *                           Keyboard Handling                             *
5906      *                                                                         *
5907      **************************************************************************/
5908 
5909     /**
5910      * Defines a function to be called when some {@code Node} of this
5911      * {@code Scene} has input focus and a key has been pressed. The function
5912      * is called only if the event hasn&#39;t been already consumed during its
5913      * capturing or bubbling phase.
5914      */
5915     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressed;
5916 
5917     public final void setOnKeyPressed(EventHandler&lt;? super KeyEvent&gt; value) {
5918         onKeyPressedProperty().set(value);
5919     }
5920 
5921     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyPressed() {
5922         return onKeyPressed == null ? null : onKeyPressed.get();
5923     }
5924 
5925     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyPressedProperty() {
5926         if (onKeyPressed == null) {
5927             onKeyPressed = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5928 
5929                 @Override
5930                 protected void invalidated() {
5931                     setEventHandler(KeyEvent.KEY_PRESSED, get());
5932                 }
5933 
5934                 @Override
5935                 public Object getBean() {
5936                     return Scene.this;
5937                 }
5938 
5939                 @Override
5940                 public String getName() {
5941                     return &quot;onKeyPressed&quot;;
5942                 }
5943             };
5944         }
5945         return onKeyPressed;
5946     }
5947 
5948     /**
5949      * Defines a function to be called when some {@code Node} of this
5950      * {@code Scene} has input focus and a key has been released. The function
5951      * is called only if the event hasn&#39;t been already consumed during its
5952      * capturing or bubbling phase.
5953      */
5954     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleased;
5955 
5956     public final void setOnKeyReleased(EventHandler&lt;? super KeyEvent&gt; value) {
5957         onKeyReleasedProperty().set(value);
5958     }
5959 
5960     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyReleased() {
5961         return onKeyReleased == null ? null : onKeyReleased.get();
5962     }
5963 
5964     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyReleasedProperty() {
5965         if (onKeyReleased == null) {
5966             onKeyReleased = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
5967 
5968                 @Override
5969                 protected void invalidated() {
5970                     setEventHandler(KeyEvent.KEY_RELEASED, get());
5971                 }
5972 
5973                 @Override
5974                 public Object getBean() {
5975                     return Scene.this;
5976                 }
5977 
5978                 @Override
5979                 public String getName() {
5980                     return &quot;onKeyReleased&quot;;
5981                 }
5982             };
5983         }
5984         return onKeyReleased;
5985     }
5986 
5987     /**
5988      * Defines a function to be called when some {@code Node} of this
5989      * {@code Scene} has input focus and a key has been typed. The function
5990      * is called only if the event hasn&#39;t been already consumed during its
5991      * capturing or bubbling phase.
5992      */
5993     private ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTyped;
5994 
5995     public final void setOnKeyTyped(
5996             EventHandler&lt;? super KeyEvent&gt; value) {
5997         onKeyTypedProperty().set( value);
5998 
5999     }
6000 
6001     public final EventHandler&lt;? super KeyEvent&gt; getOnKeyTyped(
6002             ) {
6003         return onKeyTyped == null ? null : onKeyTyped.get();
6004     }
6005 
6006     public final ObjectProperty&lt;EventHandler&lt;? super KeyEvent&gt;&gt; onKeyTypedProperty(
6007     ) {
6008         if (onKeyTyped == null) {
6009             onKeyTyped = new ObjectPropertyBase&lt;EventHandler&lt;? super KeyEvent&gt;&gt;() {
6010 
6011                 @Override
6012                 protected void invalidated() {
6013                     setEventHandler(KeyEvent.KEY_TYPED, get());
6014                 }
6015 
6016                 @Override
6017                 public Object getBean() {
6018                     return Scene.this;
6019                 }
6020 
6021                 @Override
6022                 public String getName() {
6023                     return &quot;onKeyTyped&quot;;
6024                 }
6025             };
6026         }
6027         return onKeyTyped;
6028     }
6029 
6030     /***************************************************************************
6031      *                                                                         *
6032      *                           Input Method Handling                         *
6033      *                                                                         *
6034      **************************************************************************/
6035 
6036     /**
6037      * Defines a function to be called when this {@code Node}
6038      * has input focus and the input method text has changed.  If this
6039      * function is not defined in this {@code Node}, then it
6040      * receives the result string of the input method composition as a
6041      * series of {@code onKeyTyped} function calls.
6042      * &lt;p&gt;
6043      * When the {@code Node} loses the input focus, the JavaFX runtime
6044      * automatically commits the existing composed text if any.
6045      */
6046     private ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChanged;
6047 
6048     public final void setOnInputMethodTextChanged(
6049             EventHandler&lt;? super InputMethodEvent&gt; value) {
6050         onInputMethodTextChangedProperty().set( value);
6051     }
6052 
6053     public final EventHandler&lt;? super InputMethodEvent&gt; getOnInputMethodTextChanged() {
6054         return onInputMethodTextChanged == null ? null : onInputMethodTextChanged.get();
6055     }
6056 
6057     public final ObjectProperty&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt; onInputMethodTextChangedProperty() {
6058         if (onInputMethodTextChanged == null) {
6059             onInputMethodTextChanged = new ObjectPropertyBase&lt;EventHandler&lt;? super InputMethodEvent&gt;&gt;() {
6060 
6061                 @Override
6062                 protected void invalidated() {
6063                     setEventHandler(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, get());
6064                 }
6065 
6066                 @Override
6067                 public Object getBean() {
6068                     return Scene.this;
6069                 }
6070 
6071                 @Override
6072                 public String getName() {
6073                     return &quot;onInputMethodTextChanged&quot;;
6074                 }
6075             };
6076         }
6077         return onInputMethodTextChanged;
6078     }
6079 
6080     /*
6081      * This class represents a picked target - either node, or scne, or null.
6082      * It provides functionality needed for the targets and covers the fact
6083      * that they are different kinds of animals.
6084      */
6085     private static class TargetWrapper {
6086         private Scene scene;
6087         private Node node;
6088         private PickResult result;
6089 
6090         /**
6091          * Fills the list with the target and all its parents (including scene)
6092          */
6093         public void fillHierarchy(final List&lt;EventTarget&gt; list) {
6094             list.clear();
6095             Node n = node;
6096             while(n != null) {
6097                 list.add(n);
6098                 final Parent p = n.getParent();
6099                 n = p != null ? p : n.getSubScene();
6100             }
6101 
6102             if (scene != null) {
6103                 list.add(scene);
6104             }
6105         }
6106 
6107         public EventTarget getEventTarget() {
6108             return node != null ? node : scene;
6109         }
6110 
6111         public Cursor getCursor() {
6112             Cursor cursor = null;
6113             if (node != null) {
6114                 cursor = node.getCursor();
6115                 Node n = node.getParent();
6116                 while (cursor == null &amp;&amp; n != null) {
6117                     cursor = n.getCursor();
6118 
6119                     final Parent p = n.getParent();
6120                     n = p != null ? p : n.getSubScene();
6121                 }
6122             }
6123             return cursor;
6124         }
6125 
6126         public void clear() {
6127             set(null, null);
6128             result = null;
6129         }
6130 
6131         public void setNodeResult(PickResult result) {
6132             if (result != null) {
6133                 this.result = result;
6134                 final Node n = result.getIntersectedNode();
6135                 set(n, n.getScene());
6136             }
6137         }
6138 
6139         // Pass null scene if the mouse is outside of the window content
6140         public void setSceneResult(PickResult result, Scene scene) {
6141             if (result != null) {
6142                 this.result = result;
6143                 set(null, scene);
6144             }
6145         }
6146 
6147         public PickResult getResult() {
6148             return result;
6149         }
6150 
6151         public void copy(TargetWrapper tw) {
6152             node = tw.node;
6153             scene = tw.scene;
6154             result = tw.result;
6155         }
6156 
6157         private void set(Node n, Scene s) {
6158             node = n;
6159             scene = s;
6160         }
6161     }
6162 
6163     /*************************************************************************
6164     *                                                                        *
6165     *                                                                        *
6166     *                                                                        *
6167     *************************************************************************/
6168 
6169     private static final Object USER_DATA_KEY = new Object();
6170     // A map containing a set of properties for this scene
6171     private ObservableMap&lt;Object, Object&gt; properties;
6172 
6173     /**
6174       * Returns an observable map of properties on this node for use primarily
6175       * by application developers.
6176       *
6177       * @return an observable map of properties on this node for use primarily
6178       * by application developers
6179       *
6180       * @since JavaFX 8u40
6181       */
6182      public final ObservableMap&lt;Object, Object&gt; getProperties() {
6183         if (properties == null) {
6184             properties = FXCollections.observableMap(new HashMap&lt;Object, Object&gt;());
6185         }
6186         return properties;
6187     }
6188 
6189     /**
6190      * Tests if Scene has properties.
6191      * @return true if node has properties.
6192      *
6193      * @since JavaFX 8u40
6194      */
6195      public boolean hasProperties() {
6196         return properties != null &amp;&amp; !properties.isEmpty();
6197     }
6198 
6199     /**
6200      * Convenience method for setting a single Object property that can be
6201      * retrieved at a later date. This is functionally equivalent to calling
6202      * the getProperties().put(Object key, Object value) method. This can later
6203      * be retrieved by calling {@link Scene#getUserData()}.
6204      *
6205      * @param value The value to be stored - this can later be retrieved by calling
6206      *          {@link Scene#getUserData()}.
6207      *
6208      * @since JavaFX 8u40
6209      */
6210     public void setUserData(Object value) {
6211         getProperties().put(USER_DATA_KEY, value);
6212     }
6213 
6214     /**
6215      * Returns a previously set Object property, or null if no such property
6216      * has been set using the {@link Scene#setUserData(java.lang.Object)} method.
6217      *
6218      * @return The Object that was previously set, or null if no property
6219      *          has been set or if null was set.
6220      *
6221      * @since JavaFX 8u40
6222      */
6223     public Object getUserData() {
6224         return getProperties().get(USER_DATA_KEY);
6225     }
6226 
6227     /***************************************************************************
6228      *                                                                         *
6229      *                       Component Orientation Properties                  *
6230      *                                                                         *
6231      **************************************************************************/
6232 
6233     private static final NodeOrientation defaultNodeOrientation =
6234         AccessController.doPrivileged(
6235                 (PrivilegedAction&lt;Boolean&gt;) () -&gt; Boolean.getBoolean(&quot;javafx.scene.nodeOrientation.RTL&quot;)) ? NodeOrientation.RIGHT_TO_LEFT : NodeOrientation.INHERIT;
6236 
6237 
6238 
6239     private ObjectProperty&lt;NodeOrientation&gt; nodeOrientation;
6240     private EffectiveOrientationProperty effectiveNodeOrientationProperty;
6241 
6242     private NodeOrientation effectiveNodeOrientation;
6243 
6244     public final void setNodeOrientation(NodeOrientation orientation) {
6245         nodeOrientationProperty().set(orientation);
6246     }
6247 
6248     public final NodeOrientation getNodeOrientation() {
6249         return nodeOrientation == null ? defaultNodeOrientation : nodeOrientation.get();
6250     }
6251 
6252     /**
6253      * Property holding NodeOrientation.
6254      * &lt;p&gt;
6255      * Node orientation describes the flow of visual data within a node.
6256      * In the English speaking world, visual data normally flows from
6257      * left-to-right. In an Arabic or Hebrew world, visual data flows
6258      * from right-to-left.  This is consistent with the reading order
6259      * of text in both worlds.  The default value is left-to-right.
6260      * &lt;/p&gt;
6261      *
6262      * @return NodeOrientation
6263      * @since JavaFX 8.0
6264      */
6265     public final ObjectProperty&lt;NodeOrientation&gt; nodeOrientationProperty() {
6266         if (nodeOrientation == null) {
6267             nodeOrientation = new StyleableObjectProperty&lt;NodeOrientation&gt;(defaultNodeOrientation) {
6268                 @Override
6269                 protected void invalidated() {
6270                     sceneEffectiveOrientationInvalidated();
6271                     getRoot().applyCss();
6272                 }
6273 
6274                 @Override
6275                 public Object getBean() {
6276                     return Scene.this;
6277                 }
6278 
6279                 @Override
6280                 public String getName() {
6281                     return &quot;nodeOrientation&quot;;
6282                 }
6283 
6284                 @Override
6285                 public CssMetaData getCssMetaData() {
6286                     //TODO - not yet supported
6287                     throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);
6288                 }
6289             };
6290         }
6291         return nodeOrientation;
6292     }
6293 
6294     public final NodeOrientation getEffectiveNodeOrientation() {
6295         if (effectiveNodeOrientation == null) {
6296             effectiveNodeOrientation = calcEffectiveNodeOrientation();
6297         }
6298 
6299         return effectiveNodeOrientation;
6300     }
6301 
6302     /**
6303      * The effective node orientation of a scene resolves the inheritance of
6304      * node orientation, returning either left-to-right or right-to-left.
6305      * @return the effective node orientation of this scene
6306      * @since JavaFX 8.0
6307      */
6308     public final ReadOnlyObjectProperty&lt;NodeOrientation&gt;
6309             effectiveNodeOrientationProperty() {
6310         if (effectiveNodeOrientationProperty == null) {
6311             effectiveNodeOrientationProperty =
6312                     new EffectiveOrientationProperty();
6313         }
6314 
6315         return effectiveNodeOrientationProperty;
6316     }
6317 
6318     private void parentEffectiveOrientationInvalidated() {
6319         if (getNodeOrientation() == NodeOrientation.INHERIT) {
6320             sceneEffectiveOrientationInvalidated();
6321         }
6322     }
6323 
6324     private void sceneEffectiveOrientationInvalidated() {
6325         effectiveNodeOrientation = null;
6326 
6327         if (effectiveNodeOrientationProperty != null) {
6328             effectiveNodeOrientationProperty.invalidate();
6329         }
6330 
6331         getRoot().parentResolvedOrientationInvalidated();
6332     }
6333 
6334     private NodeOrientation calcEffectiveNodeOrientation() {
6335         NodeOrientation orientation = getNodeOrientation();
6336         if (orientation == NodeOrientation.INHERIT) {
6337             Window window = getWindow();
6338             if (window != null) {
6339                 Window parent = null;
6340                 if (window instanceof Stage) {
6341                     parent = ((Stage)window).getOwner();
6342                 } else {
6343                     if (window instanceof PopupWindow) {
6344                         parent = ((PopupWindow)window).getOwnerWindow();
6345                     }
6346                 }
6347                 if (parent != null) {
6348                     Scene scene = parent.getScene();
6349                     if (scene != null) return scene.getEffectiveNodeOrientation();
6350                 }
6351             }
6352             return NodeOrientation.LEFT_TO_RIGHT;
6353         }
6354         return orientation;
6355     }
6356 
6357     private final class EffectiveOrientationProperty
6358             extends ReadOnlyObjectPropertyBase&lt;NodeOrientation&gt; {
6359         @Override
6360         public NodeOrientation get() {
6361             return getEffectiveNodeOrientation();
6362         }
6363 
6364         @Override
6365         public Object getBean() {
6366             return Scene.this;
6367         }
6368 
6369         @Override
6370         public String getName() {
6371             return &quot;effectiveNodeOrientation&quot;;
6372         }
6373 
6374         public void invalidate() {
6375             fireValueChangedEvent();
6376         }
6377     }
6378 
6379     private Map&lt;Node, Accessible&gt; accMap;
6380     Accessible removeAccessible(Node node) {
6381         if (accMap == null) return null;
6382         return accMap.remove(node);
6383     }
6384 
6385     void addAccessible(Node node, Accessible acc) {
6386         if (accMap == null) {
6387             accMap = new HashMap&lt;Node, Accessible&gt;();
6388         }
6389         accMap.put(node, acc);
6390     }
6391 
6392     private void disposeAccessibles() {
6393         if (accMap != null) {
6394             for (Map.Entry&lt;Node, Accessible&gt; entry : accMap.entrySet()) {
6395                 Node node = entry.getKey();
6396                 Accessible acc = entry.getValue();
6397                 if (node.accessible != null) {
6398                     /* This node has already been initialized to another scene.
6399                      * Note an accessible can be returned to the node before the
6400                      * pulse if getAccessible() is called. In which case it must
6401                      * already being removed from accMap.
6402                      */
6403                     if (node.accessible == acc) {
6404                         System.err.println(&quot;[A11y] &#39;node.accessible == acc&#39; should never happen.&quot;);
6405                     }
6406                     if (node.getScene() == this) {
6407                         System.err.println(&quot;[A11y] &#39;node.getScene() == this&#39; should never happen.&quot;);
6408                     }
6409                     acc.dispose();
6410                 } else {
6411                     if (node.getScene() == this) {
6412                         node.accessible = acc;
6413                     } else {
6414                         acc.dispose();
6415                     }
6416                 }
6417             }
6418             accMap.clear();
6419         }
6420     }
6421 
6422     private Accessible accessible;
6423     Accessible getAccessible() {
6424         /*
6425          * The accessible for the Scene should never be
6426          * requested when the peer is not set.
6427          * This can only happen in a error case where a
6428          * descender of this Scene was not disposed and
6429          * it still being used by the AT client and trying
6430          * to reach to the top level window.
6431          */
6432         if (peer == null) return null;
6433         if (accessible == null) {
6434             accessible = Application.GetApplication().createAccessible();
6435             accessible.setEventHandler(new Accessible.EventHandler() {
6436                 @Override public AccessControlContext getAccessControlContext() {
6437                     return getPeer().getAccessControlContext();
6438                 }
6439 
6440                 @Override public Object getAttribute(AccessibleAttribute attribute,
6441                                                      Object... parameters) {
6442                     switch (attribute) {
6443                         case CHILDREN: {
6444                             Parent root = getRoot();
6445                             if (root != null) {
6446                                 return FXCollections.observableArrayList(root);
6447                             }
6448                             break;
6449                         }
6450                         case TEXT: {
6451                             Window w = getWindow();
6452                             if (w instanceof Stage) {
6453                                 return ((Stage)w).getTitle();
6454                             }
6455                             break;
6456                         }
6457                         case NODE_AT_POINT: {
6458                             Window window = getWindow();
6459                             /* is this screen to scene translation correct ? not considering camera ? */
6460                             Point2D pt = (Point2D)parameters[0];
6461                             PickResult res = pick(pt.getX() - getX() - window.getX(), pt.getY() - getY() - window.getY());
6462                             if (res != null) {
6463                                 Node node = res.getIntersectedNode();
6464                                 if (node != null) return node;
6465                             }
6466                             return getRoot();//not sure
6467                         }
6468                         case ROLE: return AccessibleRole.PARENT;
6469                         case SCENE: return Scene.this;
6470                         case FOCUS_NODE: {
6471                             if (transientFocusContainer != null) {
6472                                 return transientFocusContainer.queryAccessibleAttribute(AccessibleAttribute.FOCUS_NODE);
6473                             }
6474                             return getFocusOwner();
6475                         }
6476                         default:
6477                     }
6478                     return super.getAttribute(attribute, parameters);
6479                 }
6480             });
6481             PlatformImpl.accessibilityActiveProperty().set(true);
6482         }
6483         return accessible;
6484     }
6485 }
    </pre>
  </body>
</html>
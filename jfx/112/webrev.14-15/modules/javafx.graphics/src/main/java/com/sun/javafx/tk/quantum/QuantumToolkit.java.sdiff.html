<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/com/sun/javafx/tk/quantum/QuantumToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/com/sun/javafx/tk/quantum/QuantumToolkit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1550 
1551                 if (w &lt;= 0 || h &lt;= 0) {
1552                     return;
1553                 }
1554 
1555                 boolean errored = false;
1556                 // A temp QuantumImage used only as a RTT cache for rendering tiles.
1557                 QuantumImage tileRttCache = null;
1558                 try {
1559                     QuantumImage pImage = (params.platformImage instanceof QuantumImage) ?
1560                             (QuantumImage) params.platformImage : new QuantumImage((com.sun.prism.Image) null);
1561 
1562                     int maxTextureSize = rf.getMaximumTextureSize();
1563                     if (h &gt; maxTextureSize || w &gt; maxTextureSize) {
1564                         tileRttCache = new QuantumImage((com.sun.prism.Image) null);
1565                         // The requested size for the snapshot is too big to fit a single texture,
1566                         // so we need to take several snapshot tiles and merge them into pImage
1567                         if (pImage.image == null) {
1568                             pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(IntBuffer.allocate(w * h), w, h));
1569                         }
<span class="line-removed">1570                         // Determine the initial dimensions of the tiles</span>
<span class="line-removed">1571                         int tileWidth = computeTileSize(w, maxTextureSize);</span>
<span class="line-removed">1572                         int tileHeight = computeTileSize(h, maxTextureSize);</span>
<span class="line-removed">1573                         IntBuffer buffer = IntBuffer.allocate(tileWidth * tileHeight);</span>
1574 
1575                         // M represents the middle set of tiles each with a size of tileW x tileH.
1576                         // R is the right hand column of tiles,
1577                         // B is the bottom row,
1578                         // C is the corner:
1579                         // +-----------+-----------+  .  +-------+
1580                         // |           |           |  .  |       |
1581                         // |     M     |     M     |  .  |   R   |
1582                         // |           |           |  .  |       |
1583                         // +-----------+-----------+  .  +-------+
1584                         // |           |           |  .  |       |
1585                         // |     M     |     M     |  .  |   R   |
1586                         // |           |           |  .  |       |
1587                         // +-----------+-----------+  .  +-------+
1588                         //       .           .        .      .
1589                         // +-----------+-----------+  .  +-------+
1590                         // |     B     |     B     |  .  |   C   |
1591                         // +-----------+-----------+  .  +-------+
<span class="line-modified">1592 </span>


1593                         // Walk through all same-size &quot;M&quot; tiles
<span class="line-modified">1594                         int xOffset = 0;</span>
<span class="line-modified">1595                         int yOffset = 0;</span>
<span class="line-modified">1596                         var mTileWidth = tileWidth;</span>
<span class="line-modified">1597                         var mTileHeight = tileHeight;</span>
<span class="line-modified">1598                         while (mTileWidth == tileWidth &amp;&amp; xOffset &lt; w) {</span>
<span class="line-removed">1599                             yOffset = 0;</span>
<span class="line-removed">1600                             mTileHeight = tileHeight;</span>
<span class="line-removed">1601                             while (mTileHeight == tileHeight &amp;&amp; yOffset &lt; h) {</span>
<span class="line-removed">1602                                 renderTile(x, xOffset, y, yOffset, mTileWidth, mTileHeight,</span>
1603                                         buffer, rf, tileRttCache, pImage);
<span class="line-removed">1604                                 yOffset += tileHeight;</span>
<span class="line-removed">1605                                 mTileHeight = Math.min(tileHeight, h - yOffset);</span>
1606                             }
<span class="line-removed">1607                             xOffset += tileWidth;</span>
<span class="line-removed">1608                             mTileWidth = Math.min(tileWidth, w - xOffset);</span>
1609                         }
1610                         // Walk through remaining same-height &quot;R&quot; tiles, if any
<span class="line-modified">1611                         int rOffset = 0;</span>
<span class="line-modified">1612                         int rTileHeight = tileHeight;</span>
<span class="line-modified">1613                         if (mTileWidth &gt; 0) {</span>
<span class="line-modified">1614                             while (rTileHeight == tileHeight &amp;&amp; rOffset &lt; h) {</span>
<span class="line-modified">1615                                 renderTile(x, xOffset, y, rOffset, mTileWidth, rTileHeight, buffer, rf, tileRttCache, pImage);</span>
<span class="line-modified">1616                                 rOffset += tileHeight;</span>
<span class="line-removed">1617                                 rTileHeight = Math.min(tileHeight, h - rOffset);</span>
1618                             }
1619                         }
1620                         // Walk through remaining same-width &quot;B&quot; tiles, if any
<span class="line-modified">1621                         int bOffset = 0;</span>
<span class="line-modified">1622                         int bTileWidth = tileWidth;</span>
<span class="line-modified">1623                         if (mTileHeight &gt; 0) {</span>
<span class="line-modified">1624                             while (bTileWidth == tileWidth &amp;&amp; bOffset &lt; w) {</span>
<span class="line-modified">1625                                 renderTile(x, bOffset, y, yOffset, bTileWidth, mTileHeight, buffer, rf, tileRttCache, pImage);</span>
<span class="line-modified">1626                                 bOffset += tileWidth;</span>
<span class="line-removed">1627                                 bTileWidth = Math.min(tileWidth, w - bOffset);</span>
1628                             }
1629                         }
1630                         // Render corner &quot;C&quot; tile if needed
<span class="line-modified">1631                         if (mTileWidth &gt; 0 &amp;&amp; mTileHeight &gt; 0 &amp;&amp; rOffset &gt; 0 &amp;&amp; bOffset &gt; 0) {</span>
<span class="line-modified">1632                             renderTile(x, bOffset, y, rOffset, bTileWidth, rTileHeight, buffer, rf, tileRttCache, pImage);</span>

1633                         }
1634                     }
1635                     else {
1636                         // The requested size for the snapshot fits max texture size,
1637                         // so we can directly render it in the target image.
1638                         renderWholeImage(x, y, w, h, rf, pImage);
1639                     }
1640                     params.platformImage = pImage;
1641                 } catch (Throwable t) {
1642                     errored = true;
1643                     t.printStackTrace(System.err);
1644                 } finally {
1645                     if (tileRttCache != null) {
1646                         tileRttCache.dispose();
1647                     }
1648                     Disposer.cleanUp();
1649                     rf.getTextureResourcePool().freeDisposalRequestedAndCheckResources(errored);
1650                 }
1651             }
1652         });
</pre>
</td>
<td>
<hr />
<pre>
1550 
1551                 if (w &lt;= 0 || h &lt;= 0) {
1552                     return;
1553                 }
1554 
1555                 boolean errored = false;
1556                 // A temp QuantumImage used only as a RTT cache for rendering tiles.
1557                 QuantumImage tileRttCache = null;
1558                 try {
1559                     QuantumImage pImage = (params.platformImage instanceof QuantumImage) ?
1560                             (QuantumImage) params.platformImage : new QuantumImage((com.sun.prism.Image) null);
1561 
1562                     int maxTextureSize = rf.getMaximumTextureSize();
1563                     if (h &gt; maxTextureSize || w &gt; maxTextureSize) {
1564                         tileRttCache = new QuantumImage((com.sun.prism.Image) null);
1565                         // The requested size for the snapshot is too big to fit a single texture,
1566                         // so we need to take several snapshot tiles and merge them into pImage
1567                         if (pImage.image == null) {
1568                             pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(IntBuffer.allocate(w * h), w, h));
1569                         }




1570 
1571                         // M represents the middle set of tiles each with a size of tileW x tileH.
1572                         // R is the right hand column of tiles,
1573                         // B is the bottom row,
1574                         // C is the corner:
1575                         // +-----------+-----------+  .  +-------+
1576                         // |           |           |  .  |       |
1577                         // |     M     |     M     |  .  |   R   |
1578                         // |           |           |  .  |       |
1579                         // +-----------+-----------+  .  +-------+
1580                         // |           |           |  .  |       |
1581                         // |     M     |     M     |  .  |   R   |
1582                         // |           |           |  .  |       |
1583                         // +-----------+-----------+  .  +-------+
1584                         //       .           .        .      .
1585                         // +-----------+-----------+  .  +-------+
1586                         // |     B     |     B     |  .  |   C   |
1587                         // +-----------+-----------+  .  +-------+
<span class="line-modified">1588                         final int mTileWidth = computeTileSize(w, maxTextureSize);</span>
<span class="line-added">1589                         final int mTileHeight = computeTileSize(h, maxTextureSize);</span>
<span class="line-added">1590                         IntBuffer buffer = IntBuffer.allocate(mTileWidth * mTileHeight);</span>
1591                         // Walk through all same-size &quot;M&quot; tiles
<span class="line-modified">1592                         int mTileXOffset = 0;</span>
<span class="line-modified">1593                         int mTileYOffset = 0;</span>
<span class="line-modified">1594                         for (mTileXOffset = 0; (mTileXOffset + mTileWidth) &lt;= w; mTileXOffset += mTileWidth) {</span>
<span class="line-modified">1595                             for (mTileYOffset = 0; (mTileYOffset + mTileHeight) &lt;= h; mTileYOffset += mTileHeight) {</span>
<span class="line-modified">1596                                 renderTile(x, mTileXOffset, y, mTileYOffset, mTileWidth, mTileHeight,</span>




1597                                         buffer, rf, tileRttCache, pImage);


1598                             }


1599                         }
1600                         // Walk through remaining same-height &quot;R&quot; tiles, if any
<span class="line-modified">1601                         final int rTileXOffset = mTileXOffset;</span>
<span class="line-modified">1602                         final int rTileWidth = w - rTileXOffset;</span>
<span class="line-modified">1603                         if (rTileWidth &gt; 0) {</span>
<span class="line-modified">1604                             for (int rTileYOffset = 0; (rTileYOffset + mTileHeight) &lt;= h; rTileYOffset += mTileHeight) {</span>
<span class="line-modified">1605                                 renderTile(x, rTileXOffset, y, rTileYOffset, rTileWidth, mTileHeight,</span>
<span class="line-modified">1606                                         buffer, rf, tileRttCache, pImage);</span>

1607                             }
1608                         }
1609                         // Walk through remaining same-width &quot;B&quot; tiles, if any
<span class="line-modified">1610                         final int bTileYOffset = mTileYOffset;</span>
<span class="line-modified">1611                         final int bTileHeight = h - bTileYOffset;</span>
<span class="line-modified">1612                         if (bTileHeight &gt; 0) {</span>
<span class="line-modified">1613                             for (int bTileXOffset = 0; (bTileXOffset + mTileWidth) &lt;= w; bTileXOffset += mTileWidth) {</span>
<span class="line-modified">1614                                 renderTile(x, bTileXOffset, y, bTileYOffset, mTileWidth, bTileHeight,</span>
<span class="line-modified">1615                                         buffer, rf, tileRttCache, pImage);</span>

1616                             }
1617                         }
1618                         // Render corner &quot;C&quot; tile if needed
<span class="line-modified">1619                         if (rTileWidth &gt; 0 &amp;&amp;  bTileHeight &gt; 0) {</span>
<span class="line-modified">1620                             renderTile(x, rTileXOffset, y, bTileYOffset, rTileWidth, bTileHeight,</span>
<span class="line-added">1621                                     buffer, rf, tileRttCache, pImage);</span>
1622                         }
1623                     }
1624                     else {
1625                         // The requested size for the snapshot fits max texture size,
1626                         // so we can directly render it in the target image.
1627                         renderWholeImage(x, y, w, h, rf, pImage);
1628                     }
1629                     params.platformImage = pImage;
1630                 } catch (Throwable t) {
1631                     errored = true;
1632                     t.printStackTrace(System.err);
1633                 } finally {
1634                     if (tileRttCache != null) {
1635                         tileRttCache.dispose();
1636                     }
1637                     Disposer.cleanUp();
1638                     rf.getTextureResourcePool().freeDisposalRequestedAndCheckResources(errored);
1639                 }
1640             }
1641         });
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
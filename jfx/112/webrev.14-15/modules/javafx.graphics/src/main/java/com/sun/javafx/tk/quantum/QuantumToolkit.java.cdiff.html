<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/java/com/sun/javafx/tk/quantum/QuantumToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>modules/javafx.graphics/src/main/java/com/sun/javafx/tk/quantum/QuantumToolkit.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1565,14 ***</span>
                          // The requested size for the snapshot is too big to fit a single texture,
                          // so we need to take several snapshot tiles and merge them into pImage
                          if (pImage.image == null) {
                              pImage.setImage(com.sun.prism.Image.fromIntArgbPreData(IntBuffer.allocate(w * h), w, h));
                          }
<span class="line-removed">-                         // Determine the initial dimensions of the tiles</span>
<span class="line-removed">-                         int tileWidth = computeTileSize(w, maxTextureSize);</span>
<span class="line-removed">-                         int tileHeight = computeTileSize(h, maxTextureSize);</span>
<span class="line-removed">-                         IntBuffer buffer = IntBuffer.allocate(tileWidth * tileHeight);</span>
  
                          // M represents the middle set of tiles each with a size of tileW x tileH.
                          // R is the right hand column of tiles,
                          // B is the bottom row,
                          // C is the corner:
<span class="line-new-header">--- 1565,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1587,51 ***</span>
                          // +-----------+-----------+  .  +-------+
                          //       .           .        .      .
                          // +-----------+-----------+  .  +-------+
                          // |     B     |     B     |  .  |   C   |
                          // +-----------+-----------+  .  +-------+
<span class="line-modified">! </span>
                          // Walk through all same-size &quot;M&quot; tiles
<span class="line-modified">!                         int xOffset = 0;</span>
<span class="line-modified">!                         int yOffset = 0;</span>
<span class="line-modified">!                         var mTileWidth = tileWidth;</span>
<span class="line-modified">!                         var mTileHeight = tileHeight;</span>
<span class="line-modified">!                         while (mTileWidth == tileWidth &amp;&amp; xOffset &lt; w) {</span>
<span class="line-removed">-                             yOffset = 0;</span>
<span class="line-removed">-                             mTileHeight = tileHeight;</span>
<span class="line-removed">-                             while (mTileHeight == tileHeight &amp;&amp; yOffset &lt; h) {</span>
<span class="line-removed">-                                 renderTile(x, xOffset, y, yOffset, mTileWidth, mTileHeight,</span>
                                          buffer, rf, tileRttCache, pImage);
<span class="line-removed">-                                 yOffset += tileHeight;</span>
<span class="line-removed">-                                 mTileHeight = Math.min(tileHeight, h - yOffset);</span>
                              }
<span class="line-removed">-                             xOffset += tileWidth;</span>
<span class="line-removed">-                             mTileWidth = Math.min(tileWidth, w - xOffset);</span>
                          }
                          // Walk through remaining same-height &quot;R&quot; tiles, if any
<span class="line-modified">!                         int rOffset = 0;</span>
<span class="line-modified">!                         int rTileHeight = tileHeight;</span>
<span class="line-modified">!                         if (mTileWidth &gt; 0) {</span>
<span class="line-modified">!                             while (rTileHeight == tileHeight &amp;&amp; rOffset &lt; h) {</span>
<span class="line-modified">!                                 renderTile(x, xOffset, y, rOffset, mTileWidth, rTileHeight, buffer, rf, tileRttCache, pImage);</span>
<span class="line-modified">!                                 rOffset += tileHeight;</span>
<span class="line-removed">-                                 rTileHeight = Math.min(tileHeight, h - rOffset);</span>
                              }
                          }
                          // Walk through remaining same-width &quot;B&quot; tiles, if any
<span class="line-modified">!                         int bOffset = 0;</span>
<span class="line-modified">!                         int bTileWidth = tileWidth;</span>
<span class="line-modified">!                         if (mTileHeight &gt; 0) {</span>
<span class="line-modified">!                             while (bTileWidth == tileWidth &amp;&amp; bOffset &lt; w) {</span>
<span class="line-modified">!                                 renderTile(x, bOffset, y, yOffset, bTileWidth, mTileHeight, buffer, rf, tileRttCache, pImage);</span>
<span class="line-modified">!                                 bOffset += tileWidth;</span>
<span class="line-removed">-                                 bTileWidth = Math.min(tileWidth, w - bOffset);</span>
                              }
                          }
                          // Render corner &quot;C&quot; tile if needed
<span class="line-modified">!                         if (mTileWidth &gt; 0 &amp;&amp; mTileHeight &gt; 0 &amp;&amp; rOffset &gt; 0 &amp;&amp; bOffset &gt; 0) {</span>
<span class="line-modified">!                             renderTile(x, bOffset, y, rOffset, bTileWidth, rTileHeight, buffer, rf, tileRttCache, pImage);</span>
                          }
                      }
                      else {
                          // The requested size for the snapshot fits max texture size,
                          // so we can directly render it in the target image.
<span class="line-new-header">--- 1583,44 ---</span>
                          // +-----------+-----------+  .  +-------+
                          //       .           .        .      .
                          // +-----------+-----------+  .  +-------+
                          // |     B     |     B     |  .  |   C   |
                          // +-----------+-----------+  .  +-------+
<span class="line-modified">!                         final int mTileWidth = computeTileSize(w, maxTextureSize);</span>
<span class="line-added">+                         final int mTileHeight = computeTileSize(h, maxTextureSize);</span>
<span class="line-added">+                         IntBuffer buffer = IntBuffer.allocate(mTileWidth * mTileHeight);</span>
                          // Walk through all same-size &quot;M&quot; tiles
<span class="line-modified">!                         int mTileXOffset = 0;</span>
<span class="line-modified">!                         int mTileYOffset = 0;</span>
<span class="line-modified">!                         for (mTileXOffset = 0; (mTileXOffset + mTileWidth) &lt;= w; mTileXOffset += mTileWidth) {</span>
<span class="line-modified">!                             for (mTileYOffset = 0; (mTileYOffset + mTileHeight) &lt;= h; mTileYOffset += mTileHeight) {</span>
<span class="line-modified">!                                 renderTile(x, mTileXOffset, y, mTileYOffset, mTileWidth, mTileHeight,</span>
                                          buffer, rf, tileRttCache, pImage);
                              }
                          }
                          // Walk through remaining same-height &quot;R&quot; tiles, if any
<span class="line-modified">!                         final int rTileXOffset = mTileXOffset;</span>
<span class="line-modified">!                         final int rTileWidth = w - rTileXOffset;</span>
<span class="line-modified">!                         if (rTileWidth &gt; 0) {</span>
<span class="line-modified">!                             for (int rTileYOffset = 0; (rTileYOffset + mTileHeight) &lt;= h; rTileYOffset += mTileHeight) {</span>
<span class="line-modified">!                                 renderTile(x, rTileXOffset, y, rTileYOffset, rTileWidth, mTileHeight,</span>
<span class="line-modified">!                                         buffer, rf, tileRttCache, pImage);</span>
                              }
                          }
                          // Walk through remaining same-width &quot;B&quot; tiles, if any
<span class="line-modified">!                         final int bTileYOffset = mTileYOffset;</span>
<span class="line-modified">!                         final int bTileHeight = h - bTileYOffset;</span>
<span class="line-modified">!                         if (bTileHeight &gt; 0) {</span>
<span class="line-modified">!                             for (int bTileXOffset = 0; (bTileXOffset + mTileWidth) &lt;= w; bTileXOffset += mTileWidth) {</span>
<span class="line-modified">!                                 renderTile(x, bTileXOffset, y, bTileYOffset, mTileWidth, bTileHeight,</span>
<span class="line-modified">!                                         buffer, rf, tileRttCache, pImage);</span>
                              }
                          }
                          // Render corner &quot;C&quot; tile if needed
<span class="line-modified">!                         if (rTileWidth &gt; 0 &amp;&amp;  bTileHeight &gt; 0) {</span>
<span class="line-modified">!                             renderTile(x, rTileXOffset, y, bTileYOffset, rTileWidth, bTileHeight,</span>
<span class="line-added">+                                     buffer, rf, tileRttCache, pImage);</span>
                          }
                      }
                      else {
                          // The requested size for the snapshot fits max texture size,
                          // so we can directly render it in the target image.
</pre>
<center>&lt; prev <a href="../../../../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
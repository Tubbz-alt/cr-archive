diff a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/ps/PaintHelper.java b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/ps/PaintHelper.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/impl/ps/PaintHelper.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/impl/ps/PaintHelper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -748,10 +748,15 @@
 
         // calculate plane equation constants
         Affine3D at = scratchXform3D;
         g.getPaintShaderTransform(at);
 
+        BaseTransform paintXform = paint.getPatternTransformNoClone();
+        if (paintXform != null) {
+            at.concatenate(paintXform);
+        }
+
         at.translate(x1, y1);
         at.scale(x2 - x1, y2 - y1);
         // Adjustment for case when WrapMode.REPEAT is simulated
         if (cw < texw) {
             at.translate(0.5/cw, 0.0);
@@ -847,19 +852,21 @@
         float texh = paintTex.getPhysicalHeight();
         paintTex.unlock();
 
         // calculate plane equation constants
         AffineBase ret;
-        if (renderTx.isIdentity()) {
+        BaseTransform paintXform = paint.getPatternTransformNoClone();
+        if (paintXform.isIdentity() && renderTx.isIdentity()) {
             Affine2D at = scratchXform2D;
 
             at.setToTranslation(px, py);
             at.scale(pw, ph);
             ret = at;
         } else {
             Affine3D at = scratchXform3D;
             at.setTransform(renderTx);
+            at.concatenate(paintXform);
 
             at.translate(px, py);
             at.scale(pw, ph);
             ret = at;
         }
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/paint/ImagePattern.java b/modules/javafx.graphics/src/main/java/com/sun/prism/paint/ImagePattern.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/paint/ImagePattern.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/paint/ImagePattern.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,22 +23,25 @@
  * questions.
  */
 
 package com.sun.prism.paint;
 
+import com.sun.javafx.geom.transform.BaseTransform;
 import com.sun.prism.Image;
 
 public final class ImagePattern extends Paint {
 
     private final Image image;
     private final float x;
     private final float y;
     private final float width;
     private final float height;
+    private final BaseTransform patternTransform;
 
     public ImagePattern(Image image,
                         float x, float y, float width, float height,
+                        BaseTransform patternTransform,
                         boolean proportional, boolean isMutable)
     {
         super(Type.IMAGE_PATTERN, proportional, isMutable);
         if (image == null) {
             throw new IllegalArgumentException("Image must be non-null");
@@ -46,10 +49,22 @@
         this.image = image;
         this.x = x;
         this.y = y;
         this.width = width;
         this.height = height;
+        if (patternTransform != null) {
+            this.patternTransform = patternTransform.copy();
+        } else {
+            this.patternTransform = BaseTransform.IDENTITY_TRANSFORM;
+        }
+    }
+
+    public ImagePattern(Image image,
+                        float x, float y, float width, float height,
+                        boolean proportional, boolean isMutable)
+    {
+        this(image, x, y, width, height, null, proportional, isMutable);
     }
 
     public Image getImage() {
         return image;
     }
@@ -68,9 +83,13 @@
 
     public float getHeight() {
         return height;
     }
 
+    public BaseTransform getPatternTransformNoClone() {
+        return patternTransform;
+    }
+
     public boolean isOpaque() {
         return image.isOpaque();
     }
 }
diff a/modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java b/modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java
--- a/modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java
+++ b/modules/javafx.web/src/main/java/com/sun/javafx/webkit/prism/WCGraphicsPrismContext.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -771,36 +771,31 @@
             return;
         }
         if (texture != null) {
             new Composite() {
                 @Override void doPaint(Graphics g) {
-                    // The handling of pattern transform is modeled after the WebKit
-                    // ImageCG.cpp's Image::drawPattern()
-                    float adjustedX = phase.getX()
-                            + srcRect.getX() * (float) patternTransform.getMatrix()[0];
-                    float adjustedY = phase.getY()
-                            + srcRect.getY() * (float) patternTransform.getMatrix()[3];
-                    float scaledTileWidth =
-                            srcRect.getWidth() * (float) patternTransform.getMatrix()[0];
-                    float scaledTileHeight =
-                            srcRect.getHeight() * (float) patternTransform.getMatrix()[3];
-
                     Image img = ((PrismImage)texture).getImage();
 
                     // Create subImage only if srcRect doesn't fit the texture bounds. See RT-20193.
                     if (!srcRect.contains(new WCRectangle(0, 0, texture.getWidth(), texture.getHeight()))) {
 
                         img = img.createSubImage(srcRect.getIntX(),
                                                  srcRect.getIntY(),
                                                  (int)Math.ceil(srcRect.getWidth()),
                                                  (int)Math.ceil(srcRect.getHeight()));
                     }
+
+                    double m[] = patternTransform.getMatrix();
+                    Affine3D at = new Affine3D();
+                    at.translate(phase.getX(), phase.getY());
+                    at.concatenate(m[0], m[1], m[4], m[2], m[3], m[5]);
+
                     g.setPaint(new ImagePattern(
                                img,
-                               adjustedX, adjustedY,
-                               scaledTileWidth, scaledTileHeight,
-                               false, false));
+                               srcRect.getX(), srcRect.getY(),
+                               srcRect.getWidth(), srcRect.getHeight(),
+                               at, false, false));
 
                     g.fillRect(destRect.getX(), destRect.getY(),
                                destRect.getWidth(), destRect.getHeight());
                 }
             }.paint();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSCanvasValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCrossfadeValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, write to the Free Software
  21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  22  * 02110-1301  USA
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 
  28 #include &quot;BasicShapeFunctions.h&quot;
  29 #include &quot;CSSAnimationController.h&quot;
  30 #include &quot;CSSAspectRatioValue.h&quot;
  31 #include &quot;CSSBasicShapes.h&quot;
  32 #include &quot;CSSBorderImage.h&quot;
  33 #include &quot;CSSBorderImageSliceValue.h&quot;
  34 #include &quot;CSSFontFeatureValue.h&quot;
  35 #include &quot;CSSFontStyleValue.h&quot;
  36 #include &quot;CSSFontValue.h&quot;
  37 #include &quot;CSSFontVariationValue.h&quot;
  38 #include &quot;CSSFunctionValue.h&quot;

  39 #include &quot;CSSLineBoxContainValue.h&quot;
  40 #include &quot;CSSPrimitiveValue.h&quot;
  41 #include &quot;CSSPrimitiveValueMappings.h&quot;
  42 #include &quot;CSSPropertyNames.h&quot;
  43 #include &quot;CSSPropertyParser.h&quot;
  44 #include &quot;CSSReflectValue.h&quot;
  45 #include &quot;CSSSelector.h&quot;
  46 #include &quot;CSSShadowValue.h&quot;
  47 #include &quot;CSSTimingFunctionValue.h&quot;
  48 #include &quot;CSSValueList.h&quot;
  49 #include &quot;CSSValuePool.h&quot;
  50 #include &quot;ComposedTreeAncestorIterator.h&quot;
  51 #include &quot;ContentData.h&quot;
  52 #include &quot;CursorList.h&quot;
  53 #include &quot;DeprecatedCSSOMValue.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentTimeline.h&quot;
  56 #include &quot;FontCascade.h&quot;
  57 #include &quot;FontSelectionValueInlines.h&quot;
  58 #include &quot;FontTaggedSettings.h&quot;
  59 #include &quot;NodeRenderStyle.h&quot;
  60 #include &quot;Pair.h&quot;
  61 #include &quot;Rect.h&quot;
  62 #include &quot;RenderBlock.h&quot;
  63 #include &quot;RenderBox.h&quot;
  64 #include &quot;RenderInline.h&quot;
  65 #include &quot;RenderStyle.h&quot;
<span class="line-removed">  66 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
  79 #include &lt;wtf/IsoMallocInlines.h&gt;
  80 #include &lt;wtf/NeverDestroyed.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 #include &quot;CSSGridLineNamesValue.h&quot;
  84 #include &quot;CSSGridTemplateAreasValue.h&quot;
  85 #include &quot;RenderGrid.h&quot;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
  90 
<span class="line-modified">  91 // List of all properties we know how to compute, omitting shorthands.</span>
<span class="line-removed">  92 static const CSSPropertyID computedProperties[] = {</span>
<span class="line-removed">  93     CSSPropertyAlignContent,</span>
<span class="line-removed">  94     CSSPropertyAlignItems,</span>
<span class="line-removed">  95     CSSPropertyAlignSelf,</span>
<span class="line-removed">  96     CSSPropertyAlignmentBaseline,</span>
<span class="line-removed">  97     CSSPropertyAlt,</span>
<span class="line-removed">  98     CSSPropertyAnimationDelay,</span>
<span class="line-removed">  99     CSSPropertyAnimationDirection,</span>
<span class="line-removed"> 100     CSSPropertyAnimationDuration,</span>
<span class="line-removed"> 101     CSSPropertyAnimationFillMode,</span>
<span class="line-removed"> 102     CSSPropertyAnimationIterationCount,</span>
<span class="line-removed"> 103     CSSPropertyAnimationName,</span>
<span class="line-removed"> 104     CSSPropertyAnimationPlayState,</span>
<span class="line-removed"> 105     CSSPropertyAnimationTimingFunction,</span>
<span class="line-removed"> 106     CSSPropertyBackgroundAttachment,</span>
<span class="line-removed"> 107     CSSPropertyBackgroundBlendMode,</span>
<span class="line-removed"> 108     CSSPropertyBackgroundClip,</span>
<span class="line-removed"> 109     CSSPropertyBackgroundColor,</span>
<span class="line-removed"> 110     CSSPropertyBackgroundImage,</span>
<span class="line-removed"> 111     CSSPropertyBackgroundOrigin,</span>
<span class="line-removed"> 112     CSSPropertyBackgroundPosition, // more-specific background-position-x/y are non-standard</span>
<span class="line-removed"> 113     CSSPropertyBackgroundRepeat,</span>
<span class="line-removed"> 114     CSSPropertyBackgroundSize,</span>
<span class="line-removed"> 115     CSSPropertyBaselineShift,</span>
<span class="line-removed"> 116     CSSPropertyBorderBottomColor,</span>
<span class="line-removed"> 117     CSSPropertyBorderBottomLeftRadius,</span>
<span class="line-removed"> 118     CSSPropertyBorderBottomRightRadius,</span>
<span class="line-removed"> 119     CSSPropertyBorderBottomStyle,</span>
<span class="line-removed"> 120     CSSPropertyBorderBottomWidth,</span>
<span class="line-removed"> 121     CSSPropertyBorderCollapse,</span>
<span class="line-removed"> 122     CSSPropertyBorderImageOutset,</span>
<span class="line-removed"> 123     CSSPropertyBorderImageRepeat,</span>
<span class="line-removed"> 124     CSSPropertyBorderImageSlice,</span>
<span class="line-removed"> 125     CSSPropertyBorderImageSource,</span>
<span class="line-removed"> 126     CSSPropertyBorderImageWidth,</span>
<span class="line-removed"> 127     CSSPropertyBorderLeftColor,</span>
<span class="line-removed"> 128     CSSPropertyBorderLeftStyle,</span>
<span class="line-removed"> 129     CSSPropertyBorderLeftWidth,</span>
<span class="line-removed"> 130     CSSPropertyBorderRightColor,</span>
<span class="line-removed"> 131     CSSPropertyBorderRightStyle,</span>
<span class="line-removed"> 132     CSSPropertyBorderRightWidth,</span>
<span class="line-removed"> 133     CSSPropertyBorderTopColor,</span>
<span class="line-removed"> 134     CSSPropertyBorderTopLeftRadius,</span>
<span class="line-removed"> 135     CSSPropertyBorderTopRightRadius,</span>
<span class="line-removed"> 136     CSSPropertyBorderTopStyle,</span>
<span class="line-removed"> 137     CSSPropertyBorderTopWidth,</span>
<span class="line-removed"> 138     CSSPropertyBottom,</span>
<span class="line-removed"> 139     CSSPropertyBoxShadow,</span>
<span class="line-removed"> 140     CSSPropertyBoxSizing,</span>
<span class="line-removed"> 141     CSSPropertyBufferedRendering,</span>
<span class="line-removed"> 142     CSSPropertyCaptionSide,</span>
<span class="line-removed"> 143     CSSPropertyCaretColor,</span>
<span class="line-removed"> 144     CSSPropertyClear,</span>
<span class="line-removed"> 145     CSSPropertyClip,</span>
<span class="line-removed"> 146     CSSPropertyClipPath,</span>
<span class="line-removed"> 147     CSSPropertyClipRule,</span>
<span class="line-removed"> 148     CSSPropertyColor,</span>
<span class="line-removed"> 149     CSSPropertyColorInterpolation,</span>
<span class="line-removed"> 150     CSSPropertyColorInterpolationFilters,</span>
<span class="line-removed"> 151     CSSPropertyColorRendering,</span>
<span class="line-removed"> 152 #if ENABLE(DARK_MODE_CSS)</span>
<span class="line-removed"> 153     CSSPropertyColorScheme,</span>
<span class="line-removed"> 154 #endif</span>
<span class="line-removed"> 155     CSSPropertyColumnCount,</span>
<span class="line-removed"> 156     CSSPropertyColumnFill,</span>
<span class="line-removed"> 157     CSSPropertyColumnGap,</span>
<span class="line-removed"> 158     CSSPropertyColumnRuleColor,</span>
<span class="line-removed"> 159     CSSPropertyColumnRuleStyle,</span>
<span class="line-removed"> 160     CSSPropertyColumnRuleWidth,</span>
<span class="line-removed"> 161     CSSPropertyColumnSpan,</span>
<span class="line-removed"> 162     CSSPropertyColumnWidth,</span>
<span class="line-removed"> 163     CSSPropertyContent,</span>
<span class="line-removed"> 164     CSSPropertyCounterIncrement,</span>
<span class="line-removed"> 165     CSSPropertyCounterReset,</span>
<span class="line-removed"> 166     CSSPropertyCursor,</span>
<span class="line-removed"> 167     CSSPropertyCx,</span>
<span class="line-removed"> 168     CSSPropertyCy,</span>
<span class="line-removed"> 169     CSSPropertyDirection,</span>
<span class="line-removed"> 170     CSSPropertyDisplay,</span>
<span class="line-removed"> 171     CSSPropertyDominantBaseline,</span>
<span class="line-removed"> 172     CSSPropertyEmptyCells,</span>
<span class="line-removed"> 173     CSSPropertyFill,</span>
<span class="line-removed"> 174     CSSPropertyFillOpacity,</span>
<span class="line-removed"> 175     CSSPropertyFillRule,</span>
<span class="line-removed"> 176     CSSPropertyFilter,</span>
<span class="line-removed"> 177     CSSPropertyFlexBasis,</span>
<span class="line-removed"> 178     CSSPropertyFlexDirection,</span>
<span class="line-removed"> 179     CSSPropertyFlexFlow,</span>
<span class="line-removed"> 180     CSSPropertyFlexGrow,</span>
<span class="line-removed"> 181     CSSPropertyFlexShrink,</span>
<span class="line-removed"> 182     CSSPropertyFlexWrap,</span>
<span class="line-removed"> 183     CSSPropertyFloat,</span>
<span class="line-removed"> 184     CSSPropertyFloodColor,</span>
<span class="line-removed"> 185     CSSPropertyFloodOpacity,</span>
<span class="line-removed"> 186     CSSPropertyFontFamily,</span>
<span class="line-removed"> 187 #if ENABLE(VARIATION_FONTS)</span>
<span class="line-removed"> 188     CSSPropertyFontOpticalSizing,</span>
<span class="line-removed"> 189 #endif</span>
<span class="line-removed"> 190     CSSPropertyFontSize,</span>
<span class="line-removed"> 191     CSSPropertyFontStretch,</span>
<span class="line-removed"> 192     CSSPropertyFontStyle,</span>
<span class="line-removed"> 193     CSSPropertyFontSynthesis,</span>
<span class="line-removed"> 194     CSSPropertyFontVariant,</span>
<span class="line-removed"> 195     CSSPropertyFontVariantAlternates,</span>
<span class="line-removed"> 196     CSSPropertyFontVariantCaps,</span>
<span class="line-removed"> 197     CSSPropertyFontVariantEastAsian,</span>
<span class="line-removed"> 198     CSSPropertyFontVariantLigatures,</span>
<span class="line-removed"> 199     CSSPropertyFontVariantNumeric,</span>
<span class="line-removed"> 200     CSSPropertyFontVariantPosition,</span>
<span class="line-removed"> 201 #if ENABLE(VARIATION_FONTS)</span>
<span class="line-removed"> 202     CSSPropertyFontVariationSettings,</span>
<span class="line-removed"> 203 #endif</span>
<span class="line-removed"> 204     CSSPropertyFontWeight,</span>
<span class="line-removed"> 205     CSSPropertyGlyphOrientationHorizontal,</span>
<span class="line-removed"> 206     CSSPropertyGlyphOrientationVertical,</span>
<span class="line-removed"> 207     CSSPropertyGridAutoColumns,</span>
<span class="line-removed"> 208     CSSPropertyGridAutoFlow,</span>
<span class="line-removed"> 209     CSSPropertyGridAutoRows,</span>
<span class="line-removed"> 210     CSSPropertyGridColumnEnd,</span>
<span class="line-removed"> 211     CSSPropertyGridColumnStart,</span>
<span class="line-removed"> 212     CSSPropertyGridRowEnd,</span>
<span class="line-removed"> 213     CSSPropertyGridRowStart,</span>
<span class="line-removed"> 214     CSSPropertyGridTemplateAreas,</span>
<span class="line-removed"> 215     CSSPropertyGridTemplateColumns,</span>
<span class="line-removed"> 216     CSSPropertyGridTemplateRows,</span>
<span class="line-removed"> 217     CSSPropertyHangingPunctuation,</span>
<span class="line-removed"> 218     CSSPropertyHeight,</span>
<span class="line-removed"> 219 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed"> 220     CSSPropertyImageOrientation,</span>
<span class="line-removed"> 221 #endif</span>
<span class="line-removed"> 222     CSSPropertyImageRendering,</span>
<span class="line-removed"> 223 #if ENABLE(CSS_IMAGE_RESOLUTION)</span>
<span class="line-removed"> 224     CSSPropertyImageResolution,</span>
<span class="line-removed"> 225 #endif</span>
<span class="line-removed"> 226 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 227     CSSPropertyIsolation,</span>
<span class="line-removed"> 228 #endif</span>
<span class="line-removed"> 229     CSSPropertyJustifyContent,</span>
<span class="line-removed"> 230     CSSPropertyJustifyItems,</span>
<span class="line-removed"> 231     CSSPropertyJustifySelf,</span>
<span class="line-removed"> 232     CSSPropertyKerning,</span>
<span class="line-removed"> 233     CSSPropertyLeft,</span>
<span class="line-removed"> 234     CSSPropertyLetterSpacing,</span>
<span class="line-removed"> 235     CSSPropertyLightingColor,</span>
<span class="line-removed"> 236     CSSPropertyLineBreak,</span>
<span class="line-removed"> 237     CSSPropertyLineHeight,</span>
<span class="line-removed"> 238     CSSPropertyListStyleImage,</span>
<span class="line-removed"> 239     CSSPropertyListStylePosition,</span>
<span class="line-removed"> 240     CSSPropertyListStyleType,</span>
<span class="line-removed"> 241     CSSPropertyMarginBottom,</span>
<span class="line-removed"> 242     CSSPropertyMarginLeft,</span>
<span class="line-removed"> 243     CSSPropertyMarginRight,</span>
<span class="line-removed"> 244     CSSPropertyMarginTop,</span>
<span class="line-removed"> 245     CSSPropertyMarkerEnd,</span>
<span class="line-removed"> 246     CSSPropertyMarkerMid,</span>
<span class="line-removed"> 247     CSSPropertyMarkerStart,</span>
<span class="line-removed"> 248     CSSPropertyMask,</span>
<span class="line-removed"> 249     CSSPropertyMaskType,</span>
<span class="line-removed"> 250     CSSPropertyMaxHeight,</span>
<span class="line-removed"> 251     CSSPropertyMaxWidth,</span>
<span class="line-removed"> 252     CSSPropertyMinHeight,</span>
<span class="line-removed"> 253     CSSPropertyMinWidth,</span>
<span class="line-removed"> 254 #if ENABLE(CSS_COMPOSITING)</span>
<span class="line-removed"> 255     CSSPropertyMixBlendMode,</span>
<span class="line-removed"> 256 #endif</span>
<span class="line-removed"> 257     CSSPropertyObjectFit,</span>
<span class="line-removed"> 258     CSSPropertyObjectPosition,</span>
<span class="line-removed"> 259     CSSPropertyOpacity,</span>
<span class="line-removed"> 260     CSSPropertyOrder,</span>
<span class="line-removed"> 261     CSSPropertyOrphans,</span>
<span class="line-removed"> 262     CSSPropertyOutlineColor,</span>
<span class="line-removed"> 263     CSSPropertyOutlineOffset,</span>
<span class="line-removed"> 264     CSSPropertyOutlineStyle,</span>
<span class="line-removed"> 265     CSSPropertyOutlineWidth,</span>
<span class="line-removed"> 266     CSSPropertyOverflowWrap,</span>
<span class="line-removed"> 267     CSSPropertyOverflowX,</span>
<span class="line-removed"> 268     CSSPropertyOverflowY,</span>
<span class="line-removed"> 269     CSSPropertyPaddingBottom,</span>
<span class="line-removed"> 270     CSSPropertyPaddingLeft,</span>
<span class="line-removed"> 271     CSSPropertyPaddingRight,</span>
<span class="line-removed"> 272     CSSPropertyPaddingTop,</span>
<span class="line-removed"> 273     CSSPropertyPageBreakAfter,</span>
<span class="line-removed"> 274     CSSPropertyPageBreakBefore,</span>
<span class="line-removed"> 275     CSSPropertyPageBreakInside,</span>
<span class="line-removed"> 276     CSSPropertyPaintOrder,</span>
<span class="line-removed"> 277     CSSPropertyPerspective,</span>
<span class="line-removed"> 278     CSSPropertyPerspectiveOrigin,</span>
<span class="line-removed"> 279     CSSPropertyPlaceContent,</span>
<span class="line-removed"> 280     CSSPropertyPlaceItems,</span>
<span class="line-removed"> 281     CSSPropertyPlaceSelf,</span>
<span class="line-removed"> 282     CSSPropertyPointerEvents,</span>
<span class="line-removed"> 283     CSSPropertyPosition,</span>
<span class="line-removed"> 284     CSSPropertyR,</span>
<span class="line-removed"> 285     CSSPropertyResize,</span>
<span class="line-removed"> 286     CSSPropertyRight,</span>
<span class="line-removed"> 287     CSSPropertyRowGap,</span>
<span class="line-removed"> 288     CSSPropertyRx,</span>
<span class="line-removed"> 289     CSSPropertyRy,</span>
<span class="line-removed"> 290 #if ENABLE(CSS_SCROLL_SNAP)</span>
<span class="line-removed"> 291     CSSPropertyScrollPadding,</span>
<span class="line-removed"> 292     CSSPropertyScrollPaddingBottom,</span>
<span class="line-removed"> 293     CSSPropertyScrollPaddingLeft,</span>
<span class="line-removed"> 294     CSSPropertyScrollPaddingRight,</span>
<span class="line-removed"> 295     CSSPropertyScrollPaddingTop,</span>
<span class="line-removed"> 296     CSSPropertyScrollSnapAlign,</span>
<span class="line-removed"> 297     CSSPropertyScrollSnapMargin,</span>
<span class="line-removed"> 298     CSSPropertyScrollSnapMarginBottom,</span>
<span class="line-removed"> 299     CSSPropertyScrollSnapMarginLeft,</span>
<span class="line-removed"> 300     CSSPropertyScrollSnapMarginRight,</span>
<span class="line-removed"> 301     CSSPropertyScrollSnapMarginTop,</span>
<span class="line-removed"> 302     CSSPropertyScrollSnapType,</span>
<span class="line-removed"> 303 #endif</span>
<span class="line-removed"> 304     CSSPropertyShapeImageThreshold,</span>
<span class="line-removed"> 305     CSSPropertyShapeMargin,</span>
<span class="line-removed"> 306     CSSPropertyShapeOutside,</span>
<span class="line-removed"> 307     CSSPropertyShapeRendering,</span>
<span class="line-removed"> 308     CSSPropertySpeakAs,</span>
<span class="line-removed"> 309     CSSPropertyStopColor,</span>
<span class="line-removed"> 310     CSSPropertyStopOpacity,</span>
<span class="line-removed"> 311     CSSPropertyStroke,</span>
<span class="line-removed"> 312     CSSPropertyStrokeColor,</span>
<span class="line-removed"> 313     CSSPropertyStrokeDasharray,</span>
<span class="line-removed"> 314     CSSPropertyStrokeDashoffset,</span>
<span class="line-removed"> 315     CSSPropertyStrokeLinecap,</span>
<span class="line-removed"> 316     CSSPropertyStrokeLinejoin,</span>
<span class="line-removed"> 317     CSSPropertyStrokeMiterlimit,</span>
<span class="line-removed"> 318     CSSPropertyStrokeOpacity,</span>
<span class="line-removed"> 319     CSSPropertyStrokeWidth,</span>
<span class="line-removed"> 320     CSSPropertyTabSize,</span>
<span class="line-removed"> 321     CSSPropertyTableLayout,</span>
<span class="line-removed"> 322     CSSPropertyTextAlign,</span>
<span class="line-removed"> 323     CSSPropertyTextAnchor,</span>
<span class="line-removed"> 324     CSSPropertyTextDecoration,</span>
<span class="line-removed"> 325     CSSPropertyTextDecorationColor,</span>
<span class="line-removed"> 326     CSSPropertyTextDecorationLine,</span>
<span class="line-removed"> 327     CSSPropertyTextDecorationSkip,</span>
<span class="line-removed"> 328     CSSPropertyTextDecorationStyle,</span>
<span class="line-removed"> 329     CSSPropertyTextIndent,</span>
<span class="line-removed"> 330     CSSPropertyTextOverflow,</span>
<span class="line-removed"> 331     CSSPropertyTextRendering,</span>
<span class="line-removed"> 332     CSSPropertyTextShadow,</span>
<span class="line-removed"> 333     CSSPropertyTextTransform,</span>
<span class="line-removed"> 334     CSSPropertyTextUnderlinePosition,</span>
<span class="line-removed"> 335     CSSPropertyTop,</span>
<span class="line-removed"> 336 #if ENABLE(POINTER_EVENTS)</span>
<span class="line-removed"> 337     CSSPropertyTouchAction,</span>
<span class="line-removed"> 338 #endif</span>
<span class="line-removed"> 339     CSSPropertyTransform,</span>
<span class="line-removed"> 340     CSSPropertyTransformBox,</span>
<span class="line-removed"> 341     CSSPropertyTransformOrigin,</span>
<span class="line-removed"> 342     CSSPropertyTransformStyle,</span>
<span class="line-removed"> 343     CSSPropertyTransitionDelay,</span>
<span class="line-removed"> 344     CSSPropertyTransitionDuration,</span>
<span class="line-removed"> 345     CSSPropertyTransitionProperty,</span>
<span class="line-removed"> 346     CSSPropertyTransitionTimingFunction,</span>
<span class="line-removed"> 347     CSSPropertyUnicodeBidi,</span>
<span class="line-removed"> 348     CSSPropertyVectorEffect,</span>
<span class="line-removed"> 349     CSSPropertyVerticalAlign,</span>
<span class="line-removed"> 350     CSSPropertyVisibility,</span>
<span class="line-removed"> 351     CSSPropertyWhiteSpace,</span>
<span class="line-removed"> 352     CSSPropertyWidows,</span>
<span class="line-removed"> 353     CSSPropertyWidth,</span>
<span class="line-removed"> 354     CSSPropertyWillChange,</span>
<span class="line-removed"> 355     CSSPropertyWordBreak,</span>
<span class="line-removed"> 356     CSSPropertyWordSpacing,</span>
<span class="line-removed"> 357     CSSPropertyWordWrap,</span>
<span class="line-removed"> 358     CSSPropertyWritingMode,</span>
<span class="line-removed"> 359     CSSPropertyX,</span>
<span class="line-removed"> 360     CSSPropertyY,</span>
<span class="line-removed"> 361     CSSPropertyZIndex,</span>
<span class="line-removed"> 362     CSSPropertyZoom,</span>
<span class="line-removed"> 363     CSSPropertyAppleColorFilter,</span>
<span class="line-removed"> 364     CSSPropertyWebkitAppearance,</span>
<span class="line-removed"> 365 #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="line-removed"> 366     CSSPropertyWebkitBackdropFilter,</span>
<span class="line-removed"> 367 #endif</span>
<span class="line-removed"> 368     CSSPropertyWebkitBackfaceVisibility,</span>
<span class="line-removed"> 369     CSSPropertyWebkitBackgroundClip,</span>
<span class="line-removed"> 370     CSSPropertyWebkitBackgroundComposite,</span>
<span class="line-removed"> 371     CSSPropertyWebkitBackgroundOrigin,</span>
<span class="line-removed"> 372     CSSPropertyWebkitBackgroundSize,</span>
<span class="line-removed"> 373     CSSPropertyWebkitBorderFit,</span>
<span class="line-removed"> 374     CSSPropertyWebkitBorderHorizontalSpacing,</span>
<span class="line-removed"> 375     CSSPropertyWebkitBorderImage,</span>
<span class="line-removed"> 376     CSSPropertyWebkitBorderVerticalSpacing,</span>
<span class="line-removed"> 377     CSSPropertyWebkitBoxAlign,</span>
<span class="line-removed"> 378 #if ENABLE(CSS_BOX_DECORATION_BREAK)</span>
<span class="line-removed"> 379     CSSPropertyWebkitBoxDecorationBreak,</span>
<span class="line-removed"> 380 #endif</span>
<span class="line-removed"> 381     CSSPropertyWebkitBoxDirection,</span>
<span class="line-removed"> 382     CSSPropertyWebkitBoxFlex,</span>
<span class="line-removed"> 383     CSSPropertyWebkitBoxFlexGroup,</span>
<span class="line-removed"> 384     CSSPropertyWebkitBoxLines,</span>
<span class="line-removed"> 385     CSSPropertyWebkitBoxOrdinalGroup,</span>
<span class="line-removed"> 386     CSSPropertyWebkitBoxOrient,</span>
<span class="line-removed"> 387     CSSPropertyWebkitBoxPack,</span>
<span class="line-removed"> 388     CSSPropertyWebkitBoxReflect,</span>
<span class="line-removed"> 389     CSSPropertyWebkitBoxShadow,</span>
<span class="line-removed"> 390     CSSPropertyWebkitClipPath,</span>
<span class="line-removed"> 391     CSSPropertyWebkitColumnAxis,</span>
<span class="line-removed"> 392     CSSPropertyWebkitColumnBreakAfter,</span>
<span class="line-removed"> 393     CSSPropertyWebkitColumnBreakBefore,</span>
<span class="line-removed"> 394     CSSPropertyWebkitColumnBreakInside,</span>
<span class="line-removed"> 395     CSSPropertyWebkitColumnProgression,</span>
<span class="line-removed"> 396 #if ENABLE(CURSOR_VISIBILITY)</span>
<span class="line-removed"> 397     CSSPropertyWebkitCursorVisibility,</span>
<span class="line-removed"> 398 #endif</span>
<span class="line-removed"> 399     CSSPropertyWebkitFontKerning,</span>
<span class="line-removed"> 400     CSSPropertyWebkitFontSmoothing,</span>
<span class="line-removed"> 401     CSSPropertyWebkitHyphenateCharacter,</span>
<span class="line-removed"> 402     CSSPropertyWebkitHyphenateLimitAfter,</span>
<span class="line-removed"> 403     CSSPropertyWebkitHyphenateLimitBefore,</span>
<span class="line-removed"> 404     CSSPropertyWebkitHyphenateLimitLines,</span>
<span class="line-removed"> 405     CSSPropertyWebkitHyphens,</span>
<span class="line-removed"> 406     CSSPropertyWebkitInitialLetter,</span>
<span class="line-removed"> 407     CSSPropertyWebkitLineAlign,</span>
<span class="line-removed"> 408     CSSPropertyWebkitLineBoxContain,</span>
<span class="line-removed"> 409     CSSPropertyWebkitLineClamp,</span>
<span class="line-removed"> 410     CSSPropertyWebkitLineGrid,</span>
<span class="line-removed"> 411     CSSPropertyWebkitLineSnap,</span>
<span class="line-removed"> 412     CSSPropertyWebkitLocale,</span>
<span class="line-removed"> 413     CSSPropertyWebkitMarginAfterCollapse,</span>
<span class="line-removed"> 414     CSSPropertyWebkitMarginBeforeCollapse,</span>
<span class="line-removed"> 415     CSSPropertyWebkitMarqueeDirection,</span>
<span class="line-removed"> 416     CSSPropertyWebkitMarqueeIncrement,</span>
<span class="line-removed"> 417     CSSPropertyWebkitMarqueeRepetition,</span>
<span class="line-removed"> 418     CSSPropertyWebkitMarqueeStyle,</span>
<span class="line-removed"> 419     CSSPropertyWebkitMaskBoxImage,</span>
<span class="line-removed"> 420     CSSPropertyWebkitMaskBoxImageOutset,</span>
<span class="line-removed"> 421     CSSPropertyWebkitMaskBoxImageRepeat,</span>
<span class="line-removed"> 422     CSSPropertyWebkitMaskBoxImageSlice,</span>
<span class="line-removed"> 423     CSSPropertyWebkitMaskBoxImageSource,</span>
<span class="line-removed"> 424     CSSPropertyWebkitMaskBoxImageWidth,</span>
<span class="line-removed"> 425     CSSPropertyWebkitMaskClip,</span>
<span class="line-removed"> 426     CSSPropertyWebkitMaskComposite,</span>
<span class="line-removed"> 427     CSSPropertyWebkitMaskImage,</span>
<span class="line-removed"> 428     CSSPropertyWebkitMaskOrigin,</span>
<span class="line-removed"> 429     CSSPropertyWebkitMaskPosition,</span>
<span class="line-removed"> 430     CSSPropertyWebkitMaskRepeat,</span>
<span class="line-removed"> 431     CSSPropertyWebkitMaskSize,</span>
<span class="line-removed"> 432     CSSPropertyWebkitMaskSourceType,</span>
<span class="line-removed"> 433     CSSPropertyWebkitNbspMode,</span>
<span class="line-removed"> 434 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)</span>
<span class="line-removed"> 435     CSSPropertyWebkitOverflowScrolling,</span>
<span class="line-removed"> 436 #endif</span>
<span class="line-removed"> 437     CSSPropertyWebkitPrintColorAdjust,</span>
<span class="line-removed"> 438     CSSPropertyWebkitRtlOrdering,</span>
<span class="line-removed"> 439 #if ENABLE(TOUCH_EVENTS)</span>
<span class="line-removed"> 440     CSSPropertyWebkitTapHighlightColor,</span>
<span class="line-removed"> 441 #endif</span>
<span class="line-removed"> 442 #if ENABLE(CSS3_TEXT)</span>
<span class="line-removed"> 443     CSSPropertyWebkitTextAlignLast,</span>
<span class="line-removed"> 444 #endif</span>
<span class="line-removed"> 445     CSSPropertyWebkitTextCombine,</span>
<span class="line-removed"> 446     CSSPropertyWebkitTextDecorationsInEffect,</span>
<span class="line-removed"> 447     CSSPropertyWebkitTextEmphasisColor,</span>
<span class="line-removed"> 448     CSSPropertyWebkitTextEmphasisPosition,</span>
<span class="line-removed"> 449     CSSPropertyWebkitTextEmphasisStyle,</span>
<span class="line-removed"> 450     CSSPropertyWebkitTextFillColor,</span>
<span class="line-removed"> 451 #if ENABLE(CSS3_TEXT)</span>
<span class="line-removed"> 452     CSSPropertyWebkitTextJustify,</span>
<span class="line-removed"> 453 #endif</span>
<span class="line-removed"> 454     CSSPropertyWebkitTextOrientation,</span>
<span class="line-removed"> 455     CSSPropertyWebkitTextSecurity,</span>
<span class="line-removed"> 456 #if ENABLE(TEXT_AUTOSIZING)</span>
<span class="line-removed"> 457     CSSPropertyWebkitTextSizeAdjust,</span>
<span class="line-removed"> 458 #endif</span>
<span class="line-removed"> 459     CSSPropertyWebkitTextStrokeColor,</span>
<span class="line-removed"> 460     CSSPropertyWebkitTextStrokeWidth,</span>
<span class="line-removed"> 461     CSSPropertyWebkitTextZoom,</span>
<span class="line-removed"> 462 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 463     CSSPropertyWebkitTouchCallout,</span>
<span class="line-removed"> 464 #endif</span>
<span class="line-removed"> 465     CSSPropertyWebkitTransformStyle,</span>
<span class="line-removed"> 466     CSSPropertyWebkitUserDrag,</span>
<span class="line-removed"> 467     CSSPropertyWebkitUserModify,</span>
<span class="line-removed"> 468     CSSPropertyWebkitUserSelect,</span>
<span class="line-removed"> 469 };</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471 const unsigned numComputedProperties = WTF_ARRAY_LENGTH(computedProperties);</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473 static CSSValueID valueForRepeatRule(int rule)</span>
 474 {
 475     switch (rule) {
<span class="line-modified"> 476         case RepeatImageRule:</span>
<span class="line-modified"> 477             return CSSValueRepeat;</span>
<span class="line-modified"> 478         case RoundImageRule:</span>
<span class="line-modified"> 479             return CSSValueRound;</span>
<span class="line-modified"> 480         case SpaceImageRule:</span>
<span class="line-modified"> 481             return CSSValueSpace;</span>
<span class="line-modified"> 482         default:</span>
<span class="line-modified"> 483             return CSSValueStretch;</span>
 484     }
 485 }
 486 
 487 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 488 {
 489     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
 490     // a calculation that combines a percentage and a number.
 491     if (length.isPercent())
<span class="line-modified"> 492         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 493     if (length.isFixed())
<span class="line-modified"> 494         return CSSValuePool::singleton().createValue(length.value(), CSSPrimitiveValue::CSS_NUMBER);</span>
 495 
 496     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
 497     // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
 498     // FIXME: For now, just return 0.
 499     ASSERT(length.isCalculated());
<span class="line-modified"> 500     return CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::CSS_NUMBER);</span>
 501 }
 502 
 503 static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
 504 {
 505     auto&amp; slices = image.imageSlices();
 506 
 507     RefPtr&lt;CSSPrimitiveValue&gt; top = valueForImageSliceSide(slices.top());
 508 
 509     RefPtr&lt;CSSPrimitiveValue&gt; right;
 510     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 511     RefPtr&lt;CSSPrimitiveValue&gt; left;
 512 
 513     if (slices.right() == slices.top() &amp;&amp; slices.bottom() == slices.top() &amp;&amp; slices.left() == slices.top()) {
 514         right = top;
 515         bottom = top;
 516         left = top;
 517     } else {
 518         right = valueForImageSliceSide(slices.right());
 519 
 520         if (slices.bottom() == slices.top() &amp;&amp; slices.right() == slices.left()) {
</pre>
<hr />
<pre>
 532 
 533     auto quad = Quad::create();
 534     quad-&gt;setTop(WTFMove(top));
 535     quad-&gt;setRight(WTFMove(right));
 536     quad-&gt;setBottom(WTFMove(bottom));
 537     quad-&gt;setLeft(WTFMove(left));
 538 
 539     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), image.fill());
 540 }
 541 
 542 static Ref&lt;CSSPrimitiveValue&gt; valueForNinePieceImageQuad(const LengthBox&amp; box)
 543 {
 544     RefPtr&lt;CSSPrimitiveValue&gt; top;
 545     RefPtr&lt;CSSPrimitiveValue&gt; right;
 546     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 547     RefPtr&lt;CSSPrimitiveValue&gt; left;
 548 
 549     auto&amp; cssValuePool = CSSValuePool::singleton();
 550 
 551     if (box.top().isRelative())
<span class="line-modified"> 552         top = cssValuePool.createValue(box.top().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
 553     else
 554         top = cssValuePool.createValue(box.top());
 555 
 556     if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
 557         right = top;
 558         bottom = top;
 559         left = top;
 560     } else {
 561         if (box.right().isRelative())
<span class="line-modified"> 562             right = cssValuePool.createValue(box.right().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
 563         else
 564             right = cssValuePool.createValue(box.right());
 565 
 566         if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
 567             bottom = top;
 568             left = right;
 569         } else {
 570             if (box.bottom().isRelative())
<span class="line-modified"> 571                 bottom = cssValuePool.createValue(box.bottom().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
 572             else
 573                 bottom = cssValuePool.createValue(box.bottom());
 574 
 575             if (box.left() == box.right())
 576                 left = right;
 577             else {
 578                 if (box.left().isRelative())
<span class="line-modified"> 579                     left = cssValuePool.createValue(box.left().value(), CSSPrimitiveValue::CSS_NUMBER);</span>
 580                 else
 581                     left = cssValuePool.createValue(box.left());
 582             }
 583         }
 584     }
 585 
 586     auto quad = Quad::create();
 587     quad-&gt;setTop(WTFMove(top));
 588     quad-&gt;setRight(WTFMove(right));
 589     quad-&gt;setBottom(WTFMove(bottom));
 590     quad-&gt;setLeft(WTFMove(left));
 591 
 592     return cssValuePool.createValue(WTFMove(quad));
 593 }
 594 
 595 static Ref&lt;CSSValue&gt; valueForNinePieceImageRepeat(const NinePieceImage&amp; image)
 596 {
 597     auto&amp; cssValuePool = CSSValuePool::singleton();
 598     auto horizontalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.horizontalRule()));
 599     RefPtr&lt;CSSPrimitiveValue&gt; verticalRepeat;
</pre>
<hr />
<pre>
 614     if (image.image())
 615         imageValue = image.image()-&gt;cssValue();
 616 
 617     // Create the image slice.
 618     RefPtr&lt;CSSBorderImageSliceValue&gt; imageSlices = valueForNinePieceImageSlice(image);
 619 
 620     // Create the border area slices.
 621     RefPtr&lt;CSSValue&gt; borderSlices = valueForNinePieceImageQuad(image.borderSlices());
 622 
 623     // Create the border outset.
 624     RefPtr&lt;CSSValue&gt; outset = valueForNinePieceImageQuad(image.outset());
 625 
 626     // Create the repeat rules.
 627     RefPtr&lt;CSSValue&gt; repeat = valueForNinePieceImageRepeat(image);
 628 
 629     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 630 }
 631 
 632 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
 633 {
<span class="line-modified"> 634     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSPrimitiveValue::CSS_PX);</span>
 635 }
 636 
 637 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
 638 {
<span class="line-modified"> 639     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSPrimitiveValue::CSS_NUMBER);</span>
 640 }
 641 
<span class="line-modified"> 642 static Ref&lt;CSSValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)</span>
 643 {
 644     if (length.isFixed())
 645         return zoomAdjustedPixelValue(length.value(), style);
 646     return CSSValuePool::singleton().createValue(length, style);
 647 }
 648 
 649 static Ref&lt;CSSValue&gt; valueForReflection(const StyleReflection* reflection, const RenderStyle&amp; style)
 650 {
 651     if (!reflection)
 652         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 653 
 654     RefPtr&lt;CSSPrimitiveValue&gt; offset;
 655     if (reflection-&gt;offset().isPercentOrCalculated())
<span class="line-modified"> 656         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 657     else
 658         offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
 659 
 660     RefPtr&lt;CSSPrimitiveValue&gt; direction;
 661     switch (reflection-&gt;direction()) {
<span class="line-modified"> 662     case ReflectionBelow:</span>
 663         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
 664         break;
<span class="line-modified"> 665     case ReflectionAbove:</span>
 666         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
 667         break;
<span class="line-modified"> 668     case ReflectionLeft:</span>
 669         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
 670         break;
<span class="line-modified"> 671     case ReflectionRight:</span>
 672         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
 673         break;
 674     }
 675 
 676     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
 677 }
 678 
 679 static Ref&lt;CSSValueList&gt; createPositionListForLayer(CSSPropertyID propertyID, const FillLayer&amp; layer, const RenderStyle&amp; style)
 680 {
 681     auto list = CSSValueList::createSpaceSeparated();
 682     if (layer.isBackgroundXOriginSet()) {
 683         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 684         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundXOrigin()));
 685     }
 686     list-&gt;append(zoomAdjustedPixelValueForLength(layer.xPosition(), style));
 687     if (layer.isBackgroundYOriginSet()) {
 688         ASSERT(propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 689         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundYOrigin()));
 690     }
 691     list-&gt;append(zoomAdjustedPixelValueForLength(layer.yPosition(), style));
</pre>
<hr />
<pre>
 817     if (box.isRelativelyPositioned())
 818         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 819 
 820     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 821         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 822 
 823     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 824 }
 825 
 826 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 827 {
 828     // This function does NOT look at visited information, so that computed style doesn&#39;t expose that.
 829     if (!color.isValid())
 830         return CSSValuePool::singleton().createColorValue(style-&gt;color());
 831     return CSSValuePool::singleton().createColorValue(color);
 832 }
 833 
 834 static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 835 {
 836     if (length.isPercent())
<span class="line-modified"> 837         return CSSValuePool::singleton().createValue(length.percent(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 838 
<span class="line-modified"> 839     return zoomAdjustedPixelValue(valueForLength(length, 0), style);</span>
 840 }
 841 
 842 static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 843 {
 844     if (length.isAuto())
 845         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 846 
<span class="line-modified"> 847     return zoomAdjustedPixelValue(valueForLength(length, 0), style);</span>
 848 }
 849 
 850 static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
 851 {
 852     auto list = CSSValueList::createSpaceSeparated();
 853     list-&gt;append(percentageOrZoomAdjustedValue(radius.width, style));
 854     list-&gt;append(percentageOrZoomAdjustedValue(radius.height, style));
 855     return list;
 856 }
 857 
 858 static Ref&lt;CSSValue&gt; borderRadiusCornerValue(const LengthSize&amp; radius, const RenderStyle&amp; style)
 859 {
 860     if (radius.width == radius.height)
 861         return percentageOrZoomAdjustedValue(radius.width, style);
 862     return borderRadiusCornerValues(radius, style);
 863 }
 864 
 865 static Ref&lt;CSSValueList&gt; borderRadiusShorthandValue(const RenderStyle&amp; style)
 866 {
 867     auto list = CSSValueList::createSlashSeparated();
</pre>
<hr />
<pre>
 903 
 904     return list;
 905 }
 906 
 907 static LayoutRect sizingBox(RenderObject&amp; renderer)
 908 {
 909     if (!is&lt;RenderBox&gt;(renderer))
 910         return LayoutRect();
 911 
 912     auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
 913     return box.style().boxSizing() == BoxSizing::BorderBox ? box.borderBoxRect() : box.computedCSSContentBoxRect();
 914 }
 915 
 916 static Ref&lt;CSSFunctionValue&gt; matrixTransformValue(const TransformationMatrix&amp; transform, const RenderStyle&amp; style)
 917 {
 918     RefPtr&lt;CSSFunctionValue&gt; transformValue;
 919     auto&amp; cssValuePool = CSSValuePool::singleton();
 920     if (transform.isAffine()) {
 921         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 922 
<span class="line-modified"> 923         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 924         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 925         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 926         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSPrimitiveValue::CSS_NUMBER));</span>
 927         transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
 928         transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
 929     } else {
 930         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 931 
<span class="line-modified"> 932         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 933         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 934         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 935         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSPrimitiveValue::CSS_NUMBER));</span>
 936 
<span class="line-modified"> 937         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 938         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 939         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 940         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSPrimitiveValue::CSS_NUMBER));</span>
 941 
<span class="line-modified"> 942         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 943         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 944         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSPrimitiveValue::CSS_NUMBER));</span>
<span class="line-modified"> 945         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSPrimitiveValue::CSS_NUMBER));</span>
 946 
 947         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
 948         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
 949         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
<span class="line-modified"> 950         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSPrimitiveValue::CSS_NUMBER));</span>
 951     }
 952 
 953     return transformValue.releaseNonNull();
 954 }
 955 
 956 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 957 {
 958     // Inline renderers do not support transforms.
 959     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 960         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 961 
 962     FloatRect pixelSnappedRect;
 963     if (is&lt;RenderBox&gt;(*renderer))
 964         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 965 
 966     TransformationMatrix transform;
 967     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 968     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 969 
 970     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 971     auto list = CSSValueList::createSpaceSeparated();
 972     list-&gt;append(matrixTransformValue(transform, style));
 973     return list;
 974 }
 975 
 976 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 977 {
<span class="line-modified"> 978     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSPrimitiveValue::CSS_PX);</span>
 979 }
 980 
 981 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 982 {
 983     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 984 }
 985 
 986 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 987 {
 988     auto&amp; cssValuePool = CSSValuePool::singleton();
 989     if (!shadow)
 990         return cssValuePool.createIdentifierValue(CSSValueNone);
 991 
 992     auto list = CSSValueList::createCommaSeparated();
 993     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 994         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 995         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 996         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 997         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
<span class="line-modified"> 998         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);</span>
 999         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
1000         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
1001     }
1002     return list;
1003 }
1004 
1005 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
1006 {
1007     auto&amp; cssValuePool = CSSValuePool::singleton();
1008     if (filterOperations.operations().isEmpty())
1009         return cssValuePool.createIdentifierValue(CSSValueNone);
1010 
1011     auto list = CSSValueList::createSpaceSeparated();
1012 
1013     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
1014     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
1015         FilterOperation&amp; filterOperation = **it;
1016 
1017         if (filterOperation.type() == FilterOperation::REFERENCE) {
1018             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified">1019             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSPrimitiveValue::CSS_URI));</span>
1020         } else {
1021             RefPtr&lt;CSSFunctionValue&gt; filterValue;
1022             switch (filterOperation.type()) {
1023             case FilterOperation::GRAYSCALE: {
1024                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
<span class="line-modified">1025                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1026                 break;
1027             }
1028             case FilterOperation::SEPIA: {
1029                 filterValue = CSSFunctionValue::create(CSSValueSepia);
<span class="line-modified">1030                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1031                 break;
1032             }
1033             case FilterOperation::SATURATE: {
1034                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
<span class="line-modified">1035                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1036                 break;
1037             }
1038             case FilterOperation::HUE_ROTATE: {
1039                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
<span class="line-modified">1040                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_DEG));</span>
1041                 break;
1042             }
1043             case FilterOperation::INVERT: {
1044                 filterValue = CSSFunctionValue::create(CSSValueInvert);
<span class="line-modified">1045                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1046                 break;
1047             }
1048             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
1049                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
1050                 break;
1051             }
1052             case FilterOperation::OPACITY: {
1053                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
<span class="line-modified">1054                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1055                 break;
1056             }
1057             case FilterOperation::BRIGHTNESS: {
1058                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
<span class="line-modified">1059                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1060                 break;
1061             }
1062             case FilterOperation::CONTRAST: {
1063                 filterValue = CSSFunctionValue::create(CSSValueContrast);
<span class="line-modified">1064                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSPrimitiveValue::CSS_NUMBER));</span>
1065                 break;
1066             }
1067             case FilterOperation::BLUR: {
1068                 filterValue = CSSFunctionValue::create(CSSValueBlur);
1069                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
1070                 break;
1071             }
1072             case FilterOperation::DROP_SHADOW: {
1073                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
1074                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
1075                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
<span class="line-modified">1076                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, Normal, false, dropShadowOperation.color());</span>
1077                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
1078                 break;
1079             }
1080             default:
1081                 ASSERT_NOT_REACHED();
1082                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
1083                 break;
1084             }
1085             list-&gt;append(filterValue.releaseNonNull());
1086         }
1087     }
1088     return list;
1089 }
1090 
1091 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
1092 {
1093     if (!trackBreadth.isLength())
<span class="line-modified">1094         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSPrimitiveValue::CSS_FR);</span>
1095 
1096     const Length&amp; trackBreadthLength = trackBreadth.length();
1097     if (trackBreadthLength.isAuto())
1098         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1099     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
1100 }
1101 
1102 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
1103 {
1104     switch (trackSize.type()) {
1105     case LengthTrackSizing:
1106         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
1107     case FitContentTrackSizing: {
1108         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
1109         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
1110         return fitContentTrackSize;
1111     }
1112     default:
1113         ASSERT(trackSize.type() == MinMaxTrackSizing);
1114         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
<span class="line-modified">1115             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSPrimitiveValue::CSS_FR);</span>
1116 
1117         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
1118         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
1119         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
1120         return minMaxTrackBreadths;
1121     }
1122 }
1123 
1124 class OrderedNamedLinesCollector {
1125     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
1126 public:
<span class="line-modified">1127     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount)</span>
1128         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
1129         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
<span class="line-removed">1130         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())</span>
<span class="line-removed">1131         , m_autoRepeatTotalTracks(autoRepeatTracksCount)</span>
<span class="line-removed">1132         , m_autoRepeatTrackListLength(isRowAxis ? style.gridAutoRepeatColumns().size() : style.gridAutoRepeatRows().size())</span>
1133     {
1134     }

1135 
1136     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
<span class="line-modified">1137     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;</span>
1138 
<span class="line-modified">1139 private:</span>
1140 
1141     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
1142     void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
1143 
1144     const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
1145     const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;

























1146     unsigned m_insertionPoint;
1147     unsigned m_autoRepeatTotalTracks;
1148     unsigned m_autoRepeatTrackListLength;
1149 };
1150 
1151 void OrderedNamedLinesCollector::appendLines(CSSGridLineNamesValue&amp; lineNamesValue, unsigned index, NamedLinesType type) const
1152 {
1153     auto iter = type == NamedLines ? m_orderedNamedGridLines.find(index) : m_orderedNamedAutoRepeatGridLines.find(index);
1154     auto endIter = type == NamedLines ? m_orderedNamedGridLines.end() : m_orderedNamedAutoRepeatGridLines.end();
1155     if (iter == endIter)
1156         return;
1157 
1158     auto&amp; cssValuePool = CSSValuePool::singleton();
1159     for (const auto&amp; lineName : iter-&gt;value)
<span class="line-modified">1160         lineNamesValue.append(cssValuePool.createValue(lineName, CSSPrimitiveValue::CSS_STRING));</span>
1161 }
1162 
1163 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
1164 {
1165     ASSERT(!isEmpty());
<span class="line-modified">1166     if (m_orderedNamedAutoRepeatGridLines.isEmpty() || i &lt; m_insertionPoint) {</span>












1167         appendLines(lineNamesValue, i, NamedLines);
1168         return;
1169     }
1170 
1171     ASSERT(m_autoRepeatTotalTracks);
1172 
1173     if (i &gt; m_insertionPoint + m_autoRepeatTotalTracks) {
1174         appendLines(lineNamesValue, i - (m_autoRepeatTotalTracks - 1), NamedLines);
1175         return;
1176     }
1177 
1178     if (i == m_insertionPoint) {
1179         appendLines(lineNamesValue, i, NamedLines);
1180         appendLines(lineNamesValue, 0, AutoRepeatNamedLines);
1181         return;
1182     }
1183 
1184     if (i == m_insertionPoint + m_autoRepeatTotalTracks) {
1185         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
1186         appendLines(lineNamesValue, m_insertionPoint + 1, NamedLines);
</pre>
<hr />
<pre>
1197 {
1198     if (collector.isEmpty())
1199         return;
1200 
1201     auto lineNames = CSSGridLineNamesValue::create();
1202     collector.collectLineNamesForIndex(lineNames.get(), i);
1203     if (lineNames-&gt;length())
1204         list.append(WTFMove(lineNames));
1205 }
1206 
1207 static Ref&lt;CSSValueList&gt; valueForGridTrackSizeList(GridTrackSizingDirection direction, const RenderStyle&amp; style)
1208 {
1209     auto&amp; autoTrackSizes = direction == ForColumns ? style.gridAutoColumns() : style.gridAutoRows();
1210 
1211     auto list = CSSValueList::createSpaceSeparated();
1212     for (auto&amp; trackSize : autoTrackSizes)
1213         list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
1214     return list;
1215 }
1216 

















1217 static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
1218 {
1219     bool isRowAxis = direction == ForColumns;
1220     bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
1221     auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
1222     auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
1223 
1224     // Handle the &#39;none&#39; case.
<span class="line-modified">1225     bool trackListIsEmpty = trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty();</span>
<span class="line-removed">1226     if (isRenderGrid &amp;&amp; trackListIsEmpty) {</span>
<span class="line-removed">1227         // For grids we should consider every listed track, whether implicitly or explicitly</span>
<span class="line-removed">1228         // created. Empty grids have a sole grid line per axis.</span>
<span class="line-removed">1229         auto&amp; grid = downcast&lt;RenderGrid&gt;(*renderer);</span>
<span class="line-removed">1230         auto&amp; positions = isRowAxis ? grid.columnPositions() : grid.rowPositions();</span>
<span class="line-removed">1231         trackListIsEmpty = positions.size() == 1;</span>
<span class="line-removed">1232     }</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234     if (trackListIsEmpty)</span>
1235         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1236 
<span class="line-removed">1237     unsigned autoRepeatTotalTracks = isRenderGrid ? downcast&lt;RenderGrid&gt;(renderer)-&gt;autoRepeatCountForDirection(direction) : 0;</span>
<span class="line-removed">1238     OrderedNamedLinesCollector collector(style, isRowAxis, autoRepeatTotalTracks);</span>
1239     auto list = CSSValueList::createSpaceSeparated();
<span class="line-removed">1240     unsigned insertionIndex;</span>
<span class="line-removed">1241     if (isRenderGrid) {</span>
<span class="line-removed">1242         auto computedTrackSizes = downcast&lt;RenderGrid&gt;(*renderer).trackSizesForComputedStyle(direction);</span>
<span class="line-removed">1243         unsigned numTracks = computedTrackSizes.size();</span>
<span class="line-removed">1244 </span>
<span class="line-removed">1245         for (unsigned i = 0; i &lt; numTracks; ++i) {</span>
<span class="line-removed">1246             addValuesForNamedGridLinesAtIndex(collector, i, list.get());</span>
<span class="line-removed">1247             list-&gt;append(zoomAdjustedPixelValue(computedTrackSizes[i], style));</span>
<span class="line-removed">1248         }</span>
<span class="line-removed">1249         addValuesForNamedGridLinesAtIndex(collector, numTracks + 1, list.get());</span>
<span class="line-removed">1250         insertionIndex = numTracks;</span>
<span class="line-removed">1251     } else {</span>
<span class="line-removed">1252         for (unsigned i = 0; i &lt; trackSizes.size(); ++i) {</span>
<span class="line-removed">1253             addValuesForNamedGridLinesAtIndex(collector, i, list.get());</span>
<span class="line-removed">1254             list-&gt;append(specifiedValueForGridTrackSize(trackSizes[i], style));</span>
<span class="line-removed">1255         }</span>
<span class="line-removed">1256         insertionIndex = trackSizes.size();</span>
<span class="line-removed">1257     }</span>
1258 
<span class="line-modified">1259     // Those are the trailing &lt;ident&gt;* allowed in the syntax.</span>
<span class="line-modified">1260     addValuesForNamedGridLinesAtIndex(collector, insertionIndex, list.get());</span>


































1261     return list;
1262 }
1263 
1264 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
1265 {
1266     auto&amp; cssValuePool = CSSValuePool::singleton();
1267     if (position.isAuto())
1268         return cssValuePool.createIdentifierValue(CSSValueAuto);
1269 
1270     if (position.isNamedGridArea())
<span class="line-modified">1271         return cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING);</span>
1272 
1273     auto list = CSSValueList::createSpaceSeparated();
1274     if (position.isSpan()) {
1275         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
<span class="line-modified">1276         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSPrimitiveValue::CSS_NUMBER));</span>
1277     } else
<span class="line-modified">1278         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSPrimitiveValue::CSS_NUMBER));</span>
1279 
1280     if (!position.namedGridLine().isNull())
<span class="line-modified">1281         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSPrimitiveValue::CSS_STRING));</span>
1282     return list;
1283 }
1284 
1285 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
1286 {
1287     switch (animation.animationMode()) {
1288     case Animation::AnimateNone:
1289         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1290     case Animation::AnimateAll:
1291         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1292     case Animation::AnimateSingleProperty:
<span class="line-modified">1293         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSPrimitiveValue::CSS_STRING);</span>
1294     case Animation::AnimateUnknownProperty:
<span class="line-modified">1295         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSPrimitiveValue::CSS_STRING);</span>
1296     }
1297     ASSERT_NOT_REACHED();
1298     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1299 }
1300 
1301 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
1302 {
1303     auto list = CSSValueList::createCommaSeparated();
1304     if (animationList) {
1305         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1306             list-&gt;append(createTransitionPropertyValue(animationList-&gt;animation(i)));
1307     } else
1308         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAll));
1309     return list;
1310 }
1311 
1312 #if ENABLE(CSS_SCROLL_SNAP)
1313 
1314 static Ref&lt;CSSValueList&gt; valueForScrollSnapType(const ScrollSnapType&amp; type)
1315 {
</pre>
<hr />
<pre>
1536     case FontVariantEastAsianWidth::Full:
1537         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1538         break;
1539     case FontVariantEastAsianWidth::Proportional:
1540         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1541         break;
1542     }
1543 
1544     if (ruby == FontVariantEastAsianRuby::Yes)
1545         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1546 
1547     return valueList;
1548 }
1549 
1550 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1551 {
1552     auto&amp; cssValuePool = CSSValuePool::singleton();
1553     auto list = CSSValueList::createCommaSeparated();
1554     if (animationList) {
1555         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">1556             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSPrimitiveValue::CSS_S));</span>
1557     } else {
1558         // Note that initialAnimationDelay() is used for both transitions and animations
<span class="line-modified">1559         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));</span>
1560     }
1561     return list;
1562 }
1563 
1564 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1565 {
1566     auto&amp; cssValuePool = CSSValuePool::singleton();
1567     auto list = CSSValueList::createCommaSeparated();
1568     if (animationList) {
1569         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">1570             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSPrimitiveValue::CSS_S));</span>
1571     } else {
1572         // Note that initialAnimationDuration() is used for both transitions and animations
<span class="line-modified">1573         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));</span>
1574     }
1575     return list;
1576 }
1577 
1578 static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
1579 {
1580     switch (timingFunction.type()) {
1581     case TimingFunction::CubicBezierFunction: {
1582         auto&amp; function = downcast&lt;CubicBezierTimingFunction&gt;(timingFunction);
1583         if (function.timingFunctionPreset() != CubicBezierTimingFunction::Custom) {
1584             CSSValueID valueId = CSSValueInvalid;
1585             switch (function.timingFunctionPreset()) {
1586             case CubicBezierTimingFunction::Ease:
1587                 valueId = CSSValueEase;
1588                 break;
1589             case CubicBezierTimingFunction::EaseIn:
1590                 valueId = CSSValueEaseIn;
1591                 break;
1592             case CubicBezierTimingFunction::EaseOut:
1593                 valueId = CSSValueEaseOut;
</pre>
<hr />
<pre>
1610         return CSSSpringTimingFunctionValue::create(function.mass(), function.stiffness(), function.damping(), function.initialVelocity());
1611     }
1612     default:
1613         ASSERT(timingFunction.type() == TimingFunction::LinearFunction);
1614         return CSSValuePool::singleton().createIdentifierValue(CSSValueLinear);
1615     }
1616 }
1617 
1618 static Ref&lt;CSSValueList&gt; timingFunctionValue(const AnimationList* animationList)
1619 {
1620     auto list = CSSValueList::createCommaSeparated();
1621     if (animationList) {
1622         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1623             list-&gt;append(createTimingFunctionValue(*animationList-&gt;animation(i).timingFunction()));
1624     } else
1625         // Note that initialAnimationTimingFunction() is used for both transitions and animations
1626         list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
1627     return list;
1628 }
1629 
<span class="line-modified">1630 static Ref&lt;CSSValue&gt; createLineBoxContainValue(unsigned lineBoxContain)</span>
1631 {
1632     if (!lineBoxContain)
1633         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1634     return CSSLineBoxContainValue::create(lineBoxContain);
1635 }
1636 
1637 static Element* styleElementForNode(Node* node)
1638 {
1639     if (!node)
1640         return nullptr;
1641     if (is&lt;Element&gt;(*node))
1642         return downcast&lt;Element&gt;(node);
1643     return composedTreeAncestors(*node).first();
1644 }
1645 
1646 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1647     : m_element(styleElementForNode(node))
1648     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1649     , m_allowVisitedStyle(allowVisitedStyle)
1650 {
</pre>
<hr />
<pre>
1674 Ref&lt;CSSComputedStyleDeclaration&gt; CSSComputedStyleDeclaration::create(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)
1675 {
1676     return adoptRef(*new CSSComputedStyleDeclaration(element, allowVisitedStyle, pseudoElementName));
1677 }
1678 
1679 void CSSComputedStyleDeclaration::ref()
1680 {
1681     ++m_refCount;
1682 }
1683 
1684 void CSSComputedStyleDeclaration::deref()
1685 {
1686     ASSERT(m_refCount);
1687     if (!--m_refCount)
1688         delete this;
1689 }
1690 
1691 String CSSComputedStyleDeclaration::cssText() const
1692 {
1693     StringBuilder result;
<span class="line-modified">1694     for (unsigned i = 0; i &lt; numComputedProperties; i++) {</span>
1695         if (i)
1696             result.append(&#39; &#39;);
<span class="line-modified">1697         result.append(getPropertyName(computedProperties[i]), &quot;: &quot;, getPropertyValue(computedProperties[i]), &#39;;&#39;);</span>
1698     }
1699     return result.toString();
1700 }
1701 
1702 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1703 {
1704     return Exception { NoModificationAllowedError };
1705 }
1706 
1707 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1708 {
1709     if (!m_element)
1710         return nullptr;
1711 
1712     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1713 
1714     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1715     if (!style)
1716         return nullptr;
1717 
</pre>
<hr />
<pre>
1830     switch (static_cast&lt;TextDecorationSkip&gt;(textDecorationSkip.toRaw())) {
1831     case TextDecorationSkip::Auto:
1832         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1833     case TextDecorationSkip::None:
1834         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1835     case TextDecorationSkip::Ink:
1836         return CSSValuePool::singleton().createIdentifierValue(CSSValueInk);
1837     case TextDecorationSkip::Objects:
1838         return CSSValuePool::singleton().createIdentifierValue(CSSValueObjects);
1839     }
1840 
1841     ASSERT_NOT_REACHED();
1842     return CSSValuePool::singleton().createExplicitInitialValue();
1843 }
1844 
1845 static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
1846 {
1847     if (textUnderlineOffset.isAuto())
1848         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1849     ASSERT(textUnderlineOffset.isLength());
<span class="line-modified">1850     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSPrimitiveValue::CSS_PX);</span>
1851 }
1852 
1853 static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
1854 {
1855     if (textDecorationThickness.isAuto())
1856         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1857     if (textDecorationThickness.isFromFont())
1858         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
1859     ASSERT(textDecorationThickness.isLength());
<span class="line-modified">1860     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSPrimitiveValue::CSS_PX);</span>
1861 }
1862 
1863 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1864 {
1865     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1866     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1867     auto&amp; cssValuePool = CSSValuePool::singleton();
1868     auto list = CSSValueList::createSpaceSeparated();
1869     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1870         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1871     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1872         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1873     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1874         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1875     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1876         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1877     if (!list-&gt;length())
1878         return cssValuePool.createIdentifierValue(CSSValueNone);
1879     return list;
1880 }
</pre>
<hr />
<pre>
1944 
1945 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1946 {
1947     if (fillSize.type == FillSizeType::Contain)
1948         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1949 
1950     if (fillSize.type == FillSizeType::Cover)
1951         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1952 
1953     if (fillSize.size.height.isAuto())
1954         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1955 
1956     auto list = CSSValueList::createSpaceSeparated();
1957     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1958     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
1959     return list;
1960 }
1961 
1962 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1963 {
<span class="line-modified">1964     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSPrimitiveValue::CSS_STRING);</span>
1965 }
1966 
1967 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1968 {
1969     auto&amp; cssValuePool = CSSValuePool::singleton();
1970     auto list = CSSValueList::createSpaceSeparated();
1971     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1972         if (is&lt;CounterContentData&gt;(*contentData))
<span class="line-modified">1973             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSPrimitiveValue::CSS_COUNTER_NAME));</span>
1974         else if (is&lt;ImageContentData&gt;(*contentData))
1975             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1976         else if (is&lt;TextContentData&gt;(*contentData))
<span class="line-modified">1977             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSPrimitiveValue::CSS_STRING));</span>
1978     }
1979     return list;
1980 }
1981 
1982 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1983 {
1984     auto* map = style.counterDirectives();
1985     if (!map)
1986         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1987 
1988     auto&amp; cssValuePool = CSSValuePool::singleton();
1989     auto list = CSSValueList::createSpaceSeparated();
1990     for (auto&amp; keyValue : *map) {
<span class="line-modified">1991         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSPrimitiveValue::CSS_STRING));</span>
1992         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
<span class="line-modified">1993         list-&gt;append(cssValuePool.createValue(number, CSSPrimitiveValue::CSS_NUMBER));</span>
1994     }
1995     return list;
1996 }
1997 
<span class="line-removed">1998 static void logUnimplementedPropertyID(CSSPropertyID propertyID)</span>
<span class="line-removed">1999 {</span>
<span class="line-removed">2000     static NeverDestroyed&lt;HashSet&lt;CSSPropertyID&gt;&gt; propertyIDSet;</span>
<span class="line-removed">2001     if (!propertyIDSet.get().add(propertyID).isNewEntry)</span>
<span class="line-removed">2002         return;</span>
<span class="line-removed">2003 </span>
<span class="line-removed">2004     LOG_ERROR(&quot;WebKit does not yet implement getComputedStyle for &#39;%s&#39;.&quot;, getPropertyName(propertyID));</span>
<span class="line-removed">2005 }</span>
<span class="line-removed">2006 </span>
2007 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
2008 {
2009     auto list = CSSValueList::createCommaSeparated();
2010     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
2011         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
2012     return list;
2013 }
2014 
2015 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
2016 {
2017     if (style.fontCascade().familyCount() == 1)
2018         return valueForFamily(style.fontCascade().familyAt(0));
2019     return fontFamilyListFromStyle(style);
2020 }
2021 
2022 static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
2023 {
2024     Length length = style.lineHeight();
<span class="line-modified">2025     if (length.isNegative()) // If true, line-height not set; use the font&#39;s line spacing.</span>
<span class="line-modified">2026         return zoomAdjustedPixelValue(style.fontMetrics().floatLineSpacing(), style);</span>
2027     if (length.isPercent()) {
2028         // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
2029         // for how high to be in pixels does include things like minimum font size and the zoom factor.
2030         // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
2031         // that here either.
2032         return zoomAdjustedPixelValue(static_cast&lt;int&gt;(length.percent() * style.fontDescription().computedSize()) / 100, style);
2033     }
2034     return zoomAdjustedPixelValue(floatValueForLength(length, 0), style);
2035 }
2036 
2037 static Ref&lt;CSSPrimitiveValue&gt; fontSizeFromStyle(const RenderStyle&amp; style)
2038 {
2039     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
2040 }
2041 
2042 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
2043 {
<span class="line-modified">2044     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);</span>
2045 }
2046 
2047 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
2048 {
2049     if (auto value = fontWeightKeyword(weight))
2050         return CSSValuePool::singleton().createIdentifierValue(value.value());
2051     return fontNonKeywordWeightFromStyleValue(weight);
2052 }
2053 
2054 static Ref&lt;CSSPrimitiveValue&gt; fontWeightFromStyle(const RenderStyle&amp; style)
2055 {
2056     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
2057 }
2058 
2059 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
2060 {
<span class="line-modified">2061     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
2062 }
2063 
2064 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
2065 {
2066     if (auto keyword = fontStretchKeyword(stretch))
2067         return CSSValuePool::singleton().createIdentifierValue(keyword.value());
2068     return fontNonKeywordStretchFromStyleValue(stretch);
2069 }
2070 
2071 static Ref&lt;CSSPrimitiveValue&gt; fontStretchFromStyle(const RenderStyle&amp; style)
2072 {
2073     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
2074 }
2075 
2076 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
2077 {
<span class="line-modified">2078     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSPrimitiveValue::CSS_DEG));</span>
2079 }
2080 
2081 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
2082 {
2083     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
2084         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(keyword.value()));
2085     return fontNonKeywordStyleFromStyleValue(italic.value());
2086 }
2087 
2088 static Ref&lt;CSSFontStyleValue&gt; fontStyleFromStyle(const RenderStyle&amp; style)
2089 {
2090     return ComputedStyleExtractor::fontStyleFromStyleValue(style.fontDescription().italic(), style.fontDescription().fontStyleAxis());
2091 }
2092 
2093 static Ref&lt;CSSValue&gt; fontVariantFromStyle(const RenderStyle&amp; style)
2094 {
2095     if (style.fontDescription().variantSettings().isAllNormal())
2096         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2097 
2098     auto list = CSSValueList::createSpaceSeparated();
</pre>
<hr />
<pre>
2699     RefPtr&lt;CSSValue&gt; propertyValue = customPropertyValue(propertyName);
2700     return propertyValue ? propertyValue-&gt;cssText() : emptyString();
2701 }
2702 
2703 static Ref&lt;CSSFontValue&gt; fontShorthandValueForSelectionProperties(const FontDescription&amp; fontDescription)
2704 {
2705     auto computedFont = CSSFontValue::create();
2706 
2707     auto variantCaps = fontDescription.variantCaps();
2708     if (variantCaps == FontVariantCaps::Small)
2709         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps);
2710     else if (variantCaps == FontVariantCaps::Normal)
2711         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2712     else
2713         return CSSFontValue::create();
2714 
2715     auto weight = fontDescription.weight();
2716     if (auto value = fontWeightKeyword(weight))
2717         computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
2718     else if (isCSS21Weight(weight))
<span class="line-modified">2719         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSPrimitiveValue::CSS_NUMBER);</span>
2720     else
2721         return CSSFontValue::create();
2722 
2723     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
2724         computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
2725     else
2726         return CSSFontValue::create();
2727 
2728     if (auto italic = fontStyleKeyword(fontDescription.italic(), fontDescription.fontStyleAxis()))
2729         computedFont-&gt;style = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(italic.value()));
2730     else
2731         return CSSFontValue::create();
2732 
2733     return computedFont;
2734 }
2735 
2736 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::propertyValue(CSSPropertyID propertyID, EUpdateLayout updateLayout)
2737 {
2738     auto* styledElement = this-&gt;styledElement();
2739     if (!styledElement)
</pre>
<hr />
<pre>
2947             return zoomAdjustedPixelValue(style.borderTopWidth(), style);
2948         case CSSPropertyBorderRightWidth:
2949             return zoomAdjustedPixelValue(style.borderRightWidth(), style);
2950         case CSSPropertyBorderBottomWidth:
2951             return zoomAdjustedPixelValue(style.borderBottomWidth(), style);
2952         case CSSPropertyBorderLeftWidth:
2953             return zoomAdjustedPixelValue(style.borderLeftWidth(), style);
2954         case CSSPropertyBottom:
2955             return positionOffsetValue(style, CSSPropertyBottom, renderer);
2956         case CSSPropertyWebkitBoxAlign:
2957             return cssValuePool.createValue(style.boxAlign());
2958 #if ENABLE(CSS_BOX_DECORATION_BREAK)
2959         case CSSPropertyWebkitBoxDecorationBreak:
2960             if (style.boxDecorationBreak() == BoxDecorationBreak::Slice)
2961                 return cssValuePool.createIdentifierValue(CSSValueSlice);
2962         return cssValuePool.createIdentifierValue(CSSValueClone);
2963 #endif
2964         case CSSPropertyWebkitBoxDirection:
2965             return cssValuePool.createValue(style.boxDirection());
2966         case CSSPropertyWebkitBoxFlex:
<span class="line-modified">2967             return cssValuePool.createValue(style.boxFlex(), CSSPrimitiveValue::CSS_NUMBER);</span>
2968         case CSSPropertyWebkitBoxFlexGroup:
<span class="line-modified">2969             return cssValuePool.createValue(style.boxFlexGroup(), CSSPrimitiveValue::CSS_NUMBER);</span>
2970         case CSSPropertyWebkitBoxLines:
2971             return cssValuePool.createValue(style.boxLines());
2972         case CSSPropertyWebkitBoxOrdinalGroup:
<span class="line-modified">2973             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSPrimitiveValue::CSS_NUMBER);</span>
2974         case CSSPropertyWebkitBoxOrient:
2975             return cssValuePool.createValue(style.boxOrient());
2976         case CSSPropertyWebkitBoxPack:
2977             return cssValuePool.createValue(style.boxPack());
2978         case CSSPropertyWebkitBoxReflect:
2979             return valueForReflection(style.boxReflect(), style);
2980         case CSSPropertyBoxShadow:
2981         case CSSPropertyWebkitBoxShadow:
2982             return valueForShadow(style.boxShadow(), propertyID, style);
2983         case CSSPropertyCaptionSide:
2984             return cssValuePool.createValue(style.captionSide());
2985         case CSSPropertyCaretColor:
2986             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyCaretColor)) : currentColorOrValidColor(&amp;style, style.caretColor());
2987         case CSSPropertyClear:
2988             return cssValuePool.createValue(style.clear());
2989         case CSSPropertyColor:
2990             return cssValuePool.createColorValue(m_allowVisitedStyle ? style.visitedDependentColor(CSSPropertyColor) : style.color());
2991         case CSSPropertyWebkitPrintColorAdjust:
2992             return cssValuePool.createValue(style.printColorAdjust());
2993         case CSSPropertyWebkitColumnAxis:
2994             return cssValuePool.createValue(style.columnAxis());
2995         case CSSPropertyColumnCount:
2996             if (style.hasAutoColumnCount())
2997                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">2998             return cssValuePool.createValue(style.columnCount(), CSSPrimitiveValue::CSS_NUMBER);</span>
2999         case CSSPropertyColumnFill:
3000             return cssValuePool.createValue(style.columnFill());
3001         case CSSPropertyColumnGap:
3002             if (style.columnGap().isNormal())
3003                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3004             return zoomAdjustedPixelValueForLength(style.columnGap().length(), style);
3005         case CSSPropertyRowGap:
3006             if (style.rowGap().isNormal())
3007                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3008             return zoomAdjustedPixelValueForLength(style.rowGap().length(), style);
3009         case CSSPropertyWebkitColumnProgression:
3010             return cssValuePool.createValue(style.columnProgression());
3011         case CSSPropertyColumnRuleColor:
3012             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
3013         case CSSPropertyColumnRuleStyle:
3014             return cssValuePool.createValue(style.columnRuleStyle());
3015         case CSSPropertyColumnRuleWidth:
3016             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
3017         case CSSPropertyColumnSpan:
3018             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
3019         case CSSPropertyWebkitColumnBreakAfter:
3020             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
3021         case CSSPropertyWebkitColumnBreakBefore:
3022             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
3023         case CSSPropertyWebkitColumnBreakInside:
3024             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
3025         case CSSPropertyColumnWidth:
3026             if (style.hasAutoColumnWidth())
3027                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3028             return zoomAdjustedPixelValue(style.columnWidth(), style);
3029         case CSSPropertyTabSize:
<span class="line-modified">3030             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSPrimitiveValue::CSS_NUMBER : CSSPrimitiveValue::CSS_PX);</span>
3031         case CSSPropertyCursor: {
3032             RefPtr&lt;CSSValueList&gt; list;
3033             auto* cursors = style.cursors();
3034             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
3035                 list = CSSValueList::createCommaSeparated();
3036                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
3037                     if (StyleImage* image = cursors-&gt;at(i).image())
3038                         list-&gt;append(image-&gt;cssValue());
3039             }
3040             auto value = cssValuePool.createValue(style.cursor());
3041             if (list) {
3042                 list-&gt;append(WTFMove(value));
3043                 return list;
3044             }
3045             return value;
3046         }
3047 #if ENABLE(CURSOR_VISIBILITY)
3048         case CSSPropertyWebkitCursorVisibility:
3049             return cssValuePool.createValue(style.cursorVisibility());
3050 #endif
</pre>
<hr />
<pre>
3070             return getCSSPropertyValuesForShorthandProperties(flexFlowShorthand());
3071         case CSSPropertyFlexGrow:
3072             return cssValuePool.createValue(style.flexGrow());
3073         case CSSPropertyFlexShrink:
3074             return cssValuePool.createValue(style.flexShrink());
3075         case CSSPropertyFlexWrap:
3076             return cssValuePool.createValue(style.flexWrap());
3077         case CSSPropertyJustifyContent:
3078             return valueForContentPositionAndDistributionWithOverflowAlignment(style.justifyContent());
3079         case CSSPropertyJustifyItems:
3080             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
3081         case CSSPropertyJustifySelf:
3082             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
3083         case CSSPropertyPlaceContent:
3084             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
3085         case CSSPropertyPlaceItems:
3086             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
3087         case CSSPropertyPlaceSelf:
3088             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
3089         case CSSPropertyOrder:
<span class="line-modified">3090             return cssValuePool.createValue(style.order(), CSSPrimitiveValue::CSS_NUMBER);</span>
3091         case CSSPropertyFloat:
3092             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
3093                 return cssValuePool.createIdentifierValue(CSSValueNone);
3094             return cssValuePool.createValue(style.floating());
3095         case CSSPropertyFont: {
3096             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
3097             computedFont-&gt;size = fontSizeFromStyle(style);
3098             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
3099             computedFont-&gt;family = fontFamilyListFromStyle(style);
3100             return computedFont;
3101         }
3102         case CSSPropertyFontFamily:
3103             return fontFamilyFromStyle(style);
3104         case CSSPropertyFontSize:
3105             return fontSizeFromStyle(style);
3106         case CSSPropertyFontStyle:
3107             return fontStyleFromStyle(style);
3108         case CSSPropertyFontStretch:
3109             return fontStretchFromStyle(style);
3110         case CSSPropertyFontVariant:
</pre>
<hr />
<pre>
3186             if (!style.namedGridAreaRowCount()) {
3187                 ASSERT(!style.namedGridAreaColumnCount());
3188                 return cssValuePool.createIdentifierValue(CSSValueNone);
3189             }
3190             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
3191         case CSSPropertyGap:
3192             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
3193         case CSSPropertyHeight:
3194             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3195                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
3196                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
3197                 if (!isNonReplacedInline(*renderer))
3198                     return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);
3199             }
3200             return zoomAdjustedPixelValueForLength(style.height(), style);
3201         case CSSPropertyWebkitHyphens:
3202             return cssValuePool.createValue(style.hyphens());
3203         case CSSPropertyWebkitHyphenateCharacter:
3204             if (style.hyphenationString().isNull())
3205                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3206             return cssValuePool.createValue(style.hyphenationString(), CSSPrimitiveValue::CSS_STRING);</span>
3207         case CSSPropertyWebkitHyphenateLimitAfter:
3208             if (style.hyphenationLimitAfter() &lt; 0)
3209                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">3210             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSPrimitiveValue::CSS_NUMBER);</span>
3211         case CSSPropertyWebkitHyphenateLimitBefore:
3212             if (style.hyphenationLimitBefore() &lt; 0)
3213                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">3214             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSPrimitiveValue::CSS_NUMBER);</span>
3215         case CSSPropertyWebkitHyphenateLimitLines:
3216             if (style.hyphenationLimitLines() &lt; 0)
3217                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
<span class="line-modified">3218             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSPrimitiveValue::CSS_NUMBER);</span>
3219         case CSSPropertyWebkitBorderFit:
3220             if (style.borderFit() == BorderFit::Border)
3221                 return cssValuePool.createIdentifierValue(CSSValueBorder);
3222             return cssValuePool.createIdentifierValue(CSSValueLines);
<span class="line-removed">3223 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
3224         case CSSPropertyImageOrientation:
<span class="line-modified">3225             return cssValuePool.createValue(style.imageOrientation());</span>
<span class="line-modified">3226 #endif</span>

3227         case CSSPropertyImageRendering:
3228             return CSSPrimitiveValue::create(style.imageRendering());
3229 #if ENABLE(CSS_IMAGE_RESOLUTION)
3230         case CSSPropertyImageResolution:
<span class="line-modified">3231             return cssValuePool.createValue(style.imageResolution(), CSSPrimitiveValue::CSS_DPPX);</span>
3232 #endif
3233         case CSSPropertyLeft:
3234             return positionOffsetValue(style, CSSPropertyLeft, renderer);
3235         case CSSPropertyLetterSpacing:
3236             if (!style.letterSpacing())
3237                 return cssValuePool.createIdentifierValue(CSSValueNormal);
3238             return zoomAdjustedPixelValue(style.letterSpacing(), style);
3239         case CSSPropertyWebkitLineClamp:
3240             if (style.lineClamp().isNone())
3241                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">3242             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSPrimitiveValue::CSS_PERCENTAGE : CSSPrimitiveValue::CSS_NUMBER);</span>
3243         case CSSPropertyLineHeight:
3244             return lineHeightFromStyle(style);
3245         case CSSPropertyListStyleImage:
3246             if (style.listStyleImage())
3247                 return style.listStyleImage()-&gt;cssValue();
3248             return cssValuePool.createIdentifierValue(CSSValueNone);
3249         case CSSPropertyListStylePosition:
3250             return cssValuePool.createValue(style.listStylePosition());
3251         case CSSPropertyListStyleType:
3252             return cssValuePool.createValue(style.listStyleType());
3253         case CSSPropertyWebkitLocale:
3254             if (style.locale().isNull())
3255                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3256             return cssValuePool.createValue(style.locale(), CSSPrimitiveValue::CSS_STRING);</span>
3257         case CSSPropertyMarginTop:
3258             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
3259         case CSSPropertyMarginRight: {
3260             Length marginRight = style.marginRight();
3261             if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
3262                 return zoomAdjustedPixelValueForLength(marginRight, style);
3263             float value;
3264             if (marginRight.isPercentOrCalculated()) {
3265                 // RenderBox gives a marginRight() that is the distance between the right-edge of the child box
3266                 // and the right-edge of the containing box, when display == DisplayType::Block. Let&#39;s calculate the absolute
3267                 // value of the specified margin-right % instead of relying on RenderBox&#39;s marginRight() value.
3268                 value = minimumValueForLength(marginRight, downcast&lt;RenderBox&gt;(*renderer).containingBlockLogicalWidthForContent());
3269             } else
3270                 value = downcast&lt;RenderBox&gt;(*renderer).marginRight();
3271             return zoomAdjustedPixelValue(value, style);
3272         }
3273         case CSSPropertyMarginBottom:
3274             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
3275         case CSSPropertyMarginLeft:
3276             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);
<span class="line-removed">3277         case CSSPropertyWebkitMarqueeDirection:</span>
<span class="line-removed">3278             return cssValuePool.createValue(style.marqueeDirection());</span>
<span class="line-removed">3279         case CSSPropertyWebkitMarqueeIncrement:</span>
<span class="line-removed">3280             return cssValuePool.createValue(style.marqueeIncrement());</span>
<span class="line-removed">3281         case CSSPropertyWebkitMarqueeRepetition:</span>
<span class="line-removed">3282             if (style.marqueeLoopCount() &lt; 0)</span>
<span class="line-removed">3283                 return cssValuePool.createIdentifierValue(CSSValueInfinite);</span>
<span class="line-removed">3284             return cssValuePool.createValue(style.marqueeLoopCount(), CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-removed">3285         case CSSPropertyWebkitMarqueeStyle:</span>
<span class="line-removed">3286             return cssValuePool.createValue(style.marqueeBehavior());</span>
3287         case CSSPropertyWebkitUserModify:
3288             return cssValuePool.createValue(style.userModify());
3289         case CSSPropertyMaxHeight: {
3290             const Length&amp; maxHeight = style.maxHeight();
3291             if (maxHeight.isUndefined())
3292                 return cssValuePool.createIdentifierValue(CSSValueNone);
3293             return zoomAdjustedPixelValueForLength(maxHeight, style);
3294         }
3295         case CSSPropertyMaxWidth: {
3296             const Length&amp; maxWidth = style.maxWidth();
3297             if (maxWidth.isUndefined())
3298                 return cssValuePool.createIdentifierValue(CSSValueNone);
3299             return zoomAdjustedPixelValueForLength(maxWidth, style);
3300         }
3301         case CSSPropertyMinHeight:
3302             if (style.minHeight().isAuto()) {
3303                 auto* styledElement = this-&gt;styledElement();
3304                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3305                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3306                 return zoomAdjustedPixelValue(0, style);
3307             }
3308             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
3309         case CSSPropertyMinWidth:
3310             if (style.minWidth().isAuto()) {
3311                 auto* styledElement = this-&gt;styledElement();
3312                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
3313                     return cssValuePool.createIdentifierValue(CSSValueAuto);
3314                 return zoomAdjustedPixelValue(0, style);
3315             }
3316             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
3317         case CSSPropertyObjectFit:
3318             return cssValuePool.createValue(style.objectFit());
3319         case CSSPropertyObjectPosition: {
3320             auto list = CSSValueList::createSpaceSeparated();
3321             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
3322             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
3323             return list;
3324         }
3325         case CSSPropertyOpacity:
<span class="line-modified">3326             return cssValuePool.createValue(style.opacity(), CSSPrimitiveValue::CSS_NUMBER);</span>
3327         case CSSPropertyOrphans:
3328             if (style.hasAutoOrphans())
3329                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3330             return cssValuePool.createValue(style.orphans(), CSSPrimitiveValue::CSS_NUMBER);</span>
3331         case CSSPropertyOutlineColor:
3332             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
3333         case CSSPropertyOutlineOffset:
3334             return zoomAdjustedPixelValue(style.outlineOffset(), style);
3335         case CSSPropertyOutlineStyle:
3336             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
3337                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3338             return cssValuePool.createValue(style.outlineStyle());
3339         case CSSPropertyOutlineWidth:
3340             return zoomAdjustedPixelValue(style.outlineWidth(), style);
3341         case CSSPropertyOverflow:
<span class="line-modified">3342             return cssValuePool.createValue(std::max(style.overflowX(), style.overflowY()));</span>
3343         case CSSPropertyOverflowWrap:
3344             return cssValuePool.createValue(style.overflowWrap());
3345         case CSSPropertyOverflowX:
3346             return cssValuePool.createValue(style.overflowX());
3347         case CSSPropertyOverflowY:
3348             return cssValuePool.createValue(style.overflowY());
3349         case CSSPropertyPaddingTop:
3350             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingTop, &amp;RenderBoxModelObject::computedCSSPaddingTop&gt;(style, renderer);
3351         case CSSPropertyPaddingRight:
3352             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingRight, &amp;RenderBoxModelObject::computedCSSPaddingRight&gt;(style, renderer);
3353         case CSSPropertyPaddingBottom:
3354             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingBottom, &amp;RenderBoxModelObject::computedCSSPaddingBottom&gt;(style, renderer);
3355         case CSSPropertyPaddingLeft:
3356             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingLeft, &amp;RenderBoxModelObject::computedCSSPaddingLeft&gt;(style, renderer);
3357         case CSSPropertyPageBreakAfter:
3358             return cssValuePool.createValue(convertToPageBreak(style.breakAfter()));
3359         case CSSPropertyPageBreakBefore:
3360             return cssValuePool.createValue(convertToPageBreak(style.breakBefore()));
3361         case CSSPropertyPageBreakInside:
3362             return cssValuePool.createValue(convertToPageBreak(style.breakInside()));
</pre>
<hr />
<pre>
3398             return renderTextDecorationSkipFlagsToCSSValue(style.textDecorationSkip());
3399         case CSSPropertyTextUnderlinePosition:
3400             return cssValuePool.createValue(style.textUnderlinePosition());
3401         case CSSPropertyTextUnderlineOffset:
3402             return textUnderlineOffsetToCSSValue(style.textUnderlineOffset());
3403         case CSSPropertyTextDecorationThickness:
3404             return textDecorationThicknessToCSSValue(style.textDecorationThickness());
3405         case CSSPropertyWebkitTextDecorationsInEffect:
3406             return renderTextDecorationFlagsToCSSValue(style.textDecorationsInEffect());
3407         case CSSPropertyWebkitTextFillColor:
3408             return currentColorOrValidColor(&amp;style, style.textFillColor());
3409         case CSSPropertyWebkitTextEmphasisColor:
3410             return currentColorOrValidColor(&amp;style, style.textEmphasisColor());
3411         case CSSPropertyWebkitTextEmphasisPosition:
3412             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3413         case CSSPropertyWebkitTextEmphasisStyle:
3414             switch (style.textEmphasisMark()) {
3415             case TextEmphasisMark::None:
3416                 return cssValuePool.createIdentifierValue(CSSValueNone);
3417             case TextEmphasisMark::Custom:
<span class="line-modified">3418                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSPrimitiveValue::CSS_STRING);</span>
3419             case TextEmphasisMark::Auto:
3420                 ASSERT_NOT_REACHED();
<span class="line-modified">3421 #if ASSERT_DISABLED</span>
3422                 FALLTHROUGH;
3423 #endif
3424             case TextEmphasisMark::Dot:
3425             case TextEmphasisMark::Circle:
3426             case TextEmphasisMark::DoubleCircle:
3427             case TextEmphasisMark::Triangle:
3428             case TextEmphasisMark::Sesame:
3429                 auto list = CSSValueList::createSpaceSeparated();
3430                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3431                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
3432                 return list;
3433             }
3434             RELEASE_ASSERT_NOT_REACHED();
3435         case CSSPropertyTextIndent: {
3436             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3437             // getPropertyCSSValue() returns CSSValue.
3438             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3439 #if ENABLE(CSS3_TEXT)
3440             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3441             // getPropertyCSSValue() returns CSSValueList.
</pre>
<hr />
<pre>
3450             }
3451 #endif
3452             return textIndent;
3453         }
3454         case CSSPropertyTextShadow:
3455             return valueForShadow(style.textShadow(), propertyID, style);
3456         case CSSPropertyTextRendering:
3457             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3458         case CSSPropertyTextOverflow:
3459             if (style.textOverflow() == TextOverflow::Ellipsis)
3460                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3461             return cssValuePool.createIdentifierValue(CSSValueClip);
3462         case CSSPropertyWebkitTextSecurity:
3463             return cssValuePool.createValue(style.textSecurity());
3464 #if ENABLE(TEXT_AUTOSIZING)
3465         case CSSPropertyWebkitTextSizeAdjust:
3466             if (style.textSizeAdjust().isAuto())
3467                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3468             if (style.textSizeAdjust().isNone())
3469                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">3470             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
3471 #endif
3472         case CSSPropertyWebkitTextStrokeColor:
3473             return currentColorOrValidColor(&amp;style, style.textStrokeColor());
3474         case CSSPropertyWebkitTextStrokeWidth:
3475             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
3476         case CSSPropertyTextTransform:
3477             return cssValuePool.createValue(style.textTransform());
3478         case CSSPropertyTop:
3479             return positionOffsetValue(style, CSSPropertyTop, renderer);
3480         case CSSPropertyUnicodeBidi:
3481             return cssValuePool.createValue(style.unicodeBidi());
3482         case CSSPropertyVerticalAlign:
3483             switch (style.verticalAlign()) {
3484             case VerticalAlign::Baseline:
3485                 return cssValuePool.createIdentifierValue(CSSValueBaseline);
3486             case VerticalAlign::Middle:
3487                 return cssValuePool.createIdentifierValue(CSSValueMiddle);
3488             case VerticalAlign::Sub:
3489                 return cssValuePool.createIdentifierValue(CSSValueSub);
3490             case VerticalAlign::Super:
</pre>
<hr />
<pre>
3494             case VerticalAlign::TextBottom:
3495                 return cssValuePool.createIdentifierValue(CSSValueTextBottom);
3496             case VerticalAlign::Top:
3497                 return cssValuePool.createIdentifierValue(CSSValueTop);
3498             case VerticalAlign::Bottom:
3499                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3500             case VerticalAlign::BaselineMiddle:
3501                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3502             case VerticalAlign::Length:
3503                 return cssValuePool.createValue(style.verticalAlignLength());
3504             }
3505             ASSERT_NOT_REACHED();
3506             return nullptr;
3507         case CSSPropertyVisibility:
3508             return cssValuePool.createValue(style.visibility());
3509         case CSSPropertyWhiteSpace:
3510             return cssValuePool.createValue(style.whiteSpace());
3511         case CSSPropertyWidows:
3512             if (style.hasAutoWidows())
3513                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3514             return cssValuePool.createValue(style.widows(), CSSPrimitiveValue::CSS_NUMBER);</span>
3515         case CSSPropertyWidth:
3516             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3517                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3518                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
3519                 if (!isNonReplacedInline(*renderer))
3520                     return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);
3521             }
3522             return zoomAdjustedPixelValueForLength(style.width(), style);
3523         case CSSPropertyWillChange:
3524             return willChangePropertyValue(style.willChange());
3525         case CSSPropertyWordBreak:
3526             return cssValuePool.createValue(style.wordBreak());
3527         case CSSPropertyWordSpacing:
3528             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3529         case CSSPropertyWordWrap:
3530             return cssValuePool.createValue(style.overflowWrap());
3531         case CSSPropertyLineBreak:
3532             return cssValuePool.createValue(style.lineBreak());
3533         case CSSPropertyWebkitNbspMode:
3534             return cssValuePool.createValue(style.nbspMode());
3535         case CSSPropertyResize:
3536             return cssValuePool.createValue(style.resize());
3537         case CSSPropertyWebkitFontKerning:
3538             return cssValuePool.createValue(style.fontDescription().kerning());
3539         case CSSPropertyWebkitFontSmoothing:
3540             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
3541         case CSSPropertyFontVariantLigatures:
3542             return fontVariantLigaturesPropertyValue(style.fontDescription().variantCommonLigatures(), style.fontDescription().variantDiscretionaryLigatures(), style.fontDescription().variantHistoricalLigatures(), style.fontDescription().variantContextualAlternates());
3543         case CSSPropertyFontVariantPosition:
3544             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3545         case CSSPropertyFontVariantCaps:
3546             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3547         case CSSPropertyFontVariantNumeric:
3548             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3549         case CSSPropertyFontVariantAlternates:
3550             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3551         case CSSPropertyFontVariantEastAsian:
3552             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3553         case CSSPropertyZIndex:
<span class="line-modified">3554             if (style.hasAutoZIndex())</span>
3555                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3556             return cssValuePool.createValue(style.zIndex(), CSSPrimitiveValue::CSS_NUMBER);</span>
3557         case CSSPropertyZoom:
<span class="line-modified">3558             return cssValuePool.createValue(style.zoom(), CSSPrimitiveValue::CSS_NUMBER);</span>
3559         case CSSPropertyBoxSizing:
3560             if (style.boxSizing() == BoxSizing::ContentBox)
3561                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3562             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
3563         case CSSPropertyAnimationDelay:
3564             return delayValue(style.animations());
3565         case CSSPropertyAnimationDirection: {
3566             auto list = CSSValueList::createCommaSeparated();
3567             const AnimationList* t = style.animations();
3568             if (t) {
3569                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3570                     switch (t-&gt;animation(i).direction()) {
3571                     case Animation::AnimationDirectionNormal:
3572                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3573                         break;
3574                     case Animation::AnimationDirectionAlternate:
3575                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3576                         break;
3577                     case Animation::AnimationDirectionReverse:
3578                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
</pre>
<hr />
<pre>
3604                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3605                         break;
3606                     case AnimationFillMode::Both:
3607                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3608                         break;
3609                     }
3610                 }
3611             } else
3612                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3613             return list;
3614         }
3615         case CSSPropertyAnimationIterationCount: {
3616             auto list = CSSValueList::createCommaSeparated();
3617             const AnimationList* t = style.animations();
3618             if (t) {
3619                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3620                     double iterationCount = t-&gt;animation(i).iterationCount();
3621                     if (iterationCount == Animation::IterationCountInfinite)
3622                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3623                     else
<span class="line-modified">3624                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSPrimitiveValue::CSS_NUMBER));</span>
3625                 }
3626             } else
<span class="line-modified">3627                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSPrimitiveValue::CSS_NUMBER));</span>
3628             return list;
3629         }
3630         case CSSPropertyAnimationName: {
3631             auto list = CSSValueList::createCommaSeparated();
3632             const AnimationList* t = style.animations();
3633             if (t) {
3634                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
<span class="line-modified">3635                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSPrimitiveValue::CSS_STRING));</span>
3636             } else
3637                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3638             return list;
3639         }
3640         case CSSPropertyAnimationPlayState: {
3641             auto list = CSSValueList::createCommaSeparated();
3642             const AnimationList* t = style.animations();
3643             if (t) {
3644                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3645                     switch (t-&gt;animation(i).playState()) {
3646                     case AnimationPlayState::Playing:
3647                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3648                         break;
3649                     case AnimationPlayState::Paused:
3650                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3651                         break;
3652                     }
3653                 }
3654             } else
3655                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
</pre>
<hr />
<pre>
3685         case CSSPropertyBorderImageWidth:
3686             return valueForNinePieceImageQuad(style.borderImage().borderSlices());
3687         case CSSPropertyWebkitMaskBoxImage:
3688             return valueForNinePieceImage(style.maskBoxImage());
3689         case CSSPropertyWebkitMaskBoxImageOutset:
3690             return valueForNinePieceImageQuad(style.maskBoxImage().outset());
3691         case CSSPropertyWebkitMaskBoxImageRepeat:
3692             return valueForNinePieceImageRepeat(style.maskBoxImage());
3693         case CSSPropertyWebkitMaskBoxImageSlice:
3694             return valueForNinePieceImageSlice(style.maskBoxImage());
3695         case CSSPropertyWebkitMaskBoxImageWidth:
3696             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3697         case CSSPropertyWebkitMaskBoxImageSource:
3698             if (style.maskBoxImageSource())
3699                 return style.maskBoxImageSource()-&gt;cssValue();
3700             return cssValuePool.createIdentifierValue(CSSValueNone);
3701         case CSSPropertyWebkitFontSizeDelta:
3702             // Not a real style property -- used by the editing engine -- so has no computed value.
3703             break;
3704         case CSSPropertyWebkitInitialLetter: {
<span class="line-modified">3705             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-modified">3706             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSPrimitiveValue::CSS_NUMBER);</span>
3707             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3708         }
3709         case CSSPropertyWebkitMarginBottomCollapse:
3710         case CSSPropertyWebkitMarginAfterCollapse:
3711             return cssValuePool.createValue(style.marginAfterCollapse());
3712         case CSSPropertyWebkitMarginTopCollapse:
3713         case CSSPropertyWebkitMarginBeforeCollapse:
3714             return cssValuePool.createValue(style.marginBeforeCollapse());
3715 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
3716         case CSSPropertyWebkitOverflowScrolling:
3717             if (!style.useTouchOverflowScrolling())
3718                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3719             return cssValuePool.createIdentifierValue(CSSValueTouch);
3720 #endif




3721         case CSSPropertyPerspective:
3722             if (!style.hasPerspective())
3723                 return cssValuePool.createIdentifierValue(CSSValueNone);
3724             return zoomAdjustedPixelValue(style.perspective(), style);
3725         case CSSPropertyPerspectiveOrigin: {
3726             auto list = CSSValueList::createSpaceSeparated();
3727             if (renderer) {
3728                 LayoutRect box;
3729                 if (is&lt;RenderBox&gt;(*renderer))
3730                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3731 
3732                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3733                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3734             } else {
3735                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3736                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3737             }
3738             return list;
3739         }
3740         case CSSPropertyWebkitRtlOrdering:
</pre>
<hr />
<pre>
3799             return list;
3800         }
3801         case CSSPropertyTransformStyle:
3802         case CSSPropertyWebkitTransformStyle:
3803             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3804         case CSSPropertyTransitionDelay:
3805             return delayValue(style.transitions());
3806         case CSSPropertyTransitionDuration:
3807             return durationValue(style.transitions());
3808         case CSSPropertyTransitionProperty:
3809             return transitionPropertyValue(style.transitions());
3810         case CSSPropertyTransitionTimingFunction:
3811             return timingFunctionValue(style.transitions());
3812         case CSSPropertyTransition: {
3813             if (auto* animationList = style.transitions()) {
3814                 auto transitionsList = CSSValueList::createCommaSeparated();
3815                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3816                     auto list = CSSValueList::createSpaceSeparated();
3817                     auto&amp; animation = animationList-&gt;animation(i);
3818                     list-&gt;append(createTransitionPropertyValue(animation));
<span class="line-modified">3819                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSPrimitiveValue::CSS_S));</span>
3820                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
<span class="line-modified">3821                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSPrimitiveValue::CSS_S));</span>
3822                     transitionsList-&gt;append(WTFMove(list));
3823                 }
3824                 return transitionsList;
3825             }
3826 
3827             auto list = CSSValueList::createSpaceSeparated();
3828             // transition-property default value.
3829             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
<span class="line-modified">3830             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSPrimitiveValue::CSS_S));</span>
3831             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
<span class="line-modified">3832             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSPrimitiveValue::CSS_S));</span>
3833             return list;
3834         }
3835         case CSSPropertyPointerEvents:
3836             return cssValuePool.createValue(style.pointerEvents());
3837         case CSSPropertyWebkitLineGrid:
3838             if (style.lineGrid().isNull())
3839                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">3840             return cssValuePool.createValue(style.lineGrid(), CSSPrimitiveValue::CSS_STRING);</span>
3841         case CSSPropertyWebkitLineSnap:
3842             return CSSPrimitiveValue::create(style.lineSnap());
3843         case CSSPropertyWebkitLineAlign:
3844             return CSSPrimitiveValue::create(style.lineAlign());
3845         case CSSPropertyWritingMode:
3846             return cssValuePool.createValue(style.writingMode());
3847         case CSSPropertyWebkitTextCombine:
3848             return cssValuePool.createValue(style.textCombine());
3849         case CSSPropertyWebkitTextOrientation:
3850             return CSSPrimitiveValue::create(style.textOrientation());
3851         case CSSPropertyWebkitLineBoxContain:
3852             return createLineBoxContainValue(style.lineBoxContain());
3853         case CSSPropertyAlt:
3854             return altTextToCSSValue(style);
3855         case CSSPropertyContent:
3856             return contentToCSSValue(style);
3857         case CSSPropertyCounterIncrement:
3858             return counterToCSSValue(style, propertyID);
3859         case CSSPropertyCounterReset:
3860             return counterToCSSValue(style, propertyID);
<span class="line-modified">3861         case CSSPropertyWebkitClipPath: {</span>
3862             auto* operation = style.clipPath();
3863             if (!operation)
3864                 return cssValuePool.createIdentifierValue(CSSValueNone);
3865             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
<span class="line-modified">3866                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSPrimitiveValue::CSS_URI);</span>
3867             auto list = CSSValueList::createSpaceSeparated();
3868             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3869                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3870                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3871                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3872                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3873             }
3874             if (is&lt;BoxClipPathOperation&gt;(*operation))
3875                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
3876             return list;
3877         }
3878         case CSSPropertyShapeMargin:
3879             return cssValuePool.createValue(style.shapeMargin(), style);
3880         case CSSPropertyShapeImageThreshold:
<span class="line-modified">3881             return cssValuePool.createValue(style.shapeImageThreshold(), CSSPrimitiveValue::CSS_NUMBER);</span>
3882         case CSSPropertyShapeOutside:
3883             return shapePropertyValue(style, style.shapeOutside());
3884         case CSSPropertyFilter:
3885             return valueForFilter(style, style.filter());
3886         case CSSPropertyAppleColorFilter:
3887             return valueForFilter(style, style.appleColorFilter());
3888 #if ENABLE(FILTERS_LEVEL_2)
3889         case CSSPropertyWebkitBackdropFilter:
3890             return valueForFilter(style, style.backdropFilter());
3891 #endif
3892 #if ENABLE(CSS_COMPOSITING)
3893         case CSSPropertyMixBlendMode:
3894             return cssValuePool.createValue(style.blendMode());
3895         case CSSPropertyIsolation:
3896             return cssValuePool.createValue(style.isolation());
3897 #endif
3898         case CSSPropertyBackgroundBlendMode: {
3899             auto&amp; layers = style.backgroundLayers();
3900             if (!layers.next())
3901                 return cssValuePool.createValue(layers.blendMode());
</pre>
<hr />
<pre>
4059         case CSSPropertyStrokeDashoffset:
4060             return zoomAdjustedPixelValueForLength(style.svgStyle().strokeDashOffset(), style);
4061         case CSSPropertyX:
4062             return zoomAdjustedPixelValueForLength(style.svgStyle().x(), style);
4063         case CSSPropertyY:
4064             return zoomAdjustedPixelValueForLength(style.svgStyle().y(), style);
4065         case CSSPropertyWebkitTextZoom:
4066             return cssValuePool.createValue(style.textZoom());
4067 
4068         case CSSPropertyPaintOrder:
4069             return paintOrder(style.paintOrder());
4070         case CSSPropertyStrokeLinecap:
4071             return CSSPrimitiveValue::create(style.capStyle());
4072         case CSSPropertyStrokeLinejoin:
4073             return CSSPrimitiveValue::create(style.joinStyle());
4074         case CSSPropertyStrokeWidth:
4075             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
4076         case CSSPropertyStrokeColor:
4077             return currentColorOrValidColor(&amp;style, style.strokeColor());
4078         case CSSPropertyStrokeMiterlimit:
<span class="line-modified">4079             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSPrimitiveValue::CSS_NUMBER);</span>
4080 
4081         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
4082         case CSSPropertyAll:
4083         case CSSPropertyAnimation:
4084         case CSSPropertyWebkitTextEmphasis:
4085             break;
4086 
4087         /* Directional properties are resolved by resolveDirectionAwareProperty() before the switch. */
4088         case CSSPropertyBorderBlockEnd:
4089         case CSSPropertyBorderBlockEndColor:
4090         case CSSPropertyBorderBlockEndStyle:
4091         case CSSPropertyBorderBlockEndWidth:
4092         case CSSPropertyBorderBlockStart:
4093         case CSSPropertyBorderBlockStartColor:
4094         case CSSPropertyBorderBlockStartStyle:
4095         case CSSPropertyBorderBlockStartWidth:
4096         case CSSPropertyBorderInlineEnd:
4097         case CSSPropertyBorderInlineEndColor:
4098         case CSSPropertyBorderInlineEndStyle:
4099         case CSSPropertyBorderInlineEndWidth:
</pre>
<hr />
<pre>
4120         case CSSPropertyMinBlockSize:
4121         case CSSPropertyMinInlineSize:
4122             ASSERT_NOT_REACHED();
4123             break;
4124 
4125         /* Unimplemented @font-face properties */
4126         case CSSPropertySrc:
4127         case CSSPropertyUnicodeRange:
4128         case CSSPropertyFontDisplay:
4129             break;
4130 
4131         /* Other unimplemented properties */
4132         case CSSPropertyPage: // for @page
4133         case CSSPropertyQuotes: // FIXME: needs implementation
4134         case CSSPropertySize: // for @page
4135             break;
4136 
4137         /* Unimplemented -webkit- properties */
4138         case CSSPropertyWebkitBorderRadius:
4139         case CSSPropertyWebkitMarginCollapse:
<span class="line-modified">4140         case CSSPropertyWebkitMarquee:</span>



4141         case CSSPropertyWebkitMarqueeSpeed:
4142         case CSSPropertyWebkitMask:
4143         case CSSPropertyWebkitMaskRepeatX:
4144         case CSSPropertyWebkitMaskRepeatY:
4145         case CSSPropertyPerspectiveOriginX:
4146         case CSSPropertyPerspectiveOriginY:
4147         case CSSPropertyWebkitTextStroke:
4148         case CSSPropertyTransformOriginX:
4149         case CSSPropertyTransformOriginY:
4150         case CSSPropertyTransformOriginZ:
4151             break;
4152 
4153 #if ENABLE(CSS_DEVICE_ADAPTATION)
4154         case CSSPropertyMaxZoom:
4155         case CSSPropertyMinZoom:
4156         case CSSPropertyOrientation:
4157         case CSSPropertyUserZoom:
4158             break;
4159 #endif
4160 
4161         case CSSPropertyBufferedRendering:
<span class="line-removed">4162         case CSSPropertyClipPath:</span>
4163         case CSSPropertyClipRule:
4164         case CSSPropertyMask:
4165         case CSSPropertyEnableBackground:
4166         case CSSPropertyFloodColor:
4167         case CSSPropertyFloodOpacity:
4168         case CSSPropertyLightingColor:
4169         case CSSPropertyStopColor:
4170         case CSSPropertyStopOpacity:
4171         case CSSPropertyColorInterpolation:
4172         case CSSPropertyColorInterpolationFilters:
4173         case CSSPropertyColorProfile:
4174         case CSSPropertyColorRendering:
4175         case CSSPropertyFill:
4176         case CSSPropertyFillOpacity:
4177         case CSSPropertyFillRule:
4178         case CSSPropertyMarker:
4179         case CSSPropertyMarkerEnd:
4180         case CSSPropertyMarkerMid:
4181         case CSSPropertyMarkerStart:
4182         case CSSPropertyMaskType:
4183         case CSSPropertyShapeRendering:
4184         case CSSPropertyStroke:
4185         case CSSPropertyStrokeDasharray:
4186         case CSSPropertyStrokeOpacity:
4187         case CSSPropertyAlignmentBaseline:
4188         case CSSPropertyBaselineShift:
4189         case CSSPropertyDominantBaseline:
4190         case CSSPropertyGlyphOrientationHorizontal:
4191         case CSSPropertyGlyphOrientationVertical:
4192         case CSSPropertyKerning:
4193         case CSSPropertyTextAnchor:
4194         case CSSPropertyVectorEffect:
4195             return svgPropertyValue(propertyID);
4196         case CSSPropertyCustom:
4197             ASSERT_NOT_REACHED();
4198             return nullptr;
4199     }
4200 
<span class="line-removed">4201     logUnimplementedPropertyID(propertyID);</span>
4202     return nullptr;
4203 }
4204 
4205 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
4206 {
4207     auto value = getPropertyCSSValue(propertyID);
4208     if (!value)
4209         return emptyString(); // FIXME: Should this be null instead, as it is in StyleProperties::getPropertyValue?
4210     return value-&gt;cssText();
4211 }
4212 
4213 unsigned CSSComputedStyleDeclaration::length() const
4214 {
4215     updateStyleIfNeededForProperty(m_element.get(), CSSPropertyCustom);
4216 
4217     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4218     if (!style)
4219         return 0;
4220 
<span class="line-modified">4221     return numComputedProperties + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();</span>
4222 }
4223 
4224 String CSSComputedStyleDeclaration::item(unsigned i) const
4225 {
4226     if (i &gt;= length())
4227         return String();
4228 
<span class="line-modified">4229     if (i &lt; numComputedProperties)</span>
<span class="line-modified">4230         return getPropertyNameString(computedProperties[i]);</span>
4231 
4232     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
4233     if (!style)
4234         return String();
4235 
4236     const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
4237 
<span class="line-modified">4238     if (i &lt; numComputedProperties + inheritedCustomProperties.size()) {</span>
4239         auto results = copyToVector(inheritedCustomProperties.keys());
<span class="line-modified">4240         return results.at(i - numComputedProperties);</span>
4241     }
4242 
4243     const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
4244     auto results = copyToVector(nonInheritedCustomProperties.keys());
<span class="line-modified">4245     return results.at(i - inheritedCustomProperties.size() - numComputedProperties);</span>
4246 }
4247 
4248 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
4249 {
4250     if (!m_element)
4251         return false;
4252     if (propertyID == CSSPropertyFontSize &amp;&amp; is&lt;CSSPrimitiveValue&gt;(*value)) {
4253         m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
4254         if (auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier)) {
4255             if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier()) {
4256                 auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
4257                 if (primitiveValue.isValueID() &amp;&amp; primitiveValue.valueID() == sizeIdentifier)
4258                     return true;
4259             }
4260         }
4261     }
4262     RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
4263     return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
4264 }
4265 
<span class="line-removed">4266 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()</span>
<span class="line-removed">4267 {</span>
<span class="line-removed">4268     return copyPropertiesInSet(computedProperties, numComputedProperties);</span>
<span class="line-removed">4269 }</span>
<span class="line-removed">4270 </span>
4271 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
4272 {
4273     auto list = CSSValueList::createSpaceSeparated();
4274     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4275         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4276     return list;
4277 }
4278 
4279 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
4280 {
4281     auto list = CSSValueList::createSpaceSeparated();
4282 
4283     // Assume the properties are in the usual order start, end.
4284     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
4285     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
4286 
4287     // All 2 properties must be specified.
4288     if (!startValue || !endValue)
4289         return nullptr;
4290 
</pre>
<hr />
<pre>
4319     if (showRight)
4320         list-&gt;append(rightValue.releaseNonNull());
4321     if (showBottom)
4322         list-&gt;append(bottomValue.releaseNonNull());
4323     if (showLeft)
4324         list-&gt;append(leftValue.releaseNonNull());
4325 
4326     return list;
4327 }
4328 
4329 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
4330 {
4331     auto list = CSSValueList::createSlashSeparated();
4332     for (size_t i = 0; i &lt; shorthand.length(); ++i)
4333         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
4334     return list;
4335 }
4336 
4337 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
4338 {
<span class="line-modified">4339     Vector&lt;CSSProperty, 256&gt; list;</span>
4340     list.reserveInitialCapacity(length);
4341     for (unsigned i = 0; i &lt; length; ++i) {
4342         if (auto value = propertyValue(set[i]))
4343             list.append(CSSProperty(set[i], WTFMove(value), false));
4344     }
<span class="line-modified">4345     return MutableStyleProperties::create(list.data(), list.size());</span>












4346 }
4347 
4348 CSSRule* CSSComputedStyleDeclaration::parentRule() const
4349 {
4350     return nullptr;
4351 }
4352 
4353 RefPtr&lt;DeprecatedCSSOMValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(const String&amp; propertyName)
4354 {
4355     if (isCustomPropertyName(propertyName)) {
4356         auto value = ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyValue(propertyName);
4357         if (!value)
4358             return nullptr;
4359         return value-&gt;createDeprecatedCSSOMWrapper(*this);
4360     }
4361 
4362     CSSPropertyID propertyID = cssPropertyID(propertyName);
4363     if (!propertyID)
4364         return nullptr;
4365     auto value = getPropertyCSSValue(propertyID);
</pre>
</td>
<td>
<hr />
<pre>
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, write to the Free Software
  21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  22  * 02110-1301  USA
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 
  28 #include &quot;BasicShapeFunctions.h&quot;
  29 #include &quot;CSSAnimationController.h&quot;
  30 #include &quot;CSSAspectRatioValue.h&quot;
  31 #include &quot;CSSBasicShapes.h&quot;
  32 #include &quot;CSSBorderImage.h&quot;
  33 #include &quot;CSSBorderImageSliceValue.h&quot;
  34 #include &quot;CSSFontFeatureValue.h&quot;
  35 #include &quot;CSSFontStyleValue.h&quot;
  36 #include &quot;CSSFontValue.h&quot;
  37 #include &quot;CSSFontVariationValue.h&quot;
  38 #include &quot;CSSFunctionValue.h&quot;
<span class="line-added">  39 #include &quot;CSSGridAutoRepeatValue.h&quot;</span>
  40 #include &quot;CSSLineBoxContainValue.h&quot;
  41 #include &quot;CSSPrimitiveValue.h&quot;
  42 #include &quot;CSSPrimitiveValueMappings.h&quot;
  43 #include &quot;CSSPropertyNames.h&quot;
  44 #include &quot;CSSPropertyParser.h&quot;
  45 #include &quot;CSSReflectValue.h&quot;
  46 #include &quot;CSSSelector.h&quot;
  47 #include &quot;CSSShadowValue.h&quot;
  48 #include &quot;CSSTimingFunctionValue.h&quot;
  49 #include &quot;CSSValueList.h&quot;
  50 #include &quot;CSSValuePool.h&quot;
  51 #include &quot;ComposedTreeAncestorIterator.h&quot;
  52 #include &quot;ContentData.h&quot;
  53 #include &quot;CursorList.h&quot;
  54 #include &quot;DeprecatedCSSOMValue.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentTimeline.h&quot;
  57 #include &quot;FontCascade.h&quot;
  58 #include &quot;FontSelectionValueInlines.h&quot;
  59 #include &quot;FontTaggedSettings.h&quot;
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;Pair.h&quot;
  62 #include &quot;Rect.h&quot;
  63 #include &quot;RenderBlock.h&quot;
  64 #include &quot;RenderBox.h&quot;
  65 #include &quot;RenderInline.h&quot;
  66 #include &quot;RenderStyle.h&quot;

  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
  79 #include &lt;wtf/IsoMallocInlines.h&gt;
  80 #include &lt;wtf/NeverDestroyed.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 #include &quot;CSSGridLineNamesValue.h&quot;
  84 #include &quot;CSSGridTemplateAreasValue.h&quot;
  85 #include &quot;RenderGrid.h&quot;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
  90 
<span class="line-modified">  91 static CSSValueID valueForRepeatRule(NinePieceImageRule rule)</span>






























































































































































































































































































































































































  92 {
  93     switch (rule) {
<span class="line-modified">  94     case NinePieceImageRule::Repeat:</span>
<span class="line-modified">  95         return CSSValueRepeat;</span>
<span class="line-modified">  96     case NinePieceImageRule::Round:</span>
<span class="line-modified">  97         return CSSValueRound;</span>
<span class="line-modified">  98     case NinePieceImageRule::Space:</span>
<span class="line-modified">  99         return CSSValueSpace;</span>
<span class="line-modified"> 100     default:</span>
<span class="line-modified"> 101         return CSSValueStretch;</span>
 102     }
 103 }
 104 
 105 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 106 {
 107     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
 108     // a calculation that combines a percentage and a number.
 109     if (length.isPercent())
<span class="line-modified"> 110         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);</span>
 111     if (length.isFixed())
<span class="line-modified"> 112         return CSSValuePool::singleton().createValue(length.value(), CSSUnitType::CSS_NUMBER);</span>
 113 
 114     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
 115     // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
 116     // FIXME: For now, just return 0.
 117     ASSERT(length.isCalculated());
<span class="line-modified"> 118     return CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_NUMBER);</span>
 119 }
 120 
 121 static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
 122 {
 123     auto&amp; slices = image.imageSlices();
 124 
 125     RefPtr&lt;CSSPrimitiveValue&gt; top = valueForImageSliceSide(slices.top());
 126 
 127     RefPtr&lt;CSSPrimitiveValue&gt; right;
 128     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 129     RefPtr&lt;CSSPrimitiveValue&gt; left;
 130 
 131     if (slices.right() == slices.top() &amp;&amp; slices.bottom() == slices.top() &amp;&amp; slices.left() == slices.top()) {
 132         right = top;
 133         bottom = top;
 134         left = top;
 135     } else {
 136         right = valueForImageSliceSide(slices.right());
 137 
 138         if (slices.bottom() == slices.top() &amp;&amp; slices.right() == slices.left()) {
</pre>
<hr />
<pre>
 150 
 151     auto quad = Quad::create();
 152     quad-&gt;setTop(WTFMove(top));
 153     quad-&gt;setRight(WTFMove(right));
 154     quad-&gt;setBottom(WTFMove(bottom));
 155     quad-&gt;setLeft(WTFMove(left));
 156 
 157     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), image.fill());
 158 }
 159 
 160 static Ref&lt;CSSPrimitiveValue&gt; valueForNinePieceImageQuad(const LengthBox&amp; box)
 161 {
 162     RefPtr&lt;CSSPrimitiveValue&gt; top;
 163     RefPtr&lt;CSSPrimitiveValue&gt; right;
 164     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 165     RefPtr&lt;CSSPrimitiveValue&gt; left;
 166 
 167     auto&amp; cssValuePool = CSSValuePool::singleton();
 168 
 169     if (box.top().isRelative())
<span class="line-modified"> 170         top = cssValuePool.createValue(box.top().value(), CSSUnitType::CSS_NUMBER);</span>
 171     else
 172         top = cssValuePool.createValue(box.top());
 173 
 174     if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
 175         right = top;
 176         bottom = top;
 177         left = top;
 178     } else {
 179         if (box.right().isRelative())
<span class="line-modified"> 180             right = cssValuePool.createValue(box.right().value(), CSSUnitType::CSS_NUMBER);</span>
 181         else
 182             right = cssValuePool.createValue(box.right());
 183 
 184         if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
 185             bottom = top;
 186             left = right;
 187         } else {
 188             if (box.bottom().isRelative())
<span class="line-modified"> 189                 bottom = cssValuePool.createValue(box.bottom().value(), CSSUnitType::CSS_NUMBER);</span>
 190             else
 191                 bottom = cssValuePool.createValue(box.bottom());
 192 
 193             if (box.left() == box.right())
 194                 left = right;
 195             else {
 196                 if (box.left().isRelative())
<span class="line-modified"> 197                     left = cssValuePool.createValue(box.left().value(), CSSUnitType::CSS_NUMBER);</span>
 198                 else
 199                     left = cssValuePool.createValue(box.left());
 200             }
 201         }
 202     }
 203 
 204     auto quad = Quad::create();
 205     quad-&gt;setTop(WTFMove(top));
 206     quad-&gt;setRight(WTFMove(right));
 207     quad-&gt;setBottom(WTFMove(bottom));
 208     quad-&gt;setLeft(WTFMove(left));
 209 
 210     return cssValuePool.createValue(WTFMove(quad));
 211 }
 212 
 213 static Ref&lt;CSSValue&gt; valueForNinePieceImageRepeat(const NinePieceImage&amp; image)
 214 {
 215     auto&amp; cssValuePool = CSSValuePool::singleton();
 216     auto horizontalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.horizontalRule()));
 217     RefPtr&lt;CSSPrimitiveValue&gt; verticalRepeat;
</pre>
<hr />
<pre>
 232     if (image.image())
 233         imageValue = image.image()-&gt;cssValue();
 234 
 235     // Create the image slice.
 236     RefPtr&lt;CSSBorderImageSliceValue&gt; imageSlices = valueForNinePieceImageSlice(image);
 237 
 238     // Create the border area slices.
 239     RefPtr&lt;CSSValue&gt; borderSlices = valueForNinePieceImageQuad(image.borderSlices());
 240 
 241     // Create the border outset.
 242     RefPtr&lt;CSSValue&gt; outset = valueForNinePieceImageQuad(image.outset());
 243 
 244     // Create the repeat rules.
 245     RefPtr&lt;CSSValue&gt; repeat = valueForNinePieceImageRepeat(image);
 246 
 247     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 248 }
 249 
 250 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
 251 {
<span class="line-modified"> 252     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSUnitType::CSS_PX);</span>
 253 }
 254 
 255 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
 256 {
<span class="line-modified"> 257     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSUnitType::CSS_NUMBER);</span>
 258 }
 259 
<span class="line-modified"> 260 static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)</span>
 261 {
 262     if (length.isFixed())
 263         return zoomAdjustedPixelValue(length.value(), style);
 264     return CSSValuePool::singleton().createValue(length, style);
 265 }
 266 
 267 static Ref&lt;CSSValue&gt; valueForReflection(const StyleReflection* reflection, const RenderStyle&amp; style)
 268 {
 269     if (!reflection)
 270         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 271 
 272     RefPtr&lt;CSSPrimitiveValue&gt; offset;
 273     if (reflection-&gt;offset().isPercentOrCalculated())
<span class="line-modified"> 274         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSUnitType::CSS_PERCENTAGE);</span>
 275     else
 276         offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
 277 
 278     RefPtr&lt;CSSPrimitiveValue&gt; direction;
 279     switch (reflection-&gt;direction()) {
<span class="line-modified"> 280     case ReflectionDirection::Below:</span>
 281         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
 282         break;
<span class="line-modified"> 283     case ReflectionDirection::Above:</span>
 284         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
 285         break;
<span class="line-modified"> 286     case ReflectionDirection::Left:</span>
 287         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
 288         break;
<span class="line-modified"> 289     case ReflectionDirection::Right:</span>
 290         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
 291         break;
 292     }
 293 
 294     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
 295 }
 296 
 297 static Ref&lt;CSSValueList&gt; createPositionListForLayer(CSSPropertyID propertyID, const FillLayer&amp; layer, const RenderStyle&amp; style)
 298 {
 299     auto list = CSSValueList::createSpaceSeparated();
 300     if (layer.isBackgroundXOriginSet()) {
 301         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 302         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundXOrigin()));
 303     }
 304     list-&gt;append(zoomAdjustedPixelValueForLength(layer.xPosition(), style));
 305     if (layer.isBackgroundYOriginSet()) {
 306         ASSERT(propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 307         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundYOrigin()));
 308     }
 309     list-&gt;append(zoomAdjustedPixelValueForLength(layer.yPosition(), style));
</pre>
<hr />
<pre>
 435     if (box.isRelativelyPositioned())
 436         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 437 
 438     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 439         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 440 
 441     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 442 }
 443 
 444 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 445 {
 446     // This function does NOT look at visited information, so that computed style doesn&#39;t expose that.
 447     if (!color.isValid())
 448         return CSSValuePool::singleton().createColorValue(style-&gt;color());
 449     return CSSValuePool::singleton().createColorValue(color);
 450 }
 451 
 452 static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 453 {
 454     if (length.isPercent())
<span class="line-modified"> 455         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);</span>
 456 
<span class="line-modified"> 457     return zoomAdjustedPixelValueForLength(length, style);</span>
 458 }
 459 
 460 static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 461 {
 462     if (length.isAuto())
 463         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 464 
<span class="line-modified"> 465     return zoomAdjustedPixelValueForLength(length, style);</span>
 466 }
 467 
 468 static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
 469 {
 470     auto list = CSSValueList::createSpaceSeparated();
 471     list-&gt;append(percentageOrZoomAdjustedValue(radius.width, style));
 472     list-&gt;append(percentageOrZoomAdjustedValue(radius.height, style));
 473     return list;
 474 }
 475 
 476 static Ref&lt;CSSValue&gt; borderRadiusCornerValue(const LengthSize&amp; radius, const RenderStyle&amp; style)
 477 {
 478     if (radius.width == radius.height)
 479         return percentageOrZoomAdjustedValue(radius.width, style);
 480     return borderRadiusCornerValues(radius, style);
 481 }
 482 
 483 static Ref&lt;CSSValueList&gt; borderRadiusShorthandValue(const RenderStyle&amp; style)
 484 {
 485     auto list = CSSValueList::createSlashSeparated();
</pre>
<hr />
<pre>
 521 
 522     return list;
 523 }
 524 
 525 static LayoutRect sizingBox(RenderObject&amp; renderer)
 526 {
 527     if (!is&lt;RenderBox&gt;(renderer))
 528         return LayoutRect();
 529 
 530     auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
 531     return box.style().boxSizing() == BoxSizing::BorderBox ? box.borderBoxRect() : box.computedCSSContentBoxRect();
 532 }
 533 
 534 static Ref&lt;CSSFunctionValue&gt; matrixTransformValue(const TransformationMatrix&amp; transform, const RenderStyle&amp; style)
 535 {
 536     RefPtr&lt;CSSFunctionValue&gt; transformValue;
 537     auto&amp; cssValuePool = CSSValuePool::singleton();
 538     if (transform.isAffine()) {
 539         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 540 
<span class="line-modified"> 541         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 542         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 543         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 544         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSUnitType::CSS_NUMBER));</span>
 545         transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
 546         transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
 547     } else {
 548         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 549 
<span class="line-modified"> 550         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 551         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 552         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 553         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSUnitType::CSS_NUMBER));</span>
 554 
<span class="line-modified"> 555         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 556         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 557         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 558         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSUnitType::CSS_NUMBER));</span>
 559 
<span class="line-modified"> 560         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 561         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 562         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSUnitType::CSS_NUMBER));</span>
<span class="line-modified"> 563         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSUnitType::CSS_NUMBER));</span>
 564 
 565         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
 566         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
 567         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
<span class="line-modified"> 568         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSUnitType::CSS_NUMBER));</span>
 569     }
 570 
 571     return transformValue.releaseNonNull();
 572 }
 573 
 574 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 575 {
 576     // Inline renderers do not support transforms.
 577     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 578         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 579 
 580     FloatRect pixelSnappedRect;
 581     if (is&lt;RenderBox&gt;(*renderer))
 582         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 583 
 584     TransformationMatrix transform;
 585     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 586     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 587 
 588     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 589     auto list = CSSValueList::createSpaceSeparated();
 590     list-&gt;append(matrixTransformValue(transform, style));
 591     return list;
 592 }
 593 
 594 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 595 {
<span class="line-modified"> 596     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSUnitType::CSS_PX);</span>
 597 }
 598 
 599 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 600 {
 601     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 602 }
 603 
 604 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 605 {
 606     auto&amp; cssValuePool = CSSValuePool::singleton();
 607     if (!shadow)
 608         return cssValuePool.createIdentifierValue(CSSValueNone);
 609 
 610     auto list = CSSValueList::createCommaSeparated();
 611     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 612         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 613         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 614         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 615         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
<span class="line-modified"> 616         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == ShadowStyle::Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);</span>
 617         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
 618         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
 619     }
 620     return list;
 621 }
 622 
 623 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
 624 {
 625     auto&amp; cssValuePool = CSSValuePool::singleton();
 626     if (filterOperations.operations().isEmpty())
 627         return cssValuePool.createIdentifierValue(CSSValueNone);
 628 
 629     auto list = CSSValueList::createSpaceSeparated();
 630 
 631     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
 632     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
 633         FilterOperation&amp; filterOperation = **it;
 634 
 635         if (filterOperation.type() == FilterOperation::REFERENCE) {
 636             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
<span class="line-modified"> 637             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSUnitType::CSS_URI));</span>
 638         } else {
 639             RefPtr&lt;CSSFunctionValue&gt; filterValue;
 640             switch (filterOperation.type()) {
 641             case FilterOperation::GRAYSCALE: {
 642                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
<span class="line-modified"> 643                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 644                 break;
 645             }
 646             case FilterOperation::SEPIA: {
 647                 filterValue = CSSFunctionValue::create(CSSValueSepia);
<span class="line-modified"> 648                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 649                 break;
 650             }
 651             case FilterOperation::SATURATE: {
 652                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
<span class="line-modified"> 653                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 654                 break;
 655             }
 656             case FilterOperation::HUE_ROTATE: {
 657                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
<span class="line-modified"> 658                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_DEG));</span>
 659                 break;
 660             }
 661             case FilterOperation::INVERT: {
 662                 filterValue = CSSFunctionValue::create(CSSValueInvert);
<span class="line-modified"> 663                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 664                 break;
 665             }
 666             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
 667                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
 668                 break;
 669             }
 670             case FilterOperation::OPACITY: {
 671                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
<span class="line-modified"> 672                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 673                 break;
 674             }
 675             case FilterOperation::BRIGHTNESS: {
 676                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
<span class="line-modified"> 677                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 678                 break;
 679             }
 680             case FilterOperation::CONTRAST: {
 681                 filterValue = CSSFunctionValue::create(CSSValueContrast);
<span class="line-modified"> 682                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));</span>
 683                 break;
 684             }
 685             case FilterOperation::BLUR: {
 686                 filterValue = CSSFunctionValue::create(CSSValueBlur);
 687                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
 688                 break;
 689             }
 690             case FilterOperation::DROP_SHADOW: {
 691                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
 692                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
 693                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
<span class="line-modified"> 694                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, ShadowStyle::Normal, false, dropShadowOperation.color());</span>
 695                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
 696                 break;
 697             }
 698             default:
 699                 ASSERT_NOT_REACHED();
 700                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
 701                 break;
 702             }
 703             list-&gt;append(filterValue.releaseNonNull());
 704         }
 705     }
 706     return list;
 707 }
 708 
 709 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
 710 {
 711     if (!trackBreadth.isLength())
<span class="line-modified"> 712         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSUnitType::CSS_FR);</span>
 713 
 714     const Length&amp; trackBreadthLength = trackBreadth.length();
 715     if (trackBreadthLength.isAuto())
 716         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 717     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
 718 }
 719 
 720 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
 721 {
 722     switch (trackSize.type()) {
 723     case LengthTrackSizing:
 724         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
 725     case FitContentTrackSizing: {
 726         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
 727         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
 728         return fitContentTrackSize;
 729     }
 730     default:
 731         ASSERT(trackSize.type() == MinMaxTrackSizing);
 732         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
<span class="line-modified"> 733             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSUnitType::CSS_FR);</span>
 734 
 735         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
 736         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
 737         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
 738         return minMaxTrackBreadths;
 739     }
 740 }
 741 
 742 class OrderedNamedLinesCollector {
 743     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
 744 public:
<span class="line-modified"> 745     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis)</span>
 746         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
 747         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())



 748     {
 749     }
<span class="line-added"> 750     virtual ~OrderedNamedLinesCollector() = default;</span>
 751 
 752     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
<span class="line-modified"> 753     virtual void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;</span>
 754 
<span class="line-modified"> 755 protected:</span>
 756 
 757     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
 758     void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
 759 
 760     const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
 761     const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
<span class="line-added"> 762 };</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764 class OrderedNamedLinesCollectorInsideRepeat : public OrderedNamedLinesCollector {</span>
<span class="line-added"> 765 public:</span>
<span class="line-added"> 766     OrderedNamedLinesCollectorInsideRepeat(const RenderStyle&amp; style, bool isRowAxis)</span>
<span class="line-added"> 767         : OrderedNamedLinesCollector(style, isRowAxis)</span>
<span class="line-added"> 768     {</span>
<span class="line-added"> 769     }</span>
<span class="line-added"> 770 </span>
<span class="line-added"> 771     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;</span>
<span class="line-added"> 772 };</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774 class OrderedNamedLinesCollectorInGridLayout : public OrderedNamedLinesCollector {</span>
<span class="line-added"> 775 public:</span>
<span class="line-added"> 776     OrderedNamedLinesCollectorInGridLayout(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount, unsigned autoRepeatTrackListLength)</span>
<span class="line-added"> 777         : OrderedNamedLinesCollector(style, isRowAxis)</span>
<span class="line-added"> 778         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())</span>
<span class="line-added"> 779         , m_autoRepeatTotalTracks(autoRepeatTracksCount)</span>
<span class="line-added"> 780         , m_autoRepeatTrackListLength(autoRepeatTrackListLength)</span>
<span class="line-added"> 781     {</span>
<span class="line-added"> 782     }</span>
<span class="line-added"> 783 </span>
<span class="line-added"> 784     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;</span>
<span class="line-added"> 785 </span>
<span class="line-added"> 786 private:</span>
 787     unsigned m_insertionPoint;
 788     unsigned m_autoRepeatTotalTracks;
 789     unsigned m_autoRepeatTrackListLength;
 790 };
 791 
 792 void OrderedNamedLinesCollector::appendLines(CSSGridLineNamesValue&amp; lineNamesValue, unsigned index, NamedLinesType type) const
 793 {
 794     auto iter = type == NamedLines ? m_orderedNamedGridLines.find(index) : m_orderedNamedAutoRepeatGridLines.find(index);
 795     auto endIter = type == NamedLines ? m_orderedNamedGridLines.end() : m_orderedNamedAutoRepeatGridLines.end();
 796     if (iter == endIter)
 797         return;
 798 
 799     auto&amp; cssValuePool = CSSValuePool::singleton();
 800     for (const auto&amp; lineName : iter-&gt;value)
<span class="line-modified"> 801         lineNamesValue.append(cssValuePool.createValue(lineName, CSSUnitType::CSS_STRING));</span>
 802 }
 803 
 804 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
 805 {
 806     ASSERT(!isEmpty());
<span class="line-modified"> 807     appendLines(lineNamesValue, i, NamedLines);</span>
<span class="line-added"> 808 }</span>
<span class="line-added"> 809 </span>
<span class="line-added"> 810 void OrderedNamedLinesCollectorInsideRepeat::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const</span>
<span class="line-added"> 811 {</span>
<span class="line-added"> 812     ASSERT(!isEmpty());</span>
<span class="line-added"> 813     appendLines(lineNamesValue, i, AutoRepeatNamedLines);</span>
<span class="line-added"> 814 }</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816 void OrderedNamedLinesCollectorInGridLayout::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const</span>
<span class="line-added"> 817 {</span>
<span class="line-added"> 818     ASSERT(!isEmpty());</span>
<span class="line-added"> 819     if (!m_autoRepeatTrackListLength || i &lt; m_insertionPoint) {</span>
 820         appendLines(lineNamesValue, i, NamedLines);
 821         return;
 822     }
 823 
 824     ASSERT(m_autoRepeatTotalTracks);
 825 
 826     if (i &gt; m_insertionPoint + m_autoRepeatTotalTracks) {
 827         appendLines(lineNamesValue, i - (m_autoRepeatTotalTracks - 1), NamedLines);
 828         return;
 829     }
 830 
 831     if (i == m_insertionPoint) {
 832         appendLines(lineNamesValue, i, NamedLines);
 833         appendLines(lineNamesValue, 0, AutoRepeatNamedLines);
 834         return;
 835     }
 836 
 837     if (i == m_insertionPoint + m_autoRepeatTotalTracks) {
 838         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
 839         appendLines(lineNamesValue, m_insertionPoint + 1, NamedLines);
</pre>
<hr />
<pre>
 850 {
 851     if (collector.isEmpty())
 852         return;
 853 
 854     auto lineNames = CSSGridLineNamesValue::create();
 855     collector.collectLineNamesForIndex(lineNames.get(), i);
 856     if (lineNames-&gt;length())
 857         list.append(WTFMove(lineNames));
 858 }
 859 
 860 static Ref&lt;CSSValueList&gt; valueForGridTrackSizeList(GridTrackSizingDirection direction, const RenderStyle&amp; style)
 861 {
 862     auto&amp; autoTrackSizes = direction == ForColumns ? style.gridAutoColumns() : style.gridAutoRows();
 863 
 864     auto list = CSSValueList::createSpaceSeparated();
 865     for (auto&amp; trackSize : autoTrackSizes)
 866         list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
 867     return list;
 868 }
 869 
<span class="line-added"> 870 template &lt;typename T, typename F&gt;</span>
<span class="line-added"> 871 void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize, unsigned start, unsigned end, unsigned offset = 0)</span>
<span class="line-added"> 872 {</span>
<span class="line-added"> 873     ASSERT(end &lt;= tracks.size());</span>
<span class="line-added"> 874     for (unsigned i = start; i &lt; end; ++i) {</span>
<span class="line-added"> 875         addValuesForNamedGridLinesAtIndex(collector, i + offset, list);</span>
<span class="line-added"> 876         list.append(getTrackSize(tracks[i]));</span>
<span class="line-added"> 877     }</span>
<span class="line-added"> 878     addValuesForNamedGridLinesAtIndex(collector, end + offset, list);</span>
<span class="line-added"> 879 }</span>
<span class="line-added"> 880 </span>
<span class="line-added"> 881 template &lt;typename T, typename F&gt;</span>
<span class="line-added"> 882 void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize)</span>
<span class="line-added"> 883 {</span>
<span class="line-added"> 884     populateGridTrackList&lt;T&gt;(list, collector, tracks, getTrackSize, 0, tracks.size());</span>
<span class="line-added"> 885 }</span>
<span class="line-added"> 886 </span>
 887 static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
 888 {
 889     bool isRowAxis = direction == ForColumns;
 890     bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
 891     auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
 892     auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
 893 
 894     // Handle the &#39;none&#39; case.
<span class="line-modified"> 895     if (trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty())</span>









 896         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 897 


 898     auto list = CSSValueList::createSpaceSeparated();


















 899 
<span class="line-modified"> 900     // If the element is a grid container, the resolved value is the used value,</span>
<span class="line-modified"> 901     // specifying track sizes in pixels and expanding the repeat() notation.</span>
<span class="line-added"> 902     if (isRenderGrid) {</span>
<span class="line-added"> 903         auto* grid = downcast&lt;RenderGrid&gt;(renderer);</span>
<span class="line-added"> 904         OrderedNamedLinesCollectorInGridLayout collector(style, isRowAxis, grid-&gt;autoRepeatCountForDirection(direction), autoRepeatTrackSizes.size());</span>
<span class="line-added"> 905         populateGridTrackList(list.get(), collector, grid-&gt;trackSizesForComputedStyle(direction), [&amp;](const LayoutUnit&amp; v) {</span>
<span class="line-added"> 906             return zoomAdjustedPixelValue(v, style);</span>
<span class="line-added"> 907         });</span>
<span class="line-added"> 908         return list;</span>
<span class="line-added"> 909     }</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911     // Otherwise, the resolved value is the computed value, preserving repeat().</span>
<span class="line-added"> 912     OrderedNamedLinesCollector collector(style, isRowAxis);</span>
<span class="line-added"> 913     auto getTrackSize = [&amp;](const GridTrackSize&amp; v) {</span>
<span class="line-added"> 914         return specifiedValueForGridTrackSize(v, style);</span>
<span class="line-added"> 915     };</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     if (autoRepeatTrackSizes.isEmpty()) {</span>
<span class="line-added"> 918         // If there&#39;s no auto repeat(), just add all the line names and track sizes.</span>
<span class="line-added"> 919         populateGridTrackList(list.get(), collector, trackSizes, getTrackSize);</span>
<span class="line-added"> 920         return list;</span>
<span class="line-added"> 921     }</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923     // Add the line names and track sizes that precede the auto repeat().</span>
<span class="line-added"> 924     unsigned autoRepeatInsertionPoint = isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint();</span>
<span class="line-added"> 925     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, 0, autoRepeatInsertionPoint);</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927     // Add a CSSGridAutoRepeatValue with the contents of the auto repeat().</span>
<span class="line-added"> 928     AutoRepeatType autoRepeatType = isRowAxis ? style.gridAutoRepeatColumnsType() : style.gridAutoRepeatRowsType();</span>
<span class="line-added"> 929     auto repeatedValues = CSSGridAutoRepeatValue::create(autoRepeatType == AutoRepeatType::Fill ? CSSValueAutoFill : CSSValueAutoFit);</span>
<span class="line-added"> 930     OrderedNamedLinesCollectorInsideRepeat repeatCollector(style, isRowAxis);</span>
<span class="line-added"> 931     populateGridTrackList(repeatedValues.get(), repeatCollector, autoRepeatTrackSizes, getTrackSize);</span>
<span class="line-added"> 932     list-&gt;append(repeatedValues.get());</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934     // Add the line names and track sizes that follow the auto repeat().</span>
<span class="line-added"> 935     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, autoRepeatInsertionPoint, trackSizes.size(), 1);</span>
 936     return list;
 937 }
 938 
 939 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
 940 {
 941     auto&amp; cssValuePool = CSSValuePool::singleton();
 942     if (position.isAuto())
 943         return cssValuePool.createIdentifierValue(CSSValueAuto);
 944 
 945     if (position.isNamedGridArea())
<span class="line-modified"> 946         return cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING);</span>
 947 
 948     auto list = CSSValueList::createSpaceSeparated();
 949     if (position.isSpan()) {
 950         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
<span class="line-modified"> 951         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSUnitType::CSS_NUMBER));</span>
 952     } else
<span class="line-modified"> 953         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSUnitType::CSS_NUMBER));</span>
 954 
 955     if (!position.namedGridLine().isNull())
<span class="line-modified"> 956         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING));</span>
 957     return list;
 958 }
 959 
 960 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
 961 {
 962     switch (animation.animationMode()) {
 963     case Animation::AnimateNone:
 964         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 965     case Animation::AnimateAll:
 966         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
 967     case Animation::AnimateSingleProperty:
<span class="line-modified"> 968         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSUnitType::CSS_STRING);</span>
 969     case Animation::AnimateUnknownProperty:
<span class="line-modified"> 970         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSUnitType::CSS_STRING);</span>
 971     }
 972     ASSERT_NOT_REACHED();
 973     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 974 }
 975 
 976 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
 977 {
 978     auto list = CSSValueList::createCommaSeparated();
 979     if (animationList) {
 980         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
 981             list-&gt;append(createTransitionPropertyValue(animationList-&gt;animation(i)));
 982     } else
 983         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAll));
 984     return list;
 985 }
 986 
 987 #if ENABLE(CSS_SCROLL_SNAP)
 988 
 989 static Ref&lt;CSSValueList&gt; valueForScrollSnapType(const ScrollSnapType&amp; type)
 990 {
</pre>
<hr />
<pre>
1211     case FontVariantEastAsianWidth::Full:
1212         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1213         break;
1214     case FontVariantEastAsianWidth::Proportional:
1215         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1216         break;
1217     }
1218 
1219     if (ruby == FontVariantEastAsianRuby::Yes)
1220         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1221 
1222     return valueList;
1223 }
1224 
1225 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1226 {
1227     auto&amp; cssValuePool = CSSValuePool::singleton();
1228     auto list = CSSValueList::createCommaSeparated();
1229     if (animationList) {
1230         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">1231             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSUnitType::CSS_S));</span>
1232     } else {
1233         // Note that initialAnimationDelay() is used for both transitions and animations
<span class="line-modified">1234         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));</span>
1235     }
1236     return list;
1237 }
1238 
1239 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1240 {
1241     auto&amp; cssValuePool = CSSValuePool::singleton();
1242     auto list = CSSValueList::createCommaSeparated();
1243     if (animationList) {
1244         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
<span class="line-modified">1245             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSUnitType::CSS_S));</span>
1246     } else {
1247         // Note that initialAnimationDuration() is used for both transitions and animations
<span class="line-modified">1248         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));</span>
1249     }
1250     return list;
1251 }
1252 
1253 static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
1254 {
1255     switch (timingFunction.type()) {
1256     case TimingFunction::CubicBezierFunction: {
1257         auto&amp; function = downcast&lt;CubicBezierTimingFunction&gt;(timingFunction);
1258         if (function.timingFunctionPreset() != CubicBezierTimingFunction::Custom) {
1259             CSSValueID valueId = CSSValueInvalid;
1260             switch (function.timingFunctionPreset()) {
1261             case CubicBezierTimingFunction::Ease:
1262                 valueId = CSSValueEase;
1263                 break;
1264             case CubicBezierTimingFunction::EaseIn:
1265                 valueId = CSSValueEaseIn;
1266                 break;
1267             case CubicBezierTimingFunction::EaseOut:
1268                 valueId = CSSValueEaseOut;
</pre>
<hr />
<pre>
1285         return CSSSpringTimingFunctionValue::create(function.mass(), function.stiffness(), function.damping(), function.initialVelocity());
1286     }
1287     default:
1288         ASSERT(timingFunction.type() == TimingFunction::LinearFunction);
1289         return CSSValuePool::singleton().createIdentifierValue(CSSValueLinear);
1290     }
1291 }
1292 
1293 static Ref&lt;CSSValueList&gt; timingFunctionValue(const AnimationList* animationList)
1294 {
1295     auto list = CSSValueList::createCommaSeparated();
1296     if (animationList) {
1297         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1298             list-&gt;append(createTimingFunctionValue(*animationList-&gt;animation(i).timingFunction()));
1299     } else
1300         // Note that initialAnimationTimingFunction() is used for both transitions and animations
1301         list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
1302     return list;
1303 }
1304 
<span class="line-modified">1305 static Ref&lt;CSSValue&gt; createLineBoxContainValue(OptionSet&lt;LineBoxContain&gt; lineBoxContain)</span>
1306 {
1307     if (!lineBoxContain)
1308         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1309     return CSSLineBoxContainValue::create(lineBoxContain);
1310 }
1311 
1312 static Element* styleElementForNode(Node* node)
1313 {
1314     if (!node)
1315         return nullptr;
1316     if (is&lt;Element&gt;(*node))
1317         return downcast&lt;Element&gt;(node);
1318     return composedTreeAncestors(*node).first();
1319 }
1320 
1321 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1322     : m_element(styleElementForNode(node))
1323     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1324     , m_allowVisitedStyle(allowVisitedStyle)
1325 {
</pre>
<hr />
<pre>
1349 Ref&lt;CSSComputedStyleDeclaration&gt; CSSComputedStyleDeclaration::create(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)
1350 {
1351     return adoptRef(*new CSSComputedStyleDeclaration(element, allowVisitedStyle, pseudoElementName));
1352 }
1353 
1354 void CSSComputedStyleDeclaration::ref()
1355 {
1356     ++m_refCount;
1357 }
1358 
1359 void CSSComputedStyleDeclaration::deref()
1360 {
1361     ASSERT(m_refCount);
1362     if (!--m_refCount)
1363         delete this;
1364 }
1365 
1366 String CSSComputedStyleDeclaration::cssText() const
1367 {
1368     StringBuilder result;
<span class="line-modified">1369     for (unsigned i = 0; i &lt; numComputedPropertyIDs; i++) {</span>
1370         if (i)
1371             result.append(&#39; &#39;);
<span class="line-modified">1372         result.append(getPropertyName(computedPropertyIDs[i]), &quot;: &quot;, getPropertyValue(computedPropertyIDs[i]), &#39;;&#39;);</span>
1373     }
1374     return result.toString();
1375 }
1376 
1377 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1378 {
1379     return Exception { NoModificationAllowedError };
1380 }
1381 
1382 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1383 {
1384     if (!m_element)
1385         return nullptr;
1386 
1387     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1388 
1389     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1390     if (!style)
1391         return nullptr;
1392 
</pre>
<hr />
<pre>
1505     switch (static_cast&lt;TextDecorationSkip&gt;(textDecorationSkip.toRaw())) {
1506     case TextDecorationSkip::Auto:
1507         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1508     case TextDecorationSkip::None:
1509         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1510     case TextDecorationSkip::Ink:
1511         return CSSValuePool::singleton().createIdentifierValue(CSSValueInk);
1512     case TextDecorationSkip::Objects:
1513         return CSSValuePool::singleton().createIdentifierValue(CSSValueObjects);
1514     }
1515 
1516     ASSERT_NOT_REACHED();
1517     return CSSValuePool::singleton().createExplicitInitialValue();
1518 }
1519 
1520 static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
1521 {
1522     if (textUnderlineOffset.isAuto())
1523         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1524     ASSERT(textUnderlineOffset.isLength());
<span class="line-modified">1525     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSUnitType::CSS_PX);</span>
1526 }
1527 
1528 static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
1529 {
1530     if (textDecorationThickness.isAuto())
1531         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1532     if (textDecorationThickness.isFromFont())
1533         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
1534     ASSERT(textDecorationThickness.isLength());
<span class="line-modified">1535     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSUnitType::CSS_PX);</span>
1536 }
1537 
1538 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1539 {
1540     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1541     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1542     auto&amp; cssValuePool = CSSValuePool::singleton();
1543     auto list = CSSValueList::createSpaceSeparated();
1544     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1545         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1546     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1547         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1548     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1549         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1550     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1551         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1552     if (!list-&gt;length())
1553         return cssValuePool.createIdentifierValue(CSSValueNone);
1554     return list;
1555 }
</pre>
<hr />
<pre>
1619 
1620 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1621 {
1622     if (fillSize.type == FillSizeType::Contain)
1623         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1624 
1625     if (fillSize.type == FillSizeType::Cover)
1626         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1627 
1628     if (fillSize.size.height.isAuto())
1629         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1630 
1631     auto list = CSSValueList::createSpaceSeparated();
1632     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1633     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
1634     return list;
1635 }
1636 
1637 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1638 {
<span class="line-modified">1639     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSUnitType::CSS_STRING);</span>
1640 }
1641 
1642 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1643 {
1644     auto&amp; cssValuePool = CSSValuePool::singleton();
1645     auto list = CSSValueList::createSpaceSeparated();
1646     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1647         if (is&lt;CounterContentData&gt;(*contentData))
<span class="line-modified">1648             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSUnitType::CSS_COUNTER_NAME));</span>
1649         else if (is&lt;ImageContentData&gt;(*contentData))
1650             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1651         else if (is&lt;TextContentData&gt;(*contentData))
<span class="line-modified">1652             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSUnitType::CSS_STRING));</span>
1653     }
1654     return list;
1655 }
1656 
1657 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1658 {
1659     auto* map = style.counterDirectives();
1660     if (!map)
1661         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1662 
1663     auto&amp; cssValuePool = CSSValuePool::singleton();
1664     auto list = CSSValueList::createSpaceSeparated();
1665     for (auto&amp; keyValue : *map) {
<span class="line-modified">1666         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSUnitType::CSS_STRING));</span>
1667         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
<span class="line-modified">1668         list-&gt;append(cssValuePool.createValue(number, CSSUnitType::CSS_NUMBER));</span>
1669     }
1670     return list;
1671 }
1672 









1673 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
1674 {
1675     auto list = CSSValueList::createCommaSeparated();
1676     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
1677         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
1678     return list;
1679 }
1680 
1681 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
1682 {
1683     if (style.fontCascade().familyCount() == 1)
1684         return valueForFamily(style.fontCascade().familyAt(0));
1685     return fontFamilyListFromStyle(style);
1686 }
1687 
1688 static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
1689 {
1690     Length length = style.lineHeight();
<span class="line-modified">1691     if (length.isNegative())</span>
<span class="line-modified">1692         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);</span>
1693     if (length.isPercent()) {
1694         // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
1695         // for how high to be in pixels does include things like minimum font size and the zoom factor.
1696         // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
1697         // that here either.
1698         return zoomAdjustedPixelValue(static_cast&lt;int&gt;(length.percent() * style.fontDescription().computedSize()) / 100, style);
1699     }
1700     return zoomAdjustedPixelValue(floatValueForLength(length, 0), style);
1701 }
1702 
1703 static Ref&lt;CSSPrimitiveValue&gt; fontSizeFromStyle(const RenderStyle&amp; style)
1704 {
1705     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
1706 }
1707 
1708 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
1709 {
<span class="line-modified">1710     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);</span>
1711 }
1712 
1713 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
1714 {
1715     if (auto value = fontWeightKeyword(weight))
1716         return CSSValuePool::singleton().createIdentifierValue(value.value());
1717     return fontNonKeywordWeightFromStyleValue(weight);
1718 }
1719 
1720 static Ref&lt;CSSPrimitiveValue&gt; fontWeightFromStyle(const RenderStyle&amp; style)
1721 {
1722     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
1723 }
1724 
1725 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
1726 {
<span class="line-modified">1727     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSUnitType::CSS_PERCENTAGE);</span>
1728 }
1729 
1730 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
1731 {
1732     if (auto keyword = fontStretchKeyword(stretch))
1733         return CSSValuePool::singleton().createIdentifierValue(keyword.value());
1734     return fontNonKeywordStretchFromStyleValue(stretch);
1735 }
1736 
1737 static Ref&lt;CSSPrimitiveValue&gt; fontStretchFromStyle(const RenderStyle&amp; style)
1738 {
1739     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
1740 }
1741 
1742 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
1743 {
<span class="line-modified">1744     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSUnitType::CSS_DEG));</span>
1745 }
1746 
1747 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
1748 {
1749     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
1750         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(keyword.value()));
1751     return fontNonKeywordStyleFromStyleValue(italic.value());
1752 }
1753 
1754 static Ref&lt;CSSFontStyleValue&gt; fontStyleFromStyle(const RenderStyle&amp; style)
1755 {
1756     return ComputedStyleExtractor::fontStyleFromStyleValue(style.fontDescription().italic(), style.fontDescription().fontStyleAxis());
1757 }
1758 
1759 static Ref&lt;CSSValue&gt; fontVariantFromStyle(const RenderStyle&amp; style)
1760 {
1761     if (style.fontDescription().variantSettings().isAllNormal())
1762         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
1763 
1764     auto list = CSSValueList::createSpaceSeparated();
</pre>
<hr />
<pre>
2365     RefPtr&lt;CSSValue&gt; propertyValue = customPropertyValue(propertyName);
2366     return propertyValue ? propertyValue-&gt;cssText() : emptyString();
2367 }
2368 
2369 static Ref&lt;CSSFontValue&gt; fontShorthandValueForSelectionProperties(const FontDescription&amp; fontDescription)
2370 {
2371     auto computedFont = CSSFontValue::create();
2372 
2373     auto variantCaps = fontDescription.variantCaps();
2374     if (variantCaps == FontVariantCaps::Small)
2375         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps);
2376     else if (variantCaps == FontVariantCaps::Normal)
2377         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2378     else
2379         return CSSFontValue::create();
2380 
2381     auto weight = fontDescription.weight();
2382     if (auto value = fontWeightKeyword(weight))
2383         computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
2384     else if (isCSS21Weight(weight))
<span class="line-modified">2385         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);</span>
2386     else
2387         return CSSFontValue::create();
2388 
2389     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
2390         computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
2391     else
2392         return CSSFontValue::create();
2393 
2394     if (auto italic = fontStyleKeyword(fontDescription.italic(), fontDescription.fontStyleAxis()))
2395         computedFont-&gt;style = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(italic.value()));
2396     else
2397         return CSSFontValue::create();
2398 
2399     return computedFont;
2400 }
2401 
2402 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::propertyValue(CSSPropertyID propertyID, EUpdateLayout updateLayout)
2403 {
2404     auto* styledElement = this-&gt;styledElement();
2405     if (!styledElement)
</pre>
<hr />
<pre>
2613             return zoomAdjustedPixelValue(style.borderTopWidth(), style);
2614         case CSSPropertyBorderRightWidth:
2615             return zoomAdjustedPixelValue(style.borderRightWidth(), style);
2616         case CSSPropertyBorderBottomWidth:
2617             return zoomAdjustedPixelValue(style.borderBottomWidth(), style);
2618         case CSSPropertyBorderLeftWidth:
2619             return zoomAdjustedPixelValue(style.borderLeftWidth(), style);
2620         case CSSPropertyBottom:
2621             return positionOffsetValue(style, CSSPropertyBottom, renderer);
2622         case CSSPropertyWebkitBoxAlign:
2623             return cssValuePool.createValue(style.boxAlign());
2624 #if ENABLE(CSS_BOX_DECORATION_BREAK)
2625         case CSSPropertyWebkitBoxDecorationBreak:
2626             if (style.boxDecorationBreak() == BoxDecorationBreak::Slice)
2627                 return cssValuePool.createIdentifierValue(CSSValueSlice);
2628         return cssValuePool.createIdentifierValue(CSSValueClone);
2629 #endif
2630         case CSSPropertyWebkitBoxDirection:
2631             return cssValuePool.createValue(style.boxDirection());
2632         case CSSPropertyWebkitBoxFlex:
<span class="line-modified">2633             return cssValuePool.createValue(style.boxFlex(), CSSUnitType::CSS_NUMBER);</span>
2634         case CSSPropertyWebkitBoxFlexGroup:
<span class="line-modified">2635             return cssValuePool.createValue(style.boxFlexGroup(), CSSUnitType::CSS_NUMBER);</span>
2636         case CSSPropertyWebkitBoxLines:
2637             return cssValuePool.createValue(style.boxLines());
2638         case CSSPropertyWebkitBoxOrdinalGroup:
<span class="line-modified">2639             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSUnitType::CSS_NUMBER);</span>
2640         case CSSPropertyWebkitBoxOrient:
2641             return cssValuePool.createValue(style.boxOrient());
2642         case CSSPropertyWebkitBoxPack:
2643             return cssValuePool.createValue(style.boxPack());
2644         case CSSPropertyWebkitBoxReflect:
2645             return valueForReflection(style.boxReflect(), style);
2646         case CSSPropertyBoxShadow:
2647         case CSSPropertyWebkitBoxShadow:
2648             return valueForShadow(style.boxShadow(), propertyID, style);
2649         case CSSPropertyCaptionSide:
2650             return cssValuePool.createValue(style.captionSide());
2651         case CSSPropertyCaretColor:
2652             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyCaretColor)) : currentColorOrValidColor(&amp;style, style.caretColor());
2653         case CSSPropertyClear:
2654             return cssValuePool.createValue(style.clear());
2655         case CSSPropertyColor:
2656             return cssValuePool.createColorValue(m_allowVisitedStyle ? style.visitedDependentColor(CSSPropertyColor) : style.color());
2657         case CSSPropertyWebkitPrintColorAdjust:
2658             return cssValuePool.createValue(style.printColorAdjust());
2659         case CSSPropertyWebkitColumnAxis:
2660             return cssValuePool.createValue(style.columnAxis());
2661         case CSSPropertyColumnCount:
2662             if (style.hasAutoColumnCount())
2663                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">2664             return cssValuePool.createValue(style.columnCount(), CSSUnitType::CSS_NUMBER);</span>
2665         case CSSPropertyColumnFill:
2666             return cssValuePool.createValue(style.columnFill());
2667         case CSSPropertyColumnGap:
2668             if (style.columnGap().isNormal())
2669                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2670             return zoomAdjustedPixelValueForLength(style.columnGap().length(), style);
2671         case CSSPropertyRowGap:
2672             if (style.rowGap().isNormal())
2673                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2674             return zoomAdjustedPixelValueForLength(style.rowGap().length(), style);
2675         case CSSPropertyWebkitColumnProgression:
2676             return cssValuePool.createValue(style.columnProgression());
2677         case CSSPropertyColumnRuleColor:
2678             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
2679         case CSSPropertyColumnRuleStyle:
2680             return cssValuePool.createValue(style.columnRuleStyle());
2681         case CSSPropertyColumnRuleWidth:
2682             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
2683         case CSSPropertyColumnSpan:
2684             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
2685         case CSSPropertyWebkitColumnBreakAfter:
2686             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
2687         case CSSPropertyWebkitColumnBreakBefore:
2688             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
2689         case CSSPropertyWebkitColumnBreakInside:
2690             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
2691         case CSSPropertyColumnWidth:
2692             if (style.hasAutoColumnWidth())
2693                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2694             return zoomAdjustedPixelValue(style.columnWidth(), style);
2695         case CSSPropertyTabSize:
<span class="line-modified">2696             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSUnitType::CSS_NUMBER : CSSUnitType::CSS_PX);</span>
2697         case CSSPropertyCursor: {
2698             RefPtr&lt;CSSValueList&gt; list;
2699             auto* cursors = style.cursors();
2700             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
2701                 list = CSSValueList::createCommaSeparated();
2702                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
2703                     if (StyleImage* image = cursors-&gt;at(i).image())
2704                         list-&gt;append(image-&gt;cssValue());
2705             }
2706             auto value = cssValuePool.createValue(style.cursor());
2707             if (list) {
2708                 list-&gt;append(WTFMove(value));
2709                 return list;
2710             }
2711             return value;
2712         }
2713 #if ENABLE(CURSOR_VISIBILITY)
2714         case CSSPropertyWebkitCursorVisibility:
2715             return cssValuePool.createValue(style.cursorVisibility());
2716 #endif
</pre>
<hr />
<pre>
2736             return getCSSPropertyValuesForShorthandProperties(flexFlowShorthand());
2737         case CSSPropertyFlexGrow:
2738             return cssValuePool.createValue(style.flexGrow());
2739         case CSSPropertyFlexShrink:
2740             return cssValuePool.createValue(style.flexShrink());
2741         case CSSPropertyFlexWrap:
2742             return cssValuePool.createValue(style.flexWrap());
2743         case CSSPropertyJustifyContent:
2744             return valueForContentPositionAndDistributionWithOverflowAlignment(style.justifyContent());
2745         case CSSPropertyJustifyItems:
2746             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
2747         case CSSPropertyJustifySelf:
2748             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
2749         case CSSPropertyPlaceContent:
2750             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
2751         case CSSPropertyPlaceItems:
2752             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
2753         case CSSPropertyPlaceSelf:
2754             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
2755         case CSSPropertyOrder:
<span class="line-modified">2756             return cssValuePool.createValue(style.order(), CSSUnitType::CSS_NUMBER);</span>
2757         case CSSPropertyFloat:
2758             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
2759                 return cssValuePool.createIdentifierValue(CSSValueNone);
2760             return cssValuePool.createValue(style.floating());
2761         case CSSPropertyFont: {
2762             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
2763             computedFont-&gt;size = fontSizeFromStyle(style);
2764             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
2765             computedFont-&gt;family = fontFamilyListFromStyle(style);
2766             return computedFont;
2767         }
2768         case CSSPropertyFontFamily:
2769             return fontFamilyFromStyle(style);
2770         case CSSPropertyFontSize:
2771             return fontSizeFromStyle(style);
2772         case CSSPropertyFontStyle:
2773             return fontStyleFromStyle(style);
2774         case CSSPropertyFontStretch:
2775             return fontStretchFromStyle(style);
2776         case CSSPropertyFontVariant:
</pre>
<hr />
<pre>
2852             if (!style.namedGridAreaRowCount()) {
2853                 ASSERT(!style.namedGridAreaColumnCount());
2854                 return cssValuePool.createIdentifierValue(CSSValueNone);
2855             }
2856             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
2857         case CSSPropertyGap:
2858             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
2859         case CSSPropertyHeight:
2860             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
2861                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
2862                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
2863                 if (!isNonReplacedInline(*renderer))
2864                     return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);
2865             }
2866             return zoomAdjustedPixelValueForLength(style.height(), style);
2867         case CSSPropertyWebkitHyphens:
2868             return cssValuePool.createValue(style.hyphens());
2869         case CSSPropertyWebkitHyphenateCharacter:
2870             if (style.hyphenationString().isNull())
2871                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">2872             return cssValuePool.createValue(style.hyphenationString(), CSSUnitType::CSS_STRING);</span>
2873         case CSSPropertyWebkitHyphenateLimitAfter:
2874             if (style.hyphenationLimitAfter() &lt; 0)
2875                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">2876             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSUnitType::CSS_NUMBER);</span>
2877         case CSSPropertyWebkitHyphenateLimitBefore:
2878             if (style.hyphenationLimitBefore() &lt; 0)
2879                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
<span class="line-modified">2880             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSUnitType::CSS_NUMBER);</span>
2881         case CSSPropertyWebkitHyphenateLimitLines:
2882             if (style.hyphenationLimitLines() &lt; 0)
2883                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
<span class="line-modified">2884             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSUnitType::CSS_NUMBER);</span>
2885         case CSSPropertyWebkitBorderFit:
2886             if (style.borderFit() == BorderFit::Border)
2887                 return cssValuePool.createIdentifierValue(CSSValueBorder);
2888             return cssValuePool.createIdentifierValue(CSSValueLines);

2889         case CSSPropertyImageOrientation:
<span class="line-modified">2890             if (style.imageOrientation() == ImageOrientation::FromImage)</span>
<span class="line-modified">2891                 return cssValuePool.createIdentifierValue(CSSValueFromImage);</span>
<span class="line-added">2892             return cssValuePool.createIdentifierValue(CSSValueNone);</span>
2893         case CSSPropertyImageRendering:
2894             return CSSPrimitiveValue::create(style.imageRendering());
2895 #if ENABLE(CSS_IMAGE_RESOLUTION)
2896         case CSSPropertyImageResolution:
<span class="line-modified">2897             return cssValuePool.createValue(style.imageResolution(), CSSUnitType::CSS_DPPX);</span>
2898 #endif
2899         case CSSPropertyLeft:
2900             return positionOffsetValue(style, CSSPropertyLeft, renderer);
2901         case CSSPropertyLetterSpacing:
2902             if (!style.letterSpacing())
2903                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2904             return zoomAdjustedPixelValue(style.letterSpacing(), style);
2905         case CSSPropertyWebkitLineClamp:
2906             if (style.lineClamp().isNone())
2907                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">2908             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);</span>
2909         case CSSPropertyLineHeight:
2910             return lineHeightFromStyle(style);
2911         case CSSPropertyListStyleImage:
2912             if (style.listStyleImage())
2913                 return style.listStyleImage()-&gt;cssValue();
2914             return cssValuePool.createIdentifierValue(CSSValueNone);
2915         case CSSPropertyListStylePosition:
2916             return cssValuePool.createValue(style.listStylePosition());
2917         case CSSPropertyListStyleType:
2918             return cssValuePool.createValue(style.listStyleType());
2919         case CSSPropertyWebkitLocale:
2920             if (style.locale().isNull())
2921                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">2922             return cssValuePool.createValue(style.locale(), CSSUnitType::CSS_STRING);</span>
2923         case CSSPropertyMarginTop:
2924             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
2925         case CSSPropertyMarginRight: {
2926             Length marginRight = style.marginRight();
2927             if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
2928                 return zoomAdjustedPixelValueForLength(marginRight, style);
2929             float value;
2930             if (marginRight.isPercentOrCalculated()) {
2931                 // RenderBox gives a marginRight() that is the distance between the right-edge of the child box
2932                 // and the right-edge of the containing box, when display == DisplayType::Block. Let&#39;s calculate the absolute
2933                 // value of the specified margin-right % instead of relying on RenderBox&#39;s marginRight() value.
2934                 value = minimumValueForLength(marginRight, downcast&lt;RenderBox&gt;(*renderer).containingBlockLogicalWidthForContent());
2935             } else
2936                 value = downcast&lt;RenderBox&gt;(*renderer).marginRight();
2937             return zoomAdjustedPixelValue(value, style);
2938         }
2939         case CSSPropertyMarginBottom:
2940             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
2941         case CSSPropertyMarginLeft:
2942             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);










2943         case CSSPropertyWebkitUserModify:
2944             return cssValuePool.createValue(style.userModify());
2945         case CSSPropertyMaxHeight: {
2946             const Length&amp; maxHeight = style.maxHeight();
2947             if (maxHeight.isUndefined())
2948                 return cssValuePool.createIdentifierValue(CSSValueNone);
2949             return zoomAdjustedPixelValueForLength(maxHeight, style);
2950         }
2951         case CSSPropertyMaxWidth: {
2952             const Length&amp; maxWidth = style.maxWidth();
2953             if (maxWidth.isUndefined())
2954                 return cssValuePool.createIdentifierValue(CSSValueNone);
2955             return zoomAdjustedPixelValueForLength(maxWidth, style);
2956         }
2957         case CSSPropertyMinHeight:
2958             if (style.minHeight().isAuto()) {
2959                 auto* styledElement = this-&gt;styledElement();
2960                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
2961                     return cssValuePool.createIdentifierValue(CSSValueAuto);
2962                 return zoomAdjustedPixelValue(0, style);
2963             }
2964             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
2965         case CSSPropertyMinWidth:
2966             if (style.minWidth().isAuto()) {
2967                 auto* styledElement = this-&gt;styledElement();
2968                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
2969                     return cssValuePool.createIdentifierValue(CSSValueAuto);
2970                 return zoomAdjustedPixelValue(0, style);
2971             }
2972             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
2973         case CSSPropertyObjectFit:
2974             return cssValuePool.createValue(style.objectFit());
2975         case CSSPropertyObjectPosition: {
2976             auto list = CSSValueList::createSpaceSeparated();
2977             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
2978             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
2979             return list;
2980         }
2981         case CSSPropertyOpacity:
<span class="line-modified">2982             return cssValuePool.createValue(style.opacity(), CSSUnitType::CSS_NUMBER);</span>
2983         case CSSPropertyOrphans:
2984             if (style.hasAutoOrphans())
2985                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">2986             return cssValuePool.createValue(style.orphans(), CSSUnitType::CSS_NUMBER);</span>
2987         case CSSPropertyOutlineColor:
2988             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
2989         case CSSPropertyOutlineOffset:
2990             return zoomAdjustedPixelValue(style.outlineOffset(), style);
2991         case CSSPropertyOutlineStyle:
2992             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
2993                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2994             return cssValuePool.createValue(style.outlineStyle());
2995         case CSSPropertyOutlineWidth:
2996             return zoomAdjustedPixelValue(style.outlineWidth(), style);
2997         case CSSPropertyOverflow:
<span class="line-modified">2998             return getCSSPropertyValuesFor2SidesShorthand(overflowShorthand());</span>
2999         case CSSPropertyOverflowWrap:
3000             return cssValuePool.createValue(style.overflowWrap());
3001         case CSSPropertyOverflowX:
3002             return cssValuePool.createValue(style.overflowX());
3003         case CSSPropertyOverflowY:
3004             return cssValuePool.createValue(style.overflowY());
3005         case CSSPropertyPaddingTop:
3006             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingTop, &amp;RenderBoxModelObject::computedCSSPaddingTop&gt;(style, renderer);
3007         case CSSPropertyPaddingRight:
3008             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingRight, &amp;RenderBoxModelObject::computedCSSPaddingRight&gt;(style, renderer);
3009         case CSSPropertyPaddingBottom:
3010             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingBottom, &amp;RenderBoxModelObject::computedCSSPaddingBottom&gt;(style, renderer);
3011         case CSSPropertyPaddingLeft:
3012             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingLeft, &amp;RenderBoxModelObject::computedCSSPaddingLeft&gt;(style, renderer);
3013         case CSSPropertyPageBreakAfter:
3014             return cssValuePool.createValue(convertToPageBreak(style.breakAfter()));
3015         case CSSPropertyPageBreakBefore:
3016             return cssValuePool.createValue(convertToPageBreak(style.breakBefore()));
3017         case CSSPropertyPageBreakInside:
3018             return cssValuePool.createValue(convertToPageBreak(style.breakInside()));
</pre>
<hr />
<pre>
3054             return renderTextDecorationSkipFlagsToCSSValue(style.textDecorationSkip());
3055         case CSSPropertyTextUnderlinePosition:
3056             return cssValuePool.createValue(style.textUnderlinePosition());
3057         case CSSPropertyTextUnderlineOffset:
3058             return textUnderlineOffsetToCSSValue(style.textUnderlineOffset());
3059         case CSSPropertyTextDecorationThickness:
3060             return textDecorationThicknessToCSSValue(style.textDecorationThickness());
3061         case CSSPropertyWebkitTextDecorationsInEffect:
3062             return renderTextDecorationFlagsToCSSValue(style.textDecorationsInEffect());
3063         case CSSPropertyWebkitTextFillColor:
3064             return currentColorOrValidColor(&amp;style, style.textFillColor());
3065         case CSSPropertyWebkitTextEmphasisColor:
3066             return currentColorOrValidColor(&amp;style, style.textEmphasisColor());
3067         case CSSPropertyWebkitTextEmphasisPosition:
3068             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3069         case CSSPropertyWebkitTextEmphasisStyle:
3070             switch (style.textEmphasisMark()) {
3071             case TextEmphasisMark::None:
3072                 return cssValuePool.createIdentifierValue(CSSValueNone);
3073             case TextEmphasisMark::Custom:
<span class="line-modified">3074                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSUnitType::CSS_STRING);</span>
3075             case TextEmphasisMark::Auto:
3076                 ASSERT_NOT_REACHED();
<span class="line-modified">3077 #if !ASSERT_ENABLED</span>
3078                 FALLTHROUGH;
3079 #endif
3080             case TextEmphasisMark::Dot:
3081             case TextEmphasisMark::Circle:
3082             case TextEmphasisMark::DoubleCircle:
3083             case TextEmphasisMark::Triangle:
3084             case TextEmphasisMark::Sesame:
3085                 auto list = CSSValueList::createSpaceSeparated();
3086                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3087                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
3088                 return list;
3089             }
3090             RELEASE_ASSERT_NOT_REACHED();
3091         case CSSPropertyTextIndent: {
3092             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3093             // getPropertyCSSValue() returns CSSValue.
3094             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3095 #if ENABLE(CSS3_TEXT)
3096             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3097             // getPropertyCSSValue() returns CSSValueList.
</pre>
<hr />
<pre>
3106             }
3107 #endif
3108             return textIndent;
3109         }
3110         case CSSPropertyTextShadow:
3111             return valueForShadow(style.textShadow(), propertyID, style);
3112         case CSSPropertyTextRendering:
3113             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3114         case CSSPropertyTextOverflow:
3115             if (style.textOverflow() == TextOverflow::Ellipsis)
3116                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3117             return cssValuePool.createIdentifierValue(CSSValueClip);
3118         case CSSPropertyWebkitTextSecurity:
3119             return cssValuePool.createValue(style.textSecurity());
3120 #if ENABLE(TEXT_AUTOSIZING)
3121         case CSSPropertyWebkitTextSizeAdjust:
3122             if (style.textSizeAdjust().isAuto())
3123                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3124             if (style.textSizeAdjust().isNone())
3125                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">3126             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSUnitType::CSS_PERCENTAGE);</span>
3127 #endif
3128         case CSSPropertyWebkitTextStrokeColor:
3129             return currentColorOrValidColor(&amp;style, style.textStrokeColor());
3130         case CSSPropertyWebkitTextStrokeWidth:
3131             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
3132         case CSSPropertyTextTransform:
3133             return cssValuePool.createValue(style.textTransform());
3134         case CSSPropertyTop:
3135             return positionOffsetValue(style, CSSPropertyTop, renderer);
3136         case CSSPropertyUnicodeBidi:
3137             return cssValuePool.createValue(style.unicodeBidi());
3138         case CSSPropertyVerticalAlign:
3139             switch (style.verticalAlign()) {
3140             case VerticalAlign::Baseline:
3141                 return cssValuePool.createIdentifierValue(CSSValueBaseline);
3142             case VerticalAlign::Middle:
3143                 return cssValuePool.createIdentifierValue(CSSValueMiddle);
3144             case VerticalAlign::Sub:
3145                 return cssValuePool.createIdentifierValue(CSSValueSub);
3146             case VerticalAlign::Super:
</pre>
<hr />
<pre>
3150             case VerticalAlign::TextBottom:
3151                 return cssValuePool.createIdentifierValue(CSSValueTextBottom);
3152             case VerticalAlign::Top:
3153                 return cssValuePool.createIdentifierValue(CSSValueTop);
3154             case VerticalAlign::Bottom:
3155                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3156             case VerticalAlign::BaselineMiddle:
3157                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3158             case VerticalAlign::Length:
3159                 return cssValuePool.createValue(style.verticalAlignLength());
3160             }
3161             ASSERT_NOT_REACHED();
3162             return nullptr;
3163         case CSSPropertyVisibility:
3164             return cssValuePool.createValue(style.visibility());
3165         case CSSPropertyWhiteSpace:
3166             return cssValuePool.createValue(style.whiteSpace());
3167         case CSSPropertyWidows:
3168             if (style.hasAutoWidows())
3169                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3170             return cssValuePool.createValue(style.widows(), CSSUnitType::CSS_NUMBER);</span>
3171         case CSSPropertyWidth:
3172             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3173                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3174                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
3175                 if (!isNonReplacedInline(*renderer))
3176                     return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);
3177             }
3178             return zoomAdjustedPixelValueForLength(style.width(), style);
3179         case CSSPropertyWillChange:
3180             return willChangePropertyValue(style.willChange());
3181         case CSSPropertyWordBreak:
3182             return cssValuePool.createValue(style.wordBreak());
3183         case CSSPropertyWordSpacing:
3184             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3185         case CSSPropertyWordWrap:
3186             return cssValuePool.createValue(style.overflowWrap());
3187         case CSSPropertyLineBreak:
3188             return cssValuePool.createValue(style.lineBreak());
3189         case CSSPropertyWebkitNbspMode:
3190             return cssValuePool.createValue(style.nbspMode());
3191         case CSSPropertyResize:
3192             return cssValuePool.createValue(style.resize());
3193         case CSSPropertyWebkitFontKerning:
3194             return cssValuePool.createValue(style.fontDescription().kerning());
3195         case CSSPropertyWebkitFontSmoothing:
3196             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
3197         case CSSPropertyFontVariantLigatures:
3198             return fontVariantLigaturesPropertyValue(style.fontDescription().variantCommonLigatures(), style.fontDescription().variantDiscretionaryLigatures(), style.fontDescription().variantHistoricalLigatures(), style.fontDescription().variantContextualAlternates());
3199         case CSSPropertyFontVariantPosition:
3200             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3201         case CSSPropertyFontVariantCaps:
3202             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3203         case CSSPropertyFontVariantNumeric:
3204             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3205         case CSSPropertyFontVariantAlternates:
3206             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3207         case CSSPropertyFontVariantEastAsian:
3208             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3209         case CSSPropertyZIndex:
<span class="line-modified">3210             if (style.hasAutoSpecifiedZIndex())</span>
3211                 return cssValuePool.createIdentifierValue(CSSValueAuto);
<span class="line-modified">3212             return cssValuePool.createValue(style.specifiedZIndex(), CSSUnitType::CSS_NUMBER);</span>
3213         case CSSPropertyZoom:
<span class="line-modified">3214             return cssValuePool.createValue(style.zoom(), CSSUnitType::CSS_NUMBER);</span>
3215         case CSSPropertyBoxSizing:
3216             if (style.boxSizing() == BoxSizing::ContentBox)
3217                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3218             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
3219         case CSSPropertyAnimationDelay:
3220             return delayValue(style.animations());
3221         case CSSPropertyAnimationDirection: {
3222             auto list = CSSValueList::createCommaSeparated();
3223             const AnimationList* t = style.animations();
3224             if (t) {
3225                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3226                     switch (t-&gt;animation(i).direction()) {
3227                     case Animation::AnimationDirectionNormal:
3228                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3229                         break;
3230                     case Animation::AnimationDirectionAlternate:
3231                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3232                         break;
3233                     case Animation::AnimationDirectionReverse:
3234                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
</pre>
<hr />
<pre>
3260                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3261                         break;
3262                     case AnimationFillMode::Both:
3263                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3264                         break;
3265                     }
3266                 }
3267             } else
3268                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3269             return list;
3270         }
3271         case CSSPropertyAnimationIterationCount: {
3272             auto list = CSSValueList::createCommaSeparated();
3273             const AnimationList* t = style.animations();
3274             if (t) {
3275                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3276                     double iterationCount = t-&gt;animation(i).iterationCount();
3277                     if (iterationCount == Animation::IterationCountInfinite)
3278                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3279                     else
<span class="line-modified">3280                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSUnitType::CSS_NUMBER));</span>
3281                 }
3282             } else
<span class="line-modified">3283                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSUnitType::CSS_NUMBER));</span>
3284             return list;
3285         }
3286         case CSSPropertyAnimationName: {
3287             auto list = CSSValueList::createCommaSeparated();
3288             const AnimationList* t = style.animations();
3289             if (t) {
3290                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
<span class="line-modified">3291                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSUnitType::CSS_STRING));</span>
3292             } else
3293                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3294             return list;
3295         }
3296         case CSSPropertyAnimationPlayState: {
3297             auto list = CSSValueList::createCommaSeparated();
3298             const AnimationList* t = style.animations();
3299             if (t) {
3300                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3301                     switch (t-&gt;animation(i).playState()) {
3302                     case AnimationPlayState::Playing:
3303                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3304                         break;
3305                     case AnimationPlayState::Paused:
3306                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3307                         break;
3308                     }
3309                 }
3310             } else
3311                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
</pre>
<hr />
<pre>
3341         case CSSPropertyBorderImageWidth:
3342             return valueForNinePieceImageQuad(style.borderImage().borderSlices());
3343         case CSSPropertyWebkitMaskBoxImage:
3344             return valueForNinePieceImage(style.maskBoxImage());
3345         case CSSPropertyWebkitMaskBoxImageOutset:
3346             return valueForNinePieceImageQuad(style.maskBoxImage().outset());
3347         case CSSPropertyWebkitMaskBoxImageRepeat:
3348             return valueForNinePieceImageRepeat(style.maskBoxImage());
3349         case CSSPropertyWebkitMaskBoxImageSlice:
3350             return valueForNinePieceImageSlice(style.maskBoxImage());
3351         case CSSPropertyWebkitMaskBoxImageWidth:
3352             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3353         case CSSPropertyWebkitMaskBoxImageSource:
3354             if (style.maskBoxImageSource())
3355                 return style.maskBoxImageSource()-&gt;cssValue();
3356             return cssValuePool.createIdentifierValue(CSSValueNone);
3357         case CSSPropertyWebkitFontSizeDelta:
3358             // Not a real style property -- used by the editing engine -- so has no computed value.
3359             break;
3360         case CSSPropertyWebkitInitialLetter: {
<span class="line-modified">3361             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSUnitType::CSS_NUMBER);</span>
<span class="line-modified">3362             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSUnitType::CSS_NUMBER);</span>
3363             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3364         }
3365         case CSSPropertyWebkitMarginBottomCollapse:
3366         case CSSPropertyWebkitMarginAfterCollapse:
3367             return cssValuePool.createValue(style.marginAfterCollapse());
3368         case CSSPropertyWebkitMarginTopCollapse:
3369         case CSSPropertyWebkitMarginBeforeCollapse:
3370             return cssValuePool.createValue(style.marginBeforeCollapse());
3371 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
3372         case CSSPropertyWebkitOverflowScrolling:
3373             if (!style.useTouchOverflowScrolling())
3374                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3375             return cssValuePool.createIdentifierValue(CSSValueTouch);
3376 #endif
<span class="line-added">3377         case CSSPropertyScrollBehavior:</span>
<span class="line-added">3378             if (!style.useSmoothScrolling())</span>
<span class="line-added">3379                 return cssValuePool.createIdentifierValue(CSSValueAuto);</span>
<span class="line-added">3380             return cssValuePool.createIdentifierValue(CSSValueSmooth);</span>
3381         case CSSPropertyPerspective:
3382             if (!style.hasPerspective())
3383                 return cssValuePool.createIdentifierValue(CSSValueNone);
3384             return zoomAdjustedPixelValue(style.perspective(), style);
3385         case CSSPropertyPerspectiveOrigin: {
3386             auto list = CSSValueList::createSpaceSeparated();
3387             if (renderer) {
3388                 LayoutRect box;
3389                 if (is&lt;RenderBox&gt;(*renderer))
3390                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3391 
3392                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3393                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3394             } else {
3395                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3396                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3397             }
3398             return list;
3399         }
3400         case CSSPropertyWebkitRtlOrdering:
</pre>
<hr />
<pre>
3459             return list;
3460         }
3461         case CSSPropertyTransformStyle:
3462         case CSSPropertyWebkitTransformStyle:
3463             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3464         case CSSPropertyTransitionDelay:
3465             return delayValue(style.transitions());
3466         case CSSPropertyTransitionDuration:
3467             return durationValue(style.transitions());
3468         case CSSPropertyTransitionProperty:
3469             return transitionPropertyValue(style.transitions());
3470         case CSSPropertyTransitionTimingFunction:
3471             return timingFunctionValue(style.transitions());
3472         case CSSPropertyTransition: {
3473             if (auto* animationList = style.transitions()) {
3474                 auto transitionsList = CSSValueList::createCommaSeparated();
3475                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3476                     auto list = CSSValueList::createSpaceSeparated();
3477                     auto&amp; animation = animationList-&gt;animation(i);
3478                     list-&gt;append(createTransitionPropertyValue(animation));
<span class="line-modified">3479                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSUnitType::CSS_S));</span>
3480                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
<span class="line-modified">3481                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSUnitType::CSS_S));</span>
3482                     transitionsList-&gt;append(WTFMove(list));
3483                 }
3484                 return transitionsList;
3485             }
3486 
3487             auto list = CSSValueList::createSpaceSeparated();
3488             // transition-property default value.
3489             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
<span class="line-modified">3490             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));</span>
3491             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
<span class="line-modified">3492             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));</span>
3493             return list;
3494         }
3495         case CSSPropertyPointerEvents:
3496             return cssValuePool.createValue(style.pointerEvents());
3497         case CSSPropertyWebkitLineGrid:
3498             if (style.lineGrid().isNull())
3499                 return cssValuePool.createIdentifierValue(CSSValueNone);
<span class="line-modified">3500             return cssValuePool.createValue(style.lineGrid(), CSSUnitType::CSS_STRING);</span>
3501         case CSSPropertyWebkitLineSnap:
3502             return CSSPrimitiveValue::create(style.lineSnap());
3503         case CSSPropertyWebkitLineAlign:
3504             return CSSPrimitiveValue::create(style.lineAlign());
3505         case CSSPropertyWritingMode:
3506             return cssValuePool.createValue(style.writingMode());
3507         case CSSPropertyWebkitTextCombine:
3508             return cssValuePool.createValue(style.textCombine());
3509         case CSSPropertyWebkitTextOrientation:
3510             return CSSPrimitiveValue::create(style.textOrientation());
3511         case CSSPropertyWebkitLineBoxContain:
3512             return createLineBoxContainValue(style.lineBoxContain());
3513         case CSSPropertyAlt:
3514             return altTextToCSSValue(style);
3515         case CSSPropertyContent:
3516             return contentToCSSValue(style);
3517         case CSSPropertyCounterIncrement:
3518             return counterToCSSValue(style, propertyID);
3519         case CSSPropertyCounterReset:
3520             return counterToCSSValue(style, propertyID);
<span class="line-modified">3521         case CSSPropertyClipPath: {</span>
3522             auto* operation = style.clipPath();
3523             if (!operation)
3524                 return cssValuePool.createIdentifierValue(CSSValueNone);
3525             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
<span class="line-modified">3526                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSUnitType::CSS_URI);</span>
3527             auto list = CSSValueList::createSpaceSeparated();
3528             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3529                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3530                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3531                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3532                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3533             }
3534             if (is&lt;BoxClipPathOperation&gt;(*operation))
3535                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
3536             return list;
3537         }
3538         case CSSPropertyShapeMargin:
3539             return cssValuePool.createValue(style.shapeMargin(), style);
3540         case CSSPropertyShapeImageThreshold:
<span class="line-modified">3541             return cssValuePool.createValue(style.shapeImageThreshold(), CSSUnitType::CSS_NUMBER);</span>
3542         case CSSPropertyShapeOutside:
3543             return shapePropertyValue(style, style.shapeOutside());
3544         case CSSPropertyFilter:
3545             return valueForFilter(style, style.filter());
3546         case CSSPropertyAppleColorFilter:
3547             return valueForFilter(style, style.appleColorFilter());
3548 #if ENABLE(FILTERS_LEVEL_2)
3549         case CSSPropertyWebkitBackdropFilter:
3550             return valueForFilter(style, style.backdropFilter());
3551 #endif
3552 #if ENABLE(CSS_COMPOSITING)
3553         case CSSPropertyMixBlendMode:
3554             return cssValuePool.createValue(style.blendMode());
3555         case CSSPropertyIsolation:
3556             return cssValuePool.createValue(style.isolation());
3557 #endif
3558         case CSSPropertyBackgroundBlendMode: {
3559             auto&amp; layers = style.backgroundLayers();
3560             if (!layers.next())
3561                 return cssValuePool.createValue(layers.blendMode());
</pre>
<hr />
<pre>
3719         case CSSPropertyStrokeDashoffset:
3720             return zoomAdjustedPixelValueForLength(style.svgStyle().strokeDashOffset(), style);
3721         case CSSPropertyX:
3722             return zoomAdjustedPixelValueForLength(style.svgStyle().x(), style);
3723         case CSSPropertyY:
3724             return zoomAdjustedPixelValueForLength(style.svgStyle().y(), style);
3725         case CSSPropertyWebkitTextZoom:
3726             return cssValuePool.createValue(style.textZoom());
3727 
3728         case CSSPropertyPaintOrder:
3729             return paintOrder(style.paintOrder());
3730         case CSSPropertyStrokeLinecap:
3731             return CSSPrimitiveValue::create(style.capStyle());
3732         case CSSPropertyStrokeLinejoin:
3733             return CSSPrimitiveValue::create(style.joinStyle());
3734         case CSSPropertyStrokeWidth:
3735             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
3736         case CSSPropertyStrokeColor:
3737             return currentColorOrValidColor(&amp;style, style.strokeColor());
3738         case CSSPropertyStrokeMiterlimit:
<span class="line-modified">3739             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSUnitType::CSS_NUMBER);</span>
3740 
3741         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
3742         case CSSPropertyAll:
3743         case CSSPropertyAnimation:
3744         case CSSPropertyWebkitTextEmphasis:
3745             break;
3746 
3747         /* Directional properties are resolved by resolveDirectionAwareProperty() before the switch. */
3748         case CSSPropertyBorderBlockEnd:
3749         case CSSPropertyBorderBlockEndColor:
3750         case CSSPropertyBorderBlockEndStyle:
3751         case CSSPropertyBorderBlockEndWidth:
3752         case CSSPropertyBorderBlockStart:
3753         case CSSPropertyBorderBlockStartColor:
3754         case CSSPropertyBorderBlockStartStyle:
3755         case CSSPropertyBorderBlockStartWidth:
3756         case CSSPropertyBorderInlineEnd:
3757         case CSSPropertyBorderInlineEndColor:
3758         case CSSPropertyBorderInlineEndStyle:
3759         case CSSPropertyBorderInlineEndWidth:
</pre>
<hr />
<pre>
3780         case CSSPropertyMinBlockSize:
3781         case CSSPropertyMinInlineSize:
3782             ASSERT_NOT_REACHED();
3783             break;
3784 
3785         /* Unimplemented @font-face properties */
3786         case CSSPropertySrc:
3787         case CSSPropertyUnicodeRange:
3788         case CSSPropertyFontDisplay:
3789             break;
3790 
3791         /* Other unimplemented properties */
3792         case CSSPropertyPage: // for @page
3793         case CSSPropertyQuotes: // FIXME: needs implementation
3794         case CSSPropertySize: // for @page
3795             break;
3796 
3797         /* Unimplemented -webkit- properties */
3798         case CSSPropertyWebkitBorderRadius:
3799         case CSSPropertyWebkitMarginCollapse:
<span class="line-modified">3800         case CSSPropertyWebkitMarqueeDirection:</span>
<span class="line-added">3801         case CSSPropertyWebkitMarqueeIncrement:</span>
<span class="line-added">3802         case CSSPropertyWebkitMarqueeRepetition:</span>
<span class="line-added">3803         case CSSPropertyWebkitMarqueeStyle:</span>
3804         case CSSPropertyWebkitMarqueeSpeed:
3805         case CSSPropertyWebkitMask:
3806         case CSSPropertyWebkitMaskRepeatX:
3807         case CSSPropertyWebkitMaskRepeatY:
3808         case CSSPropertyPerspectiveOriginX:
3809         case CSSPropertyPerspectiveOriginY:
3810         case CSSPropertyWebkitTextStroke:
3811         case CSSPropertyTransformOriginX:
3812         case CSSPropertyTransformOriginY:
3813         case CSSPropertyTransformOriginZ:
3814             break;
3815 
3816 #if ENABLE(CSS_DEVICE_ADAPTATION)
3817         case CSSPropertyMaxZoom:
3818         case CSSPropertyMinZoom:
3819         case CSSPropertyOrientation:
3820         case CSSPropertyUserZoom:
3821             break;
3822 #endif
3823 
3824         case CSSPropertyBufferedRendering:

3825         case CSSPropertyClipRule:
3826         case CSSPropertyMask:
3827         case CSSPropertyEnableBackground:
3828         case CSSPropertyFloodColor:
3829         case CSSPropertyFloodOpacity:
3830         case CSSPropertyLightingColor:
3831         case CSSPropertyStopColor:
3832         case CSSPropertyStopOpacity:
3833         case CSSPropertyColorInterpolation:
3834         case CSSPropertyColorInterpolationFilters:
3835         case CSSPropertyColorProfile:
3836         case CSSPropertyColorRendering:
3837         case CSSPropertyFill:
3838         case CSSPropertyFillOpacity:
3839         case CSSPropertyFillRule:
3840         case CSSPropertyMarker:
3841         case CSSPropertyMarkerEnd:
3842         case CSSPropertyMarkerMid:
3843         case CSSPropertyMarkerStart:
3844         case CSSPropertyMaskType:
3845         case CSSPropertyShapeRendering:
3846         case CSSPropertyStroke:
3847         case CSSPropertyStrokeDasharray:
3848         case CSSPropertyStrokeOpacity:
3849         case CSSPropertyAlignmentBaseline:
3850         case CSSPropertyBaselineShift:
3851         case CSSPropertyDominantBaseline:
3852         case CSSPropertyGlyphOrientationHorizontal:
3853         case CSSPropertyGlyphOrientationVertical:
3854         case CSSPropertyKerning:
3855         case CSSPropertyTextAnchor:
3856         case CSSPropertyVectorEffect:
3857             return svgPropertyValue(propertyID);
3858         case CSSPropertyCustom:
3859             ASSERT_NOT_REACHED();
3860             return nullptr;
3861     }
3862 

3863     return nullptr;
3864 }
3865 
3866 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
3867 {
3868     auto value = getPropertyCSSValue(propertyID);
3869     if (!value)
3870         return emptyString(); // FIXME: Should this be null instead, as it is in StyleProperties::getPropertyValue?
3871     return value-&gt;cssText();
3872 }
3873 
3874 unsigned CSSComputedStyleDeclaration::length() const
3875 {
3876     updateStyleIfNeededForProperty(m_element.get(), CSSPropertyCustom);
3877 
3878     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
3879     if (!style)
3880         return 0;
3881 
<span class="line-modified">3882     return numComputedPropertyIDs + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();</span>
3883 }
3884 
3885 String CSSComputedStyleDeclaration::item(unsigned i) const
3886 {
3887     if (i &gt;= length())
3888         return String();
3889 
<span class="line-modified">3890     if (i &lt; numComputedPropertyIDs)</span>
<span class="line-modified">3891         return getPropertyNameString(computedPropertyIDs[i]);</span>
3892 
3893     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
3894     if (!style)
3895         return String();
3896 
3897     const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
3898 
<span class="line-modified">3899     if (i &lt; numComputedPropertyIDs + inheritedCustomProperties.size()) {</span>
3900         auto results = copyToVector(inheritedCustomProperties.keys());
<span class="line-modified">3901         return results.at(i - numComputedPropertyIDs);</span>
3902     }
3903 
3904     const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
3905     auto results = copyToVector(nonInheritedCustomProperties.keys());
<span class="line-modified">3906     return results.at(i - inheritedCustomProperties.size() - numComputedPropertyIDs);</span>
3907 }
3908 
3909 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
3910 {
3911     if (!m_element)
3912         return false;
3913     if (propertyID == CSSPropertyFontSize &amp;&amp; is&lt;CSSPrimitiveValue&gt;(*value)) {
3914         m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
3915         if (auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier)) {
3916             if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier()) {
3917                 auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
3918                 if (primitiveValue.isValueID() &amp;&amp; primitiveValue.valueID() == sizeIdentifier)
3919                     return true;
3920             }
3921         }
3922     }
3923     RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
3924     return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
3925 }
3926 





3927 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
3928 {
3929     auto list = CSSValueList::createSpaceSeparated();
3930     for (size_t i = 0; i &lt; shorthand.length(); ++i)
3931         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
3932     return list;
3933 }
3934 
3935 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
3936 {
3937     auto list = CSSValueList::createSpaceSeparated();
3938 
3939     // Assume the properties are in the usual order start, end.
3940     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
3941     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
3942 
3943     // All 2 properties must be specified.
3944     if (!startValue || !endValue)
3945         return nullptr;
3946 
</pre>
<hr />
<pre>
3975     if (showRight)
3976         list-&gt;append(rightValue.releaseNonNull());
3977     if (showBottom)
3978         list-&gt;append(bottomValue.releaseNonNull());
3979     if (showLeft)
3980         list-&gt;append(leftValue.releaseNonNull());
3981 
3982     return list;
3983 }
3984 
3985 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
3986 {
3987     auto list = CSSValueList::createSlashSeparated();
3988     for (size_t i = 0; i &lt; shorthand.length(); ++i)
3989         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
3990     return list;
3991 }
3992 
3993 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
3994 {
<span class="line-modified">3995     Vector&lt;CSSProperty&gt; list;</span>
3996     list.reserveInitialCapacity(length);
3997     for (unsigned i = 0; i &lt; length; ++i) {
3998         if (auto value = propertyValue(set[i]))
3999             list.append(CSSProperty(set[i], WTFMove(value), false));
4000     }
<span class="line-modified">4001     return MutableStyleProperties::create(WTFMove(list));</span>
<span class="line-added">4002 }</span>
<span class="line-added">4003 </span>
<span class="line-added">4004 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()</span>
<span class="line-added">4005 {</span>
<span class="line-added">4006     Vector&lt;CSSProperty&gt; list;</span>
<span class="line-added">4007     list.reserveInitialCapacity(numCSSProperties);</span>
<span class="line-added">4008     for (unsigned i = firstCSSProperty; i &lt; lastCSSProperty; ++i) {</span>
<span class="line-added">4009         auto propertyID = convertToCSSPropertyID(i);</span>
<span class="line-added">4010         if (auto value = propertyValue(propertyID))</span>
<span class="line-added">4011             list.append(CSSProperty(propertyID, WTFMove(value)));</span>
<span class="line-added">4012     }</span>
<span class="line-added">4013     return MutableStyleProperties::create(WTFMove(list));</span>
4014 }
4015 
4016 CSSRule* CSSComputedStyleDeclaration::parentRule() const
4017 {
4018     return nullptr;
4019 }
4020 
4021 RefPtr&lt;DeprecatedCSSOMValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(const String&amp; propertyName)
4022 {
4023     if (isCustomPropertyName(propertyName)) {
4024         auto value = ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyValue(propertyName);
4025         if (!value)
4026             return nullptr;
4027         return value-&gt;createDeprecatedCSSOMWrapper(*this);
4028     }
4029 
4030     CSSPropertyID propertyID = cssPropertyID(propertyName);
4031     if (!propertyID)
4032         return nullptr;
4033     auto value = getPropertyCSSValue(propertyID);
</pre>
</td>
</tr>
</table>
<center><a href="CSSCanvasValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSCrossfadeValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperLayer.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerBuffer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -33,49 +33,80 @@</span>
  
  namespace WebCore {
  
  TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr&lt;BitmapTexture&gt;&amp;&amp; texture, TextureMapperGL::Flags flags)
      : m_texture(WTFMove(texture))
<span class="udiff-line-modified-removed">-     , m_textureID(0)</span>
<span class="udiff-line-modified-added">+     , m_variant(RGBTexture { 0 })</span>
      , m_extraFlags(flags)
      , m_hasManagedTexture(true)
  {
  }
  
  TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
<span class="udiff-line-modified-removed">-     : m_textureID(textureID)</span>
<span class="udiff-line-modified-added">+     : TextureMapperPlatformLayerBuffer({ RGBTexture { textureID } }, size, flags, internalFormat)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVariant&amp;&amp; variant, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)</span>
<span class="udiff-line-added">+     : m_variant(WTFMove(variant))</span>
      , m_size(size)
      , m_internalFormat(internalFormat)
      , m_extraFlags(flags)
      , m_hasManagedTexture(false)
  {
  }
  
<span class="udiff-line-added">+ TextureMapperPlatformLayerBuffer::~TextureMapperPlatformLayerBuffer()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize&amp; size, GLint internalFormat)
  {
      return m_texture &amp;&amp; (m_texture-&gt;size() == size) &amp;&amp; (static_cast&lt;BitmapTextureGL*&gt;(m_texture.get())-&gt;internalFormat() == internalFormat || internalFormat == GL_DONT_CARE);
  }
  
  std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerBuffer::clone()
  {
<span class="udiff-line-modified-removed">-     if (m_hasManagedTexture || !m_textureID) {</span>
<span class="udiff-line-modified-added">+     if (m_hasManagedTexture) {</span>
          notImplemented();
          return nullptr;
      }
<span class="udiff-line-modified-removed">-     auto texture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);</span>
<span class="udiff-line-modified-removed">-     texture-&gt;reset(m_size);</span>
<span class="udiff-line-modified-removed">-     static_cast&lt;BitmapTextureGL&amp;&gt;(texture.get()).copyFromExternalTexture(m_textureID);</span>
<span class="udiff-line-modified-removed">-     return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(texture), m_extraFlags);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     return WTF::switchOn(m_variant,</span>
<span class="udiff-line-modified-added">+         [&amp;](const RGBTexture&amp; texture) mutable -&gt; std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; {</span>
<span class="udiff-line-modified-added">+             if (!texture.id) {</span>
<span class="udiff-line-added">+                 notImplemented();</span>
<span class="udiff-line-added">+                 return nullptr;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             auto clonedTexture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);</span>
<span class="udiff-line-added">+             clonedTexture-&gt;reset(m_size);</span>
<span class="udiff-line-added">+             static_cast&lt;BitmapTextureGL&amp;&gt;(clonedTexture.get()).copyFromExternalTexture(texture.id);</span>
<span class="udiff-line-added">+             return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(clonedTexture), m_extraFlags);</span>
<span class="udiff-line-added">+         },</span>
<span class="udiff-line-added">+         [](const YUVTexture&amp;)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             notImplemented();</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         },</span>
<span class="udiff-line-added">+         [](const ExternalOESTexture&amp;)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             notImplemented();</span>
<span class="udiff-line-added">+             return nullptr;</span>
<span class="udiff-line-added">+         });</span>
  }
  
  void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)
  {
      TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
  
      if (m_hasManagedTexture) {
          ASSERT(m_texture);
          BitmapTextureGL* textureGL = static_cast&lt;BitmapTextureGL*&gt;(m_texture.get());
<span class="udiff-line-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+         textureGL-&gt;updatePendingContents(IntRect(IntPoint(), textureGL-&gt;contentSize()), IntPoint());</span>
<span class="udiff-line-added">+ #endif</span>
          texmapGL.drawTexture(textureGL-&gt;id(), m_extraFlags | textureGL-&gt;colorConvertFlags(), textureGL-&gt;size(), targetRect, modelViewMatrix, opacity);
          return;
      }
  
      if (m_extraFlags &amp; TextureMapperGL::ShouldNotBlend) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -84,12 +115,44 @@</span>
              m_holePunchClient-&gt;setVideoRectangle(enclosingIntRect(modelViewMatrix.mapRect(targetRect)));
          texmapGL.drawSolidColor(targetRect, modelViewMatrix, Color(0, 0, 0, 0), false);
          return;
      }
  
<span class="udiff-line-modified-removed">-     ASSERT(m_textureID);</span>
<span class="udiff-line-modified-removed">-     texmapGL.drawTexture(m_textureID, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-modified-added">+ #if USE(GSTREAMER_GL)</span>
<span class="udiff-line-modified-added">+     if (m_unmanagedBufferDataHolder)</span>
<span class="udiff-line-added">+         m_unmanagedBufferDataHolder-&gt;waitForCPUSync();</span>
<span class="udiff-line-added">+ #endif // USE(GSTREAMER_GL)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     WTF::switchOn(m_variant,</span>
<span class="udiff-line-added">+         [&amp;](const RGBTexture&amp; texture) {</span>
<span class="udiff-line-added">+             ASSERT(texture.id);</span>
<span class="udiff-line-added">+             texmapGL.drawTexture(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-added">+         },</span>
<span class="udiff-line-added">+         [&amp;](const YUVTexture&amp; texture) {</span>
<span class="udiff-line-added">+             switch (texture.numberOfPlanes) {</span>
<span class="udiff-line-added">+             case 1:</span>
<span class="udiff-line-added">+                 ASSERT(texture.yuvPlane[0] == texture.yuvPlane[1] &amp;&amp; texture.yuvPlane[1] == texture.yuvPlane[2]);</span>
<span class="udiff-line-added">+                 ASSERT(texture.yuvPlaneOffset[0] == 2 &amp;&amp; texture.yuvPlaneOffset[1] == 1 &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="udiff-line-added">+                 texmapGL.drawTexturePackedYUV(texture.planes[texture.yuvPlane[0]],</span>
<span class="udiff-line-added">+                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case 2:</span>
<span class="udiff-line-added">+                 ASSERT(!texture.yuvPlaneOffset[0]);</span>
<span class="udiff-line-added">+                 texmapGL.drawTextureSemiPlanarYUV(std::array&lt;GLuint, 2&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]] }, !!texture.yuvPlaneOffset[1],</span>
<span class="udiff-line-added">+                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case 3:</span>
<span class="udiff-line-added">+                 ASSERT(!texture.yuvPlaneOffset[0] &amp;&amp; !texture.yuvPlaneOffset[1] &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="udiff-line-added">+                 texmapGL.drawTexturePlanarYUV(std::array&lt;GLuint, 3&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]], texture.planes[texture.yuvPlane[2]] },</span>
<span class="udiff-line-added">+                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         },</span>
<span class="udiff-line-added">+         [&amp;](const ExternalOESTexture&amp; texture) {</span>
<span class="udiff-line-added">+             ASSERT(texture.id);</span>
<span class="udiff-line-added">+             texmapGL.drawTextureExternalOES(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="udiff-line-added">+         });</span>
  }
  
  } // namespace WebCore
  
  #endif // USE(COORDINATED_GRAPHICS)
</pre>
<center><a href="TextureMapperLayer.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerBuffer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
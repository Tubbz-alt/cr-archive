<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 # Copyright (C) 2011 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require &quot;config&quot;
 25 require &quot;ast&quot;
 26 
 27 #
 28 # node.resolveSettings(settings)
 29 #
 30 # Construct a new AST that does not have any IfThenElse nodes by
 31 # substituting concrete boolean values for each Setting.
 32 #
 33 
 34 class Node
 35     def resolveSettings(settings)
 36         mapChildren {
 37             | child |
 38             child.resolveSettings(settings)
 39         }
 40     end
 41 end
 42 
 43 class True
 44     def resolveSettings(settings)
 45         self
 46     end
 47 end
 48 
 49 class False
 50     def resolveSettings(settings)
 51         self
 52     end
 53 end
 54 
 55 class Setting
 56     def resolveSettings(settings)
 57         settings[@name].asNode
 58     end
 59 end
 60 
 61 class And
 62     def resolveSettings(settings)
 63         (@left.resolveSettings(settings).value and @right.resolveSettings(settings).value).asNode
 64     end
 65 end
 66 
 67 class Or
 68     def resolveSettings(settings)
 69         (@left.resolveSettings(settings).value or @right.resolveSettings(settings).value).asNode
 70     end
 71 end
 72 
 73 class Not
 74     def resolveSettings(settings)
 75         (not @child.resolveSettings(settings).value).asNode
 76     end
 77 end
 78 
 79 class IfThenElse
 80     def resolveSettings(settings)
 81         if @predicate.resolveSettings(settings).value
 82             @thenCase.resolveSettings(settings)
 83         else
 84             @elseCase.resolveSettings(settings)
 85         end
 86     end
 87 end
 88 
 89 class Sequence
 90     def resolveSettings(settings)
 91         newList = []
 92         @list.each {
 93             | item |
 94             item = item.resolveSettings(settings)
 95             if item.is_a? Sequence
 96                 newList += item.list
 97             else
 98                 newList &lt;&lt; item
 99             end
100         }
101         Sequence.new(codeOrigin, newList)
102     end
103 end
104 
105 #
106 # node.demacroify(macros)
107 # node.substitute(mapping)
108 #
109 # demacroify() constructs a new AST that does not have any Macro
110 # nodes, while substitute() replaces Variable nodes with the given
111 # nodes in the mapping.
112 #
113 
114 class Node
115     def demacroify(macros)
116         mapChildren {
117             | child |
118             child.demacroify(macros)
119         }
120     end
121 
122     def freshVariables(mapping)
123         mapChildren {
124             | child |
125             child.freshVariables(mapping)
126         }
127     end
128 
129     def substitute(mapping)
130         mapChildren {
131             | child |
132             child.substitute(mapping)
133         }
134     end
135     
136     def substituteLabels(mapping)
137         mapChildren {
138             | child |
139             child.substituteLabels(mapping)
140         }
141     end
142 end
143 
144 $uniqueMacroVarID = 0
145 class Macro
146     def freshVariables(mapping = {})
147         myMapping = mapping.dup
148         newVars = []
149         variables.each do |var|
150             $uniqueMacroVarID += 1
151             newVar = Variable.forName(var.codeOrigin, &quot;_var#{$uniqueMacroVarID}&quot;, var.originalName)
152             newVars &lt;&lt; newVar
153             myMapping[var] = newVar
154         end
155         Macro.new(codeOrigin, name, newVars, body.freshVariables(myMapping))
156     end
157 
158     def substitute(mapping)
159         myMapping = {}
160         mapping.each_pair {
161             | key, value |
162             unless @variables.include? key
163                 myMapping[key] = value
164             end
165         }
166         mapChildren {
167             | child |
168             child.substitute(myMapping)
169         }
170     end
171 end
172 
173 class MacroCall
174     def freshVariables(mapping)
175         newName = Variable.forName(codeOrigin, name, originalName)
176         if mapping[newName]
177             newName = mapping[newName]
178         end
179         newOperands = operands.map { |operand| operand.freshVariables(mapping) }
180         MacroCall.new(codeOrigin, newName.name, newOperands, annotation, originalName)
181     end
182 end
183 
184 $concatenation = /%([a-zA-Z0-9_]+)%/
185 class Variable
186     def freshVariables(mapping)
187         if @name =~ $concatenation
188             name = @name.gsub($concatenation) { |match|
189                 var = Variable.forName(codeOrigin, match[1...-1])
190                 if mapping[var]
191                     &quot;%#{mapping[var].name}%&quot;
192                 else
193                     match
194                 end
195             }
196             Variable.forName(codeOrigin, name)
197         elsif mapping[self]
198             mapping[self]
199         else
200             self
201         end
202     end
203 
204     def substitute(mapping)
205         if @name =~ $concatenation
206             name = @name.gsub($concatenation) { |match|
207                 var = Variable.forName(codeOrigin, match[1...-1])
<a name="1" id="anc1"></a><span class="line-modified">208                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin} - #{mapping} &quot; unless mapping[var]</span>
<span class="line-modified">209                 mapping[var].name</span>



210             }
211             Variable.forName(codeOrigin, name)
212         elsif mapping[self]
213             mapping[self]
214         else
215             self
216         end
217     end
218 end
219 
220 class StructOffset
221     def freshVariables(mapping)
222         if dump =~ $concatenation
223             names = dump.gsub($concatenation) { |match|
224                 var = Variable.forName(codeOrigin, match[1...-1])
225                 if mapping[var]
226                     &quot;%#{mapping[var].name}%&quot;
227                 else
228                     match
229                 end
230             }.split(&#39;::&#39;)
231             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
232         else
233             self
234         end
235     end
236 
237     def substitute(mapping)
238         if dump =~ $concatenation
239             names = dump.gsub($concatenation) { |match|
240                 var = Variable.forName(codeOrigin, match[1...-1])
<a name="2" id="anc2"></a><span class="line-modified">241                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">242                 mapping[var].name</span>



243             }.split(&#39;::&#39;)
244             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
245         else
246             self
247         end
248     end
249 end
250 
251 class Label
252     def freshVariables(mapping)
253         if @name =~ $concatenation
254             name = @name.gsub($concatenation) { |match|
255                 var = Variable.forName(codeOrigin, match[1...-1])
256                 if mapping[var]
257                     &quot;%#{mapping[var].name}%&quot;
258                 else
259                     match
260                 end
261             }
<a name="3" id="anc3"></a><span class="line-modified">262             Label.forName(codeOrigin, name, @definedInFile)</span>



263         else
264             self
265         end
266     end
267 
268     def substitute(mapping)
269         if @name =~ $concatenation
270             name = @name.gsub($concatenation) { |match|
271                 var = Variable.forName(codeOrigin, match[1...-1])
<a name="4" id="anc4"></a><span class="line-modified">272                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">273                 mapping[var].name</span>



274             }
<a name="5" id="anc5"></a><span class="line-modified">275             Label.forName(codeOrigin, name, @definedInFile)</span>



276         else
277             self
278         end
279     end
280 end
281 
282 class ConstExpr
283     def freshVariables(mapping)
284         if @value =~ $concatenation
285             value = @value.gsub($concatenation) { |match|
286                 var = Variable.forName(codeOrigin, match[1...-1])
287                 if mapping[var]
288                     &quot;%#{mapping[var].name}%&quot;
289                 else
290                     match
291                 end
292             }
293             ConstExpr.forName(codeOrigin, value)
294         else
295             self
296         end
297     end
298 
299     def substitute(mapping)
300         if @value =~ $concatenation
301             value = @value.gsub($concatenation) { |match|
302                 var = Variable.forName(codeOrigin, match[1...-1])
<a name="6" id="anc6"></a><span class="line-modified">303                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">304                 mapping[var].name</span>



305             }
306             ConstExpr.forName(codeOrigin, value)
307         else
308             self
309         end
310     end
311 end
312 
313 class Sizeof
314     def freshVariables(mapping)
315         if struct =~ $concatenation
316             value = struct.gsub($concatenation) { |match|
317                 var = Variable.forName(codeOrigin, match[1...-1])
318                 if mapping[var]
319                     &quot;%#{mapping[var].name}%&quot;
320                 else
321                     match
322                 end
323             }
324             Sizeof.forName(codeOrigin, value)
325         else
326             self
327         end
328     end
329 
330     def substitute(mapping)
331         if struct =~ $concatenation
332             value = struct.gsub($concatenation) { |match|
333                 var = Variable.forName(codeOrigin, match[1...-1])
<a name="7" id="anc7"></a><span class="line-modified">334                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">335                 mapping[var].name</span>



336             }
337             Sizeof.forName(codeOrigin, value)
338         else
339             self
340         end
341     end
342 end
343 
344 class LocalLabel
345     def substituteLabels(mapping)
346         if mapping[self]
347             mapping[self]
348         else
349             self
350         end
351     end
352 end
353 
<a name="8" id="anc8"></a><span class="line-modified">354 class MacroError &lt; RuntimeError</span>
<span class="line-removed">355     attr_reader :message</span>
<span class="line-removed">356     attr_reader :backtrace</span>
<span class="line-removed">357     def initialize(message, backtrace)</span>
<span class="line-removed">358         @message = message</span>
<span class="line-removed">359         @backtrace = backtrace</span>
<span class="line-removed">360     end</span>
361 end
362 
363 class Sequence
364     def substitute(constants)
365         newList = []
366         myConstants = constants.dup
367         @list.each {
368             | item |
369             if item.is_a? ConstDecl
370                 myConstants[item.variable] = item.value.substitute(myConstants)
371             else
372                 newList &lt;&lt; item.substitute(myConstants)
373             end
374         }
375         Sequence.new(codeOrigin, newList)
376     end
377     
378     def renameLabels(comment)
379         mapping = {}
380         
381         @list.each {
382             | item |
383             if item.is_a? LocalLabel
384                 mapping[item] = LocalLabel.unique(if comment then comment + &quot;_&quot; else &quot;&quot; end + item.cleanName)
385             end
386         }
387         
388         substituteLabels(mapping)
389     end
390     
391     @@demacroifyStack = []
392     def macroError(msg)
393         backtrace = @@demacroifyStack.reverse.map { |macroCall|
394             &quot;#{macroCall.codeOrigin} in call to #{macroCall.originalName}&quot;
395         }
<a name="9" id="anc9"></a><span class="line-modified">396         raise MacroError.new(msg, backtrace)</span>
397     end
398 
399     def demacroify(macros)
400         myMacros = macros.dup
<a name="10" id="anc10"></a>
401         @list.each {
402             | item |
403             if item.is_a? Macro
404                 myMacros[item.name] = item.freshVariables
405             end
406         }
407         newList = []
408         @list.each {
409             | item |
410             if item.is_a? Macro
<a name="11" id="anc11"></a><span class="line-modified">411                 # Ignore.</span>
412             elsif item.is_a? MacroCall
413                 @@demacroifyStack &lt;&lt; item
414                 mapping = {}
415                 myMyMacros = myMacros.dup
416                 macro = myMacros[item.name]
417                 macroError &quot;Could not find macro #{item.originalName}&quot; unless macro
418                 macroError &quot;Argument count mismatch for call to #{item.originalName} (expected #{macro.variables.size} but got #{item.operands.size} arguments for macro #{item.originalName} defined at #{macro.codeOrigin})&quot; unless item.operands.size == macro.variables.size
419                 item.operands.size.times {
420                     | idx |
421                     if item.operands[idx].is_a? Variable and myMacros[item.operands[idx].name]
422                         myMyMacros[macro.variables[idx].name] = myMacros[item.operands[idx].name]
423                         mapping[macro.variables[idx]] = nil
424                     elsif item.operands[idx].is_a? Macro
425                         myMyMacros[macro.variables[idx].name] = item.operands[idx].freshVariables
426                         mapping[macro.variables[idx]] = nil
427                     else
428                         myMyMacros[macro.variables[idx]] = nil
429                         mapping[macro.variables[idx]] = item.operands[idx]
430                     end
431                 }
432                 if item.annotation
433                     newList &lt;&lt; Instruction.new(item.codeOrigin, &quot;localAnnotation&quot;, [], item.annotation)
434                 end
435                 newList += macro.body.substitute(mapping).demacroify(myMyMacros).renameLabels(item.originalName).list
<a name="12" id="anc12"></a>
436                 @@demacroifyStack.pop
437             else
438                 newList &lt;&lt; item.demacroify(myMacros)
439             end
440         }
441         Sequence.new(codeOrigin, newList).substitute({})
442     end
443 end
444 
445 #
446 # node.resolveOffsets(offsets, sizes)
447 #
448 # Construct a new AST that has offset values instead of symbolic
449 # offsets.
450 #
451 
452 class Node
453     def resolveOffsets(constantsMap)
454         mapChildren {
455             | child |
456             child.resolveOffsets(constantsMap)
457         }
458     end
459 end
460 
461 class StructOffset
462     def resolveOffsets(constantsMap)
463         if constantsMap[self]
464             Immediate.new(codeOrigin, constantsMap[self])
465         else
466             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
467             puts &quot;sizes = #{constantsMap.inspect}&quot;
468             raise
469         end
470     end
471 end
472 
473 class Sizeof
474     def resolveOffsets(constantsMap)
475         if constantsMap[self]
476             Immediate.new(codeOrigin, constantsMap[self])
477         else
478             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
479             puts &quot;sizes = #{constantsMap.inspect}&quot;
480             raise
481         end
482     end
483 end
484 
485 class ConstExpr
486     def resolveOffsets(constantsMap)
487         if constantsMap[self]
488             Immediate.new(codeOrigin, constantsMap[self])
489         else
490             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
491             puts &quot;sizes = #{constantsMap.inspect}&quot;
492             raise
493         end
494     end
495 end
496 
497 #
498 # node.fold
499 #
500 # Resolve constant references and compute arithmetic expressions.
501 #
502 
503 class Node
504     def fold
505         mapChildren {
506             | child |
507             child.fold
508         }
509     end
510 end
511 
512 class AddImmediates
513     def fold
514         @left = @left.fold
515         @right = @right.fold
516         
517         return right.plusOffset(@left.value) if @left.is_a? Immediate and @right.is_a? LabelReference
518         return left.plusOffset(@right.value) if @left.is_a? LabelReference and @right.is_a? Immediate
519         
520         return self unless @left.is_a? Immediate
521         return self unless @right.is_a? Immediate
522         Immediate.new(codeOrigin, @left.value + @right.value)
523     end
524 end
525 
526 class SubImmediates
527     def fold
528         @left = @left.fold
529         @right = @right.fold
530         
531         return left.plusOffset(-@right.value) if @left.is_a? LabelReference and @right.is_a? Immediate
532         
533         return self unless @left.is_a? Immediate
534         return self unless @right.is_a? Immediate
535         Immediate.new(codeOrigin, @left.value - @right.value)
536     end
537 end
538 
539 class MulImmediates
540     def fold
541         @left = @left.fold
542         @right = @right.fold
543         return self unless @left.is_a? Immediate
544         return self unless @right.is_a? Immediate
545         Immediate.new(codeOrigin, @left.value * @right.value)
546     end
547 end
548 
549 class NegImmediate
550     def fold
551         @child = @child.fold
552         return self unless @child.is_a? Immediate
553         Immediate.new(codeOrigin, -@child.value)
554     end
555 end
556 
557 class OrImmediates
558     def fold
559         @left = @left.fold
560         @right = @right.fold
561         return self unless @left.is_a? Immediate
562         return self unless @right.is_a? Immediate
563         Immediate.new(codeOrigin, @left.value | @right.value)
564     end
565 end
566 
567 class AndImmediates
568     def fold
569         @left = @left.fold
570         @right = @right.fold
571         return self unless @left.is_a? Immediate
572         return self unless @right.is_a? Immediate
573         Immediate.new(codeOrigin, @left.value &amp; @right.value)
574     end
575 end
576 
577 class XorImmediates
578     def fold
579         @left = @left.fold
580         @right = @right.fold
581         return self unless @left.is_a? Immediate
582         return self unless @right.is_a? Immediate
583         Immediate.new(codeOrigin, @left.value ^ @right.value)
584     end
585 end
586 
587 class BitnotImmediate
588     def fold
589         @child = @child.fold
590         return self unless @child.is_a? Immediate
591         Immediate.new(codeOrigin, ~@child.value)
592     end
593 end
594 
595 #
596 # node.resolveAfterSettings(offsets, sizes)
597 #
598 # Compile assembly against a set of offsets.
599 #
600 
601 class Node
602     def resolve(constantsMap)
603         demacroify({}).resolveOffsets(constantsMap).fold
604     end
605 end
606 
607 #
608 # node.validate
609 #
610 # Checks that the node is ready for backend compilation.
611 #
612 
613 class Node
614     def validate
615         raise &quot;Unresolved #{dump} at #{codeOriginString}&quot;
616     end
617     
618     def validateChildren
619         children.each {
620             | node |
621             node.validate
622         }
623     end
624 end
625 
626 class Sequence
627     def validate
628         validateChildren
629         
630         # Further verify that this list contains only instructions, labels, and skips.
631         @list.each {
632             | node |
633             unless node.is_a? Instruction or
634                     node.is_a? Label or
635                     node.is_a? LocalLabel or
636                     node.is_a? Skip
637                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
638             end
639         }
640     end
641 end
642 
643 class Immediate
644     def validate
645     end
646 end
647 
648 class StringLiteral
649     def validate
650     end
651 end
652 
653 class RegisterID
654     def validate
655     end
656 end
657 
658 class FPRegisterID
659     def validate
660     end
661 end
662 
663 class Address
664     def validate
665         validateChildren
666     end
667 end
668 
669 class BaseIndex
670     def validate
671         validateChildren
672     end
673 end
674 
675 class AbsoluteAddress
676     def validate
677         validateChildren
678     end
679 end
680 
681 class Instruction
682     def validate
683         validateChildren
684     end
685 end
686 
687 class SubImmediates
688     def validate
689       raise &quot;Invalid operand #{left.dump} to immediate subtraction&quot; unless left.immediateOperand?
690       raise &quot;Invalid operand #{right.dump} to immediate subtraction&quot; unless right.immediateOperand?
691     end
692 end
693 
694 class Error
695     def validate
696     end
697 end
698 
699 class Label
700     def validate
701         raise &quot;Unresolved substitution in Label #{name} at #{codeOrigin}&quot; if name =~ /%/
702     end
703 end
704 
705 class LocalLabel
706     def validate
707     end
708 end
709 
710 class LabelReference
711     def validate
712     end
713 end
714 
715 class LocalLabelReference
716     def validate
717     end
718 end
719 
720 class Skip
721     def validate
722     end
723 end
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
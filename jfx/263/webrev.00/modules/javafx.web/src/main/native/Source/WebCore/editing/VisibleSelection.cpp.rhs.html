<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleSelection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2015 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;VisibleSelection.h&quot;
 28 
 29 #include &quot;Document.h&quot;
 30 #include &quot;Editing.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;HTMLInputElement.h&quot;
 33 #include &quot;Settings.h&quot;
 34 #include &quot;ShadowRoot.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &quot;StaticRange.h&quot;</span>
 36 #include &quot;TextIterator.h&quot;
 37 #include &quot;VisibleUnits.h&quot;
 38 #include &lt;stdio.h&gt;
 39 #include &lt;wtf/Assertions.h&gt;
 40 #include &lt;wtf/text/CString.h&gt;
 41 #include &lt;wtf/text/StringBuilder.h&gt;
 42 #include &lt;wtf/text/TextStream.h&gt;
 43 #include &lt;wtf/unicode/CharacterNames.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 VisibleSelection::VisibleSelection()
 48     : m_affinity(DOWNSTREAM)
 49     , m_selectionType(NoSelection)
 50     , m_baseIsFirst(true)
 51     , m_isDirectional(false)
 52 {
 53 }
 54 
 55 VisibleSelection::VisibleSelection(const Position&amp; pos, EAffinity affinity, bool isDirectional)
 56     : m_base(pos)
 57     , m_extent(pos)
 58     , m_affinity(affinity)
 59     , m_isDirectional(isDirectional)
 60 {
 61     validate();
 62 }
 63 
 64 VisibleSelection::VisibleSelection(const Position&amp; base, const Position&amp; extent, EAffinity affinity, bool isDirectional)
 65     : m_base(base)
 66     , m_extent(extent)
 67     , m_affinity(affinity)
 68     , m_isDirectional(isDirectional)
 69 {
 70     validate();
 71 }
 72 
 73 VisibleSelection::VisibleSelection(const VisiblePosition&amp; pos, bool isDirectional)
 74     : m_base(pos.deepEquivalent())
 75     , m_extent(pos.deepEquivalent())
 76     , m_affinity(pos.affinity())
 77     , m_isDirectional(isDirectional)
 78 {
 79     validate();
 80 }
 81 
 82 VisibleSelection::VisibleSelection(const VisiblePosition&amp; base, const VisiblePosition&amp; extent, bool isDirectional)
 83     : m_base(base.deepEquivalent())
 84     , m_extent(extent.deepEquivalent())
 85     , m_affinity(base.affinity())
 86     , m_isDirectional(isDirectional)
 87 {
 88     validate();
 89 }
 90 
 91 VisibleSelection::VisibleSelection(const Range&amp; range, EAffinity affinity, bool isDirectional)
 92     : m_base(range.startPosition())
 93     , m_extent(range.endPosition())
 94     , m_affinity(affinity)
 95     , m_isDirectional(isDirectional)
 96 {
 97     validate();
 98 }
 99 
<a name="2" id="anc2"></a><span class="line-added">100 VisibleSelection::VisibleSelection(const StaticRange&amp; staticRange, EAffinity affinity, bool isDirectional)</span>
<span class="line-added">101     : m_base(createLegacyEditingPosition(staticRange.startContainer(), staticRange.startOffset()))</span>
<span class="line-added">102     , m_extent(createLegacyEditingPosition(staticRange.endContainer(), staticRange.endOffset()))</span>
<span class="line-added">103     , m_affinity(affinity)</span>
<span class="line-added">104     , m_isDirectional(isDirectional)</span>
<span class="line-added">105 {</span>
<span class="line-added">106     ASSERT(&amp;staticRange.startContainer()-&gt;treeScope() == &amp;staticRange.endContainer()-&gt;treeScope());</span>
<span class="line-added">107     validate();</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
110 VisibleSelection VisibleSelection::selectionFromContentsOfNode(Node* node)
111 {
112     ASSERT(!editingIgnoresContent(*node));
113     return VisibleSelection(firstPositionInNode(node), lastPositionInNode(node), DOWNSTREAM);
114 }
115 
116 void VisibleSelection::setBase(const Position&amp; position)
117 {
118     m_base = position;
119     validate();
120 }
121 
122 void VisibleSelection::setBase(const VisiblePosition&amp; visiblePosition)
123 {
124     m_base = visiblePosition.deepEquivalent();
125     validate();
126 }
127 
128 void VisibleSelection::setExtent(const Position&amp; position)
129 {
130     m_extent = position;
131     validate();
132 }
133 
134 void VisibleSelection::setExtent(const VisiblePosition&amp; visiblePosition)
135 {
136     m_extent = visiblePosition.deepEquivalent();
137     validate();
138 }
139 
140 RefPtr&lt;Range&gt; VisibleSelection::firstRange() const
141 {
142     if (isNoneOrOrphaned())
143         return nullptr;
144     Position start = m_start.parentAnchoredEquivalent();
145     Position end = m_end.parentAnchoredEquivalent();
146     if (start.isNull() || start.isOrphan() || end.isNull() || end.isOrphan())
147         return nullptr;
148     return Range::create(start.anchorNode()-&gt;document(), start, end);
149 }
150 
151 RefPtr&lt;Range&gt; VisibleSelection::toNormalizedRange() const
152 {
153     if (isNoneOrOrphaned())
154         return nullptr;
155 
156     // Make sure we have an updated layout since this function is called
157     // in the course of running edit commands which modify the DOM.
158     // Failing to call this can result in equivalentXXXPosition calls returning
159     // incorrect results.
160     m_start.anchorNode()-&gt;document().updateLayout();
161 
162     // Check again, because updating layout can clear the selection.
163     if (isNoneOrOrphaned())
164         return nullptr;
165 
166     Position s, e;
167     if (isCaret()) {
168         // If the selection is a caret, move the range start upstream. This helps us match
169         // the conventions of text editors tested, which make style determinations based
170         // on the character before the caret, if any.
171         s = m_start.upstream().parentAnchoredEquivalent();
172         e = s;
173     } else {
174         // If the selection is a range, select the minimum range that encompasses the selection.
175         // Again, this is to match the conventions of text editors tested, which make style
176         // determinations based on the first character of the selection.
177         // For instance, this operation helps to make sure that the &quot;X&quot; selected below is the
178         // only thing selected. The range should not be allowed to &quot;leak&quot; out to the end of the
179         // previous text node, or to the beginning of the next text node, each of which has a
180         // different style.
181         //
182         // On a treasure map, &lt;b&gt;X&lt;/b&gt; marks the spot.
183         //                       ^ selected
184         //
185         ASSERT(isRange());
186         s = m_start.downstream();
187         e = m_end.upstream();
188         if (comparePositions(s, e) &gt; 0) {
189             // Make sure the start is before the end.
190             // The end can wind up before the start if collapsed whitespace is the only thing selected.
191             Position tmp = s;
192             s = e;
193             e = tmp;
194         }
195         s = s.parentAnchoredEquivalent();
196         e = e.parentAnchoredEquivalent();
197     }
198 
199     if (!s.containerNode() || !e.containerNode())
200         return nullptr;
201 
202     // VisibleSelections are supposed to always be valid.  This constructor will ASSERT
203     // if a valid range could not be created, which is fine for this callsite.
204     return Range::create(s.anchorNode()-&gt;document(), s, e);
205 }
206 
207 bool VisibleSelection::expandUsingGranularity(TextGranularity granularity)
208 {
209     if (isNone())
210         return false;
211 
212     validate(granularity);
213     return true;
214 }
215 
216 static RefPtr&lt;Range&gt; makeSearchRange(const Position&amp; position)
217 {
218     auto* node = position.deprecatedNode();
219     if (!node)
220         return nullptr;
221     auto* boundary = deprecatedEnclosingBlockFlowElement(node);
222     if (!boundary)
223         return nullptr;
224 
225     auto searchRange = Range::create(node-&gt;document());
226 
227     auto result = searchRange-&gt;selectNodeContents(*boundary);
228     if (result.hasException())
229         return nullptr;
230     Position start { position.parentAnchoredEquivalent() };
231     result = searchRange-&gt;setStart(*start.containerNode(), start.offsetInContainerNode());
232     if (result.hasException())
233         return nullptr;
234 
235     return searchRange;
236 }
237 
238 bool VisibleSelection::isAll(EditingBoundaryCrossingRule rule) const
239 {
240     return !nonBoundaryShadowTreeRootNode() &amp;&amp; visibleStart().previous(rule).isNull() &amp;&amp; visibleEnd().next(rule).isNull();
241 }
242 
243 void VisibleSelection::appendTrailingWhitespace()
244 {
245     RefPtr&lt;Range&gt; searchRange = makeSearchRange(m_end);
246     if (!searchRange)
247         return;
248 
249     CharacterIterator charIt(*searchRange, TextIteratorEmitsCharactersBetweenAllVisiblePositions);
250 
251     for (; !charIt.atEnd() &amp;&amp; charIt.text().length(); charIt.advance(1)) {
252         UChar c = charIt.text()[0];
253         if ((!isSpaceOrNewline(c) &amp;&amp; c != noBreakSpace) || c == &#39;\n&#39;)
254             break;
255         m_end = charIt.range()-&gt;endPosition();
256     }
257 }
258 
259 void VisibleSelection::setBaseAndExtentToDeepEquivalents()
260 {
261     // Move the selection to rendered positions, if possible.
262     bool baseAndExtentEqual = m_base == m_extent;
263     if (m_base.isNotNull()) {
264         m_base = VisiblePosition(m_base, m_affinity).deepEquivalent();
265         if (baseAndExtentEqual)
266             m_extent = m_base;
267     }
268     if (m_extent.isNotNull() &amp;&amp; !baseAndExtentEqual)
269         m_extent = VisiblePosition(m_extent, m_affinity).deepEquivalent();
270 
271     // Make sure we do not have a dangling base or extent.
272     if (m_base.isNull() &amp;&amp; m_extent.isNull())
273         m_baseIsFirst = true;
274     else if (m_base.isNull()) {
275         m_base = m_extent;
276         m_baseIsFirst = true;
277     } else if (m_extent.isNull()) {
278         m_extent = m_base;
279         m_baseIsFirst = true;
280     } else
281         m_baseIsFirst = comparePositions(m_base, m_extent) &lt;= 0;
282 }
283 
284 void VisibleSelection::setStartAndEndFromBaseAndExtentRespectingGranularity(TextGranularity granularity)
285 {
286     if (m_baseIsFirst) {
287         m_start = m_base;
288         m_end = m_extent;
289     } else {
290         m_start = m_extent;
291         m_end = m_base;
292     }
293 
294     switch (granularity) {
295         case CharacterGranularity:
296             // Don&#39;t do any expansion.
297             break;
298         case WordGranularity: {
299             // General case: Select the word the caret is positioned inside of, or at the start of (RightWordIfOnBoundary).
300             // Edge case: If the caret is after the last word in a soft-wrapped line or the last word in
301             // the document, select that last word (LeftWordIfOnBoundary).
302             // Edge case: If the caret is after the last word in a paragraph, select from the end of the
303             // last word to the line break (also RightWordIfOnBoundary);
304             VisiblePosition start = VisiblePosition(m_start, m_affinity);
305             VisiblePosition originalEnd(m_end, m_affinity);
306             EWordSide side = RightWordIfOnBoundary;
307             if (isEndOfEditableOrNonEditableContent(start) || (isEndOfLine(start) &amp;&amp; !isStartOfLine(start) &amp;&amp; !isEndOfParagraph(start)))
308                 side = LeftWordIfOnBoundary;
309             m_start = startOfWord(start, side).deepEquivalent();
310             side = RightWordIfOnBoundary;
311             if (isEndOfEditableOrNonEditableContent(originalEnd) || (isEndOfLine(originalEnd) &amp;&amp; !isStartOfLine(originalEnd) &amp;&amp; !isEndOfParagraph(originalEnd)))
312                 side = LeftWordIfOnBoundary;
313 
314             VisiblePosition wordEnd(endOfWord(originalEnd, side));
315             VisiblePosition end(wordEnd);
316 
317             if (isEndOfParagraph(originalEnd) &amp;&amp; !isEmptyTableCell(m_start.deprecatedNode())) {
318                 // Select the paragraph break (the space from the end of a paragraph to the start of
319                 // the next one) to match TextEdit.
320                 end = wordEnd.next();
321 
322                 if (auto* table = isFirstPositionAfterTable(end)) {
323                     // The paragraph break after the last paragraph in the last cell of a block table ends
324                     // at the start of the paragraph after the table.
325                     if (isBlock(table))
326                         end = end.next(CannotCrossEditingBoundary);
327                     else
328                         end = wordEnd;
329                 }
330 
331                 if (end.isNull())
332                     end = wordEnd;
333 
334             }
335 
336             m_end = end.deepEquivalent();
337             // End must not be before start.
338             if (m_start.deprecatedNode() == m_end.deprecatedNode() &amp;&amp; m_start.deprecatedEditingOffset() &gt; m_end.deprecatedEditingOffset()) {
339                 Position swap(m_start);
340                 m_start = m_end;
341                 m_end = swap;
342             }
343             break;
344         }
345         case SentenceGranularity: {
346             m_start = startOfSentence(VisiblePosition(m_start, m_affinity)).deepEquivalent();
347             m_end = endOfSentence(VisiblePosition(m_end, m_affinity)).deepEquivalent();
348             break;
349         }
350         case LineGranularity: {
351             m_start = startOfLine(VisiblePosition(m_start, m_affinity)).deepEquivalent();
352             VisiblePosition end = endOfLine(VisiblePosition(m_end, m_affinity));
353             // If the end of this line is at the end of a paragraph, include the space
354             // after the end of the line in the selection.
355             if (isEndOfParagraph(end)) {
356                 VisiblePosition next = end.next();
357                 if (next.isNotNull())
358                     end = next;
359             }
360             m_end = end.deepEquivalent();
361             break;
362         }
363         case LineBoundary:
364             m_start = startOfLine(VisiblePosition(m_start, m_affinity)).deepEquivalent();
365             m_end = endOfLine(VisiblePosition(m_end, m_affinity)).deepEquivalent();
366             break;
367         case ParagraphGranularity: {
368             VisiblePosition pos(m_start, m_affinity);
369             if (isStartOfLine(pos) &amp;&amp; isEndOfEditableOrNonEditableContent(pos))
370                 pos = pos.previous();
371             m_start = startOfParagraph(pos).deepEquivalent();
372             VisiblePosition visibleParagraphEnd = endOfParagraph(VisiblePosition(m_end, m_affinity));
373 
374             // Include the &quot;paragraph break&quot; (the space from the end of this paragraph to the start
375             // of the next one) in the selection.
376             VisiblePosition end(visibleParagraphEnd.next());
377 
378             if (Node* table = isFirstPositionAfterTable(end)) {
379                 // The paragraph break after the last paragraph in the last cell of a block table ends
380                 // at the start of the paragraph after the table, not at the position just after the table.
381                 if (isBlock(table))
382                     end = end.next(CannotCrossEditingBoundary);
383                 // There is no parargraph break after the last paragraph in the last cell of an inline table.
384                 else
385                     end = visibleParagraphEnd;
386             }
387 
388             if (end.isNull())
389                 end = visibleParagraphEnd;
390 
391             m_end = end.deepEquivalent();
392             break;
393         }
394         case DocumentBoundary:
395             m_start = startOfDocument(VisiblePosition(m_start, m_affinity)).deepEquivalent();
396             m_end = endOfDocument(VisiblePosition(m_end, m_affinity)).deepEquivalent();
397             break;
398         case ParagraphBoundary:
399             m_start = startOfParagraph(VisiblePosition(m_start, m_affinity)).deepEquivalent();
400             m_end = endOfParagraph(VisiblePosition(m_end, m_affinity)).deepEquivalent();
401             break;
402         case SentenceBoundary:
403             m_start = startOfSentence(VisiblePosition(m_start, m_affinity)).deepEquivalent();
404             m_end = endOfSentence(VisiblePosition(m_end, m_affinity)).deepEquivalent();
405             break;
406         case DocumentGranularity:
407             ASSERT_NOT_REACHED();
408             break;
409     }
410 
411     // Make sure we do not have a dangling start or end.
412     if (m_start.isNull())
413         m_start = m_end;
414     if (m_end.isNull())
415         m_end = m_start;
416 }
417 
418 void VisibleSelection::updateSelectionType()
419 {
420     if (m_start.isNull()) {
421         ASSERT(m_end.isNull());
422         m_selectionType = NoSelection;
423     } else if (m_start == m_end || m_start.upstream() == m_end.upstream()) {
424         m_selectionType = CaretSelection;
425     } else
426         m_selectionType = RangeSelection;
427 
428     // Affinity only makes sense for a caret
429     if (m_selectionType != CaretSelection)
430         m_affinity = DOWNSTREAM;
431 }
432 
433 void VisibleSelection::validate(TextGranularity granularity)
434 {
435     setBaseAndExtentToDeepEquivalents();
436     setStartAndEndFromBaseAndExtentRespectingGranularity(granularity);
437     adjustSelectionToAvoidCrossingShadowBoundaries();
438     adjustSelectionToAvoidCrossingEditingBoundaries();
439     updateSelectionType();
440 
441     if (selectionType() == RangeSelection) {
442         // &quot;Constrain&quot; the selection to be the smallest equivalent range of nodes.
443         // This is a somewhat arbitrary choice, but experience shows that it is
444         // useful to make to make the selection &quot;canonical&quot; (if only for
445         // purposes of comparing selections). This is an ideal point of the code
446         // to do this operation, since all selection changes that result in a RANGE
447         // come through here before anyone uses it.
448         // FIXME: Canonicalizing is good, but haven&#39;t we already done it (when we
449         // set these two positions to VisiblePosition deepEquivalent()s above)?
450         m_start = m_start.downstream();
451         m_end = m_end.upstream();
452 
453         // FIXME: Position::downstream() or Position::upStream() might violate editing boundaries
454         // if an anchor node has a Shadow DOM. So we adjust selection to avoid crossing editing
455         // boundaries again. See https://bugs.webkit.org/show_bug.cgi?id=87463
456         adjustSelectionToAvoidCrossingEditingBoundaries();
457     }
458 }
459 
460 // FIXME: This function breaks the invariant of this class.
461 // But because we use VisibleSelection to store values in editing commands for use when
462 // undoing the command, we need to be able to create a selection that while currently
463 // invalid, will be valid once the changes are undone. This is a design problem.
464 // To fix it we either need to change the invariants of VisibleSelection or create a new
465 // class for editing to use that can manipulate selections that are not currently valid.
466 void VisibleSelection::setWithoutValidation(const Position&amp; base, const Position&amp; extent)
467 {
468     ASSERT(!base.isNull());
469     ASSERT(!extent.isNull());
470     ASSERT(m_affinity == DOWNSTREAM);
471     m_base = base;
472     m_extent = extent;
473     m_baseIsFirst = comparePositions(base, extent) &lt;= 0;
474     if (m_baseIsFirst) {
475         m_start = base;
476         m_end = extent;
477     } else {
478         m_start = extent;
479         m_end = base;
480     }
481     m_selectionType = base == extent ? CaretSelection : RangeSelection;
482 }
483 
484 Position VisibleSelection::adjustPositionForEnd(const Position&amp; currentPosition, Node* startContainerNode)
485 {
486     TreeScope&amp; treeScope = startContainerNode-&gt;treeScope();
487 
488     ASSERT(&amp;currentPosition.containerNode()-&gt;treeScope() != &amp;treeScope);
489 
490     if (Node* ancestor = treeScope.ancestorNodeInThisScope(currentPosition.containerNode())) {
491         if (ancestor-&gt;contains(startContainerNode))
492             return positionAfterNode(ancestor);
493         return positionBeforeNode(ancestor);
494     }
495 
496     if (Node* lastChild = treeScope.rootNode().lastChild())
497         return positionAfterNode(lastChild);
498 
499     return Position();
500 }
501 
502 Position VisibleSelection::adjustPositionForStart(const Position&amp; currentPosition, Node* endContainerNode)
503 {
504     TreeScope&amp; treeScope = endContainerNode-&gt;treeScope();
505 
506     ASSERT(&amp;currentPosition.containerNode()-&gt;treeScope() != &amp;treeScope);
507 
508     if (Node* ancestor = treeScope.ancestorNodeInThisScope(currentPosition.containerNode())) {
509         if (ancestor-&gt;contains(endContainerNode))
510             return positionBeforeNode(ancestor);
511         return positionAfterNode(ancestor);
512     }
513 
514     if (Node* firstChild = treeScope.rootNode().firstChild())
515         return positionBeforeNode(firstChild);
516 
517     return Position();
518 }
519 
520 static bool isInUserAgentShadowRootOrHasEditableShadowAncestor(Node&amp; node)
521 {
522     auto* shadowRoot = node.containingShadowRoot();
523     if (!shadowRoot)
524         return false;
525 
526     if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
527         return true;
528 
529     for (RefPtr&lt;Node&gt; currentNode = &amp;node; currentNode; currentNode = currentNode-&gt;parentOrShadowHostNode()) {
530         if (currentNode-&gt;hasEditableStyle())
531             return true;
532     }
533     return false;
534 }
535 
536 void VisibleSelection::adjustSelectionToAvoidCrossingShadowBoundaries()
537 {
538     if (m_base.isNull() || m_start.isNull() || m_end.isNull())
539         return;
540 
541     auto startNode = makeRef(*m_start.anchorNode());
542     auto endNode = makeRef(*m_end.anchorNode());
543     if (&amp;startNode-&gt;treeScope() == &amp;endNode-&gt;treeScope())
544         return;
545 
546     if (startNode-&gt;document().settings().selectionAcrossShadowBoundariesEnabled()) {
547         if (!isInUserAgentShadowRootOrHasEditableShadowAncestor(startNode)
548             &amp;&amp; !isInUserAgentShadowRootOrHasEditableShadowAncestor(endNode))
549             return;
550     }
551 
552     if (m_baseIsFirst) {
553         m_extent = adjustPositionForEnd(m_end, m_start.containerNode());
554         m_end = m_extent;
555     } else {
556         m_extent = adjustPositionForStart(m_start, m_end.containerNode());
557         m_start = m_extent;
558     }
559 }
560 
561 void VisibleSelection::adjustSelectionToAvoidCrossingEditingBoundaries()
562 {
563     if (m_base.isNull() || m_start.isNull() || m_end.isNull())
564         return;
565 
566     // Early return in the caret case (the state hasn&#39;t actually been set yet, so we can&#39;t use isCaret()) to avoid the
567     // expense of computing highestEditableRoot.
568     if (m_base == m_start &amp;&amp; m_base == m_end)
569         return;
570 
571     auto* baseRoot = highestEditableRoot(m_base);
572     auto* startRoot = highestEditableRoot(m_start);
573     auto* endRoot = highestEditableRoot(m_end);
574 
575     auto* baseEditableAncestor = lowestEditableAncestor(m_base.containerNode());
576 
577     // The base, start and end are all in the same region.  No adjustment necessary.
578     if (baseRoot == startRoot &amp;&amp; baseRoot == endRoot)
579         return;
580 
581     // The selection is based in editable content.
582     if (baseRoot) {
583         // If the start is outside the base&#39;s editable root, cap it at the start of that root.
584         // If the start is in non-editable content that is inside the base&#39;s editable root, put it
585         // at the first editable position after start inside the base&#39;s editable root.
586         if (startRoot != baseRoot) {
587             VisiblePosition first = firstEditablePositionAfterPositionInRoot(m_start, baseRoot);
588             m_start = first.deepEquivalent();
589             if (m_start.isNull()) {
590                 ASSERT_NOT_REACHED();
591                 m_start = m_end;
592             }
593         }
594         // If the end is outside the base&#39;s editable root, cap it at the end of that root.
595         // If the end is in non-editable content that is inside the base&#39;s root, put it
596         // at the last editable position before the end inside the base&#39;s root.
597         if (endRoot != baseRoot) {
598             VisiblePosition last = lastEditablePositionBeforePositionInRoot(m_end, baseRoot);
599             m_end = last.deepEquivalent();
600             if (m_end.isNull())
601                 m_end = m_start;
602         }
603     // The selection is based in non-editable content.
604     } else {
605         // FIXME: Non-editable pieces inside editable content should be atomic, in the same way that editable
606         // pieces in non-editable content are atomic.
607 
608         // The selection ends in editable content or non-editable content inside a different editable ancestor,
609         // move backward until non-editable content inside the same lowest editable ancestor is reached.
610         auto* endEditableAncestor = lowestEditableAncestor(m_end.containerNode());
611         if (endRoot || endEditableAncestor != baseEditableAncestor) {
612 
613             Position p = previousVisuallyDistinctCandidate(m_end);
614             Node* shadowAncestor = endRoot ? endRoot-&gt;shadowHost() : 0;
615             if (p.isNull() &amp;&amp; shadowAncestor)
616                 p = positionAfterNode(shadowAncestor);
617             while (p.isNotNull() &amp;&amp; !(lowestEditableAncestor(p.containerNode()) == baseEditableAncestor &amp;&amp; !isEditablePosition(p))) {
618                 Node* root = editableRootForPosition(p);
619                 shadowAncestor = root ? root-&gt;shadowHost() : 0;
620                 p = isAtomicNode(p.containerNode()) ? positionInParentBeforeNode(p.containerNode()) : previousVisuallyDistinctCandidate(p);
621                 if (p.isNull() &amp;&amp; shadowAncestor)
622                     p = positionAfterNode(shadowAncestor);
623             }
624             VisiblePosition previous(p);
625 
626             if (previous.isNull()) {
627                 // The selection crosses an Editing boundary.  This is a
628                 // programmer error in the editing code.  Happy debugging!
629                 ASSERT_NOT_REACHED();
630                 m_base = Position();
631                 m_extent = Position();
632                 validate();
633                 return;
634             }
635             m_end = previous.deepEquivalent();
636         }
637 
638         // The selection starts in editable content or non-editable content inside a different editable ancestor,
639         // move forward until non-editable content inside the same lowest editable ancestor is reached.
640         auto* startEditableAncestor = lowestEditableAncestor(m_start.containerNode());
641         if (startRoot || startEditableAncestor != baseEditableAncestor) {
642             Position p = nextVisuallyDistinctCandidate(m_start);
643             Node* shadowAncestor = startRoot ? startRoot-&gt;shadowHost() : 0;
644             if (p.isNull() &amp;&amp; shadowAncestor)
645                 p = positionBeforeNode(shadowAncestor);
646             while (p.isNotNull() &amp;&amp; !(lowestEditableAncestor(p.containerNode()) == baseEditableAncestor &amp;&amp; !isEditablePosition(p))) {
647                 Node* root = editableRootForPosition(p);
648                 shadowAncestor = root ? root-&gt;shadowHost() : 0;
649                 p = isAtomicNode(p.containerNode()) ? positionInParentAfterNode(p.containerNode()) : nextVisuallyDistinctCandidate(p);
650                 if (p.isNull() &amp;&amp; shadowAncestor)
651                     p = positionBeforeNode(shadowAncestor);
652             }
653             VisiblePosition next(p);
654 
655             if (next.isNull()) {
656                 // The selection crosses an Editing boundary.  This is a
657                 // programmer error in the editing code.  Happy debugging!
658                 ASSERT_NOT_REACHED();
659                 m_base = Position();
660                 m_extent = Position();
661                 validate();
662                 return;
663             }
664             m_start = next.deepEquivalent();
665         }
666     }
667 
668     // Correct the extent if necessary.
669     if (baseEditableAncestor != lowestEditableAncestor(m_extent.containerNode()))
670         m_extent = m_baseIsFirst ? m_end : m_start;
671 }
672 
673 bool VisibleSelection::isContentEditable() const
674 {
675     return isEditablePosition(start());
676 }
677 
678 bool VisibleSelection::hasEditableStyle() const
679 {
680     if (Node* containerNode = start().containerNode())
681         return containerNode-&gt;hasEditableStyle();
682     return false;
683 }
684 
685 bool VisibleSelection::isContentRichlyEditable() const
686 {
687     return isRichlyEditablePosition(start());
688 }
689 
690 Element* VisibleSelection::rootEditableElement() const
691 {
692     return editableRootForPosition(start());
693 }
694 
695 Node* VisibleSelection::nonBoundaryShadowTreeRootNode() const
696 {
697     return start().deprecatedNode() ? start().deprecatedNode()-&gt;nonBoundaryShadowTreeRootNode() : nullptr;
698 }
699 
700 bool VisibleSelection::isInPasswordField() const
701 {
702     HTMLTextFormControlElement* textControl = enclosingTextFormControl(start());
703     return is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*textControl).isPasswordField();
704 }
705 
706 #if ENABLE(TREE_DEBUGGING)
707 
708 void VisibleSelection::debugPosition() const
709 {
710     fprintf(stderr, &quot;VisibleSelection ===============\n&quot;);
711 
712     if (!m_start.anchorNode())
713         fputs(&quot;pos:   null&quot;, stderr);
714     else if (m_start == m_end) {
715         fprintf(stderr, &quot;pos:   %s &quot;, m_start.anchorNode()-&gt;nodeName().utf8().data());
716         m_start.showAnchorTypeAndOffset();
717     } else {
718         fprintf(stderr, &quot;start: %s &quot;, m_start.anchorNode()-&gt;nodeName().utf8().data());
719         m_start.showAnchorTypeAndOffset();
720         fprintf(stderr, &quot;end:   %s &quot;, m_end.anchorNode()-&gt;nodeName().utf8().data());
721         m_end.showAnchorTypeAndOffset();
722     }
723 
724     fprintf(stderr, &quot;================================\n&quot;);
725 }
726 
727 void VisibleSelection::formatForDebugger(char* buffer, unsigned length) const
728 {
729     StringBuilder result;
730     String s;
731 
732     if (isNone()) {
733         result.appendLiteral(&quot;&lt;none&gt;&quot;);
734     } else {
735         const int FormatBufferSize = 1024;
736         char s[FormatBufferSize];
737         result.appendLiteral(&quot;from &quot;);
738         start().formatForDebugger(s, FormatBufferSize);
739         result.append(s);
740         result.appendLiteral(&quot; to &quot;);
741         end().formatForDebugger(s, FormatBufferSize);
742         result.append(s);
743     }
744 
745     strncpy(buffer, result.toString().utf8().data(), length - 1);
746 }
747 
748 void VisibleSelection::showTreeForThis() const
749 {
750     if (start().anchorNode()) {
751         start().anchorNode()-&gt;showTreeAndMark(start().anchorNode(), &quot;S&quot;, end().anchorNode(), &quot;E&quot;);
752         fputs(&quot;start: &quot;, stderr);
753         start().showAnchorTypeAndOffset();
754         fputs(&quot;end: &quot;, stderr);
755         end().showAnchorTypeAndOffset();
756     }
757 }
758 
759 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const VisibleSelection&amp; v)
760 {
761     TextStream::GroupScope scope(stream);
762     stream &lt;&lt; &quot;VisibleSelection &quot; &lt;&lt; &amp;v;
763 
764     stream.dumpProperty(&quot;base&quot;, v.base());
765     stream.dumpProperty(&quot;extent&quot;, v.extent());
766     stream.dumpProperty(&quot;start&quot;, v.start());
767     stream.dumpProperty(&quot;end&quot;, v.end());
768 
769     return stream;
770 }
771 
772 #endif
773 
774 } // namespace WebCore
775 
776 #if ENABLE(TREE_DEBUGGING)
777 
778 void showTree(const WebCore::VisibleSelection&amp; sel)
779 {
780     sel.showTreeForThis();
781 }
782 
783 void showTree(const WebCore::VisibleSelection* sel)
784 {
785     if (sel)
786         sel-&gt;showTreeForThis();
787 }
788 
789 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
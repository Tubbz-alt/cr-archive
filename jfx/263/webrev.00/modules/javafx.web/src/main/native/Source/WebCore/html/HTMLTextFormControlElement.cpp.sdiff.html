<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTextAreaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTextFormControlElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48 #include &quot;ScriptDisallowedScope.h&quot;
 49 #include &quot;ShadowRoot.h&quot;
 50 #include &quot;Text.h&quot;
 51 #include &quot;TextControlInnerElements.h&quot;
 52 #include &lt;wtf/IsoMallocInlines.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLTextFormControlElement);
 58 
 59 using namespace HTMLNames;
 60 
 61 static Position positionForIndex(TextControlInnerTextElement*, unsigned);
 62 
 63 HTMLTextFormControlElement::HTMLTextFormControlElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 64     : HTMLFormControlElementWithState(tagName, document, form)
 65     , m_cachedSelectionDirection(SelectionHasNoDirection)
 66     , m_lastChangeWasUserEdit(false)
 67     , m_isPlaceholderVisible(false)

 68     , m_cachedSelectionStart(-1)
 69     , m_cachedSelectionEnd(-1)
 70 {
 71 }
 72 
 73 HTMLTextFormControlElement::~HTMLTextFormControlElement() = default;
 74 
 75 bool HTMLTextFormControlElement::childShouldCreateRenderer(const Node&amp; child) const
 76 {
 77     // FIXME: We shouldn&#39;t force the pseudo elements down into the shadow, but
 78     // this perserves the current behavior of WebKit.
 79     if (child.isPseudoElement())
 80         return HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 81     return hasShadowRootParent(child) &amp;&amp; HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 82 }
 83 
 84 Node::InsertedIntoAncestorResult HTMLTextFormControlElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 85 {
 86     InsertedIntoAncestorResult InsertedIntoAncestorResult = HTMLFormControlElementWithState::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 87     if (insertionType.connectedToDocument) {
</pre>
<hr />
<pre>
141         UChar character = attributeValue[i];
142         if (character == newlineCharacter || character == carriageReturn)
143             continue;
144         stripped.append(character);
145     }
146     return stripped.toString();
147 }
148 
149 static bool isNotLineBreak(UChar ch) { return ch != newlineCharacter &amp;&amp; ch != carriageReturn; }
150 
151 bool HTMLTextFormControlElement::isPlaceholderEmpty() const
152 {
153     const AtomString&amp; attributeValue = attributeWithoutSynchronization(placeholderAttr);
154     return attributeValue.string().find(isNotLineBreak) == notFound;
155 }
156 
157 bool HTMLTextFormControlElement::placeholderShouldBeVisible() const
158 {
159     // This function is used by the style resolver to match the :placeholder-shown pseudo class.
160     // Since it is used for styling, it must not use any value depending on the style.
<span class="line-modified">161     return supportsPlaceholder() &amp;&amp; isEmptyValue() &amp;&amp; !isPlaceholderEmpty();</span>
162 }
163 
164 void HTMLTextFormControlElement::updatePlaceholderVisibility()
165 {
166     bool placeHolderWasVisible = m_isPlaceholderVisible;
167     m_isPlaceholderVisible = placeholderShouldBeVisible();
168 
169     if (placeHolderWasVisible == m_isPlaceholderVisible)
170         return;
171 
172     invalidateStyleForSubtree();
173 }
174 






175 void HTMLTextFormControlElement::setSelectionStart(int start)
176 {
177     setSelectionRange(start, std::max(start, selectionEnd()), selectionDirection());
178 }
179 
180 void HTMLTextFormControlElement::setSelectionEnd(int end)
181 {
182     setSelectionRange(std::min(end, selectionStart()), end, selectionDirection());
183 }
184 
185 void HTMLTextFormControlElement::setSelectionDirection(const String&amp; direction)
186 {
187     setSelectionRange(selectionStart(), selectionEnd(), direction);
188 }
189 
190 void HTMLTextFormControlElement::select(SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
191 {
192     setSelectionRange(0, std::numeric_limits&lt;int&gt;::max(), SelectionHasNoDirection, revealMode, intent);
193 }
194 
</pre>
<hr />
<pre>
272     TextFieldSelectionDirection direction = SelectionHasNoDirection;
273     if (directionString == &quot;forward&quot;)
274         direction = SelectionHasForwardDirection;
275     else if (directionString == &quot;backward&quot;)
276         direction = SelectionHasBackwardDirection;
277 
278     return setSelectionRange(start, end, direction, SelectionRevealMode::DoNotReveal, intent);
279 }
280 
281 void HTMLTextFormControlElement::setSelectionRange(int start, int end, TextFieldSelectionDirection direction, SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
282 {
283     if (!isTextField())
284         return;
285 
286     end = std::max(end, 0);
287     start = std::min(std::max(start, 0), end);
288 
289     auto innerText = innerTextElement();
290     bool hasFocus = document().focusedElement() == this;
291     if (!hasFocus &amp;&amp; innerText) {





292         // FIXME: Removing this synchronous layout requires fixing setSelectionWithoutUpdatingAppearance not needing up-to-date style.
293         document().updateLayoutIgnorePendingStylesheets();
294 



295         // Double-check the state of innerTextElement after the layout.
296         innerText = innerTextElement();
297         auto* rendererTextControl = renderer();
298 
299         if (innerText &amp;&amp; rendererTextControl) {
300             if (rendererTextControl-&gt;style().visibility() == Visibility::Hidden || !innerText-&gt;renderBox() || !innerText-&gt;renderBox()-&gt;height()) {
301                 cacheSelection(start, end, direction);
302                 return;
303             }
304         }
305     }
306 
307     Position startPosition = positionForIndex(innerText.get(), start);
308     Position endPosition;
309     if (start == end)
310         endPosition = startPosition;
311     else {
312         if (direction == SelectionHasBackwardDirection) {
313             endPosition = startPosition;
314             startPosition = positionForIndex(innerText.get(), end);
</pre>
<hr />
<pre>
626     unsigned index = 0;
627     RefPtr&lt;Node&gt; startNode = passedPosition.computeNodeBeforePosition();
628     if (!startNode)
629         startNode = passedPosition.containerNode();
630     ASSERT(startNode);
631     ASSERT(innerText-&gt;contains(startNode.get()));
632 
633     for (RefPtr&lt;Node&gt; node = startNode; node; node = NodeTraversal::previous(*node, innerText.get())) {
634         if (is&lt;Text&gt;(*node)) {
635             unsigned length = downcast&lt;Text&gt;(*node).length();
636             if (node == passedPosition.containerNode())
637                 index += std::min&lt;unsigned&gt;(length, passedPosition.offsetInContainerNode());
638             else
639                 index += length;
640         } else if (is&lt;HTMLBRElement&gt;(*node))
641             ++index;
642     }
643 
644     unsigned length = innerTextValue().length();
645     index = std::min(index, length); // FIXME: We shouldn&#39;t have to call innerTextValue() just to ignore the last LF. See finishText.
<span class="line-modified">646 #ifndef ASSERT_DISABLED</span>



647     VisiblePosition visiblePosition = passedPosition;
648     unsigned indexComputedByVisiblePosition = 0;
649     if (visiblePosition.isNotNull())
650         indexComputedByVisiblePosition = WebCore::indexForVisiblePosition(innerText, visiblePosition, false /* forSelectionPreservation */);
651     ASSERT(index == indexComputedByVisiblePosition);

652 #endif
653     return index;
654 }
655 
656 #if PLATFORM(IOS_FAMILY)
657 void HTMLTextFormControlElement::hidePlaceholder()
658 {
659     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
660         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueHidden, true);
661 }
662 
663 void HTMLTextFormControlElement::showPlaceholderIfNecessary()
664 {
665     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
666         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueVisible, true);
667 }
668 #endif
669 
670 static void getNextSoftBreak(RootInlineBox*&amp; line, Node*&amp; breakNode, unsigned&amp; breakOffset)
671 {
</pre>
</td>
<td>
<hr />
<pre>
 48 #include &quot;ScriptDisallowedScope.h&quot;
 49 #include &quot;ShadowRoot.h&quot;
 50 #include &quot;Text.h&quot;
 51 #include &quot;TextControlInnerElements.h&quot;
 52 #include &lt;wtf/IsoMallocInlines.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLTextFormControlElement);
 58 
 59 using namespace HTMLNames;
 60 
 61 static Position positionForIndex(TextControlInnerTextElement*, unsigned);
 62 
 63 HTMLTextFormControlElement::HTMLTextFormControlElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 64     : HTMLFormControlElementWithState(tagName, document, form)
 65     , m_cachedSelectionDirection(SelectionHasNoDirection)
 66     , m_lastChangeWasUserEdit(false)
 67     , m_isPlaceholderVisible(false)
<span class="line-added"> 68     , m_canShowPlaceholder(true)</span>
 69     , m_cachedSelectionStart(-1)
 70     , m_cachedSelectionEnd(-1)
 71 {
 72 }
 73 
 74 HTMLTextFormControlElement::~HTMLTextFormControlElement() = default;
 75 
 76 bool HTMLTextFormControlElement::childShouldCreateRenderer(const Node&amp; child) const
 77 {
 78     // FIXME: We shouldn&#39;t force the pseudo elements down into the shadow, but
 79     // this perserves the current behavior of WebKit.
 80     if (child.isPseudoElement())
 81         return HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 82     return hasShadowRootParent(child) &amp;&amp; HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 83 }
 84 
 85 Node::InsertedIntoAncestorResult HTMLTextFormControlElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 86 {
 87     InsertedIntoAncestorResult InsertedIntoAncestorResult = HTMLFormControlElementWithState::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 88     if (insertionType.connectedToDocument) {
</pre>
<hr />
<pre>
142         UChar character = attributeValue[i];
143         if (character == newlineCharacter || character == carriageReturn)
144             continue;
145         stripped.append(character);
146     }
147     return stripped.toString();
148 }
149 
150 static bool isNotLineBreak(UChar ch) { return ch != newlineCharacter &amp;&amp; ch != carriageReturn; }
151 
152 bool HTMLTextFormControlElement::isPlaceholderEmpty() const
153 {
154     const AtomString&amp; attributeValue = attributeWithoutSynchronization(placeholderAttr);
155     return attributeValue.string().find(isNotLineBreak) == notFound;
156 }
157 
158 bool HTMLTextFormControlElement::placeholderShouldBeVisible() const
159 {
160     // This function is used by the style resolver to match the :placeholder-shown pseudo class.
161     // Since it is used for styling, it must not use any value depending on the style.
<span class="line-modified">162     return supportsPlaceholder() &amp;&amp; isEmptyValue() &amp;&amp; !isPlaceholderEmpty() &amp;&amp; m_canShowPlaceholder;</span>
163 }
164 
165 void HTMLTextFormControlElement::updatePlaceholderVisibility()
166 {
167     bool placeHolderWasVisible = m_isPlaceholderVisible;
168     m_isPlaceholderVisible = placeholderShouldBeVisible();
169 
170     if (placeHolderWasVisible == m_isPlaceholderVisible)
171         return;
172 
173     invalidateStyleForSubtree();
174 }
175 
<span class="line-added">176 void HTMLTextFormControlElement::setCanShowPlaceholder(bool canShowPlaceholder)</span>
<span class="line-added">177 {</span>
<span class="line-added">178     m_canShowPlaceholder = canShowPlaceholder;</span>
<span class="line-added">179     updatePlaceholderVisibility();</span>
<span class="line-added">180 }</span>
<span class="line-added">181 </span>
182 void HTMLTextFormControlElement::setSelectionStart(int start)
183 {
184     setSelectionRange(start, std::max(start, selectionEnd()), selectionDirection());
185 }
186 
187 void HTMLTextFormControlElement::setSelectionEnd(int end)
188 {
189     setSelectionRange(std::min(end, selectionStart()), end, selectionDirection());
190 }
191 
192 void HTMLTextFormControlElement::setSelectionDirection(const String&amp; direction)
193 {
194     setSelectionRange(selectionStart(), selectionEnd(), direction);
195 }
196 
197 void HTMLTextFormControlElement::select(SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
198 {
199     setSelectionRange(0, std::numeric_limits&lt;int&gt;::max(), SelectionHasNoDirection, revealMode, intent);
200 }
201 
</pre>
<hr />
<pre>
279     TextFieldSelectionDirection direction = SelectionHasNoDirection;
280     if (directionString == &quot;forward&quot;)
281         direction = SelectionHasForwardDirection;
282     else if (directionString == &quot;backward&quot;)
283         direction = SelectionHasBackwardDirection;
284 
285     return setSelectionRange(start, end, direction, SelectionRevealMode::DoNotReveal, intent);
286 }
287 
288 void HTMLTextFormControlElement::setSelectionRange(int start, int end, TextFieldSelectionDirection direction, SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
289 {
290     if (!isTextField())
291         return;
292 
293     end = std::max(end, 0);
294     start = std::min(std::max(start, 0), end);
295 
296     auto innerText = innerTextElement();
297     bool hasFocus = document().focusedElement() == this;
298     if (!hasFocus &amp;&amp; innerText) {
<span class="line-added">299         if (!isConnected()) {</span>
<span class="line-added">300             cacheSelection(start, end, direction);</span>
<span class="line-added">301             return;</span>
<span class="line-added">302         }</span>
<span class="line-added">303 </span>
304         // FIXME: Removing this synchronous layout requires fixing setSelectionWithoutUpdatingAppearance not needing up-to-date style.
305         document().updateLayoutIgnorePendingStylesheets();
306 
<span class="line-added">307         if (!isTextField())</span>
<span class="line-added">308             return;</span>
<span class="line-added">309 </span>
310         // Double-check the state of innerTextElement after the layout.
311         innerText = innerTextElement();
312         auto* rendererTextControl = renderer();
313 
314         if (innerText &amp;&amp; rendererTextControl) {
315             if (rendererTextControl-&gt;style().visibility() == Visibility::Hidden || !innerText-&gt;renderBox() || !innerText-&gt;renderBox()-&gt;height()) {
316                 cacheSelection(start, end, direction);
317                 return;
318             }
319         }
320     }
321 
322     Position startPosition = positionForIndex(innerText.get(), start);
323     Position endPosition;
324     if (start == end)
325         endPosition = startPosition;
326     else {
327         if (direction == SelectionHasBackwardDirection) {
328             endPosition = startPosition;
329             startPosition = positionForIndex(innerText.get(), end);
</pre>
<hr />
<pre>
641     unsigned index = 0;
642     RefPtr&lt;Node&gt; startNode = passedPosition.computeNodeBeforePosition();
643     if (!startNode)
644         startNode = passedPosition.containerNode();
645     ASSERT(startNode);
646     ASSERT(innerText-&gt;contains(startNode.get()));
647 
648     for (RefPtr&lt;Node&gt; node = startNode; node; node = NodeTraversal::previous(*node, innerText.get())) {
649         if (is&lt;Text&gt;(*node)) {
650             unsigned length = downcast&lt;Text&gt;(*node).length();
651             if (node == passedPosition.containerNode())
652                 index += std::min&lt;unsigned&gt;(length, passedPosition.offsetInContainerNode());
653             else
654                 index += length;
655         } else if (is&lt;HTMLBRElement&gt;(*node))
656             ++index;
657     }
658 
659     unsigned length = innerTextValue().length();
660     index = std::min(index, length); // FIXME: We shouldn&#39;t have to call innerTextValue() just to ignore the last LF. See finishText.
<span class="line-modified">661 #if 0</span>
<span class="line-added">662     // FIXME: This assertion code was never built, has bit rotted, and needs to be fixed before it can be enabled:</span>
<span class="line-added">663     // https://bugs.webkit.org/show_bug.cgi?id=205706.</span>
<span class="line-added">664 #if ASSERT_ENABLED</span>
665     VisiblePosition visiblePosition = passedPosition;
666     unsigned indexComputedByVisiblePosition = 0;
667     if (visiblePosition.isNotNull())
668         indexComputedByVisiblePosition = WebCore::indexForVisiblePosition(innerText, visiblePosition, false /* forSelectionPreservation */);
669     ASSERT(index == indexComputedByVisiblePosition);
<span class="line-added">670 #endif</span>
671 #endif
672     return index;
673 }
674 
675 #if PLATFORM(IOS_FAMILY)
676 void HTMLTextFormControlElement::hidePlaceholder()
677 {
678     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
679         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueHidden, true);
680 }
681 
682 void HTMLTextFormControlElement::showPlaceholderIfNecessary()
683 {
684     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
685         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueVisible, true);
686 }
687 #endif
688 
689 static void getNextSoftBreak(RootInlineBox*&amp; line, Node*&amp; breakNode, unsigned&amp; breakOffset)
690 {
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTextAreaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTextFormControlElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -30,16 +30,24 @@
 
 #include "FloatRect.h"
 #include "Logging.h"
 #include "MediaPlaybackTargetPickerMock.h"
 #include "WebMediaSessionManagerClient.h"
+#include <wtf/Algorithms.h>
+#include <wtf/Logger.h>
 #include <wtf/text/StringBuilder.h>
 
 namespace WebCore {
 
 static const Seconds taskDelayInterval { 100_ms };
 
+#undef LOGIDENTIFIER
+#define LOGIDENTIFIER __func__
+
+#undef ALWAYS_LOG
+#define ALWAYS_LOG logger().logAlways
+
 struct ClientState {
     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 
     explicit ClientState(WebMediaSessionManagerClient& client, uint64_t contextId)
         : client(client)
@@ -64,56 +72,113 @@
 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 {
     return value & flags;
 }
 
-#if !LOG_DISABLED
-static String mediaProducerStateString(MediaProducer::MediaStateFlags flags)
+String mediaProducerStateString(MediaProducer::MediaStateFlags flags)
 {
     StringBuilder string;
     if (flags & MediaProducer::IsPlayingAudio)
-        string.append("IsPlayingAudio + ");
+        string.append("IsPlayingAudio+");
     if (flags & MediaProducer::IsPlayingVideo)
-        string.append("IsPlayingVideo + ");
+        string.append("IsPlayingVideo+");
     if (flags & MediaProducer::IsPlayingToExternalDevice)
-        string.append("IsPlayingToExternalDevice + ");
+        string.append("IsPlayingToExternalDevice+");
     if (flags & MediaProducer::HasPlaybackTargetAvailabilityListener)
-        string.append("HasPlaybackTargetAvailabilityListener + ");
+        string.append("HasTargetAvailabilityListener+");
     if (flags & MediaProducer::RequiresPlaybackTargetMonitoring)
-        string.append("RequiresPlaybackTargetMonitoring + ");
+        string.append("RequiresTargetMonitoring+");
     if (flags & MediaProducer::ExternalDeviceAutoPlayCandidate)
-        string.append("ExternalDeviceAutoPlayCandidate + ");
+        string.append("ExternalDeviceAutoPlayCandidate+");
     if (flags & MediaProducer::DidPlayToEnd)
-        string.append("DidPlayToEnd + ");
+        string.append("DidPlayToEnd+");
     if (flags & MediaProducer::HasAudioOrVideo)
-        string.append("HasAudioOrVideo + ");
+        string.append("HasAudioOrVideo+");
     if (string.isEmpty())
         string.append("IsNotPlaying");
     else
-        string.resize(string.length() - 2);
+        string.resize(string.length() - 1);
 
-    return string.toString();
+    return makeString(" { ", string.toString(), " }");
 }
-#endif
 
-void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
+class WebMediaSessionLogger {
+    WTF_MAKE_NONCOPYABLE(WebMediaSessionLogger);
+    WTF_MAKE_FAST_ALLOCATED;
+public:
+
+    static std::unique_ptr<WebMediaSessionLogger> create(WebMediaSessionManager& manager)
+    {
+        return makeUnique<WebMediaSessionLogger>(manager);
+    }
+
+    template<typename... Arguments>
+    inline void logAlways(const char* methodName, ClientState* state, const Arguments&... arguments) const
+    {
+        if (!state->client.alwaysOnLoggingAllowed())
+            return;
+
+        m_logger->logAlways(LogMedia, makeString("WebMediaSessionManager::", methodName, ' '), state->contextId, state->flags, arguments...);
+    }
+
+    template<typename... Arguments>
+    inline void logAlways(const char* methodName, const Arguments&... arguments) const
+    {
+        if (!m_manager.alwaysOnLoggingAllowed())
+            return;
+
+        m_logger->logAlways(LogMedia, makeString("WebMediaSessionManager::", methodName, ' '), arguments...);
+    }
+
+private:
+    friend std::unique_ptr<WebMediaSessionLogger> std::make_unique<WebMediaSessionLogger>(WebMediaSessionManager&);
+    WebMediaSessionLogger(WebMediaSessionManager& manager)
+        : m_manager(manager)
+        , m_logger(Logger::create(this))
+    {
+    }
+
+    WebMediaSessionManager& m_manager;
+    Ref<Logger> m_logger;
+};
+
+WebMediaSessionLogger& WebMediaSessionManager::logger()
 {
-    LOG(Media, "WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled - enabled = %i", (int)enabled);
+    if (!m_logger)
+        m_logger = WebMediaSessionLogger::create(*this);
 
+    return *m_logger;
+}
+
+bool WebMediaSessionManager::alwaysOnLoggingAllowed() const
+{
+    return allOf(m_clientState, [] (auto& state) {
+        return state->client.alwaysOnLoggingAllowed();
+    });
+}
+
+void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
+{
     if (m_mockPickerEnabled == enabled)
         return;
 
+    ALWAYS_LOG(LOGIDENTIFIER);
     m_mockPickerEnabled = enabled;
 }
 
 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String& name, MediaPlaybackTargetContext::State state)
 {
-    LOG(Media, "WebMediaSessionManager::setMockMediaPlaybackTargetPickerState - name = %s, state = %i", name.utf8().data(), (int)state);
-
+    ALWAYS_LOG(LOGIDENTIFIER);
     mockPicker().setState(name, state);
 }
 
+void WebMediaSessionManager::mockMediaPlaybackTargetPickerDismissPopup()
+{
+    ALWAYS_LOG(LOGIDENTIFIER);
+    mockPicker().dismissPopup();
+}
+
 MediaPlaybackTargetPickerMock& WebMediaSessionManager::mockPicker()
 {
     if (!m_pickerOverride)
         m_pickerOverride = makeUnique<MediaPlaybackTargetPickerMock>(*this);
 
@@ -141,12 +206,11 @@
     size_t index = find(&client, contextId);
     ASSERT(index == notFound);
     if (index != notFound)
         return 0;
 
-    LOG(Media, "WebMediaSessionManager::addPlaybackTargetPickerClient(%p + %llu)", &client, contextId);
-
+    ALWAYS_LOG(LOGIDENTIFIER, contextId);
     m_clientState.append(makeUnique<ClientState>(client, contextId));
 
     if (m_externalOutputDeviceAvailable || m_playbackTarget)
         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
 
@@ -158,26 +222,26 @@
     size_t index = find(&client, contextId);
     ASSERT(index != notFound);
     if (index == notFound)
         return;
 
-    LOG(Media, "WebMediaSessionManager::removePlaybackTargetPickerClient(%p + %llu)", &client, contextId);
+    ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());
 
     m_clientState.remove(index);
     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
 }
 
 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient& client)
 {
     if (m_clientState.isEmpty())
         return;
 
-    LOG(Media, "WebMediaSessionManager::removeAllPlaybackTargetPickerClients(%p)", &client);
-
     for (size_t i = m_clientState.size(); i > 0; --i) {
-        if (&m_clientState[i - 1]->client == &client)
+        if (&m_clientState[i - 1]->client == &client) {
+            ALWAYS_LOG(LOGIDENTIFIER, m_clientState[i - 1].get());
             m_clientState.remove(i - 1);
+        }
     }
     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
 }
 
 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient& client, uint64_t contextId, const IntRect& rect, bool, bool useDarkAppearance)
@@ -191,12 +255,13 @@
     for (auto& state : m_clientState) {
         state->requestedPicker = state == clientRequestingPicker;
         state->previouslyRequestedPicker = state == clientRequestingPicker;
     }
 
+    ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());
+
     bool hasActiveRoute = flagsAreSet(m_clientState[index]->flags, MediaProducer::IsPlayingToExternalDevice);
-    LOG(Media, "WebMediaSessionManager::showPlaybackTargetPicker(%p + %llu) - hasActiveRoute = %i", &client, contextId, (int)hasActiveRoute);
     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
 }
 
 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient& client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
 {
@@ -208,11 +273,11 @@
     auto& changedClientState = m_clientState[index];
     MediaProducer::MediaStateFlags oldFlags = changedClientState->flags;
     if (newFlags == oldFlags)
         return;
 
-    LOG(Media, "WebMediaSessionManager::clientStateDidChange(%p + %llu) - new flags = %s, old flags = %s", &client, contextId, mediaProducerStateString(newFlags).utf8().data(), mediaProducerStateString(oldFlags).utf8().data());
+    ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get(), "new flags = ", newFlags);
 
     changedClientState->flags = newFlags;
 
     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
     if ((oldFlags & updateConfigurationFlags) != (newFlags & updateConfigurationFlags))
@@ -231,46 +296,59 @@
     // Do not interrupt another element already playing to a device.
     for (auto& state : m_clientState) {
         if (state == changedClientState)
             continue;
 
-        if (flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice) && flagsAreSet(state->flags, MediaProducer::IsPlayingVideo))
+        if (flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice) && flagsAreSet(state->flags, MediaProducer::IsPlayingVideo)) {
+            ALWAYS_LOG(LOGIDENTIFIER, state.get(), " returning early");
             return;
+        }
     }
 
     // Do not begin playing to the device unless playback has just started.
-    if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo))
+    if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo)) {
+        ALWAYS_LOG(LOGIDENTIFIER, "returning early, playback didn't just start");
         return;
+    }
 
     for (auto& state : m_clientState) {
         if (state == changedClientState)
             continue;
+        ALWAYS_LOG(LOGIDENTIFIER, state.get(), " calling setShouldPlayToPlaybackTarget(false)");
         state->client.setShouldPlayToPlaybackTarget(state->contextId, false);
     }
 
+    ALWAYS_LOG(LOGIDENTIFIER, changedClientState.get(), " calling setShouldPlayToPlaybackTarget(true)");
     changedClientState->client.setShouldPlayToPlaybackTarget(changedClientState->contextId, true);
 
     if (index && m_clientState.size() > 1)
         std::swap(m_clientState.at(index), m_clientState.at(0));
 }
 
 void WebMediaSessionManager::setPlaybackTarget(Ref<MediaPlaybackTarget>&& target)
 {
+    ALWAYS_LOG(LOGIDENTIFIER, "has active route = ", target->hasActiveRoute());
     m_playbackTarget = WTFMove(target);
     m_targetChanged = true;
     scheduleDelayedTask(TargetClientsConfigurationTask);
 }
 
 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
 {
-    LOG(Media, "WebMediaSessionManager::externalOutputDeviceAvailableDidChange - clients = %zu, available = %i", m_clientState.size(), (int)available);
-
+    ALWAYS_LOG(LOGIDENTIFIER, available);
     m_externalOutputDeviceAvailable = available;
     for (auto& state : m_clientState)
         state->client.externalOutputDeviceAvailableDidChange(state->contextId, available);
 }
 
+void WebMediaSessionManager::playbackTargetPickerWasDismissed()
+{
+    ALWAYS_LOG(LOGIDENTIFIER);
+    m_playbackTargetPickerDismissed = true;
+    scheduleDelayedTask(TargetClientsConfigurationTask);
+}
+
 void WebMediaSessionManager::configureNewClients()
 {
     for (auto& state : m_clientState) {
         if (!state->configurationRequired)
             continue;
@@ -295,13 +373,13 @@
     bool haveActiveRoute = m_playbackTarget && m_playbackTarget->hasActiveRoute();
 
     for (size_t i = 0; i < m_clientState.size(); ++i) {
         auto& state = m_clientState[i];
 
-        LOG(Media, "WebMediaSessionManager::configurePlaybackTargetClients %zu - client (%p + %llu) requestedPicker = %i, flags = %s", i, &state->client, state->contextId, state->requestedPicker, mediaProducerStateString(state->flags).utf8().data());
+        ALWAYS_LOG(LOGIDENTIFIER, state.get(), ", requestedPicker = ", state->requestedPicker);
 
-        if (m_targetChanged && state->requestedPicker)
+        if ((m_targetChanged || m_playbackTargetPickerDismissed) && state->requestedPicker)
             indexOfClientThatRequestedPicker = i;
 
         if (indexOfClientWillPlayToTarget == notFound && flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice))
             indexOfClientWillPlayToTarget = i;
 
@@ -314,30 +392,37 @@
     if (indexOfClientWillPlayToTarget == notFound && indexOfLastClientToRequestPicker != notFound)
         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
     if (indexOfClientWillPlayToTarget == notFound && haveActiveRoute && flagsAreSet(m_clientState[0]->flags, MediaProducer::ExternalDeviceAutoPlayCandidate) && !flagsAreSet(m_clientState[0]->flags, MediaProducer::IsPlayingVideo))
         indexOfClientWillPlayToTarget = 0;
 
-    LOG(Media, "WebMediaSessionManager::configurePlaybackTargetClients - indexOfClientWillPlayToTarget = %zu", indexOfClientWillPlayToTarget);
-
     for (size_t i = 0; i < m_clientState.size(); ++i) {
         auto& state = m_clientState[i];
 
         if (m_playbackTarget)
             state->client.setPlaybackTarget(state->contextId, *m_playbackTarget.copyRef());
 
-        if (i != indexOfClientWillPlayToTarget || !haveActiveRoute)
+        if (i != indexOfClientWillPlayToTarget || !haveActiveRoute) {
+            ALWAYS_LOG(LOGIDENTIFIER, state.get(), " calling setShouldPlayToPlaybackTarget(false)");
             state->client.setShouldPlayToPlaybackTarget(state->contextId, false);
+        }
+
+        if (state->requestedPicker && m_playbackTargetPickerDismissed) {
+            ALWAYS_LOG(LOGIDENTIFIER, state.get(), " calling playbackTargetPickerWasDismissed");
+            state->client.playbackTargetPickerWasDismissed(state->contextId);
+        }
 
         state->configurationRequired = false;
-        if (m_targetChanged)
+        if (m_targetChanged || m_playbackTargetPickerDismissed)
             state->requestedPicker = false;
     }
 
     if (haveActiveRoute && indexOfClientWillPlayToTarget != notFound) {
         auto& state = m_clientState[indexOfClientWillPlayToTarget];
-        if (!flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice))
+        if (!flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice)) {
+            ALWAYS_LOG(LOGIDENTIFIER, state.get(), " calling setShouldPlayToPlaybackTarget(true)");
             state->client.setShouldPlayToPlaybackTarget(state->contextId, true);
+        }
     }
 
     m_targetChanged = false;
     configureWatchdogTimer();
 }
@@ -346,61 +431,38 @@
 {
     bool monitoringRequired = false;
     bool hasAvailabilityListener = false;
     bool haveClientWithMedia = false;
     for (auto& state : m_clientState) {
+        ALWAYS_LOG(LOGIDENTIFIER, state.get());
         if (state->flags & MediaProducer::RequiresPlaybackTargetMonitoring) {
             monitoringRequired = true;
             break;
         }
         if (state->flags & MediaProducer::HasPlaybackTargetAvailabilityListener)
             hasAvailabilityListener = true;
         if (state->flags & MediaProducer::HasAudioOrVideo)
             haveClientWithMedia = true;
     }
 
-    LOG(Media, "WebMediaSessionManager::configurePlaybackTargetMonitoring - monitoringRequired = %i", static_cast<int>(monitoringRequired || (hasAvailabilityListener && haveClientWithMedia)));
-
-    if (monitoringRequired || (hasAvailabilityListener && haveClientWithMedia))
+    if (monitoringRequired || (hasAvailabilityListener && haveClientWithMedia)) {
+        ALWAYS_LOG(LOGIDENTIFIER, "starting monitoring");
         targetPicker().startingMonitoringPlaybackTargets();
-    else
+    } else {
+        ALWAYS_LOG(LOGIDENTIFIER, "stopping monitoring");
         targetPicker().stopMonitoringPlaybackTargets();
+    }
 }
 
-#if !LOG_DISABLED
-String WebMediaSessionManager::toString(ConfigurationTasks tasks)
-{
-    StringBuilder string;
-    if (tasks & InitialConfigurationTask)
-        string.append("InitialConfigurationTask + ");
-    if (tasks & TargetClientsConfigurationTask)
-        string.append("TargetClientsConfigurationTask + ");
-    if (tasks & TargetMonitoringConfigurationTask)
-        string.append("TargetMonitoringConfigurationTask + ");
-    if (tasks & WatchdogTimerConfigurationTask)
-        string.append("WatchdogTimerConfigurationTask + ");
-    if (string.isEmpty())
-        string.append("NoTask");
-    else
-        string.resize(string.length() - 2);
-
-    return string.toString();
-}
-#endif
-
 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
 {
-    LOG(Media, "WebMediaSessionManager::scheduleDelayedTask - %s", toString(tasks).utf8().data());
-
     m_taskFlags |= tasks;
     m_taskTimer.startOneShot(taskDelayInterval);
 }
 
 void WebMediaSessionManager::taskTimerFired()
 {
-    LOG(Media, "WebMediaSessionManager::taskTimerFired - tasks = %s", toString(m_taskFlags).utf8().data());
-
     if (m_taskFlags & InitialConfigurationTask)
         configureNewClients();
     if (m_taskFlags & TargetClientsConfigurationTask)
         configurePlaybackTargetClients();
     if (m_taskFlags & TargetMonitoringConfigurationTask)
@@ -425,44 +487,52 @@
 {
     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
 
     if (!m_playbackTarget || !m_playbackTarget->hasActiveRoute()) {
-        m_watchdogTimer.stop();
+        if (m_watchdogTimer.isActive()) {
+            ALWAYS_LOG(LOGIDENTIFIER, "stopping timer");
+            m_currentWatchdogInterval = { };
+            m_watchdogTimer.stop();
+        }
+
         return;
     }
 
     bool stopTimer = false;
     bool didPlayToEnd = false;
     for (auto& state : m_clientState) {
+
+        ALWAYS_LOG(LOGIDENTIFIER, state.get(), " playedToEnd = ", state->playedToEnd);
+
         if (flagsAreSet(state->flags, MediaProducer::IsPlayingToExternalDevice) && flagsAreSet(state->flags, MediaProducer::IsPlayingVideo))
             stopTimer = true;
         if (state->playedToEnd)
             didPlayToEnd = true;
         state->playedToEnd = false;
     }
 
     if (stopTimer) {
+        ALWAYS_LOG(LOGIDENTIFIER, "stopping timer");
         m_currentWatchdogInterval = { };
         m_watchdogTimer.stop();
-        LOG(Media, "WebMediaSessionManager::configureWatchdogTimer - timer stopped");
     } else {
         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
             m_watchdogTimer.startOneShot(interval);
-            LOG(Media, "WebMediaSessionManager::configureWatchdogTimer - timer scheduled for %.0f seconds", interval.value());
         }
+        ALWAYS_LOG(LOGIDENTIFIER, "timer scheduled for ", interval.value(), " seconds");
         m_currentWatchdogInterval = interval;
     }
 }
 
 void WebMediaSessionManager::watchdogTimerFired()
 {
-    LOG(Media, "WebMediaSessionManager::watchdogTimerFired");
     if (!m_playbackTarget)
         return;
 
+    ALWAYS_LOG(LOGIDENTIFIER);
     targetPicker().invalidatePlaybackTargets();
 }
 
 } // namespace WebCore
 

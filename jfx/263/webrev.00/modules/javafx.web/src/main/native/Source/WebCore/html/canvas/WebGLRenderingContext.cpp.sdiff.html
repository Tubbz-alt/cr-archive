<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderbuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLRenderingContext.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;ANGLEInstancedArrays.h&quot;
 32 #include &quot;CachedImage.h&quot;
 33 #include &quot;EXTBlendMinMax.h&quot;
 34 #include &quot;EXTFragDepth.h&quot;
 35 #include &quot;EXTShaderTextureLOD.h&quot;
 36 #include &quot;EXTTextureFilterAnisotropic.h&quot;
 37 #include &quot;EXTsRGB.h&quot;
<span class="line-modified"> 38 #include &quot;Extensions3D.h&quot;</span>
 39 #include &quot;HTMLCanvasElement.h&quot;
 40 #include &quot;HTMLImageElement.h&quot;
 41 #include &quot;HTMLVideoElement.h&quot;
 42 #include &quot;ImageData.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;OESElementIndexUint.h&quot;
 45 #include &quot;OESStandardDerivatives.h&quot;
 46 #include &quot;OESTextureFloat.h&quot;
 47 #include &quot;OESTextureFloatLinear.h&quot;
 48 #include &quot;OESTextureHalfFloat.h&quot;
 49 #include &quot;OESTextureHalfFloatLinear.h&quot;
 50 #include &quot;OESVertexArrayObject.h&quot;
 51 #include &quot;RenderBox.h&quot;
 52 #include &quot;WebGLCompressedTextureASTC.h&quot;
 53 #include &quot;WebGLCompressedTextureATC.h&quot;


 54 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
 55 #include &quot;WebGLCompressedTextureS3TC.h&quot;
 56 #include &quot;WebGLDebugRendererInfo.h&quot;
 57 #include &quot;WebGLDebugShaders.h&quot;
 58 #include &quot;WebGLDepthTexture.h&quot;
 59 #include &quot;WebGLDrawBuffers.h&quot;
 60 #include &quot;WebGLLoseContext.h&quot;
 61 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 62 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
 63 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 64 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 65 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 66 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
 67 #include &lt;wtf/IsoMallocInlines.h&gt;
 68 
 69 namespace WebCore {
 70 
 71 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContext);
 72 
<span class="line-modified"> 73 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
 74 {
 75     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
 76 
 77     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 78 
 79     return renderingContext;
 80 }
 81 
<span class="line-modified"> 82 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
 83 {
 84     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
 85 
 86     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 87 
 88     return renderingContext;
 89 }
 90 
<span class="line-modified"> 91 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContext3DAttributes attributes)</span>
 92     : WebGLRenderingContextBase(canvas, attributes)
 93 {
 94 }
 95 
<span class="line-modified"> 96 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, GraphicsContext3DAttributes attributes)</span>
 97     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
 98 {
 99     initializeVertexArrayObjects();
100 }
101 
102 void WebGLRenderingContext::initializeVertexArrayObjects()
103 {
104     m_defaultVertexArrayObject = WebGLVertexArrayObjectOES::create(*this, WebGLVertexArrayObjectOES::Type::Default);
105     addContextObject(*m_defaultVertexArrayObject);
106     m_boundVertexArrayObject = m_defaultVertexArrayObject;
107     if (!isGLES2Compliant())
108         initVertexAttrib0();
109 }
110 
111 WebGLExtension* WebGLRenderingContext::getExtension(const String&amp; name)
112 {
113     if (isContextLostOrPending())
114         return nullptr;
115 
116 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
</pre>
<hr />
<pre>
122         } \
123         return variable.get(); \
124     }
125 
126     ENABLE_IF_REQUESTED(EXTBlendMinMax, m_extBlendMinMax, &quot;EXT_blend_minmax&quot;, enableSupportedExtension(&quot;GL_EXT_blend_minmax&quot;_s));
127     ENABLE_IF_REQUESTED(EXTsRGB, m_extsRGB, &quot;EXT_sRGB&quot;, enableSupportedExtension(&quot;GL_EXT_sRGB&quot;_s));
128     ENABLE_IF_REQUESTED(EXTFragDepth, m_extFragDepth, &quot;EXT_frag_depth&quot;, enableSupportedExtension(&quot;GL_EXT_frag_depth&quot;_s));
129     if (equalIgnoringASCIICase(name, &quot;EXT_shader_texture_lod&quot;)) {
130         if (!m_extShaderTextureLOD) {
131             if (!(m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s)))
132                 m_extShaderTextureLOD = nullptr;
133             else {
134                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;_s);
135                 m_extShaderTextureLOD = makeUnique&lt;EXTShaderTextureLOD&gt;(*this);
136                 InspectorInstrumentation::didEnableExtension(*this, name);
137             }
138         }
139         return m_extShaderTextureLOD.get();
140     }
141     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
<span class="line-removed">142     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;WEBKIT_EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));</span>
143     ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
144     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
145     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
146     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
147     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
148     ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
149     ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
150     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);

151     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));


152     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
153     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
<span class="line-removed">154     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
155     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
156     if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
157         if (!m_webglDrawBuffers) {
158             if (!supportsDrawBuffers())
159                 m_webglDrawBuffers = nullptr;
160             else {
161                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;_s);
162                 m_webglDrawBuffers = makeUnique&lt;WebGLDrawBuffers&gt;(*this);
163                 InspectorInstrumentation::didEnableExtension(*this, name);
164             }
165         }
166         return m_webglDrawBuffers.get();
167     }
168     if (equalIgnoringASCIICase(name, &quot;ANGLE_instanced_arrays&quot;)) {
169         if (!m_angleInstancedArrays) {
170             if (!ANGLEInstancedArrays::supported(*this))
171                 m_angleInstancedArrays = nullptr;
172             else {
173                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_ANGLE_instanced_arrays&quot;_s);
174                 m_angleInstancedArrays = makeUnique&lt;ANGLEInstancedArrays&gt;(*this);
</pre>
<hr />
<pre>
200         result.append(&quot;EXT_frag_depth&quot;_s);
201     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float&quot;_s))
202         result.append(&quot;OES_texture_float&quot;_s);
203     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float_linear&quot;_s))
204         result.append(&quot;OES_texture_float_linear&quot;_s);
205     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float&quot;_s))
206         result.append(&quot;OES_texture_half_float&quot;_s);
207     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
208         result.append(&quot;OES_texture_half_float_linear&quot;_s);
209     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_standard_derivatives&quot;_s))
210         result.append(&quot;OES_standard_derivatives&quot;_s);
211     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s))
212         result.append(&quot;EXT_shader_texture_lod&quot;_s);
213     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
214         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);
215     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
216         result.append(&quot;OES_vertex_array_object&quot;_s);
217     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
218         result.append(&quot;OES_element_index_uint&quot;_s);
219     result.append(&quot;WEBGL_lose_context&quot;_s);


220     if (WebGLCompressedTextureATC::supported(*this))
221         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);




222     if (WebGLCompressedTexturePVRTC::supported(*this))
223         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
224     if (WebGLCompressedTextureS3TC::supported(*this))
225         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
<span class="line-removed">226     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-removed">227         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
228     if (WebGLDepthTexture::supported(*m_context))
229         result.append(&quot;WEBGL_depth_texture&quot;_s);
230     if (supportsDrawBuffers())
231         result.append(&quot;WEBGL_draw_buffers&quot;_s);
232     if (ANGLEInstancedArrays::supported(*this))
233         result.append(&quot;ANGLE_instanced_arrays&quot;_s);
234     if (m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
235         result.append(&quot;WEBGL_debug_shaders&quot;_s);
236     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
237 
238     return result;
239 }
240 
<span class="line-modified">241 WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname)</span>
242 {
243     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
244         return nullptr;
245 
246     if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
<span class="line-modified">247         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);</span>
248         return nullptr;
249     }
250 
251     auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
252     if (!object) {
<span class="line-modified">253         if (pname == GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">254             return static_cast&lt;unsigned&gt;(GraphicsContext3D::NONE);</span>
255         // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
256         // specifies INVALID_OPERATION.
<span class="line-modified">257         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);</span>
258         return nullptr;
259     }
260 
261     if (object-&gt;isTexture()) {
262         switch (pname) {
<span class="line-modified">263         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">264             return static_cast&lt;unsigned&gt;(GraphicsContext3D::TEXTURE);</span>
<span class="line-modified">265         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
266             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">267         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">268         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">269         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
<span class="line-modified">270             GC3Dint value = 0;</span>
271             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
272             return value;
273         }
274         default:
<span class="line-modified">275             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);</span>
276             return nullptr;
277         }
278     } else {
279         ASSERT(object-&gt;isRenderbuffer());
280         switch (pname) {
<span class="line-modified">281         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">282             return static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER);</span>
<span class="line-modified">283         case GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
284             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">285         case Extensions3D::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
286             if (!m_extsRGB) {
<span class="line-modified">287                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
288                 return nullptr;
289             }
290             RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
<span class="line-modified">291             GC3Denum renderBufferFormat = renderBuffer-&gt;getInternalFormat();</span>
<span class="line-modified">292             ASSERT(renderBufferFormat != Extensions3D::SRGB_EXT &amp;&amp; renderBufferFormat != Extensions3D::SRGB_ALPHA_EXT);</span>
<span class="line-modified">293             if (renderBufferFormat == Extensions3D::SRGB8_ALPHA8_EXT)</span>
<span class="line-modified">294                 return static_cast&lt;unsigned&gt;(Extensions3D::SRGB_EXT);</span>
<span class="line-modified">295             return static_cast&lt;unsigned&gt;(GraphicsContext3D::LINEAR);</span>
296         }
297         default:
<span class="line-modified">298             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
299             return nullptr;
300         }
301     }
302 }
303 
<span class="line-modified">304 bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment)</span>
305 {
<span class="line-modified">306     if (target != GraphicsContext3D::FRAMEBUFFER) {</span>
<span class="line-modified">307         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
308         return false;
309     }
310     // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
311     // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
312     switch (attachment) {
<span class="line-modified">313     case GraphicsContext3D::COLOR_ATTACHMENT0:</span>
<span class="line-modified">314     case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">315     case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-modified">316     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
317         return true;
318     default:
319         if (m_webglDrawBuffers
<span class="line-modified">320             &amp;&amp; attachment &gt;= GraphicsContext3D::COLOR_ATTACHMENT0</span>
<span class="line-modified">321             &amp;&amp; attachment &lt; static_cast&lt;GC3Denum&gt;(GraphicsContext3D::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
322             return true;
<span class="line-modified">323         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
324         return false;
325     }
326 }
327 
<span class="line-modified">328 void WebGLRenderingContext::renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height)</span>
329 {
330     if (isContextLostOrPending())
331         return;
<span class="line-modified">332     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="line-modified">333         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
334         return;
335     }
336     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">337         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
338         return;
339     }
340     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
341         return;
342     switch (internalformat) {
<span class="line-modified">343     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="line-modified">344     case GraphicsContext3D::RGBA4:</span>
<span class="line-modified">345     case GraphicsContext3D::RGB5_A1:</span>
<span class="line-modified">346     case GraphicsContext3D::RGB565:</span>
<span class="line-modified">347     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="line-modified">348     case Extensions3D::SRGB8_ALPHA8_EXT:</span>
<span class="line-modified">349         if (internalformat == Extensions3D::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {</span>
<span class="line-modified">350             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
351             return;
352         }
353         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
354         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
355         m_renderbufferBinding-&gt;setIsValid(true);
356         m_renderbufferBinding-&gt;setSize(width, height);
357         break;
<span class="line-modified">358     case GraphicsContext3D::DEPTH_STENCIL:</span>
359         if (isDepthStencilSupported())
<span class="line-modified">360             m_context-&gt;renderbufferStorage(target, Extensions3D::DEPTH24_STENCIL8, width, height);</span>
361         m_renderbufferBinding-&gt;setSize(width, height);
362         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
363         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
364         break;
365     default:
<span class="line-modified">366         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
367         return;
368     }
369     applyStencilTest();
370 }
371 
<span class="line-modified">372 void WebGLRenderingContext::hint(GC3Denum target, GC3Denum mode)</span>
373 {
374     if (isContextLostOrPending())
375         return;
376     bool isValid = false;
377     switch (target) {
<span class="line-modified">378     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
379         isValid = true;
380         break;
<span class="line-modified">381     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
382         if (m_oesStandardDerivatives)
383             isValid = true;
384         break;
385     }
386     if (!isValid) {
<span class="line-modified">387         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
388         return;
389     }
390     m_context-&gt;hint(target, mode);
391 }
392 
<span class="line-modified">393 void WebGLRenderingContext::clear(GC3Dbitfield mask)</span>
394 {
395     if (isContextLostOrPending())
396         return;
<span class="line-modified">397     if (mask &amp; ~(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified">398         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
399         return;
400     }
401     const char* reason = &quot;framebuffer incomplete&quot;;
402     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
<span class="line-modified">403         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
404         return;
405     }
406     if (!clearIfComposited(mask))
407         m_context-&gt;clear(mask);
408     markContextChangedAndNotifyCanvasObserver();
409 }
410 
<span class="line-modified">411 WebGLAny WebGLRenderingContext::getParameter(GC3Denum pname)</span>
412 {
413     if (isContextLostOrPending())
414         return nullptr;
415 
416     switch (pname) {
<span class="line-modified">417     case GraphicsContext3D::ACTIVE_TEXTURE:</span>
418         return getUnsignedIntParameter(pname);
<span class="line-modified">419     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:</span>
420         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">421     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:</span>
422         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">423     case GraphicsContext3D::ALPHA_BITS:</span>
424         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
425             return 0;
426         return getIntParameter(pname);
<span class="line-modified">427     case GraphicsContext3D::ARRAY_BUFFER_BINDING:</span>
428         return m_boundArrayBuffer;
<span class="line-modified">429     case GraphicsContext3D::BLEND:</span>
430         return getBooleanParameter(pname);
<span class="line-modified">431     case GraphicsContext3D::BLEND_COLOR:</span>
432         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">433     case GraphicsContext3D::BLEND_DST_ALPHA:</span>
434         return getUnsignedIntParameter(pname);
<span class="line-modified">435     case GraphicsContext3D::BLEND_DST_RGB:</span>
436         return getUnsignedIntParameter(pname);
<span class="line-modified">437     case GraphicsContext3D::BLEND_EQUATION_ALPHA:</span>
438         return getUnsignedIntParameter(pname);
<span class="line-modified">439     case GraphicsContext3D::BLEND_EQUATION_RGB:</span>
440         return getUnsignedIntParameter(pname);
<span class="line-modified">441     case GraphicsContext3D::BLEND_SRC_ALPHA:</span>
442         return getUnsignedIntParameter(pname);
<span class="line-modified">443     case GraphicsContext3D::BLEND_SRC_RGB:</span>
444         return getUnsignedIntParameter(pname);
<span class="line-modified">445     case GraphicsContext3D::BLUE_BITS:</span>
446         return getIntParameter(pname);
<span class="line-modified">447     case GraphicsContext3D::COLOR_CLEAR_VALUE:</span>
448         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">449     case GraphicsContext3D::COLOR_WRITEMASK:</span>
450         return getBooleanArrayParameter(pname);
<span class="line-modified">451     case GraphicsContext3D::COMPRESSED_TEXTURE_FORMATS:</span>
452         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">453     case GraphicsContext3D::CULL_FACE:</span>
454         return getBooleanParameter(pname);
<span class="line-modified">455     case GraphicsContext3D::CULL_FACE_MODE:</span>
456         return getUnsignedIntParameter(pname);
<span class="line-modified">457     case GraphicsContext3D::CURRENT_PROGRAM:</span>
458         return m_currentProgram;
<span class="line-modified">459     case GraphicsContext3D::DEPTH_BITS:</span>
460         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
461             return 0;
462         return getIntParameter(pname);
<span class="line-modified">463     case GraphicsContext3D::DEPTH_CLEAR_VALUE:</span>
464         return getFloatParameter(pname);
<span class="line-modified">465     case GraphicsContext3D::DEPTH_FUNC:</span>
466         return getUnsignedIntParameter(pname);
<span class="line-modified">467     case GraphicsContext3D::DEPTH_RANGE:</span>
468         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">469     case GraphicsContext3D::DEPTH_TEST:</span>
470         return getBooleanParameter(pname);
<span class="line-modified">471     case GraphicsContext3D::DEPTH_WRITEMASK:</span>
472         return getBooleanParameter(pname);
<span class="line-modified">473     case GraphicsContext3D::DITHER:</span>
474         return getBooleanParameter(pname);
<span class="line-modified">475     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER_BINDING:</span>
476         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">477     case GraphicsContext3D::FRAMEBUFFER_BINDING:</span>
478         return m_framebufferBinding;
<span class="line-modified">479     case GraphicsContext3D::FRONT_FACE:</span>
480         return getUnsignedIntParameter(pname);
<span class="line-modified">481     case GraphicsContext3D::GENERATE_MIPMAP_HINT:</span>
482         return getUnsignedIntParameter(pname);
<span class="line-modified">483     case GraphicsContext3D::GREEN_BITS:</span>
484         return getIntParameter(pname);
<span class="line-modified">485     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
486         return getIntParameter(pname);
<span class="line-modified">487     case GraphicsContext3D::IMPLEMENTATION_COLOR_READ_TYPE:</span>
488         return getIntParameter(pname);
<span class="line-modified">489     case GraphicsContext3D::LINE_WIDTH:</span>
490         return getFloatParameter(pname);
<span class="line-modified">491     case GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
492         return getIntParameter(pname);
<span class="line-modified">493     case GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
494         return getIntParameter(pname);
<span class="line-modified">495     case GraphicsContext3D::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
496         return getIntParameter(pname);
<span class="line-modified">497     case GraphicsContext3D::MAX_RENDERBUFFER_SIZE:</span>
498         return getIntParameter(pname);
<span class="line-modified">499     case GraphicsContext3D::MAX_TEXTURE_IMAGE_UNITS:</span>
500         return getIntParameter(pname);
<span class="line-modified">501     case GraphicsContext3D::MAX_TEXTURE_SIZE:</span>
502         return getIntParameter(pname);
<span class="line-modified">503     case GraphicsContext3D::MAX_VARYING_VECTORS:</span>
504         return getIntParameter(pname);
<span class="line-modified">505     case GraphicsContext3D::MAX_VERTEX_ATTRIBS:</span>
506         return getIntParameter(pname);
<span class="line-modified">507     case GraphicsContext3D::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
508         return getIntParameter(pname);
<span class="line-modified">509     case GraphicsContext3D::MAX_VERTEX_UNIFORM_VECTORS:</span>
510         return getIntParameter(pname);
<span class="line-modified">511     case GraphicsContext3D::MAX_VIEWPORT_DIMS:</span>
512         return getWebGLIntArrayParameter(pname);
<span class="line-modified">513     case GraphicsContext3D::NUM_SHADER_BINARY_FORMATS:</span>
514         return getIntParameter(pname);
<span class="line-modified">515     case GraphicsContext3D::PACK_ALIGNMENT:</span>
516         return getIntParameter(pname);
<span class="line-modified">517     case GraphicsContext3D::POLYGON_OFFSET_FACTOR:</span>
518         return getFloatParameter(pname);
<span class="line-modified">519     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
520         return getBooleanParameter(pname);
<span class="line-modified">521     case GraphicsContext3D::POLYGON_OFFSET_UNITS:</span>
522         return getFloatParameter(pname);
<span class="line-modified">523     case GraphicsContext3D::RED_BITS:</span>
524         return getIntParameter(pname);
<span class="line-modified">525     case GraphicsContext3D::RENDERBUFFER_BINDING:</span>
526         return m_renderbufferBinding;
<span class="line-modified">527     case GraphicsContext3D::RENDERER:</span>
528         return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">529     case GraphicsContext3D::SAMPLE_BUFFERS:</span>
530         return getIntParameter(pname);
<span class="line-modified">531     case GraphicsContext3D::SAMPLE_COVERAGE_INVERT:</span>
532         return getBooleanParameter(pname);
<span class="line-modified">533     case GraphicsContext3D::SAMPLE_COVERAGE_VALUE:</span>
534         return getFloatParameter(pname);
<span class="line-modified">535     case GraphicsContext3D::SAMPLES:</span>
536         return getIntParameter(pname);
<span class="line-modified">537     case GraphicsContext3D::SCISSOR_BOX:</span>
538         return getWebGLIntArrayParameter(pname);
<span class="line-modified">539     case GraphicsContext3D::SCISSOR_TEST:</span>
540         return getBooleanParameter(pname);
<span class="line-modified">541     case GraphicsContext3D::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">542         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContext3D::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">543     case GraphicsContext3D::STENCIL_BACK_FAIL:</span>
544         return getUnsignedIntParameter(pname);
<span class="line-modified">545     case GraphicsContext3D::STENCIL_BACK_FUNC:</span>
546         return getUnsignedIntParameter(pname);
<span class="line-modified">547     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
548         return getUnsignedIntParameter(pname);
<span class="line-modified">549     case GraphicsContext3D::STENCIL_BACK_PASS_DEPTH_PASS:</span>
550         return getUnsignedIntParameter(pname);
<span class="line-modified">551     case GraphicsContext3D::STENCIL_BACK_REF:</span>
552         return getIntParameter(pname);
<span class="line-modified">553     case GraphicsContext3D::STENCIL_BACK_VALUE_MASK:</span>
554         return getUnsignedIntParameter(pname);
<span class="line-modified">555     case GraphicsContext3D::STENCIL_BACK_WRITEMASK:</span>
556         return getUnsignedIntParameter(pname);
<span class="line-modified">557     case GraphicsContext3D::STENCIL_BITS:</span>
558         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
559             return 0;
560         return getIntParameter(pname);
<span class="line-modified">561     case GraphicsContext3D::STENCIL_CLEAR_VALUE:</span>
562         return getIntParameter(pname);
<span class="line-modified">563     case GraphicsContext3D::STENCIL_FAIL:</span>
564         return getUnsignedIntParameter(pname);
<span class="line-modified">565     case GraphicsContext3D::STENCIL_FUNC:</span>
566         return getUnsignedIntParameter(pname);
<span class="line-modified">567     case GraphicsContext3D::STENCIL_PASS_DEPTH_FAIL:</span>
568         return getUnsignedIntParameter(pname);
<span class="line-modified">569     case GraphicsContext3D::STENCIL_PASS_DEPTH_PASS:</span>
570         return getUnsignedIntParameter(pname);
<span class="line-modified">571     case GraphicsContext3D::STENCIL_REF:</span>
572         return getIntParameter(pname);
<span class="line-modified">573     case GraphicsContext3D::STENCIL_TEST:</span>
574         return getBooleanParameter(pname);
<span class="line-modified">575     case GraphicsContext3D::STENCIL_VALUE_MASK:</span>
576         return getUnsignedIntParameter(pname);
<span class="line-modified">577     case GraphicsContext3D::STENCIL_WRITEMASK:</span>
578         return getUnsignedIntParameter(pname);
<span class="line-modified">579     case GraphicsContext3D::SUBPIXEL_BITS:</span>
580         return getIntParameter(pname);
<span class="line-modified">581     case GraphicsContext3D::TEXTURE_BINDING_2D:</span>
582         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">583     case GraphicsContext3D::TEXTURE_BINDING_CUBE_MAP:</span>
584         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">585     case GraphicsContext3D::UNPACK_ALIGNMENT:</span>
586         return getIntParameter(pname);
<span class="line-modified">587     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:</span>
588         return m_unpackFlipY;
<span class="line-modified">589     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
590         return m_unpackPremultiplyAlpha;
<span class="line-modified">591     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
592         return m_unpackColorspaceConversion;
<span class="line-modified">593     case GraphicsContext3D::VENDOR:</span>
594         return &quot;WebKit&quot;_str;
<span class="line-modified">595     case GraphicsContext3D::VERSION:</span>
596         return &quot;WebGL 1.0&quot;_str;
<span class="line-modified">597     case GraphicsContext3D::VIEWPORT:</span>
598         return getWebGLIntArrayParameter(pname);
<span class="line-modified">599     case Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
600         if (m_oesStandardDerivatives)
<span class="line-modified">601             return getUnsignedIntParameter(Extensions3D::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);</span>
<span class="line-modified">602         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);</span>
603         return nullptr;
604     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
605         if (m_webglDebugRendererInfo) {
606 #if PLATFORM(IOS_FAMILY)
607             return &quot;Apple GPU&quot;_str;
608 #else
<span class="line-modified">609             return m_context-&gt;getString(GraphicsContext3D::RENDERER);</span>
610 #endif
611         }
<span class="line-modified">612         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
613         return nullptr;
614     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
615         if (m_webglDebugRendererInfo)
<span class="line-modified">616             return m_context-&gt;getString(GraphicsContext3D::VENDOR);</span>
<span class="line-modified">617         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
618         return nullptr;
<span class="line-modified">619     case Extensions3D::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object</span>
620         if (m_oesVertexArrayObject) {
621             if (m_boundVertexArrayObject-&gt;isDefaultObject())
622                 return nullptr;
623             return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
624         }
<span class="line-modified">625         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);</span>
626         return nullptr;
<span class="line-modified">627     case Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
628         if (m_extTextureFilterAnisotropic)
<span class="line-modified">629             return getUnsignedIntParameter(Extensions3D::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">630         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
631         return nullptr;
<span class="line-modified">632     case Extensions3D::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN</span>
633         if (m_webglDrawBuffers)
634             return getMaxColorAttachments();
<span class="line-modified">635         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
636         return nullptr;
<span class="line-modified">637     case Extensions3D::MAX_DRAW_BUFFERS_EXT:</span>
638         if (m_webglDrawBuffers)
639             return getMaxDrawBuffers();
<span class="line-modified">640         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
641         return nullptr;
642     default:
643         if (m_webglDrawBuffers
<span class="line-modified">644             &amp;&amp; pname &gt;= Extensions3D::DRAW_BUFFER0_EXT</span>
<span class="line-modified">645             &amp;&amp; pname &lt; static_cast&lt;GC3Denum&gt;(Extensions3D::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {</span>
<span class="line-modified">646             GC3Dint value = GraphicsContext3D::NONE;</span>
647             if (m_framebufferBinding)
648                 value = m_framebufferBinding-&gt;getDrawBuffer(pname);
649             else // emulated backbuffer
650                 value = m_backDrawBuffer;
651             return value;
652         }
<span class="line-modified">653         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
654         return nullptr;
655     }
656 }
657 
<span class="line-modified">658 GC3Dint WebGLRenderingContext::getMaxDrawBuffers()</span>
659 {
660     if (!supportsDrawBuffers())
661         return 0;
662     if (!m_maxDrawBuffers)
<span class="line-modified">663         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
664     if (!m_maxColorAttachments)
<span class="line-modified">665         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
666     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
667     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
668 }
669 
<span class="line-modified">670 GC3Dint WebGLRenderingContext::getMaxColorAttachments()</span>
671 {
672     if (!supportsDrawBuffers())
673         return 0;
674     if (!m_maxColorAttachments)
<span class="line-modified">675         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
676     return m_maxColorAttachments;
677 }
678 
<span class="line-modified">679 bool WebGLRenderingContext::validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired)</span>
680 {
681     // Performs conservative validation by caching a maximum index of
682     // the given type per element array buffer. If all of the bound
683     // array buffers have enough elements to satisfy that maximum
684     // index, skips the expensive per-draw-call iteration in
685     // validateIndexArrayPrecise.
686 
687     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
688 
689     if (!elementArrayBuffer)
690         return false;
691 
<span class="line-modified">692     GC3Dsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
693     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
694     if (!numElements)
695         return false;
696     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
697     ASSERT(buffer);
698 
699     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
700     if (!maxIndex) {
701         // Compute the maximum index in the entire buffer for the given type of index.
702         switch (type) {
<span class="line-modified">703         case GraphicsContext3D::UNSIGNED_BYTE: {</span>
<span class="line-modified">704             const GC3Dubyte* p = static_cast&lt;const GC3Dubyte*&gt;(buffer-&gt;data());</span>
<span class="line-modified">705             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
706                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
707             break;
708         }
<span class="line-modified">709         case GraphicsContext3D::UNSIGNED_SHORT: {</span>
<span class="line-modified">710             numElements /= sizeof(GC3Dushort);</span>
<span class="line-modified">711             const GC3Dushort* p = static_cast&lt;const GC3Dushort*&gt;(buffer-&gt;data());</span>
<span class="line-modified">712             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
713                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
714             break;
715         }
<span class="line-modified">716         case GraphicsContext3D::UNSIGNED_INT: {</span>
717             if (!m_oesElementIndexUint)
718                 return false;
<span class="line-modified">719             numElements /= sizeof(GC3Duint);</span>
<span class="line-modified">720             const GC3Duint* p = static_cast&lt;const GC3Duint*&gt;(buffer-&gt;data());</span>
<span class="line-modified">721             for (GC3Dsizeiptr i = 0; i &lt; numElements; i++)</span>
722                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
723             break;
724         }
725         default:
726             return false;
727         }
728         if (maxIndex)
729             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
730     }
731 
732     if (!maxIndex)
733         return false;
734 
735     // The number of required elements is one more than the maximum index that will be accessed.
736     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
737     if (!checkedNumElementsRequired)
738         return false;
739     numElementsRequired = checkedNumElementsRequired.value();
740 
741     return true;
742 }
743 
<span class="line-modified">744 bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GC3Denum mode)</span>
745 {
746     switch (mode) {
<span class="line-modified">747     case GraphicsContext3D::FUNC_ADD:</span>
<span class="line-modified">748     case GraphicsContext3D::FUNC_SUBTRACT:</span>
<span class="line-modified">749     case GraphicsContext3D::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">750     case Extensions3D::MIN_EXT:</span>
<span class="line-modified">751     case Extensions3D::MAX_EXT:</span>
<span class="line-modified">752         if ((mode == Extensions3D::MIN_EXT || mode == Extensions3D::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {</span>
<span class="line-modified">753             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
754             return false;
755         }
756         return true;
757         break;
758     default:
<span class="line-modified">759         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
760         return false;
761     }
762 }
763 
<span class="line-modified">764 bool WebGLRenderingContext::validateCapability(const char* functionName, GC3Denum cap)</span>
765 {
766     switch (cap) {
<span class="line-modified">767     case GraphicsContext3D::BLEND:</span>
<span class="line-modified">768     case GraphicsContext3D::CULL_FACE:</span>
<span class="line-modified">769     case GraphicsContext3D::DEPTH_TEST:</span>
<span class="line-modified">770     case GraphicsContext3D::DITHER:</span>
<span class="line-modified">771     case GraphicsContext3D::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">772     case GraphicsContext3D::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">773     case GraphicsContext3D::SAMPLE_COVERAGE:</span>
<span class="line-modified">774     case GraphicsContext3D::SCISSOR_TEST:</span>
<span class="line-modified">775     case GraphicsContext3D::STENCIL_TEST:</span>
776         return true;
777     default:
<span class="line-modified">778         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
779         return false;
780     }
781 }
782 
783 } // namespace WebCore
784 
785 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLRenderingContext.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
 31 #include &quot;ANGLEInstancedArrays.h&quot;
 32 #include &quot;CachedImage.h&quot;
 33 #include &quot;EXTBlendMinMax.h&quot;
 34 #include &quot;EXTFragDepth.h&quot;
 35 #include &quot;EXTShaderTextureLOD.h&quot;
 36 #include &quot;EXTTextureFilterAnisotropic.h&quot;
 37 #include &quot;EXTsRGB.h&quot;
<span class="line-modified"> 38 #include &quot;ExtensionsGL.h&quot;</span>
 39 #include &quot;HTMLCanvasElement.h&quot;
 40 #include &quot;HTMLImageElement.h&quot;
 41 #include &quot;HTMLVideoElement.h&quot;
 42 #include &quot;ImageData.h&quot;
 43 #include &quot;InspectorInstrumentation.h&quot;
 44 #include &quot;OESElementIndexUint.h&quot;
 45 #include &quot;OESStandardDerivatives.h&quot;
 46 #include &quot;OESTextureFloat.h&quot;
 47 #include &quot;OESTextureFloatLinear.h&quot;
 48 #include &quot;OESTextureHalfFloat.h&quot;
 49 #include &quot;OESTextureHalfFloatLinear.h&quot;
 50 #include &quot;OESVertexArrayObject.h&quot;
 51 #include &quot;RenderBox.h&quot;
 52 #include &quot;WebGLCompressedTextureASTC.h&quot;
 53 #include &quot;WebGLCompressedTextureATC.h&quot;
<span class="line-added"> 54 #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="line-added"> 55 #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
 56 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
 57 #include &quot;WebGLCompressedTextureS3TC.h&quot;
 58 #include &quot;WebGLDebugRendererInfo.h&quot;
 59 #include &quot;WebGLDebugShaders.h&quot;
 60 #include &quot;WebGLDepthTexture.h&quot;
 61 #include &quot;WebGLDrawBuffers.h&quot;
 62 #include &quot;WebGLLoseContext.h&quot;
 63 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 64 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
 65 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 66 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 67 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 68 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
 69 #include &lt;wtf/IsoMallocInlines.h&gt;
 70 
 71 namespace WebCore {
 72 
 73 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContext);
 74 
<span class="line-modified"> 75 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
 76 {
 77     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, attributes));
 78 
 79     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 80 
 81     return renderingContext;
 82 }
 83 
<span class="line-modified"> 84 std::unique_ptr&lt;WebGLRenderingContext&gt; WebGLRenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
 85 {
 86     auto renderingContext = std::unique_ptr&lt;WebGLRenderingContext&gt;(new WebGLRenderingContext(canvas, WTFMove(context), attributes));
 87 
 88     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
 89 
 90     return renderingContext;
 91 }
 92 
<span class="line-modified"> 93 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)</span>
 94     : WebGLRenderingContextBase(canvas, attributes)
 95 {
 96 }
 97 
<span class="line-modified"> 98 WebGLRenderingContext::WebGLRenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)</span>
 99     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
100 {
101     initializeVertexArrayObjects();
102 }
103 
104 void WebGLRenderingContext::initializeVertexArrayObjects()
105 {
106     m_defaultVertexArrayObject = WebGLVertexArrayObjectOES::create(*this, WebGLVertexArrayObjectOES::Type::Default);
107     addContextObject(*m_defaultVertexArrayObject);
108     m_boundVertexArrayObject = m_defaultVertexArrayObject;
109     if (!isGLES2Compliant())
110         initVertexAttrib0();
111 }
112 
113 WebGLExtension* WebGLRenderingContext::getExtension(const String&amp; name)
114 {
115     if (isContextLostOrPending())
116         return nullptr;
117 
118 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
</pre>
<hr />
<pre>
124         } \
125         return variable.get(); \
126     }
127 
128     ENABLE_IF_REQUESTED(EXTBlendMinMax, m_extBlendMinMax, &quot;EXT_blend_minmax&quot;, enableSupportedExtension(&quot;GL_EXT_blend_minmax&quot;_s));
129     ENABLE_IF_REQUESTED(EXTsRGB, m_extsRGB, &quot;EXT_sRGB&quot;, enableSupportedExtension(&quot;GL_EXT_sRGB&quot;_s));
130     ENABLE_IF_REQUESTED(EXTFragDepth, m_extFragDepth, &quot;EXT_frag_depth&quot;, enableSupportedExtension(&quot;GL_EXT_frag_depth&quot;_s));
131     if (equalIgnoringASCIICase(name, &quot;EXT_shader_texture_lod&quot;)) {
132         if (!m_extShaderTextureLOD) {
133             if (!(m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s)))
134                 m_extShaderTextureLOD = nullptr;
135             else {
136                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;_s);
137                 m_extShaderTextureLOD = makeUnique&lt;EXTShaderTextureLOD&gt;(*this);
138                 InspectorInstrumentation::didEnableExtension(*this, name);
139             }
140         }
141         return m_extShaderTextureLOD.get();
142     }
143     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));

144     ENABLE_IF_REQUESTED(OESStandardDerivatives, m_oesStandardDerivatives, &quot;OES_standard_derivatives&quot;, enableSupportedExtension(&quot;GL_OES_standard_derivatives&quot;_s));
145     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
146     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
147     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
148     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
149     ENABLE_IF_REQUESTED(OESVertexArrayObject, m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;, enableSupportedExtension(&quot;GL_OES_vertex_array_object&quot;_s));
150     ENABLE_IF_REQUESTED(OESElementIndexUint, m_oesElementIndexUint, &quot;OES_element_index_uint&quot;, enableSupportedExtension(&quot;GL_OES_element_index_uint&quot;_s));
151     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
<span class="line-added">152     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));</span>
153     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
<span class="line-added">154     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC, m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;, WebGLCompressedTextureETC::supported(*this));</span>
<span class="line-added">155     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC1, m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;, WebGLCompressedTextureETC1::supported(*this));</span>
156     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
157     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));

158     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*m_context));
159     if (equalIgnoringASCIICase(name, &quot;WEBGL_draw_buffers&quot;)) {
160         if (!m_webglDrawBuffers) {
161             if (!supportsDrawBuffers())
162                 m_webglDrawBuffers = nullptr;
163             else {
164                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;_s);
165                 m_webglDrawBuffers = makeUnique&lt;WebGLDrawBuffers&gt;(*this);
166                 InspectorInstrumentation::didEnableExtension(*this, name);
167             }
168         }
169         return m_webglDrawBuffers.get();
170     }
171     if (equalIgnoringASCIICase(name, &quot;ANGLE_instanced_arrays&quot;)) {
172         if (!m_angleInstancedArrays) {
173             if (!ANGLEInstancedArrays::supported(*this))
174                 m_angleInstancedArrays = nullptr;
175             else {
176                 m_context-&gt;getExtensions().ensureEnabled(&quot;GL_ANGLE_instanced_arrays&quot;_s);
177                 m_angleInstancedArrays = makeUnique&lt;ANGLEInstancedArrays&gt;(*this);
</pre>
<hr />
<pre>
203         result.append(&quot;EXT_frag_depth&quot;_s);
204     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float&quot;_s))
205         result.append(&quot;OES_texture_float&quot;_s);
206     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_float_linear&quot;_s))
207         result.append(&quot;OES_texture_float_linear&quot;_s);
208     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float&quot;_s))
209         result.append(&quot;OES_texture_half_float&quot;_s);
210     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
211         result.append(&quot;OES_texture_half_float_linear&quot;_s);
212     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_standard_derivatives&quot;_s))
213         result.append(&quot;OES_standard_derivatives&quot;_s);
214     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_shader_texture_lod&quot;_s) || m_context-&gt;getExtensions().supports(&quot;GL_ARB_shader_texture_lod&quot;_s))
215         result.append(&quot;EXT_shader_texture_lod&quot;_s);
216     if (m_context-&gt;getExtensions().supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
217         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);
218     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_vertex_array_object&quot;_s))
219         result.append(&quot;OES_vertex_array_object&quot;_s);
220     if (m_context-&gt;getExtensions().supports(&quot;GL_OES_element_index_uint&quot;_s))
221         result.append(&quot;OES_element_index_uint&quot;_s);
222     result.append(&quot;WEBGL_lose_context&quot;_s);
<span class="line-added">223     if (WebGLCompressedTextureASTC::supported(*this))</span>
<span class="line-added">224         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);</span>
225     if (WebGLCompressedTextureATC::supported(*this))
226         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
<span class="line-added">227     if (WebGLCompressedTextureETC::supported(*this))</span>
<span class="line-added">228         result.append(&quot;WEBGL_compressed_texture_etc&quot;_s);</span>
<span class="line-added">229     if (WebGLCompressedTextureETC1::supported(*this))</span>
<span class="line-added">230         result.append(&quot;WEBGL_compressed_texture_etc1&quot;_s);</span>
231     if (WebGLCompressedTexturePVRTC::supported(*this))
232         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
233     if (WebGLCompressedTextureS3TC::supported(*this))
234         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);


235     if (WebGLDepthTexture::supported(*m_context))
236         result.append(&quot;WEBGL_depth_texture&quot;_s);
237     if (supportsDrawBuffers())
238         result.append(&quot;WEBGL_draw_buffers&quot;_s);
239     if (ANGLEInstancedArrays::supported(*this))
240         result.append(&quot;ANGLE_instanced_arrays&quot;_s);
241     if (m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
242         result.append(&quot;WEBGL_debug_shaders&quot;_s);
243     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
244 
245     return result;
246 }
247 
<span class="line-modified">248 WebGLAny WebGLRenderingContext::getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname)</span>
249 {
250     if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;getFramebufferAttachmentParameter&quot;, target, attachment))
251         return nullptr;
252 
253     if (!m_framebufferBinding || !m_framebufferBinding-&gt;object()) {
<span class="line-modified">254         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getFramebufferAttachmentParameter&quot;, &quot;no framebuffer bound&quot;);</span>
255         return nullptr;
256     }
257 
258     auto object = makeRefPtr(m_framebufferBinding-&gt;getAttachmentObject(attachment));
259     if (!object) {
<span class="line-modified">260         if (pname == GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)</span>
<span class="line-modified">261             return static_cast&lt;unsigned&gt;(GraphicsContextGL::NONE);</span>
262         // OpenGL ES 2.0 specifies INVALID_ENUM in this case, while desktop GL
263         // specifies INVALID_OPERATION.
<span class="line-modified">264         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name&quot;);</span>
265         return nullptr;
266     }
267 
268     if (object-&gt;isTexture()) {
269         switch (pname) {
<span class="line-modified">270         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">271             return static_cast&lt;unsigned&gt;(GraphicsContextGL::TEXTURE);</span>
<span class="line-modified">272         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
273             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
<span class="line-modified">274         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:</span>
<span class="line-modified">275         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:</span>
<span class="line-modified">276         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
<span class="line-modified">277             GCGLint value = 0;</span>
278             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
279             return value;
280         }
281         default:
<span class="line-modified">282             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for texture attachment&quot;);</span>
283             return nullptr;
284         }
285     } else {
286         ASSERT(object-&gt;isRenderbuffer());
287         switch (pname) {
<span class="line-modified">288         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:</span>
<span class="line-modified">289             return static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER);</span>
<span class="line-modified">290         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:</span>
291             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
<span class="line-modified">292         case ExtensionsGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: {</span>
293             if (!m_extsRGB) {
<span class="line-modified">294                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
295                 return nullptr;
296             }
297             RefPtr&lt;WebGLRenderbuffer&gt; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer*&gt;(object.get());
<span class="line-modified">298             GCGLenum renderBufferFormat = renderBuffer-&gt;getInternalFormat();</span>
<span class="line-modified">299             ASSERT(renderBufferFormat != ExtensionsGL::SRGB_EXT &amp;&amp; renderBufferFormat != ExtensionsGL::SRGB_ALPHA_EXT);</span>
<span class="line-modified">300             if (renderBufferFormat == ExtensionsGL::SRGB8_ALPHA8_EXT)</span>
<span class="line-modified">301                 return static_cast&lt;unsigned&gt;(ExtensionsGL::SRGB_EXT);</span>
<span class="line-modified">302             return static_cast&lt;unsigned&gt;(GraphicsContextGL::LINEAR);</span>
303         }
304         default:
<span class="line-modified">305             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getFramebufferAttachmentParameter&quot;, &quot;invalid parameter name for renderbuffer attachment&quot;);</span>
306             return nullptr;
307         }
308     }
309 }
310 
<span class="line-modified">311 bool WebGLRenderingContext::validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment)</span>
312 {
<span class="line-modified">313     if (target != GraphicsContextGL::FRAMEBUFFER) {</span>
<span class="line-modified">314         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
315         return false;
316     }
317     // FIXME: Why does this return true unconditionally for COLOR_ATTACHMENT0,
318     // but false for other COLOR_ATTACHMENT values if m_webglDrawBuffers is false?
319     switch (attachment) {
<span class="line-modified">320     case GraphicsContextGL::COLOR_ATTACHMENT0:</span>
<span class="line-modified">321     case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">322     case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">323     case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
324         return true;
325     default:
326         if (m_webglDrawBuffers
<span class="line-modified">327             &amp;&amp; attachment &gt;= GraphicsContextGL::COLOR_ATTACHMENT0</span>
<span class="line-modified">328             &amp;&amp; attachment &lt; static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + getMaxColorAttachments()))</span>
329             return true;
<span class="line-modified">330         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);</span>
331         return false;
332     }
333 }
334 
<span class="line-modified">335 void WebGLRenderingContext::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)</span>
336 {
337     if (isContextLostOrPending())
338         return;
<span class="line-modified">339     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="line-modified">340         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);</span>
341         return;
342     }
343     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="line-modified">344         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);</span>
345         return;
346     }
347     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
348         return;
349     switch (internalformat) {
<span class="line-modified">350     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="line-modified">351     case GraphicsContextGL::RGBA4:</span>
<span class="line-modified">352     case GraphicsContextGL::RGB5_A1:</span>
<span class="line-modified">353     case GraphicsContextGL::RGB565:</span>
<span class="line-modified">354     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="line-modified">355     case ExtensionsGL::SRGB8_ALPHA8_EXT:</span>
<span class="line-modified">356         if (internalformat == ExtensionsGL::SRGB8_ALPHA8_EXT &amp;&amp; !m_extsRGB) {</span>
<span class="line-modified">357             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
358             return;
359         }
360         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
361         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
362         m_renderbufferBinding-&gt;setIsValid(true);
363         m_renderbufferBinding-&gt;setSize(width, height);
364         break;
<span class="line-modified">365     case GraphicsContextGL::DEPTH_STENCIL:</span>
366         if (isDepthStencilSupported())
<span class="line-modified">367             m_context-&gt;renderbufferStorage(target, ExtensionsGL::DEPTH24_STENCIL8, width, height);</span>
368         m_renderbufferBinding-&gt;setSize(width, height);
369         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
370         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
371         break;
372     default:
<span class="line-modified">373         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);</span>
374         return;
375     }
376     applyStencilTest();
377 }
378 
<span class="line-modified">379 void WebGLRenderingContext::hint(GCGLenum target, GCGLenum mode)</span>
380 {
381     if (isContextLostOrPending())
382         return;
383     bool isValid = false;
384     switch (target) {
<span class="line-modified">385     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
386         isValid = true;
387         break;
<span class="line-modified">388     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
389         if (m_oesStandardDerivatives)
390             isValid = true;
391         break;
392     }
393     if (!isValid) {
<span class="line-modified">394         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);</span>
395         return;
396     }
397     m_context-&gt;hint(target, mode);
398 }
399 
<span class="line-modified">400 void WebGLRenderingContext::clear(GCGLbitfield mask)</span>
401 {
402     if (isContextLostOrPending())
403         return;
<span class="line-modified">404     if (mask &amp; ~(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT)) {</span>
<span class="line-modified">405         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);</span>
406         return;
407     }
408     const char* reason = &quot;framebuffer incomplete&quot;;
409     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(m_context.get(), &amp;reason)) {
<span class="line-modified">410         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);</span>
411         return;
412     }
413     if (!clearIfComposited(mask))
414         m_context-&gt;clear(mask);
415     markContextChangedAndNotifyCanvasObserver();
416 }
417 
<span class="line-modified">418 WebGLAny WebGLRenderingContext::getParameter(GCGLenum pname)</span>
419 {
420     if (isContextLostOrPending())
421         return nullptr;
422 
423     switch (pname) {
<span class="line-modified">424     case GraphicsContextGL::ACTIVE_TEXTURE:</span>
425         return getUnsignedIntParameter(pname);
<span class="line-modified">426     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
427         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">428     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
429         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">430     case GraphicsContextGL::ALPHA_BITS:</span>
431         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
432             return 0;
433         return getIntParameter(pname);
<span class="line-modified">434     case GraphicsContextGL::ARRAY_BUFFER_BINDING:</span>
435         return m_boundArrayBuffer;
<span class="line-modified">436     case GraphicsContextGL::BLEND:</span>
437         return getBooleanParameter(pname);
<span class="line-modified">438     case GraphicsContextGL::BLEND_COLOR:</span>
439         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">440     case GraphicsContextGL::BLEND_DST_ALPHA:</span>
441         return getUnsignedIntParameter(pname);
<span class="line-modified">442     case GraphicsContextGL::BLEND_DST_RGB:</span>
443         return getUnsignedIntParameter(pname);
<span class="line-modified">444     case GraphicsContextGL::BLEND_EQUATION_ALPHA:</span>
445         return getUnsignedIntParameter(pname);
<span class="line-modified">446     case GraphicsContextGL::BLEND_EQUATION_RGB:</span>
447         return getUnsignedIntParameter(pname);
<span class="line-modified">448     case GraphicsContextGL::BLEND_SRC_ALPHA:</span>
449         return getUnsignedIntParameter(pname);
<span class="line-modified">450     case GraphicsContextGL::BLEND_SRC_RGB:</span>
451         return getUnsignedIntParameter(pname);
<span class="line-modified">452     case GraphicsContextGL::BLUE_BITS:</span>
453         return getIntParameter(pname);
<span class="line-modified">454     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
455         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">456     case GraphicsContextGL::COLOR_WRITEMASK:</span>
457         return getBooleanArrayParameter(pname);
<span class="line-modified">458     case GraphicsContextGL::COMPRESSED_TEXTURE_FORMATS:</span>
459         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
<span class="line-modified">460     case GraphicsContextGL::CULL_FACE:</span>
461         return getBooleanParameter(pname);
<span class="line-modified">462     case GraphicsContextGL::CULL_FACE_MODE:</span>
463         return getUnsignedIntParameter(pname);
<span class="line-modified">464     case GraphicsContextGL::CURRENT_PROGRAM:</span>
465         return m_currentProgram;
<span class="line-modified">466     case GraphicsContextGL::DEPTH_BITS:</span>
467         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
468             return 0;
469         return getIntParameter(pname);
<span class="line-modified">470     case GraphicsContextGL::DEPTH_CLEAR_VALUE:</span>
471         return getFloatParameter(pname);
<span class="line-modified">472     case GraphicsContextGL::DEPTH_FUNC:</span>
473         return getUnsignedIntParameter(pname);
<span class="line-modified">474     case GraphicsContextGL::DEPTH_RANGE:</span>
475         return getWebGLFloatArrayParameter(pname);
<span class="line-modified">476     case GraphicsContextGL::DEPTH_TEST:</span>
477         return getBooleanParameter(pname);
<span class="line-modified">478     case GraphicsContextGL::DEPTH_WRITEMASK:</span>
479         return getBooleanParameter(pname);
<span class="line-modified">480     case GraphicsContextGL::DITHER:</span>
481         return getBooleanParameter(pname);
<span class="line-modified">482     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER_BINDING:</span>
483         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
<span class="line-modified">484     case GraphicsContextGL::FRAMEBUFFER_BINDING:</span>
485         return m_framebufferBinding;
<span class="line-modified">486     case GraphicsContextGL::FRONT_FACE:</span>
487         return getUnsignedIntParameter(pname);
<span class="line-modified">488     case GraphicsContextGL::GENERATE_MIPMAP_HINT:</span>
489         return getUnsignedIntParameter(pname);
<span class="line-modified">490     case GraphicsContextGL::GREEN_BITS:</span>
491         return getIntParameter(pname);
<span class="line-modified">492     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_FORMAT:</span>
493         return getIntParameter(pname);
<span class="line-modified">494     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_TYPE:</span>
495         return getIntParameter(pname);
<span class="line-modified">496     case GraphicsContextGL::LINE_WIDTH:</span>
497         return getFloatParameter(pname);
<span class="line-modified">498     case GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS:</span>
499         return getIntParameter(pname);
<span class="line-modified">500     case GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE:</span>
501         return getIntParameter(pname);
<span class="line-modified">502     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_VECTORS:</span>
503         return getIntParameter(pname);
<span class="line-modified">504     case GraphicsContextGL::MAX_RENDERBUFFER_SIZE:</span>
505         return getIntParameter(pname);
<span class="line-modified">506     case GraphicsContextGL::MAX_TEXTURE_IMAGE_UNITS:</span>
507         return getIntParameter(pname);
<span class="line-modified">508     case GraphicsContextGL::MAX_TEXTURE_SIZE:</span>
509         return getIntParameter(pname);
<span class="line-modified">510     case GraphicsContextGL::MAX_VARYING_VECTORS:</span>
511         return getIntParameter(pname);
<span class="line-modified">512     case GraphicsContextGL::MAX_VERTEX_ATTRIBS:</span>
513         return getIntParameter(pname);
<span class="line-modified">514     case GraphicsContextGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS:</span>
515         return getIntParameter(pname);
<span class="line-modified">516     case GraphicsContextGL::MAX_VERTEX_UNIFORM_VECTORS:</span>
517         return getIntParameter(pname);
<span class="line-modified">518     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
519         return getWebGLIntArrayParameter(pname);
<span class="line-modified">520     case GraphicsContextGL::NUM_SHADER_BINARY_FORMATS:</span>
521         return getIntParameter(pname);
<span class="line-modified">522     case GraphicsContextGL::PACK_ALIGNMENT:</span>
523         return getIntParameter(pname);
<span class="line-modified">524     case GraphicsContextGL::POLYGON_OFFSET_FACTOR:</span>
525         return getFloatParameter(pname);
<span class="line-modified">526     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
527         return getBooleanParameter(pname);
<span class="line-modified">528     case GraphicsContextGL::POLYGON_OFFSET_UNITS:</span>
529         return getFloatParameter(pname);
<span class="line-modified">530     case GraphicsContextGL::RED_BITS:</span>
531         return getIntParameter(pname);
<span class="line-modified">532     case GraphicsContextGL::RENDERBUFFER_BINDING:</span>
533         return m_renderbufferBinding;
<span class="line-modified">534     case GraphicsContextGL::RENDERER:</span>
535         return &quot;WebKit WebGL&quot;_str;
<span class="line-modified">536     case GraphicsContextGL::SAMPLE_BUFFERS:</span>
537         return getIntParameter(pname);
<span class="line-modified">538     case GraphicsContextGL::SAMPLE_COVERAGE_INVERT:</span>
539         return getBooleanParameter(pname);
<span class="line-modified">540     case GraphicsContextGL::SAMPLE_COVERAGE_VALUE:</span>
541         return getFloatParameter(pname);
<span class="line-modified">542     case GraphicsContextGL::SAMPLES:</span>
543         return getIntParameter(pname);
<span class="line-modified">544     case GraphicsContextGL::SCISSOR_BOX:</span>
545         return getWebGLIntArrayParameter(pname);
<span class="line-modified">546     case GraphicsContextGL::SCISSOR_TEST:</span>
547         return getBooleanParameter(pname);
<span class="line-modified">548     case GraphicsContextGL::SHADING_LANGUAGE_VERSION:</span>
<span class="line-modified">549         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContextGL::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;</span>
<span class="line-modified">550     case GraphicsContextGL::STENCIL_BACK_FAIL:</span>
551         return getUnsignedIntParameter(pname);
<span class="line-modified">552     case GraphicsContextGL::STENCIL_BACK_FUNC:</span>
553         return getUnsignedIntParameter(pname);
<span class="line-modified">554     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_FAIL:</span>
555         return getUnsignedIntParameter(pname);
<span class="line-modified">556     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_PASS:</span>
557         return getUnsignedIntParameter(pname);
<span class="line-modified">558     case GraphicsContextGL::STENCIL_BACK_REF:</span>
559         return getIntParameter(pname);
<span class="line-modified">560     case GraphicsContextGL::STENCIL_BACK_VALUE_MASK:</span>
561         return getUnsignedIntParameter(pname);
<span class="line-modified">562     case GraphicsContextGL::STENCIL_BACK_WRITEMASK:</span>
563         return getUnsignedIntParameter(pname);
<span class="line-modified">564     case GraphicsContextGL::STENCIL_BITS:</span>
565         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
566             return 0;
567         return getIntParameter(pname);
<span class="line-modified">568     case GraphicsContextGL::STENCIL_CLEAR_VALUE:</span>
569         return getIntParameter(pname);
<span class="line-modified">570     case GraphicsContextGL::STENCIL_FAIL:</span>
571         return getUnsignedIntParameter(pname);
<span class="line-modified">572     case GraphicsContextGL::STENCIL_FUNC:</span>
573         return getUnsignedIntParameter(pname);
<span class="line-modified">574     case GraphicsContextGL::STENCIL_PASS_DEPTH_FAIL:</span>
575         return getUnsignedIntParameter(pname);
<span class="line-modified">576     case GraphicsContextGL::STENCIL_PASS_DEPTH_PASS:</span>
577         return getUnsignedIntParameter(pname);
<span class="line-modified">578     case GraphicsContextGL::STENCIL_REF:</span>
579         return getIntParameter(pname);
<span class="line-modified">580     case GraphicsContextGL::STENCIL_TEST:</span>
581         return getBooleanParameter(pname);
<span class="line-modified">582     case GraphicsContextGL::STENCIL_VALUE_MASK:</span>
583         return getUnsignedIntParameter(pname);
<span class="line-modified">584     case GraphicsContextGL::STENCIL_WRITEMASK:</span>
585         return getUnsignedIntParameter(pname);
<span class="line-modified">586     case GraphicsContextGL::SUBPIXEL_BITS:</span>
587         return getIntParameter(pname);
<span class="line-modified">588     case GraphicsContextGL::TEXTURE_BINDING_2D:</span>
589         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
<span class="line-modified">590     case GraphicsContextGL::TEXTURE_BINDING_CUBE_MAP:</span>
591         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
<span class="line-modified">592     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
593         return getIntParameter(pname);
<span class="line-modified">594     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
595         return m_unpackFlipY;
<span class="line-modified">596     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
597         return m_unpackPremultiplyAlpha;
<span class="line-modified">598     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
599         return m_unpackColorspaceConversion;
<span class="line-modified">600     case GraphicsContextGL::VENDOR:</span>
601         return &quot;WebKit&quot;_str;
<span class="line-modified">602     case GraphicsContextGL::VERSION:</span>
603         return &quot;WebGL 1.0&quot;_str;
<span class="line-modified">604     case GraphicsContextGL::VIEWPORT:</span>
605         return getWebGLIntArrayParameter(pname);
<span class="line-modified">606     case ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES: // OES_standard_derivatives</span>
607         if (m_oesStandardDerivatives)
<span class="line-modified">608             return getUnsignedIntParameter(ExtensionsGL::FRAGMENT_SHADER_DERIVATIVE_HINT_OES);</span>
<span class="line-modified">609         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_standard_derivatives not enabled&quot;);</span>
610         return nullptr;
611     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
612         if (m_webglDebugRendererInfo) {
613 #if PLATFORM(IOS_FAMILY)
614             return &quot;Apple GPU&quot;_str;
615 #else
<span class="line-modified">616             return m_context-&gt;getString(GraphicsContextGL::RENDERER);</span>
617 #endif
618         }
<span class="line-modified">619         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
620         return nullptr;
621     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
622         if (m_webglDebugRendererInfo)
<span class="line-modified">623             return m_context-&gt;getString(GraphicsContextGL::VENDOR);</span>
<span class="line-modified">624         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);</span>
625         return nullptr;
<span class="line-modified">626     case ExtensionsGL::VERTEX_ARRAY_BINDING_OES: // OES_vertex_array_object</span>
627         if (m_oesVertexArrayObject) {
628             if (m_boundVertexArrayObject-&gt;isDefaultObject())
629                 return nullptr;
630             return makeRefPtr(static_cast&lt;WebGLVertexArrayObjectOES&amp;&gt;(*m_boundVertexArrayObject));
631         }
<span class="line-modified">632         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, OES_vertex_array_object not enabled&quot;);</span>
633         return nullptr;
<span class="line-modified">634     case ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
635         if (m_extTextureFilterAnisotropic)
<span class="line-modified">636             return getUnsignedIntParameter(ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT);</span>
<span class="line-modified">637         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
638         return nullptr;
<span class="line-modified">639     case ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT: // EXT_draw_buffers BEGIN</span>
640         if (m_webglDrawBuffers)
641             return getMaxColorAttachments();
<span class="line-modified">642         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
643         return nullptr;
<span class="line-modified">644     case ExtensionsGL::MAX_DRAW_BUFFERS_EXT:</span>
645         if (m_webglDrawBuffers)
646             return getMaxDrawBuffers();
<span class="line-modified">647         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_draw_buffers not enabled&quot;);</span>
648         return nullptr;
649     default:
650         if (m_webglDrawBuffers
<span class="line-modified">651             &amp;&amp; pname &gt;= ExtensionsGL::DRAW_BUFFER0_EXT</span>
<span class="line-modified">652             &amp;&amp; pname &lt; static_cast&lt;GCGLenum&gt;(ExtensionsGL::DRAW_BUFFER0_EXT + getMaxDrawBuffers())) {</span>
<span class="line-modified">653             GCGLint value = GraphicsContextGL::NONE;</span>
654             if (m_framebufferBinding)
655                 value = m_framebufferBinding-&gt;getDrawBuffer(pname);
656             else // emulated backbuffer
657                 value = m_backDrawBuffer;
658             return value;
659         }
<span class="line-modified">660         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);</span>
661         return nullptr;
662     }
663 }
664 
<span class="line-modified">665 GCGLint WebGLRenderingContext::getMaxDrawBuffers()</span>
666 {
667     if (!supportsDrawBuffers())
668         return 0;
669     if (!m_maxDrawBuffers)
<span class="line-modified">670         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
671     if (!m_maxColorAttachments)
<span class="line-modified">672         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
673     // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
674     return std::min(m_maxDrawBuffers, m_maxColorAttachments);
675 }
676 
<span class="line-modified">677 GCGLint WebGLRenderingContext::getMaxColorAttachments()</span>
678 {
679     if (!supportsDrawBuffers())
680         return 0;
681     if (!m_maxColorAttachments)
<span class="line-modified">682         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
683     return m_maxColorAttachments;
684 }
685 
<span class="line-modified">686 bool WebGLRenderingContext::validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired)</span>
687 {
688     // Performs conservative validation by caching a maximum index of
689     // the given type per element array buffer. If all of the bound
690     // array buffers have enough elements to satisfy that maximum
691     // index, skips the expensive per-draw-call iteration in
692     // validateIndexArrayPrecise.
693 
694     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
695 
696     if (!elementArrayBuffer)
697         return false;
698 
<span class="line-modified">699     GCGLsizeiptr numElements = elementArrayBuffer-&gt;byteLength();</span>
700     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
701     if (!numElements)
702         return false;
703     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
704     ASSERT(buffer);
705 
706     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
707     if (!maxIndex) {
708         // Compute the maximum index in the entire buffer for the given type of index.
709         switch (type) {
<span class="line-modified">710         case GraphicsContextGL::UNSIGNED_BYTE: {</span>
<span class="line-modified">711             const GCGLubyte* p = static_cast&lt;const GCGLubyte*&gt;(buffer-&gt;data());</span>
<span class="line-modified">712             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
713                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
714             break;
715         }
<span class="line-modified">716         case GraphicsContextGL::UNSIGNED_SHORT: {</span>
<span class="line-modified">717             numElements /= sizeof(GCGLushort);</span>
<span class="line-modified">718             const GCGLushort* p = static_cast&lt;const GCGLushort*&gt;(buffer-&gt;data());</span>
<span class="line-modified">719             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
720                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
721             break;
722         }
<span class="line-modified">723         case GraphicsContextGL::UNSIGNED_INT: {</span>
724             if (!m_oesElementIndexUint)
725                 return false;
<span class="line-modified">726             numElements /= sizeof(GCGLuint);</span>
<span class="line-modified">727             const GCGLuint* p = static_cast&lt;const GCGLuint*&gt;(buffer-&gt;data());</span>
<span class="line-modified">728             for (GCGLsizeiptr i = 0; i &lt; numElements; i++)</span>
729                 maxIndex = maxIndex ? std::max(maxIndex.value(), static_cast&lt;unsigned&gt;(p[i])) : static_cast&lt;unsigned&gt;(p[i]);
730             break;
731         }
732         default:
733             return false;
734         }
735         if (maxIndex)
736             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
737     }
738 
739     if (!maxIndex)
740         return false;
741 
742     // The number of required elements is one more than the maximum index that will be accessed.
743     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
744     if (!checkedNumElementsRequired)
745         return false;
746     numElementsRequired = checkedNumElementsRequired.value();
747 
748     return true;
749 }
750 
<span class="line-modified">751 bool WebGLRenderingContext::validateBlendEquation(const char* functionName, GCGLenum mode)</span>
752 {
753     switch (mode) {
<span class="line-modified">754     case GraphicsContextGL::FUNC_ADD:</span>
<span class="line-modified">755     case GraphicsContextGL::FUNC_SUBTRACT:</span>
<span class="line-modified">756     case GraphicsContextGL::FUNC_REVERSE_SUBTRACT:</span>
<span class="line-modified">757     case ExtensionsGL::MIN_EXT:</span>
<span class="line-modified">758     case ExtensionsGL::MAX_EXT:</span>
<span class="line-modified">759         if ((mode == ExtensionsGL::MIN_EXT || mode == ExtensionsGL::MAX_EXT) &amp;&amp; !m_extBlendMinMax) {</span>
<span class="line-modified">760             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
761             return false;
762         }
763         return true;
764         break;
765     default:
<span class="line-modified">766         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);</span>
767         return false;
768     }
769 }
770 
<span class="line-modified">771 bool WebGLRenderingContext::validateCapability(const char* functionName, GCGLenum cap)</span>
772 {
773     switch (cap) {
<span class="line-modified">774     case GraphicsContextGL::BLEND:</span>
<span class="line-modified">775     case GraphicsContextGL::CULL_FACE:</span>
<span class="line-modified">776     case GraphicsContextGL::DEPTH_TEST:</span>
<span class="line-modified">777     case GraphicsContextGL::DITHER:</span>
<span class="line-modified">778     case GraphicsContextGL::POLYGON_OFFSET_FILL:</span>
<span class="line-modified">779     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:</span>
<span class="line-modified">780     case GraphicsContextGL::SAMPLE_COVERAGE:</span>
<span class="line-modified">781     case GraphicsContextGL::SCISSOR_TEST:</span>
<span class="line-modified">782     case GraphicsContextGL::STENCIL_TEST:</span>
783         return true;
784     default:
<span class="line-modified">785         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid capability&quot;);</span>
786         return false;
787     }
788 }
789 
790 } // namespace WebCore
791 
792 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLRenderbuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
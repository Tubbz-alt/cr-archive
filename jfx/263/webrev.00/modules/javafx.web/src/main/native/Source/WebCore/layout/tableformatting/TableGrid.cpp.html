<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableGrid.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 namespace Layout {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(TableGrid);
 37 
 38 TableGrid::Column::Column(const Box* columnBox)
 39     : m_columnBox(makeWeakPtr(columnBox))
 40 {
 41 }
 42 
 43 void TableGrid::Column::setWidthConstraints(FormattingContext::IntrinsicWidthConstraints widthConstraints)
 44 {
 45 #if ASSERT_ENABLED
 46     m_hasWidthConstraints = true;
 47 #endif
 48     m_widthConstraints = widthConstraints;
 49 }
 50 
 51 FormattingContext::IntrinsicWidthConstraints TableGrid::Column::widthConstraints() const
 52 {
 53     ASSERT(m_hasWidthConstraints);
 54     return m_widthConstraints;
 55 }
 56 
 57 void TableGrid::Column::setLogicalWidth(LayoutUnit computedLogicalWidth)
 58 {
 59 #if ASSERT_ENABLED
 60     m_hasComputedWidth = true;
 61 #endif
 62     m_computedLogicalWidth = computedLogicalWidth;
 63 }
 64 
 65 LayoutUnit TableGrid::Column::logicalWidth() const
 66 {
 67     ASSERT(m_hasComputedWidth);
 68     return m_computedLogicalWidth;
 69 }
 70 
 71 void TableGrid::Column::setLogicalLeft(LayoutUnit computedLogicalLeft)
 72 {
 73 #if ASSERT_ENABLED
 74     m_hasComputedLeft = true;
 75 #endif
 76     m_computedLogicalLeft = computedLogicalLeft;
 77 }
 78 
 79 LayoutUnit TableGrid::Column::logicalLeft() const
 80 {
 81     ASSERT(m_hasComputedLeft);
 82     return m_computedLogicalLeft;
 83 }
 84 
 85 bool TableGrid::Column::hasFixedWidth() const
 86 {
 87     // FIXME: This only covers the &lt;col&gt; attribute case.
 88     return columnBox() &amp;&amp; columnBox()-&gt;columnWidth();
 89 }
 90 
 91 void TableGrid::ColumnsContext::addColumn(const Box* columnBox)
 92 {
 93     m_columns.append({ columnBox });
 94 }
 95 
 96 TableGrid::Row::Row(const Box&amp; rowBox)
 97     : m_layoutBox(rowBox)
 98 {
 99 }
100 
101 TableGrid::CellInfo::CellInfo(const Box&amp; tableCellBox, SlotPosition position, CellSize size)
102     : tableCellBox(tableCellBox)
103     , position(position)
104     , size(size)
105 {
106 }
107 
108 TableGrid::SlotInfo::SlotInfo(CellInfo&amp; cell)
109     : cell(makeWeakPtr(cell))
110 {
111 }
112 
113 TableGrid::TableGrid()
114 {
115 }
116 
117 TableGrid::SlotInfo* TableGrid::slot(SlotPosition position)
118 {
119     return m_slotMap.get(position);
120 }
121 
122 void TableGrid::appendCell(const Box&amp; tableCellBox)
123 {
124     int rowSpan = tableCellBox.rowSpan();
125     int columnSpan = tableCellBox.columnSpan();
126     auto isInNewRow = !tableCellBox.previousSibling();
127     auto initialSlotPosition = SlotPosition { };
128 
129     if (!m_cellList.isEmpty()) {
130         auto&amp; lastCell = m_cellList.last();
131         auto lastSlotPosition = lastCell-&gt;position;
132         // First table cell in this row?
133         if (isInNewRow)
134             initialSlotPosition = SlotPosition { 0, lastSlotPosition.y() + 1 };
135         else
136             initialSlotPosition = SlotPosition { lastSlotPosition.x() + 1, lastSlotPosition.y() };
137 
138         // Pick the next available slot by avoiding row and column spanners.
139         while (true) {
140             if (!m_slotMap.contains(initialSlotPosition))
141                 break;
142             initialSlotPosition.move(1, 0);
143         }
144     }
145     auto cellInfo = makeUnique&lt;CellInfo&gt;(tableCellBox, initialSlotPosition, CellSize { rowSpan, columnSpan });
146     // Row and column spanners create additional slots.
147     for (int row = 1; row &lt;= rowSpan; ++row) {
148         for (int column = 1; column &lt;= columnSpan; ++column) {
149             auto position = SlotPosition { initialSlotPosition.x() + row - 1, initialSlotPosition.y() + column - 1 };
150             ASSERT(!m_slotMap.contains(position));
151             m_slotMap.add(position, makeUnique&lt;SlotInfo&gt;(*cellInfo));
152         }
153     }
154     // Initialize columns/rows if needed.
155     auto missingNumberOfColumns = std::max&lt;int&gt;(0, initialSlotPosition.x() + columnSpan - m_columnsContext.columns().size());
156     for (auto column = 0; column &lt; missingNumberOfColumns; ++column)
157         m_columnsContext.addColumn();
158 
159     if (isInNewRow)
160         m_rows.append({ *tableCellBox.parent() });
161 
162     m_cellList.add(WTFMove(cellInfo));
163 }
164 
165 void TableGrid::insertCell(const Box&amp; tableCellBox, const Box&amp; before)
166 {
167     UNUSED_PARAM(tableCellBox);
168     UNUSED_PARAM(before);
169 }
170 
171 void TableGrid::removeCell(const Box&amp; tableCellBox)
172 {
173     UNUSED_PARAM(tableCellBox);
174 }
175 
176 FormattingContext::IntrinsicWidthConstraints TableGrid::widthConstraints()
177 {
178     // FIXME: Add constraint invalidation for incremental layouts.
179     if (m_intrinsicWidthConstraints)
180         return *m_intrinsicWidthConstraints;
181 
182     m_intrinsicWidthConstraints = FormattingContext::IntrinsicWidthConstraints { };
183     for (auto&amp; column : m_columnsContext.columns())
184         *m_intrinsicWidthConstraints += column.widthConstraints();
185     m_intrinsicWidthConstraints-&gt;expand(totalHorizontalSpacing());
186     return *m_intrinsicWidthConstraints;
187 }
188 
189 }
190 }
191 #endif
    </pre>
  </body>
</html>
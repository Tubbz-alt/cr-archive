<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GradientImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  55 
  56     unsigned offset() const { return m_offset; }
  57     void increment() { m_offset++; }
  58     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  59     UChar current() const { return (*m_textRun)[m_offset]; }
  60     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  61 
  62     bool operator==(const TextRunIterator&amp; other)
  63     {
  64         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  65     }
  66 
  67     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  68 
  69 private:
  70     const TextRun* m_textRun;
  71     unsigned m_offset;
  72 };
  73 
  74 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
<span class="line-modified">  75     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \</span>
<span class="line-modified">  76         changeFlags |= GraphicsContextState::flag;</span>
  77 
  78 GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  79 {
<span class="line-modified">  80     GraphicsContextState::StateChangeFlags changeFlags = GraphicsContextState::NoChange;</span>
  81 
  82     CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
  83     CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
  84     CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
  85     CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  86 
<span class="line-modified">  87     if ((m_changeFlags &amp; GraphicsContextState::ShadowChange)</span>
  88         &amp;&amp; (m_state.shadowOffset != state.shadowOffset
  89             || m_state.shadowBlur != state.shadowBlur
  90             || m_state.shadowColor != state.shadowColor))
<span class="line-modified">  91         changeFlags |= GraphicsContextState::ShadowChange;</span>
  92 
  93     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
  94     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
  95     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
  96     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
  97     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
  98     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
  99     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 100 
<span class="line-modified"> 101     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))</span>
<span class="line-modified"> 102         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))</span>
<span class="line-modified"> 103         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);</span>


 104 
 105     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 106     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 107     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 108     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 109     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 110     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 111 
 112 #if HAVE(OS_DARK_MODE_SUPPORT)
 113     CHECK_FOR_CHANGED_PROPERTY(UseDarkAppearanceChange, useDarkAppearance);
 114 #endif
 115 
 116     return changeFlags;
 117 }
 118 
 119 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 120 {
 121     // FIXME: This code should move to GraphicsContextState.
<span class="line-modified"> 122     if (flags &amp; GraphicsContextState::StrokeGradientChange)</span>
 123         m_state.strokeGradient = state.strokeGradient;
 124 
<span class="line-modified"> 125     if (flags &amp; GraphicsContextState::StrokePatternChange)</span>
 126         m_state.strokePattern = state.strokePattern;
 127 
<span class="line-modified"> 128     if (flags &amp; GraphicsContextState::FillGradientChange)</span>
 129         m_state.fillGradient = state.fillGradient;
 130 
<span class="line-modified"> 131     if (flags &amp; GraphicsContextState::FillPatternChange)</span>
 132         m_state.fillPattern = state.fillPattern;
 133 
<span class="line-modified"> 134     if (flags &amp; GraphicsContextState::ShadowChange) {</span>
 135         // FIXME: Deal with state.shadowsUseLegacyRadius.
 136         m_state.shadowOffset = state.shadowOffset;
 137         m_state.shadowBlur = state.shadowBlur;
 138         m_state.shadowColor = state.shadowColor;
 139     }
 140 
<span class="line-modified"> 141     if (flags &amp; GraphicsContextState::StrokeThicknessChange)</span>
 142         m_state.strokeThickness = state.strokeThickness;
 143 
<span class="line-modified"> 144     if (flags &amp; GraphicsContextState::TextDrawingModeChange)</span>
 145         m_state.textDrawingMode = state.textDrawingMode;
 146 
<span class="line-modified"> 147     if (flags &amp; GraphicsContextState::StrokeColorChange)</span>
 148         m_state.strokeColor = state.strokeColor;
 149 
<span class="line-modified"> 150     if (flags &amp; GraphicsContextState::FillColorChange)</span>
 151         m_state.fillColor = state.fillColor;
 152 
<span class="line-modified"> 153     if (flags &amp; GraphicsContextState::StrokeStyleChange)</span>
 154         m_state.strokeStyle = state.strokeStyle;
 155 
<span class="line-modified"> 156     if (flags &amp; GraphicsContextState::FillRuleChange)</span>
 157         m_state.fillRule = state.fillRule;
 158 
<span class="line-modified"> 159     if (flags &amp; GraphicsContextState::AlphaChange)</span>
 160         m_state.alpha = state.alpha;
 161 
<span class="line-modified"> 162     if (flags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange)) {</span>
 163         m_state.compositeOperator = state.compositeOperator;
 164         m_state.blendMode = state.blendMode;
 165     }
 166 
<span class="line-modified"> 167     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
 168         m_state.shouldAntialias = state.shouldAntialias;
 169 
<span class="line-modified"> 170     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
 171         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 172 
<span class="line-modified"> 173     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
 174         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 175 
<span class="line-modified"> 176     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
 177         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 178 
<span class="line-modified"> 179     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
 180         m_state.drawLuminanceMask = state.drawLuminanceMask;
 181 
<span class="line-modified"> 182     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)</span>
 183         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 184 
 185 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 186     if (flags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
 187         m_state.useDarkAppearance = state.useDarkAppearance;
 188 #endif
 189 
<span class="line-modified"> 190     m_changeFlags |= flags;</span>
 191 }
 192 
 193 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 194 {
<span class="line-modified"> 195     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)</span>
 196         context.setStrokeGradient(*m_state.strokeGradient);
 197 
<span class="line-modified"> 198     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)</span>
 199         context.setStrokePattern(*m_state.strokePattern);
 200 
<span class="line-modified"> 201     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)</span>
 202         context.setFillGradient(*m_state.fillGradient);
 203 
<span class="line-modified"> 204     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)</span>
 205         context.setFillPattern(*m_state.fillPattern);
 206 
<span class="line-modified"> 207     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {</span>
 208 #if USE(CG)
 209         if (m_state.shadowsUseLegacyRadius)
 210             context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 211         else
 212 #endif
 213             context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 214     }
 215 
<span class="line-modified"> 216     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)</span>
 217         context.setStrokeThickness(m_state.strokeThickness);
 218 
<span class="line-modified"> 219     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)</span>
 220         context.setTextDrawingMode(m_state.textDrawingMode);
 221 
<span class="line-modified"> 222     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)</span>
 223         context.setStrokeColor(m_state.strokeColor);
 224 
<span class="line-modified"> 225     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)</span>
 226         context.setFillColor(m_state.fillColor);
 227 
<span class="line-modified"> 228     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)</span>
 229         context.setStrokeStyle(m_state.strokeStyle);
 230 
<span class="line-modified"> 231     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)</span>
 232         context.setFillRule(m_state.fillRule);
 233 
<span class="line-modified"> 234     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)</span>
 235         context.setAlpha(m_state.alpha);
 236 
<span class="line-modified"> 237     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))</span>
 238         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 239 
<span class="line-modified"> 240     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
 241         context.setShouldAntialias(m_state.shouldAntialias);
 242 
<span class="line-modified"> 243     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
 244         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 245 
<span class="line-modified"> 246     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
 247         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 248 
<span class="line-modified"> 249     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
 250         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 251 
<span class="line-modified"> 252     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
 253         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 254 
<span class="line-modified"> 255     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)</span>
 256         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
 257 
 258 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 259     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
 260         context.setUseDarkAppearance(m_state.useDarkAppearance);
 261 #endif
 262 }
 263 
 264 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 265 {
<span class="line-modified"> 266     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);</span>
 267 
<span class="line-modified"> 268     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)</span>
 269         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 270 
<span class="line-modified"> 271     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)</span>
 272         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 273 
<span class="line-modified"> 274     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)</span>
 275         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 276 
<span class="line-modified"> 277     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)</span>
 278         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 279 
<span class="line-modified"> 280     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {</span>
 281         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
 282         ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
 283 #if USE(CG)
 284         ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
 285 #endif
 286     }
 287 
<span class="line-modified"> 288     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)</span>
 289         ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
 290 
<span class="line-modified"> 291     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)</span>
 292         ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
 293 
<span class="line-modified"> 294     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)</span>
 295         ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
 296 
<span class="line-modified"> 297     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)</span>
 298         ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
 299 
<span class="line-modified"> 300     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)</span>
 301         ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
 302 
<span class="line-modified"> 303     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)</span>
 304         ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
 305 
<span class="line-modified"> 306     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)</span>
 307         ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
 308 
<span class="line-modified"> 309     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)</span>
 310         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 311 
<span class="line-modified"> 312     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)</span>
 313         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 314 
<span class="line-modified"> 315     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
 316         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 317 
<span class="line-modified"> 318     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
 319         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 320 
<span class="line-modified"> 321     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
 322         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 323 
<span class="line-modified"> 324     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
 325         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 326 
<span class="line-modified"> 327     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
 328         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
 329 
 330 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 331     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
 332         ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);
 333 #endif
 334 }
 335 
 336 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 337 {
 338     stateChange.dump(ts);
 339     return ts;
 340 }
 341 
 342 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 343     : m_paintInvalidationReasons(paintInvalidationReasons)
 344 {
 345 }
 346 
 347 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 348 {
 349     platformInit(platformGraphicsContext);
 350 }
 351 
</pre>
<hr />
<pre>
1100 
1101     strokeEllipseAsPath(ellipse);
1102 }
1103 #endif
1104 
1105 FloatRect GraphicsContext::computeUnderlineBoundsForText(const FloatRect&amp; rect, bool printing)
1106 {
1107     Color dummyColor;
1108     return computeLineBoundsAndAntialiasingModeForText(rect, printing, dummyColor);
1109 }
1110 
1111 FloatRect GraphicsContext::computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp; rect, bool printing, Color&amp; color)
1112 {
1113     FloatPoint origin = rect.location();
1114     float thickness = std::max(rect.height(), 0.5f);
1115     if (printing)
1116         return FloatRect(origin, FloatSize(rect.width(), thickness));
1117 
1118     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1119     // Just compute scale in x dimension, assuming x and y scales are equal.
<span class="line-modified">1120     float scale = transform.b() ? sqrtf(transform.a() * transform.a() + transform.b() * transform.b()) : transform.a();</span>
1121     if (scale &lt; 1.0) {
1122         // This code always draws a line that is at least one-pixel line high,
1123         // which tends to visually overwhelm text at small scales. To counter this
1124         // effect, an alpha is applied to the underline color when text is at small scales.
1125         static const float minimumUnderlineAlpha = 0.4f;
1126         float shade = scale &gt; minimumUnderlineAlpha ? scale : minimumUnderlineAlpha;
1127         color = color.colorWithAlphaMultipliedBy(shade);
1128     }
1129 
1130     FloatPoint devicePoint = transform.mapPoint(rect.location());
1131     // Visual overflow might occur here due to integral roundf/ceilf. visualOverflowForDecorations adjusts the overflow value for underline decoration.
1132     FloatPoint deviceOrigin = FloatPoint(roundf(devicePoint.x()), ceilf(devicePoint.y()));
1133     if (auto inverse = transform.inverse())
1134         origin = inverse.value().mapPoint(deviceOrigin);
1135     return FloatRect(origin, FloatSize(rect.width(), thickness));
1136 }
1137 
<span class="line-modified">1138 void GraphicsContext::applyState(const GraphicsContextState&amp; state)</span>
1139 {
1140     setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
1141     setPlatformStrokeThickness(state.strokeThickness);
1142     setPlatformTextDrawingMode(state.textDrawingMode);
1143     setPlatformStrokeColor(state.strokeColor);
1144     setPlatformFillColor(state.fillColor);
1145     setPlatformStrokeStyle(state.strokeStyle);
1146     setPlatformAlpha(state.alpha);
1147     setPlatformCompositeOperation(state.compositeOperator, state.blendMode);
1148     setPlatformShouldAntialias(state.shouldAntialias);
1149     setPlatformShouldSmoothFonts(state.shouldSmoothFonts);
1150 }
1151 
1152 float GraphicsContext::dashedLineCornerWidthForStrokeWidth(float strokeWidth) const
1153 {
1154     float thickness = strokeThickness();
1155     return strokeStyle() == DottedStroke ? thickness : std::min(2.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1156 }
1157 
1158 float GraphicsContext::dashedLinePatternWidthForStrokeWidth(float strokeWidth) const
</pre>
</td>
<td>
<hr />
<pre>
  55 
  56     unsigned offset() const { return m_offset; }
  57     void increment() { m_offset++; }
  58     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  59     UChar current() const { return (*m_textRun)[m_offset]; }
  60     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  61 
  62     bool operator==(const TextRunIterator&amp; other)
  63     {
  64         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  65     }
  66 
  67     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  68 
  69 private:
  70     const TextRun* m_textRun;
  71     unsigned m_offset;
  72 };
  73 
  74 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
<span class="line-modified">  75     if (m_changeFlags.contains(GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \</span>
<span class="line-modified">  76         changeFlags.add(GraphicsContextState::flag);</span>
  77 
  78 GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  79 {
<span class="line-modified">  80     GraphicsContextState::StateChangeFlags changeFlags;</span>
  81 
  82     CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
  83     CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
  84     CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
  85     CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  86 
<span class="line-modified">  87     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)</span>
  88         &amp;&amp; (m_state.shadowOffset != state.shadowOffset
  89             || m_state.shadowBlur != state.shadowBlur
  90             || m_state.shadowColor != state.shadowColor))
<span class="line-modified">  91         changeFlags.add(GraphicsContextState::ShadowChange);</span>
  92 
  93     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
  94     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
  95     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
  96     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
  97     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
  98     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
  99     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 100 
<span class="line-modified"> 101     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })</span>
<span class="line-modified"> 102         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode)) {</span>
<span class="line-modified"> 103         changeFlags.add(GraphicsContextState::CompositeOperationChange);</span>
<span class="line-added"> 104         changeFlags.add(GraphicsContextState::BlendModeChange);</span>
<span class="line-added"> 105     }</span>
 106 
 107     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 108     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 109     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 110     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 111     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 112     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 113 
 114 #if HAVE(OS_DARK_MODE_SUPPORT)
 115     CHECK_FOR_CHANGED_PROPERTY(UseDarkAppearanceChange, useDarkAppearance);
 116 #endif
 117 
 118     return changeFlags;
 119 }
 120 
 121 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 122 {
 123     // FIXME: This code should move to GraphicsContextState.
<span class="line-modified"> 124     if (flags.contains(GraphicsContextState::StrokeGradientChange))</span>
 125         m_state.strokeGradient = state.strokeGradient;
 126 
<span class="line-modified"> 127     if (flags.contains(GraphicsContextState::StrokePatternChange))</span>
 128         m_state.strokePattern = state.strokePattern;
 129 
<span class="line-modified"> 130     if (flags.contains(GraphicsContextState::FillGradientChange))</span>
 131         m_state.fillGradient = state.fillGradient;
 132 
<span class="line-modified"> 133     if (flags.contains(GraphicsContextState::FillPatternChange))</span>
 134         m_state.fillPattern = state.fillPattern;
 135 
<span class="line-modified"> 136     if (flags.contains(GraphicsContextState::ShadowChange)) {</span>
 137         // FIXME: Deal with state.shadowsUseLegacyRadius.
 138         m_state.shadowOffset = state.shadowOffset;
 139         m_state.shadowBlur = state.shadowBlur;
 140         m_state.shadowColor = state.shadowColor;
 141     }
 142 
<span class="line-modified"> 143     if (flags.contains(GraphicsContextState::StrokeThicknessChange))</span>
 144         m_state.strokeThickness = state.strokeThickness;
 145 
<span class="line-modified"> 146     if (flags.contains(GraphicsContextState::TextDrawingModeChange))</span>
 147         m_state.textDrawingMode = state.textDrawingMode;
 148 
<span class="line-modified"> 149     if (flags.contains(GraphicsContextState::StrokeColorChange))</span>
 150         m_state.strokeColor = state.strokeColor;
 151 
<span class="line-modified"> 152     if (flags.contains(GraphicsContextState::FillColorChange))</span>
 153         m_state.fillColor = state.fillColor;
 154 
<span class="line-modified"> 155     if (flags.contains(GraphicsContextState::StrokeStyleChange))</span>
 156         m_state.strokeStyle = state.strokeStyle;
 157 
<span class="line-modified"> 158     if (flags.contains(GraphicsContextState::FillRuleChange))</span>
 159         m_state.fillRule = state.fillRule;
 160 
<span class="line-modified"> 161     if (flags.contains(GraphicsContextState::AlphaChange))</span>
 162         m_state.alpha = state.alpha;
 163 
<span class="line-modified"> 164     if (flags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })) {</span>
 165         m_state.compositeOperator = state.compositeOperator;
 166         m_state.blendMode = state.blendMode;
 167     }
 168 
<span class="line-modified"> 169     if (flags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
 170         m_state.shouldAntialias = state.shouldAntialias;
 171 
<span class="line-modified"> 172     if (flags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
 173         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 174 
<span class="line-modified"> 175     if (flags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
 176         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 177 
<span class="line-modified"> 178     if (flags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
 179         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 180 
<span class="line-modified"> 181     if (flags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
 182         m_state.drawLuminanceMask = state.drawLuminanceMask;
 183 
<span class="line-modified"> 184     if (flags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
 185         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 186 
 187 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 188     if (flags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
 189         m_state.useDarkAppearance = state.useDarkAppearance;
 190 #endif
 191 
<span class="line-modified"> 192     m_changeFlags.add(flags);</span>
 193 }
 194 
 195 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 196 {
<span class="line-modified"> 197     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))</span>
 198         context.setStrokeGradient(*m_state.strokeGradient);
 199 
<span class="line-modified"> 200     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))</span>
 201         context.setStrokePattern(*m_state.strokePattern);
 202 
<span class="line-modified"> 203     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))</span>
 204         context.setFillGradient(*m_state.fillGradient);
 205 
<span class="line-modified"> 206     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))</span>
 207         context.setFillPattern(*m_state.fillPattern);
 208 
<span class="line-modified"> 209     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
 210 #if USE(CG)
 211         if (m_state.shadowsUseLegacyRadius)
 212             context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 213         else
 214 #endif
 215             context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 216     }
 217 
<span class="line-modified"> 218     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
 219         context.setStrokeThickness(m_state.strokeThickness);
 220 
<span class="line-modified"> 221     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
 222         context.setTextDrawingMode(m_state.textDrawingMode);
 223 
<span class="line-modified"> 224     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
 225         context.setStrokeColor(m_state.strokeColor);
 226 
<span class="line-modified"> 227     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))</span>
 228         context.setFillColor(m_state.fillColor);
 229 
<span class="line-modified"> 230     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
 231         context.setStrokeStyle(m_state.strokeStyle);
 232 
<span class="line-modified"> 233     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
 234         context.setFillRule(m_state.fillRule);
 235 
<span class="line-modified"> 236     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))</span>
 237         context.setAlpha(m_state.alpha);
 238 
<span class="line-modified"> 239     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange }))</span>
 240         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 241 
<span class="line-modified"> 242     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
 243         context.setShouldAntialias(m_state.shouldAntialias);
 244 
<span class="line-modified"> 245     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
 246         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 247 
<span class="line-modified"> 248     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
 249         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 250 
<span class="line-modified"> 251     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
 252         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 253 
<span class="line-modified"> 254     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
 255         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 256 
<span class="line-modified"> 257     if (m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
 258         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
 259 
 260 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 261     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
 262         context.setUseDarkAppearance(m_state.useDarkAppearance);
 263 #endif
 264 }
 265 
 266 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 267 {
<span class="line-modified"> 268     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags.toRaw());</span>
 269 
<span class="line-modified"> 270     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))</span>
 271         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 272 
<span class="line-modified"> 273     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))</span>
 274         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 275 
<span class="line-modified"> 276     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))</span>
 277         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 278 
<span class="line-modified"> 279     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))</span>
 280         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 281 
<span class="line-modified"> 282     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
 283         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
 284         ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
 285 #if USE(CG)
 286         ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
 287 #endif
 288     }
 289 
<span class="line-modified"> 290     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
 291         ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
 292 
<span class="line-modified"> 293     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
 294         ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
 295 
<span class="line-modified"> 296     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
 297         ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
 298 
<span class="line-modified"> 299     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))</span>
 300         ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
 301 
<span class="line-modified"> 302     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
 303         ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
 304 
<span class="line-modified"> 305     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
 306         ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
 307 
<span class="line-modified"> 308     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))</span>
 309         ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
 310 
<span class="line-modified"> 311     if (m_changeFlags.contains(GraphicsContextState::CompositeOperationChange))</span>
 312         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 313 
<span class="line-modified"> 314     if (m_changeFlags.contains(GraphicsContextState::BlendModeChange))</span>
 315         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 316 
<span class="line-modified"> 317     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
 318         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 319 
<span class="line-modified"> 320     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
 321         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 322 
<span class="line-modified"> 323     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
 324         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 325 
<span class="line-modified"> 326     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
 327         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 328 
<span class="line-modified"> 329     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
 330         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
 331 
 332 #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified"> 333     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
 334         ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);
 335 #endif
 336 }
 337 
 338 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 339 {
 340     stateChange.dump(ts);
 341     return ts;
 342 }
 343 
 344 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 345     : m_paintInvalidationReasons(paintInvalidationReasons)
 346 {
 347 }
 348 
 349 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 350 {
 351     platformInit(platformGraphicsContext);
 352 }
 353 
</pre>
<hr />
<pre>
1102 
1103     strokeEllipseAsPath(ellipse);
1104 }
1105 #endif
1106 
1107 FloatRect GraphicsContext::computeUnderlineBoundsForText(const FloatRect&amp; rect, bool printing)
1108 {
1109     Color dummyColor;
1110     return computeLineBoundsAndAntialiasingModeForText(rect, printing, dummyColor);
1111 }
1112 
1113 FloatRect GraphicsContext::computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp; rect, bool printing, Color&amp; color)
1114 {
1115     FloatPoint origin = rect.location();
1116     float thickness = std::max(rect.height(), 0.5f);
1117     if (printing)
1118         return FloatRect(origin, FloatSize(rect.width(), thickness));
1119 
1120     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1121     // Just compute scale in x dimension, assuming x and y scales are equal.
<span class="line-modified">1122     float scale = transform.b() ? std::hypot(transform.a(), transform.b()) : transform.a();</span>
1123     if (scale &lt; 1.0) {
1124         // This code always draws a line that is at least one-pixel line high,
1125         // which tends to visually overwhelm text at small scales. To counter this
1126         // effect, an alpha is applied to the underline color when text is at small scales.
1127         static const float minimumUnderlineAlpha = 0.4f;
1128         float shade = scale &gt; minimumUnderlineAlpha ? scale : minimumUnderlineAlpha;
1129         color = color.colorWithAlphaMultipliedBy(shade);
1130     }
1131 
1132     FloatPoint devicePoint = transform.mapPoint(rect.location());
1133     // Visual overflow might occur here due to integral roundf/ceilf. visualOverflowForDecorations adjusts the overflow value for underline decoration.
1134     FloatPoint deviceOrigin = FloatPoint(roundf(devicePoint.x()), ceilf(devicePoint.y()));
1135     if (auto inverse = transform.inverse())
1136         origin = inverse.value().mapPoint(deviceOrigin);
1137     return FloatRect(origin, FloatSize(rect.width(), thickness));
1138 }
1139 
<span class="line-modified">1140 void GraphicsContext::builderState(const GraphicsContextState&amp; state)</span>
1141 {
1142     setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
1143     setPlatformStrokeThickness(state.strokeThickness);
1144     setPlatformTextDrawingMode(state.textDrawingMode);
1145     setPlatformStrokeColor(state.strokeColor);
1146     setPlatformFillColor(state.fillColor);
1147     setPlatformStrokeStyle(state.strokeStyle);
1148     setPlatformAlpha(state.alpha);
1149     setPlatformCompositeOperation(state.compositeOperator, state.blendMode);
1150     setPlatformShouldAntialias(state.shouldAntialias);
1151     setPlatformShouldSmoothFonts(state.shouldSmoothFonts);
1152 }
1153 
1154 float GraphicsContext::dashedLineCornerWidthForStrokeWidth(float strokeWidth) const
1155 {
1156     float thickness = strokeThickness();
1157     return strokeStyle() == DottedStroke ? thickness : std::min(2.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1158 }
1159 
1160 float GraphicsContext::dashedLinePatternWidthForStrokeWidth(float strokeWidth) const
</pre>
</td>
</tr>
</table>
<center><a href="GradientImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
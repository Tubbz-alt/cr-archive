<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/contentextensions/ContentExtensionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ContentExtensionCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentExtensionsBackend.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/contentextensions/ContentExtensionParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #include &lt;JavaScriptCore/JSONObject.h&gt;
 40 #include &lt;JavaScriptCore/VM.h&gt;
 41 #include &lt;wtf/Expected.h&gt;
 42 #include &lt;wtf/text/WTFString.h&gt;
 43 
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 namespace ContentExtensions {
 49 
 50 static bool containsOnlyASCIIWithNoUppercase(const String&amp; domain)
 51 {
 52     for (auto character : StringView { domain }.codeUnits()) {
 53         if (!isASCII(character) || isASCIIUpper(character))
 54             return false;
 55     }
 56     return true;
 57 }
 58 
<span class="line-modified"> 59 static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getStringList(ExecState&amp; exec, const JSObject* arrayObject)</span>
 60 {
 61     static const ContentExtensionError error = ContentExtensionError::JSONInvalidConditionList;
<span class="line-modified"> 62     VM&amp; vm = exec.vm();</span>
 63     auto scope = DECLARE_THROW_SCOPE(vm);
 64 
 65     if (!arrayObject || !isJSArray(arrayObject))
 66         return makeUnexpected(error);
 67     const JSArray* array = jsCast&lt;const JSArray*&gt;(arrayObject);
 68 
 69     Vector&lt;String&gt; strings;
 70     unsigned length = array-&gt;length();
 71     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 72         const JSValue value = array-&gt;getIndex(&amp;exec, i);</span>
 73         if (scope.exception() || !value.isString())
 74             return makeUnexpected(error);
 75 
<span class="line-modified"> 76         const String&amp; string = asString(value)-&gt;value(&amp;exec);</span>
 77         if (string.isEmpty())
 78             return makeUnexpected(error);
 79         strings.append(string);
 80     }
 81     return strings;
 82 }
 83 
<span class="line-modified"> 84 static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getDomainList(ExecState&amp; exec, const JSObject* arrayObject)</span>
 85 {
<span class="line-modified"> 86     auto strings = getStringList(exec, arrayObject);</span>
 87     if (!strings.has_value())
 88         return strings;
 89     for (auto&amp; domain : strings.value()) {
 90         // Domains should be punycode encoded lower case.
 91         if (!containsOnlyASCIIWithNoUppercase(domain))
 92             return makeUnexpected(ContentExtensionError::JSONDomainNotLowerCaseASCII);
 93     }
 94     return strings;
 95 }
 96 
<span class="line-modified"> 97 static std::error_code getTypeFlags(ExecState&amp; exec, const JSValue&amp; typeValue, ResourceFlags&amp; flags, uint16_t (*stringToType)(const String&amp;))</span>
 98 {
<span class="line-modified"> 99     VM&amp; vm = exec.vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101 
102     if (!typeValue.isObject())
103         return { };
104 
<span class="line-modified">105     const JSObject* object = typeValue.toObject(&amp;exec);</span>
106     scope.assertNoException();
107     if (!isJSArray(object))
108         return ContentExtensionError::JSONInvalidTriggerFlagsArray;
109 
110     const JSArray* array = jsCast&lt;const JSArray*&gt;(object);
111 
112     unsigned length = array-&gt;length();
113     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">114         const JSValue value = array-&gt;getIndex(&amp;exec, i);</span>
115         if (scope.exception() || !value)
116             return ContentExtensionError::JSONInvalidObjectInTriggerFlagsArray;
117 
<span class="line-modified">118         String name = value.toWTFString(&amp;exec);</span>
119         uint16_t type = stringToType(name);
120         if (!type)
121             return ContentExtensionError::JSONInvalidStringInTriggerFlagsArray;
122 
123         flags |= type;
124     }
125 
126     return { };
127 }
128 
<span class="line-modified">129 static Expected&lt;Trigger, std::error_code&gt; loadTrigger(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
130 {
<span class="line-modified">131     VM&amp; vm = exec.vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
<span class="line-modified">134     const JSValue triggerObject = ruleObject.get(&amp;exec, Identifier::fromString(vm, &quot;trigger&quot;));</span>
135     if (!triggerObject || scope.exception() || !triggerObject.isObject())
136         return makeUnexpected(ContentExtensionError::JSONInvalidTrigger);
137 
<span class="line-modified">138     const JSValue urlFilterObject = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;url-filter&quot;));</span>
139     if (!urlFilterObject || scope.exception() || !urlFilterObject.isString())
140         return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
141 
<span class="line-modified">142     String urlFilter = asString(urlFilterObject)-&gt;value(&amp;exec);</span>
143     if (urlFilter.isEmpty())
144         return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
145 
146     Trigger trigger;
147     trigger.urlFilter = urlFilter;
148 
<span class="line-modified">149     const JSValue urlFilterCaseValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;url-filter-is-case-sensitive&quot;));</span>
150     if (urlFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; urlFilterCaseValue.isBoolean())
<span class="line-modified">151         trigger.urlFilterIsCaseSensitive = urlFilterCaseValue.toBoolean(&amp;exec);</span>
152 
<span class="line-modified">153     const JSValue topURLFilterCaseValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;top-url-filter-is-case-sensitive&quot;));</span>
154     if (topURLFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; topURLFilterCaseValue.isBoolean())
<span class="line-modified">155         trigger.topURLConditionIsCaseSensitive = topURLFilterCaseValue.toBoolean(&amp;exec);</span>
156 
<span class="line-modified">157     const JSValue resourceTypeValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;resource-type&quot;));</span>
158     if (!scope.exception() &amp;&amp; resourceTypeValue.isObject()) {
<span class="line-modified">159         auto typeFlagsError = getTypeFlags(exec, resourceTypeValue, trigger.flags, readResourceType);</span>
160         if (typeFlagsError)
161             return makeUnexpected(typeFlagsError);
162     } else if (!resourceTypeValue.isUndefined())
163         return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
164 
<span class="line-modified">165     const JSValue loadTypeValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;load-type&quot;));</span>
166     if (!scope.exception() &amp;&amp; loadTypeValue.isObject()) {
<span class="line-modified">167         auto typeFlagsError = getTypeFlags(exec, loadTypeValue, trigger.flags, readLoadType);</span>
168         if (typeFlagsError)
169             return makeUnexpected(typeFlagsError);
170     } else if (!loadTypeValue.isUndefined())
171         return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
172 
<span class="line-modified">173     const JSValue ifDomainValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;if-domain&quot;));</span>
174     if (!scope.exception() &amp;&amp; ifDomainValue.isObject()) {
<span class="line-modified">175         auto ifDomain = getDomainList(exec, asObject(ifDomainValue));</span>
176         if (!ifDomain.has_value())
177             return makeUnexpected(ifDomain.error());
178         trigger.conditions = WTFMove(ifDomain.value());
179         if (trigger.conditions.isEmpty())
180             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
181         ASSERT(trigger.conditionType == Trigger::ConditionType::None);
182         trigger.conditionType = Trigger::ConditionType::IfDomain;
183     } else if (!ifDomainValue.isUndefined())
184         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
185 
<span class="line-modified">186     const JSValue unlessDomainValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;unless-domain&quot;));</span>
187     if (!scope.exception() &amp;&amp; unlessDomainValue.isObject()) {
188         if (trigger.conditionType != Trigger::ConditionType::None)
189             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">190         auto unlessDomain = getDomainList(exec, asObject(unlessDomainValue));</span>
191         if (!unlessDomain.has_value())
192             return makeUnexpected(unlessDomain.error());
193         trigger.conditions = WTFMove(unlessDomain.value());
194         if (trigger.conditions.isEmpty())
195             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
196         trigger.conditionType = Trigger::ConditionType::UnlessDomain;
197     } else if (!unlessDomainValue.isUndefined())
198         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
199 
<span class="line-modified">200     const JSValue ifTopURLValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;if-top-url&quot;));</span>
201     if (!scope.exception() &amp;&amp; ifTopURLValue.isObject()) {
202         if (trigger.conditionType != Trigger::ConditionType::None)
203             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">204         auto ifTopURL = getStringList(exec, asObject(ifTopURLValue));</span>
205         if (!ifTopURL.has_value())
206             return makeUnexpected(ifTopURL.error());
207         trigger.conditions = WTFMove(ifTopURL.value());
208         if (trigger.conditions.isEmpty())
209             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
210         trigger.conditionType = Trigger::ConditionType::IfTopURL;
211     } else if (!ifTopURLValue.isUndefined())
212         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
213 
<span class="line-modified">214     const JSValue unlessTopURLValue = triggerObject.get(&amp;exec, Identifier::fromString(vm, &quot;unless-top-url&quot;));</span>
215     if (!scope.exception() &amp;&amp; unlessTopURLValue.isObject()) {
216         if (trigger.conditionType != Trigger::ConditionType::None)
217             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">218         auto unlessTopURL = getStringList(exec, asObject(unlessTopURLValue));</span>
219         if (!unlessTopURL.has_value())
220             return makeUnexpected(unlessTopURL.error());
221         trigger.conditions = WTFMove(unlessTopURL.value());
222         if (trigger.conditions.isEmpty())
223             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
224         trigger.conditionType = Trigger::ConditionType::UnlessTopURL;
225     } else if (!unlessTopURLValue.isUndefined())
226         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
227 
228     return trigger;
229 }
230 
231 bool isValidCSSSelector(const String&amp; selector)
232 {
233     ASSERT(isMainThread());
234     AtomString::init();
235     QualifiedName::init();
236     CSSParserContext context(HTMLQuirksMode);
237     CSSParser parser(context);
238     CSSSelectorList selectorList;
239     parser.parseSelector(selector, selectorList);
240     return selectorList.isValid();
241 }
242 
<span class="line-modified">243 static Expected&lt;Optional&lt;Action&gt;, std::error_code&gt; loadAction(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
244 {
<span class="line-modified">245     VM&amp; vm = exec.vm();</span>
246     auto scope = DECLARE_THROW_SCOPE(vm);
247 
<span class="line-modified">248     const JSValue actionObject = ruleObject.get(&amp;exec, Identifier::fromString(vm, &quot;action&quot;));</span>
249     if (scope.exception() || !actionObject.isObject())
250         return makeUnexpected(ContentExtensionError::JSONInvalidAction);
251 
<span class="line-modified">252     const JSValue typeObject = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;type&quot;));</span>
253     if (scope.exception() || !typeObject.isString())
254         return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
255 
<span class="line-modified">256     String actionType = asString(typeObject)-&gt;value(&amp;exec);</span>
257 
258     if (actionType == &quot;block&quot;)
259         return { Action(ActionType::BlockLoad) };
260     if (actionType == &quot;ignore-previous-rules&quot;)
261         return { Action(ActionType::IgnorePreviousRules) };
262     if (actionType == &quot;block-cookies&quot;)
263         return { Action(ActionType::BlockCookies) };
264     if (actionType == &quot;css-display-none&quot;) {
<span class="line-modified">265         JSValue selector = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;selector&quot;));</span>
266         if (scope.exception() || !selector.isString())
267             return makeUnexpected(ContentExtensionError::JSONInvalidCSSDisplayNoneActionType);
268 
<span class="line-modified">269         String selectorString = asString(selector)-&gt;value(&amp;exec);</span>
270         if (!isValidCSSSelector(selectorString)) {
271             // Skip rules with invalid selectors to be backwards-compatible.
272             return { WTF::nullopt };
273         }
274         return { Action(ActionType::CSSDisplayNoneSelector, selectorString) };
275     }
276     if (actionType == &quot;make-https&quot;)
277         return { Action(ActionType::MakeHTTPS) };
278     if (actionType == &quot;notify&quot;) {
<span class="line-modified">279         JSValue notification = actionObject.get(&amp;exec, Identifier::fromString(vm, &quot;notification&quot;));</span>
280         if (scope.exception() || !notification.isString())
281             return makeUnexpected(ContentExtensionError::JSONInvalidNotification);
<span class="line-modified">282         return { Action(ActionType::Notify, asString(notification)-&gt;value(&amp;exec)) };</span>
283     }
284     return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
285 }
286 
<span class="line-modified">287 static Expected&lt;Optional&lt;ContentExtensionRule&gt;, std::error_code&gt; loadRule(ExecState&amp; exec, const JSObject&amp; ruleObject)</span>
288 {
<span class="line-modified">289     auto trigger = loadTrigger(exec, ruleObject);</span>
290     if (!trigger.has_value())
291         return makeUnexpected(trigger.error());
292 
<span class="line-modified">293     auto action = loadAction(exec, ruleObject);</span>
294     if (!action.has_value())
295         return makeUnexpected(action.error());
296 
297     if (action.value())
298         return {{{ WTFMove(trigger.value()), WTFMove(action.value().value()) }}};
299 
300     return { WTF::nullopt };
301 }
302 
<span class="line-modified">303 static Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; loadEncodedRules(ExecState&amp; exec, const String&amp; ruleJSON)</span>
304 {
<span class="line-modified">305     VM&amp; vm = exec.vm();</span>
306     auto scope = DECLARE_THROW_SCOPE(vm);
307 
308     // FIXME: JSONParse should require callbacks instead of an ExecState.
<span class="line-modified">309     const JSValue decodedRules = JSONParse(&amp;exec, ruleJSON);</span>
310 
311     if (scope.exception() || !decodedRules)
312         return makeUnexpected(ContentExtensionError::JSONInvalid);
313 
314     if (!decodedRules.isObject())
315         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
316 
<span class="line-modified">317     const JSObject* topLevelObject = decodedRules.toObject(&amp;exec);</span>
318     if (!topLevelObject || scope.exception())
319         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
320 
321     if (!isJSArray(topLevelObject))
322         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnArray);
323 
324     const JSArray* topLevelArray = jsCast&lt;const JSArray*&gt;(topLevelObject);
325 
326     Vector&lt;ContentExtensionRule&gt; ruleList;
327 
328     unsigned length = topLevelArray-&gt;length();
329     const unsigned maxRuleCount = 50000;
330     if (length &gt; maxRuleCount)
331         return makeUnexpected(ContentExtensionError::JSONTooManyRules);
332     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">333         const JSValue value = topLevelArray-&gt;getIndex(&amp;exec, i);</span>
334         if (scope.exception() || !value)
335             return makeUnexpected(ContentExtensionError::JSONInvalidObjectInTopLevelArray);
336 
<span class="line-modified">337         const JSObject* ruleObject = value.toObject(&amp;exec);</span>
338         if (!ruleObject || scope.exception())
339             return makeUnexpected(ContentExtensionError::JSONInvalidRule);
340 
<span class="line-modified">341         auto rule = loadRule(exec, *ruleObject);</span>
342         if (!rule.has_value())
343             return makeUnexpected(rule.error());
344         if (rule.value())
345             ruleList.append(WTFMove(*rule.value()));
346     }
347 
348     return ruleList;
349 }
350 
351 Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; parseRuleList(const String&amp; ruleJSON)
352 {
353 #if CONTENT_EXTENSIONS_PERFORMANCE_REPORTING
354     MonotonicTime loadExtensionStartTime = MonotonicTime::now();
355 #endif
356     RefPtr&lt;VM&gt; vm = VM::create();
357 
358     JSLockHolder locker(vm.get());
359     JSGlobalObject* globalObject = JSGlobalObject::create(*vm, JSGlobalObject::createStructure(*vm, jsNull()));
360 
<span class="line-modified">361     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-modified">362     auto ruleList = loadEncodedRules(*exec, ruleJSON);</span>
363 
364     vm = nullptr;
365 
366     if (!ruleList.has_value())
367         return makeUnexpected(ruleList.error());
368 
369     if (ruleList-&gt;isEmpty())
370         return makeUnexpected(ContentExtensionError::JSONContainsNoRules);
371 
372 #if CONTENT_EXTENSIONS_PERFORMANCE_REPORTING
373     MonotonicTime loadExtensionEndTime = MonotonicTime::now();
374     dataLogF(&quot;Time spent loading extension %f\n&quot;, (loadExtensionEndTime - loadExtensionStartTime).seconds());
375 #endif
376 
377     return ruleList;
378 }
379 
380 } // namespace ContentExtensions
381 } // namespace WebCore
382 
</pre>
</td>
<td>
<hr />
<pre>
 39 #include &lt;JavaScriptCore/JSONObject.h&gt;
 40 #include &lt;JavaScriptCore/VM.h&gt;
 41 #include &lt;wtf/Expected.h&gt;
 42 #include &lt;wtf/text/WTFString.h&gt;
 43 
 44 
 45 namespace WebCore {
 46 using namespace JSC;
 47 
 48 namespace ContentExtensions {
 49 
 50 static bool containsOnlyASCIIWithNoUppercase(const String&amp; domain)
 51 {
 52     for (auto character : StringView { domain }.codeUnits()) {
 53         if (!isASCII(character) || isASCIIUpper(character))
 54             return false;
 55     }
 56     return true;
 57 }
 58 
<span class="line-modified"> 59 static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getStringList(JSGlobalObject&amp; lexicalGlobalObject, const JSObject* arrayObject)</span>
 60 {
 61     static const ContentExtensionError error = ContentExtensionError::JSONInvalidConditionList;
<span class="line-modified"> 62     VM&amp; vm = lexicalGlobalObject.vm();</span>
 63     auto scope = DECLARE_THROW_SCOPE(vm);
 64 
 65     if (!arrayObject || !isJSArray(arrayObject))
 66         return makeUnexpected(error);
 67     const JSArray* array = jsCast&lt;const JSArray*&gt;(arrayObject);
 68 
 69     Vector&lt;String&gt; strings;
 70     unsigned length = array-&gt;length();
 71     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 72         const JSValue value = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
 73         if (scope.exception() || !value.isString())
 74             return makeUnexpected(error);
 75 
<span class="line-modified"> 76         const String&amp; string = asString(value)-&gt;value(&amp;lexicalGlobalObject);</span>
 77         if (string.isEmpty())
 78             return makeUnexpected(error);
 79         strings.append(string);
 80     }
 81     return strings;
 82 }
 83 
<span class="line-modified"> 84 static Expected&lt;Vector&lt;String&gt;, std::error_code&gt; getDomainList(JSGlobalObject&amp; lexicalGlobalObject, const JSObject* arrayObject)</span>
 85 {
<span class="line-modified"> 86     auto strings = getStringList(lexicalGlobalObject, arrayObject);</span>
 87     if (!strings.has_value())
 88         return strings;
 89     for (auto&amp; domain : strings.value()) {
 90         // Domains should be punycode encoded lower case.
 91         if (!containsOnlyASCIIWithNoUppercase(domain))
 92             return makeUnexpected(ContentExtensionError::JSONDomainNotLowerCaseASCII);
 93     }
 94     return strings;
 95 }
 96 
<span class="line-modified"> 97 static std::error_code getTypeFlags(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; typeValue, ResourceFlags&amp; flags, uint16_t (*stringToType)(const String&amp;))</span>
 98 {
<span class="line-modified"> 99     VM&amp; vm = lexicalGlobalObject.vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101 
102     if (!typeValue.isObject())
103         return { };
104 
<span class="line-modified">105     const JSObject* object = typeValue.toObject(&amp;lexicalGlobalObject);</span>
106     scope.assertNoException();
107     if (!isJSArray(object))
108         return ContentExtensionError::JSONInvalidTriggerFlagsArray;
109 
110     const JSArray* array = jsCast&lt;const JSArray*&gt;(object);
111 
112     unsigned length = array-&gt;length();
113     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">114         const JSValue value = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
115         if (scope.exception() || !value)
116             return ContentExtensionError::JSONInvalidObjectInTriggerFlagsArray;
117 
<span class="line-modified">118         String name = value.toWTFString(&amp;lexicalGlobalObject);</span>
119         uint16_t type = stringToType(name);
120         if (!type)
121             return ContentExtensionError::JSONInvalidStringInTriggerFlagsArray;
122 
123         flags |= type;
124     }
125 
126     return { };
127 }
128 
<span class="line-modified">129 static Expected&lt;Trigger, std::error_code&gt; loadTrigger(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
130 {
<span class="line-modified">131     VM&amp; vm = lexicalGlobalObject.vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
<span class="line-modified">134     const JSValue triggerObject = ruleObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;trigger&quot;));</span>
135     if (!triggerObject || scope.exception() || !triggerObject.isObject())
136         return makeUnexpected(ContentExtensionError::JSONInvalidTrigger);
137 
<span class="line-modified">138     const JSValue urlFilterObject = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;url-filter&quot;));</span>
139     if (!urlFilterObject || scope.exception() || !urlFilterObject.isString())
140         return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
141 
<span class="line-modified">142     String urlFilter = asString(urlFilterObject)-&gt;value(&amp;lexicalGlobalObject);</span>
143     if (urlFilter.isEmpty())
144         return makeUnexpected(ContentExtensionError::JSONInvalidURLFilterInTrigger);
145 
146     Trigger trigger;
147     trigger.urlFilter = urlFilter;
148 
<span class="line-modified">149     const JSValue urlFilterCaseValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;url-filter-is-case-sensitive&quot;));</span>
150     if (urlFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; urlFilterCaseValue.isBoolean())
<span class="line-modified">151         trigger.urlFilterIsCaseSensitive = urlFilterCaseValue.toBoolean(&amp;lexicalGlobalObject);</span>
152 
<span class="line-modified">153     const JSValue topURLFilterCaseValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;top-url-filter-is-case-sensitive&quot;));</span>
154     if (topURLFilterCaseValue &amp;&amp; !scope.exception() &amp;&amp; topURLFilterCaseValue.isBoolean())
<span class="line-modified">155         trigger.topURLConditionIsCaseSensitive = topURLFilterCaseValue.toBoolean(&amp;lexicalGlobalObject);</span>
156 
<span class="line-modified">157     const JSValue resourceTypeValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;resource-type&quot;));</span>
158     if (!scope.exception() &amp;&amp; resourceTypeValue.isObject()) {
<span class="line-modified">159         auto typeFlagsError = getTypeFlags(lexicalGlobalObject, resourceTypeValue, trigger.flags, readResourceType);</span>
160         if (typeFlagsError)
161             return makeUnexpected(typeFlagsError);
162     } else if (!resourceTypeValue.isUndefined())
163         return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
164 
<span class="line-modified">165     const JSValue loadTypeValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;load-type&quot;));</span>
166     if (!scope.exception() &amp;&amp; loadTypeValue.isObject()) {
<span class="line-modified">167         auto typeFlagsError = getTypeFlags(lexicalGlobalObject, loadTypeValue, trigger.flags, readLoadType);</span>
168         if (typeFlagsError)
169             return makeUnexpected(typeFlagsError);
170     } else if (!loadTypeValue.isUndefined())
171         return makeUnexpected(ContentExtensionError::JSONInvalidTriggerFlagsArray);
172 
<span class="line-modified">173     const JSValue ifDomainValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;if-domain&quot;));</span>
174     if (!scope.exception() &amp;&amp; ifDomainValue.isObject()) {
<span class="line-modified">175         auto ifDomain = getDomainList(lexicalGlobalObject, asObject(ifDomainValue));</span>
176         if (!ifDomain.has_value())
177             return makeUnexpected(ifDomain.error());
178         trigger.conditions = WTFMove(ifDomain.value());
179         if (trigger.conditions.isEmpty())
180             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
181         ASSERT(trigger.conditionType == Trigger::ConditionType::None);
182         trigger.conditionType = Trigger::ConditionType::IfDomain;
183     } else if (!ifDomainValue.isUndefined())
184         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
185 
<span class="line-modified">186     const JSValue unlessDomainValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;unless-domain&quot;));</span>
187     if (!scope.exception() &amp;&amp; unlessDomainValue.isObject()) {
188         if (trigger.conditionType != Trigger::ConditionType::None)
189             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">190         auto unlessDomain = getDomainList(lexicalGlobalObject, asObject(unlessDomainValue));</span>
191         if (!unlessDomain.has_value())
192             return makeUnexpected(unlessDomain.error());
193         trigger.conditions = WTFMove(unlessDomain.value());
194         if (trigger.conditions.isEmpty())
195             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
196         trigger.conditionType = Trigger::ConditionType::UnlessDomain;
197     } else if (!unlessDomainValue.isUndefined())
198         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
199 
<span class="line-modified">200     const JSValue ifTopURLValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;if-top-url&quot;));</span>
201     if (!scope.exception() &amp;&amp; ifTopURLValue.isObject()) {
202         if (trigger.conditionType != Trigger::ConditionType::None)
203             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">204         auto ifTopURL = getStringList(lexicalGlobalObject, asObject(ifTopURLValue));</span>
205         if (!ifTopURL.has_value())
206             return makeUnexpected(ifTopURL.error());
207         trigger.conditions = WTFMove(ifTopURL.value());
208         if (trigger.conditions.isEmpty())
209             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
210         trigger.conditionType = Trigger::ConditionType::IfTopURL;
211     } else if (!ifTopURLValue.isUndefined())
212         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
213 
<span class="line-modified">214     const JSValue unlessTopURLValue = triggerObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;unless-top-url&quot;));</span>
215     if (!scope.exception() &amp;&amp; unlessTopURLValue.isObject()) {
216         if (trigger.conditionType != Trigger::ConditionType::None)
217             return makeUnexpected(ContentExtensionError::JSONMultipleConditions);
<span class="line-modified">218         auto unlessTopURL = getStringList(lexicalGlobalObject, asObject(unlessTopURLValue));</span>
219         if (!unlessTopURL.has_value())
220             return makeUnexpected(unlessTopURL.error());
221         trigger.conditions = WTFMove(unlessTopURL.value());
222         if (trigger.conditions.isEmpty())
223             return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
224         trigger.conditionType = Trigger::ConditionType::UnlessTopURL;
225     } else if (!unlessTopURLValue.isUndefined())
226         return makeUnexpected(ContentExtensionError::JSONInvalidConditionList);
227 
228     return trigger;
229 }
230 
231 bool isValidCSSSelector(const String&amp; selector)
232 {
233     ASSERT(isMainThread());
234     AtomString::init();
235     QualifiedName::init();
236     CSSParserContext context(HTMLQuirksMode);
237     CSSParser parser(context);
238     CSSSelectorList selectorList;
239     parser.parseSelector(selector, selectorList);
240     return selectorList.isValid();
241 }
242 
<span class="line-modified">243 static Expected&lt;Optional&lt;Action&gt;, std::error_code&gt; loadAction(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
244 {
<span class="line-modified">245     VM&amp; vm = lexicalGlobalObject.vm();</span>
246     auto scope = DECLARE_THROW_SCOPE(vm);
247 
<span class="line-modified">248     const JSValue actionObject = ruleObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;action&quot;));</span>
249     if (scope.exception() || !actionObject.isObject())
250         return makeUnexpected(ContentExtensionError::JSONInvalidAction);
251 
<span class="line-modified">252     const JSValue typeObject = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;type&quot;));</span>
253     if (scope.exception() || !typeObject.isString())
254         return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
255 
<span class="line-modified">256     String actionType = asString(typeObject)-&gt;value(&amp;lexicalGlobalObject);</span>
257 
258     if (actionType == &quot;block&quot;)
259         return { Action(ActionType::BlockLoad) };
260     if (actionType == &quot;ignore-previous-rules&quot;)
261         return { Action(ActionType::IgnorePreviousRules) };
262     if (actionType == &quot;block-cookies&quot;)
263         return { Action(ActionType::BlockCookies) };
264     if (actionType == &quot;css-display-none&quot;) {
<span class="line-modified">265         JSValue selector = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;selector&quot;));</span>
266         if (scope.exception() || !selector.isString())
267             return makeUnexpected(ContentExtensionError::JSONInvalidCSSDisplayNoneActionType);
268 
<span class="line-modified">269         String selectorString = asString(selector)-&gt;value(&amp;lexicalGlobalObject);</span>
270         if (!isValidCSSSelector(selectorString)) {
271             // Skip rules with invalid selectors to be backwards-compatible.
272             return { WTF::nullopt };
273         }
274         return { Action(ActionType::CSSDisplayNoneSelector, selectorString) };
275     }
276     if (actionType == &quot;make-https&quot;)
277         return { Action(ActionType::MakeHTTPS) };
278     if (actionType == &quot;notify&quot;) {
<span class="line-modified">279         JSValue notification = actionObject.get(&amp;lexicalGlobalObject, Identifier::fromString(vm, &quot;notification&quot;));</span>
280         if (scope.exception() || !notification.isString())
281             return makeUnexpected(ContentExtensionError::JSONInvalidNotification);
<span class="line-modified">282         return { Action(ActionType::Notify, asString(notification)-&gt;value(&amp;lexicalGlobalObject)) };</span>
283     }
284     return makeUnexpected(ContentExtensionError::JSONInvalidActionType);
285 }
286 
<span class="line-modified">287 static Expected&lt;Optional&lt;ContentExtensionRule&gt;, std::error_code&gt; loadRule(JSGlobalObject&amp; lexicalGlobalObject, const JSObject&amp; ruleObject)</span>
288 {
<span class="line-modified">289     auto trigger = loadTrigger(lexicalGlobalObject, ruleObject);</span>
290     if (!trigger.has_value())
291         return makeUnexpected(trigger.error());
292 
<span class="line-modified">293     auto action = loadAction(lexicalGlobalObject, ruleObject);</span>
294     if (!action.has_value())
295         return makeUnexpected(action.error());
296 
297     if (action.value())
298         return {{{ WTFMove(trigger.value()), WTFMove(action.value().value()) }}};
299 
300     return { WTF::nullopt };
301 }
302 
<span class="line-modified">303 static Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; loadEncodedRules(JSGlobalObject&amp; lexicalGlobalObject, const String&amp; ruleJSON)</span>
304 {
<span class="line-modified">305     VM&amp; vm = lexicalGlobalObject.vm();</span>
306     auto scope = DECLARE_THROW_SCOPE(vm);
307 
308     // FIXME: JSONParse should require callbacks instead of an ExecState.
<span class="line-modified">309     const JSValue decodedRules = JSONParse(&amp;lexicalGlobalObject, ruleJSON);</span>
310 
311     if (scope.exception() || !decodedRules)
312         return makeUnexpected(ContentExtensionError::JSONInvalid);
313 
314     if (!decodedRules.isObject())
315         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
316 
<span class="line-modified">317     const JSObject* topLevelObject = decodedRules.toObject(&amp;lexicalGlobalObject);</span>
318     if (!topLevelObject || scope.exception())
319         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnObject);
320 
321     if (!isJSArray(topLevelObject))
322         return makeUnexpected(ContentExtensionError::JSONTopLevelStructureNotAnArray);
323 
324     const JSArray* topLevelArray = jsCast&lt;const JSArray*&gt;(topLevelObject);
325 
326     Vector&lt;ContentExtensionRule&gt; ruleList;
327 
328     unsigned length = topLevelArray-&gt;length();
329     const unsigned maxRuleCount = 50000;
330     if (length &gt; maxRuleCount)
331         return makeUnexpected(ContentExtensionError::JSONTooManyRules);
332     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">333         const JSValue value = topLevelArray-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
334         if (scope.exception() || !value)
335             return makeUnexpected(ContentExtensionError::JSONInvalidObjectInTopLevelArray);
336 
<span class="line-modified">337         const JSObject* ruleObject = value.toObject(&amp;lexicalGlobalObject);</span>
338         if (!ruleObject || scope.exception())
339             return makeUnexpected(ContentExtensionError::JSONInvalidRule);
340 
<span class="line-modified">341         auto rule = loadRule(lexicalGlobalObject, *ruleObject);</span>
342         if (!rule.has_value())
343             return makeUnexpected(rule.error());
344         if (rule.value())
345             ruleList.append(WTFMove(*rule.value()));
346     }
347 
348     return ruleList;
349 }
350 
351 Expected&lt;Vector&lt;ContentExtensionRule&gt;, std::error_code&gt; parseRuleList(const String&amp; ruleJSON)
352 {
353 #if CONTENT_EXTENSIONS_PERFORMANCE_REPORTING
354     MonotonicTime loadExtensionStartTime = MonotonicTime::now();
355 #endif
356     RefPtr&lt;VM&gt; vm = VM::create();
357 
358     JSLockHolder locker(vm.get());
359     JSGlobalObject* globalObject = JSGlobalObject::create(*vm, JSGlobalObject::createStructure(*vm, jsNull()));
360 
<span class="line-modified">361     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
<span class="line-modified">362     auto ruleList = loadEncodedRules(*lexicalGlobalObject, ruleJSON);</span>
363 
364     vm = nullptr;
365 
366     if (!ruleList.has_value())
367         return makeUnexpected(ruleList.error());
368 
369     if (ruleList-&gt;isEmpty())
370         return makeUnexpected(ContentExtensionError::JSONContainsNoRules);
371 
372 #if CONTENT_EXTENSIONS_PERFORMANCE_REPORTING
373     MonotonicTime loadExtensionEndTime = MonotonicTime::now();
374     dataLogF(&quot;Time spent loading extension %f\n&quot;, (loadExtensionEndTime - loadExtensionStartTime).seconds());
375 #endif
376 
377     return ruleList;
378 }
379 
380 } // namespace ContentExtensions
381 } // namespace WebCore
382 
</pre>
</td>
</tr>
</table>
<center><a href="ContentExtensionCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContentExtensionsBackend.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
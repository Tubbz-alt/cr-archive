<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/IDBBindingUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMWrapperWorld.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBBindingUtilities.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/IDBBindingUtilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 55,24 ***</span>
  #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! static bool get(ExecState&amp; exec, JSValue object, const String&amp; keyPathElement, JSValue&amp; result)</span>
  {
      if (object.isString() &amp;&amp; keyPathElement == &quot;length&quot;) {
          result = jsNumber(asString(object)-&gt;length());
          return true;
      }
      if (!object.isObject())
          return false;
  
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto* obj = asObject(object);
      Identifier identifier = Identifier::fromString(vm, keyPathElement);
      if (obj-&gt;inherits&lt;JSArray&gt;(vm) &amp;&amp; keyPathElement == &quot;length&quot;) {
<span class="line-modified">!         result = obj-&gt;get(&amp;exec, identifier);</span>
          return true;
      }
      if (obj-&gt;inherits&lt;JSBlob&gt;(vm) &amp;&amp; (keyPathElement == &quot;size&quot; || keyPathElement == &quot;type&quot;)) {
          if (keyPathElement == &quot;size&quot;) {
              result = jsNumber(jsCast&lt;JSBlob*&gt;(obj)-&gt;wrapped().size());
<span class="line-new-header">--- 55,24 ---</span>
  #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! static bool get(JSGlobalObject&amp; lexicalGlobalObject, JSValue object, const String&amp; keyPathElement, JSValue&amp; result)</span>
  {
      if (object.isString() &amp;&amp; keyPathElement == &quot;length&quot;) {
          result = jsNumber(asString(object)-&gt;length());
          return true;
      }
      if (!object.isObject())
          return false;
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto* obj = asObject(object);
      Identifier identifier = Identifier::fromString(vm, keyPathElement);
      if (obj-&gt;inherits&lt;JSArray&gt;(vm) &amp;&amp; keyPathElement == &quot;length&quot;) {
<span class="line-modified">!         result = obj-&gt;get(&amp;lexicalGlobalObject, identifier);</span>
          return true;
      }
      if (obj-&gt;inherits&lt;JSBlob&gt;(vm) &amp;&amp; (keyPathElement == &quot;size&quot; || keyPathElement == &quot;type&quot;)) {
          if (keyPathElement == &quot;size&quot;) {
              result = jsNumber(jsCast&lt;JSBlob*&gt;(obj)-&gt;wrapped().size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,61 ***</span>
          if (keyPathElement == &quot;lastModified&quot;) {
              result = jsNumber(jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());
              return true;
          }
          if (keyPathElement == &quot;lastModifiedDate&quot;) {
<span class="line-modified">!             result = jsDate(exec, jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());</span>
              return true;
          }
      }
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!obj-&gt;getOwnPropertyDescriptor(&amp;exec, identifier, descriptor))</span>
          return false;
      if (!descriptor.enumerable())
          return false;
  
<span class="line-modified">!     result = obj-&gt;get(&amp;exec, identifier);</span>
      return true;
  }
  
  static bool canSet(JSValue object, const String&amp; keyPathElement)
  {
      UNUSED_PARAM(keyPathElement);
      return object.isObject();
  }
  
<span class="line-modified">! static bool set(ExecState&amp; exec, JSValue&amp; object, const String&amp; keyPathElement, JSValue jsValue)</span>
  {
      if (!canSet(object, keyPathElement))
          return false;
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      Identifier identifier = Identifier::fromString(vm, keyPathElement);
      asObject(object)-&gt;putDirect(vm, identifier, jsValue);
      return true;
  }
  
<span class="line-modified">! JSValue toJS(ExecState&amp; state, JSGlobalObject&amp; globalObject, IDBKey* key)</span>
  {
      if (!key) {
          // This must be undefined, not null.
          // Spec: http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBKeyRange
          return jsUndefined();
      }
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      Locker&lt;JSLock&gt; locker(vm.apiLock());
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (key-&gt;type()) {
      case IndexedDB::KeyType::Array: {
          auto&amp; inArray = key-&gt;array();
          unsigned size = inArray.size();
<span class="line-modified">!         auto outArray = constructEmptyArray(&amp;state, 0, &amp;globalObject, size);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          for (size_t i = 0; i &lt; size; ++i) {
<span class="line-modified">!             outArray-&gt;putDirectIndex(&amp;state, i, toJS(state, globalObject, inArray.at(i).get()));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
          }
          return outArray;
      }
      case IndexedDB::KeyType::Binary: {
<span class="line-new-header">--- 91,61 ---</span>
          if (keyPathElement == &quot;lastModified&quot;) {
              result = jsNumber(jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());
              return true;
          }
          if (keyPathElement == &quot;lastModifiedDate&quot;) {
<span class="line-modified">!             result = jsDate(lexicalGlobalObject, jsCast&lt;JSFile*&gt;(obj)-&gt;wrapped().lastModified());</span>
              return true;
          }
      }
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!obj-&gt;getOwnPropertyDescriptor(&amp;lexicalGlobalObject, identifier, descriptor))</span>
          return false;
      if (!descriptor.enumerable())
          return false;
  
<span class="line-modified">!     result = obj-&gt;get(&amp;lexicalGlobalObject, identifier);</span>
      return true;
  }
  
  static bool canSet(JSValue object, const String&amp; keyPathElement)
  {
      UNUSED_PARAM(keyPathElement);
      return object.isObject();
  }
  
<span class="line-modified">! static bool set(JSGlobalObject&amp; lexicalGlobalObject, JSValue&amp; object, const String&amp; keyPathElement, JSValue jsValue)</span>
  {
      if (!canSet(object, keyPathElement))
          return false;
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      Identifier identifier = Identifier::fromString(vm, keyPathElement);
      asObject(object)-&gt;putDirect(vm, identifier, jsValue);
      return true;
  }
  
<span class="line-modified">! JSValue toJS(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject&amp; globalObject, IDBKey* key)</span>
  {
      if (!key) {
          // This must be undefined, not null.
          // Spec: http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBKeyRange
          return jsUndefined();
      }
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      Locker&lt;JSLock&gt; locker(vm.apiLock());
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (key-&gt;type()) {
      case IndexedDB::KeyType::Array: {
          auto&amp; inArray = key-&gt;array();
          unsigned size = inArray.size();
<span class="line-modified">!         auto outArray = constructEmptyArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), size);</span>
          RETURN_IF_EXCEPTION(scope, JSValue());
          for (size_t i = 0; i &lt; size; ++i) {
<span class="line-modified">!             outArray-&gt;putDirectIndex(&amp;lexicalGlobalObject, i, toJS(lexicalGlobalObject, globalObject, inArray.at(i).get()));</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
          }
          return outArray;
      }
      case IndexedDB::KeyType::Binary: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,18 ***</span>
          auto arrayBuffer = ArrayBuffer::create(data-&gt;data(), data-&gt;size());
          Structure* structure = globalObject.arrayBufferStructure(arrayBuffer-&gt;sharingMode());
          if (!structure)
              return jsNull();
  
<span class="line-modified">!         return JSArrayBuffer::create(state.vm(), structure, WTFMove(arrayBuffer));</span>
      }
      case IndexedDB::KeyType::String:
<span class="line-modified">!         return jsStringWithCache(&amp;state, key-&gt;string());</span>
      case IndexedDB::KeyType::Date:
          // FIXME: This should probably be toJS&lt;IDLDate&gt;(...) as per:
          // http://w3c.github.io/IndexedDB/#request-convert-a-key-to-a-value
<span class="line-modified">!         return toJS&lt;IDLNullable&lt;IDLDate&gt;&gt;(state, key-&gt;date());</span>
      case IndexedDB::KeyType::Number:
          return jsNumber(key-&gt;number());
      case IndexedDB::KeyType::Min:
      case IndexedDB::KeyType::Max:
      case IndexedDB::KeyType::Invalid:
<span class="line-new-header">--- 158,18 ---</span>
          auto arrayBuffer = ArrayBuffer::create(data-&gt;data(), data-&gt;size());
          Structure* structure = globalObject.arrayBufferStructure(arrayBuffer-&gt;sharingMode());
          if (!structure)
              return jsNull();
  
<span class="line-modified">!         return JSArrayBuffer::create(lexicalGlobalObject.vm(), structure, WTFMove(arrayBuffer));</span>
      }
      case IndexedDB::KeyType::String:
<span class="line-modified">!         return jsStringWithCache(&amp;lexicalGlobalObject, key-&gt;string());</span>
      case IndexedDB::KeyType::Date:
          // FIXME: This should probably be toJS&lt;IDLDate&gt;(...) as per:
          // http://w3c.github.io/IndexedDB/#request-convert-a-key-to-a-value
<span class="line-modified">!         return toJS&lt;IDLNullable&lt;IDLDate&gt;&gt;(lexicalGlobalObject, key-&gt;date());</span>
      case IndexedDB::KeyType::Number:
          return jsNumber(key-&gt;number());
      case IndexedDB::KeyType::Min:
      case IndexedDB::KeyType::Max:
      case IndexedDB::KeyType::Invalid:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,21 ***</span>
      return jsUndefined();
  }
  
  static const size_t maximumDepth = 2000;
  
<span class="line-modified">! static RefPtr&lt;IDBKey&gt; createIDBKeyFromValue(ExecState&amp; exec, JSValue value, Vector&lt;JSArray*&gt;&amp; stack)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
<span class="line-modified">!     if (value.isNumber() &amp;&amp; !std::isnan(value.toNumber(&amp;exec)))</span>
<span class="line-modified">!         return IDBKey::createNumber(value.toNumber(&amp;exec));</span>
  
      if (value.isString())
<span class="line-modified">!         return IDBKey::createString(asString(value)-&gt;value(&amp;exec));</span>
  
      if (value.inherits&lt;DateInstance&gt;(vm)) {
<span class="line-modified">!         auto dateValue = valueToDate(exec, value);</span>
          if (!std::isnan(dateValue))
              return IDBKey::createDate(dateValue);
      }
  
      if (value.isObject()) {
<span class="line-new-header">--- 181,21 ---</span>
      return jsUndefined();
  }
  
  static const size_t maximumDepth = 2000;
  
<span class="line-modified">! static RefPtr&lt;IDBKey&gt; createIDBKeyFromValue(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, Vector&lt;JSArray*&gt;&amp; stack)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     if (value.isNumber() &amp;&amp; !std::isnan(value.toNumber(&amp;lexicalGlobalObject)))</span>
<span class="line-modified">!         return IDBKey::createNumber(value.toNumber(&amp;lexicalGlobalObject));</span>
  
      if (value.isString())
<span class="line-modified">!         return IDBKey::createString(asString(value)-&gt;value(&amp;lexicalGlobalObject));</span>
  
      if (value.inherits&lt;DateInstance&gt;(vm)) {
<span class="line-modified">!         auto dateValue = valueToDate(lexicalGlobalObject, value);</span>
          if (!std::isnan(dateValue))
              return IDBKey::createDate(dateValue);
      }
  
      if (value.isObject()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,12 ***</span>
  
              stack.append(array);
  
              Vector&lt;RefPtr&lt;IDBKey&gt;&gt; subkeys;
              for (size_t i = 0; i &lt; length; i++) {
<span class="line-modified">!                 JSValue item = array-&gt;getIndex(&amp;exec, i);</span>
<span class="line-modified">!                 RefPtr&lt;IDBKey&gt; subkey = createIDBKeyFromValue(exec, item, stack);</span>
                  if (!subkey)
                      subkeys.append(IDBKey::createInvalid());
                  else
                      subkeys.append(subkey);
              }
<span class="line-new-header">--- 211,12 ---</span>
  
              stack.append(array);
  
              Vector&lt;RefPtr&lt;IDBKey&gt;&gt; subkeys;
              for (size_t i = 0; i &lt; length; i++) {
<span class="line-modified">!                 JSValue item = array-&gt;getIndex(&amp;lexicalGlobalObject, i);</span>
<span class="line-modified">!                 RefPtr&lt;IDBKey&gt; subkey = createIDBKeyFromValue(lexicalGlobalObject, item, stack);</span>
                  if (!subkey)
                      subkeys.append(IDBKey::createInvalid());
                  else
                      subkeys.append(subkey);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,82 ***</span>
              return IDBKey::createBinary(*arrayBufferView);
      }
      return nullptr;
  }
  
<span class="line-modified">! static Ref&lt;IDBKey&gt; createIDBKeyFromValue(ExecState&amp; exec, JSValue value)</span>
  {
      Vector&lt;JSArray*&gt; stack;
<span class="line-modified">!     RefPtr&lt;IDBKey&gt; key = createIDBKeyFromValue(exec, value, stack);</span>
      if (key)
          return *key;
      return IDBKey::createInvalid();
  }
  
<span class="line-modified">! static JSValue getNthValueOnKeyPath(ExecState&amp; exec, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      JSValue currentValue(rootValue);
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt; index; i++) {
          JSValue parentValue(currentValue);
<span class="line-modified">!         if (!get(exec, parentValue, keyPathElements[i], currentValue))</span>
              return jsUndefined();
      }
      return currentValue;
  }
  
<span class="line-modified">! static RefPtr&lt;IDBKey&gt; internalCreateIDBKeyFromScriptValueAndKeyPath(ExecState&amp; exec, const JSValue&amp; value, const String&amp; keyPath)</span>
  {
      Vector&lt;String&gt; keyPathElements;
      IDBKeyPathParseError error;
      IDBParseKeyPath(keyPath, keyPathElements, error);
      ASSERT(error == IDBKeyPathParseError::None);
  
      JSValue jsValue = value;
<span class="line-modified">!     jsValue = getNthValueOnKeyPath(exec, jsValue, keyPathElements, keyPathElements.size());</span>
      if (jsValue.isUndefined())
          return nullptr;
<span class="line-modified">!     return createIDBKeyFromValue(exec, jsValue);</span>
  }
  
<span class="line-modified">! static JSValue ensureNthValueOnKeyPath(ExecState&amp; exec, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      JSValue currentValue(rootValue);
  
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt; index; i++) {
          JSValue parentValue(currentValue);
          const String&amp; keyPathElement = keyPathElements[i];
<span class="line-modified">!         if (!get(exec, parentValue, keyPathElement, currentValue)) {</span>
<span class="line-modified">!             JSObject* object = constructEmptyObject(&amp;exec);</span>
<span class="line-modified">!             if (!set(exec, parentValue, keyPathElement, JSValue(object)))</span>
                  return jsUndefined();
              currentValue = JSValue(object);
          }
      }
  
      return currentValue;
  }
  
<span class="line-modified">! static bool canInjectNthValueOnKeyPath(ExecState&amp; exec, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      if (!rootValue.isObject())
          return false;
  
      JSValue currentValue(rootValue);
  
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt;= index; ++i) {
          JSValue parentValue(currentValue);
          const String&amp; keyPathElement = keyPathElements[i];
<span class="line-modified">!         if (!get(exec, parentValue, keyPathElement, currentValue))</span>
              return canSet(parentValue, keyPathElement);
      }
      return true;
  }
  
<span class="line-modified">! bool injectIDBKeyIntoScriptValue(ExecState&amp; exec, const IDBKeyData&amp; keyData, JSValue value, const IDBKeyPath&amp; keyPath)</span>
  {
      LOG(IndexedDB, &quot;injectIDBKeyIntoScriptValue&quot;);
  
      ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
  
<span class="line-new-header">--- 232,82 ---</span>
              return IDBKey::createBinary(*arrayBufferView);
      }
      return nullptr;
  }
  
<span class="line-modified">! static Ref&lt;IDBKey&gt; createIDBKeyFromValue(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
  {
      Vector&lt;JSArray*&gt; stack;
<span class="line-modified">!     RefPtr&lt;IDBKey&gt; key = createIDBKeyFromValue(lexicalGlobalObject, value, stack);</span>
      if (key)
          return *key;
      return IDBKey::createInvalid();
  }
  
<span class="line-modified">! static JSValue getNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      JSValue currentValue(rootValue);
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt; index; i++) {
          JSValue parentValue(currentValue);
<span class="line-modified">!         if (!get(lexicalGlobalObject, parentValue, keyPathElements[i], currentValue))</span>
              return jsUndefined();
      }
      return currentValue;
  }
  
<span class="line-modified">! static RefPtr&lt;IDBKey&gt; internalCreateIDBKeyFromScriptValueAndKeyPath(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; value, const String&amp; keyPath)</span>
  {
      Vector&lt;String&gt; keyPathElements;
      IDBKeyPathParseError error;
      IDBParseKeyPath(keyPath, keyPathElements, error);
      ASSERT(error == IDBKeyPathParseError::None);
  
      JSValue jsValue = value;
<span class="line-modified">!     jsValue = getNthValueOnKeyPath(lexicalGlobalObject, jsValue, keyPathElements, keyPathElements.size());</span>
      if (jsValue.isUndefined())
          return nullptr;
<span class="line-modified">!     return createIDBKeyFromValue(lexicalGlobalObject, jsValue);</span>
  }
  
<span class="line-modified">! static JSValue ensureNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      JSValue currentValue(rootValue);
  
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt; index; i++) {
          JSValue parentValue(currentValue);
          const String&amp; keyPathElement = keyPathElements[i];
<span class="line-modified">!         if (!get(lexicalGlobalObject, parentValue, keyPathElement, currentValue)) {</span>
<span class="line-modified">!             JSObject* object = constructEmptyObject(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!             if (!set(lexicalGlobalObject, parentValue, keyPathElement, JSValue(object)))</span>
                  return jsUndefined();
              currentValue = JSValue(object);
          }
      }
  
      return currentValue;
  }
  
<span class="line-modified">! static bool canInjectNthValueOnKeyPath(JSGlobalObject&amp; lexicalGlobalObject, JSValue rootValue, const Vector&lt;String&gt;&amp; keyPathElements, size_t index)</span>
  {
      if (!rootValue.isObject())
          return false;
  
      JSValue currentValue(rootValue);
  
      ASSERT(index &lt;= keyPathElements.size());
      for (size_t i = 0; i &lt;= index; ++i) {
          JSValue parentValue(currentValue);
          const String&amp; keyPathElement = keyPathElements[i];
<span class="line-modified">!         if (!get(lexicalGlobalObject, parentValue, keyPathElement, currentValue))</span>
              return canSet(parentValue, keyPathElement);
      }
      return true;
  }
  
<span class="line-modified">! bool injectIDBKeyIntoScriptValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBKeyData&amp; keyData, JSValue value, const IDBKeyPath&amp; keyPath)</span>
  {
      LOG(IndexedDB, &quot;injectIDBKeyIntoScriptValue&quot;);
  
      ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,48 ***</span>
      ASSERT(error == IDBKeyPathParseError::None);
  
      if (keyPathElements.isEmpty())
          return false;
  
<span class="line-modified">!     JSValue parent = ensureNthValueOnKeyPath(exec, value, keyPathElements, keyPathElements.size() - 1);</span>
      if (parent.isUndefined())
          return false;
  
      auto key = keyData.maybeCreateIDBKey();
      if (!key)
          return false;
  
      // Do not set if object already has the correct property value.
      JSValue existingKey;
<span class="line-modified">!     if (get(exec, parent, keyPathElements.last(), existingKey) &amp;&amp; !key-&gt;compare(createIDBKeyFromValue(exec, existingKey)))</span>
          return true;
<span class="line-modified">!     if (!set(exec, parent, keyPathElements.last(), toJS(exec, *exec.lexicalGlobalObject(), key.get())))</span>
          return false;
  
      return true;
  }
  
  
<span class="line-modified">! RefPtr&lt;IDBKey&gt; maybeCreateIDBKeyFromScriptValueAndKeyPath(ExecState&amp; exec, const JSValue&amp; value, const IDBKeyPath&amp; keyPath)</span>
  {
      if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath)) {
          auto&amp; array = WTF::get&lt;Vector&lt;String&gt;&gt;(keyPath);
          Vector&lt;RefPtr&lt;IDBKey&gt;&gt; result;
          result.reserveInitialCapacity(array.size());
          for (auto&amp; string : array) {
<span class="line-modified">!             RefPtr&lt;IDBKey&gt; key = internalCreateIDBKeyFromScriptValueAndKeyPath(exec, value, string);</span>
              if (!key)
                  return nullptr;
              result.uncheckedAppend(WTFMove(key));
          }
          return IDBKey::createArray(WTFMove(result));
      }
  
<span class="line-modified">!     return internalCreateIDBKeyFromScriptValueAndKeyPath(exec, value, WTF::get&lt;String&gt;(keyPath));</span>
  }
  
<span class="line-modified">! bool canInjectIDBKeyIntoScriptValue(ExecState&amp; exec, const JSValue&amp; scriptValue, const IDBKeyPath&amp; keyPath)</span>
  {
      LOG(StorageAPI, &quot;canInjectIDBKeyIntoScriptValue&quot;);
  
      ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
      Vector&lt;String&gt; keyPathElements;
<span class="line-new-header">--- 317,48 ---</span>
      ASSERT(error == IDBKeyPathParseError::None);
  
      if (keyPathElements.isEmpty())
          return false;
  
<span class="line-modified">!     JSValue parent = ensureNthValueOnKeyPath(lexicalGlobalObject, value, keyPathElements, keyPathElements.size() - 1);</span>
      if (parent.isUndefined())
          return false;
  
      auto key = keyData.maybeCreateIDBKey();
      if (!key)
          return false;
  
      // Do not set if object already has the correct property value.
      JSValue existingKey;
<span class="line-modified">!     if (get(lexicalGlobalObject, parent, keyPathElements.last(), existingKey) &amp;&amp; !key-&gt;compare(createIDBKeyFromValue(lexicalGlobalObject, existingKey)))</span>
          return true;
<span class="line-modified">!     if (!set(lexicalGlobalObject, parent, keyPathElements.last(), toJS(lexicalGlobalObject, lexicalGlobalObject, key.get())))</span>
          return false;
  
      return true;
  }
  
  
<span class="line-modified">! RefPtr&lt;IDBKey&gt; maybeCreateIDBKeyFromScriptValueAndKeyPath(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; value, const IDBKeyPath&amp; keyPath)</span>
  {
      if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath)) {
          auto&amp; array = WTF::get&lt;Vector&lt;String&gt;&gt;(keyPath);
          Vector&lt;RefPtr&lt;IDBKey&gt;&gt; result;
          result.reserveInitialCapacity(array.size());
          for (auto&amp; string : array) {
<span class="line-modified">!             RefPtr&lt;IDBKey&gt; key = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, string);</span>
              if (!key)
                  return nullptr;
              result.uncheckedAppend(WTFMove(key));
          }
          return IDBKey::createArray(WTFMove(result));
      }
  
<span class="line-modified">!     return internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, WTF::get&lt;String&gt;(keyPath));</span>
  }
  
<span class="line-modified">! bool canInjectIDBKeyIntoScriptValue(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; scriptValue, const IDBKeyPath&amp; keyPath)</span>
  {
      LOG(StorageAPI, &quot;canInjectIDBKeyIntoScriptValue&quot;);
  
      ASSERT(WTF::holds_alternative&lt;String&gt;(keyPath));
      Vector&lt;String&gt; keyPathElements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,14 ***</span>
      ASSERT(error == IDBKeyPathParseError::None);
  
      if (!keyPathElements.size())
          return false;
  
<span class="line-modified">!     return canInjectNthValueOnKeyPath(exec, scriptValue, keyPathElements, keyPathElements.size() - 1);</span>
  }
  
<span class="line-modified">! static JSValue deserializeIDBValueToJSValue(ExecState&amp; state, JSC::JSGlobalObject&amp; globalObject, const IDBValue&amp; value)</span>
  {
      // FIXME: I think it&#39;s peculiar to use undefined to mean &quot;null data&quot; and null to mean &quot;empty data&quot;.
      // But I am not changing this at the moment because at least some callers are specifically checking isUndefined.
  
      if (!value.data().data())
<span class="line-new-header">--- 367,14 ---</span>
      ASSERT(error == IDBKeyPathParseError::None);
  
      if (!keyPathElements.size())
          return false;
  
<span class="line-modified">!     return canInjectNthValueOnKeyPath(lexicalGlobalObject, scriptValue, keyPathElements, keyPathElements.size() - 1);</span>
  }
  
<span class="line-modified">! static JSValue deserializeIDBValueToJSValue(JSGlobalObject&amp; lexicalGlobalObject, JSC::JSGlobalObject&amp; globalObject, const IDBValue&amp; value)</span>
  {
      // FIXME: I think it&#39;s peculiar to use undefined to mean &quot;null data&quot; and null to mean &quot;empty data&quot;.
      // But I am not changing this at the moment because at least some callers are specifically checking isUndefined.
  
      if (!value.data().data())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,50 ***</span>
      if (data.isEmpty())
          return jsNull();
  
      auto serializedValue = SerializedScriptValue::createFromWireBytes(Vector&lt;uint8_t&gt;(data));
  
<span class="line-modified">!     state.vm().apiLock().lock();</span>
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; messagePorts;
<span class="line-modified">!     JSValue result = serializedValue-&gt;deserialize(state, &amp;globalObject, messagePorts, value.blobURLs(), value.blobFilePaths(), SerializationErrorMode::NonThrowing);</span>
<span class="line-modified">!     state.vm().apiLock().unlock();</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue deserializeIDBValueToJSValue(ExecState&amp; state, const IDBValue&amp; value)</span>
  {
<span class="line-modified">!     return deserializeIDBValueToJSValue(state, *state.lexicalGlobalObject(), value);</span>
  }
  
<span class="line-modified">! JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, const IDBValue&amp; value)</span>
  {
<span class="line-modified">!     ASSERT(state);</span>
<span class="line-modified">!     return deserializeIDBValueToJSValue(*state, *globalObject, value);</span>
  }
  
<span class="line-modified">! Ref&lt;IDBKey&gt; scriptValueToIDBKey(ExecState&amp; exec, const JSValue&amp; scriptValue)</span>
  {
<span class="line-modified">!     return createIDBKeyFromValue(exec, scriptValue);</span>
  }
  
<span class="line-modified">! JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, const IDBKeyData&amp; keyData)</span>
  {
<span class="line-modified">!     ASSERT(state);</span>
      ASSERT(globalObject);
  
<span class="line-modified">!     return toJS(*state, *globalObject, keyData.maybeCreateIDBKey().get());</span>
  }
  
<span class="line-modified">! static Vector&lt;IDBKeyData&gt; createKeyPathArray(ExecState&amp; exec, JSValue value, const IDBIndexInfo&amp; info, Optional&lt;IDBKeyPath&gt; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
  {
      auto visitor = WTF::makeVisitor([&amp;](const String&amp; string) -&gt; Vector&lt;IDBKeyData&gt; {
          // Value doesn&#39;t contain auto-generated key, so we need to manually add key if it is possibly auto-generated.
          if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(string) == objectStoreKeyPath.value())
              return { objectStoreKey };
  
<span class="line-modified">!         auto idbKey = internalCreateIDBKeyFromScriptValueAndKeyPath(exec, value, string);</span>
          if (!idbKey)
              return { };
  
          Vector&lt;IDBKeyData&gt; keys;
          if (info.multiEntry() &amp;&amp; idbKey-&gt;type() == IndexedDB::Array) {
<span class="line-new-header">--- 384,50 ---</span>
      if (data.isEmpty())
          return jsNull();
  
      auto serializedValue = SerializedScriptValue::createFromWireBytes(Vector&lt;uint8_t&gt;(data));
  
<span class="line-modified">!     lexicalGlobalObject.vm().apiLock().lock();</span>
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; messagePorts;
<span class="line-modified">!     JSValue result = serializedValue-&gt;deserialize(lexicalGlobalObject, &amp;globalObject, messagePorts, value.blobURLs(), value.blobFilePaths(), SerializationErrorMode::NonThrowing);</span>
<span class="line-modified">!     lexicalGlobalObject.vm().apiLock().unlock();</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue deserializeIDBValueToJSValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBValue&amp; value)</span>
  {
<span class="line-modified">!     return deserializeIDBValueToJSValue(lexicalGlobalObject, lexicalGlobalObject, value);</span>
  }
  
<span class="line-modified">! JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, const IDBValue&amp; value)</span>
  {
<span class="line-modified">!     ASSERT(lexicalGlobalObject);</span>
<span class="line-modified">!     return deserializeIDBValueToJSValue(*lexicalGlobalObject, *globalObject, value);</span>
  }
  
<span class="line-modified">! Ref&lt;IDBKey&gt; scriptValueToIDBKey(JSGlobalObject&amp; lexicalGlobalObject, const JSValue&amp; scriptValue)</span>
  {
<span class="line-modified">!     return createIDBKeyFromValue(lexicalGlobalObject, scriptValue);</span>
  }
  
<span class="line-modified">! JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, const IDBKeyData&amp; keyData)</span>
  {
<span class="line-modified">!     ASSERT(lexicalGlobalObject);</span>
      ASSERT(globalObject);
  
<span class="line-modified">!     return toJS(*lexicalGlobalObject, *globalObject, keyData.maybeCreateIDBKey().get());</span>
  }
  
<span class="line-modified">! static Vector&lt;IDBKeyData&gt; createKeyPathArray(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, const IDBIndexInfo&amp; info, Optional&lt;IDBKeyPath&gt; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
  {
      auto visitor = WTF::makeVisitor([&amp;](const String&amp; string) -&gt; Vector&lt;IDBKeyData&gt; {
          // Value doesn&#39;t contain auto-generated key, so we need to manually add key if it is possibly auto-generated.
          if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(string) == objectStoreKeyPath.value())
              return { objectStoreKey };
  
<span class="line-modified">!         auto idbKey = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, string);</span>
          if (!idbKey)
              return { };
  
          Vector&lt;IDBKeyData&gt; keys;
          if (info.multiEntry() &amp;&amp; idbKey-&gt;type() == IndexedDB::Array) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,11 ***</span>
          Vector&lt;IDBKeyData&gt; keys;
          for (auto&amp; entry : vector) {
              if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(entry) == objectStoreKeyPath.value())
                  keys.append(objectStoreKey);
              else {
<span class="line-modified">!                 auto key = internalCreateIDBKeyFromScriptValueAndKeyPath(exec, value, entry);</span>
                  if (!key || !key-&gt;isValid())
                      return { };
                  keys.append(key.get());
              }
          }
<span class="line-new-header">--- 440,11 ---</span>
          Vector&lt;IDBKeyData&gt; keys;
          for (auto&amp; entry : vector) {
              if (objectStoreKeyPath &amp;&amp; WTF::holds_alternative&lt;String&gt;(objectStoreKeyPath.value()) &amp;&amp; IDBKeyPath(entry) == objectStoreKeyPath.value())
                  keys.append(objectStoreKey);
              else {
<span class="line-modified">!                 auto key = internalCreateIDBKeyFromScriptValueAndKeyPath(lexicalGlobalObject, value, entry);</span>
                  if (!key || !key-&gt;isValid())
                      return { };
                  keys.append(key.get());
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,29 ***</span>
      });
  
      return WTF::visit(visitor, info.keyPath());
  }
  
<span class="line-modified">! void generateIndexKeyForValue(ExecState&amp; exec, const IDBIndexInfo&amp; info, JSValue value, IndexKey&amp; outKey, const Optional&lt;IDBKeyPath&gt;&amp; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
  {
<span class="line-modified">!     auto keyDatas = createKeyPathArray(exec, value, info, objectStoreKeyPath, objectStoreKey);</span>
      if (keyDatas.isEmpty())
          return;
  
      outKey = IndexKey(WTFMove(keyDatas));
  }
  
<span class="line-modified">! Optional&lt;JSC::JSValue&gt; deserializeIDBValueWithKeyInjection(ExecState&amp; state, const IDBValue&amp; value, const IDBKeyData&amp; key, const Optional&lt;IDBKeyPath&gt;&amp; keyPath)</span>
  {
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(state, value);</span>
      if (jsValue.isUndefined() || !keyPath || !WTF::holds_alternative&lt;String&gt;(keyPath.value()) || !isIDBKeyPathValid(keyPath.value()))
          return jsValue;
  
<span class="line-modified">!     JSLockHolder locker(state.vm());</span>
<span class="line-modified">!     if (!injectIDBKeyIntoScriptValue(state, key, jsValue, keyPath.value())) {</span>
<span class="line-modified">!         auto throwScope = DECLARE_THROW_SCOPE(state.vm());</span>
<span class="line-modified">!         propagateException(state, throwScope, Exception(UnknownError, &quot;Cannot inject key into script value&quot;_s));</span>
          return WTF::nullopt;
      }
  
      return jsValue;
  }
<span class="line-new-header">--- 452,29 ---</span>
      });
  
      return WTF::visit(visitor, info.keyPath());
  }
  
<span class="line-modified">! void generateIndexKeyForValue(JSGlobalObject&amp; lexicalGlobalObject, const IDBIndexInfo&amp; info, JSValue value, IndexKey&amp; outKey, const Optional&lt;IDBKeyPath&gt;&amp; objectStoreKeyPath, const IDBKeyData&amp; objectStoreKey)</span>
  {
<span class="line-modified">!     auto keyDatas = createKeyPathArray(lexicalGlobalObject, value, info, objectStoreKeyPath, objectStoreKey);</span>
      if (keyDatas.isEmpty())
          return;
  
      outKey = IndexKey(WTFMove(keyDatas));
  }
  
<span class="line-modified">! Optional&lt;JSC::JSValue&gt; deserializeIDBValueWithKeyInjection(JSGlobalObject&amp; lexicalGlobalObject, const IDBValue&amp; value, const IDBKeyData&amp; key, const Optional&lt;IDBKeyPath&gt;&amp; keyPath)</span>
  {
<span class="line-modified">!     auto jsValue = deserializeIDBValueToJSValue(lexicalGlobalObject, value);</span>
      if (jsValue.isUndefined() || !keyPath || !WTF::holds_alternative&lt;String&gt;(keyPath.value()) || !isIDBKeyPathValid(keyPath.value()))
          return jsValue;
  
<span class="line-modified">!     JSLockHolder locker(lexicalGlobalObject.vm());</span>
<span class="line-modified">!     if (!injectIDBKeyIntoScriptValue(lexicalGlobalObject, key, jsValue, keyPath.value())) {</span>
<span class="line-modified">!         auto throwScope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
<span class="line-modified">!         propagateException(lexicalGlobalObject, throwScope, Exception(UnknownError, &quot;Cannot inject key into script value&quot;_s));</span>
          return WTF::nullopt;
      }
  
      return jsValue;
  }
</pre>
<center><a href="DOMWrapperWorld.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBBindingUtilities.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
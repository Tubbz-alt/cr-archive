diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBodyOwner.cpp
@@ -27,15 +27,17 @@
  */
 
 #include "config.h"
 #include "FetchBodyOwner.h"
 
+#include "Document.h"
 #include "FetchLoader.h"
 #include "HTTPParsers.h"
 #include "JSBlob.h"
 #include "ResourceError.h"
 #include "ResourceResponse.h"
+#include "WindowEventLoop.h"
 
 namespace WebCore {
 
 FetchBodyOwner::FetchBodyOwner(ScriptExecutionContext& context, Optional<FetchBody>&& body, Ref<FetchHeaders>&& headers)
     : ActiveDOMObject(&context)
@@ -122,12 +124,12 @@
         promise->reject(*exception);
         return;
     }
 
     if (isBodyNullOrOpaque()) {
-        promise->resolveCallbackValueWithNewlyCreated<IDLInterface<Blob>>([this](auto& context) {
-            return Blob::create(context.sessionID(), Vector<uint8_t> { }, Blob::normalizedContentType(extractMIMETypeFromMediaType(m_contentType)));
+        promise->resolveCallbackValueWithNewlyCreated<IDLInterface<Blob>>([this](auto&) {
+            return Blob::create(Vector<uint8_t> { }, Blob::normalizedContentType(extractMIMETypeFromMediaType(m_contentType)));
         });
         return;
     }
     if (isDisturbedOrLocked()) {
         promise->reject(Exception { TypeError, "Body is disturbed or locked"_s });
@@ -287,11 +289,10 @@
             m_readableStreamSource->error(Exception { TypeError, "Blob loading failed"_s});
         m_readableStreamSource = nullptr;
     } else
 #endif
         m_body->loadingFailed(Exception { TypeError, "Blob loading failed"_s});
-
     finishBlobLoading();
 }
 
 void FetchBodyOwner::blobChunk(const char* data, size_t size)
 {
@@ -322,22 +323,22 @@
     // didFail might be called within FetchLoader::start call.
     if (loader->isStarted())
         owner.blobLoadingFailed();
 }
 
-RefPtr<ReadableStream> FetchBodyOwner::readableStream(JSC::ExecState& state)
+RefPtr<ReadableStream> FetchBodyOwner::readableStream(JSC::JSGlobalObject& state)
 {
     if (isBodyNullOrOpaque())
         return nullptr;
 
     if (!m_body->hasReadableStream())
         createReadableStream(state);
 
     return m_body->readableStream();
 }
 
-void FetchBodyOwner::createReadableStream(JSC::ExecState& state)
+void FetchBodyOwner::createReadableStream(JSC::JSGlobalObject& state)
 {
     ASSERT(!m_readableStreamSource);
     if (isDisturbed()) {
         m_body->setReadableStream(ReadableStream::create(state, nullptr));
         m_body->readableStream()->lock();

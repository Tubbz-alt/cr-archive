<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDollarVM.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;


  33 #include &quot;FrameTracers.h&quot;
  34 #include &quot;FunctionCodeBlock.h&quot;
  35 #include &quot;GetterSetter.h&quot;
  36 #include &quot;JSArray.h&quot;
  37 #include &quot;JSArrayBuffer.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
  40 #include &quot;JSONObject.h&quot;
  41 #include &quot;JSProxy.h&quot;
  42 #include &quot;JSString.h&quot;

  43 #include &quot;Parser.h&quot;

  44 #include &quot;ShadowChicken.h&quot;
  45 #include &quot;Snippet.h&quot;
  46 #include &quot;SnippetParams.h&quot;
  47 #include &quot;TypeProfiler.h&quot;
  48 #include &quot;TypeProfilerLog.h&quot;
  49 #include &quot;VMInspector.h&quot;
  50 #include &quot;WasmCapabilities.h&quot;
  51 #include &lt;wtf/Atomics.h&gt;

  52 #include &lt;wtf/DataLog.h&gt;
  53 #include &lt;wtf/ProcessID.h&gt;
  54 #include &lt;wtf/StringPrintStream.h&gt;
  55 
  56 #if ENABLE(WEBASSEMBLY)
  57 #include &quot;JSWebAssemblyHelpers.h&quot;
  58 #include &quot;WasmStreamingParser.h&quot;
  59 #endif
  60 
  61 using namespace JSC;
  62 
























  63 namespace {
  64 
<span class="line-modified">  65 class JSDollarVMCallFrame : public JSDestructibleObject {</span>
<span class="line-modified">  66     using Base = JSDestructibleObject;</span>
















  67 public:
  68     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
  69         : Base(vm, structure)
<span class="line-modified">  70     { }</span>


  71 
  72     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  73     {

  74         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  75     }
  76 
<span class="line-modified">  77     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)</span>
  78     {
<span class="line-modified">  79         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">  80         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
  81         Structure* structure = createStructure(vm, globalObject, jsNull());
  82         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
<span class="line-modified">  83         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);</span>
  84         return frame;
  85     }
  86 
<span class="line-modified">  87     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)</span>
  88     {

  89         Base::finishCreation(vm);
  90 
  91         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {

  92             JSDollarVMCallFrame::addProperty(vm, name, value);
  93         };
  94 
  95         unsigned frameIndex = 0;
  96         bool isValid = false;
<span class="line-modified">  97         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>

  98 
  99             if (frameIndex++ != requestedFrameIndex)
 100                 return StackVisitor::Continue;
 101 
 102             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
 103 
 104             if (visitor-&gt;callee().isCell())
 105                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 106 
 107             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 108             if (codeBlock) {
 109                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 110                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 111                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 112             }
 113             isValid = true;
 114 
 115             return StackVisitor::Done;
 116         });
 117 
 118         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 119     }
 120 
 121     DECLARE_INFO;
 122 
 123 private:
 124     void addProperty(VM&amp; vm, const char* name, JSValue value)
 125     {

 126         Identifier identifier = Identifier::fromString(vm, name);
 127         putDirect(vm, identifier, value);
 128     }
 129 };
 130 
 131 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 132 
 133 class ElementHandleOwner;
 134 class Root;
 135 
 136 class Element : public JSNonFinalObject {
 137 public:
 138     Element(VM&amp; vm, Structure* structure)
 139         : Base(vm, structure)
 140     {

 141     }
 142 
 143     typedef JSNonFinalObject Base;
 144 
 145     Root* root() const { return m_root.get(); }
 146     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 147 
 148     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 149     {

 150         Structure* structure = createStructure(vm, globalObject, jsNull());
 151         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
 152         element-&gt;finishCreation(vm, root);
 153         return element;
 154     }
 155 
 156     void finishCreation(VM&amp;, Root*);
 157 
 158     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 159     {

 160         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 161         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 162         Base::visitChildren(thisObject, visitor);
 163         visitor.append(thisObject-&gt;m_root);
 164     }
 165 
 166     static ElementHandleOwner* handleOwner();
 167 
 168     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 169     {

 170         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 171     }
 172 
 173     DECLARE_INFO;
 174 
 175 private:
 176     WriteBarrier&lt;Root&gt; m_root;
 177 };
 178 
 179 class ElementHandleOwner : public WeakHandleOwner {
 180     WTF_MAKE_FAST_ALLOCATED;
 181 public:
<span class="line-modified"> 182     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override</span>
 183     {

 184         if (UNLIKELY(reason))
 185             *reason = &quot;JSC::Element is opaque root&quot;;
 186         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 187         return visitor.containsOpaqueRoot(element-&gt;root());
 188     }
 189 };
 190 
 191 class Root : public JSDestructibleObject {
 192 public:
 193     Root(VM&amp; vm, Structure* structure)
 194         : Base(vm, structure)
 195     {

 196     }
 197 
 198     Element* element()
 199     {
 200         return m_element.get();
 201     }
 202 
 203     void setElement(Element* element)
 204     {

 205         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 206         m_element.swap(newElement);
 207     }
 208 
 209     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {

 211         Structure* structure = createStructure(vm, globalObject, jsNull());
 212         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
 213         root-&gt;finishCreation(vm);
 214         return root;
 215     }
 216 
 217     typedef JSDestructibleObject Base;
 218 
 219     DECLARE_INFO;
 220 
 221     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 222     {

 223         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 224     }
 225 
 226     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 227     {

 228         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 229         Base::visitChildren(thisObject, visitor);
 230         visitor.addOpaqueRoot(thisObject);
 231     }
 232 
 233 private:
 234     Weak&lt;Element&gt; m_element;
 235 };
 236 
 237 class SimpleObject : public JSNonFinalObject {
 238 public:
 239     SimpleObject(VM&amp; vm, Structure* structure)
 240         : Base(vm, structure)
 241     {

 242     }
 243 
 244     typedef JSNonFinalObject Base;
<span class="line-modified"> 245     static const bool needsDestruction = false;</span>
 246 
 247     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 248     {

 249         Structure* structure = createStructure(vm, globalObject, jsNull());
 250         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
 251         simpleObject-&gt;finishCreation(vm);
 252         return simpleObject;
 253     }
 254 
 255     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 256     {

 257         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 258         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 259         Base::visitChildren(thisObject, visitor);
 260         visitor.append(thisObject-&gt;m_hiddenValue);
 261     }
 262 
 263     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 264     {

 265         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 266     }
 267 
 268     JSValue hiddenValue()
 269     {
 270         return m_hiddenValue.get();
 271     }
 272 
 273     void setHiddenValue(VM&amp; vm, JSValue value)
 274     {
 275         ASSERT(value.isCell());
 276         m_hiddenValue.set(vm, this, value);
 277     }
 278 
 279     DECLARE_INFO;
 280 
 281 private:
 282     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 283 };
 284 
 285 class ImpureGetter : public JSNonFinalObject {
 286 public:
 287     ImpureGetter(VM&amp; vm, Structure* structure)
 288         : Base(vm, structure)
 289     {

 290     }
 291 
 292     DECLARE_INFO;
 293     typedef JSNonFinalObject Base;
<span class="line-modified"> 294     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;</span>
 295 
 296     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 297     {

 298         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 299     }
 300 
 301     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 302     {

 303         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
 304         getter-&gt;finishCreation(vm, delegate);
 305         return getter;
 306     }
 307 
 308     void finishCreation(VM&amp; vm, JSObject* delegate)
 309     {

 310         Base::finishCreation(vm);
 311         if (delegate)
 312             m_delegate.set(vm, this, delegate);
 313     }
 314 
<span class="line-modified"> 315     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)</span>
 316     {
<span class="line-modified"> 317         VM&amp; vm = exec-&gt;vm();</span>

 318         auto scope = DECLARE_THROW_SCOPE(vm);
 319         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 320 
 321         if (thisObject-&gt;m_delegate) {
<span class="line-modified"> 322             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))</span>
 323                 return true;
 324             RETURN_IF_EXCEPTION(scope, false);
 325         }
 326 
<span class="line-modified"> 327         return Base::getOwnPropertySlot(object, exec, name, slot);</span>
 328     }
 329 
 330     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 331     {

 332         ASSERT_GC_OBJECT_INHERITS(cell, info());
 333         Base::visitChildren(cell, visitor);
 334         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 335         visitor.append(thisObject-&gt;m_delegate);
 336     }
 337 
 338     void setDelegate(VM&amp; vm, JSObject* delegate)
 339     {
 340         m_delegate.set(vm, this, delegate);
 341     }
 342 
 343 private:
 344     WriteBarrier&lt;JSObject&gt; m_delegate;
 345 };
 346 
 347 class CustomGetter : public JSNonFinalObject {
 348 public:
 349     CustomGetter(VM&amp; vm, Structure* structure)
 350         : Base(vm, structure)
 351     {

 352     }
 353 
 354     DECLARE_INFO;
 355     typedef JSNonFinalObject Base;
<span class="line-modified"> 356     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;</span>
 357 
 358     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 359     {

 360         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 361     }
 362 
 363     static CustomGetter* create(VM&amp; vm, Structure* structure)
 364     {

 365         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
 366         getter-&gt;finishCreation(vm);
 367         return getter;
 368     }
 369 
<span class="line-modified"> 370     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 371     {
<span class="line-modified"> 372         VM&amp; vm = exec-&gt;vm();</span>

 373         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 374         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
 375             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 376             return true;
 377         }
 378 
 379         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
 380             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 381             return true;
 382         }
 383 
<span class="line-modified"> 384         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
 385     }
 386 
 387 private:
<span class="line-modified"> 388     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 389     {
<span class="line-modified"> 390         VM&amp; vm = exec-&gt;vm();</span>

 391         auto scope = DECLARE_THROW_SCOPE(vm);
 392 
 393         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 394         if (!thisObject)
<span class="line-modified"> 395             return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 396         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 397         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 398         if (shouldThrow)
<span class="line-modified"> 399             return throwVMTypeError(exec, scope);</span>
 400         return JSValue::encode(jsNumber(100));
 401     }
 402 
<span class="line-modified"> 403     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 404     {
<span class="line-modified"> 405         VM&amp; vm = exec-&gt;vm();</span>

 406         auto scope = DECLARE_THROW_SCOPE(vm);
 407 
 408         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 409         if (!thisObject)
<span class="line-modified"> 410             return throwVMTypeError(exec, scope);</span>
<span class="line-modified"> 411         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
 412         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 413         if (shouldThrow)
<span class="line-modified"> 414             return throwVMTypeError(exec, scope);</span>
 415         return JSValue::encode(jsNumber(100));
 416     }
 417 };
 418 
 419 class RuntimeArray : public JSArray {
 420 public:
 421     typedef JSArray Base;
<span class="line-modified"> 422     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;</span>
 423 
<span class="line-modified"> 424     static RuntimeArray* create(ExecState* exec)</span>
 425     {
<span class="line-modified"> 426         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 427         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
 428         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
<span class="line-modified"> 429         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);</span>
<span class="line-modified"> 430         runtimeArray-&gt;finishCreation(exec);</span>
 431         vm.heap.addFinalizer(runtimeArray, destroy);
 432         return runtimeArray;
 433     }
 434 
 435     ~RuntimeArray() { }
 436 
 437     static void destroy(JSCell* cell)
 438     {

 439         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 440     }
 441 
<span class="line-modified"> 442     static const bool needsDestruction = false;</span>
 443 
<span class="line-modified"> 444     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 445     {
<span class="line-modified"> 446         VM&amp; vm = exec-&gt;vm();</span>

 447         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 448         if (propertyName == vm.propertyNames-&gt;length) {
 449             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 450             return true;
 451         }
 452 
 453         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 454         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 455             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 456             return true;
 457         }
 458 
<span class="line-modified"> 459         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
 460     }
 461 
<span class="line-modified"> 462     static bool getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)</span>
 463     {

 464         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 465         if (index &lt; thisObject-&gt;getLength()) {
 466             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 467             return true;
 468         }
 469 
<span class="line-modified"> 470         return JSObject::getOwnPropertySlotByIndex(thisObject, exec, index, slot);</span>
 471     }
 472 
<span class="line-modified"> 473     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;)</span>
 474     {
 475         RELEASE_ASSERT_NOT_REACHED();
 476     }
 477 
<span class="line-modified"> 478     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, ExecState*, PropertyName)</span>
 479     {
 480         RELEASE_ASSERT_NOT_REACHED();
 481     }
 482 
 483     unsigned getLength() const { return m_vector.size(); }
 484 
 485     DECLARE_INFO;
 486 
 487     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 488     {

 489         return globalObject-&gt;arrayPrototype();
 490     }
 491 
 492     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 493     {

 494         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 495     }
 496 
 497 protected:
<span class="line-modified"> 498     void finishCreation(ExecState* exec)</span>
 499     {
<span class="line-modified"> 500         VM&amp; vm = exec-&gt;vm();</span>

 501         Base::finishCreation(vm);
 502         ASSERT(inherits(vm, info()));
 503 
<span class="line-modified"> 504         for (size_t i = 0; i &lt; exec-&gt;argumentCount(); i++)</span>
<span class="line-modified"> 505             m_vector.append(exec-&gt;argument(i).toInt32(exec));</span>
 506     }
 507 
 508 private:
<span class="line-modified"> 509     RuntimeArray(ExecState* exec, Structure* structure)</span>
<span class="line-modified"> 510         : JSArray(exec-&gt;vm(), structure, 0)</span>
 511     {

 512     }
 513 
<span class="line-modified"> 514     static EncodedJSValue lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 515     {
<span class="line-modified"> 516         VM&amp; vm = exec-&gt;vm();</span>

 517         auto scope = DECLARE_THROW_SCOPE(vm);
 518 
 519         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 520         if (!thisObject)
<span class="line-modified"> 521             return throwVMTypeError(exec, scope);</span>
 522         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 523     }
 524 
 525     Vector&lt;int&gt; m_vector;
 526 };
 527 













































































































 528 class DOMJITNode : public JSNonFinalObject {
 529 public:
 530     DOMJITNode(VM&amp; vm, Structure* structure)
 531         : Base(vm, structure)
 532     {

 533     }
 534 
 535     DECLARE_INFO;
 536     typedef JSNonFinalObject Base;
<span class="line-modified"> 537     static const unsigned StructureFlags = Base::StructureFlags;</span>
 538 
 539     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 540     {

 541         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 542     }
 543 
 544 #if ENABLE(JIT)
 545     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 546     {

 547         Ref&lt;Snippet&gt; snippet = Snippet::create();
<span class="line-modified"> 548         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 549             CCallHelpers::JumpList failureCases;
 550             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 551             return failureCases;
 552         });
 553         return snippet;
 554     }
 555 #endif
 556 
 557     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 558     {

 559         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
 560         getter-&gt;finishCreation(vm);
 561         return getter;
 562     }
 563 
 564     int32_t value() const
 565     {
 566         return m_value;
 567     }
 568 
 569     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 570 
 571 private:
 572     int32_t m_value { 42 };
 573 };
 574 
 575 class DOMJITGetter : public DOMJITNode {
 576 public:
 577     DOMJITGetter(VM&amp; vm, Structure* structure)
 578         : Base(vm, structure)
 579     {

 580     }
 581 
 582     DECLARE_INFO;
 583     typedef DOMJITNode Base;
<span class="line-modified"> 584     static const unsigned StructureFlags = Base::StructureFlags;</span>
 585 
 586     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 587     {

 588         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 589     }
 590 
 591     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 592     {

 593         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
 594         getter-&gt;finishCreation(vm);
 595         return getter;
 596     }
 597 
 598     class DOMJITAttribute : public DOMJIT::GetterSetter {
 599     public:
<span class="line-modified"> 600         constexpr DOMJITAttribute()</span>
 601             : DOMJIT::GetterSetter(
 602                 DOMJITGetter::customGetter,
 603 #if ENABLE(JIT)
 604                 &amp;callDOMGetter,
 605 #else
 606                 nullptr,
 607 #endif
 608                 SpecInt32Only)
 609         {
 610         }
 611 
 612 #if ENABLE(JIT)
<span class="line-modified"> 613         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 614         {
<span class="line-modified"> 615             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 616             NativeCallFrameTracer tracer(vm, exec);</span>


 617             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 618         }
 619 
 620         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 621         {

 622             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified"> 623             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified"> 624             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 625                 JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified"> 626                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified"> 627                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>

 628                 return CCallHelpers::JumpList();
 629 
 630             });
 631             return snippet;
 632         }
 633 #endif
 634     };
 635 
 636 private:
 637     void finishCreation(VM&amp;);
 638 
<span class="line-modified"> 639     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 640     {
<span class="line-modified"> 641         VM&amp; vm = exec-&gt;vm();</span>

 642         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 643         ASSERT(thisObject);
 644         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 645     }
 646 };
 647 
 648 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 649 
 650 void DOMJITGetter::finishCreation(VM&amp; vm)
 651 {

 652     Base::finishCreation(vm);
 653     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 654     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 655     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 656 }
 657 

 658 class DOMJITGetterComplex : public DOMJITNode {
 659 public:
 660     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 661         : Base(vm, structure)
 662     {

 663     }
 664 
 665     DECLARE_INFO;
 666     typedef DOMJITNode Base;
<span class="line-modified"> 667     static const unsigned StructureFlags = Base::StructureFlags;</span>
 668 
 669     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 670     {

 671         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 672     }
 673 
 674     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 675     {

 676         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
 677         getter-&gt;finishCreation(vm, globalObject);
 678         return getter;
 679     }
 680 
 681     class DOMJITAttribute : public DOMJIT::GetterSetter {
 682     public:
<span class="line-modified"> 683         constexpr DOMJITAttribute()</span>
 684             : DOMJIT::GetterSetter(
 685                 DOMJITGetterComplex::customGetter,
 686 #if ENABLE(JIT)
 687                 &amp;callDOMGetter,
 688 #else
 689                 nullptr,
 690 #endif
 691                 SpecInt32Only)
 692         {
 693         }
 694 
 695 #if ENABLE(JIT)
<span class="line-modified"> 696         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 697         {
<span class="line-modified"> 698             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 699             NativeCallFrameTracer tracer(vm, exec);</span>


 700             auto scope = DECLARE_THROW_SCOPE(vm);
 701             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 702             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 703             if (domjitGetterComplex) {
 704                 if (domjitGetterComplex-&gt;m_enableException)
<span class="line-modified"> 705                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 706             }
 707             return JSValue::encode(jsNumber(object-&gt;value()));
 708         }
 709 
 710         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 711         {

 712             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 713             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 714             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 715             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 716             snippet-&gt;numFPScratchRegisters = 3;
<span class="line-modified"> 717             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>


 718                 JSValueRegs results = params[0].jsValueRegs();
 719                 GPRReg domGPR = params[1].gpr();

 720                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 721                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 722 
<span class="line-modified"> 723                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, domGPR);</span>
 724                 return CCallHelpers::JumpList();
 725             });
 726             return snippet;
 727         }
 728 #endif
 729     };
 730 
 731 private:
 732     void finishCreation(VM&amp;, JSGlobalObject*);
 733 
<span class="line-modified"> 734     static EncodedJSValue JSC_HOST_CALL functionEnableException(ExecState* exec)</span>
 735     {
<span class="line-modified"> 736         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 737         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, exec-&gt;thisValue());</span>

 738         if (object)
 739             object-&gt;m_enableException = true;
 740         return JSValue::encode(jsUndefined());
 741     }
 742 
<span class="line-modified"> 743     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 744     {
<span class="line-modified"> 745         VM&amp; vm = exec-&gt;vm();</span>

 746         auto scope = DECLARE_THROW_SCOPE(vm);
 747 
 748         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 749         ASSERT(thisObject);
 750         if (thisObject-&gt;m_enableException)
<span class="line-modified"> 751             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 752         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 753     }
 754 
 755     bool m_enableException { false };
 756 };
 757 
 758 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 759 
 760 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 761 {

 762     Base::finishCreation(vm);
 763     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 764     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 765     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 766     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 767 }
 768 
 769 class DOMJITFunctionObject : public DOMJITNode {
 770 public:
 771     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 772         : Base(vm, structure)
 773     {

 774     }
 775 
 776     DECLARE_INFO;
 777     typedef DOMJITNode Base;
<span class="line-modified"> 778     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed"> 779 </span>
 780 
 781     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 782     {

 783         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 784     }
 785 
 786     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 787     {

 788         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
 789         object-&gt;finishCreation(vm, globalObject);
 790         return object;
 791     }
 792 
<span class="line-modified"> 793     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 794     {
<span class="line-modified"> 795         VM&amp; vm = exec-&gt;vm();</span>

 796         auto scope = DECLARE_THROW_SCOPE(vm);
 797 
<span class="line-modified"> 798         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());</span>
 799         if (!thisObject)
<span class="line-modified"> 800             return throwVMTypeError(exec, scope);</span>
 801         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 802     }
 803 
<span class="line-modified"> 804     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 805     {
<span class="line-modified"> 806         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 807         NativeCallFrameTracer tracer(vm, exec);</span>


 808         return JSValue::encode(jsNumber(node-&gt;value()));
 809     }
 810 
 811 #if ENABLE(JIT)
 812     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 813     {

 814         Ref&lt;Snippet&gt; snippet = Snippet::create();
 815         snippet-&gt;numFPScratchRegisters = 1;
<span class="line-modified"> 816         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 817             static const double value = 42.0;
 818             CCallHelpers::JumpList failureCases;
 819             // May use scratch registers.
 820             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
 821             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 822             return failureCases;
 823         });
 824         return snippet;
 825     }
 826 #endif
 827 
 828 private:
 829     void finishCreation(VM&amp;, JSGlobalObject*);
 830 };
 831 
 832 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 833 
 834 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 835 {

 836     Base::finishCreation(vm);
 837     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 838 }
 839 
 840 class DOMJITCheckSubClassObject : public DOMJITNode {
 841 public:
 842     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
 843         : Base(vm, structure)
 844     {

 845     }
 846 
 847     DECLARE_INFO;
 848     typedef DOMJITNode Base;
<span class="line-modified"> 849     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed"> 850 </span>
 851 
 852     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 853     {

 854         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 855     }
 856 
 857     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 858     {

 859         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
 860         object-&gt;finishCreation(vm, globalObject);
 861         return object;
 862     }
 863 
<span class="line-modified"> 864     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
 865     {
<span class="line-modified"> 866         VM&amp; vm = exec-&gt;vm();</span>

 867         auto scope = DECLARE_THROW_SCOPE(vm);
 868 
<span class="line-modified"> 869         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());</span>
 870         if (!thisObject)
<span class="line-modified"> 871             return throwVMTypeError(exec, scope);</span>
 872         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 873     }
 874 
<span class="line-modified"> 875     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
 876     {
<span class="line-modified"> 877         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 878         NativeCallFrameTracer tracer(vm, exec);</span>


 879         return JSValue::encode(jsNumber(node-&gt;value()));
 880     }
 881 
 882 private:
 883     void finishCreation(VM&amp;, JSGlobalObject*);
 884 };
 885 
 886 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
 887 
 888 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 889 {

 890     Base::finishCreation(vm);
 891     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 892 }
 893 
 894 class DOMJITGetterBaseJSObject : public DOMJITNode {
 895 public:
 896     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
 897         : Base(vm, structure)
 898     {

 899     }
 900 
 901     DECLARE_INFO;
 902     using Base = DOMJITNode;
<span class="line-modified"> 903     static const unsigned StructureFlags = Base::StructureFlags;</span>
 904 
 905     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 906     {

 907         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 908     }
 909 
 910     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
 911     {

 912         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
 913         getter-&gt;finishCreation(vm);
 914         return getter;
 915     }
 916 
 917     class DOMJITAttribute : public DOMJIT::GetterSetter {
 918     public:
<span class="line-modified"> 919         constexpr DOMJITAttribute()</span>
 920             : DOMJIT::GetterSetter(
 921                 DOMJITGetterBaseJSObject::customGetter,
 922 #if ENABLE(JIT)
 923                 &amp;callDOMGetter,
 924 #else
 925                 nullptr,
 926 #endif
 927                 SpecBytecodeTop)
 928         {
 929         }
 930 
 931 #if ENABLE(JIT)
<span class="line-modified"> 932         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
 933         {
<span class="line-modified"> 934             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 935             NativeCallFrameTracer tracer(vm, exec);</span>


 936             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
 937             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
 938         }
 939 
 940         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 941         {

 942             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified"> 943             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified"> 944             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>

 945                 JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified"> 946                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified"> 947                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>

 948                 return CCallHelpers::JumpList();
 949 
 950             });
 951             return snippet;
 952         }
 953 #endif
 954     };
 955 
 956 private:
 957     void finishCreation(VM&amp;);
 958 
<span class="line-modified"> 959     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
 960     {
<span class="line-modified"> 961         VM&amp; vm = exec-&gt;vm();</span>

 962         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 963         RELEASE_ASSERT(thisObject);
 964         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
 965     }
 966 };
 967 
 968 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
 969 
 970 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
 971 {

 972     Base::finishCreation(vm);
 973     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
 974     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
 975     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 976 }
 977 
 978 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 979 public:
 980     Message(ArrayBufferContents&amp;&amp;, int32_t);
 981     ~Message();
 982 
 983     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 984     int32_t index() const { return m_index; }
 985 
 986 private:
 987     ArrayBufferContents m_contents;
 988     int32_t m_index { 0 };
 989 };
 990 
 991 class JSTestCustomGetterSetter : public JSNonFinalObject {
 992 public:
 993     using Base = JSNonFinalObject;
<span class="line-modified"> 994     static const unsigned StructureFlags = Base::StructureFlags;</span>
 995 
 996     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
 997         : Base(vm, structure)
<span class="line-modified"> 998     { }</span>


 999 
1000     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1001     {

1002         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
1003         result-&gt;finishCreation(vm);
1004         return result;
1005     }
1006 
1007     void finishCreation(VM&amp;);
1008 
1009     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1010     {

1011         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1012     }
1013 
1014     DECLARE_INFO;
1015 };
1016 
1017 
<span class="line-modified">1018 static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)</span>
1019 {
1020     // Passed |this|
1021     return thisValue;
1022 }
1023 
<span class="line-modified">1024 static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)</span>
1025 {
<span class="line-modified">1026     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
1027     // Passed property holder.
1028     return slotValue;
1029 }
1030 
<span class="line-modified">1031 static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)</span>
1032 {
<span class="line-modified">1033     VM&amp; vm = exec-&gt;vm();</span>

1034 
1035     JSValue value = JSValue::decode(encodedValue);
1036     RELEASE_ASSERT(value.isObject());
1037     JSObject* object = asObject(value);
1038     PutPropertySlot slot(object);
<span class="line-modified">1039     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
1040 
1041     return true;
1042 }
1043 
<span class="line-modified">1044 static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)</span>
1045 {
<span class="line-modified">1046     VM&amp; vm = exec-&gt;vm();</span>

1047 
<span class="line-modified">1048     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
1049 
1050     JSValue value = JSValue::decode(encodedValue);
1051     RELEASE_ASSERT(value.isObject());
1052     JSObject* object = asObject(value);
1053     PutPropertySlot slot(object);
<span class="line-modified">1054     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
1055 
1056     return true;
1057 }
1058 
1059 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1060 {

1061     Base::finishCreation(vm);
1062 
1063     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
1064         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1065     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
1066         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1067 }
1068 
1069 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1070 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1071 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1072 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1073 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1074 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1075 #if ENABLE(JIT)
1076 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1077 #else
1078 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1079 #endif
1080 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1081 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1082 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1083 #if ENABLE(JIT)
1084 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1085 #else
1086 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1087 #endif
1088 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1089 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1090 



1091 ElementHandleOwner* Element::handleOwner()
1092 {

1093     static ElementHandleOwner* owner = 0;
1094     if (!owner)
1095         owner = new ElementHandleOwner();
1096     return owner;
1097 }
1098 
1099 void Element::finishCreation(VM&amp; vm, Root* root)
1100 {

1101     Base::finishCreation(vm);
1102     setRoot(vm, root);
1103     m_root-&gt;setElement(this);
1104 }
1105 
1106 #if ENABLE(WEBASSEMBLY)
1107 
<span class="line-modified">1108 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);</span>
<span class="line-modified">1109 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);</span>
1110 
1111 class WasmStreamingParser : public JSDestructibleObject {
1112 public:














1113     WasmStreamingParser(VM&amp; vm, Structure* structure)
1114         : Base(vm, structure)
1115         , m_info(Wasm::ModuleInformation::create())
<span class="line-modified">1116         , m_streamingParser(m_info.get())</span>

1117     {

1118     }
1119 
1120     using Base = JSDestructibleObject;
1121 
1122     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1123     {

1124         Structure* structure = createStructure(vm, globalObject, jsNull());
1125         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
1126         result-&gt;finishCreation(vm);
1127         return result;
1128     }
1129 
1130     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1131     {

1132         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1133     }
1134 
1135     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1136 
1137     void finishCreation(VM&amp; vm)
1138     {

1139         Base::finishCreation(vm);
1140 
1141         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1142         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1143         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1144     }
1145 
1146     DECLARE_INFO;
1147 
1148     Ref&lt;Wasm::ModuleInformation&gt; m_info;

1149     Wasm::StreamingParser m_streamingParser;
1150 };
1151 
1152 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1153 
<span class="line-modified">1154 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)</span>
1155 {
<span class="line-modified">1156     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1157     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">1158     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>


1159     if (!thisObject)
1160         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1161 
<span class="line-modified">1162     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));</span>
1163     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1164     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1165 }
1166 
<span class="line-modified">1167 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState* exec)</span>
1168 {
<span class="line-modified">1169     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1170     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>

1171     if (!thisObject)
1172         return JSValue::encode(jsBoolean(false));
1173     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1174 }
1175 
1176 #endif
1177 
1178 } // namespace
1179 
1180 namespace JSC {
1181 
1182 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1183 
1184 // Triggers a crash immediately.
1185 // Usage: $vm.crash()
<span class="line-modified">1186 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(ExecState*)</span>
1187 {

1188     CRASH();
1189 }
1190 
1191 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1192 // Usage: $vm.breakpoint(&lt;condition&gt;)
<span class="line-modified">1193 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(ExecState* exec)</span>
1194 {

1195     // Nothing should throw here but we might as well double check...
<span class="line-modified">1196     VM&amp; vm = exec-&gt;vm();</span>
1197     auto scope = DECLARE_CATCH_SCOPE(vm);
1198     UNUSED_PARAM(scope);
<span class="line-modified">1199     if (!exec-&gt;argumentCount() || exec-&gt;argument(0).toBoolean(exec))</span>
1200         WTFBreakpointTrap();
1201 
1202     return encodedJSUndefined();
1203 }
1204 
1205 // Returns true if the current frame is a DFG frame.
1206 // Usage: isDFG = $vm.dfgTrue()
<span class="line-modified">1207 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(ExecState*)</span>
1208 {

1209     return JSValue::encode(jsBoolean(false));
1210 }
1211 
1212 // Returns true if the current frame is a FTL frame.
1213 // Usage: isFTL = $vm.ftlTrue()
<span class="line-modified">1214 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(ExecState*)</span>
1215 {

1216     return JSValue::encode(jsBoolean(false));
1217 }
1218 
<span class="line-modified">1219 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(ExecState*)</span>
1220 {

1221 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1222     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1223 #endif
1224     return JSValue::encode(jsUndefined());
1225 }
1226 
<span class="line-modified">1227 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(ExecState*)</span>
1228 {

1229 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1230     unsigned high;
1231     unsigned low;
1232     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1233     return JSValue::encode(jsNumber(low));
1234 #else
1235     return JSValue::encode(jsNumber(0));
1236 #endif
1237 }
1238 
<span class="line-modified">1239 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(ExecState*)</span>
1240 {

1241 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1242     WTF::x86_cpuid();
1243 #endif
1244     return JSValue::encode(jsUndefined());
1245 }
1246 
<span class="line-modified">1247 static EncodedJSValue JSC_HOST_CALL functionCpuPause(ExecState*)</span>
1248 {

1249 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1250     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1251 #endif
1252     return JSValue::encode(jsUndefined());
1253 }
1254 
1255 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1256 // argument. The second argument is expected to be an integer.
1257 //
1258 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1259 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1260 // itself so its length, etc, aren&#39;t in the cache.
1261 //
1262 // If the first argument is not a JSArrayBuffer, we load the butterfly
1263 // and clflush at the address of the butterfly.
<span class="line-modified">1264 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(ExecState* exec)</span>
1265 {

1266 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
<span class="line-modified">1267     VM&amp; vm = exec-&gt;vm();</span>
1268 
<span class="line-modified">1269     if (!exec-&gt;argument(1).isInt32())</span>
1270         return JSValue::encode(jsBoolean(false));
1271 
1272     auto clflush = [] (void* ptr) {

1273         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1274         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1275     };
1276 
1277     Vector&lt;void*&gt; toFlush;
1278 
<span class="line-modified">1279     uint32_t offset = exec-&gt;argument(1).asUInt32();</span>
1280 
<span class="line-modified">1281     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, exec-&gt;argument(0)))</span>
1282         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
<span class="line-modified">1283     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0))) {</span>
1284         switch (object-&gt;indexingType()) {
1285         case ALL_INT32_INDEXING_TYPES:
1286         case ALL_CONTIGUOUS_INDEXING_TYPES:
1287         case ALL_DOUBLE_INDEXING_TYPES:
1288             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1289             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1290         }
1291     }
1292 
1293     if (!toFlush.size())
1294         return JSValue::encode(jsBoolean(false));
1295 
1296     for (void* ptr : toFlush)
1297         clflush(ptr);
1298     return JSValue::encode(jsBoolean(true));
1299 #else
<span class="line-modified">1300     UNUSED_PARAM(exec);</span>

1301     return JSValue::encode(jsBoolean(false));
1302 #endif
1303 }
1304 
1305 class CallerFrameJITTypeFunctor {
1306 public:
1307     CallerFrameJITTypeFunctor()
1308         : m_currentFrame(0)
1309         , m_jitType(JITType::None)
1310     {

1311     }
1312 
1313     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1314     {
1315         if (m_currentFrame++ &gt; 1) {
1316             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1317             return StackVisitor::Done;
1318         }
1319         return StackVisitor::Continue;
1320     }
1321 
1322     JITType jitType() { return m_jitType; }
1323 
1324 private:
1325     mutable unsigned m_currentFrame;
1326     mutable JITType m_jitType;
1327 };
1328 
1329 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1330 {

1331     if (!theFunctionValue.isCell())
1332         return nullptr;
1333 
1334     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
1335     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1336     if (!theFunction)
1337         return nullptr;
1338 
1339     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1340         theFunction-&gt;executable());
1341 
1342     return executable;
1343 }
1344 
1345 // Returns true if the current frame is a LLInt frame.
1346 // Usage: isLLInt = $vm.llintTrue()
<span class="line-modified">1347 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)</span>
1348 {
<span class="line-modified">1349     if (!exec)</span>


1350         return JSValue::encode(jsUndefined());
1351     CallerFrameJITTypeFunctor functor;
<span class="line-modified">1352     exec-&gt;iterate(functor);</span>
1353     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
1354 }
1355 
1356 // Returns true if the current frame is a baseline JIT frame.
1357 // Usage: isBaselineJIT = $vm.jitTrue()
<span class="line-modified">1358 static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)</span>
1359 {
<span class="line-modified">1360     if (!exec)</span>


1361         return JSValue::encode(jsUndefined());
1362     CallerFrameJITTypeFunctor functor;
<span class="line-modified">1363     exec-&gt;iterate(functor);</span>
1364     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
1365 }
1366 
1367 // Set that the argument function should not be inlined.
1368 // Usage:
1369 // function f() { };
1370 // $vm.noInline(f);
<span class="line-modified">1371 static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)</span>
1372 {
<span class="line-modified">1373     if (exec-&gt;argumentCount() &lt; 1)</span>

1374         return JSValue::encode(jsUndefined());
1375 
<span class="line-modified">1376     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);</span>
1377 
1378     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1379         executable-&gt;setNeverInline(true);
1380 
1381     return JSValue::encode(jsUndefined());
1382 }
1383 
1384 // Runs a full GC synchronously.
1385 // Usage: $vm.gc()
<span class="line-modified">1386 static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)</span>
1387 {
<span class="line-modified">1388     VMInspector::gc(exec);</span>

1389     return JSValue::encode(jsUndefined());
1390 }
1391 
1392 // Runs the edenGC synchronously.
1393 // Usage: $vm.edenGC()
<span class="line-modified">1394 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
1395 {
<span class="line-modified">1396     VMInspector::edenGC(exec);</span>

1397     return JSValue::encode(jsUndefined());
1398 }
1399 
1400 // Dumps the hashes of all subspaces currently registered with the VM.
1401 // Usage: $vm.dumpSubspaceHashes()
<span class="line-modified">1402 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(ExecState* exec)</span>
1403 {
<span class="line-modified">1404     VM&amp; vm = exec-&gt;vm();</span>

1405     VMInspector::dumpSubspaceHashes(&amp;vm);
1406     return JSValue::encode(jsUndefined());
1407 }
1408 
1409 // Gets a JSDollarVMCallFrame for a specified frame index.
1410 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1411 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1412 //
1413 // This gives you the ability to query the following:
1414 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1415 //    callFrame.callee;
1416 //    callFrame.codeBlock;
1417 //    callFrame.unlinkedCodeBlock;
1418 //    callFrame.executable;
1419 //
1420 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1421 // there are internal objects and not a JS object. Hence, you cannot do string
1422 // concatenation with them.
<span class="line-modified">1423 static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)</span>
1424 {

1425     unsigned frameNumber = 1;
<span class="line-modified">1426     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1427         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1428         if (!value.isUInt32())
1429             return JSValue::encode(jsUndefined());
1430 
1431         // We need to inc the frame number because the caller would consider
1432         // its own frame as frame 0. Hence, we need discount the frame for this
1433         // function.
1434         frameNumber = value.asUInt32() + 1;
1435     }
1436 
<span class="line-modified">1437     return JSValue::encode(JSDollarVMCallFrame::create(exec, frameNumber));</span>
1438 }
1439 
1440 // Gets a token for the CodeBlock for a specified frame index.
1441 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1442 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
<span class="line-modified">1443 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(ExecState* exec)</span>
1444 {

1445     unsigned frameNumber = 1;
<span class="line-modified">1446     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1447         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1448         if (!value.isUInt32())
1449             return JSValue::encode(jsUndefined());
1450 
1451         // We need to inc the frame number because the caller would consider
1452         // its own frame as frame 0. Hence, we need discount the frame for this
1453         // function.
1454         frameNumber = value.asUInt32() + 1;
1455     }
1456 
<span class="line-modified">1457     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(exec, frameNumber);</span>
1458     if (codeBlock)
1459         return JSValue::encode(codeBlock);
1460     return JSValue::encode(jsUndefined());
1461 }
1462 
<span class="line-modified">1463 static CodeBlock* codeBlockFromArg(ExecState* exec)</span>
1464 {
<span class="line-modified">1465     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1466     if (exec-&gt;argumentCount() &lt; 1)</span>

1467         return nullptr;
1468 
<span class="line-modified">1469     JSValue value = exec-&gt;uncheckedArgument(0);</span>
1470     CodeBlock* candidateCodeBlock = nullptr;
1471     if (value.isCell()) {
1472         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1473         if (func) {
1474             if (func-&gt;isHostFunction())
1475                 candidateCodeBlock = nullptr;
1476             else
1477                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1478         } else
1479             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1480     }
1481 
<span class="line-modified">1482     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))</span>
1483         return candidateCodeBlock;
1484 
1485     if (candidateCodeBlock)
1486         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1487     else
1488         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1489     return nullptr;
1490 }
1491 
1492 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1493 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1494 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1495 // a JS object. Hence, you cannot do string concatenation with it.
<span class="line-modified">1496 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)</span>
1497 {
<span class="line-modified">1498     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1499     WTF::StringPrintStream stream;
1500     if (codeBlock) {
1501         stream.print(*codeBlock);
<span class="line-modified">1502         return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1503     }
1504     return JSValue::encode(jsUndefined());
1505 }
1506 
1507 // Usage: $vm.dumpSourceFor(functionObj)
1508 // Usage: $vm.dumpSourceFor(codeBlockToken)
<span class="line-modified">1509 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)</span>
1510 {
<span class="line-modified">1511     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1512     if (codeBlock)
1513         codeBlock-&gt;dumpSource();
1514     return JSValue::encode(jsUndefined());
1515 }
1516 
1517 // Usage: $vm.dumpBytecodeFor(functionObj)
1518 // Usage: $vm.dumpBytecodeFor(codeBlock)
<span class="line-modified">1519 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)</span>
1520 {
<span class="line-modified">1521     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>

1522     if (codeBlock)
1523         codeBlock-&gt;dumpBytecode();
1524     return JSValue::encode(jsUndefined());
1525 }
1526 
<span class="line-modified">1527 static EncodedJSValue doPrint(ExecState* exec, bool addLineFeed)</span>
1528 {
<span class="line-modified">1529     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">1530     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1531         JSValue arg = exec-&gt;uncheckedArgument(i);</span>

1532         if (arg.isCell()
1533             &amp;&amp; !arg.isObject()
1534             &amp;&amp; !arg.isString()
1535             &amp;&amp; !arg.isBigInt()) {
1536             dataLog(arg);
1537             continue;
1538         }
<span class="line-modified">1539         String argStr = exec-&gt;uncheckedArgument(i).toWTFString(exec);</span>
1540         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1541         dataLog(argStr);
1542     }
1543     if (addLineFeed)
1544         dataLog(&quot;\n&quot;);
1545     return JSValue::encode(jsUndefined());
1546 }
1547 
1548 // Prints a series of comma separate strings without appending a newline.
1549 // Usage: $vm.dataLog(str1, str2, str3)
<span class="line-modified">1550 static EncodedJSValue JSC_HOST_CALL functionDataLog(ExecState* exec)</span>
1551 {

1552     const bool addLineFeed = false;
<span class="line-modified">1553     return doPrint(exec, addLineFeed);</span>
1554 }
1555 
1556 // Prints a series of comma separate strings and appends a newline.
1557 // Usage: $vm.print(str1, str2, str3)
<span class="line-modified">1558 static EncodedJSValue JSC_HOST_CALL functionPrint(ExecState* exec)</span>
1559 {

1560     const bool addLineFeed = true;
<span class="line-modified">1561     return doPrint(exec, addLineFeed);</span>
1562 }
1563 
1564 // Dumps the current CallFrame.
1565 // Usage: $vm.dumpCallFrame()
<span class="line-modified">1566 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(ExecState* exec)</span>
1567 {

1568     // When the callers call this function, they are expecting to dump their
1569     // own frame. So skip 1 for this frame.
<span class="line-modified">1570     VMInspector::dumpCallFrame(exec, 1);</span>
1571     return JSValue::encode(jsUndefined());
1572 }
1573 
1574 // Dumps the JS stack.
1575 // Usage: $vm.printStack()
<span class="line-modified">1576 static EncodedJSValue JSC_HOST_CALL functionDumpStack(ExecState* exec)</span>
1577 {

1578     // When the callers call this function, they are expecting to dump the
1579     // stack starting their own frame. So skip 1 for this frame.
<span class="line-modified">1580     VMInspector::dumpStack(exec, 1);</span>
1581     return JSValue::encode(jsUndefined());
1582 }
1583 
1584 // Dumps the current CallFrame.
1585 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1586 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1587 // FIXME: Currently, this function dumps the physical frame. We should make
1588 // it dump the logical frame (i.e. be able to dump inlined frames as well).
<span class="line-modified">1589 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(ExecState* exec)</span>
1590 {


1591     unsigned requestedFrameIndex = 1;
<span class="line-modified">1592     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1593         JSValue value = exec-&gt;uncheckedArgument(0);</span>
1594         if (!value.isUInt32())
1595             return JSValue::encode(jsUndefined());
1596 
1597         // We need to inc the frame number because the caller would consider
1598         // its own frame as frame 0. Hence, we need discount the frame for this
1599         // function.
1600         requestedFrameIndex = value.asUInt32() + 1;
1601     }
1602 
1603     unsigned frameIndex = 0;
<span class="line-modified">1604     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>

1605         if (frameIndex++ != requestedFrameIndex)
1606             return StackVisitor::Continue;
1607         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1608         return StackVisitor::Done;
1609     });
1610 
1611     return encodedJSUndefined();
1612 }
1613 
1614 // Dumps the internal memory layout of a JSCell.
1615 // Usage: $vm.dumpCell(cell)
<span class="line-modified">1616 static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)</span>
1617 {
<span class="line-modified">1618     JSValue value = exec-&gt;argument(0);</span>

1619     if (!value.isCell())
1620         return encodedJSUndefined();
1621 
1622     VMInspector::dumpCellMemory(value.asCell());
1623     return encodedJSUndefined();
1624 }
1625 
1626 // Gets the dataLog dump of the indexingMode of the passed value.
1627 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
<span class="line-modified">1628 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)</span>
1629 {
<span class="line-modified">1630     if (!exec-&gt;argument(0).isObject())</span>

1631         return encodedJSUndefined();
1632 
1633     WTF::StringPrintStream stream;
<span class="line-modified">1634     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));</span>
<span class="line-modified">1635     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1636 }
1637 
<span class="line-modified">1638 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)</span>
1639 {
<span class="line-modified">1640     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1641     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))</span>

1642         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1643 
1644     return encodedJSUndefined();
1645 }
1646 
1647 // Gets the dataLog dump of a given JS value as a string.
1648 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
<span class="line-modified">1649 static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)</span>
1650 {

1651     WTF::StringPrintStream stream;
<span class="line-modified">1652     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
1653         if (i)
1654             stream.print(&quot;, &quot;);
<span class="line-modified">1655         stream.print(exec-&gt;uncheckedArgument(i));</span>
1656     }
1657 
<span class="line-modified">1658     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
1659 }
1660 
1661 // Gets the pid of the current process.
1662 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
<span class="line-modified">1663 static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)</span>
1664 {

1665     return JSValue::encode(jsNumber(getCurrentProcessID()));
1666 }
1667 
1668 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1669 // Usage: $vm.haveABadTime(globalObject)
<span class="line-modified">1670 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)</span>
1671 {
<span class="line-modified">1672     VM&amp; vm = exec-&gt;vm();</span>

1673     JSLockHolder lock(vm);
<span class="line-modified">1674     JSValue objValue = exec-&gt;argument(0);</span>
1675     if (!objValue.isObject())
1676         return JSValue::encode(jsBoolean(false));
1677 
1678     JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">1679     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">1680     if (!globalObject)</span>
1681         JSValue::encode(jsBoolean(false));
1682 
<span class="line-modified">1683     globalObject-&gt;haveABadTime(vm);</span>
1684     return JSValue::encode(jsBoolean(true));
1685 }
1686 
1687 // Checks if the object (or its global if the object is not a global) is having a bad time.
1688 // Usage: $vm.isHavingABadTime(obj)
<span class="line-modified">1689 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(ExecState* exec)</span>
1690 {
<span class="line-modified">1691     VM&amp; vm = exec-&gt;vm();</span>

1692     JSLockHolder lock(vm);
<span class="line-modified">1693     JSValue objValue = exec-&gt;argument(0);</span>
1694     if (!objValue.isObject())
1695         return JSValue::encode(jsUndefined());
1696 
1697     JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">1698     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">1699     if (globalObject)</span>
<span class="line-modified">1700         JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>
1701 
<span class="line-modified">1702     globalObject = obj-&gt;globalObject();</span>
<span class="line-modified">1703     if (!globalObject)</span>
1704         return JSValue::encode(jsUndefined());
1705 
<span class="line-modified">1706     return JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>

























































































































1707 }
1708 
1709 // Creates a new global object.
1710 // Usage: $vm.createGlobalObject()
<span class="line-modified">1711 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
1712 {
<span class="line-modified">1713     VM&amp; vm = exec-&gt;vm();</span>

1714     JSLockHolder lock(vm);
<span class="line-modified">1715     JSGlobalObject* globalObject = JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull()));</span>
<span class="line-removed">1716     return JSValue::encode(globalObject);</span>
1717 }
1718 
<span class="line-modified">1719 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)</span>
1720 {
<span class="line-modified">1721     VM&amp; vm = exec-&gt;vm();</span>

1722     JSLockHolder lock(vm);
<span class="line-modified">1723     JSValue target = exec-&gt;argument(0);</span>
1724     if (!target.isObject())
1725         return JSValue::encode(jsUndefined());
1726     JSObject* jsTarget = asObject(target.asCell());
<span class="line-modified">1727     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);</span>
1728     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
1729     return JSValue::encode(proxy);
1730 }
1731 
<span class="line-modified">1732 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)</span>
1733 {
<span class="line-modified">1734     JSLockHolder lock(exec);</span>
<span class="line-modified">1735     RuntimeArray* array = RuntimeArray::create(exec);</span>

1736     return JSValue::encode(array);
1737 }
1738 
<span class="line-modified">1739 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(ExecState* exec)</span>
1740 {
<span class="line-modified">1741     VM&amp; vm = exec-&gt;vm();</span>

1742     JSLockHolder lock(vm);
1743     return JSValue::encode(JSRopeString::createNullForTesting(vm));
1744 }
1745 
<span class="line-modified">1746 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)</span>
1747 {
<span class="line-modified">1748     VM&amp; vm = exec-&gt;vm();</span>

1749     JSLockHolder lock(vm);
<span class="line-modified">1750     JSValue target = exec-&gt;argument(0);</span>
1751     JSObject* delegate = nullptr;
1752     if (target.isObject())
1753         delegate = asObject(target.asCell());
<span class="line-modified">1754     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1755     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
1756     return JSValue::encode(result);
1757 }
1758 
<span class="line-modified">1759 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)</span>
1760 {
<span class="line-modified">1761     VM&amp; vm = exec-&gt;vm();</span>

1762     JSLockHolder lock(vm);
<span class="line-modified">1763     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1764     CustomGetter* result = CustomGetter::create(vm, structure);
1765     return JSValue::encode(result);
1766 }
1767 
<span class="line-modified">1768 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(ExecState* exec)</span>
1769 {
<span class="line-modified">1770     VM&amp; vm = exec-&gt;vm();</span>

1771     JSLockHolder lock(vm);
<span class="line-modified">1772     Structure* structure = DOMJITNode::createStructure(vm, exec-&gt;lexicalGlobalObject(), DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull())));</span>
1773     DOMJITNode* result = DOMJITNode::create(vm, structure);
1774     return JSValue::encode(result);
1775 }
1776 
<span class="line-modified">1777 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(ExecState* exec)</span>
1778 {
<span class="line-modified">1779     VM&amp; vm = exec-&gt;vm();</span>

1780     JSLockHolder lock(vm);
<span class="line-modified">1781     Structure* structure = DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1782     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
1783     return JSValue::encode(result);
1784 }
1785 
<span class="line-modified">1786 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(ExecState* exec)</span>
1787 {
<span class="line-modified">1788     VM&amp; vm = exec-&gt;vm();</span>

1789     JSLockHolder lock(vm);
<span class="line-modified">1790     Structure* structure = DOMJITGetterComplex::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1791     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1792     return JSValue::encode(result);
1793 }
1794 
<span class="line-modified">1795 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(ExecState* exec)</span>
1796 {
<span class="line-modified">1797     VM&amp; vm = exec-&gt;vm();</span>

1798     JSLockHolder lock(vm);
<span class="line-modified">1799     Structure* structure = DOMJITFunctionObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1800     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1801     return JSValue::encode(result);
1802 }
1803 
<span class="line-modified">1804 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(ExecState* exec)</span>
1805 {
<span class="line-modified">1806     VM&amp; vm = exec-&gt;vm();</span>

1807     JSLockHolder lock(vm);
<span class="line-modified">1808     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">1809     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
1810     return JSValue::encode(result);
1811 }
1812 
<span class="line-modified">1813 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(ExecState* exec)</span>
1814 {
<span class="line-modified">1815     VM&amp; vm = exec-&gt;vm();</span>

1816     JSLockHolder lock(vm);
<span class="line-modified">1817     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
1818     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
1819     return JSValue::encode(result);
1820 }
1821 
1822 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">1823 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(ExecState* exec)</span>
1824 {
<span class="line-modified">1825     VM&amp; vm = exec-&gt;vm();</span>

1826     JSLockHolder lock(vm);
<span class="line-modified">1827     return JSValue::encode(WasmStreamingParser::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1828 }
1829 #endif
1830 
<span class="line-modified">1831 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)</span>










1832 {
<span class="line-modified">1833     VM&amp; vm = exec-&gt;vm();</span>













1834     JSLockHolder lock(vm);
1835     auto scope = DECLARE_THROW_SCOPE(vm);
1836 
<span class="line-modified">1837     JSValue base = exec-&gt;argument(0);</span>
1838     if (!base.isObject())
1839         return JSValue::encode(jsUndefined());
<span class="line-modified">1840     JSValue delegate = exec-&gt;argument(1);</span>
1841     if (!delegate.isObject())
1842         return JSValue::encode(jsUndefined());
1843     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
1844     if (UNLIKELY(!impureGetter)) {
<span class="line-modified">1845         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);</span>
1846         return encodedJSValue();
1847     }
1848     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
1849     return JSValue::encode(jsUndefined());
1850 }
1851 
<span class="line-modified">1852 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)</span>
1853 {
<span class="line-modified">1854     VM&amp; vm = exec-&gt;vm();</span>

1855     auto scope = DECLARE_THROW_SCOPE(vm);
1856 
<span class="line-modified">1857     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())</span>
1858         return JSValue::encode(jsUndefined());
1859 
<span class="line-modified">1860     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);</span>
1861     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1862 
<span class="line-modified">1863     const SourceCode&amp; source = makeSource(functionText, { });</span>
<span class="line-modified">1864     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), exec-&gt;lexicalGlobalObject());</span>
1865 
1866     return JSValue::encode(func);
1867 }
1868 
<span class="line-modified">1869 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)</span>
1870 {
<span class="line-modified">1871     VM&amp; vm = exec-&gt;vm();</span>

1872     auto scope = DECLARE_THROW_SCOPE(vm);
1873 
<span class="line-modified">1874     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())</span>
1875         return encodedJSUndefined();
1876 
<span class="line-modified">1877     String str = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
1878 
1879     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
1880     if (!symbol)
<span class="line-modified">1881         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);</span>
1882 
<span class="line-modified">1883     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));</span>
1884 }
1885 
<span class="line-modified">1886 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)</span>
1887 {
<span class="line-modified">1888     VM&amp; vm = exec-&gt;vm();</span>

1889     JSLockHolder lock(vm);
<span class="line-modified">1890     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1891 }
1892 
<span class="line-modified">1893 static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)</span>
1894 {
<span class="line-modified">1895     VM&amp; vm = exec-&gt;vm();</span>

1896     JSLockHolder lock(vm);
1897     auto scope = DECLARE_THROW_SCOPE(vm);
1898 
<span class="line-modified">1899     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
1900     if (!root)
<span class="line-modified">1901         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Cannot create Element without a Root.&quot;_s)));</span>
<span class="line-modified">1902     return JSValue::encode(Element::create(vm, exec-&gt;lexicalGlobalObject(), root));</span>
1903 }
1904 
<span class="line-modified">1905 static EncodedJSValue JSC_HOST_CALL functionGetElement(ExecState* exec)</span>
1906 {
<span class="line-modified">1907     VM&amp; vm = exec-&gt;vm();</span>

1908     JSLockHolder lock(vm);
<span class="line-modified">1909     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
1910     if (!root)
1911         return JSValue::encode(jsUndefined());
1912     Element* result = root-&gt;element();
1913     return JSValue::encode(result ? result : jsUndefined());
1914 }
1915 
<span class="line-modified">1916 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(ExecState* exec)</span>
1917 {
<span class="line-modified">1918     VM&amp; vm = exec-&gt;vm();</span>

1919     JSLockHolder lock(vm);
<span class="line-modified">1920     return JSValue::encode(SimpleObject::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1921 }
1922 
<span class="line-modified">1923 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(ExecState* exec)</span>
1924 {
<span class="line-modified">1925     VM&amp; vm = exec-&gt;vm();</span>

1926     JSLockHolder lock(vm);
1927     auto scope = DECLARE_THROW_SCOPE(vm);
1928 
<span class="line-modified">1929     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
1930     if (UNLIKELY(!simpleObject)) {
<span class="line-modified">1931         throwTypeError(exec, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);</span>
1932         return encodedJSValue();
1933     }
1934     return JSValue::encode(simpleObject-&gt;hiddenValue());
1935 }
1936 
<span class="line-modified">1937 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState* exec)</span>
1938 {
<span class="line-modified">1939     VM&amp; vm = exec-&gt;vm();</span>

1940     JSLockHolder lock(vm);
1941     auto scope = DECLARE_THROW_SCOPE(vm);
1942 
<span class="line-modified">1943     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
1944     if (UNLIKELY(!simpleObject)) {
<span class="line-modified">1945         throwTypeError(exec, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);</span>
1946         return encodedJSValue();
1947     }
<span class="line-modified">1948     JSValue value = exec-&gt;argument(1);</span>
1949     simpleObject-&gt;setHiddenValue(vm, value);
1950     return JSValue::encode(jsUndefined());
1951 }
1952 
<span class="line-modified">1953 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(ExecState* exec)</span>
1954 {
<span class="line-modified">1955     VM&amp; vm = exec-&gt;vm();</span>

1956     auto scope = DECLARE_THROW_SCOPE(vm);
1957     if (auto* shadowChicken = vm.shadowChicken()) {
1958         scope.release();
<span class="line-modified">1959         return JSValue::encode(shadowChicken-&gt;functionsOnStack(exec));</span>
1960     }
1961 
<span class="line-modified">1962     JSArray* result = constructEmptyArray(exec, 0);</span>
1963     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1964     StackVisitor::visit(exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>

1965         if (visitor-&gt;isInlinedFrame())
1966             return StackVisitor::Continue;
1967         if (visitor-&gt;isWasmFrame())
1968             return StackVisitor::Continue;
<span class="line-modified">1969         result-&gt;push(exec, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));</span>
1970         scope.releaseAssertNoException(); // This function is only called from tests.
1971         return StackVisitor::Continue;
1972     });
1973     RETURN_IF_EXCEPTION(scope, { });
1974     return JSValue::encode(result);
1975 }
1976 
<span class="line-modified">1977 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(ExecState* exec)</span>
1978 {
<span class="line-modified">1979     VM&amp; vm = exec-&gt;vm();</span>

1980     vm.setGlobalConstRedeclarationShouldThrow(false);
1981     return JSValue::encode(jsUndefined());
1982 }
1983 
<span class="line-modified">1984 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(ExecState* exec)</span>
1985 {
<span class="line-modified">1986     VM&amp; vm = exec-&gt;vm();</span>

1987     RELEASE_ASSERT(vm.typeProfiler());
1988     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
1989 
<span class="line-modified">1990     JSValue functionValue = exec-&gt;argument(0);</span>
1991     RELEASE_ASSERT(functionValue.isFunction(vm));
1992     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
1993 
<span class="line-modified">1994     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">1995     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
1996     String sourceCodeText = executable-&gt;source().view().toString();
1997     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
1998 
1999     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">2000     return JSValue::encode(JSONParse(exec, jsonString));</span>
2001 }
2002 
<span class="line-modified">2003 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(ExecState* exec)</span>
2004 {
<span class="line-modified">2005     VM&amp; vm = exec-&gt;vm();</span>

2006     RELEASE_ASSERT(vm.typeProfiler());
2007     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
2008 
<span class="line-modified">2009     JSValue functionValue = exec-&gt;argument(0);</span>
2010     RELEASE_ASSERT(functionValue.isFunction(vm));
2011     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2012 
2013     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
2014     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">2015     return JSValue::encode(JSONParse(exec, jsonString));</span>
2016 }
2017 
<span class="line-modified">2018 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(ExecState* exec)</span>
2019 {
<span class="line-modified">2020     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2021     JSValue value = exec-&gt;argument(0);</span>

2022     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2023     value.getObject()-&gt;flattenDictionaryObject(vm);
2024     return encodedJSUndefined();
2025 }
2026 
<span class="line-modified">2027 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(ExecState* exec)</span>
2028 {
<span class="line-modified">2029     VM&amp; vm = exec-&gt;vm();</span>

2030     RELEASE_ASSERT(vm.controlFlowProfiler());
2031     vm.controlFlowProfiler()-&gt;dumpData();
2032     return JSValue::encode(jsUndefined());
2033 }
2034 
<span class="line-modified">2035 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(ExecState* exec)</span>
2036 {
<span class="line-modified">2037     VM&amp; vm = exec-&gt;vm();</span>

2038     RELEASE_ASSERT(vm.controlFlowProfiler());
2039 
<span class="line-modified">2040     JSValue functionValue = exec-&gt;argument(0);</span>
2041     RELEASE_ASSERT(functionValue.isFunction(vm));
2042     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2043 
<span class="line-modified">2044     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">2045     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
2046     String sourceCodeText = executable-&gt;source().view().toString();
2047     RELEASE_ASSERT(sourceCodeText.contains(substring));
2048     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2049 
2050     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2051     return JSValue::encode(jsBoolean(hasExecuted));
2052 }
2053 
<span class="line-modified">2054 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(ExecState* exec)</span>
2055 {
<span class="line-modified">2056     VM&amp; vm = exec-&gt;vm();</span>

2057     RELEASE_ASSERT(vm.controlFlowProfiler());
2058 
<span class="line-modified">2059     JSValue functionValue = exec-&gt;argument(0);</span>
2060     RELEASE_ASSERT(functionValue.isFunction(vm));
2061     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2062 
<span class="line-modified">2063     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">2064     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
2065     String sourceCodeText = executable-&gt;source().view().toString();
2066     RELEASE_ASSERT(sourceCodeText.contains(substring));
2067     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2068 
2069     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2070     return JSValue::encode(JSValue(executionCount));
2071 }
2072 
<span class="line-modified">2073 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)</span>
2074 {

2075     Options::useExceptionFuzz() = true;
2076     return JSValue::encode(jsUndefined());
2077 }
2078 
<span class="line-modified">2079 static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>


















2080 {
<span class="line-modified">2081     bool newDebuggerMode = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
<span class="line-modified">2082     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)</span>


2083         return JSValue::encode(jsUndefined());
2084 
<span class="line-modified">2085     VM* vm = &amp;exec-&gt;vm();</span>
2086     vm-&gt;whenIdle([=] () {
<span class="line-modified">2087         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;</span>
<span class="line-modified">2088         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);</span>
<span class="line-modified">2089         if (newDebuggerMode)</span>
<span class="line-modified">2090             vm-&gt;ensureShadowChicken();</span>







2091     });
2092     return JSValue::encode(jsUndefined());
2093 }
2094 
<span class="line-modified">2095 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)</span>
2096 {
<span class="line-modified">2097     return changeDebuggerModeWhenIdle(exec, { CodeGenerationMode::Debugger });</span>

2098 }
2099 
<span class="line-modified">2100 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)</span>
2101 {
<span class="line-modified">2102     return changeDebuggerModeWhenIdle(exec, { });</span>

2103 }
2104 
<span class="line-modified">2105 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(ExecState* exec)</span>
2106 {
<span class="line-modified">2107     VM* vm = &amp;exec-&gt;vm();</span>

2108     vm-&gt;whenIdle([=] () {

2109         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2110     });
2111     return JSValue::encode(jsUndefined());
2112 }
2113 
<span class="line-modified">2114 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)</span>
2115 {
<span class="line-modified">2116     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));</span>

2117 }
2118 
<span class="line-modified">2119 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)</span>
2120 {
<span class="line-modified">2121     JSValue value = exec-&gt;argument(0);</span>

2122     RELEASE_ASSERT(value.isObject());
<span class="line-modified">2123     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());</span>
<span class="line-modified">2124     RELEASE_ASSERT(globalObject);</span>
<span class="line-modified">2125     return JSValue::encode(globalObject);</span>
2126 }
2127 
<span class="line-modified">2128 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)</span>
2129 {
<span class="line-modified">2130     VM&amp; vm = exec-&gt;vm();</span>

2131     auto scope = DECLARE_THROW_SCOPE(vm);
2132 
<span class="line-modified">2133     JSValue value = exec-&gt;argument(0);</span>
2134     if (!value.isObject())
2135         return JSValue::encode(jsUndefined());
2136 
<span class="line-modified">2137     JSValue property = exec-&gt;argument(1);</span>
2138     if (!property.isString())
2139         return JSValue::encode(jsUndefined());
2140 
<span class="line-modified">2141     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
2142     RETURN_IF_EXCEPTION(scope, { });
2143 
2144     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">2145     value.getPropertySlot(exec, propertyName, slot);</span>
2146     RETURN_IF_EXCEPTION(scope, { });
2147 
2148     JSValue result;
2149     if (slot.isCacheableGetter())
2150         result = slot.getterSetter();
2151     else
2152         result = jsNull();
2153 
2154     return JSValue::encode(result);
2155 }
2156 
<span class="line-modified">2157 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)</span>
2158 {
<span class="line-modified">2159     VM&amp; vm = exec-&gt;vm();</span>

2160     auto scope = DECLARE_THROW_SCOPE(vm);
2161 
<span class="line-modified">2162     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));</span>
2163     if (UNLIKELY(!getterSetter)) {
<span class="line-modified">2164         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);</span>
2165         return encodedJSValue();
2166     }
2167 
2168     JSObject* getter = getterSetter-&gt;getter();
2169     RELEASE_ASSERT(getter);
2170     return JSValue::encode(getter);
2171 }
2172 
<span class="line-modified">2173 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(ExecState* exec)</span>
2174 {
<span class="line-modified">2175     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2176     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
2177     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2178 }
2179 
<span class="line-modified">2180 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(ExecState* exec)</span>
2181 {
<span class="line-modified">2182     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2183     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
<span class="line-modified">2184     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));</span>

2185     if (!a || !b)
2186         return JSValue::encode(jsNumber(PNaN));
2187 
2188     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2189     if (delta &lt; 0)
2190         return JSValue::encode(jsNumber(PNaN));
2191     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2192         return JSValue::encode(jsNumber(PNaN));
2193     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2194 }
2195 
<span class="line-modified">2196 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)</span>






2197 {
<span class="line-modified">2198     VM&amp; vm = exec-&gt;vm();</span>

2199     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2200 }
2201 
<span class="line-modified">2202 static EncodedJSValue JSC_HOST_CALL functionParseCount(ExecState*)</span>
2203 {

2204     return JSValue::encode(jsNumber(globalParseCount.load()));
2205 }
2206 
<span class="line-modified">2207 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(ExecState*)</span>
2208 {

2209 #if ENABLE(WEBASSEMBLY)
2210     return JSValue::encode(jsBoolean(Wasm::isSupported()));
2211 #else
2212     return JSValue::encode(jsBoolean(false));
2213 #endif
2214 }
2215 








































































2216 void JSDollarVM::finishCreation(VM&amp; vm)
2217 {

2218     Base::finishCreation(vm);
2219 
2220     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2221 
2222     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {

2223         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2224     };
2225     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {

2226         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2227     };
2228 
2229     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2230     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2231     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2232 
2233     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2234     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2235 
2236     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2237     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2238     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2239     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2240     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2241 
2242     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2243     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2244 
2245     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
</pre>
<hr />
<pre>
2253     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2254     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2255     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2256 
2257     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2258     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2259     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2260     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2261     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2262 
2263     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2264 
2265     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2266     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2267     addFunction(vm, &quot;value&quot;, functionValue, 1);
2268     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2269 
2270     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2271     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2272 


2273     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2274     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2275     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2276     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
2277 
2278     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2279     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2280     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2281     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2282     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2283     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2284     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2285     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2286     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2287 #if ENABLE(WEBASSEMBLY)
2288     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2289 #endif


2290     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2291     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2292 
2293     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2294     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2295     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2296 
2297     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2298     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2299     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2300 
2301     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2302     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2303 
2304     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2305     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2306 
2307     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2308 
2309     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2310     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2311     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2312 
2313     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2314 
2315     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2316     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2317 
2318     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);
2319 
2320     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2321     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2322 
2323     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2324     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2325     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2326 
2327     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2328 

2329     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2330 
2331     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
2332 
2333     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);






2334 }
2335 
2336 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2337 {

2338     Identifier identifier = Identifier::fromString(vm, name);
2339     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2340 }
2341 
2342 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2343 {

2344     Identifier identifier = Identifier::fromString(vm, name);
2345     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2346 }
2347 







2348 } // namespace JSC


</pre>
</td>
<td>
<hr />
<pre>
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JSDollarVM.h&quot;
  28 
  29 #include &quot;BuiltinExecutableCreator.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DOMAttributeGetterSetter.h&quot;
  32 #include &quot;DOMJITGetterSetter.h&quot;
<span class="line-added">  33 #include &quot;Debugger.h&quot;</span>
<span class="line-added">  34 #include &quot;Error.h&quot;</span>
  35 #include &quot;FrameTracers.h&quot;
  36 #include &quot;FunctionCodeBlock.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;JSArray.h&quot;
  39 #include &quot;JSArrayBuffer.h&quot;
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;JSFunction.h&quot;
  42 #include &quot;JSONObject.h&quot;
  43 #include &quot;JSProxy.h&quot;
  44 #include &quot;JSString.h&quot;
<span class="line-added">  45 #include &quot;Options.h&quot;</span>
  46 #include &quot;Parser.h&quot;
<span class="line-added">  47 #include &quot;ProbeContext.h&quot;</span>
  48 #include &quot;ShadowChicken.h&quot;
  49 #include &quot;Snippet.h&quot;
  50 #include &quot;SnippetParams.h&quot;
  51 #include &quot;TypeProfiler.h&quot;
  52 #include &quot;TypeProfilerLog.h&quot;
  53 #include &quot;VMInspector.h&quot;
  54 #include &quot;WasmCapabilities.h&quot;
  55 #include &lt;wtf/Atomics.h&gt;
<span class="line-added">  56 #include &lt;wtf/CPUTime.h&gt;</span>
  57 #include &lt;wtf/DataLog.h&gt;
  58 #include &lt;wtf/ProcessID.h&gt;
  59 #include &lt;wtf/StringPrintStream.h&gt;
  60 
  61 #if ENABLE(WEBASSEMBLY)
  62 #include &quot;JSWebAssemblyHelpers.h&quot;
  63 #include &quot;WasmStreamingParser.h&quot;
  64 #endif
  65 
  66 using namespace JSC;
  67 
<span class="line-added">  68 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">  69 </span>
<span class="line-added">  70 extern &quot;C&quot; void ctiMasmProbeTrampoline();</span>
<span class="line-added">  71 </span>
<span class="line-added">  72 namespace JSC {</span>
<span class="line-added">  73 </span>
<span class="line-added">  74 // This class is only here as a simple way to grant JSDollarVM friend privileges</span>
<span class="line-added">  75 // to all the classes that it needs special access to.</span>
<span class="line-added">  76 class JSDollarVMHelper {</span>
<span class="line-added">  77 public:</span>
<span class="line-added">  78     JSDollarVMHelper(VM&amp; vm)</span>
<span class="line-added">  79         : m_vm(vm)</span>
<span class="line-added">  80     { }</span>
<span class="line-added">  81 </span>
<span class="line-added">  82     void updateVMStackLimits() { return m_vm.updateStackLimits(); };</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     static EncodedJSValue JSC_HOST_CALL functionGetStructureTransitionList(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">  85 </span>
<span class="line-added">  86 private:</span>
<span class="line-added">  87     VM&amp; m_vm;</span>
<span class="line-added">  88 };</span>
<span class="line-added">  89 </span>
<span class="line-added">  90 } // namespace JSC</span>
<span class="line-added">  91 </span>
  92 namespace {
  93 
<span class="line-modified">  94 // We must RELEASE_ASSERT(Options::useDollarVM()) in all JSDollarVM functions</span>
<span class="line-modified">  95 // that are non-trivial at an eye&#39;s glance. This includes (but is not limited to):</span>
<span class="line-added">  96 //      constructors</span>
<span class="line-added">  97 //      create() factory</span>
<span class="line-added">  98 //      createStructure() factory</span>
<span class="line-added">  99 //      finishCreation()</span>
<span class="line-added"> 100 //      HOST_CALL or operation functions</span>
<span class="line-added"> 101 //      Constructors and methods of utility and test classes</span>
<span class="line-added"> 102 //      lambda functions</span>
<span class="line-added"> 103 //</span>
<span class="line-added"> 104 // The way to do this RELEASE_ASSERT is with the DollarVMAssertScope below.</span>
<span class="line-added"> 105 //</span>
<span class="line-added"> 106 // The only exception are some constexpr constructors used for instantiating</span>
<span class="line-added"> 107 // globals (since these must have trivial constructors) e.g. DOMJITAttribute.</span>
<span class="line-added"> 108 // Instead, these constructors should always be ALWAYS_INLINE.</span>
<span class="line-added"> 109 </span>
<span class="line-added"> 110 class JSDollarVMCallFrame : public JSNonFinalObject {</span>
<span class="line-added"> 111     using Base = JSNonFinalObject;</span>
 112 public:
 113     JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
 114         : Base(vm, structure)
<span class="line-modified"> 115     {</span>
<span class="line-added"> 116         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 117     }</span>
 118 
 119     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 120     {
<span class="line-added"> 121         DollarVMAssertScope assertScope;</span>
 122         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 123     }
 124 
<span class="line-modified"> 125     static JSDollarVMCallFrame* create(JSGlobalObject* globalObject, CallFrame* callFrame, unsigned requestedFrameIndex)</span>
 126     {
<span class="line-modified"> 127         DollarVMAssertScope assertScope;</span>
<span class="line-modified"> 128         VM&amp; vm = globalObject-&gt;vm();</span>
 129         Structure* structure = createStructure(vm, globalObject, jsNull());
 130         JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
<span class="line-modified"> 131         frame-&gt;finishCreation(vm, callFrame, requestedFrameIndex);</span>
 132         return frame;
 133     }
 134 
<span class="line-modified"> 135     void finishCreation(VM&amp; vm, CallFrame* callFrame, unsigned requestedFrameIndex)</span>
 136     {
<span class="line-added"> 137         DollarVMAssertScope assertScope;</span>
 138         Base::finishCreation(vm);
 139 
 140         auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
<span class="line-added"> 141             DollarVMAssertScope assertScope;</span>
 142             JSDollarVMCallFrame::addProperty(vm, name, value);
 143         };
 144 
 145         unsigned frameIndex = 0;
 146         bool isValid = false;
<span class="line-modified"> 147         callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {</span>
<span class="line-added"> 148             DollarVMAssertScope assertScope;</span>
 149 
 150             if (frameIndex++ != requestedFrameIndex)
 151                 return StackVisitor::Continue;
 152 
 153             addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
 154 
 155             if (visitor-&gt;callee().isCell())
 156                 addProperty(vm, &quot;callee&quot;, visitor-&gt;callee().asCell());
 157 
 158             CodeBlock* codeBlock = visitor-&gt;codeBlock();
 159             if (codeBlock) {
 160                 addProperty(vm, &quot;codeBlock&quot;, codeBlock);
 161                 addProperty(vm, &quot;unlinkedCodeBlock&quot;, codeBlock-&gt;unlinkedCodeBlock());
 162                 addProperty(vm, &quot;executable&quot;, codeBlock-&gt;ownerExecutable());
 163             }
 164             isValid = true;
 165 
 166             return StackVisitor::Done;
 167         });
 168 
 169         addProperty(vm, &quot;valid&quot;, jsBoolean(isValid));
 170     }
 171 
 172     DECLARE_INFO;
 173 
 174 private:
 175     void addProperty(VM&amp; vm, const char* name, JSValue value)
 176     {
<span class="line-added"> 177         DollarVMAssertScope assertScope;</span>
 178         Identifier identifier = Identifier::fromString(vm, name);
 179         putDirect(vm, identifier, value);
 180     }
 181 };
 182 
 183 const ClassInfo JSDollarVMCallFrame::s_info = { &quot;CallFrame&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVMCallFrame) };
 184 
 185 class ElementHandleOwner;
 186 class Root;
 187 
 188 class Element : public JSNonFinalObject {
 189 public:
 190     Element(VM&amp; vm, Structure* structure)
 191         : Base(vm, structure)
 192     {
<span class="line-added"> 193         DollarVMAssertScope assertScope;</span>
 194     }
 195 
 196     typedef JSNonFinalObject Base;
 197 
 198     Root* root() const { return m_root.get(); }
 199     void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
 200 
 201     static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
 202     {
<span class="line-added"> 203         DollarVMAssertScope assertScope;</span>
 204         Structure* structure = createStructure(vm, globalObject, jsNull());
 205         Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
 206         element-&gt;finishCreation(vm, root);
 207         return element;
 208     }
 209 
 210     void finishCreation(VM&amp;, Root*);
 211 
 212     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 213     {
<span class="line-added"> 214         DollarVMAssertScope assertScope;</span>
 215         Element* thisObject = jsCast&lt;Element*&gt;(cell);
 216         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 217         Base::visitChildren(thisObject, visitor);
 218         visitor.append(thisObject-&gt;m_root);
 219     }
 220 
 221     static ElementHandleOwner* handleOwner();
 222 
 223     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 224     {
<span class="line-added"> 225         DollarVMAssertScope assertScope;</span>
 226         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 227     }
 228 
 229     DECLARE_INFO;
 230 
 231 private:
 232     WriteBarrier&lt;Root&gt; m_root;
 233 };
 234 
 235 class ElementHandleOwner : public WeakHandleOwner {
 236     WTF_MAKE_FAST_ALLOCATED;
 237 public:
<span class="line-modified"> 238     bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override</span>
 239     {
<span class="line-added"> 240         DollarVMAssertScope assertScope;</span>
 241         if (UNLIKELY(reason))
 242             *reason = &quot;JSC::Element is opaque root&quot;;
 243         Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
 244         return visitor.containsOpaqueRoot(element-&gt;root());
 245     }
 246 };
 247 
 248 class Root : public JSDestructibleObject {
 249 public:
 250     Root(VM&amp; vm, Structure* structure)
 251         : Base(vm, structure)
 252     {
<span class="line-added"> 253         DollarVMAssertScope assertScope;</span>
 254     }
 255 
 256     Element* element()
 257     {
 258         return m_element.get();
 259     }
 260 
 261     void setElement(Element* element)
 262     {
<span class="line-added"> 263         DollarVMAssertScope assertScope;</span>
 264         Weak&lt;Element&gt; newElement(element, Element::handleOwner());
 265         m_element.swap(newElement);
 266     }
 267 
 268     static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
 269     {
<span class="line-added"> 270         DollarVMAssertScope assertScope;</span>
 271         Structure* structure = createStructure(vm, globalObject, jsNull());
 272         Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
 273         root-&gt;finishCreation(vm);
 274         return root;
 275     }
 276 
 277     typedef JSDestructibleObject Base;
 278 
 279     DECLARE_INFO;
 280 
 281     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 282     {
<span class="line-added"> 283         DollarVMAssertScope assertScope;</span>
 284         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 285     }
 286 
 287     static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
 288     {
<span class="line-added"> 289         DollarVMAssertScope assertScope;</span>
 290         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 291         Base::visitChildren(thisObject, visitor);
 292         visitor.addOpaqueRoot(thisObject);
 293     }
 294 
 295 private:
 296     Weak&lt;Element&gt; m_element;
 297 };
 298 
 299 class SimpleObject : public JSNonFinalObject {
 300 public:
 301     SimpleObject(VM&amp; vm, Structure* structure)
 302         : Base(vm, structure)
 303     {
<span class="line-added"> 304         DollarVMAssertScope assertScope;</span>
 305     }
 306 
 307     typedef JSNonFinalObject Base;
<span class="line-modified"> 308     static constexpr bool needsDestruction = false;</span>
 309 
 310     static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
 311     {
<span class="line-added"> 312         DollarVMAssertScope assertScope;</span>
 313         Structure* structure = createStructure(vm, globalObject, jsNull());
 314         SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
 315         simpleObject-&gt;finishCreation(vm);
 316         return simpleObject;
 317     }
 318 
 319     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 320     {
<span class="line-added"> 321         DollarVMAssertScope assertScope;</span>
 322         SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
 323         ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 324         Base::visitChildren(thisObject, visitor);
 325         visitor.append(thisObject-&gt;m_hiddenValue);
 326     }
 327 
 328     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 329     {
<span class="line-added"> 330         DollarVMAssertScope assertScope;</span>
 331         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 332     }
 333 
 334     JSValue hiddenValue()
 335     {
 336         return m_hiddenValue.get();
 337     }
 338 
 339     void setHiddenValue(VM&amp; vm, JSValue value)
 340     {
 341         ASSERT(value.isCell());
 342         m_hiddenValue.set(vm, this, value);
 343     }
 344 
 345     DECLARE_INFO;
 346 
 347 private:
 348     WriteBarrier&lt;JSC::Unknown&gt; m_hiddenValue;
 349 };
 350 
 351 class ImpureGetter : public JSNonFinalObject {
 352 public:
 353     ImpureGetter(VM&amp; vm, Structure* structure)
 354         : Base(vm, structure)
 355     {
<span class="line-added"> 356         DollarVMAssertScope assertScope;</span>
 357     }
 358 
 359     DECLARE_INFO;
 360     typedef JSNonFinalObject Base;
<span class="line-modified"> 361     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;</span>
 362 
 363     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 364     {
<span class="line-added"> 365         DollarVMAssertScope assertScope;</span>
 366         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 367     }
 368 
 369     static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
 370     {
<span class="line-added"> 371         DollarVMAssertScope assertScope;</span>
 372         ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
 373         getter-&gt;finishCreation(vm, delegate);
 374         return getter;
 375     }
 376 
 377     void finishCreation(VM&amp; vm, JSObject* delegate)
 378     {
<span class="line-added"> 379         DollarVMAssertScope assertScope;</span>
 380         Base::finishCreation(vm);
 381         if (delegate)
 382             m_delegate.set(vm, this, delegate);
 383     }
 384 
<span class="line-modified"> 385     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName name, PropertySlot&amp; slot)</span>
 386     {
<span class="line-modified"> 387         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 388         VM&amp; vm = globalObject-&gt;vm();</span>
 389         auto scope = DECLARE_THROW_SCOPE(vm);
 390         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
 391 
 392         if (thisObject-&gt;m_delegate) {
<span class="line-modified"> 393             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(globalObject, name, slot))</span>
 394                 return true;
 395             RETURN_IF_EXCEPTION(scope, false);
 396         }
 397 
<span class="line-modified"> 398         return Base::getOwnPropertySlot(object, globalObject, name, slot);</span>
 399     }
 400 
 401     static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 402     {
<span class="line-added"> 403         DollarVMAssertScope assertScope;</span>
 404         ASSERT_GC_OBJECT_INHERITS(cell, info());
 405         Base::visitChildren(cell, visitor);
 406         ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
 407         visitor.append(thisObject-&gt;m_delegate);
 408     }
 409 
 410     void setDelegate(VM&amp; vm, JSObject* delegate)
 411     {
 412         m_delegate.set(vm, this, delegate);
 413     }
 414 
 415 private:
 416     WriteBarrier&lt;JSObject&gt; m_delegate;
 417 };
 418 
 419 class CustomGetter : public JSNonFinalObject {
 420 public:
 421     CustomGetter(VM&amp; vm, Structure* structure)
 422         : Base(vm, structure)
 423     {
<span class="line-added"> 424         DollarVMAssertScope assertScope;</span>
 425     }
 426 
 427     DECLARE_INFO;
 428     typedef JSNonFinalObject Base;
<span class="line-modified"> 429     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;</span>
 430 
 431     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 432     {
<span class="line-added"> 433         DollarVMAssertScope assertScope;</span>
 434         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 435     }
 436 
 437     static CustomGetter* create(VM&amp; vm, Structure* structure)
 438     {
<span class="line-added"> 439         DollarVMAssertScope assertScope;</span>
 440         CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
 441         getter-&gt;finishCreation(vm);
 442         return getter;
 443     }
 444 
<span class="line-modified"> 445     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 446     {
<span class="line-modified"> 447         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 448         VM&amp; vm = globalObject-&gt;vm();</span>
 449         CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
 450         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
 451             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
 452             return true;
 453         }
 454 
 455         if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
 456             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
 457             return true;
 458         }
 459 
<span class="line-modified"> 460         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
 461     }
 462 
 463 private:
<span class="line-modified"> 464     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
 465     {
<span class="line-modified"> 466         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 467         VM&amp; vm = globalObject-&gt;vm();</span>
 468         auto scope = DECLARE_THROW_SCOPE(vm);
 469 
 470         CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
 471         if (!thisObject)
<span class="line-modified"> 472             return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified"> 473         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);</span>
 474         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 475         if (shouldThrow)
<span class="line-modified"> 476             return throwVMTypeError(globalObject, scope);</span>
 477         return JSValue::encode(jsNumber(100));
 478     }
 479 
<span class="line-modified"> 480     static EncodedJSValue customGetterAcessor(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
 481     {
<span class="line-modified"> 482         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 483         VM&amp; vm = globalObject-&gt;vm();</span>
 484         auto scope = DECLARE_THROW_SCOPE(vm);
 485 
 486         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
 487         if (!thisObject)
<span class="line-modified"> 488             return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified"> 489         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);</span>
 490         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 491         if (shouldThrow)
<span class="line-modified"> 492             return throwVMTypeError(globalObject, scope);</span>
 493         return JSValue::encode(jsNumber(100));
 494     }
 495 };
 496 
 497 class RuntimeArray : public JSArray {
 498 public:
 499     typedef JSArray Base;
<span class="line-modified"> 500     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;</span>
 501 
<span class="line-modified"> 502     static RuntimeArray* create(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 503     {
<span class="line-modified"> 504         DollarVMAssertScope assertScope;</span>
<span class="line-modified"> 505         VM&amp; vm = globalObject-&gt;vm();</span>
 506         Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
<span class="line-modified"> 507         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(globalObject, structure);</span>
<span class="line-modified"> 508         runtimeArray-&gt;finishCreation(globalObject, callFrame);</span>
 509         vm.heap.addFinalizer(runtimeArray, destroy);
 510         return runtimeArray;
 511     }
 512 
 513     ~RuntimeArray() { }
 514 
 515     static void destroy(JSCell* cell)
 516     {
<span class="line-added"> 517         DollarVMAssertScope assertScope;</span>
 518         static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
 519     }
 520 
<span class="line-modified"> 521     static constexpr bool needsDestruction = false;</span>
 522 
<span class="line-modified"> 523     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 524     {
<span class="line-modified"> 525         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 526         VM&amp; vm = globalObject-&gt;vm();</span>
 527         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 528         if (propertyName == vm.propertyNames-&gt;length) {
 529             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
 530             return true;
 531         }
 532 
 533         Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 534         if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
 535             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
 536             return true;
 537         }
 538 
<span class="line-modified"> 539         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
 540     }
 541 
<span class="line-modified"> 542     static bool getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned index, PropertySlot&amp; slot)</span>
 543     {
<span class="line-added"> 544         DollarVMAssertScope assertScope;</span>
 545         RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
 546         if (index &lt; thisObject-&gt;getLength()) {
 547             slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
 548             return true;
 549         }
 550 
<span class="line-modified"> 551         return JSObject::getOwnPropertySlotByIndex(thisObject, globalObject, index, slot);</span>
 552     }
 553 
<span class="line-modified"> 554     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;)</span>
 555     {
 556         RELEASE_ASSERT_NOT_REACHED();
 557     }
 558 
<span class="line-modified"> 559     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName)</span>
 560     {
 561         RELEASE_ASSERT_NOT_REACHED();
 562     }
 563 
 564     unsigned getLength() const { return m_vector.size(); }
 565 
 566     DECLARE_INFO;
 567 
 568     static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
 569     {
<span class="line-added"> 570         DollarVMAssertScope assertScope;</span>
 571         return globalObject-&gt;arrayPrototype();
 572     }
 573 
 574     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 575     {
<span class="line-added"> 576         DollarVMAssertScope assertScope;</span>
 577         return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
 578     }
 579 
 580 protected:
<span class="line-modified"> 581     void finishCreation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 582     {
<span class="line-modified"> 583         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 584         VM&amp; vm = globalObject-&gt;vm();</span>
 585         Base::finishCreation(vm);
 586         ASSERT(inherits(vm, info()));
 587 
<span class="line-modified"> 588         for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); i++)</span>
<span class="line-modified"> 589             m_vector.append(callFrame-&gt;argument(i).toInt32(globalObject));</span>
 590     }
 591 
 592 private:
<span class="line-modified"> 593     RuntimeArray(JSGlobalObject* globalObject, Structure* structure)</span>
<span class="line-modified"> 594         : JSArray(globalObject-&gt;vm(), structure, 0)</span>
 595     {
<span class="line-added"> 596         DollarVMAssertScope assertScope;</span>
 597     }
 598 
<span class="line-modified"> 599     static EncodedJSValue lengthGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
 600     {
<span class="line-modified"> 601         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 602         VM&amp; vm = globalObject-&gt;vm();</span>
 603         auto scope = DECLARE_THROW_SCOPE(vm);
 604 
 605         RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
 606         if (!thisObject)
<span class="line-modified"> 607             return throwVMTypeError(globalObject, scope);</span>
 608         return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
 609     }
 610 
 611     Vector&lt;int&gt; m_vector;
 612 };
 613 
<span class="line-added"> 614 static const struct CompactHashIndex staticCustomAccessorTableIndex[2] = {</span>
<span class="line-added"> 615     { 0, -1 },</span>
<span class="line-added"> 616     { -1, -1 },</span>
<span class="line-added"> 617 };</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619 static EncodedJSValue testStaticAccessorGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
<span class="line-added"> 620 {</span>
<span class="line-added"> 621     DollarVMAssertScope assertScope;</span>
<span class="line-added"> 622     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));</span>
<span class="line-added"> 625     RELEASE_ASSERT(thisObject);</span>
<span class="line-added"> 626 </span>
<span class="line-added"> 627     if (JSValue result = thisObject-&gt;getDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;))))</span>
<span class="line-added"> 628         return JSValue::encode(result);</span>
<span class="line-added"> 629     return JSValue::encode(jsUndefined());</span>
<span class="line-added"> 630 }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632 static bool testStaticAccessorPutter(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
<span class="line-added"> 633 {</span>
<span class="line-added"> 634     DollarVMAssertScope assertScope;</span>
<span class="line-added"> 635     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 636 </span>
<span class="line-added"> 637     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));</span>
<span class="line-added"> 638     RELEASE_ASSERT(thisObject);</span>
<span class="line-added"> 639 </span>
<span class="line-added"> 640     return thisObject-&gt;putDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;)), JSValue::decode(value));</span>
<span class="line-added"> 641 }</span>
<span class="line-added"> 642 </span>
<span class="line-added"> 643 static const struct HashTableValue staticCustomAccessorTableValues[1] = {</span>
<span class="line-added"> 644     { &quot;testStaticAccessor&quot;, static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor), NoIntrinsic, { (intptr_t)static_cast&lt;PropertySlot::GetValueFunc&gt;(testStaticAccessorGetter), (intptr_t)static_cast&lt;PutPropertySlot::PutValueFunc&gt;(testStaticAccessorPutter) } },</span>
<span class="line-added"> 645 };</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647 static const struct HashTable staticCustomAccessorTable =</span>
<span class="line-added"> 648     { 1, 1, true, nullptr, staticCustomAccessorTableValues, staticCustomAccessorTableIndex };</span>
<span class="line-added"> 649 </span>
<span class="line-added"> 650 class StaticCustomAccessor : public JSNonFinalObject {</span>
<span class="line-added"> 651     using Base = JSNonFinalObject;</span>
<span class="line-added"> 652 public:</span>
<span class="line-added"> 653     StaticCustomAccessor(VM&amp; vm, Structure* structure)</span>
<span class="line-added"> 654         : Base(vm, structure)</span>
<span class="line-added"> 655     {</span>
<span class="line-added"> 656         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 657     }</span>
<span class="line-added"> 658 </span>
<span class="line-added"> 659     DECLARE_INFO;</span>
<span class="line-added"> 660 </span>
<span class="line-added"> 661     static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot;</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)</span>
<span class="line-added"> 664     {</span>
<span class="line-added"> 665         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 666         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
<span class="line-added"> 667     }</span>
<span class="line-added"> 668 </span>
<span class="line-added"> 669     static StaticCustomAccessor* create(VM&amp; vm, Structure* structure)</span>
<span class="line-added"> 670     {</span>
<span class="line-added"> 671         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 672         StaticCustomAccessor* accessor = new (NotNull, allocateCell&lt;StaticCustomAccessor&gt;(vm.heap)) StaticCustomAccessor(vm, structure);</span>
<span class="line-added"> 673         accessor-&gt;finishCreation(vm);</span>
<span class="line-added"> 674         return accessor;</span>
<span class="line-added"> 675     }</span>
<span class="line-added"> 676 </span>
<span class="line-added"> 677     static bool getOwnPropertySlot(JSObject* thisObject, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
<span class="line-added"> 678     {</span>
<span class="line-added"> 679         if (String(propertyName.uid()) == &quot;thinAirCustomGetter&quot;) {</span>
<span class="line-added"> 680             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, testStaticAccessorGetter);</span>
<span class="line-added"> 681             return true;</span>
<span class="line-added"> 682         }</span>
<span class="line-added"> 683         return JSNonFinalObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
<span class="line-added"> 684     }</span>
<span class="line-added"> 685 };</span>
<span class="line-added"> 686 </span>
<span class="line-added"> 687 class ObjectDoingSideEffectPutWithoutCorrectSlotStatus : public JSNonFinalObject {</span>
<span class="line-added"> 688     using Base = JSNonFinalObject;</span>
<span class="line-added"> 689 public:</span>
<span class="line-added"> 690     ObjectDoingSideEffectPutWithoutCorrectSlotStatus(VM&amp; vm, Structure* structure)</span>
<span class="line-added"> 691         : Base(vm, structure)</span>
<span class="line-added"> 692     {</span>
<span class="line-added"> 693         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 694     }</span>
<span class="line-added"> 695 </span>
<span class="line-added"> 696     DECLARE_INFO;</span>
<span class="line-added"> 697 </span>
<span class="line-added"> 698     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)</span>
<span class="line-added"> 699     {</span>
<span class="line-added"> 700         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 701         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
<span class="line-added"> 702     }</span>
<span class="line-added"> 703 </span>
<span class="line-added"> 704     static ObjectDoingSideEffectPutWithoutCorrectSlotStatus* create(VM&amp; vm, Structure* structure)</span>
<span class="line-added"> 705     {</span>
<span class="line-added"> 706         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 707         ObjectDoingSideEffectPutWithoutCorrectSlotStatus* accessor = new (NotNull, allocateCell&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&gt;(vm.heap)) ObjectDoingSideEffectPutWithoutCorrectSlotStatus(vm, structure);</span>
<span class="line-added"> 708         accessor-&gt;finishCreation(vm);</span>
<span class="line-added"> 709         return accessor;</span>
<span class="line-added"> 710     }</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712     static bool put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added"> 713     {</span>
<span class="line-added"> 714         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 715         auto* thisObject = jsCast&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus*&gt;(cell);</span>
<span class="line-added"> 716         auto throwScope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-added"> 717         auto* string = value.toString(globalObject);</span>
<span class="line-added"> 718         RETURN_IF_EXCEPTION(throwScope, false);</span>
<span class="line-added"> 719         RELEASE_AND_RETURN(throwScope, Base::put(thisObject, globalObject, propertyName, string, slot));</span>
<span class="line-added"> 720     }</span>
<span class="line-added"> 721 };</span>
<span class="line-added"> 722 </span>
 723 class DOMJITNode : public JSNonFinalObject {
 724 public:
 725     DOMJITNode(VM&amp; vm, Structure* structure)
 726         : Base(vm, structure)
 727     {
<span class="line-added"> 728         DollarVMAssertScope assertScope;</span>
 729     }
 730 
 731     DECLARE_INFO;
 732     typedef JSNonFinalObject Base;
<span class="line-modified"> 733     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
 734 
 735     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 736     {
<span class="line-added"> 737         DollarVMAssertScope assertScope;</span>
 738         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 739     }
 740 
 741 #if ENABLE(JIT)
 742     static Ref&lt;Snippet&gt; checkSubClassSnippet()
 743     {
<span class="line-added"> 744         DollarVMAssertScope assertScope;</span>
 745         Ref&lt;Snippet&gt; snippet = Snippet::create();
<span class="line-modified"> 746         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added"> 747             DollarVMAssertScope assertScope;</span>
 748             CCallHelpers::JumpList failureCases;
 749             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
 750             return failureCases;
 751         });
 752         return snippet;
 753     }
 754 #endif
 755 
 756     static DOMJITNode* create(VM&amp; vm, Structure* structure)
 757     {
<span class="line-added"> 758         DollarVMAssertScope assertScope;</span>
 759         DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
 760         getter-&gt;finishCreation(vm);
 761         return getter;
 762     }
 763 
 764     int32_t value() const
 765     {
 766         return m_value;
 767     }
 768 
 769     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(DOMJITNode, m_value); }
 770 
 771 private:
 772     int32_t m_value { 42 };
 773 };
 774 
 775 class DOMJITGetter : public DOMJITNode {
 776 public:
 777     DOMJITGetter(VM&amp; vm, Structure* structure)
 778         : Base(vm, structure)
 779     {
<span class="line-added"> 780         DollarVMAssertScope assertScope;</span>
 781     }
 782 
 783     DECLARE_INFO;
 784     typedef DOMJITNode Base;
<span class="line-modified"> 785     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
 786 
 787     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 788     {
<span class="line-added"> 789         DollarVMAssertScope assertScope;</span>
 790         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 791     }
 792 
 793     static DOMJITGetter* create(VM&amp; vm, Structure* structure)
 794     {
<span class="line-added"> 795         DollarVMAssertScope assertScope;</span>
 796         DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
 797         getter-&gt;finishCreation(vm);
 798         return getter;
 799     }
 800 
 801     class DOMJITAttribute : public DOMJIT::GetterSetter {
 802     public:
<span class="line-modified"> 803         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
 804             : DOMJIT::GetterSetter(
 805                 DOMJITGetter::customGetter,
 806 #if ENABLE(JIT)
 807                 &amp;callDOMGetter,
 808 #else
 809                 nullptr,
 810 #endif
 811                 SpecInt32Only)
 812         {
 813         }
 814 
 815 #if ENABLE(JIT)
<span class="line-modified"> 816         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
 817         {
<span class="line-modified"> 818             DollarVMAssertScope assertScope;</span>
<span class="line-modified"> 819             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 820             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 821             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 822             return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
 823         }
 824 
 825         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 826         {
<span class="line-added"> 827             DollarVMAssertScope assertScope;</span>
 828             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified"> 829             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-modified"> 830             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added"> 831                 DollarVMAssertScope assertScope;</span>
 832                 JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified"> 833                 GPRReg domGPR = params[1].gpr();</span>
<span class="line-modified"> 834                 GPRReg globalObjectGPR = params[2].gpr();</span>
<span class="line-added"> 835                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
 836                 return CCallHelpers::JumpList();
 837 
 838             });
 839             return snippet;
 840         }
 841 #endif
 842     };
 843 
 844 private:
 845     void finishCreation(VM&amp;);
 846 
<span class="line-modified"> 847     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
 848     {
<span class="line-modified"> 849         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 850         VM&amp; vm = globalObject-&gt;vm();</span>
 851         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
 852         ASSERT(thisObject);
 853         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 854     }
 855 };
 856 
 857 static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
 858 
 859 void DOMJITGetter::finishCreation(VM&amp; vm)
 860 {
<span class="line-added"> 861     DollarVMAssertScope assertScope;</span>
 862     Base::finishCreation(vm);
 863     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
 864     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
 865     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 866 }
 867 
<span class="line-added"> 868 </span>
 869 class DOMJITGetterComplex : public DOMJITNode {
 870 public:
 871     DOMJITGetterComplex(VM&amp; vm, Structure* structure)
 872         : Base(vm, structure)
 873     {
<span class="line-added"> 874         DollarVMAssertScope assertScope;</span>
 875     }
 876 
 877     DECLARE_INFO;
 878     typedef DOMJITNode Base;
<span class="line-modified"> 879     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
 880 
 881     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 882     {
<span class="line-added"> 883         DollarVMAssertScope assertScope;</span>
 884         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
 885     }
 886 
 887     static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
 888     {
<span class="line-added"> 889         DollarVMAssertScope assertScope;</span>
 890         DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
 891         getter-&gt;finishCreation(vm, globalObject);
 892         return getter;
 893     }
 894 
 895     class DOMJITAttribute : public DOMJIT::GetterSetter {
 896     public:
<span class="line-modified"> 897         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
 898             : DOMJIT::GetterSetter(
 899                 DOMJITGetterComplex::customGetter,
 900 #if ENABLE(JIT)
 901                 &amp;callDOMGetter,
 902 #else
 903                 nullptr,
 904 #endif
 905                 SpecInt32Only)
 906         {
 907         }
 908 
 909 #if ENABLE(JIT)
<span class="line-modified"> 910         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
 911         {
<span class="line-modified"> 912             DollarVMAssertScope assertScope;</span>
<span class="line-modified"> 913             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 914             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 915             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 916             auto scope = DECLARE_THROW_SCOPE(vm);
 917             auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
 918             auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
 919             if (domjitGetterComplex) {
 920                 if (domjitGetterComplex-&gt;m_enableException)
<span class="line-modified"> 921                     return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 922             }
 923             return JSValue::encode(jsNumber(object-&gt;value()));
 924         }
 925 
 926         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
 927         {
<span class="line-added"> 928             DollarVMAssertScope assertScope;</span>
 929             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
 930             static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
 931             unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
 932             snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
 933             snippet-&gt;numFPScratchRegisters = 3;
<span class="line-modified"> 934             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-added"> 935             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added"> 936                 DollarVMAssertScope assertScope;</span>
 937                 JSValueRegs results = params[0].jsValueRegs();
 938                 GPRReg domGPR = params[1].gpr();
<span class="line-added"> 939                 GPRReg globalObjectGPR = params[2].gpr();</span>
 940                 for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
 941                     jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
 942 
<span class="line-modified"> 943                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
 944                 return CCallHelpers::JumpList();
 945             });
 946             return snippet;
 947         }
 948 #endif
 949     };
 950 
 951 private:
 952     void finishCreation(VM&amp;, JSGlobalObject*);
 953 
<span class="line-modified"> 954     static EncodedJSValue JSC_HOST_CALL functionEnableException(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 955     {
<span class="line-modified"> 956         DollarVMAssertScope assertScope;</span>
<span class="line-modified"> 957         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 958         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, callFrame-&gt;thisValue());</span>
 959         if (object)
 960             object-&gt;m_enableException = true;
 961         return JSValue::encode(jsUndefined());
 962     }
 963 
<span class="line-modified"> 964     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
 965     {
<span class="line-modified"> 966         DollarVMAssertScope assertScope;</span>
<span class="line-added"> 967         VM&amp; vm = globalObject-&gt;vm();</span>
 968         auto scope = DECLARE_THROW_SCOPE(vm);
 969 
 970         auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
 971         ASSERT(thisObject);
 972         if (thisObject-&gt;m_enableException)
<span class="line-modified"> 973             return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
 974         return JSValue::encode(jsNumber(thisObject-&gt;value()));
 975     }
 976 
 977     bool m_enableException { false };
 978 };
 979 
 980 static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
 981 
 982 void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 983 {
<span class="line-added"> 984     DollarVMAssertScope assertScope;</span>
 985     Base::finishCreation(vm);
 986     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
 987     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
 988     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
 989     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
 990 }
 991 
 992 class DOMJITFunctionObject : public DOMJITNode {
 993 public:
 994     DOMJITFunctionObject(VM&amp; vm, Structure* structure)
 995         : Base(vm, structure)
 996     {
<span class="line-added"> 997         DollarVMAssertScope assertScope;</span>
 998     }
 999 
1000     DECLARE_INFO;
1001     typedef DOMJITNode Base;
<span class="line-modified">1002     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>

1003 
1004     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1005     {
<span class="line-added">1006         DollarVMAssertScope assertScope;</span>
1007         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1008     }
1009 
1010     static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
1011     {
<span class="line-added">1012         DollarVMAssertScope assertScope;</span>
1013         DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
1014         object-&gt;finishCreation(vm, globalObject);
1015         return object;
1016     }
1017 
<span class="line-modified">1018     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1019     {
<span class="line-modified">1020         DollarVMAssertScope assertScope;</span>
<span class="line-added">1021         VM&amp; vm = globalObject-&gt;vm();</span>
1022         auto scope = DECLARE_THROW_SCOPE(vm);
1023 
<span class="line-modified">1024         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, callFrame-&gt;thisValue());</span>
1025         if (!thisObject)
<span class="line-modified">1026             return throwVMTypeError(globalObject, scope);</span>
1027         return JSValue::encode(jsNumber(thisObject-&gt;value()));
1028     }
1029 
<span class="line-modified">1030     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)</span>
1031     {
<span class="line-modified">1032         DollarVMAssertScope assertScope;</span>
<span class="line-modified">1033         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1034         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1035         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1036         return JSValue::encode(jsNumber(node-&gt;value()));
1037     }
1038 
1039 #if ENABLE(JIT)
1040     static Ref&lt;Snippet&gt; checkSubClassSnippet()
1041     {
<span class="line-added">1042         DollarVMAssertScope assertScope;</span>
1043         Ref&lt;Snippet&gt; snippet = Snippet::create();
1044         snippet-&gt;numFPScratchRegisters = 1;
<span class="line-modified">1045         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">1046             DollarVMAssertScope assertScope;</span>
1047             static const double value = 42.0;
1048             CCallHelpers::JumpList failureCases;
1049             // May use scratch registers.
1050             jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
1051             failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
1052             return failureCases;
1053         });
1054         return snippet;
1055     }
1056 #endif
1057 
1058 private:
1059     void finishCreation(VM&amp;, JSGlobalObject*);
1060 };
1061 
1062 static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
1063 
1064 void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
1065 {
<span class="line-added">1066     DollarVMAssertScope assertScope;</span>
1067     Base::finishCreation(vm);
1068     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
1069 }
1070 
1071 class DOMJITCheckSubClassObject : public DOMJITNode {
1072 public:
1073     DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
1074         : Base(vm, structure)
1075     {
<span class="line-added">1076         DollarVMAssertScope assertScope;</span>
1077     }
1078 
1079     DECLARE_INFO;
1080     typedef DOMJITNode Base;
<span class="line-modified">1081     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>

1082 
1083     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1084     {
<span class="line-added">1085         DollarVMAssertScope assertScope;</span>
1086         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1087     }
1088 
1089     static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
1090     {
<span class="line-added">1091         DollarVMAssertScope assertScope;</span>
1092         DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
1093         object-&gt;finishCreation(vm, globalObject);
1094         return object;
1095     }
1096 
<span class="line-modified">1097     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1098     {
<span class="line-modified">1099         DollarVMAssertScope assertScope;</span>
<span class="line-added">1100         VM&amp; vm = globalObject-&gt;vm();</span>
1101         auto scope = DECLARE_THROW_SCOPE(vm);
1102 
<span class="line-modified">1103         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, callFrame-&gt;thisValue());</span>
1104         if (!thisObject)
<span class="line-modified">1105             return throwVMTypeError(globalObject, scope);</span>
1106         return JSValue::encode(jsNumber(thisObject-&gt;value()));
1107     }
1108 
<span class="line-modified">1109     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)</span>
1110     {
<span class="line-modified">1111         DollarVMAssertScope assertScope;</span>
<span class="line-modified">1112         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1113         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1114         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1115         return JSValue::encode(jsNumber(node-&gt;value()));
1116     }
1117 
1118 private:
1119     void finishCreation(VM&amp;, JSGlobalObject*);
1120 };
1121 
1122 static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
1123 
1124 void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
1125 {
<span class="line-added">1126     DollarVMAssertScope assertScope;</span>
1127     Base::finishCreation(vm);
1128     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
1129 }
1130 
1131 class DOMJITGetterBaseJSObject : public DOMJITNode {
1132 public:
1133     DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
1134         : Base(vm, structure)
1135     {
<span class="line-added">1136         DollarVMAssertScope assertScope;</span>
1137     }
1138 
1139     DECLARE_INFO;
1140     using Base = DOMJITNode;
<span class="line-modified">1141     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
1142 
1143     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1144     {
<span class="line-added">1145         DollarVMAssertScope assertScope;</span>
1146         return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
1147     }
1148 
1149     static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
1150     {
<span class="line-added">1151         DollarVMAssertScope assertScope;</span>
1152         DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
1153         getter-&gt;finishCreation(vm);
1154         return getter;
1155     }
1156 
1157     class DOMJITAttribute : public DOMJIT::GetterSetter {
1158     public:
<span class="line-modified">1159         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
1160             : DOMJIT::GetterSetter(
1161                 DOMJITGetterBaseJSObject::customGetter,
1162 #if ENABLE(JIT)
1163                 &amp;callDOMGetter,
1164 #else
1165                 nullptr,
1166 #endif
1167                 SpecBytecodeTop)
1168         {
1169         }
1170 
1171 #if ENABLE(JIT)
<span class="line-modified">1172         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
1173         {
<span class="line-modified">1174             DollarVMAssertScope assertScope;</span>
<span class="line-modified">1175             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1176             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1177             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1178             JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
1179             return JSValue::encode(object-&gt;getPrototypeDirect(vm));
1180         }
1181 
1182         static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
1183         {
<span class="line-added">1184             DollarVMAssertScope assertScope;</span>
1185             Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified">1186             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-modified">1187             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">1188                 DollarVMAssertScope assertScope;</span>
1189                 JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified">1190                 GPRReg domGPR = params[1].gpr();</span>
<span class="line-modified">1191                 GPRReg globalObjectGPR = params[2].gpr();</span>
<span class="line-added">1192                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
1193                 return CCallHelpers::JumpList();
1194 
1195             });
1196             return snippet;
1197         }
1198 #endif
1199     };
1200 
1201 private:
1202     void finishCreation(VM&amp;);
1203 
<span class="line-modified">1204     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
1205     {
<span class="line-modified">1206         DollarVMAssertScope assertScope;</span>
<span class="line-added">1207         VM&amp; vm = globalObject-&gt;vm();</span>
1208         JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
1209         RELEASE_ASSERT(thisObject);
1210         return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
1211     }
1212 };
1213 
1214 static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
1215 
1216 void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
1217 {
<span class="line-added">1218     DollarVMAssertScope assertScope;</span>
1219     Base::finishCreation(vm);
1220     const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
1221     auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
1222     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
1223 }
1224 
1225 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
1226 public:
1227     Message(ArrayBufferContents&amp;&amp;, int32_t);
1228     ~Message();
1229 
1230     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
1231     int32_t index() const { return m_index; }
1232 
1233 private:
1234     ArrayBufferContents m_contents;
1235     int32_t m_index { 0 };
1236 };
1237 
1238 class JSTestCustomGetterSetter : public JSNonFinalObject {
1239 public:
1240     using Base = JSNonFinalObject;
<span class="line-modified">1241     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
1242 
1243     JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
1244         : Base(vm, structure)
<span class="line-modified">1245     {</span>
<span class="line-added">1246         DollarVMAssertScope assertScope;</span>
<span class="line-added">1247     }</span>
1248 
1249     static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
1250     {
<span class="line-added">1251         DollarVMAssertScope assertScope;</span>
1252         JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
1253         result-&gt;finishCreation(vm);
1254         return result;
1255     }
1256 
1257     void finishCreation(VM&amp;);
1258 
1259     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
1260     {
<span class="line-added">1261         DollarVMAssertScope assertScope;</span>
1262         return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
1263     }
1264 
1265     DECLARE_INFO;
1266 };
1267 
1268 
<span class="line-modified">1269 static EncodedJSValue customGetAccessor(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
1270 {
1271     // Passed |this|
1272     return thisValue;
1273 }
1274 
<span class="line-modified">1275 static EncodedJSValue customGetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, PropertyName)</span>
1276 {
<span class="line-modified">1277     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));</span>
1278     // Passed property holder.
1279     return slotValue;
1280 }
1281 
<span class="line-modified">1282 static bool customSetAccessor(JSGlobalObject* globalObject, EncodedJSValue thisObject, EncodedJSValue encodedValue)</span>
1283 {
<span class="line-modified">1284     DollarVMAssertScope assertScope;</span>
<span class="line-added">1285     VM&amp; vm = globalObject-&gt;vm();</span>
1286 
1287     JSValue value = JSValue::decode(encodedValue);
1288     RELEASE_ASSERT(value.isObject());
1289     JSObject* object = asObject(value);
1290     PutPropertySlot slot(object);
<span class="line-modified">1291     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
1292 
1293     return true;
1294 }
1295 
<span class="line-modified">1296 static bool customSetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, EncodedJSValue encodedValue)</span>
1297 {
<span class="line-modified">1298     DollarVMAssertScope assertScope;</span>
<span class="line-added">1299     VM&amp; vm = globalObject-&gt;vm();</span>
1300 
<span class="line-modified">1301     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));</span>
1302 
1303     JSValue value = JSValue::decode(encodedValue);
1304     RELEASE_ASSERT(value.isObject());
1305     JSObject* object = asObject(value);
1306     PutPropertySlot slot(object);
<span class="line-modified">1307     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
1308 
1309     return true;
1310 }
1311 
1312 void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
1313 {
<span class="line-added">1314     DollarVMAssertScope assertScope;</span>
1315     Base::finishCreation(vm);
1316 
1317     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
1318         CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
1319     putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
1320         CustomGetterSetter::create(vm, customGetAccessor, customSetAccessor), static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor));
1321 }
1322 
1323 const ClassInfo Element::s_info = { &quot;Element&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Element) };
1324 const ClassInfo Root::s_info = { &quot;Root&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Root) };
1325 const ClassInfo SimpleObject::s_info = { &quot;SimpleObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(SimpleObject) };
1326 const ClassInfo ImpureGetter::s_info = { &quot;ImpureGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ImpureGetter) };
1327 const ClassInfo CustomGetter::s_info = { &quot;CustomGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CustomGetter) };
1328 const ClassInfo RuntimeArray::s_info = { &quot;RuntimeArray&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeArray) };
1329 #if ENABLE(JIT)
1330 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITNode::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITNode) };
1331 #else
1332 const ClassInfo DOMJITNode::s_info = { &quot;DOMJITNode&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITNode) };
1333 #endif
1334 const ClassInfo DOMJITGetter::s_info = { &quot;DOMJITGetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetter) };
1335 const ClassInfo DOMJITGetterComplex::s_info = { &quot;DOMJITGetterComplex&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterComplex) };
1336 const ClassInfo DOMJITGetterBaseJSObject::s_info = { &quot;DOMJITGetterBaseJSObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITGetterBaseJSObject) };
1337 #if ENABLE(JIT)
1338 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, &amp;DOMJITFunctionObject::checkSubClassSnippet, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1339 #else
1340 const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
1341 #endif
1342 const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
1343 const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
1344 
<span class="line-added">1345 const ClassInfo StaticCustomAccessor::s_info = { &quot;StaticCustomAccessor&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(StaticCustomAccessor) };</span>
<span class="line-added">1346 const ClassInfo ObjectDoingSideEffectPutWithoutCorrectSlotStatus::s_info = { &quot;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(ObjectDoingSideEffectPutWithoutCorrectSlotStatus) };</span>
<span class="line-added">1347 </span>
1348 ElementHandleOwner* Element::handleOwner()
1349 {
<span class="line-added">1350     DollarVMAssertScope assertScope;</span>
1351     static ElementHandleOwner* owner = 0;
1352     if (!owner)
1353         owner = new ElementHandleOwner();
1354     return owner;
1355 }
1356 
1357 void Element::finishCreation(VM&amp; vm, Root* root)
1358 {
<span class="line-added">1359     DollarVMAssertScope assertScope;</span>
1360     Base::finishCreation(vm);
1361     setRoot(vm, root);
1362     m_root-&gt;setElement(this);
1363 }
1364 
1365 #if ENABLE(WEBASSEMBLY)
1366 
<span class="line-modified">1367 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">1368 static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject*, CallFrame*);</span>
1369 
1370 class WasmStreamingParser : public JSDestructibleObject {
1371 public:
<span class="line-added">1372     class Client final : public Wasm::StreamingParserClient {</span>
<span class="line-added">1373     public:</span>
<span class="line-added">1374         explicit Client(WasmStreamingParser* parser)</span>
<span class="line-added">1375             : m_parser(parser)</span>
<span class="line-added">1376         {</span>
<span class="line-added">1377         }</span>
<span class="line-added">1378 </span>
<span class="line-added">1379         bool didReceiveSectionData(Wasm::Section) override { return true; }</span>
<span class="line-added">1380         bool didReceiveFunctionData(unsigned, const Wasm::FunctionData&amp;) override { return true; }</span>
<span class="line-added">1381         void didFinishParsing() override { }</span>
<span class="line-added">1382 </span>
<span class="line-added">1383         WasmStreamingParser* m_parser;</span>
<span class="line-added">1384     };</span>
<span class="line-added">1385 </span>
1386     WasmStreamingParser(VM&amp; vm, Structure* structure)
1387         : Base(vm, structure)
1388         , m_info(Wasm::ModuleInformation::create())
<span class="line-modified">1389         , m_client(this)</span>
<span class="line-added">1390         , m_streamingParser(m_info.get(), m_client)</span>
1391     {
<span class="line-added">1392         DollarVMAssertScope assertScope;</span>
1393     }
1394 
1395     using Base = JSDestructibleObject;
1396 
1397     static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
<span class="line-added">1399         DollarVMAssertScope assertScope;</span>
1400         Structure* structure = createStructure(vm, globalObject, jsNull());
1401         WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
1402         result-&gt;finishCreation(vm);
1403         return result;
1404     }
1405 
1406     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1407     {
<span class="line-added">1408         DollarVMAssertScope assertScope;</span>
1409         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1410     }
1411 
1412     Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
1413 
1414     void finishCreation(VM&amp; vm)
1415     {
<span class="line-added">1416         DollarVMAssertScope assertScope;</span>
1417         Base::finishCreation(vm);
1418 
1419         JSGlobalObject* globalObject = this-&gt;globalObject(vm);
1420         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1421         putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
1422     }
1423 
1424     DECLARE_INFO;
1425 
1426     Ref&lt;Wasm::ModuleInformation&gt; m_info;
<span class="line-added">1427     Client m_client;</span>
1428     Wasm::StreamingParser m_streamingParser;
1429 };
1430 
1431 const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
1432 
<span class="line-modified">1433 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1434 {
<span class="line-modified">1435     DollarVMAssertScope assertScope;</span>
<span class="line-modified">1436     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1437     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-added">1438 </span>
<span class="line-added">1439     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());</span>
1440     if (!thisObject)
1441         RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
1442 
<span class="line-modified">1443     auto data = getWasmBufferFromValue(globalObject, callFrame-&gt;argument(0));</span>
1444     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1445     RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
1446 }
1447 
<span class="line-modified">1448 EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1449 {
<span class="line-modified">1450     DollarVMAssertScope assertScope;</span>
<span class="line-modified">1451     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1452     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());</span>
1453     if (!thisObject)
1454         return JSValue::encode(jsBoolean(false));
1455     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
1456 }
1457 
1458 #endif
1459 
1460 } // namespace
1461 
1462 namespace JSC {
1463 
1464 const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
1465 
1466 // Triggers a crash immediately.
1467 // Usage: $vm.crash()
<span class="line-modified">1468 static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(JSGlobalObject*, CallFrame*)</span>
1469 {
<span class="line-added">1470     DollarVMAssertScope assertScope;</span>
1471     CRASH();
1472 }
1473 
1474 // Executes a breakpoint instruction if the first argument is truthy or is unset.
1475 // Usage: $vm.breakpoint(&lt;condition&gt;)
<span class="line-modified">1476 static EncodedJSValue JSC_HOST_CALL functionBreakpoint(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1477 {
<span class="line-added">1478     DollarVMAssertScope assertScope;</span>
1479     // Nothing should throw here but we might as well double check...
<span class="line-modified">1480     VM&amp; vm = globalObject-&gt;vm();</span>
1481     auto scope = DECLARE_CATCH_SCOPE(vm);
1482     UNUSED_PARAM(scope);
<span class="line-modified">1483     if (!callFrame-&gt;argumentCount() || callFrame-&gt;argument(0).toBoolean(globalObject))</span>
1484         WTFBreakpointTrap();
1485 
1486     return encodedJSUndefined();
1487 }
1488 
1489 // Returns true if the current frame is a DFG frame.
1490 // Usage: isDFG = $vm.dfgTrue()
<span class="line-modified">1491 static EncodedJSValue JSC_HOST_CALL functionDFGTrue(JSGlobalObject*, CallFrame*)</span>
1492 {
<span class="line-added">1493     DollarVMAssertScope assertScope;</span>
1494     return JSValue::encode(jsBoolean(false));
1495 }
1496 
1497 // Returns true if the current frame is a FTL frame.
1498 // Usage: isFTL = $vm.ftlTrue()
<span class="line-modified">1499 static EncodedJSValue JSC_HOST_CALL functionFTLTrue(JSGlobalObject*, CallFrame*)</span>
1500 {
<span class="line-added">1501     DollarVMAssertScope assertScope;</span>
1502     return JSValue::encode(jsBoolean(false));
1503 }
1504 
<span class="line-modified">1505 static EncodedJSValue JSC_HOST_CALL functionCpuMfence(JSGlobalObject*, CallFrame*)</span>
1506 {
<span class="line-added">1507     DollarVMAssertScope assertScope;</span>
1508 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1509     asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
1510 #endif
1511     return JSValue::encode(jsUndefined());
1512 }
1513 
<span class="line-modified">1514 static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(JSGlobalObject*, CallFrame*)</span>
1515 {
<span class="line-added">1516     DollarVMAssertScope assertScope;</span>
1517 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1518     unsigned high;
1519     unsigned low;
1520     asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
1521     return JSValue::encode(jsNumber(low));
1522 #else
1523     return JSValue::encode(jsNumber(0));
1524 #endif
1525 }
1526 
<span class="line-modified">1527 static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(JSGlobalObject*, CallFrame*)</span>
1528 {
<span class="line-added">1529     DollarVMAssertScope assertScope;</span>
1530 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1531     WTF::x86_cpuid();
1532 #endif
1533     return JSValue::encode(jsUndefined());
1534 }
1535 
<span class="line-modified">1536 static EncodedJSValue JSC_HOST_CALL functionCpuPause(JSGlobalObject*, CallFrame*)</span>
1537 {
<span class="line-added">1538     DollarVMAssertScope assertScope;</span>
1539 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
1540     asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
1541 #endif
1542     return JSValue::encode(jsUndefined());
1543 }
1544 
1545 // This takes either a JSArrayBuffer, JSArrayBufferView*, or any other object as its first
1546 // argument. The second argument is expected to be an integer.
1547 //
1548 // If the first argument is a JSArrayBuffer, it&#39;ll clflush on that buffer
1549 // plus the second argument as a byte offset. It&#39;ll also flush on the object
1550 // itself so its length, etc, aren&#39;t in the cache.
1551 //
1552 // If the first argument is not a JSArrayBuffer, we load the butterfly
1553 // and clflush at the address of the butterfly.
<span class="line-modified">1554 static EncodedJSValue JSC_HOST_CALL functionCpuClflush(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1555 {
<span class="line-added">1556     DollarVMAssertScope assertScope;</span>
1557 #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
<span class="line-modified">1558     VM&amp; vm = globalObject-&gt;vm();</span>
1559 
<span class="line-modified">1560     if (!callFrame-&gt;argument(1).isInt32())</span>
1561         return JSValue::encode(jsBoolean(false));
1562 
1563     auto clflush = [] (void* ptr) {
<span class="line-added">1564         DollarVMAssertScope assertScope;</span>
1565         char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
1566         asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
1567     };
1568 
1569     Vector&lt;void*&gt; toFlush;
1570 
<span class="line-modified">1571     uint32_t offset = callFrame-&gt;argument(1).asUInt32();</span>
1572 
<span class="line-modified">1573     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, callFrame-&gt;argument(0)))</span>
1574         toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
<span class="line-modified">1575     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0))) {</span>
1576         switch (object-&gt;indexingType()) {
1577         case ALL_INT32_INDEXING_TYPES:
1578         case ALL_CONTIGUOUS_INDEXING_TYPES:
1579         case ALL_DOUBLE_INDEXING_TYPES:
1580             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
1581             toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfPublicLength());
1582         }
1583     }
1584 
1585     if (!toFlush.size())
1586         return JSValue::encode(jsBoolean(false));
1587 
1588     for (void* ptr : toFlush)
1589         clflush(ptr);
1590     return JSValue::encode(jsBoolean(true));
1591 #else
<span class="line-modified">1592     UNUSED_PARAM(globalObject);</span>
<span class="line-added">1593     UNUSED_PARAM(callFrame);</span>
1594     return JSValue::encode(jsBoolean(false));
1595 #endif
1596 }
1597 
1598 class CallerFrameJITTypeFunctor {
1599 public:
1600     CallerFrameJITTypeFunctor()
1601         : m_currentFrame(0)
1602         , m_jitType(JITType::None)
1603     {
<span class="line-added">1604         DollarVMAssertScope assertScope;</span>
1605     }
1606 
1607     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1608     {
1609         if (m_currentFrame++ &gt; 1) {
1610             m_jitType = visitor-&gt;codeBlock()-&gt;jitType();
1611             return StackVisitor::Done;
1612         }
1613         return StackVisitor::Continue;
1614     }
1615 
1616     JITType jitType() { return m_jitType; }
1617 
1618 private:
1619     mutable unsigned m_currentFrame;
1620     mutable JITType m_jitType;
1621 };
1622 
1623 static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
1624 {
<span class="line-added">1625     DollarVMAssertScope assertScope;</span>
1626     if (!theFunctionValue.isCell())
1627         return nullptr;
1628 
1629     VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
1630     JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
1631     if (!theFunction)
1632         return nullptr;
1633 
1634     FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm,
1635         theFunction-&gt;executable());
1636 
1637     return executable;
1638 }
1639 
1640 // Returns true if the current frame is a LLInt frame.
1641 // Usage: isLLInt = $vm.llintTrue()
<span class="line-modified">1642 static EncodedJSValue JSC_HOST_CALL functionLLintTrue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1643 {
<span class="line-modified">1644     DollarVMAssertScope assertScope;</span>
<span class="line-added">1645     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1646     if (!callFrame)</span>
1647         return JSValue::encode(jsUndefined());
1648     CallerFrameJITTypeFunctor functor;
<span class="line-modified">1649     callFrame-&gt;iterate(vm, functor);</span>
1650     return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
1651 }
1652 
1653 // Returns true if the current frame is a baseline JIT frame.
1654 // Usage: isBaselineJIT = $vm.jitTrue()
<span class="line-modified">1655 static EncodedJSValue JSC_HOST_CALL functionJITTrue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1656 {
<span class="line-modified">1657     DollarVMAssertScope assertScope;</span>
<span class="line-added">1658     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1659     if (!callFrame)</span>
1660         return JSValue::encode(jsUndefined());
1661     CallerFrameJITTypeFunctor functor;
<span class="line-modified">1662     callFrame-&gt;iterate(vm, functor);</span>
1663     return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
1664 }
1665 
1666 // Set that the argument function should not be inlined.
1667 // Usage:
1668 // function f() { };
1669 // $vm.noInline(f);
<span class="line-modified">1670 static EncodedJSValue JSC_HOST_CALL functionNoInline(JSGlobalObject*, CallFrame* callFrame)</span>
1671 {
<span class="line-modified">1672     DollarVMAssertScope assertScope;</span>
<span class="line-added">1673     if (callFrame-&gt;argumentCount() &lt; 1)</span>
1674         return JSValue::encode(jsUndefined());
1675 
<span class="line-modified">1676     JSValue theFunctionValue = callFrame-&gt;uncheckedArgument(0);</span>
1677 
1678     if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
1679         executable-&gt;setNeverInline(true);
1680 
1681     return JSValue::encode(jsUndefined());
1682 }
1683 
1684 // Runs a full GC synchronously.
1685 // Usage: $vm.gc()
<span class="line-modified">1686 static EncodedJSValue JSC_HOST_CALL functionGC(JSGlobalObject* globalObject, CallFrame*)</span>
1687 {
<span class="line-modified">1688     DollarVMAssertScope assertScope;</span>
<span class="line-added">1689     VMInspector::gc(globalObject);</span>
1690     return JSValue::encode(jsUndefined());
1691 }
1692 
1693 // Runs the edenGC synchronously.
1694 // Usage: $vm.edenGC()
<span class="line-modified">1695 static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)</span>
1696 {
<span class="line-modified">1697     DollarVMAssertScope assertScope;</span>
<span class="line-added">1698     VMInspector::edenGC(globalObject);</span>
1699     return JSValue::encode(jsUndefined());
1700 }
1701 
1702 // Dumps the hashes of all subspaces currently registered with the VM.
1703 // Usage: $vm.dumpSubspaceHashes()
<span class="line-modified">1704 static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(JSGlobalObject* globalObject, CallFrame*)</span>
1705 {
<span class="line-modified">1706     DollarVMAssertScope assertScope;</span>
<span class="line-added">1707     VM&amp; vm = globalObject-&gt;vm();</span>
1708     VMInspector::dumpSubspaceHashes(&amp;vm);
1709     return JSValue::encode(jsUndefined());
1710 }
1711 
1712 // Gets a JSDollarVMCallFrame for a specified frame index.
1713 // Usage: var callFrame = $vm.callFrame(0) // frame 0 is the top frame.
1714 // Usage: var callFrame = $vm.callFrame() // implies frame 0 i.e. current frame.
1715 //
1716 // This gives you the ability to query the following:
1717 //    callFrame.valid; // false if we asked for a frame beyond the end of the stack, else true.
1718 //    callFrame.callee;
1719 //    callFrame.codeBlock;
1720 //    callFrame.unlinkedCodeBlock;
1721 //    callFrame.executable;
1722 //
1723 // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
1724 // there are internal objects and not a JS object. Hence, you cannot do string
1725 // concatenation with them.
<span class="line-modified">1726 static EncodedJSValue JSC_HOST_CALL functionCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1727 {
<span class="line-added">1728     DollarVMAssertScope assertScope;</span>
1729     unsigned frameNumber = 1;
<span class="line-modified">1730     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1731         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
1732         if (!value.isUInt32())
1733             return JSValue::encode(jsUndefined());
1734 
1735         // We need to inc the frame number because the caller would consider
1736         // its own frame as frame 0. Hence, we need discount the frame for this
1737         // function.
1738         frameNumber = value.asUInt32() + 1;
1739     }
1740 
<span class="line-modified">1741     return JSValue::encode(JSDollarVMCallFrame::create(globalObject, callFrame, frameNumber));</span>
1742 }
1743 
1744 // Gets a token for the CodeBlock for a specified frame index.
1745 // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
1746 // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
<span class="line-modified">1747 static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1748 {
<span class="line-added">1749     DollarVMAssertScope assertScope;</span>
1750     unsigned frameNumber = 1;
<span class="line-modified">1751     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1752         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
1753         if (!value.isUInt32())
1754             return JSValue::encode(jsUndefined());
1755 
1756         // We need to inc the frame number because the caller would consider
1757         // its own frame as frame 0. Hence, we need discount the frame for this
1758         // function.
1759         frameNumber = value.asUInt32() + 1;
1760     }
1761 
<span class="line-modified">1762     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(globalObject, callFrame, frameNumber);</span>
1763     if (codeBlock)
1764         return JSValue::encode(codeBlock);
1765     return JSValue::encode(jsUndefined());
1766 }
1767 
<span class="line-modified">1768 static CodeBlock* codeBlockFromArg(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1769 {
<span class="line-modified">1770     DollarVMAssertScope assertScope;</span>
<span class="line-modified">1771     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1772     if (callFrame-&gt;argumentCount() &lt; 1)</span>
1773         return nullptr;
1774 
<span class="line-modified">1775     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
1776     CodeBlock* candidateCodeBlock = nullptr;
1777     if (value.isCell()) {
1778         JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
1779         if (func) {
1780             if (func-&gt;isHostFunction())
1781                 candidateCodeBlock = nullptr;
1782             else
1783                 candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
1784         } else
1785             candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
1786     }
1787 
<span class="line-modified">1788     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(globalObject, candidateCodeBlock))</span>
1789         return candidateCodeBlock;
1790 
1791     if (candidateCodeBlock)
1792         dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
1793     else
1794         dataLog(&quot;Invalid codeBlock: &quot;, value, &quot;\n&quot;);
1795     return nullptr;
1796 }
1797 
1798 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
1799 // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
1800 // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
1801 // a JS object. Hence, you cannot do string concatenation with it.
<span class="line-modified">1802 static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1803 {
<span class="line-modified">1804     DollarVMAssertScope assertScope;</span>
<span class="line-added">1805     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
1806     WTF::StringPrintStream stream;
1807     if (codeBlock) {
1808         stream.print(*codeBlock);
<span class="line-modified">1809         return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
1810     }
1811     return JSValue::encode(jsUndefined());
1812 }
1813 
1814 // Usage: $vm.dumpSourceFor(functionObj)
1815 // Usage: $vm.dumpSourceFor(codeBlockToken)
<span class="line-modified">1816 static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1817 {
<span class="line-modified">1818     DollarVMAssertScope assertScope;</span>
<span class="line-added">1819     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
1820     if (codeBlock)
1821         codeBlock-&gt;dumpSource();
1822     return JSValue::encode(jsUndefined());
1823 }
1824 
1825 // Usage: $vm.dumpBytecodeFor(functionObj)
1826 // Usage: $vm.dumpBytecodeFor(codeBlock)
<span class="line-modified">1827 static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1828 {
<span class="line-modified">1829     DollarVMAssertScope assertScope;</span>
<span class="line-added">1830     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
1831     if (codeBlock)
1832         codeBlock-&gt;dumpBytecode();
1833     return JSValue::encode(jsUndefined());
1834 }
1835 
<span class="line-modified">1836 static EncodedJSValue doPrint(JSGlobalObject* globalObject, CallFrame* callFrame, bool addLineFeed)</span>
1837 {
<span class="line-modified">1838     DollarVMAssertScope assertScope;</span>
<span class="line-modified">1839     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-modified">1840     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-added">1841         JSValue arg = callFrame-&gt;uncheckedArgument(i);</span>
1842         if (arg.isCell()
1843             &amp;&amp; !arg.isObject()
1844             &amp;&amp; !arg.isString()
1845             &amp;&amp; !arg.isBigInt()) {
1846             dataLog(arg);
1847             continue;
1848         }
<span class="line-modified">1849         String argStr = callFrame-&gt;uncheckedArgument(i).toWTFString(globalObject);</span>
1850         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1851         dataLog(argStr);
1852     }
1853     if (addLineFeed)
1854         dataLog(&quot;\n&quot;);
1855     return JSValue::encode(jsUndefined());
1856 }
1857 
1858 // Prints a series of comma separate strings without appending a newline.
1859 // Usage: $vm.dataLog(str1, str2, str3)
<span class="line-modified">1860 static EncodedJSValue JSC_HOST_CALL functionDataLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1861 {
<span class="line-added">1862     DollarVMAssertScope assertScope;</span>
1863     const bool addLineFeed = false;
<span class="line-modified">1864     return doPrint(globalObject, callFrame, addLineFeed);</span>
1865 }
1866 
1867 // Prints a series of comma separate strings and appends a newline.
1868 // Usage: $vm.print(str1, str2, str3)
<span class="line-modified">1869 static EncodedJSValue JSC_HOST_CALL functionPrint(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1870 {
<span class="line-added">1871     DollarVMAssertScope assertScope;</span>
1872     const bool addLineFeed = true;
<span class="line-modified">1873     return doPrint(globalObject, callFrame, addLineFeed);</span>
1874 }
1875 
1876 // Dumps the current CallFrame.
1877 // Usage: $vm.dumpCallFrame()
<span class="line-modified">1878 static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1879 {
<span class="line-added">1880     DollarVMAssertScope assertScope;</span>
1881     // When the callers call this function, they are expecting to dump their
1882     // own frame. So skip 1 for this frame.
<span class="line-modified">1883     VMInspector::dumpCallFrame(globalObject, callFrame, 1);</span>
1884     return JSValue::encode(jsUndefined());
1885 }
1886 
1887 // Dumps the JS stack.
1888 // Usage: $vm.printStack()
<span class="line-modified">1889 static EncodedJSValue JSC_HOST_CALL functionDumpStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1890 {
<span class="line-added">1891     DollarVMAssertScope assertScope;</span>
1892     // When the callers call this function, they are expecting to dump the
1893     // stack starting their own frame. So skip 1 for this frame.
<span class="line-modified">1894     VMInspector::dumpStack(globalObject, callFrame, 1);</span>
1895     return JSValue::encode(jsUndefined());
1896 }
1897 
1898 // Dumps the current CallFrame.
1899 // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
1900 // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
1901 // FIXME: Currently, this function dumps the physical frame. We should make
1902 // it dump the logical frame (i.e. be able to dump inlined frames as well).
<span class="line-modified">1903 static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1904 {
<span class="line-added">1905     DollarVMAssertScope assertScope;</span>
<span class="line-added">1906     VM&amp; vm = globalObject-&gt;vm();</span>
1907     unsigned requestedFrameIndex = 1;
<span class="line-modified">1908     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1909         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
1910         if (!value.isUInt32())
1911             return JSValue::encode(jsUndefined());
1912 
1913         // We need to inc the frame number because the caller would consider
1914         // its own frame as frame 0. Hence, we need discount the frame for this
1915         // function.
1916         requestedFrameIndex = value.asUInt32() + 1;
1917     }
1918 
1919     unsigned frameIndex = 0;
<span class="line-modified">1920     callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {</span>
<span class="line-added">1921         DollarVMAssertScope assertScope;</span>
1922         if (frameIndex++ != requestedFrameIndex)
1923             return StackVisitor::Continue;
1924         VMInspector::dumpRegisters(visitor-&gt;callFrame());
1925         return StackVisitor::Done;
1926     });
1927 
1928     return encodedJSUndefined();
1929 }
1930 
1931 // Dumps the internal memory layout of a JSCell.
1932 // Usage: $vm.dumpCell(cell)
<span class="line-modified">1933 static EncodedJSValue JSC_HOST_CALL functionDumpCell(JSGlobalObject*, CallFrame* callFrame)</span>
1934 {
<span class="line-modified">1935     DollarVMAssertScope assertScope;</span>
<span class="line-added">1936     JSValue value = callFrame-&gt;argument(0);</span>
1937     if (!value.isCell())
1938         return encodedJSUndefined();
1939 
1940     VMInspector::dumpCellMemory(value.asCell());
1941     return encodedJSUndefined();
1942 }
1943 
1944 // Gets the dataLog dump of the indexingMode of the passed value.
1945 // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
<span class="line-modified">1946 static EncodedJSValue JSC_HOST_CALL functionIndexingMode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1947 {
<span class="line-modified">1948     DollarVMAssertScope assertScope;</span>
<span class="line-added">1949     if (!callFrame-&gt;argument(0).isObject())</span>
1950         return encodedJSUndefined();
1951 
1952     WTF::StringPrintStream stream;
<span class="line-modified">1953     stream.print(IndexingTypeDump(callFrame-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));</span>
<span class="line-modified">1954     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
1955 }
1956 
<span class="line-modified">1957 static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1958 {
<span class="line-modified">1959     DollarVMAssertScope assertScope;</span>
<span class="line-modified">1960     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1961     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0)))</span>
1962         return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
1963 
1964     return encodedJSUndefined();
1965 }
1966 
1967 // Gets the dataLog dump of a given JS value as a string.
1968 // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
<span class="line-modified">1969 static EncodedJSValue JSC_HOST_CALL functionValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1970 {
<span class="line-added">1971     DollarVMAssertScope assertScope;</span>
1972     WTF::StringPrintStream stream;
<span class="line-modified">1973     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
1974         if (i)
1975             stream.print(&quot;, &quot;);
<span class="line-modified">1976         stream.print(callFrame-&gt;uncheckedArgument(i));</span>
1977     }
1978 
<span class="line-modified">1979     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
1980 }
1981 
1982 // Gets the pid of the current process.
1983 // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
<span class="line-modified">1984 static EncodedJSValue JSC_HOST_CALL functionGetPID(JSGlobalObject*, CallFrame*)</span>
1985 {
<span class="line-added">1986     DollarVMAssertScope assertScope;</span>
1987     return JSValue::encode(jsNumber(getCurrentProcessID()));
1988 }
1989 
1990 // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
1991 // Usage: $vm.haveABadTime(globalObject)
<span class="line-modified">1992 static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1993 {
<span class="line-modified">1994     DollarVMAssertScope assertScope;</span>
<span class="line-added">1995     VM&amp; vm = globalObject-&gt;vm();</span>
1996     JSLockHolder lock(vm);
<span class="line-modified">1997     JSValue objValue = callFrame-&gt;argument(0);</span>
1998     if (!objValue.isObject())
1999         return JSValue::encode(jsBoolean(false));
2000 
2001     JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">2002     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">2003     if (!target)</span>
2004         JSValue::encode(jsBoolean(false));
2005 
<span class="line-modified">2006     target-&gt;haveABadTime(vm);</span>
2007     return JSValue::encode(jsBoolean(true));
2008 }
2009 
2010 // Checks if the object (or its global if the object is not a global) is having a bad time.
2011 // Usage: $vm.isHavingABadTime(obj)
<span class="line-modified">2012 static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2013 {
<span class="line-modified">2014     DollarVMAssertScope assertScope;</span>
<span class="line-added">2015     VM&amp; vm = globalObject-&gt;vm();</span>
2016     JSLockHolder lock(vm);
<span class="line-modified">2017     JSValue objValue = callFrame-&gt;argument(0);</span>
2018     if (!objValue.isObject())
2019         return JSValue::encode(jsUndefined());
2020 
2021     JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">2022     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">2023     if (target)</span>
<span class="line-modified">2024         JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));</span>
2025 
<span class="line-modified">2026     target= obj-&gt;globalObject();</span>
<span class="line-modified">2027     if (!target)</span>
2028         return JSValue::encode(jsUndefined());
2029 
<span class="line-modified">2030     return JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));</span>
<span class="line-added">2031 }</span>
<span class="line-added">2032 </span>
<span class="line-added">2033 // Calls the specified test function after adjusting the stack to have the specified</span>
<span class="line-added">2034 // remaining size from the end of the physical stack.</span>
<span class="line-added">2035 // Usage: $vm.callWithStackSize(funcToCall, desiredStackSize)</span>
<span class="line-added">2036 //</span>
<span class="line-added">2037 // This function will only work in test configurations, specifically, only if JSC</span>
<span class="line-added">2038 // options are not frozen. For the jsc shell, the --disableOptionsFreezingForTesting</span>
<span class="line-added">2039 // argument needs to be passed in on the command line.</span>
<span class="line-added">2040 </span>
<span class="line-added">2041 #if ENABLE(MASM_PROBE)</span>
<span class="line-added">2042 static void callWithStackSizeProbeFunction(Probe::State* state)</span>
<span class="line-added">2043 {</span>
<span class="line-added">2044     JSGlobalObject* globalObject = bitwise_cast&lt;JSGlobalObject*&gt;(state-&gt;arg);</span>
<span class="line-added">2045     JSFunction* function = bitwise_cast&lt;JSFunction*&gt;(state-&gt;probeFunction);</span>
<span class="line-added">2046     state-&gt;initializeStackFunction = nullptr;</span>
<span class="line-added">2047     state-&gt;initializeStackArg = nullptr;</span>
<span class="line-added">2048 </span>
<span class="line-added">2049     DollarVMAssertScope assertScope;</span>
<span class="line-added">2050     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2051 </span>
<span class="line-added">2052     CallData callData;</span>
<span class="line-added">2053     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-added">2054     MarkedArgumentBuffer args;</span>
<span class="line-added">2055     call(globalObject, function, callType, callData, jsUndefined(), args);</span>
<span class="line-added">2056 }</span>
<span class="line-added">2057 #endif // ENABLE(MASM_PROBE)</span>
<span class="line-added">2058 </span>
<span class="line-added">2059 SUPPRESS_ASAN</span>
<span class="line-added">2060 static EncodedJSValue JSC_HOST_CALL functionCallWithStackSize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">2061 {</span>
<span class="line-added">2062     DollarVMAssertScope assertScope;</span>
<span class="line-added">2063     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2064     JSLockHolder lock(vm);</span>
<span class="line-added">2065     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2066 </span>
<span class="line-added">2067 #if OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">2068     constexpr bool isSupportedByPlatform = true;</span>
<span class="line-added">2069 #else</span>
<span class="line-added">2070     constexpr bool isSupportedByPlatform = false;</span>
<span class="line-added">2071 #endif</span>
<span class="line-added">2072 </span>
<span class="line-added">2073     if (!isSupportedByPlatform)</span>
<span class="line-added">2074         return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);</span>
<span class="line-added">2075 </span>
<span class="line-added">2076 #if ENABLE(MASM_PROBE)</span>
<span class="line-added">2077     if (g_jscConfig.isPermanentlyFrozen || !g_jscConfig.disabledFreezingForTesting)</span>
<span class="line-added">2078         return throwVMError(globalObject, throwScope, &quot;Options are frozen&quot;);</span>
<span class="line-added">2079 </span>
<span class="line-added">2080     if (callFrame-&gt;argumentCount() &lt; 2)</span>
<span class="line-added">2081         return throwVMError(globalObject, throwScope, &quot;Invalid number of arguments&quot;);</span>
<span class="line-added">2082     JSValue arg0 = callFrame-&gt;argument(0);</span>
<span class="line-added">2083     JSValue arg1 = callFrame-&gt;argument(1);</span>
<span class="line-added">2084     if (!arg0.isFunction(vm))</span>
<span class="line-added">2085         return throwVMError(globalObject, throwScope, &quot;arg0 should be a function&quot;);</span>
<span class="line-added">2086     if (!arg1.isNumber())</span>
<span class="line-added">2087         return throwVMError(globalObject, throwScope, &quot;arg1 should be a number&quot;);</span>
<span class="line-added">2088 </span>
<span class="line-added">2089     JSFunction* function = jsCast&lt;JSFunction*&gt;(arg0);</span>
<span class="line-added">2090     size_t desiredStackSize = arg1.asNumber();</span>
<span class="line-added">2091 </span>
<span class="line-added">2092     const StackBounds&amp; bounds = Thread::current().stack();</span>
<span class="line-added">2093     uint8_t* currentStackPosition = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-added">2094     uint8_t* end = bitwise_cast&lt;uint8_t*&gt;(bounds.end());</span>
<span class="line-added">2095     uint8_t* desiredStart = end + desiredStackSize;</span>
<span class="line-added">2096     if (desiredStart &gt;= currentStackPosition)</span>
<span class="line-added">2097         return throwVMError(globalObject, throwScope, &quot;Unable to setup desired stack size&quot;);</span>
<span class="line-added">2098 </span>
<span class="line-added">2099     JSDollarVMHelper helper(vm);</span>
<span class="line-added">2100 </span>
<span class="line-added">2101     unsigned originalMaxPerThreadStackUsage = Options::maxPerThreadStackUsage();</span>
<span class="line-added">2102     void* originalVMSoftStackLimit = vm.softStackLimit();</span>
<span class="line-added">2103     void* originalVMStackLimit = vm.stackLimit();</span>
<span class="line-added">2104 </span>
<span class="line-added">2105     // This is a hack to make the VM think it&#39;s stack limits are near the end</span>
<span class="line-added">2106     // of the physical stack.</span>
<span class="line-added">2107     uint8_t* vmStackStart = bitwise_cast&lt;uint8_t*&gt;(vm.stackPointerAtVMEntry());</span>
<span class="line-added">2108     uint8_t* vmStackEnd = vmStackStart - originalMaxPerThreadStackUsage;</span>
<span class="line-added">2109     ptrdiff_t sizeDiff = vmStackEnd - end;</span>
<span class="line-added">2110     RELEASE_ASSERT(sizeDiff &gt;= 0);</span>
<span class="line-added">2111     RELEASE_ASSERT(sizeDiff &lt; UINT_MAX);</span>
<span class="line-added">2112 </span>
<span class="line-added">2113     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage + sizeDiff;</span>
<span class="line-added">2114     helper.updateVMStackLimits();</span>
<span class="line-added">2115 </span>
<span class="line-added">2116 #if OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">2117     __asm__ volatile (</span>
<span class="line-added">2118         &quot;subq %[sizeDiff], %%rsp&quot; &quot;\n&quot;</span>
<span class="line-added">2119         &quot;pushq %%rax&quot; &quot;\n&quot;</span>
<span class="line-added">2120         &quot;pushq %%rcx&quot; &quot;\n&quot;</span>
<span class="line-added">2121         &quot;pushq %%rdx&quot; &quot;\n&quot;</span>
<span class="line-added">2122         &quot;pushq %%rbx&quot; &quot;\n&quot;</span>
<span class="line-added">2123         &quot;callq *%%rax&quot; &quot;\n&quot;</span>
<span class="line-added">2124         &quot;addq %[sizeDiff], %%rsp&quot; &quot;\n&quot;</span>
<span class="line-added">2125         :</span>
<span class="line-added">2126         : &quot;a&quot; (ctiMasmProbeTrampoline)</span>
<span class="line-added">2127         , &quot;c&quot; (callWithStackSizeProbeFunction)</span>
<span class="line-added">2128         , &quot;d&quot; (function)</span>
<span class="line-added">2129         , &quot;b&quot; (globalObject)</span>
<span class="line-added">2130         , [sizeDiff] &quot;rm&quot; (sizeDiff)</span>
<span class="line-added">2131         : &quot;memory&quot;</span>
<span class="line-added">2132     );</span>
<span class="line-added">2133 #else</span>
<span class="line-added">2134     UNUSED_PARAM(function);</span>
<span class="line-added">2135 #if !COMPILER(MSVC)</span>
<span class="line-added">2136     UNUSED_PARAM(callWithStackSizeProbeFunction);</span>
<span class="line-added">2137 #endif</span>
<span class="line-added">2138 #endif // OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">2139 </span>
<span class="line-added">2140     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage;</span>
<span class="line-added">2141     helper.updateVMStackLimits();</span>
<span class="line-added">2142     RELEASE_ASSERT(vm.softStackLimit() == originalVMSoftStackLimit);</span>
<span class="line-added">2143     RELEASE_ASSERT(vm.stackLimit() == originalVMStackLimit);</span>
<span class="line-added">2144 </span>
<span class="line-added">2145     throwScope.release();</span>
<span class="line-added">2146     return encodedJSUndefined();</span>
<span class="line-added">2147 </span>
<span class="line-added">2148 #else // not ENABLE(MASM_PROBE)</span>
<span class="line-added">2149     UNUSED_PARAM(callFrame);</span>
<span class="line-added">2150     return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);</span>
<span class="line-added">2151 #endif // ENABLE(MASM_PROBE)</span>
2152 }
2153 
2154 // Creates a new global object.
2155 // Usage: $vm.createGlobalObject()
<span class="line-modified">2156 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)</span>
2157 {
<span class="line-modified">2158     DollarVMAssertScope assertScope;</span>
<span class="line-added">2159     VM&amp; vm = globalObject-&gt;vm();</span>
2160     JSLockHolder lock(vm);
<span class="line-modified">2161     return JSValue::encode(JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull())));</span>

2162 }
2163 
<span class="line-modified">2164 static EncodedJSValue JSC_HOST_CALL functionCreateProxy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2165 {
<span class="line-modified">2166     DollarVMAssertScope assertScope;</span>
<span class="line-added">2167     VM&amp; vm = globalObject-&gt;vm();</span>
2168     JSLockHolder lock(vm);
<span class="line-modified">2169     JSValue target = callFrame-&gt;argument(0);</span>
2170     if (!target.isObject())
2171         return JSValue::encode(jsUndefined());
2172     JSObject* jsTarget = asObject(target.asCell());
<span class="line-modified">2173     Structure* structure = JSProxy::createStructure(vm, globalObject, jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);</span>
2174     JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
2175     return JSValue::encode(proxy);
2176 }
2177 
<span class="line-modified">2178 static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2179 {
<span class="line-modified">2180     DollarVMAssertScope assertScope;</span>
<span class="line-modified">2181     JSLockHolder lock(globalObject);</span>
<span class="line-added">2182     RuntimeArray* array = RuntimeArray::create(globalObject, callFrame);</span>
2183     return JSValue::encode(array);
2184 }
2185 
<span class="line-modified">2186 static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(JSGlobalObject* globalObject, CallFrame*)</span>
2187 {
<span class="line-modified">2188     DollarVMAssertScope assertScope;</span>
<span class="line-added">2189     VM&amp; vm = globalObject-&gt;vm();</span>
2190     JSLockHolder lock(vm);
2191     return JSValue::encode(JSRopeString::createNullForTesting(vm));
2192 }
2193 
<span class="line-modified">2194 static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2195 {
<span class="line-modified">2196     DollarVMAssertScope assertScope;</span>
<span class="line-added">2197     VM&amp; vm = globalObject-&gt;vm();</span>
2198     JSLockHolder lock(vm);
<span class="line-modified">2199     JSValue target = callFrame-&gt;argument(0);</span>
2200     JSObject* delegate = nullptr;
2201     if (target.isObject())
2202         delegate = asObject(target.asCell());
<span class="line-modified">2203     Structure* structure = ImpureGetter::createStructure(vm, globalObject, jsNull());</span>
2204     ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
2205     return JSValue::encode(result);
2206 }
2207 
<span class="line-modified">2208 static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(JSGlobalObject* globalObject, CallFrame*)</span>
2209 {
<span class="line-modified">2210     DollarVMAssertScope assertScope;</span>
<span class="line-added">2211     VM&amp; vm = globalObject-&gt;vm();</span>
2212     JSLockHolder lock(vm);
<span class="line-modified">2213     Structure* structure = CustomGetter::createStructure(vm, globalObject, jsNull());</span>
2214     CustomGetter* result = CustomGetter::create(vm, structure);
2215     return JSValue::encode(result);
2216 }
2217 
<span class="line-modified">2218 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(JSGlobalObject* globalObject, CallFrame*)</span>
2219 {
<span class="line-modified">2220     DollarVMAssertScope assertScope;</span>
<span class="line-added">2221     VM&amp; vm = globalObject-&gt;vm();</span>
2222     JSLockHolder lock(vm);
<span class="line-modified">2223     Structure* structure = DOMJITNode::createStructure(vm, globalObject, DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, globalObject, jsNull())));</span>
2224     DOMJITNode* result = DOMJITNode::create(vm, structure);
2225     return JSValue::encode(result);
2226 }
2227 
<span class="line-modified">2228 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(JSGlobalObject* globalObject, CallFrame*)</span>
2229 {
<span class="line-modified">2230     DollarVMAssertScope assertScope;</span>
<span class="line-added">2231     VM&amp; vm = globalObject-&gt;vm();</span>
2232     JSLockHolder lock(vm);
<span class="line-modified">2233     Structure* structure = DOMJITGetter::createStructure(vm, globalObject, jsNull());</span>
2234     DOMJITGetter* result = DOMJITGetter::create(vm, structure);
2235     return JSValue::encode(result);
2236 }
2237 
<span class="line-modified">2238 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(JSGlobalObject* globalObject, CallFrame*)</span>
2239 {
<span class="line-modified">2240     DollarVMAssertScope assertScope;</span>
<span class="line-added">2241     VM&amp; vm = globalObject-&gt;vm();</span>
2242     JSLockHolder lock(vm);
<span class="line-modified">2243     Structure* structure = DOMJITGetterComplex::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">2244     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, globalObject, structure);</span>
2245     return JSValue::encode(result);
2246 }
2247 
<span class="line-modified">2248 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(JSGlobalObject* globalObject, CallFrame*)</span>
2249 {
<span class="line-modified">2250     DollarVMAssertScope assertScope;</span>
<span class="line-added">2251     VM&amp; vm = globalObject-&gt;vm();</span>
2252     JSLockHolder lock(vm);
<span class="line-modified">2253     Structure* structure = DOMJITFunctionObject::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">2254     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, globalObject, structure);</span>
2255     return JSValue::encode(result);
2256 }
2257 
<span class="line-modified">2258 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(JSGlobalObject* globalObject, CallFrame*)</span>
2259 {
<span class="line-modified">2260     DollarVMAssertScope assertScope;</span>
<span class="line-added">2261     VM&amp; vm = globalObject-&gt;vm();</span>
2262     JSLockHolder lock(vm);
<span class="line-modified">2263     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">2264     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, globalObject, structure);</span>
2265     return JSValue::encode(result);
2266 }
2267 
<span class="line-modified">2268 static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(JSGlobalObject* globalObject, CallFrame*)</span>
2269 {
<span class="line-modified">2270     DollarVMAssertScope assertScope;</span>
<span class="line-added">2271     VM&amp; vm = globalObject-&gt;vm();</span>
2272     JSLockHolder lock(vm);
<span class="line-modified">2273     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, globalObject, jsNull());</span>
2274     DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
2275     return JSValue::encode(result);
2276 }
2277 
2278 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">2279 static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(JSGlobalObject* globalObject, CallFrame*)</span>
2280 {
<span class="line-modified">2281     DollarVMAssertScope assertScope;</span>
<span class="line-added">2282     VM&amp; vm = globalObject-&gt;vm();</span>
2283     JSLockHolder lock(vm);
<span class="line-modified">2284     return JSValue::encode(WasmStreamingParser::create(vm, globalObject));</span>
2285 }
2286 #endif
2287 
<span class="line-modified">2288 static EncodedJSValue JSC_HOST_CALL functionCreateStaticCustomAccessor(JSGlobalObject* globalObject, CallFrame*)</span>
<span class="line-added">2289 {</span>
<span class="line-added">2290     DollarVMAssertScope assertScope;</span>
<span class="line-added">2291     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2292     JSLockHolder lock(vm);</span>
<span class="line-added">2293     Structure* structure = StaticCustomAccessor::createStructure(vm, globalObject, jsNull());</span>
<span class="line-added">2294     auto* result = StaticCustomAccessor::create(vm, structure);</span>
<span class="line-added">2295     return JSValue::encode(result);</span>
<span class="line-added">2296 }</span>
<span class="line-added">2297 </span>
<span class="line-added">2298 static EncodedJSValue JSC_HOST_CALL functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2299 {
<span class="line-modified">2300     DollarVMAssertScope assertScope;</span>
<span class="line-added">2301     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2302     JSLockHolder lock(vm);</span>
<span class="line-added">2303 </span>
<span class="line-added">2304     auto* dollarVM = jsDynamicCast&lt;JSDollarVM*&gt;(vm, callFrame-&gt;thisValue());</span>
<span class="line-added">2305     RELEASE_ASSERT(dollarVM);</span>
<span class="line-added">2306     auto* result = ObjectDoingSideEffectPutWithoutCorrectSlotStatus::create(vm, dollarVM-&gt;objectDoingSideEffectPutWithoutCorrectSlotStatusStructure());</span>
<span class="line-added">2307     return JSValue::encode(result);</span>
<span class="line-added">2308 }</span>
<span class="line-added">2309 </span>
<span class="line-added">2310 static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">2311 {</span>
<span class="line-added">2312     DollarVMAssertScope assertScope;</span>
<span class="line-added">2313     VM&amp; vm = globalObject-&gt;vm();</span>
2314     JSLockHolder lock(vm);
2315     auto scope = DECLARE_THROW_SCOPE(vm);
2316 
<span class="line-modified">2317     JSValue base = callFrame-&gt;argument(0);</span>
2318     if (!base.isObject())
2319         return JSValue::encode(jsUndefined());
<span class="line-modified">2320     JSValue delegate = callFrame-&gt;argument(1);</span>
2321     if (!delegate.isObject())
2322         return JSValue::encode(jsUndefined());
2323     ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
2324     if (UNLIKELY(!impureGetter)) {
<span class="line-modified">2325         throwTypeError(globalObject, scope, &quot;argument is not an ImpureGetter&quot;_s);</span>
2326         return encodedJSValue();
2327     }
2328     impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
2329     return JSValue::encode(jsUndefined());
2330 }
2331 
<span class="line-modified">2332 static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2333 {
<span class="line-modified">2334     DollarVMAssertScope assertScope;</span>
<span class="line-added">2335     VM&amp; vm = globalObject-&gt;vm();</span>
2336     auto scope = DECLARE_THROW_SCOPE(vm);
2337 
<span class="line-modified">2338     if (callFrame-&gt;argumentCount() &lt; 1 || !callFrame-&gt;argument(0).isString())</span>
2339         return JSValue::encode(jsUndefined());
2340 
<span class="line-modified">2341     String functionText = asString(callFrame-&gt;argument(0))-&gt;value(globalObject);</span>
2342     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2343 
<span class="line-modified">2344     SourceCode source = makeSource(functionText, { });</span>
<span class="line-modified">2345     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), globalObject);</span>
2346 
2347     return JSValue::encode(func);
2348 }
2349 
<span class="line-modified">2350 static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2351 {
<span class="line-modified">2352     DollarVMAssertScope assertScope;</span>
<span class="line-added">2353     VM&amp; vm = globalObject-&gt;vm();</span>
2354     auto scope = DECLARE_THROW_SCOPE(vm);
2355 
<span class="line-modified">2356     if (callFrame-&gt;argumentCount() &lt; 2 || !callFrame-&gt;argument(1).isString())</span>
2357         return encodedJSUndefined();
2358 
<span class="line-modified">2359     String str = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
2360 
2361     SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
2362     if (!symbol)
<span class="line-modified">2363         return throwVMError(globalObject, scope, &quot;Unknown private name.&quot;);</span>
2364 
<span class="line-modified">2365     RELEASE_AND_RETURN(scope, JSValue::encode(callFrame-&gt;argument(0).get(globalObject, symbol)));</span>
2366 }
2367 
<span class="line-modified">2368 static EncodedJSValue JSC_HOST_CALL functionCreateRoot(JSGlobalObject* globalObject, CallFrame*)</span>
2369 {
<span class="line-modified">2370     DollarVMAssertScope assertScope;</span>
<span class="line-added">2371     VM&amp; vm = globalObject-&gt;vm();</span>
2372     JSLockHolder lock(vm);
<span class="line-modified">2373     return JSValue::encode(Root::create(vm, globalObject));</span>
2374 }
2375 
<span class="line-modified">2376 static EncodedJSValue JSC_HOST_CALL functionCreateElement(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2377 {
<span class="line-modified">2378     DollarVMAssertScope assertScope;</span>
<span class="line-added">2379     VM&amp; vm = globalObject-&gt;vm();</span>
2380     JSLockHolder lock(vm);
2381     auto scope = DECLARE_THROW_SCOPE(vm);
2382 
<span class="line-modified">2383     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));</span>
2384     if (!root)
<span class="line-modified">2385         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Cannot create Element without a Root.&quot;_s)));</span>
<span class="line-modified">2386     return JSValue::encode(Element::create(vm, globalObject, root));</span>
2387 }
2388 
<span class="line-modified">2389 static EncodedJSValue JSC_HOST_CALL functionGetElement(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2390 {
<span class="line-modified">2391     DollarVMAssertScope assertScope;</span>
<span class="line-added">2392     VM&amp; vm = globalObject-&gt;vm();</span>
2393     JSLockHolder lock(vm);
<span class="line-modified">2394     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));</span>
2395     if (!root)
2396         return JSValue::encode(jsUndefined());
2397     Element* result = root-&gt;element();
2398     return JSValue::encode(result ? result : jsUndefined());
2399 }
2400 
<span class="line-modified">2401 static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(JSGlobalObject* globalObject, CallFrame*)</span>
2402 {
<span class="line-modified">2403     DollarVMAssertScope assertScope;</span>
<span class="line-added">2404     VM&amp; vm = globalObject-&gt;vm();</span>
2405     JSLockHolder lock(vm);
<span class="line-modified">2406     return JSValue::encode(SimpleObject::create(vm, globalObject));</span>
2407 }
2408 
<span class="line-modified">2409 static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2410 {
<span class="line-modified">2411     DollarVMAssertScope assertScope;</span>
<span class="line-added">2412     VM&amp; vm = globalObject-&gt;vm();</span>
2413     JSLockHolder lock(vm);
2414     auto scope = DECLARE_THROW_SCOPE(vm);
2415 
<span class="line-modified">2416     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));</span>
2417     if (UNLIKELY(!simpleObject)) {
<span class="line-modified">2418         throwTypeError(globalObject, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);</span>
2419         return encodedJSValue();
2420     }
2421     return JSValue::encode(simpleObject-&gt;hiddenValue());
2422 }
2423 
<span class="line-modified">2424 static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2425 {
<span class="line-modified">2426     DollarVMAssertScope assertScope;</span>
<span class="line-added">2427     VM&amp; vm = globalObject-&gt;vm();</span>
2428     JSLockHolder lock(vm);
2429     auto scope = DECLARE_THROW_SCOPE(vm);
2430 
<span class="line-modified">2431     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));</span>
2432     if (UNLIKELY(!simpleObject)) {
<span class="line-modified">2433         throwTypeError(globalObject, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);</span>
2434         return encodedJSValue();
2435     }
<span class="line-modified">2436     JSValue value = callFrame-&gt;argument(1);</span>
2437     simpleObject-&gt;setHiddenValue(vm, value);
2438     return JSValue::encode(jsUndefined());
2439 }
2440 
<span class="line-modified">2441 static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2442 {
<span class="line-modified">2443     DollarVMAssertScope assertScope;</span>
<span class="line-added">2444     VM&amp; vm = globalObject-&gt;vm();</span>
2445     auto scope = DECLARE_THROW_SCOPE(vm);
2446     if (auto* shadowChicken = vm.shadowChicken()) {
2447         scope.release();
<span class="line-modified">2448         return JSValue::encode(shadowChicken-&gt;functionsOnStack(globalObject, callFrame));</span>
2449     }
2450 
<span class="line-modified">2451     JSArray* result = constructEmptyArray(globalObject, 0);</span>
2452     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">2453     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
<span class="line-added">2454         DollarVMAssertScope assertScope;</span>
2455         if (visitor-&gt;isInlinedFrame())
2456             return StackVisitor::Continue;
2457         if (visitor-&gt;isWasmFrame())
2458             return StackVisitor::Continue;
<span class="line-modified">2459         result-&gt;push(globalObject, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));</span>
2460         scope.releaseAssertNoException(); // This function is only called from tests.
2461         return StackVisitor::Continue;
2462     });
2463     RETURN_IF_EXCEPTION(scope, { });
2464     return JSValue::encode(result);
2465 }
2466 
<span class="line-modified">2467 static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(JSGlobalObject* globalObject, CallFrame*)</span>
2468 {
<span class="line-modified">2469     DollarVMAssertScope assertScope;</span>
<span class="line-added">2470     VM&amp; vm = globalObject-&gt;vm();</span>
2471     vm.setGlobalConstRedeclarationShouldThrow(false);
2472     return JSValue::encode(jsUndefined());
2473 }
2474 
<span class="line-modified">2475 static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2476 {
<span class="line-modified">2477     DollarVMAssertScope assertScope;</span>
<span class="line-added">2478     VM&amp; vm = globalObject-&gt;vm();</span>
2479     RELEASE_ASSERT(vm.typeProfiler());
2480     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
2481 
<span class="line-modified">2482     JSValue functionValue = callFrame-&gt;argument(0);</span>
2483     RELEASE_ASSERT(functionValue.isFunction(vm));
2484     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2485 
<span class="line-modified">2486     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">2487     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
2488     String sourceCodeText = executable-&gt;source().view().toString();
2489     unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
2490 
2491     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">2492     return JSValue::encode(JSONParse(globalObject, jsonString));</span>
2493 }
2494 
<span class="line-modified">2495 static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2496 {
<span class="line-modified">2497     DollarVMAssertScope assertScope;</span>
<span class="line-added">2498     VM&amp; vm = globalObject-&gt;vm();</span>
2499     RELEASE_ASSERT(vm.typeProfiler());
2500     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
2501 
<span class="line-modified">2502     JSValue functionValue = callFrame-&gt;argument(0);</span>
2503     RELEASE_ASSERT(functionValue.isFunction(vm));
2504     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2505 
2506     unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
2507     String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">2508     return JSValue::encode(JSONParse(globalObject, jsonString));</span>
2509 }
2510 
<span class="line-modified">2511 static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2512 {
<span class="line-modified">2513     DollarVMAssertScope assertScope;</span>
<span class="line-modified">2514     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2515     JSValue value = callFrame-&gt;argument(0);</span>
2516     RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
2517     value.getObject()-&gt;flattenDictionaryObject(vm);
2518     return encodedJSUndefined();
2519 }
2520 
<span class="line-modified">2521 static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(JSGlobalObject* globalObject, CallFrame*)</span>
2522 {
<span class="line-modified">2523     DollarVMAssertScope assertScope;</span>
<span class="line-added">2524     VM&amp; vm = globalObject-&gt;vm();</span>
2525     RELEASE_ASSERT(vm.controlFlowProfiler());
2526     vm.controlFlowProfiler()-&gt;dumpData();
2527     return JSValue::encode(jsUndefined());
2528 }
2529 
<span class="line-modified">2530 static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2531 {
<span class="line-modified">2532     DollarVMAssertScope assertScope;</span>
<span class="line-added">2533     VM&amp; vm = globalObject-&gt;vm();</span>
2534     RELEASE_ASSERT(vm.controlFlowProfiler());
2535 
<span class="line-modified">2536     JSValue functionValue = callFrame-&gt;argument(0);</span>
2537     RELEASE_ASSERT(functionValue.isFunction(vm));
2538     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2539 
<span class="line-modified">2540     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">2541     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
2542     String sourceCodeText = executable-&gt;source().view().toString();
2543     RELEASE_ASSERT(sourceCodeText.contains(substring));
2544     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2545 
2546     bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
2547     return JSValue::encode(jsBoolean(hasExecuted));
2548 }
2549 
<span class="line-modified">2550 static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2551 {
<span class="line-modified">2552     DollarVMAssertScope assertScope;</span>
<span class="line-added">2553     VM&amp; vm = globalObject-&gt;vm();</span>
2554     RELEASE_ASSERT(vm.controlFlowProfiler());
2555 
<span class="line-modified">2556     JSValue functionValue = callFrame-&gt;argument(0);</span>
2557     RELEASE_ASSERT(functionValue.isFunction(vm));
2558     FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
2559 
<span class="line-modified">2560     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">2561     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
2562     String sourceCodeText = executable-&gt;source().view().toString();
2563     RELEASE_ASSERT(sourceCodeText.contains(substring));
2564     int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
2565 
2566     size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
2567     return JSValue::encode(JSValue(executionCount));
2568 }
2569 
<span class="line-modified">2570 static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(JSGlobalObject*, CallFrame*)</span>
2571 {
<span class="line-added">2572     DollarVMAssertScope assertScope;</span>
2573     Options::useExceptionFuzz() = true;
2574     return JSValue::encode(jsUndefined());
2575 }
2576 
<span class="line-modified">2577 class DoNothingDebugger final : public Debugger {</span>
<span class="line-added">2578     WTF_MAKE_NONCOPYABLE(DoNothingDebugger);</span>
<span class="line-added">2579     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">2580 public:</span>
<span class="line-added">2581     DoNothingDebugger(VM&amp; vm)</span>
<span class="line-added">2582         : Debugger(vm)</span>
<span class="line-added">2583     {</span>
<span class="line-added">2584         DollarVMAssertScope assertScope;</span>
<span class="line-added">2585         setSuppressAllPauses(true);</span>
<span class="line-added">2586     }</span>
<span class="line-added">2587 </span>
<span class="line-added">2588 private:</span>
<span class="line-added">2589     void sourceParsed(JSGlobalObject*, SourceProvider*, int, const WTF::String&amp;) override</span>
<span class="line-added">2590     {</span>
<span class="line-added">2591         DollarVMAssertScope assertScope;</span>
<span class="line-added">2592     }</span>
<span class="line-added">2593 };</span>
<span class="line-added">2594 </span>
<span class="line-added">2595 static EncodedJSValue changeDebuggerModeWhenIdle(JSGlobalObject* globalObject, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>
2596 {
<span class="line-modified">2597     DollarVMAssertScope assertScope;</span>
<span class="line-modified">2598 </span>
<span class="line-added">2599     bool debuggerRequested = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
<span class="line-added">2600     if (debuggerRequested == globalObject-&gt;hasDebugger())</span>
2601         return JSValue::encode(jsUndefined());
2602 
<span class="line-modified">2603     VM* vm = &amp;globalObject-&gt;vm();</span>
2604     vm-&gt;whenIdle([=] () {
<span class="line-modified">2605         DollarVMAssertScope assertScope;</span>
<span class="line-modified">2606         if (debuggerRequested) {</span>
<span class="line-modified">2607             Debugger* debugger = new DoNothingDebugger(globalObject-&gt;vm());</span>
<span class="line-modified">2608             globalObject-&gt;setDebugger(debugger);</span>
<span class="line-added">2609             debugger-&gt;activateBreakpoints(); // Also deletes all code.</span>
<span class="line-added">2610         } else {</span>
<span class="line-added">2611             Debugger* debugger = globalObject-&gt;debugger();</span>
<span class="line-added">2612             debugger-&gt;deactivateBreakpoints(); // Also deletes all code.</span>
<span class="line-added">2613             globalObject-&gt;setDebugger(nullptr);</span>
<span class="line-added">2614             delete debugger;</span>
<span class="line-added">2615         }</span>
2616     });
2617     return JSValue::encode(jsUndefined());
2618 }
2619 
<span class="line-modified">2620 static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
2621 {
<span class="line-modified">2622     DollarVMAssertScope assertScope;</span>
<span class="line-added">2623     return changeDebuggerModeWhenIdle(globalObject, { CodeGenerationMode::Debugger });</span>
2624 }
2625 
<span class="line-modified">2626 static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
2627 {
<span class="line-modified">2628     DollarVMAssertScope assertScope;</span>
<span class="line-added">2629     return changeDebuggerModeWhenIdle(globalObject, { });</span>
2630 }
2631 
<span class="line-modified">2632 static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
2633 {
<span class="line-modified">2634     DollarVMAssertScope assertScope;</span>
<span class="line-added">2635     VM* vm = &amp;globalObject-&gt;vm();</span>
2636     vm-&gt;whenIdle([=] () {
<span class="line-added">2637         DollarVMAssertScope assertScope;</span>
2638         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
2639     });
2640     return JSValue::encode(jsUndefined());
2641 }
2642 
<span class="line-modified">2643 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(JSGlobalObject* globalObject, CallFrame*)</span>
2644 {
<span class="line-modified">2645     DollarVMAssertScope assertScope;</span>
<span class="line-added">2646     return JSValue::encode(jsNumber(globalObject-&gt;vm().heap.globalObjectCount()));</span>
2647 }
2648 
<span class="line-modified">2649 static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2650 {
<span class="line-modified">2651     DollarVMAssertScope assertScope;</span>
<span class="line-added">2652     JSValue value = callFrame-&gt;argument(0);</span>
2653     RELEASE_ASSERT(value.isObject());
<span class="line-modified">2654     JSGlobalObject* result = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(globalObject-&gt;vm());</span>
<span class="line-modified">2655     RELEASE_ASSERT(result);</span>
<span class="line-modified">2656     return JSValue::encode(result);</span>
2657 }
2658 
<span class="line-modified">2659 static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2660 {
<span class="line-modified">2661     DollarVMAssertScope assertScope;</span>
<span class="line-added">2662     VM&amp; vm = globalObject-&gt;vm();</span>
2663     auto scope = DECLARE_THROW_SCOPE(vm);
2664 
<span class="line-modified">2665     JSValue value = callFrame-&gt;argument(0);</span>
2666     if (!value.isObject())
2667         return JSValue::encode(jsUndefined());
2668 
<span class="line-modified">2669     JSValue property = callFrame-&gt;argument(1);</span>
2670     if (!property.isString())
2671         return JSValue::encode(jsUndefined());
2672 
<span class="line-modified">2673     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);</span>
2674     RETURN_IF_EXCEPTION(scope, { });
2675 
2676     PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">2677     value.getPropertySlot(globalObject, propertyName, slot);</span>
2678     RETURN_IF_EXCEPTION(scope, { });
2679 
2680     JSValue result;
2681     if (slot.isCacheableGetter())
2682         result = slot.getterSetter();
2683     else
2684         result = jsNull();
2685 
2686     return JSValue::encode(result);
2687 }
2688 
<span class="line-modified">2689 static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2690 {
<span class="line-modified">2691     DollarVMAssertScope assertScope;</span>
<span class="line-added">2692     VM&amp; vm = globalObject-&gt;vm();</span>
2693     auto scope = DECLARE_THROW_SCOPE(vm);
2694 
<span class="line-modified">2695     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, callFrame-&gt;argument(0));</span>
2696     if (UNLIKELY(!getterSetter)) {
<span class="line-modified">2697         throwTypeError(globalObject, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);</span>
2698         return encodedJSValue();
2699     }
2700 
2701     JSObject* getter = getterSetter-&gt;getter();
2702     RELEASE_ASSERT(getter);
2703     return JSValue::encode(getter);
2704 }
2705 
<span class="line-modified">2706 static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(JSGlobalObject* globalObject, CallFrame*)</span>
2707 {
<span class="line-modified">2708     DollarVMAssertScope assertScope;</span>
<span class="line-modified">2709     VM&amp; vm = globalObject-&gt;vm();</span>
2710     return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
2711 }
2712 
<span class="line-modified">2713 static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2714 {
<span class="line-modified">2715     DollarVMAssertScope assertScope;</span>
<span class="line-modified">2716     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2717     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));</span>
<span class="line-added">2718     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(1));</span>
2719     if (!a || !b)
2720         return JSValue::encode(jsNumber(PNaN));
2721 
2722     ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
2723     if (delta &lt; 0)
2724         return JSValue::encode(jsNumber(PNaN));
2725     if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
2726         return JSValue::encode(jsNumber(PNaN));
2727     return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
2728 }
2729 
<span class="line-modified">2730 static EncodedJSValue JSC_HOST_CALL functionCurrentCPUTime(JSGlobalObject*, CallFrame*)</span>
<span class="line-added">2731 {</span>
<span class="line-added">2732     DollarVMAssertScope assertScope;</span>
<span class="line-added">2733     return JSValue::encode(jsNumber(CPUTime::forCurrentThread().value()));</span>
<span class="line-added">2734 }</span>
<span class="line-added">2735 </span>
<span class="line-added">2736 static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(JSGlobalObject* globalObject, CallFrame*)</span>
2737 {
<span class="line-modified">2738     DollarVMAssertScope assertScope;</span>
<span class="line-added">2739     VM&amp; vm = globalObject-&gt;vm();</span>
2740     return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
2741 }
2742 
<span class="line-modified">2743 static EncodedJSValue JSC_HOST_CALL functionParseCount(JSGlobalObject*, CallFrame*)</span>
2744 {
<span class="line-added">2745     DollarVMAssertScope assertScope;</span>
2746     return JSValue::encode(jsNumber(globalParseCount.load()));
2747 }
2748 
<span class="line-modified">2749 static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(JSGlobalObject*, CallFrame*)</span>
2750 {
<span class="line-added">2751     DollarVMAssertScope assertScope;</span>
2752 #if ENABLE(WEBASSEMBLY)
2753     return JSValue::encode(jsBoolean(Wasm::isSupported()));
2754 #else
2755     return JSValue::encode(jsBoolean(false));
2756 #endif
2757 }
2758 
<span class="line-added">2759 static EncodedJSValue JSC_HOST_CALL functionMake16BitStringIfPossible(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">2760 {</span>
<span class="line-added">2761     DollarVMAssertScope assertScope;</span>
<span class="line-added">2762     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2763     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2764     String string = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
<span class="line-added">2765     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2766     if (!string.is8Bit())</span>
<span class="line-added">2767         return JSValue::encode(jsString(vm, WTFMove(string)));</span>
<span class="line-added">2768     Vector&lt;UChar&gt; buffer;</span>
<span class="line-added">2769     buffer.resize(string.length());</span>
<span class="line-added">2770     StringImpl::copyCharacters(buffer.data(), string.characters8(), string.length());</span>
<span class="line-added">2771     return JSValue::encode(jsString(vm, String::adopt(WTFMove(buffer))));</span>
<span class="line-added">2772 }</span>
<span class="line-added">2773 </span>
<span class="line-added">2774 EncodedJSValue JSC_HOST_CALL JSDollarVMHelper::functionGetStructureTransitionList(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">2775 {</span>
<span class="line-added">2776     DollarVMAssertScope assertScope;</span>
<span class="line-added">2777     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2778     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2779     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);</span>
<span class="line-added">2780     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2781     if (!obj)</span>
<span class="line-added">2782         return JSValue::encode(jsNull());</span>
<span class="line-added">2783     Vector&lt;Structure*, 8&gt; structures;</span>
<span class="line-added">2784 </span>
<span class="line-added">2785     for (auto* structure = obj-&gt;structure(); structure; structure = structure-&gt;previousID())</span>
<span class="line-added">2786         structures.append(structure);</span>
<span class="line-added">2787 </span>
<span class="line-added">2788     JSArray* result = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);</span>
<span class="line-added">2789     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2790 </span>
<span class="line-added">2791     for (size_t i = 0; i &lt; structures.size(); ++i) {</span>
<span class="line-added">2792         auto* structure = structures[structures.size() - i - 1];</span>
<span class="line-added">2793         result-&gt;push(globalObject, JSValue(structure-&gt;id()));</span>
<span class="line-added">2794         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2795         result-&gt;push(globalObject, JSValue(structure-&gt;transitionOffset()));</span>
<span class="line-added">2796         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2797         result-&gt;push(globalObject, JSValue(structure-&gt;maxOffset()));</span>
<span class="line-added">2798         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2799         if (structure-&gt;m_transitionPropertyName)</span>
<span class="line-added">2800             result-&gt;push(globalObject, jsString(vm, String(*structure-&gt;m_transitionPropertyName)));</span>
<span class="line-added">2801         else</span>
<span class="line-added">2802             result-&gt;push(globalObject, jsNull());</span>
<span class="line-added">2803         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2804         result-&gt;push(globalObject, JSValue(structure-&gt;isPropertyDeletionTransition()));</span>
<span class="line-added">2805         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2806     }</span>
<span class="line-added">2807 </span>
<span class="line-added">2808     return JSValue::encode(result);</span>
<span class="line-added">2809 }</span>
<span class="line-added">2810 </span>
<span class="line-added">2811 static EncodedJSValue JSC_HOST_CALL functionGetConcurrently(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">2812 {</span>
<span class="line-added">2813     DollarVMAssertScope assertScope;</span>
<span class="line-added">2814     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2815     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2816     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);</span>
<span class="line-added">2817     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2818     if (!obj)</span>
<span class="line-added">2819         return JSValue::encode(jsNull());</span>
<span class="line-added">2820     String property = callFrame-&gt;argument(1).toWTFString(globalObject);</span>
<span class="line-added">2821     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2822     auto name = PropertyName(Identifier::fromString(vm, property));</span>
<span class="line-added">2823     auto offset = obj-&gt;structure()-&gt;getConcurrently(name.uid());</span>
<span class="line-added">2824     if (offset != invalidOffset)</span>
<span class="line-added">2825         ASSERT(JSValue::encode(obj-&gt;getDirect(offset)));</span>
<span class="line-added">2826     JSValue result = JSValue(offset != invalidOffset);</span>
<span class="line-added">2827     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">2828     return JSValue::encode(result);</span>
<span class="line-added">2829 }</span>
<span class="line-added">2830 </span>
2831 void JSDollarVM::finishCreation(VM&amp; vm)
2832 {
<span class="line-added">2833     DollarVMAssertScope assertScope;</span>
2834     Base::finishCreation(vm);
2835 
2836     JSGlobalObject* globalObject = this-&gt;globalObject(vm);
2837 
2838     auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<span class="line-added">2839         DollarVMAssertScope assertScope;</span>
2840         JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
2841     };
2842     auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<span class="line-added">2843         DollarVMAssertScope assertScope;</span>
2844         JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
2845     };
2846 
2847     addFunction(vm, &quot;abort&quot;, functionCrash, 0);
2848     addFunction(vm, &quot;crash&quot;, functionCrash, 0);
2849     addFunction(vm, &quot;breakpoint&quot;, functionBreakpoint, 0);
2850 
2851     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;dfgTrue&quot;), 0, functionDFGTrue, DFGTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2852     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;ftlTrue&quot;), 0, functionFTLTrue, FTLTrueIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
2853 
2854     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuMfence&quot;), 0, functionCpuMfence, CPUMfenceIntrinsic, 0);
2855     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuRdtsc&quot;), 0, functionCpuRdtsc, CPURdtscIntrinsic, 0);
2856     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuCpuid&quot;), 0, functionCpuCpuid, CPUCpuidIntrinsic, 0);
2857     putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;cpuPause&quot;), 0, functionCpuPause, CPUPauseIntrinsic, 0);
2858     addFunction(vm, &quot;cpuClflush&quot;, functionCpuClflush, 2);
2859 
2860     addFunction(vm, &quot;llintTrue&quot;, functionLLintTrue, 0);
2861     addFunction(vm, &quot;jitTrue&quot;, functionJITTrue, 0);
2862 
2863     addFunction(vm, &quot;noInline&quot;, functionNoInline, 1);
</pre>
<hr />
<pre>
2871     addFunction(vm, &quot;codeBlockForFrame&quot;, functionCodeBlockForFrame, 1);
2872     addFunction(vm, &quot;dumpSourceFor&quot;, functionDumpSourceFor, 1);
2873     addFunction(vm, &quot;dumpBytecodeFor&quot;, functionDumpBytecodeFor, 1);
2874 
2875     addFunction(vm, &quot;dataLog&quot;, functionDataLog, 1);
2876     addFunction(vm, &quot;print&quot;, functionPrint, 1);
2877     addFunction(vm, &quot;dumpCallFrame&quot;, functionDumpCallFrame, 0);
2878     addFunction(vm, &quot;dumpStack&quot;, functionDumpStack, 0);
2879     addFunction(vm, &quot;dumpRegisters&quot;, functionDumpRegisters, 1);
2880 
2881     addFunction(vm, &quot;dumpCell&quot;, functionDumpCell, 1);
2882 
2883     addFunction(vm, &quot;indexingMode&quot;, functionIndexingMode, 1);
2884     addFunction(vm, &quot;inlineCapacity&quot;, functionInlineCapacity, 1);
2885     addFunction(vm, &quot;value&quot;, functionValue, 1);
2886     addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
2887 
2888     addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
2889     addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
2890 
<span class="line-added">2891     addFunction(vm, &quot;callWithStackSize&quot;, functionCallWithStackSize, 2);</span>
<span class="line-added">2892 </span>
2893     addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
2894     addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
2895     addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
2896     addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
2897 
2898     addFunction(vm, &quot;createImpureGetter&quot;, functionCreateImpureGetter, 1);
2899     addFunction(vm, &quot;createCustomGetterObject&quot;, functionCreateCustomGetterObject, 0);
2900     addFunction(vm, &quot;createDOMJITNodeObject&quot;, functionCreateDOMJITNodeObject, 0);
2901     addFunction(vm, &quot;createDOMJITGetterObject&quot;, functionCreateDOMJITGetterObject, 0);
2902     addFunction(vm, &quot;createDOMJITGetterComplexObject&quot;, functionCreateDOMJITGetterComplexObject, 0);
2903     addFunction(vm, &quot;createDOMJITFunctionObject&quot;, functionCreateDOMJITFunctionObject, 0);
2904     addFunction(vm, &quot;createDOMJITCheckSubClassObject&quot;, functionCreateDOMJITCheckSubClassObject, 0);
2905     addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
2906     addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
2907 #if ENABLE(WEBASSEMBLY)
2908     addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
2909 #endif
<span class="line-added">2910     addFunction(vm, &quot;createStaticCustomAccessor&quot;, functionCreateStaticCustomAccessor, 0);</span>
<span class="line-added">2911     addFunction(vm, &quot;createObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus, 0);</span>
2912     addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
2913     addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
2914 
2915     addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
2916     addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
2917     addFunction(vm, &quot;getElement&quot;, functionGetElement, 1);
2918 
2919     addConstructibleFunction(vm, &quot;SimpleObject&quot;, functionCreateSimpleObject, 0);
2920     addFunction(vm, &quot;getHiddenValue&quot;, functionGetHiddenValue, 1);
2921     addFunction(vm, &quot;setHiddenValue&quot;, functionSetHiddenValue, 2);
2922 
2923     addFunction(vm, &quot;shadowChickenFunctionsOnStack&quot;, functionShadowChickenFunctionsOnStack, 0);
2924     addFunction(vm, &quot;setGlobalConstRedeclarationShouldNotThrow&quot;, functionSetGlobalConstRedeclarationShouldNotThrow, 0);
2925 
2926     addFunction(vm, &quot;findTypeForExpression&quot;, functionFindTypeForExpression, 2);
2927     addFunction(vm, &quot;returnTypeFor&quot;, functionReturnTypeFor, 1);
2928 
2929     addFunction(vm, &quot;flattenDictionaryObject&quot;, functionFlattenDictionaryObject, 1);
2930 
2931     addFunction(vm, &quot;dumpBasicBlockExecutionRanges&quot;, functionDumpBasicBlockExecutionRanges , 0);
2932     addFunction(vm, &quot;hasBasicBlockExecuted&quot;, functionHasBasicBlockExecuted, 2);
2933     addFunction(vm, &quot;basicBlockExecutionCount&quot;, functionBasicBlockExecutionCount, 2);
2934 
2935     addFunction(vm, &quot;enableExceptionFuzz&quot;, functionEnableExceptionFuzz, 0);
2936 
2937     addFunction(vm, &quot;enableDebuggerModeWhenIdle&quot;, functionEnableDebuggerModeWhenIdle, 0);
2938     addFunction(vm, &quot;disableDebuggerModeWhenIdle&quot;, functionDisableDebuggerModeWhenIdle, 0);
2939 
2940     addFunction(vm, &quot;deleteAllCodeWhenIdle&quot;, functionDeleteAllCodeWhenIdle, 0);
2941 
2942     addFunction(vm, &quot;globalObjectCount&quot;, functionGlobalObjectCount, 0);
2943     addFunction(vm, &quot;globalObjectForObject&quot;, functionGlobalObjectForObject, 1);
2944 
2945     addFunction(vm, &quot;getGetterSetter&quot;, functionGetGetterSetter, 2);
2946     addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
2947     addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
2948 
2949     addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
2950 
<span class="line-added">2951     addFunction(vm, &quot;currentCPUTime&quot;, functionCurrentCPUTime, 0);</span>
2952     addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
2953 
2954     addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
2955 
2956     addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);
<span class="line-added">2957     addFunction(vm, &quot;make16BitStringIfPossible&quot;, functionMake16BitStringIfPossible, 1);</span>
<span class="line-added">2958 </span>
<span class="line-added">2959     addFunction(vm, &quot;getStructureTransitionList&quot;, JSDollarVMHelper::functionGetStructureTransitionList, 1);</span>
<span class="line-added">2960     addFunction(vm, &quot;getConcurrently&quot;, functionGetConcurrently, 2);</span>
<span class="line-added">2961 </span>
<span class="line-added">2962     m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure.set(vm, this, ObjectDoingSideEffectPutWithoutCorrectSlotStatus::createStructure(vm, globalObject, jsNull()));</span>
2963 }
2964 
2965 void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2966 {
<span class="line-added">2967     DollarVMAssertScope assertScope;</span>
2968     Identifier identifier = Identifier::fromString(vm, name);
2969     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
2970 }
2971 
2972 void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
2973 {
<span class="line-added">2974     DollarVMAssertScope assertScope;</span>
2975     Identifier identifier = Identifier::fromString(vm, name);
2976     putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
2977 }
2978 
<span class="line-added">2979 void JSDollarVM::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)</span>
<span class="line-added">2980 {</span>
<span class="line-added">2981     JSDollarVM* thisObject = jsCast&lt;JSDollarVM*&gt;(cell);</span>
<span class="line-added">2982     Base::visitChildren(thisObject, visitor);</span>
<span class="line-added">2983     visitor.append(thisObject-&gt;m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure);</span>
<span class="line-added">2984 }</span>
<span class="line-added">2985 </span>
2986 } // namespace JSC
<span class="line-added">2987 </span>
<span class="line-added">2988 IGNORE_WARNINGS_END</span>
</pre>
</td>
</tr>
</table>
<center><a href="HeapVerifier.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDollarVM.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormDataBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPHeaderMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormDataBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 81         default:
 82             append(buffer, character);
 83         }
 84     }
 85 }
 86 
 87 // https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer
 88 static void appendFormURLEncoded(Vector&lt;char&gt;&amp; buffer, const uint8_t* string, size_t length)
 89 {
 90     static const char safeCharacters[] = &quot;-._*&quot;;
 91     for (size_t i = 0; i &lt; length; ++i) {
 92         auto character = string[i];
 93         if (isASCIIAlphanumeric(character) || strchr(safeCharacters, character))
 94             append(buffer, character);
 95         else if (character == &#39; &#39;)
 96             append(buffer, &#39;+&#39;);
 97         else if (character == &#39;\n&#39; || (character == &#39;\r&#39; &amp;&amp; (i + 1 &gt;= length || string[i + 1] != &#39;\n&#39;)))
 98             append(buffer, &quot;%0D%0A&quot;); // FIXME: Unclear exactly where this rule about normalizing line endings to CRLF comes from.
 99         else if (character != &#39;\r&#39;) {
100             append(buffer, &#39;%&#39;);
<span class="line-modified">101             appendByteAsHex(character, buffer);</span>


102         }
103     }
104 }
105 
106 static void appendFormURLEncoded(Vector&lt;char&gt;&amp; buffer, const Vector&lt;uint8_t&gt;&amp; string)
107 {
108     appendFormURLEncoded(buffer, string.data(), string.size());
109 }
110 
111 Vector&lt;char&gt; generateUniqueBoundaryString()
112 {
113     Vector&lt;char&gt; boundary;
114 
115     // The RFC 2046 spec says the alphanumeric characters plus the
116     // following characters are legal for boundaries:  &#39;()+_,-./:=?
117     // However the following characters, though legal, cause some sites
118     // to fail: (),./:=+
119     // Note that our algorithm makes it twice as much likely for &#39;A&#39; or &#39;B&#39;
120     // to appear in the boundary string, because 0x41 and 0x42 are present in
121     // the below array twice.
</pre>
</td>
<td>
<hr />
<pre>
 81         default:
 82             append(buffer, character);
 83         }
 84     }
 85 }
 86 
 87 // https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer
 88 static void appendFormURLEncoded(Vector&lt;char&gt;&amp; buffer, const uint8_t* string, size_t length)
 89 {
 90     static const char safeCharacters[] = &quot;-._*&quot;;
 91     for (size_t i = 0; i &lt; length; ++i) {
 92         auto character = string[i];
 93         if (isASCIIAlphanumeric(character) || strchr(safeCharacters, character))
 94             append(buffer, character);
 95         else if (character == &#39; &#39;)
 96             append(buffer, &#39;+&#39;);
 97         else if (character == &#39;\n&#39; || (character == &#39;\r&#39; &amp;&amp; (i + 1 &gt;= length || string[i + 1] != &#39;\n&#39;)))
 98             append(buffer, &quot;%0D%0A&quot;); // FIXME: Unclear exactly where this rule about normalizing line endings to CRLF comes from.
 99         else if (character != &#39;\r&#39;) {
100             append(buffer, &#39;%&#39;);
<span class="line-modified">101             auto hexBuffer = hex(character, 2);</span>
<span class="line-added">102             append(buffer, hexBuffer.characters()[0]);</span>
<span class="line-added">103             append(buffer, hexBuffer.characters()[1]);</span>
104         }
105     }
106 }
107 
108 static void appendFormURLEncoded(Vector&lt;char&gt;&amp; buffer, const Vector&lt;uint8_t&gt;&amp; string)
109 {
110     appendFormURLEncoded(buffer, string.data(), string.size());
111 }
112 
113 Vector&lt;char&gt; generateUniqueBoundaryString()
114 {
115     Vector&lt;char&gt; boundary;
116 
117     // The RFC 2046 spec says the alphanumeric characters plus the
118     // following characters are legal for boundaries:  &#39;()+_,-./:=?
119     // However the following characters, though legal, cause some sites
120     // to fail: (),./:=+
121     // Note that our algorithm makes it twice as much likely for &#39;A&#39; or &#39;B&#39;
122     // to appear in the boundary string, because 0x41 and 0x42 are present in
123     // the below array twice.
</pre>
</td>
</tr>
</table>
<center><a href="FormData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPHeaderMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
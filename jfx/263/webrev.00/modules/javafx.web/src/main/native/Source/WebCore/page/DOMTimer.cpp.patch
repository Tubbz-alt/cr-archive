diff a/modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp
@@ -159,51 +159,47 @@
 };
 
 bool NestedTimersMap::isTrackingNestedTimers = false;
 
 DOMTimer::DOMTimer(ScriptExecutionContext& context, std::unique_ptr<ScheduledAction> action, Seconds interval, bool singleShot)
-    : SuspendableTimer(context)
+    : SuspendableTimerBase(&context)
     , m_nestingLevel(context.timerNestingLevel())
     , m_action(WTFMove(action))
     , m_originalInterval(interval)
     , m_throttleState(Undetermined)
     , m_currentTimerInterval(intervalClampedToMinimum())
     , m_userGestureTokenToForward(UserGestureIndicator::currentUserGesture())
 {
-    RefPtr<DOMTimer> reference = adoptRef(this);
-
-    // Keep asking for the next id until we're given one that we don't already have.
-    do {
-        m_timeoutId = context.circularSequentialID();
-    } while (!context.addTimeout(m_timeoutId, *this));
-
     if (singleShot)
         startOneShot(m_currentTimerInterval);
     else
         startRepeating(m_currentTimerInterval);
 }
 
 DOMTimer::~DOMTimer() = default;
 
 int DOMTimer::install(ScriptExecutionContext& context, std::unique_ptr<ScheduledAction> action, Seconds timeout, bool singleShot)
 {
-    // DOMTimer constructor passes ownership of the initial ref on the object to the constructor.
-    // This reference will be released automatically when a one-shot timer fires, when the context
-    // is destroyed, or if explicitly cancelled by removeById.
-    DOMTimer* timer = new DOMTimer(context, WTFMove(action), timeout, singleShot);
+    Ref<DOMTimer> timer = adoptRef(*new DOMTimer(context, WTFMove(action), timeout, singleShot));
     timer->suspendIfNeeded();
+
+    // Keep asking for the next id until we're given one that we don't already have.
+    do {
+        timer->m_timeoutId = context.circularSequentialID();
+    } while (!context.addTimeout(timer->m_timeoutId, timer.get()));
+
     InspectorInstrumentation::didInstallTimer(context, timer->m_timeoutId, timeout, singleShot);
 
     // Keep track of nested timer installs.
     if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
-        nestedTimers->add(timer->m_timeoutId, *timer);
+        nestedTimers->add(timer->m_timeoutId, timer.get());
 #if PLATFORM(IOS_FAMILY)
     if (is<Document>(context)) {
         auto& document = downcast<Document>(context);
-        document.contentChangeObserver().didInstallDOMTimer(*timer, timeout, singleShot);
+        document.contentChangeObserver().didInstallDOMTimer(timer.get(), timeout, singleShot);
         if (DeferDOMTimersForScope::isDeferring())
-            document.domTimerHoldingTank().add(*timer);
+            document.domTimerHoldingTank().add(timer.get());
     }
 #endif
     return timer->m_timeoutId;
 }
 
@@ -285,11 +281,11 @@
 void DOMTimer::fired()
 {
     // Retain this - if the timer is cancelled while this function is on the stack (implicitly and always
     // for one-shot timers, or if removeById is called on itself from within an interval timer fire) then
     // wait unit the end of this function to delete DOMTimer.
-    RefPtr<DOMTimer> reference = this;
+    Ref<DOMTimer> protectedThis(*this);
 
     ASSERT(scriptExecutionContext());
     ScriptExecutionContext& context = *scriptExecutionContext();
 
 #if PLATFORM(IOS_FAMILY)
@@ -312,24 +308,24 @@
     ASSERT(!context.activeDOMObjectsAreSuspended());
     UserGestureIndicator gestureIndicator(m_userGestureTokenToForward);
     // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
     m_userGestureTokenToForward = nullptr;
 
-    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());
+    InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());
 
     // Simple case for non-one-shot timers.
     if (isActive()) {
         if (m_nestingLevel < maxTimerNestingLevel) {
             m_nestingLevel++;
             updateTimerIntervalIfNecessary();
         }
 
         m_action->execute(context);
 
-        InspectorInstrumentation::didFireTimer(cookie);
-        updateThrottlingStateIfNecessary(fireState);
+        InspectorInstrumentation::didFireTimer(context);
 
+        updateThrottlingStateIfNecessary(fireState);
         return;
     }
 
     context.removeTimeout(m_timeoutId);
 
@@ -341,11 +337,11 @@
 #if PLATFORM(IOS_FAMILY)
     ContentChangeObserver::DOMTimerScope observingScope(is<Document>(context) ? &downcast<Document>(context) : nullptr, *this);
 #endif
     m_action->execute(context);
 
-    InspectorInstrumentation::didFireTimer(cookie);
+    InspectorInstrumentation::didFireTimer(context);
 
     // Check if we should throttle nested single-shot timers.
     if (nestedTimers) {
         for (auto& idAndTimer : *nestedTimers) {
             auto& timer = idAndTimer.value;

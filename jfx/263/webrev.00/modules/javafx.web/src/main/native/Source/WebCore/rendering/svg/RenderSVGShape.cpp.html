<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2008 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2005, 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  * Copyright (C) 2009 Google, Inc.
  6  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  7  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  8  * Copyright (C) 2009 Jeff Schiller &lt;codedread@gmail.com&gt;
  9  * Copyright (C) 2011 Renata Hodovan &lt;reni@webkit.org&gt;
 10  * Copyright (C) 2011 University of Szeged
 11  * Copyright (C) 2018 Adobe Systems Incorporated. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;RenderSVGShape.h&quot;
 31 
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;FloatQuad.h&quot;
 34 #include &quot;GraphicsContext.h&quot;
 35 #include &quot;HitTestRequest.h&quot;
 36 #include &quot;HitTestResult.h&quot;
 37 #include &quot;LayoutRepainter.h&quot;
 38 #include &quot;PointerEventsHitRules.h&quot;
 39 #include &quot;RenderSVGResourceMarker.h&quot;
 40 #include &quot;RenderSVGResourceSolidColor.h&quot;
 41 #include &quot;SVGPathData.h&quot;
 42 #include &quot;SVGRenderingContext.h&quot;
 43 #include &quot;SVGResources.h&quot;
 44 #include &quot;SVGResourcesCache.h&quot;
 45 #include &quot;SVGURIReference.h&quot;
 46 #include &quot;StrokeStyleApplier.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;
 48 #include &lt;wtf/StackStats.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGShape);
 53 
 54 class BoundingRectStrokeStyleApplier final : public StrokeStyleApplier {
 55 public:
 56     BoundingRectStrokeStyleApplier(const RenderSVGShape&amp; renderer)
 57         : m_renderer(renderer)
 58     {
 59     }
 60 
 61     void strokeStyle(GraphicsContext* context) override
 62     {
 63         SVGRenderSupport::applyStrokeStyleToContext(context, m_renderer.style(), m_renderer);
 64     }
 65 
 66 private:
 67     const RenderSVGShape&amp; m_renderer;
 68 };
 69 
 70 RenderSVGShape::RenderSVGShape(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 71     : RenderSVGModelObject(element, WTFMove(style))
 72     , m_needsBoundariesUpdate(false) // Default is false, the cached rects are empty from the beginning.
 73     , m_needsShapeUpdate(true) // Default is true, so we grab a Path object once from SVGGraphicsElement.
 74     , m_needsTransformUpdate(true) // Default is true, so we grab a AffineTransform object once from SVGGraphicsElement.
 75 {
 76 }
 77 
 78 RenderSVGShape::~RenderSVGShape() = default;
 79 
 80 void RenderSVGShape::updateShapeFromElement()
 81 {
 82     m_path = createPath();
 83     processMarkerPositions();
 84 
 85     m_fillBoundingBox = calculateObjectBoundingBox();
 86     m_strokeBoundingBox = calculateStrokeBoundingBox();
 87 }
 88 
 89 bool RenderSVGShape::isEmpty() const
 90 {
 91     // This function should never be called before assigning a new Path to m_path.
 92     // But this bug can happen if this renderer was created and its layout was not
 93     // done before painting. Assert this did not happen but do not crash.
 94     ASSERT(hasPath());
 95     return !hasPath() || path().isEmpty();
 96 }
 97 
 98 void RenderSVGShape::fillShape(GraphicsContext&amp; context) const
 99 {
100     context.fillPath(path());
101 }
102 
103 void RenderSVGShape::strokeShape(GraphicsContext&amp; context) const
104 {
105     ASSERT(m_path);
106     Path* usePath = m_path.get();
107 
108     if (hasNonScalingStroke())
109         usePath = nonScalingStrokePath(usePath, nonScalingStrokeTransform());
110 
111     context.strokePath(*usePath);
112 }
113 
114 bool RenderSVGShape::shapeDependentStrokeContains(const FloatPoint&amp; point, PointCoordinateSpace pointCoordinateSpace)
115 {
116     ASSERT(m_path);
117     BoundingRectStrokeStyleApplier applier(*this);
118 
119     if (hasNonScalingStroke() &amp;&amp; pointCoordinateSpace != LocalCoordinateSpace) {
120         AffineTransform nonScalingTransform = nonScalingStrokeTransform();
121         Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
122 
123         return usePath-&gt;strokeContains(applier, nonScalingTransform.mapPoint(point));
124     }
125 
126     return m_path-&gt;strokeContains(applier, point);
127 }
128 
129 bool RenderSVGShape::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
130 {
131     return path().contains(point, fillRule);
132 }
133 
134 bool RenderSVGShape::fillContains(const FloatPoint&amp; point, bool requiresFill, const WindRule fillRule)
135 {
136     if (m_fillBoundingBox.isEmpty() || !m_fillBoundingBox.contains(point))
137         return false;
138 
139     Color fallbackColor;
140     if (requiresFill &amp;&amp; !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
141         return false;
142 
143     return shapeDependentFillContains(point, fillRule);
144 }
145 
146 bool RenderSVGShape::strokeContains(const FloatPoint&amp; point, bool requiresStroke)
147 {
148     if (strokeBoundingBox().isEmpty() || !strokeBoundingBox().contains(point))
149         return false;
150 
151     Color fallbackColor;
152     if (requiresStroke &amp;&amp; !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
153         return false;
154 
155     return shapeDependentStrokeContains(point);
156 }
157 
158 void RenderSVGShape::layout()
159 {
160     StackStats::LayoutCheckPoint layoutCheckPoint;
161     LayoutRepainter repainter(*this, SVGRenderSupport::checkForSVGRepaintDuringLayout(*this) &amp;&amp; selfNeedsLayout());
162 
163     bool updateCachedBoundariesInParents = false;
164 
165     if (m_needsShapeUpdate || m_needsBoundariesUpdate) {
166         updateShapeFromElement();
167         m_needsShapeUpdate = false;
168         updateRepaintBoundingBox();
169         m_needsBoundariesUpdate = false;
170         updateCachedBoundariesInParents = true;
171     }
172 
173     if (m_needsTransformUpdate) {
174         m_localTransform = graphicsElement().animatedLocalTransform();
175         m_needsTransformUpdate = false;
176         updateCachedBoundariesInParents = true;
177     }
178 
179     // Invalidate all resources of this client if our layout changed.
180     if (everHadLayout() &amp;&amp; selfNeedsLayout())
181         SVGResourcesCache::clientLayoutChanged(*this);
182 
183     // If our bounds changed, notify the parents.
184     if (updateCachedBoundariesInParents)
185         RenderSVGModelObject::setNeedsBoundariesUpdate();
186 
187     repainter.repaintAfterLayout();
188     clearNeedsLayout();
189 }
190 
191 Path* RenderSVGShape::nonScalingStrokePath(const Path* path, const AffineTransform&amp; strokeTransform) const
192 {
193     static NeverDestroyed&lt;Path&gt; tempPath;
194 
195     tempPath.get() = *path;
196     tempPath.get().transform(strokeTransform);
197 
198     return &amp;tempPath.get();
199 }
200 
201 bool RenderSVGShape::setupNonScalingStrokeContext(AffineTransform&amp; strokeTransform, GraphicsContextStateSaver&amp; stateSaver)
202 {
203     Optional&lt;AffineTransform&gt; inverse = strokeTransform.inverse();
204     if (!inverse)
205         return false;
206 
207     stateSaver.save();
208     stateSaver.context()-&gt;concatCTM(inverse.value());
209     return true;
210 }
211 
212 AffineTransform RenderSVGShape::nonScalingStrokeTransform() const
213 {
214     return graphicsElement().getScreenCTM(SVGLocatable::DisallowStyleUpdate);
215 }
216 
217 bool RenderSVGShape::shouldGenerateMarkerPositions() const
218 {
219     if (!style().svgStyle().hasMarkers())
220         return false;
221 
222     if (!graphicsElement().supportsMarkers())
223         return false;
224 
225     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
226     if (!resources)
227         return false;
228 
229     return resources-&gt;markerStart() || resources-&gt;markerMid() || resources-&gt;markerEnd();
230 }
231 
232 void RenderSVGShape::fillShape(const RenderStyle&amp; style, GraphicsContext&amp; originalContext)
233 {
234     GraphicsContext* context = &amp;originalContext;
235     Color fallbackColor;
236     if (RenderSVGResource* fillPaintingResource = RenderSVGResource::fillPaintingResource(*this, style, fallbackColor)) {
237         if (fillPaintingResource-&gt;applyResource(*this, style, context, RenderSVGResourceMode::ApplyToFill))
238             fillPaintingResource-&gt;postApplyResource(*this, context, RenderSVGResourceMode::ApplyToFill, nullptr, this);
239         else if (fallbackColor.isValid()) {
240             RenderSVGResourceSolidColor* fallbackResource = RenderSVGResource::sharedSolidPaintingResource();
241             fallbackResource-&gt;setColor(fallbackColor);
242             if (fallbackResource-&gt;applyResource(*this, style, context, RenderSVGResourceMode::ApplyToFill))
243                 fallbackResource-&gt;postApplyResource(*this, context, RenderSVGResourceMode::ApplyToFill, nullptr, this);
244         }
245     }
246 }
247 
248 void RenderSVGShape::strokeShape(const RenderStyle&amp; style, GraphicsContext&amp; originalContext)
249 {
250     GraphicsContext* context = &amp;originalContext;
251     Color fallbackColor;
252     if (RenderSVGResource* strokePaintingResource = RenderSVGResource::strokePaintingResource(*this, style, fallbackColor)) {
253         if (strokePaintingResource-&gt;applyResource(*this, style, context, RenderSVGResourceMode::ApplyToStroke))
254             strokePaintingResource-&gt;postApplyResource(*this, context, RenderSVGResourceMode::ApplyToStroke, nullptr, this);
255         else if (fallbackColor.isValid()) {
256             RenderSVGResourceSolidColor* fallbackResource = RenderSVGResource::sharedSolidPaintingResource();
257             fallbackResource-&gt;setColor(fallbackColor);
258             if (fallbackResource-&gt;applyResource(*this, style, context, RenderSVGResourceMode::ApplyToStroke))
259                 fallbackResource-&gt;postApplyResource(*this, context, RenderSVGResourceMode::ApplyToStroke, nullptr, this);
260         }
261     }
262 }
263 
264 void RenderSVGShape::strokeShape(GraphicsContext&amp; context)
265 {
266     if (!style().hasVisibleStroke())
267         return;
268 
269     GraphicsContextStateSaver stateSaver(context, false);
270     if (hasNonScalingStroke()) {
271         AffineTransform nonScalingTransform = nonScalingStrokeTransform();
272         if (!setupNonScalingStrokeContext(nonScalingTransform, stateSaver))
273             return;
274     }
275     strokeShape(style(), context);
276 }
277 
278 void RenderSVGShape::fillStrokeMarkers(PaintInfo&amp; childPaintInfo)
279 {
280     auto paintOrder = RenderStyle::paintTypesForPaintOrder(style().paintOrder());
281     for (unsigned i = 0; i &lt; paintOrder.size(); ++i) {
282         switch (paintOrder.at(i)) {
283         case PaintType::Fill:
284             fillShape(style(), childPaintInfo.context());
285             break;
286         case PaintType::Stroke:
287             strokeShape(childPaintInfo.context());
288             break;
289         case PaintType::Markers:
290             if (!m_markerPositions.isEmpty())
291                 drawMarkers(childPaintInfo);
292             break;
293         }
294     }
295 }
296 
297 void RenderSVGShape::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp;)
298 {
299     if (paintInfo.context().paintingDisabled() || paintInfo.phase != PaintPhase::Foreground
300         || style().visibility() == Visibility::Hidden || isEmpty())
301         return;
302     FloatRect boundingBox = repaintRectInLocalCoordinates();
303     if (!SVGRenderSupport::paintInfoIntersectsRepaintRect(boundingBox, m_localTransform, paintInfo))
304         return;
305 
306     PaintInfo childPaintInfo(paintInfo);
307     GraphicsContextStateSaver stateSaver(childPaintInfo.context());
308     childPaintInfo.applyTransform(m_localTransform);
309 
310     if (childPaintInfo.phase == PaintPhase::Foreground) {
311         SVGRenderingContext renderingContext(*this, childPaintInfo);
312 
313         if (renderingContext.isRenderingPrepared()) {
314             const SVGRenderStyle&amp; svgStyle = style().svgStyle();
315             if (svgStyle.shapeRendering() == ShapeRendering::CrispEdges)
316                 childPaintInfo.context().setShouldAntialias(false);
317 
318             fillStrokeMarkers(childPaintInfo);
319         }
320     }
321 
322     if (style().outlineWidth())
323         paintOutline(childPaintInfo, IntRect(boundingBox));
324 }
325 
326 // This method is called from inside paintOutline() since we call paintOutline()
327 // while transformed to our coord system, return local coords
328 void RenderSVGShape::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp;, const RenderLayerModelObject*)
329 {
330     LayoutRect rect = LayoutRect(repaintRectInLocalCoordinates());
331     if (!rect.isEmpty())
332         rects.append(rect);
333 }
334 
335 bool RenderSVGShape::isPointInFill(const FloatPoint&amp; point)
336 {
337     return shapeDependentFillContains(point, style().svgStyle().fillRule());
338 }
339 
340 bool RenderSVGShape::isPointInStroke(const FloatPoint&amp; point)
341 {
342     if (!style().svgStyle().hasStroke())
343         return false;
344 
345     return shapeDependentStrokeContains(point, LocalCoordinateSpace);
346 }
347 
348 float RenderSVGShape::getTotalLength() const
349 {
350     return hasPath() ? path().length() : createPath()-&gt;length();
351 }
352 
353 FloatPoint RenderSVGShape::getPointAtLength(float distance) const
354 {
355     return hasPath() ? path().pointAtLength(distance) : createPath()-&gt;pointAtLength(distance);
356 }
357 
358 bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
359 {
360     // We only draw in the forground phase, so we only hit-test then.
361     if (hitTestAction != HitTestForeground)
362         return false;
363 
364     FloatPoint localPoint = m_localTransform.inverse().valueOr(AffineTransform()).mapPoint(pointInParent);
365 
366     if (!SVGRenderSupport::pointInClippingArea(*this, localPoint))
367         return false;
368 
369     PointerEventsHitRules hitRules(PointerEventsHitRules::SVG_PATH_HITTESTING, request, style().pointerEvents());
370     bool isVisible = (style().visibility() == Visibility::Visible);
371     if (isVisible || !hitRules.requireVisible) {
372         const SVGRenderStyle&amp; svgStyle = style().svgStyle();
373         WindRule fillRule = svgStyle.fillRule();
374         if (request.svgClipContent())
375             fillRule = svgStyle.clipRule();
376         if ((hitRules.canHitStroke &amp;&amp; (svgStyle.hasStroke() || !hitRules.requireStroke) &amp;&amp; strokeContains(localPoint, hitRules.requireStroke))
377             || (hitRules.canHitFill &amp;&amp; (svgStyle.hasFill() || !hitRules.requireFill) &amp;&amp; fillContains(localPoint, hitRules.requireFill, fillRule))
378             || (hitRules.canHitBoundingBox &amp;&amp; objectBoundingBox().contains(localPoint))) {
379             updateHitTestResult(result, LayoutPoint(localPoint));
380             if (result.addNodeToListBasedTestResult(&amp;graphicsElement(), request, localPoint) == HitTestProgress::Stop)
381                 return true;
382         }
383     }
384     return false;
385 }
386 
387 static inline RenderSVGResourceMarker* markerForType(SVGMarkerType type, RenderSVGResourceMarker* markerStart, RenderSVGResourceMarker* markerMid, RenderSVGResourceMarker* markerEnd)
388 {
389     switch (type) {
390     case StartMarker:
391         return markerStart;
392     case MidMarker:
393         return markerMid;
394     case EndMarker:
395         return markerEnd;
396     }
397 
398     ASSERT_NOT_REACHED();
399     return 0;
400 }
401 
402 FloatRect RenderSVGShape::markerRect(float strokeWidth) const
403 {
404     ASSERT(!m_markerPositions.isEmpty());
405 
406     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
407     ASSERT(resources);
408 
409     RenderSVGResourceMarker* markerStart = resources-&gt;markerStart();
410     RenderSVGResourceMarker* markerMid = resources-&gt;markerMid();
411     RenderSVGResourceMarker* markerEnd = resources-&gt;markerEnd();
412     ASSERT(markerStart || markerMid || markerEnd);
413 
414     FloatRect boundaries;
415     unsigned size = m_markerPositions.size();
416     for (unsigned i = 0; i &lt; size; ++i) {
417         if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
418             boundaries.unite(marker-&gt;markerBoundaries(marker-&gt;markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth)));
419     }
420     return boundaries;
421 }
422 
423 FloatRect RenderSVGShape::calculateObjectBoundingBox() const
424 {
425     return path().boundingRect();
426 }
427 
428 FloatRect RenderSVGShape::calculateStrokeBoundingBox() const
429 {
430     ASSERT(m_path);
431     FloatRect strokeBoundingBox = m_fillBoundingBox;
432 
433     const SVGRenderStyle&amp; svgStyle = style().svgStyle();
434     if (svgStyle.hasStroke()) {
435         BoundingRectStrokeStyleApplier strokeStyle(*this);
436         if (hasNonScalingStroke()) {
437             AffineTransform nonScalingTransform = nonScalingStrokeTransform();
438             if (Optional&lt;AffineTransform&gt; inverse = nonScalingTransform.inverse()) {
439                 Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
440                 FloatRect strokeBoundingRect = usePath-&gt;strokeBoundingRect(&amp;strokeStyle);
441                 strokeBoundingRect = inverse.value().mapRect(strokeBoundingRect);
442                 strokeBoundingBox.unite(strokeBoundingRect);
443             }
444         } else
445             strokeBoundingBox.unite(path().strokeBoundingRect(&amp;strokeStyle));
446     }
447 
448     if (!m_markerPositions.isEmpty())
449         strokeBoundingBox.unite(markerRect(strokeWidth()));
450 
451     return strokeBoundingBox;
452 }
453 
454 void RenderSVGShape::updateRepaintBoundingBox()
455 {
456     m_repaintBoundingBoxExcludingShadow = strokeBoundingBox();
457     SVGRenderSupport::intersectRepaintRectWithResources(*this, m_repaintBoundingBoxExcludingShadow);
458 
459     m_repaintBoundingBox = m_repaintBoundingBoxExcludingShadow;
460 }
461 
462 float RenderSVGShape::strokeWidth() const
463 {
464     SVGLengthContext lengthContext(&amp;graphicsElement());
465     return lengthContext.valueForLength(style().strokeWidth());
466 }
467 
468 bool RenderSVGShape::hasSmoothStroke() const
469 {
470     const SVGRenderStyle&amp; svgStyle = style().svgStyle();
471     return svgStyle.strokeDashArray().isEmpty()
472         &amp;&amp; style().strokeMiterLimit() == style().initialStrokeMiterLimit()
473         &amp;&amp; style().joinStyle() == style().initialJoinStyle()
474         &amp;&amp; style().capStyle() == style().initialCapStyle();
475 }
476 
477 void RenderSVGShape::drawMarkers(PaintInfo&amp; paintInfo)
478 {
479     ASSERT(!m_markerPositions.isEmpty());
480 
481     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
482     if (!resources)
483         return;
484 
485     RenderSVGResourceMarker* markerStart = resources-&gt;markerStart();
486     RenderSVGResourceMarker* markerMid = resources-&gt;markerMid();
487     RenderSVGResourceMarker* markerEnd = resources-&gt;markerEnd();
488     if (!markerStart &amp;&amp; !markerMid &amp;&amp; !markerEnd)
489         return;
490 
491     float strokeWidth = this-&gt;strokeWidth();
492     unsigned size = m_markerPositions.size();
493     for (unsigned i = 0; i &lt; size; ++i) {
494         if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
495             marker-&gt;draw(paintInfo, marker-&gt;markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth));
496     }
497 }
498 
499 std::unique_ptr&lt;Path&gt; RenderSVGShape::createPath() const
500 {
501     return makeUnique&lt;Path&gt;(pathFromGraphicsElement(&amp;graphicsElement()));
502 }
503 
504 void RenderSVGShape::processMarkerPositions()
505 {
506     m_markerPositions.clear();
507 
508     if (!shouldGenerateMarkerPositions())
509         return;
510 
511     ASSERT(m_path);
512 
513     SVGMarkerData markerData(m_markerPositions, SVGResourcesCache::cachedResourcesForRenderer(*this)-&gt;markerReverseStart());
514     m_path-&gt;apply([&amp;markerData](const PathElement&amp; pathElement) {
515         SVGMarkerData::updateFromPathElement(markerData, pathElement);
516     });
517     markerData.pathIsDone();
518 }
519 
520 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaKeyMessageEvent.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaKeySession.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/encryptedmedia/MediaKeySession.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,11 +31,13 @@</span>
  
  #if ENABLE(ENCRYPTED_MEDIA)
  
  #include &quot;CDM.h&quot;
  #include &quot;CDMInstance.h&quot;
<span class="udiff-line-added">+ #include &quot;DOMPromiseProxy.h&quot;</span>
  #include &quot;Document.h&quot;
<span class="udiff-line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;EventNames.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MediaKeyMessageEvent.h&quot;
  #include &quot;MediaKeyMessageType.h&quot;
  #include &quot;MediaKeyStatusMap.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,16 +63,16 @@</span>
  
  MediaKeySession::MediaKeySession(ScriptExecutionContext&amp; context, WeakPtr&lt;MediaKeys&gt;&amp;&amp; keys, MediaKeySessionType sessionType, bool useDistinctiveIdentifier, Ref&lt;CDM&gt;&amp;&amp; implementation, Ref&lt;CDMInstanceSession&gt;&amp;&amp; instanceSession)
      : ActiveDOMObject(&amp;context)
      , m_keys(WTFMove(keys))
      , m_expiration(std::numeric_limits&lt;double&gt;::quiet_NaN())
<span class="udiff-line-added">+     , m_closedPromise(makeUniqueRef&lt;ClosedPromise&gt;())</span>
      , m_keyStatuses(MediaKeyStatusMap::create(*this))
      , m_useDistinctiveIdentifier(useDistinctiveIdentifier)
      , m_sessionType(sessionType)
      , m_implementation(WTFMove(implementation))
      , m_instanceSession(WTFMove(instanceSession))
<span class="udiff-line-removed">-     , m_eventQueue(*this)</span>
  {
      // https://w3c.github.io/encrypted-media/#dom-mediakeys-createsession
      // W3C Editor&#39;s Draft 09 November 2016
      // createSession(), ctd.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,11 +155,11 @@</span>
  
      // 7. Let init data be a copy of the contents of the initData parameter.
      // 8. Let session type be this object&#39;s session type.
      // 9. Let promise be a new promise.
      // 10. Run the following steps in parallel:
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask([this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, initData = SharedBuffer::create(initData.data(), initData.length()), initDataType, promise = WTFMove(promise)] () mutable {</span>
          // 10.1. If the init data is not valid for initDataType, reject promise with a newly created TypeError.
          // 10.2. Let sanitized init data be a validated and sanitized version of init data.
          RefPtr&lt;SharedBuffer&gt; sanitizedInitData = m_implementation-&gt;sanitizeInitData(initDataType, initData);
  
          // 10.3. If the preceding step failed, reject promise with a newly created TypeError.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,11 +224,11 @@</span>
                  // 10.9.5.2. Let message type reflect the type of message, either &quot;license-request&quot; or &quot;individualization-request&quot;.
                  messageType = MediaKeyMessageType::IndividualizationRequest;
              }
  
              // 10.10. Queue a task to run the following steps:
<span class="udiff-line-modified-removed">-             m_taskQueue.enqueueTask([this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {</span>
<span class="udiff-line-modified-added">+             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise), message = WTFMove(message), messageType, sessionId, succeeded] () mutable {</span>
                  // 10.10.1. If any of the preceding steps failed, reject promise with a new DOMException whose name is the appropriate error name.
                  if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
                      promise-&gt;reject(NotSupportedError);
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -273,11 +275,11 @@</span>
      // 6. Let origin be the origin of this object&#39;s Document.
      // This is retrieved in the following task.
  
      // 7. Let promise be a new promise.
      // 8. Run the following steps in parallel:
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask([this, sessionId, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionId, promise = WTFMove(promise)] () mutable {</span>
          // 8.1. Let sanitized session ID be a validated and/or sanitized version of sessionId.
          // 8.2. If the preceding step failed, or if sanitized session ID is empty, reject promise with a newly created TypeError.
          Optional&lt;String&gt; sanitizedSessionId = m_implementation-&gt;sanitizeSessionId(sessionId);
          if (!sanitizedSessionId || sanitizedSessionId-&gt;isEmpty()) {
              promise-&gt;reject(TypeError);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -325,11 +327,11 @@</span>
                      break;
                  }
              }
  
              // 8.9. Queue a task to run the following steps:
<span class="udiff-line-modified-removed">-             m_taskQueue.enqueueTask([this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, knownKeys = WTFMove(knownKeys), expiration = WTFMove(expiration), message = WTFMove(message), sanitizedSessionId, succeeded, promise = WTFMove(promise)] () mutable {</span>
                  // 8.9.1. If any of the preceding steps failed, reject promise with a the appropriate error name.
                  if (succeeded == CDMInstanceSession::SuccessValue::Failed) {
                      promise-&gt;reject(NotSupportedError);
                      return;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -382,11 +384,11 @@</span>
      }
  
      // 4. Let response copy be a copy of the contents of the response parameter.
      // 5. Let promise be a new promise.
      // 6. Run the following steps in parallel:
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask([this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, response = SharedBuffer::create(response.data(), response.length()), promise = WTFMove(promise)] () mutable {</span>
          // 6.1. Let sanitized response be a validated and/or sanitized version of response copy.
          RefPtr&lt;SharedBuffer&gt; sanitizedResponse = m_implementation-&gt;sanitizeResponse(response);
  
          // 6.2. If the preceding step failed, or if sanitized response is empty, reject promise with a newly created TypeError.
          if (!sanitizedResponse || sanitizedResponse-&gt;isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -433,11 +435,11 @@</span>
  
              // 6.7.3. If a message needs to be sent to the server, execute the following steps:
              //   6.7.3.1. Let message be that message.
              //   6.7.3.2. Let message type be the appropriate MediaKeyMessageType for the message.
              // 6.8. Queue a task to run the following steps:
<span class="udiff-line-modified-removed">-             m_taskQueue.enqueueTask([this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, sessionWasClosed, changedKeys = WTFMove(changedKeys), changedExpiration = WTFMove(changedExpiration), message = WTFMove(message), promise = WTFMove(promise)] () mutable {</span>
                  LOG(EME, &quot;EME - updating CDM license succeeded for session %s, sending a message to the license server&quot;, m_sessionId.utf8().data());
                  // 6.8.1.
                  if (sessionWasClosed) {
                      // â†³ If session closed is true:
                      //   Run the Session Closed algorithm on this object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,20 +512,20 @@</span>
          return;
      }
  
      // 4. Let promise be a new promise.
      // 5. Run the following steps in parallel:
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {</span>
          // 5.1. Let cdm be the CDM instance represented by session&#39;s cdm instance value.
          // 5.2. Use cdm to close the key session associated with session.
          LOG(EME, &quot;EME - closing CDM session %s&quot;, m_sessionId.utf8().data());
          m_instanceSession-&gt;closeSession(m_sessionId, [this, weakThis = makeWeakPtr(*this), promise = WTFMove(promise)] () mutable {
              if (!weakThis)
                  return;
  
              // 5.3. Queue a task to run the following steps:
<span class="udiff-line-modified-removed">-             m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {</span>
                  // 5.3.1. Run the Session Closed algorithm on the session.
                  sessionClosed();
  
                  // 5.3.2. Resolve promise.
                  promise-&gt;resolve();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -548,11 +550,11 @@</span>
          return;
      }
  
      // 3. Let promise be a new promise.
      // 4. Run the following steps in parallel:
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask([this, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, promise = WTFMove(promise)] () mutable {</span>
          // 4.1. Let cdm be the CDM instance represented by this object&#39;s cdm instance value.
          // 4.2. Let message be null.
          // 4.3. Let message type be null.
  
          // 4.4. Use the cdm to execute the following steps:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -573,11 +575,11 @@</span>
              //       4.4.1.2.3.1. Store this object&#39;s record of key usage.
              //       4.4.1.2.3.2. Let message be a message containing or reflecting this object&#39;s record of key usage.
              // NOTE: Step 4.4.1. should be implemented in CDMInstance.
  
              // 4.5. Queue a task to run the following steps:
<span class="udiff-line-modified-removed">-             m_taskQueue.enqueueTask([this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {</span>
<span class="udiff-line-modified-added">+             queueTaskKeepingObjectAlive(*this, TaskSource::Networking, [this, keys = WTFMove(keys), message = WTFMove(message), succeeded, promise = WTFMove(promise)] () mutable {</span>
                  // 4.5.1. Run the Update Key Statuses algorithm on the session, providing all key ID(s) in the session along with the &quot;released&quot; MediaKeyStatus value for each.
                  updateKeyStatuses(WTFMove(keys));
  
                  // 4.5.2. Run the Update Expiration algorithm on the session, providing NaN.
                  updateExpiration(std::numeric_limits&lt;double&gt;::quiet_NaN());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -612,11 +614,11 @@</span>
      // 1. Let the session be the specified MediaKeySession object.
      // 2. Queue a task to create an event named message that does not bubble and is not cancellable using the MediaKeyMessageEvent
      //    interface with its type attribute set to message and its isTrusted attribute initialized to true, and dispatch it at the
      //    session.
      auto messageEvent = MediaKeyMessageEvent::create(eventNames().messageEvent, {messageType, message.tryCreateArrayBuffer()}, Event::IsTrusted::Yes);
<span class="udiff-line-modified-removed">-     m_eventQueue.enqueueEvent(WTFMove(messageEvent));</span>
<span class="udiff-line-modified-added">+     queueTaskToDispatchEvent(*this, TaskSource::Networking, WTFMove(messageEvent));</span>
  }
  
  void MediaKeySession::updateKeyStatuses(CDMInstanceSession::KeyStatusVector&amp;&amp; inputStatuses)
  {
      // https://w3c.github.io/encrypted-media/#update-key-statuses
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -657,14 +659,14 @@</span>
      m_statuses.reserveCapacity(inputStatuses.size());
      for (auto&amp; status : inputStatuses)
          m_statuses.uncheckedAppend({ WTFMove(status.first), toMediaKeyStatus(status.second) });
  
      // 5. Queue a task to fire a simple event named keystatuseschange at the session.
<span class="udiff-line-modified-removed">-     m_eventQueue.enqueueEvent(Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="udiff-line-modified-added">+     queueTaskToDispatchEvent(*this, TaskSource::Networking, Event::create(eventNames().keystatuseschangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  
      // 6. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on each of the media element(s) whose mediaKeys attribute is the MediaKeys object that created the session.
<span class="udiff-line-modified-removed">-     m_taskQueue.enqueueTask(</span>
<span class="udiff-line-modified-added">+     queueTaskKeepingObjectAlive(*this, TaskSource::Networking,</span>
          [this] () mutable {
              if (m_keys)
                  m_keys-&gt;attemptToResumePlaybackOnClients();
          });
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -707,11 +709,11 @@</span>
      // Let&#39;s consider the session closed before any promise on the &#39;closed&#39; attribute is resolved.
      m_closed = true;
  
      // 5. Let promise be the closed attribute of the session.
      // 6. Resolve promise.
<span class="udiff-line-modified-removed">-     m_closedPromise.resolve();</span>
<span class="udiff-line-modified-added">+     m_closedPromise-&gt;resolve();</span>
  }
  
  String MediaKeySession::mediaKeysStorageDirectory() const
  {
      auto* document = downcast&lt;Document&gt;(scriptExecutionContext());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -729,29 +731,17 @@</span>
      return FileSystem::pathByAppendingComponent(storageDirectory, document-&gt;securityOrigin().data().databaseIdentifier());
  }
  
  bool MediaKeySession::hasPendingActivity() const
  {
<span class="udiff-line-modified-removed">-     notImplemented();</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     // A MediaKeySession object SHALL NOT be destroyed and SHALL continue to receive events if it is not closed and the MediaKeys object that created it remains accessible.</span>
<span class="udiff-line-modified-added">+     return (!m_closed &amp;&amp; m_keys) || ActiveDOMObject::hasPendingActivity();</span>
  }
  
  const char* MediaKeySession::activeDOMObjectName() const
  {
<span class="udiff-line-removed">-     notImplemented();</span>
      return &quot;MediaKeySession&quot;;
  }
  
<span class="udiff-line-removed">- bool MediaKeySession::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     notImplemented();</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void MediaKeySession::stop()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     notImplemented();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  } // namespace WebCore
  
  #endif
</pre>
<center><a href="MediaKeyMessageEvent.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaKeySession.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGDocumentExtensions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;
  47 #include &quot;SVGPropertyAnimatorFactory.h&quot;
  48 #include &quot;SVGRenderStyle.h&quot;
  49 #include &quot;SVGRenderSupport.h&quot;
  50 #include &quot;SVGSVGElement.h&quot;
  51 #include &quot;SVGTitleElement.h&quot;
  52 #include &quot;SVGUseElement.h&quot;
  53 #include &quot;ShadowRoot.h&quot;

  54 #include &quot;XMLNames.h&quot;
  55 #include &lt;wtf/Assertions.h&gt;
  56 #include &lt;wtf/HashMap.h&gt;
  57 #include &lt;wtf/IsoMallocInlines.h&gt;
  58 #include &lt;wtf/NeverDestroyed.h&gt;
  59 #include &lt;wtf/StdLibExtras.h&gt;
  60 #include &lt;wtf/text/WTFString.h&gt;
  61 
  62 
  63 namespace WebCore {
  64 
  65 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  66 
  67 static NEVER_INLINE HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()
  68 {
  69     using namespace HTMLNames;
  70     using namespace SVGNames;
  71 
  72     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  73     static const QualifiedName* const attributeNames[] = {
</pre>
<hr />
<pre>
 143         &amp;xAttr.get(),
 144         &amp;yAttr.get(),
 145     };
 146 
 147     HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; map;
 148 
 149     for (auto&amp; name : attributeNames) {
 150         const AtomString&amp; localName = name-&gt;localName();
 151         map.add(localName.impl(), cssPropertyID(localName));
 152     }
 153 
 154     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 155     // and we can add transform_originAttr to the table above instead.
 156     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 157 
 158     return map;
 159 }
 160 
 161 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 162     : StyledElement(tagName, document, CreateSVGElement)
<span class="line-removed"> 163     , SVGLangSpace(this)</span>
 164     , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())
 165 {
 166     static std::once_flag onceFlag;
 167     std::call_once(onceFlag, [] {
 168         PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
 169     });
 170 }
 171 
 172 SVGElement::~SVGElement()
 173 {
 174     if (m_svgRareData) {
 175         for (SVGElement* instance : m_svgRareData-&gt;instances())
 176             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 177         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 178             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 179 
 180         m_svgRareData = nullptr;
 181     }
 182     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 183     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
</pre>
<hr />
<pre>
 337 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 338 {
 339     if (name == HTMLNames::classAttr) {
 340         m_className-&gt;setBaseValInternal(value);
 341         return;
 342     }
 343 
 344     if (name == HTMLNames::tabindexAttr) {
 345         if (value.isEmpty())
 346             clearTabIndexExplicitlyIfNeeded();
 347         else if (auto optionalTabIndex = parseHTMLInteger(value))
 348             setTabIndexExplicitly(optionalTabIndex.value());
 349         return;
 350     }
 351 
 352     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 353     if (!eventName.isNull()) {
 354         setAttributeEventListener(eventName, name, value);
 355         return;
 356     }
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358     SVGLangSpace::parseAttribute(name, value);</span>
 359 }
 360 
 361 bool SVGElement::haveLoadedRequiredResources()
 362 {
 363     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 364         if (!child.haveLoadedRequiredResources())
 365             return false;
 366     }
 367     return true;
 368 }
 369 
 370 bool SVGElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
 371 {
 372     // Add event listener to regular DOM element
 373     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 374         return false;
 375 
 376     if (containingShadowRoot())
 377         return true;
 378 
</pre>
<hr />
<pre>
 423         ASSERT(instance-&gt;eventTargetData());
 424         instance-&gt;eventTargetData()-&gt;eventListenerMap.removeFirstEventListenerCreatedFromMarkup(eventType);
 425     }
 426 
 427     return true;
 428 }
 429 
 430 static bool hasLoadListener(Element* element)
 431 {
 432     if (element-&gt;hasEventListeners(eventNames().loadEvent))
 433         return true;
 434 
 435     for (element = element-&gt;parentOrShadowHostElement(); element; element = element-&gt;parentOrShadowHostElement()) {
 436         if (element-&gt;hasCapturingEventListeners(eventNames().loadEvent))
 437             return true;
 438     }
 439 
 440     return false;
 441 }
 442 
<span class="line-modified"> 443 void SVGElement::sendSVGLoadEventIfPossible(bool sendParentLoadEvents)</span>
 444 {
 445     if (!isConnected() || !document().frame())
 446         return;
 447 
<span class="line-modified"> 448     RefPtr&lt;SVGElement&gt; currentTarget = this;</span>
<span class="line-modified"> 449     while (currentTarget &amp;&amp; currentTarget-&gt;haveLoadedRequiredResources()) {</span>
<span class="line-removed"> 450         RefPtr&lt;Element&gt; parent;</span>
<span class="line-removed"> 451         if (sendParentLoadEvents)</span>
<span class="line-removed"> 452             parent = currentTarget-&gt;parentOrShadowHostElement(); // save the next parent to dispatch too incase dispatching the event changes the tree</span>
<span class="line-removed"> 453         if (hasLoadListener(currentTarget.get()))</span>
<span class="line-removed"> 454             currentTarget-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-removed"> 455         currentTarget = (parent &amp;&amp; parent-&gt;isSVGElement()) ? static_pointer_cast&lt;SVGElement&gt;(parent) : RefPtr&lt;SVGElement&gt;();</span>
<span class="line-removed"> 456         SVGElement* element = currentTarget.get();</span>
<span class="line-removed"> 457         if (!element || !element-&gt;isOutermostSVGSVGElement())</span>
<span class="line-removed"> 458             continue;</span>
<span class="line-removed"> 459 </span>
<span class="line-removed"> 460         // Consider &lt;svg onload=&quot;foo()&quot;&gt;&lt;image xlink:href=&quot;foo.png&quot; externalResourcesRequired=&quot;true&quot;/&gt;&lt;/svg&gt;.</span>
<span class="line-removed"> 461         // If foo.png is not yet loaded, the first SVGLoad event will go to the &lt;svg&gt; element, sent through</span>
<span class="line-removed"> 462         // Document::implicitClose(). Then the SVGLoad event will fire for &lt;image&gt;, once its loaded.</span>
<span class="line-removed"> 463         ASSERT(sendParentLoadEvents);</span>
<span class="line-removed"> 464 </span>
<span class="line-removed"> 465         // If the load event was not sent yet by Document::implicitClose(), but the &lt;image&gt; from the example</span>
<span class="line-removed"> 466         // above, just appeared, don&#39;t send the SVGLoad event to the outermost &lt;svg&gt;, but wait for the document</span>
<span class="line-removed"> 467         // to be &quot;ready to render&quot;, first.</span>
<span class="line-removed"> 468         if (!document().loadEventFinished())</span>
<span class="line-removed"> 469             break;</span>
<span class="line-removed"> 470     }</span>
<span class="line-removed"> 471 }</span>
 472 
<span class="line-modified"> 473 void SVGElement::sendSVGLoadEventIfPossibleAsynchronously()</span>
<span class="line-removed"> 474 {</span>
<span class="line-removed"> 475     svgLoadEventTimer()-&gt;startOneShot(0_s);</span>
 476 }
 477 
<span class="line-modified"> 478 void SVGElement::svgLoadEventTimerFired()</span>
 479 {
<span class="line-modified"> 480     sendSVGLoadEventIfPossible();</span>
 481 }
 482 
<span class="line-modified"> 483 Timer* SVGElement::svgLoadEventTimer()</span>
 484 {
 485     ASSERT_NOT_REACHED();
 486     return nullptr;
 487 }
 488 
 489 void SVGElement::finishParsingChildren()
 490 {
 491     StyledElement::finishParsingChildren();
 492 
<span class="line-removed"> 493     // The outermost SVGSVGElement SVGLoad event is fired through Document::dispatchWindowLoadEvent.</span>
 494     if (isOutermostSVGSVGElement())
 495         return;
 496 
<span class="line-removed"> 497     // finishParsingChildren() is called when the close tag is reached for an element (e.g. &lt;/svg&gt;)</span>
<span class="line-removed"> 498     // we send SVGLoad events here if we can, otherwise they&#39;ll be sent when any required loads finish</span>
<span class="line-removed"> 499     sendSVGLoadEventIfPossible();</span>
<span class="line-removed"> 500 </span>
 501     // Notify all the elements which have references to this element to rebuild their shadow and render
 502     // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
 503     invalidateInstances();
 504 }
 505 
 506 bool SVGElement::childShouldCreateRenderer(const Node&amp; child) const
 507 {
 508     if (!child.isSVGElement())
 509         return false;
 510     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 511 
 512     static const QualifiedName* const invalidTextContent[] {
 513 #if ENABLE(SVG_FONTS)
 514         &amp;SVGNames::altGlyphTag.get(),
 515 #endif
 516         &amp;SVGNames::textPathTag.get(),
 517         &amp;SVGNames::trefTag.get(),
 518         &amp;SVGNames::tspanTag.get(),
 519     };
 520     auto&amp; name = svgChild.localName();
</pre>
<hr />
<pre>
 564 
 565 void SVGElement::commitPropertyChange(SVGProperty* property)
 566 {
 567     // We want to dirty the top-level property when a descendant changes. For example
 568     // a change in an SVGLength item in SVGLengthList should set the dirty flag on
 569     // SVGLengthList and not the SVGLength.
 570     property-&gt;setDirty();
 571 
 572     invalidateSVGAttributes();
 573     svgAttributeChanged(propertyRegistry().propertyAttributeName(*property));
 574 }
 575 
 576 void SVGElement::commitPropertyChange(SVGAnimatedProperty&amp; animatedProperty)
 577 {
 578     QualifiedName attributeName = propertyRegistry().animatedPropertyAttributeName(animatedProperty);
 579     ASSERT(attributeName != nullQName());
 580 
 581     // A change in a style property, e.g SVGRectElement::x should be serialized to
 582     // the attribute immediately. Otherwise it is okay to be lazy in this regard.
 583     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
<span class="line-modified"> 584         animatedProperty.setDirty();</span>
 585     else
 586         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
 587 
 588     invalidateSVGAttributes();
 589     svgAttributeChanged(attributeName);
 590 }
 591 
 592 bool SVGElement::isAnimatedPropertyAttribute(const QualifiedName&amp; attributeName) const
 593 {
 594     return propertyRegistry().isAnimatedPropertyAttribute(attributeName);
 595 }
 596 
 597 bool SVGElement::isAnimatedAttribute(const QualifiedName&amp; attributeName) const
 598 {
 599     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || isAnimatedPropertyAttribute(attributeName);
 600 }
 601 
 602 bool SVGElement::isAnimatedStyleAttribute(const QualifiedName&amp; attributeName) const
 603 {
 604     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || propertyRegistry().isAnimatedStylePropertyAttribute(attributeName);
</pre>
<hr />
<pre>
 607 RefPtr&lt;SVGAttributeAnimator&gt; SVGElement::createAnimator(const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive)
 608 {
 609     // Property animator, e.g. &quot;fill&quot; or &quot;fill-opacity&quot;.
 610     if (auto animator = propertyAnimatorFactory().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive))
 611         return animator;
 612 
 613     // Animated property animator.
 614     auto animator = propertyRegistry().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive);
 615     if (!animator)
 616         return animator;
 617     for (auto* instance : instances())
 618         instance-&gt;propertyRegistry().appendAnimatedInstance(attributeName, *animator);
 619     return animator;
 620 }
 621 
 622 void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
 623 {
 624     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
 625 }
 626 
<span class="line-modified"> 627 Optional&lt;ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
 628 {
 629     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 630     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
<span class="line-modified"> 631         Optional&lt;ElementStyle&gt; style = styleElement-&gt;resolveStyle(&amp;parentStyle);</span>
<span class="line-modified"> 632         StyleResolver::adjustSVGElementStyle(*this, *style-&gt;renderStyle);</span>
 633         return style;
 634     }
 635 
 636     return resolveStyle(&amp;parentStyle);
 637 }
 638 
 639 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 640 {
 641     if (m_svgRareData)
 642         return m_svgRareData-&gt;animatedSMILStyleProperties();
 643     return 0;
 644 }
 645 
 646 MutableStyleProperties&amp; SVGElement::ensureAnimatedSMILStyleProperties()
 647 {
 648     return ensureSVGRareData().ensureAnimatedSMILStyleProperties();
 649 }
 650 
 651 void SVGElement::setUseOverrideComputedStyle(bool value)
 652 {
</pre>
<hr />
<pre>
 846         invalidateInstances();
 847         return;
 848     }
 849 
 850     if (attrName == HTMLNames::classAttr) {
 851         classAttributeChanged(className());
 852         invalidateInstances();
 853         return;
 854     }
 855 
 856     if (attrName == HTMLNames::idAttr) {
 857         auto renderer = this-&gt;renderer();
 858         // Notify resources about id changes, this is important as we cache resources by id in SVGDocumentExtensions
 859         if (is&lt;RenderSVGResourceContainer&gt;(renderer))
 860             downcast&lt;RenderSVGResourceContainer&gt;(*renderer).idChanged();
 861         if (isConnected())
 862             buildPendingResourcesIfNeeded();
 863         invalidateInstances();
 864         return;
 865     }
<span class="line-removed"> 866 </span>
<span class="line-removed"> 867     SVGLangSpace::svgAttributeChanged(attrName);</span>
 868 }
 869 
 870 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 871 {
 872     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 873     updateRelativeLengthsInformation();
 874     buildPendingResourcesIfNeeded();
 875     return InsertedIntoAncestorResult::Done;
 876 }
 877 
 878 void SVGElement::buildPendingResourcesIfNeeded()
 879 {
 880     if (!needsPendingResourceHandling() || !isConnected() || isInShadowTree())
 881         return;
 882 
 883     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 884     String resourceId = getIdAttribute();
 885     if (!extensions.isIdOfPendingResource(resourceId))
 886         return;
 887 
</pre>
<hr />
<pre>
 890 
 891     // Rebuild pending resources for each client of a pending resource that is being removed.
 892     while (auto clientElement = extensions.removeElementFromPendingResourcesForRemovalMap(resourceId)) {
 893         ASSERT(clientElement-&gt;hasPendingResources());
 894         if (clientElement-&gt;hasPendingResources()) {
 895             clientElement-&gt;buildPendingResource();
 896             extensions.clearHasPendingResourcesIfPossible(*clientElement);
 897         }
 898     }
 899 }
 900 
 901 void SVGElement::childrenChanged(const ChildChange&amp; change)
 902 {
 903     StyledElement::childrenChanged(change);
 904 
 905     if (change.source == ChildChangeSource::Parser)
 906         return;
 907     invalidateInstances();
 908 }
 909 
<span class="line-removed"> 910 RefPtr&lt;DeprecatedCSSOMValue&gt; SVGElement::getPresentationAttribute(const String&amp; name)</span>
<span class="line-removed"> 911 {</span>
<span class="line-removed"> 912     if (!hasAttributesWithoutUpdate())</span>
<span class="line-removed"> 913         return 0;</span>
<span class="line-removed"> 914 </span>
<span class="line-removed"> 915     QualifiedName attributeName(nullAtom(), name, nullAtom());</span>
<span class="line-removed"> 916     const Attribute* attribute = findAttributeByName(attributeName);</span>
<span class="line-removed"> 917     if (!attribute)</span>
<span class="line-removed"> 918         return 0;</span>
<span class="line-removed"> 919 </span>
<span class="line-removed"> 920     auto style = MutableStyleProperties::create(SVGAttributeMode);</span>
<span class="line-removed"> 921     CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(attribute-&gt;name());</span>
<span class="line-removed"> 922     style-&gt;setProperty(propertyID, attribute-&gt;value());</span>
<span class="line-removed"> 923     auto cssValue = style-&gt;getPropertyCSSValue(propertyID);</span>
<span class="line-removed"> 924     if (!cssValue)</span>
<span class="line-removed"> 925         return nullptr;</span>
<span class="line-removed"> 926     return cssValue-&gt;createDeprecatedCSSOMWrapper(style-&gt;ensureCSSStyleDeclaration());</span>
<span class="line-removed"> 927 }</span>
<span class="line-removed"> 928 </span>
 929 bool SVGElement::instanceUpdatesBlocked() const
 930 {
 931     return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
 932 }
 933 
 934 void SVGElement::setInstanceUpdatesBlocked(bool value)
 935 {
 936     // Catch any callers that calls setInstanceUpdatesBlocked(true) twice in a row.
 937     // That probably indicates nested use of InstanceUpdateBlocker and a bug.
 938     ASSERT(!value || !instanceUpdatesBlocked());
 939 
 940     if (m_svgRareData)
 941         m_svgRareData-&gt;setInstanceUpdatesBlocked(value);
 942 }
 943 
 944 AffineTransform SVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope) const
 945 {
 946     // To be overridden by SVGGraphicsElement (or as special case SVGTextElement and SVGPatternElement)
 947     return AffineTransform();
 948 }
</pre>
</td>
<td>
<hr />
<pre>
  34 #include &quot;EventNames.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLNames.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;RenderObject.h&quot;
  39 #include &quot;RenderSVGResource.h&quot;
  40 #include &quot;RenderSVGResourceFilter.h&quot;
  41 #include &quot;RenderSVGResourceMasker.h&quot;
  42 #include &quot;SVGDocumentExtensions.h&quot;
  43 #include &quot;SVGElementRareData.h&quot;
  44 #include &quot;SVGGraphicsElement.h&quot;
  45 #include &quot;SVGImageElement.h&quot;
  46 #include &quot;SVGNames.h&quot;
  47 #include &quot;SVGPropertyAnimatorFactory.h&quot;
  48 #include &quot;SVGRenderStyle.h&quot;
  49 #include &quot;SVGRenderSupport.h&quot;
  50 #include &quot;SVGSVGElement.h&quot;
  51 #include &quot;SVGTitleElement.h&quot;
  52 #include &quot;SVGUseElement.h&quot;
  53 #include &quot;ShadowRoot.h&quot;
<span class="line-added">  54 #include &quot;StyleAdjuster.h&quot;</span>
  55 #include &quot;XMLNames.h&quot;
  56 #include &lt;wtf/Assertions.h&gt;
  57 #include &lt;wtf/HashMap.h&gt;
  58 #include &lt;wtf/IsoMallocInlines.h&gt;
  59 #include &lt;wtf/NeverDestroyed.h&gt;
  60 #include &lt;wtf/StdLibExtras.h&gt;
  61 #include &lt;wtf/text/WTFString.h&gt;
  62 
  63 
  64 namespace WebCore {
  65 
  66 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGElement);
  67 
  68 static NEVER_INLINE HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; createAttributeNameToCSSPropertyIDMap()
  69 {
  70     using namespace HTMLNames;
  71     using namespace SVGNames;
  72 
  73     // This list should include all base CSS and SVG CSS properties which are exposed as SVG XML attributes.
  74     static const QualifiedName* const attributeNames[] = {
</pre>
<hr />
<pre>
 144         &amp;xAttr.get(),
 145         &amp;yAttr.get(),
 146     };
 147 
 148     HashMap&lt;AtomStringImpl*, CSSPropertyID&gt; map;
 149 
 150     for (auto&amp; name : attributeNames) {
 151         const AtomString&amp; localName = name-&gt;localName();
 152         map.add(localName.impl(), cssPropertyID(localName));
 153     }
 154 
 155     // FIXME: When CSS supports &quot;transform-origin&quot; this special case can be removed,
 156     // and we can add transform_originAttr to the table above instead.
 157     map.add(transform_originAttr-&gt;localName().impl(), CSSPropertyTransformOrigin);
 158 
 159     return map;
 160 }
 161 
 162 SVGElement::SVGElement(const QualifiedName&amp; tagName, Document&amp; document)
 163     : StyledElement(tagName, document, CreateSVGElement)

 164     , m_propertyAnimatorFactory(makeUnique&lt;SVGPropertyAnimatorFactory&gt;())
 165 {
 166     static std::once_flag onceFlag;
 167     std::call_once(onceFlag, [] {
 168         PropertyRegistry::registerProperty&lt;HTMLNames::classAttr, &amp;SVGElement::m_className&gt;();
 169     });
 170 }
 171 
 172 SVGElement::~SVGElement()
 173 {
 174     if (m_svgRareData) {
 175         for (SVGElement* instance : m_svgRareData-&gt;instances())
 176             instance-&gt;m_svgRareData-&gt;setCorrespondingElement(nullptr);
 177         if (auto correspondingElement = makeRefPtr(m_svgRareData-&gt;correspondingElement()))
 178             correspondingElement-&gt;m_svgRareData-&gt;instances().remove(this);
 179 
 180         m_svgRareData = nullptr;
 181     }
 182     document().accessSVGExtensions().rebuildAllElementReferencesForTarget(*this);
 183     document().accessSVGExtensions().removeAllElementReferencesForTarget(*this);
</pre>
<hr />
<pre>
 337 void SVGElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 338 {
 339     if (name == HTMLNames::classAttr) {
 340         m_className-&gt;setBaseValInternal(value);
 341         return;
 342     }
 343 
 344     if (name == HTMLNames::tabindexAttr) {
 345         if (value.isEmpty())
 346             clearTabIndexExplicitlyIfNeeded();
 347         else if (auto optionalTabIndex = parseHTMLInteger(value))
 348             setTabIndexExplicitly(optionalTabIndex.value());
 349         return;
 350     }
 351 
 352     auto&amp; eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
 353     if (!eventName.isNull()) {
 354         setAttributeEventListener(eventName, name, value);
 355         return;
 356     }


 357 }
 358 
 359 bool SVGElement::haveLoadedRequiredResources()
 360 {
 361     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(*this)) {
 362         if (!child.haveLoadedRequiredResources())
 363             return false;
 364     }
 365     return true;
 366 }
 367 
 368 bool SVGElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
 369 {
 370     // Add event listener to regular DOM element
 371     if (!Node::addEventListener(eventType, listener.copyRef(), options))
 372         return false;
 373 
 374     if (containingShadowRoot())
 375         return true;
 376 
</pre>
<hr />
<pre>
 421         ASSERT(instance-&gt;eventTargetData());
 422         instance-&gt;eventTargetData()-&gt;eventListenerMap.removeFirstEventListenerCreatedFromMarkup(eventType);
 423     }
 424 
 425     return true;
 426 }
 427 
 428 static bool hasLoadListener(Element* element)
 429 {
 430     if (element-&gt;hasEventListeners(eventNames().loadEvent))
 431         return true;
 432 
 433     for (element = element-&gt;parentOrShadowHostElement(); element; element = element-&gt;parentOrShadowHostElement()) {
 434         if (element-&gt;hasCapturingEventListeners(eventNames().loadEvent))
 435             return true;
 436     }
 437 
 438     return false;
 439 }
 440 
<span class="line-modified"> 441 void SVGElement::sendLoadEventIfPossible()</span>
 442 {
 443     if (!isConnected() || !document().frame())
 444         return;
 445 
<span class="line-modified"> 446     if (!haveLoadedRequiredResources() || !hasLoadListener(this))</span>
<span class="line-modified"> 447         return;</span>






















 448 
<span class="line-modified"> 449     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>


 450 }
 451 
<span class="line-modified"> 452 void SVGElement::loadEventTimerFired()</span>
 453 {
<span class="line-modified"> 454     sendLoadEventIfPossible();</span>
 455 }
 456 
<span class="line-modified"> 457 Timer* SVGElement::loadEventTimer()</span>
 458 {
 459     ASSERT_NOT_REACHED();
 460     return nullptr;
 461 }
 462 
 463 void SVGElement::finishParsingChildren()
 464 {
 465     StyledElement::finishParsingChildren();
 466 

 467     if (isOutermostSVGSVGElement())
 468         return;
 469 




 470     // Notify all the elements which have references to this element to rebuild their shadow and render
 471     // trees, e.g. a &lt;use&gt; element references a target element before this target element is defined.
 472     invalidateInstances();
 473 }
 474 
 475 bool SVGElement::childShouldCreateRenderer(const Node&amp; child) const
 476 {
 477     if (!child.isSVGElement())
 478         return false;
 479     auto&amp; svgChild = downcast&lt;SVGElement&gt;(child);
 480 
 481     static const QualifiedName* const invalidTextContent[] {
 482 #if ENABLE(SVG_FONTS)
 483         &amp;SVGNames::altGlyphTag.get(),
 484 #endif
 485         &amp;SVGNames::textPathTag.get(),
 486         &amp;SVGNames::trefTag.get(),
 487         &amp;SVGNames::tspanTag.get(),
 488     };
 489     auto&amp; name = svgChild.localName();
</pre>
<hr />
<pre>
 533 
 534 void SVGElement::commitPropertyChange(SVGProperty* property)
 535 {
 536     // We want to dirty the top-level property when a descendant changes. For example
 537     // a change in an SVGLength item in SVGLengthList should set the dirty flag on
 538     // SVGLengthList and not the SVGLength.
 539     property-&gt;setDirty();
 540 
 541     invalidateSVGAttributes();
 542     svgAttributeChanged(propertyRegistry().propertyAttributeName(*property));
 543 }
 544 
 545 void SVGElement::commitPropertyChange(SVGAnimatedProperty&amp; animatedProperty)
 546 {
 547     QualifiedName attributeName = propertyRegistry().animatedPropertyAttributeName(animatedProperty);
 548     ASSERT(attributeName != nullQName());
 549 
 550     // A change in a style property, e.g SVGRectElement::x should be serialized to
 551     // the attribute immediately. Otherwise it is okay to be lazy in this regard.
 552     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
<span class="line-modified"> 553         propertyRegistry().setAnimatedPropertDirty(attributeName, animatedProperty);</span>
 554     else
 555         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
 556 
 557     invalidateSVGAttributes();
 558     svgAttributeChanged(attributeName);
 559 }
 560 
 561 bool SVGElement::isAnimatedPropertyAttribute(const QualifiedName&amp; attributeName) const
 562 {
 563     return propertyRegistry().isAnimatedPropertyAttribute(attributeName);
 564 }
 565 
 566 bool SVGElement::isAnimatedAttribute(const QualifiedName&amp; attributeName) const
 567 {
 568     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || isAnimatedPropertyAttribute(attributeName);
 569 }
 570 
 571 bool SVGElement::isAnimatedStyleAttribute(const QualifiedName&amp; attributeName) const
 572 {
 573     return SVGPropertyAnimatorFactory::isKnownAttribute(attributeName) || propertyRegistry().isAnimatedStylePropertyAttribute(attributeName);
</pre>
<hr />
<pre>
 576 RefPtr&lt;SVGAttributeAnimator&gt; SVGElement::createAnimator(const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive)
 577 {
 578     // Property animator, e.g. &quot;fill&quot; or &quot;fill-opacity&quot;.
 579     if (auto animator = propertyAnimatorFactory().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive))
 580         return animator;
 581 
 582     // Animated property animator.
 583     auto animator = propertyRegistry().createAnimator(attributeName, animationMode, calcMode, isAccumulated, isAdditive);
 584     if (!animator)
 585         return animator;
 586     for (auto* instance : instances())
 587         instance-&gt;propertyRegistry().appendAnimatedInstance(attributeName, *animator);
 588     return animator;
 589 }
 590 
 591 void SVGElement::animatorWillBeDeleted(const QualifiedName&amp; attributeName)
 592 {
 593     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
 594 }
 595 
<span class="line-modified"> 596 Optional&lt;Style::ElementStyle&gt; SVGElement::resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle*)</span>
 597 {
 598     // If the element is in a &lt;use&gt; tree we get the style from the definition tree.
 599     if (auto styleElement = makeRefPtr(this-&gt;correspondingElement())) {
<span class="line-modified"> 600         auto style = styleElement-&gt;resolveStyle(&amp;parentStyle);</span>
<span class="line-modified"> 601         Style::Adjuster::adjustSVGElementStyle(*style.renderStyle, *this);</span>
 602         return style;
 603     }
 604 
 605     return resolveStyle(&amp;parentStyle);
 606 }
 607 
 608 MutableStyleProperties* SVGElement::animatedSMILStyleProperties() const
 609 {
 610     if (m_svgRareData)
 611         return m_svgRareData-&gt;animatedSMILStyleProperties();
 612     return 0;
 613 }
 614 
 615 MutableStyleProperties&amp; SVGElement::ensureAnimatedSMILStyleProperties()
 616 {
 617     return ensureSVGRareData().ensureAnimatedSMILStyleProperties();
 618 }
 619 
 620 void SVGElement::setUseOverrideComputedStyle(bool value)
 621 {
</pre>
<hr />
<pre>
 815         invalidateInstances();
 816         return;
 817     }
 818 
 819     if (attrName == HTMLNames::classAttr) {
 820         classAttributeChanged(className());
 821         invalidateInstances();
 822         return;
 823     }
 824 
 825     if (attrName == HTMLNames::idAttr) {
 826         auto renderer = this-&gt;renderer();
 827         // Notify resources about id changes, this is important as we cache resources by id in SVGDocumentExtensions
 828         if (is&lt;RenderSVGResourceContainer&gt;(renderer))
 829             downcast&lt;RenderSVGResourceContainer&gt;(*renderer).idChanged();
 830         if (isConnected())
 831             buildPendingResourcesIfNeeded();
 832         invalidateInstances();
 833         return;
 834     }


 835 }
 836 
 837 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 838 {
 839     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 840     updateRelativeLengthsInformation();
 841     buildPendingResourcesIfNeeded();
 842     return InsertedIntoAncestorResult::Done;
 843 }
 844 
 845 void SVGElement::buildPendingResourcesIfNeeded()
 846 {
 847     if (!needsPendingResourceHandling() || !isConnected() || isInShadowTree())
 848         return;
 849 
 850     SVGDocumentExtensions&amp; extensions = document().accessSVGExtensions();
 851     String resourceId = getIdAttribute();
 852     if (!extensions.isIdOfPendingResource(resourceId))
 853         return;
 854 
</pre>
<hr />
<pre>
 857 
 858     // Rebuild pending resources for each client of a pending resource that is being removed.
 859     while (auto clientElement = extensions.removeElementFromPendingResourcesForRemovalMap(resourceId)) {
 860         ASSERT(clientElement-&gt;hasPendingResources());
 861         if (clientElement-&gt;hasPendingResources()) {
 862             clientElement-&gt;buildPendingResource();
 863             extensions.clearHasPendingResourcesIfPossible(*clientElement);
 864         }
 865     }
 866 }
 867 
 868 void SVGElement::childrenChanged(const ChildChange&amp; change)
 869 {
 870     StyledElement::childrenChanged(change);
 871 
 872     if (change.source == ChildChangeSource::Parser)
 873         return;
 874     invalidateInstances();
 875 }
 876 



















 877 bool SVGElement::instanceUpdatesBlocked() const
 878 {
 879     return m_svgRareData &amp;&amp; m_svgRareData-&gt;instanceUpdatesBlocked();
 880 }
 881 
 882 void SVGElement::setInstanceUpdatesBlocked(bool value)
 883 {
 884     // Catch any callers that calls setInstanceUpdatesBlocked(true) twice in a row.
 885     // That probably indicates nested use of InstanceUpdateBlocker and a bug.
 886     ASSERT(!value || !instanceUpdatesBlocked());
 887 
 888     if (m_svgRareData)
 889         m_svgRareData-&gt;setInstanceUpdatesBlocked(value);
 890 }
 891 
 892 AffineTransform SVGElement::localCoordinateSpaceTransform(SVGLocatable::CTMScope) const
 893 {
 894     // To be overridden by SVGGraphicsElement (or as special case SVGTextElement and SVGPatternElement)
 895     return AffineTransform();
 896 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGDocumentExtensions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/opcode_generator.rb</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #!/usr/bin/env ruby
   2 
   3 # Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   4 #
   5 # Redistribution and use in source and binary forms, with or without
   6 # modification, are permitted provided that the following conditions
   7 # are met:
   8 # 1. Redistributions of source code must retain the above copyright
   9 #    notice, this list of conditions and the following disclaimer.
  10 # 2. Redistributions in binary form must reproduce the above copyright
  11 #    notice, this list of conditions and the following disclaimer in the
  12 #    documentation and/or other materials provided with the distribution.
  13 #
  14 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24 # THE POSSIBILITY OF SUCH DAMAGE.
  25 
  26 require &quot;pathname&quot;
  27 
  28 class Opcode
  29     attr_reader :name, :custom, :overloads
  30     attr_reader :attributes
  31 
  32     def initialize(name, custom)
  33         @name = name
  34         @custom = custom
  35         @attributes = {}
  36         unless custom
  37             @overloads = []
  38         end
  39     end
  40 
  41     def masmName
  42         name[0].downcase + name[1..-1]
  43     end
  44 end
  45 
  46 class Arg
  47     attr_reader :role, :bank, :width
  48 
  49     def initialize(role, bank, width)
  50         @role = role
  51         @bank = bank
  52         @width = width
  53     end
  54     
  55     def self.widthCode(width)
  56         if width == &quot;Ptr&quot;
  57             &quot;POINTER_WIDTH&quot;
  58         else
  59             &quot;Width#{width}&quot;
  60         end
  61     end
  62 
  63     def widthCode
  64         Arg.widthCode(width)
  65     end
  66     
  67     def self.roleCode(role)
  68         case role
  69         when &quot;U&quot;
  70             &quot;Use&quot;
  71         when &quot;D&quot;
  72             &quot;Def&quot;
  73         when &quot;ZD&quot;
  74             &quot;ZDef&quot;
  75         when &quot;UD&quot;
  76             &quot;UseDef&quot;
  77         when &quot;UZD&quot;
  78             &quot;UseZDef&quot;
  79         when &quot;UA&quot;
  80             &quot;UseAddr&quot;
  81         when &quot;S&quot;
  82             &quot;Scratch&quot;
  83         when &quot;ED&quot;
  84             &quot;EarlyDef&quot;
  85         when &quot;EZD&quot;
  86             &quot;EarlyZDef&quot;
  87         when &quot;LU&quot;
  88             &quot;LateUse&quot;
  89         else
  90             raise
  91         end
  92     end
  93     
  94     def roleCode
  95         Arg.roleCode(role)
  96     end
  97     
  98     def to_s
  99         &quot;#{role}:#{bank}:#{width}&quot;
 100     end
 101 end
 102 
 103 class Overload
 104     attr_reader :signature, :forms
 105 
 106     def initialize(signature, forms)
 107         @signature = signature
 108         @forms = forms
 109     end
 110 end
 111 
 112 class Kind
 113     attr_reader :name
 114     attr_accessor :custom
 115 
 116     def initialize(name)
 117         @name = name
 118         @custom = false
 119     end
 120 
 121     def ==(other)
 122         if other.is_a? String
 123             @name == other
 124         else
 125             @name == other.name and @custom == other.custom
 126         end
 127     end
 128 
 129     def Kind.argKinds(kind)
 130         if kind == &quot;Addr&quot;
 131             [&quot;Addr&quot;, &quot;Stack&quot;, &quot;CallArg&quot;]
 132         else
 133             [kind]
 134         end
 135     end
 136 
 137     def argKinds
 138         Kind.argKinds(kind)
 139     end
 140 end
 141 
 142 class Form
 143     attr_reader :kinds, :altName, :archs
 144 
 145     def initialize(kinds, altName, archs)
 146         @kinds = kinds
 147         @altName = altName
 148         @archs = archs
 149     end
 150 end
 151 
 152 class Origin
 153     attr_reader :fileName, :lineNumber
 154     
 155     def initialize(fileName, lineNumber)
 156         @fileName = fileName
 157         @lineNumber = lineNumber
 158     end
 159     
 160     def to_s
 161         &quot;#{fileName}:#{lineNumber}&quot;
 162     end
 163 end
 164 
 165 class Token
 166     attr_reader :origin, :string
 167     
 168     def initialize(origin, string)
 169         @origin = origin
 170         @string = string
 171     end
 172     
 173     def ==(other)
 174         if other.is_a? Token
 175             @string == other.string
 176         else
 177             @string == other
 178         end
 179     end
 180     
 181     def =~(other)
 182         @string =~ other
 183     end
 184     
 185     def to_s
 186         &quot;#{@string.inspect} at #{origin}&quot;
 187     end
 188     
 189     def parseError(*comment)
 190         if comment.empty?
 191             raise &quot;Parse error: #{to_s}&quot;
 192         else
 193             raise &quot;Parse error: #{to_s}: #{comment[0]}&quot;
 194         end
 195     end
 196 end
 197 
 198 def lex(str, fileName)
 199     fileName = Pathname.new(fileName)
 200     result = []
 201     lineNumber = 1
 202     while not str.empty?
 203         case str
 204         when /\A\#([^\n]*)/
 205             # comment, ignore
 206         when /\A\n/
 207             # newline, ignore
 208             lineNumber += 1
 209         when /\A([a-zA-Z0-9_]+)/
 210             result &lt;&lt; Token.new(Origin.new(fileName, lineNumber), $&amp;)
 211         when /\A([ \t\r]+)/
 212             # whitespace, ignore
 213         when /\A[,:*\/]/
 214             result &lt;&lt; Token.new(Origin.new(fileName, lineNumber), $&amp;)
 215         else
 216             raise &quot;Lexer error at #{Origin.new(fileName, lineNumber).to_s}, unexpected sequence #{str[0..20].inspect}&quot;
 217         end
 218         str = $~.post_match
 219     end
 220     result
 221 end
 222 
 223 def isRole(token)
 224     token =~ /\A((U)|(D)|(UD)|(ZD)|(UZD)|(UA)|(S)|(ED)|(EZD)|(LU))\Z/
 225 end
 226 
 227 def isGF(token)
 228     token =~ /\A((G)|(F))\Z/
 229 end
 230 
 231 def isKind(token)
 232     token =~ /\A((Tmp)|(Imm)|(BigImm)|(BitImm)|(BitImm64)|(SimpleAddr)|(Addr)|(ExtendedOffsetAddr)|(Index)|(RelCond)|(ResCond)|(DoubleCond)|(StatusCond))\Z/
 233 end
 234 
 235 def isArch(token)
 236     token =~ /\A((x86)|(x86_32)|(x86_64)|(arm)|(armv7)|(arm64)|(32)|(64))\Z/
 237 end
 238 
 239 def isWidth(token)
 240     token =~ /\A((8)|(16)|(32)|(64)|(Ptr))\Z/
 241 end
 242 
 243 def isKeyword(token)
 244     isRole(token) or isGF(token) or isKind(token) or isArch(token) or isWidth(token) or
 245         token == &quot;custom&quot; or token == &quot;as&quot;
 246 end
 247 
 248 def isIdentifier(token)
 249     token =~ /\A([a-zA-Z0-9_]+)\Z/ and not isKeyword(token)
 250 end
 251 
 252 class Parser
 253     def initialize(data, fileName)
 254         @tokens = lex(data, fileName)
 255         @idx = 0
 256     end
 257 
 258     def token
 259         @tokens[@idx]
 260     end
 261 
 262     def advance
 263         @idx += 1
 264     end
 265 
 266     def parseError(*comment)
 267         if token
 268             token.parseError(*comment)
 269         else
 270             if comment.empty?
 271                 raise &quot;Parse error at end of file&quot;
 272             else
 273                 raise &quot;Parse error at end of file: #{comment[0]}&quot;
 274             end
 275         end
 276     end
 277 
 278     def consume(string)
 279         parseError(&quot;Expected #{string}&quot;) unless token == string
 280         advance
 281     end
 282 
 283     def consumeIdentifier
 284         result = token.string
 285         parseError(&quot;Expected identifier&quot;) unless isIdentifier(result)
 286         advance
 287         result
 288     end
 289 
 290     def consumeRole
 291         result = token.string
 292         parseError(&quot;Expected role (U, D, UD, ZD, UZD, UA, or S)&quot;) unless isRole(result)
 293         advance
 294         result
 295     end
 296 
 297     def consumeBank
 298         result = token.string
 299         parseError(&quot;Expected bank (G or F)&quot;) unless isGF(result)
 300         advance
 301         result
 302     end
 303 
 304     def consumeKind
 305         result = token.string
 306         parseError(&quot;Expected kind (Imm, BigImm, BitImm, BitImm64, Tmp, SimpleAddr, Addr, ExtendedOffsetAddr, Index, RelCond, ResCond, DoubleCond, or StatusCond)&quot;) unless isKind(result)
 307         advance
 308         result
 309     end
 310 
 311     def consumeWidth
 312         result = token.string
 313         parseError(&quot;Expected width (8, 16, 32, or 64)&quot;) unless isWidth(result)
 314         advance
 315         result
 316     end
 317 
 318     def parseArchs
 319         return nil unless isArch(token)
 320 
 321         result = []
 322         while isArch(token)
 323             case token.string
 324             when &quot;x86&quot;
 325                 result &lt;&lt; &quot;X86&quot;
 326                 result &lt;&lt; &quot;X86_64&quot;
 327             when &quot;x86_32&quot;
 328                 result &lt;&lt; &quot;X86&quot;
 329             when &quot;x86_64&quot;
 330                 result &lt;&lt; &quot;X86_64&quot;
 331             when &quot;arm&quot;
 332                 result &lt;&lt; &quot;ARMv7&quot;
 333                 result &lt;&lt; &quot;ARM64&quot;
 334             when &quot;armv7&quot;
 335                 result &lt;&lt; &quot;ARMv7&quot;
 336             when &quot;arm64&quot;
 337                 result &lt;&lt; &quot;ARM64&quot;
 338             when &quot;32&quot;
 339                 result &lt;&lt; &quot;X86&quot;
 340                 result &lt;&lt; &quot;ARMv7&quot;
 341             when &quot;64&quot;
 342                 result &lt;&lt; &quot;X86_64&quot;
 343                 result &lt;&lt; &quot;ARM64&quot;
 344             else
 345                 raise token.string
 346             end
 347             advance
 348         end
 349 
 350         consume(&quot;:&quot;)
 351         @lastArchs = result
 352     end
 353 
 354     def consumeArchs
 355         result = @lastArchs
 356         @lastArchs = nil
 357         result
 358     end
 359 
 360     def parseAndConsumeArchs
 361         parseArchs
 362         consumeArchs
 363     end
 364 
 365     def intersectArchs(left, right)
 366         return left unless right
 367         return right unless left
 368 
 369         left.select {
 370             | value |
 371             right.find {
 372                 | otherValue |
 373                 value == otherValue
 374             }
 375         }
 376     end
 377 
 378     def parse
 379         result = {}
 380         
 381         loop {
 382             break if @idx &gt;= @tokens.length
 383 
 384             if token == &quot;custom&quot;
 385                 consume(&quot;custom&quot;)
 386                 opcodeName = consumeIdentifier
 387 
 388                 parseError(&quot;Cannot overload a custom opcode&quot;) if result[opcodeName]
 389 
 390                 result[opcodeName] = Opcode.new(opcodeName, true)
 391             else
 392                 opcodeArchs = parseAndConsumeArchs
 393 
 394                 opcodeName = consumeIdentifier
 395 
 396                 if result[opcodeName]
 397                     opcode = result[opcodeName]
 398                     parseError(&quot;Cannot overload a custom opcode&quot;) if opcode.custom
 399                 else
 400                     opcode = Opcode.new(opcodeName, false)
 401                     result[opcodeName] = opcode
 402                 end
 403 
 404                 signature = []
 405                 forms = []
 406                 
 407                 if isRole(token)
 408                     loop {
 409                         role = consumeRole
 410                         consume(&quot;:&quot;)
 411                         bank = consumeBank
 412                         consume(&quot;:&quot;)
 413                         width = consumeWidth
 414                         
 415                         signature &lt;&lt; Arg.new(role, bank, width)
 416                         
 417                         break unless token == &quot;,&quot;
 418                         consume(&quot;,&quot;)
 419                     }
 420                 end
 421 
 422                 while token == &quot;/&quot;
 423                     consume(&quot;/&quot;)
 424                     case token.string
 425                     when &quot;branch&quot;
 426                         opcode.attributes[:branch] = true
 427                         opcode.attributes[:terminal] = true
 428                     when &quot;terminal&quot;
 429                         opcode.attributes[:terminal] = true
 430                     when &quot;effects&quot;
 431                         opcode.attributes[:effects] = true
 432                     when &quot;return&quot;
 433                         opcode.attributes[:return] = true
 434                         opcode.attributes[:terminal] = true
 435                     else
 436                         parseError(&quot;Bad / directive&quot;)
 437                     end
 438                     advance
 439                 end
 440 
 441                 parseArchs
 442                 if isKind(token)
 443                     loop {
 444                         kinds = []
 445                         altName = nil
 446                         formArchs = consumeArchs
 447                         loop {
 448                             kinds &lt;&lt; Kind.new(consumeKind)
 449 
 450                             if token == &quot;*&quot;
 451                                 parseError(&quot;Can only apply * to Tmp&quot;) unless kinds[-1].name == &quot;Tmp&quot;
 452                                 kinds[-1].custom = true
 453                                 consume(&quot;*&quot;)
 454                             end
 455 
 456                             break unless token == &quot;,&quot;
 457                             consume(&quot;,&quot;)
 458                         }
 459 
 460                         if token == &quot;as&quot;
 461                             consume(&quot;as&quot;)
 462                             altName = consumeIdentifier
 463                         end
 464 
 465                         parseError(&quot;Form has wrong number of arguments for overload&quot;) unless kinds.length == signature.length
 466                         kinds.each_with_index {
 467                             | kind, index |
 468                             if kind.name == &quot;Imm&quot; or kind.name == &quot;BigImm&quot; or kind.name == &quot;BitImm&quot; or kind.name == &quot;BitImm64&quot;
 469                                 if signature[index].role != &quot;U&quot;
 470                                     parseError(&quot;Form has an immediate for a non-use argument&quot;)
 471                                 end
 472                                 if signature[index].bank != &quot;G&quot;
 473                                     parseError(&quot;Form has an immediate for a non-general-purpose argument&quot;)
 474                                 end
 475                             end
 476                         }
 477                         forms &lt;&lt; Form.new(kinds, altName, intersectArchs(opcodeArchs, formArchs))
 478 
 479                         parseArchs
 480                         break unless isKind(token)
 481                     }
 482                 end
 483 
 484                 if signature.length == 0
 485                     raise unless forms.length == 0
 486                     forms &lt;&lt; Form.new([], nil, opcodeArchs)
 487                 end
 488 
 489                 opcode.overloads &lt;&lt; Overload.new(signature, forms)
 490             end
 491         }
 492 
 493         result
 494     end
 495 end
 496 
 497 $fileName = ARGV[0]
 498 
 499 parser = Parser.new(IO::read($fileName), $fileName)
 500 $opcodes = parser.parse
 501 
 502 def writeH(filename)
 503     File.open(&quot;Air#{filename}.h&quot;, &quot;w&quot;) {
 504         | outp |
 505         
 506         outp.puts &quot;// Generated by opcode_generator.rb from #{$fileName} -- do not edit!&quot;
 507         
 508         outp.puts &quot;#ifndef Air#{filename}_h&quot;
 509         outp.puts &quot;#define Air#{filename}_h&quot;
 510 
 511         yield outp
 512         
 513         outp.puts &quot;#endif // Air#{filename}_h&quot;
 514     }
 515 end
 516 
 517 writeH(&quot;Opcode&quot;) {
 518     | outp |
 519     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 520     outp.puts &quot;enum Opcode : int16_t {&quot;
 521     $opcodes.keys.each {
 522         | opcode |
 523         outp.puts &quot;    #{opcode},&quot;
 524     }
 525     outp.puts &quot;};&quot;
 526 
 527     outp.puts &quot;static const unsigned numOpcodes = #{$opcodes.keys.size};&quot;
 528     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
 529     
 530     outp.puts &quot;namespace WTF {&quot;
 531     outp.puts &quot;class PrintStream;&quot;
 532     outp.puts &quot;JS_EXPORT_PRIVATE void printInternal(PrintStream&amp;, JSC::B3::Air::Opcode);&quot;
 533     outp.puts &quot;} // namespace WTF&quot;
 534 }
 535 
 536 # From here on, we don&#39;t try to emit properly indented code, since we&#39;re using a recursive pattern
 537 # matcher.
 538 
 539 def matchForms(outp, speed, forms, columnIndex, columnGetter, filter, callback)
 540     return if forms.length == 0
 541 
 542     if filter[forms]
 543         return
 544     end
 545 
 546     if columnIndex &gt;= forms[0].kinds.length
 547         raise &quot;Did not reduce to one form: #{forms.inspect}&quot; unless forms.length == 1
 548         callback[forms[0]]
 549         outp.puts &quot;break;&quot;
 550         return
 551     end
 552     
 553     groups = {}
 554     forms.each {
 555         | form |
 556         kind = form.kinds[columnIndex].name
 557         if groups[kind]
 558             groups[kind] &lt;&lt; form
 559         else
 560             groups[kind] = [form]
 561         end
 562     }
 563 
 564     if speed == :fast and groups.length == 1
 565         matchForms(outp, speed, forms, columnIndex + 1, columnGetter, filter, callback)
 566         return
 567     end
 568 
 569     outp.puts &quot;switch (#{columnGetter[columnIndex]}) {&quot;
 570     groups.each_pair {
 571         | key, value |
 572         outp.puts &quot;#if USE(JSVALUE64)&quot; if key == &quot;BigImm&quot; or key == &quot;BitImm64&quot;
 573         Kind.argKinds(key).each {
 574             | argKind |
 575             outp.puts &quot;case Arg::#{argKind}:&quot;
 576         }
 577         matchForms(outp, speed, value, columnIndex + 1, columnGetter, filter, callback)
 578         outp.puts &quot;break;&quot;
 579         outp.puts &quot;#endif // USE(JSVALUE64)&quot; if key == &quot;BigImm&quot; or key == &quot;BitImm64&quot;
 580     }
 581     outp.puts &quot;default:&quot;
 582     outp.puts &quot;break;&quot;
 583     outp.puts &quot;}&quot;
 584 end
 585 
 586 def matchInstOverload(outp, speed, inst)
 587     outp.puts &quot;switch (#{inst}-&gt;kind.opcode) {&quot;
 588     $opcodes.values.each {
 589         | opcode |
 590         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 591         if opcode.custom
 592             yield opcode, nil
 593         else
 594             needOverloadSwitch = ((opcode.overloads.size != 1) or speed == :safe)
 595             outp.puts &quot;switch (#{inst}-&gt;args.size()) {&quot; if needOverloadSwitch
 596             opcode.overloads.each {
 597                 | overload |
 598                 outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
 599                 yield opcode, overload
 600                 outp.puts &quot;break;&quot; if needOverloadSwitch
 601             }
 602             if needOverloadSwitch
 603                 outp.puts &quot;default:&quot;
 604                 outp.puts &quot;break;&quot;
 605                 outp.puts &quot;}&quot;
 606             end
 607         end
 608         outp.puts &quot;break;&quot;
 609     }
 610     outp.puts &quot;default:&quot;
 611     outp.puts &quot;break;&quot;
 612     outp.puts &quot;}&quot;
 613 end
 614     
 615 def matchInstOverloadForm(outp, speed, inst)
 616     matchInstOverload(outp, speed, inst) {
 617         | opcode, overload |
 618         if opcode.custom
 619             yield opcode, nil, nil
 620         else
 621             columnGetter = proc {
 622                 | columnIndex |
 623                 &quot;#{inst}-&gt;args[#{columnIndex}].kind()&quot;
 624             }
 625             filter = proc { false }
 626             callback = proc {
 627                 | form |
 628                 yield opcode, overload, form
 629             }
 630             matchForms(outp, speed, overload.forms, 0, columnGetter, filter, callback)
 631         end
 632     }
 633 end
 634 
 635 def beginArchs(outp, archs)
 636     return unless archs
 637     if archs.empty?
 638         outp.puts &quot;#if 0&quot;
 639         return
 640     end
 641     outp.puts(&quot;#if &quot; + archs.map {
 642                   | arch |
 643                   &quot;CPU(#{arch})&quot;
 644               }.join(&quot; || &quot;))
 645 end
 646 
 647 def endArchs(outp, archs)
 648     return unless archs
 649     outp.puts &quot;#endif&quot;
 650 end
 651 
 652 maxNumOperands = 0
 653 $opcodes.values.each {
 654     | opcode |
 655     next if opcode.custom
 656     opcode.overloads.each {
 657         | overload |
 658         maxNumOperands = overload.signature.length if overload.signature.length &gt; maxNumOperands
 659     }
 660 }
 661 
 662 formTableWidth = (maxNumOperands + 1) * maxNumOperands / 2
 663 
 664 writeH(&quot;OpcodeUtils&quot;) {
 665     | outp |
 666     outp.puts &quot;#include \&quot;AirCustom.h\&quot;&quot;
 667     outp.puts &quot;#include \&quot;AirInst.h\&quot;&quot;
 668     outp.puts &quot;#include \&quot;AirFormTable.h\&quot;&quot;
 669     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 670     
 671     outp.puts &quot;inline bool opgenHiddenTruth() { return true; }&quot;
 672     outp.puts &quot;template&lt;typename T&gt;&quot;
 673     outp.puts &quot;inline T* opgenHiddenPtrIdentity(T* pointer) { return pointer; }&quot;
 674     outp.puts &quot;#define OPGEN_RETURN(value) do {\\&quot;
 675     outp.puts &quot;    if (opgenHiddenTruth())\\&quot;
 676     outp.puts &quot;        return value;\\&quot;
 677     outp.puts &quot;} while (false)&quot;
 678 
 679     outp.puts &quot;template&lt;typename Functor&gt;&quot;
 680     outp.puts &quot;ALWAYS_INLINE void Inst::forEachArg(const Functor&amp; functor)&quot;
 681     outp.puts &quot;{&quot;
 682     outp.puts &quot;switch (kind.opcode) {&quot;
 683     $opcodes.values.each {
 684         | opcode |
 685         if opcode.custom
 686             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 687         end
 688     }
 689     outp.puts &quot;forEachArgCustom(scopedLambdaRef&lt;EachArgCallback&gt;(functor));&quot;
 690     outp.puts &quot;return;&quot;
 691     outp.puts &quot;default:&quot;
 692     outp.puts &quot;forEachArgSimple(functor);&quot;
 693     outp.puts &quot;return;&quot;
 694     outp.puts &quot;}&quot;
 695     outp.puts &quot;}&quot;
 696     
 697     outp.puts &quot;template&lt;typename Func&gt;&quot;
 698     outp.puts &quot;ALWAYS_INLINE void Inst::forEachArgSimple(const Func&amp; func)&quot;
 699     outp.puts &quot;{&quot;
 700     outp.puts &quot;    size_t numOperands = args.size();&quot;
 701     outp.puts &quot;    size_t formOffset = (numOperands - 1) * numOperands / 2;&quot;
 702     outp.puts &quot;    const uint8_t* formBase = g_formTable + kind.opcode * #{formTableWidth} + formOffset;&quot;
 703     outp.puts &quot;    for (size_t i = 0; i &lt; numOperands; ++i) {&quot;
 704     outp.puts &quot;        uint8_t form = formBase[i];&quot;
 705     outp.puts &quot;        ASSERT(!(form &amp; (1 &lt;&lt; formInvalidShift)));&quot;
 706     outp.puts &quot;        func(args[i], decodeFormRole(form), decodeFormBank(form), decodeFormWidth(form));&quot;
 707     outp.puts &quot;    }&quot;
 708     outp.puts &quot;}&quot;
 709 
 710     outp.puts &quot;template&lt;typename... Arguments&gt;&quot;
 711     outp.puts &quot;ALWAYS_INLINE bool isValidForm(Opcode opcode, Arguments... arguments)&quot;
 712     outp.puts &quot;{&quot;
 713     outp.puts &quot;Arg::Kind kinds[sizeof...(Arguments)] = { arguments... };&quot;
 714     outp.puts &quot;switch (opcode) {&quot;
 715     $opcodes.values.each {
 716         | opcode |
 717         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 718         if opcode.custom
 719             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::isValidFormStatic(arguments...));&quot;
 720         else
 721             outp.puts &quot;switch (sizeof...(Arguments)) {&quot;
 722             opcode.overloads.each {
 723                 | overload |
 724                 outp.puts &quot;case #{overload.signature.length}:&quot;
 725                 columnGetter = proc { | columnIndex | &quot;opgenHiddenPtrIdentity(kinds)[#{columnIndex}]&quot; }
 726                 filter = proc { false }
 727                 callback = proc {
 728                     | form |
 729                     # This conservatively says that Stack is not a valid form for UseAddr,
 730                     # because it&#39;s only valid if it&#39;s not a spill slot. This is consistent with
 731                     # isValidForm() being conservative and it also happens to be practical since
 732                     # we don&#39;t really use isValidForm for deciding when Stack is safe.
 733                     overload.signature.length.times {
 734                         | index |
 735                         if overload.signature[index].role == &quot;UA&quot;
 736                             outp.puts &quot;if (opgenHiddenPtrIdentity(kinds)[#{index}] == Arg::Stack)&quot;
 737                             outp.puts &quot;    return false;&quot;
 738                         end
 739                     }
 740                     
 741                     notCustom = (not form.kinds.detect { | kind | kind.custom })
 742                     if notCustom
 743                         beginArchs(outp, form.archs)
 744                         outp.puts &quot;OPGEN_RETURN(true);&quot;
 745                         endArchs(outp, form.archs)
 746                     end
 747                 }
 748                 matchForms(outp, :safe, overload.forms, 0, columnGetter, filter, callback)
 749                 outp.puts &quot;break;&quot;
 750             }
 751             outp.puts &quot;default:&quot;
 752             outp.puts &quot;break;&quot;
 753             outp.puts &quot;}&quot;
 754         end
 755         outp.puts &quot;break;&quot;
 756     }
 757     outp.puts &quot;default:&quot;
 758     outp.puts &quot;break;&quot;
 759     outp.puts &quot;}&quot;
 760     outp.puts &quot;return false; &quot;
 761     outp.puts &quot;}&quot;
 762 
 763     outp.puts &quot;inline bool isDefinitelyTerminal(Opcode opcode)&quot;
 764     outp.puts &quot;{&quot;
 765     outp.puts &quot;switch (opcode) {&quot;
 766     didFindTerminals = false
 767     $opcodes.values.each {
 768         | opcode |
 769         if opcode.attributes[:terminal]
 770             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 771             didFindTerminals = true
 772         end
 773     }
 774     if didFindTerminals
 775         outp.puts &quot;return true;&quot;
 776     end
 777     outp.puts &quot;default:&quot;
 778     outp.puts &quot;return false;&quot;
 779     outp.puts &quot;}&quot;
 780     outp.puts &quot;}&quot;
 781 
 782     outp.puts &quot;inline bool isReturn(Opcode opcode)&quot;
 783     outp.puts &quot;{&quot;
 784     outp.puts &quot;switch (opcode) {&quot;
 785     didFindReturns = false
 786     $opcodes.values.each {
 787         | opcode |
 788         if opcode.attributes[:return]
 789             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 790             didFindReturns = true
 791         end
 792     }
 793     if didFindReturns
 794         outp.puts &quot;return true;&quot;
 795     end
 796     outp.puts &quot;default:&quot;
 797     outp.puts &quot;return false;&quot;
 798     outp.puts &quot;}&quot;
 799     outp.puts &quot;}&quot;
 800     
 801     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
 802 }
 803 
 804 writeH(&quot;OpcodeGenerated&quot;) {
 805     | outp |
 806     outp.puts &quot;#include \&quot;AirInstInlines.h\&quot;&quot;
 807     outp.puts &quot;#include \&quot;wtf/PrintStream.h\&quot;&quot;
 808     outp.puts &quot;namespace WTF {&quot;
 809     outp.puts &quot;using namespace JSC::B3::Air;&quot;
 810     outp.puts &quot;void printInternal(PrintStream&amp; out, Opcode opcode)&quot;
 811     outp.puts &quot;{&quot;
 812     outp.puts &quot;    switch (opcode) {&quot;
 813     $opcodes.keys.each {
 814         | opcode |
 815         outp.puts &quot;    case Opcode::#{opcode}:&quot;
 816         outp.puts &quot;        out.print(\&quot;#{opcode}\&quot;);&quot;
 817         outp.puts &quot;        return;&quot;
 818     }
 819     outp.puts &quot;    }&quot;
 820     outp.puts &quot;    RELEASE_ASSERT_NOT_REACHED();&quot;
 821     outp.puts &quot;}&quot;
 822     outp.puts &quot;} // namespace WTF&quot;
 823     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 824     
 825     outp.puts &quot;const uint8_t g_formTable[#{$opcodes.size * formTableWidth}] = {&quot;
 826     $opcodes.values.each {
 827         | opcode |
 828         overloads = [nil] * (maxNumOperands + 1)
 829         unless opcode.custom
 830             opcode.overloads.each {
 831                 | overload |
 832                 overloads[overload.signature.length] = overload
 833             }
 834         end
 835         
 836         (0..maxNumOperands).each {
 837             | numOperands |
 838             overload = overloads[numOperands]
 839             if overload
 840                 outp.puts &quot;// #{opcode.name} #{overload.signature.join(&#39;, &#39;)}&quot;
 841                 numOperands.times {
 842                     | index |
 843                     arg = overload.signature[index]
 844                     outp.print &quot;ENCODE_INST_FORM(Arg::#{arg.roleCode}, #{arg.bank}P, #{arg.widthCode}), &quot;
 845                 }
 846             else
 847                 outp.puts &quot;// Invalid: #{opcode.name} with numOperands = #{numOperands}&quot;
 848                 numOperands.times {
 849                     outp.print &quot;INVALID_INST_FORM, &quot;
 850                 }
 851             end
 852             outp.puts
 853         }
 854     }
 855     outp.puts &quot;};&quot;
 856     
 857     outp.puts &quot;void Inst::forEachArgCustom(ScopedLambda&lt;EachArgCallback&gt; lambda)&quot;
 858     outp.puts &quot;{&quot;
 859     outp.puts &quot;switch (kind.opcode) {&quot;
 860     $opcodes.values.each {
 861         | opcode |
 862         if opcode.custom
 863             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 864             outp.puts &quot;#{opcode.name}Custom::forEachArg(*this, lambda);&quot;
 865             outp.puts &quot;break;&quot;
 866         end
 867     }
 868     outp.puts &quot;default:&quot;
 869     outp.puts &quot;dataLog(\&quot;Bad call to forEachArgCustom, not custom opcode: \&quot;, kind, \&quot;\\n\&quot;);&quot;
 870     outp.puts &quot;RELEASE_ASSERT_NOT_REACHED();&quot;
 871     outp.puts &quot;}&quot;
 872     outp.puts &quot;}&quot;
 873     
 874     outp.puts &quot;bool Inst::isValidForm()&quot;
 875     outp.puts &quot;{&quot;
 876     matchInstOverloadForm(outp, :safe, &quot;this&quot;) {
 877         | opcode, overload, form |
 878         if opcode.custom
 879             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::isValidForm(*this));&quot;
 880         else
 881             beginArchs(outp, form.archs)
 882             needsMoreValidation = false
 883             overload.signature.length.times {
 884                 | index |
 885                 arg = overload.signature[index]
 886                 kind = form.kinds[index]
 887                 needsMoreValidation |= kind.custom
 888 
 889                 # Some kinds of Args reqire additional validation.
 890                 case kind.name
 891                 when &quot;Tmp&quot;
 892                     outp.puts &quot;if (!args[#{index}].tmp().is#{arg.bank}P())&quot;
 893                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 894                 when &quot;Imm&quot;
 895                     outp.puts &quot;if (!Arg::isValidImmForm(args[#{index}].value()))&quot;
 896                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 897                 when &quot;BitImm&quot;
 898                     outp.puts &quot;if (!Arg::isValidBitImmForm(args[#{index}].value()))&quot;
 899                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 900                 when &quot;BitImm64&quot;
 901                     outp.puts &quot;if (!Arg::isValidBitImm64Form(args[#{index}].value()))&quot;
 902                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 903                 when &quot;SimpleAddr&quot;
 904                     outp.puts &quot;if (!args[#{index}].ptr().isGP())&quot;
 905                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 906                 when &quot;Addr&quot;
 907                     if arg.role == &quot;UA&quot;
 908                         outp.puts &quot;if (args[#{index}].isStack() &amp;&amp; args[#{index}].stackSlot()-&gt;isSpill())&quot;
 909                         outp.puts &quot;OPGEN_RETURN(false);&quot;
 910                     end
 911                     outp.puts &quot;if (!Arg::isValidAddrForm(args[#{index}].offset()))&quot;
 912                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 913                 when &quot;ExtendedOffsetAddr&quot;
 914                     if arg.role == &quot;UA&quot;
 915                         outp.puts &quot;if (args[#{index}].isStack() &amp;&amp; args[#{index}].stackSlot()-&gt;isSpill())&quot;
 916                         outp.puts &quot;OPGEN_RETURN(false);&quot;
 917                     end
 918                 when &quot;Index&quot;
 919                     outp.puts &quot;if (!Arg::isValidIndexForm(args[#{index}].scale(), args[#{index}].offset(), #{arg.widthCode}))&quot;
 920                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 921                 when &quot;BigImm&quot;
 922                 when &quot;RelCond&quot;
 923                 when &quot;ResCond&quot;
 924                 when &quot;DoubleCond&quot;
 925                 when &quot;StatusCond&quot;
 926                 else
 927                     raise &quot;Unexpected kind: #{kind.name}&quot;
 928                 end
 929             }
 930             if needsMoreValidation
 931                 outp.puts &quot;if (!is#{opcode.name}Valid(*this))&quot;
 932                 outp.puts &quot;OPGEN_RETURN(false);&quot;
 933             end
 934             outp.puts &quot;OPGEN_RETURN(true);&quot;
 935             endArchs(outp, form.archs)
 936         end
 937     }
 938     outp.puts &quot;return false;&quot;
 939     outp.puts &quot;}&quot;
 940 
 941     outp.puts &quot;bool Inst::admitsStack(unsigned argIndex)&quot;
 942     outp.puts &quot;{&quot;
 943     outp.puts &quot;switch (kind.opcode) {&quot;
 944     $opcodes.values.each {
 945         | opcode |
 946         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 947 
 948         if opcode.custom
 949             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::admitsStack(*this, argIndex));&quot;
 950         else
 951             # Switch on the argIndex.
 952             outp.puts &quot;switch (argIndex) {&quot;
 953 
 954             numArgs = opcode.overloads.map {
 955                 | overload |
 956                 overload.signature.length
 957             }.max
 958             
 959             numArgs.times {
 960                 | argIndex |
 961                 outp.puts &quot;case #{argIndex}:&quot;
 962 
 963                 # Check if all of the forms of all of the overloads either do, or don&#39;t, admit an address
 964                 # at this index. We expect this to be a very common case.
 965                 numYes = 0
 966                 numNo = 0
 967                 opcode.overloads.each {
 968                     | overload |
 969                     useAddr = (overload.signature[argIndex] and
 970                                overload.signature[argIndex].role == &quot;UA&quot;)
 971                     overload.forms.each {
 972                         | form |
 973                         if form.kinds[argIndex] == &quot;Addr&quot; and not useAddr
 974                             numYes += 1
 975                         else
 976                             numNo += 1
 977                         end
 978                     }
 979                 }
 980 
 981                 # Note that we deliberately test numYes first because if we end up with no forms, we want
 982                 # to say that Address is inadmissible.
 983                 if numYes == 0
 984                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 985                 elsif numNo == 0
 986                     outp.puts &quot;OPGEN_RETURN(true);&quot;
 987                 else
 988                     # Now do the full test.
 989 
 990                     needOverloadSwitch = (opcode.overloads.size != 1)
 991 
 992                     outp.puts &quot;switch (args.size()) {&quot; if needOverloadSwitch
 993                     opcode.overloads.each {
 994                         | overload |
 995 
 996                         useAddr = (overload.signature[argIndex] and
 997                                    overload.signature[argIndex].role == &quot;UA&quot;)
 998                         
 999                         # Again, check if all of them do what we want.
1000                         numYes = 0
1001                         numNo = 0
1002                         overload.forms.each {
1003                             | form |
1004                             if form.kinds[argIndex] == &quot;Addr&quot; and not useAddr
1005                                 numYes += 1
1006                             else
1007                                 numNo += 1
1008                             end
1009                         }
1010 
1011                         if numYes == 0
1012                             # Don&#39;t emit anything, just drop to default.
1013                         elsif numNo == 0
1014                             outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
1015                             outp.puts &quot;OPGEN_RETURN(true);&quot;
1016                             outp.puts &quot;break;&quot; if needOverloadSwitch
1017                         else
1018                             outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
1019 
1020                             # This is how we test the hypothesis that changing this argument to an
1021                             # address yields a valid form.
1022                             columnGetter = proc {
1023                                 | columnIndex |
1024                                 if columnIndex == argIndex
1025                                     &quot;Arg::Addr&quot;
1026                                 else
1027                                     &quot;args[#{columnIndex}].kind()&quot;
1028                                 end
1029                             }
1030                             filter = proc {
1031                                 | forms |
1032                                 numYes = 0
1033 
1034                                 forms.each {
1035                                     | form |
1036                                     if form.kinds[argIndex] == &quot;Addr&quot;
1037                                         numYes += 1
1038                                     end
1039                                 }
1040 
1041                                 if numYes == 0
1042                                     # Drop down, emit no code, since we cannot match.
1043                                     true
1044                                 else
1045                                     # Keep going.
1046                                     false
1047                                 end
1048                             }
1049                             callback = proc {
1050                                 | form |
1051                                 beginArchs(outp, form.archs)
1052                                 outp.puts &quot;OPGEN_RETURN(true);&quot;
1053                                 endArchs(outp, form.archs)
1054                             }
1055                             matchForms(outp, :safe, overload.forms, 0, columnGetter, filter, callback)
1056 
1057                             outp.puts &quot;break;&quot; if needOverloadSwitch
1058                         end
1059                     }
1060                     if needOverloadSwitch
1061                         outp.puts &quot;default:&quot;
1062                         outp.puts &quot;break;&quot;
1063                         outp.puts &quot;}&quot;
1064                     end
1065                 end
1066                 
1067                 outp.puts &quot;break;&quot;
1068             }
1069             
1070             outp.puts &quot;default:&quot;
1071             outp.puts &quot;break;&quot;
1072             outp.puts &quot;}&quot;
1073         end
1074         
1075         outp.puts &quot;break;&quot;
1076     }
1077     outp.puts &quot;default:&quot;;
1078     outp.puts &quot;break;&quot;
1079     outp.puts &quot;}&quot;
1080     outp.puts &quot;return false;&quot;
1081     outp.puts &quot;}&quot;
1082 
1083     outp.puts &quot;bool Inst::admitsExtendedOffsetAddr(unsigned argIndex)&quot;
1084     outp.puts &quot;{&quot;
1085     outp.puts &quot;switch (kind.opcode) {&quot;
1086     $opcodes.values.each {
1087         | opcode |
1088         if opcode.custom
1089             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1090             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::admitsExtendedOffsetAddr(*this, argIndex));&quot;
1091             outp.puts &quot;break;&quot;
1092         end
1093     }
1094     outp.puts &quot;default:&quot;
1095     outp.puts &quot;break;&quot;
1096     outp.puts &quot;}&quot;
1097     outp.puts &quot;return false;&quot;
1098     outp.puts &quot;}&quot;
1099 
1100 
1101     outp.puts &quot;bool Inst::isTerminal()&quot;
1102     outp.puts &quot;{&quot;
1103     outp.puts &quot;switch (kind.opcode) {&quot;
1104     foundTrue = false
1105     $opcodes.values.each {
1106         | opcode |
1107         if opcode.attributes[:terminal]
1108             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1109             foundTrue = true
1110         end
1111     }
1112     if foundTrue
1113         outp.puts &quot;return true;&quot;
1114     end
1115     $opcodes.values.each {
1116         | opcode |
1117         if opcode.custom
1118             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1119             outp.puts &quot;return #{opcode.name}Custom::isTerminal(*this);&quot;
1120         end
1121     }
1122     outp.puts &quot;default:&quot;
1123     outp.puts &quot;return false;&quot;
1124     outp.puts &quot;}&quot;
1125     outp.puts &quot;}&quot;
1126     
1127     outp.puts &quot;bool Inst::hasNonArgNonControlEffects()&quot;
1128     outp.puts &quot;{&quot;
1129     outp.puts &quot;if (kind.effects)&quot;
1130     outp.puts &quot;return true;&quot;
1131     outp.puts &quot;switch (kind.opcode) {&quot;
1132     foundTrue = false
1133     $opcodes.values.each {
1134         | opcode |
1135         if opcode.attributes[:effects]
1136             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1137             foundTrue = true
1138         end
1139     }
1140     if foundTrue
1141         outp.puts &quot;return true;&quot;
1142     end
1143     $opcodes.values.each {
1144         | opcode |
1145         if opcode.custom
1146             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1147             outp.puts &quot;return #{opcode.name}Custom::hasNonArgNonControlEffects(*this);&quot;
1148         end
1149     }
1150     outp.puts &quot;default:&quot;
1151     outp.puts &quot;return false;&quot;
1152     outp.puts &quot;}&quot;
1153     outp.puts &quot;}&quot;
1154     
1155     outp.puts &quot;bool Inst::hasNonArgEffects()&quot;
1156     outp.puts &quot;{&quot;
1157     outp.puts &quot;if (kind.effects)&quot;
1158     outp.puts &quot;return true;&quot;
1159     outp.puts &quot;switch (kind.opcode) {&quot;
1160     foundTrue = false
1161     $opcodes.values.each {
1162         | opcode |
1163         if opcode.attributes[:terminal] or opcode.attributes[:effects]
1164             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1165             foundTrue = true
1166         end
1167     }
1168     if foundTrue
1169         outp.puts &quot;return true;&quot;
1170     end
1171     $opcodes.values.each {
1172         | opcode |
1173         if opcode.custom
1174             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1175             outp.puts &quot;return #{opcode.name}Custom::hasNonArgEffects(*this);&quot;
1176         end
1177     }
1178     outp.puts &quot;default:&quot;
1179     outp.puts &quot;return false;&quot;
1180     outp.puts &quot;}&quot;
1181     outp.puts &quot;}&quot;
1182     
1183     outp.puts &quot;CCallHelpers::Jump Inst::generate(CCallHelpers&amp; jit, GenerationContext&amp; context)&quot;
1184     outp.puts &quot;{&quot;
1185     outp.puts &quot;UNUSED_PARAM(jit);&quot;
1186     outp.puts &quot;UNUSED_PARAM(context);&quot;
1187     outp.puts &quot;CCallHelpers::Jump result;&quot;
1188     matchInstOverloadForm(outp, :fast, &quot;this&quot;) {
1189         | opcode, overload, form |
1190         if opcode.custom
1191             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::generate(*this, jit, context));&quot;
1192         else
1193             beginArchs(outp, form.archs)
1194             if form.altName
1195                 methodName = form.altName
1196             else
1197                 methodName = opcode.masmName
1198             end
1199             if opcode.attributes[:branch]
1200                 outp.print &quot;result = &quot;
1201             end
1202             outp.print &quot;jit.#{methodName}(&quot;
1203 
1204             form.kinds.each_with_index {
1205                 | kind, index |
1206                 if index != 0
1207                     outp.print &quot;, &quot;
1208                 end
1209                 case kind.name
1210                 when &quot;Tmp&quot;
1211                     if overload.signature[index].bank == &quot;G&quot;
1212                         outp.print &quot;args[#{index}].gpr()&quot;
1213                     else
1214                         outp.print &quot;args[#{index}].fpr()&quot;
1215                     end
1216                 when &quot;Imm&quot;, &quot;BitImm&quot;
1217                     outp.print &quot;args[#{index}].asTrustedImm32()&quot;
1218                 when &quot;BigImm&quot;, &quot;BitImm64&quot;
1219                     outp.print &quot;args[#{index}].asTrustedImm64()&quot;
1220                 when &quot;SimpleAddr&quot;, &quot;Addr&quot;, &quot;ExtendedOffsetAddr&quot;
1221                     outp.print &quot;args[#{index}].asAddress()&quot;
1222                 when &quot;Index&quot;
1223                     outp.print &quot;args[#{index}].asBaseIndex()&quot;
1224                 when &quot;RelCond&quot;
1225                     outp.print &quot;args[#{index}].asRelationalCondition()&quot;
1226                 when &quot;ResCond&quot;
1227                     outp.print &quot;args[#{index}].asResultCondition()&quot;
1228                 when &quot;DoubleCond&quot;
1229                     outp.print &quot;args[#{index}].asDoubleCondition()&quot;
1230                 when &quot;StatusCond&quot;
1231                     outp.print &quot;args[#{index}].asStatusCondition()&quot;
1232                 end
1233             }
1234 
1235             outp.puts &quot;);&quot;
1236             outp.puts &quot;OPGEN_RETURN(result);&quot;
1237             endArchs(outp, form.archs)
1238         end
1239     }
1240     outp.puts &quot;RELEASE_ASSERT_NOT_REACHED();&quot;
1241     outp.puts &quot;return result;&quot;
1242     outp.puts &quot;}&quot;
1243 
1244     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
1245 }
1246 
    </pre>
  </body>
</html>
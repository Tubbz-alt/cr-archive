<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Error.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  5  *  Copyright (C) 2007 Eric Seidel (eric@webkit.org)
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Library General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Library General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Library General Public License
 18  *  along with this library; see the file COPYING.LIB.  If not, write to
 19  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  *  Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;Error.h&quot;
 26 
 27 #include &quot;ConstructData.h&quot;
 28 #include &quot;ErrorConstructor.h&quot;
 29 #include &quot;ExceptionHelpers.h&quot;
 30 #include &quot;FunctionPrototype.h&quot;
 31 #include &quot;Interpreter.h&quot;
 32 #include &quot;JSArray.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSFunction.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSObject.h&quot;
 37 #include &quot;JSString.h&quot;
 38 #include &quot;NativeErrorConstructor.h&quot;
 39 #include &quot;SourceCode.h&quot;
 40 #include &quot;StackFrame.h&quot;
 41 #include &quot;SuperSampler.h&quot;
 42 
 43 namespace JSC {
 44 
 45 JSObject* createError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 46 {
 47     ASSERT(!message.isEmpty());
 48     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(), message, appender, TypeNothing, true);
 49 }
 50 
 51 JSObject* createEvalError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 52 {
 53     ASSERT(!message.isEmpty());
 54     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::EvalError), message, appender, TypeNothing, true);
 55 }
 56 
 57 JSObject* createRangeError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 58 {
 59     ASSERT(!message.isEmpty());
 60     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::RangeError), message, appender, TypeNothing, true);
 61 }
 62 
 63 JSObject* createReferenceError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 64 {
 65     ASSERT(!message.isEmpty());
 66     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::ReferenceError), message, appender, TypeNothing, true);
 67 }
 68 
 69 JSObject* createSyntaxError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 70 {
 71     ASSERT(!message.isEmpty());
 72     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::SyntaxError), message, appender, TypeNothing, true);
 73 }
 74 
 75 JSObject* createTypeError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender, RuntimeType type)
 76 {
 77     ASSERT(!message.isEmpty());
 78     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message, appender, type, true);
 79 }
 80 
 81 JSObject* createNotEnoughArgumentsError(JSGlobalObject* globalObject, ErrorInstance::SourceAppender appender)
 82 {
 83     return createTypeError(globalObject, &quot;Not enough arguments&quot;_s, appender, TypeNothing);
 84 }
 85 
 86 JSObject* createURIError(JSGlobalObject* globalObject, const String&amp; message, ErrorInstance::SourceAppender appender)
 87 {
 88     ASSERT(!message.isEmpty());
 89     return ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::URIError), message, appender, TypeNothing, true);
 90 }
 91 
 92 JSObject* createError(JSGlobalObject* globalObject, ErrorType errorType, const String&amp; message)
 93 {
 94     switch (errorType) {
 95     case ErrorType::Error:
 96         return createError(globalObject, message);
 97     case ErrorType::EvalError:
 98         return createEvalError(globalObject, message);
 99     case ErrorType::RangeError:
100         return createRangeError(globalObject, message);
101     case ErrorType::ReferenceError:
102         return createReferenceError(globalObject, message);
103     case ErrorType::SyntaxError:
104         return createSyntaxError(globalObject, message);
105     case ErrorType::TypeError:
106         return createTypeError(globalObject, message);
107     case ErrorType::URIError:
108         return createURIError(globalObject, message);
109     }
110     ASSERT_NOT_REACHED();
111     return nullptr;
112 }
113 
114 JSObject* createGetterTypeError(JSGlobalObject* globalObject, const String&amp; message)
115 {
116     ASSERT(!message.isEmpty());
117     auto* error = ErrorInstance::create(globalObject, globalObject-&gt;vm(), globalObject-&gt;errorStructure(ErrorType::TypeError), message);
118     error-&gt;setNativeGetterTypeError();
119     return error;
120 }
121 
122 class FindFirstCallerFrameWithCodeblockFunctor {
123 public:
124     FindFirstCallerFrameWithCodeblockFunctor(CallFrame* startCallFrame)
125         : m_startCallFrame(startCallFrame)
126         , m_foundCallFrame(nullptr)
127         , m_foundStartCallFrame(false)
128         , m_index(0)
129     { }
130 
131     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
132     {
133         if (!m_foundStartCallFrame &amp;&amp; (visitor-&gt;callFrame() == m_startCallFrame))
134             m_foundStartCallFrame = true;
135 
136         if (m_foundStartCallFrame) {
137             if (!visitor-&gt;isWasmFrame() &amp;&amp; visitor-&gt;callFrame()-&gt;codeBlock()) {
138                 m_foundCallFrame = visitor-&gt;callFrame();
139                 return StackVisitor::Done;
140             }
141             m_index++;
142         }
143 
144         return StackVisitor::Continue;
145     }
146 
147     CallFrame* foundCallFrame() const { return m_foundCallFrame; }
148     unsigned index() const { return m_index; }
149 
150 private:
151     CallFrame* m_startCallFrame;
152     mutable CallFrame* m_foundCallFrame;
153     mutable bool m_foundStartCallFrame;
154     mutable unsigned m_index;
155 };
156 
157 std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; getStackTrace(JSGlobalObject*, VM&amp; vm, JSObject* obj, bool useCurrentFrame)
158 {
159     JSGlobalObject* globalObject = obj-&gt;globalObject(vm);
160     if (!globalObject-&gt;stackTraceLimit())
161         return nullptr;
162 
163     size_t framesToSkip = useCurrentFrame ? 0 : 1;
164     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = makeUnique&lt;Vector&lt;StackFrame&gt;&gt;();
165     vm.interpreter-&gt;getStackTrace(obj, *stackTrace, framesToSkip, globalObject-&gt;stackTraceLimit().value());
166     return stackTrace;
167 }
168 
169 void getBytecodeIndex(VM&amp; vm, CallFrame* startCallFrame, Vector&lt;StackFrame&gt;* stackTrace, CallFrame*&amp; callFrame, BytecodeIndex&amp; bytecodeIndex)
170 {
171     FindFirstCallerFrameWithCodeblockFunctor functor(startCallFrame);
172     StackVisitor::visit(vm.topCallFrame, vm, functor);
173     callFrame = functor.foundCallFrame();
174     unsigned stackIndex = functor.index();
175     bytecodeIndex = BytecodeIndex(0);
176     if (stackTrace &amp;&amp; stackIndex &lt; stackTrace-&gt;size() &amp;&amp; stackTrace-&gt;at(stackIndex).hasBytecodeIndex())
177         bytecodeIndex = stackTrace-&gt;at(stackIndex).bytecodeIndex();
178 }
179 
180 bool getLineColumnAndSource(Vector&lt;StackFrame&gt;* stackTrace, unsigned&amp; line, unsigned&amp; column, String&amp; sourceURL)
181 {
182     line = 0;
183     column = 0;
184     sourceURL = String();
185 
186     if (!stackTrace)
187         return false;
188 
189     for (unsigned i = 0 ; i &lt; stackTrace-&gt;size(); ++i) {
190         StackFrame&amp; frame = stackTrace-&gt;at(i);
191         if (frame.hasLineAndColumnInfo()) {
192             frame.computeLineAndColumn(line, column);
193             sourceURL = frame.sourceURL();
194             return true;
195         }
196     }
197 
198     return false;
199 }
200 
201 bool addErrorInfo(VM&amp; vm, Vector&lt;StackFrame&gt;* stackTrace, JSObject* obj)
202 {
203     if (!stackTrace)
204         return false;
205 
206     if (!stackTrace-&gt;isEmpty()) {
207         unsigned line;
208         unsigned column;
209         String sourceURL;
210         getLineColumnAndSource(stackTrace, line, column, sourceURL);
211         obj-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
212         obj-&gt;putDirect(vm, vm.propertyNames-&gt;column, jsNumber(column));
213         if (!sourceURL.isEmpty())
214             obj-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
215 
216         obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, Interpreter::stackTraceAsString(vm, *stackTrace)), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
217 
218         return true;
219     }
220 
221     obj-&gt;putDirect(vm, vm.propertyNames-&gt;stack, vm.smallStrings.emptyString(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
222     return false;
223 }
224 
225 void addErrorInfo(JSGlobalObject* globalObject, JSObject* obj, bool useCurrentFrame)
226 {
227     VM&amp; vm = globalObject-&gt;vm();
228     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(globalObject, vm, obj, useCurrentFrame);
229     addErrorInfo(vm, stackTrace.get(), obj);
230 }
231 
232 JSObject* addErrorInfo(VM&amp; vm, JSObject* error, int line, const SourceCode&amp; source)
233 {
234     const String&amp; sourceURL = source.provider()-&gt;url();
235 
236     // The putDirect() calls below should really be put() so that they trigger materialization of
237     // the line/sourceURL properties. Otherwise, what we set here will just be overwritten later.
238     // But calling put() would be bad because we&#39;d rather not do effectful things here. Luckily, we
239     // know that this will get called on some kind of error - so we can just directly ask the
240     // ErrorInstance to materialize whatever it needs to. There&#39;s a chance that we get passed some
241     // other kind of object, which also has materializable properties. But this code is heuristic-ey
242     // enough that if we&#39;re wrong in such corner cases, it&#39;s not the end of the world.
243     if (ErrorInstance* errorInstance = jsDynamicCast&lt;ErrorInstance*&gt;(vm, error))
244         errorInstance-&gt;materializeErrorInfoIfNeeded(vm);
245 
246     // FIXME: This does not modify the column property, which confusingly continues to reflect
247     // the column at which the exception was thrown.
248     // https://bugs.webkit.org/show_bug.cgi?id=176673
249     if (line != -1)
250         error-&gt;putDirect(vm, vm.propertyNames-&gt;line, jsNumber(line));
251     if (!sourceURL.isNull())
252         error-&gt;putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, sourceURL));
253     return error;
254 }
255 
256 Exception* throwConstructorCannotBeCalledAsFunctionTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const char* constructorName)
257 {
258     return throwTypeError(globalObject, scope, makeString(&quot;calling &quot;, constructorName, &quot; constructor without new is invalid&quot;));
259 }
260 
261 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope)
262 {
263     return throwException(globalObject, scope, createTypeError(globalObject));
264 }
265 
266 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, ASCIILiteral errorMessage)
267 {
268     return throwTypeError(globalObject, scope, String(errorMessage));
269 }
270 
271 Exception* throwTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)
272 {
273     return throwException(globalObject, scope, createTypeError(globalObject, message));
274 }
275 
276 Exception* throwSyntaxError(JSGlobalObject* globalObject, ThrowScope&amp; scope)
277 {
278     return throwException(globalObject, scope, createSyntaxError(globalObject, &quot;Syntax error&quot;_s));
279 }
280 
281 Exception* throwSyntaxError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)
282 {
283     return throwException(globalObject, scope, createSyntaxError(globalObject, message));
284 }
285 
286 Exception* throwGetterTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const String&amp; message)
287 {
288     return throwException(globalObject, scope, createGetterTypeError(globalObject, message));
289 }
290 
291 JSValue throwDOMAttributeGetterTypeError(JSGlobalObject* globalObject, ThrowScope&amp; scope, const ClassInfo* classInfo, PropertyName propertyName)
292 {
293     return throwGetterTypeError(globalObject, scope, makeString(&quot;The &quot;, classInfo-&gt;className, &#39;.&#39;, String(propertyName.uid()), &quot; getter can only be used on instances of &quot;, classInfo-&gt;className));
294 }
295 
296 JSObject* createError(JSGlobalObject* globalObject, const String&amp; message)
297 {
298     return createError(globalObject, message, nullptr);
299 }
300 
301 JSObject* createEvalError(JSGlobalObject* globalObject, const String&amp; message)
302 {
303     return createEvalError(globalObject, message, nullptr);
304 }
305 
306 JSObject* createRangeError(JSGlobalObject* globalObject, const String&amp; message)
307 {
308     return createRangeError(globalObject, message, nullptr);
309 }
310 
311 JSObject* createReferenceError(JSGlobalObject* globalObject, const String&amp; message)
312 {
313     return createReferenceError(globalObject, message, nullptr);
314 }
315 
316 JSObject* createSyntaxError(JSGlobalObject* globalObject, const String&amp; message)
317 {
318     return createSyntaxError(globalObject, message, nullptr);
319 }
320 
321 JSObject* createTypeError(JSGlobalObject* globalObject)
322 {
323     return createTypeError(globalObject, &quot;Type error&quot;_s);
324 }
325 
326 JSObject* createTypeError(JSGlobalObject* globalObject, const String&amp; message)
327 {
328     return createTypeError(globalObject, message, nullptr, TypeNothing);
329 }
330 
331 JSObject* createNotEnoughArgumentsError(JSGlobalObject* globalObject)
332 {
333     return createNotEnoughArgumentsError(globalObject, nullptr);
334 }
335 
336 JSObject* createURIError(JSGlobalObject* globalObject, const String&amp; message)
337 {
338     return createURIError(globalObject, message, nullptr);
339 }
340 
341 JSObject* createOutOfMemoryError(JSGlobalObject* globalObject)
342 {
343     auto* error = createError(globalObject, &quot;Out of memory&quot;_s, nullptr);
344     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
345     return error;
346 }
347 
348 JSObject* createOutOfMemoryError(JSGlobalObject* globalObject, const String&amp; message)
349 {
350 
351     auto* error = createError(globalObject, makeString(&quot;Out of memory: &quot;, message), nullptr);
352     jsCast&lt;ErrorInstance*&gt;(error)-&gt;setOutOfMemoryError();
353     return error;
354 }
355 
356 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGRenderTreeAsText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderingContext.h&quot;
 28 
 29 #include &quot;BasicShapes.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameView.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderSVGImage.h&quot;
 34 #include &quot;RenderSVGResourceClipper.h&quot;
 35 #include &quot;RenderSVGResourceFilter.h&quot;
 36 #include &quot;RenderSVGResourceMasker.h&quot;
 37 #include &quot;RenderView.h&quot;
 38 #include &quot;SVGLengthContext.h&quot;
 39 #include &quot;SVGResources.h&quot;
 40 #include &quot;SVGResourcesCache.h&quot;

 41 
 42 namespace WebCore {
 43 
 44 static inline bool isRenderingMaskImage(const RenderObject&amp; object)
 45 {
 46     return object.view().frameView().paintBehavior().contains(PaintBehavior::RenderingSVGMask);
 47 }
 48 
 49 SVGRenderingContext::~SVGRenderingContext()
 50 {
 51     // Fast path if we don&#39;t need to restore anything.
 52     if (!(m_renderingFlags &amp; ActionsNeeded))
 53         return;
 54 
 55     ASSERT(m_renderer &amp;&amp; m_paintInfo);
 56 
 57     if (m_renderingFlags &amp; EndFilterLayer) {
 58         ASSERT(m_filter);
 59         GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
 60         m_filter-&gt;postApplyResource(*m_renderer, contextPtr, { }, nullptr, nullptr);
</pre>
<hr />
<pre>
184             // Since we&#39;re caching the resulting bitmap and do not invalidate it on repaint rect
185             // changes, we need to paint the whole filter region. Otherwise, elements not visible
186             // at the time of the initial paint (due to scrolling, window size, etc.) will never
187             // be drawn.
188             m_paintInfo-&gt;rect = IntRect(m_filter-&gt;drawingRegion(m_renderer));
189         }
190     }
191 
192     m_renderingFlags |= RenderingPrepared;
193 }
194 
195 static AffineTransform&amp; currentContentTransformation()
196 {
197     static NeverDestroyed&lt;AffineTransform&gt; s_currentContentTransformation;
198     return s_currentContentTransformation;
199 }
200 
201 float SVGRenderingContext::calculateScreenFontSizeScalingFactor(const RenderObject&amp; renderer)
202 {
203     AffineTransform ctm = calculateTransformationToOutermostCoordinateSystem(renderer);
<span class="line-modified">204     return narrowPrecisionToFloat(sqrt((pow(ctm.xScale(), 2) + pow(ctm.yScale(), 2)) / 2));</span>
205 }
206 
207 AffineTransform SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(const RenderObject&amp; renderer)
208 {
209     AffineTransform absoluteTransform = currentContentTransformation();
210 
211     float deviceScaleFactor = renderer.document().deviceScaleFactor();
212     // Walk up the render tree, accumulating SVG transforms.
213     const RenderObject* ancestor = &amp;renderer;
214     while (ancestor) {
215         absoluteTransform = ancestor-&gt;localToParentTransform() * absoluteTransform;
216         if (ancestor-&gt;isSVGRoot())
217             break;
218         ancestor = ancestor-&gt;parent();
219     }
220 
221     // Continue walking up the layer tree, accumulating CSS transforms.
222     RenderLayer* layer = ancestor ? ancestor-&gt;enclosingLayer() : nullptr;
223     while (layer) {
224         if (TransformationMatrix* layerTransform = layer-&gt;transform())
</pre>
<hr />
<pre>
334     transform.recompose(decomposition);
335 }
336 
337 bool SVGRenderingContext::bufferForeground(std::unique_ptr&lt;ImageBuffer&gt;&amp; imageBuffer)
338 {
339     ASSERT(m_paintInfo);
340     ASSERT(is&lt;RenderSVGImage&gt;(*m_renderer));
341     FloatRect boundingBox = m_renderer-&gt;objectBoundingBox();
342 
343     // Invalidate an existing buffer if the scale is not correct.
344     if (imageBuffer) {
345         AffineTransform transform = m_paintInfo-&gt;context().getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
346         IntSize expandedBoundingBox = expandedIntSize(boundingBox.size());
347         IntSize bufferSize(static_cast&lt;int&gt;(ceil(expandedBoundingBox.width() * transform.xScale())), static_cast&lt;int&gt;(ceil(expandedBoundingBox.height() * transform.yScale())));
348         if (bufferSize != imageBuffer-&gt;internalSize())
349             imageBuffer.reset();
350     }
351 
352     // Create a new buffer and paint the foreground into it.
353     if (!imageBuffer) {
<span class="line-modified">354         if ((imageBuffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(boundingBox.size()), ColorSpaceSRGB, m_paintInfo-&gt;context()))) {</span>
355             GraphicsContext&amp; bufferedRenderingContext = imageBuffer-&gt;context();
356             bufferedRenderingContext.translate(-boundingBox.location());
357             PaintInfo bufferedInfo(*m_paintInfo);
358             bufferedInfo.setContext(bufferedRenderingContext);
359             downcast&lt;RenderSVGImage&gt;(*m_renderer).paintForeground(bufferedInfo);
360         } else
361             return false;
362     }
363 
364     m_paintInfo-&gt;context().drawImageBuffer(*imageBuffer, boundingBox);
365     return true;
366 }
367 
368 }
</pre>
</td>
<td>
<hr />
<pre>
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGRenderingContext.h&quot;
 28 
 29 #include &quot;BasicShapes.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameView.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderSVGImage.h&quot;
 34 #include &quot;RenderSVGResourceClipper.h&quot;
 35 #include &quot;RenderSVGResourceFilter.h&quot;
 36 #include &quot;RenderSVGResourceMasker.h&quot;
 37 #include &quot;RenderView.h&quot;
 38 #include &quot;SVGLengthContext.h&quot;
 39 #include &quot;SVGResources.h&quot;
 40 #include &quot;SVGResourcesCache.h&quot;
<span class="line-added"> 41 #include &lt;wtf/MathExtras.h&gt;</span>
 42 
 43 namespace WebCore {
 44 
 45 static inline bool isRenderingMaskImage(const RenderObject&amp; object)
 46 {
 47     return object.view().frameView().paintBehavior().contains(PaintBehavior::RenderingSVGMask);
 48 }
 49 
 50 SVGRenderingContext::~SVGRenderingContext()
 51 {
 52     // Fast path if we don&#39;t need to restore anything.
 53     if (!(m_renderingFlags &amp; ActionsNeeded))
 54         return;
 55 
 56     ASSERT(m_renderer &amp;&amp; m_paintInfo);
 57 
 58     if (m_renderingFlags &amp; EndFilterLayer) {
 59         ASSERT(m_filter);
 60         GraphicsContext* contextPtr = &amp;m_paintInfo-&gt;context();
 61         m_filter-&gt;postApplyResource(*m_renderer, contextPtr, { }, nullptr, nullptr);
</pre>
<hr />
<pre>
185             // Since we&#39;re caching the resulting bitmap and do not invalidate it on repaint rect
186             // changes, we need to paint the whole filter region. Otherwise, elements not visible
187             // at the time of the initial paint (due to scrolling, window size, etc.) will never
188             // be drawn.
189             m_paintInfo-&gt;rect = IntRect(m_filter-&gt;drawingRegion(m_renderer));
190         }
191     }
192 
193     m_renderingFlags |= RenderingPrepared;
194 }
195 
196 static AffineTransform&amp; currentContentTransformation()
197 {
198     static NeverDestroyed&lt;AffineTransform&gt; s_currentContentTransformation;
199     return s_currentContentTransformation;
200 }
201 
202 float SVGRenderingContext::calculateScreenFontSizeScalingFactor(const RenderObject&amp; renderer)
203 {
204     AffineTransform ctm = calculateTransformationToOutermostCoordinateSystem(renderer);
<span class="line-modified">205     return narrowPrecisionToFloat(std::hypot(ctm.xScale(), ctm.yScale()) / sqrtOfTwoDouble);</span>
206 }
207 
208 AffineTransform SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(const RenderObject&amp; renderer)
209 {
210     AffineTransform absoluteTransform = currentContentTransformation();
211 
212     float deviceScaleFactor = renderer.document().deviceScaleFactor();
213     // Walk up the render tree, accumulating SVG transforms.
214     const RenderObject* ancestor = &amp;renderer;
215     while (ancestor) {
216         absoluteTransform = ancestor-&gt;localToParentTransform() * absoluteTransform;
217         if (ancestor-&gt;isSVGRoot())
218             break;
219         ancestor = ancestor-&gt;parent();
220     }
221 
222     // Continue walking up the layer tree, accumulating CSS transforms.
223     RenderLayer* layer = ancestor ? ancestor-&gt;enclosingLayer() : nullptr;
224     while (layer) {
225         if (TransformationMatrix* layerTransform = layer-&gt;transform())
</pre>
<hr />
<pre>
335     transform.recompose(decomposition);
336 }
337 
338 bool SVGRenderingContext::bufferForeground(std::unique_ptr&lt;ImageBuffer&gt;&amp; imageBuffer)
339 {
340     ASSERT(m_paintInfo);
341     ASSERT(is&lt;RenderSVGImage&gt;(*m_renderer));
342     FloatRect boundingBox = m_renderer-&gt;objectBoundingBox();
343 
344     // Invalidate an existing buffer if the scale is not correct.
345     if (imageBuffer) {
346         AffineTransform transform = m_paintInfo-&gt;context().getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
347         IntSize expandedBoundingBox = expandedIntSize(boundingBox.size());
348         IntSize bufferSize(static_cast&lt;int&gt;(ceil(expandedBoundingBox.width() * transform.xScale())), static_cast&lt;int&gt;(ceil(expandedBoundingBox.height() * transform.yScale())));
349         if (bufferSize != imageBuffer-&gt;internalSize())
350             imageBuffer.reset();
351     }
352 
353     // Create a new buffer and paint the foreground into it.
354     if (!imageBuffer) {
<span class="line-modified">355         if ((imageBuffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(boundingBox.size()), ColorSpace::SRGB, m_paintInfo-&gt;context()))) {</span>
356             GraphicsContext&amp; bufferedRenderingContext = imageBuffer-&gt;context();
357             bufferedRenderingContext.translate(-boundingBox.location());
358             PaintInfo bufferedInfo(*m_paintInfo);
359             bufferedInfo.setContext(bufferedRenderingContext);
360             downcast&lt;RenderSVGImage&gt;(*m_renderer).paintForeground(bufferedInfo);
361         } else
362             return false;
363     }
364 
365     m_paintInfo-&gt;context().drawImageBuffer(*imageBuffer, boundingBox);
366     return true;
367 }
368 
369 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGRenderTreeAsText.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
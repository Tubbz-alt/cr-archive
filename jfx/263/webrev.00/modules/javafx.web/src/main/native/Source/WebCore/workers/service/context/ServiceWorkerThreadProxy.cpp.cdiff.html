<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThreadProxy.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,20 ***</span>
  #include &quot;ServiceWorkerThreadProxy.h&quot;
  
  #if ENABLE(SERVICE_WORKER)
  
  #include &quot;CacheStorageProvider.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;FetchLoader.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;PlatformStrategies.h&quot;
  #include &quot;ServiceWorkerClientIdentifier.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;WorkerGlobalScope.h&quot;
<span class="line-removed">- #include &lt;pal/SessionID.h&gt;</span>
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/RunLoop.h&gt;
  
  namespace WebCore {
  
<span class="line-new-header">--- 27,22 ---</span>
  #include &quot;ServiceWorkerThreadProxy.h&quot;
  
  #if ENABLE(SERVICE_WORKER)
  
  #include &quot;CacheStorageProvider.h&quot;
<span class="line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;EventNames.h&quot;
  #include &quot;FetchLoader.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;LoaderStrategy.h&quot;
<span class="line-added">+ #include &quot;MessageWithMessagePorts.h&quot;</span>
  #include &quot;PlatformStrategies.h&quot;
<span class="line-added">+ #include &quot;ServiceWorkerClientData.h&quot;</span>
  #include &quot;ServiceWorkerClientIdentifier.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;WorkerGlobalScope.h&quot;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/RunLoop.h&gt;
  
  namespace WebCore {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,14 ***</span>
      if (origin.port())
          url.setPort(*origin.port());
      return url;
  }
  
<span class="line-modified">! static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy, PAL::SessionID sessionID)</span>
  {
      auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));
<span class="line-removed">-     page-&gt;setSessionID(sessionID);</span>
  
      auto&amp; mainFrame = page-&gt;mainFrame();
      mainFrame.loader().initForSynthesizedDocument({ });
      auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
      document-&gt;createDOMWindow();
<span class="line-new-header">--- 54,13 ---</span>
      if (origin.port())
          url.setPort(*origin.port());
      return url;
  }
  
<span class="line-modified">! static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
  {
      auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));
  
      auto&amp; mainFrame = page-&gt;mainFrame();
      mainFrame.loader().initForSynthesizedDocument({ });
      auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
      document-&gt;createDOMWindow();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
  
      auto origin = data.registration.key.topOrigin().securityOrigin();
      origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
  
      document-&gt;setSiteForCookies(topOriginURL(origin));
<span class="line-modified">!     document-&gt;setFirstPartyForCookies(data.scriptURL);</span>
      document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
  
      if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
          document-&gt;setReferrerPolicy(*policy);
  
<span class="line-new-header">--- 70,11 ---</span>
  
      auto origin = data.registration.key.topOrigin().securityOrigin();
      origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
  
      document-&gt;setSiteForCookies(topOriginURL(origin));
<span class="line-modified">!     document-&gt;setFirstPartyForCookies(topOriginURL(origin));</span>
      document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
  
      if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
          document-&gt;setReferrerPolicy(*policy);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,16 ***</span>
  {
      static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
      return set;
  }
  
<span class="line-modified">! ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, PAL::SessionID sessionID, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
<span class="line-modified">!     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy, data.sessionID))</span>
      , m_document(*m_page-&gt;mainFrame().document())
<span class="line-modified">!     , m_serviceWorkerThread(ServiceWorkerThread::create(data, sessionID, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))</span>
      , m_cacheStorageProvider(cacheStorageProvider)
<span class="line-removed">-     , m_sessionID(sessionID)</span>
      , m_inspectorProxy(*this)
  {
      static bool addedListener;
      if (!addedListener) {
          platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
<span class="line-new-header">--- 95,15 ---</span>
  {
      static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
      return set;
  }
  
<span class="line-modified">! ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
<span class="line-modified">!     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy))</span>
      , m_document(*m_page-&gt;mainFrame().document())
<span class="line-modified">!     , m_serviceWorkerThread(ServiceWorkerThread::create(data, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))</span>
      , m_cacheStorageProvider(cacheStorageProvider)
      , m_inspectorProxy(*this)
  {
      static bool addedListener;
      if (!addedListener) {
          platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,23 ***</span>
          // FIXME: Handle terminated case.
          m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
      });
  }
  
<span class="line-modified">! void ServiceWorkerThreadProxy::setResourceCachingDisabled(bool disabled)</span>
  {
      postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
          ASSERT(isMainThread());
<span class="line-modified">!         m_page-&gt;setResourceCachingDisabled(disabled);</span>
      });
  }
  
  Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
  {
      ASSERT(isMainThread());
      if (!m_cacheStorageConnection)
<span class="line-modified">!         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection(m_sessionID);</span>
      return *m_cacheStorageConnection;
  }
  
  std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
  {
<span class="line-new-header">--- 148,23 ---</span>
          // FIXME: Handle terminated case.
          m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
      });
  }
  
<span class="line-modified">! void ServiceWorkerThreadProxy::setResourceCachingDisabledByWebInspector(bool disabled)</span>
  {
      postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
          ASSERT(isMainThread());
<span class="line-modified">!         m_page-&gt;setResourceCachingDisabledByWebInspector(disabled);</span>
      });
  }
  
  Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
  {
      ASSERT(isMainThread());
      if (!m_cacheStorageConnection)
<span class="line-modified">!         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection();</span>
      return *m_cacheStorageConnection;
  }
  
  std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,29 ***</span>
          return;
  
      postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
          auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
          globalScope.setIsOnline(isOnline);
<span class="line-modified">!         globalScope.dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
      }, WorkerRunLoop::defaultMode());
  }
  
  void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
  {
      auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
  
      ASSERT(!m_ongoingFetchTasks.contains(key));
      m_ongoingFetchTasks.add(key, client.copyRef());
<span class="line-modified">!     thread().postFetchTask(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
  }
  
  void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
  {
      auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
      if (!client)
          return;
  
      postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
          client-&gt;cancel();
      }, WorkerRunLoop::defaultMode());
  }
  
<span class="line-new-header">--- 187,39 ---</span>
          return;
  
      postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
          auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
          globalScope.setIsOnline(isOnline);
<span class="line-modified">!         globalScope.eventLoop().queueTask(TaskSource::DOMManipulation, [globalScope = makeRef(globalScope), isOnline] {</span>
<span class="line-added">+             globalScope-&gt;dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">+         });</span>
      }, WorkerRunLoop::defaultMode());
  }
  
  void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
  {
      auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
  
<span class="line-added">+     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">+         thread().startFetchEventMonitoring();</span>
<span class="line-added">+ </span>
      ASSERT(!m_ongoingFetchTasks.contains(key));
      m_ongoingFetchTasks.add(key, client.copyRef());
<span class="line-modified">!     postTaskForModeToWorkerGlobalScope([this, protectedThis = makeRef(*this), client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()](auto&amp;) mutable {</span>
<span class="line-added">+         thread().queueTaskToFireFetchEvent(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="line-added">+     }, WorkerRunLoop::defaultMode());</span>
  }
  
  void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
  {
      auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
      if (!client)
          return;
  
<span class="line-added">+     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">+         thread().stopFetchEventMonitoring();</span>
<span class="line-added">+ </span>
      postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
          client-&gt;cancel();
      }, WorkerRunLoop::defaultMode());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,10 ***</span>
<span class="line-new-header">--- 235,37 ---</span>
  }
  
  void ServiceWorkerThreadProxy::removeFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
  {
      m_ongoingFetchTasks.remove(std::make_pair(connectionIdentifier, fetchIdentifier));
<span class="line-added">+ </span>
<span class="line-added">+     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">+         thread().stopFetchEventMonitoring();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ServiceWorkerThreadProxy::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     thread().willPostTaskToFireMessageEvent();</span>
<span class="line-added">+     thread().runLoop().postTask([this, protectedThis = makeRef(*this), message = WTFMove(message), sourceData = WTFMove(sourceData)](auto&amp;) mutable {</span>
<span class="line-added">+         thread().queueTaskToPostMessage(WTFMove(message), WTFMove(sourceData));</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ServiceWorkerThreadProxy::fireInstallEvent()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     thread().willPostTaskToFireInstallEvent();</span>
<span class="line-added">+     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">+         thread().queueTaskToFireInstallEvent();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ServiceWorkerThreadProxy::fireActivateEvent()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     thread().willPostTaskToFireActivateEvent();</span>
<span class="line-added">+     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">+         thread().queueTaskToFireActivateEvent();</span>
<span class="line-added">+     });</span>
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="ServiceWorkerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThreadProxy.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
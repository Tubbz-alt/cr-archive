<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSSegmentedFontFace.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelector.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;CSSSelector.h&quot;
  
  #include &quot;CSSMarkup.h&quot;
  #include &quot;CSSSelectorList.h&quot;
  #include &quot;HTMLNames.h&quot;
<span class="line-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;SelectorPseudoTypeMap.h&quot;
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/Vector.h&gt;
  #include &lt;wtf/text/AtomStringHash.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 47,12 ---</span>
  };
  
  static_assert(CSSSelector::RelationType::Subselector == 0, &quot;Subselector must be 0 for consumeCombinator.&quot;);
  static_assert(sizeof(CSSSelector) == sizeof(SameSizeAsCSSSelector), &quot;CSSSelector should remain small.&quot;);
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSSelectorRareData);</span>
<span class="line-added">+ </span>
  CSSSelector::CSSSelector(const QualifiedName&amp; tagQName, bool tagIsForNamespaceRule)
      : m_relation(DescendantSpace)
      , m_match(Tag)
      , m_pseudoType(0)
      , m_isLastInSelectorList(false)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,10 ***</span>
<span class="line-new-header">--- 275,12 ---</span>
          return PseudoId::FirstLine;
      case PseudoElementFirstLetter:
          return PseudoId::FirstLetter;
      case PseudoElementSelection:
          return PseudoId::Selection;
<span class="line-added">+     case PseudoElementHighlight:</span>
<span class="line-added">+         return PseudoId::Highlight;</span>
      case PseudoElementMarker:
          return PseudoId::Marker;
      case PseudoElementBefore:
          return PseudoId::Before;
      case PseudoElementAfter:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,10 ***</span>
<span class="line-new-header">--- 301,11 ---</span>
          return PseudoId::Resizer;
  #if ENABLE(VIDEO_TRACK)
      case PseudoElementCue:
  #endif
      case PseudoElementSlotted:
<span class="line-added">+     case PseudoElementPart:</span>
      case PseudoElementUnknown:
      case PseudoElementWebKitCustom:
      case PseudoElementWebKitCustomLegacyPrefixed:
          return PseudoId::None;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,15 ***</span>
<span class="line-new-header">--- 316,23 ---</span>
  
  CSSSelector::PseudoElementType CSSSelector::parsePseudoElementType(StringView name)
  {
      if (name.isNull())
          return PseudoElementUnknown;
<span class="line-added">+ </span>
      auto type = parsePseudoElementString(name);
      if (type == PseudoElementUnknown) {
          if (name.startsWith(&quot;-webkit-&quot;))
              type = PseudoElementWebKitCustom;
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (type == PseudoElementHighlight &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())</span>
<span class="line-added">+         return PseudoElementUnknown;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (type == PseudoElementPart &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="line-added">+         return PseudoElementUnknown;</span>
<span class="line-added">+ </span>
      return type;
  }
  
  bool CSSSelector::operator==(const CSSSelector&amp; other) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,11 ***</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! static void appendPseudoClassFunctionTail(StringBuilder&amp; str, const CSSSelector* selector)</span>
  {
      switch (selector-&gt;pseudoClassType()) {
  #if ENABLE(CSS_SELECTORS_LEVEL4)
      case CSSSelector::PseudoClassDir:
  #endif
<span class="line-new-header">--- 360,11 ---</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! static void appendPseudoClassFunctionTail(StringBuilder&amp; builder, const CSSSelector* selector)</span>
  {
      switch (selector-&gt;pseudoClassType()) {
  #if ENABLE(CSS_SELECTORS_LEVEL4)
      case CSSSelector::PseudoClassDir:
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,369 ***</span>
      case CSSSelector::PseudoClassNthOfType:
      case CSSSelector::PseudoClassNthLastOfType:
  #if ENABLE(CSS_SELECTORS_LEVEL4)
      case CSSSelector::PseudoClassRole:
  #endif
<span class="line-modified">!         str.append(selector-&gt;argument());</span>
<span class="line-modified">!         str.append(&#39;)&#39;);</span>
          break;
      default:
          break;
      }
  
  }
  
<span class="line-modified">! static void appendLangArgumentList(StringBuilder&amp; str, const Vector&lt;AtomString&gt;&amp; argumentList)</span>
  {
      unsigned argumentListSize = argumentList.size();
      for (unsigned i = 0; i &lt; argumentListSize; ++i) {
<span class="line-modified">!         str.append(&#39;&quot;&#39;);</span>
<span class="line-modified">!         str.append(argumentList[i]);</span>
<span class="line-modified">!         str.append(&#39;&quot;&#39;);</span>
          if (i != argumentListSize - 1)
<span class="line-modified">!             str.appendLiteral(&quot;, &quot;);</span>
      }
  }
  
  String CSSSelector::selectorText(const String&amp; rightSide) const
  {
<span class="line-modified">!     StringBuilder str;</span>
  
      if (match() == CSSSelector::Tag &amp;&amp; !m_tagIsForNamespaceRule) {
          if (tagQName().prefix().isNull())
<span class="line-modified">!             str.append(tagQName().localName());</span>
          else {
<span class="line-modified">!             str.append(tagQName().prefix().string());</span>
<span class="line-modified">!             str.append(&#39;|&#39;);</span>
<span class="line-modified">!             str.append(tagQName().localName());</span>
          }
      }
  
      const CSSSelector* cs = this;
      while (true) {
          if (cs-&gt;match() == CSSSelector::Id) {
<span class="line-modified">!             str.append(&#39;#&#39;);</span>
<span class="line-modified">!             serializeIdentifier(cs-&gt;serializingValue(), str);</span>
          } else if (cs-&gt;match() == CSSSelector::Class) {
<span class="line-modified">!             str.append(&#39;.&#39;);</span>
<span class="line-modified">!             serializeIdentifier(cs-&gt;serializingValue(), str);</span>
          } else if (cs-&gt;match() == CSSSelector::PseudoClass) {
              switch (cs-&gt;pseudoClassType()) {
  #if ENABLE(FULLSCREEN_API)
              case CSSSelector::PseudoClassAnimatingFullScreenTransition:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-animating-full-screen-transition&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassAny: {
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-any(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              }
              case CSSSelector::PseudoClassAnyLink:
<span class="line-modified">!                 str.appendLiteral(&quot;:any-link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAnyLinkDeprecated:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-any-link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofill:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-autofill&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofillStrongPassword:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-autofill-strong-password&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-autofill-strong-password-viewable&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDrag:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-drag&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullPageMedia:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-full-page-media&quot;);</span>
                  break;
  #if ENABLE(FULLSCREEN_API)
              case CSSSelector::PseudoClassFullScreen:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-full-screen&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenAncestor:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-full-screen-ancestor&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenDocument:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-full-screen-document&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenControlsHidden:
<span class="line-modified">!                 str.appendLiteral(&quot;:-webkit-full-screen-controls-hidden&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassActive:
<span class="line-modified">!                 str.appendLiteral(&quot;:active&quot;);</span>
                  break;
              case CSSSelector::PseudoClassChecked:
<span class="line-modified">!                 str.appendLiteral(&quot;:checked&quot;);</span>
                  break;
              case CSSSelector::PseudoClassCornerPresent:
<span class="line-modified">!                 str.appendLiteral(&quot;:corner-present&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDecrement:
<span class="line-modified">!                 str.appendLiteral(&quot;:decrement&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDefault:
<span class="line-modified">!                 str.appendLiteral(&quot;:default&quot;);</span>
                  break;
  #if ENABLE(CSS_SELECTORS_LEVEL4)
              case CSSSelector::PseudoClassDir:
<span class="line-modified">!                 str.appendLiteral(&quot;:dir(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(str, cs);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassDisabled:
<span class="line-modified">!                 str.appendLiteral(&quot;:disabled&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDoubleButton:
<span class="line-modified">!                 str.appendLiteral(&quot;:double-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEmpty:
<span class="line-modified">!                 str.appendLiteral(&quot;:empty&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEnabled:
<span class="line-modified">!                 str.appendLiteral(&quot;:enabled&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEnd:
<span class="line-modified">!                 str.appendLiteral(&quot;:end&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFirstChild:
<span class="line-modified">!                 str.appendLiteral(&quot;:first-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFirstOfType:
<span class="line-modified">!                 str.appendLiteral(&quot;:first-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFocus:
<span class="line-modified">!                 str.appendLiteral(&quot;:focus&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFocusWithin:
<span class="line-modified">!                 str.appendLiteral(&quot;:focus-within&quot;);</span>
                  break;
  #if ENABLE(VIDEO_TRACK)
              case CSSSelector::PseudoClassFuture:
<span class="line-modified">!                 str.appendLiteral(&quot;:future&quot;);</span>
                  break;
  #endif
  #if ENABLE(ATTACHMENT_ELEMENT)
              case CSSSelector::PseudoClassHasAttachment:
<span class="line-modified">!                 str.appendLiteral(&quot;:has-attachment&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassHorizontal:
<span class="line-modified">!                 str.appendLiteral(&quot;:horizontal&quot;);</span>
                  break;
              case CSSSelector::PseudoClassHover:
<span class="line-modified">!                 str.appendLiteral(&quot;:hover&quot;);</span>
                  break;
              case CSSSelector::PseudoClassInRange:
<span class="line-modified">!                 str.appendLiteral(&quot;:in-range&quot;);</span>
                  break;
              case CSSSelector::PseudoClassIncrement:
<span class="line-modified">!                 str.appendLiteral(&quot;:increment&quot;);</span>
                  break;
              case CSSSelector::PseudoClassIndeterminate:
<span class="line-modified">!                 str.appendLiteral(&quot;:indeterminate&quot;);</span>
                  break;
              case CSSSelector::PseudoClassInvalid:
<span class="line-modified">!                 str.appendLiteral(&quot;:invalid&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLang:
<span class="line-modified">!                 str.appendLiteral(&quot;:lang(&quot;);</span>
<span class="line-modified">!                 ASSERT_WITH_MESSAGE(cs-&gt;langArgumentList() &amp;&amp; !cs-&gt;langArgumentList()-&gt;isEmpty(), &quot;An empty :lang() is invalid and should never be generated by the parser.&quot;);</span>
<span class="line-modified">!                 appendLangArgumentList(str, *cs-&gt;langArgumentList());</span>
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassLastChild:
<span class="line-modified">!                 str.appendLiteral(&quot;:last-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLastOfType:
<span class="line-modified">!                 str.appendLiteral(&quot;:last-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLink:
<span class="line-modified">!                 str.appendLiteral(&quot;:link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassNoButton:
<span class="line-modified">!                 str.appendLiteral(&quot;:no-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassNot:
<span class="line-modified">!                 str.appendLiteral(&quot;:not(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthChild:
<span class="line-modified">!                 str.appendLiteral(&quot;:nth-child(&quot;);</span>
<span class="line-modified">!                 str.append(cs-&gt;argument());</span>
                  if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">!                     str.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">!                     selectorList-&gt;buildSelectorsText(str);</span>
                  }
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthLastChild:
<span class="line-modified">!                 str.appendLiteral(&quot;:nth-last-child(&quot;);</span>
<span class="line-modified">!                 str.append(cs-&gt;argument());</span>
                  if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">!                     str.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">!                     selectorList-&gt;buildSelectorsText(str);</span>
                  }
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthLastOfType:
<span class="line-modified">!                 str.appendLiteral(&quot;:nth-last-of-type(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(str, cs);</span>
                  break;
              case CSSSelector::PseudoClassNthOfType:
<span class="line-modified">!                 str.appendLiteral(&quot;:nth-of-type(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(str, cs);</span>
                  break;
              case CSSSelector::PseudoClassOnlyChild:
<span class="line-modified">!                 str.appendLiteral(&quot;:only-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOnlyOfType:
<span class="line-modified">!                 str.appendLiteral(&quot;:only-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOptional:
<span class="line-modified">!                 str.appendLiteral(&quot;:optional&quot;);</span>
                  break;
              case CSSSelector::PseudoClassMatches: {
<span class="line-modified">!                 str.appendLiteral(&quot;:matches(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              }
              case CSSSelector::PseudoClassPlaceholderShown:
<span class="line-modified">!                 str.appendLiteral(&quot;:placeholder-shown&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOutOfRange:
<span class="line-modified">!                 str.appendLiteral(&quot;:out-of-range&quot;);</span>
                  break;
  #if ENABLE(VIDEO_TRACK)
              case CSSSelector::PseudoClassPast:
<span class="line-modified">!                 str.appendLiteral(&quot;:past&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassReadOnly:
<span class="line-modified">!                 str.appendLiteral(&quot;:read-only&quot;);</span>
                  break;
              case CSSSelector::PseudoClassReadWrite:
<span class="line-modified">!                 str.appendLiteral(&quot;:read-write&quot;);</span>
                  break;
              case CSSSelector::PseudoClassRequired:
<span class="line-modified">!                 str.appendLiteral(&quot;:required&quot;);</span>
                  break;
  #if ENABLE(CSS_SELECTORS_LEVEL4)
              case CSSSelector::PseudoClassRole:
<span class="line-modified">!                 str.appendLiteral(&quot;:role(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(str, cs);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassRoot:
<span class="line-modified">!                 str.appendLiteral(&quot;:root&quot;);</span>
                  break;
              case CSSSelector::PseudoClassScope:
<span class="line-modified">!                 str.appendLiteral(&quot;:scope&quot;);</span>
                  break;
              case CSSSelector::PseudoClassSingleButton:
<span class="line-modified">!                 str.appendLiteral(&quot;:single-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassStart:
<span class="line-modified">!                 str.appendLiteral(&quot;:start&quot;);</span>
                  break;
              case CSSSelector::PseudoClassTarget:
<span class="line-modified">!                 str.appendLiteral(&quot;:target&quot;);</span>
                  break;
              case CSSSelector::PseudoClassValid:
<span class="line-modified">!                 str.appendLiteral(&quot;:valid&quot;);</span>
                  break;
              case CSSSelector::PseudoClassVertical:
<span class="line-modified">!                 str.appendLiteral(&quot;:vertical&quot;);</span>
                  break;
              case CSSSelector::PseudoClassVisited:
<span class="line-modified">!                 str.appendLiteral(&quot;:visited&quot;);</span>
                  break;
              case CSSSelector::PseudoClassWindowInactive:
<span class="line-modified">!                 str.appendLiteral(&quot;:window-inactive&quot;);</span>
                  break;
              case CSSSelector::PseudoClassHost:
<span class="line-modified">!                 str.appendLiteral(&quot;:host&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDefined:
<span class="line-modified">!                 str.appendLiteral(&quot;:defined&quot;);</span>
                  break;
              case CSSSelector::PseudoClassUnknown:
                  ASSERT_NOT_REACHED();
              }
          } else if (cs-&gt;match() == CSSSelector::PseudoElement) {
              switch (cs-&gt;pseudoElementType()) {
              case CSSSelector::PseudoElementSlotted:
<span class="line-modified">!                 str.appendLiteral(&quot;::slotted(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">!                 str.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
                  if (cs-&gt;value() == &quot;placeholder&quot;)
<span class="line-modified">!                     str.appendLiteral(&quot;::-webkit-input-placeholder&quot;);</span>
                  break;
              default:
<span class="line-modified">!                 str.appendLiteral(&quot;::&quot;);</span>
<span class="line-modified">!                 str.append(cs-&gt;serializingValue());</span>
              }
          } else if (cs-&gt;isAttributeSelector()) {
<span class="line-modified">!             str.append(&#39;[&#39;);</span>
              const AtomString&amp; prefix = cs-&gt;attribute().prefix();
              if (!prefix.isEmpty()) {
<span class="line-modified">!                 str.append(prefix);</span>
<span class="line-modified">!                 str.append(&#39;|&#39;);</span>
              }
<span class="line-modified">!             str.append(cs-&gt;attribute().localName());</span>
              switch (cs-&gt;match()) {
                  case CSSSelector::Exact:
<span class="line-modified">!                     str.append(&#39;=&#39;);</span>
                      break;
                  case CSSSelector::Set:
                      // set has no operator or value, just the attrName
<span class="line-modified">!                     str.append(&#39;]&#39;);</span>
                      break;
                  case CSSSelector::List:
<span class="line-modified">!                     str.appendLiteral(&quot;~=&quot;);</span>
                      break;
                  case CSSSelector::Hyphen:
<span class="line-modified">!                     str.appendLiteral(&quot;|=&quot;);</span>
                      break;
                  case CSSSelector::Begin:
<span class="line-modified">!                     str.appendLiteral(&quot;^=&quot;);</span>
                      break;
                  case CSSSelector::End:
<span class="line-modified">!                     str.appendLiteral(&quot;$=&quot;);</span>
                      break;
                  case CSSSelector::Contain:
<span class="line-modified">!                     str.appendLiteral(&quot;*=&quot;);</span>
                      break;
                  default:
                      break;
              }
              if (cs-&gt;match() != CSSSelector::Set) {
<span class="line-modified">!                 serializeString(cs-&gt;serializingValue(), str);</span>
                  if (cs-&gt;attributeValueMatchingIsCaseInsensitive())
<span class="line-modified">!                     str.appendLiteral(&quot; i]&quot;);</span>
                  else
<span class="line-modified">!                     str.append(&#39;]&#39;);</span>
              }
          } else if (cs-&gt;match() == CSSSelector::PagePseudoClass) {
              switch (cs-&gt;pagePseudoClassType()) {
              case PagePseudoClassFirst:
<span class="line-modified">!                 str.appendLiteral(&quot;:first&quot;);</span>
                  break;
              case PagePseudoClassLeft:
<span class="line-modified">!                 str.appendLiteral(&quot;:left&quot;);</span>
                  break;
              case PagePseudoClassRight:
<span class="line-modified">!                 str.appendLiteral(&quot;:right&quot;);</span>
                  break;
              }
          }
  
          if (cs-&gt;relation() != CSSSelector::Subselector || !cs-&gt;tagHistory())
<span class="line-new-header">--- 374,436 ---</span>
      case CSSSelector::PseudoClassNthOfType:
      case CSSSelector::PseudoClassNthLastOfType:
  #if ENABLE(CSS_SELECTORS_LEVEL4)
      case CSSSelector::PseudoClassRole:
  #endif
<span class="line-modified">!         builder.append(selector-&gt;argument());</span>
<span class="line-modified">!         builder.append(&#39;)&#39;);</span>
          break;
      default:
          break;
      }
  
  }
  
<span class="line-modified">! static void appendLangArgumentList(StringBuilder&amp; builder, const Vector&lt;AtomString&gt;&amp; argumentList)</span>
  {
      unsigned argumentListSize = argumentList.size();
      for (unsigned i = 0; i &lt; argumentListSize; ++i) {
<span class="line-modified">!         builder.append(&#39;&quot;&#39;);</span>
<span class="line-modified">!         builder.append(argumentList[i]);</span>
<span class="line-modified">!         builder.append(&#39;&quot;&#39;);</span>
          if (i != argumentListSize - 1)
<span class="line-modified">!             builder.appendLiteral(&quot;, &quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // http://dev.w3.org/csswg/css-syntax/#serializing-anb</span>
<span class="line-added">+ static void outputNthChildAnPlusB(const CSSSelector&amp; selector, StringBuilder&amp; builder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto outputFirstTerm = [&amp;builder] (int a) {</span>
<span class="line-added">+         switch (a) {</span>
<span class="line-added">+         case 1:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case -1:</span>
<span class="line-added">+             builder.append(&#39;-&#39;);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             builder.append(a);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (selector.argument() == nullAtom())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     int a = selector.nthA();</span>
<span class="line-added">+     int b = selector.nthB();</span>
<span class="line-added">+     if (a == 0 &amp;&amp; b == 0)</span>
<span class="line-added">+         builder.append(&#39;0&#39;);</span>
<span class="line-added">+     else if (a == 0)</span>
<span class="line-added">+         builder.append(b);</span>
<span class="line-added">+     else if (b == 0) {</span>
<span class="line-added">+         outputFirstTerm(a);</span>
<span class="line-added">+         builder.append(&#39;n&#39;);</span>
<span class="line-added">+     } else if (b &lt; 0) {</span>
<span class="line-added">+         outputFirstTerm(a);</span>
<span class="line-added">+         builder.append(&#39;n&#39;, b);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         outputFirstTerm(a);</span>
<span class="line-added">+         builder.append(&quot;n+&quot;, b);</span>
      }
  }
  
  String CSSSelector::selectorText(const String&amp; rightSide) const
  {
<span class="line-modified">!     StringBuilder builder;</span>
  
      if (match() == CSSSelector::Tag &amp;&amp; !m_tagIsForNamespaceRule) {
          if (tagQName().prefix().isNull())
<span class="line-modified">!             builder.append(tagQName().localName());</span>
          else {
<span class="line-modified">!             builder.append(tagQName().prefix().string());</span>
<span class="line-modified">!             builder.append(&#39;|&#39;);</span>
<span class="line-modified">!             builder.append(tagQName().localName());</span>
          }
      }
  
      const CSSSelector* cs = this;
      while (true) {
          if (cs-&gt;match() == CSSSelector::Id) {
<span class="line-modified">!             builder.append(&#39;#&#39;);</span>
<span class="line-modified">!             serializeIdentifier(cs-&gt;serializingValue(), builder);</span>
          } else if (cs-&gt;match() == CSSSelector::Class) {
<span class="line-modified">!             builder.append(&#39;.&#39;);</span>
<span class="line-modified">!             serializeIdentifier(cs-&gt;serializingValue(), builder);</span>
          } else if (cs-&gt;match() == CSSSelector::PseudoClass) {
              switch (cs-&gt;pseudoClassType()) {
  #if ENABLE(FULLSCREEN_API)
              case CSSSelector::PseudoClassAnimatingFullScreenTransition:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-animating-full-screen-transition&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassAny: {
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-any(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              }
              case CSSSelector::PseudoClassAnyLink:
<span class="line-modified">!                 builder.appendLiteral(&quot;:any-link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAnyLinkDeprecated:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-any-link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofill:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-autofill&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofillStrongPassword:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password&quot;);</span>
                  break;
              case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password-viewable&quot;);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">+                 builder.appendLiteral(&quot;:-webkit-direct-focus&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDrag:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-drag&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullPageMedia:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-full-page-media&quot;);</span>
                  break;
  #if ENABLE(FULLSCREEN_API)
              case CSSSelector::PseudoClassFullScreen:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-full-screen&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenAncestor:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-full-screen-ancestor&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenDocument:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-full-screen-document&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFullScreenControlsHidden:
<span class="line-modified">!                 builder.appendLiteral(&quot;:-webkit-full-screen-controls-hidden&quot;);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+             case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">+                 builder.appendLiteral(&quot;:picture-in-picture&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassActive:
<span class="line-modified">!                 builder.appendLiteral(&quot;:active&quot;);</span>
                  break;
              case CSSSelector::PseudoClassChecked:
<span class="line-modified">!                 builder.appendLiteral(&quot;:checked&quot;);</span>
                  break;
              case CSSSelector::PseudoClassCornerPresent:
<span class="line-modified">!                 builder.appendLiteral(&quot;:corner-present&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDecrement:
<span class="line-modified">!                 builder.appendLiteral(&quot;:decrement&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDefault:
<span class="line-modified">!                 builder.appendLiteral(&quot;:default&quot;);</span>
                  break;
  #if ENABLE(CSS_SELECTORS_LEVEL4)
              case CSSSelector::PseudoClassDir:
<span class="line-modified">!                 builder.appendLiteral(&quot;:dir(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(builder, cs);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassDisabled:
<span class="line-modified">!                 builder.appendLiteral(&quot;:disabled&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDoubleButton:
<span class="line-modified">!                 builder.appendLiteral(&quot;:double-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEmpty:
<span class="line-modified">!                 builder.appendLiteral(&quot;:empty&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEnabled:
<span class="line-modified">!                 builder.appendLiteral(&quot;:enabled&quot;);</span>
                  break;
              case CSSSelector::PseudoClassEnd:
<span class="line-modified">!                 builder.appendLiteral(&quot;:end&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFirstChild:
<span class="line-modified">!                 builder.appendLiteral(&quot;:first-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFirstOfType:
<span class="line-modified">!                 builder.appendLiteral(&quot;:first-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFocus:
<span class="line-modified">!                 builder.appendLiteral(&quot;:focus&quot;);</span>
                  break;
              case CSSSelector::PseudoClassFocusWithin:
<span class="line-modified">!                 builder.appendLiteral(&quot;:focus-within&quot;);</span>
                  break;
  #if ENABLE(VIDEO_TRACK)
              case CSSSelector::PseudoClassFuture:
<span class="line-modified">!                 builder.appendLiteral(&quot;:future&quot;);</span>
                  break;
  #endif
  #if ENABLE(ATTACHMENT_ELEMENT)
              case CSSSelector::PseudoClassHasAttachment:
<span class="line-modified">!                 builder.appendLiteral(&quot;:has-attachment&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassHorizontal:
<span class="line-modified">!                 builder.appendLiteral(&quot;:horizontal&quot;);</span>
                  break;
              case CSSSelector::PseudoClassHover:
<span class="line-modified">!                 builder.appendLiteral(&quot;:hover&quot;);</span>
                  break;
              case CSSSelector::PseudoClassInRange:
<span class="line-modified">!                 builder.appendLiteral(&quot;:in-range&quot;);</span>
                  break;
              case CSSSelector::PseudoClassIncrement:
<span class="line-modified">!                 builder.appendLiteral(&quot;:increment&quot;);</span>
                  break;
              case CSSSelector::PseudoClassIndeterminate:
<span class="line-modified">!                 builder.appendLiteral(&quot;:indeterminate&quot;);</span>
                  break;
              case CSSSelector::PseudoClassInvalid:
<span class="line-modified">!                 builder.appendLiteral(&quot;:invalid&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLang:
<span class="line-modified">!                 builder.appendLiteral(&quot;:lang(&quot;);</span>
<span class="line-modified">!                 ASSERT_WITH_MESSAGE(cs-&gt;argumentList() &amp;&amp; !cs-&gt;argumentList()-&gt;isEmpty(), &quot;An empty :lang() is invalid and should never be generated by the parser.&quot;);</span>
<span class="line-modified">!                 appendLangArgumentList(builder, *cs-&gt;argumentList());</span>
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassLastChild:
<span class="line-modified">!                 builder.appendLiteral(&quot;:last-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLastOfType:
<span class="line-modified">!                 builder.appendLiteral(&quot;:last-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassLink:
<span class="line-modified">!                 builder.appendLiteral(&quot;:link&quot;);</span>
                  break;
              case CSSSelector::PseudoClassNoButton:
<span class="line-modified">!                 builder.appendLiteral(&quot;:no-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassNot:
<span class="line-modified">!                 builder.appendLiteral(&quot;:not(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthChild:
<span class="line-modified">!                 builder.appendLiteral(&quot;:nth-child(&quot;);</span>
<span class="line-modified">!                 outputNthChildAnPlusB(*cs, builder);</span>
                  if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">!                     builder.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">!                     selectorList-&gt;buildSelectorsText(builder);</span>
                  }
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthLastChild:
<span class="line-modified">!                 builder.appendLiteral(&quot;:nth-last-child(&quot;);</span>
<span class="line-modified">!                 outputNthChildAnPlusB(*cs, builder);</span>
                  if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">!                     builder.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">!                     selectorList-&gt;buildSelectorsText(builder);</span>
                  }
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              case CSSSelector::PseudoClassNthLastOfType:
<span class="line-modified">!                 builder.appendLiteral(&quot;:nth-last-of-type(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(builder, cs);</span>
                  break;
              case CSSSelector::PseudoClassNthOfType:
<span class="line-modified">!                 builder.appendLiteral(&quot;:nth-of-type(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(builder, cs);</span>
                  break;
              case CSSSelector::PseudoClassOnlyChild:
<span class="line-modified">!                 builder.appendLiteral(&quot;:only-child&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOnlyOfType:
<span class="line-modified">!                 builder.appendLiteral(&quot;:only-of-type&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOptional:
<span class="line-modified">!                 builder.appendLiteral(&quot;:optional&quot;);</span>
                  break;
              case CSSSelector::PseudoClassMatches: {
<span class="line-modified">!                 builder.appendLiteral(&quot;:matches(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
                  break;
              }
              case CSSSelector::PseudoClassPlaceholderShown:
<span class="line-modified">!                 builder.appendLiteral(&quot;:placeholder-shown&quot;);</span>
                  break;
              case CSSSelector::PseudoClassOutOfRange:
<span class="line-modified">!                 builder.appendLiteral(&quot;:out-of-range&quot;);</span>
                  break;
  #if ENABLE(VIDEO_TRACK)
              case CSSSelector::PseudoClassPast:
<span class="line-modified">!                 builder.appendLiteral(&quot;:past&quot;);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassReadOnly:
<span class="line-modified">!                 builder.appendLiteral(&quot;:read-only&quot;);</span>
                  break;
              case CSSSelector::PseudoClassReadWrite:
<span class="line-modified">!                 builder.appendLiteral(&quot;:read-write&quot;);</span>
                  break;
              case CSSSelector::PseudoClassRequired:
<span class="line-modified">!                 builder.appendLiteral(&quot;:required&quot;);</span>
                  break;
  #if ENABLE(CSS_SELECTORS_LEVEL4)
              case CSSSelector::PseudoClassRole:
<span class="line-modified">!                 builder.appendLiteral(&quot;:role(&quot;);</span>
<span class="line-modified">!                 appendPseudoClassFunctionTail(builder, cs);</span>
                  break;
  #endif
              case CSSSelector::PseudoClassRoot:
<span class="line-modified">!                 builder.appendLiteral(&quot;:root&quot;);</span>
                  break;
              case CSSSelector::PseudoClassScope:
<span class="line-modified">!                 builder.appendLiteral(&quot;:scope&quot;);</span>
                  break;
              case CSSSelector::PseudoClassSingleButton:
<span class="line-modified">!                 builder.appendLiteral(&quot;:single-button&quot;);</span>
                  break;
              case CSSSelector::PseudoClassStart:
<span class="line-modified">!                 builder.appendLiteral(&quot;:start&quot;);</span>
                  break;
              case CSSSelector::PseudoClassTarget:
<span class="line-modified">!                 builder.appendLiteral(&quot;:target&quot;);</span>
                  break;
              case CSSSelector::PseudoClassValid:
<span class="line-modified">!                 builder.appendLiteral(&quot;:valid&quot;);</span>
                  break;
              case CSSSelector::PseudoClassVertical:
<span class="line-modified">!                 builder.appendLiteral(&quot;:vertical&quot;);</span>
                  break;
              case CSSSelector::PseudoClassVisited:
<span class="line-modified">!                 builder.appendLiteral(&quot;:visited&quot;);</span>
                  break;
              case CSSSelector::PseudoClassWindowInactive:
<span class="line-modified">!                 builder.appendLiteral(&quot;:window-inactive&quot;);</span>
                  break;
              case CSSSelector::PseudoClassHost:
<span class="line-modified">!                 builder.appendLiteral(&quot;:host&quot;);</span>
                  break;
              case CSSSelector::PseudoClassDefined:
<span class="line-modified">!                 builder.appendLiteral(&quot;:defined&quot;);</span>
                  break;
              case CSSSelector::PseudoClassUnknown:
                  ASSERT_NOT_REACHED();
              }
          } else if (cs-&gt;match() == CSSSelector::PseudoElement) {
              switch (cs-&gt;pseudoElementType()) {
              case CSSSelector::PseudoElementSlotted:
<span class="line-modified">!                 builder.appendLiteral(&quot;::slotted(&quot;);</span>
<span class="line-modified">!                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">!                 builder.append(&#39;)&#39;);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">+                 builder.appendLiteral(&quot;::part(&quot;);</span>
<span class="line-added">+                 bool isFirst = true;</span>
<span class="line-added">+                 for (auto&amp; partName : *cs-&gt;argumentList()) {</span>
<span class="line-added">+                     if (!isFirst)</span>
<span class="line-added">+                         builder.append(&#39; &#39;);</span>
<span class="line-added">+                     isFirst = false;</span>
<span class="line-added">+                     builder.append(partName);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 builder.append(&#39;)&#39;);</span>
                  break;
<span class="line-added">+             }</span>
              case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
                  if (cs-&gt;value() == &quot;placeholder&quot;)
<span class="line-modified">!                     builder.appendLiteral(&quot;::-webkit-input-placeholder&quot;);</span>
                  break;
<span class="line-added">+ #if ENABLE(VIDEO_TRACK)</span>
<span class="line-added">+             case CSSSelector::PseudoElementCue: {</span>
<span class="line-added">+                 if (auto* selectorList = cs-&gt;selectorList()) {</span>
<span class="line-added">+                     builder.appendLiteral(&quot;::cue(&quot;);</span>
<span class="line-added">+                     selectorList-&gt;buildSelectorsText(builder);</span>
<span class="line-added">+                     builder.append(&#39;)&#39;);</span>
<span class="line-added">+                 } else</span>
<span class="line-added">+                     builder.appendLiteral(&quot;::cue&quot;);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #endif</span>
              default:
<span class="line-modified">!                 builder.appendLiteral(&quot;::&quot;);</span>
<span class="line-modified">!                 builder.append(cs-&gt;serializingValue());</span>
              }
          } else if (cs-&gt;isAttributeSelector()) {
<span class="line-modified">!             builder.append(&#39;[&#39;);</span>
              const AtomString&amp; prefix = cs-&gt;attribute().prefix();
              if (!prefix.isEmpty()) {
<span class="line-modified">!                 builder.append(prefix);</span>
<span class="line-modified">!                 builder.append(&#39;|&#39;);</span>
              }
<span class="line-modified">!             builder.append(cs-&gt;attribute().localName());</span>
              switch (cs-&gt;match()) {
                  case CSSSelector::Exact:
<span class="line-modified">!                     builder.append(&#39;=&#39;);</span>
                      break;
                  case CSSSelector::Set:
                      // set has no operator or value, just the attrName
<span class="line-modified">!                     builder.append(&#39;]&#39;);</span>
                      break;
                  case CSSSelector::List:
<span class="line-modified">!                     builder.appendLiteral(&quot;~=&quot;);</span>
                      break;
                  case CSSSelector::Hyphen:
<span class="line-modified">!                     builder.appendLiteral(&quot;|=&quot;);</span>
                      break;
                  case CSSSelector::Begin:
<span class="line-modified">!                     builder.appendLiteral(&quot;^=&quot;);</span>
                      break;
                  case CSSSelector::End:
<span class="line-modified">!                     builder.appendLiteral(&quot;$=&quot;);</span>
                      break;
                  case CSSSelector::Contain:
<span class="line-modified">!                     builder.appendLiteral(&quot;*=&quot;);</span>
                      break;
                  default:
                      break;
              }
              if (cs-&gt;match() != CSSSelector::Set) {
<span class="line-modified">!                 serializeString(cs-&gt;serializingValue(), builder);</span>
                  if (cs-&gt;attributeValueMatchingIsCaseInsensitive())
<span class="line-modified">!                     builder.appendLiteral(&quot; i]&quot;);</span>
                  else
<span class="line-modified">!                     builder.append(&#39;]&#39;);</span>
              }
          } else if (cs-&gt;match() == CSSSelector::PagePseudoClass) {
              switch (cs-&gt;pagePseudoClassType()) {
              case PagePseudoClassFirst:
<span class="line-modified">!                 builder.appendLiteral(&quot;:first&quot;);</span>
                  break;
              case PagePseudoClassLeft:
<span class="line-modified">!                 builder.appendLiteral(&quot;:left&quot;);</span>
                  break;
              case PagePseudoClassRight:
<span class="line-modified">!                 builder.appendLiteral(&quot;:right&quot;);</span>
                  break;
              }
          }
  
          if (cs-&gt;relation() != CSSSelector::Subselector || !cs-&gt;tagHistory())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,27 ***</span>
      }
  
      if (const CSSSelector* tagHistory = cs-&gt;tagHistory()) {
          switch (cs-&gt;relation()) {
          case CSSSelector::DescendantSpace:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; &quot; + str.toString() + rightSide);</span>
          case CSSSelector::Child:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; &gt; &quot; + str.toString() + rightSide);</span>
          case CSSSelector::DirectAdjacent:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; + &quot; + str.toString() + rightSide);</span>
          case CSSSelector::IndirectAdjacent:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; ~ &quot; + str.toString() + rightSide);</span>
          case CSSSelector::Subselector:
              ASSERT_NOT_REACHED();
<span class="line-modified">! #if ASSERT_DISABLED</span>
              FALLTHROUGH;
  #endif
          case CSSSelector::ShadowDescendant:
<span class="line-modified">!             return tagHistory-&gt;selectorText(str.toString() + rightSide);</span>
          }
      }
<span class="line-modified">!     return str.toString() + rightSide;</span>
  }
  
  void CSSSelector::setAttribute(const QualifiedName&amp; value, bool convertToLowercase, AttributeMatchType matchType)
  {
      createRareData();
<span class="line-new-header">--- 812,27 ---</span>
      }
  
      if (const CSSSelector* tagHistory = cs-&gt;tagHistory()) {
          switch (cs-&gt;relation()) {
          case CSSSelector::DescendantSpace:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; &quot; + builder.toString() + rightSide);</span>
          case CSSSelector::Child:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; &gt; &quot; + builder.toString() + rightSide);</span>
          case CSSSelector::DirectAdjacent:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; + &quot; + builder.toString() + rightSide);</span>
          case CSSSelector::IndirectAdjacent:
<span class="line-modified">!             return tagHistory-&gt;selectorText(&quot; ~ &quot; + builder.toString() + rightSide);</span>
          case CSSSelector::Subselector:
              ASSERT_NOT_REACHED();
<span class="line-modified">! #if !ASSERT_ENABLED</span>
              FALLTHROUGH;
  #endif
          case CSSSelector::ShadowDescendant:
<span class="line-modified">!             return tagHistory-&gt;selectorText(builder.toString() + rightSide);</span>
          }
      }
<span class="line-modified">!     return builder.toString() + rightSide;</span>
  }
  
  void CSSSelector::setAttribute(const QualifiedName&amp; value, bool convertToLowercase, AttributeMatchType matchType)
  {
      createRareData();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,14 ***</span>
  {
      createRareData();
      m_data.m_rareData-&gt;m_argument = value;
  }
  
<span class="line-modified">! void CSSSelector::setLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
  {
      createRareData();
<span class="line-modified">!     m_data.m_rareData-&gt;m_langArgumentList = WTFMove(argumentList);</span>
  }
  
  void CSSSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
  {
      createRareData();
<span class="line-new-header">--- 845,14 ---</span>
  {
      createRareData();
      m_data.m_rareData-&gt;m_argument = value;
  }
  
<span class="line-modified">! void CSSSelector::setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
  {
      createRareData();
<span class="line-modified">!     m_data.m_rareData-&gt;m_argumentList = WTFMove(argumentList);</span>
  }
  
  void CSSSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
  {
      createRareData();
</pre>
<center><a href="CSSSegmentedFontFace.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelector.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
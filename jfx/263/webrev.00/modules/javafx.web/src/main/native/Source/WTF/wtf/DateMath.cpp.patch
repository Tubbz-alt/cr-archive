diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
- * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  * Copyright (C) 2009 Google Inc. All rights reserved.
  * Copyright (C) 2007-2009 Torch Mobile, Inc.
  * Copyright (C) 2010 &yet, LLC. (nate@andyet.net)
  *
  * The Original Code is Mozilla Communicator client code, released
@@ -107,19 +107,17 @@
     return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
 }
 
 /* Constants */
 
-static const double maxUnixTime = 2145859200.0; // 12/31/2037
-// ECMAScript asks not to support for a date of which total
-// millisecond value is larger than the following value.
-// See 15.9.1.14 of ECMA-262 5th edition.
-static const double maxECMAScriptTime = 8.64E15;
+const char* const weekdayName[7] = { "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" };
+const char* const monthName[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
+const char* const monthFullName[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
 
 // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
 // First for non-leap years, then for leap years.
-static const int firstDayOfMonth[2][12] = {
+const int firstDayOfMonth[2][12] = {
     {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
 };
 
 #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
@@ -131,189 +129,26 @@
     localtime_s(localTime, localTM);
 #endif
 }
 #endif
 
-bool isLeapYear(int year)
-{
-    if (year % 4 != 0)
-        return false;
-    if (year % 400 == 0)
-        return true;
-    if (year % 100 == 0)
-        return false;
-    return true;
-}
-
-static inline int daysInYear(int year)
-{
-    return 365 + isLeapYear(year);
-}
-
-static inline double daysFrom1970ToYear(int year)
-{
-    // The Gregorian Calendar rules for leap years:
-    // Every fourth year is a leap year.  2004, 2008, and 2012 are leap years.
-    // However, every hundredth year is not a leap year.  1900 and 2100 are not leap years.
-    // Every four hundred years, there's a leap year after all.  2000 and 2400 are leap years.
-
-    static const int leapDaysBefore1971By4Rule = 1970 / 4;
-    static const int excludedLeapDaysBefore1971By100Rule = 1970 / 100;
-    static const int leapDaysBefore1971By400Rule = 1970 / 400;
-
-    const double yearMinusOne = year - 1;
-    const double yearsToAddBy4Rule = floor(yearMinusOne / 4.0) - leapDaysBefore1971By4Rule;
-    const double yearsToExcludeBy100Rule = floor(yearMinusOne / 100.0) - excludedLeapDaysBefore1971By100Rule;
-    const double yearsToAddBy400Rule = floor(yearMinusOne / 400.0) - leapDaysBefore1971By400Rule;
-
-    return 365.0 * (year - 1970.0) + yearsToAddBy4Rule - yearsToExcludeBy100Rule + yearsToAddBy400Rule;
-}
-
-double msToDays(double ms)
-{
-    return floor(ms / msPerDay);
-}
-
 static void appendTwoDigitNumber(StringBuilder& builder, int number)
 {
     ASSERT(number >= 0);
     ASSERT(number < 100);
     builder.append(static_cast<LChar>('0' + number / 10));
     builder.append(static_cast<LChar>('0' + number % 10));
 }
 
-int msToYear(double ms)
-{
-    int approxYear = static_cast<int>(floor(ms / (msPerDay * 365.2425)) + 1970);
-    double msFromApproxYearTo1970 = msPerDay * daysFrom1970ToYear(approxYear);
-    if (msFromApproxYearTo1970 > ms)
-        return approxYear - 1;
-    if (msFromApproxYearTo1970 + msPerDay * daysInYear(approxYear) <= ms)
-        return approxYear + 1;
-    return approxYear;
-}
-
-int dayInYear(double ms, int year)
-{
-    return static_cast<int>(msToDays(ms) - daysFrom1970ToYear(year));
-}
-
 static inline double msToMilliseconds(double ms)
 {
     double result = fmod(ms, msPerDay);
     if (result < 0)
         result += msPerDay;
     return result;
 }
 
-int msToMinutes(double ms)
-{
-    double result = fmod(floor(ms / msPerMinute), minutesPerHour);
-    if (result < 0)
-        result += minutesPerHour;
-    return static_cast<int>(result);
-}
-
-int msToHours(double ms)
-{
-    double result = fmod(floor(ms/msPerHour), hoursPerDay);
-    if (result < 0)
-        result += hoursPerDay;
-    return static_cast<int>(result);
-}
-
-int monthFromDayInYear(int dayInYear, bool leapYear)
-{
-    const int d = dayInYear;
-    int step;
-
-    if (d < (step = 31))
-        return 0;
-    step += (leapYear ? 29 : 28);
-    if (d < step)
-        return 1;
-    if (d < (step += 31))
-        return 2;
-    if (d < (step += 30))
-        return 3;
-    if (d < (step += 31))
-        return 4;
-    if (d < (step += 30))
-        return 5;
-    if (d < (step += 31))
-        return 6;
-    if (d < (step += 31))
-        return 7;
-    if (d < (step += 30))
-        return 8;
-    if (d < (step += 31))
-        return 9;
-    if (d < (step += 30))
-        return 10;
-    return 11;
-}
-
-static inline bool checkMonth(int dayInYear, int& startDayOfThisMonth, int& startDayOfNextMonth, int daysInThisMonth)
-{
-    startDayOfThisMonth = startDayOfNextMonth;
-    startDayOfNextMonth += daysInThisMonth;
-    return (dayInYear <= startDayOfNextMonth);
-}
-
-int dayInMonthFromDayInYear(int dayInYear, bool leapYear)
-{
-    const int d = dayInYear;
-    int step;
-    int next = 30;
-
-    if (d <= next)
-        return d + 1;
-    const int daysInFeb = (leapYear ? 29 : 28);
-    if (checkMonth(d, step, next, daysInFeb))
-        return d - step;
-    if (checkMonth(d, step, next, 31))
-        return d - step;
-    if (checkMonth(d, step, next, 30))
-        return d - step;
-    if (checkMonth(d, step, next, 31))
-        return d - step;
-    if (checkMonth(d, step, next, 30))
-        return d - step;
-    if (checkMonth(d, step, next, 31))
-        return d - step;
-    if (checkMonth(d, step, next, 31))
-        return d - step;
-    if (checkMonth(d, step, next, 30))
-        return d - step;
-    if (checkMonth(d, step, next, 31))
-        return d - step;
-    if (checkMonth(d, step, next, 30))
-        return d - step;
-    step = next;
-    return d - step;
-}
-
-int dayInYear(int year, int month, int day)
-{
-    return firstDayOfMonth[isLeapYear(year)][month] + day - 1;
-}
-
-double dateToDaysFrom1970(int year, int month, int day)
-{
-    year += month / 12;
-
-    month %= 12;
-    if (month < 0) {
-        month += 12;
-        --year;
-    }
-
-    double yearday = floor(daysFrom1970ToYear(year));
-    ASSERT((year >= 1970 && yearday >= 0) || (year < 1970 && yearday < 0));
-    return yearday + dayInYear(year, month, day);
-}
-
 // There is a hard limit at 2038 that we currently do not have a workaround
 // for (rdar://problem/5052975).
 static inline int maximumYearForDST()
 {
     return 2037;
@@ -432,13 +267,13 @@
 #endif
 
 #if HAVE(TIMEGM)
     time_t utcOffset = timegm(&localt) - mktime(&localt);
 #else
-    // Using a canned date of 01/01/2009 on platforms with weaker date-handling foo.
-    localt.tm_year = 109;
-    time_t utcOffset = 1230768000 - mktime(&localt);
+    // Using a canned date of 01/01/2019 on platforms with weaker date-handling foo.
+    localt.tm_year = 119;
+    time_t utcOffset = 1546300800 - mktime(&localt);
 #endif
 
     return static_cast<int32_t>(utcOffset * 1000);
 #endif
 }
@@ -540,11 +375,11 @@
 #endif
 }
 
 void initializeDates()
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     static bool alreadyInitialized;
     ASSERT(!alreadyInitialized);
     alreadyInitialized = true;
 #endif
 
@@ -681,15 +516,17 @@
     if ((postParsePosition - currentPosition) != 2)
         return 0;
     return postParsePosition;
 }
 
-// Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)00:00].
+// Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)].
 // Fractional seconds parsing is lenient, allows any number of digits.
 // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
-static char* parseES5TimePortion(char* currentPosition, long& hours, long& minutes, double& seconds, long& timeZoneSeconds)
+static char* parseES5TimePortion(char* currentPosition, long& hours, long& minutes, double& seconds, bool& isLocalTime, long& timeZoneSeconds)
 {
+    isLocalTime = false;
+
     char* postParsePosition;
     if (!isASCIIDigit(*currentPosition))
         return 0;
     if (!parseLong(currentPosition, &postParsePosition, 10, &hours))
         return 0;
@@ -738,38 +575,55 @@
     }
 
     if (*currentPosition == 'Z')
         return currentPosition + 1;
 
+    // Parse (+|-)(00:00|0000|00).
     bool tzNegative;
     if (*currentPosition == '-')
         tzNegative = true;
     else if (*currentPosition == '+')
         tzNegative = false;
-    else
-        return currentPosition; // no timezone
+    else {
+        isLocalTime = true;
+        return currentPosition;
+    }
     ++currentPosition;
 
-    long tzHours;
-    long tzHoursAbs;
-    long tzMinutes;
+    long tzHours = 0;
+    long tzHoursAbs = 0;
+    long tzMinutes = 0;
 
     if (!isASCIIDigit(*currentPosition))
         return 0;
     if (!parseLong(currentPosition, &postParsePosition, 10, &tzHours))
         return 0;
-    if (*postParsePosition != ':' || (postParsePosition - currentPosition) != 2)
-        return 0;
-    tzHoursAbs = labs(tzHours);
-    currentPosition = postParsePosition + 1;
+    if (*postParsePosition != ':') {
+        if ((postParsePosition - currentPosition) == 2) {
+            // "00" case.
+            tzHoursAbs = labs(tzHours);
+        } else if ((postParsePosition - currentPosition) == 4) {
+            // "0000" case.
+            tzHoursAbs = labs(tzHours);
+            tzMinutes = tzHoursAbs % 100;
+            tzHoursAbs = tzHoursAbs / 100;
+        } else
+            return 0;
+    } else {
+        // "00:00" case.
+        if ((postParsePosition - currentPosition) != 2)
+            return 0;
+        tzHoursAbs = labs(tzHours);
+        currentPosition = postParsePosition + 1; // Skip ":".
 
-    if (!isASCIIDigit(*currentPosition))
-        return 0;
-    if (!parseLong(currentPosition, &postParsePosition, 10, &tzMinutes))
-        return 0;
-    if ((postParsePosition - currentPosition) != 2)
-        return 0;
+        if (!isASCIIDigit(*currentPosition))
+            return 0;
+        if (!parseLong(currentPosition, &postParsePosition, 10, &tzMinutes))
+            return 0;
+        if ((postParsePosition - currentPosition) != 2)
+            return 0;
+    }
     currentPosition = postParsePosition;
 
     if (tzHoursAbs > 24)
         return 0;
     if (tzMinutes < 0 || tzMinutes > 59)
@@ -780,12 +634,14 @@
         timeZoneSeconds = -timeZoneSeconds;
 
     return currentPosition;
 }
 
-double parseES5DateFromNullTerminatedCharacters(const char* dateString)
+double parseES5DateFromNullTerminatedCharacters(const char* dateString, bool& isLocalTime)
 {
+    isLocalTime = false;
+
     // This parses a date of the form defined in ecma262/#sec-date-time-string-format
     // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
     // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
 
     static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
@@ -802,13 +658,14 @@
     // Parse the date YYYY[-MM[-DD]]
     char* currentPosition = parseES5DatePortion(dateString, year, month, day);
     if (!currentPosition)
         return std::numeric_limits<double>::quiet_NaN();
     // Look for a time portion.
+    // Note: As of ES2016, when a UTC offset is missing, date-time forms are local time while date-only forms are UTC.
     if (*currentPosition == 'T') {
-        // Parse the time HH:mm[:ss[.sss]][Z|(+|-)00:00]
-        currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, timeZoneSeconds);
+        // Parse the time HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)]
+        currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, isLocalTime, timeZoneSeconds);
         if (!currentPosition)
             return std::numeric_limits<double>::quiet_NaN();
     }
     // Check that we have parsed all characters in the string.
     if (*currentPosition)
@@ -838,14 +695,14 @@
     double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
     return dateSeconds * msPerSecond;
 }
 
 // Odd case where 'exec' is allowed to be 0, to accomodate a caller in WebCore.
-double parseDateFromNullTerminatedCharacters(const char* dateString, bool& haveTZ, int& offset)
+double parseDateFromNullTerminatedCharacters(const char* dateString, bool& isLocalTime)
 {
-    haveTZ = false;
-    offset = 0;
+    isLocalTime = true;
+    int offset = 0;
 
     // This parses a date in the form:
     //     Tuesday, 09-Nov-99 23:12:40 GMT
     // or
     //     Sat, 01-Jan-2000 08:00:00 GMT
@@ -1059,11 +916,11 @@
     // Don't fail if the time zone is missing.
     // Some websites omit the time zone (4275206).
     if (*dateString) {
         if (startsWithLettersIgnoringASCIICase(dateString, "gmt") || startsWithLettersIgnoringASCIICase(dateString, "utc")) {
             dateString += 3;
-            haveTZ = true;
+            isLocalTime = false;
         }
 
         if (*dateString == '+' || *dateString == '-') {
             int o;
             if (!parseInt(dateString, &newPosStr, 10, &o))
@@ -1086,20 +943,20 @@
                 if (!parseInt(dateString, &newPosStr, 10, &o2))
                     return std::numeric_limits<double>::quiet_NaN();
                 dateString = newPosStr;
                 offset = (o * 60 + o2) * sgn;
             }
-            haveTZ = true;
+            isLocalTime = false;
         } else {
             for (auto& knownZone : knownZones) {
                 // Since the passed-in length is used for both strings, the following checks that
                 // dateString has the time zone name as a prefix, not that it is equal.
                 auto length = strlen(knownZone.tzName);
                 if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
                     offset = knownZone.tzOffset;
                     dateString += length;
-                    haveTZ = true;
+                    isLocalTime = false;
                     break;
                 }
             }
         }
     }
@@ -1139,33 +996,23 @@
         //    may not be a leap year. In that case, `new Date("Feb 29").getMonth()` becomes 2 (March).
         year = 2000;
     }
     ASSERT(year);
 
-    return ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) * msPerSecond;
+    double dateSeconds = ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) - offset * secondsPerMinute;
+    return dateSeconds * msPerSecond;
 }
 
 double parseDateFromNullTerminatedCharacters(const char* dateString)
 {
-    bool haveTZ;
-    int offset;
-    double ms = parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);
-    if (std::isnan(ms))
-        return std::numeric_limits<double>::quiet_NaN();
-
-    // fall back to local timezone
-    if (!haveTZ)
-        offset = calculateLocalTimeOffset(ms, LocalTime).offset / msPerMinute; // ms value is in local time milliseconds.
+    bool isLocalTime;
+    double value = parseDateFromNullTerminatedCharacters(dateString, isLocalTime);
 
-    return ms - (offset * msPerMinute);
-}
+    if (isLocalTime)
+        value -= calculateLocalTimeOffset(value, LocalTime).offset;
 
-double timeClip(double t)
-{
-    if (std::abs(t) > maxECMAScriptTime)
-        return std::numeric_limits<double>::quiet_NaN();
-    return std::trunc(t) + 0.0;
+    return value;
 }
 
 // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
 String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
 {

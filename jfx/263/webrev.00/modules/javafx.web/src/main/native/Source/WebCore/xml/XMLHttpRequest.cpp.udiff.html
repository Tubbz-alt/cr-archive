<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NativeXPathNSResolver.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XMLHttpRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -31,10 +31,11 @@</span>
  #include &quot;DOMWindow.h&quot;
  #include &quot;Event.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;File.h&quot;
  #include &quot;HTMLDocument.h&quot;
<span class="udiff-line-added">+ #include &quot;HTMLIFrameElement.h&quot;</span>
  #include &quot;HTTPHeaderNames.h&quot;
  #include &quot;HTTPHeaderValues.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;JSDOMBinding.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -114,15 +115,13 @@</span>
      , m_error(false)
      , m_uploadListenerFlag(false)
      , m_uploadComplete(false)
      , m_wasAbortedByClient(false)
      , m_responseCacheIsValid(false)
<span class="udiff-line-removed">-     , m_dispatchErrorOnResuming(false)</span>
      , m_readyState(static_cast&lt;unsigned&gt;(UNSENT))
      , m_responseType(static_cast&lt;unsigned&gt;(ResponseType::EmptyString))
<span class="udiff-line-modified-removed">-     , m_progressEventThrottle(this)</span>
<span class="udiff-line-removed">-     , m_resumeTimer(*this, &amp;XMLHttpRequest::resumeTimerFired)</span>
<span class="udiff-line-modified-added">+     , m_progressEventThrottle(*this)</span>
      , m_networkErrorTimer(*this, &amp;XMLHttpRequest::networkErrorTimerFired)
      , m_timeoutTimer(*this, &amp;XMLHttpRequest::didReachTimeout)
      , m_maximumIntervalForUserGestureForwarding(maximumIntervalForUserGestureForwarding)
  {
  #ifndef NDEBUG
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -171,11 +170,11 @@</span>
  
      if (!doneWithoutErrors())
          return nullptr;
  
      if (!m_createdDocument) {
<span class="udiff-line-modified-removed">-         auto&amp; context = *scriptExecutionContext();</span>
<span class="udiff-line-modified-added">+         auto&amp; context = downcast&lt;Document&gt;(*scriptExecutionContext());</span>
  
          String mimeType = responseMIMEType();
          bool isHTML = equalLettersIgnoringASCIICase(mimeType, &quot;text/html&quot;);
  
          // The W3C spec requires the final MIME type to be some valid XML type, or text/html.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -183,16 +182,16 @@</span>
          if ((m_response.isHTTP() &amp;&amp; !responseIsXML() &amp;&amp; !isHTML)
              || (isHTML &amp;&amp; responseType() == ResponseType::EmptyString)) {
              m_responseDocument = nullptr;
          } else {
              if (isHTML)
<span class="udiff-line-modified-removed">-                 m_responseDocument = HTMLDocument::create(context.sessionID(), nullptr, m_url);</span>
<span class="udiff-line-modified-added">+                 m_responseDocument = HTMLDocument::create(nullptr, m_response.url());</span>
              else
<span class="udiff-line-modified-removed">-                 m_responseDocument = XMLDocument::create(context.sessionID(), nullptr, m_url);</span>
<span class="udiff-line-modified-added">+                 m_responseDocument = XMLDocument::create(nullptr, m_response.url());</span>
              m_responseDocument-&gt;overrideLastModified(m_response.lastModified());
              m_responseDocument-&gt;setContent(m_responseBuilder.toStringPreserveCapacity());
<span class="udiff-line-modified-removed">-             m_responseDocument-&gt;setContextDocument(downcast&lt;Document&gt;(context));</span>
<span class="udiff-line-modified-added">+             m_responseDocument-&gt;setContextDocument(context);</span>
              m_responseDocument-&gt;setSecurityOriginPolicy(context.securityOriginPolicy());
              m_responseDocument-&gt;overrideMIMEType(mimeType);
  
              if (!m_responseDocument-&gt;wellFormed())
                  m_responseDocument = nullptr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -212,11 +211,11 @@</span>
      Vector&lt;uint8_t&gt; data;
      if (m_binaryResponseBuilder)
          data.append(m_binaryResponseBuilder-&gt;data(), m_binaryResponseBuilder-&gt;size());
      m_binaryResponseBuilder = nullptr;
      String normalizedContentType = Blob::normalizedContentType(responseMIMEType()); // responseMIMEType defaults to text/xml which may be incorrect.
<span class="udiff-line-modified-removed">-     return Blob::create(scriptExecutionContext()-&gt;sessionID(), WTFMove(data), normalizedContentType);</span>
<span class="udiff-line-modified-added">+     return Blob::create(WTFMove(data), normalizedContentType);</span>
  }
  
  RefPtr&lt;ArrayBuffer&gt; XMLHttpRequest::createResponseArrayBuffer()
  {
      ASSERT(responseType() == ResponseType::Arraybuffer);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,32 +333,37 @@</span>
      return open(method, scriptExecutionContext()-&gt;completeURL(url), true);
  }
  
  ExceptionOr&lt;void&gt; XMLHttpRequest::open(const String&amp; method, const URL&amp; url, bool async)
  {
<span class="udiff-line-added">+     auto* context = scriptExecutionContext();</span>
<span class="udiff-line-added">+     bool contextIsDocument = is&lt;Document&gt;(*context);</span>
<span class="udiff-line-added">+     if (contextIsDocument &amp;&amp; !downcast&lt;Document&gt;(*context).isFullyActive())</span>
<span class="udiff-line-added">+         return Exception { InvalidStateError, &quot;Document is not fully active&quot;_s };</span>
<span class="udiff-line-added">+ </span>
      if (!isValidHTTPToken(method))
          return Exception { SyntaxError };
  
      if (isForbiddenMethod(method))
          return Exception { SecurityError };
  
      if (!url.isValid())
          return Exception { SyntaxError };
  
<span class="udiff-line-modified-removed">-     if (!async &amp;&amp; scriptExecutionContext()-&gt;isDocument()) {</span>
<span class="udiff-line-modified-added">+     if (!async &amp;&amp; contextIsDocument) {</span>
          // Newer functionality is not available to synchronous requests in window contexts, as a spec-mandated
          // attempt to discourage synchronous XHR use. responseType is one such piece of functionality.
          // We&#39;ll only disable this functionality for HTTP(S) requests since sync requests for local protocols
          // such as file: and data: still make sense to allow.
          if (url.protocolIsInHTTPFamily() &amp;&amp; responseType() != ResponseType::EmptyString) {
<span class="udiff-line-modified-removed">-             logConsoleError(scriptExecutionContext(), &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);</span>
<span class="udiff-line-modified-added">+             logConsoleError(context, &quot;Synchronous HTTP(S) requests made from the window context cannot have XMLHttpRequest.responseType set.&quot;);</span>
              return Exception { InvalidAccessError };
          }
  
          // Similarly, timeouts are disabled for synchronous requests as well.
          if (m_timeoutMilliseconds &gt; 0) {
<span class="udiff-line-modified-removed">-             logConsoleError(scriptExecutionContext(), &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);</span>
<span class="udiff-line-modified-added">+             logConsoleError(context, &quot;Synchronous XMLHttpRequests must not have a timeout value set.&quot;);</span>
              return Exception { InvalidAccessError };
          }
      }
  
      if (!internalAbort())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -375,11 +379,11 @@</span>
      // clear stuff from possible previous load
      clearResponse();
      clearRequest();
  
      m_url = url;
<span class="udiff-line-modified-removed">-     scriptExecutionContext()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);</span>
<span class="udiff-line-modified-added">+     context-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);</span>
  
      m_async = async;
  
      ASSERT(!m_loader);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -407,10 +411,15 @@</span>
      if (!scriptExecutionContext())
          return ExceptionOr&lt;void&gt; { };
  
      auto&amp; context = *scriptExecutionContext();
  
<span class="udiff-line-added">+     if (is&lt;Document&gt;(context) &amp;&amp; downcast&lt;Document&gt;(context).shouldIgnoreSyncXHRs()) {</span>
<span class="udiff-line-added">+         logConsoleError(scriptExecutionContext(), makeString(&quot;Ignoring XMLHttpRequest.send() call for &#39;&quot;, m_url.string(), &quot;&#39; because the maximum number of synchronous failures was reached.&quot;));</span>
<span class="udiff-line-added">+         return ExceptionOr&lt;void&gt; { };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if (readyState() != OPENED || m_sendFlag)
          return ExceptionOr&lt;void&gt; { Exception { InvalidStateError } };
      ASSERT(!m_loader);
  
      // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -621,11 +630,11 @@</span>
      m_sendFlag = true;
  
      if (m_async) {
          m_progressEventThrottle.dispatchProgressEvent(eventNames().loadstartEvent);
          if (!m_uploadComplete &amp;&amp; m_uploadListenerFlag)
<span class="udiff-line-modified-removed">-             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes(scriptExecutionContext()-&gt;sessionID()));</span>
<span class="udiff-line-modified-added">+             m_upload-&gt;dispatchProgressEvent(eventNames().loadstartEvent, 0, request.httpBody()-&gt;lengthInBytes());</span>
  
          if (readyState() != OPENED || !m_sendFlag || m_loader)
              return { };
  
          // ThreadableLoader::create can return null here, for example if we&#39;re no longer attached to a page or if a content blocker blocks the load.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -640,10 +649,13 @@</span>
          // a request is in progress because we need to keep the listeners alive,
          // and they are referenced by the JavaScript wrapper.
          if (m_loader)
              setPendingActivity(*this);
      } else {
<span class="udiff-line-added">+         if (scriptExecutionContext()-&gt;isDocument() &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::SyncXHR, *document()))</span>
<span class="udiff-line-added">+             return Exception { NetworkError };</span>
<span class="udiff-line-added">+ </span>
          request.setDomainForCachePartition(scriptExecutionContext()-&gt;domainForCachePartition());
          InspectorInstrumentation::willLoadXHRSynchronously(scriptExecutionContext());
          ThreadableLoader::loadResourceSynchronously(*scriptExecutionContext(), WTFMove(request), *this, options);
          InspectorInstrumentation::didLoadXHRSynchronously(scriptExecutionContext());
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1068,10 +1080,12 @@</span>
      }
  }
  
  void XMLHttpRequest::dispatchEvent(Event&amp; event)
  {
<span class="udiff-line-added">+     RELEASE_ASSERT(!scriptExecutionContext()-&gt;activeDOMObjectsAreSuspended());</span>
<span class="udiff-line-added">+ </span>
      if (m_userGestureToken &amp;&amp; m_userGestureToken-&gt;hasExpired(m_maximumIntervalForUserGestureForwarding))
          m_userGestureToken = nullptr;
  
      if (readyState() != DONE || !m_userGestureToken || !m_userGestureToken-&gt;processingUserGesture()) {
          EventTarget::dispatchEvent(event);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1118,58 +1132,23 @@</span>
      changeState(DONE);
  
      dispatchErrorEvents(eventNames().timeoutEvent);
  }
  
<span class="udiff-line-removed">- bool XMLHttpRequest::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     // If the load event has not fired yet, cancelling the load in suspend() may cause</span>
<span class="udiff-line-removed">-     // the load event to be fired and arbitrary JS execution, which would be unsafe.</span>
<span class="udiff-line-removed">-     // Therefore, we prevent suspending in this case.</span>
<span class="udiff-line-removed">-     return document()-&gt;loadEventFinished();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  const char* XMLHttpRequest::activeDOMObjectName() const
  {
      return &quot;XMLHttpRequest&quot;;
  }
  
<span class="udiff-line-modified-removed">- void XMLHttpRequest::suspend(ReasonForSuspension reason)</span>
<span class="udiff-line-modified-added">+ void XMLHttpRequest::suspend(ReasonForSuspension)</span>
  {
      m_progressEventThrottle.suspend();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (m_resumeTimer.isActive()) {</span>
<span class="udiff-line-removed">-         m_resumeTimer.stop();</span>
<span class="udiff-line-removed">-         m_dispatchErrorOnResuming = true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (reason == ReasonForSuspension::PageCache &amp;&amp; m_loader) {</span>
<span class="udiff-line-removed">-         // Going into PageCache, abort the request and dispatch a network error on resuming.</span>
<span class="udiff-line-removed">-         genericError();</span>
<span class="udiff-line-removed">-         m_dispatchErrorOnResuming = true;</span>
<span class="udiff-line-removed">-         bool aborted = internalAbort();</span>
<span class="udiff-line-removed">-         // It should not be possible to restart the load when aborting in suspend() because</span>
<span class="udiff-line-removed">-         // we are not allowed to execute in JS in suspend().</span>
<span class="udiff-line-removed">-         ASSERT_UNUSED(aborted, aborted);</span>
<span class="udiff-line-removed">-     }</span>
  }
  
  void XMLHttpRequest::resume()
  {
      m_progressEventThrottle.resume();
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // We are not allowed to execute arbitrary JS in resume() so dispatch</span>
<span class="udiff-line-removed">-     // the error event in a timer.</span>
<span class="udiff-line-removed">-     if (m_dispatchErrorOnResuming &amp;&amp; !m_resumeTimer.isActive())</span>
<span class="udiff-line-removed">-         m_resumeTimer.startOneShot(0_s);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void XMLHttpRequest::resumeTimerFired()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(m_dispatchErrorOnResuming);</span>
<span class="udiff-line-removed">-     m_dispatchErrorOnResuming = false;</span>
<span class="udiff-line-removed">-     dispatchErrorEvents(eventNames().errorEvent);</span>
  }
  
  void XMLHttpRequest::stop()
  {
      internalAbort();
</pre>
<center><a href="NativeXPathNSResolver.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XMLHttpRequest.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
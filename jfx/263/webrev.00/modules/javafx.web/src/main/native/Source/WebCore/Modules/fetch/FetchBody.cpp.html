<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBody.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Canon Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted, provided that the following conditions
  6  * are required to be met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Canon Inc. nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBody.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;FetchBodyOwner.h&quot;
 34 #include &quot;FetchBodySource.h&quot;
 35 #include &quot;FetchHeaders.h&quot;
 36 #include &quot;HTTPHeaderValues.h&quot;
 37 #include &quot;HTTPParsers.h&quot;
 38 #include &quot;JSDOMPromiseDeferred.h&quot;
 39 #include &quot;ReadableStreamSource.h&quot;
 40 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 ExceptionOr&lt;FetchBody&gt; FetchBody::extract(Init&amp;&amp; value, String&amp; contentType)
 45 {
 46     return WTF::switchOn(value, [&amp;](RefPtr&lt;Blob&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 47         Ref&lt;const Blob&gt; blob = value.releaseNonNull();
 48         if (!blob-&gt;type().isEmpty())
 49             contentType = blob-&gt;type();
 50         return FetchBody(WTFMove(blob));
 51     }, [&amp;](RefPtr&lt;DOMFormData&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 52         Ref&lt;DOMFormData&gt; domFormData = value.releaseNonNull();
 53         auto formData = FormData::createMultiPart(domFormData.get());
 54         contentType = makeString(&quot;multipart/form-data; boundary=&quot;, formData-&gt;boundary().data());
 55         return FetchBody(WTFMove(formData));
 56     }, [&amp;](RefPtr&lt;URLSearchParams&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 57         Ref&lt;const URLSearchParams&gt; params = value.releaseNonNull();
 58         contentType = HTTPHeaderValues::formURLEncodedContentType();
 59         return FetchBody(WTFMove(params));
 60     }, [&amp;](RefPtr&lt;ArrayBuffer&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 61         Ref&lt;const ArrayBuffer&gt; buffer = value.releaseNonNull();
 62         return FetchBody(WTFMove(buffer));
 63     }, [&amp;](RefPtr&lt;ArrayBufferView&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 64         Ref&lt;const ArrayBufferView&gt; buffer = value.releaseNonNull();
 65         return FetchBody(WTFMove(buffer));
 66     }, [&amp;](RefPtr&lt;ReadableStream&gt;&amp; stream) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 67         if (stream-&gt;isDisturbed())
 68             return Exception { TypeError, &quot;Input body is disturbed.&quot;_s };
 69         if (stream-&gt;isLocked())
 70             return Exception { TypeError, &quot;Input body is locked.&quot;_s };
 71 
 72         return FetchBody(stream.releaseNonNull());
 73     }, [&amp;](String&amp; value) -&gt; ExceptionOr&lt;FetchBody&gt; {
 74         contentType = HTTPHeaderValues::textPlainContentType();
 75         return FetchBody(WTFMove(value));
 76     });
 77 }
 78 
 79 Optional&lt;FetchBody&gt; FetchBody::fromFormData(FormData&amp; formData)
 80 {
 81     ASSERT(!formData.isEmpty());
 82 
 83     if (auto buffer = formData.asSharedBuffer()) {
 84         FetchBody body;
 85         body.m_consumer.setData(buffer.releaseNonNull());
 86         return body;
 87     }
 88 
 89     auto url = formData.asBlobURL();
 90     if (!url.isNull()) {
 91         // FIXME: Properly set mime type and size of the blob.
 92         Ref&lt;const Blob&gt; blob = Blob::deserialize(url, { }, { }, { });
 93         return FetchBody { WTFMove(blob) };
 94     }
 95 
 96     // FIXME: Support form data bodies.
 97     return WTF::nullopt;
 98 }
 99 
100 void FetchBody::arrayBuffer(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
101 {
102     m_consumer.setType(FetchBodyConsumer::Type::ArrayBuffer);
103     consume(owner, WTFMove(promise));
104 }
105 
106 void FetchBody::blob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
107 {
108     m_consumer.setType(FetchBodyConsumer::Type::Blob);
109     m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
110     consume(owner, WTFMove(promise));
111 }
112 
113 void FetchBody::json(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
114 {
115     if (isText()) {
116         fulfillPromiseWithJSON(WTFMove(promise), textBody());
117         return;
118     }
119     m_consumer.setType(FetchBodyConsumer::Type::JSON);
120     consume(owner, WTFMove(promise));
121 }
122 
123 void FetchBody::text(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
124 {
125     if (isText()) {
126         promise-&gt;resolve&lt;IDLDOMString&gt;(textBody());
127         return;
128     }
129     m_consumer.setType(FetchBodyConsumer::Type::Text);
130     consume(owner, WTFMove(promise));
131 }
132 
133 void FetchBody::formData(FetchBodyOwner&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
134 {
135     promise.get().reject(NotSupportedError);
136 }
137 
138 void FetchBody::consumeOnceLoadingFinished(FetchBodyConsumer::Type type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
139 {
140     m_consumer.setType(type);
141     m_consumer.setConsumePromise(WTFMove(promise));
142     if (type == FetchBodyConsumer::Type::Blob)
143         m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
144 }
145 
146 void FetchBody::consume(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
147 {
148     if (isArrayBuffer()) {
149         consumeArrayBuffer(WTFMove(promise));
150         return;
151     }
152     if (isArrayBufferView()) {
153         consumeArrayBufferView(WTFMove(promise));
154         return;
155     }
156     if (isText()) {
157         consumeText(WTFMove(promise), textBody());
158         return;
159     }
160     if (isURLSearchParams()) {
161         consumeText(WTFMove(promise), urlSearchParamsBody().toString());
162         return;
163     }
164     if (isBlob()) {
165         consumeBlob(owner, WTFMove(promise));
166         return;
167     }
168     if (isFormData()) {
169         // FIXME: Support consuming FormData.
170         promise-&gt;reject(NotSupportedError);
171         return;
172     }
173 
174     m_consumer.resolve(WTFMove(promise), m_readableStream.get());
175 }
176 
177 #if ENABLE(STREAMS_API)
178 
179 void FetchBody::consumeAsStream(FetchBodyOwner&amp; owner, FetchBodySource&amp; source)
180 {
181     bool closeStream = false;
182     if (isArrayBuffer()) {
183         closeStream = source.enqueue(ArrayBuffer::tryCreate(arrayBufferBody().data(), arrayBufferBody().byteLength()));
184         m_data = nullptr;
185     } else if (isArrayBufferView()) {
186         closeStream = source.enqueue(ArrayBuffer::tryCreate(arrayBufferViewBody().baseAddress(), arrayBufferViewBody().byteLength()));
187         m_data = nullptr;
188     } else if (isText()) {
189         auto data = UTF8Encoding().encode(textBody(), UnencodableHandling::Entities);
190         closeStream = source.enqueue(ArrayBuffer::tryCreate(data.data(), data.size()));
191         m_data = nullptr;
192     } else if (isURLSearchParams()) {
193         auto data = UTF8Encoding().encode(urlSearchParamsBody().toString(), UnencodableHandling::Entities);
194         closeStream = source.enqueue(ArrayBuffer::tryCreate(data.data(), data.size()));
195         m_data = nullptr;
196     } else if (isBlob()) {
197         owner.loadBlob(blobBody(), nullptr);
198         m_data = nullptr;
199     } else if (isFormData())
200         source.error(Exception { NotSupportedError, &quot;Not implemented&quot;_s });
201     else if (m_consumer.hasData())
202         closeStream = source.enqueue(m_consumer.takeAsArrayBuffer());
203     else
204         closeStream = true;
205 
206     if (closeStream)
207         source.close();
208 }
209 
210 #endif
211 
212 void FetchBody::consumeArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
213 {
214     m_consumer.resolveWithData(WTFMove(promise), static_cast&lt;const uint8_t*&gt;(arrayBufferBody().data()), arrayBufferBody().byteLength());
215     m_data = nullptr;
216 }
217 
218 void FetchBody::consumeArrayBufferView(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
219 {
220     m_consumer.resolveWithData(WTFMove(promise), static_cast&lt;const uint8_t*&gt;(arrayBufferViewBody().baseAddress()), arrayBufferViewBody().byteLength());
221     m_data = nullptr;
222 }
223 
224 void FetchBody::consumeText(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; text)
225 {
226     auto data = UTF8Encoding().encode(text, UnencodableHandling::Entities);
227     m_consumer.resolveWithData(WTFMove(promise), data.data(), data.size());
228     m_data = nullptr;
229 }
230 
231 void FetchBody::consumeBlob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
232 {
233     m_consumer.setConsumePromise(WTFMove(promise));
234     owner.loadBlob(blobBody(), &amp;m_consumer);
235     m_data = nullptr;
236 }
237 
238 void FetchBody::loadingFailed(const Exception&amp; exception)
239 {
240     m_consumer.loadingFailed(exception);
241 }
242 
243 void FetchBody::loadingSucceeded()
244 {
245     m_consumer.loadingSucceeded();
246 }
247 
248 RefPtr&lt;FormData&gt; FetchBody::bodyAsFormData() const
249 {
250     if (isText())
251         return FormData::create(UTF8Encoding().encode(textBody(), UnencodableHandling::Entities));
252     if (isURLSearchParams())
253         return FormData::create(UTF8Encoding().encode(urlSearchParamsBody().toString(), UnencodableHandling::Entities));
254     if (isBlob()) {
255         auto body = FormData::create();
256         body-&gt;appendBlob(blobBody().url());
257         return body;
258     }
259     if (isArrayBuffer())
260         return FormData::create(arrayBufferBody().data(), arrayBufferBody().byteLength());
261     if (isArrayBufferView())
262         return FormData::create(arrayBufferViewBody().baseAddress(), arrayBufferViewBody().byteLength());
263     if (isFormData()) {
264         auto body = makeRef(const_cast&lt;FormData&amp;&gt;(formDataBody()));
265         return body;
266     }
267     if (auto* data = m_consumer.data())
268         return FormData::create(data-&gt;data(), data-&gt;size());
269 
270     ASSERT_NOT_REACHED();
271     return nullptr;
272 }
273 
274 FetchBody::TakenData FetchBody::take()
275 {
276     if (m_consumer.hasData()) {
277         auto buffer = m_consumer.takeData();
278         if (!buffer)
279             return nullptr;
280         return buffer.releaseNonNull();
281     }
282 
283     if (isBlob()) {
284         auto body = FormData::create();
285         body-&gt;appendBlob(blobBody().url());
286         return TakenData { WTFMove(body) };
287     }
288 
289     if (isFormData())
290         return formDataBody();
291 
292     if (isText())
293         return SharedBuffer::create(UTF8Encoding().encode(textBody(), UnencodableHandling::Entities));
294     if (isURLSearchParams())
295         return SharedBuffer::create(UTF8Encoding().encode(urlSearchParamsBody().toString(), UnencodableHandling::Entities));
296 
297     if (isArrayBuffer())
298         return SharedBuffer::create(reinterpret_cast&lt;const char*&gt;(arrayBufferBody().data()), arrayBufferBody().byteLength());
299     if (isArrayBufferView())
300         return SharedBuffer::create(reinterpret_cast&lt;const uint8_t*&gt;(arrayBufferViewBody().baseAddress()), arrayBufferViewBody().byteLength());
301 
302     return nullptr;
303 }
304 
305 FetchBody FetchBody::clone()
306 {
307     FetchBody clone(m_consumer);
308 
309     if (isArrayBuffer())
310         clone.m_data = arrayBufferBody();
311     else if (isArrayBufferView())
312         clone.m_data = arrayBufferViewBody();
313     else if (isBlob())
314         clone.m_data = blobBody();
315     else if (isFormData())
316         clone.m_data = const_cast&lt;FormData&amp;&gt;(formDataBody());
317     else if (isText())
318         clone.m_data = textBody();
319     else if (isURLSearchParams())
320         clone.m_data = urlSearchParamsBody();
321 
322     if (m_readableStream) {
323         auto clones = m_readableStream-&gt;tee();
324         m_readableStream = WTFMove(clones.first);
325         clone.m_readableStream = WTFMove(clones.second);
326     }
327     return clone;
328 }
329 
330 }
    </pre>
  </body>
</html>
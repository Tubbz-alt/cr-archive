diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorFrontendHost.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorFrontendHost.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorFrontendHost.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorFrontendHost.cpp
@@ -42,10 +42,11 @@
 #include "FloatRect.h"
 #include "FocusController.h"
 #include "Frame.h"
 #include "HitTestResult.h"
 #include "InspectorController.h"
+#include "InspectorDebuggableType.h"
 #include "InspectorFrontendClient.h"
 #include "JSDOMConvertInterface.h"
 #include "JSDOMExceptionHandling.h"
 #include "JSExecState.h"
 #include "JSInspectorFrontendHost.h"
@@ -55,10 +56,11 @@
 #include "Pasteboard.h"
 #include "ScriptState.h"
 #include "UserGestureIndicator.h"
 #include <JavaScriptCore/ScriptFunctionCall.h>
 #include <pal/system/Sound.h>
+#include <wtf/JSONValues.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/text/Base64.h>
 
 namespace WebCore {
 
@@ -84,11 +86,11 @@
         , m_frontendApiObject(frontendApiObject)
         , m_items(items)
     {
     }
 
-    virtual ~FrontendMenuProvider()
+    ~FrontendMenuProvider() override
     {
         contextMenuCleared();
     }
 
     void populateContextMenu(ContextMenu* menu) override
@@ -150,19 +152,19 @@
     m_frontendPage = nullptr;
 }
 
 void InspectorFrontendHost::addSelfToGlobalObjectInWorld(DOMWrapperWorld& world)
 {
-    auto& state = *execStateFromPage(world, m_frontendPage);
-    auto& vm = state.vm();
+    auto& lexicalGlobalObject = *execStateFromPage(world, m_frontendPage);
+    auto& vm = lexicalGlobalObject.vm();
     JSC::JSLockHolder lock(vm);
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    auto& globalObject = *JSC::jsCast<JSDOMGlobalObject*>(state.lexicalGlobalObject());
-    globalObject.putDirect(vm, JSC::Identifier::fromString(vm, "InspectorFrontendHost"), toJS<IDLInterface<InspectorFrontendHost>>(state, globalObject, *this));
+    auto& globalObject = *JSC::jsCast<JSDOMGlobalObject*>(&lexicalGlobalObject);
+    globalObject.putDirect(vm, JSC::Identifier::fromString(vm, "InspectorFrontendHost"), toJS<IDLInterface<InspectorFrontendHost>>(lexicalGlobalObject, globalObject, *this));
     if (UNLIKELY(scope.exception()))
-        reportException(&state, scope.exception());
+        reportException(&lexicalGlobalObject, scope.exception());
 }
 
 void InspectorFrontendHost::loaded()
 {
     if (m_client)
@@ -268,36 +270,62 @@
         m_client->moveWindowBy(x, y);
 }
 
 bool InspectorFrontendHost::isRemote() const
 {
-    return m_client ? m_client->isRemote() : false;
+    return m_client && m_client->isRemote();
 }
 
-String InspectorFrontendHost::localizedStringsURL()
+String InspectorFrontendHost::localizedStringsURL() const
 {
     return m_client ? m_client->localizedStringsURL() : String();
 }
 
-String InspectorFrontendHost::backendCommandsURL()
+String InspectorFrontendHost::backendCommandsURL() const
 {
     return m_client ? m_client->backendCommandsURL() : String();
 }
 
-String InspectorFrontendHost::debuggableType()
+static String debuggableTypeToString(DebuggableType debuggableType)
 {
-    return m_client ? m_client->debuggableType() : String();
+    switch (debuggableType) {
+    case DebuggableType::JavaScript:
+        return "javascript"_s;
+    case DebuggableType::Page:
+        return "page"_s;
+    case DebuggableType::ServiceWorker:
+        return "service-worker"_s;
+    case DebuggableType::WebPage:
+        return "web-page"_s;
+    }
+
+    ASSERT_NOT_REACHED();
+    return String();
 }
 
-unsigned InspectorFrontendHost::inspectionLevel()
+InspectorFrontendHost::DebuggableInfo InspectorFrontendHost::debuggableInfo() const
+{
+    if (!m_client)
+        return {debuggableTypeToString(DebuggableType::JavaScript), "Unknown"_s, "Unknown"_s, "Unknown"_s, false};
+
+    return {
+        debuggableTypeToString(m_client->debuggableType()),
+        m_client->targetPlatformName(),
+        m_client->targetBuildVersion(),
+        m_client->targetProductVersion(),
+        m_client->targetIsSimulator(),
+    };
+}
+
+unsigned InspectorFrontendHost::inspectionLevel() const
 {
     return m_client ? m_client->inspectionLevel() : 1;
 }
 
-String InspectorFrontendHost::platform()
+String InspectorFrontendHost::platform() const
 {
-#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
+#if PLATFORM(COCOA)
     return "mac"_s;
 #elif OS(WINDOWS)
     return "windows"_s;
 #elif OS(LINUX)
     return "linux"_s;
@@ -308,11 +336,11 @@
 #else
     return "unknown"_s;
 #endif
 }
 
-String InspectorFrontendHost::port()
+String InspectorFrontendHost::port() const
 {
 #if PLATFORM(GTK)
     return "gtk"_s;
 #else
     return "unknown"_s;
@@ -406,21 +434,21 @@
 void InspectorFrontendHost::showContextMenu(Event& event, Vector<ContextMenuItem>&& items)
 {
 #if ENABLE(CONTEXT_MENUS)
     ASSERT(m_frontendPage);
 
-    auto& state = *execStateFromPage(debuggerWorld(), m_frontendPage);
-    auto& vm = state.vm();
-    auto value = state.lexicalGlobalObject()->get(&state, JSC::Identifier::fromString(vm, "InspectorFrontendAPI"));
+    auto& lexicalGlobalObject = *execStateFromPage(debuggerWorld(), m_frontendPage);
+    auto& vm = lexicalGlobalObject.vm();
+    auto value = lexicalGlobalObject.get(&lexicalGlobalObject, JSC::Identifier::fromString(vm, "InspectorFrontendAPI"));
     ASSERT(value);
     ASSERT(value.isObject());
     auto* frontendAPIObject = asObject(value);
 
     ContextMenu menu;
     populateContextMenu(WTFMove(items), menu);
 
-    auto menuProvider = FrontendMenuProvider::create(this, { &state, frontendAPIObject }, menu.items());
+    auto menuProvider = FrontendMenuProvider::create(this, { &lexicalGlobalObject, frontendAPIObject }, menu.items());
     m_menuProvider = menuProvider.ptr();
     m_frontendPage->contextMenuController().showContextMenu(event, menuProvider);
 #else
     UNUSED_PARAM(event);
     UNUSED_PARAM(items);
@@ -444,10 +472,19 @@
 bool InspectorFrontendHost::isUnderTest()
 {
     return m_client && m_client->isUnderTest();
 }
 
+bool InspectorFrontendHost::isExperimentalBuild()
+{
+#if ENABLE(EXPERIMENTAL_FEATURES)
+    return true;
+#else
+    return false;
+#endif
+}
+
 void InspectorFrontendHost::unbufferedLog(const String& message)
 {
     // This is used only for debugging inspector tests.
     WTFLogAlways("%s", message.utf8().data());
 }
@@ -500,6 +537,78 @@
 
     m_client->showCertificate(certificateInfo);
     return true;
 }
 
+bool InspectorFrontendHost::supportsDiagnosticLogging()
+{
+#if ENABLE(INSPECTOR_TELEMETRY)
+    return m_client && m_client->supportsDiagnosticLogging();
+#else
+    return false;
+#endif
+}
+
+#if ENABLE(INSPECTOR_TELEMETRY)
+bool InspectorFrontendHost::diagnosticLoggingAvailable()
+{
+    return m_client && m_client->diagnosticLoggingAvailable();
+}
+
+static Optional<DiagnosticLoggingClient::ValuePayload> valuePayloadFromJSONValue(const RefPtr<JSON::Value>& value)
+{
+    switch (value->type()) {
+    case JSON::Value::Type::Array:
+    case JSON::Value::Type::Null:
+    case JSON::Value::Type::Object:
+        ASSERT_NOT_REACHED();
+        return WTF::nullopt;
+
+    case JSON::Value::Type::Boolean:
+        bool boolValue;
+        value->asBoolean(boolValue);
+        return DiagnosticLoggingClient::ValuePayload(boolValue);
+
+    case JSON::Value::Type::Double:
+        double doubleValue;
+        value->asDouble(doubleValue);
+        return DiagnosticLoggingClient::ValuePayload(doubleValue);
+
+    case JSON::Value::Type::Integer:
+        long long intValue;
+        value->asInteger(intValue);
+        return DiagnosticLoggingClient::ValuePayload(intValue);
+
+    case JSON::Value::Type::String:
+        String stringValue;
+        value->asString(stringValue);
+        return DiagnosticLoggingClient::ValuePayload(stringValue);
+    }
+
+    ASSERT_NOT_REACHED();
+    return WTF::nullopt;
+}
+
+void InspectorFrontendHost::logDiagnosticEvent(const String& eventName, const String& payloadString)
+{
+    if (!supportsDiagnosticLogging())
+        return;
+
+    RefPtr<JSON::Value> payloadValue;
+    if (!JSON::Value::parseJSON(payloadString, payloadValue))
+        return;
+
+    RefPtr<JSON::Object> payloadObject;
+    if (!payloadValue->asObject(payloadObject))
+        return;
+
+    DiagnosticLoggingClient::ValueDictionary dictionary;
+    for (const auto& [key, value] : *payloadObject) {
+        if (auto valuePayload = valuePayloadFromJSONValue(value))
+            dictionary.set(key, WTFMove(valuePayload.value()));
+    }
+
+    m_client->logDiagnosticEvent(makeString("WebInspector."_s, eventName), dictionary);
+}
+#endif // ENABLE(INSPECTOR_TELEMETRY)
+
 } // namespace WebCore

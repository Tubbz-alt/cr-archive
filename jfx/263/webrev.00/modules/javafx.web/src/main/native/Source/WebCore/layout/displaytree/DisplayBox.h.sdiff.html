<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayRect.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;DisplayRect.h&quot;
 31 #include &quot;LayoutUnits.h&quot;
<span class="line-removed"> 32 #include &quot;RenderStyleConstants.h&quot;</span>
 33 #include &lt;wtf/IsoMalloc.h&gt;
 34 
 35 namespace WebCore {
<span class="line-removed"> 36 </span>
<span class="line-removed"> 37 class RenderStyle;</span>
<span class="line-removed"> 38 </span>
<span class="line-removed"> 39 namespace Layout {</span>
<span class="line-removed"> 40 class BlockFormattingContext;</span>
<span class="line-removed"> 41 class FloatAvoider;</span>
<span class="line-removed"> 42 class FloatBox;</span>
<span class="line-removed"> 43 class FormattingContext;</span>
<span class="line-removed"> 44 class FloatingContext;</span>
<span class="line-removed"> 45 class InlineFormattingContext;</span>
<span class="line-removed"> 46 class LayoutState;</span>
<span class="line-removed"> 47 class TableFormattingContext;</span>
<span class="line-removed"> 48 }</span>
<span class="line-removed"> 49 </span>
 50 namespace Display {
 51 
 52 class Box {
 53     WTF_MAKE_ISO_ALLOCATED(Box);
 54 public:
<span class="line-removed"> 55     friend class Layout::BlockFormattingContext;</span>
<span class="line-removed"> 56     friend class Layout::FloatAvoider;</span>
<span class="line-removed"> 57     friend class Layout::FloatBox;</span>
<span class="line-removed"> 58     friend class Layout::FormattingContext;</span>
<span class="line-removed"> 59     friend class Layout::FloatingContext;</span>
<span class="line-removed"> 60     friend class Layout::InlineFormattingContext;</span>
<span class="line-removed"> 61     friend class Layout::LayoutState;</span>
<span class="line-removed"> 62     friend class Layout::TableFormattingContext;</span>
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64     Box(const RenderStyle&amp;);</span>
 65     Box(const Box&amp;);

 66     ~Box();
 67 
 68     LayoutUnit top() const;
 69     LayoutUnit left() const;
 70     LayoutUnit bottom() const { return top() + height(); }
 71     LayoutUnit right() const { return left() + width(); }
 72 
 73     LayoutPoint topLeft() const;
 74     LayoutPoint bottomRight() const { return { right(), bottom() }; }
 75 
 76     LayoutSize size() const { return { width(), height() }; }
 77     LayoutUnit width() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
 78     LayoutUnit height() const { return borderTop() + paddingBoxHeight() + borderBottom(); }

 79     Rect rect() const { return { top(), left(), width(), height() }; }
 80     Rect rectWithMargin() const;
 81 
 82     Layout::UsedVerticalMargin verticalMargin() const;
 83     Layout::UsedHorizontalMargin horizontalMargin() const;
 84     LayoutUnit marginBefore() const;
 85     LayoutUnit marginStart() const;
 86     LayoutUnit marginAfter() const;
 87     LayoutUnit marginEnd() const;
 88     bool hasCollapsedThroughMargin() const { return m_verticalMargin.isCollapsedThrough(); }
 89     bool hasClearance() const { return m_hasClearance; }
 90 
 91     LayoutUnit nonCollapsedMarginBefore() const;
 92     LayoutUnit nonCollapsedMarginAfter() const;
 93     Optional&lt;LayoutUnit&gt; computedMarginStart() const;
 94     Optional&lt;LayoutUnit&gt; computedMarginEnd() const;
 95 
 96     LayoutUnit borderTop() const;
 97     LayoutUnit borderLeft() const;
 98     LayoutUnit borderBottom() const;
</pre>
<hr />
<pre>
118     LayoutUnit paddingBoxLeft() const { return borderLeft(); }
119     LayoutUnit paddingBoxBottom() const { return paddingBoxTop() + paddingBoxHeight(); }
120     LayoutUnit paddingBoxRight() const { return paddingBoxLeft() + paddingBoxWidth(); }
121     LayoutUnit paddingBoxHeight() const { return paddingTop().valueOr(0) + contentBoxHeight() + paddingBottom().valueOr(0); }
122     LayoutUnit paddingBoxWidth() const { return paddingLeft().valueOr(0) + contentBoxWidth() + paddingRight().valueOr(0); }
123 
124     LayoutUnit borderBoxHeight() const { return borderTop() + paddingBoxHeight() + borderBottom(); }
125     LayoutUnit borderBoxWidth() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
126     LayoutUnit marginBoxHeight() const { return marginBefore() + borderBoxHeight() + marginAfter(); }
127     LayoutUnit marginBoxWidth() const { return marginStart() + borderBoxWidth() + marginEnd(); }
128 
129     LayoutUnit horizontalMarginBorderAndPadding() const { return marginStart() + horizontalBorder() + horizontalPadding().valueOr(0) + marginEnd(); }
130 
131     Rect marginBox() const;
132     Rect nonCollapsedMarginBox() const;
133 
134     Rect borderBox() const;
135     Rect paddingBox() const;
136     Rect contentBox() const;
137 
<span class="line-modified">138 #if !ASSERT_DISABLED</span>
<span class="line-modified">139     void setHasEstimatedMarginBefore() { m_hasEstimatedMarginBefore = true; }</span>
140 #endif
141 
<span class="line-removed">142 private:</span>
<span class="line-removed">143     struct Style {</span>
<span class="line-removed">144         Style(const RenderStyle&amp;);</span>
<span class="line-removed">145 </span>
<span class="line-removed">146         BoxSizing boxSizing { BoxSizing::ContentBox };</span>
<span class="line-removed">147     };</span>
<span class="line-removed">148 </span>
149     void setTopLeft(const LayoutPoint&amp;);
150     void setTop(LayoutUnit);
151     void setLeft(LayoutUnit);
152     void moveHorizontally(LayoutUnit offset) { m_topLeft.move(offset, 0_lu); }
153     void moveVertically(LayoutUnit offset) { m_topLeft.move(0_lu, offset); }


154 
155     void setContentBoxHeight(LayoutUnit);
156     void setContentBoxWidth(LayoutUnit);
157 
158     void setHorizontalMargin(Layout::UsedHorizontalMargin);
159     void setVerticalMargin(Layout::UsedVerticalMargin);
160     void setHorizontalComputedMargin(Layout::ComputedHorizontalMargin);
161     void setHasClearance() { m_hasClearance = true; }
162 
163     void setBorder(Layout::Edges);
164     void setPadding(Optional&lt;Layout::Edges&gt;);
165 
<span class="line-modified">166 #if !ASSERT_DISABLED</span>

167     void invalidateMargin();
168     void invalidateBorder() { m_hasValidBorder = false; }
169     void invalidatePadding() { m_hasValidPadding = false; }
<span class="line-modified">170     void invalidateEstimatedMarginBefore() { m_hasEstimatedMarginBefore = false; }</span>
171 
172     void setHasValidTop() { m_hasValidTop = true; }
173     void setHasValidLeft() { m_hasValidLeft = true; }
174     void setHasValidVerticalMargin() { m_hasValidVerticalMargin = true; }
175     void setHasValidVerticalNonCollapsedMargin() { m_hasValidVerticalNonCollapsedMargin = true; }
176     void setHasValidHorizontalComputedMargin() { m_hasValidHorizontalComputedMargin = true; }
177     void setHasValidHorizontalMargin() { m_hasValidHorizontalMargin = true; }
178 
179     void setHasValidBorder() { m_hasValidBorder = true; }
180     void setHasValidPadding() { m_hasValidPadding = true; }
181 
182     void setHasValidContentHeight() { m_hasValidContentHeight = true; }
183     void setHasValidContentWidth() { m_hasValidContentWidth = true; }
<span class="line-modified">184 #endif</span>
<span class="line-removed">185 </span>
<span class="line-removed">186     const Style m_style;</span>
187 
188     LayoutPoint m_topLeft;
189     LayoutUnit m_contentWidth;
190     LayoutUnit m_contentHeight;
191 
192     Layout::UsedHorizontalMargin m_horizontalMargin;
193     Layout::UsedVerticalMargin m_verticalMargin;
194     Layout::ComputedHorizontalMargin m_horizontalComputedMargin;
195     bool m_hasClearance { false };
196 
197     Layout::Edges m_border;
198     Optional&lt;Layout::Edges&gt; m_padding;
199 
<span class="line-modified">200 #if !ASSERT_DISABLED</span>
201     bool m_hasValidTop { false };
202     bool m_hasValidLeft { false };
203     bool m_hasValidHorizontalMargin { false };
204     bool m_hasValidVerticalMargin { false };
205     bool m_hasValidVerticalNonCollapsedMargin { false };
206     bool m_hasValidHorizontalComputedMargin { false };
207     bool m_hasValidBorder { false };
208     bool m_hasValidPadding { false };
209     bool m_hasValidContentHeight { false };
210     bool m_hasValidContentWidth { false };
<span class="line-modified">211     bool m_hasEstimatedMarginBefore { false };</span>
<span class="line-modified">212 #endif</span>
213 };
214 
<span class="line-modified">215 #if !ASSERT_DISABLED</span>
216 inline void Box::invalidateMargin()
217 {
218     m_hasValidHorizontalMargin = false;
219     m_hasValidVerticalMargin = false;
220 }
221 #endif
222 
223 inline LayoutUnit Box::top() const
224 {
<span class="line-modified">225     ASSERT(m_hasValidTop &amp;&amp; (m_hasEstimatedMarginBefore || m_hasValidVerticalMargin));</span>
226     return m_topLeft.y();
227 }
228 
229 inline LayoutUnit Box::left() const
230 {
231     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
232     return m_topLeft.x();
233 }
234 
235 inline LayoutPoint Box::topLeft() const
236 {
<span class="line-modified">237     ASSERT(m_hasValidTop &amp;&amp; (m_hasEstimatedMarginBefore || m_hasValidVerticalMargin));</span>
238     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
239     return m_topLeft;
240 }
241 
242 inline void Box::setTopLeft(const LayoutPoint&amp; topLeft)
243 {
<span class="line-modified">244 #if !ASSERT_DISABLED</span>
245     setHasValidTop();
246     setHasValidLeft();
247 #endif
248     m_topLeft = topLeft;
249 }
250 
251 inline void Box::setTop(LayoutUnit top)
252 {
<span class="line-modified">253 #if !ASSERT_DISABLED</span>
254     setHasValidTop();
255 #endif
256     m_topLeft.setY(top);
257 }
258 
259 inline void Box::setLeft(LayoutUnit left)
260 {
<span class="line-modified">261 #if !ASSERT_DISABLED</span>
262     setHasValidLeft();
263 #endif
264     m_topLeft.setX(left);
265 }
266 
267 inline void Box::setContentBoxHeight(LayoutUnit height)
268 {
<span class="line-modified">269 #if !ASSERT_DISABLED</span>
270     setHasValidContentHeight();
271 #endif
272     m_contentHeight = height;
273 }
274 
275 inline void Box::setContentBoxWidth(LayoutUnit width)
276 {
<span class="line-modified">277 #if !ASSERT_DISABLED</span>
278     setHasValidContentWidth();
279 #endif
280     m_contentWidth = width;
281 }
282 
283 inline LayoutUnit Box::contentBoxHeight() const
284 {
285     ASSERT(m_hasValidContentHeight);
286     return m_contentHeight;
287 }
288 
289 inline LayoutUnit Box::contentBoxWidth() const
290 {
291     ASSERT(m_hasValidContentWidth);
292     return m_contentWidth;
293 }
294 
295 inline void Box::setHorizontalMargin(Layout::UsedHorizontalMargin margin)
296 {
<span class="line-modified">297 #if !ASSERT_DISABLED</span>
298     setHasValidHorizontalMargin();
299 #endif
300     m_horizontalMargin = margin;
301 }
302 
303 inline void Box::setVerticalMargin(Layout::UsedVerticalMargin margin)
304 {
<span class="line-modified">305 #if !ASSERT_DISABLED</span>
306     setHasValidVerticalMargin();
307     setHasValidVerticalNonCollapsedMargin();
<span class="line-modified">308     invalidateEstimatedMarginBefore();</span>
309 #endif
310     m_verticalMargin = margin;
311 }
312 
313 inline void Box::setHorizontalComputedMargin(Layout::ComputedHorizontalMargin margin)
314 {
<span class="line-modified">315 #if !ASSERT_DISABLED</span>
316     setHasValidHorizontalComputedMargin();
317 #endif
318     m_horizontalComputedMargin = margin;
319 }
320 
321 inline void Box::setBorder(Layout::Edges border)
322 {
<span class="line-modified">323 #if !ASSERT_DISABLED</span>
324     setHasValidBorder();
325 #endif
326     m_border = border;
327 }
328 
329 inline void Box::setPadding(Optional&lt;Layout::Edges&gt; padding)
330 {
<span class="line-modified">331 #if !ASSERT_DISABLED</span>
332     setHasValidPadding();
333 #endif
334     m_padding = padding;
335 }
336 
337 inline Rect Box::rectWithMargin() const
338 {
339     auto marginAfter = this-&gt;marginAfter();
340     if (m_verticalMargin.collapsedValues().isCollapsedThrough)
341         marginAfter = 0;
342     return { top() - marginBefore(), left() - marginStart(), marginStart() + width() + marginEnd(), marginBefore() + height() + marginAfter };
343 }
344 
345 inline Layout::UsedVerticalMargin Box::verticalMargin() const
346 {
347     ASSERT(m_hasValidVerticalMargin);
348     return m_verticalMargin;
349 }
350 
351 inline Layout::UsedHorizontalMargin Box::horizontalMargin() const
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;DisplayRect.h&quot;
 31 #include &quot;LayoutUnits.h&quot;

 32 #include &lt;wtf/IsoMalloc.h&gt;
 33 
 34 namespace WebCore {














 35 namespace Display {
 36 
 37 class Box {
 38     WTF_MAKE_ISO_ALLOCATED(Box);
 39 public:










 40     Box(const Box&amp;);
<span class="line-added"> 41     Box() = default;</span>
 42     ~Box();
 43 
 44     LayoutUnit top() const;
 45     LayoutUnit left() const;
 46     LayoutUnit bottom() const { return top() + height(); }
 47     LayoutUnit right() const { return left() + width(); }
 48 
 49     LayoutPoint topLeft() const;
 50     LayoutPoint bottomRight() const { return { right(), bottom() }; }
 51 
 52     LayoutSize size() const { return { width(), height() }; }
 53     LayoutUnit width() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
 54     LayoutUnit height() const { return borderTop() + paddingBoxHeight() + borderBottom(); }
<span class="line-added"> 55     bool isEmpty() const { return size().isEmpty(); }</span>
 56     Rect rect() const { return { top(), left(), width(), height() }; }
 57     Rect rectWithMargin() const;
 58 
 59     Layout::UsedVerticalMargin verticalMargin() const;
 60     Layout::UsedHorizontalMargin horizontalMargin() const;
 61     LayoutUnit marginBefore() const;
 62     LayoutUnit marginStart() const;
 63     LayoutUnit marginAfter() const;
 64     LayoutUnit marginEnd() const;
 65     bool hasCollapsedThroughMargin() const { return m_verticalMargin.isCollapsedThrough(); }
 66     bool hasClearance() const { return m_hasClearance; }
 67 
 68     LayoutUnit nonCollapsedMarginBefore() const;
 69     LayoutUnit nonCollapsedMarginAfter() const;
 70     Optional&lt;LayoutUnit&gt; computedMarginStart() const;
 71     Optional&lt;LayoutUnit&gt; computedMarginEnd() const;
 72 
 73     LayoutUnit borderTop() const;
 74     LayoutUnit borderLeft() const;
 75     LayoutUnit borderBottom() const;
</pre>
<hr />
<pre>
 95     LayoutUnit paddingBoxLeft() const { return borderLeft(); }
 96     LayoutUnit paddingBoxBottom() const { return paddingBoxTop() + paddingBoxHeight(); }
 97     LayoutUnit paddingBoxRight() const { return paddingBoxLeft() + paddingBoxWidth(); }
 98     LayoutUnit paddingBoxHeight() const { return paddingTop().valueOr(0) + contentBoxHeight() + paddingBottom().valueOr(0); }
 99     LayoutUnit paddingBoxWidth() const { return paddingLeft().valueOr(0) + contentBoxWidth() + paddingRight().valueOr(0); }
100 
101     LayoutUnit borderBoxHeight() const { return borderTop() + paddingBoxHeight() + borderBottom(); }
102     LayoutUnit borderBoxWidth() const { return borderLeft() + paddingBoxWidth() + borderRight(); }
103     LayoutUnit marginBoxHeight() const { return marginBefore() + borderBoxHeight() + marginAfter(); }
104     LayoutUnit marginBoxWidth() const { return marginStart() + borderBoxWidth() + marginEnd(); }
105 
106     LayoutUnit horizontalMarginBorderAndPadding() const { return marginStart() + horizontalBorder() + horizontalPadding().valueOr(0) + marginEnd(); }
107 
108     Rect marginBox() const;
109     Rect nonCollapsedMarginBox() const;
110 
111     Rect borderBox() const;
112     Rect paddingBox() const;
113     Rect contentBox() const;
114 
<span class="line-modified">115 #if ASSERT_ENABLED</span>
<span class="line-modified">116     void setHasPrecomputedMarginBefore() { m_hasPrecomputedMarginBefore = true; }</span>
117 #endif
118 







119     void setTopLeft(const LayoutPoint&amp;);
120     void setTop(LayoutUnit);
121     void setLeft(LayoutUnit);
122     void moveHorizontally(LayoutUnit offset) { m_topLeft.move(offset, 0_lu); }
123     void moveVertically(LayoutUnit offset) { m_topLeft.move(0_lu, offset); }
<span class="line-added">124     void move(const LayoutSize&amp; size) { m_topLeft.move(size); }</span>
<span class="line-added">125     void moveBy(LayoutPoint offset) { m_topLeft.moveBy(offset); }</span>
126 
127     void setContentBoxHeight(LayoutUnit);
128     void setContentBoxWidth(LayoutUnit);
129 
130     void setHorizontalMargin(Layout::UsedHorizontalMargin);
131     void setVerticalMargin(Layout::UsedVerticalMargin);
132     void setHorizontalComputedMargin(Layout::ComputedHorizontalMargin);
133     void setHasClearance() { m_hasClearance = true; }
134 
135     void setBorder(Layout::Edges);
136     void setPadding(Optional&lt;Layout::Edges&gt;);
137 
<span class="line-modified">138 private:</span>
<span class="line-added">139 #if ASSERT_ENABLED</span>
140     void invalidateMargin();
141     void invalidateBorder() { m_hasValidBorder = false; }
142     void invalidatePadding() { m_hasValidPadding = false; }
<span class="line-modified">143     void invalidatePrecomputedMarginBefore() { m_hasPrecomputedMarginBefore = false; }</span>
144 
145     void setHasValidTop() { m_hasValidTop = true; }
146     void setHasValidLeft() { m_hasValidLeft = true; }
147     void setHasValidVerticalMargin() { m_hasValidVerticalMargin = true; }
148     void setHasValidVerticalNonCollapsedMargin() { m_hasValidVerticalNonCollapsedMargin = true; }
149     void setHasValidHorizontalComputedMargin() { m_hasValidHorizontalComputedMargin = true; }
150     void setHasValidHorizontalMargin() { m_hasValidHorizontalMargin = true; }
151 
152     void setHasValidBorder() { m_hasValidBorder = true; }
153     void setHasValidPadding() { m_hasValidPadding = true; }
154 
155     void setHasValidContentHeight() { m_hasValidContentHeight = true; }
156     void setHasValidContentWidth() { m_hasValidContentWidth = true; }
<span class="line-modified">157 #endif // ASSERT_ENABLED</span>


158 
159     LayoutPoint m_topLeft;
160     LayoutUnit m_contentWidth;
161     LayoutUnit m_contentHeight;
162 
163     Layout::UsedHorizontalMargin m_horizontalMargin;
164     Layout::UsedVerticalMargin m_verticalMargin;
165     Layout::ComputedHorizontalMargin m_horizontalComputedMargin;
166     bool m_hasClearance { false };
167 
168     Layout::Edges m_border;
169     Optional&lt;Layout::Edges&gt; m_padding;
170 
<span class="line-modified">171 #if ASSERT_ENABLED</span>
172     bool m_hasValidTop { false };
173     bool m_hasValidLeft { false };
174     bool m_hasValidHorizontalMargin { false };
175     bool m_hasValidVerticalMargin { false };
176     bool m_hasValidVerticalNonCollapsedMargin { false };
177     bool m_hasValidHorizontalComputedMargin { false };
178     bool m_hasValidBorder { false };
179     bool m_hasValidPadding { false };
180     bool m_hasValidContentHeight { false };
181     bool m_hasValidContentWidth { false };
<span class="line-modified">182     bool m_hasPrecomputedMarginBefore { false };</span>
<span class="line-modified">183 #endif // ASSERT_ENABLED</span>
184 };
185 
<span class="line-modified">186 #if ASSERT_ENABLED</span>
187 inline void Box::invalidateMargin()
188 {
189     m_hasValidHorizontalMargin = false;
190     m_hasValidVerticalMargin = false;
191 }
192 #endif
193 
194 inline LayoutUnit Box::top() const
195 {
<span class="line-modified">196     ASSERT(m_hasValidTop &amp;&amp; (m_hasPrecomputedMarginBefore || m_hasValidVerticalMargin));</span>
197     return m_topLeft.y();
198 }
199 
200 inline LayoutUnit Box::left() const
201 {
202     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
203     return m_topLeft.x();
204 }
205 
206 inline LayoutPoint Box::topLeft() const
207 {
<span class="line-modified">208     ASSERT(m_hasValidTop &amp;&amp; (m_hasPrecomputedMarginBefore || m_hasValidVerticalMargin));</span>
209     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidHorizontalMargin);
210     return m_topLeft;
211 }
212 
213 inline void Box::setTopLeft(const LayoutPoint&amp; topLeft)
214 {
<span class="line-modified">215 #if ASSERT_ENABLED</span>
216     setHasValidTop();
217     setHasValidLeft();
218 #endif
219     m_topLeft = topLeft;
220 }
221 
222 inline void Box::setTop(LayoutUnit top)
223 {
<span class="line-modified">224 #if ASSERT_ENABLED</span>
225     setHasValidTop();
226 #endif
227     m_topLeft.setY(top);
228 }
229 
230 inline void Box::setLeft(LayoutUnit left)
231 {
<span class="line-modified">232 #if ASSERT_ENABLED</span>
233     setHasValidLeft();
234 #endif
235     m_topLeft.setX(left);
236 }
237 
238 inline void Box::setContentBoxHeight(LayoutUnit height)
239 {
<span class="line-modified">240 #if ASSERT_ENABLED</span>
241     setHasValidContentHeight();
242 #endif
243     m_contentHeight = height;
244 }
245 
246 inline void Box::setContentBoxWidth(LayoutUnit width)
247 {
<span class="line-modified">248 #if ASSERT_ENABLED</span>
249     setHasValidContentWidth();
250 #endif
251     m_contentWidth = width;
252 }
253 
254 inline LayoutUnit Box::contentBoxHeight() const
255 {
256     ASSERT(m_hasValidContentHeight);
257     return m_contentHeight;
258 }
259 
260 inline LayoutUnit Box::contentBoxWidth() const
261 {
262     ASSERT(m_hasValidContentWidth);
263     return m_contentWidth;
264 }
265 
266 inline void Box::setHorizontalMargin(Layout::UsedHorizontalMargin margin)
267 {
<span class="line-modified">268 #if ASSERT_ENABLED</span>
269     setHasValidHorizontalMargin();
270 #endif
271     m_horizontalMargin = margin;
272 }
273 
274 inline void Box::setVerticalMargin(Layout::UsedVerticalMargin margin)
275 {
<span class="line-modified">276 #if ASSERT_ENABLED</span>
277     setHasValidVerticalMargin();
278     setHasValidVerticalNonCollapsedMargin();
<span class="line-modified">279     invalidatePrecomputedMarginBefore();</span>
280 #endif
281     m_verticalMargin = margin;
282 }
283 
284 inline void Box::setHorizontalComputedMargin(Layout::ComputedHorizontalMargin margin)
285 {
<span class="line-modified">286 #if ASSERT_ENABLED</span>
287     setHasValidHorizontalComputedMargin();
288 #endif
289     m_horizontalComputedMargin = margin;
290 }
291 
292 inline void Box::setBorder(Layout::Edges border)
293 {
<span class="line-modified">294 #if ASSERT_ENABLED</span>
295     setHasValidBorder();
296 #endif
297     m_border = border;
298 }
299 
300 inline void Box::setPadding(Optional&lt;Layout::Edges&gt; padding)
301 {
<span class="line-modified">302 #if ASSERT_ENABLED</span>
303     setHasValidPadding();
304 #endif
305     m_padding = padding;
306 }
307 
308 inline Rect Box::rectWithMargin() const
309 {
310     auto marginAfter = this-&gt;marginAfter();
311     if (m_verticalMargin.collapsedValues().isCollapsedThrough)
312         marginAfter = 0;
313     return { top() - marginBefore(), left() - marginStart(), marginStart() + width() + marginEnd(), marginBefore() + height() + marginAfter };
314 }
315 
316 inline Layout::UsedVerticalMargin Box::verticalMargin() const
317 {
318     ASSERT(m_hasValidVerticalMargin);
319     return m_verticalMargin;
320 }
321 
322 inline Layout::UsedHorizontalMargin Box::horizontalMargin() const
</pre>
</td>
</tr>
</table>
<center><a href="DisplayBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayRect.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
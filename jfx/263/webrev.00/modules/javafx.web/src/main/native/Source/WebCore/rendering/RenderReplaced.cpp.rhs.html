<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2000 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2004, 2006, 2007 Apple Inc. All rights reserved.
  5  * Copyright (C) Research In Motion Limited 2011-2012. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;RenderReplaced.h&quot;
 26 
 27 #include &quot;DocumentMarkerController.h&quot;
 28 #include &quot;FloatRoundedRect.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;GraphicsContext.h&quot;
 31 #include &quot;HTMLElement.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;HTMLImageElement.h&quot;</span>
<span class="line-added"> 33 #include &quot;HTMLParserIdioms.h&quot;</span>
 34 #include &quot;InlineElementBox.h&quot;
 35 #include &quot;LayoutRepainter.h&quot;
 36 #include &quot;RenderBlock.h&quot;
 37 #include &quot;RenderFragmentedFlow.h&quot;
 38 #include &quot;RenderImage.h&quot;
 39 #include &quot;RenderLayer.h&quot;
 40 #include &quot;RenderTheme.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;RenderedDocumentMarker.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 43 #include &quot;Settings.h&quot;</span>
 44 #include &quot;VisiblePosition.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/StackStats.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderReplaced);
 51 
 52 const int cDefaultWidth = 300;
 53 const int cDefaultHeight = 150;
 54 
 55 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style)
 56     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
 57     , m_intrinsicSize(cDefaultWidth, cDefaultHeight)
 58 {
 59     setReplaced(true);
 60 }
 61 
 62 RenderReplaced::RenderReplaced(Element&amp; element, RenderStyle&amp;&amp; style, const LayoutSize&amp; intrinsicSize)
 63     : RenderBox(element, WTFMove(style), RenderReplacedFlag)
 64     , m_intrinsicSize(intrinsicSize)
 65 {
 66     setReplaced(true);
 67 }
 68 
 69 RenderReplaced::RenderReplaced(Document&amp; document, RenderStyle&amp;&amp; style, const LayoutSize&amp; intrinsicSize)
 70     : RenderBox(document, WTFMove(style), RenderReplacedFlag)
 71     , m_intrinsicSize(intrinsicSize)
 72 {
 73     setReplaced(true);
 74 }
 75 
 76 RenderReplaced::~RenderReplaced() = default;
 77 
 78 void RenderReplaced::willBeDestroyed()
 79 {
 80     if (!renderTreeBeingDestroyed() &amp;&amp; parent())
 81         parent()-&gt;dirtyLinesFromChangedChild(*this);
 82 
 83     RenderBox::willBeDestroyed();
 84 }
 85 
 86 void RenderReplaced::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 87 {
 88     RenderBox::styleDidChange(diff, oldStyle);
 89 
 90     bool hadStyle = (oldStyle != 0);
 91     float oldZoom = hadStyle ? oldStyle-&gt;effectiveZoom() : RenderStyle::initialZoom();
 92     if (style().effectiveZoom() != oldZoom)
 93         intrinsicSizeChanged();
 94 }
 95 
 96 void RenderReplaced::layout()
 97 {
 98     StackStats::LayoutCheckPoint layoutCheckPoint;
 99     ASSERT(needsLayout());
100 
101     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
102 
103     setHeight(minimumReplacedHeight());
104 
105     updateLogicalWidth();
106     updateLogicalHeight();
107 
108     // Now that we&#39;ve calculated our preferred layout, we check to see
109     // if we should further constrain sizing to the intrinsic aspect ratio.
110     if (style().aspectRatioType() == AspectRatioType::FromIntrinsic &amp;&amp; !m_intrinsicSize.isEmpty()) {
111         float aspectRatio = m_intrinsicSize.aspectRatio();
112         LayoutSize frameSize = size();
113         float frameAspectRatio = frameSize.aspectRatio();
114         if (frameAspectRatio &lt; aspectRatio)
115             setHeight(computeReplacedLogicalHeightRespectingMinMaxHeight(frameSize.height() * frameAspectRatio / aspectRatio));
116         else if (frameAspectRatio &gt; aspectRatio)
117             setWidth(computeReplacedLogicalWidthRespectingMinMaxWidth(frameSize.width() * aspectRatio / frameAspectRatio, ComputePreferred));
118     }
119 
120     clearOverflow();
121     addVisualEffectOverflow();
122     updateLayerTransform();
123     invalidateBackgroundObscurationStatus();
124 
125     repainter.repaintAfterLayout();
126     clearNeedsLayout();
127 }
128 
129 void RenderReplaced::intrinsicSizeChanged()
130 {
131     int scaledWidth = static_cast&lt;int&gt;(cDefaultWidth * style().effectiveZoom());
132     int scaledHeight = static_cast&lt;int&gt;(cDefaultHeight * style().effectiveZoom());
133     m_intrinsicSize = IntSize(scaledWidth, scaledHeight);
134     setNeedsLayoutAndPrefWidthsRecalc();
135 }
136 
137 bool RenderReplaced::shouldDrawSelectionTint() const
138 {
139     return selectionState() != SelectionNone &amp;&amp; !document().printing();
140 }
141 
142 inline static bool draggedContentContainsReplacedElement(const Vector&lt;RenderedDocumentMarker*&gt;&amp; markers, const Element&amp; element)
143 {
144     if (markers.isEmpty())
145         return false;
146 
147     for (auto* marker : markers) {
148         auto&amp; draggedContentData = WTF::get&lt;DocumentMarker::DraggedContentData&gt;(marker-&gt;data());
149         if (draggedContentData.targetNode == &amp;element)
150             return true;
151     }
152 
153     return false;
154 }
155 
156 void RenderReplaced::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
157 {
158     if (!shouldPaint(paintInfo, paintOffset))
159         return;
160 
161     LayoutPoint adjustedPaintOffset = paintOffset + location();
162 
163     if (paintInfo.phase == PaintPhase::EventRegion) {
164         if (visibleToHitTesting()) {
165             auto borderRect = LayoutRect(adjustedPaintOffset, size());
166             auto borderRegion = approximateAsRegion(style().getRoundedBorderFor(borderRect));
167             paintInfo.eventRegionContext-&gt;unite(borderRegion, style());
168         }
169         return;
170     }
171 
172 #ifndef NDEBUG
173     SetLayoutNeededForbiddenScope scope(this);
174 #endif
175 
176     GraphicsContextStateSaver savedGraphicsContext(paintInfo.context(), false);
177     if (element() &amp;&amp; element()-&gt;parentOrShadowHostElement()) {
178         auto* parentContainer = element()-&gt;parentOrShadowHostElement();
179         ASSERT(parentContainer);
180         if (draggedContentContainsReplacedElement(document().markers().markersFor(*parentContainer, DocumentMarker::DraggedContent), *element())) {
181             savedGraphicsContext.save();
182             paintInfo.context().setAlpha(0.25);
183         }
184     }
185 
186     if (hasVisibleBoxDecorations() &amp;&amp; paintInfo.phase == PaintPhase::Foreground)
187         paintBoxDecorations(paintInfo, adjustedPaintOffset);
188 
189     if (paintInfo.phase == PaintPhase::Mask) {
190         paintMask(paintInfo, adjustedPaintOffset);
191         return;
192     }
193 
194     LayoutRect paintRect = LayoutRect(adjustedPaintOffset, size());
195     if (paintInfo.phase == PaintPhase::Outline || paintInfo.phase == PaintPhase::SelfOutline) {
196         if (style().outlineWidth())
197             paintOutline(paintInfo, paintRect);
198         return;
199     }
200 
201     if (paintInfo.phase != PaintPhase::Foreground &amp;&amp; paintInfo.phase != PaintPhase::Selection)
202         return;
203 
204     if (!paintInfo.shouldPaintWithinRoot(*this))
205         return;
206 
207     bool drawSelectionTint = shouldDrawSelectionTint();
208     if (paintInfo.phase == PaintPhase::Selection) {
209         if (selectionState() == SelectionNone)
210             return;
211         drawSelectionTint = false;
212     }
213 
214     bool completelyClippedOut = false;
215     if (style().hasBorderRadius()) {
216         LayoutRect borderRect = LayoutRect(adjustedPaintOffset, size());
217 
218         if (borderRect.isEmpty())
219             completelyClippedOut = true;
220         else {
221             // Push a clip if we have a border radius, since we want to round the foreground content that gets painted.
222             paintInfo.context().save();
223             FloatRoundedRect roundedInnerRect = FloatRoundedRect(style().getRoundedInnerBorderFor(paintRect,
224                 paddingTop() + borderTop(), paddingBottom() + borderBottom(), paddingLeft() + borderLeft(), paddingRight() + borderRight(), true, true));
225             clipRoundedInnerRect(paintInfo.context(), paintRect, roundedInnerRect);
226         }
227     }
228 
229     if (!completelyClippedOut) {
230         paintReplaced(paintInfo, adjustedPaintOffset);
231 
232         if (style().hasBorderRadius())
233             paintInfo.context().restore();
234     }
235 
236     // The selection tint never gets clipped by border-radius rounding, since we want it to run right up to the edges of
237     // surrounding content.
238     if (drawSelectionTint) {
239         LayoutRect selectionPaintingRect = localSelectionRect();
240         selectionPaintingRect.moveBy(adjustedPaintOffset);
241         paintInfo.context().fillRect(snappedIntRect(selectionPaintingRect), selectionBackgroundColor());
242     }
243 }
244 
245 bool RenderReplaced::shouldPaint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
246 {
247     if ((paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection)) &amp;&amp; isSelected())
248         return false;
249 
250     if (paintInfo.phase != PaintPhase::Foreground
251         &amp;&amp; paintInfo.phase != PaintPhase::Outline
252         &amp;&amp; paintInfo.phase != PaintPhase::SelfOutline
253         &amp;&amp; paintInfo.phase != PaintPhase::Selection
254         &amp;&amp; paintInfo.phase != PaintPhase::Mask
255         &amp;&amp; paintInfo.phase != PaintPhase::EventRegion)
256         return false;
257 
258     if (!paintInfo.shouldPaintWithinRoot(*this))
259         return false;
260 
261     // if we&#39;re invisible or haven&#39;t received a layout yet, then just bail.
262     if (style().visibility() != Visibility::Visible)
263         return false;
264 
265     LayoutPoint adjustedPaintOffset = paintOffset + location();
266 
267     // Early exit if the element touches the edges.
268     LayoutUnit top = adjustedPaintOffset.y() + visualOverflowRect().y();
269     LayoutUnit bottom = adjustedPaintOffset.y() + visualOverflowRect().maxY();
270     if (isSelected() &amp;&amp; m_inlineBoxWrapper) {
271         const RootInlineBox&amp; rootBox = m_inlineBoxWrapper-&gt;root();
272         LayoutUnit selTop = paintOffset.y() + rootBox.selectionTop();
273         LayoutUnit selBottom = paintOffset.y() + selTop + rootBox.selectionHeight();
274         top = std::min(selTop, top);
275         bottom = std::max(selBottom, bottom);
276     }
277 
278     LayoutRect localRepaintRect = paintInfo.rect;
279     if (adjustedPaintOffset.x() + visualOverflowRect().x() &gt;= localRepaintRect.maxX() || adjustedPaintOffset.x() + visualOverflowRect().maxX() &lt;= localRepaintRect.x())
280         return false;
281 
282     if (top &gt;= localRepaintRect.maxY() || bottom &lt;= localRepaintRect.y())
283         return false;
284 
285     return true;
286 }
287 
288 static inline RenderBlock* firstContainingBlockWithLogicalWidth(const RenderReplaced* replaced)
289 {
290     // We have to lookup the containing block, which has an explicit width, which must not be equal to our direct containing block.
291     // If the embedded document appears _after_ we performed the initial layout, our intrinsic size is 300x150. If our containing
292     // block doesn&#39;t provide an explicit width, it&#39;s set to the 300 default, coming from the initial layout run.
293     RenderBlock* containingBlock = replaced-&gt;containingBlock();
294     if (!containingBlock)
295         return 0;
296 
297     for (; containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock) &amp;&amp; !containingBlock-&gt;isBody(); containingBlock = containingBlock-&gt;containingBlock()) {
298         if (containingBlock-&gt;style().logicalWidth().isSpecified())
299             return containingBlock;
300     }
301 
302     return 0;
303 }
304 
305 bool RenderReplaced::hasReplacedLogicalWidth() const
306 {
307     if (style().logicalWidth().isSpecified())
308         return true;
309 
310     if (style().logicalWidth().isAuto())
311         return false;
312 
313     return firstContainingBlockWithLogicalWidth(this);
314 }
315 
316 bool RenderReplaced::hasReplacedLogicalHeight() const
317 {
318     if (style().logicalHeight().isAuto())
319         return false;
320 
321     if (style().logicalHeight().isSpecified()) {
322         if (hasAutoHeightOrContainingBlockWithAutoHeight())
323             return false;
324         return true;
325     }
326 
327     if (style().logicalHeight().isIntrinsic())
328         return true;
329 
330     return false;
331 }
332 
333 bool RenderReplaced::setNeedsLayoutIfNeededAfterIntrinsicSizeChange()
334 {
335     setPreferredLogicalWidthsDirty(true);
336 
337     // If the actual area occupied by the image has changed and it is not constrained by style then a layout is required.
338     bool imageSizeIsConstrained = style().logicalWidth().isSpecified() &amp;&amp; style().logicalHeight().isSpecified();
339 
340     // FIXME: We only need to recompute the containing block&#39;s preferred size
341     // if the containing block&#39;s size depends on the image&#39;s size (i.e., the container uses shrink-to-fit sizing).
342     // There&#39;s no easy way to detect that shrink-to-fit is needed, always force a layout.
343     bool containingBlockNeedsToRecomputePreferredSize =
344         style().logicalWidth().isPercentOrCalculated()
345         || style().logicalMaxWidth().isPercentOrCalculated()
346         || style().logicalMinWidth().isPercentOrCalculated();
347 
348     bool layoutSizeDependsOnIntrinsicSize = style().aspectRatioType() == AspectRatioType::FromIntrinsic;
349 
350     if (!imageSizeIsConstrained || containingBlockNeedsToRecomputePreferredSize || layoutSizeDependsOnIntrinsicSize) {
351         setNeedsLayout();
352         return true;
353     }
354 
355     return false;
356 }
357 
358 void RenderReplaced::computeAspectRatioInformationForRenderBox(RenderBox* contentRenderer, FloatSize&amp; constrainedSize, double&amp; intrinsicRatio) const
359 {
360     FloatSize intrinsicSize;
361     if (contentRenderer) {
362         contentRenderer-&gt;computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
363 
364         // Handle zoom &amp; vertical writing modes here, as the embedded document doesn&#39;t know about them.
365         intrinsicSize.scale(style().effectiveZoom());
366 
367         if (is&lt;RenderImage&gt;(*this))
368             intrinsicSize.scale(downcast&lt;RenderImage&gt;(*this).imageDevicePixelRatio());
369 
370         // Update our intrinsic size to match what the content renderer has computed, so that when we
371         // constrain the size below, the correct intrinsic size will be obtained for comparison against
372         // min and max widths.
373         if (intrinsicRatio &amp;&amp; !intrinsicSize.isEmpty())
374             m_intrinsicSize = LayoutSize(intrinsicSize);
375 
376         if (!isHorizontalWritingMode()) {
377             if (intrinsicRatio)
378                 intrinsicRatio = 1 / intrinsicRatio;
379             intrinsicSize = intrinsicSize.transposedSize();
380         }
381     } else {
382         computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
383         if (intrinsicRatio &amp;&amp; !intrinsicSize.isEmpty())
384             m_intrinsicSize = LayoutSize(isHorizontalWritingMode() ? intrinsicSize : intrinsicSize.transposedSize());
385     }
386 
387     // Now constrain the intrinsic size along each axis according to minimum and maximum width/heights along the
388     // opposite axis. So for example a maximum width that shrinks our width will result in the height we compute here
389     // having to shrink in order to preserve the aspect ratio. Because we compute these values independently along
390     // each axis, the final returned size may in fact not preserve the aspect ratio.
391     // FIXME: In the long term, it might be better to just return this code more to the way it used to be before this
392     // function was added, since all it has done is make the code more unclear.
393     constrainedSize = intrinsicSize;
394     if (intrinsicRatio &amp;&amp; !intrinsicSize.isEmpty() &amp;&amp; style().logicalWidth().isAuto() &amp;&amp; style().logicalHeight().isAuto()) {
395         // We can&#39;t multiply or divide by &#39;intrinsicRatio&#39; here, it breaks tests, like fast/images/zoomed-img-size.html, which
396         // can only be fixed once subpixel precision is available for things like intrinsicWidth/Height - which include zoom!
397         constrainedSize.setWidth(RenderBox::computeReplacedLogicalHeight() * intrinsicSize.width() / intrinsicSize.height());
398         constrainedSize.setHeight(RenderBox::computeReplacedLogicalWidth() * intrinsicSize.height() / intrinsicSize.width());
399     }
400 }
401 
402 LayoutRect RenderReplaced::replacedContentRect(const LayoutSize&amp; intrinsicSize) const
403 {
404     LayoutRect contentRect = contentBoxRect();
405     if (intrinsicSize.isEmpty())
406         return contentRect;
407 
408     ObjectFit objectFit = style().objectFit();
409 
410     LayoutRect finalRect = contentRect;
411     switch (objectFit) {
412     case ObjectFit::Contain:
413     case ObjectFit::ScaleDown:
414     case ObjectFit::Cover:
415         finalRect.setSize(finalRect.size().fitToAspectRatio(intrinsicSize, objectFit == ObjectFit::Cover ? AspectRatioFitGrow : AspectRatioFitShrink));
416         if (objectFit != ObjectFit::ScaleDown || finalRect.width() &lt;= intrinsicSize.width())
417             break;
418         FALLTHROUGH;
419     case ObjectFit::None:
420         finalRect.setSize(intrinsicSize);
421         break;
422     case ObjectFit::Fill:
423         break;
424     }
425 
426     LengthPoint objectPosition = style().objectPosition();
427 
428     LayoutUnit xOffset = minimumValueForLength(objectPosition.x(), contentRect.width() - finalRect.width());
429     LayoutUnit yOffset = minimumValueForLength(objectPosition.y(), contentRect.height() - finalRect.height());
430 
431     finalRect.move(xOffset, yOffset);
432 
433     return finalRect;
434 }
435 
436 void RenderReplaced::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
437 {
438     // If there&#39;s an embeddedContentBox() of a remote, referenced document available, this code-path should never be used.
439     ASSERT(!embeddedContentBox());
440     intrinsicSize = FloatSize(intrinsicLogicalWidth(), intrinsicLogicalHeight());
441 
442     // Figure out if we need to compute an intrinsic ratio.
<a name="3" id="anc3"></a><span class="line-modified">443     if (!hasAspectRatio())</span>
444         return;
445 
<a name="4" id="anc4"></a><span class="line-added">446     if (intrinsicSize.isEmpty()) {</span>
<span class="line-added">447         if (!settings().aspectRatioOfImgFromWidthAndHeightEnabled())</span>
<span class="line-added">448             return;</span>
<span class="line-added">449 </span>
<span class="line-added">450         auto* node = element();</span>
<span class="line-added">451         // The aspectRatioOfImgFromWidthAndHeight only applies to &lt;img&gt;.</span>
<span class="line-added">452         if (!node || !is&lt;HTMLImageElement&gt;(*node) || !node-&gt;hasAttribute(HTMLNames::widthAttr) || !node-&gt;hasAttribute(HTMLNames::heightAttr))</span>
<span class="line-added">453             return;</span>
<span class="line-added">454 </span>
<span class="line-added">455         // We shouldn&#39;t override the aspect-ratio when the &lt;img&gt; element has an empty src attribute.</span>
<span class="line-added">456         if (!is&lt;RenderImage&gt;(*this) || !downcast&lt;RenderImage&gt;(*this).cachedImage())</span>
<span class="line-added">457             return;</span>
<span class="line-added">458 </span>
<span class="line-added">459         intrinsicSize.setWidth(parseValidHTMLFloatingPointNumber(node-&gt;getAttribute(HTMLNames::widthAttr)).valueOr(0));</span>
<span class="line-added">460         intrinsicSize.setHeight(parseValidHTMLFloatingPointNumber(node-&gt;getAttribute(HTMLNames::heightAttr)).valueOr(0));</span>
<span class="line-added">461         if (intrinsicSize.isEmpty())</span>
<span class="line-added">462             return;</span>
<span class="line-added">463     }</span>
<span class="line-added">464 </span>
465     intrinsicRatio = intrinsicSize.width() / intrinsicSize.height();
466 }
467 
468 LayoutUnit RenderReplaced::computeConstrainedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
469 {
470     if (shouldComputePreferred == ComputePreferred)
471         return computeReplacedLogicalWidthRespectingMinMaxWidth(0_lu, ComputePreferred);
472 
473     // The aforementioned &#39;constraint equation&#39; used for block-level, non-replaced
474     // elements in normal flow:
475     // &#39;margin-left&#39; + &#39;border-left-width&#39; + &#39;padding-left&#39; + &#39;width&#39; +
476     // &#39;padding-right&#39; + &#39;border-right-width&#39; + &#39;margin-right&#39; = width of
477     // containing block
478     LayoutUnit logicalWidth = containingBlock()-&gt;availableLogicalWidth();
479 
480     // This solves above equation for &#39;width&#39; (== logicalWidth).
481     LayoutUnit marginStart = minimumValueForLength(style().marginStart(), logicalWidth);
482     LayoutUnit marginEnd = minimumValueForLength(style().marginEnd(), logicalWidth);
<a name="5" id="anc5"></a><span class="line-modified">483 </span>
<span class="line-added">484     // FIXME: This expression does not align with the comment above, which is quoting https://www.w3.org/TR/CSS22/visudet.html#blockwidth.</span>
<span class="line-added">485     logicalWidth = std::max(0_lu, (logicalWidth - (marginStart + marginEnd + borderLeft() + borderRight())));</span>
486     return computeReplacedLogicalWidthRespectingMinMaxWidth(logicalWidth, shouldComputePreferred);
487 }
488 
489 LayoutUnit RenderReplaced::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
490 {
491     if (style().logicalWidth().isSpecified() || style().logicalWidth().isIntrinsic())
492         return computeReplacedLogicalWidthRespectingMinMaxWidth(computeReplacedLogicalWidthUsing(MainOrPreferredSize, style().logicalWidth()), shouldComputePreferred);
493 
494     RenderBox* contentRenderer = embeddedContentBox();
495 
496     // 10.3.2 Inline, replaced elements: http://www.w3.org/TR/CSS21/visudet.html#inline-replaced-width
497     double intrinsicRatio = 0;
498     FloatSize constrainedSize;
499     computeAspectRatioInformationForRenderBox(contentRenderer, constrainedSize, intrinsicRatio);
500 
501     if (style().logicalWidth().isAuto()) {
502         bool computedHeightIsAuto = style().logicalHeight().isAuto();
503         bool hasIntrinsicWidth = constrainedSize.width() &gt; 0;
504 
505         // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
506         if (computedHeightIsAuto &amp;&amp; hasIntrinsicWidth)
507             return computeReplacedLogicalWidthRespectingMinMaxWidth(constrainedSize.width(), shouldComputePreferred);
508 
509         bool hasIntrinsicHeight = constrainedSize.height() &gt; 0;
510         if (intrinsicRatio) {
511             // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio;
512             // or if &#39;width&#39; has a computed value of &#39;auto&#39;, &#39;height&#39; has some other computed value, and the element does have an intrinsic ratio; then the used value
513             // of &#39;width&#39; is: (used height) * (intrinsic ratio)
514             if (intrinsicRatio &amp;&amp; ((computedHeightIsAuto &amp;&amp; !hasIntrinsicWidth &amp;&amp; hasIntrinsicHeight) || !computedHeightIsAuto)) {
515                 LayoutUnit estimatedUsedWidth = hasIntrinsicWidth ? LayoutUnit(constrainedSize.width()) : computeConstrainedLogicalWidth(shouldComputePreferred);
516                 LayoutUnit logicalHeight = computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt;(estimatedUsedWidth));
517                 return computeReplacedLogicalWidthRespectingMinMaxWidth(roundToInt(round(logicalHeight * intrinsicRatio)), shouldComputePreferred);
518             }
519 
520 
521             // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the
522             // element has an intrinsic ratio but no intrinsic height or width, then
523             // the used value of &#39;width&#39; is undefined in CSS 2.1. However, it is
524             // suggested that, if the containing block&#39;s width does not itself depend
525             // on the replaced element&#39;s width, then the used value of &#39;width&#39; is
526             // calculated from the constraint equation used for block-level,
527             // non-replaced elements in normal flow.
528             if (computedHeightIsAuto &amp;&amp; !hasIntrinsicWidth &amp;&amp; !hasIntrinsicHeight)
529                 return computeConstrainedLogicalWidth(shouldComputePreferred);
530         }
531 
532         // Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic width, then that intrinsic width is the used value of &#39;width&#39;.
533         if (hasIntrinsicWidth)
534             return computeReplacedLogicalWidthRespectingMinMaxWidth(constrainedSize.width(), shouldComputePreferred);
535 
536         // Otherwise, if &#39;width&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;width&#39; becomes 300px. If 300px is too
537         // wide to fit the device, UAs should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
538         // Note: We fall through and instead return intrinsicLogicalWidth() here - to preserve existing WebKit behavior, which might or might not be correct, or desired.
539         // Changing this to return cDefaultWidth, will affect lots of test results. Eg. some tests assume that a blank &lt;img&gt; tag (which implies width/height=auto)
540         // has no intrinsic size, which is wrong per CSS 2.1, but matches our behavior since a long time.
541     }
542 
543     return computeReplacedLogicalWidthRespectingMinMaxWidth(intrinsicLogicalWidth(), shouldComputePreferred);
544 }
545 
546 LayoutUnit RenderReplaced::computeReplacedLogicalHeight(Optional&lt;LayoutUnit&gt; estimatedUsedWidth) const
547 {
548     // 10.5 Content height: the &#39;height&#39; property: http://www.w3.org/TR/CSS21/visudet.html#propdef-height
549     if (hasReplacedLogicalHeight())
550         return computeReplacedLogicalHeightRespectingMinMaxHeight(computeReplacedLogicalHeightUsing(MainOrPreferredSize, style().logicalHeight()));
551 
552     RenderBox* contentRenderer = embeddedContentBox();
553 
554     // 10.6.2 Inline, replaced elements: http://www.w3.org/TR/CSS21/visudet.html#inline-replaced-height
555     double intrinsicRatio = 0;
556     FloatSize constrainedSize;
557     computeAspectRatioInformationForRenderBox(contentRenderer, constrainedSize, intrinsicRatio);
558 
559     bool widthIsAuto = style().logicalWidth().isAuto();
560     bool hasIntrinsicHeight = constrainedSize.height() &gt; 0;
561 
562     // If &#39;height&#39; and &#39;width&#39; both have computed values of &#39;auto&#39; and the element also has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
563     if (widthIsAuto &amp;&amp; hasIntrinsicHeight)
564         return computeReplacedLogicalHeightRespectingMinMaxHeight(constrainedSize.height());
565 
566     // Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic ratio then the used value of &#39;height&#39; is:
567     // (used width) / (intrinsic ratio)
568     if (intrinsicRatio) {
569         LayoutUnit usedWidth = estimatedUsedWidth ? estimatedUsedWidth.value() : availableLogicalWidth();
570         return computeReplacedLogicalHeightRespectingMinMaxHeight(roundToInt(round(usedWidth / intrinsicRatio)));
571     }
572 
573     // Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, and the element has an intrinsic height, then that intrinsic height is the used value of &#39;height&#39;.
574     if (hasIntrinsicHeight)
575         return computeReplacedLogicalHeightRespectingMinMaxHeight(constrainedSize.height());
576 
577     // Otherwise, if &#39;height&#39; has a computed value of &#39;auto&#39;, but none of the conditions above are met, then the used value of &#39;height&#39; must be set to the height
578     // of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
579     return computeReplacedLogicalHeightRespectingMinMaxHeight(intrinsicLogicalHeight());
580 }
581 
582 void RenderReplaced::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
583 {
584     minLogicalWidth = maxLogicalWidth = intrinsicLogicalWidth();
585 }
586 
587 void RenderReplaced::computePreferredLogicalWidths()
588 {
589     ASSERT(preferredLogicalWidthsDirty());
590 
591     // We cannot resolve any percent logical width here as the available logical
592     // width may not be set on our containing block.
593     if (style().logicalWidth().isPercentOrCalculated())
594         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
595     else
596         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = computeReplacedLogicalWidth(ComputePreferred);
597 
598     const RenderStyle&amp; styleToUse = style();
599     if (styleToUse.logicalWidth().isPercentOrCalculated() || styleToUse.logicalMaxWidth().isPercentOrCalculated())
600         m_minPreferredLogicalWidth = 0;
601 
602     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {
603         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
604         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
605     }
606 
607     if (styleToUse.logicalMaxWidth().isFixed()) {
608         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
609         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
610     }
611 
612     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
613     m_minPreferredLogicalWidth += borderAndPadding;
614     m_maxPreferredLogicalWidth += borderAndPadding;
615 
616     setPreferredLogicalWidthsDirty(false);
617 }
618 
619 VisiblePosition RenderReplaced::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer* fragment)
620 {
621     // FIXME: This code is buggy if the replaced element is relative positioned.
622     InlineBox* box = inlineBoxWrapper();
623     const RootInlineBox* rootBox = box ? &amp;box-&gt;root() : 0;
624 
625     LayoutUnit top = rootBox ? rootBox-&gt;selectionTop() : logicalTop();
626     LayoutUnit bottom = rootBox ? rootBox-&gt;selectionBottom() : logicalBottom();
627 
628     LayoutUnit blockDirectionPosition = isHorizontalWritingMode() ? point.y() + y() : point.x() + x();
629     LayoutUnit lineDirectionPosition = isHorizontalWritingMode() ? point.x() + x() : point.y() + y();
630 
631     if (blockDirectionPosition &lt; top)
632         return createVisiblePosition(caretMinOffset(), DOWNSTREAM); // coordinates are above
633 
634     if (blockDirectionPosition &gt;= bottom)
635         return createVisiblePosition(caretMaxOffset(), DOWNSTREAM); // coordinates are below
636 
637     if (element()) {
638         if (lineDirectionPosition &lt;= logicalLeft() + (logicalWidth() / 2))
639             return createVisiblePosition(0, DOWNSTREAM);
640         return createVisiblePosition(1, DOWNSTREAM);
641     }
642 
643     return RenderBox::positionForPoint(point, fragment);
644 }
645 
646 LayoutRect RenderReplaced::selectionRectForRepaint(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent)
647 {
648     ASSERT(!needsLayout());
649 
650     if (!isSelected())
651         return LayoutRect();
652 
653     LayoutRect rect = localSelectionRect();
654     if (clipToVisibleContent)
655         return computeRectForRepaint(rect, repaintContainer);
656     return localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
657 }
658 
659 LayoutRect RenderReplaced::localSelectionRect(bool checkWhetherSelected) const
660 {
661     if (checkWhetherSelected &amp;&amp; !isSelected())
662         return LayoutRect();
663 
664     if (!m_inlineBoxWrapper)
665         // We&#39;re a block-level replaced element.  Just return our own dimensions.
666         return LayoutRect(LayoutPoint(), size());
667 
668     const RootInlineBox&amp; rootBox = m_inlineBoxWrapper-&gt;root();
669     LayoutUnit newLogicalTop { rootBox.blockFlow().style().isFlippedBlocksWritingMode() ? m_inlineBoxWrapper-&gt;logicalBottom() - rootBox.selectionBottom() : rootBox.selectionTop() - m_inlineBoxWrapper-&gt;logicalTop() };
670     if (rootBox.blockFlow().style().isHorizontalWritingMode())
671         return LayoutRect(0_lu, newLogicalTop, width(), rootBox.selectionHeight());
672     return LayoutRect(newLogicalTop, 0_lu, rootBox.selectionHeight(), height());
673 }
674 
675 void RenderReplaced::setSelectionState(SelectionState state)
676 {
677     // The selection state for our containing block hierarchy is updated by the base class call.
678     RenderBox::setSelectionState(state);
679 
680     if (m_inlineBoxWrapper &amp;&amp; canUpdateSelectionOnRootLineBoxes())
681         m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(isSelected());
682 }
683 
684 bool RenderReplaced::isSelected() const
685 {
686     SelectionState state = selectionState();
687     if (state == SelectionNone)
688         return false;
689     if (state == SelectionInside)
690         return true;
691 
<a name="6" id="anc6"></a><span class="line-modified">692     auto selectionStart = view().selection().startOffset();</span>
<span class="line-modified">693     auto selectionEnd = view().selection().endOffset();</span>
694     if (state == SelectionStart)
695         return !selectionStart;
696 
697     unsigned end = element()-&gt;hasChildNodes() ? element()-&gt;countChildNodes() : 1;
698     if (state == SelectionEnd)
699         return selectionEnd == end;
700     if (state == SelectionBoth)
701         return !selectionStart &amp;&amp; selectionEnd == end;
702     ASSERT_NOT_REACHED();
703     return false;
704 }
705 
706 LayoutRect RenderReplaced::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
707 {
708     if (style().visibility() != Visibility::Visible &amp;&amp; !enclosingLayer()-&gt;hasVisibleContent())
709         return LayoutRect();
710 
711     // The selectionRect can project outside of the overflowRect, so take their union
712     // for repainting to avoid selection painting glitches.
713     LayoutRect r = unionRect(localSelectionRect(false), visualOverflowRect());
714     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
715     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
716     r.move(view().frameView().layoutContext().layoutDelta());
717     return computeRectForRepaint(r, repaintContainer);
718 }
719 
720 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
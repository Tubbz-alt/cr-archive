<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Breakpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Debugger.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;Debugger.h&quot;
 24 
 25 #include &quot;CodeBlock.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;Error.h&quot;
 28 #include &quot;HeapIterationScope.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGlobalObject.h&quot;
 34 #include &quot;MarkedSpaceInlines.h&quot;
 35 #include &quot;Parser.h&quot;
 36 #include &quot;Protect.h&quot;
 37 #include &quot;VMEntryScope.h&quot;
 38 
<span class="line-removed"> 39 namespace {</span>
<span class="line-removed"> 40 </span>
<span class="line-removed"> 41 using namespace JSC;</span>
<span class="line-removed"> 42 </span>
<span class="line-removed"> 43 struct GatherSourceProviders : public MarkedBlock::VoidFunctor {</span>
<span class="line-removed"> 44     // FIXME: This is a mutable field because this isn&#39;t a C++ lambda.</span>
<span class="line-removed"> 45     // https://bugs.webkit.org/show_bug.cgi?id=159644</span>
<span class="line-removed"> 46     mutable HashSet&lt;SourceProvider*&gt; sourceProviders;</span>
<span class="line-removed"> 47     JSGlobalObject* m_globalObject;</span>
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49     GatherSourceProviders(JSGlobalObject* globalObject)</span>
<span class="line-removed"> 50         : m_globalObject(globalObject) { }</span>
<span class="line-removed"> 51 </span>
<span class="line-removed"> 52     IterationStatus operator()(HeapCell* heapCell, HeapCell::Kind kind) const</span>
<span class="line-removed"> 53     {</span>
<span class="line-removed"> 54         if (!isJSCellKind(kind))</span>
<span class="line-removed"> 55             return IterationStatus::Continue;</span>
<span class="line-removed"> 56 </span>
<span class="line-removed"> 57         JSCell* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-removed"> 58 </span>
<span class="line-removed"> 59         JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(cell-&gt;vm(), cell);</span>
<span class="line-removed"> 60         if (!function)</span>
<span class="line-removed"> 61             return IterationStatus::Continue;</span>
<span class="line-removed"> 62 </span>
<span class="line-removed"> 63         if (function-&gt;scope()-&gt;globalObject() != m_globalObject)</span>
<span class="line-removed"> 64             return IterationStatus::Continue;</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66         if (!function-&gt;executable()-&gt;isFunctionExecutable())</span>
<span class="line-removed"> 67             return IterationStatus::Continue;</span>
<span class="line-removed"> 68 </span>
<span class="line-removed"> 69         if (function-&gt;isHostOrBuiltinFunction())</span>
<span class="line-removed"> 70             return IterationStatus::Continue;</span>
<span class="line-removed"> 71 </span>
<span class="line-removed"> 72         sourceProviders.add(</span>
<span class="line-removed"> 73             jsCast&lt;FunctionExecutable*&gt;(function-&gt;executable())-&gt;source().provider());</span>
<span class="line-removed"> 74         return IterationStatus::Continue;</span>
<span class="line-removed"> 75     }</span>
<span class="line-removed"> 76 };</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 } // namespace</span>
<span class="line-removed"> 79 </span>
 80 namespace JSC {
 81 
 82 class DebuggerPausedScope {
 83 public:
 84     DebuggerPausedScope(Debugger&amp; debugger)
 85         : m_debugger(debugger)
 86     {
 87         ASSERT(!m_debugger.m_currentDebuggerCallFrame);
 88     }
 89 
 90     ~DebuggerPausedScope()
 91     {
 92         if (m_debugger.m_currentDebuggerCallFrame) {
 93             m_debugger.m_currentDebuggerCallFrame-&gt;invalidate();
 94             m_debugger.m_currentDebuggerCallFrame = nullptr;
 95         }
 96     }
 97 
 98 private:
 99     Debugger&amp; m_debugger;
</pre>
<hr />
<pre>
140     , m_topBreakpointID(noBreakpointID)
141     , m_pausingBreakpointID(noBreakpointID)
142 {
143 }
144 
145 Debugger::~Debugger()
146 {
147     HashSet&lt;JSGlobalObject*&gt;::iterator end = m_globalObjects.end();
148     for (HashSet&lt;JSGlobalObject*&gt;::iterator it = m_globalObjects.begin(); it != end; ++it)
149         (*it)-&gt;setDebugger(nullptr);
150 }
151 
152 void Debugger::attach(JSGlobalObject* globalObject)
153 {
154     ASSERT(!globalObject-&gt;debugger());
155     globalObject-&gt;setDebugger(this);
156     m_globalObjects.add(globalObject);
157 
158     m_vm.setShouldBuildPCToCodeOriginMapping();
159 
<span class="line-modified">160     // Call sourceParsed because it will execute JavaScript in the inspector.</span>
<span class="line-modified">161     GatherSourceProviders gatherSourceProviders(globalObject);</span>
162     {
163         HeapIterationScope iterationScope(m_vm.heap);
<span class="line-modified">164         m_vm.heap.objectSpace().forEachLiveCell(iterationScope, gatherSourceProviders);</span>









165     }
<span class="line-modified">166     for (auto* sourceProvider : gatherSourceProviders.sourceProviders)</span>
<span class="line-modified">167         sourceParsed(globalObject-&gt;globalExec(), sourceProvider, -1, String());</span>
168 }
169 
170 void Debugger::detach(JSGlobalObject* globalObject, ReasonForDetach reason)
171 {
172     // If we&#39;re detaching from the currently executing global object, manually tear down our
173     // stack, since we won&#39;t get further debugger callbacks to do so. Also, resume execution,
174     // since there&#39;s no point in staying paused once a window closes.
175     // We know there is an entry scope, otherwise, m_currentCallFrame would be null.
176     VM&amp; vm = globalObject-&gt;vm();


177     if (m_isPaused &amp;&amp; m_currentCallFrame &amp;&amp; vm.entryScope-&gt;globalObject() == globalObject) {
178         m_currentCallFrame = nullptr;
179         m_pauseOnCallFrame = nullptr;
180         continueProgram();
181     }
182 
183     ASSERT(m_globalObjects.contains(globalObject));
184     m_globalObjects.remove(globalObject);
185 
186     // If the globalObject is destructing, then its CodeBlocks will also be
187     // destructed. There is no need to do the debugger requests clean up, and
188     // it is not safe to access those CodeBlocks at this time anyway.
189     if (reason != GlobalObjectIsDestructing)
190         clearDebuggerRequests(globalObject);
191 
192     globalObject-&gt;setDebugger(nullptr);
193 
194     if (m_globalObjects.isEmpty())
195         clearParsedData();
196 }
</pre>
<hr />
<pre>
251 Seconds Debugger::willEvaluateScript()
252 {
253     return m_profilingClient-&gt;willEvaluateScript();
254 }
255 
256 void Debugger::didEvaluateScript(Seconds startTime, ProfilingReason reason)
257 {
258     m_profilingClient-&gt;didEvaluateScript(startTime, reason);
259 }
260 
261 void Debugger::toggleBreakpoint(CodeBlock* codeBlock, Breakpoint&amp; breakpoint, BreakpointState enabledOrNot)
262 {
263     ASSERT(breakpoint.resolved);
264 
265     ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
266 
267     SourceID sourceID = static_cast&lt;SourceID&gt;(executable-&gt;sourceID());
268     if (breakpoint.sourceID != sourceID)
269         return;
270 
<span class="line-removed">271     unsigned line = breakpoint.line;</span>
<span class="line-removed">272     unsigned column = breakpoint.column;</span>
<span class="line-removed">273 </span>
274     unsigned startLine = executable-&gt;firstLine();
275     unsigned startColumn = executable-&gt;startColumn();
276     unsigned endLine = executable-&gt;lastLine();
277     unsigned endColumn = executable-&gt;endColumn();
278 
279     // Inspector breakpoint line and column values are zero-based but the executable
280     // and CodeBlock line and column values are one-based.
<span class="line-modified">281     line += 1;</span>
<span class="line-modified">282     column = column ? column + 1 : Breakpoint::unspecifiedColumn;</span>


283 
284     if (line &lt; startLine || line &gt; endLine)
285         return;
<span class="line-modified">286     if (column != Breakpoint::unspecifiedColumn) {</span>
287         if (line == startLine &amp;&amp; column &lt; startColumn)
288             return;
289         if (line == endLine &amp;&amp; column &gt; endColumn)
290             return;
291     }
292 
293     if (!codeBlock-&gt;hasOpDebugForLineAndColumn(line, column))
294         return;
295 
296     if (enabledOrNot == BreakpointEnabled)
297         codeBlock-&gt;addBreakpoint(1);
298     else
299         codeBlock-&gt;removeBreakpoint(1);
300 }
301 
302 void Debugger::applyBreakpoints(CodeBlock* codeBlock)
303 {
304     BreakpointIDToBreakpointMap&amp; breakpoints = m_breakpointIDToBreakpoint;
305     for (auto* breakpoint : breakpoints.values())
306         toggleBreakpoint(codeBlock, *breakpoint, BreakpointEnabled);
</pre>
<hr />
<pre>
342 
343 DebuggerParseData&amp; Debugger::debuggerParseData(SourceID sourceID, SourceProvider* provider)
344 {
345     auto iter = m_parseDataMap.find(sourceID);
346     if (iter != m_parseDataMap.end())
347         return iter-&gt;value;
348 
349     DebuggerParseData parseData;
350     gatherDebuggerParseDataForSource(m_vm, provider, parseData);
351     auto result = m_parseDataMap.add(sourceID, parseData);
352     return result.iterator-&gt;value;
353 }
354 
355 void Debugger::resolveBreakpoint(Breakpoint&amp; breakpoint, SourceProvider* sourceProvider)
356 {
357     RELEASE_ASSERT(!breakpoint.resolved);
358     ASSERT(breakpoint.sourceID != noSourceID);
359 
360     // FIXME: &lt;https://webkit.org/b/162771&gt; Web Inspector: Adopt TextPosition in Inspector to avoid oneBasedInt/zeroBasedInt ambiguity
361     // Inspector breakpoint line and column values are zero-based but the executable
<span class="line-modified">362     // and CodeBlock line and column values are one-based.</span>
<span class="line-modified">363     unsigned line = breakpoint.line + 1;</span>
<span class="line-modified">364     unsigned column = breakpoint.column ? breakpoint.column : Breakpoint::unspecifiedColumn;</span>









365 
366     DebuggerParseData&amp; parseData = debuggerParseData(breakpoint.sourceID, sourceProvider);
<span class="line-modified">367     Optional&lt;JSTextPosition&gt; resolvedPosition = parseData.pausePositions.breakpointLocationForLineColumn((int)line, (int)column);</span>
368     if (!resolvedPosition)
369         return;
370 
<span class="line-modified">371     unsigned resolvedLine = resolvedPosition-&gt;line;</span>
<span class="line-modified">372     unsigned resolvedColumn = resolvedPosition-&gt;offset - resolvedPosition-&gt;lineStartOffset + 1;</span>






373 
374     breakpoint.line = resolvedLine - 1;
<span class="line-modified">375     breakpoint.column = resolvedColumn - 1;</span>
376     breakpoint.resolved = true;
377 }
378 
379 BreakpointID Debugger::setBreakpoint(Breakpoint&amp; breakpoint, bool&amp; existing)
380 {
381     ASSERT(breakpoint.resolved);
382     ASSERT(breakpoint.sourceID != noSourceID);
383 
384     SourceID sourceID = breakpoint.sourceID;
385     unsigned line = breakpoint.line;
386     unsigned column = breakpoint.column;
387 
388     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(breakpoint.sourceID);
389     if (it == m_sourceIDToBreakpoints.end())
390         it = m_sourceIDToBreakpoints.set(sourceID, LineToBreakpointsMap()).iterator;
391 
392     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(line);
393     if (breaksIt == it-&gt;value.end())
394         breaksIt = it-&gt;value.set(line, adoptRef(new BreakpointsList)).iterator;
395 
</pre>
<hr />
<pre>
418 }
419 
420 void Debugger::removeBreakpoint(BreakpointID id)
421 {
422     ASSERT(id != noBreakpointID);
423 
424     BreakpointIDToBreakpointMap::iterator idIt = m_breakpointIDToBreakpoint.find(id);
425     ASSERT(idIt != m_breakpointIDToBreakpoint.end());
426     Breakpoint* breakpoint = idIt-&gt;value;
427 
428     SourceID sourceID = breakpoint-&gt;sourceID;
429     ASSERT(sourceID);
430     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(sourceID);
431     ASSERT(it != m_sourceIDToBreakpoints.end());
432     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(breakpoint-&gt;line);
433     ASSERT(breaksIt != it-&gt;value.end());
434 
435     toggleBreakpoint(*breakpoint, BreakpointDisabled);
436 
437     BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
<span class="line-modified">438 #if !ASSERT_DISABLED</span>
439     bool found = false;
440     for (Breakpoint* current = breakpoints.head(); current &amp;&amp; !found; current = current-&gt;next()) {
441         if (current-&gt;id == breakpoint-&gt;id)
442             found = true;
443     }
444     ASSERT(found);
<span class="line-modified">445 #endif</span>
446 
447     m_breakpointIDToBreakpoint.remove(idIt);
448     breakpoints.remove(breakpoint);
449     delete breakpoint;
450 
451     if (breakpoints.isEmpty()) {
452         it-&gt;value.remove(breaksIt);
453         if (it-&gt;value.isEmpty())
454             m_sourceIDToBreakpoints.remove(it);
455     }
456 }
457 
458 bool Debugger::hasBreakpoint(SourceID sourceID, const TextPosition&amp; position, Breakpoint *hitBreakpoint)
459 {
460     if (!m_breakpointsActivated)
461         return false;
462 
463     SourceIDToBreakpointsMap::const_iterator it = m_sourceIDToBreakpoints.find(sourceID);
464     if (it == m_sourceIDToBreakpoints.end())
465         return false;
</pre>
<hr />
<pre>
494     breakpoint-&gt;hitCount++;
495     if (breakpoint-&gt;ignoreCount &gt;= breakpoint-&gt;hitCount)
496         return false;
497 
498     if (breakpoint-&gt;condition.isEmpty())
499         return true;
500 
501     // We cannot stop in the debugger while executing condition code,
502     // so make it looks like the debugger is already paused.
503     TemporaryPausedState pausedState(*this);
504 
505     NakedPtr&lt;Exception&gt; exception;
506     DebuggerCallFrame&amp; debuggerCallFrame = currentDebuggerCallFrame();
507     JSObject* scopeExtensionObject = nullptr;
508     JSValue result = debuggerCallFrame.evaluateWithScopeExtension(breakpoint-&gt;condition, scopeExtensionObject, exception);
509 
510     // We can lose the debugger while executing JavaScript.
511     if (!m_currentCallFrame)
512         return false;
513 

514     if (exception) {
515         // An erroneous condition counts as &quot;false&quot;.
<span class="line-modified">516         handleExceptionInBreakpointCondition(m_currentCallFrame, exception);</span>
517         return false;
518     }
519 
<span class="line-modified">520     return result.toBoolean(m_currentCallFrame);</span>
521 }
522 
523 class Debugger::ClearCodeBlockDebuggerRequestsFunctor {
524 public:
525     ClearCodeBlockDebuggerRequestsFunctor(Debugger* debugger)
526         : m_debugger(debugger)
527     {
528     }
529 
530     void operator()(CodeBlock* codeBlock) const
531     {
532         if (codeBlock-&gt;hasDebuggerRequests() &amp;&amp; m_debugger == codeBlock-&gt;globalObject()-&gt;debugger())
533             codeBlock-&gt;clearDebuggerRequests();
534     }
535 
536 private:
537     Debugger* m_debugger;
538 };
539 
540 void Debugger::clearBreakpoints()
</pre>
<hr />
<pre>
594 }
595 
596 void Debugger::setPauseOnNextStatement(bool pause)
597 {
598     m_pauseAtNextOpportunity = pause;
599     if (pause)
600         setSteppingMode(SteppingModeEnabled);
601 }
602 
603 void Debugger::breakProgram()
604 {
605     if (m_isPaused)
606         return;
607 
608     if (!m_vm.topCallFrame)
609         return;
610 
611     m_pauseAtNextOpportunity = true;
612     setSteppingMode(SteppingModeEnabled);
613     m_currentCallFrame = m_vm.topCallFrame;
<span class="line-modified">614     pauseIfNeeded(m_currentCallFrame);</span>
615 }
616 
617 void Debugger::continueProgram()
618 {
619     clearNextPauseState();
620 
621     if (!m_isPaused)
622         return;
623 
624     notifyDoneProcessingDebuggerEvents();
625 }
626 
627 void Debugger::stepIntoStatement()
628 {
629     if (!m_isPaused)
630         return;
631 
632     m_pauseAtNextOpportunity = true;
633     setSteppingMode(SteppingModeEnabled);
634     notifyDoneProcessingDebuggerEvents();
</pre>
<hr />
<pre>
639     if (!m_isPaused)
640         return;
641 
642     m_pauseOnCallFrame = m_currentCallFrame;
643     setSteppingMode(SteppingModeEnabled);
644     notifyDoneProcessingDebuggerEvents();
645 }
646 
647 void Debugger::stepOutOfFunction()
648 {
649     if (!m_isPaused)
650         return;
651 
652     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
653     m_pauseOnCallFrame = m_currentCallFrame ? m_currentCallFrame-&gt;callerFrame(topEntryFrame) : nullptr;
654     m_pauseOnStepOut = true;
655     setSteppingMode(SteppingModeEnabled);
656     notifyDoneProcessingDebuggerEvents();
657 }
658 
<span class="line-modified">659 void Debugger::updateCallFrame(CallFrame* callFrame, CallFrameUpdateAction action)</span>







660 {
661     if (!callFrame) {
662         m_currentCallFrame = nullptr;
663         return;
664     }
<span class="line-removed">665 </span>
666     updateCallFrameInternal(callFrame);
667 
668     if (action == AttemptPause)
<span class="line-modified">669         pauseIfNeeded(callFrame);</span>
670 
671     if (!isStepping())
672         m_currentCallFrame = nullptr;
673 }
674 
675 void Debugger::updateCallFrameInternal(CallFrame* callFrame)
676 {
677     m_currentCallFrame = callFrame;
678     SourceID sourceID = DebuggerCallFrame::sourceIDForCallFrame(callFrame);
679     if (m_lastExecutedSourceID != sourceID) {
680         m_lastExecutedLine = UINT_MAX;
681         m_lastExecutedSourceID = sourceID;
682     }
683 }
684 
<span class="line-modified">685 void Debugger::pauseIfNeeded(CallFrame* callFrame)</span>
686 {
687     VM&amp; vm = m_vm;
688     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">689     ASSERT(callFrame);</span>
690 
691     if (m_isPaused)
692         return;
693 
694     if (m_suppressAllPauses)
695         return;
696 
697     intptr_t sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);
<span class="line-modified">698     if (isBlacklisted(sourceID))</span>


699         return;
700 
701     DebuggerPausedScope debuggerPausedScope(*this);
702 
703     bool pauseNow = m_pauseAtNextOpportunity;
704     pauseNow |= (m_pauseOnCallFrame == m_currentCallFrame);
705 
706     bool didPauseForStep = pauseNow;
707 
708     Breakpoint breakpoint;
709     TextPosition position = DebuggerCallFrame::positionForCallFrame(vm, m_currentCallFrame);
710     bool didHitBreakpoint = hasBreakpoint(sourceID, position, &amp;breakpoint);
711     pauseNow |= didHitBreakpoint;
712     m_lastExecutedLine = position.m_line.zeroBasedInt();
713     if (!pauseNow)
714         return;
715 

716     clearNextPauseState();
717 
718     // Make sure we are not going to pause again on breakpoint actions by
719     // reseting the pause state before executing any breakpoint actions.
720     TemporaryPausedState pausedState(*this);
721 
<span class="line-removed">722     JSGlobalObject* vmEntryGlobalObject = vm.vmEntryGlobalObject(callFrame);</span>
<span class="line-removed">723 </span>
724     if (didHitBreakpoint) {
<span class="line-modified">725         handleBreakpointHit(vmEntryGlobalObject, breakpoint);</span>
726         // Note that the actions can potentially stop the debugger, so we need to check that
727         // we still have a current call frame when we get back.
728         if (!m_currentCallFrame)
729             return;
730 
731         if (breakpoint.autoContinue) {
732             if (!didPauseForStep)
733                 return;
734             didHitBreakpoint = false;
735         } else
736             m_pausingBreakpointID = breakpoint.id;
737     }
738 






739     {
<span class="line-modified">740         PauseReasonDeclaration reason(*this, didHitBreakpoint ? PausedForBreakpoint : m_reasonForPause);</span>
<span class="line-modified">741         handlePause(vmEntryGlobalObject, m_reasonForPause);</span>






742         scope.releaseAssertNoException();
743     }
744 
745     m_pausingBreakpointID = noBreakpointID;
746 
747     if (!m_pauseAtNextOpportunity &amp;&amp; !m_pauseOnCallFrame) {
748         setSteppingMode(SteppingModeDisabled);
749         m_currentCallFrame = nullptr;
750     }
751 }
752 
<span class="line-modified">753 void Debugger::exception(CallFrame* callFrame, JSValue exception, bool hasCatchHandler)</span>
754 {
755     if (m_isPaused)
756         return;
757 
758     if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(m_vm, exception)) {
759         if (object-&gt;isErrorInstance()) {
760             ErrorInstance* error = static_cast&lt;ErrorInstance*&gt;(object);
761             // FIXME: &lt;https://webkit.org/b/173625&gt; Web Inspector: Should be able to pause and debug a StackOverflow Exception
762             // FIXME: &lt;https://webkit.org/b/173627&gt; Web Inspector: Should be able to pause and debug an OutOfMemory Exception
763             if (error-&gt;isStackOverflowError() || error-&gt;isOutOfMemoryError())
764                 return;
765         }
766     }
767 
768     PauseReasonDeclaration reason(*this, PausedForException);
769     if (m_pauseOnExceptionsState == PauseOnAllExceptions || (m_pauseOnExceptionsState == PauseOnUncaughtExceptions &amp;&amp; !hasCatchHandler)) {
770         m_pauseAtNextOpportunity = true;
771         setSteppingMode(SteppingModeEnabled);
772     }
773 
774     m_hasHandlerForExceptionCallback = true;
775     m_currentException = exception;
<span class="line-modified">776     updateCallFrame(callFrame, AttemptPause);</span>
777     m_currentException = JSValue();
778     m_hasHandlerForExceptionCallback = false;
779 }
780 
781 void Debugger::atStatement(CallFrame* callFrame)
782 {
783     if (m_isPaused)
784         return;
785 
786     m_pastFirstExpressionInStatement = false;
787 
788     PauseReasonDeclaration reason(*this, PausedAtStatement);
<span class="line-modified">789     updateCallFrame(callFrame, AttemptPause);</span>
790 }
791 
792 void Debugger::atExpression(CallFrame* callFrame)
793 {
794     if (m_isPaused)
795         return;
796 
797     // If this is the first call in a statement, then we would have paused at the statement.
798     if (!m_pastFirstExpressionInStatement) {
799         m_pastFirstExpressionInStatement = true;
800         return;
801     }
802 
803     // Only pause at the next expression with step-in and step-out, not step-over.
804     bool shouldAttemptPause = m_pauseAtNextOpportunity || m_pauseOnStepOut;
805 
806     PauseReasonDeclaration reason(*this, PausedAtExpression);
<span class="line-modified">807     updateCallFrame(callFrame, shouldAttemptPause ? AttemptPause : NoPause);</span>
808 }
809 
810 void Debugger::callEvent(CallFrame* callFrame)
811 {
812     if (m_isPaused)
813         return;
814 
<span class="line-modified">815     updateCallFrame(callFrame, NoPause);</span>
816 }
817 
818 void Debugger::returnEvent(CallFrame* callFrame)
819 {
820     if (m_isPaused)
821         return;
822 
823     {
824         PauseReasonDeclaration reason(*this, PausedBeforeReturn);
<span class="line-modified">825         updateCallFrame(callFrame, AttemptPause);</span>
826     }
827 
828     // Detach may have been called during pauseIfNeeded.
829     if (!m_currentCallFrame)
830         return;
831 
832     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
833     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
834 
835     // Returning from a call, there was at least one expression on the statement we are returning to.
836     m_pastFirstExpressionInStatement = true;
837 
838     // Treat stepping over a return statement like a step-out.
839     if (m_currentCallFrame == m_pauseOnCallFrame) {
840         m_pauseOnCallFrame = callerFrame;
841         m_pauseOnStepOut = true;
842     }
843 
<span class="line-modified">844     updateCallFrame(callerFrame, NoPause);</span>
845 }
846 
847 void Debugger::unwindEvent(CallFrame* callFrame)
848 {
849     if (m_isPaused)
850         return;
851 
<span class="line-modified">852     updateCallFrame(callFrame, NoPause);</span>
853 
854     if (!m_currentCallFrame)
855         return;
856 
857     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
858     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
859 
860     // Treat stepping over an exception location like a step-out.
861     if (m_currentCallFrame == m_pauseOnCallFrame)
862         m_pauseOnCallFrame = callerFrame;
863 
<span class="line-modified">864     updateCallFrame(callerFrame, NoPause);</span>
865 }
866 
867 void Debugger::willExecuteProgram(CallFrame* callFrame)
868 {
869     if (m_isPaused)
870         return;
871 
<span class="line-modified">872     updateCallFrame(callFrame, NoPause);</span>
873 }
874 
875 void Debugger::didExecuteProgram(CallFrame* callFrame)
876 {
877     if (m_isPaused)
878         return;
879 
880     PauseReasonDeclaration reason(*this, PausedAtEndOfProgram);
<span class="line-modified">881     updateCallFrame(callFrame, AttemptPause);</span>
882 
883     // Detach may have been called during pauseIfNeeded.
884     if (!m_currentCallFrame)
885         return;
886 
887     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
888     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
889 
890     // Returning from a program, could be eval(), there was at least one expression on the statement we are returning to.
891     m_pastFirstExpressionInStatement = true;
892 
893     // Treat stepping over the end of a program like a step-out.
894     if (m_currentCallFrame == m_pauseOnCallFrame) {
895         m_pauseOnCallFrame = callerFrame;
896         m_pauseAtNextOpportunity = true;
897     }
898 
<span class="line-modified">899     updateCallFrame(callerFrame, NoPause);</span>
900 
901     // Do not continue stepping into an unknown future program.
902     if (!m_currentCallFrame)
903         clearNextPauseState();
904 }
905 
906 void Debugger::clearNextPauseState()
907 {
908     m_pauseOnCallFrame = nullptr;
909     m_pauseAtNextOpportunity = false;
910     m_pauseOnStepOut = false;

911 }
912 
<span class="line-modified">913 void Debugger::didReachBreakpoint(CallFrame* callFrame)</span>
914 {
915     if (m_isPaused)
916         return;
917 



918     PauseReasonDeclaration reason(*this, PausedForDebuggerStatement);
919     m_pauseAtNextOpportunity = true;
920     setSteppingMode(SteppingModeEnabled);
<span class="line-modified">921     updateCallFrame(callFrame, AttemptPause);</span>
922 }
923 
924 DebuggerCallFrame&amp; Debugger::currentDebuggerCallFrame()
925 {
926     if (!m_currentDebuggerCallFrame)
927         m_currentDebuggerCallFrame = DebuggerCallFrame::create(m_vm, m_currentCallFrame);
928     return *m_currentDebuggerCallFrame;
929 }
930 
<span class="line-modified">931 bool Debugger::isBlacklisted(SourceID sourceID) const</span>
<span class="line-removed">932 {</span>
<span class="line-removed">933     return m_blacklistedScripts.contains(sourceID);</span>
<span class="line-removed">934 }</span>
<span class="line-removed">935 </span>
<span class="line-removed">936 void Debugger::addToBlacklist(SourceID sourceID)</span>
937 {
<span class="line-modified">938     m_blacklistedScripts.add(sourceID);</span>



939 }
940 
<span class="line-modified">941 void Debugger::clearBlacklist()</span>
942 {
<span class="line-modified">943     m_blacklistedScripts.clear();</span>
944 }
945 
946 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;Debugger.h&quot;
 24 
 25 #include &quot;CodeBlock.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;Error.h&quot;
 28 #include &quot;HeapIterationScope.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGlobalObject.h&quot;
 34 #include &quot;MarkedSpaceInlines.h&quot;
 35 #include &quot;Parser.h&quot;
 36 #include &quot;Protect.h&quot;
 37 #include &quot;VMEntryScope.h&quot;
 38 









































 39 namespace JSC {
 40 
 41 class DebuggerPausedScope {
 42 public:
 43     DebuggerPausedScope(Debugger&amp; debugger)
 44         : m_debugger(debugger)
 45     {
 46         ASSERT(!m_debugger.m_currentDebuggerCallFrame);
 47     }
 48 
 49     ~DebuggerPausedScope()
 50     {
 51         if (m_debugger.m_currentDebuggerCallFrame) {
 52             m_debugger.m_currentDebuggerCallFrame-&gt;invalidate();
 53             m_debugger.m_currentDebuggerCallFrame = nullptr;
 54         }
 55     }
 56 
 57 private:
 58     Debugger&amp; m_debugger;
</pre>
<hr />
<pre>
 99     , m_topBreakpointID(noBreakpointID)
100     , m_pausingBreakpointID(noBreakpointID)
101 {
102 }
103 
104 Debugger::~Debugger()
105 {
106     HashSet&lt;JSGlobalObject*&gt;::iterator end = m_globalObjects.end();
107     for (HashSet&lt;JSGlobalObject*&gt;::iterator it = m_globalObjects.begin(); it != end; ++it)
108         (*it)-&gt;setDebugger(nullptr);
109 }
110 
111 void Debugger::attach(JSGlobalObject* globalObject)
112 {
113     ASSERT(!globalObject-&gt;debugger());
114     globalObject-&gt;setDebugger(this);
115     m_globalObjects.add(globalObject);
116 
117     m_vm.setShouldBuildPCToCodeOriginMapping();
118 
<span class="line-modified">119     // Call `sourceParsed` after iterating because it will execute JavaScript in Web Inspector.</span>
<span class="line-modified">120     HashSet&lt;RefPtr&lt;SourceProvider&gt;&gt; sourceProviders;</span>
121     {
122         HeapIterationScope iterationScope(m_vm.heap);
<span class="line-modified">123         m_vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* heapCell, HeapCell::Kind kind) {</span>
<span class="line-added">124             if (isJSCellKind(kind)) {</span>
<span class="line-added">125                 auto* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-added">126                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(cell-&gt;vm(), cell)) {</span>
<span class="line-added">127                     if (function-&gt;scope()-&gt;globalObject() == globalObject &amp;&amp; function-&gt;executable()-&gt;isFunctionExecutable() &amp;&amp; !function-&gt;isHostOrBuiltinFunction())</span>
<span class="line-added">128                         sourceProviders.add(jsCast&lt;FunctionExecutable*&gt;(function-&gt;executable())-&gt;source().provider());</span>
<span class="line-added">129                 }</span>
<span class="line-added">130             }</span>
<span class="line-added">131             return IterationStatus::Continue;</span>
<span class="line-added">132         });</span>
133     }
<span class="line-modified">134     for (auto&amp; sourceProvider : sourceProviders)</span>
<span class="line-modified">135         sourceParsed(globalObject, sourceProvider.get(), -1, nullString());</span>
136 }
137 
138 void Debugger::detach(JSGlobalObject* globalObject, ReasonForDetach reason)
139 {
140     // If we&#39;re detaching from the currently executing global object, manually tear down our
141     // stack, since we won&#39;t get further debugger callbacks to do so. Also, resume execution,
142     // since there&#39;s no point in staying paused once a window closes.
143     // We know there is an entry scope, otherwise, m_currentCallFrame would be null.
144     VM&amp; vm = globalObject-&gt;vm();
<span class="line-added">145     JSLockHolder locker(vm);</span>
<span class="line-added">146 </span>
147     if (m_isPaused &amp;&amp; m_currentCallFrame &amp;&amp; vm.entryScope-&gt;globalObject() == globalObject) {
148         m_currentCallFrame = nullptr;
149         m_pauseOnCallFrame = nullptr;
150         continueProgram();
151     }
152 
153     ASSERT(m_globalObjects.contains(globalObject));
154     m_globalObjects.remove(globalObject);
155 
156     // If the globalObject is destructing, then its CodeBlocks will also be
157     // destructed. There is no need to do the debugger requests clean up, and
158     // it is not safe to access those CodeBlocks at this time anyway.
159     if (reason != GlobalObjectIsDestructing)
160         clearDebuggerRequests(globalObject);
161 
162     globalObject-&gt;setDebugger(nullptr);
163 
164     if (m_globalObjects.isEmpty())
165         clearParsedData();
166 }
</pre>
<hr />
<pre>
221 Seconds Debugger::willEvaluateScript()
222 {
223     return m_profilingClient-&gt;willEvaluateScript();
224 }
225 
226 void Debugger::didEvaluateScript(Seconds startTime, ProfilingReason reason)
227 {
228     m_profilingClient-&gt;didEvaluateScript(startTime, reason);
229 }
230 
231 void Debugger::toggleBreakpoint(CodeBlock* codeBlock, Breakpoint&amp; breakpoint, BreakpointState enabledOrNot)
232 {
233     ASSERT(breakpoint.resolved);
234 
235     ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
236 
237     SourceID sourceID = static_cast&lt;SourceID&gt;(executable-&gt;sourceID());
238     if (breakpoint.sourceID != sourceID)
239         return;
240 



241     unsigned startLine = executable-&gt;firstLine();
242     unsigned startColumn = executable-&gt;startColumn();
243     unsigned endLine = executable-&gt;lastLine();
244     unsigned endColumn = executable-&gt;endColumn();
245 
246     // Inspector breakpoint line and column values are zero-based but the executable
247     // and CodeBlock line and column values are one-based.
<span class="line-modified">248     unsigned line = breakpoint.line + 1;</span>
<span class="line-modified">249     Optional&lt;unsigned&gt; column;</span>
<span class="line-added">250     if (breakpoint.column)</span>
<span class="line-added">251         column = breakpoint.column + 1;</span>
252 
253     if (line &lt; startLine || line &gt; endLine)
254         return;
<span class="line-modified">255     if (column) {</span>
256         if (line == startLine &amp;&amp; column &lt; startColumn)
257             return;
258         if (line == endLine &amp;&amp; column &gt; endColumn)
259             return;
260     }
261 
262     if (!codeBlock-&gt;hasOpDebugForLineAndColumn(line, column))
263         return;
264 
265     if (enabledOrNot == BreakpointEnabled)
266         codeBlock-&gt;addBreakpoint(1);
267     else
268         codeBlock-&gt;removeBreakpoint(1);
269 }
270 
271 void Debugger::applyBreakpoints(CodeBlock* codeBlock)
272 {
273     BreakpointIDToBreakpointMap&amp; breakpoints = m_breakpointIDToBreakpoint;
274     for (auto* breakpoint : breakpoints.values())
275         toggleBreakpoint(codeBlock, *breakpoint, BreakpointEnabled);
</pre>
<hr />
<pre>
311 
312 DebuggerParseData&amp; Debugger::debuggerParseData(SourceID sourceID, SourceProvider* provider)
313 {
314     auto iter = m_parseDataMap.find(sourceID);
315     if (iter != m_parseDataMap.end())
316         return iter-&gt;value;
317 
318     DebuggerParseData parseData;
319     gatherDebuggerParseDataForSource(m_vm, provider, parseData);
320     auto result = m_parseDataMap.add(sourceID, parseData);
321     return result.iterator-&gt;value;
322 }
323 
324 void Debugger::resolveBreakpoint(Breakpoint&amp; breakpoint, SourceProvider* sourceProvider)
325 {
326     RELEASE_ASSERT(!breakpoint.resolved);
327     ASSERT(breakpoint.sourceID != noSourceID);
328 
329     // FIXME: &lt;https://webkit.org/b/162771&gt; Web Inspector: Adopt TextPosition in Inspector to avoid oneBasedInt/zeroBasedInt ambiguity
330     // Inspector breakpoint line and column values are zero-based but the executable
<span class="line-modified">331     // and CodeBlock line values are one-based while column is zero-based.</span>
<span class="line-modified">332     int line = breakpoint.line + 1;</span>
<span class="line-modified">333     int column = breakpoint.column;</span>
<span class="line-added">334 </span>
<span class="line-added">335     // Account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">336     int providerStartLine = sourceProvider-&gt;startPosition().m_line.oneBasedInt(); // One based to match the already adjusted line.</span>
<span class="line-added">337     int providerStartColumn = sourceProvider-&gt;startPosition().m_column.zeroBasedInt(); // Zero based so column zero is zero.</span>
<span class="line-added">338     if (line == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">339         ASSERT(providerStartColumn &lt;= column);</span>
<span class="line-added">340         if (providerStartColumn)</span>
<span class="line-added">341             column -= providerStartColumn;</span>
<span class="line-added">342     }</span>
343 
344     DebuggerParseData&amp; parseData = debuggerParseData(breakpoint.sourceID, sourceProvider);
<span class="line-modified">345     Optional&lt;JSTextPosition&gt; resolvedPosition = parseData.pausePositions.breakpointLocationForLineColumn(line, column);</span>
346     if (!resolvedPosition)
347         return;
348 
<span class="line-modified">349     int resolvedLine = resolvedPosition-&gt;line;</span>
<span class="line-modified">350     int resolvedColumn = resolvedPosition-&gt;column();</span>
<span class="line-added">351 </span>
<span class="line-added">352     // Re-account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">353     if (resolvedLine == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">354         if (providerStartColumn)</span>
<span class="line-added">355             resolvedColumn += providerStartColumn;</span>
<span class="line-added">356     }</span>
357 
358     breakpoint.line = resolvedLine - 1;
<span class="line-modified">359     breakpoint.column = resolvedColumn;</span>
360     breakpoint.resolved = true;
361 }
362 
363 BreakpointID Debugger::setBreakpoint(Breakpoint&amp; breakpoint, bool&amp; existing)
364 {
365     ASSERT(breakpoint.resolved);
366     ASSERT(breakpoint.sourceID != noSourceID);
367 
368     SourceID sourceID = breakpoint.sourceID;
369     unsigned line = breakpoint.line;
370     unsigned column = breakpoint.column;
371 
372     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(breakpoint.sourceID);
373     if (it == m_sourceIDToBreakpoints.end())
374         it = m_sourceIDToBreakpoints.set(sourceID, LineToBreakpointsMap()).iterator;
375 
376     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(line);
377     if (breaksIt == it-&gt;value.end())
378         breaksIt = it-&gt;value.set(line, adoptRef(new BreakpointsList)).iterator;
379 
</pre>
<hr />
<pre>
402 }
403 
404 void Debugger::removeBreakpoint(BreakpointID id)
405 {
406     ASSERT(id != noBreakpointID);
407 
408     BreakpointIDToBreakpointMap::iterator idIt = m_breakpointIDToBreakpoint.find(id);
409     ASSERT(idIt != m_breakpointIDToBreakpoint.end());
410     Breakpoint* breakpoint = idIt-&gt;value;
411 
412     SourceID sourceID = breakpoint-&gt;sourceID;
413     ASSERT(sourceID);
414     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(sourceID);
415     ASSERT(it != m_sourceIDToBreakpoints.end());
416     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(breakpoint-&gt;line);
417     ASSERT(breaksIt != it-&gt;value.end());
418 
419     toggleBreakpoint(*breakpoint, BreakpointDisabled);
420 
421     BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
<span class="line-modified">422 #if ASSERT_ENABLED</span>
423     bool found = false;
424     for (Breakpoint* current = breakpoints.head(); current &amp;&amp; !found; current = current-&gt;next()) {
425         if (current-&gt;id == breakpoint-&gt;id)
426             found = true;
427     }
428     ASSERT(found);
<span class="line-modified">429 #endif // ASSERT_ENABLED</span>
430 
431     m_breakpointIDToBreakpoint.remove(idIt);
432     breakpoints.remove(breakpoint);
433     delete breakpoint;
434 
435     if (breakpoints.isEmpty()) {
436         it-&gt;value.remove(breaksIt);
437         if (it-&gt;value.isEmpty())
438             m_sourceIDToBreakpoints.remove(it);
439     }
440 }
441 
442 bool Debugger::hasBreakpoint(SourceID sourceID, const TextPosition&amp; position, Breakpoint *hitBreakpoint)
443 {
444     if (!m_breakpointsActivated)
445         return false;
446 
447     SourceIDToBreakpointsMap::const_iterator it = m_sourceIDToBreakpoints.find(sourceID);
448     if (it == m_sourceIDToBreakpoints.end())
449         return false;
</pre>
<hr />
<pre>
478     breakpoint-&gt;hitCount++;
479     if (breakpoint-&gt;ignoreCount &gt;= breakpoint-&gt;hitCount)
480         return false;
481 
482     if (breakpoint-&gt;condition.isEmpty())
483         return true;
484 
485     // We cannot stop in the debugger while executing condition code,
486     // so make it looks like the debugger is already paused.
487     TemporaryPausedState pausedState(*this);
488 
489     NakedPtr&lt;Exception&gt; exception;
490     DebuggerCallFrame&amp; debuggerCallFrame = currentDebuggerCallFrame();
491     JSObject* scopeExtensionObject = nullptr;
492     JSValue result = debuggerCallFrame.evaluateWithScopeExtension(breakpoint-&gt;condition, scopeExtensionObject, exception);
493 
494     // We can lose the debugger while executing JavaScript.
495     if (!m_currentCallFrame)
496         return false;
497 
<span class="line-added">498     JSGlobalObject* globalObject = m_currentCallFrame-&gt;lexicalGlobalObject(m_vm);</span>
499     if (exception) {
500         // An erroneous condition counts as &quot;false&quot;.
<span class="line-modified">501         handleExceptionInBreakpointCondition(globalObject, exception);</span>
502         return false;
503     }
504 
<span class="line-modified">505     return result.toBoolean(globalObject);</span>
506 }
507 
508 class Debugger::ClearCodeBlockDebuggerRequestsFunctor {
509 public:
510     ClearCodeBlockDebuggerRequestsFunctor(Debugger* debugger)
511         : m_debugger(debugger)
512     {
513     }
514 
515     void operator()(CodeBlock* codeBlock) const
516     {
517         if (codeBlock-&gt;hasDebuggerRequests() &amp;&amp; m_debugger == codeBlock-&gt;globalObject()-&gt;debugger())
518             codeBlock-&gt;clearDebuggerRequests();
519     }
520 
521 private:
522     Debugger* m_debugger;
523 };
524 
525 void Debugger::clearBreakpoints()
</pre>
<hr />
<pre>
579 }
580 
581 void Debugger::setPauseOnNextStatement(bool pause)
582 {
583     m_pauseAtNextOpportunity = pause;
584     if (pause)
585         setSteppingMode(SteppingModeEnabled);
586 }
587 
588 void Debugger::breakProgram()
589 {
590     if (m_isPaused)
591         return;
592 
593     if (!m_vm.topCallFrame)
594         return;
595 
596     m_pauseAtNextOpportunity = true;
597     setSteppingMode(SteppingModeEnabled);
598     m_currentCallFrame = m_vm.topCallFrame;
<span class="line-modified">599     pauseIfNeeded(m_currentCallFrame-&gt;lexicalGlobalObject(m_vm));</span>
600 }
601 
602 void Debugger::continueProgram()
603 {
604     clearNextPauseState();
605 
606     if (!m_isPaused)
607         return;
608 
609     notifyDoneProcessingDebuggerEvents();
610 }
611 
612 void Debugger::stepIntoStatement()
613 {
614     if (!m_isPaused)
615         return;
616 
617     m_pauseAtNextOpportunity = true;
618     setSteppingMode(SteppingModeEnabled);
619     notifyDoneProcessingDebuggerEvents();
</pre>
<hr />
<pre>
624     if (!m_isPaused)
625         return;
626 
627     m_pauseOnCallFrame = m_currentCallFrame;
628     setSteppingMode(SteppingModeEnabled);
629     notifyDoneProcessingDebuggerEvents();
630 }
631 
632 void Debugger::stepOutOfFunction()
633 {
634     if (!m_isPaused)
635         return;
636 
637     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
638     m_pauseOnCallFrame = m_currentCallFrame ? m_currentCallFrame-&gt;callerFrame(topEntryFrame) : nullptr;
639     m_pauseOnStepOut = true;
640     setSteppingMode(SteppingModeEnabled);
641     notifyDoneProcessingDebuggerEvents();
642 }
643 
<span class="line-modified">644 static inline JSGlobalObject* lexicalGlobalObjectForCallFrame(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added">645 {</span>
<span class="line-added">646     if (!callFrame)</span>
<span class="line-added">647         return nullptr;</span>
<span class="line-added">648     return callFrame-&gt;lexicalGlobalObject(vm);</span>
<span class="line-added">649 }</span>
<span class="line-added">650 </span>
<span class="line-added">651 void Debugger::updateCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrameUpdateAction action)</span>
652 {
653     if (!callFrame) {
654         m_currentCallFrame = nullptr;
655         return;
656     }

657     updateCallFrameInternal(callFrame);
658 
659     if (action == AttemptPause)
<span class="line-modified">660         pauseIfNeeded(globalObject);</span>
661 
662     if (!isStepping())
663         m_currentCallFrame = nullptr;
664 }
665 
666 void Debugger::updateCallFrameInternal(CallFrame* callFrame)
667 {
668     m_currentCallFrame = callFrame;
669     SourceID sourceID = DebuggerCallFrame::sourceIDForCallFrame(callFrame);
670     if (m_lastExecutedSourceID != sourceID) {
671         m_lastExecutedLine = UINT_MAX;
672         m_lastExecutedSourceID = sourceID;
673     }
674 }
675 
<span class="line-modified">676 void Debugger::pauseIfNeeded(JSGlobalObject* globalObject)</span>
677 {
678     VM&amp; vm = m_vm;
679     auto scope = DECLARE_THROW_SCOPE(vm);

680 
681     if (m_isPaused)
682         return;
683 
684     if (m_suppressAllPauses)
685         return;
686 
687     intptr_t sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);
<span class="line-modified">688 </span>
<span class="line-added">689     auto blackboxTypeIterator = m_blackboxedScripts.find(sourceID);</span>
<span class="line-added">690     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Ignored)</span>
691         return;
692 
693     DebuggerPausedScope debuggerPausedScope(*this);
694 
695     bool pauseNow = m_pauseAtNextOpportunity;
696     pauseNow |= (m_pauseOnCallFrame == m_currentCallFrame);
697 
698     bool didPauseForStep = pauseNow;
699 
700     Breakpoint breakpoint;
701     TextPosition position = DebuggerCallFrame::positionForCallFrame(vm, m_currentCallFrame);
702     bool didHitBreakpoint = hasBreakpoint(sourceID, position, &amp;breakpoint);
703     pauseNow |= didHitBreakpoint;
704     m_lastExecutedLine = position.m_line.zeroBasedInt();
705     if (!pauseNow)
706         return;
707 
<span class="line-added">708     bool afterBlackboxedScript = m_afterBlackboxedScript;</span>
709     clearNextPauseState();
710 
711     // Make sure we are not going to pause again on breakpoint actions by
712     // reseting the pause state before executing any breakpoint actions.
713     TemporaryPausedState pausedState(*this);
714 


715     if (didHitBreakpoint) {
<span class="line-modified">716         handleBreakpointHit(globalObject, breakpoint);</span>
717         // Note that the actions can potentially stop the debugger, so we need to check that
718         // we still have a current call frame when we get back.
719         if (!m_currentCallFrame)
720             return;
721 
722         if (breakpoint.autoContinue) {
723             if (!didPauseForStep)
724                 return;
725             didHitBreakpoint = false;
726         } else
727             m_pausingBreakpointID = breakpoint.id;
728     }
729 
<span class="line-added">730     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Deferred) {</span>
<span class="line-added">731         m_afterBlackboxedScript = true;</span>
<span class="line-added">732         setPauseOnNextStatement(true);</span>
<span class="line-added">733         return;</span>
<span class="line-added">734     }</span>
<span class="line-added">735 </span>
736     {
<span class="line-modified">737         auto reason = m_reasonForPause;</span>
<span class="line-modified">738         if (afterBlackboxedScript)</span>
<span class="line-added">739             reason = PausedAfterBlackboxedScript;</span>
<span class="line-added">740         else if (didHitBreakpoint)</span>
<span class="line-added">741             reason = PausedForBreakpoint;</span>
<span class="line-added">742         PauseReasonDeclaration rauseReasonDeclaration(*this, reason);</span>
<span class="line-added">743 </span>
<span class="line-added">744         handlePause(globalObject, m_reasonForPause);</span>
745         scope.releaseAssertNoException();
746     }
747 
748     m_pausingBreakpointID = noBreakpointID;
749 
750     if (!m_pauseAtNextOpportunity &amp;&amp; !m_pauseOnCallFrame) {
751         setSteppingMode(SteppingModeDisabled);
752         m_currentCallFrame = nullptr;
753     }
754 }
755 
<span class="line-modified">756 void Debugger::exception(JSGlobalObject* globalObject, CallFrame* callFrame, JSValue exception, bool hasCatchHandler)</span>
757 {
758     if (m_isPaused)
759         return;
760 
761     if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(m_vm, exception)) {
762         if (object-&gt;isErrorInstance()) {
763             ErrorInstance* error = static_cast&lt;ErrorInstance*&gt;(object);
764             // FIXME: &lt;https://webkit.org/b/173625&gt; Web Inspector: Should be able to pause and debug a StackOverflow Exception
765             // FIXME: &lt;https://webkit.org/b/173627&gt; Web Inspector: Should be able to pause and debug an OutOfMemory Exception
766             if (error-&gt;isStackOverflowError() || error-&gt;isOutOfMemoryError())
767                 return;
768         }
769     }
770 
771     PauseReasonDeclaration reason(*this, PausedForException);
772     if (m_pauseOnExceptionsState == PauseOnAllExceptions || (m_pauseOnExceptionsState == PauseOnUncaughtExceptions &amp;&amp; !hasCatchHandler)) {
773         m_pauseAtNextOpportunity = true;
774         setSteppingMode(SteppingModeEnabled);
775     }
776 
777     m_hasHandlerForExceptionCallback = true;
778     m_currentException = exception;
<span class="line-modified">779     updateCallFrame(globalObject, callFrame, AttemptPause);</span>
780     m_currentException = JSValue();
781     m_hasHandlerForExceptionCallback = false;
782 }
783 
784 void Debugger::atStatement(CallFrame* callFrame)
785 {
786     if (m_isPaused)
787         return;
788 
789     m_pastFirstExpressionInStatement = false;
790 
791     PauseReasonDeclaration reason(*this, PausedAtStatement);
<span class="line-modified">792     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
793 }
794 
795 void Debugger::atExpression(CallFrame* callFrame)
796 {
797     if (m_isPaused)
798         return;
799 
800     // If this is the first call in a statement, then we would have paused at the statement.
801     if (!m_pastFirstExpressionInStatement) {
802         m_pastFirstExpressionInStatement = true;
803         return;
804     }
805 
806     // Only pause at the next expression with step-in and step-out, not step-over.
807     bool shouldAttemptPause = m_pauseAtNextOpportunity || m_pauseOnStepOut;
808 
809     PauseReasonDeclaration reason(*this, PausedAtExpression);
<span class="line-modified">810     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, shouldAttemptPause ? AttemptPause : NoPause);</span>
811 }
812 
813 void Debugger::callEvent(CallFrame* callFrame)
814 {
815     if (m_isPaused)
816         return;
817 
<span class="line-modified">818     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
819 }
820 
821 void Debugger::returnEvent(CallFrame* callFrame)
822 {
823     if (m_isPaused)
824         return;
825 
826     {
827         PauseReasonDeclaration reason(*this, PausedBeforeReturn);
<span class="line-modified">828         updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
829     }
830 
831     // Detach may have been called during pauseIfNeeded.
832     if (!m_currentCallFrame)
833         return;
834 
835     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
836     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
837 
838     // Returning from a call, there was at least one expression on the statement we are returning to.
839     m_pastFirstExpressionInStatement = true;
840 
841     // Treat stepping over a return statement like a step-out.
842     if (m_currentCallFrame == m_pauseOnCallFrame) {
843         m_pauseOnCallFrame = callerFrame;
844         m_pauseOnStepOut = true;
845     }
846 
<span class="line-modified">847     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
848 }
849 
850 void Debugger::unwindEvent(CallFrame* callFrame)
851 {
852     if (m_isPaused)
853         return;
854 
<span class="line-modified">855     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
856 
857     if (!m_currentCallFrame)
858         return;
859 
860     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
861     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
862 
863     // Treat stepping over an exception location like a step-out.
864     if (m_currentCallFrame == m_pauseOnCallFrame)
865         m_pauseOnCallFrame = callerFrame;
866 
<span class="line-modified">867     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
868 }
869 
870 void Debugger::willExecuteProgram(CallFrame* callFrame)
871 {
872     if (m_isPaused)
873         return;
874 
<span class="line-modified">875     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
876 }
877 
878 void Debugger::didExecuteProgram(CallFrame* callFrame)
879 {
880     if (m_isPaused)
881         return;
882 
883     PauseReasonDeclaration reason(*this, PausedAtEndOfProgram);
<span class="line-modified">884     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
885 
886     // Detach may have been called during pauseIfNeeded.
887     if (!m_currentCallFrame)
888         return;
889 
890     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
891     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
892 
893     // Returning from a program, could be eval(), there was at least one expression on the statement we are returning to.
894     m_pastFirstExpressionInStatement = true;
895 
896     // Treat stepping over the end of a program like a step-out.
897     if (m_currentCallFrame == m_pauseOnCallFrame) {
898         m_pauseOnCallFrame = callerFrame;
899         m_pauseAtNextOpportunity = true;
900     }
901 
<span class="line-modified">902     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
903 
904     // Do not continue stepping into an unknown future program.
905     if (!m_currentCallFrame)
906         clearNextPauseState();
907 }
908 
909 void Debugger::clearNextPauseState()
910 {
911     m_pauseOnCallFrame = nullptr;
912     m_pauseAtNextOpportunity = false;
913     m_pauseOnStepOut = false;
<span class="line-added">914     m_afterBlackboxedScript = false;</span>
915 }
916 
<span class="line-modified">917 void Debugger::didReachDebuggerStatement(CallFrame* callFrame)</span>
918 {
919     if (m_isPaused)
920         return;
921 
<span class="line-added">922     if (!m_pauseOnDebuggerStatements)</span>
<span class="line-added">923         return;</span>
<span class="line-added">924 </span>
925     PauseReasonDeclaration reason(*this, PausedForDebuggerStatement);
926     m_pauseAtNextOpportunity = true;
927     setSteppingMode(SteppingModeEnabled);
<span class="line-modified">928     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
929 }
930 
931 DebuggerCallFrame&amp; Debugger::currentDebuggerCallFrame()
932 {
933     if (!m_currentDebuggerCallFrame)
934         m_currentDebuggerCallFrame = DebuggerCallFrame::create(m_vm, m_currentCallFrame);
935     return *m_currentDebuggerCallFrame;
936 }
937 
<span class="line-modified">938 void Debugger::setBlackboxType(SourceID sourceID, Optional&lt;BlackboxType&gt; type)</span>





939 {
<span class="line-modified">940     if (type)</span>
<span class="line-added">941         m_blackboxedScripts.set(sourceID, type.value());</span>
<span class="line-added">942     else</span>
<span class="line-added">943         m_blackboxedScripts.remove(sourceID);</span>
944 }
945 
<span class="line-modified">946 void Debugger::clearBlackbox()</span>
947 {
<span class="line-modified">948     m_blackboxedScripts.clear();</span>
949 }
950 
951 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Breakpoint.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Debugger.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
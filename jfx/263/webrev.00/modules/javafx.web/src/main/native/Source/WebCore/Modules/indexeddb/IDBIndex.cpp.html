<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBIndex.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBBindingUtilities.h&quot;
 32 #include &quot;IDBCursor.h&quot;
 33 #include &quot;IDBDatabase.h&quot;
 34 #include &quot;IDBKeyRangeData.h&quot;
 35 #include &quot;IDBObjectStore.h&quot;
 36 #include &quot;IDBRequest.h&quot;
 37 #include &quot;IDBTransaction.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 40 
 41 namespace WebCore {
 42 using namespace JSC;
 43 
 44 IDBIndex::IDBIndex(ScriptExecutionContext&amp; context, const IDBIndexInfo&amp; info, IDBObjectStore&amp; objectStore)
 45     : ActiveDOMObject(&amp;context)
 46     , m_info(info)
 47     , m_originalInfo(info)
 48     , m_objectStore(objectStore)
 49 {
 50     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
 51 
 52     suspendIfNeeded();
 53 }
 54 
 55 IDBIndex::~IDBIndex()
 56 {
 57     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
 58 }
 59 
 60 const char* IDBIndex::activeDOMObjectName() const
 61 {
 62     return &quot;IDBIndex&quot;;
 63 }
 64 
 65 bool IDBIndex::hasPendingActivity() const
 66 {
 67     return m_objectStore.hasPendingActivity();
 68 }
 69 
 70 const String&amp; IDBIndex::name() const
 71 {
 72     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
 73     return m_info.name();
 74 }
 75 
 76 ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
 77 {
 78     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
 79 
 80     if (m_deleted)
 81         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
 82 
 83     if (m_objectStore.isDeleted())
 84         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s object store has been deleted.&quot;_s };
 85 
 86     if (!m_objectStore.transaction().isVersionChange())
 87         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not a version change transaction.&quot;_s };
 88 
 89     if (!m_objectStore.transaction().isActive())
 90         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not active.&quot;_s };
 91 
 92     if (m_info.name() == name)
 93         return { };
 94 
 95     if (m_objectStore.info().hasIndex(name))
 96         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The owning object store already has an index named &#39;&quot;, name, &quot;&#39;.&quot;) };
 97 
 98     m_objectStore.transaction().database().renameIndex(*this, name);
 99     m_info.rename(name);
100 
101     return { };
102 }
103 
104 IDBObjectStore&amp; IDBIndex::objectStore()
105 {
106     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
107     return m_objectStore;
108 }
109 
110 const IDBKeyPath&amp; IDBIndex::keyPath() const
111 {
112     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
113     return m_info.keyPath();
114 }
115 
116 bool IDBIndex::unique() const
117 {
118     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
119     return m_info.unique();
120 }
121 
122 bool IDBIndex::multiEntry() const
123 {
124     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
125     return m_info.multiEntry();
126 }
127 
128 void IDBIndex::rollbackInfoForVersionChangeAbort()
129 {
130     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
131 
132     // Only rollback to the original info if this index still exists in the rolled-back database info.
133     auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
134     if (!objectStoreInfo)
135         return;
136 
137     if (!objectStoreInfo-&gt;hasIndex(m_info.identifier())) {
138         m_deleted = true;
139         return;
140     }
141 
142     m_info = m_originalInfo;
143     m_deleted = false;
144 }
145 
146 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)
147 {
148     LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
149     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
150 
151     if (m_deleted || m_objectStore.isDeleted())
152         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
153 
154     if (!m_objectStore.transaction().isActive())
155         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
156 
157     auto keyRange = function();
158     if (keyRange.hasException())
159         return keyRange.releaseException();
160 
161     IDBKeyRangeData rangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
162     if (rangeData.lowerKey.isNull())
163         rangeData.lowerKey = IDBKeyData::minimum();
164     if (rangeData.upperKey.isNull())
165         rangeData.upperKey = IDBKeyData::maximum();
166 
167     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
168     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
169 }
170 
171 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)
172 {
173     return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
174         return range;
175     });
176 }
177 
178 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)
179 {
180     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
181         auto onlyResult = IDBKeyRange::only(*state, key);
182         if (onlyResult.hasException())
183             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
184 
185         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
186     });
187 }
188 
189 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)
190 {
191     LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
192     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
193 
194     if (m_deleted || m_objectStore.isDeleted())
195         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
196 
197     if (!m_objectStore.transaction().isActive())
198         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
199 
200     auto keyRange = function();
201     if (keyRange.hasException())
202         return keyRange.releaseException();
203 
204     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
205     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
206     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
207 }
208 
209 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)
210 {
211     return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
212         return range;
213     });
214 }
215 
216 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)
217 {
218     return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
219         auto onlyResult = IDBKeyRange::only(*state, key);
220         if (onlyResult.hasException())
221             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
222 
223         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
224     });
225 }
226 
227 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, IDBKeyRange* range)
228 {
229     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
230 
231     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
232 }
233 
234 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, JSValue key)
235 {
236     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
237 
238     auto idbKey = scriptValueToIDBKey(execState, key);
239     auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
240 
241     return doCount(execState, IDBKeyRangeData(idbKeyPointer));
242 }
243 
244 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)
245 {
246     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
247 
248     if (m_deleted || m_objectStore.isDeleted())
249         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
250 
251     auto&amp; transaction = m_objectStore.transaction();
252     if (!transaction.isActive())
253         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
254 
255     if (!range.isValid())
256         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
257 
258     return transaction.requestCount(execState, *this, range);
259 }
260 
261 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, IDBKeyRange* range)
262 {
263     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
264 
265     return doGet(execState, IDBKeyRangeData(range));
266 }
267 
268 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, JSValue key)
269 {
270     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
271 
272     auto idbKey = scriptValueToIDBKey(execState, key);
273     if (!idbKey-&gt;isValid())
274         return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
275 
276     return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
277 }
278 
279 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)
280 {
281     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
282 
283     if (m_deleted || m_objectStore.isDeleted())
284         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
285 
286     auto&amp; transaction = m_objectStore.transaction();
287     if (!transaction.isActive())
288         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
289 
290     if (range.hasException())
291         return range.releaseException();
292     auto keyRange = range.releaseReturnValue();
293 
294     if (keyRange.isNull)
295         return Exception { DataError };
296 
297     return transaction.requestGetValue(execState, *this, keyRange);
298 }
299 
300 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, IDBKeyRange* range)
301 {
302     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
303 
304     return doGetKey(execState, IDBKeyRangeData(range));
305 }
306 
307 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, JSValue key)
308 {
309     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
310 
311     auto idbKey = scriptValueToIDBKey(execState, key);
312     if (!idbKey-&gt;isValid())
313         return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
314 
315     return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
316 }
317 
318 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)
319 {
320     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
321 
322     if (m_deleted || m_objectStore.isDeleted())
323         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
324 
325     auto&amp; transaction = m_objectStore.transaction();
326     if (!transaction.isActive())
327         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
328 
329     if (range.hasException())
330         return range.releaseException();
331     auto keyRange = range.releaseReturnValue();
332 
333     if (keyRange.isNull)
334         return Exception { DataError };
335 
336     return transaction.requestGetKey(execState, *this, keyRange);
337 }
338 
339 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)
340 {
341     LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
342     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
343 
344     if (m_deleted || m_objectStore.isDeleted())
345         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
346 
347     if (!m_objectStore.transaction().isActive())
348         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
349 
350     auto keyRange = function();
351     if (keyRange.hasException())
352         return keyRange.releaseException();
353 
354     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
355     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
356 }
357 
358 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)
359 {
360     return doGetAll(execState, count, [range = WTFMove(range)]() {
361         return range;
362     });
363 }
364 
365 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
366 {
367     return doGetAll(execState, count, [state=&amp;execState, key]() {
368         auto onlyResult = IDBKeyRange::only(*state, key);
369         if (onlyResult.hasException())
370             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
371 
372         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
373     });
374 }
375 
376 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)
377 {
378     LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
379     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
380 
381     if (m_deleted || m_objectStore.isDeleted())
382         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
383 
384     if (!m_objectStore.transaction().isActive())
385         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
386 
387     auto keyRange = function();
388     if (keyRange.hasException())
389         return keyRange.releaseException();
390 
391     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
392     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
393 }
394 
395 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)
396 {
397     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
398         return range;
399     });
400 }
401 
402 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)
403 {
404     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
405         auto onlyResult = IDBKeyRange::only(*state, key);
406         if (onlyResult.hasException())
407             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
408 
409         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
410     });
411 }
412 
413 void IDBIndex::markAsDeleted()
414 {
415     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));
416 
417     ASSERT(!m_deleted);
418     m_deleted = true;
419 }
420 
421 void IDBIndex::ref()
422 {
423     m_objectStore.ref();
424 }
425 
426 void IDBIndex::deref()
427 {
428     m_objectStore.deref();
429 }
430 
431 } // namespace WebCore
432 
433 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
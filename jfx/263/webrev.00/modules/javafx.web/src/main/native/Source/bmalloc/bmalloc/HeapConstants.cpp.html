<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/HeapConstants.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;HeapConstants.h&quot;
 27 #include &lt;algorithm&gt;
 28 
 29 namespace bmalloc {
 30 
 31 DEFINE_STATIC_PER_PROCESS_STORAGE(HeapConstants);
 32 
 33 HeapConstants::HeapConstants(const LockHolder&amp;)
 34     : m_vmPageSizePhysical { vmPageSizePhysical() }
 35 {
 36     RELEASE_BASSERT(m_vmPageSizePhysical &gt;= smallPageSize);
 37     RELEASE_BASSERT(vmPageSize() &gt;= m_vmPageSizePhysical);
 38 
 39     initializeLineMetadata();
 40     initializePageMetadata();
 41 }
 42 
 43 template &lt;class C&gt;
 44 constexpr void fillLineMetadata(C&amp; container, size_t VMPageSize)
 45 {
 46     constexpr size_t clsCount = sizeClass(smallLineSize);
 47     size_t lineCount = smallLineCount(VMPageSize);
 48 
 49     for (size_t cls = 0; cls &lt; clsCount; ++cls) {
 50         size_t size = objectSize(cls);
 51         size_t baseIndex = cls * lineCount;
 52         size_t object = 0;
 53         while (object &lt; VMPageSize) {
 54             size_t line = object / smallLineSize;
 55             size_t leftover = object % smallLineSize;
 56 
 57             auto objectCount = divideRoundingUp(smallLineSize - leftover, size);
 58 
 59             object += objectCount * size;
 60 
 61             // Don&#39;t allow the last object in a page to escape the page.
 62             if (object &gt; VMPageSize) {
 63                 BASSERT(objectCount);
 64                 --objectCount;
 65             }
 66 
 67             container[baseIndex + line] = { static_cast&lt;unsigned char&gt;(leftover), static_cast&lt;unsigned char&gt;(objectCount) };
 68         }
 69     }
 70 }
 71 
 72 template &lt;size_t VMPageSize&gt;
 73 constexpr auto computeLineMetadata()
 74 {
 75     std::array&lt;LineMetadata, sizeClass(smallLineSize) * smallLineCount(VMPageSize)&gt; result;
 76     fillLineMetadata(result, VMPageSize);
 77     return result;
 78 }
 79 
 80 #if BUSE(PRECOMPUTED_CONSTANTS_VMPAGE4K)
 81 constexpr auto kPrecalcuratedLineMetadata4k = computeLineMetadata&lt;4 * kB&gt;();
 82 #endif
 83 
 84 #if BUSE(PRECOMPUTED_CONSTANTS_VMPAGE16K)
 85 constexpr auto kPrecalcuratedLineMetadata16k = computeLineMetadata&lt;16 * kB&gt;();
 86 #endif
 87 
 88 void HeapConstants::initializeLineMetadata()
 89 {
 90 #if BUSE(PRECOMPUTED_CONSTANTS_VMPAGE4K)
 91     if (m_vmPageSizePhysical == 4 * kB) {
 92         m_smallLineMetadata = &amp;kPrecalcuratedLineMetadata4k[0];
 93         return;
 94     }
 95 #endif
 96 
 97 #if BUSE(PRECOMPUTED_CONSTANTS_VMPAGE16K)
 98     if (m_vmPageSizePhysical == 16 * kB) {
 99         m_smallLineMetadata = &amp;kPrecalcuratedLineMetadata16k[0];
100         return;
101     }
102 #endif
103 
104     size_t sizeClassCount = bmalloc::sizeClass(smallLineSize);
105     m_smallLineMetadataStorage.grow(sizeClassCount * smallLineCount());
106     fillLineMetadata(m_smallLineMetadataStorage, m_vmPageSizePhysical);
107     m_smallLineMetadata = &amp;m_smallLineMetadataStorage[0];
108 }
109 
110 void HeapConstants::initializePageMetadata()
111 {
112     auto computePageSize = [&amp;](size_t sizeClass) {
113         size_t size = objectSize(sizeClass);
114         if (sizeClass &lt; bmalloc::sizeClass(smallLineSize))
115             return m_vmPageSizePhysical;
116 
117         for (size_t pageSize = m_vmPageSizePhysical; pageSize &lt; pageSizeMax; pageSize += m_vmPageSizePhysical) {
118             RELEASE_BASSERT(pageSize &lt;= chunkSize / 2);
119             size_t waste = pageSize % size;
120             if (waste &lt;= pageSize / pageSizeWasteFactor)
121                 return pageSize;
122         }
123 
124         return pageSizeMax;
125     };
126 
127     for (size_t i = 0; i &lt; sizeClassCount; ++i)
128         m_pageClasses[i] = (computePageSize(i) - 1) / smallPageSize;
129 }
130 
131 } // namespace bmalloc
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SharedBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SharedStringHash.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 40 #endif
 41 
 42 #if USE(SOUP)
 43 #include &quot;GUniquePtrSoup.h&quot;
 44 #endif
 45 
 46 #if USE(GLIB)
 47 #include &lt;wtf/glib/GRefPtr.h&gt;
 48 typedef struct _GBytes GBytes;
 49 #endif
 50 
 51 #if USE(GSTREAMER)
 52 #include &quot;GStreamerCommon.h&quot;
 53 #endif
 54 
 55 #if USE(FOUNDATION)
 56 OBJC_CLASS NSArray;
 57 OBJC_CLASS NSData;
 58 #endif
 59 






 60 namespace WebCore {
 61 
 62 class SharedBufferDataView;
 63 
 64 class WEBCORE_EXPORT SharedBuffer : public RefCounted&lt;SharedBuffer&gt; {
 65 public:
 66     static Ref&lt;SharedBuffer&gt; create() { return adoptRef(*new SharedBuffer); }
 67     static Ref&lt;SharedBuffer&gt; create(const char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 68     static Ref&lt;SharedBuffer&gt; create(const unsigned char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 69     static RefPtr&lt;SharedBuffer&gt; createWithContentsOfFile(const String&amp; filePath);
 70 
 71     static Ref&lt;SharedBuffer&gt; create(Vector&lt;char&gt;&amp;&amp;);
 72     static Ref&lt;SharedBuffer&gt; create(Vector&lt;uint8_t&gt;&amp;&amp;);
 73 
 74 #if USE(FOUNDATION)
 75     RetainPtr&lt;NSData&gt; createNSData() const;
 76     RetainPtr&lt;NSArray&gt; createNSDataArray() const;
 77     static Ref&lt;SharedBuffer&gt; create(NSData *);
 78     void append(NSData *);
 79 #endif
</pre>
<hr />
<pre>
106 
107     size_t size() const { return m_size; }
108 
109     bool isEmpty() const { return !size(); }
110 
111     void append(const SharedBuffer&amp;);
112     void append(const char*, size_t);
113     void append(Vector&lt;char&gt;&amp;&amp;);
114 
115     void clear();
116 
117     Ref&lt;SharedBuffer&gt; copy() const;
118 
119     // Data wrapped by a DataSegment should be immutable because it can be referenced by other objects.
120     // To modify or combine the data, allocate a new DataSegment.
121     class DataSegment : public ThreadSafeRefCounted&lt;DataSegment&gt; {
122     public:
123         WEBCORE_EXPORT const char* data() const;
124         WEBCORE_EXPORT size_t size() const;
125 
<span class="line-modified">126         static Ref&lt;DataSegment&gt; create(Vector&lt;char&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }</span>





127 #if USE(CF)
128         static Ref&lt;DataSegment&gt; create(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
129 #endif
130 #if USE(SOUP)
131         static Ref&lt;DataSegment&gt; create(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
132 #endif
133 #if USE(GLIB)
134         static Ref&lt;DataSegment&gt; create(GRefPtr&lt;GBytes&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
135 #endif
136 #if USE(GSTREAMER)
137         static Ref&lt;DataSegment&gt; create(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
138 #endif
139         static Ref&lt;DataSegment&gt; create(FileSystem::MappedFileData&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
140 




141     private:
142         DataSegment(Vector&lt;char&gt;&amp;&amp; data)
143             : m_immutableData(WTFMove(data)) { }
144 #if USE(CF)
145         DataSegment(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data)
146             : m_immutableData(WTFMove(data)) { }
147 #endif
148 #if USE(SOUP)
149         DataSegment(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data)
150             : m_immutableData(WTFMove(data)) { }
151 #endif
152 #if USE(GLIB)
153         DataSegment(GRefPtr&lt;GBytes&gt;&amp;&amp; data)
154             : m_immutableData(WTFMove(data)) { }
155 #endif
156 #if USE(GSTREAMER)
157         DataSegment(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data)
158             : m_immutableData(WTFMove(data)) { }
159 #endif
160         DataSegment(FileSystem::MappedFileData&amp;&amp; data)
</pre>
<hr />
<pre>
171             GRefPtr&lt;GBytes&gt;,
172 #endif
173 #if USE(GSTREAMER)
174             RefPtr&lt;GstMappedBuffer&gt;,
175 #endif
176             FileSystem::MappedFileData&gt; m_immutableData;
177         friend class SharedBuffer;
178     };
179 
180     struct DataSegmentVectorEntry {
181         size_t beginPosition;
182         Ref&lt;DataSegment&gt; segment;
183     };
184     using DataSegmentVector = Vector&lt;DataSegmentVectorEntry, 1&gt;;
185     DataSegmentVector::const_iterator begin() const { return m_segments.begin(); }
186     DataSegmentVector::const_iterator end() const { return m_segments.end(); }
187 
188     // begin and end take O(1) time, this takes O(log(N)) time.
189     SharedBufferDataView getSomeData(size_t position) const;
190 


191     void hintMemoryNotNeededSoon() const;
192 


193     bool operator==(const SharedBuffer&amp;) const;
194     bool operator!=(const SharedBuffer&amp; other) const { return !operator==(other); }
195 
196 private:
197     explicit SharedBuffer() = default;
198     explicit SharedBuffer(const char*, size_t);
199     explicit SharedBuffer(const unsigned char*, size_t);
200     explicit SharedBuffer(Vector&lt;char&gt;&amp;&amp;);
201     explicit SharedBuffer(FileSystem::MappedFileData&amp;&amp;);
202 #if USE(CF)
203     explicit SharedBuffer(CFDataRef);
204 #endif
205 #if USE(SOUP)
206     explicit SharedBuffer(SoupBuffer*);
207 #endif
208 #if USE(GLIB)
209     explicit SharedBuffer(GBytes*);
210 #endif
211 #if USE(GSTREAMER)
212     explicit SharedBuffer(GstMappedBuffer&amp;);
213 #endif
214 
215     void combineIntoOneSegment() const;
216 
217     static RefPtr&lt;SharedBuffer&gt; createFromReadingFile(const String&amp; filePath);
218 
219     size_t m_size { 0 };
220     mutable DataSegmentVector m_segments;
221 
<span class="line-modified">222 #if !ASSERT_DISABLED</span>
223     mutable bool m_hasBeenCombinedIntoOneSegment { false };
224     bool internallyConsistent() const;
225 #endif
226 };
227 
228 inline bool operator==(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
229 {
230     return left.get() == right;
231 }
232 
233 inline bool operator!=(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
234 {
235     return left.get() != right;
236 }
237 
238 class WEBCORE_EXPORT SharedBufferDataView {
239 public:
240     SharedBufferDataView(Ref&lt;SharedBuffer::DataSegment&gt;&amp;&amp;, size_t);
241     size_t size() const;
242     const char* data() const;



243 private:
244     size_t m_positionWithinSegment;
245     Ref&lt;SharedBuffer::DataSegment&gt; m_segment;
246 };
247 
248 RefPtr&lt;SharedBuffer&gt; utf8Buffer(const String&amp;);
249 
250 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 40 #endif
 41 
 42 #if USE(SOUP)
 43 #include &quot;GUniquePtrSoup.h&quot;
 44 #endif
 45 
 46 #if USE(GLIB)
 47 #include &lt;wtf/glib/GRefPtr.h&gt;
 48 typedef struct _GBytes GBytes;
 49 #endif
 50 
 51 #if USE(GSTREAMER)
 52 #include &quot;GStreamerCommon.h&quot;
 53 #endif
 54 
 55 #if USE(FOUNDATION)
 56 OBJC_CLASS NSArray;
 57 OBJC_CLASS NSData;
 58 #endif
 59 
<span class="line-added"> 60 namespace WTF {</span>
<span class="line-added"> 61 namespace Persistence {</span>
<span class="line-added"> 62 class Decoder;</span>
<span class="line-added"> 63 }</span>
<span class="line-added"> 64 }</span>
<span class="line-added"> 65 </span>
 66 namespace WebCore {
 67 
 68 class SharedBufferDataView;
 69 
 70 class WEBCORE_EXPORT SharedBuffer : public RefCounted&lt;SharedBuffer&gt; {
 71 public:
 72     static Ref&lt;SharedBuffer&gt; create() { return adoptRef(*new SharedBuffer); }
 73     static Ref&lt;SharedBuffer&gt; create(const char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 74     static Ref&lt;SharedBuffer&gt; create(const unsigned char* data, size_t size) { return adoptRef(*new SharedBuffer(data, size)); }
 75     static RefPtr&lt;SharedBuffer&gt; createWithContentsOfFile(const String&amp; filePath);
 76 
 77     static Ref&lt;SharedBuffer&gt; create(Vector&lt;char&gt;&amp;&amp;);
 78     static Ref&lt;SharedBuffer&gt; create(Vector&lt;uint8_t&gt;&amp;&amp;);
 79 
 80 #if USE(FOUNDATION)
 81     RetainPtr&lt;NSData&gt; createNSData() const;
 82     RetainPtr&lt;NSArray&gt; createNSDataArray() const;
 83     static Ref&lt;SharedBuffer&gt; create(NSData *);
 84     void append(NSData *);
 85 #endif
</pre>
<hr />
<pre>
112 
113     size_t size() const { return m_size; }
114 
115     bool isEmpty() const { return !size(); }
116 
117     void append(const SharedBuffer&amp;);
118     void append(const char*, size_t);
119     void append(Vector&lt;char&gt;&amp;&amp;);
120 
121     void clear();
122 
123     Ref&lt;SharedBuffer&gt; copy() const;
124 
125     // Data wrapped by a DataSegment should be immutable because it can be referenced by other objects.
126     // To modify or combine the data, allocate a new DataSegment.
127     class DataSegment : public ThreadSafeRefCounted&lt;DataSegment&gt; {
128     public:
129         WEBCORE_EXPORT const char* data() const;
130         WEBCORE_EXPORT size_t size() const;
131 
<span class="line-modified">132         static Ref&lt;DataSegment&gt; create(Vector&lt;char&gt;&amp;&amp; data)</span>
<span class="line-added">133         {</span>
<span class="line-added">134             data.shrinkToFit();</span>
<span class="line-added">135             return adoptRef(*new DataSegment(WTFMove(data)));</span>
<span class="line-added">136         }</span>
<span class="line-added">137 </span>
138 #if USE(CF)
139         static Ref&lt;DataSegment&gt; create(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
140 #endif
141 #if USE(SOUP)
142         static Ref&lt;DataSegment&gt; create(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
143 #endif
144 #if USE(GLIB)
145         static Ref&lt;DataSegment&gt; create(GRefPtr&lt;GBytes&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
146 #endif
147 #if USE(GSTREAMER)
148         static Ref&lt;DataSegment&gt; create(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
149 #endif
150         static Ref&lt;DataSegment&gt; create(FileSystem::MappedFileData&amp;&amp; data) { return adoptRef(*new DataSegment(WTFMove(data))); }
151 
<span class="line-added">152 #if USE(FOUNDATION)</span>
<span class="line-added">153         RetainPtr&lt;NSData&gt; createNSData() const;</span>
<span class="line-added">154 #endif</span>
<span class="line-added">155 </span>
156     private:
157         DataSegment(Vector&lt;char&gt;&amp;&amp; data)
158             : m_immutableData(WTFMove(data)) { }
159 #if USE(CF)
160         DataSegment(RetainPtr&lt;CFDataRef&gt;&amp;&amp; data)
161             : m_immutableData(WTFMove(data)) { }
162 #endif
163 #if USE(SOUP)
164         DataSegment(GUniquePtr&lt;SoupBuffer&gt;&amp;&amp; data)
165             : m_immutableData(WTFMove(data)) { }
166 #endif
167 #if USE(GLIB)
168         DataSegment(GRefPtr&lt;GBytes&gt;&amp;&amp; data)
169             : m_immutableData(WTFMove(data)) { }
170 #endif
171 #if USE(GSTREAMER)
172         DataSegment(RefPtr&lt;GstMappedBuffer&gt;&amp;&amp; data)
173             : m_immutableData(WTFMove(data)) { }
174 #endif
175         DataSegment(FileSystem::MappedFileData&amp;&amp; data)
</pre>
<hr />
<pre>
186             GRefPtr&lt;GBytes&gt;,
187 #endif
188 #if USE(GSTREAMER)
189             RefPtr&lt;GstMappedBuffer&gt;,
190 #endif
191             FileSystem::MappedFileData&gt; m_immutableData;
192         friend class SharedBuffer;
193     };
194 
195     struct DataSegmentVectorEntry {
196         size_t beginPosition;
197         Ref&lt;DataSegment&gt; segment;
198     };
199     using DataSegmentVector = Vector&lt;DataSegmentVectorEntry, 1&gt;;
200     DataSegmentVector::const_iterator begin() const { return m_segments.begin(); }
201     DataSegmentVector::const_iterator end() const { return m_segments.end(); }
202 
203     // begin and end take O(1) time, this takes O(log(N)) time.
204     SharedBufferDataView getSomeData(size_t position) const;
205 
<span class="line-added">206     String toHexString() const;</span>
<span class="line-added">207 </span>
208     void hintMemoryNotNeededSoon() const;
209 
<span class="line-added">210     WTF::Persistence::Decoder decoder() const;</span>
<span class="line-added">211 </span>
212     bool operator==(const SharedBuffer&amp;) const;
213     bool operator!=(const SharedBuffer&amp; other) const { return !operator==(other); }
214 
215 private:
216     explicit SharedBuffer() = default;
217     explicit SharedBuffer(const char*, size_t);
218     explicit SharedBuffer(const unsigned char*, size_t);
219     explicit SharedBuffer(Vector&lt;char&gt;&amp;&amp;);
220     explicit SharedBuffer(FileSystem::MappedFileData&amp;&amp;);
221 #if USE(CF)
222     explicit SharedBuffer(CFDataRef);
223 #endif
224 #if USE(SOUP)
225     explicit SharedBuffer(SoupBuffer*);
226 #endif
227 #if USE(GLIB)
228     explicit SharedBuffer(GBytes*);
229 #endif
230 #if USE(GSTREAMER)
231     explicit SharedBuffer(GstMappedBuffer&amp;);
232 #endif
233 
234     void combineIntoOneSegment() const;
235 
236     static RefPtr&lt;SharedBuffer&gt; createFromReadingFile(const String&amp; filePath);
237 
238     size_t m_size { 0 };
239     mutable DataSegmentVector m_segments;
240 
<span class="line-modified">241 #if ASSERT_ENABLED</span>
242     mutable bool m_hasBeenCombinedIntoOneSegment { false };
243     bool internallyConsistent() const;
244 #endif
245 };
246 
247 inline bool operator==(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
248 {
249     return left.get() == right;
250 }
251 
252 inline bool operator!=(const Ref&lt;SharedBuffer&gt;&amp; left, const SharedBuffer&amp; right)
253 {
254     return left.get() != right;
255 }
256 
257 class WEBCORE_EXPORT SharedBufferDataView {
258 public:
259     SharedBufferDataView(Ref&lt;SharedBuffer::DataSegment&gt;&amp;&amp;, size_t);
260     size_t size() const;
261     const char* data() const;
<span class="line-added">262 #if USE(FOUNDATION)</span>
<span class="line-added">263     RetainPtr&lt;NSData&gt; createNSData() const;</span>
<span class="line-added">264 #endif</span>
265 private:
266     size_t m_positionWithinSegment;
267     Ref&lt;SharedBuffer::DataSegment&gt; m_segment;
268 };
269 
270 RefPtr&lt;SharedBuffer&gt; utf8Buffer(const String&amp;);
271 
272 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="SharedBuffer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SharedStringHash.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
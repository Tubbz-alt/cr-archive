<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/ExtensionsGLOpenGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ExtensionsGLOpenGL.h&quot;
 28 
 29 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; (USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)))
 30 
 31 #include &quot;GraphicsContextGLOpenGL.h&quot;
 32 
 33 #if PLATFORM(GTK) || PLATFORM(WIN)
 34 #include &quot;OpenGLShims.h&quot;
 35 #elif USE(OPENGL_ES)
 36 #include &lt;OpenGLES/ES2/glext.h&gt;
 37 #elif USE(OPENGL)
 38 #include &lt;OpenGL/gl.h&gt;
 39 #endif
 40 
 41 #if PLATFORM(IOS_FAMILY)
 42 #include &quot;GraphicsContextGLOpenGLESIOS.h&quot;
 43 #endif
 44 
 45 namespace WebCore {
 46 
 47 ExtensionsGLOpenGL::ExtensionsGLOpenGL(GraphicsContextGLOpenGL* context, bool useIndexedGetString)
 48     : ExtensionsGLOpenGLCommon(context, useIndexedGetString)
 49 {
 50 }
 51 
 52 ExtensionsGLOpenGL::~ExtensionsGLOpenGL() = default;
 53 
 54 
 55 void ExtensionsGLOpenGL::blitFramebuffer(long srcX0, long srcY0, long srcX1, long srcY1, long dstX0, long dstY0, long dstX1, long dstY1, unsigned long mask, unsigned long filter)
 56 {
 57 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 58     UNUSED_PARAM(srcX0);
 59     UNUSED_PARAM(srcY0);
 60     UNUSED_PARAM(srcX1);
 61     UNUSED_PARAM(srcY1);
 62     UNUSED_PARAM(dstX0);
 63     UNUSED_PARAM(dstY0);
 64     UNUSED_PARAM(dstX1);
 65     UNUSED_PARAM(dstY1);
 66     UNUSED_PARAM(mask);
 67     UNUSED_PARAM(filter);
 68     ::glResolveMultisampleFramebufferAPPLE();
 69 #else
 70     ::glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
 71 #endif
 72 }
 73 
 74 void ExtensionsGLOpenGL::renderbufferStorageMultisample(unsigned long target, unsigned long samples, unsigned long internalformat, unsigned long width, unsigned long height)
 75 {
 76     ::glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
 77 }
 78 
 79 PlatformGLObject ExtensionsGLOpenGL::createVertexArrayOES()
 80 {
 81     m_context-&gt;makeContextCurrent();
 82     GLuint array = 0;
 83 #if PLATFORM(GTK) || PLATFORM(WIN) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
 84     if (isVertexArrayObjectSupported())
 85         glGenVertexArrays(1, &amp;array);
 86 #elif defined(GL_APPLE_vertex_array_object) &amp;&amp; GL_APPLE_vertex_array_object
 87     glGenVertexArraysAPPLE(1, &amp;array);
 88 #endif
 89     return array;
 90 }
 91 
 92 void ExtensionsGLOpenGL::deleteVertexArrayOES(PlatformGLObject array)
 93 {
 94     if (!array)
 95         return;
 96 
 97     m_context-&gt;makeContextCurrent();
 98 #if PLATFORM(GTK) || PLATFORM(WIN) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
 99     if (isVertexArrayObjectSupported())
100         glDeleteVertexArrays(1, &amp;array);
101 #elif defined(GL_APPLE_vertex_array_object) &amp;&amp; GL_APPLE_vertex_array_object
102     glDeleteVertexArraysAPPLE(1, &amp;array);
103 #endif
104 }
105 
106 GCGLboolean ExtensionsGLOpenGL::isVertexArrayOES(PlatformGLObject array)
107 {
108     if (!array)
109         return GL_FALSE;
110 
111     m_context-&gt;makeContextCurrent();
112 #if PLATFORM(GTK) || PLATFORM(WIN) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
113     if (isVertexArrayObjectSupported())
114         return glIsVertexArray(array);
115 #elif defined(GL_APPLE_vertex_array_object) &amp;&amp; GL_APPLE_vertex_array_object
116     return glIsVertexArrayAPPLE(array);
117 #endif
118     return GL_FALSE;
119 }
120 
121 void ExtensionsGLOpenGL::bindVertexArrayOES(PlatformGLObject array)
122 {
123     m_context-&gt;makeContextCurrent();
124 #if PLATFORM(GTK) || PLATFORM(WIN) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
125     if (isVertexArrayObjectSupported())
126         glBindVertexArray(array);
127 #elif defined(GL_APPLE_vertex_array_object) &amp;&amp; GL_APPLE_vertex_array_object
128     glBindVertexArrayAPPLE(array);
129 #else
130     UNUSED_PARAM(array);
131 #endif
132 }
133 
134 void ExtensionsGLOpenGL::insertEventMarkerEXT(const String&amp;)
135 {
136     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
137     return;
138 }
139 
140 void ExtensionsGLOpenGL::pushGroupMarkerEXT(const String&amp;)
141 {
142     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
143     return;
144 }
145 
146 void ExtensionsGLOpenGL::popGroupMarkerEXT(void)
147 {
148     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
149     return;
150 }
151 
152 bool ExtensionsGLOpenGL::supportsExtension(const String&amp; name)
153 {
154     // GL_ANGLE_framebuffer_blit and GL_ANGLE_framebuffer_multisample are &quot;fake&quot;. They are implemented using other
155     // extensions. In particular GL_EXT_framebuffer_blit and GL_EXT_framebuffer_multisample/GL_APPLE_framebuffer_multisample.
156     if (name == &quot;GL_ANGLE_framebuffer_blit&quot;)
157         return m_availableExtensions.contains(&quot;GL_EXT_framebuffer_blit&quot;);
158     if (name == &quot;GL_ANGLE_framebuffer_multisample&quot;)
159 #if PLATFORM(IOS_FAMILY)
160         return m_availableExtensions.contains(&quot;GL_APPLE_framebuffer_multisample&quot;);
161 #else
162         return m_availableExtensions.contains(&quot;GL_EXT_framebuffer_multisample&quot;);
163 #endif
164 
165     if (name == &quot;GL_ANGLE_instanced_arrays&quot;) {
166         return (m_availableExtensions.contains(&quot;GL_ARB_instanced_arrays&quot;) || m_availableExtensions.contains(&quot;GL_EXT_instanced_arrays&quot;))
167             &amp;&amp; (m_availableExtensions.contains(&quot;GL_ARB_draw_instanced&quot;) || m_availableExtensions.contains(&quot;GL_EXT_draw_instanced&quot;));
168     }
169 
170     if (name == &quot;GL_EXT_sRGB&quot;)
171 #if PLATFORM(IOS_FAMILY)
172         return m_availableExtensions.contains(&quot;GL_EXT_sRGB&quot;);
173 #else
174         return m_availableExtensions.contains(&quot;GL_EXT_texture_sRGB&quot;) &amp;&amp; (m_availableExtensions.contains(&quot;GL_EXT_framebuffer_sRGB&quot;) || m_availableExtensions.contains(&quot;GL_ARB_framebuffer_sRGB&quot;));
175 #endif
176 
177     if (name == &quot;GL_EXT_frag_depth&quot;)
178 #if PLATFORM(MAC)
179         return true;
180 #else
181         return m_availableExtensions.contains(&quot;GL_EXT_frag_depth&quot;);
182 #endif
183 
184     // Desktop GL always supports GL_OES_rgb8_rgba8.
185     if (name == &quot;GL_OES_rgb8_rgba8&quot;)
186         return true;
187 
188     // If GL_ARB_texture_float or GL_OES_texture_float is available then we report
189     // GL_OES_texture_half_float, GL_OES_texture_float_linear and GL_OES_texture_half_float_linear as available.
190     if (name == &quot;GL_OES_texture_float&quot; || name == &quot;GL_OES_texture_half_float&quot; || name == &quot;GL_OES_texture_float_linear&quot; || name == &quot;GL_OES_texture_half_float_linear&quot;)
191         return m_availableExtensions.contains(&quot;GL_ARB_texture_float&quot;) || m_availableExtensions.contains(&quot;GL_OES_texture_float&quot;);
192 
193     // GL_OES_vertex_array_object
194     if (name == &quot;GL_OES_vertex_array_object&quot;) {
195 #if (PLATFORM(GTK))
196         return m_availableExtensions.contains(&quot;GL_ARB_vertex_array_object&quot;);
197 #elif PLATFORM(IOS_FAMILY)
198         return m_availableExtensions.contains(&quot;GL_OES_vertex_array_object&quot;);
199 #else
200         return m_availableExtensions.contains(&quot;GL_APPLE_vertex_array_object&quot;);
201 #endif
202     }
203 
204     // Desktop GL always supports the standard derivative functions
205     if (name == &quot;GL_OES_standard_derivatives&quot;)
206         return true;
207 
208     // Desktop GL always supports UNSIGNED_INT indices
209     if (name == &quot;GL_OES_element_index_uint&quot;)
210         return true;
211 
212     if (name == &quot;GL_EXT_shader_texture_lod&quot;)
213         return m_availableExtensions.contains(&quot;GL_EXT_shader_texture_lod&quot;);
214 
215     if (name == &quot;GL_EXT_texture_filter_anisotropic&quot;)
216         return m_availableExtensions.contains(&quot;GL_EXT_texture_filter_anisotropic&quot;);
217 
218     if (name == &quot;GL_EXT_draw_buffers&quot;) {
219 #if PLATFORM(IOS_FAMILY)
220         return m_availableExtensions.contains(name);
221 #elif PLATFORM(MAC) || PLATFORM(GTK)
222         return m_availableExtensions.contains(&quot;GL_ARB_draw_buffers&quot;);
223 #else
224         // FIXME: implement support for other platforms.
225         return false;
226 #endif
227     }
228 
229 #if PLATFORM(IOS_FAMILY) || PLATFORM(IOS_FAMILY_SIMULATOR)
230     if (name == &quot;GL_EXT_packed_depth_stencil&quot;)
231         return m_availableExtensions.contains(&quot;GL_OES_packed_depth_stencil&quot;);
232 
233     if (name == &quot;GL_OES_compressed_ETC1_RGB8_texture&quot;
234         || name == &quot;GL_ANGLE_compressed_texture_etc&quot;) {
235         // Implicitly enabled with ES 3.0 contexts.
236         return m_context-&gt;m_isForWebGL2;
237     }
238 #endif
239 
240     return m_availableExtensions.contains(name);
241 }
242 
243 void ExtensionsGLOpenGL::drawBuffersEXT(GCGLsizei n, const GCGLenum* bufs)
244 {
245     //  FIXME: implement support for other platforms.
246 #if PLATFORM(MAC)
247     ::glDrawBuffersARB(n, bufs);
248 #elif PLATFORM(GTK)
249     ::glDrawBuffers(n, bufs);
250 #else
251     UNUSED_PARAM(n);
252     UNUSED_PARAM(bufs);
253 #endif
254 }
255 
256 void ExtensionsGLOpenGL::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
257 {
258     m_context-&gt;makeContextCurrent();
259 #if PLATFORM(GTK)
260     ::glDrawArraysInstanced(mode, first, count, primcount);
261 #elif PLATFORM(COCOA)
262     ::glDrawArraysInstancedARB(mode, first, count, primcount);
263 #else
264     UNUSED_PARAM(mode);
265     UNUSED_PARAM(first);
266     UNUSED_PARAM(count);
267     UNUSED_PARAM(primcount);
268 #endif
269 }
270 
271 void ExtensionsGLOpenGL::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)
272 {
273     m_context-&gt;makeContextCurrent();
274 #if PLATFORM(GTK)
275     ::glDrawElementsInstanced(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)), primcount);
276 #elif PLATFORM(COCOA)
277     ::glDrawElementsInstancedARB(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)), primcount);
278 #else
279     UNUSED_PARAM(mode);
280     UNUSED_PARAM(count);
281     UNUSED_PARAM(type);
282     UNUSED_PARAM(offset);
283     UNUSED_PARAM(primcount);
284 #endif
285 }
286 
287 void ExtensionsGLOpenGL::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
288 {
289     m_context-&gt;makeContextCurrent();
290 #if PLATFORM(GTK)
291     ::glVertexAttribDivisor(index, divisor);
292 #elif PLATFORM(COCOA)
293     ::glVertexAttribDivisorARB(index, divisor);
294 #else
295     UNUSED_PARAM(index);
296     UNUSED_PARAM(divisor);
297 #endif
298 }
299 
300 String ExtensionsGLOpenGL::getExtensions()
301 {
302     ASSERT(!m_useIndexedGetString);
303     return String(reinterpret_cast&lt;const char*&gt;(::glGetString(GL_EXTENSIONS)));
304 }
305 
306 #if PLATFORM(GTK) || PLATFORM(WIN) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES))
307 bool ExtensionsGLOpenGL::isVertexArrayObjectSupported()
308 {
309     static const bool supportsVertexArrayObject = supports(&quot;GL_OES_vertex_array_object&quot;);
310     return supportsVertexArrayObject;
311 }
312 #endif
313 
314 } // namespace WebCore
315 
316 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; (USE(OPENGL) || (PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)))
    </pre>
  </body>
</html>
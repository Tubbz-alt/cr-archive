<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  3  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BytecodeDumper.h&quot;
 29 
 30 #include &quot;ArithProfile.h&quot;
 31 #include &quot;B3Type.h&quot;
 32 #include &quot;BytecodeGenerator.h&quot;
 33 #include &quot;BytecodeStructs.h&quot;
 34 #include &quot;CallLinkStatus.h&quot;
 35 #include &quot;CodeBlock.h&quot;
 36 #include &quot;Error.h&quot;
 37 #include &quot;HeapInlines.h&quot;
 38 #include &quot;InterpreterInlines.h&quot;
 39 #include &quot;PolymorphicAccess.h&quot;
 40 #include &quot;PutByIdFlags.h&quot;
 41 #include &quot;StructureInlines.h&quot;
 42 #include &quot;ToThisStatus.h&quot;
 43 #include &quot;UnlinkedCodeBlockGenerator.h&quot;
 44 #include &quot;UnlinkedMetadataTableInlines.h&quot;
 45 #include &quot;WasmFunctionCodeBlock.h&quot;
 46 #include &quot;WasmGeneratorTraits.h&quot;
 47 #include &quot;WasmModuleInformation.h&quot;
 48 #include &quot;WasmOps.h&quot;
 49 #include &quot;WasmSignatureInlines.h&quot;
 50 
 51 namespace JSC {
 52 
 53 static ALWAYS_INLINE bool isConstantRegisterIndex(int index)
 54 {
 55     return index &gt;= FirstConstantRegisterIndex;
 56 }
 57 
 58 void BytecodeDumperBase::printLocationAndOp(InstructionStream::Offset location, const char* op)
 59 {
 60     m_currentLocation = location;
 61     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);
 62 }
 63 
 64 void BytecodeDumperBase::dumpValue(VirtualRegister reg)
 65 {
 66     m_out.printf(&quot;%s&quot;, registerName(reg).data());
 67 }
 68 
 69 template&lt;typename Traits&gt;
 70 void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Traits&gt; label)
 71 {
 72     int target = label.target();
 73     if (!target)
 74         target = outOfLineJumpOffset(m_currentLocation);
 75     InstructionStream::Offset targetOffset = target + m_currentLocation;
 76     m_out.print(target, &quot;(-&gt;&quot;, targetOffset, &quot;)&quot;);
 77 }
 78 
 79 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;JSGeneratorTraits&gt;);
 80 
 81 #if ENABLE(WEBASSEMBLY)
 82 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Wasm::GeneratorTraits&gt;);
 83 #endif // ENABLE(WEBASSEMBLY)
 84 
 85 template&lt;class Block&gt;
 86 CString BytecodeDumper&lt;Block&gt;::registerName(VirtualRegister r) const
 87 {
 88     if (r.isConstant())
 89         return constantName(r);
 90 
 91     return toCString(r);
 92 }
 93 
 94 template &lt;class Block&gt;
 95 int BytecodeDumper&lt;Block&gt;::outOfLineJumpOffset(InstructionStream::Offset offset) const
 96 {
 97     return m_block-&gt;outOfLineJumpOffset(offset);
 98 }
 99 
100 template&lt;class Block&gt;
101 CString BytecodeDumper&lt;Block&gt;::constantName(VirtualRegister reg) const
102 {
103     auto value = block()-&gt;getConstant(reg);
104     return toCString(value, &quot;(&quot;, reg, &quot;)&quot;);
105 }
106 
107 template&lt;class Block&gt;
108 void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
109 {
110     ::JSC::dumpBytecode(this, it.offset(), it.ptr());
111     this-&gt;m_out.print(&quot;\n&quot;);
112 }
113 
114 template&lt;class Block&gt;
115 void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
116 {
117     BytecodeDumper dumper(block, out);
118     dumper.dumpBytecode(it, statusMap);
119 }
120 
121 template&lt;class Block&gt;
122 VM&amp; CodeBlockBytecodeDumper&lt;Block&gt;::vm() const
123 {
124     return this-&gt;block()-&gt;vm();
125 }
126 
127 template&lt;class Block&gt;
128 const Identifier&amp; CodeBlockBytecodeDumper&lt;Block&gt;::identifier(int index) const
129 {
130     return this-&gt;block()-&gt;identifier(index);
131 }
132 
133 template&lt;class Block&gt;
134 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpIdentifiers()
135 {
136     if (size_t count = this-&gt;block()-&gt;numberOfIdentifiers()) {
137         this-&gt;m_out.printf(&quot;\nIdentifiers:\n&quot;);
138         size_t i = 0;
139         do {
140             this-&gt;m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);
141             ++i;
142         } while (i != count);
143     }
144 }
145 
146 template&lt;class Block&gt;
147 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpConstants()
148 {
149     if (!this-&gt;block()-&gt;constantRegisters().isEmpty()) {
150         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);
151         size_t i = 0;
152         for (const auto&amp; constant : this-&gt;block()-&gt;constantRegisters()) {
153             const char* sourceCodeRepresentationDescription = nullptr;
154             switch (this-&gt;block()-&gt;constantsSourceCodeRepresentation()[i]) {
155             case SourceCodeRepresentation::Double:
156                 sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
157                 break;
158             case SourceCodeRepresentation::Integer:
159                 sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
160                 break;
161             case SourceCodeRepresentation::Other:
162                 sourceCodeRepresentationDescription = &quot;&quot;;
163                 break;
164             case SourceCodeRepresentation::LinkTimeConstant:
165                 sourceCodeRepresentationDescription = &quot;: in source as linke-time-constant&quot;;
166                 break;
167             }
168             this-&gt;m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);
169             ++i;
170         }
171     }
172 }
173 
174 template&lt;class Block&gt;
175 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()
176 {
177     if (unsigned count = this-&gt;block()-&gt;numberOfExceptionHandlers()) {
178         this-&gt;m_out.printf(&quot;\nException Handlers:\n&quot;);
179         unsigned i = 0;
180         do {
181             const auto&amp; handler = this-&gt;block()-&gt;exceptionHandler(i);
182             this-&gt;m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());
183             ++i;
184         } while (i &lt; count);
185     }
186 }
187 
188 template&lt;class Block&gt;
189 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()
190 {
191     if (unsigned count = this-&gt;block()-&gt;numberOfSwitchJumpTables()) {
192         this-&gt;m_out.printf(&quot;Switch Jump Tables:\n&quot;);
193         unsigned i = 0;
194         do {
195             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);
196             const auto&amp; switchJumpTable = this-&gt;block()-&gt;switchJumpTable(i);
197             int entry = 0;
198             auto end = switchJumpTable.branchOffsets.end();
199             for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
200                 if (!*iter)
201                     continue;
202                 this-&gt;m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);
203             }
204             this-&gt;m_out.printf(&quot;      }\n&quot;);
205             ++i;
206         } while (i &lt; count);
207     }
208 }
209 
210 template&lt;class Block&gt;
211 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()
212 {
213     if (unsigned count = this-&gt;block()-&gt;numberOfStringSwitchJumpTables()) {
214         this-&gt;m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);
215         unsigned i = 0;
216         do {
217             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);
218             const auto&amp; stringSwitchJumpTable = this-&gt;block()-&gt;stringSwitchJumpTable(i);
219             auto end = stringSwitchJumpTable.offsetTable.end();
220             for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
221                 this-&gt;m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);
222             this-&gt;m_out.printf(&quot;      }\n&quot;);
223             ++i;
224         } while (i &lt; count);
225     }
226 }
227 
228 template&lt;class Block&gt;
229 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)
230 {
231     size_t instructionCount = 0;
232     size_t wide16InstructionCount = 0;
233     size_t wide32InstructionCount = 0;
234     size_t instructionWithMetadataCount = 0;
235 
236     for (const auto&amp; instruction : instructions) {
237         if (instruction-&gt;isWide16())
238             ++wide16InstructionCount;
239         else if (instruction-&gt;isWide32())
240             ++wide32InstructionCount;
241         if (instruction-&gt;hasMetadata())
242             ++instructionWithMetadataCount;
243         ++instructionCount;
244     }
245 
246     out.print(*block);
247     out.printf(
248         &quot;: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions, %lu instructions with metadata); %lu bytes (%lu metadata bytes); %d parameter(s); %d callee register(s); %d variable(s)&quot;,
249         static_cast&lt;unsigned long&gt;(instructionCount),
250         static_cast&lt;unsigned long&gt;(wide16InstructionCount),
251         static_cast&lt;unsigned long&gt;(wide32InstructionCount),
252         static_cast&lt;unsigned long&gt;(instructionWithMetadataCount),
253         static_cast&lt;unsigned long&gt;(instructions.sizeInBytes() + block-&gt;metadataSizeInBytes()),
254         static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
255         block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
256     out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
257     out.printf(&quot;\n&quot;);
258 
259     CodeBlockBytecodeDumper&lt;Block&gt; dumper(block, out);
260     for (const auto&amp; it : instructions)
261         dumper.dumpBytecode(it, statusMap);
262 
263     dumper.dumpIdentifiers();
264     dumper.dumpConstants();
265     dumper.dumpExceptionHandlers();
266     dumper.dumpSwitchJumpTables();
267     dumper.dumpStringSwitchJumpTables();
268 
269     out.printf(&quot;\n&quot;);
270 }
271 
272 template class BytecodeDumper&lt;CodeBlock&gt;;
273 template class CodeBlockBytecodeDumper&lt;UnlinkedCodeBlockGenerator&gt;;
274 template class CodeBlockBytecodeDumper&lt;CodeBlock&gt;;
275 
276 #if ENABLE(WEBASSEMBLY)
277 
278 namespace Wasm {
279 
280 void BytecodeDumper::dumpBlock(FunctionCodeBlock* block, const ModuleInformation&amp; moduleInformation, PrintStream&amp; out)
281 {
282     size_t instructionCount = 0;
283     size_t wide16InstructionCount = 0;
284     size_t wide32InstructionCount = 0;
285 
286     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {
287         if (it-&gt;isWide16())
288             ++wide16InstructionCount;
289         else if (it-&gt;isWide32())
290             ++wide32InstructionCount;
291         ++instructionCount;
292     }
293 
294     size_t functionIndexSpace = moduleInformation.importFunctionCount() + block-&gt;functionIndex();
295     out.print(makeString(IndexOrName(functionIndexSpace, moduleInformation.nameSection-&gt;get(functionIndexSpace))));
296 
297     const auto&amp; function = moduleInformation.functions[block-&gt;functionIndex()];
298     SignatureIndex signatureIndex = moduleInformation.internalFunctionSignatureIndices[block-&gt;functionIndex()];
299     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
300     out.print(&quot; : &quot;, signature, &quot;\n&quot;);
301     out.print(&quot;wasm size: &quot;, function.data.size(), &quot; bytes\n&quot;);
302 
303     out.printf(
304         &quot;bytecode: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions); %lu bytes; %d parameter(s); %d local(s); %d callee register(s)\n&quot;,
305         static_cast&lt;unsigned long&gt;(instructionCount),
306         static_cast&lt;unsigned long&gt;(wide16InstructionCount),
307         static_cast&lt;unsigned long&gt;(wide32InstructionCount),
308         static_cast&lt;unsigned long&gt;(block-&gt;instructions().sizeInBytes()),
309         block-&gt;numArguments(),
310         block-&gt;numVars(),
311         block-&gt;numCalleeLocals());
312 
313     BytecodeDumper dumper(block, out);
314     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {
315         dumpWasm(&amp;dumper, it.offset(), it.ptr());
316         out.print(&quot;\n&quot;);
317     }
318 
319     dumper.dumpConstants();
320 
321     out.printf(&quot;\n&quot;);
322 }
323 
324 void BytecodeDumper::dumpConstants()
325 {
326     FunctionCodeBlock* block = this-&gt;block();
327     if (!block-&gt;constants().isEmpty()) {
328         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);
329         unsigned i = 0;
330         for (const auto&amp; constant : block-&gt;constants()) {
331             Type type = block-&gt;constantTypes()[i];
332             this-&gt;m_out.print(&quot;   const&quot;, i, &quot; : &quot;, type, &quot; = &quot;, formatConstant(type, constant), &quot;\n&quot;);
333             ++i;
334         }
335     }
336 }
337 
338 CString BytecodeDumper::constantName(VirtualRegister index) const
339 {
340     FunctionCodeBlock* block = this-&gt;block();
341     auto value = formatConstant(block-&gt;getConstantType(index), block-&gt;getConstant(index));
342     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);
343 }
344 
345 CString BytecodeDumper::formatConstant(Type type, uint64_t constant) const
346 {
347     switch (type) {
348     case Type::I32:
349         return toCString(static_cast&lt;int32_t&gt;(constant));
350     case Type::I64:
351         return toCString(constant);
352     case Type::F32:
353         return toCString(bitwise_cast&lt;float&gt;(static_cast&lt;int32_t&gt;(constant)));
354         break;
355     case Type::F64:
356         return toCString(bitwise_cast&lt;double&gt;(constant));
357         break;
358     case Type::Anyref:
359     case Type::Funcref:
360         if (JSValue::decode(constant) == jsNull())
361             return &quot;null&quot;;
362         return toCString(RawPointer(bitwise_cast&lt;void*&gt;(constant)));
363     default:
364         RELEASE_ASSERT_NOT_REACHED();
365         return &quot;&quot;;
366     }
367 }
368 
369 } // namespace Wasm
370 
371 #endif // ENABLE(WEBASSEMBLY)
372 }
    </pre>
  </body>
</html>
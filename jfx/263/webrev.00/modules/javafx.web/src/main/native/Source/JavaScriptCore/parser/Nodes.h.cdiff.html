<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   *  Copyright (C) 2007 Maks Orlovich
   *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   *  This library is free software; you can redistribute it and/or
<span class="line-new-header">--- 1,9 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   *  Copyright (C) 2007 Maks Orlovich
   *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   *  This library is free software; you can redistribute it and/or
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,10 ***</span>
<span class="line-new-header">--- 25,11 ---</span>
  
  #pragma once
  
  #include &quot;BytecodeIntrinsicRegistry.h&quot;
  #include &quot;JITCode.h&quot;
<span class="line-added">+ #include &quot;Label.h&quot;</span>
  #include &quot;ParserArena.h&quot;
  #include &quot;ParserModes.h&quot;
  #include &quot;ParserTokens.h&quot;
  #include &quot;ResultType.h&quot;
  #include &quot;SourceCode.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,11 ***</span>
  
      class ArgumentListNode;
      class BytecodeGenerator;
      class FunctionMetadataNode;
      class FunctionParameters;
<span class="line-removed">-     class Label;</span>
      class ModuleAnalyzer;
      class ModuleScopeData;
      class PropertyListNode;
      class ReadModifyResolveNode;
      class RegisterID;
<span class="line-new-header">--- 44,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,12 ***</span>
      public: \
          JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
      private: \
          typedef int __thisIsHereToForceASemicolonAfterThisMacro
  
      class ParserArenaRoot {
<span class="line-modified">!         WTF_MAKE_FAST_ALLOCATED;</span>
      protected:
          ParserArenaRoot(ParserArena&amp;);
  
      public:
          ParserArena&amp; parserArena() { return m_arena; }
<span class="line-new-header">--- 126,13 ---</span>
      public: \
          JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
      private: \
          typedef int __thisIsHereToForceASemicolonAfterThisMacro
  
<span class="line-added">+     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
      class ParserArenaRoot {
<span class="line-modified">!         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
      protected:
          ParserArenaRoot(ParserArena&amp;);
  
      public:
          ParserArena&amp; parserArena() { return m_arena; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,10 ***</span>
<span class="line-new-header">--- 249,11 ---</span>
          virtual bool isLabel() const { return false; }
          virtual bool isBlock() const { return false; }
          virtual bool isFuncDeclNode() const { return false; }
          virtual bool isModuleDeclarationNode() const { return false; }
          virtual bool isForOfNode() const { return false; }
<span class="line-added">+         virtual bool isDefineFieldNode() const { return false; }</span>
  
      protected:
          int m_lastLine { -1 };
          StatementNode* m_next { nullptr };
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,41 ***</span>
          const bool m_sign;
      };
  
      class ThrowableExpressionData {
      public:
<span class="line-modified">!         ThrowableExpressionData()</span>
<span class="line-removed">-             : m_divot(-1, -1, -1)</span>
<span class="line-removed">-             , m_divotStart(-1, -1, -1)</span>
<span class="line-removed">-             , m_divotEnd(-1, -1, -1)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-         }</span>
  
          ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
              : m_divot(divot)
              , m_divotStart(start)
              , m_divotEnd(end)
          {
<span class="line-modified">!             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);</span>
<span class="line-removed">-             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);</span>
<span class="line-removed">-             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);</span>
          }
  
          void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
          {
<span class="line-removed">-             ASSERT(divot.offset &gt;= divot.lineStartOffset);</span>
<span class="line-removed">-             ASSERT(divotStart.offset &gt;= divotStart.lineStartOffset);</span>
<span class="line-removed">-             ASSERT(divotEnd.offset &gt;= divotEnd.lineStartOffset);</span>
              m_divot = divot;
              m_divotStart = divotStart;
              m_divotEnd = divotEnd;
          }
  
          const JSTextPosition&amp; divot() const { return m_divot; }
          const JSTextPosition&amp; divotStart() const { return m_divotStart; }
          const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
  
      protected:
          RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
  
      private:
          JSTextPosition m_divot;
<span class="line-new-header">--- 370,40 ---</span>
          const bool m_sign;
      };
  
      class ThrowableExpressionData {
      public:
<span class="line-modified">!         ThrowableExpressionData() = default;</span>
  
          ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
              : m_divot(divot)
              , m_divotStart(start)
              , m_divotEnd(end)
          {
<span class="line-modified">!             checkConsistency();</span>
          }
  
          void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
          {
              m_divot = divot;
              m_divotStart = divotStart;
              m_divotEnd = divotEnd;
<span class="line-added">+             checkConsistency();</span>
          }
  
          const JSTextPosition&amp; divot() const { return m_divot; }
          const JSTextPosition&amp; divotStart() const { return m_divotStart; }
          const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
  
<span class="line-added">+         void checkConsistency() const</span>
<span class="line-added">+         {</span>
<span class="line-added">+             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);</span>
<span class="line-added">+             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);</span>
<span class="line-added">+             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);</span>
<span class="line-added">+             ASSERT(m_divot.offset &gt;= m_divotStart.offset);</span>
<span class="line-added">+             ASSERT(m_divotEnd.offset &gt;= m_divot.offset);</span>
<span class="line-added">+         }</span>
      protected:
          RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
  
      private:
          JSTextPosition m_divot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 715,20 ***</span>
<span class="line-new-header">--- 716,25 ---</span>
          enum PutType : uint8_t { Unknown, KnownDirect };
  
          PropertyNode(const Identifier&amp;, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
          PropertyNode(ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
          PropertyNode(ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
<span class="line-added">+         PropertyNode(const Identifier&amp;, ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);</span>
  
          ExpressionNode* expressionName() const { return m_expression; }
          const Identifier* name() const { return m_name; }
  
          Type type() const { return static_cast&lt;Type&gt;(m_type); }
          bool needsSuperBinding() const { return m_needsSuperBinding; }
          bool isClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) != ClassElementTag::No; }
          bool isStaticClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Static; }
          bool isInstanceClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Instance; }
<span class="line-added">+         bool isClassField() const { return isClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
<span class="line-added">+         bool isInstanceClassField() const { return isInstanceClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
          bool isOverriddenByDuplicate() const { return m_isOverriddenByDuplicate; }
<span class="line-added">+         bool hasComputedName() const { return m_expression; }</span>
<span class="line-added">+         bool isComputedClassField() const { return isClassField() &amp;&amp; hasComputedName(); }</span>
          void setIsOverriddenByDuplicate() { m_isOverriddenByDuplicate = true; }
          PutType putType() const { return static_cast&lt;PutType&gt;(m_putType); }
  
      private:
          friend class PropertyListNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,28 ***</span>
          unsigned m_type : 6;
          unsigned m_needsSuperBinding : 1;
          unsigned m_putType : 1;
          static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
          unsigned m_classElementTag : 2;
<span class="line-modified">!         unsigned m_isOverriddenByDuplicate: 1;</span>
      };
  
      class PropertyListNode final : public ExpressionNode {
      public:
          PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
          PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
  
          bool hasStaticallyNamedProperty(const Identifier&amp; propName);
  
<span class="line-modified">!         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*);</span>
  
      private:
          RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
          {
<span class="line-modified">!             return emitBytecode(generator, dst, nullptr);</span>
          }
          void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);
  
          PropertyNode* m_node;
          PropertyListNode* m_next { nullptr };
      };
  
<span class="line-new-header">--- 744,40 ---</span>
          unsigned m_type : 6;
          unsigned m_needsSuperBinding : 1;
          unsigned m_putType : 1;
          static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
          unsigned m_classElementTag : 2;
<span class="line-modified">!         unsigned m_isOverriddenByDuplicate : 1;</span>
      };
  
      class PropertyListNode final : public ExpressionNode {
      public:
          PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
          PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
  
          bool hasStaticallyNamedProperty(const Identifier&amp; propName);
<span class="line-added">+         bool isComputedClassField() const</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return m_node-&gt;isComputedClassField();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         bool isInstanceClassField() const</span>
<span class="line-added">+         {</span>
<span class="line-added">+             return m_node-&gt;isInstanceClassField();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         bool hasInstanceFields() const;</span>
  
<span class="line-modified">!         static bool shouldCreateLexicalScopeForClass(PropertyListNode*);</span>
<span class="line-added">+ </span>
<span class="line-added">+         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*, Vector&lt;JSTextPosition&gt;*);</span>
  
      private:
          RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
          {
<span class="line-modified">!             return emitBytecode(generator, dst, nullptr, nullptr);</span>
          }
          void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);
<span class="line-added">+         void emitSaveComputedFieldName(BytecodeGenerator&amp;, PropertyNode&amp;);</span>
  
          PropertyNode* m_node;
          PropertyListNode* m_next { nullptr };
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 942,18 ***</span>
          enum class Type : uint8_t {
              Constant,
              Function
          };
  
<span class="line-modified">!         typedef RegisterID* (BytecodeIntrinsicNode::* EmitterType)(BytecodeGenerator&amp;, RegisterID*);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, EmitterType, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>
  
          bool isBytecodeIntrinsicNode() const override { return true; }
  
          Type type() const { return m_type; }
<span class="line-modified">!         EmitterType emitter() const { return m_emitter; }</span>
          const Identifier&amp; identifier() const { return m_ident; }
  
  #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
          JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
          JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
<span class="line-new-header">--- 960,16 ---</span>
          enum class Type : uint8_t {
              Constant,
              Function
          };
  
<span class="line-modified">!         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, BytecodeIntrinsicRegistry::Entry, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>
  
          bool isBytecodeIntrinsicNode() const override { return true; }
  
          Type type() const { return m_type; }
<span class="line-modified">!         BytecodeIntrinsicRegistry::Entry entry() const { return m_entry; }</span>
          const Identifier&amp; identifier() const { return m_ident; }
  
  #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
          JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
          JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 962,11 ***</span>
      private:
          RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          bool isFunctionCall() const override { return m_type == Type::Function; }
  
<span class="line-modified">!         EmitterType m_emitter;</span>
          const Identifier&amp; m_ident;
          ArgumentsNode* m_args;
          Type m_type;
      };
  
<span class="line-new-header">--- 978,11 ---</span>
      private:
          RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          bool isFunctionCall() const override { return m_type == Type::Function; }
  
<span class="line-modified">!         BytecodeIntrinsicRegistry::Entry m_entry;</span>
          const Identifier&amp; m_ident;
          ArgumentsNode* m_args;
          Type m_type;
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1842,11 ***</span>
          ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static const bool scopeIsFunction = false;</span>
  
      private:
          void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
          unsigned m_startColumn;
          unsigned m_endColumn;
<span class="line-new-header">--- 1858,11 ---</span>
          ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static constexpr bool scopeIsFunction = false;</span>
  
      private:
          void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
          unsigned m_startColumn;
          unsigned m_endColumn;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1857,11 ***</span>
          EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          ALWAYS_INLINE unsigned startColumn() const { return 0; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static const bool scopeIsFunction = false;</span>
  
      private:
          void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          unsigned m_endColumn;
<span class="line-new-header">--- 1873,11 ---</span>
          EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          ALWAYS_INLINE unsigned startColumn() const { return 0; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static constexpr bool scopeIsFunction = false;</span>
  
      private:
          void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          unsigned m_endColumn;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1872,11 ***</span>
          ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static const bool scopeIsFunction = false;</span>
  
          ModuleScopeData&amp; moduleScopeData()
          {
              return m_moduleScopeData;
          }
<span class="line-new-header">--- 1888,11 ---</span>
          ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static constexpr bool scopeIsFunction = false;</span>
  
          ModuleScopeData&amp; moduleScopeData()
          {
              return m_moduleScopeData;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2073,10 ***</span>
<span class="line-new-header">--- 2089,16 ---</span>
  
          int startStartOffset() const { return m_startStartOffset; }
          bool isInStrictContext() const { return m_isInStrictContext; }
          SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
          ConstructorKind constructorKind() { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
<span class="line-added">+         bool isConstructorAndNeedsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
<span class="line-added">+         void setNeedsClassFieldInitializer(bool value)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             ASSERT(!value || constructorKind() != ConstructorKind::None);</span>
<span class="line-added">+             m_needsClassFieldInitializer = value;</span>
<span class="line-added">+         }</span>
          bool isArrowFunctionBodyExpression() const { return m_isArrowFunctionBodyExpression; }
  
          void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
          {
              m_lastLine = lastLine;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2093,10 ***</span>
<span class="line-new-header">--- 2115,11 ---</span>
  
      public:
          unsigned m_isInStrictContext : 1;
          unsigned m_superBinding : 1;
          unsigned m_constructorKind : 2;
<span class="line-added">+         unsigned m_needsClassFieldInitializer : 1;</span>
          unsigned m_isArrowFunctionBodyExpression : 1;
          SourceParseMode m_parseMode;
          FunctionMode m_functionMode;
          Identifier m_ident;
          Identifier m_ecmaName;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2107,11 ***</span>
          int m_parametersStart;
          SourceCode m_source;
          SourceCode m_classSource;
          int m_startStartOffset;
          unsigned m_parameterCount;
<span class="line-modified">!         int m_lastLine;</span>
      };
  
      class FunctionNode final : public ScopeNode {
      public:
          FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
<span class="line-new-header">--- 2130,11 ---</span>
          int m_parametersStart;
          SourceCode m_source;
          SourceCode m_classSource;
          int m_startStartOffset;
          unsigned m_parameterCount;
<span class="line-modified">!         int m_lastLine { 0 };</span>
      };
  
      class FunctionNode final : public ScopeNode {
      public:
          FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2129,11 ***</span>
          FunctionMode functionMode() const { return m_functionMode; }
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static const bool scopeIsFunction = true;</span>
  
      private:
          Identifier m_ident;
          FunctionMode m_functionMode;
          FunctionParameters* m_parameters;
<span class="line-new-header">--- 2152,11 ---</span>
          FunctionMode functionMode() const { return m_functionMode; }
  
          unsigned startColumn() const { return m_startColumn; }
          unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!         static constexpr bool scopeIsFunction = true;</span>
  
      private:
          Identifier m_ident;
          FunctionMode m_functionMode;
          FunctionParameters* m_parameters;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2209,10 ***</span>
<span class="line-new-header">--- 2232,25 ---</span>
          RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          ExpressionNode* m_argument;
      };
  
<span class="line-added">+     class DefineFieldNode final : public StatementNode {</span>
<span class="line-added">+     public:</span>
<span class="line-added">+         enum class Type { Name, ComputedName };</span>
<span class="line-added">+         DefineFieldNode(const JSTokenLocation&amp;, const Identifier*, ExpressionNode*, Type);</span>
<span class="line-added">+ </span>
<span class="line-added">+     private:</span>
<span class="line-added">+         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = nullptr) override;</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool isDefineFieldNode() const override { return true; }</span>
<span class="line-added">+ </span>
<span class="line-added">+         const Identifier* m_ident;</span>
<span class="line-added">+         ExpressionNode* m_assign;</span>
<span class="line-added">+         Type m_type;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      class ClassExprNode final : public ExpressionNode, public VariableEnvironmentNode {
          JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ClassExprNode);
      public:
          ClassExprNode(const JSTokenLocation&amp;, const Identifier&amp;, const SourceCode&amp; classSource,
              VariableEnvironment&amp; classEnvironment, ExpressionNode* constructorExpresssion,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2221,10 ***</span>
<span class="line-new-header">--- 2259,11 ---</span>
          const Identifier&amp; name() { return m_name; }
          const Identifier&amp; ecmaName() { return m_ecmaName ? *m_ecmaName : m_name; }
          void setEcmaName(const Identifier&amp; name) { m_ecmaName = m_name.isNull() ? &amp;name : &amp;m_name; }
  
          bool hasStaticProperty(const Identifier&amp; propName) { return m_classElements ? m_classElements-&gt;hasStaticallyNamedProperty(propName) : false; }
<span class="line-added">+         bool hasInstanceFields() const { return m_classElements ? m_classElements-&gt;hasInstanceFields() : false; }</span>
  
      private:
          RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
  
          bool isClassExprNode() const override { return true; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2233,10 ***</span>
<span class="line-new-header">--- 2272,11 ---</span>
          const Identifier&amp; m_name;
          const Identifier* m_ecmaName;
          ExpressionNode* m_constructorExpression;
          ExpressionNode* m_classHeritage;
          PropertyListNode* m_classElements;
<span class="line-added">+         bool m_needsLexicalScope;</span>
      };
  
      class DestructuringPatternNode : public ParserArenaFreeable {
      public:
          virtual ~DestructuringPatternNode() { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2490,11 ***</span>
  
          void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
  
      private:
          SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
<span class="line-modified">!         static const size_t s_tableSwitchMinimum = 3;</span>
          ClauseListNode* m_list1;
          CaseClauseNode* m_defaultClause;
          ClauseListNode* m_list2;
      };
  
<span class="line-new-header">--- 2530,11 ---</span>
  
          void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
  
      private:
          SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
<span class="line-modified">!         static constexpr size_t s_tableSwitchMinimum = 3;</span>
          ClauseListNode* m_list1;
          CaseClauseNode* m_defaultClause;
          ClauseListNode* m_list2;
      };
  
</pre>
<center><a href="Nodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
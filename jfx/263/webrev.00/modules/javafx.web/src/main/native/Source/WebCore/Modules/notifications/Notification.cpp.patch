diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/notifications/Notification.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/notifications/Notification.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/notifications/Notification.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/notifications/Notification.cpp
@@ -39,10 +39,11 @@
 #include "Event.h"
 #include "EventNames.h"
 #include "NotificationClient.h"
 #include "NotificationController.h"
 #include "NotificationPermissionCallback.h"
+#include "WindowEventLoop.h"
 #include "WindowFocusAllowedIndicator.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
@@ -61,30 +62,31 @@
     , m_direction(options.dir)
     , m_lang(options.lang)
     , m_body(options.body)
     , m_tag(options.tag)
     , m_state(Idle)
-    , m_taskTimer(makeUnique<Timer>([this] () { show(); }))
+    , m_showNotificationTimer(&document, *this, &Notification::show)
 {
     if (!options.icon.isEmpty()) {
         auto iconURL = document.completeURL(options.icon);
         if (iconURL.isValid())
             m_icon = iconURL;
     }
 
-    m_taskTimer->startOneShot(0_s);
+    m_showNotificationTimer.startOneShot(0_s);
+    m_showNotificationTimer.suspendIfNeeded();
 }
 
-Notification::~Notification()  = default;
+Notification::~Notification() = default;
 
 void Notification::show()
 {
     // prevent double-showing
     if (m_state != Idle)
         return;
 
-    auto* page = downcast<Document>(*scriptExecutionContext()).page();
+    auto* page = document()->page();
     if (!page)
         return;
 
     auto& client = NotificationController::from(page)->client();
 
@@ -102,85 +104,116 @@
 {
     switch (m_state) {
     case Idle:
         break;
     case Showing: {
-        auto* page = downcast<Document>(*scriptExecutionContext()).page();
-        if (page)
+        if (auto* page = document()->page())
             NotificationController::from(page)->client().cancel(this);
         break;
     }
     case Closed:
         break;
     }
 }
 
-const char* Notification::activeDOMObjectName() const
+Document* Notification::document() const
 {
-    return "Notification";
+    return downcast<Document>(scriptExecutionContext());
 }
 
-bool Notification::canSuspendForDocumentSuspension() const
+const char* Notification::activeDOMObjectName() const
 {
-    // We can suspend if the Notification is not shown yet or after it is closed.
-    return m_state == Idle || m_state == Closed;
+    return "Notification";
 }
 
 void Notification::stop()
 {
     ActiveDOMObject::stop();
 
-    auto* page = downcast<Document>(*scriptExecutionContext()).page();
-    if (page)
+    if (auto* page = document()->page())
         NotificationController::from(page)->client().notificationObjectDestroyed(this);
 }
 
+void Notification::suspend(ReasonForSuspension)
+{
+    close();
+}
+
 void Notification::finalize()
 {
     if (m_state == Closed)
         return;
     m_state = Closed;
     unsetPendingActivity(*this);
 }
 
+void Notification::queueTask(Function<void()>&& task)
+{
+    auto* document = this->document();
+    if (!document)
+        return;
+
+    document->eventLoop().queueTask(TaskSource::UserInteraction, WTFMove(task));
+}
+
 void Notification::dispatchShowEvent()
 {
-    dispatchEvent(Event::create(eventNames().showEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTask([this, pendingActivity = makePendingActivity(*this)] {
+        dispatchEvent(Event::create(eventNames().showEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    });
 }
 
 void Notification::dispatchClickEvent()
 {
-    WindowFocusAllowedIndicator windowFocusAllowed;
-    dispatchEvent(Event::create(eventNames().clickEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTask([this, pendingActivity = makePendingActivity(*this)] {
+        WindowFocusAllowedIndicator windowFocusAllowed;
+        dispatchEvent(Event::create(eventNames().clickEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    });
 }
 
 void Notification::dispatchCloseEvent()
 {
-    dispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTask([this, pendingActivity = makePendingActivity(*this)] {
+        dispatchEvent(Event::create(eventNames().closeEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    });
     finalize();
 }
 
 void Notification::dispatchErrorEvent()
 {
-    dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTask([this, pendingActivity = makePendingActivity(*this)] {
+        dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    });
 }
 
 auto Notification::permission(Document& document) -> Permission
 {
     auto* page = document.page();
     if (!page)
         return Permission::Default;
 
+    if (!document.isSecureContext())
+        return Permission::Denied;
+
     return NotificationController::from(document.page())->client().checkPermission(&document);
 }
 
 void Notification::requestPermission(Document& document, RefPtr<NotificationPermissionCallback>&& callback)
 {
     auto* page = document.page();
     if (!page)
         return;
 
+    if (!document.isSecureContext()) {
+        if (callback) {
+            document.eventLoop().queueTask(TaskSource::DOMManipulation, [callback = WTFMove(callback)]() mutable {
+                callback->handleEvent(Permission::Denied);
+            });
+        }
+        return;
+    }
+
     NotificationController::from(page)->client().requestPermission(&document, WTFMove(callback));
 }
 
 } // namespace WebCore
 

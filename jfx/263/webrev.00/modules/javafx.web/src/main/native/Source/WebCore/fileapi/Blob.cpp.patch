diff a/modules/javafx.web/src/main/native/Source/WebCore/fileapi/Blob.cpp b/modules/javafx.web/src/main/native/Source/WebCore/fileapi/Blob.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/fileapi/Blob.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/fileapi/Blob.cpp
@@ -47,51 +47,48 @@
 WTF_MAKE_ISO_ALLOCATED_IMPL(Blob);
 
 class BlobURLRegistry final : public URLRegistry {
 public:
     void registerURL(ScriptExecutionContext&, const URL&, URLRegistrable&) final;
-    void unregisterURL(ScriptExecutionContext&, const URL&) final;
+    void unregisterURL(const URL&) final;
 
     static URLRegistry& registry();
 };
 
 
 void BlobURLRegistry::registerURL(ScriptExecutionContext& context, const URL& publicURL, URLRegistrable& blob)
 {
     ASSERT(&blob.registry() == this);
-    ThreadableBlobRegistry::registerBlobURL(context.sessionID(), context.securityOrigin(), publicURL, static_cast<Blob&>(blob).url());
+    ThreadableBlobRegistry::registerBlobURL(context.securityOrigin(), publicURL, static_cast<Blob&>(blob).url());
 }
 
-void BlobURLRegistry::unregisterURL(ScriptExecutionContext& context, const URL& url)
+void BlobURLRegistry::unregisterURL(const URL& url)
 {
-    ThreadableBlobRegistry::unregisterBlobURL(context.sessionID(), url);
+    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
 
 URLRegistry& BlobURLRegistry::registry()
 {
     static NeverDestroyed<BlobURLRegistry> instance;
     return instance;
 }
 
-Blob::Blob(UninitializedContructor, PAL::SessionID sessionID, URL&& url, String&& type)
-    : m_sessionID(sessionID)
-    , m_internalURL(WTFMove(url))
+Blob::Blob(UninitializedContructor, URL&& url, String&& type)
+    : m_internalURL(WTFMove(url))
     , m_type(WTFMove(type))
 {
 }
 
-Blob::Blob(PAL::SessionID sessionID)
-    : m_sessionID(sessionID)
-    , m_size(0)
+Blob::Blob()
+    : m_size(0)
 {
     m_internalURL = BlobURL::createInternalURL();
-    ThreadableBlobRegistry::registerBlobURL(m_sessionID, m_internalURL, { },  { });
+    ThreadableBlobRegistry::registerBlobURL(m_internalURL, { },  { });
 }
 
-Blob::Blob(PAL::SessionID sessionID, Vector<BlobPartVariant>&& blobPartVariants, const BlobPropertyBag& propertyBag)
-    : m_sessionID(sessionID)
-    , m_internalURL(BlobURL::createInternalURL())
+Blob::Blob(Vector<BlobPartVariant>&& blobPartVariants, const BlobPropertyBag& propertyBag)
+    : m_internalURL(BlobURL::createInternalURL())
     , m_type(normalizedContentType(propertyBag.type))
 {
     BlobBuilder builder(propertyBag.endings);
     for (auto& blobPartVariant : blobPartVariants) {
         WTF::switchOn(blobPartVariant,
@@ -99,79 +96,74 @@
                 builder.append(WTFMove(part));
             }
         );
     }
 
-    ThreadableBlobRegistry::registerBlobURL(m_sessionID, m_internalURL, builder.finalize(), m_type);
+    ThreadableBlobRegistry::registerBlobURL(m_internalURL, builder.finalize(), m_type);
 }
 
-Blob::Blob(PAL::SessionID sessionID, const SharedBuffer& buffer, const String& contentType)
-    : m_sessionID(sessionID)
-    , m_type(contentType)
+Blob::Blob(const SharedBuffer& buffer, const String& contentType)
+    : m_type(contentType)
     , m_size(buffer.size())
 {
     Vector<uint8_t> data;
     data.append(buffer.data(), buffer.size());
 
     Vector<BlobPart> blobParts;
     blobParts.append(BlobPart(WTFMove(data)));
     m_internalURL = BlobURL::createInternalURL();
-    ThreadableBlobRegistry::registerBlobURL(m_sessionID, m_internalURL, WTFMove(blobParts), contentType);
+    ThreadableBlobRegistry::registerBlobURL(m_internalURL, WTFMove(blobParts), contentType);
 }
 
-Blob::Blob(PAL::SessionID sessionID, Vector<uint8_t>&& data, const String& contentType)
-    : m_sessionID(sessionID)
-    , m_type(contentType)
+Blob::Blob(Vector<uint8_t>&& data, const String& contentType)
+    : m_type(contentType)
     , m_size(data.size())
 {
     Vector<BlobPart> blobParts;
     blobParts.append(BlobPart(WTFMove(data)));
     m_internalURL = BlobURL::createInternalURL();
-    ThreadableBlobRegistry::registerBlobURL(m_sessionID, m_internalURL, WTFMove(blobParts), contentType);
+    ThreadableBlobRegistry::registerBlobURL(m_internalURL, WTFMove(blobParts), contentType);
 }
 
 Blob::Blob(ReferencingExistingBlobConstructor, const Blob& blob)
-    : m_sessionID(blob.m_sessionID)
-    , m_internalURL(BlobURL::createInternalURL())
+    : m_internalURL(BlobURL::createInternalURL())
     , m_type(blob.type())
     , m_size(blob.size())
 {
-    ThreadableBlobRegistry::registerBlobURL(m_sessionID, m_internalURL, { BlobPart(blob.url()) } , m_type);
+    ThreadableBlobRegistry::registerBlobURL(m_internalURL, { BlobPart(blob.url()) } , m_type);
 }
 
-Blob::Blob(DeserializationContructor, PAL::SessionID sessionID, const URL& srcURL, const String& type, Optional<unsigned long long> size, const String& fileBackedPath)
-    : m_sessionID(sessionID)
-    , m_type(normalizedContentType(type))
+Blob::Blob(DeserializationContructor, const URL& srcURL, const String& type, Optional<unsigned long long> size, const String& fileBackedPath)
+    : m_type(normalizedContentType(type))
     , m_size(size)
 {
     m_internalURL = BlobURL::createInternalURL();
     if (fileBackedPath.isEmpty())
-        ThreadableBlobRegistry::registerBlobURL(m_sessionID, nullptr, m_internalURL, srcURL);
+        ThreadableBlobRegistry::registerBlobURL(nullptr, m_internalURL, srcURL);
     else
-        ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(m_sessionID, m_internalURL, srcURL, fileBackedPath, m_type);
+        ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(m_internalURL, srcURL, fileBackedPath, m_type);
 }
 
-Blob::Blob(PAL::SessionID sessionID, const URL& srcURL, long long start, long long end, const String& type)
-    : m_sessionID(sessionID)
-    , m_type(normalizedContentType(type))
+Blob::Blob(const URL& srcURL, long long start, long long end, const String& type)
+    : m_type(normalizedContentType(type))
     // m_size is not necessarily equal to end - start so we do not initialize it here.
 {
     m_internalURL = BlobURL::createInternalURL();
-    ThreadableBlobRegistry::registerBlobURLForSlice(m_sessionID, m_internalURL, srcURL, start, end);
+    ThreadableBlobRegistry::registerBlobURLForSlice(m_internalURL, srcURL, start, end);
 }
 
 Blob::~Blob()
 {
-    ThreadableBlobRegistry::unregisterBlobURL(m_sessionID, m_internalURL);
+    ThreadableBlobRegistry::unregisterBlobURL(m_internalURL);
 }
 
 unsigned long long Blob::size() const
 {
     if (!m_size) {
         // FIXME: JavaScript cannot represent sizes as large as unsigned long long, we need to
         // come up with an exception to throw if file size is not representable.
-        unsigned long long actualSize = ThreadableBlobRegistry::blobSize(m_sessionID, m_internalURL);
+        unsigned long long actualSize = ThreadableBlobRegistry::blobSize(m_internalURL);
         m_size = WTF::isInBounds<long long>(actualSize) ? actualSize : 0;
     }
 
     return *m_size;
 }
@@ -192,11 +184,11 @@
     if (!isValidContentType(contentType))
         return emptyString();
     return contentType.convertToASCIILowercase();
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 bool Blob::isNormalizedContentType(const String& contentType)
 {
     // FIXME: Do we really want to treat the empty string and null string as valid content types?
     unsigned length = contentType.length();
     for (size_t i = 0; i < length; ++i) {
@@ -219,11 +211,11 @@
         if (isASCIIUpper(characters[i]))
             return false;
     }
     return true;
 }
-#endif
+#endif // ASSERT_ENABLED
 
 URLRegistry& Blob::registry() const
 {
     return BlobURLRegistry::registry();
 }

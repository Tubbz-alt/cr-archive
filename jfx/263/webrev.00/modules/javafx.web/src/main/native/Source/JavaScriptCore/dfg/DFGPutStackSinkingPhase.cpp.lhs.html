<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGPutStackSinkingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBlockMapInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;DFGPreciseLocalClobberize.h&quot;
 36 #include &quot;DFGSSACalculator.h&quot;
 37 #include &quot;DFGValidate.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;OperandsInlines.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
 43 namespace {
 44 
<a name="2" id="anc2"></a><span class="line-removed"> 45 namespace DFGPutStackSinkingPhaseInternal {</span>
<span class="line-removed"> 46 static const bool verbose = false;</span>
<span class="line-removed"> 47 }</span>
<span class="line-removed"> 48 </span>
 49 class PutStackSinkingPhase : public Phase {
<a name="3" id="anc3"></a>
 50 public:
 51     PutStackSinkingPhase(Graph&amp; graph)
 52         : Phase(graph, &quot;PutStack sinking&quot;)
 53     {
 54     }
 55 
 56     bool run()
 57     {
 58         // FIXME: One of the problems of this approach is that it will create a duplicate Phi graph
 59         // for sunken PutStacks in the presence of interesting control flow merges, and where the
 60         // value being PutStack&#39;d is also otherwise live in the DFG code. We could work around this
 61         // by doing the sinking over CPS, or maybe just by doing really smart hoisting. It&#39;s also
 62         // possible that the duplicate Phi graph can be deduplicated by B3. It would be best if we
 63         // could observe that there is already a Phi graph in place that does what we want. In
 64         // principle if we have a request to place a Phi at a particular place, we could just check
 65         // if there is already a Phi that does what we want. Because PutStackSinkingPhase runs just
 66         // after SSA conversion, we have almost a guarantee that the Phi graph we produce here would
 67         // be trivially redundant to the one we already have.
 68 
 69         // FIXME: This phase doesn&#39;t adequately use KillStacks. KillStack can be viewed as a def.
 70         // This is mostly inconsequential; it would be a bug to have a local live at a KillStack.
 71         // More important is that KillStack should swallow any deferral. After a KillStack, the
 72         // local should behave like a TOP deferral because it would be invalid for anyone to trust
 73         // the stack. It&#39;s not clear to me if this is important or not.
 74         // https://bugs.webkit.org/show_bug.cgi?id=145296
 75 
<a name="4" id="anc4"></a><span class="line-modified"> 76         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
 77             dataLog(&quot;Graph before PutStack sinking:\n&quot;);
 78             m_graph.dump();
 79         }
 80 
 81         m_graph.ensureSSADominators();
 82 
 83         SSACalculator ssaCalculator(m_graph);
 84         InsertionSet insertionSet(m_graph);
 85 
 86         // First figure out where various locals are live.
 87         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtHead(m_graph);
 88         BlockMap&lt;Operands&lt;bool&gt;&gt; liveAtTail(m_graph);
 89 
 90         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<a name="5" id="anc5"></a><span class="line-modified"> 91             liveAtHead[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-modified"> 92             liveAtTail[block] = Operands&lt;bool&gt;(OperandsLike, block-&gt;variablesAtHead);</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94             liveAtHead[block].fill(false);</span>
<span class="line-removed"> 95             liveAtTail[block].fill(false);</span>
 96         }
 97 
 98         bool changed;
 99         do {
100             changed = false;
101 
102             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
103                 BasicBlock* block = m_graph.block(blockIndex);
104                 if (!block)
105                     continue;
106 
107                 Operands&lt;bool&gt; live = liveAtTail[block];
108                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
109                     Node* node = block-&gt;at(nodeIndex);
<a name="6" id="anc6"></a><span class="line-modified">110                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
111                         dataLog(&quot;Live at &quot;, node, &quot;: &quot;, live, &quot;\n&quot;);
112 
<a name="7" id="anc7"></a><span class="line-modified">113                     Vector&lt;VirtualRegister, 4&gt; reads;</span>
<span class="line-modified">114                     Vector&lt;VirtualRegister, 4&gt; writes;</span>
<span class="line-modified">115                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
116                         if (operand.isHeader())
117                             return;
<a name="8" id="anc8"></a><span class="line-modified">118                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
119                             dataLog(&quot;    &quot;, operand, &quot; is live at &quot;, node, &quot;\n&quot;);
120                         reads.append(operand);
121                     };
122 
<a name="9" id="anc9"></a><span class="line-modified">123                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
124                         if (operand.isHeader())
125                             return;
<a name="10" id="anc10"></a><span class="line-modified">126                         RELEASE_ASSERT(node-&gt;op() == PutStack || node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs || node-&gt;op() == KillStack);</span>

127                         writes.append(operand);
128                     };
129 
130                     preciseLocalClobberize(
131                         m_graph, node, escapeHandler, writeHandler,
<a name="11" id="anc11"></a><span class="line-modified">132                         [&amp;] (VirtualRegister, LazyNode) { });</span>
133 
<a name="12" id="anc12"></a><span class="line-modified">134                     for (VirtualRegister operand : writes)</span>
135                         live.operand(operand) = false;
<a name="13" id="anc13"></a><span class="line-modified">136                     for (VirtualRegister operand : reads)</span>
137                         live.operand(operand) = true;
138                 }
139 
140                 if (live == liveAtHead[block])
141                     continue;
142 
143                 liveAtHead[block] = live;
144                 changed = true;
145 
146                 for (BasicBlock* predecessor : block-&gt;predecessors) {
147                     for (size_t i = live.size(); i--;)
148                         liveAtTail[predecessor][i] |= live[i];
149                 }
150             }
151 
152         } while (changed);
153 
154         // All of the arguments should be live at head of root. Note that we may find that some
155         // locals are live at head of root. This seems wrong but isn&#39;t. This will happen for example
156         // if the function accesses closure variable #42 for some other function and we either don&#39;t
157         // have variable #42 at all or we haven&#39;t set it at root, for whatever reason. Basically this
158         // arises since our aliasing for closure variables is conservatively based on variable number
159         // and ignores the owning symbol table. We should probably fix this eventually and make our
160         // aliasing more precise.
161         //
162         // For our purposes here, the imprecision in the aliasing is harmless. It just means that we
163         // may not do as much Phi pruning as we wanted.
164         for (size_t i = liveAtHead.atIndex(0).numberOfArguments(); i--;)
165             DFG_ASSERT(m_graph, nullptr, liveAtHead.atIndex(0).argument(i));
166 
167         // Next identify where we would want to sink PutStacks to. We say that there is a deferred
168         // flush if we had a PutStack with a given FlushFormat but it hasn&#39;t been materialized yet.
169         // Deferrals have the following lattice; but it&#39;s worth noting that the TOP part of the
170         // lattice serves an entirely different purpose than the rest of the lattice: it just means
171         // that we&#39;re in a region of code where nobody should have been relying on the value. The
172         // rest of the lattice means that we either have a PutStack that is deferred (i.e. still
173         // needs to be executed) or there isn&#39;t one (because we&#39;ve alraedy executed it).
174         //
175         // Bottom:
176         //     Represented as DeadFlush.
177         //     Means that all previous PutStacks have been executed so there is nothing deferred.
178         //     During merging this is subordinate to the other kinds of deferrals, because it
179         //     represents the fact that we&#39;ve already executed all necessary PutStacks. This implies
180         //     that there *had* been some PutStacks that we should have executed.
181         //
182         // Top:
183         //     Represented as ConflictingFlush.
184         //     Represents the fact that we know, via forward flow, that there isn&#39;t any value in the
185         //     given local that anyone should have been relying on. This comes into play at the
186         //     prologue (because in SSA form at the prologue no local has any value) or when we merge
187         //     deferrals for different formats&#39;s. A lexical scope in which a local had some semantic
188         //     meaning will by this point share the same format; if we had stores from different
189         //     lexical scopes that got merged together then we may have a conflicting format. Hence
190         //     a conflicting format proves that we&#39;re no longer in an area in which the variable was
191         //     in scope. Note that this is all approximate and only precise enough to later answer
192         //     questions pertinent to sinking. For example, this doesn&#39;t always detect when a local
193         //     is no longer semantically relevant - we may well have a deferral from inside some
194         //     inlined call survive outside of that inlined code, and this is generally OK. In the
195         //     worst case it means that we might think that a deferral that is actually dead must
196         //     still be executed. But we usually catch that with liveness. Liveness usually catches
197         //     such cases, but that&#39;s not guaranteed since liveness is conservative.
198         //
199         //     What Top does give us is detects situations where we both don&#39;t need to care about a
200         //     deferral and there is no way that we could reason about it anyway. If we merged
201         //     deferrals for different formats then we wouldn&#39;t know the format to use. So, we use
202         //     Top in that case because that&#39;s also a case where we know that we can ignore the
203         //     deferral.
204         //
205         // Deferral with a concrete format:
206         //     Represented by format values other than DeadFlush or ConflictingFlush.
207         //     Represents the fact that the original code would have done a PutStack but we haven&#39;t
208         //     identified an operation that would have observed that PutStack.
209         //
210         // We need to be precise about liveness in this phase because not doing so
211         // could cause us to insert a PutStack before a node we thought may escape a
212         // value that it doesn&#39;t really escape. Sinking this PutStack above such a node may
213         // cause us to insert a GetStack that we forward to the Phi we&#39;re feeding into the
214         // sunken PutStack. Inserting such a GetStack could cause us to load garbage and
215         // can confuse the AI to claim untrue things (like that the program will exit when
216         // it really won&#39;t).
217         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtHead(m_graph);
218         BlockMap&lt;Operands&lt;FlushFormat&gt;&gt; deferredAtTail(m_graph);
219 
220         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
221             deferredAtHead[block] =
222                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
223             deferredAtTail[block] =
224                 Operands&lt;FlushFormat&gt;(OperandsLike, block-&gt;variablesAtHead);
225         }
226 
227         for (unsigned local = deferredAtHead.atIndex(0).numberOfLocals(); local--;)
228             deferredAtHead.atIndex(0).local(local) = ConflictingFlush;
229 
230         do {
231             changed = false;
232 
233             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
234                 Operands&lt;FlushFormat&gt; deferred = deferredAtHead[block];
235 
236                 for (Node* node : *block) {
<a name="14" id="anc14"></a><span class="line-modified">237                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
238                         dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
239 
240                     if (node-&gt;op() == GetStack) {
241                         // Handle the case that the input doesn&#39;t match our requirements. This is
242                         // really a bug, but it&#39;s a benign one if we simply don&#39;t run this phase.
243                         // It usually arises because of patterns like:
244                         //
245                         // if (thing)
246                         //     PutStack()
247                         // ...
248                         // if (thing)
249                         //     GetStack()
250                         //
251                         // Or:
252                         //
253                         // if (never happens)
254                         //     GetStack()
255                         //
256                         // Because this phase runs early in SSA, it should be sensible to enforce
257                         // that no such code pattern has arisen yet. So, when validation is
258                         // enabled, we assert that we aren&#39;t seeing this. But with validation
259                         // disabled we silently let this fly and we just abort this phase.
260                         // FIXME: Get rid of all remaining cases of conflicting GetStacks.
261                         // https://bugs.webkit.org/show_bug.cgi?id=150398
262 
263                         bool isConflicting =
<a name="15" id="anc15"></a><span class="line-modified">264                             deferred.operand(node-&gt;stackAccessData()-&gt;local) == ConflictingFlush;</span>
265 
266                         if (validationEnabled())
267                             DFG_ASSERT(m_graph, node, !isConflicting);
268 
269                         if (isConflicting) {
270                             // Oh noes! Abort!!
271                             return false;
272                         }
273 
274                         // A GetStack doesn&#39;t affect anything, since we know which local we are reading
275                         // from.
276                         continue;
277                     } else if (node-&gt;op() == PutStack) {
<a name="16" id="anc16"></a><span class="line-modified">278                         VirtualRegister operand = node-&gt;stackAccessData()-&gt;local;</span>

279                         deferred.operand(operand) = node-&gt;stackAccessData()-&gt;format;
280                         continue;
281                     } else if (node-&gt;op() == KillStack) {
282                         // We don&#39;t want to sink a PutStack past a KillStack.
<a name="17" id="anc17"></a><span class="line-modified">283                         deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>


284                         continue;
285                     }
286 
<a name="18" id="anc18"></a><span class="line-modified">287                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">288                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
289                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
290                         if (operand.isHeader())
291                             return;
292                         // We will materialize just before any reads.
293                         deferred.operand(operand) = DeadFlush;
294                     };
295 
<a name="19" id="anc19"></a><span class="line-modified">296                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>

297                         if (operand.isHeader())
298                             return;
<a name="20" id="anc20"></a><span class="line-modified">299                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>

300                         deferred.operand(operand) = DeadFlush;
301                     };
302 
303                     preciseLocalClobberize(
304                         m_graph, node, escapeHandler, writeHandler,
<a name="21" id="anc21"></a><span class="line-modified">305                         [&amp;] (VirtualRegister, LazyNode) { });</span>
306                 }
307 
308                 if (deferred == deferredAtTail[block])
309                     continue;
310 
311                 deferredAtTail[block] = deferred;
312                 changed = true;
313 
314                 for (BasicBlock* successor : block-&gt;successors()) {
315                     for (size_t i = deferred.size(); i--;) {
<a name="22" id="anc22"></a><span class="line-modified">316                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
<span class="line-modified">317                             dataLog(&quot;Considering &quot;, VirtualRegister(deferred.operandForIndex(i)), &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successor), &quot;: &quot;, deferred[i], &quot; and &quot;, deferredAtHead[successor][i], &quot; merges to &quot;);</span>
318 
319                         deferredAtHead[successor][i] =
320                             merge(deferredAtHead[successor][i], deferred[i]);
321 
<a name="23" id="anc23"></a><span class="line-modified">322                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
323                             dataLog(deferredAtHead[successor][i], &quot;\n&quot;);
324                     }
325                 }
326             }
327 
328         } while (changed);
329 
330         // We wish to insert PutStacks at all of the materialization points, which are defined
331         // implicitly as the places where we set deferred to Dead while it was previously not Dead.
332         // To do this, we may need to build some Phi functions to handle stuff like this:
333         //
334         // Before:
335         //
336         //     if (p)
337         //         PutStack(r42, @x)
338         //     else
339         //         PutStack(r42, @y)
340         //
341         // After:
342         //
343         //     if (p)
344         //         Upsilon(@x, ^z)
345         //     else
346         //         Upsilon(@y, ^z)
347         //     z: Phi()
348         //     PutStack(r42, @z)
349         //
350         // This means that we have an SSACalculator::Variable for each local, and a Def is any
351         // PutStack in the original program. The original PutStacks will simply vanish.
352 
353         Operands&lt;SSACalculator::Variable*&gt; operandToVariable(
354             OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
<a name="24" id="anc24"></a><span class="line-modified">355         Vector&lt;VirtualRegister&gt; indexToOperand;</span>
356         for (size_t i = m_graph.block(0)-&gt;variablesAtHead.size(); i--;) {
<a name="25" id="anc25"></a><span class="line-modified">357             VirtualRegister operand(m_graph.block(0)-&gt;variablesAtHead.operandForIndex(i));</span>
358 
359             SSACalculator::Variable* variable = ssaCalculator.newVariable();
360             operandToVariable.operand(operand) = variable;
361             ASSERT(indexToOperand.size() == variable-&gt;index());
362             indexToOperand.append(operand);
363         }
364 
365         HashSet&lt;Node*&gt; putStacksToSink;
366 
367         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
368             for (Node* node : *block) {
369                 switch (node-&gt;op()) {
370                 case PutStack:
371                     putStacksToSink.add(node);
372                     ssaCalculator.newDef(
<a name="26" id="anc26"></a><span class="line-modified">373                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
374                         block, node-&gt;child1().node());
375                     break;
376                 case GetStack:
377                     ssaCalculator.newDef(
<a name="27" id="anc27"></a><span class="line-modified">378                         operandToVariable.operand(node-&gt;stackAccessData()-&gt;local),</span>
379                         block, node);
380                     break;
381                 default:
382                     break;
383                 }
384             }
385         }
386 
387         ssaCalculator.computePhis(
388             [&amp;] (SSACalculator::Variable* variable, BasicBlock* block) -&gt; Node* {
<a name="28" id="anc28"></a><span class="line-modified">389                 VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
390 
391                 if (!liveAtHead[block].operand(operand))
392                     return nullptr;
393 
394                 FlushFormat format = deferredAtHead[block].operand(operand);
395 
396                 // We could have an invalid deferral because liveness is imprecise.
397                 if (!isConcrete(format))
398                     return nullptr;
399 
<a name="29" id="anc29"></a><span class="line-modified">400                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
401                     dataLog(&quot;Adding Phi for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;\n&quot;);
402 
403                 Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block-&gt;at(0)-&gt;origin.withInvalidExit());
404                 phiNode-&gt;mergeFlags(resultFor(format));
405                 return phiNode;
406             });
407 
408         Operands&lt;Node*&gt; mapping(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
409         Operands&lt;FlushFormat&gt; deferred;
410         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
411             mapping.fill(nullptr);
412 
413             for (size_t i = mapping.size(); i--;) {
<a name="30" id="anc30"></a><span class="line-modified">414                 VirtualRegister operand(mapping.operandForIndex(i));</span>
415 
416                 SSACalculator::Variable* variable = operandToVariable.operand(operand);
417                 SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
418                 if (!def)
419                     continue;
420 
421                 mapping.operand(operand) = def-&gt;value();
422             }
423 
<a name="31" id="anc31"></a><span class="line-modified">424             if (DFGPutStackSinkingPhaseInternal::verbose)</span>
425                 dataLog(&quot;Mapping at top of &quot;, pointerDump(block), &quot;: &quot;, mapping, &quot;\n&quot;);
426 
427             for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
<a name="32" id="anc32"></a><span class="line-modified">428                 VirtualRegister operand = indexToOperand[phiDef-&gt;variable()-&gt;index()];</span>
429 
430                 insertionSet.insert(0, phiDef-&gt;value());
431 
<a name="33" id="anc33"></a><span class="line-modified">432                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
433                     dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, phiDef-&gt;value(), &quot;\n&quot;);
434                 mapping.operand(operand) = phiDef-&gt;value();
435             }
436 
437             deferred = deferredAtHead[block];
438             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
439                 Node* node = block-&gt;at(nodeIndex);
<a name="34" id="anc34"></a><span class="line-modified">440                 if (DFGPutStackSinkingPhaseInternal::verbose)</span>
441                     dataLog(&quot;Deferred at &quot;, node, &quot;:&quot;, deferred, &quot;\n&quot;);
442 
443                 switch (node-&gt;op()) {
444                 case PutStack: {
445                     StackAccessData* data = node-&gt;stackAccessData();
<a name="35" id="anc35"></a><span class="line-modified">446                     VirtualRegister operand = data-&gt;local;</span>
447                     deferred.operand(operand) = data-&gt;format;
<a name="36" id="anc36"></a><span class="line-modified">448                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
449                         dataLog(&quot;   Mapping &quot;, operand, &quot; to &quot;, node-&gt;child1().node(), &quot; at &quot;, node, &quot;\n&quot;);
450                     mapping.operand(operand) = node-&gt;child1().node();
451                     break;
452                 }
453 
454                 case GetStack: {
455                     StackAccessData* data = node-&gt;stackAccessData();
<a name="37" id="anc37"></a><span class="line-modified">456                     FlushFormat format = deferred.operand(data-&gt;local);</span>
457                     if (!isConcrete(format)) {
458                         DFG_ASSERT(
459                             m_graph, node,
<a name="38" id="anc38"></a><span class="line-modified">460                             deferred.operand(data-&gt;local) != ConflictingFlush, deferred.operand(data-&gt;local));</span>
461 
462                         // This means there is no deferral. No deferral means that the most
463                         // authoritative value for this stack slot is what is stored in the stack. So,
464                         // keep the GetStack.
<a name="39" id="anc39"></a><span class="line-modified">465                         mapping.operand(data-&gt;local) = node;</span>
466                         break;
467                     }
468 
469                     // We have a concrete deferral, which means a PutStack that hasn&#39;t executed yet. It
470                     // would have stored a value with a certain format. That format must match our
471                     // format. But more importantly, we can simply use the value that the PutStack would
472                     // have stored and get rid of the GetStack.
473                     DFG_ASSERT(m_graph, node, format == data-&gt;format, format, data-&gt;format);
474 
<a name="40" id="anc40"></a><span class="line-modified">475                     Node* incoming = mapping.operand(data-&gt;local);</span>
476                     node-&gt;child1() = incoming-&gt;defaultEdge();
477                     node-&gt;convertToIdentity();
478                     break;
479                 }
480 
481                 case KillStack: {
<a name="41" id="anc41"></a><span class="line-modified">482                     deferred.operand(node-&gt;unlinkedLocal()) = ConflictingFlush;</span>
483                     break;
484                 }
485 
486                 default: {
<a name="42" id="anc42"></a><span class="line-modified">487                     auto escapeHandler = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">488                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
489                             dataLog(&quot;For &quot;, node, &quot; escaping &quot;, operand, &quot;\n&quot;);
490 
491                         if (operand.isHeader())
492                             return;
493 
494                         FlushFormat format = deferred.operand(operand);
495                         if (!isConcrete(format)) {
496                             // It&#39;s dead now, rather than conflicting.
497                             deferred.operand(operand) = DeadFlush;
498                             return;
499                         }
500 
501                         // Gotta insert a PutStack.
<a name="43" id="anc43"></a><span class="line-modified">502                         if (DFGPutStackSinkingPhaseInternal::verbose)</span>
503                             dataLog(&quot;Inserting a PutStack for &quot;, operand, &quot; at &quot;, node, &quot;\n&quot;);
504 
505                         Node* incoming = mapping.operand(operand);
506                         DFG_ASSERT(m_graph, node, incoming);
507 
508                         insertionSet.insertNode(
509                             nodeIndex, SpecNone, PutStack, node-&gt;origin,
510                             OpInfo(m_graph.m_stackAccessData.add(operand, format)),
511                             Edge(incoming, uncheckedUseKindFor(format)));
512 
513                         deferred.operand(operand) = DeadFlush;
514                     };
515 
<a name="44" id="anc44"></a><span class="line-modified">516                     auto writeHandler = [&amp;] (VirtualRegister operand) {</span>
517                         if (operand.isHeader())
518                             return;
519                         // LoadVarargs and ForwardVarargs are unconditional writes to the stack
520                         // locations they claim to write to. They do not read from the stack
521                         // locations they write to. This makes those stack locations dead right
522                         // before a LoadVarargs/ForwardVarargs. This means we should never sink
523                         // PutStacks right to this point.
<a name="45" id="anc45"></a><span class="line-modified">524                         RELEASE_ASSERT(node-&gt;op() == LoadVarargs || node-&gt;op() == ForwardVarargs);</span>
525                         deferred.operand(operand) = DeadFlush;
526                     };
527 
528                     preciseLocalClobberize(
529                         m_graph, node, escapeHandler, writeHandler,
<a name="46" id="anc46"></a><span class="line-modified">530                         [&amp;] (VirtualRegister, LazyNode) { });</span>
531                     break;
532                 } }
533             }
534 
535             NodeAndIndex terminal = block-&gt;findTerminal();
536             size_t upsilonInsertionPoint = terminal.index;
537             NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
538             for (BasicBlock* successorBlock : block-&gt;successors()) {
539                 for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
540                     Node* phiNode = phiDef-&gt;value();
541                     SSACalculator::Variable* variable = phiDef-&gt;variable();
<a name="47" id="anc47"></a><span class="line-modified">542                     VirtualRegister operand = indexToOperand[variable-&gt;index()];</span>
<span class="line-modified">543                     if (DFGPutStackSinkingPhaseInternal::verbose)</span>
544                         dataLog(&quot;Creating Upsilon for &quot;, operand, &quot; at &quot;, pointerDump(block), &quot;-&gt;&quot;, pointerDump(successorBlock), &quot;\n&quot;);
545                     FlushFormat format = deferredAtHead[successorBlock].operand(operand);
546                     DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
547                     UseKind useKind = uncheckedUseKindFor(format);
548 
549                     // We need to get a value for the stack slot. This phase doesn&#39;t really have a
550                     // good way of determining if a stack location got clobbered. It just knows if
551                     // there is a deferral. The lack of a deferral might mean that a PutStack or
552                     // GetStack had never happened, or it might mean that the value was read, or
553                     // that it was written. It&#39;s OK for us to make some bad decisions here, since
554                     // GCSE will clean it up anyway.
555                     Node* incoming;
556                     if (isConcrete(deferred.operand(operand))) {
557                         incoming = mapping.operand(operand);
558                         DFG_ASSERT(m_graph, phiNode, incoming);
559                     } else {
560                         // Issue a GetStack to get the value. This might introduce some redundancy
561                         // into the code, but if it&#39;s bad enough, GCSE will clean it up.
562                         incoming = insertionSet.insertNode(
563                             upsilonInsertionPoint, SpecNone, GetStack, upsilonOrigin,
564                             OpInfo(m_graph.m_stackAccessData.add(operand, format)));
565                         incoming-&gt;setResult(resultFor(format));
566                     }
567 
568                     insertionSet.insertNode(
569                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
570                         OpInfo(phiNode), Edge(incoming, useKind));
571                 }
572             }
573 
574             insertionSet.execute(block);
575         }
576 
577         // Finally eliminate the sunken PutStacks by turning them into Checks. This keeps whatever
578         // type check they were doing.
579         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
580             for (auto* node : *block) {
581                 if (!putStacksToSink.contains(node))
582                     continue;
583 
584                 node-&gt;remove(m_graph);
585             }
586         }
587 
<a name="48" id="anc48"></a><span class="line-modified">588         if (DFGPutStackSinkingPhaseInternal::verbose) {</span>
589             dataLog(&quot;Graph after PutStack sinking:\n&quot;);
590             m_graph.dump();
591         }
592 
593         return true;
594     }
595 };
596 
597 } // anonymous namespace
598 
599 bool performPutStackSinking(Graph&amp; graph)
600 {
601     return runPhase&lt;PutStackSinkingPhase&gt;(graph);
602 }
603 
604 } } // namespace JSC::DFG
605 
606 #endif // ENABLE(DFG_JIT)
607 
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
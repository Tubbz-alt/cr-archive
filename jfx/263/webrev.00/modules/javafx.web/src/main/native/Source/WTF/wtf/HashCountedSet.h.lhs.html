<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/HashCountedSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005, 2006, 2008, 2013, 2016 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;initializer_list&gt;
 24 #include &lt;wtf/Assertions.h&gt;
 25 #include &lt;wtf/Forward.h&gt;
 26 #include &lt;wtf/HashMap.h&gt;
 27 #include &lt;wtf/Vector.h&gt;
 28 
 29 namespace WTF {
 30 
 31 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
 32 class HashCountedSet final {
 33     WTF_MAKE_FAST_ALLOCATED;
 34 private:
 35     using ImplType = HashMap&lt;Value, unsigned, HashFunctions, Traits&gt;;
 36 public:
 37     using ValueType = Value;
 38     using iterator = typename ImplType::iterator;
 39     using const_iterator = typename ImplType::const_iterator;
 40     using ValuesIteratorRange = typename ImplType::KeysIteratorRange;
 41     using ValuesConstIteratorRange = typename ImplType::KeysConstIteratorRange;
 42     using AddResult = typename ImplType::AddResult;
 43 
 44     HashCountedSet()
 45     {
 46     }
 47 
 48     HashCountedSet(std::initializer_list&lt;typename ImplType::KeyValuePairType&gt; initializerList)
 49     {
 50         for (const auto&amp; keyValuePair : initializerList)
 51             add(keyValuePair.key, keyValuePair.value);
 52     }
 53 
 54     HashCountedSet(std::initializer_list&lt;typename ImplType::KeyType&gt; initializerList)
 55     {
 56         for (const auto&amp; value : initializerList)
 57             add(value);
 58     }
 59 
 60     void swap(HashCountedSet&amp;);
 61 
 62     unsigned size() const;
 63     unsigned capacity() const;
 64     bool isEmpty() const;
 65 
 66     // Iterators iterate over pairs of values and counts.
 67     iterator begin();
 68     iterator end();
 69     const_iterator begin() const;
 70     const_iterator end() const;
 71 
 72     iterator random() { return m_impl.random(); }
 73     const_iterator random() const { return m_impl.random(); }
 74 
 75     ValuesIteratorRange values();
 76     const ValuesConstIteratorRange values() const;
 77 
 78     iterator find(const ValueType&amp;);
 79     const_iterator find(const ValueType&amp;) const;
 80     bool contains(const ValueType&amp;) const;
 81     unsigned count(const ValueType&amp;) const;
 82 
 83     // Increments the count if an equal value is already present.
 84     // The return value includes both an iterator to the value&#39;s location,
 85     // and an isNewEntry bool that indicates whether it is a new or existing entry.
 86     AddResult add(const ValueType&amp;);
 87     AddResult add(ValueType&amp;&amp;);
 88 
 89     // Increments the count of a value by the passed amount.
 90     AddResult add(const ValueType&amp;, unsigned);
 91     AddResult add(ValueType&amp;&amp;, unsigned);
 92 
 93     // Decrements the count of the value, and removes it if count goes down to zero.
 94     // Returns true if the value is removed.
 95     bool remove(const ValueType&amp;);
 96     bool remove(iterator);
 97 
 98     // Removes the value, regardless of its count.
 99     // Returns true if a value was removed.
100     bool removeAll(iterator);
101     bool removeAll(const ValueType&amp;);
102 
103     // Clears the whole set.
104     void clear();
105 
106     // Overloads for smart pointer keys that take the raw pointer type as the parameter.
107     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType);
108     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type find(typename GetPtrHelper&lt;V&gt;::PtrType) const;
109     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type contains(typename GetPtrHelper&lt;V&gt;::PtrType) const;
110     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type count(typename GetPtrHelper&lt;V&gt;::PtrType) const;
111     template&lt;typename V = ValueType&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type remove(typename GetPtrHelper&lt;V&gt;::PtrType);
112 
<a name="1" id="anc1"></a>

113 private:
114     ImplType m_impl;
115 };
116 
117 
118 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
119 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::swap(HashCountedSet&amp; other)
120 {
121     m_impl.swap(other.m_impl);
122 }
123 
124 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
125 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::size() const
126 {
127     return m_impl.size();
128 }
129 
130 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
131 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::capacity() const
132 {
133     return m_impl.capacity();
134 }
135 
136 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
137 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::isEmpty() const
138 {
139     return size() == 0;
140 }
141 
142 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
143 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::begin() -&gt; iterator
144 {
145     return m_impl.begin();
146 }
147 
148 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
149 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::end() -&gt; iterator
150 {
151     return m_impl.end();
152 }
153 
154 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
155 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::begin() const -&gt; const_iterator
156 {
157     return m_impl.begin();
158 }
159 
160 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
161 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::end() const -&gt; const_iterator
162 {
163     return m_impl.end();
164 }
165 
166 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
167 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::values() -&gt; ValuesIteratorRange
168 {
169     return m_impl.keys();
170 }
171 
172 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
173 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::values() const -&gt; const ValuesConstIteratorRange
174 {
175     return m_impl.keys();
176 }
177 
178 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
179 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(const ValueType&amp; value) -&gt; iterator
180 {
181     return m_impl.find(value);
182 }
183 
184 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
185 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(const ValueType&amp; value) const -&gt; const_iterator
186 {
187     return m_impl.find(value);
188 }
189 
190 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
191 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::contains(const ValueType&amp; value) const
192 {
193     return m_impl.contains(value);
194 }
195 
196 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
197 inline unsigned HashCountedSet&lt;Value, HashFunctions, Traits&gt;::count(const ValueType&amp; value) const
198 {
199     return m_impl.get(value);
200 }
201 
202 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
203 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(const ValueType &amp;value) -&gt; AddResult
204 {
205     auto result = m_impl.add(value, 0);
206     ++result.iterator-&gt;value;
207     return result;
208 }
209 
210 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
211 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(ValueType&amp;&amp; value) -&gt; AddResult
212 {
213     auto result = m_impl.add(std::forward&lt;Value&gt;(value), 0);
214     ++result.iterator-&gt;value;
215     return result;
216 }
217 
218 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
219 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(const ValueType&amp; value, unsigned count) -&gt; AddResult
220 {
221     auto result = m_impl.add(value, 0);
222     result.iterator-&gt;value += count;
223     return result;
224 }
225 
226 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
227 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::add(ValueType&amp;&amp; value, unsigned count) -&gt; AddResult
228 {
229     auto result = m_impl.add(std::forward&lt;Value&gt;(value), 0);
230     result.iterator-&gt;value += count;
231     return result;
232 }
233 
234 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
235 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(const ValueType&amp; value)
236 {
237     return remove(find(value));
238 }
239 
240 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
241 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(iterator it)
242 {
243     if (it == end())
244         return false;
245 
246     unsigned oldVal = it-&gt;value;
247     ASSERT(oldVal);
248     unsigned newVal = oldVal - 1;
249     if (newVal) {
250         it-&gt;value = newVal;
251         return false;
252     }
253 
254     m_impl.remove(it);
255     return true;
256 }
257 
258 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
259 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::removeAll(const ValueType&amp; value)
260 {
261     return removeAll(find(value));
262 }
263 
264 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
265 inline bool HashCountedSet&lt;Value, HashFunctions, Traits&gt;::removeAll(iterator it)
266 {
267     if (it == end())
268         return false;
269 
270     m_impl.remove(it);
271     return true;
272 }
273 
274 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
275 inline void HashCountedSet&lt;Value, HashFunctions, Traits&gt;::clear()
276 {
277     m_impl.clear();
278 }
279 
280 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
281 template&lt;typename V&gt;
282 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(typename GetPtrHelper&lt;V&gt;::PtrType value) -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, iterator&gt;::type
283 {
284     return m_impl.find(value);
285 }
286 
287 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
288 template&lt;typename V&gt;
289 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::find(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, const_iterator&gt;::type
290 {
291     return m_impl.find(value);
292 }
293 
294 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
295 template&lt;typename V&gt;
296 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::contains(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type
297 {
298     return m_impl.contains(value);
299 }
300 
301 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
302 template&lt;typename V&gt;
303 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::count(typename GetPtrHelper&lt;V&gt;::PtrType value) const -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, unsigned&gt;::type
304 {
305     return m_impl.get(value);
306 }
307 
308 template&lt;typename Value, typename HashFunctions, typename Traits&gt;
309 template&lt;typename V&gt;
310 inline auto HashCountedSet&lt;Value, HashFunctions, Traits&gt;::remove(typename GetPtrHelper&lt;V&gt;::PtrType value) -&gt; typename std::enable_if&lt;IsSmartPtr&lt;V&gt;::value, bool&gt;::type
311 {
312     return remove(find(value));
313 }
314 
315 } // namespace WTF
316 
317 using WTF::HashCountedSet;
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
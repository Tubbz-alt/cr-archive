<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/style/StyleTreeResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleSharingResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleTreeResolver.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/style/StyleTreeResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;ComposedTreeIterator.h&quot;
 33 #include &quot;DocumentTimeline.h&quot;
 34 #include &quot;ElementIterator.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;HTMLBodyElement.h&quot;
 37 #include &quot;HTMLMeterElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLProgressElement.h&quot;
 40 #include &quot;HTMLSlotElement.h&quot;
 41 #include &quot;LoaderStrategy.h&quot;
 42 #include &quot;NodeRenderStyle.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PlatformStrategies.h&quot;
 45 #include &quot;Quirks.h&quot;
 46 #include &quot;RenderElement.h&quot;
 47 #include &quot;RenderStyle.h&quot;
 48 #include &quot;RenderView.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;ShadowRoot.h&quot;

 52 #include &quot;StyleFontSizeFunctions.h&quot;
 53 #include &quot;StyleResolver.h&quot;
 54 #include &quot;StyleScope.h&quot;
 55 #include &quot;Text.h&quot;
 56 
 57 namespace WebCore {
 58 
 59 namespace Style {
 60 


 61 TreeResolver::TreeResolver(Document&amp; document)
 62     : m_document(document)
 63 {
 64 }
 65 
 66 TreeResolver::~TreeResolver() = default;
 67 
 68 TreeResolver::Scope::Scope(Document&amp; document)
<span class="line-modified"> 69     : styleResolver(document.styleScope().resolver())</span>
<span class="line-modified"> 70     , sharingResolver(document, styleResolver.ruleSets(), selectorFilter)</span>
 71 {
 72     document.setIsResolvingTreeStyle(true);
 73 }
 74 
 75 TreeResolver::Scope::Scope(ShadowRoot&amp; shadowRoot, Scope&amp; enclosingScope)
<span class="line-modified"> 76     : styleResolver(shadowRoot.styleScope().resolver())</span>
<span class="line-modified"> 77     , sharingResolver(shadowRoot.documentScope(), styleResolver.ruleSets(), selectorFilter)</span>
 78     , shadowRoot(&amp;shadowRoot)
 79     , enclosingScope(&amp;enclosingScope)
 80 {
<span class="line-modified"> 81     styleResolver.setOverrideDocumentElementStyle(enclosingScope.styleResolver.overrideDocumentElementStyle());</span>
 82 }
 83 
 84 TreeResolver::Scope::~Scope()
 85 {
 86     if (!shadowRoot)
<span class="line-modified"> 87         styleResolver.document().setIsResolvingTreeStyle(false);</span>
 88 
<span class="line-modified"> 89     styleResolver.setOverrideDocumentElementStyle(nullptr);</span>
 90 }
 91 
 92 TreeResolver::Parent::Parent(Document&amp; document)
 93     : element(nullptr)
 94     , style(*document.renderStyle())
 95 {
 96 }
 97 
 98 TreeResolver::Parent::Parent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
 99     : element(&amp;element)
100     , style(style)
101     , change(change)
102     , descendantsToResolve(descendantsToResolve)
103 {
104 }
105 
106 void TreeResolver::pushScope(ShadowRoot&amp; shadowRoot)
107 {
108     m_scopeStack.append(adoptRef(*new Scope(shadowRoot, scope())));
109 }
</pre>
<hr />
<pre>
117 void TreeResolver::popScope()
118 {
119     return m_scopeStack.removeLast();
120 }
121 
122 std::unique_ptr&lt;RenderStyle&gt; TreeResolver::styleForElement(Element&amp; element, const RenderStyle&amp; inheritedStyle)
123 {
124     if (element.hasCustomStyleResolveCallbacks()) {
125         RenderStyle* shadowHostStyle = scope().shadowRoot ? m_update-&gt;elementStyle(*scope().shadowRoot-&gt;host()) : nullptr;
126         if (auto customStyle = element.resolveCustomStyle(inheritedStyle, shadowHostStyle)) {
127             if (customStyle-&gt;relations)
128                 commitRelations(WTFMove(customStyle-&gt;relations), *m_update);
129 
130             return WTFMove(customStyle-&gt;renderStyle);
131         }
132     }
133 
134     if (auto style = scope().sharingResolver.resolve(element, *m_update))
135         return style;
136 
<span class="line-modified">137     auto elementStyle = scope().styleResolver.styleForElement(element, &amp;inheritedStyle, parentBoxStyle(), RuleMatchingBehavior::MatchAllRules, &amp;scope().selectorFilter);</span>
138 
139     if (elementStyle.relations)
140         commitRelations(WTFMove(elementStyle.relations), *m_update);
141 
142     return WTFMove(elementStyle.renderStyle);
143 }
144 
145 static void resetStyleForNonRenderedDescendants(Element&amp; current)
146 {
147     for (auto&amp; child : childrenOfType&lt;Element&gt;(current)) {
148         if (child.needsStyleRecalc()) {
149             child.resetComputedStyle();
150             child.resetStyleRelations();
151             child.setHasValidStyle();
152         }
153 
154         if (child.childNeedsStyleRecalc())
155             resetStyleForNonRenderedDescendants(child);
156     }
157     current.clearChildNeedsStyleRecalc();
</pre>
<hr />
<pre>
178     case NoChange:
179         return DescendantsToResolve::None;
180     case NoInherit:
181         return DescendantsToResolve::ChildrenWithExplicitInherit;
182     case Inherit:
183         return DescendantsToResolve::Children;
184     case Detach:
185         return DescendantsToResolve::All;
186     };
187     ASSERT_NOT_REACHED();
188     return DescendantsToResolve::None;
189 };
190 
191 ElementUpdates TreeResolver::resolveElement(Element&amp; element)
192 {
193     if (m_didSeePendingStylesheet &amp;&amp; !element.renderer() &amp;&amp; !m_document.isIgnoringPendingStylesheets()) {
194         m_document.setHasNodesWithMissingStyle();
195         return { };
196     }
197 



198     auto newStyle = styleForElement(element, parent().style);
199 
200     if (!affectsRenderedSubtree(element, *newStyle))
201         return { };
202 
203     auto* existingStyle = element.renderOrDisplayContentsStyle();
204 
205     if (m_didSeePendingStylesheet &amp;&amp; (!existingStyle || existingStyle-&gt;isNotFinal())) {
206         newStyle-&gt;setIsNotFinal();
207         m_document.setHasNodesWithNonFinalStyle();
208     }
209 
210     auto update = createAnimatedElementUpdate(WTFMove(newStyle), element, parent().change);
211     auto descendantsToResolve = computeDescendantsToResolve(update.change, element.styleValidity(), parent().descendantsToResolve);
212 
213     if (&amp;element == m_document.documentElement()) {
214         m_documentElementStyle = RenderStyle::clonePtr(*update.style);
<span class="line-modified">215         scope().styleResolver.setOverrideDocumentElementStyle(m_documentElementStyle.get());</span>
216 
217         if (update.change != NoChange &amp;&amp; existingStyle &amp;&amp; existingStyle-&gt;computedFontPixelSize() != update.style-&gt;computedFontPixelSize()) {
218             // &quot;rem&quot; units are relative to the document element&#39;s font size so we need to recompute everything.
219             // In practice this is rare.
<span class="line-modified">220             scope().styleResolver.invalidateMatchedPropertiesCache();</span>
221             descendantsToResolve = DescendantsToResolve::All;
222         }
223     }
224 
225     // This is needed for resolving color:-webkit-text for subsequent elements.
226     // FIXME: We shouldn&#39;t mutate document when resolving style.
227     if (&amp;element == m_document.body())
228         m_document.setTextColor(update.style-&gt;visitedDependentColor(CSSPropertyColor));
229 
230     // FIXME: These elements should not change renderer based on appearance property.
231     if (element.hasTagName(HTMLNames::meterTag) || is&lt;HTMLProgressElement&gt;(element)) {
232         if (existingStyle &amp;&amp; update.style-&gt;appearance() != existingStyle-&gt;appearance()) {
233             update.change = Detach;
234             descendantsToResolve = DescendantsToResolve::All;
235         }
236     }
237 
238     auto beforeUpdate = resolvePseudoStyle(element, update, PseudoId::Before);
239     auto afterUpdate = resolvePseudoStyle(element, update, PseudoId::After);
240 
241 #if ENABLE(POINTER_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
242     // FIXME: Track this exactly.
243     if (update.style-&gt;touchActions() != TouchAction::Auto &amp;&amp; !m_document.quirks().shouldDisablePointerEventsQuirk() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled())
244         m_document.setMayHaveElementsWithNonAutoTouchAction();
245 #endif
246 
247     return { WTFMove(update), descendantsToResolve, WTFMove(beforeUpdate), WTFMove(afterUpdate) };
248 }
249 
250 ElementUpdate TreeResolver::resolvePseudoStyle(Element&amp; element, const ElementUpdate&amp; elementUpdate, PseudoId pseudoId)
251 {
252     if (elementUpdate.style-&gt;display() == DisplayType::None)
253         return { };
254     if (!elementUpdate.style-&gt;hasPseudoStyle(pseudoId))
255         return { };
256 
<span class="line-modified">257     auto pseudoStyle = scope().styleResolver.pseudoStyleForElement(element, { pseudoId }, *elementUpdate.style, &amp;scope().selectorFilter);</span>
258     if (!pseudoElementRendererIsNeeded(pseudoStyle.get()))
259         return { };
260 
261     PseudoElement* pseudoElement = pseudoId == PseudoId::Before ? element.beforePseudoElement() : element.afterPseudoElement();
262     if (!pseudoElement) {
263         auto newPseudoElement = PseudoElement::create(element, pseudoId);
264         pseudoElement = newPseudoElement.ptr();
265         if (pseudoId == PseudoId::Before)
266             element.setBeforePseudoElement(WTFMove(newPseudoElement));
267         else
268             element.setAfterPseudoElement(WTFMove(newPseudoElement));
269     }
270 
271     return createAnimatedElementUpdate(WTFMove(pseudoStyle), *pseudoElement, elementUpdate.change);
272 }
273 
274 const RenderStyle* TreeResolver::parentBoxStyle() const
275 {
276     // &#39;display: contents&#39; doesn&#39;t generate boxes.
<span class="line-modified">277     for (unsigned i = m_parentStack.size(); i; --i) {</span>
<span class="line-modified">278         auto&amp; parent = m_parentStack[i - 1];</span>
279         if (parent.style.display() == DisplayType::None)
280             return nullptr;
281         if (parent.style.display() != DisplayType::Contents)
282             return &amp;parent.style;
283     }
284     ASSERT_NOT_REACHED();
285     return nullptr;
286 }
287 












288 ElementUpdate TreeResolver::createAnimatedElementUpdate(std::unique_ptr&lt;RenderStyle&gt; newStyle, Element&amp; element, Change parentChange)
289 {
290     auto* oldStyle = element.renderOrDisplayContentsStyle();
291 
<span class="line-modified">292     bool shouldRecompositeLayer = false;</span>
293 
294     // New code path for CSS Animations and CSS Transitions.
295     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
296         // First, we need to make sure that any new CSS animation occuring on this element has a matching WebAnimation
297         // on the document timeline. Note that we get timeline() on the Document here because we need a timeline created
298         // in case no Web Animations have been created through the JS API.
<span class="line-modified">299         if (element.document().pageCacheState() == Document::NotInPageCache &amp;&amp; !element.document().renderView()-&gt;printing()) {</span>
300             if (oldStyle &amp;&amp; (oldStyle-&gt;hasTransitions() || newStyle-&gt;hasTransitions()))
301                 m_document.timeline().updateCSSTransitionsForElement(element, *oldStyle, *newStyle);
302 
303             if ((oldStyle &amp;&amp; oldStyle-&gt;hasAnimations()) || newStyle-&gt;hasAnimations())
304                 m_document.timeline().updateCSSAnimationsForElement(element, oldStyle, *newStyle);
305         }
306     }
307 
<span class="line-modified">308     if (auto timeline = m_document.existingTimeline()) {</span>
<span class="line-modified">309         // Now we can update all Web animations, which will include CSS Animations as well</span>
<span class="line-modified">310         // as animations created via the JS API.</span>
311         auto animatedStyle = RenderStyle::clonePtr(*newStyle);
<span class="line-modified">312         shouldRecompositeLayer = timeline-&gt;resolveAnimationsForElement(element, *animatedStyle);</span>
313         newStyle = WTFMove(animatedStyle);
314     }
315 
316     // Old code path for CSS Animations and CSS Transitions.
317     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
318         auto&amp; animationController = m_document.frame()-&gt;animation();
319 
320         auto animationUpdate = animationController.updateAnimations(element, *newStyle, oldStyle);
<span class="line-modified">321         shouldRecompositeLayer = animationUpdate.animationChangeRequiresRecomposite;</span>
322 
323         if (animationUpdate.style)
324             newStyle = WTFMove(animationUpdate.style);
325     }
326 



327     auto change = oldStyle ? determineChange(*oldStyle, *newStyle) : Detach;
328 
329     auto validity = element.styleValidity();
330     if (validity &gt;= Validity::SubtreeAndRenderersInvalid || parentChange == Detach)
331         change = Detach;
332 
<span class="line-modified">333     shouldRecompositeLayer |= element.styleResolutionShouldRecompositeLayer();</span>
<span class="line-removed">334 </span>
335     return { WTFMove(newStyle), change, shouldRecompositeLayer };
336 }
337 
338 void TreeResolver::pushParent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
339 {
340     scope().selectorFilter.pushParent(&amp;element);
341 
342     Parent parent(element, style, change, descendantsToResolve);
343 
344     if (auto* shadowRoot = element.shadowRoot()) {
345         pushScope(*shadowRoot);
346         parent.didPushScope = true;
347     }
348     else if (is&lt;HTMLSlotElement&gt;(element) &amp;&amp; downcast&lt;HTMLSlotElement&gt;(element).assignedNodes()) {
349         pushEnclosingScope();
350         parent.didPushScope = true;
351     }
352 
353     m_parentStack.append(WTFMove(parent));
354 }
</pre>
<hr />
<pre>
418 
419 static bool hasLoadingStylesheet(const Style::Scope&amp; styleScope, const Element&amp; element, bool checkDescendants)
420 {
421     if (!styleScope.hasPendingSheetsInBody())
422         return false;
423     if (styleScope.hasPendingSheetInBody(element))
424         return true;
425     if (!checkDescendants)
426         return false;
427     for (auto&amp; descendant : descendantsOfType&lt;Element&gt;(element)) {
428         if (styleScope.hasPendingSheetInBody(descendant))
429             return true;
430     };
431     return false;
432 }
433 
434 static std::unique_ptr&lt;RenderStyle&gt; createInheritedDisplayContentsStyleIfNeeded(const RenderStyle&amp; parentElementStyle, const RenderStyle* parentBoxStyle)
435 {
436     if (parentElementStyle.display() != DisplayType::Contents)
437         return nullptr;
<span class="line-modified">438     if (parentBoxStyle &amp;&amp; !parentBoxStyle-&gt;inheritedNotEqual(&amp;parentElementStyle))</span>
439         return nullptr;
440     // Compute style for imaginary unstyled &lt;span&gt; around the text node.
441     auto style = RenderStyle::createPtr();
442     style-&gt;inheritFrom(parentElementStyle);
443     return style;
444 }
445 
446 void TreeResolver::resolveComposedTree()
447 {
448     ASSERT(m_parentStack.size() == 1);
449     ASSERT(m_scopeStack.size() == 1);
450 
451     auto descendants = composedTreeDescendants(m_document);
452     auto it = descendants.begin();
453     auto end = descendants.end();
454 
455     while (it != end) {
456         popParentsToDepth(it.depth());
457 
458         auto&amp; node = *it;
</pre>
<hr />
<pre>
536 
537 std::unique_ptr&lt;Update&gt; TreeResolver::resolve()
538 {
539     auto&amp; renderView = *m_document.renderView();
540 
541     Element* documentElement = m_document.documentElement();
542     if (!documentElement) {
543         m_document.styleScope().resolver();
544         return nullptr;
545     }
546     if (!documentElement-&gt;childNeedsStyleRecalc() &amp;&amp; !documentElement-&gt;needsStyleRecalc())
547         return nullptr;
548 
549     m_didSeePendingStylesheet = m_document.styleScope().hasPendingSheetsBeforeBody();
550 
551     m_update = makeUnique&lt;Update&gt;(m_document);
552     m_scopeStack.append(adoptRef(*new Scope(m_document)));
553     m_parentStack.append(Parent(m_document));
554 
555     // Pseudo element removal and similar may only work with these flags still set. Reset them after the style recalc.
<span class="line-modified">556     renderView.setUsesFirstLineRules(renderView.usesFirstLineRules() || scope().styleResolver.usesFirstLineRules());</span>
<span class="line-modified">557     renderView.setUsesFirstLetterRules(renderView.usesFirstLetterRules() || scope().styleResolver.usesFirstLetterRules());</span>
558 
559     resolveComposedTree();
560 
<span class="line-modified">561     renderView.setUsesFirstLineRules(scope().styleResolver.usesFirstLineRules());</span>
<span class="line-modified">562     renderView.setUsesFirstLetterRules(scope().styleResolver.usesFirstLetterRules());</span>
563 
564     ASSERT(m_scopeStack.size() == 1);
565     ASSERT(m_parentStack.size() == 1);
566     m_parentStack.clear();
567     popScope();
568 
569     if (m_update-&gt;roots().isEmpty())
570         return { };
571 
572     return WTFMove(m_update);
573 }
574 
575 static Vector&lt;Function&lt;void ()&gt;&gt;&amp; postResolutionCallbackQueue()
576 {
577     static NeverDestroyed&lt;Vector&lt;Function&lt;void ()&gt;&gt;&gt; vector;
578     return vector;
579 }
580 
581 static Vector&lt;RefPtr&lt;Frame&gt;&gt;&amp; memoryCacheClientCallsResumeQueue()
582 {
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;ComposedTreeIterator.h&quot;
 33 #include &quot;DocumentTimeline.h&quot;
 34 #include &quot;ElementIterator.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;HTMLBodyElement.h&quot;
 37 #include &quot;HTMLMeterElement.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLProgressElement.h&quot;
 40 #include &quot;HTMLSlotElement.h&quot;
 41 #include &quot;LoaderStrategy.h&quot;
 42 #include &quot;NodeRenderStyle.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PlatformStrategies.h&quot;
 45 #include &quot;Quirks.h&quot;
 46 #include &quot;RenderElement.h&quot;
 47 #include &quot;RenderStyle.h&quot;
 48 #include &quot;RenderView.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;Settings.h&quot;
 51 #include &quot;ShadowRoot.h&quot;
<span class="line-added"> 52 #include &quot;StyleAdjuster.h&quot;</span>
 53 #include &quot;StyleFontSizeFunctions.h&quot;
 54 #include &quot;StyleResolver.h&quot;
 55 #include &quot;StyleScope.h&quot;
 56 #include &quot;Text.h&quot;
 57 
 58 namespace WebCore {
 59 
 60 namespace Style {
 61 
<span class="line-added"> 62 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(TreeResolverScope);</span>
<span class="line-added"> 63 </span>
 64 TreeResolver::TreeResolver(Document&amp; document)
 65     : m_document(document)
 66 {
 67 }
 68 
 69 TreeResolver::~TreeResolver() = default;
 70 
 71 TreeResolver::Scope::Scope(Document&amp; document)
<span class="line-modified"> 72     : resolver(document.styleScope().resolver())</span>
<span class="line-modified"> 73     , sharingResolver(document, resolver.ruleSets(), selectorFilter)</span>
 74 {
 75     document.setIsResolvingTreeStyle(true);
 76 }
 77 
 78 TreeResolver::Scope::Scope(ShadowRoot&amp; shadowRoot, Scope&amp; enclosingScope)
<span class="line-modified"> 79     : resolver(shadowRoot.styleScope().resolver())</span>
<span class="line-modified"> 80     , sharingResolver(shadowRoot.documentScope(), resolver.ruleSets(), selectorFilter)</span>
 81     , shadowRoot(&amp;shadowRoot)
 82     , enclosingScope(&amp;enclosingScope)
 83 {
<span class="line-modified"> 84     resolver.setOverrideDocumentElementStyle(enclosingScope.resolver.overrideDocumentElementStyle());</span>
 85 }
 86 
 87 TreeResolver::Scope::~Scope()
 88 {
 89     if (!shadowRoot)
<span class="line-modified"> 90         resolver.document().setIsResolvingTreeStyle(false);</span>
 91 
<span class="line-modified"> 92     resolver.setOverrideDocumentElementStyle(nullptr);</span>
 93 }
 94 
 95 TreeResolver::Parent::Parent(Document&amp; document)
 96     : element(nullptr)
 97     , style(*document.renderStyle())
 98 {
 99 }
100 
101 TreeResolver::Parent::Parent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
102     : element(&amp;element)
103     , style(style)
104     , change(change)
105     , descendantsToResolve(descendantsToResolve)
106 {
107 }
108 
109 void TreeResolver::pushScope(ShadowRoot&amp; shadowRoot)
110 {
111     m_scopeStack.append(adoptRef(*new Scope(shadowRoot, scope())));
112 }
</pre>
<hr />
<pre>
120 void TreeResolver::popScope()
121 {
122     return m_scopeStack.removeLast();
123 }
124 
125 std::unique_ptr&lt;RenderStyle&gt; TreeResolver::styleForElement(Element&amp; element, const RenderStyle&amp; inheritedStyle)
126 {
127     if (element.hasCustomStyleResolveCallbacks()) {
128         RenderStyle* shadowHostStyle = scope().shadowRoot ? m_update-&gt;elementStyle(*scope().shadowRoot-&gt;host()) : nullptr;
129         if (auto customStyle = element.resolveCustomStyle(inheritedStyle, shadowHostStyle)) {
130             if (customStyle-&gt;relations)
131                 commitRelations(WTFMove(customStyle-&gt;relations), *m_update);
132 
133             return WTFMove(customStyle-&gt;renderStyle);
134         }
135     }
136 
137     if (auto style = scope().sharingResolver.resolve(element, *m_update))
138         return style;
139 
<span class="line-modified">140     auto elementStyle = scope().resolver.styleForElement(element, &amp;inheritedStyle, parentBoxStyle(), RuleMatchingBehavior::MatchAllRules, &amp;scope().selectorFilter);</span>
141 
142     if (elementStyle.relations)
143         commitRelations(WTFMove(elementStyle.relations), *m_update);
144 
145     return WTFMove(elementStyle.renderStyle);
146 }
147 
148 static void resetStyleForNonRenderedDescendants(Element&amp; current)
149 {
150     for (auto&amp; child : childrenOfType&lt;Element&gt;(current)) {
151         if (child.needsStyleRecalc()) {
152             child.resetComputedStyle();
153             child.resetStyleRelations();
154             child.setHasValidStyle();
155         }
156 
157         if (child.childNeedsStyleRecalc())
158             resetStyleForNonRenderedDescendants(child);
159     }
160     current.clearChildNeedsStyleRecalc();
</pre>
<hr />
<pre>
181     case NoChange:
182         return DescendantsToResolve::None;
183     case NoInherit:
184         return DescendantsToResolve::ChildrenWithExplicitInherit;
185     case Inherit:
186         return DescendantsToResolve::Children;
187     case Detach:
188         return DescendantsToResolve::All;
189     };
190     ASSERT_NOT_REACHED();
191     return DescendantsToResolve::None;
192 };
193 
194 ElementUpdates TreeResolver::resolveElement(Element&amp; element)
195 {
196     if (m_didSeePendingStylesheet &amp;&amp; !element.renderer() &amp;&amp; !m_document.isIgnoringPendingStylesheets()) {
197         m_document.setHasNodesWithMissingStyle();
198         return { };
199     }
200 
<span class="line-added">201     if (!element.rendererIsEverNeeded())</span>
<span class="line-added">202         return { };</span>
<span class="line-added">203 </span>
204     auto newStyle = styleForElement(element, parent().style);
205 
206     if (!affectsRenderedSubtree(element, *newStyle))
207         return { };
208 
209     auto* existingStyle = element.renderOrDisplayContentsStyle();
210 
211     if (m_didSeePendingStylesheet &amp;&amp; (!existingStyle || existingStyle-&gt;isNotFinal())) {
212         newStyle-&gt;setIsNotFinal();
213         m_document.setHasNodesWithNonFinalStyle();
214     }
215 
216     auto update = createAnimatedElementUpdate(WTFMove(newStyle), element, parent().change);
217     auto descendantsToResolve = computeDescendantsToResolve(update.change, element.styleValidity(), parent().descendantsToResolve);
218 
219     if (&amp;element == m_document.documentElement()) {
220         m_documentElementStyle = RenderStyle::clonePtr(*update.style);
<span class="line-modified">221         scope().resolver.setOverrideDocumentElementStyle(m_documentElementStyle.get());</span>
222 
223         if (update.change != NoChange &amp;&amp; existingStyle &amp;&amp; existingStyle-&gt;computedFontPixelSize() != update.style-&gt;computedFontPixelSize()) {
224             // &quot;rem&quot; units are relative to the document element&#39;s font size so we need to recompute everything.
225             // In practice this is rare.
<span class="line-modified">226             scope().resolver.invalidateMatchedDeclarationsCache();</span>
227             descendantsToResolve = DescendantsToResolve::All;
228         }
229     }
230 
231     // This is needed for resolving color:-webkit-text for subsequent elements.
232     // FIXME: We shouldn&#39;t mutate document when resolving style.
233     if (&amp;element == m_document.body())
234         m_document.setTextColor(update.style-&gt;visitedDependentColor(CSSPropertyColor));
235 
236     // FIXME: These elements should not change renderer based on appearance property.
237     if (element.hasTagName(HTMLNames::meterTag) || is&lt;HTMLProgressElement&gt;(element)) {
238         if (existingStyle &amp;&amp; update.style-&gt;appearance() != existingStyle-&gt;appearance()) {
239             update.change = Detach;
240             descendantsToResolve = DescendantsToResolve::All;
241         }
242     }
243 
244     auto beforeUpdate = resolvePseudoStyle(element, update, PseudoId::Before);
245     auto afterUpdate = resolvePseudoStyle(element, update, PseudoId::After);
246 
247 #if ENABLE(POINTER_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
248     // FIXME: Track this exactly.
249     if (update.style-&gt;touchActions() != TouchAction::Auto &amp;&amp; !m_document.quirks().shouldDisablePointerEventsQuirk() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().pointerEventsEnabled())
250         m_document.setMayHaveElementsWithNonAutoTouchAction();
251 #endif
252 
253     return { WTFMove(update), descendantsToResolve, WTFMove(beforeUpdate), WTFMove(afterUpdate) };
254 }
255 
256 ElementUpdate TreeResolver::resolvePseudoStyle(Element&amp; element, const ElementUpdate&amp; elementUpdate, PseudoId pseudoId)
257 {
258     if (elementUpdate.style-&gt;display() == DisplayType::None)
259         return { };
260     if (!elementUpdate.style-&gt;hasPseudoStyle(pseudoId))
261         return { };
262 
<span class="line-modified">263     auto pseudoStyle = scope().resolver.pseudoStyleForElement(element, { pseudoId }, *elementUpdate.style, parentBoxStyleForPseudo(elementUpdate), &amp;scope().selectorFilter);</span>
264     if (!pseudoElementRendererIsNeeded(pseudoStyle.get()))
265         return { };
266 
267     PseudoElement* pseudoElement = pseudoId == PseudoId::Before ? element.beforePseudoElement() : element.afterPseudoElement();
268     if (!pseudoElement) {
269         auto newPseudoElement = PseudoElement::create(element, pseudoId);
270         pseudoElement = newPseudoElement.ptr();
271         if (pseudoId == PseudoId::Before)
272             element.setBeforePseudoElement(WTFMove(newPseudoElement));
273         else
274             element.setAfterPseudoElement(WTFMove(newPseudoElement));
275     }
276 
277     return createAnimatedElementUpdate(WTFMove(pseudoStyle), *pseudoElement, elementUpdate.change);
278 }
279 
280 const RenderStyle* TreeResolver::parentBoxStyle() const
281 {
282     // &#39;display: contents&#39; doesn&#39;t generate boxes.
<span class="line-modified">283     for (auto i = m_parentStack.size(); i--;) {</span>
<span class="line-modified">284         auto&amp; parent = m_parentStack[i];</span>
285         if (parent.style.display() == DisplayType::None)
286             return nullptr;
287         if (parent.style.display() != DisplayType::Contents)
288             return &amp;parent.style;
289     }
290     ASSERT_NOT_REACHED();
291     return nullptr;
292 }
293 
<span class="line-added">294 const RenderStyle* TreeResolver::parentBoxStyleForPseudo(const ElementUpdate&amp; elementUpdate) const</span>
<span class="line-added">295 {</span>
<span class="line-added">296     switch (elementUpdate.style-&gt;display()) {</span>
<span class="line-added">297     case DisplayType::None:</span>
<span class="line-added">298         return nullptr;</span>
<span class="line-added">299     case DisplayType::Contents:</span>
<span class="line-added">300         return parentBoxStyle();</span>
<span class="line-added">301     default:</span>
<span class="line-added">302         return elementUpdate.style.get();</span>
<span class="line-added">303     }</span>
<span class="line-added">304 }</span>
<span class="line-added">305 </span>
306 ElementUpdate TreeResolver::createAnimatedElementUpdate(std::unique_ptr&lt;RenderStyle&gt; newStyle, Element&amp; element, Change parentChange)
307 {
308     auto* oldStyle = element.renderOrDisplayContentsStyle();
309 
<span class="line-modified">310     OptionSet&lt;AnimationImpact&gt; animationImpact;</span>
311 
312     // New code path for CSS Animations and CSS Transitions.
313     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
314         // First, we need to make sure that any new CSS animation occuring on this element has a matching WebAnimation
315         // on the document timeline. Note that we get timeline() on the Document here because we need a timeline created
316         // in case no Web Animations have been created through the JS API.
<span class="line-modified">317         if (element.document().backForwardCacheState() == Document::NotInBackForwardCache &amp;&amp; !element.document().renderView()-&gt;printing()) {</span>
318             if (oldStyle &amp;&amp; (oldStyle-&gt;hasTransitions() || newStyle-&gt;hasTransitions()))
319                 m_document.timeline().updateCSSTransitionsForElement(element, *oldStyle, *newStyle);
320 
321             if ((oldStyle &amp;&amp; oldStyle-&gt;hasAnimations()) || newStyle-&gt;hasAnimations())
322                 m_document.timeline().updateCSSAnimationsForElement(element, oldStyle, *newStyle);
323         }
324     }
325 
<span class="line-modified">326     // Now we can update all Web animations, which will include CSS Animations as well</span>
<span class="line-modified">327     // as animations created via the JS API.</span>
<span class="line-modified">328     if (element.hasKeyframeEffects()) {</span>
329         auto animatedStyle = RenderStyle::clonePtr(*newStyle);
<span class="line-modified">330         animationImpact = element.applyKeyframeEffects(*animatedStyle);</span>
331         newStyle = WTFMove(animatedStyle);
332     }
333 
334     // Old code path for CSS Animations and CSS Transitions.
335     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
336         auto&amp; animationController = m_document.frame()-&gt;animation();
337 
338         auto animationUpdate = animationController.updateAnimations(element, *newStyle, oldStyle);
<span class="line-modified">339         animationImpact.add(animationUpdate.impact);</span>
340 
341         if (animationUpdate.style)
342             newStyle = WTFMove(animationUpdate.style);
343     }
344 
<span class="line-added">345     if (animationImpact)</span>
<span class="line-added">346         Adjuster::adjustAnimatedStyle(*newStyle, parentBoxStyle(), animationImpact);</span>
<span class="line-added">347 </span>
348     auto change = oldStyle ? determineChange(*oldStyle, *newStyle) : Detach;
349 
350     auto validity = element.styleValidity();
351     if (validity &gt;= Validity::SubtreeAndRenderersInvalid || parentChange == Detach)
352         change = Detach;
353 
<span class="line-modified">354     bool shouldRecompositeLayer = animationImpact.contains(AnimationImpact::RequiresRecomposite) || element.styleResolutionShouldRecompositeLayer();</span>

355     return { WTFMove(newStyle), change, shouldRecompositeLayer };
356 }
357 
358 void TreeResolver::pushParent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
359 {
360     scope().selectorFilter.pushParent(&amp;element);
361 
362     Parent parent(element, style, change, descendantsToResolve);
363 
364     if (auto* shadowRoot = element.shadowRoot()) {
365         pushScope(*shadowRoot);
366         parent.didPushScope = true;
367     }
368     else if (is&lt;HTMLSlotElement&gt;(element) &amp;&amp; downcast&lt;HTMLSlotElement&gt;(element).assignedNodes()) {
369         pushEnclosingScope();
370         parent.didPushScope = true;
371     }
372 
373     m_parentStack.append(WTFMove(parent));
374 }
</pre>
<hr />
<pre>
438 
439 static bool hasLoadingStylesheet(const Style::Scope&amp; styleScope, const Element&amp; element, bool checkDescendants)
440 {
441     if (!styleScope.hasPendingSheetsInBody())
442         return false;
443     if (styleScope.hasPendingSheetInBody(element))
444         return true;
445     if (!checkDescendants)
446         return false;
447     for (auto&amp; descendant : descendantsOfType&lt;Element&gt;(element)) {
448         if (styleScope.hasPendingSheetInBody(descendant))
449             return true;
450     };
451     return false;
452 }
453 
454 static std::unique_ptr&lt;RenderStyle&gt; createInheritedDisplayContentsStyleIfNeeded(const RenderStyle&amp; parentElementStyle, const RenderStyle* parentBoxStyle)
455 {
456     if (parentElementStyle.display() != DisplayType::Contents)
457         return nullptr;
<span class="line-modified">458     if (parentBoxStyle &amp;&amp; parentBoxStyle-&gt;inheritedEqual(parentElementStyle))</span>
459         return nullptr;
460     // Compute style for imaginary unstyled &lt;span&gt; around the text node.
461     auto style = RenderStyle::createPtr();
462     style-&gt;inheritFrom(parentElementStyle);
463     return style;
464 }
465 
466 void TreeResolver::resolveComposedTree()
467 {
468     ASSERT(m_parentStack.size() == 1);
469     ASSERT(m_scopeStack.size() == 1);
470 
471     auto descendants = composedTreeDescendants(m_document);
472     auto it = descendants.begin();
473     auto end = descendants.end();
474 
475     while (it != end) {
476         popParentsToDepth(it.depth());
477 
478         auto&amp; node = *it;
</pre>
<hr />
<pre>
556 
557 std::unique_ptr&lt;Update&gt; TreeResolver::resolve()
558 {
559     auto&amp; renderView = *m_document.renderView();
560 
561     Element* documentElement = m_document.documentElement();
562     if (!documentElement) {
563         m_document.styleScope().resolver();
564         return nullptr;
565     }
566     if (!documentElement-&gt;childNeedsStyleRecalc() &amp;&amp; !documentElement-&gt;needsStyleRecalc())
567         return nullptr;
568 
569     m_didSeePendingStylesheet = m_document.styleScope().hasPendingSheetsBeforeBody();
570 
571     m_update = makeUnique&lt;Update&gt;(m_document);
572     m_scopeStack.append(adoptRef(*new Scope(m_document)));
573     m_parentStack.append(Parent(m_document));
574 
575     // Pseudo element removal and similar may only work with these flags still set. Reset them after the style recalc.
<span class="line-modified">576     renderView.setUsesFirstLineRules(renderView.usesFirstLineRules() || scope().resolver.usesFirstLineRules());</span>
<span class="line-modified">577     renderView.setUsesFirstLetterRules(renderView.usesFirstLetterRules() || scope().resolver.usesFirstLetterRules());</span>
578 
579     resolveComposedTree();
580 
<span class="line-modified">581     renderView.setUsesFirstLineRules(scope().resolver.usesFirstLineRules());</span>
<span class="line-modified">582     renderView.setUsesFirstLetterRules(scope().resolver.usesFirstLetterRules());</span>
583 
584     ASSERT(m_scopeStack.size() == 1);
585     ASSERT(m_parentStack.size() == 1);
586     m_parentStack.clear();
587     popScope();
588 
589     if (m_update-&gt;roots().isEmpty())
590         return { };
591 
592     return WTFMove(m_update);
593 }
594 
595 static Vector&lt;Function&lt;void ()&gt;&gt;&amp; postResolutionCallbackQueue()
596 {
597     static NeverDestroyed&lt;Vector&lt;Function&lt;void ()&gt;&gt;&gt; vector;
598     return vector;
599 }
600 
601 static Vector&lt;RefPtr&lt;Frame&gt;&gt;&amp; memoryCacheClientCallsResumeQueue()
602 {
</pre>
</td>
</tr>
</table>
<center><a href="StyleSharingResolver.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleTreeResolver.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
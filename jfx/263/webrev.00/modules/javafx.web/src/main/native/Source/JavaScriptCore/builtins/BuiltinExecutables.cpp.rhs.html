<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BuiltinExecutables.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;Parser.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 
 35 namespace JSC {
 36 
 37 BuiltinExecutables::BuiltinExecutables(VM&amp; vm)
 38     : m_vm(vm)
 39     , m_combinedSourceProvider(StringSourceProvider::create(StringImpl::createFromLiteral(s_JSCCombinedCode, s_JSCCombinedCodeLength), { }, URL()))
 40 {
 41 }
 42 
 43 SourceCode BuiltinExecutables::defaultConstructorSourceCode(ConstructorKind constructorKind)
 44 {
 45     switch (constructorKind) {
 46     case ConstructorKind::None:
<a name="1" id="anc1"></a><span class="line-added"> 47     case ConstructorKind::Naked:</span>
 48         break;
 49     case ConstructorKind::Base: {
 50         static NeverDestroyed&lt;const String&gt; baseConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function () { })&quot;));
 51         return makeSource(baseConstructorCode, { });
 52     }
 53     case ConstructorKind::Extends: {
 54         static NeverDestroyed&lt;const String&gt; derivedConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function (...args) { super(...args); })&quot;));
 55         return makeSource(derivedConstructorCode, { });
 56     }
 57     }
 58     RELEASE_ASSERT_NOT_REACHED();
 59     return SourceCode();
 60 }
 61 
<a name="2" id="anc2"></a><span class="line-modified"> 62 UnlinkedFunctionExecutable* BuiltinExecutables::createDefaultConstructor(ConstructorKind constructorKind, const Identifier&amp; name, NeedsClassFieldInitializer needsClassFieldInitializer)</span>
 63 {
 64     switch (constructorKind) {
 65     case ConstructorKind::None:
<a name="3" id="anc3"></a><span class="line-added"> 66     case ConstructorKind::Naked:</span>
 67         break;
 68     case ConstructorKind::Base:
 69     case ConstructorKind::Extends:
<a name="4" id="anc4"></a><span class="line-modified"> 70         return createExecutable(m_vm, defaultConstructorSourceCode(constructorKind), name, constructorKind, ConstructAbility::CanConstruct, needsClassFieldInitializer);</span>
 71     }
 72     ASSERT_NOT_REACHED();
 73     return nullptr;
 74 }
 75 
<a name="5" id="anc5"></a><span class="line-modified"> 76 UnlinkedFunctionExecutable* BuiltinExecutables::createBuiltinExecutable(const SourceCode&amp; code, const Identifier&amp; name, ConstructorKind constructorKind, ConstructAbility constructAbility)</span>
 77 {
<a name="6" id="anc6"></a><span class="line-modified"> 78     return createExecutable(m_vm, code, name, constructorKind, constructAbility, NeedsClassFieldInitializer::No);</span>
 79 }
 80 
<a name="7" id="anc7"></a><span class="line-modified"> 81 UnlinkedFunctionExecutable* BuiltinExecutables::createExecutable(VM&amp; vm, const SourceCode&amp; source, const Identifier&amp; name, ConstructorKind constructorKind, ConstructAbility constructAbility, NeedsClassFieldInitializer needsClassFieldInitializer)</span>





 82 {
 83     // FIXME: Can we just make MetaData computation be constexpr and have the compiler do this for us?
 84     // https://bugs.webkit.org/show_bug.cgi?id=193272
 85     // Someone should get mad at me for writing this code. But, it prevents us from recursing into
 86     // the parser, and hence, from throwing stack overflow when parsing a builtin.
 87     StringView view = source.view();
 88     RELEASE_ASSERT(!view.isNull());
 89     RELEASE_ASSERT(view.is8Bit());
 90     auto* characters = view.characters8();
 91     const char* regularFunctionBegin = &quot;(function (&quot;;
 92     const char* asyncFunctionBegin = &quot;(async function (&quot;;
 93     RELEASE_ASSERT(view.length() &gt;= strlen(&quot;(function (){})&quot;));
 94     bool isAsyncFunction = view.length() &gt;= strlen(&quot;(async function (){})&quot;) &amp;&amp; !memcmp(characters, asyncFunctionBegin, strlen(asyncFunctionBegin));
 95     RELEASE_ASSERT(isAsyncFunction || !memcmp(characters, regularFunctionBegin, strlen(regularFunctionBegin)));
 96 
 97     unsigned asyncOffset = isAsyncFunction ? strlen(&quot;async &quot;) : 0;
 98     unsigned parametersStart = strlen(&quot;function (&quot;) + asyncOffset;
 99     unsigned startColumn = parametersStart;
100     int functionKeywordStart = strlen(&quot;(&quot;) + asyncOffset;
101     int functionNameStart = parametersStart;
102     bool isInStrictContext = false;
103     bool isArrowFunctionBodyExpression = false;
104 
105     unsigned parameterCount;
106     {
107         unsigned i = parametersStart + 1;
108         unsigned commas = 0;
109         bool sawOneParam = false;
110         bool hasRestParam = false;
111         while (true) {
112             ASSERT(i &lt; view.length());
113             if (characters[i] == &#39;)&#39;)
114                 break;
115 
116             if (characters[i] == &#39;,&#39;)
117                 ++commas;
118             else if (!Lexer&lt;LChar&gt;::isWhiteSpace(characters[i]))
119                 sawOneParam = true;
120 
121             if (i + 2 &lt; view.length() &amp;&amp; characters[i] == &#39;.&#39; &amp;&amp; characters[i + 1] == &#39;.&#39; &amp;&amp; characters[i + 2] == &#39;.&#39;) {
122                 hasRestParam = true;
123                 i += 2;
124             }
125 
126             ++i;
127         }
128 
129         if (commas)
130             parameterCount = commas + 1;
131         else if (sawOneParam)
132             parameterCount = 1;
133         else
134             parameterCount = 0;
135 
136         if (hasRestParam) {
137             RELEASE_ASSERT(parameterCount);
138             --parameterCount;
139         }
140     }
141 
142     unsigned lineCount = 0;
143     unsigned endColumn = 0;
144     unsigned offsetOfLastNewline = 0;
145     Optional&lt;unsigned&gt; offsetOfSecondToLastNewline;
146     for (unsigned i = 0; i &lt; view.length(); ++i) {
147         if (characters[i] == &#39;\n&#39;) {
148             if (lineCount)
149                 offsetOfSecondToLastNewline = offsetOfLastNewline;
150             ++lineCount;
151             endColumn = 0;
152             offsetOfLastNewline = i;
153         } else
154             ++endColumn;
155 
156         if (!isInStrictContext &amp;&amp; (characters[i] == &#39;&quot;&#39; || characters[i] == &#39;\&#39;&#39;)) {
157             const unsigned useStrictLength = strlen(&quot;use strict&quot;);
158             if (i + 1 + useStrictLength &lt; view.length()) {
159                 if (!memcmp(characters + i + 1, &quot;use strict&quot;, useStrictLength)) {
160                     isInStrictContext = true;
161                     i += 1 + useStrictLength;
162                 }
163             }
164         }
165     }
166 
167     unsigned positionBeforeLastNewlineLineStartOffset = offsetOfSecondToLastNewline ? *offsetOfSecondToLastNewline + 1 : 0;
168 
169     int closeBraceOffsetFromEnd = 1;
170     while (true) {
171         if (characters[view.length() - closeBraceOffsetFromEnd] == &#39;}&#39;)
172             break;
173         ++closeBraceOffsetFromEnd;
174     }
175 
176     JSTextPosition positionBeforeLastNewline;
177     positionBeforeLastNewline.line = lineCount;
178     positionBeforeLastNewline.offset = source.startOffset() + offsetOfLastNewline;
179     positionBeforeLastNewline.lineStartOffset = source.startOffset() + positionBeforeLastNewlineLineStartOffset;
180 
181     SourceCode newSource = source.subExpression(source.startOffset() + parametersStart, source.startOffset() + (view.length() - closeBraceOffsetFromEnd), 0, parametersStart);
<a name="8" id="anc8"></a><span class="line-modified">182     bool isBuiltinDefaultClassConstructor = constructorKind != ConstructorKind::None &amp;&amp; constructorKind != ConstructorKind::Naked;</span>
183     UnlinkedFunctionKind kind = isBuiltinDefaultClassConstructor ? UnlinkedNormalFunction : UnlinkedBuiltinFunction;
184 
185     SourceParseMode parseMode = isAsyncFunction ? SourceParseMode::AsyncFunctionMode : SourceParseMode::NormalFunctionMode;
186 
187     JSTokenLocation start;
188     start.line = -1;
189     start.lineStartOffset = std::numeric_limits&lt;unsigned&gt;::max();
190     start.startOffset = source.startOffset() + parametersStart;
191     start.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
192 
193     JSTokenLocation end;
194     end.line = 1;
195     end.lineStartOffset = source.startOffset();
196     end.startOffset = source.startOffset() + strlen(&quot;(&quot;) + asyncOffset;
197     end.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
198 
199     FunctionMetadataNode metadata(
200         start, end, startColumn, endColumn, source.startOffset() + functionKeywordStart, source.startOffset() + functionNameStart, source.startOffset() + parametersStart,
201         isInStrictContext, constructorKind, constructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded,
202         parameterCount, parseMode, isArrowFunctionBodyExpression);
203 
204     metadata.finishParsing(newSource, Identifier(), FunctionMode::FunctionExpression);
205     metadata.overrideName(name);
206     metadata.setEndPosition(positionBeforeLastNewline);
207 
<a name="9" id="anc9"></a><span class="line-modified">208     if (UNLIKELY(ASSERT_ENABLED || Options::validateBytecode())) {</span>
209         JSTextPosition positionBeforeLastNewlineFromParser;
210         ParserError error;
211         JSParserBuiltinMode builtinMode = isBuiltinDefaultClassConstructor ? JSParserBuiltinMode::NotBuiltin : JSParserBuiltinMode::Builtin;
212         std::unique_ptr&lt;ProgramNode&gt; program = parse&lt;ProgramNode&gt;(
213             vm, source, Identifier(), builtinMode,
214             JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, error,
215             &amp;positionBeforeLastNewlineFromParser, constructorKind);
216 
217         if (program) {
218             StatementNode* exprStatement = program-&gt;singleStatement();
219             RELEASE_ASSERT(exprStatement);
220             RELEASE_ASSERT(exprStatement-&gt;isExprStatement());
221             ExpressionNode* funcExpr = static_cast&lt;ExprStatementNode*&gt;(exprStatement)-&gt;expr();
222             RELEASE_ASSERT(funcExpr);
223             RELEASE_ASSERT(funcExpr-&gt;isFuncExprNode());
224             FunctionMetadataNode* metadataFromParser = static_cast&lt;FuncExprNode*&gt;(funcExpr)-&gt;metadata();
225             RELEASE_ASSERT(!program-&gt;hasCapturedVariables());
226 
227             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
228             RELEASE_ASSERT(metadataFromParser);
229             RELEASE_ASSERT(metadataFromParser-&gt;ident().isNull());
230 
231             // This function assumes an input string that would result in a single anonymous function expression.
232             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
233             RELEASE_ASSERT(metadataFromParser);
234             metadataFromParser-&gt;overrideName(name);
235             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
236             if (metadata != *metadataFromParser || positionBeforeLastNewlineFromParser != positionBeforeLastNewline) {
237                 dataLogLn(&quot;Expected Metadata:\n&quot;, metadata);
238                 dataLogLn(&quot;Metadata from parser:\n&quot;, *metadataFromParser);
239                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.line &quot;, positionBeforeLastNewlineFromParser.line);
240                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.offset &quot;, positionBeforeLastNewlineFromParser.offset);
241                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.lineStartOffset &quot;, positionBeforeLastNewlineFromParser.lineStartOffset);
242                 dataLogLn(&quot;positionBeforeLastNewline.line &quot;, positionBeforeLastNewline.line);
243                 dataLogLn(&quot;positionBeforeLastNewline.offset &quot;, positionBeforeLastNewline.offset);
244                 dataLogLn(&quot;positionBeforeLastNewline.lineStartOffset &quot;, positionBeforeLastNewline.lineStartOffset);
245                 WTFLogAlways(&quot;Metadata of parser and hand rolled parser don&#39;t match\n&quot;);
246                 CRASH();
247             }
248         } else {
249             RELEASE_ASSERT(error.isValid());
250             RELEASE_ASSERT(error.type() == ParserError::StackOverflow);
251         }
252     }
253 
<a name="10" id="anc10"></a><span class="line-modified">254     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, &amp;metadata, kind, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, needsClassFieldInitializer, isBuiltinDefaultClassConstructor);</span>
255     return functionExecutable;
256 }
257 
258 void BuiltinExecutables::finalizeUnconditionally()
259 {
260     for (auto*&amp; unlinkedExecutable : m_unlinkedExecutables) {
261         if (unlinkedExecutable &amp;&amp; !m_vm.heap.isMarked(unlinkedExecutable))
262             unlinkedExecutable = nullptr;
263     }
264 }
265 
266 #define DEFINE_BUILTIN_EXECUTABLES(name, functionName, overrideName, length) \
267 SourceCode BuiltinExecutables::name##Source() \
268 {\
269     return SourceCode { m_combinedSourceProvider.copyRef(), static_cast&lt;int&gt;(s_##name - s_JSCCombinedCode), static_cast&lt;int&gt;((s_##name - s_JSCCombinedCode) + length), 1, 1 };\
270 }\
271 \
272 UnlinkedFunctionExecutable* BuiltinExecutables::name##Executable() \
273 {\
274     unsigned index = static_cast&lt;unsigned&gt;(BuiltinCodeIndex::name);\
275     if (!m_unlinkedExecutables[index]) {\
276         Identifier executableName = m_vm.propertyNames-&gt;builtinNames().functionName##PublicName();\
277         if (overrideName)\
278             executableName = Identifier::fromString(m_vm, overrideName);\
<a name="11" id="anc11"></a><span class="line-modified">279         m_unlinkedExecutables[index] = createBuiltinExecutable(name##Source(), executableName, s_##name##ConstructorKind, s_##name##ConstructAbility);\</span>
280     }\
281     return m_unlinkedExecutables[index];\
282 }
283 JSC_FOREACH_BUILTIN_CODE(DEFINE_BUILTIN_EXECUTABLES)
284 #undef DEFINE_BUILTIN_EXECUTABLES
285 
286 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
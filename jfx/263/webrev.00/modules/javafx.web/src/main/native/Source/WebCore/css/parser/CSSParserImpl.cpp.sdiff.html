<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserFastPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 68 CSSParserImpl::CSSParserImpl(CSSDeferredParser&amp; deferredParser)
 69     : m_context(deferredParser.context())
 70     , m_styleSheet(deferredParser.styleSheet())
 71     , m_deferredParser(&amp;deferredParser)
 72 {
 73 }
 74 
 75 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, const String&amp; string, StyleSheetContents* styleSheet, CSSParserObserverWrapper* wrapper, CSSParser::RuleParsing ruleParsing)
 76     : m_context(context)
 77     , m_styleSheet(styleSheet)
 78     , m_observerWrapper(wrapper)
 79 {
 80     m_tokenizer = wrapper ? makeUnique&lt;CSSTokenizer&gt;(string, *wrapper) : makeUnique&lt;CSSTokenizer&gt;(string);
 81     if (context.deferredCSSParserEnabled &amp;&amp; !wrapper &amp;&amp; styleSheet &amp;&amp; ruleParsing == CSSParser::RuleParsing::Deferred)
 82         m_deferredParser = CSSDeferredParser::create(context, string, *styleSheet);
 83 }
 84 
 85 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
 86 {
 87     CSSParserImpl parser(context, string);
<span class="line-modified"> 88     StyleRule::Type ruleType = StyleRule::Style;</span>
<span class="line-removed"> 89 #if ENABLE(CSS_DEVICE_ADAPTATION)</span>
<span class="line-removed"> 90     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)</span>
<span class="line-removed"> 91         ruleType = StyleRule::Viewport;</span>
<span class="line-removed"> 92 #endif</span>
 93     parser.consumeDeclarationValue(parser.tokenizer()-&gt;tokenRange(), propertyID, important, ruleType);
 94     if (parser.m_parsedProperties.isEmpty())
 95         return CSSParser::ParseResult::Error;
 96     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 97 }
 98 
 99 CSSParser::ParseResult CSSParserImpl::parseCustomPropertyValue(MutableStyleProperties* declaration, const AtomString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)
100 {
101     CSSParserImpl parser(context, string);
102     parser.consumeCustomPropertyValue(parser.tokenizer()-&gt;tokenRange(), propertyName, important);
103     if (parser.m_parsedProperties.isEmpty())
104         return CSSParser::ParseResult::Error;
105     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
106 }
107 
108 static inline void filterProperties(bool important, const ParsedPropertyVector&amp; input, ParsedPropertyVector&amp; output, size_t&amp; unusedEntries, std::bitset&lt;numCSSProperties&gt;&amp; seenProperties, HashSet&lt;AtomString&gt;&amp; seenCustomProperties)
109 {
110     // Add properties in reverse order so that highest priority definitions are reached first. Duplicate definitions can then be ignored when found.
111     for (size_t i = input.size(); i--; ) {
112         const CSSProperty&amp; property = input[i];
</pre>
<hr />
<pre>
145 {
146     std::bitset&lt;numCSSProperties&gt; seenProperties;
147     size_t unusedEntries = parsedProperties.size();
148     ParsedPropertyVector results(unusedEntries);
149     HashSet&lt;AtomString&gt; seenCustomProperties;
150 
151     filterProperties(true, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
152     filterProperties(false, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
153 
154     Ref&lt;ImmutableStyleProperties&gt; result = ImmutableStyleProperties::create(results.data() + unusedEntries, results.size() - unusedEntries, mode);
155     parsedProperties.clear();
156     return result;
157 }
158 
159 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
160 {
161     CSSParserContext context(element-&gt;document());
162     context.mode = strictToCSSParserMode(element-&gt;isHTMLElement() &amp;&amp; !element-&gt;document().inQuirksMode());
163 
164     CSSParserImpl parser(context, string);
<span class="line-modified">165     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRule::Style);</span>
166     return createStyleProperties(parser.m_parsedProperties, context.mode);
167 }
168 
169 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
170 {
171     if (!styleSheet) {
172         ParsedPropertyVector properties;
173         return createStyleProperties(properties, context.mode);
174     }
175     CSSParserImpl parser(context, styleSheet);
<span class="line-modified">176     parser.consumeDeclarationList(tokenRange, StyleRule::Style);</span>
177     return createStyleProperties(parser.m_parsedProperties, context.mode);
178 }
179 
180 void CSSParserImpl::parseDeferredRuleList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
181 {
182     if (!deferredParser.styleSheet())
183         return;
184     CSSParserImpl parser(deferredParser);
185     parser.consumeRuleList(tokenRange, RegularRuleList, [&amp;childRules](const RefPtr&lt;StyleRuleBase&gt;&amp; rule) {
186         childRules.append(rule);
187     });
188     childRules.shrinkToFit();
189 }
190 
191 void CSSParserImpl::parseDeferredKeyframeList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, StyleRuleKeyframes&amp; keyframeRule)
192 {
193     if (!deferredParser.styleSheet())
194         return;
195     CSSParserImpl parser(deferredParser);
196     parser.consumeRuleList(tokenRange, KeyframesRuleList, [&amp;keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
197         keyframeRule.parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
198     });
199 }
200 
201 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String&amp; string, const CSSParserContext&amp; context)
202 {
203     CSSParserImpl parser(context, string);
<span class="line-modified">204     StyleRule::Type ruleType = StyleRule::Style;</span>
<span class="line-removed">205 #if ENABLE(CSS_DEVICE_ADAPTATION)</span>
<span class="line-removed">206     if (declaration-&gt;cssParserMode() == CSSViewportRuleMode)</span>
<span class="line-removed">207         ruleType = StyleRule::Viewport;</span>
<span class="line-removed">208 #endif</span>
209     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), ruleType);
210     if (parser.m_parsedProperties.isEmpty())
211         return false;
212 
213     std::bitset&lt;numCSSProperties&gt; seenProperties;
214     size_t unusedEntries = parser.m_parsedProperties.size();
215     ParsedPropertyVector results(unusedEntries);
216     HashSet&lt;AtomString&gt; seenCustomProperties;
217     filterProperties(true, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
218     filterProperties(false, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
219     if (unusedEntries)
220         results.remove(0, unusedEntries);
221     return declaration-&gt;addParsedProperties(results);
222 }
223 
224 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::parseRule(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, AllowedRulesType allowedRules)
225 {
226     CSSParserImpl parser(context, string, styleSheet);
227     CSSParserTokenRange range = parser.tokenizer()-&gt;tokenRange();
228     range.consumeWhitespace();
</pre>
<hr />
<pre>
289             selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePagePseudoSelector(pseudo));
290             if (!selector || selector-&gt;match() != CSSSelector::PagePseudoClass)
291                 return CSSSelectorList();
292         }
293         if (!typeSelector.isNull())
294             selector-&gt;prependTagSelector(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
295     }
296 
297     selector-&gt;setForPage();
298     return CSSSelectorList { Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(selector)) };
299 }
300 
301 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::parseKeyframeKeyList(const String&amp; keyList)
302 {
303     return consumeKeyframeKeyList(CSSTokenizer(keyList).tokenRange());
304 }
305 
306 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange&amp; range)
307 {
308     ASSERT(m_parsedProperties.isEmpty());
<span class="line-modified">309     consumeDeclaration(range, StyleRule::Style);</span>
310     bool result = !m_parsedProperties.isEmpty();
311     m_parsedProperties.clear();
312     return result;
313 }
314 
315 void CSSParserImpl::parseDeclarationListForInspector(const String&amp; declaration, const CSSParserContext&amp; context, CSSParserObserver&amp; observer)
316 {
317     CSSParserObserverWrapper wrapper(observer);
318     CSSParserImpl parser(context, declaration, nullptr, &amp;wrapper);
<span class="line-modified">319     observer.startRuleHeader(StyleRule::Style, 0);</span>
320     observer.endRuleHeader(1);
<span class="line-modified">321     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRule::Style);</span>
322 }
323 
324 void CSSParserImpl::parseStyleSheetForInspector(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, CSSParserObserver&amp; observer)
325 {
326     CSSParserObserverWrapper wrapper(observer);
327     CSSParserImpl parser(context, string, styleSheet, &amp;wrapper);
328     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
329         if (rule-&gt;isCharsetRule())
330             return;
331         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
332     });
333     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
334 }
335 
336 static CSSParserImpl::AllowedRulesType computeNewAllowedRules(CSSParserImpl::AllowedRulesType allowedRules, StyleRuleBase* rule)
337 {
338     if (!rule || allowedRules == CSSParserImpl::KeyframeRules || allowedRules == CSSParserImpl::NoRules)
339         return allowedRules;
340     ASSERT(allowedRules &lt;= CSSParserImpl::RegularRules);
341     if (rule-&gt;isCharsetRule() || rule-&gt;isImportRule())
</pre>
<hr />
<pre>
493         return AtomString();
494     return uri.value().toAtomString();
495 }
496 
497 RefPtr&lt;StyleRuleCharset&gt; CSSParserImpl::consumeCharsetRule(CSSParserTokenRange prelude)
498 {
499     const CSSParserToken&amp; string = prelude.consumeIncludingWhitespace();
500     if (string.type() != StringToken || !prelude.atEnd())
501         return nullptr; // Parse error, expected a single string
502     return StyleRuleCharset::create();
503 }
504 
505 RefPtr&lt;StyleRuleImport&gt; CSSParserImpl::consumeImportRule(CSSParserTokenRange prelude)
506 {
507     AtomString uri(consumeStringOrURI(prelude));
508     if (uri.isNull())
509         return nullptr; // Parse error, expected string or URI
510 
511     if (m_observerWrapper) {
512         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">513         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Import, m_observerWrapper-&gt;startOffset(prelude));</span>
514         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
515         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
516         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
517     }
518 
519     return StyleRuleImport::create(uri, MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull());
520 }
521 
522 RefPtr&lt;StyleRuleNamespace&gt; CSSParserImpl::consumeNamespaceRule(CSSParserTokenRange prelude)
523 {
524     AtomString namespacePrefix;
525     if (prelude.peek().type() == IdentToken)
526         namespacePrefix = prelude.consumeIncludingWhitespace().value().toAtomString();
527 
528     AtomString uri(consumeStringOrURI(prelude));
529     if (uri.isNull() || !prelude.atEnd())
530         return nullptr; // Parse error, expected string or URI
531 
532     return StyleRuleNamespace::create(namespacePrefix, uri);
533 }
534 
535 RefPtr&lt;StyleRuleMedia&gt; CSSParserImpl::consumeMediaRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
536 {
537     if (m_deferredParser)
538         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
539 
540     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
541 
542     if (m_observerWrapper) {
<span class="line-modified">543         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Media, m_observerWrapper-&gt;startOffset(prelude));</span>
544         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
545         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
546     }
547 
548     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
549         rules.append(rule);
550     });
551     rules.shrinkToFit();
552 
553     if (m_observerWrapper)
554         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
555 
556     return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(), rules);
557 }
558 
559 RefPtr&lt;StyleRuleSupports&gt; CSSParserImpl::consumeSupportsRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
560 {
561     CSSSupportsParser::SupportsResult supported = CSSSupportsParser::supportsCondition(prelude, *this, CSSSupportsParser::ForAtRule);
562     if (supported == CSSSupportsParser::Invalid)
563         return nullptr; // Parse error, invalid @supports condition
564 
565     if (m_deferredParser)
566         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
567 
568     if (m_observerWrapper) {
<span class="line-modified">569         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Supports, m_observerWrapper-&gt;startOffset(prelude));</span>
570         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
571         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
572     }
573 
574     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
575     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
576         rules.append(rule);
577     });
578     rules.shrinkToFit();
579 
580     if (m_observerWrapper)
581         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
582 
583     return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, rules);
584 }
585 
586 #if ENABLE(CSS_DEVICE_ADAPTATION)
587 RefPtr&lt;StyleRuleViewport&gt; CSSParserImpl::consumeViewportRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
588 {
589     if (!prelude.atEnd())
590         return nullptr; // Parser error; @viewport prelude should be empty
591 
592     if (m_observerWrapper) {
593         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">594         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Viewport, m_observerWrapper-&gt;startOffset(prelude));</span>
595         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
596         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
597         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
598     }
599 
600     consumeDeclarationList(block, StyleRule::Viewport);
601     return StyleRuleViewport::create(createStyleProperties(m_parsedProperties, CSSViewportRuleMode));
602 }
603 #endif
604 
605 RefPtr&lt;StyleRuleFontFace&gt; CSSParserImpl::consumeFontFaceRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
606 {
607     if (!prelude.atEnd())
608         return nullptr; // Parse error; @font-face prelude should be empty
609 
610     if (m_observerWrapper) {
611         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">612         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::FontFace, m_observerWrapper-&gt;startOffset(prelude));</span>
613         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
614         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
615         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
616     }
617 
<span class="line-modified">618     consumeDeclarationList(block, StyleRule::FontFace);</span>
619     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
620 }
621 
622 RefPtr&lt;StyleRuleKeyframes&gt; CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
623 {
624     CSSParserTokenRange rangeCopy = prelude; // For inspector callbacks
625     const CSSParserToken&amp; nameToken = prelude.consumeIncludingWhitespace();
626     if (!prelude.atEnd())
627         return nullptr; // Parse error; expected single non-whitespace token in @keyframes header
628 
629     String name;
630     if (nameToken.type() == IdentToken) {
631         name = nameToken.value().toString();
632     } else if (nameToken.type() == StringToken &amp;&amp; webkitPrefixed)
633         name = nameToken.value().toString();
634     else
635         return nullptr; // Parse error; expected ident token in @keyframes header
636 
637     if (m_deferredParser)
638         return StyleRuleKeyframes::create(name, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
639 
640     if (m_observerWrapper) {
<span class="line-modified">641         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Keyframes, m_observerWrapper-&gt;startOffset(rangeCopy));</span>
642         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
643         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
644         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
645     }
646 
647     RefPtr&lt;StyleRuleKeyframes&gt; keyframeRule = StyleRuleKeyframes::create(name);
648     consumeRuleList(block, KeyframesRuleList, [keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
649         keyframeRule-&gt;parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
650     });
651 
652     // FIXME-NEWPARSER: Find out why this is done. Behavior difference when prefixed?
653     // keyframeRule-&gt;setVendorPrefixed(webkitPrefixed);
654     return keyframeRule;
655 }
656 
657 RefPtr&lt;StyleRulePage&gt; CSSParserImpl::consumePageRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
658 {
659     CSSSelectorList selectorList = parsePageSelector(prelude, m_styleSheet.get());
660     if (!selectorList.isValid())
661         return nullptr; // Parse error, invalid @page selector
662 
663     if (m_observerWrapper) {
664         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">665         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Page, m_observerWrapper-&gt;startOffset(prelude));</span>
666         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
667     }
668 
<span class="line-modified">669     consumeDeclarationList(block, StyleRule::Style);</span>
670 
671     return StyleRulePage::create(createStyleProperties(m_parsedProperties, m_context.mode), WTFMove(selectorList));
672 }
673 
674 // FIXME-NEWPARSER: Support &quot;apply&quot;
675 /*void CSSParserImpl::consumeApplyRule(CSSParserTokenRange prelude)
676 {
677     const CSSParserToken&amp; ident = prelude.consumeIncludingWhitespace();
678     if (!prelude.atEnd() || !CSSVariableParser::isValidVariableName(ident))
679         return; // Parse error, expected a single custom property name
680     m_parsedProperties.append(CSSProperty(
681         CSSPropertyApplyAtRule,
682         *CSSCustomIdentValue::create(ident.value().toString())));
683 }
684 */
685 
686 RefPtr&lt;StyleRuleKeyframe&gt; CSSParserImpl::consumeKeyframeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
687 {
688     std::unique_ptr&lt;Vector&lt;double&gt;&gt; keyList = consumeKeyframeKeyList(prelude);
689     if (!keyList)
690         return nullptr;
691 
692     if (m_observerWrapper) {
<span class="line-modified">693         m_observerWrapper-&gt;observer().startRuleHeader(StyleRule::Keyframe, m_observerWrapper-&gt;startOffset(prelude));</span>
694         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
695     }
696 
<span class="line-modified">697     consumeDeclarationList(block, StyleRule::Keyframe);</span>
698     return StyleRuleKeyframe::create(WTFMove(keyList), createStyleProperties(m_parsedProperties, m_context.mode));
699 }
700 
701 static void observeSelectors(CSSParserObserverWrapper&amp; wrapper, CSSParserTokenRange selectors)
702 {
703     // This is easier than hooking into the CSSSelectorParser
704     selectors.consumeWhitespace();
705     CSSParserTokenRange originalRange = selectors;
<span class="line-modified">706     wrapper.observer().startRuleHeader(StyleRule::Style, wrapper.startOffset(originalRange));</span>
707 
708     while (!selectors.atEnd()) {
709         const CSSParserToken* selectorStart = &amp;selectors.peek();
710         while (!selectors.atEnd() &amp;&amp; selectors.peek().type() != CommaToken)
711             selectors.consumeComponentValue();
712         CSSParserTokenRange selector = selectors.makeSubRange(selectorStart, &amp;selectors.peek());
713         selectors.consumeIncludingWhitespace();
714 
715         wrapper.observer().observeSelector(wrapper.startOffset(selector), wrapper.endOffset(selector));
716     }
717 
718     wrapper.observer().endRuleHeader(wrapper.endOffset(originalRange));
719 }
720 
721 RefPtr&lt;StyleRule&gt; CSSParserImpl::consumeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
722 {
723     CSSSelectorList selectorList = CSSSelectorParser::parseSelector(prelude, m_context, m_styleSheet.get());
724     if (!selectorList.isValid())
725         return nullptr; // Parse error, invalid selector list
726 
727     if (m_observerWrapper)
728         observeSelectors(*m_observerWrapper, prelude);
729 
730     if (m_deferredParser) {
731         // If a rule is empty (i.e., only whitespace), don&#39;t bother using
732         // deferred parsing. This allows the empty rule optimization in ElementRuleCollector
733         // to continue to work. Note we don&#39;t have to consider CommentTokens, since those
734         // are stripped out.
735         CSSParserTokenRange blockCopy = block;
736         blockCopy.consumeWhitespace();
737         if (!blockCopy.atEnd()) {
738             return StyleRule::create(createDeferredStyleProperties(block), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
739         }
740     }
741 
<span class="line-modified">742     consumeDeclarationList(block, StyleRule::Style);</span>
743     return StyleRule::create(createStyleProperties(m_parsedProperties, m_context.mode), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
744 }
745 
<span class="line-modified">746 void CSSParserImpl::consumeDeclarationList(CSSParserTokenRange range, StyleRule::Type ruleType)</span>
747 {
748     ASSERT(m_parsedProperties.isEmpty());
749 
<span class="line-modified">750     bool useObserver = m_observerWrapper &amp;&amp; (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe);</span>
751     if (useObserver) {
752         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(range));
753         m_observerWrapper-&gt;skipCommentsBefore(range, true);
754     }
755 
756     while (!range.atEnd()) {
757         switch (range.peek().type()) {
758         case WhitespaceToken:
759         case SemicolonToken:
760             range.consume();
761             break;
762         case IdentToken: {
763             const CSSParserToken* declarationStart = &amp;range.peek();
764 
765             if (useObserver)
766                 m_observerWrapper-&gt;yieldCommentsBefore(range);
767 
768             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
769                 range.consumeComponentValue();
770 
771             consumeDeclaration(range.makeSubRange(declarationStart, &amp;range.peek()), ruleType);
772 
773             if (useObserver)
774                 m_observerWrapper-&gt;skipCommentsBefore(range, false);
775             break;
776         }
777         case AtKeywordToken: {
778             // FIXME-NEWPARSER: Support apply
<span class="line-modified">779             AllowedRulesType allowedRules = /* ruleType == StyleRule::Style &amp;&amp; RuntimeEnabledFeatures::cssApplyAtRulesEnabled() ? ApplyRules :*/ NoRules;</span>
780             RefPtr&lt;StyleRuleBase&gt; rule = consumeAtRule(range, allowedRules);
781             ASSERT_UNUSED(rule, !rule);
782             break;
783         }
784         default: // Parse error, unexpected token in declaration list
785             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
786                 range.consumeComponentValue();
787             break;
788         }
789     }
790 
791     // Yield remaining comments
792     if (useObserver) {
793         m_observerWrapper-&gt;yieldCommentsBefore(range);
794         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(range));
795     }
796 }
797 
<span class="line-modified">798 void CSSParserImpl::consumeDeclaration(CSSParserTokenRange range, StyleRule::Type ruleType)</span>
799 {
800     CSSParserTokenRange rangeCopy = range; // For inspector callbacks
801 
802     ASSERT(range.peek().type() == IdentToken);
803     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
804     CSSPropertyID propertyID = token.parseAsCSSPropertyID();
805     if (range.consume().type() != ColonToken)
806         return; // Parse error
807 
808     bool important = false;
809     const CSSParserToken* declarationValueEnd = range.end();
810     const CSSParserToken* last = range.end() - 1;
811     while (last-&gt;type() == WhitespaceToken)
812         --last;
813     if (last-&gt;type() == IdentToken &amp;&amp; equalIgnoringASCIICase(last-&gt;value(), &quot;important&quot;)) {
814         --last;
815         while (last-&gt;type() == WhitespaceToken)
816             --last;
817         if (last-&gt;type() == DelimiterToken &amp;&amp; last-&gt;delimiter() == &#39;!&#39;) {
818             important = true;
819             declarationValueEnd = last;
820         }
821     }
822 
823     size_t propertiesCount = m_parsedProperties.size();
824     if (propertyID == CSSPropertyInvalid &amp;&amp; CSSVariableParser::isValidVariableName(token)) {
825         AtomString variableName = token.value().toAtomString();
826         consumeCustomPropertyValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), variableName, important);
827     }
828 
<span class="line-modified">829     if (important &amp;&amp; (ruleType == StyleRule::FontFace || ruleType == StyleRule::Keyframe))</span>
830         return;
831 
832     if (propertyID != CSSPropertyInvalid)
833         consumeDeclarationValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), propertyID, important, ruleType);
834 
<span class="line-modified">835     if (m_observerWrapper &amp;&amp; (ruleType == StyleRule::Style || ruleType == StyleRule::Keyframe)) {</span>
836         m_observerWrapper-&gt;observer().observeProperty(
837             m_observerWrapper-&gt;startOffset(rangeCopy), m_observerWrapper-&gt;endOffset(rangeCopy),
838             important, m_parsedProperties.size() != propertiesCount);
839     }
840 }
841 
842 void CSSParserImpl::consumeCustomPropertyValue(CSSParserTokenRange range, const AtomString&amp; variableName, bool important)
843 {
844     if (RefPtr&lt;CSSCustomPropertyValue&gt; value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
845         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
846 }
847 
<span class="line-modified">848 void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRule::Type ruleType)</span>
849 {
850     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
851 }
852 
853 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)
854 {
855     std::unique_ptr&lt;Vector&lt;double&gt;&gt; result = std::unique_ptr&lt;Vector&lt;double&gt;&gt;(new Vector&lt;double&gt;);
856     while (true) {
857         range.consumeWhitespace();
858         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
859         if (token.type() == PercentageToken &amp;&amp; token.numericValue() &gt;= 0 &amp;&amp; token.numericValue() &lt;= 100)
860             result-&gt;append(token.numericValue() / 100);
861         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;from&quot;))
862             result-&gt;append(0);
863         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;to&quot;))
864             result-&gt;append(1);
865         else
866             return nullptr; // Parser error, invalid value in keyframe selector
867         if (range.atEnd())
868             return result;
</pre>
</td>
<td>
<hr />
<pre>
 68 CSSParserImpl::CSSParserImpl(CSSDeferredParser&amp; deferredParser)
 69     : m_context(deferredParser.context())
 70     , m_styleSheet(deferredParser.styleSheet())
 71     , m_deferredParser(&amp;deferredParser)
 72 {
 73 }
 74 
 75 CSSParserImpl::CSSParserImpl(const CSSParserContext&amp; context, const String&amp; string, StyleSheetContents* styleSheet, CSSParserObserverWrapper* wrapper, CSSParser::RuleParsing ruleParsing)
 76     : m_context(context)
 77     , m_styleSheet(styleSheet)
 78     , m_observerWrapper(wrapper)
 79 {
 80     m_tokenizer = wrapper ? makeUnique&lt;CSSTokenizer&gt;(string, *wrapper) : makeUnique&lt;CSSTokenizer&gt;(string);
 81     if (context.deferredCSSParserEnabled &amp;&amp; !wrapper &amp;&amp; styleSheet &amp;&amp; ruleParsing == CSSParser::RuleParsing::Deferred)
 82         m_deferredParser = CSSDeferredParser::create(context, string, *styleSheet);
 83 }
 84 
 85 CSSParser::ParseResult CSSParserImpl::parseValue(MutableStyleProperties* declaration, CSSPropertyID propertyID, const String&amp; string, bool important, const CSSParserContext&amp; context)
 86 {
 87     CSSParserImpl parser(context, string);
<span class="line-modified"> 88     auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);</span>




 89     parser.consumeDeclarationValue(parser.tokenizer()-&gt;tokenRange(), propertyID, important, ruleType);
 90     if (parser.m_parsedProperties.isEmpty())
 91         return CSSParser::ParseResult::Error;
 92     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
 93 }
 94 
 95 CSSParser::ParseResult CSSParserImpl::parseCustomPropertyValue(MutableStyleProperties* declaration, const AtomString&amp; propertyName, const String&amp; string, bool important, const CSSParserContext&amp; context)
 96 {
 97     CSSParserImpl parser(context, string);
 98     parser.consumeCustomPropertyValue(parser.tokenizer()-&gt;tokenRange(), propertyName, important);
 99     if (parser.m_parsedProperties.isEmpty())
100         return CSSParser::ParseResult::Error;
101     return declaration-&gt;addParsedProperties(parser.m_parsedProperties) ? CSSParser::ParseResult::Changed : CSSParser::ParseResult::Unchanged;
102 }
103 
104 static inline void filterProperties(bool important, const ParsedPropertyVector&amp; input, ParsedPropertyVector&amp; output, size_t&amp; unusedEntries, std::bitset&lt;numCSSProperties&gt;&amp; seenProperties, HashSet&lt;AtomString&gt;&amp; seenCustomProperties)
105 {
106     // Add properties in reverse order so that highest priority definitions are reached first. Duplicate definitions can then be ignored when found.
107     for (size_t i = input.size(); i--; ) {
108         const CSSProperty&amp; property = input[i];
</pre>
<hr />
<pre>
141 {
142     std::bitset&lt;numCSSProperties&gt; seenProperties;
143     size_t unusedEntries = parsedProperties.size();
144     ParsedPropertyVector results(unusedEntries);
145     HashSet&lt;AtomString&gt; seenCustomProperties;
146 
147     filterProperties(true, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
148     filterProperties(false, parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
149 
150     Ref&lt;ImmutableStyleProperties&gt; result = ImmutableStyleProperties::create(results.data() + unusedEntries, results.size() - unusedEntries, mode);
151     parsedProperties.clear();
152     return result;
153 }
154 
155 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
156 {
157     CSSParserContext context(element-&gt;document());
158     context.mode = strictToCSSParserMode(element-&gt;isHTMLElement() &amp;&amp; !element-&gt;document().inQuirksMode());
159 
160     CSSParserImpl parser(context, string);
<span class="line-modified">161     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRuleType::Style);</span>
162     return createStyleProperties(parser.m_parsedProperties, context.mode);
163 }
164 
165 Ref&lt;ImmutableStyleProperties&gt; CSSParserImpl::parseDeferredDeclaration(CSSParserTokenRange tokenRange, const CSSParserContext&amp; context, StyleSheetContents* styleSheet)
166 {
167     if (!styleSheet) {
168         ParsedPropertyVector properties;
169         return createStyleProperties(properties, context.mode);
170     }
171     CSSParserImpl parser(context, styleSheet);
<span class="line-modified">172     parser.consumeDeclarationList(tokenRange, StyleRuleType::Style);</span>
173     return createStyleProperties(parser.m_parsedProperties, context.mode);
174 }
175 
176 void CSSParserImpl::parseDeferredRuleList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
177 {
178     if (!deferredParser.styleSheet())
179         return;
180     CSSParserImpl parser(deferredParser);
181     parser.consumeRuleList(tokenRange, RegularRuleList, [&amp;childRules](const RefPtr&lt;StyleRuleBase&gt;&amp; rule) {
182         childRules.append(rule);
183     });
184     childRules.shrinkToFit();
185 }
186 
187 void CSSParserImpl::parseDeferredKeyframeList(CSSParserTokenRange tokenRange, CSSDeferredParser&amp; deferredParser, StyleRuleKeyframes&amp; keyframeRule)
188 {
189     if (!deferredParser.styleSheet())
190         return;
191     CSSParserImpl parser(deferredParser);
192     parser.consumeRuleList(tokenRange, KeyframesRuleList, [&amp;keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
193         keyframeRule.parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
194     });
195 }
196 
197 bool CSSParserImpl::parseDeclarationList(MutableStyleProperties* declaration, const String&amp; string, const CSSParserContext&amp; context)
198 {
199     CSSParserImpl parser(context, string);
<span class="line-modified">200     auto ruleType = context.enclosingRuleType.valueOr(StyleRuleType::Style);</span>




201     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), ruleType);
202     if (parser.m_parsedProperties.isEmpty())
203         return false;
204 
205     std::bitset&lt;numCSSProperties&gt; seenProperties;
206     size_t unusedEntries = parser.m_parsedProperties.size();
207     ParsedPropertyVector results(unusedEntries);
208     HashSet&lt;AtomString&gt; seenCustomProperties;
209     filterProperties(true, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
210     filterProperties(false, parser.m_parsedProperties, results, unusedEntries, seenProperties, seenCustomProperties);
211     if (unusedEntries)
212         results.remove(0, unusedEntries);
213     return declaration-&gt;addParsedProperties(results);
214 }
215 
216 RefPtr&lt;StyleRuleBase&gt; CSSParserImpl::parseRule(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, AllowedRulesType allowedRules)
217 {
218     CSSParserImpl parser(context, string, styleSheet);
219     CSSParserTokenRange range = parser.tokenizer()-&gt;tokenRange();
220     range.consumeWhitespace();
</pre>
<hr />
<pre>
281             selector = std::unique_ptr&lt;CSSParserSelector&gt;(CSSParserSelector::parsePagePseudoSelector(pseudo));
282             if (!selector || selector-&gt;match() != CSSSelector::PagePseudoClass)
283                 return CSSSelectorList();
284         }
285         if (!typeSelector.isNull())
286             selector-&gt;prependTagSelector(QualifiedName(nullAtom(), typeSelector, styleSheet-&gt;defaultNamespace()));
287     }
288 
289     selector-&gt;setForPage();
290     return CSSSelectorList { Vector&lt;std::unique_ptr&lt;CSSParserSelector&gt;&gt;::from(WTFMove(selector)) };
291 }
292 
293 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::parseKeyframeKeyList(const String&amp; keyList)
294 {
295     return consumeKeyframeKeyList(CSSTokenizer(keyList).tokenRange());
296 }
297 
298 bool CSSParserImpl::supportsDeclaration(CSSParserTokenRange&amp; range)
299 {
300     ASSERT(m_parsedProperties.isEmpty());
<span class="line-modified">301     consumeDeclaration(range, StyleRuleType::Style);</span>
302     bool result = !m_parsedProperties.isEmpty();
303     m_parsedProperties.clear();
304     return result;
305 }
306 
307 void CSSParserImpl::parseDeclarationListForInspector(const String&amp; declaration, const CSSParserContext&amp; context, CSSParserObserver&amp; observer)
308 {
309     CSSParserObserverWrapper wrapper(observer);
310     CSSParserImpl parser(context, declaration, nullptr, &amp;wrapper);
<span class="line-modified">311     observer.startRuleHeader(StyleRuleType::Style, 0);</span>
312     observer.endRuleHeader(1);
<span class="line-modified">313     parser.consumeDeclarationList(parser.tokenizer()-&gt;tokenRange(), StyleRuleType::Style);</span>
314 }
315 
316 void CSSParserImpl::parseStyleSheetForInspector(const String&amp; string, const CSSParserContext&amp; context, StyleSheetContents* styleSheet, CSSParserObserver&amp; observer)
317 {
318     CSSParserObserverWrapper wrapper(observer);
319     CSSParserImpl parser(context, string, styleSheet, &amp;wrapper);
320     bool firstRuleValid = parser.consumeRuleList(parser.tokenizer()-&gt;tokenRange(), TopLevelRuleList, [&amp;styleSheet](RefPtr&lt;StyleRuleBase&gt; rule) {
321         if (rule-&gt;isCharsetRule())
322             return;
323         styleSheet-&gt;parserAppendRule(rule.releaseNonNull());
324     });
325     styleSheet-&gt;setHasSyntacticallyValidCSSHeader(firstRuleValid);
326 }
327 
328 static CSSParserImpl::AllowedRulesType computeNewAllowedRules(CSSParserImpl::AllowedRulesType allowedRules, StyleRuleBase* rule)
329 {
330     if (!rule || allowedRules == CSSParserImpl::KeyframeRules || allowedRules == CSSParserImpl::NoRules)
331         return allowedRules;
332     ASSERT(allowedRules &lt;= CSSParserImpl::RegularRules);
333     if (rule-&gt;isCharsetRule() || rule-&gt;isImportRule())
</pre>
<hr />
<pre>
485         return AtomString();
486     return uri.value().toAtomString();
487 }
488 
489 RefPtr&lt;StyleRuleCharset&gt; CSSParserImpl::consumeCharsetRule(CSSParserTokenRange prelude)
490 {
491     const CSSParserToken&amp; string = prelude.consumeIncludingWhitespace();
492     if (string.type() != StringToken || !prelude.atEnd())
493         return nullptr; // Parse error, expected a single string
494     return StyleRuleCharset::create();
495 }
496 
497 RefPtr&lt;StyleRuleImport&gt; CSSParserImpl::consumeImportRule(CSSParserTokenRange prelude)
498 {
499     AtomString uri(consumeStringOrURI(prelude));
500     if (uri.isNull())
501         return nullptr; // Parse error, expected string or URI
502 
503     if (m_observerWrapper) {
504         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">505         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Import, m_observerWrapper-&gt;startOffset(prelude));</span>
506         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
507         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
508         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
509     }
510 
511     return StyleRuleImport::create(uri, MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull());
512 }
513 
514 RefPtr&lt;StyleRuleNamespace&gt; CSSParserImpl::consumeNamespaceRule(CSSParserTokenRange prelude)
515 {
516     AtomString namespacePrefix;
517     if (prelude.peek().type() == IdentToken)
518         namespacePrefix = prelude.consumeIncludingWhitespace().value().toAtomString();
519 
520     AtomString uri(consumeStringOrURI(prelude));
521     if (uri.isNull() || !prelude.atEnd())
522         return nullptr; // Parse error, expected string or URI
523 
524     return StyleRuleNamespace::create(namespacePrefix, uri);
525 }
526 
527 RefPtr&lt;StyleRuleMedia&gt; CSSParserImpl::consumeMediaRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
528 {
529     if (m_deferredParser)
530         return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(),  makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
531 
532     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
533 
534     if (m_observerWrapper) {
<span class="line-modified">535         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Media, m_observerWrapper-&gt;startOffset(prelude));</span>
536         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
537         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
538     }
539 
540     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
541         rules.append(rule);
542     });
543     rules.shrinkToFit();
544 
545     if (m_observerWrapper)
546         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
547 
548     return StyleRuleMedia::create(MediaQueryParser::parseMediaQuerySet(prelude, MediaQueryParserContext(m_context)).releaseNonNull(), rules);
549 }
550 
551 RefPtr&lt;StyleRuleSupports&gt; CSSParserImpl::consumeSupportsRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
552 {
553     CSSSupportsParser::SupportsResult supported = CSSSupportsParser::supportsCondition(prelude, *this, CSSSupportsParser::ForAtRule);
554     if (supported == CSSSupportsParser::Invalid)
555         return nullptr; // Parse error, invalid @supports condition
556 
557     if (m_deferredParser)
558         return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
559 
560     if (m_observerWrapper) {
<span class="line-modified">561         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Supports, m_observerWrapper-&gt;startOffset(prelude));</span>
562         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
563         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
564     }
565 
566     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; rules;
567     consumeRuleList(block, RegularRuleList, [&amp;rules](RefPtr&lt;StyleRuleBase&gt; rule) {
568         rules.append(rule);
569     });
570     rules.shrinkToFit();
571 
572     if (m_observerWrapper)
573         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
574 
575     return StyleRuleSupports::create(prelude.serialize().stripWhiteSpace(), supported, rules);
576 }
577 
578 #if ENABLE(CSS_DEVICE_ADAPTATION)
579 RefPtr&lt;StyleRuleViewport&gt; CSSParserImpl::consumeViewportRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
580 {
581     if (!prelude.atEnd())
582         return nullptr; // Parser error; @viewport prelude should be empty
583 
584     if (m_observerWrapper) {
585         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">586         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Viewport, m_observerWrapper-&gt;startOffset(prelude));</span>
587         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
588         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
589         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
590     }
591 
592     consumeDeclarationList(block, StyleRule::Viewport);
593     return StyleRuleViewport::create(createStyleProperties(m_parsedProperties, CSSViewportRuleMode));
594 }
595 #endif
596 
597 RefPtr&lt;StyleRuleFontFace&gt; CSSParserImpl::consumeFontFaceRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
598 {
599     if (!prelude.atEnd())
600         return nullptr; // Parse error; @font-face prelude should be empty
601 
602     if (m_observerWrapper) {
603         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">604         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::FontFace, m_observerWrapper-&gt;startOffset(prelude));</span>
605         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
606         m_observerWrapper-&gt;observer().startRuleBody(endOffset);
607         m_observerWrapper-&gt;observer().endRuleBody(endOffset);
608     }
609 
<span class="line-modified">610     consumeDeclarationList(block, StyleRuleType::FontFace);</span>
611     return StyleRuleFontFace::create(createStyleProperties(m_parsedProperties, m_context.mode));
612 }
613 
614 RefPtr&lt;StyleRuleKeyframes&gt; CSSParserImpl::consumeKeyframesRule(bool webkitPrefixed, CSSParserTokenRange prelude, CSSParserTokenRange block)
615 {
616     CSSParserTokenRange rangeCopy = prelude; // For inspector callbacks
617     const CSSParserToken&amp; nameToken = prelude.consumeIncludingWhitespace();
618     if (!prelude.atEnd())
619         return nullptr; // Parse error; expected single non-whitespace token in @keyframes header
620 
621     String name;
622     if (nameToken.type() == IdentToken) {
623         name = nameToken.value().toString();
624     } else if (nameToken.type() == StringToken &amp;&amp; webkitPrefixed)
625         name = nameToken.value().toString();
626     else
627         return nullptr; // Parse error; expected ident token in @keyframes header
628 
629     if (m_deferredParser)
630         return StyleRuleKeyframes::create(name, makeUnique&lt;DeferredStyleGroupRuleList&gt;(block, *m_deferredParser));
631 
632     if (m_observerWrapper) {
<span class="line-modified">633         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Keyframes, m_observerWrapper-&gt;startOffset(rangeCopy));</span>
634         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
635         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(block));
636         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(block));
637     }
638 
639     RefPtr&lt;StyleRuleKeyframes&gt; keyframeRule = StyleRuleKeyframes::create(name);
640     consumeRuleList(block, KeyframesRuleList, [keyframeRule](const RefPtr&lt;StyleRuleBase&gt;&amp; keyframe) {
641         keyframeRule-&gt;parserAppendKeyframe(downcast&lt;const StyleRuleKeyframe&gt;(keyframe.get()));
642     });
643 
644     // FIXME-NEWPARSER: Find out why this is done. Behavior difference when prefixed?
645     // keyframeRule-&gt;setVendorPrefixed(webkitPrefixed);
646     return keyframeRule;
647 }
648 
649 RefPtr&lt;StyleRulePage&gt; CSSParserImpl::consumePageRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
650 {
651     CSSSelectorList selectorList = parsePageSelector(prelude, m_styleSheet.get());
652     if (!selectorList.isValid())
653         return nullptr; // Parse error, invalid @page selector
654 
655     if (m_observerWrapper) {
656         unsigned endOffset = m_observerWrapper-&gt;endOffset(prelude);
<span class="line-modified">657         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Page, m_observerWrapper-&gt;startOffset(prelude));</span>
658         m_observerWrapper-&gt;observer().endRuleHeader(endOffset);
659     }
660 
<span class="line-modified">661     consumeDeclarationList(block, StyleRuleType::Style);</span>
662 
663     return StyleRulePage::create(createStyleProperties(m_parsedProperties, m_context.mode), WTFMove(selectorList));
664 }
665 
666 // FIXME-NEWPARSER: Support &quot;apply&quot;
667 /*void CSSParserImpl::consumeApplyRule(CSSParserTokenRange prelude)
668 {
669     const CSSParserToken&amp; ident = prelude.consumeIncludingWhitespace();
670     if (!prelude.atEnd() || !CSSVariableParser::isValidVariableName(ident))
671         return; // Parse error, expected a single custom property name
672     m_parsedProperties.append(CSSProperty(
673         CSSPropertyApplyAtRule,
674         *CSSCustomIdentValue::create(ident.value().toString())));
675 }
676 */
677 
678 RefPtr&lt;StyleRuleKeyframe&gt; CSSParserImpl::consumeKeyframeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
679 {
680     std::unique_ptr&lt;Vector&lt;double&gt;&gt; keyList = consumeKeyframeKeyList(prelude);
681     if (!keyList)
682         return nullptr;
683 
684     if (m_observerWrapper) {
<span class="line-modified">685         m_observerWrapper-&gt;observer().startRuleHeader(StyleRuleType::Keyframe, m_observerWrapper-&gt;startOffset(prelude));</span>
686         m_observerWrapper-&gt;observer().endRuleHeader(m_observerWrapper-&gt;endOffset(prelude));
687     }
688 
<span class="line-modified">689     consumeDeclarationList(block, StyleRuleType::Keyframe);</span>
690     return StyleRuleKeyframe::create(WTFMove(keyList), createStyleProperties(m_parsedProperties, m_context.mode));
691 }
692 
693 static void observeSelectors(CSSParserObserverWrapper&amp; wrapper, CSSParserTokenRange selectors)
694 {
695     // This is easier than hooking into the CSSSelectorParser
696     selectors.consumeWhitespace();
697     CSSParserTokenRange originalRange = selectors;
<span class="line-modified">698     wrapper.observer().startRuleHeader(StyleRuleType::Style, wrapper.startOffset(originalRange));</span>
699 
700     while (!selectors.atEnd()) {
701         const CSSParserToken* selectorStart = &amp;selectors.peek();
702         while (!selectors.atEnd() &amp;&amp; selectors.peek().type() != CommaToken)
703             selectors.consumeComponentValue();
704         CSSParserTokenRange selector = selectors.makeSubRange(selectorStart, &amp;selectors.peek());
705         selectors.consumeIncludingWhitespace();
706 
707         wrapper.observer().observeSelector(wrapper.startOffset(selector), wrapper.endOffset(selector));
708     }
709 
710     wrapper.observer().endRuleHeader(wrapper.endOffset(originalRange));
711 }
712 
713 RefPtr&lt;StyleRule&gt; CSSParserImpl::consumeStyleRule(CSSParserTokenRange prelude, CSSParserTokenRange block)
714 {
715     CSSSelectorList selectorList = CSSSelectorParser::parseSelector(prelude, m_context, m_styleSheet.get());
716     if (!selectorList.isValid())
717         return nullptr; // Parse error, invalid selector list
718 
719     if (m_observerWrapper)
720         observeSelectors(*m_observerWrapper, prelude);
721 
722     if (m_deferredParser) {
723         // If a rule is empty (i.e., only whitespace), don&#39;t bother using
724         // deferred parsing. This allows the empty rule optimization in ElementRuleCollector
725         // to continue to work. Note we don&#39;t have to consider CommentTokens, since those
726         // are stripped out.
727         CSSParserTokenRange blockCopy = block;
728         blockCopy.consumeWhitespace();
729         if (!blockCopy.atEnd()) {
730             return StyleRule::create(createDeferredStyleProperties(block), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
731         }
732     }
733 
<span class="line-modified">734     consumeDeclarationList(block, StyleRuleType::Style);</span>
735     return StyleRule::create(createStyleProperties(m_parsedProperties, m_context.mode), m_context.hasDocumentSecurityOrigin, WTFMove(selectorList));
736 }
737 
<span class="line-modified">738 void CSSParserImpl::consumeDeclarationList(CSSParserTokenRange range, StyleRuleType ruleType)</span>
739 {
740     ASSERT(m_parsedProperties.isEmpty());
741 
<span class="line-modified">742     bool useObserver = m_observerWrapper &amp;&amp; (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe);</span>
743     if (useObserver) {
744         m_observerWrapper-&gt;observer().startRuleBody(m_observerWrapper-&gt;previousTokenStartOffset(range));
745         m_observerWrapper-&gt;skipCommentsBefore(range, true);
746     }
747 
748     while (!range.atEnd()) {
749         switch (range.peek().type()) {
750         case WhitespaceToken:
751         case SemicolonToken:
752             range.consume();
753             break;
754         case IdentToken: {
755             const CSSParserToken* declarationStart = &amp;range.peek();
756 
757             if (useObserver)
758                 m_observerWrapper-&gt;yieldCommentsBefore(range);
759 
760             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
761                 range.consumeComponentValue();
762 
763             consumeDeclaration(range.makeSubRange(declarationStart, &amp;range.peek()), ruleType);
764 
765             if (useObserver)
766                 m_observerWrapper-&gt;skipCommentsBefore(range, false);
767             break;
768         }
769         case AtKeywordToken: {
770             // FIXME-NEWPARSER: Support apply
<span class="line-modified">771             AllowedRulesType allowedRules = /* ruleType == StyleRuleType::Style &amp;&amp; RuntimeEnabledFeatures::cssApplyAtRulesEnabled() ? ApplyRules :*/ NoRules;</span>
772             RefPtr&lt;StyleRuleBase&gt; rule = consumeAtRule(range, allowedRules);
773             ASSERT_UNUSED(rule, !rule);
774             break;
775         }
776         default: // Parse error, unexpected token in declaration list
777             while (!range.atEnd() &amp;&amp; range.peek().type() != SemicolonToken)
778                 range.consumeComponentValue();
779             break;
780         }
781     }
782 
783     // Yield remaining comments
784     if (useObserver) {
785         m_observerWrapper-&gt;yieldCommentsBefore(range);
786         m_observerWrapper-&gt;observer().endRuleBody(m_observerWrapper-&gt;endOffset(range));
787     }
788 }
789 
<span class="line-modified">790 void CSSParserImpl::consumeDeclaration(CSSParserTokenRange range, StyleRuleType ruleType)</span>
791 {
792     CSSParserTokenRange rangeCopy = range; // For inspector callbacks
793 
794     ASSERT(range.peek().type() == IdentToken);
795     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
796     CSSPropertyID propertyID = token.parseAsCSSPropertyID();
797     if (range.consume().type() != ColonToken)
798         return; // Parse error
799 
800     bool important = false;
801     const CSSParserToken* declarationValueEnd = range.end();
802     const CSSParserToken* last = range.end() - 1;
803     while (last-&gt;type() == WhitespaceToken)
804         --last;
805     if (last-&gt;type() == IdentToken &amp;&amp; equalIgnoringASCIICase(last-&gt;value(), &quot;important&quot;)) {
806         --last;
807         while (last-&gt;type() == WhitespaceToken)
808             --last;
809         if (last-&gt;type() == DelimiterToken &amp;&amp; last-&gt;delimiter() == &#39;!&#39;) {
810             important = true;
811             declarationValueEnd = last;
812         }
813     }
814 
815     size_t propertiesCount = m_parsedProperties.size();
816     if (propertyID == CSSPropertyInvalid &amp;&amp; CSSVariableParser::isValidVariableName(token)) {
817         AtomString variableName = token.value().toAtomString();
818         consumeCustomPropertyValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), variableName, important);
819     }
820 
<span class="line-modified">821     if (important &amp;&amp; (ruleType == StyleRuleType::FontFace || ruleType == StyleRuleType::Keyframe))</span>
822         return;
823 
824     if (propertyID != CSSPropertyInvalid)
825         consumeDeclarationValue(range.makeSubRange(&amp;range.peek(), declarationValueEnd), propertyID, important, ruleType);
826 
<span class="line-modified">827     if (m_observerWrapper &amp;&amp; (ruleType == StyleRuleType::Style || ruleType == StyleRuleType::Keyframe)) {</span>
828         m_observerWrapper-&gt;observer().observeProperty(
829             m_observerWrapper-&gt;startOffset(rangeCopy), m_observerWrapper-&gt;endOffset(rangeCopy),
830             important, m_parsedProperties.size() != propertiesCount);
831     }
832 }
833 
834 void CSSParserImpl::consumeCustomPropertyValue(CSSParserTokenRange range, const AtomString&amp; variableName, bool important)
835 {
836     if (RefPtr&lt;CSSCustomPropertyValue&gt; value = CSSVariableParser::parseDeclarationValue(variableName, range, m_context))
837         m_parsedProperties.append(CSSProperty(CSSPropertyCustom, WTFMove(value), important));
838 }
839 
<span class="line-modified">840 void CSSParserImpl::consumeDeclarationValue(CSSParserTokenRange range, CSSPropertyID propertyID, bool important, StyleRuleType ruleType)</span>
841 {
842     CSSPropertyParser::parseValue(propertyID, important, range, m_context, m_parsedProperties, ruleType);
843 }
844 
845 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParserImpl::consumeKeyframeKeyList(CSSParserTokenRange range)
846 {
847     std::unique_ptr&lt;Vector&lt;double&gt;&gt; result = std::unique_ptr&lt;Vector&lt;double&gt;&gt;(new Vector&lt;double&gt;);
848     while (true) {
849         range.consumeWhitespace();
850         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
851         if (token.type() == PercentageToken &amp;&amp; token.numericValue() &gt;= 0 &amp;&amp; token.numericValue() &lt;= 100)
852             result-&gt;append(token.numericValue() / 100);
853         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;from&quot;))
854             result-&gt;append(0);
855         else if (token.type() == IdentToken &amp;&amp; equalIgnoringASCIICase(token.value(), &quot;to&quot;))
856             result-&gt;append(1);
857         else
858             return nullptr; // Parser error, invalid value in keyframe selector
859         if (range.atEnd())
860             return result;
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserFastPaths.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/TransactionOperation.h b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/TransactionOperation.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/TransactionOperation.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/TransactionOperation.h
@@ -49,43 +49,43 @@
 class TransactionOperation : public ThreadSafeRefCounted<TransactionOperation> {
     friend IDBRequestData::IDBRequestData(TransactionOperation&);
 public:
     virtual ~TransactionOperation()
     {
-        ASSERT(m_originThread.ptr() == &Thread::current());
+        ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
     }
 
     void perform()
     {
-        ASSERT(m_originThread.ptr() == &Thread::current());
+        ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
         ASSERT(m_performFunction);
         m_performFunction();
         m_performFunction = { };
     }
 
     void transitionToCompleteOnThisThread(const IDBResultData& data)
     {
-        ASSERT(m_originThread.ptr() == &Thread::current());
+        ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
         m_transaction->operationCompletedOnServer(data, *this);
     }
 
     void transitionToComplete(const IDBResultData& data, RefPtr<TransactionOperation>&& lastRef)
     {
         ASSERT(isMainThread());
 
-        if (m_originThread.ptr() == &Thread::current())
+        if (canCurrentThreadAccessThreadLocalData(originThread()))
             transitionToCompleteOnThisThread(data);
         else {
             m_transaction->performCallbackOnOriginThread(*this, &TransactionOperation::transitionToCompleteOnThisThread, data);
             m_transaction->callFunctionOnOriginThread([lastRef = WTFMove(lastRef)]() {
             });
         }
     }
 
     void doComplete(const IDBResultData& data)
     {
-        ASSERT(m_originThread.ptr() == &Thread::current());
+        ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
 
         if (m_performFunction)
             m_performFunction = { };
 
         // Due to race conditions between the server sending an "operation complete" message and the client
@@ -110,14 +110,17 @@
     IDBRequest* idbRequest() { return m_idbRequest.get(); }
 
     bool nextRequestCanGoToServer() const { return m_nextRequestCanGoToServer && m_idbRequest; }
     void setNextRequestCanGoToServer(bool nextRequestCanGoToServer) { m_nextRequestCanGoToServer = nextRequestCanGoToServer; }
 
+    uint64_t operationID() const { return m_operationID; }
+
 protected:
     TransactionOperation(IDBTransaction& transaction)
         : m_transaction(transaction)
         , m_identifier(transaction.connectionProxy())
+        , m_operationID(transaction.generateOperationID())
     {
     }
 
     TransactionOperation(IDBTransaction&, IDBRequest&);
 
@@ -140,10 +143,12 @@
 
     Ref<Thread> m_originThread { Thread::current() };
     RefPtr<IDBRequest> m_idbRequest;
     bool m_nextRequestCanGoToServer { true };
     bool m_didComplete { false };
+
+    uint64_t m_operationID { 0 };
 };
 
 class TransactionOperationImpl final : public TransactionOperation {
 public:
     template<typename... Args> static Ref<TransactionOperationImpl> create(Args&&... args) { return adoptRef(*new TransactionOperationImpl(std::forward<Args>(args)...)); }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/risc.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 # Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require &#39;config&#39;
 25 require &#39;ast&#39;
 26 require &#39;opt&#39;
 27 
 28 # This file contains utilities that are useful for implementing a backend
 29 # for RISC-like processors (ARM, MIPS, etc).
 30 
 31 #
 32 # Lowering of simple branch ops. For example:
 33 #
 34 # baddiz foo, bar, baz
 35 #
 36 # will become:
 37 #
 38 # addi foo, bar
 39 # bz baz
 40 #
 41 
 42 def riscLowerSimpleBranchOps(list)
 43     newList = []
 44     list.each {
 45         | node |
 46         if node.is_a? Instruction
 47             annotation = node.annotation
 48             case node.opcode
 49             when /^b(addi|subi|ori|addp)/
 50                 op = $1
 51                 branch = &quot;b&quot; + $~.post_match
 52                 
 53                 case op
 54                 when &quot;addi&quot;
 55                     op = &quot;addis&quot;
 56                 when &quot;addp&quot;
 57                     op = &quot;addps&quot;
 58                 when &quot;subi&quot;
 59                     op = &quot;subis&quot;
 60                 when &quot;ori&quot;
 61                     op = &quot;oris&quot;
 62                 end
 63                 
 64                 newList &lt;&lt; Instruction.new(node.codeOrigin, op, node.operands[0..-2], annotation)
 65                 newList &lt;&lt; Instruction.new(node.codeOrigin, branch, [node.operands[-1]])
 66             when &#39;bmulis&#39;, &#39;bmulz&#39;, &#39;bmulnz&#39;
 67                 condition = $~.post_match
 68                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;muli&quot;, node.operands[0..-2], annotation)
 69                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bti&quot; + condition, [node.operands[-2], node.operands[-1]])
 70             else
 71                 newList &lt;&lt; node
 72             end
 73         else
 74             newList &lt;&lt; node
 75         end
 76     }
 77     newList
 78 end
 79 
 80 #
 81 # Lowing of complex branch ops. For example:
 82 #
 83 # bmulio foo, bar, baz
 84 #
 85 # becomes:
 86 #
 87 # smulli foo, bar, bar, tmp1
 88 # rshifti bar, 31, tmp2
 89 # bineq tmp1, tmp2, baz
 90 #
 91 
 92 def riscLowerHardBranchOps(list)
 93     newList = []
 94     list.each {
 95         | node |
 96         if node.is_a? Instruction and node.opcode == &quot;bmulio&quot;
 97             tmp1 = Tmp.new(node.codeOrigin, :gpr)
 98             tmp2 = Tmp.new(node.codeOrigin, :gpr)
 99             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;smulli&quot;, [node.operands[0], node.operands[1], node.operands[1], tmp1], node.annotation)
100             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshifti&quot;, [node.operands[-2], Immediate.new(node.codeOrigin, 31), tmp2])
101             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bineq&quot;, [tmp1, tmp2, node.operands[-1]])
102         else
103             newList &lt;&lt; node
104         end
105     }
106     newList
107 end
108 
109 #
110 # Lowering of shift ops. For example:
111 #
112 # lshifti foo, bar
113 #
114 # will become:
115 #
116 # andi foo, 31, tmp
117 # lshifti tmp, bar
118 #
119 
120 def riscSanitizeShift(operand, list)
121     return operand if operand.immediate?
122     
123     tmp = Tmp.new(operand.codeOrigin, :gpr)
124     list &lt;&lt; Instruction.new(operand.codeOrigin, &quot;andi&quot;, [operand, Immediate.new(operand.codeOrigin, 31), tmp])
125     tmp
126 end
127 
128 def riscLowerShiftOps(list)
129     newList = []
130     list.each {
131         | node |
132         if node.is_a? Instruction
133             case node.opcode
134             when &quot;lshifti&quot;, &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;lshiftp&quot;, &quot;rshiftp&quot;, &quot;urshiftp&quot;
135                 if node.operands.size == 2
136                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [riscSanitizeShift(node.operands[0], newList), node.operands[1]], node.annotation)
137                 else
138                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], riscSanitizeShift(node.operands[1], newList), node.operands[2]], node.annotation)
139                     raise &quot;Wrong number of operands for shift at #{node.codeOriginString}&quot; unless node.operands.size == 3
140                 end
141             else
142                 newList &lt;&lt; node
143             end
144         else
145             newList &lt;&lt; node
146         end
147     }
148     newList
149 end
150 
151 #
152 # Lowering of malformed addresses. For example:
153 #
154 # loadp 10000[foo], bar
155 #
156 # will become:
157 #
158 # move 10000, tmp
159 # addp foo, tmp
160 # loadp 0[tmp], bar
161 #
162 # Note that you use this lowering phase by passing it a block that returns true
163 # if you don&#39;t want to lower the address, or false if you do. For example to get
164 # the effect of the example above, the block would have to say something like:
165 #
166 # riscLowerMalformedAddresses(thingy) {
167 #     | node, address |
168 #     if address.is_a? Address
169 #         address.offset.value &gt; 1000
170 #     else
171 #         true # don&#39;t lower anything else, in this example
172 #     end
173 # }
174 #
175 # See arm.rb for a different example, in which we lower all BaseIndex addresses
176 # that have non-zero offset, all Address addresses that have large offsets, and
177 # all other addresses (like AbsoluteAddress).
178 #
179 
180 class Node
181     def riscLowerMalformedAddressesRecurse(list, topLevelNode, &amp;block)
182         mapChildren {
183             | subNode |
184             subNode.riscLowerMalformedAddressesRecurse(list, topLevelNode, &amp;block)
185         }
186     end
187 end
188 
189 class Address
190     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
191         return self if yield node, self
192 
193         tmp = Tmp.new(codeOrigin, :gpr)
194         list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [offset, tmp])
195         list &lt;&lt; Instruction.new(codeOrigin, &quot;addp&quot;, [base, tmp])
196         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
197     end
198 end
199 
200 class BaseIndex
201     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
202         return self if yield node, self
203         
204         tmp = Tmp.new(codeOrigin, :gpr)
205         list &lt;&lt; Instruction.new(codeOrigin, &quot;leap&quot;, [BaseIndex.new(codeOrigin, base, index, scale, Immediate.new(codeOrigin, 0)), tmp])
206         Address.new(codeOrigin, tmp, offset).riscLowerMalformedAddressesRecurse(list, node, &amp;block)
207     end
208 end
209 
210 class AbsoluteAddress
211     def riscLowerMalformedAddressesRecurse(list, node, &amp;block)
212         return self if yield node, self
213         
214         tmp = Tmp.new(codeOrigin, :gpr)
215         list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [address, tmp])
216         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
217     end
218 end
219 
220 def riscLowerMalformedAddresses(list, &amp;block)
221     newList = []
222     list.each {
223         | node |
224         newList &lt;&lt; node.riscLowerMalformedAddressesRecurse(newList, node, &amp;block)
225     }
226     newList
227 end
228 
229 #
230 # Lowering of malformed addresses in double loads and stores. For example:
231 #
232 # loadd [foo, bar, 8], baz
233 #
234 # becomes:
235 #
236 # leap [foo, bar, 8], tmp
237 # loadd [tmp], baz
238 #
239 
240 class Node
241     def riscDoubleAddress(list)
242         self
243     end
244 end
245 
246 class BaseIndex
247     def riscDoubleAddress(list)
248         tmp = Tmp.new(codeOrigin, :gpr)
249         list &lt;&lt; Instruction.new(codeOrigin, &quot;leap&quot;, [self, tmp])
250         Address.new(codeOrigin, tmp, Immediate.new(codeOrigin, 0))
251     end
252 end
253 
254 def riscLowerMalformedAddressesDouble(list)
255     newList = []
256     list.each {
257         | node |
258         if node.is_a? Instruction
259             case node.opcode
260             when &quot;loadd&quot;
261                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;loadd&quot;, [node.operands[0].riscDoubleAddress(newList), node.operands[1]], node.annotation)
262             when &quot;stored&quot;
263                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;stored&quot;, [node.operands[0], node.operands[1].riscDoubleAddress(newList)], node.annotation)
264             else
265                 newList &lt;&lt; node
266             end
267         else
268             newList &lt;&lt; node
269         end
270     }
271     newList
272 end
273 
274 #
275 # Lowering of misplaced immediates for opcodes in opcodeList. For example, if storei is in opcodeList:
276 #
277 # storei 0, [foo]
278 #
279 # will become:
280 #
281 # move 0, tmp
282 # storei tmp, [foo]
283 #
284 
285 def riscLowerMisplacedImmediates(list, opcodeList)
286     newList = []
287     list.each {
288         | node |
289         if node.is_a? Instruction
290             if opcodeList.include? node.opcode
291                 operands = node.operands
292                 newOperands = []
293                 operands.each {
294                     | operand |
295                     if operand.is_a? Immediate
296                         tmp = Tmp.new(operand.codeOrigin, :gpr)
297                         newList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;move&quot;, [operand, tmp])
298                         newOperands &lt;&lt; tmp
299                     else
300                         newOperands &lt;&lt; operand
301                     end
302                 }
303                 newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, newOperands, node.annotation)
304             else
305                 newList &lt;&lt; node
306             end
307         else
308             newList &lt;&lt; node
309         end
310     }
311     newList
312 end
313 
314 #
315 # Lowering of malformed immediates except when used in a &quot;move&quot; instruction.
316 # For example:
317 #
318 # addp 642641, foo
319 #
320 # will become:
321 #
322 # move 642641, tmp
323 # addp tmp, foo
324 #
325 
326 class Node
327     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
328         mapChildren {
329             | node |
330             node.riscLowerMalformedImmediatesRecurse(list, validImmediates)
331         }
332     end
333 end
334 
335 class Address
336     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
337         self
338     end
339 end
340 
341 class BaseIndex
342     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
343         self
344     end
345 end
346 
347 class AbsoluteAddress
348     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
349         self
350     end
351 end
352 
353 class Immediate
354     def riscLowerMalformedImmediatesRecurse(list, validImmediates)
355         unless validImmediates.include? value
356             tmp = Tmp.new(codeOrigin, :gpr)
357             list &lt;&lt; Instruction.new(codeOrigin, &quot;move&quot;, [self, tmp])
358             tmp
359         else
360             self
361         end
362     end
363 end
364 
<a name="1" id="anc1"></a><span class="line-modified">365 def riscLowerMalformedImmediates(list, validImmediates, validLogicalImmediates)</span>
366     newList = []
367     list.each {
368         | node |
369         if node.is_a? Instruction
370             annotation = node.annotation
371             case node.opcode
372             when &quot;move&quot;
373                 newList &lt;&lt; node
374             when &quot;addi&quot;, &quot;addp&quot;, &quot;addq&quot;, &quot;addis&quot;, &quot;subi&quot;, &quot;subp&quot;, &quot;subq&quot;, &quot;subis&quot;
375                 if node.operands[0].is_a? Immediate and
376                         (not validImmediates.include? node.operands[0].value) and
377                         validImmediates.include? -node.operands[0].value and
378                         node.operands.size == 2
379                     if node.opcode =~ /add/
380                         newOpcode = &quot;sub&quot; + $~.post_match
381                     else
382                         newOpcode = &quot;add&quot; + $~.post_match
383                     end
384                     newList &lt;&lt; Instruction.new(node.codeOrigin, newOpcode,
385                                                [Immediate.new(node.codeOrigin, -node.operands[0].value)] + node.operands[1..-1],
386                                                annotation)
387                 else
388                     newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
389                 end
390             when &quot;muli&quot;, &quot;mulp&quot;, &quot;mulq&quot;
391                 if node.operands[0].is_a? Immediate
392                     tmp = Tmp.new(codeOrigin, :gpr)
393                     newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
394                     newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp] + node.operands[1..-1])
395                 else
396                     newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
397                 end
<a name="2" id="anc2"></a><span class="line-added">398             when &quot;ori&quot;, &quot;orh&quot;, &quot;orp&quot;, &quot;oris&quot;, &quot;xori&quot;, &quot;xorp&quot;, &quot;andi&quot;, &quot;andp&quot;</span>
<span class="line-added">399                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validLogicalImmediates)</span>
400             else
401                 newList &lt;&lt; node.riscLowerMalformedImmediatesRecurse(newList, validImmediates)
402             end
403         else
404             newList &lt;&lt; node
405         end
406     }
407     newList
408 end
409 
410 #
411 # Lowering of misplaced addresses. For example:
412 #
413 # addi foo, [bar]
414 #
415 # will become:
416 #
417 # loadi [bar], tmp
418 # addi foo, tmp
419 # storei tmp, [bar]
420 #
421 # Another example:
422 #
423 # addi [foo], bar
424 #
425 # will become:
426 #
427 # loadi [foo], tmp
428 # addi tmp, bar
429 #
430 
431 def riscAsRegister(preList, postList, operand, suffix, needStore)
432     return operand unless operand.address?
433     
434     tmp = Tmp.new(operand.codeOrigin, if suffix == &quot;d&quot; then :fpr else :gpr end)
435     preList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;load&quot; + suffix, [operand, tmp])
436     if needStore
437         postList &lt;&lt; Instruction.new(operand.codeOrigin, &quot;store&quot; + suffix, [tmp, operand])
438     end
439     tmp
440 end
441 
442 def riscAsRegisters(preList, postList, operands, suffix)
443     newOperands = []
444     operands.each_with_index {
445         | operand, index |
446         newOperands &lt;&lt; riscAsRegister(preList, postList, operand, suffix, index == operands.size - 1)
447     }
448     newOperands
449 end
450 
451 def riscLowerMisplacedAddresses(list)
452     newList = []
453     hasBackendSpecificLowering = Instruction.respond_to? &quot;lowerMisplacedAddresses#{$activeBackend}&quot;
454     list.each {
455         | node |
456         if node.is_a? Instruction
457             if hasBackendSpecificLowering
458                 wasHandled, newList = Instruction.send(&quot;lowerMisplacedAddresses#{$activeBackend}&quot;, node, newList)
459                 next if wasHandled
460             end
461 
462             postInstructions = []
463             annotation = node.annotation
464             case node.opcode
<a name="3" id="anc3"></a><span class="line-modified">465             when &quot;addi&quot;, &quot;addis&quot;, &quot;andi&quot;, &quot;lshifti&quot;, &quot;muli&quot;, &quot;negi&quot;, &quot;noti&quot;, &quot;ori&quot;, &quot;orh&quot;, &quot;oris&quot;,</span>
466                 &quot;rshifti&quot;, &quot;urshifti&quot;, &quot;subi&quot;, &quot;subis&quot;, &quot;xori&quot;, /^bi/, /^bti/, /^ci/, /^ti/
467                 newList &lt;&lt; Instruction.new(node.codeOrigin,
468                                            node.opcode,
469                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;i&quot;),
470                                            annotation)
471             when &quot;addp&quot;, &quot;andp&quot;, &quot;lshiftp&quot;, &quot;mulp&quot;, &quot;negp&quot;, &quot;orp&quot;, &quot;rshiftp&quot;, &quot;urshiftp&quot;,
472                 &quot;subp&quot;, &quot;xorp&quot;, /^bp/, /^btp/, /^cp/
473                 newList &lt;&lt; Instruction.new(node.codeOrigin,
474                                            node.opcode,
475                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;p&quot;),
476                                            annotation)
477             when &quot;addq&quot;, &quot;andq&quot;, &quot;lshiftq&quot;, &quot;mulq&quot;, &quot;negq&quot;, &quot;orq&quot;, &quot;rshiftq&quot;, &quot;urshiftq&quot;,
478                 &quot;subq&quot;, &quot;xorq&quot;, /^bq/, /^btq/, /^cq/
479                 newList &lt;&lt; Instruction.new(node.codeOrigin,
480                                            node.opcode,
481                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;q&quot;),
482                                            annotation)
483             when &quot;bbeq&quot;, &quot;bbneq&quot;, &quot;bba&quot;, &quot;bbaeq&quot;, &quot;bbb&quot;, &quot;bbbeq&quot;, &quot;btbz&quot;, &quot;btbnz&quot;, &quot;tbz&quot;, &quot;tbnz&quot;,
484                 &quot;cbeq&quot;, &quot;cbneq&quot;, &quot;cba&quot;, &quot;cbaeq&quot;, &quot;cbb&quot;, &quot;cbbeq&quot;
485                 newList &lt;&lt; Instruction.new(node.codeOrigin,
486                                            node.opcode,
487                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;b&quot;),
488                                            annotation)
489             when &quot;bbgt&quot;, &quot;bbgteq&quot;, &quot;bblt&quot;, &quot;bblteq&quot;, &quot;btbs&quot;, &quot;tbs&quot;, &quot;cbgt&quot;, &quot;cbgteq&quot;, &quot;cblt&quot;, &quot;cblteq&quot;
490                 newList &lt;&lt; Instruction.new(node.codeOrigin,
491                                            node.opcode,
492                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;bs&quot;),
493                                            annotation)
494             when &quot;addd&quot;, &quot;divd&quot;, &quot;subd&quot;, &quot;muld&quot;, &quot;sqrtd&quot;, /^bd/
495                 newList &lt;&lt; Instruction.new(node.codeOrigin,
496                                            node.opcode,
497                                            riscAsRegisters(newList, postInstructions, node.operands, &quot;d&quot;),
498                                            annotation)
499             when &quot;jmp&quot;, &quot;call&quot;
500                 newList &lt;&lt; Instruction.new(node.codeOrigin,
501                                            node.opcode,
502                                            [riscAsRegister(newList, postInstructions, node.operands[0], &quot;p&quot;, false)],
503                                            annotation)
504             else
505                 newList &lt;&lt; node
506             end
507             newList += postInstructions
508         else
509             newList &lt;&lt; node
510         end
511     }
512     newList
513 end
514 
515 #
516 # Lowering of register reuse in compare instructions. For example:
517 #
518 # cieq t0, t1, t0
519 #
520 # will become:
521 #
522 # mov tmp, t0
523 # cieq tmp, t1, t0
524 #
525 
526 def riscLowerRegisterReuse(list)
527     newList = []
528     list.each {
529         | node |
530         if node.is_a? Instruction
531             annotation = node.annotation
532             case node.opcode
533             when &quot;cieq&quot;, &quot;cineq&quot;, &quot;cia&quot;, &quot;ciaeq&quot;, &quot;cib&quot;, &quot;cibeq&quot;, &quot;cigt&quot;, &quot;cigteq&quot;, &quot;cilt&quot;, &quot;cilteq&quot;,
534                 &quot;cpeq&quot;, &quot;cpneq&quot;, &quot;cpa&quot;, &quot;cpaeq&quot;, &quot;cpb&quot;, &quot;cpbeq&quot;, &quot;cpgt&quot;, &quot;cpgteq&quot;, &quot;cplt&quot;, &quot;cplteq&quot;,
535                 &quot;tis&quot;, &quot;tiz&quot;, &quot;tinz&quot;, &quot;tbs&quot;, &quot;tbz&quot;, &quot;tbnz&quot;, &quot;tps&quot;, &quot;tpz&quot;, &quot;tpnz&quot;, &quot;cbeq&quot;, &quot;cbneq&quot;,
536                 &quot;cba&quot;, &quot;cbaeq&quot;, &quot;cbb&quot;, &quot;cbbeq&quot;, &quot;cbgt&quot;, &quot;cbgteq&quot;, &quot;cblt&quot;, &quot;cblteq&quot;
537                 if node.operands.size == 2
538                     if node.operands[0] == node.operands[1]
539                         tmp = Tmp.new(node.codeOrigin, :gpr)
540                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
541                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp, node.operands[1]])
542                     else
543                         newList &lt;&lt; node
544                     end
545                 else
546                     raise &quot;Wrong number of arguments at #{node.codeOriginString}&quot; unless node.operands.size == 3
547                     if node.operands[0] == node.operands[2]
548                         tmp = Tmp.new(node.codeOrigin, :gpr)
549                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[0], tmp], annotation)
550                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [tmp, node.operands[1], node.operands[2]])
551                     elsif node.operands[1] == node.operands[2]
552                         tmp = Tmp.new(node.codeOrigin, :gpr)
553                         newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;move&quot;, [node.operands[1], tmp], annotation)
554                         newList &lt;&lt; Instruction.new(node.codeOrigin, node.opcode, [node.operands[0], tmp, node.operands[2]])
555                     else
556                         newList &lt;&lt; node
557                     end
558                 end
559             else
560                 newList &lt;&lt; node
561             end
562         else
563             newList &lt;&lt; node
564         end
565     }
566     newList
567 end
568 
569 #
570 # Lowering of the not instruction. The following:
571 #
572 # noti t0
573 #
574 # becomes:
575 #
576 # xori -1, t0
577 #
578 
579 def riscLowerNot(list)
580     newList = []
581     list.each {
582         | node |
583         if node.is_a? Instruction
584             case node.opcode
585             when &quot;noti&quot;, &quot;notp&quot;
586                 raise &quot;Wrong number of operands at #{node.codeOriginString}&quot; unless node.operands.size == 1
587                 suffix = node.opcode[-1..-1]
588                 newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;xor&quot; + suffix,
589                                            [Immediate.new(node.codeOrigin, -1), node.operands[0]])
590             else
591                 newList &lt;&lt; node
592             end
593         else
594             newList &lt;&lt; node
595         end
596     }
597     return newList
598 end
599 
600 #
601 # Lowing of complex branch ops on 64-bit. For example:
602 #
603 # bmulio foo, bar, baz
604 #
605 # becomes:
606 #
607 # smulli foo, bar, bar
608 # rshiftp bar, 32, tmp1
609 # rshifti bar, 31, tmp2
610 # zxi2p bar, bar 
611 # bineq tmp1, tmp2, baz
612 #
613 
614 def riscLowerHardBranchOps64(list)
615     newList = []
616     list.each {
617         | node |
618         if node.is_a? Instruction and node.opcode == &quot;bmulio&quot;
619             tmp1 = Tmp.new(node.codeOrigin, :gpr)
620             tmp2 = Tmp.new(node.codeOrigin, :gpr)
621             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;smulli&quot;, [node.operands[0], node.operands[1], node.operands[1]])
622             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshiftp&quot;, [node.operands[1], Immediate.new(node.codeOrigin, 32), tmp1])
623             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;rshifti&quot;, [node.operands[1], Immediate.new(node.codeOrigin, 31), tmp2])
624             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;zxi2p&quot;, [node.operands[1], node.operands[1]])
625             newList &lt;&lt; Instruction.new(node.codeOrigin, &quot;bineq&quot;, [tmp1, tmp2, node.operands[2]])
626         else
627             newList &lt;&lt; node
628         end
629     }
630     newList
631 end
632 
633 #
634 # Lowering of test instructions. For example:
635 #
636 # btiz t0, t1, .foo
637 #
638 # becomes:
639 #
640 # andi t0, t1, tmp
641 # bieq tmp, 0, .foo
642 #
643 # and another example:
644 #
645 # tiz t0, t1, t2
646 #
647 # becomes:
648 #
649 # andi t0, t1, tmp
650 # cieq tmp, 0, t2
651 #
652 
653 def riscLowerTest(list)
654     def emit(newList, andOpcode, branchOpcode, node)
655         if node.operands.size == 2
656             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[0], Immediate.new(node.codeOrigin, 0), node.operands[1]])
657             return
658         end
659 
660         raise &quot;Incorrect number of operands at #{codeOriginString}&quot; unless node.operands.size == 3
661 
662         if node.operands[0].immediate? and node.operands[0].value == -1
663             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[1], Immediate.new(node.codeOrigin, 0), node.operands[2]])
664             return
665         end
666 
667         if node.operands[1].immediate? and node.operands[1].value == -1
668             newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [node.operands[0], Immediate.new(node.codeOrigin, 0), node.operands[2]])
669             return
670         end
671         
672         tmp = Tmp.new(node.codeOrigin, :gpr)
673         newList &lt;&lt; Instruction.new(node.codeOrigin, andOpcode, [node.operands[0], node.operands[1], tmp])
674         newList &lt;&lt; Instruction.new(node.codeOrigin, branchOpcode, [tmp, Immediate.new(node.codeOrigin, 0), node.operands[2]])
675     end
676 
677     newList = []
678     list.each {
679         | node |
680         if node.is_a? Instruction
681             case node.opcode
682             when &quot;btis&quot;
683                 emit(newList, &quot;andi&quot;, &quot;bilt&quot;, node)
684             when &quot;btiz&quot;
685                 emit(newList, &quot;andi&quot;, &quot;bieq&quot;, node)
686             when &quot;btinz&quot;
687                 emit(newList, &quot;andi&quot;, &quot;bineq&quot;, node)
688             when &quot;btps&quot;
689                 emit(newList, &quot;andp&quot;, &quot;bplt&quot;, node)
690             when &quot;btpz&quot;
691                 emit(newList, &quot;andp&quot;, &quot;bpeq&quot;, node)
692             when &quot;btpnz&quot;
693                 emit(newList, &quot;andp&quot;, &quot;bpneq&quot;, node)
694             when &quot;btqs&quot;
695                 emit(newList, &quot;andq&quot;, &quot;bqlt&quot;, node)
696             when &quot;btqz&quot;
697                 emit(newList, &quot;andq&quot;, &quot;bqeq&quot;, node)
698             when &quot;btqnz&quot;
699                 emit(newList, &quot;andq&quot;, &quot;bqneq&quot;, node)
700             when &quot;btbs&quot;
701                 emit(newList, &quot;andi&quot;, &quot;bblt&quot;, node)
702             when &quot;btbz&quot;
703                 emit(newList, &quot;andi&quot;, &quot;bbeq&quot;, node)
704             when &quot;btbnz&quot;
705                 emit(newList, &quot;andi&quot;, &quot;bbneq&quot;, node)
706             when &quot;tis&quot;
707                 emit(newList, &quot;andi&quot;, &quot;cilt&quot;, node)
708             when &quot;tiz&quot;
709                 emit(newList, &quot;andi&quot;, &quot;cieq&quot;, node)
710             when &quot;tinz&quot;
711                 emit(newList, &quot;andi&quot;, &quot;cineq&quot;, node)
712             when &quot;tps&quot;
713                 emit(newList, &quot;andp&quot;, &quot;cplt&quot;, node)
714             when &quot;tpz&quot;
715                 emit(newList, &quot;andp&quot;, &quot;cpeq&quot;, node)
716             when &quot;tpnz&quot;
717                 emit(newList, &quot;andp&quot;, &quot;cpneq&quot;, node)
718             when &quot;tqs&quot;
719                 emit(newList, &quot;andq&quot;, &quot;cqlt&quot;, node)
720             when &quot;tqz&quot;
721                 emit(newList, &quot;andq&quot;, &quot;cqeq&quot;, node)
722             when &quot;tqnz&quot;
723                 emit(newList, &quot;andq&quot;, &quot;cqneq&quot;, node)
724             when &quot;tbs&quot;
725                 emit(newList, &quot;andi&quot;, &quot;cblt&quot;, node)
726             when &quot;tbz&quot;
727                 emit(newList, &quot;andi&quot;, &quot;cbeq&quot;, node)
728             when &quot;tbnz&quot;
729                 emit(newList, &quot;andi&quot;, &quot;cbneq&quot;, node)
730             else
731                 newList &lt;&lt; node
732             end
733         else
734             newList &lt;&lt; node
735         end
736     }
737     return newList
738 end
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GradientImage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,39 ***</span>
      const TextRun* m_textRun;
      unsigned m_offset;
  };
  
  #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
<span class="line-modified">!     if ((m_changeFlags &amp; GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \</span>
<span class="line-modified">!         changeFlags |= GraphicsContextState::flag;</span>
  
  GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  {
<span class="line-modified">!     GraphicsContextState::StateChangeFlags changeFlags = GraphicsContextState::NoChange;</span>
  
      CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
      CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
      CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
      CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  
<span class="line-modified">!     if ((m_changeFlags &amp; GraphicsContextState::ShadowChange)</span>
          &amp;&amp; (m_state.shadowOffset != state.shadowOffset
              || m_state.shadowBlur != state.shadowBlur
              || m_state.shadowColor != state.shadowColor))
<span class="line-modified">!         changeFlags |= GraphicsContextState::ShadowChange;</span>
  
      CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
      CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
      CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
      CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
      CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
      CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
      CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
  
<span class="line-modified">!     if ((m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))</span>
<span class="line-modified">!         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode))</span>
<span class="line-modified">!         changeFlags |= (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange);</span>
  
      CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
      CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
      CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
      CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
<span class="line-new-header">--- 70,41 ---</span>
      const TextRun* m_textRun;
      unsigned m_offset;
  };
  
  #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \</span>
<span class="line-modified">!         changeFlags.add(GraphicsContextState::flag);</span>
  
  GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  {
<span class="line-modified">!     GraphicsContextState::StateChangeFlags changeFlags;</span>
  
      CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
      CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
      CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
      CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)</span>
          &amp;&amp; (m_state.shadowOffset != state.shadowOffset
              || m_state.shadowBlur != state.shadowBlur
              || m_state.shadowColor != state.shadowColor))
<span class="line-modified">!         changeFlags.add(GraphicsContextState::ShadowChange);</span>
  
      CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
      CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
      CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
      CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
      CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
      CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
      CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
  
<span class="line-modified">!     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })</span>
<span class="line-modified">!         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode)) {</span>
<span class="line-modified">!         changeFlags.add(GraphicsContextState::CompositeOperationChange);</span>
<span class="line-added">+         changeFlags.add(GraphicsContextState::BlendModeChange);</span>
<span class="line-added">+     }</span>
  
      CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
      CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
      CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
      CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,220 ***</span>
  }
  
  void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
  {
      // FIXME: This code should move to GraphicsContextState.
<span class="line-modified">!     if (flags &amp; GraphicsContextState::StrokeGradientChange)</span>
          m_state.strokeGradient = state.strokeGradient;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::StrokePatternChange)</span>
          m_state.strokePattern = state.strokePattern;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::FillGradientChange)</span>
          m_state.fillGradient = state.fillGradient;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::FillPatternChange)</span>
          m_state.fillPattern = state.fillPattern;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ShadowChange) {</span>
          // FIXME: Deal with state.shadowsUseLegacyRadius.
          m_state.shadowOffset = state.shadowOffset;
          m_state.shadowBlur = state.shadowBlur;
          m_state.shadowColor = state.shadowColor;
      }
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::StrokeThicknessChange)</span>
          m_state.strokeThickness = state.strokeThickness;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::TextDrawingModeChange)</span>
          m_state.textDrawingMode = state.textDrawingMode;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::StrokeColorChange)</span>
          m_state.strokeColor = state.strokeColor;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::FillColorChange)</span>
          m_state.fillColor = state.fillColor;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::StrokeStyleChange)</span>
          m_state.strokeStyle = state.strokeStyle;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::FillRuleChange)</span>
          m_state.fillRule = state.fillRule;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::AlphaChange)</span>
          m_state.alpha = state.alpha;
  
<span class="line-modified">!     if (flags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange)) {</span>
          m_state.compositeOperator = state.compositeOperator;
          m_state.blendMode = state.blendMode;
      }
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
          m_state.shouldAntialias = state.shouldAntialias;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
          m_state.shouldSmoothFonts = state.shouldSmoothFonts;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
          m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
          m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
          m_state.drawLuminanceMask = state.drawLuminanceMask;
  
<span class="line-modified">!     if (flags &amp; GraphicsContextState::ImageInterpolationQualityChange)</span>
          m_state.imageInterpolationQuality = state.imageInterpolationQuality;
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (flags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
          m_state.useDarkAppearance = state.useDarkAppearance;
  #endif
  
<span class="line-modified">!     m_changeFlags |= flags;</span>
  }
  
  void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
  {
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)</span>
          context.setStrokeGradient(*m_state.strokeGradient);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)</span>
          context.setStrokePattern(*m_state.strokePattern);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)</span>
          context.setFillGradient(*m_state.fillGradient);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)</span>
          context.setFillPattern(*m_state.fillPattern);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {</span>
  #if USE(CG)
          if (m_state.shadowsUseLegacyRadius)
              context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
          else
  #endif
              context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
      }
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)</span>
          context.setStrokeThickness(m_state.strokeThickness);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)</span>
          context.setTextDrawingMode(m_state.textDrawingMode);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)</span>
          context.setStrokeColor(m_state.strokeColor);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)</span>
          context.setFillColor(m_state.fillColor);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)</span>
          context.setStrokeStyle(m_state.strokeStyle);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)</span>
          context.setFillRule(m_state.fillRule);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)</span>
          context.setAlpha(m_state.alpha);
  
<span class="line-modified">!     if (m_changeFlags &amp; (GraphicsContextState::CompositeOperationChange | GraphicsContextState::BlendModeChange))</span>
          context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
          context.setShouldAntialias(m_state.shouldAntialias);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
          context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
          context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
          context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
          context.setDrawLuminanceMask(m_state.drawLuminanceMask);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ImageInterpolationQualityChange)</span>
          context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
          context.setUseDarkAppearance(m_state.useDarkAppearance);
  #endif
  }
  
  void GraphicsContextStateChange::dump(TextStream&amp; ts) const
  {
<span class="line-modified">!     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags);</span>
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeGradientChange)</span>
          ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokePatternChange)</span>
          ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillGradientChange)</span>
          ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillPatternChange)</span>
          ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShadowChange) {</span>
          ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
          ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
  #if USE(CG)
          ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
  #endif
      }
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeThicknessChange)</span>
          ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::TextDrawingModeChange)</span>
          ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeColorChange)</span>
          ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillColorChange)</span>
          ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::StrokeStyleChange)</span>
          ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::FillRuleChange)</span>
          ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::AlphaChange)</span>
          ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::CompositeOperationChange)</span>
          ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::BlendModeChange)</span>
          ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldAntialiasChange)</span>
          ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldSmoothFontsChange)</span>
          ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShouldSubpixelQuantizeFontsChange)</span>
          ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::ShadowsIgnoreTransformsChange)</span>
          ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
  
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::DrawLuminanceMaskChange)</span>
          ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (m_changeFlags &amp; GraphicsContextState::UseDarkAppearanceChange)</span>
          ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);
  #endif
  }
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
<span class="line-new-header">--- 119,220 ---</span>
  }
  
  void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
  {
      // FIXME: This code should move to GraphicsContextState.
<span class="line-modified">!     if (flags.contains(GraphicsContextState::StrokeGradientChange))</span>
          m_state.strokeGradient = state.strokeGradient;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::StrokePatternChange))</span>
          m_state.strokePattern = state.strokePattern;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::FillGradientChange))</span>
          m_state.fillGradient = state.fillGradient;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::FillPatternChange))</span>
          m_state.fillPattern = state.fillPattern;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ShadowChange)) {</span>
          // FIXME: Deal with state.shadowsUseLegacyRadius.
          m_state.shadowOffset = state.shadowOffset;
          m_state.shadowBlur = state.shadowBlur;
          m_state.shadowColor = state.shadowColor;
      }
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::StrokeThicknessChange))</span>
          m_state.strokeThickness = state.strokeThickness;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::TextDrawingModeChange))</span>
          m_state.textDrawingMode = state.textDrawingMode;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::StrokeColorChange))</span>
          m_state.strokeColor = state.strokeColor;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::FillColorChange))</span>
          m_state.fillColor = state.fillColor;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::StrokeStyleChange))</span>
          m_state.strokeStyle = state.strokeStyle;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::FillRuleChange))</span>
          m_state.fillRule = state.fillRule;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::AlphaChange))</span>
          m_state.alpha = state.alpha;
  
<span class="line-modified">!     if (flags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })) {</span>
          m_state.compositeOperator = state.compositeOperator;
          m_state.blendMode = state.blendMode;
      }
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
          m_state.shouldAntialias = state.shouldAntialias;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
          m_state.shouldSmoothFonts = state.shouldSmoothFonts;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
          m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
          m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
          m_state.drawLuminanceMask = state.drawLuminanceMask;
  
<span class="line-modified">!     if (flags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
          m_state.imageInterpolationQuality = state.imageInterpolationQuality;
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (flags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
          m_state.useDarkAppearance = state.useDarkAppearance;
  #endif
  
<span class="line-modified">!     m_changeFlags.add(flags);</span>
  }
  
  void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
  {
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))</span>
          context.setStrokeGradient(*m_state.strokeGradient);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))</span>
          context.setStrokePattern(*m_state.strokePattern);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))</span>
          context.setFillGradient(*m_state.fillGradient);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))</span>
          context.setFillPattern(*m_state.fillPattern);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
  #if USE(CG)
          if (m_state.shadowsUseLegacyRadius)
              context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
          else
  #endif
              context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
      }
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
          context.setStrokeThickness(m_state.strokeThickness);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
          context.setTextDrawingMode(m_state.textDrawingMode);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
          context.setStrokeColor(m_state.strokeColor);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))</span>
          context.setFillColor(m_state.fillColor);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
          context.setStrokeStyle(m_state.strokeStyle);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
          context.setFillRule(m_state.fillRule);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))</span>
          context.setAlpha(m_state.alpha);
  
<span class="line-modified">!     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange }))</span>
          context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
          context.setShouldAntialias(m_state.shouldAntialias);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
          context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
          context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
          context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
          context.setDrawLuminanceMask(m_state.drawLuminanceMask);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))</span>
          context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
          context.setUseDarkAppearance(m_state.useDarkAppearance);
  #endif
  }
  
  void GraphicsContextStateChange::dump(TextStream&amp; ts) const
  {
<span class="line-modified">!     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags.toRaw());</span>
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))</span>
          ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))</span>
          ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))</span>
          ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))</span>
          ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {</span>
          ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
          ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
  #if USE(CG)
          ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
  #endif
      }
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))</span>
          ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))</span>
          ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))</span>
          ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))</span>
          ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))</span>
          ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))</span>
          ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))</span>
          ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::CompositeOperationChange))</span>
          ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::BlendModeChange))</span>
          ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))</span>
          ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))</span>
          ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))</span>
          ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))</span>
          ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
  
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))</span>
          ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
  
  #if HAVE(OS_DARK_MODE_SUPPORT)
<span class="line-modified">!     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))</span>
          ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);
  #endif
  }
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1115,11 ***</span>
      if (printing)
          return FloatRect(origin, FloatSize(rect.width(), thickness));
  
      AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
      // Just compute scale in x dimension, assuming x and y scales are equal.
<span class="line-modified">!     float scale = transform.b() ? sqrtf(transform.a() * transform.a() + transform.b() * transform.b()) : transform.a();</span>
      if (scale &lt; 1.0) {
          // This code always draws a line that is at least one-pixel line high,
          // which tends to visually overwhelm text at small scales. To counter this
          // effect, an alpha is applied to the underline color when text is at small scales.
          static const float minimumUnderlineAlpha = 0.4f;
<span class="line-new-header">--- 1117,11 ---</span>
      if (printing)
          return FloatRect(origin, FloatSize(rect.width(), thickness));
  
      AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
      // Just compute scale in x dimension, assuming x and y scales are equal.
<span class="line-modified">!     float scale = transform.b() ? std::hypot(transform.a(), transform.b()) : transform.a();</span>
      if (scale &lt; 1.0) {
          // This code always draws a line that is at least one-pixel line high,
          // which tends to visually overwhelm text at small scales. To counter this
          // effect, an alpha is applied to the underline color when text is at small scales.
          static const float minimumUnderlineAlpha = 0.4f;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1133,11 ***</span>
      if (auto inverse = transform.inverse())
          origin = inverse.value().mapPoint(deviceOrigin);
      return FloatRect(origin, FloatSize(rect.width(), thickness));
  }
  
<span class="line-modified">! void GraphicsContext::applyState(const GraphicsContextState&amp; state)</span>
  {
      setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
      setPlatformStrokeThickness(state.strokeThickness);
      setPlatformTextDrawingMode(state.textDrawingMode);
      setPlatformStrokeColor(state.strokeColor);
<span class="line-new-header">--- 1135,11 ---</span>
      if (auto inverse = transform.inverse())
          origin = inverse.value().mapPoint(deviceOrigin);
      return FloatRect(origin, FloatSize(rect.width(), thickness));
  }
  
<span class="line-modified">! void GraphicsContext::builderState(const GraphicsContextState&amp; state)</span>
  {
      setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
      setPlatformStrokeThickness(state.strokeThickness);
      setPlatformTextDrawingMode(state.textDrawingMode);
      setPlatformStrokeColor(state.strokeColor);
</pre>
<center><a href="GradientImage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
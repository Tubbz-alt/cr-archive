diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp
@@ -34,13 +34,13 @@
 
 namespace JSC {
 
 class JITWorklist::Plan : public ThreadSafeRefCounted<JITWorklist::Plan> {
 public:
-    Plan(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)
+    Plan(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)
         : m_codeBlock(codeBlock)
-        , m_jit(codeBlock->vm(), codeBlock, loopOSREntryBytecodeOffset)
+        , m_jit(codeBlock->vm(), codeBlock, loopOSREntryBytecodeIndex)
     {
         m_jit.doMainThreadPreparationBeforeCompile();
     }
 
     void compileInThread()
@@ -55,18 +55,16 @@
     {
         CompilationResult result = m_jit.link();
         switch (result) {
         case CompilationFailed:
             CODEBLOCK_LOG_EVENT(m_codeBlock, "delayJITCompile", ("compilation failed"));
-            if (Options::verboseOSR())
-                dataLogF("    JIT compilation failed.\n");
+            dataLogLnIf(Options::verboseOSR(), "    JIT compilation failed.");
             m_codeBlock->dontJITAnytimeSoon();
             m_codeBlock->m_didFailJITCompilation = true;
             return;
         case CompilationSuccessful:
-            if (Options::verboseOSR())
-                dataLogF("    JIT compilation successful.\n");
+            dataLogLnIf(Options::verboseOSR(), "    JIT compilation successful.");
             m_codeBlock->ownerExecutable()->installCode(m_codeBlock);
             m_codeBlock->jitSoon();
             return;
         default:
             RELEASE_ASSERT_NOT_REACHED();
@@ -81,13 +79,13 @@
     {
         LockHolder locker(m_lock);
         return m_isFinishedCompiling;
     }
 
-    static void compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)
+    static void compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)
     {
-        Plan plan(codeBlock, loopOSREntryBytecodeOffset);
+        Plan plan(codeBlock, loopOSREntryBytecodeIndex);
         plan.compileInThread();
         plan.finalize();
     }
 
 private:
@@ -226,22 +224,22 @@
     }
 
     finalizePlans(myPlans);
 }
 
-void JITWorklist::compileLater(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)
+void JITWorklist::compileLater(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)
 {
     DeferGC deferGC(codeBlock->vm().heap);
     RELEASE_ASSERT(codeBlock->jitType() == JITType::InterpreterThunk);
 
     if (codeBlock->m_didFailJITCompilation) {
         codeBlock->dontJITAnytimeSoon();
         return;
     }
 
     if (!Options::useConcurrentJIT()) {
-        Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);
+        Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);
         return;
     }
 
     codeBlock->jitSoon();
 
@@ -251,11 +249,11 @@
         if (m_planned.contains(codeBlock))
             return;
 
         if (m_numAvailableThreads) {
             m_planned.add(codeBlock);
-            RefPtr<Plan> plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeOffset));
+            RefPtr<Plan> plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeIndex));
             m_plans.append(plan);
             m_queue.append(plan);
             m_condition->notifyAll(locker);
             return;
         }
@@ -275,14 +273,14 @@
     // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
     // time postponing when it happens, which means that the convoy delays are less predictable.
     // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
     // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
     // can do that someday.
-    Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);
+    Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);
 }
 
-void JITWorklist::compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)
+void JITWorklist::compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)
 {
     VM& vm = codeBlock->vm();
     DeferGC deferGC(vm.heap);
     if (codeBlock->jitType() != JITType::InterpreterThunk)
         return;
@@ -306,11 +304,11 @@
     // We do this in case we had previously attempted, and then failed, to compile with the
     // baseline JIT.
     codeBlock->resetJITData();
 
     // OK, just compile it.
-    JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeOffset);
+    JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeIndex);
     codeBlock->ownerExecutable()->installCode(codeBlock);
 }
 
 void JITWorklist::finalizePlans(Plans& myPlans)
 {

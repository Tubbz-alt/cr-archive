<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEDropShadow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FEComposite.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FEDropShadow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FEDropShadow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 91     if (!sourceImage)
 92         return;
 93 
 94     GraphicsContext&amp; resultContext = resultImage-&gt;context();
 95     resultContext.setAlpha(m_shadowOpacity);
 96     resultContext.drawImageBuffer(*sourceImage, drawingRegionWithOffset);
 97     resultContext.setAlpha(1);
 98 
 99     ShadowBlur contextShadow(blurRadius, offset, m_shadowColor);
100 
101     // TODO: Direct pixel access to ImageBuffer would avoid copying the ImageData.
102     IntRect shadowArea(IntPoint(), resultImage-&gt;internalSize());
103     auto srcPixelArray = resultImage-&gt;getPremultipliedImageData(shadowArea, nullptr, ImageBuffer::BackingStoreCoordinateSystem);
104     if (!srcPixelArray)
105         return;
106 
107     contextShadow.blurLayerImage(srcPixelArray-&gt;data(), shadowArea.size(), 4 * shadowArea.size().width());
108 
109     resultImage-&gt;putByteArray(*srcPixelArray, AlphaPremultiplication::Premultiplied, shadowArea.size(), shadowArea, IntPoint(), ImageBuffer::BackingStoreCoordinateSystem);
110 
<span class="line-modified">111     resultContext.setCompositeOperation(CompositeSourceIn);</span>
112     resultContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()), m_shadowColor);
<span class="line-modified">113     resultContext.setCompositeOperation(CompositeDestinationOver);</span>
114 
115     resultImage-&gt;context().drawImageBuffer(*sourceImage, drawingRegion);
116 }
117 











118 TextStream&amp; FEDropShadow::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
119 {
120     ts &lt;&lt; indent &lt;&lt;&quot;[feDropShadow&quot;;
121     FilterEffect::externalRepresentation(ts, representation);
122     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot; dx=\&quot;&quot; &lt;&lt; m_dx &lt;&lt; &quot;\&quot; dy=\&quot;&quot; &lt;&lt; m_dy &lt;&lt; &quot;\&quot; flood-color=\&quot;&quot; &lt;&lt; m_shadowColor.nameForRenderTreeAsText() &lt;&lt;&quot;\&quot; flood-opacity=\&quot;&quot; &lt;&lt; m_shadowOpacity &lt;&lt; &quot;]\n&quot;;
123 
124     TextStream::IndentScope indentScope(ts);
125     inputEffect(0)-&gt;externalRepresentation(ts, representation);
126     return ts;
127 }
128 
129 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 91     if (!sourceImage)
 92         return;
 93 
 94     GraphicsContext&amp; resultContext = resultImage-&gt;context();
 95     resultContext.setAlpha(m_shadowOpacity);
 96     resultContext.drawImageBuffer(*sourceImage, drawingRegionWithOffset);
 97     resultContext.setAlpha(1);
 98 
 99     ShadowBlur contextShadow(blurRadius, offset, m_shadowColor);
100 
101     // TODO: Direct pixel access to ImageBuffer would avoid copying the ImageData.
102     IntRect shadowArea(IntPoint(), resultImage-&gt;internalSize());
103     auto srcPixelArray = resultImage-&gt;getPremultipliedImageData(shadowArea, nullptr, ImageBuffer::BackingStoreCoordinateSystem);
104     if (!srcPixelArray)
105         return;
106 
107     contextShadow.blurLayerImage(srcPixelArray-&gt;data(), shadowArea.size(), 4 * shadowArea.size().width());
108 
109     resultImage-&gt;putByteArray(*srcPixelArray, AlphaPremultiplication::Premultiplied, shadowArea.size(), shadowArea, IntPoint(), ImageBuffer::BackingStoreCoordinateSystem);
110 
<span class="line-modified">111     resultContext.setCompositeOperation(CompositeOperator::SourceIn);</span>
112     resultContext.fillRect(FloatRect(FloatPoint(), absolutePaintRect().size()), m_shadowColor);
<span class="line-modified">113     resultContext.setCompositeOperation(CompositeOperator::DestinationOver);</span>
114 
115     resultImage-&gt;context().drawImageBuffer(*sourceImage, drawingRegion);
116 }
117 
<span class="line-added">118 IntOutsets FEDropShadow::outsets() const</span>
<span class="line-added">119 {</span>
<span class="line-added">120     IntSize outsetSize = FEGaussianBlur::calculateOutsetSize({ m_stdX, m_stdY });</span>
<span class="line-added">121     return {</span>
<span class="line-added">122         std::max&lt;int&gt;(0, outsetSize.height() - m_dy),</span>
<span class="line-added">123         std::max&lt;int&gt;(0, outsetSize.width() + m_dx),</span>
<span class="line-added">124         std::max&lt;int&gt;(0, outsetSize.height() + m_dy),</span>
<span class="line-added">125         std::max&lt;int&gt;(0, outsetSize.width() - m_dx)</span>
<span class="line-added">126     };</span>
<span class="line-added">127 }</span>
<span class="line-added">128 </span>
129 TextStream&amp; FEDropShadow::externalRepresentation(TextStream&amp; ts, RepresentationType representation) const
130 {
131     ts &lt;&lt; indent &lt;&lt;&quot;[feDropShadow&quot;;
132     FilterEffect::externalRepresentation(ts, representation);
133     ts &lt;&lt; &quot; stdDeviation=\&quot;&quot; &lt;&lt; m_stdX &lt;&lt; &quot;, &quot; &lt;&lt; m_stdY &lt;&lt; &quot;\&quot; dx=\&quot;&quot; &lt;&lt; m_dx &lt;&lt; &quot;\&quot; dy=\&quot;&quot; &lt;&lt; m_dy &lt;&lt; &quot;\&quot; flood-color=\&quot;&quot; &lt;&lt; m_shadowColor.nameForRenderTreeAsText() &lt;&lt;&quot;\&quot; flood-opacity=\&quot;&quot; &lt;&lt; m_shadowOpacity &lt;&lt; &quot;]\n&quot;;
134 
135     TextStream::IndentScope indentScope(ts);
136     inputEffect(0)-&gt;externalRepresentation(ts, representation);
137     return ts;
138 }
139 
140 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FEComposite.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="FEDropShadow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
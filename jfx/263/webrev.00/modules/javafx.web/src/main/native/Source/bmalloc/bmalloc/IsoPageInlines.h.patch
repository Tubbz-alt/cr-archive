diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h
@@ -45,12 +45,12 @@
 }
 
 template<typename Config>
 IsoPage<Config>::IsoPage(IsoDirectoryBase<Config>& directory, unsigned index)
     : IsoPageBase(false)
-    , m_directory(directory)
     , m_index(index)
+    , m_directory(directory)
 {
     memset(m_allocBits, 0, sizeof(m_allocBits));
 }
 
 inline IsoPageBase* IsoPageBase::pageFor(void* ptr)
@@ -63,33 +63,33 @@
 {
     return reinterpret_cast<IsoPage<Config>*>(IsoPageBase::pageFor(ptr));
 }
 
 template<typename Config>
-void IsoPage<Config>::free(void* passedPtr)
+void IsoPage<Config>::free(const LockHolder& locker, void* passedPtr)
 {
     BASSERT(!m_isShared);
     unsigned offset = static_cast<char*>(passedPtr) - reinterpret_cast<char*>(this);
     unsigned index = offset / Config::objectSize;
 
     if (!m_eligibilityHasBeenNoted) {
-        m_eligibilityTrigger.didBecome(*this);
+        m_eligibilityTrigger.didBecome(locker, *this);
         m_eligibilityHasBeenNoted = true;
     }
 
     unsigned wordIndex = index / 32;
     unsigned bitIndex = index % 32;
 
     unsigned newWord = m_allocBits[wordIndex] &= ~(1 << bitIndex);
     if (!newWord) {
         if (!--m_numNonEmptyWords)
-            m_emptyTrigger.didBecome(*this);
+            m_emptyTrigger.didBecome(locker, *this);
     }
 }
 
 template<typename Config>
-FreeList IsoPage<Config>::startAllocating()
+FreeList IsoPage<Config>::startAllocating(const LockHolder&)
 {
     static constexpr bool verbose = false;
 
     if (verbose)
         fprintf(stderr, "%p: starting allocation.\n", this);
@@ -206,32 +206,32 @@
     result.initializeList(head, secret, bytes);
     return result;
 }
 
 template<typename Config>
-void IsoPage<Config>::stopAllocating(FreeList freeList)
+void IsoPage<Config>::stopAllocating(const LockHolder& locker, FreeList freeList)
 {
     static constexpr bool verbose = false;
 
     if (verbose)
         fprintf(stderr, "%p: stopping allocation.\n", this);
 
     freeList.forEach<Config>(
         [&] (void* ptr) {
-            free(ptr);
+            free(locker, ptr);
         });
 
     RELEASE_BASSERT(m_isInUseForAllocation);
     m_isInUseForAllocation = false;
 
-    m_eligibilityTrigger.handleDeferral(*this);
-    m_emptyTrigger.handleDeferral(*this);
+    m_eligibilityTrigger.handleDeferral(locker, *this);
+    m_emptyTrigger.handleDeferral(locker, *this);
 }
 
 template<typename Config>
 template<typename Func>
-void IsoPage<Config>::forEachLiveObject(const Func& func)
+void IsoPage<Config>::forEachLiveObject(const LockHolder&, const Func& func)
 {
     for (unsigned wordIndex = 0; wordIndex < bitsArrayLength(numObjects); ++wordIndex) {
         unsigned word = m_allocBits[wordIndex];
         if (!word)
             continue;

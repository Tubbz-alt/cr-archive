<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../b3/testb3_8.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptFunctionCall.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,24 ***</span>
  
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSLock.h&quot;
  #include &lt;wtf/text/WTFString.h&gt;
  
<span class="line-removed">- using namespace JSC;</span>
<span class="line-removed">- </span>
  namespace Deprecated {
  
  void ScriptCallArgumentHandler::appendArgument(const String&amp; argument)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      m_arguments.append(jsString(vm, argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(const char* argument)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      m_arguments.append(jsString(vm, String(argument)));
  }
  
  void ScriptCallArgumentHandler::appendArgument(JSValue argument)
<span class="line-new-header">--- 34,24 ---</span>
  
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSLock.h&quot;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace Deprecated {
  
<span class="line-added">+ using namespace JSC;</span>
<span class="line-added">+ </span>
  void ScriptCallArgumentHandler::appendArgument(const String&amp; argument)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      m_arguments.append(jsString(vm, argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(const char* argument)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      m_arguments.append(jsString(vm, String(argument)));
  }
  
  void ScriptCallArgumentHandler::appendArgument(JSValue argument)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,88 ***</span>
      m_arguments.append(argument);
  }
  
  void ScriptCallArgumentHandler::appendArgument(long argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_exec);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(long long argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_exec);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(unsigned int argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_exec);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(uint64_t argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_exec);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(int argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_exec);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(bool argument)
  {
      m_arguments.append(jsBoolean(argument));
  }
  
  ScriptFunctionCall::ScriptFunctionCall(const Deprecated::ScriptObject&amp; thisObject, const String&amp; name, ScriptFunctionCallHandler callHandler)
<span class="line-modified">!     : ScriptCallArgumentHandler(thisObject.scriptState())</span>
      , m_callHandler(callHandler)
      , m_thisObject(thisObject)
      , m_name(name)
  {
  }
  
<span class="line-modified">! JSValue ScriptFunctionCall::call(bool&amp; hadException)</span>
  {
      JSObject* thisObject = m_thisObject.jsObject();
  
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue function = thisObject-&gt;get(m_exec, Identifier::fromString(vm, m_name));</span>
<span class="line-modified">!     if (UNLIKELY(scope.exception())) {</span>
<span class="line-modified">!         hadException = true;</span>
<span class="line-removed">-         return { };</span>
<span class="line-removed">-     }</span>
  
      CallData callData;
      CallType callType = getCallData(vm, function, callData);
      if (callType == CallType::None)
          return { };
  
      JSValue result;
      NakedPtr&lt;Exception&gt; exception;
      if (m_callHandler)
<span class="line-modified">!         result = m_callHandler(m_exec, function, callType, callData, thisObject, m_arguments, exception);</span>
      else
<span class="line-modified">!         result = JSC::call(m_exec, function, callType, callData, thisObject, m_arguments, exception);</span>
  
      if (exception) {
          // Do not treat a terminated execution exception as having an exception. Just treat it as an empty result.
<span class="line-modified">!         hadException = !isTerminatedExecutionException(vm, exception);</span>
          return { };
      }
  
      return result;
  }
  
<span class="line-removed">- JSC::JSValue ScriptFunctionCall::call()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     bool hadException;</span>
<span class="line-removed">-     return call(hadException);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  } // namespace Deprecated
<span class="line-new-header">--- 59,81 ---</span>
      m_arguments.append(argument);
  }
  
  void ScriptCallArgumentHandler::appendArgument(long argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_globalObject);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(long long argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_globalObject);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(unsigned int argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_globalObject);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(uint64_t argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_globalObject);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(int argument)
  {
<span class="line-modified">!     JSLockHolder lock(m_globalObject);</span>
      m_arguments.append(jsNumber(argument));
  }
  
  void ScriptCallArgumentHandler::appendArgument(bool argument)
  {
      m_arguments.append(jsBoolean(argument));
  }
  
  ScriptFunctionCall::ScriptFunctionCall(const Deprecated::ScriptObject&amp; thisObject, const String&amp; name, ScriptFunctionCallHandler callHandler)
<span class="line-modified">!     : ScriptCallArgumentHandler(thisObject.globalObject())</span>
      , m_callHandler(callHandler)
      , m_thisObject(thisObject)
      , m_name(name)
  {
  }
  
<span class="line-modified">! Expected&lt;JSValue, NakedPtr&lt;Exception&gt;&gt; ScriptFunctionCall::call()</span>
  {
      JSObject* thisObject = m_thisObject.jsObject();
  
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue function = thisObject-&gt;get(m_globalObject, Identifier::fromString(vm, m_name));</span>
<span class="line-modified">!     if (UNLIKELY(scope.exception()))</span>
<span class="line-modified">!         return makeUnexpected(scope.exception());</span>
  
      CallData callData;
      CallType callType = getCallData(vm, function, callData);
      if (callType == CallType::None)
          return { };
  
      JSValue result;
      NakedPtr&lt;Exception&gt; exception;
      if (m_callHandler)
<span class="line-modified">!         result = m_callHandler(m_globalObject, function, callType, callData, thisObject, m_arguments, exception);</span>
      else
<span class="line-modified">!         result = JSC::call(m_globalObject, function, callType, callData, thisObject, m_arguments, exception);</span>
  
      if (exception) {
          // Do not treat a terminated execution exception as having an exception. Just treat it as an empty result.
<span class="line-modified">!         if (!isTerminatedExecutionException(vm, exception))</span>
<span class="line-added">+             return makeUnexpected(exception);</span>
          return { };
      }
  
      return result;
  }
  
  } // namespace Deprecated
</pre>
<center><a href="../b3/testb3_8.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptFunctionCall.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
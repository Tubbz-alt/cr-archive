<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../page/scrolling/nicosia/ScrollingTreeStickyNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CalculationValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,11 ***</span>
      ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_value);
  }
  
  bool CalcExpressionNumber::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return other.type() == CalcExpressionNodeType::Number &amp;&amp; *this == toCalcExpressionNumber(other);</span>
  }
  
  float CalculationValue::evaluate(float maxValue) const
  {
      float result = m_expression-&gt;evaluate(maxValue);
<span class="line-new-header">--- 53,11 ---</span>
      ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_value);
  }
  
  bool CalcExpressionNumber::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return is&lt;CalcExpressionNumber&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNumber&gt;(other);</span>
  }
  
  float CalculationValue::evaluate(float maxValue) const
  {
      float result = m_expression-&gt;evaluate(maxValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,32 ***</span>
      if (std::isnan(result))
          return 0;
      return m_shouldClampToNonNegative &amp;&amp; result &lt; 0 ? 0 : result;
  }
  
  float CalcExpressionOperation::evaluate(float maxValue) const
  {
      switch (m_operator) {
      case CalcOperator::Add: {
<span class="line-modified">!         ASSERT(m_children.size() == 2);</span>
<span class="line-modified">!         float left = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         float right = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         return left + right;</span>
      }
      case CalcOperator::Subtract: {
          ASSERT(m_children.size() == 2);
          float left = m_children[0]-&gt;evaluate(maxValue);
          float right = m_children[1]-&gt;evaluate(maxValue);
          return left - right;
      }
      case CalcOperator::Multiply: {
<span class="line-modified">!         ASSERT(m_children.size() == 2);</span>
<span class="line-modified">!         float left = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         float right = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         return left * right;</span>
      }
      case CalcOperator::Divide: {
          ASSERT(m_children.size() == 1 || m_children.size() == 2);
          if (m_children.size() == 1)
              return std::numeric_limits&lt;float&gt;::quiet_NaN();
          float left = m_children[0]-&gt;evaluate(maxValue);
          float right = m_children[1]-&gt;evaluate(maxValue);
<span class="line-new-header">--- 66,78 ---</span>
      if (std::isnan(result))
          return 0;
      return m_shouldClampToNonNegative &amp;&amp; result &lt; 0 ? 0 : result;
  }
  
<span class="line-added">+ float CalcExpressionNegation::evaluate(float maxValue) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return -m_child-&gt;evaluate(maxValue);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CalcExpressionNegation::operator==(const CalcExpressionNode&amp; other) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return is&lt;CalcExpressionNegation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNegation&gt;(other);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CalcExpressionNegation::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;-(&quot;;</span>
<span class="line-added">+     ts &lt;&lt; *m_child;</span>
<span class="line-added">+     ts &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool operator==(const CalcExpressionNegation&amp; a, const CalcExpressionNegation&amp; b)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return *a.child() == *b.child();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ float CalcExpressionInversion::evaluate(float maxValue) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return 1.0f / m_child-&gt;evaluate(maxValue);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CalcExpressionInversion::dump(TextStream&amp; ts) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ts &lt;&lt; &quot;1.0 / &quot; &lt;&lt; &quot;(&quot;;</span>
<span class="line-added">+     ts &lt;&lt; *m_child;</span>
<span class="line-added">+     ts &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CalcExpressionInversion::operator==(const CalcExpressionNode&amp; other) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return is&lt;CalcExpressionInversion&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionInversion&gt;(other);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool operator==(const CalcExpressionInversion&amp; a, const CalcExpressionInversion&amp; b)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return *a.child() == *b.child();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  float CalcExpressionOperation::evaluate(float maxValue) const
  {
      switch (m_operator) {
      case CalcOperator::Add: {
<span class="line-modified">!         float sum = 0;</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             sum += child-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         return sum;</span>
      }
      case CalcOperator::Subtract: {
<span class="line-added">+         // FIXME</span>
          ASSERT(m_children.size() == 2);
          float left = m_children[0]-&gt;evaluate(maxValue);
          float right = m_children[1]-&gt;evaluate(maxValue);
          return left - right;
      }
      case CalcOperator::Multiply: {
<span class="line-modified">!         float product = 1;</span>
<span class="line-modified">!         for (auto&amp; child : m_children)</span>
<span class="line-modified">!             product *= child-&gt;evaluate(maxValue);</span>
<span class="line-modified">!         return product;</span>
      }
      case CalcOperator::Divide: {
<span class="line-added">+         // FIXME</span>
          ASSERT(m_children.size() == 1 || m_children.size() == 2);
          if (m_children.size() == 1)
              return std::numeric_limits&lt;float&gt;::quiet_NaN();
          float left = m_children[0]-&gt;evaluate(maxValue);
          float right = m_children[1]-&gt;evaluate(maxValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,18 ***</span>
          float maximum = m_children[0]-&gt;evaluate(maxValue);
          for (auto&amp; child : m_children)
              maximum = std::max(maximum, child-&gt;evaluate(maxValue));
          return maximum;
      }
      }
      ASSERT_NOT_REACHED();
      return std::numeric_limits&lt;float&gt;::quiet_NaN();
  }
  
  bool CalcExpressionOperation::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return other.type() == CalcExpressionNodeType::Operation &amp;&amp; *this == toCalcExpressionOperation(other);</span>
  }
  
  bool operator==(const CalcExpressionOperation&amp; a, const CalcExpressionOperation&amp; b)
  {
      if (a.getOperator() != b.getOperator())
<span class="line-new-header">--- 157,27 ---</span>
          float maximum = m_children[0]-&gt;evaluate(maxValue);
          for (auto&amp; child : m_children)
              maximum = std::max(maximum, child-&gt;evaluate(maxValue));
          return maximum;
      }
<span class="line-added">+     case CalcOperator::Clamp: {</span>
<span class="line-added">+         if (m_children.size() != 3)</span>
<span class="line-added">+             return std::numeric_limits&lt;float&gt;::quiet_NaN();</span>
<span class="line-added">+ </span>
<span class="line-added">+         float min = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-added">+         float value = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-added">+         float max = m_children[2]-&gt;evaluate(maxValue);</span>
<span class="line-added">+         return std::max(min, std::min(value, max));</span>
<span class="line-added">+     }</span>
      }
      ASSERT_NOT_REACHED();
      return std::numeric_limits&lt;float&gt;::quiet_NaN();
  }
  
  bool CalcExpressionOperation::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return is&lt;CalcExpressionOperation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionOperation&gt;(other);</span>
  }
  
  bool operator==(const CalcExpressionOperation&amp; a, const CalcExpressionOperation&amp; b)
  {
      if (a.getOperator() != b.getOperator())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
      return floatValueForLength(m_length, maxValue);
  }
  
  bool CalcExpressionLength::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return other.type() == CalcExpressionNodeType::Length &amp;&amp; *this == toCalcExpressionLength(other);</span>
  }
  
  void CalcExpressionLength::dump(TextStream&amp; ts) const
  {
      ts &lt;&lt; m_length;
<span class="line-new-header">--- 212,11 ---</span>
      return floatValueForLength(m_length, maxValue);
  }
  
  bool CalcExpressionLength::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return is&lt;CalcExpressionLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionLength&gt;(other);</span>
  }
  
  void CalcExpressionLength::dump(TextStream&amp; ts) const
  {
      ts &lt;&lt; m_length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,23 ***</span>
      , m_progress(progress)
  {
      // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
      // CalcExpressionBlendLength is only used as a result of animation and they don&#39;t nest in normal cases.
      if (m_from.isCalculated() &amp;&amp; m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">!         m_from = toCalcExpressionBlendLength(m_from.calculationValue().expression()).from();</span>
      if (m_to.isCalculated() &amp;&amp; m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">!         m_to = toCalcExpressionBlendLength(m_to.calculationValue().expression()).to();</span>
  }
  
  float CalcExpressionBlendLength::evaluate(float maxValue) const
  {
      return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
  }
  
  bool CalcExpressionBlendLength::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return other.type() == CalcExpressionNodeType::BlendLength &amp;&amp; *this == toCalcExpressionBlendLength(other);</span>
  }
  
  void CalcExpressionBlendLength::dump(TextStream&amp; ts) const
  {
      ts &lt;&lt; &quot;blend(&quot; &lt;&lt; m_from &lt;&lt; &quot;, &quot; &lt;&lt; m_to &lt;&lt; &quot;, &quot; &lt;&lt; m_progress &lt;&lt; &quot;)&quot;;
<span class="line-new-header">--- 229,23 ---</span>
      , m_progress(progress)
  {
      // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
      // CalcExpressionBlendLength is only used as a result of animation and they don&#39;t nest in normal cases.
      if (m_from.isCalculated() &amp;&amp; m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">!         m_from = downcast&lt;CalcExpressionBlendLength&gt;(m_from.calculationValue().expression()).from();</span>
      if (m_to.isCalculated() &amp;&amp; m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">!         m_to = downcast&lt;CalcExpressionBlendLength&gt;(m_to.calculationValue().expression()).to();</span>
  }
  
  float CalcExpressionBlendLength::evaluate(float maxValue) const
  {
      return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
  }
  
  bool CalcExpressionBlendLength::operator==(const CalcExpressionNode&amp; other) const
  {
<span class="line-modified">!     return is&lt;CalcExpressionBlendLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionBlendLength&gt;(other);</span>
  }
  
  void CalcExpressionBlendLength::dump(TextStream&amp; ts) const
  {
      ts &lt;&lt; &quot;blend(&quot; &lt;&lt; m_from &lt;&lt; &quot;, &quot; &lt;&lt; m_to &lt;&lt; &quot;, &quot; &lt;&lt; m_progress &lt;&lt; &quot;)&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,12 ***</span>
      switch (op) {
      case CalcOperator::Add: ts &lt;&lt; &quot;+&quot;; break;
      case CalcOperator::Subtract: ts &lt;&lt; &quot;-&quot;; break;
      case CalcOperator::Multiply: ts &lt;&lt; &quot;*&quot;; break;
      case CalcOperator::Divide: ts &lt;&lt; &quot;/&quot;; break;
<span class="line-modified">!     case CalcOperator::Min: ts &lt;&lt; &quot;max&quot;; break;</span>
<span class="line-modified">!     case CalcOperator::Max: ts &lt;&lt; &quot;min&quot;; break;</span>
      }
      return ts;
  }
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalculationValue&amp; value)
<span class="line-new-header">--- 256,13 ---</span>
      switch (op) {
      case CalcOperator::Add: ts &lt;&lt; &quot;+&quot;; break;
      case CalcOperator::Subtract: ts &lt;&lt; &quot;-&quot;; break;
      case CalcOperator::Multiply: ts &lt;&lt; &quot;*&quot;; break;
      case CalcOperator::Divide: ts &lt;&lt; &quot;/&quot;; break;
<span class="line-modified">!     case CalcOperator::Min: ts &lt;&lt; &quot;min&quot;; break;</span>
<span class="line-modified">!     case CalcOperator::Max: ts &lt;&lt; &quot;max&quot;; break;</span>
<span class="line-added">+     case CalcOperator::Clamp: ts &lt;&lt; &quot;clamp&quot;; break;</span>
      }
      return ts;
  }
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalculationValue&amp; value)
</pre>
<center><a href="../page/scrolling/nicosia/ScrollingTreeStickyNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CalculationValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/WorkerSWClientConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WorkerSWClientConnection.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;SecurityOrigin.h&quot;
 32 #include &quot;ServiceWorkerClientData.h&quot;
 33 #include &quot;ServiceWorkerFetchResult.h&quot;
 34 #include &quot;ServiceWorkerJobData.h&quot;
 35 #include &quot;ServiceWorkerProvider.h&quot;
 36 #include &quot;ServiceWorkerRegistration.h&quot;
 37 #include &quot;WorkerGlobalScope.h&quot;
 38 #include &quot;WorkerThread.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 WorkerSWClientConnection::WorkerSWClientConnection(WorkerGlobalScope&amp; scope)
 43     : m_thread(scope.thread())
 44 {
 45 }
 46 
 47 WorkerSWClientConnection::~WorkerSWClientConnection()
 48 {
 49     auto matchRegistrations = WTFMove(m_matchRegistrationRequests);
 50     for (auto&amp; callback : matchRegistrations.values())
 51         callback({ });
 52 
 53     auto getRegistrationsRequests = WTFMove(m_getRegistrationsRequests);
 54     for (auto&amp; callback : getRegistrationsRequests.values())
 55         callback({ });
 56 
 57     auto whenRegistrationReadyRequests = WTFMove(m_whenRegistrationReadyRequests);
 58     for (auto&amp; callback : whenRegistrationReadyRequests.values())
 59         callback({ });
 60 }
 61 
 62 void WorkerSWClientConnection::matchRegistration(SecurityOriginData&amp;&amp; topOrigin, const URL&amp; clientURL, RegistrationCallback&amp;&amp; callback)
 63 {
 64     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 65     m_matchRegistrationRequests.add(requestIdentifier, WTFMove(callback));
 66 
 67     callOnMainThread([thread = m_thread.copyRef(), requestIdentifier, topOrigin = crossThreadCopy(WTFMove(topOrigin)), clientURL = crossThreadCopy(clientURL)]() mutable {
 68         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
 69         connection.matchRegistration(WTFMove(topOrigin), clientURL, [thread = WTFMove(thread), requestIdentifier](auto&amp;&amp; result) mutable {
 70             thread-&gt;runLoop().postTaskForMode([requestIdentifier, result = WTFMove(result)] (auto&amp; scope) mutable {
 71                 auto callback = downcast&lt;WorkerGlobalScope&gt;(scope).swClientConnection().m_matchRegistrationRequests.take(requestIdentifier);
 72                 callback(WTFMove(result));
 73             }, WorkerRunLoop::defaultMode());
 74         });
 75     });
 76 }
 77 
 78 void WorkerSWClientConnection::getRegistrations(SecurityOriginData&amp;&amp; topOrigin, const URL&amp; clientURL, GetRegistrationsCallback&amp;&amp; callback)
 79 {
 80     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 81     m_getRegistrationsRequests.add(requestIdentifier, WTFMove(callback));
 82 
 83     callOnMainThread([thread = m_thread.copyRef(), requestIdentifier, topOrigin = crossThreadCopy(WTFMove(topOrigin)), clientURL = crossThreadCopy(clientURL)]() mutable {
 84         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
 85         connection.getRegistrations(WTFMove(topOrigin), clientURL, [thread = WTFMove(thread), requestIdentifier](auto&amp;&amp; data) mutable {
 86             thread-&gt;runLoop().postTaskForMode([requestIdentifier, data = crossThreadCopy(WTFMove(data))] (auto&amp; scope) mutable {
 87                 auto callback = downcast&lt;WorkerGlobalScope&gt;(scope).swClientConnection().m_getRegistrationsRequests.take(requestIdentifier);
 88                 callback(WTFMove(data));
 89             }, WorkerRunLoop::defaultMode());
 90         });
 91     });
 92 }
 93 
 94 void WorkerSWClientConnection::whenRegistrationReady(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL, WhenRegistrationReadyCallback&amp;&amp; callback)
 95 {
 96     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 97     m_whenRegistrationReadyRequests.add(requestIdentifier, WTFMove(callback));
 98 
 99     callOnMainThread([thread = m_thread.copyRef(), requestIdentifier, topOrigin = topOrigin.isolatedCopy(), clientURL = crossThreadCopy(clientURL)]() mutable {
100         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
101         connection.whenRegistrationReady(topOrigin, clientURL, [thread = WTFMove(thread), requestIdentifier](auto&amp;&amp; result) mutable {
102             thread-&gt;runLoop().postTaskForMode([requestIdentifier, result = crossThreadCopy(WTFMove(result))] (auto&amp; scope) mutable {
103                 auto callback = downcast&lt;WorkerGlobalScope&gt;(scope).swClientConnection().m_whenRegistrationReadyRequests.take(requestIdentifier);
104                 callback(WTFMove(result));
105             }, WorkerRunLoop::defaultMode());
106         });
107     });
108 }
109 
110 void WorkerSWClientConnection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
111 {
112     callOnMainThread([identifier]() mutable {
113         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
114         connection.addServiceWorkerRegistrationInServer(identifier);
115     });
116 }
117 
118 void WorkerSWClientConnection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
119 {
120     callOnMainThread([identifier]() mutable {
121         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
122         connection.removeServiceWorkerRegistrationInServer(identifier);
123     });
124 }
125 
126 void WorkerSWClientConnection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
127 {
128     callOnMainThread([key = crossThreadCopy(key)]() mutable {
129         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
130         connection.didResolveRegistrationPromise(key);
131     });
132 }
133 
134 void WorkerSWClientConnection::postMessageToServiceWorker(ServiceWorkerIdentifier destination, MessageWithMessagePorts&amp;&amp; ports, const ServiceWorkerOrClientIdentifier&amp; source)
135 {
136     callOnMainThreadAndWait([&amp;] {
137         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
138         connection.postMessageToServiceWorker(destination, WTFMove(ports), source);
139     });
140 }
141 
142 SWServerConnectionIdentifier WorkerSWClientConnection::serverConnectionIdentifier() const
143 {
144     SWServerConnectionIdentifier identifier;
145     callOnMainThreadAndWait([&amp;] {
146         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
147         identifier = connection.serverConnectionIdentifier();
148     });
149     return identifier;
150 }
151 
152 bool WorkerSWClientConnection::mayHaveServiceWorkerRegisteredForOrigin(const SecurityOriginData&amp;) const
153 {
154     ASSERT_NOT_REACHED();
155     return true;
156 }
157 
158 void WorkerSWClientConnection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
159 {
160     callOnMainThread([identifier]() mutable {
161         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
162         connection.syncTerminateWorker(identifier);
163     });
164 }
165 
166 void WorkerSWClientConnection::registerServiceWorkerClient(const SecurityOrigin&amp; topOrigin, const ServiceWorkerClientData&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; identifier, const String&amp; userAgent)
167 {
168     callOnMainThread([topOrigin = topOrigin.isolatedCopy(), data = crossThreadCopy(data), identifier, userAgent = crossThreadCopy(userAgent)] {
169         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
170         connection.registerServiceWorkerClient(topOrigin, data, identifier, userAgent);
171     });
172 }
173 
174 void WorkerSWClientConnection::unregisterServiceWorkerClient(DocumentIdentifier)
175 {
176     ASSERT_NOT_REACHED();
177 }
178 
179 void WorkerSWClientConnection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
180 {
181     callOnMainThread([result = crossThreadCopy(result)]() mutable {
182         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
183         connection.finishFetchingScriptInServer(result);
184     });
185 }
186 
187 void WorkerSWClientConnection::scheduleJob(DocumentOrWorkerIdentifier identifier, const ServiceWorkerJobData&amp; data)
188 {
189     callOnMainThread([identifier, data = crossThreadCopy(data)]() mutable {
190         auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
191         connection.scheduleJob(identifier, data);
192     });
193 }
194 
195 void WorkerSWClientConnection::scheduleJobInServer(const ServiceWorkerJobData&amp;)
196 {
197     ASSERT_NOT_REACHED();
198 }
199 
200 } // namespace WebCore
201 
202 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
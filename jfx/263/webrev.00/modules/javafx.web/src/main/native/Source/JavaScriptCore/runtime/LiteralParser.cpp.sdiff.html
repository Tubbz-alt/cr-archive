<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LazyClassStructure.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LiteralParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 #include &quot;ObjectConstructor.h&quot;
  36 #include &quot;JSCInlines.h&quot;
  37 #include &quot;StrongInlines.h&quot;
  38 #include &lt;wtf/ASCIICType.h&gt;
  39 #include &lt;wtf/dtoa.h&gt;
  40 #include &lt;wtf/text/StringConcatenate.h&gt;
  41 
  42 namespace JSC {
  43 
  44 template &lt;typename CharType&gt;
  45 static ALWAYS_INLINE bool isJSONWhiteSpace(const CharType&amp; c)
  46 {
  47     // The JSON RFC 4627 defines a list of allowed characters to be considered
  48     // insignificant white space: http://www.ietf.org/rfc/rfc4627.txt (2. JSON Grammar).
  49     return c == &#39; &#39; || c == 0x9 || c == 0xA || c == 0xD;
  50 }
  51 
  52 template &lt;typename CharType&gt;
  53 bool LiteralParser&lt;CharType&gt;::tryJSONPParse(Vector&lt;JSONPData&gt;&amp; results, bool needsFullSourceInfo)
  54 {
<span class="line-modified">  55     VM&amp; vm = m_exec-&gt;vm();</span>
  56     auto scope = DECLARE_THROW_SCOPE(vm);
  57     if (m_lexer.next() != TokIdentifier)
  58         return false;
  59     do {
  60         Vector&lt;JSONPPathEntry&gt; path;
  61         // Unguarded next to start off the lexer
  62         Identifier name = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  63         JSONPPathEntry entry;
  64         if (name == vm.propertyNames-&gt;varKeyword) {
  65             if (m_lexer.next() != TokIdentifier)
  66                 return false;
  67             entry.m_type = JSONPPathEntryTypeDeclareVar;
  68             entry.m_pathEntryName = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  69             path.append(entry);
  70         } else {
  71             entry.m_type = JSONPPathEntryTypeDot;
  72             entry.m_pathEntryName = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  73             path.append(entry);
  74         }
  75         if (isLexerKeyword(entry.m_pathEntryName))
</pre>
<hr />
<pre>
 119         RETURN_IF_EXCEPTION(scope, false);
 120         results.last().m_value.set(vm, startParseExpressionValue);
 121         if (!results.last().m_value)
 122             return false;
 123         results.last().m_path.swap(path);
 124         if (entry.m_type == JSONPPathEntryTypeCall) {
 125             if (m_lexer.currentToken()-&gt;type != TokRParen)
 126                 return false;
 127             m_lexer.next();
 128         }
 129         if (m_lexer.currentToken()-&gt;type != TokSemi)
 130             break;
 131         m_lexer.next();
 132     } while (m_lexer.currentToken()-&gt;type == TokIdentifier);
 133     return m_lexer.currentToken()-&gt;type == TokEnd;
 134 }
 135 
 136 template &lt;typename CharType&gt;
 137 ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const LChar* characters, size_t length)
 138 {
<span class="line-modified"> 139     VM&amp; vm = m_exec-&gt;vm();</span>
 140     if (!length)
 141         return vm.propertyNames-&gt;emptyIdentifier;
 142     if (characters[0] &gt;= MaximumCachableCharacter)
 143         return Identifier::fromString(vm, characters, length);
 144 
 145     if (length == 1) {
 146         if (!m_shortIdentifiers[characters[0]].isNull())
 147             return m_shortIdentifiers[characters[0]];
 148         m_shortIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 149         return m_shortIdentifiers[characters[0]];
 150     }
 151     if (!m_recentIdentifiers[characters[0]].isNull() &amp;&amp; Identifier::equal(m_recentIdentifiers[characters[0]].impl(), characters, length))
 152         return m_recentIdentifiers[characters[0]];
 153     m_recentIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 154     return m_recentIdentifiers[characters[0]];
 155 }
 156 
 157 template &lt;typename CharType&gt;
 158 ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const UChar* characters, size_t length)
 159 {
<span class="line-modified"> 160     VM&amp; vm = m_exec-&gt;vm();</span>
 161     if (!length)
 162         return vm.propertyNames-&gt;emptyIdentifier;
 163     if (characters[0] &gt;= MaximumCachableCharacter)
 164         return Identifier::fromString(vm, characters, length);
 165 
 166     if (length == 1) {
 167         if (!m_shortIdentifiers[characters[0]].isNull())
 168             return m_shortIdentifiers[characters[0]];
 169         m_shortIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 170         return m_shortIdentifiers[characters[0]];
 171     }
 172     if (!m_recentIdentifiers[characters[0]].isNull() &amp;&amp; Identifier::equal(m_recentIdentifiers[characters[0]].impl(), characters, length))
 173         return m_recentIdentifiers[characters[0]];
 174     m_recentIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 175     return m_recentIdentifiers[characters[0]];
 176 }
 177 
 178 // 256 Latin-1 codes
 179 static constexpr const TokenType TokenTypesOfLatin1Characters[256] = {
 180 /*   0 - Null               */ TokError,
</pre>
<hr />
<pre>
 421 /* 241 - Ll category        */ TokError,
 422 /* 242 - Ll category        */ TokError,
 423 /* 243 - Ll category        */ TokError,
 424 /* 244 - Ll category        */ TokError,
 425 /* 245 - Ll category        */ TokError,
 426 /* 246 - Ll category        */ TokError,
 427 /* 247 - Sm category        */ TokError,
 428 /* 248 - Ll category        */ TokError,
 429 /* 249 - Ll category        */ TokError,
 430 /* 250 - Ll category        */ TokError,
 431 /* 251 - Ll category        */ TokError,
 432 /* 252 - Ll category        */ TokError,
 433 /* 253 - Ll category        */ TokError,
 434 /* 254 - Ll category        */ TokError,
 435 /* 255 - Ll category        */ TokError
 436 };
 437 
 438 template &lt;typename CharType&gt;
 439 ALWAYS_INLINE TokenType LiteralParser&lt;CharType&gt;::Lexer::lex(LiteralParserToken&lt;CharType&gt;&amp; token)
 440 {
<span class="line-modified"> 441 #if !ASSERT_DISABLED</span>
 442     m_currentTokenID++;
 443 #endif
 444 
 445     while (m_ptr &lt; m_end &amp;&amp; isJSONWhiteSpace(*m_ptr))
 446         ++m_ptr;
 447 
 448     ASSERT(m_ptr &lt;= m_end);
 449     if (m_ptr == m_end) {
 450         token.type = TokEnd;
 451         token.start = token.end = m_ptr;
 452         return TokEnd;
 453     }
 454     ASSERT(m_ptr &lt; m_end);
 455     token.type = TokError;
 456     token.start = m_ptr;
 457     CharType character = *m_ptr;
 458     if (LIKELY(isLatin1(character))) {
 459         TokenType tokenType = TokenTypesOfLatin1Characters[character];
 460         switch (tokenType) {
 461         case TokString:
</pre>
<hr />
<pre>
 803         if (m_ptr &gt;= m_end || !isASCIIDigit(*m_ptr)) {
 804             m_lexErrorMessage = &quot;Exponent symbols should be followed by an optional &#39;+&#39; or &#39;-&#39; and then by at least one number&quot;_s;
 805             return TokError;
 806         }
 807 
 808         ++m_ptr;
 809         while (m_ptr &lt; m_end &amp;&amp; isASCIIDigit(*m_ptr))
 810             ++m_ptr;
 811     }
 812 
 813     token.type = TokNumber;
 814     token.end = m_ptr;
 815     size_t parsedLength;
 816     token.numberToken = parseDouble(token.start, token.end - token.start, parsedLength);
 817     return TokNumber;
 818 }
 819 
 820 template &lt;typename CharType&gt;
 821 JSValue LiteralParser&lt;CharType&gt;::parse(ParserState initialState)
 822 {
<span class="line-modified"> 823     VM&amp; vm = m_exec-&gt;vm();</span>
 824     auto scope = DECLARE_THROW_SCOPE(vm);
 825     ParserState state = initialState;
 826     MarkedArgumentBuffer objectStack;
 827     JSValue lastValue;
 828     Vector&lt;ParserState, 16, UnsafeVectorOverflow&gt; stateStack;
 829     Vector&lt;Identifier, 16, UnsafeVectorOverflow&gt; identifierStack;
 830     HashSet&lt;JSObject*&gt; visitedUnderscoreProto;
 831     while (1) {
 832         switch(state) {
 833             startParseArray:
 834             case StartParseArray: {
<span class="line-modified"> 835                 JSArray* array = constructEmptyArray(m_exec, 0);</span>
 836                 RETURN_IF_EXCEPTION(scope, JSValue());
 837                 objectStack.appendWithCrashOnOverflow(array);
 838             }
 839             doParseArrayStartExpression:
 840             FALLTHROUGH;
 841             case DoParseArrayStartExpression: {
 842                 TokenType lastToken = m_lexer.currentToken()-&gt;type;
 843                 if (m_lexer.next() == TokRBracket) {
 844                     if (lastToken == TokComma) {
 845                         m_parseErrorMessage = &quot;Unexpected comma at the end of array expression&quot;_s;
 846                         return JSValue();
 847                     }
 848                     m_lexer.next();
 849                     lastValue = objectStack.takeLast();
 850                     break;
 851                 }
 852 
 853                 stateStack.append(DoParseArrayEndExpression);
 854                 goto startParseExpression;
 855             }
 856             case DoParseArrayEndExpression: {
 857                 JSArray* array = asArray(objectStack.last());
<span class="line-modified"> 858                 array-&gt;putDirectIndex(m_exec, array-&gt;length(), lastValue);</span>
 859                 RETURN_IF_EXCEPTION(scope, JSValue());
 860 
 861                 if (m_lexer.currentToken()-&gt;type == TokComma)
 862                     goto doParseArrayStartExpression;
 863 
 864                 if (m_lexer.currentToken()-&gt;type != TokRBracket) {
 865                     m_parseErrorMessage = &quot;Expected &#39;]&#39;&quot;_s;
 866                     return JSValue();
 867                 }
 868 
 869                 m_lexer.next();
 870                 lastValue = objectStack.takeLast();
 871                 break;
 872             }
 873             startParseObject:
 874             case StartParseObject: {
<span class="line-modified"> 875                 JSObject* object = constructEmptyObject(m_exec);</span>
 876                 objectStack.appendWithCrashOnOverflow(object);
 877 
 878                 TokenType type = m_lexer.next();
 879                 if (type == TokString || (m_mode != StrictJSON &amp;&amp; type == TokIdentifier)) {
 880                     typename Lexer::LiteralParserTokenPtr identifierToken = m_lexer.currentToken();
 881                     if (identifierToken-&gt;stringIs8Bit)
 882                         identifierStack.append(makeIdentifier(identifierToken-&gt;stringToken8, identifierToken-&gt;stringLength));
 883                     else
 884                         identifierStack.append(makeIdentifier(identifierToken-&gt;stringToken16, identifierToken-&gt;stringLength));
 885 
 886                     // Check for colon
 887                     if (m_lexer.next() != TokColon) {
 888                         m_parseErrorMessage = &quot;Expected &#39;:&#39; before value in object property definition&quot;_s;
 889                         return JSValue();
 890                     }
 891 
 892                     m_lexer.next();
 893                     stateStack.append(DoParseObjectEndExpression);
 894                     goto startParseExpression;
 895                 }
</pre>
<hr />
<pre>
 916 
 917                 // Check for colon
 918                 if (m_lexer.next() != TokColon) {
 919                     m_parseErrorMessage = &quot;Expected &#39;:&#39;&quot;_s;
 920                     return JSValue();
 921                 }
 922 
 923                 m_lexer.next();
 924                 stateStack.append(DoParseObjectEndExpression);
 925                 goto startParseExpression;
 926             }
 927             case DoParseObjectEndExpression:
 928             {
 929                 JSObject* object = asObject(objectStack.last());
 930                 Identifier ident = identifierStack.takeLast();
 931                 if (m_mode != StrictJSON &amp;&amp; ident == vm.propertyNames-&gt;underscoreProto) {
 932                     if (!visitedUnderscoreProto.add(object).isNewEntry) {
 933                         m_parseErrorMessage = &quot;Attempted to redefine __proto__ property&quot;_s;
 934                         return JSValue();
 935                     }
<span class="line-modified"> 936                     CodeBlock* codeBlock = m_exec-&gt;codeBlock();</span>
<span class="line-modified"> 937                     PutPropertySlot slot(object, codeBlock ? codeBlock-&gt;isStrictMode() : false);</span>
<span class="line-removed"> 938                     objectStack.last().put(m_exec, ident, lastValue, slot);</span>
 939                 } else {
 940                     if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified"> 941                         object-&gt;putDirectIndex(m_exec, index.value(), lastValue);</span>
 942                     else
 943                         object-&gt;putDirect(vm, ident, lastValue);
 944                 }
 945                 RETURN_IF_EXCEPTION(scope, JSValue());
 946                 if (m_lexer.currentToken()-&gt;type == TokComma)
 947                     goto doParseObjectStartExpression;
 948                 if (m_lexer.currentToken()-&gt;type != TokRBrace) {
 949                     m_parseErrorMessage = &quot;Expected &#39;}&#39;&quot;_s;
 950                     return JSValue();
 951                 }
 952                 m_lexer.next();
 953                 lastValue = objectStack.takeLast();
 954                 break;
 955             }
 956             startParseExpression:
 957             case StartParseExpression: {
 958                 switch (m_lexer.currentToken()-&gt;type) {
 959                     case TokLBracket:
 960                         goto startParseArray;
 961                     case TokLBrace:
</pre>
</td>
<td>
<hr />
<pre>
  35 #include &quot;ObjectConstructor.h&quot;
  36 #include &quot;JSCInlines.h&quot;
  37 #include &quot;StrongInlines.h&quot;
  38 #include &lt;wtf/ASCIICType.h&gt;
  39 #include &lt;wtf/dtoa.h&gt;
  40 #include &lt;wtf/text/StringConcatenate.h&gt;
  41 
  42 namespace JSC {
  43 
  44 template &lt;typename CharType&gt;
  45 static ALWAYS_INLINE bool isJSONWhiteSpace(const CharType&amp; c)
  46 {
  47     // The JSON RFC 4627 defines a list of allowed characters to be considered
  48     // insignificant white space: http://www.ietf.org/rfc/rfc4627.txt (2. JSON Grammar).
  49     return c == &#39; &#39; || c == 0x9 || c == 0xA || c == 0xD;
  50 }
  51 
  52 template &lt;typename CharType&gt;
  53 bool LiteralParser&lt;CharType&gt;::tryJSONPParse(Vector&lt;JSONPData&gt;&amp; results, bool needsFullSourceInfo)
  54 {
<span class="line-modified">  55     VM&amp; vm = m_globalObject-&gt;vm();</span>
  56     auto scope = DECLARE_THROW_SCOPE(vm);
  57     if (m_lexer.next() != TokIdentifier)
  58         return false;
  59     do {
  60         Vector&lt;JSONPPathEntry&gt; path;
  61         // Unguarded next to start off the lexer
  62         Identifier name = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  63         JSONPPathEntry entry;
  64         if (name == vm.propertyNames-&gt;varKeyword) {
  65             if (m_lexer.next() != TokIdentifier)
  66                 return false;
  67             entry.m_type = JSONPPathEntryTypeDeclareVar;
  68             entry.m_pathEntryName = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  69             path.append(entry);
  70         } else {
  71             entry.m_type = JSONPPathEntryTypeDot;
  72             entry.m_pathEntryName = Identifier::fromString(vm, m_lexer.currentToken()-&gt;start, m_lexer.currentToken()-&gt;end - m_lexer.currentToken()-&gt;start);
  73             path.append(entry);
  74         }
  75         if (isLexerKeyword(entry.m_pathEntryName))
</pre>
<hr />
<pre>
 119         RETURN_IF_EXCEPTION(scope, false);
 120         results.last().m_value.set(vm, startParseExpressionValue);
 121         if (!results.last().m_value)
 122             return false;
 123         results.last().m_path.swap(path);
 124         if (entry.m_type == JSONPPathEntryTypeCall) {
 125             if (m_lexer.currentToken()-&gt;type != TokRParen)
 126                 return false;
 127             m_lexer.next();
 128         }
 129         if (m_lexer.currentToken()-&gt;type != TokSemi)
 130             break;
 131         m_lexer.next();
 132     } while (m_lexer.currentToken()-&gt;type == TokIdentifier);
 133     return m_lexer.currentToken()-&gt;type == TokEnd;
 134 }
 135 
 136 template &lt;typename CharType&gt;
 137 ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const LChar* characters, size_t length)
 138 {
<span class="line-modified"> 139     VM&amp; vm = m_globalObject-&gt;vm();</span>
 140     if (!length)
 141         return vm.propertyNames-&gt;emptyIdentifier;
 142     if (characters[0] &gt;= MaximumCachableCharacter)
 143         return Identifier::fromString(vm, characters, length);
 144 
 145     if (length == 1) {
 146         if (!m_shortIdentifiers[characters[0]].isNull())
 147             return m_shortIdentifiers[characters[0]];
 148         m_shortIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 149         return m_shortIdentifiers[characters[0]];
 150     }
 151     if (!m_recentIdentifiers[characters[0]].isNull() &amp;&amp; Identifier::equal(m_recentIdentifiers[characters[0]].impl(), characters, length))
 152         return m_recentIdentifiers[characters[0]];
 153     m_recentIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 154     return m_recentIdentifiers[characters[0]];
 155 }
 156 
 157 template &lt;typename CharType&gt;
 158 ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const UChar* characters, size_t length)
 159 {
<span class="line-modified"> 160     VM&amp; vm = m_globalObject-&gt;vm();</span>
 161     if (!length)
 162         return vm.propertyNames-&gt;emptyIdentifier;
 163     if (characters[0] &gt;= MaximumCachableCharacter)
 164         return Identifier::fromString(vm, characters, length);
 165 
 166     if (length == 1) {
 167         if (!m_shortIdentifiers[characters[0]].isNull())
 168             return m_shortIdentifiers[characters[0]];
 169         m_shortIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 170         return m_shortIdentifiers[characters[0]];
 171     }
 172     if (!m_recentIdentifiers[characters[0]].isNull() &amp;&amp; Identifier::equal(m_recentIdentifiers[characters[0]].impl(), characters, length))
 173         return m_recentIdentifiers[characters[0]];
 174     m_recentIdentifiers[characters[0]] = Identifier::fromString(vm, characters, length);
 175     return m_recentIdentifiers[characters[0]];
 176 }
 177 
 178 // 256 Latin-1 codes
 179 static constexpr const TokenType TokenTypesOfLatin1Characters[256] = {
 180 /*   0 - Null               */ TokError,
</pre>
<hr />
<pre>
 421 /* 241 - Ll category        */ TokError,
 422 /* 242 - Ll category        */ TokError,
 423 /* 243 - Ll category        */ TokError,
 424 /* 244 - Ll category        */ TokError,
 425 /* 245 - Ll category        */ TokError,
 426 /* 246 - Ll category        */ TokError,
 427 /* 247 - Sm category        */ TokError,
 428 /* 248 - Ll category        */ TokError,
 429 /* 249 - Ll category        */ TokError,
 430 /* 250 - Ll category        */ TokError,
 431 /* 251 - Ll category        */ TokError,
 432 /* 252 - Ll category        */ TokError,
 433 /* 253 - Ll category        */ TokError,
 434 /* 254 - Ll category        */ TokError,
 435 /* 255 - Ll category        */ TokError
 436 };
 437 
 438 template &lt;typename CharType&gt;
 439 ALWAYS_INLINE TokenType LiteralParser&lt;CharType&gt;::Lexer::lex(LiteralParserToken&lt;CharType&gt;&amp; token)
 440 {
<span class="line-modified"> 441 #if ASSERT_ENABLED</span>
 442     m_currentTokenID++;
 443 #endif
 444 
 445     while (m_ptr &lt; m_end &amp;&amp; isJSONWhiteSpace(*m_ptr))
 446         ++m_ptr;
 447 
 448     ASSERT(m_ptr &lt;= m_end);
 449     if (m_ptr == m_end) {
 450         token.type = TokEnd;
 451         token.start = token.end = m_ptr;
 452         return TokEnd;
 453     }
 454     ASSERT(m_ptr &lt; m_end);
 455     token.type = TokError;
 456     token.start = m_ptr;
 457     CharType character = *m_ptr;
 458     if (LIKELY(isLatin1(character))) {
 459         TokenType tokenType = TokenTypesOfLatin1Characters[character];
 460         switch (tokenType) {
 461         case TokString:
</pre>
<hr />
<pre>
 803         if (m_ptr &gt;= m_end || !isASCIIDigit(*m_ptr)) {
 804             m_lexErrorMessage = &quot;Exponent symbols should be followed by an optional &#39;+&#39; or &#39;-&#39; and then by at least one number&quot;_s;
 805             return TokError;
 806         }
 807 
 808         ++m_ptr;
 809         while (m_ptr &lt; m_end &amp;&amp; isASCIIDigit(*m_ptr))
 810             ++m_ptr;
 811     }
 812 
 813     token.type = TokNumber;
 814     token.end = m_ptr;
 815     size_t parsedLength;
 816     token.numberToken = parseDouble(token.start, token.end - token.start, parsedLength);
 817     return TokNumber;
 818 }
 819 
 820 template &lt;typename CharType&gt;
 821 JSValue LiteralParser&lt;CharType&gt;::parse(ParserState initialState)
 822 {
<span class="line-modified"> 823     VM&amp; vm = m_globalObject-&gt;vm();</span>
 824     auto scope = DECLARE_THROW_SCOPE(vm);
 825     ParserState state = initialState;
 826     MarkedArgumentBuffer objectStack;
 827     JSValue lastValue;
 828     Vector&lt;ParserState, 16, UnsafeVectorOverflow&gt; stateStack;
 829     Vector&lt;Identifier, 16, UnsafeVectorOverflow&gt; identifierStack;
 830     HashSet&lt;JSObject*&gt; visitedUnderscoreProto;
 831     while (1) {
 832         switch(state) {
 833             startParseArray:
 834             case StartParseArray: {
<span class="line-modified"> 835                 JSArray* array = constructEmptyArray(m_globalObject, 0);</span>
 836                 RETURN_IF_EXCEPTION(scope, JSValue());
 837                 objectStack.appendWithCrashOnOverflow(array);
 838             }
 839             doParseArrayStartExpression:
 840             FALLTHROUGH;
 841             case DoParseArrayStartExpression: {
 842                 TokenType lastToken = m_lexer.currentToken()-&gt;type;
 843                 if (m_lexer.next() == TokRBracket) {
 844                     if (lastToken == TokComma) {
 845                         m_parseErrorMessage = &quot;Unexpected comma at the end of array expression&quot;_s;
 846                         return JSValue();
 847                     }
 848                     m_lexer.next();
 849                     lastValue = objectStack.takeLast();
 850                     break;
 851                 }
 852 
 853                 stateStack.append(DoParseArrayEndExpression);
 854                 goto startParseExpression;
 855             }
 856             case DoParseArrayEndExpression: {
 857                 JSArray* array = asArray(objectStack.last());
<span class="line-modified"> 858                 array-&gt;putDirectIndex(m_globalObject, array-&gt;length(), lastValue);</span>
 859                 RETURN_IF_EXCEPTION(scope, JSValue());
 860 
 861                 if (m_lexer.currentToken()-&gt;type == TokComma)
 862                     goto doParseArrayStartExpression;
 863 
 864                 if (m_lexer.currentToken()-&gt;type != TokRBracket) {
 865                     m_parseErrorMessage = &quot;Expected &#39;]&#39;&quot;_s;
 866                     return JSValue();
 867                 }
 868 
 869                 m_lexer.next();
 870                 lastValue = objectStack.takeLast();
 871                 break;
 872             }
 873             startParseObject:
 874             case StartParseObject: {
<span class="line-modified"> 875                 JSObject* object = constructEmptyObject(m_globalObject);</span>
 876                 objectStack.appendWithCrashOnOverflow(object);
 877 
 878                 TokenType type = m_lexer.next();
 879                 if (type == TokString || (m_mode != StrictJSON &amp;&amp; type == TokIdentifier)) {
 880                     typename Lexer::LiteralParserTokenPtr identifierToken = m_lexer.currentToken();
 881                     if (identifierToken-&gt;stringIs8Bit)
 882                         identifierStack.append(makeIdentifier(identifierToken-&gt;stringToken8, identifierToken-&gt;stringLength));
 883                     else
 884                         identifierStack.append(makeIdentifier(identifierToken-&gt;stringToken16, identifierToken-&gt;stringLength));
 885 
 886                     // Check for colon
 887                     if (m_lexer.next() != TokColon) {
 888                         m_parseErrorMessage = &quot;Expected &#39;:&#39; before value in object property definition&quot;_s;
 889                         return JSValue();
 890                     }
 891 
 892                     m_lexer.next();
 893                     stateStack.append(DoParseObjectEndExpression);
 894                     goto startParseExpression;
 895                 }
</pre>
<hr />
<pre>
 916 
 917                 // Check for colon
 918                 if (m_lexer.next() != TokColon) {
 919                     m_parseErrorMessage = &quot;Expected &#39;:&#39;&quot;_s;
 920                     return JSValue();
 921                 }
 922 
 923                 m_lexer.next();
 924                 stateStack.append(DoParseObjectEndExpression);
 925                 goto startParseExpression;
 926             }
 927             case DoParseObjectEndExpression:
 928             {
 929                 JSObject* object = asObject(objectStack.last());
 930                 Identifier ident = identifierStack.takeLast();
 931                 if (m_mode != StrictJSON &amp;&amp; ident == vm.propertyNames-&gt;underscoreProto) {
 932                     if (!visitedUnderscoreProto.add(object).isNewEntry) {
 933                         m_parseErrorMessage = &quot;Attempted to redefine __proto__ property&quot;_s;
 934                         return JSValue();
 935                     }
<span class="line-modified"> 936                     PutPropertySlot slot(object, m_nullOrCodeBlock ? m_nullOrCodeBlock-&gt;isStrictMode() : false);</span>
<span class="line-modified"> 937                     objectStack.last().put(m_globalObject, ident, lastValue, slot);</span>

 938                 } else {
 939                     if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified"> 940                         object-&gt;putDirectIndex(m_globalObject, index.value(), lastValue);</span>
 941                     else
 942                         object-&gt;putDirect(vm, ident, lastValue);
 943                 }
 944                 RETURN_IF_EXCEPTION(scope, JSValue());
 945                 if (m_lexer.currentToken()-&gt;type == TokComma)
 946                     goto doParseObjectStartExpression;
 947                 if (m_lexer.currentToken()-&gt;type != TokRBrace) {
 948                     m_parseErrorMessage = &quot;Expected &#39;}&#39;&quot;_s;
 949                     return JSValue();
 950                 }
 951                 m_lexer.next();
 952                 lastValue = objectStack.takeLast();
 953                 break;
 954             }
 955             startParseExpression:
 956             case StartParseExpression: {
 957                 switch (m_lexer.currentToken()-&gt;type) {
 958                     case TokLBracket:
 959                         goto startParseArray;
 960                     case TokLBrace:
</pre>
</td>
</tr>
</table>
<center><a href="LazyClassStructure.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LiteralParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
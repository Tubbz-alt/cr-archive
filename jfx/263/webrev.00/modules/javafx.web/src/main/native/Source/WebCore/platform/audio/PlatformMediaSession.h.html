<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/audio/PlatformMediaSession.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef PlatformMediaSession_h
 27 #define PlatformMediaSession_h
 28 
 29 #include &quot;Timer.h&quot;
 30 #include &lt;wtf/LoggerHelper.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 #include &lt;wtf/WeakPtr.h&gt;
 33 #include &lt;wtf/text/WTFString.h&gt;
 34 
 35 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 36 #include &quot;MediaPlaybackTargetClient.h&quot;
 37 #endif
 38 
 39 namespace WebCore {
 40 
 41 class Document;
 42 class MediaPlaybackTarget;
 43 class PlatformMediaSessionClient;
 44 enum class DelayCallingUpdateNowPlaying { No, Yes };
 45 
 46 class PlatformMediaSession
 47     : public CanMakeWeakPtr&lt;PlatformMediaSession&gt;
 48 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 49     , public MediaPlaybackTargetClient
 50 #endif
 51 #if !RELEASE_LOG_DISABLED
 52     , private LoggerHelper
 53 #endif
 54 {
 55     WTF_MAKE_FAST_ALLOCATED;
 56 public:
 57     static std::unique_ptr&lt;PlatformMediaSession&gt; create(PlatformMediaSessionClient&amp;);
 58 
 59     PlatformMediaSession(PlatformMediaSessionClient&amp;);
 60     virtual ~PlatformMediaSession();
 61 
 62     enum MediaType {
 63         None = 0,
 64         Video,
 65         VideoAudio,
 66         Audio,
 67         WebAudio,
 68         MediaStreamCapturingAudio,
 69     };
 70     MediaType mediaType() const;
 71     MediaType presentationType() const;
 72 
 73     enum State {
 74         Idle,
 75         Autoplaying,
 76         Playing,
 77         Paused,
 78         Interrupted,
 79     };
 80     State state() const { return m_state; }
 81     void setState(State);
 82 
 83     enum InterruptionType {
 84         NoInterruption,
 85         SystemSleep,
 86         EnteringBackground,
 87         SystemInterruption,
 88         SuspendedUnderLock,
 89         InvisibleAutoplay,
 90         ProcessInactive,
 91         PlaybackSuspended,
 92     };
 93     InterruptionType interruptionType() const { return m_interruptionType; }
 94 
 95     enum EndInterruptionFlags {
 96         NoFlags = 0,
 97         MayResumePlaying = 1 &lt;&lt; 0,
 98     };
 99 
100     enum Characteristics {
101         HasNothing = 0,
102         HasAudio = 1 &lt;&lt; 0,
103         HasVideo = 1 &lt;&lt; 1,
104     };
105     typedef unsigned CharacteristicsFlags;
106 
107     CharacteristicsFlags characteristics() const;
108     void clientCharacteristicsChanged();
109 
110     void beginInterruption(InterruptionType);
111     void endInterruption(EndInterruptionFlags);
112 
113     virtual void clientWillBeginAutoplaying();
114     virtual bool clientWillBeginPlayback();
115     virtual bool clientWillPausePlayback();
116 
117     void clientWillBeDOMSuspended();
118 
119     void pauseSession();
120     void stopSession();
121 
122     virtual void suspendBuffering() { }
123     virtual void resumeBuffering() { }
124 
125 #if ENABLE(VIDEO)
126     uint64_t uniqueIdentifier() const;
127     String title() const;
128     double duration() const;
129     double currentTime() const;
130 #endif
131 
132     typedef union {
133         double asDouble;
134     } RemoteCommandArgument;
135 
136     enum RemoteControlCommandType {
137         NoCommand,
138         PlayCommand,
139         PauseCommand,
140         StopCommand,
141         TogglePlayPauseCommand,
142         BeginSeekingBackwardCommand,
143         EndSeekingBackwardCommand,
144         BeginSeekingForwardCommand,
145         EndSeekingForwardCommand,
146         SeekToPlaybackPositionCommand,
147     };
148     bool canReceiveRemoteControlCommands() const;
149     void didReceiveRemoteControlCommand(RemoteControlCommandType, const RemoteCommandArgument* argument = nullptr);
150     bool supportsSeeking() const;
151 
152     enum DisplayType {
153         Normal,
154         Fullscreen,
155         Optimized,
156     };
157     DisplayType displayType() const;
158 
159     bool isHidden() const;
160     bool isSuspended() const;
161 
162     bool shouldOverrideBackgroundLoadingRestriction() const;
163 
164     virtual bool isPlayingToWirelessPlaybackTarget() const { return m_isPlayingToWirelessPlaybackTarget; }
165     void isPlayingToWirelessPlaybackTargetChanged(bool);
166 
167 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
168     // MediaPlaybackTargetClient
169     void setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override { }
170     void externalOutputDeviceAvailableDidChange(bool) override { }
171     void setShouldPlayToPlaybackTarget(bool) override { }
172     void playbackTargetPickerWasDismissed() override { }
173 #endif
174 
175 #if PLATFORM(IOS_FAMILY)
176     virtual bool requiresPlaybackTargetRouteMonitoring() const { return false; }
177 #endif
178 
179     bool activeAudioSessionRequired() const;
180     bool canProduceAudio() const;
181     void canProduceAudioChanged();
182 
183     virtual void resetPlaybackSessionState() { }
184     String sourceApplicationIdentifier() const;
185 
186     virtual bool allowsNowPlayingControlsVisibility() const { return false; }
187 
188     bool hasPlayedSinceLastInterruption() const { return m_hasPlayedSinceLastInterruption; }
189     void clearHasPlayedSinceLastInterruption() { m_hasPlayedSinceLastInterruption = false; }
190 
191 #if !RELEASE_LOG_DISABLED
192     const Logger&amp; logger() const final { return m_logger.get(); }
193     const void* logIdentifier() const override { return m_logIdentifier; }
194     const char* logClassName() const override { return &quot;PlatformMediaSession&quot;; }
195     WTFLogChannel&amp; logChannel() const final;
196 #endif
197 
198     bool canPlayConcurrently(const PlatformMediaSession&amp;) const;
199     bool shouldOverridePauseDuringRouteChange() const;
200 
201 protected:
202     PlatformMediaSessionClient&amp; client() const { return m_client; }
203 
204 private:
205     bool processClientWillPausePlayback(DelayCallingUpdateNowPlaying);
206 
207     PlatformMediaSessionClient&amp; m_client;
208     State m_state;
209     State m_stateToRestore;
210     InterruptionType m_interruptionType { NoInterruption };
211     int m_interruptionCount { 0 };
212     bool m_notifyingClient;
213     bool m_isPlayingToWirelessPlaybackTarget { false };
214     bool m_hasPlayedSinceLastInterruption { false };
215 
216 #if !RELEASE_LOG_DISABLED
217     Ref&lt;const Logger&gt; m_logger;
218     const void* m_logIdentifier;
219 #endif
220 
221     friend class PlatformMediaSessionManager;
222 };
223 
224 class PlatformMediaSessionClient {
225     WTF_MAKE_NONCOPYABLE(PlatformMediaSessionClient);
226 public:
227     PlatformMediaSessionClient() = default;
228 
229     virtual PlatformMediaSession::MediaType mediaType() const = 0;
230     virtual PlatformMediaSession::MediaType presentationType() const = 0;
231     virtual PlatformMediaSession::DisplayType displayType() const { return PlatformMediaSession::Normal; }
232     virtual PlatformMediaSession::CharacteristicsFlags characteristics() const = 0;
233 
234     virtual void resumeAutoplaying() { }
235     virtual void mayResumePlayback(bool shouldResume) = 0;
236     virtual void suspendPlayback() = 0;
237 
238 #if ENABLE(VIDEO)
239     virtual uint64_t mediaSessionUniqueIdentifier() const;
240     virtual String mediaSessionTitle() const;
241     virtual double mediaSessionDuration() const;
242     virtual double mediaSessionCurrentTime() const;
243 #endif
244 
245     virtual bool canReceiveRemoteControlCommands() const = 0;
246     virtual void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) = 0;
247     virtual bool supportsSeeking() const = 0;
248 
249     virtual bool canProduceAudio() const { return false; }
250     virtual bool isSuspended() const { return false; };
251 
252     virtual bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const = 0;
253     virtual bool shouldOverrideBackgroundLoadingRestriction() const { return false; }
254 
255     virtual void wirelessRoutesAvailableDidChange() { }
256     virtual void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) { }
257     virtual bool isPlayingToWirelessPlaybackTarget() const { return false; }
258     virtual void setShouldPlayToPlaybackTarget(bool) { }
259     virtual void playbackTargetPickerWasDismissed() { }
260 
261     virtual bool isPlayingOnSecondScreen() const { return false; }
262 
263     virtual Document* hostingDocument() const = 0;
264     virtual String sourceApplicationIdentifier() const = 0;
265 
266     virtual bool processingUserGestureForMedia() const = 0;
267 
268     virtual bool hasMediaStreamSource() const { return false; }
269 
270     virtual void processIsSuspendedChanged() { }
271 
272     virtual bool shouldOverridePauseDuringRouteChange() const { return false; }
273 
274 protected:
275     virtual ~PlatformMediaSessionClient() = default;
276 };
277 
278 String convertEnumerationToString(PlatformMediaSession::State);
279 String convertEnumerationToString(PlatformMediaSession::InterruptionType);
280 String convertEnumerationToString(PlatformMediaSession::RemoteControlCommandType);
281 }
282 
283 namespace WTF {
284 
285 template&lt;typename Type&gt;
286 struct LogArgument;
287 
288 template &lt;&gt;
289 struct LogArgument&lt;WebCore::PlatformMediaSession::State&gt; {
290     static String toString(const WebCore::PlatformMediaSession::State state)
291     {
292         return convertEnumerationToString(state);
293     }
294 };
295 
296 template &lt;&gt;
297 struct LogArgument&lt;WebCore::PlatformMediaSession::InterruptionType&gt; {
298     static String toString(const WebCore::PlatformMediaSession::InterruptionType state)
299     {
300         return convertEnumerationToString(state);
301     }
302 };
303 
304 template &lt;&gt;
305 struct LogArgument&lt;WebCore::PlatformMediaSession::RemoteControlCommandType&gt; {
306     static String toString(const WebCore::PlatformMediaSession::RemoteControlCommandType command)
307     {
308         return convertEnumerationToString(command);
309     }
310 };
311 
312 } // namespace WTF
313 
314 #endif // PlatformMediaSession_h
    </pre>
  </body>
</html>
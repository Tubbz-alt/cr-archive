diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Pattern.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Pattern.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Pattern.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Pattern.h
@@ -26,10 +26,11 @@
  */
 
 #pragma once
 
 #include "AffineTransform.h"
+#include "Image.h"
 
 #include <wtf/Ref.h>
 #include <wtf/RefCounted.h>
 
 #if USE(CG)
@@ -56,40 +57,82 @@
 namespace WebCore {
 
 class AffineTransform;
 class GraphicsContext;
 class Image;
+class ImageHandle;
 
 class Pattern final : public RefCounted<Pattern> {
 public:
-    static Ref<Pattern> create(Ref<Image>&& tileImage, bool repeatX, bool repeatY);
-    ~Pattern();
+    WEBCORE_EXPORT static Ref<Pattern> create(Ref<Image>&& tileImage, bool repeatX, bool repeatY);
+    WEBCORE_EXPORT ~Pattern();
 
     Image& tileImage() const { return m_tileImage.get(); }
 
     // Pattern space is an abstract space that maps to the default user space by the transformation 'userSpaceTransformation'
 #if !USE(DIRECT2D)
     PlatformPatternPtr createPlatformPattern(const AffineTransform& userSpaceTransformation) const;
 #else
-    PlatformPatternPtr createPlatformPattern(PlatformGraphicsContext&, float alpha, const AffineTransform& userSpaceTransformation) const;
     PlatformPatternPtr createPlatformPattern(const GraphicsContext&, float alpha, const AffineTransform& userSpaceTransformation) const;
 #endif
-    void setPatternSpaceTransform(const AffineTransform& patternSpaceTransformation);
+    WEBCORE_EXPORT void setPatternSpaceTransform(const AffineTransform& patternSpaceTransformation);
     const AffineTransform& patternSpaceTransform() const { return m_patternSpaceTransformation; };
     bool repeatX() const { return m_repeatX; }
     bool repeatY() const { return m_repeatY; }
 
 #if PLATFORM(JAVA)
     const AffineTransform& getPatternSpaceTransform() const { return m_patternSpaceTransformation; }
 #endif
 
+    template<class Encoder> void encode(Encoder&) const;
+    template<class Decoder> static Optional<Ref<Pattern>> decode(Decoder&);
+
 private:
     Pattern(Ref<Image>&&, bool repeatX, bool repeatY);
 
     Ref<Image> m_tileImage;
     AffineTransform m_patternSpaceTransformation;
     bool m_repeatX;
     bool m_repeatY;
 };
 
+template<class Encoder>
+void Pattern::encode(Encoder& encoder) const
+{
+    ImageHandle imageHandle;
+    imageHandle.image = m_tileImage.ptr();
+    encoder << imageHandle;
+    encoder << m_patternSpaceTransformation;
+    encoder << m_repeatX;
+    encoder << m_repeatY;
+}
+
+template<class Decoder>
+Optional<Ref<Pattern>> Pattern::decode(Decoder& decoder)
+{
+    Optional<ImageHandle> imageHandle;
+    decoder >> imageHandle;
+    if (!imageHandle)
+        return WTF::nullopt;
+
+    Optional<AffineTransform> patternSpaceTransformation;
+    decoder >> patternSpaceTransformation;
+    if (!patternSpaceTransformation)
+        return WTF::nullopt;
+
+    Optional<bool> repeatX;
+    decoder >> repeatX;
+    if (!repeatX)
+        return WTF::nullopt;
+
+    Optional<bool> repeatY;
+    decoder >> repeatY;
+    if (!repeatY)
+        return WTF::nullopt;
+
+    auto pattern = Pattern::create(imageHandle->image.releaseNonNull(), *repeatX, *repeatY);
+    pattern->setPatternSpaceTransform(*patternSpaceTransformation);
+    return pattern;
+}
+
 } //namespace
 

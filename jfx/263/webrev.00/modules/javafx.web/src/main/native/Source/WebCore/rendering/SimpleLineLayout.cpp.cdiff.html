<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectionRangeData.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayout.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 160,11 ***</span>
      const auto&amp; style = flow.style();
      auto&amp; fontCascade = style.fontCascade();
      if (fontCascade.primaryFont().isInterstitial())
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
      Optional&lt;float&gt; lineHeightConstraint;
<span class="line-modified">!     if (style.lineBoxContain() &amp; LineBoxContainGlyphs)</span>
          lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
      bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
      for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
          // FIXME: Do not return until after checking all children.
          if (textRenderer.text().isEmpty())
<span class="line-new-header">--- 160,11 ---</span>
      const auto&amp; style = flow.style();
      auto&amp; fontCascade = style.fontCascade();
      if (fontCascade.primaryFont().isInterstitial())
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
      Optional&lt;float&gt; lineHeightConstraint;
<span class="line-modified">!     if (style.lineBoxContain().contains(LineBoxContain::Glyphs))</span>
          lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
      bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
      for (const auto&amp; textRenderer : childrenOfType&lt;RenderText&gt;(flow)) {
          // FIXME: Do not return until after checking all children.
          if (textRenderer.text().isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,11 ***</span>
      // Non-visible overflow should be pretty easy to support.
      if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
      if (!style.isLeftToRightDirection())
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
<span class="line-modified">!     if (!(style.lineBoxContain() &amp; LineBoxContainBlock))</span>
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
      if (style.writingMode() != TopToBottomWritingMode)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
      if (style.lineBreak() != LineBreak::Auto)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
<span class="line-new-header">--- 206,11 ---</span>
      // Non-visible overflow should be pretty easy to support.
      if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
      if (!style.isLeftToRightDirection())
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
<span class="line-modified">!     if (!(style.lineBoxContain().contains(LineBoxContain::Block)))</span>
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
      if (style.writingMode() != TopToBottomWritingMode)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
      if (style.lineBreak() != LineBreak::Auto)
          SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,34 ***</span>
  bool canUseFor(const RenderBlockFlow&amp; flow)
  {
      return canUseForWithReason(flow, IncludeReasons::First) == NoReason;
  }
  
<span class="line-removed">- static float computeLineLeft(TextAlignMode textAlign, float availableWidth, float committedWidth, float logicalLeftOffset)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     float remainingWidth = availableWidth - committedWidth;</span>
<span class="line-removed">-     float left = logicalLeftOffset;</span>
<span class="line-removed">-     switch (textAlign) {</span>
<span class="line-removed">-     case TextAlignMode::Left:</span>
<span class="line-removed">-     case TextAlignMode::WebKitLeft:</span>
<span class="line-removed">-     case TextAlignMode::Start:</span>
<span class="line-removed">-         return left;</span>
<span class="line-removed">-     case TextAlignMode::Right:</span>
<span class="line-removed">-     case TextAlignMode::WebKitRight:</span>
<span class="line-removed">-     case TextAlignMode::End:</span>
<span class="line-removed">-         return left + std::max&lt;float&gt;(remainingWidth, 0);</span>
<span class="line-removed">-     case TextAlignMode::Center:</span>
<span class="line-removed">-     case TextAlignMode::WebKitCenter:</span>
<span class="line-removed">-         return left + std::max&lt;float&gt;(remainingWidth / 2, 0);</span>
<span class="line-removed">-     case TextAlignMode::Justify:</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static void revertAllRunsOnCurrentLine(Layout::RunVector&amp; runs)
  {
      while (!runs.isEmpty() &amp;&amp; !runs.last().isEndOfLine)
          runs.removeLast();
  }
<span class="line-new-header">--- 353,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,11 ***</span>
          // Adjust end position while collapsing.
          unsigned endPosition = endPositionForCollapsedFragment(fragment);
          // New line needs new run.
          if (!m_runsWidth) {
              ASSERT(!m_uncompletedWidth);
<span class="line-modified">!             runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));</span>
          } else {
              // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
              if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
                  m_lastCompleteFragment = m_lastFragment;
                  m_uncompletedWidth = fragment.width();
<span class="line-new-header">--- 447,11 ---</span>
          // Adjust end position while collapsing.
          unsigned endPosition = endPositionForCollapsedFragment(fragment);
          // New line needs new run.
          if (!m_runsWidth) {
              ASSERT(!m_uncompletedWidth);
<span class="line-modified">!             runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));</span>
          } else {
              // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
              if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
                  m_lastCompleteFragment = m_lastFragment;
                  m_uncompletedWidth = fragment.width();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 489,14 ***</span>
                      m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
                  }
                  // This fragment is collapsed completely. No run is needed.
                  return;
              }
<span class="line-modified">!             if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed())</span>
<span class="line-modified">!                 runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));</span>
              else {
<span class="line-removed">-                 Run&amp; lastRun = runs.last();</span>
                  lastRun.end = endPosition;
                  lastRun.logicalRight += fragment.width();
                  ASSERT(!lastRun.hasHyphen);
                  lastRun.hasHyphen = fragment.hasHyphen();
              }
<span class="line-new-header">--- 465,14 ---</span>
                      m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
                  }
                  // This fragment is collapsed completely. No run is needed.
                  return;
              }
<span class="line-modified">!             Run&amp; lastRun = runs.last();</span>
<span class="line-modified">!             if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed() || fragment.isLineBreak() || lastRun.isLineBreak)</span>
<span class="line-added">+                 runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));</span>
              else {
                  lastRun.end = endPosition;
                  lastRun.logicalRight += fragment.width();
                  ASSERT(!lastRun.hasHyphen);
                  lastRun.hasHyphen = fragment.hasHyphen();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,11 ***</span>
          return m_lastCompleteFragment;
      }
  
      void removeTrailingWhitespace(Layout::RunVector&amp; runs)
      {
<span class="line-modified">!         if (m_lastFragment.type() != TextFragmentIterator::TextFragment::Whitespace)</span>
              return;
          if (m_lastNonWhitespaceFragment) {
              auto needsReverting = m_lastNonWhitespaceFragment-&gt;end() != m_lastFragment.end();
              // Trailing whitespace fragment might actually have zero length.
              ASSERT(needsReverting || !m_trailingWhitespaceWidth);
<span class="line-new-header">--- 508,11 ---</span>
          return m_lastCompleteFragment;
      }
  
      void removeTrailingWhitespace(Layout::RunVector&amp; runs)
      {
<span class="line-modified">!         if (!hasTrailingWhitespace())</span>
              return;
          if (m_lastNonWhitespaceFragment) {
              auto needsReverting = m_lastNonWhitespaceFragment-&gt;end() != m_lastFragment.end();
              // Trailing whitespace fragment might actually have zero length.
              ASSERT(needsReverting || !m_trailingWhitespaceWidth);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,10 ***</span>
<span class="line-new-header">--- 530,12 ---</span>
          m_trailingWhitespaceWidth = 0;
          // FIXME: Make m_lastFragment optional.
          m_lastFragment = TextFragmentIterator::TextFragment();
      }
  
<span class="line-added">+     float trailingWhitespaceWidth() const { return m_trailingWhitespaceWidth; }</span>
<span class="line-added">+ </span>
  private:
      bool expansionOpportunity(TextFragmentIterator::TextFragment::Type currentFragmentType, TextFragmentIterator::TextFragment::Type previousFragmentType) const
      {
          return (currentFragmentType == TextFragmentIterator::TextFragment::Whitespace
              || (currentFragmentType == TextFragmentIterator::TextFragment::NonWhitespace &amp;&amp; previousFragmentType == TextFragmentIterator::TextFragment::NonWhitespace));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 579,28 ***</span>
      bool m_firstCharacterFits { false };
      bool m_hyphenationDisabled { false };
      Optional&lt;Vector&lt;TextFragmentIterator::TextFragment, 30&gt;&gt; m_fragments;
  };
  
<span class="line-modified">! static bool preWrap(const TextFragmentIterator::Style&amp; style)</span>
  {
<span class="line-modified">!     return style.wrapLines &amp;&amp; !style.collapseWhitespace;</span>
  }
  
<span class="line-modified">! static void removeTrailingWhitespace(LineState&amp; lineState, Layout::RunVector&amp; runs, const TextFragmentIterator&amp; textFragmentIterator)</span>
  {
<span class="line-modified">!     if (!lineState.hasTrailingWhitespace())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     // Remove collapsed whitespace, or non-collapsed pre-wrap whitespace, unless it&#39;s the only content on the line -so removing the whitesapce</span>
<span class="line-removed">-     // would produce an empty line.</span>
<span class="line-removed">-     const auto&amp; style = textFragmentIterator.style();</span>
<span class="line-removed">-     bool collapseWhitespace = style.collapseWhitespace || (!style.breakSpaces &amp;&amp; preWrap(style));</span>
<span class="line-removed">-     if (!collapseWhitespace)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     if (preWrap(style) &amp;&amp; lineState.isWhitespaceOnly())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     lineState.removeTrailingWhitespace(runs);</span>
  }
  
  static void updateLineConstrains(const RenderBlockFlow&amp; flow, LineState&amp; line, const LineState&amp; previousLine, unsigned&amp; numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style&amp; style, bool isFirstLine)
  {
      bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()-&gt;firstChild() == &amp;flow;
<span class="line-new-header">--- 557,41 ---</span>
      bool m_firstCharacterFits { false };
      bool m_hyphenationDisabled { false };
      Optional&lt;Vector&lt;TextFragmentIterator::TextFragment, 30&gt;&gt; m_fragments;
  };
  
<span class="line-modified">! static float computeLineLeft(const LineState&amp; line, TextAlignMode textAlign, float&amp; hangingWhitespaceWidth)</span>
  {
<span class="line-modified">!     float totalWidth = line.width() - hangingWhitespaceWidth;</span>
<span class="line-added">+     float remainingWidth = line.availableWidth() - totalWidth;</span>
<span class="line-added">+     float left = line.logicalLeftOffset();</span>
<span class="line-added">+     switch (textAlign) {</span>
<span class="line-added">+     case TextAlignMode::Left:</span>
<span class="line-added">+     case TextAlignMode::WebKitLeft:</span>
<span class="line-added">+     case TextAlignMode::Start:</span>
<span class="line-added">+         hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, remainingWidth));</span>
<span class="line-added">+         return left;</span>
<span class="line-added">+     case TextAlignMode::Right:</span>
<span class="line-added">+     case TextAlignMode::WebKitRight:</span>
<span class="line-added">+     case TextAlignMode::End:</span>
<span class="line-added">+         hangingWhitespaceWidth = 0;</span>
<span class="line-added">+         return left + std::max&lt;float&gt;(remainingWidth, 0);</span>
<span class="line-added">+     case TextAlignMode::Center:</span>
<span class="line-added">+     case TextAlignMode::WebKitCenter:</span>
<span class="line-added">+         hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, (remainingWidth + 1) / 2));</span>
<span class="line-added">+         return left + std::max&lt;float&gt;(remainingWidth / 2, 0);</span>
<span class="line-added">+     case TextAlignMode::Justify:</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return 0;</span>
  }
  
<span class="line-modified">! static bool preWrap(const TextFragmentIterator::Style&amp; style)</span>
  {
<span class="line-modified">!     return style.wrapLines &amp;&amp; !style.collapseWhitespace &amp;&amp; !style.breakSpaces;</span>
  }
  
  static void updateLineConstrains(const RenderBlockFlow&amp; flow, LineState&amp; line, const LineState&amp; previousLine, unsigned&amp; numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style&amp; style, bool isFirstLine)
  {
      bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()-&gt;firstChild() == &amp;flow;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,15 ***</span>
          if (style.breakFirstWordOnOverflow || previousLine.hasTrailingWhitespace())
              return overflowedFragment;
      }
      // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
      // if we manage to fit at least one character on the previous line.
<span class="line-modified">!     auto preWrapIsOn = preWrap(style);</span>
<span class="line-removed">-     if ((style.collapseWhitespace || preWrapIsOn) &amp;&amp; previousLine.firstCharacterFits()) {</span>
          // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
          auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
<span class="line-modified">!             preWrapIsOn ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);</span>
          return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
      }
      return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
  }
  
<span class="line-new-header">--- 747,14 ---</span>
          if (style.breakFirstWordOnOverflow || previousLine.hasTrailingWhitespace())
              return overflowedFragment;
      }
      // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
      // if we manage to fit at least one character on the previous line.
<span class="line-modified">!     if ((style.collapseWhitespace || style.wrapLines) &amp;&amp; previousLine.firstCharacterFits()) {</span>
          // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
          auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
<span class="line-modified">!             preWrap(style) ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);</span>
          return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
      }
      return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 797,11 ***</span>
      auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
      while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
          // Hard and soft linebreaks.
          if (fragment.isLineBreak()) {
              // Add the new line fragment only if there&#39;s nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
<span class="line-modified">!             if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak) {</span>
                  if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
                      line.removeTrailingWhitespace(runs);
                  line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
              }
              break;
<span class="line-new-header">--- 787,11 ---</span>
      auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
      while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
          // Hard and soft linebreaks.
          if (fragment.isLineBreak()) {
              // Add the new line fragment only if there&#39;s nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
<span class="line-modified">!             if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak || preWrap(style) || style.preserveNewline) {</span>
                  if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
                      line.removeTrailingWhitespace(runs);
                  line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
              }
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,10 ***</span>
<span class="line-new-header">--- 814,18 ---</span>
                  if (style.breakSpaces &amp;&amp; line.hasWhitespaceFragments() &amp;&amp; fragment.length() == 1) {
                      // Breaking before the first space after a word is not allowed if there are previous breaking opportunities in the line.
                      textFragmentIterator.revertToEndOfFragment(line.revertToLastCompleteFragment(runs));
                      break;
                  }
<span class="line-added">+                 if (preWrap(style)) {</span>
<span class="line-added">+                     line.appendFragmentAndCreateRunIfNeeded(fragment, runs);</span>
<span class="line-added">+                     fragment = textFragmentIterator.nextTextFragment(line.width());</span>
<span class="line-added">+                     if (fragment.isLineBreak())</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+                     line.setOverflowedFragment(fragment);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
                  // Split the whitespace; left part stays on this line, right is pushed to next line.
                  line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
                  line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 929,26 ***</span>
  static void closeLineEndingAndAdjustRuns(LineState&amp; line, Layout::RunVector&amp; runs, Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine, unsigned&amp; lineCount,
      const TextFragmentIterator&amp; textFragmentIterator, bool lastLineInFlow)
  {
      if (!runs.size() || (lastRunIndexOfPreviousLine &amp;&amp; runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
          return;
<span class="line-modified">!     removeTrailingWhitespace(line, runs, textFragmentIterator);</span>
      if (!runs.size())
          return;
      // Adjust runs&#39; position by taking line&#39;s alignment into account.
<span class="line-removed">-     const auto&amp; style = textFragmentIterator.style();</span>
      auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
      auto lineLogicalLeft = line.logicalLeftOffset();
      auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() &amp;&amp; line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
<span class="line-modified">!     if (textAlign == TextAlignMode::Justify)</span>
          justifyRuns(line, runs, firstRunIndex);
<span class="line-modified">!     else</span>
<span class="line-modified">!         lineLogicalLeft = computeLineLeft(textAlign, line.availableWidth(), line.width(), line.logicalLeftOffset());</span>
      for (auto i = firstRunIndex; i &lt; runs.size(); ++i) {
          runs[i].logicalLeft += lineLogicalLeft;
          runs[i].logicalRight += lineLogicalLeft;
      }
      runs.last().isEndOfLine = true;
      ++lineCount;
  }
  
  static void createTextRuns(Layout::RunVector&amp; runs, RenderBlockFlow&amp; flow, unsigned&amp; lineCount)
<span class="line-new-header">--- 927,42 ---</span>
  static void closeLineEndingAndAdjustRuns(LineState&amp; line, Layout::RunVector&amp; runs, Optional&lt;unsigned&gt; lastRunIndexOfPreviousLine, unsigned&amp; lineCount,
      const TextFragmentIterator&amp; textFragmentIterator, bool lastLineInFlow)
  {
      if (!runs.size() || (lastRunIndexOfPreviousLine &amp;&amp; runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
          return;
<span class="line-modified">! </span>
<span class="line-added">+     const auto&amp; style = textFragmentIterator.style();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (style.collapseWhitespace)</span>
<span class="line-added">+         line.removeTrailingWhitespace(runs);</span>
<span class="line-added">+ </span>
      if (!runs.size())
          return;
<span class="line-added">+ </span>
      // Adjust runs&#39; position by taking line&#39;s alignment into account.
      auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
      auto lineLogicalLeft = line.logicalLeftOffset();
      auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() &amp;&amp; line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
<span class="line-modified">! </span>
<span class="line-added">+     // https://www.w3.org/TR/css-text-3/#white-space-phase-2</span>
<span class="line-added">+     bool shouldHangTrailingWhitespace = style.wrapLines &amp;&amp; line.trailingWhitespaceWidth();</span>
<span class="line-added">+     auto hangingWhitespaceWidth = shouldHangTrailingWhitespace ? line.trailingWhitespaceWidth() : 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (textAlign == TextAlignMode::Justify) {</span>
          justifyRuns(line, runs, firstRunIndex);
<span class="line-modified">!         hangingWhitespaceWidth = 0;</span>
<span class="line-modified">!     } else</span>
<span class="line-added">+         lineLogicalLeft = computeLineLeft(line, textAlign, hangingWhitespaceWidth);</span>
<span class="line-added">+ </span>
      for (auto i = firstRunIndex; i &lt; runs.size(); ++i) {
          runs[i].logicalLeft += lineLogicalLeft;
          runs[i].logicalRight += lineLogicalLeft;
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (shouldHangTrailingWhitespace &amp;&amp; hangingWhitespaceWidth &lt; line.trailingWhitespaceWidth())</span>
<span class="line-added">+         runs.last().logicalRight = runs.last().logicalRight - (line.trailingWhitespaceWidth() - hangingWhitespaceWidth);</span>
<span class="line-added">+ </span>
      runs.last().isEndOfLine = true;
      ++lineCount;
  }
  
  static void createTextRuns(Layout::RunVector&amp; runs, RenderBlockFlow&amp; flow, unsigned&amp; lineCount)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 970,22 ***</span>
          if (runs.size())
              lastRunIndexOfPreviousLine = runs.size() - 1;
      } while (!isEndOfContent);
  }
  
<span class="line-modified">! std::unique_ptr&lt;Layout&gt; create(RenderBlockFlow&amp; flow)</span>
  {
      unsigned lineCount = 0;
      Layout::RunVector runs;
      createTextRuns(runs, flow, lineCount);
      return Layout::create(runs, lineCount, flow);
  }
  
<span class="line-modified">! std::unique_ptr&lt;Layout&gt; Layout::create(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)</span>
  {
      void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
<span class="line-modified">!     return std::unique_ptr&lt;Layout&gt;(new (NotNull, slot) Layout(runVector, lineCount, blockFlow));</span>
  }
  
  Layout::Layout(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
      : m_lineCount(lineCount)
      , m_runCount(runVector.size())
<span class="line-new-header">--- 984,22 ---</span>
          if (runs.size())
              lastRunIndexOfPreviousLine = runs.size() - 1;
      } while (!isEndOfContent);
  }
  
<span class="line-modified">! Ref&lt;Layout&gt; create(RenderBlockFlow&amp; flow)</span>
  {
      unsigned lineCount = 0;
      Layout::RunVector runs;
      createTextRuns(runs, flow, lineCount);
      return Layout::create(runs, lineCount, flow);
  }
  
<span class="line-modified">! Ref&lt;Layout&gt; Layout::create(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)</span>
  {
      void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
<span class="line-modified">!     return adoptRef(*new (NotNull, slot) Layout(runVector, lineCount, blockFlow));</span>
  }
  
  Layout::Layout(const RunVector&amp; runVector, unsigned lineCount, const RenderBlockFlow&amp; blockFlow)
      : m_lineCount(lineCount)
      , m_runCount(runVector.size())
</pre>
<center><a href="SelectionRangeData.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayout.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
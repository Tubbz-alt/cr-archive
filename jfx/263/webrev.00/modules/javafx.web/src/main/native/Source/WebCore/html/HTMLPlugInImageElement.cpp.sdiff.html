<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLPlugInElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLSelectElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;HTMLPlugInImageElement.h&quot;
 23 
 24 #include &quot;Chrome.h&quot;
 25 #include &quot;ChromeClient.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;EventNames.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;FrameLoaderClient.h&quot;
 31 #include &quot;HTMLImageLoader.h&quot;
 32 #include &quot;JSDOMConvertBoolean.h&quot;
 33 #include &quot;JSDOMConvertInterface.h&quot;
 34 #include &quot;JSDOMConvertStrings.h&quot;
 35 #include &quot;JSShadowRoot.h&quot;

 36 #include &quot;LocalizedStrings.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;MouseEvent.h&quot;
 39 #include &quot;Page.h&quot;
 40 #include &quot;PlatformMouseEvent.h&quot;
 41 #include &quot;PlugInClient.h&quot;
 42 #include &quot;PluginViewBase.h&quot;
 43 #include &quot;RenderImage.h&quot;
 44 #include &quot;RenderSnapshottedPlugIn.h&quot;
 45 #include &quot;RenderTreeUpdater.h&quot;
<span class="line-removed"> 46 #include &quot;SchemeRegistry.h&quot;</span>
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;SecurityOrigin.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;ShadowRoot.h&quot;
 51 #include &quot;StyleTreeResolver.h&quot;
 52 #include &quot;SubframeLoader.h&quot;
 53 #include &quot;TypedElementDescendantIterator.h&quot;
 54 #include &quot;UserGestureIndicator.h&quot;
 55 #include &lt;JavaScriptCore/CatchScope.h&gt;

 56 #include &lt;wtf/IsoMallocInlines.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
 61 
 62 static const int sizingTinyDimensionThreshold = 40;
 63 static const float sizingFullPageAreaRatioThreshold = 0.96;
 64 static const Seconds autostartSoonAfterUserGestureThreshold = 5_s;
 65 
 66 // This delay should not exceed the snapshot delay in PluginView.cpp
 67 static const Seconds simulatedMouseClickTimerDelay { 750_ms };
 68 
 69 #if PLATFORM(COCOA)
 70 static const Seconds removeSnapshotTimerDelay { 1500_ms };
 71 #endif
 72 
 73 static const String titleText(Page&amp; page, const String&amp; mimeType)
 74 {
 75     if (mimeType.isEmpty())
</pre>
<hr />
<pre>
167         if (contentDocument &amp;&amp; !document().securityOrigin().canAccess(contentDocument-&gt;securityOrigin()))
168             return false;
169     }
170 
171     return !isProhibitedSelfReference(completeURL);
172 }
173 
174 // We don&#39;t use m_url, or m_serviceType as they may not be the final values
175 // that &lt;object&gt; uses depending on &lt;param&gt; values.
176 bool HTMLPlugInImageElement::wouldLoadAsPlugIn(const String&amp; relativeURL, const String&amp; serviceType)
177 {
178     ASSERT(document().frame());
179     URL completedURL;
180     if (!relativeURL.isEmpty())
181         completedURL = document().completeURL(relativeURL);
182     return document().frame()-&gt;loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
183 }
184 
185 RenderPtr&lt;RenderElement&gt; HTMLPlugInImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
186 {
<span class="line-modified">187     ASSERT(document().pageCacheState() == Document::NotInPageCache);</span>
188 
189     if (displayState() &gt;= PreparingPluginReplacement)
190         return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
191 
192     // Once a plug-in element creates its renderer, it needs to be told when the document goes
<span class="line-modified">193     // inactive or reactivates so it can clear the renderer before going into the page cache.</span>
194     if (!m_needsDocumentActivationCallbacks) {
195         m_needsDocumentActivationCallbacks = true;
196         document().registerForDocumentSuspensionCallbacks(*this);
197     }
198 
199     if (displayState() == DisplayingSnapshot) {
200         auto renderSnapshottedPlugIn = createRenderer&lt;RenderSnapshottedPlugIn&gt;(*this, WTFMove(style));
201         renderSnapshottedPlugIn-&gt;updateSnapshot(m_snapshotImage.get());
202         return renderSnapshottedPlugIn;
203     }
204 
205     if (useFallbackContent())
206         return RenderElement::createFor(*this, WTFMove(style));
207 
208     if (isImageType())
209         return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style));
210 
211     return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
212 }
213 
</pre>
<hr />
<pre>
345     if (displayState() &gt; DisplayingSnapshot)
346         return;
347 
348     m_snapshotImage = image;
349 
350     auto* renderer = this-&gt;renderer();
351     if (!renderer)
352         return;
353 
354     if (is&lt;RenderSnapshottedPlugIn&gt;(*renderer)) {
355         downcast&lt;RenderSnapshottedPlugIn&gt;(*renderer).updateSnapshot(image);
356         return;
357     }
358 
359     if (is&lt;RenderEmbeddedObject&gt;(*renderer))
360         renderer-&gt;repaint();
361 }
362 
363 static DOMWrapperWorld&amp; plugInImageElementIsolatedWorld()
364 {
<span class="line-modified">365     static auto&amp; isolatedWorld = DOMWrapperWorld::create(commonVM()).leakRef();</span>
366     return isolatedWorld;
367 }
368 
369 void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
370 {
371     HTMLPlugInElement::didAddUserAgentShadowRoot(root);
372     if (displayState() &gt;= PreparingPluginReplacement)
373         return;
374 
375     auto* page = document().page();
376     if (!page)
377         return;
378 
379     // Reset any author styles that may apply as we only want explicit
380     // styles defined in the injected user agents stylesheets to specify
381     // the look-and-feel of the snapshotted plug-in overlay.
382     root.setResetStyleInheritance(true);
383 
384     String mimeType = serviceType();
385 
386     auto&amp; isolatedWorld = plugInImageElementIsolatedWorld();
387     document().ensurePlugInsInjectedScript(isolatedWorld);
388 
389     auto&amp; scriptController = document().frame()-&gt;script();
390     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(isolatedWorld));
391 
392     auto&amp; vm = globalObject.vm();
393     JSC::JSLockHolder lock(vm);
394     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">395     auto&amp; state = *globalObject.globalExec();</span>
396 
397     JSC::MarkedArgumentBuffer argList;
<span class="line-modified">398     argList.append(toJS&lt;IDLInterface&lt;ShadowRoot&gt;&gt;(state, globalObject, root));</span>
<span class="line-modified">399     argList.append(toJS&lt;IDLDOMString&gt;(state, titleText(*page, mimeType)));</span>
<span class="line-modified">400     argList.append(toJS&lt;IDLDOMString&gt;(state, subtitleText(*page, mimeType)));</span>
401 
402     // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
403     // If no snapshot was found then we want the overlay to be visible.
404     argList.append(toJS&lt;IDLBoolean&gt;(!m_snapshotImage));
405     ASSERT(!argList.hasOverflowed());
406 
407     // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
<span class="line-modified">408     auto* overlay = globalObject.get(&amp;state, JSC::Identifier::fromString(vm, &quot;createOverlay&quot;)).toObject(&amp;state);</span>
409     ASSERT(!overlay == !!scope.exception());
410     if (!overlay) {
411         scope.clearException();
412         return;
413     }
414     JSC::CallData callData;
415     auto callType = overlay-&gt;methodTable(vm)-&gt;getCallData(overlay, callData);
416     if (callType == JSC::CallType::None)
417         return;
418 
<span class="line-modified">419     call(&amp;state, overlay, callType, callData, &amp;globalObject, argList);</span>
420     scope.clearException();
421 }
422 
423 bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
424 {
425     static NeverDestroyed&lt;AtomString&gt; selector(&quot;.snapshot-overlay&quot;, AtomString::ConstructFromLiteral);
426     auto shadow = userAgentShadowRoot();
427     if (!shadow)
428         return false;
429     if (!is&lt;Node&gt;(target))
430         return false;
431     auto queryResult = shadow-&gt;querySelector(selector.get());
432     if (queryResult.hasException())
433         return false;
434     auto snapshotLabel = makeRefPtr(queryResult.releaseReturnValue());
435     return snapshotLabel &amp;&amp; snapshotLabel-&gt;contains(downcast&lt;Node&gt;(target));
436 }
437 
438 void HTMLPlugInImageElement::removeSnapshotTimerFired()
439 {
</pre>
<hr />
<pre>
467             if (plugInOrigin == element.loadedUrl().host() &amp;&amp; mimeType == element.serviceType())
468                 similarPlugins.append(element);
469         }
470     }
471 
472     for (auto&amp; plugInToRestart : similarPlugins) {
473         if (plugInToRestart-&gt;displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot) {
474             LOG(Plugins, &quot;%p Plug-in looks similar to a restarted plug-in. Restart.&quot;, plugInToRestart.ptr());
475             plugInToRestart-&gt;restartSnapshottedPlugIn();
476         }
477         plugInToRestart-&gt;m_snapshotDecision = NeverSnapshot;
478     }
479 }
480 
481 void HTMLPlugInImageElement::userDidClickSnapshot(MouseEvent&amp; event, bool forwardEvent)
482 {
483     if (forwardEvent)
484         m_pendingClickEventFromSnapshot = &amp;event;
485 
486     auto plugInOrigin = m_loadedUrl.host();
<span class="line-modified">487     if (document().page() &amp;&amp; !SchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()-&gt;mainFrame().document()-&gt;baseURL().protocol().toStringWithoutCopying()) &amp;&amp; document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled())</span>
<span class="line-modified">488         document().page()-&gt;plugInClient()-&gt;didStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), plugInOrigin.toString(), serviceType(), document().page()-&gt;sessionID());</span>
489 
490     LOG(Plugins, &quot;%p User clicked on snapshotted plug-in. Restart.&quot;, this);
491     restartSnapshottedPlugIn();
492     if (forwardEvent)
493         setDisplayState(RestartingWithPendingMouseClick);
494     restartSimilarPlugIns();
495 }
496 
497 void HTMLPlugInImageElement::setIsPrimarySnapshottedPlugIn(bool isPrimarySnapshottedPlugIn)
498 {
499     if (!document().page() || !document().page()-&gt;settings().primaryPlugInSnapshotDetectionEnabled() || document().page()-&gt;settings().snapshotAllPlugIns())
500         return;
501 
502     if (isPrimarySnapshottedPlugIn) {
503         if (m_plugInWasCreated) {
504             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page. Restart.&quot;, this);
505             restartSnapshottedPlugIn();
506             restartSimilarPlugIns();
507         } else {
508             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page, but is not yet created. Will restart later.&quot;, this);
</pre>
<hr />
<pre>
684 
685     if (document().page()-&gt;settings().snapshotAllPlugIns()) {
686         LOG(Plugins, &quot;%p Plug-in forced to snapshot by user preference&quot;, this);
687         m_snapshotDecision = Snapshotted;
688         setDisplayState(WaitingForSnapshot);
689         return;
690     }
691 
692     if (document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled() &amp;&amp; document().page()-&gt;plugInClient() &amp;&amp; document().page()-&gt;plugInClient()-&gt;shouldAutoStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), url.host().toString(), serviceType())) {
693         LOG(Plugins, &quot;%p Plug-in from (%s, %s) is marked to auto-start, set to play&quot;, this, document().page()-&gt;mainFrame().document()-&gt;baseURL().host().utf8().data(), url.host().utf8().data());
694         m_snapshotDecision = NeverSnapshot;
695         return;
696     }
697 
698     if (m_loadedUrl.isEmpty() &amp;&amp; !serviceType().isEmpty()) {
699         LOG(Plugins, &quot;%p Plug-in has no src URL but does have a valid mime type %s, set to play&quot;, this, serviceType().utf8().data());
700         m_snapshotDecision = MaySnapshotWhenContentIsSet;
701         return;
702     }
703 
<span class="line-modified">704     if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) &amp;&amp; !m_loadedUrl.host().isEmpty() &amp;&amp; m_loadedUrl.host() == document().page()-&gt;mainFrame().document()-&gt;baseURL().host()) {</span>
705         LOG(Plugins, &quot;%p Plug-in is served from page&#39;s domain, set to play&quot;, this);
706         m_snapshotDecision = NeverSnapshot;
707         return;
708     }
709 
710     auto&amp; renderer = downcast&lt;RenderEmbeddedObject&gt;(*this-&gt;renderer());
711     auto contentRect = renderer.contentBoxRect();
712     int contentWidth = contentRect.width();
713     int contentHeight = contentRect.height();
714 
715     m_plugInDimensionsSpecified = renderer.style().logicalWidth().isSpecified() || renderer.style().logicalHeight().isSpecified();
716 
717     if (isTopLevelFullPagePlugin(renderer)) {
718         LOG(Plugins, &quot;%p Plug-in is top level full page, set to play&quot;, this);
719         m_snapshotDecision = NeverSnapshot;
720         return;
721     }
722 
723     if (isSmallerThanTinySizingThreshold(renderer)) {
724         LOG(Plugins, &quot;%p Plug-in is very small %dx%d, set to play&quot;, this, contentWidth, contentHeight);
</pre>
</td>
<td>
<hr />
<pre>
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;HTMLPlugInImageElement.h&quot;
 23 
 24 #include &quot;Chrome.h&quot;
 25 #include &quot;ChromeClient.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;EventNames.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;FrameLoaderClient.h&quot;
 31 #include &quot;HTMLImageLoader.h&quot;
 32 #include &quot;JSDOMConvertBoolean.h&quot;
 33 #include &quot;JSDOMConvertInterface.h&quot;
 34 #include &quot;JSDOMConvertStrings.h&quot;
 35 #include &quot;JSShadowRoot.h&quot;
<span class="line-added"> 36 #include &quot;LegacySchemeRegistry.h&quot;</span>
 37 #include &quot;LocalizedStrings.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MouseEvent.h&quot;
 40 #include &quot;Page.h&quot;
 41 #include &quot;PlatformMouseEvent.h&quot;
 42 #include &quot;PlugInClient.h&quot;
 43 #include &quot;PluginViewBase.h&quot;
 44 #include &quot;RenderImage.h&quot;
 45 #include &quot;RenderSnapshottedPlugIn.h&quot;
 46 #include &quot;RenderTreeUpdater.h&quot;

 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;SecurityOrigin.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;ShadowRoot.h&quot;
 51 #include &quot;StyleTreeResolver.h&quot;
 52 #include &quot;SubframeLoader.h&quot;
 53 #include &quot;TypedElementDescendantIterator.h&quot;
 54 #include &quot;UserGestureIndicator.h&quot;
 55 #include &lt;JavaScriptCore/CatchScope.h&gt;
<span class="line-added"> 56 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;</span>
 57 #include &lt;wtf/IsoMallocInlines.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
 62 
 63 static const int sizingTinyDimensionThreshold = 40;
 64 static const float sizingFullPageAreaRatioThreshold = 0.96;
 65 static const Seconds autostartSoonAfterUserGestureThreshold = 5_s;
 66 
 67 // This delay should not exceed the snapshot delay in PluginView.cpp
 68 static const Seconds simulatedMouseClickTimerDelay { 750_ms };
 69 
 70 #if PLATFORM(COCOA)
 71 static const Seconds removeSnapshotTimerDelay { 1500_ms };
 72 #endif
 73 
 74 static const String titleText(Page&amp; page, const String&amp; mimeType)
 75 {
 76     if (mimeType.isEmpty())
</pre>
<hr />
<pre>
168         if (contentDocument &amp;&amp; !document().securityOrigin().canAccess(contentDocument-&gt;securityOrigin()))
169             return false;
170     }
171 
172     return !isProhibitedSelfReference(completeURL);
173 }
174 
175 // We don&#39;t use m_url, or m_serviceType as they may not be the final values
176 // that &lt;object&gt; uses depending on &lt;param&gt; values.
177 bool HTMLPlugInImageElement::wouldLoadAsPlugIn(const String&amp; relativeURL, const String&amp; serviceType)
178 {
179     ASSERT(document().frame());
180     URL completedURL;
181     if (!relativeURL.isEmpty())
182         completedURL = document().completeURL(relativeURL);
183     return document().frame()-&gt;loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
184 }
185 
186 RenderPtr&lt;RenderElement&gt; HTMLPlugInImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
187 {
<span class="line-modified">188     ASSERT(document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
189 
190     if (displayState() &gt;= PreparingPluginReplacement)
191         return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
192 
193     // Once a plug-in element creates its renderer, it needs to be told when the document goes
<span class="line-modified">194     // inactive or reactivates so it can clear the renderer before going into the back/forward cache.</span>
195     if (!m_needsDocumentActivationCallbacks) {
196         m_needsDocumentActivationCallbacks = true;
197         document().registerForDocumentSuspensionCallbacks(*this);
198     }
199 
200     if (displayState() == DisplayingSnapshot) {
201         auto renderSnapshottedPlugIn = createRenderer&lt;RenderSnapshottedPlugIn&gt;(*this, WTFMove(style));
202         renderSnapshottedPlugIn-&gt;updateSnapshot(m_snapshotImage.get());
203         return renderSnapshottedPlugIn;
204     }
205 
206     if (useFallbackContent())
207         return RenderElement::createFor(*this, WTFMove(style));
208 
209     if (isImageType())
210         return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style));
211 
212     return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
213 }
214 
</pre>
<hr />
<pre>
346     if (displayState() &gt; DisplayingSnapshot)
347         return;
348 
349     m_snapshotImage = image;
350 
351     auto* renderer = this-&gt;renderer();
352     if (!renderer)
353         return;
354 
355     if (is&lt;RenderSnapshottedPlugIn&gt;(*renderer)) {
356         downcast&lt;RenderSnapshottedPlugIn&gt;(*renderer).updateSnapshot(image);
357         return;
358     }
359 
360     if (is&lt;RenderEmbeddedObject&gt;(*renderer))
361         renderer-&gt;repaint();
362 }
363 
364 static DOMWrapperWorld&amp; plugInImageElementIsolatedWorld()
365 {
<span class="line-modified">366     static auto&amp; isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, &quot;Plugin&quot;_s).leakRef();</span>
367     return isolatedWorld;
368 }
369 
370 void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
371 {
372     HTMLPlugInElement::didAddUserAgentShadowRoot(root);
373     if (displayState() &gt;= PreparingPluginReplacement)
374         return;
375 
376     auto* page = document().page();
377     if (!page)
378         return;
379 
380     // Reset any author styles that may apply as we only want explicit
381     // styles defined in the injected user agents stylesheets to specify
382     // the look-and-feel of the snapshotted plug-in overlay.
383     root.setResetStyleInheritance(true);
384 
385     String mimeType = serviceType();
386 
387     auto&amp; isolatedWorld = plugInImageElementIsolatedWorld();
388     document().ensurePlugInsInjectedScript(isolatedWorld);
389 
390     auto&amp; scriptController = document().frame()-&gt;script();
391     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(isolatedWorld));
392 
393     auto&amp; vm = globalObject.vm();
394     JSC::JSLockHolder lock(vm);
395     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">396     auto&amp; lexicalGlobalObject = globalObject;</span>
397 
398     JSC::MarkedArgumentBuffer argList;
<span class="line-modified">399     argList.append(toJS&lt;IDLInterface&lt;ShadowRoot&gt;&gt;(lexicalGlobalObject, globalObject, root));</span>
<span class="line-modified">400     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, titleText(*page, mimeType)));</span>
<span class="line-modified">401     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, subtitleText(*page, mimeType)));</span>
402 
403     // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
404     // If no snapshot was found then we want the overlay to be visible.
405     argList.append(toJS&lt;IDLBoolean&gt;(!m_snapshotImage));
406     ASSERT(!argList.hasOverflowed());
407 
408     // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
<span class="line-modified">409     auto* overlay = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createOverlay&quot;)).toObject(&amp;lexicalGlobalObject);</span>
410     ASSERT(!overlay == !!scope.exception());
411     if (!overlay) {
412         scope.clearException();
413         return;
414     }
415     JSC::CallData callData;
416     auto callType = overlay-&gt;methodTable(vm)-&gt;getCallData(overlay, callData);
417     if (callType == JSC::CallType::None)
418         return;
419 
<span class="line-modified">420     call(&amp;lexicalGlobalObject, overlay, callType, callData, &amp;globalObject, argList);</span>
421     scope.clearException();
422 }
423 
424 bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
425 {
426     static NeverDestroyed&lt;AtomString&gt; selector(&quot;.snapshot-overlay&quot;, AtomString::ConstructFromLiteral);
427     auto shadow = userAgentShadowRoot();
428     if (!shadow)
429         return false;
430     if (!is&lt;Node&gt;(target))
431         return false;
432     auto queryResult = shadow-&gt;querySelector(selector.get());
433     if (queryResult.hasException())
434         return false;
435     auto snapshotLabel = makeRefPtr(queryResult.releaseReturnValue());
436     return snapshotLabel &amp;&amp; snapshotLabel-&gt;contains(downcast&lt;Node&gt;(target));
437 }
438 
439 void HTMLPlugInImageElement::removeSnapshotTimerFired()
440 {
</pre>
<hr />
<pre>
468             if (plugInOrigin == element.loadedUrl().host() &amp;&amp; mimeType == element.serviceType())
469                 similarPlugins.append(element);
470         }
471     }
472 
473     for (auto&amp; plugInToRestart : similarPlugins) {
474         if (plugInToRestart-&gt;displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot) {
475             LOG(Plugins, &quot;%p Plug-in looks similar to a restarted plug-in. Restart.&quot;, plugInToRestart.ptr());
476             plugInToRestart-&gt;restartSnapshottedPlugIn();
477         }
478         plugInToRestart-&gt;m_snapshotDecision = NeverSnapshot;
479     }
480 }
481 
482 void HTMLPlugInImageElement::userDidClickSnapshot(MouseEvent&amp; event, bool forwardEvent)
483 {
484     if (forwardEvent)
485         m_pendingClickEventFromSnapshot = &amp;event;
486 
487     auto plugInOrigin = m_loadedUrl.host();
<span class="line-modified">488     if (document().page() &amp;&amp; !LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()-&gt;mainFrame().document()-&gt;baseURL().protocol().toStringWithoutCopying()) &amp;&amp; document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled())</span>
<span class="line-modified">489         document().page()-&gt;plugInClient()-&gt;didStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), plugInOrigin.toString(), serviceType());</span>
490 
491     LOG(Plugins, &quot;%p User clicked on snapshotted plug-in. Restart.&quot;, this);
492     restartSnapshottedPlugIn();
493     if (forwardEvent)
494         setDisplayState(RestartingWithPendingMouseClick);
495     restartSimilarPlugIns();
496 }
497 
498 void HTMLPlugInImageElement::setIsPrimarySnapshottedPlugIn(bool isPrimarySnapshottedPlugIn)
499 {
500     if (!document().page() || !document().page()-&gt;settings().primaryPlugInSnapshotDetectionEnabled() || document().page()-&gt;settings().snapshotAllPlugIns())
501         return;
502 
503     if (isPrimarySnapshottedPlugIn) {
504         if (m_plugInWasCreated) {
505             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page. Restart.&quot;, this);
506             restartSnapshottedPlugIn();
507             restartSimilarPlugIns();
508         } else {
509             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page, but is not yet created. Will restart later.&quot;, this);
</pre>
<hr />
<pre>
685 
686     if (document().page()-&gt;settings().snapshotAllPlugIns()) {
687         LOG(Plugins, &quot;%p Plug-in forced to snapshot by user preference&quot;, this);
688         m_snapshotDecision = Snapshotted;
689         setDisplayState(WaitingForSnapshot);
690         return;
691     }
692 
693     if (document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled() &amp;&amp; document().page()-&gt;plugInClient() &amp;&amp; document().page()-&gt;plugInClient()-&gt;shouldAutoStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), url.host().toString(), serviceType())) {
694         LOG(Plugins, &quot;%p Plug-in from (%s, %s) is marked to auto-start, set to play&quot;, this, document().page()-&gt;mainFrame().document()-&gt;baseURL().host().utf8().data(), url.host().utf8().data());
695         m_snapshotDecision = NeverSnapshot;
696         return;
697     }
698 
699     if (m_loadedUrl.isEmpty() &amp;&amp; !serviceType().isEmpty()) {
700         LOG(Plugins, &quot;%p Plug-in has no src URL but does have a valid mime type %s, set to play&quot;, this, serviceType().utf8().data());
701         m_snapshotDecision = MaySnapshotWhenContentIsSet;
702         return;
703     }
704 
<span class="line-modified">705     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) &amp;&amp; !m_loadedUrl.host().isEmpty() &amp;&amp; m_loadedUrl.host() == document().page()-&gt;mainFrame().document()-&gt;baseURL().host()) {</span>
706         LOG(Plugins, &quot;%p Plug-in is served from page&#39;s domain, set to play&quot;, this);
707         m_snapshotDecision = NeverSnapshot;
708         return;
709     }
710 
711     auto&amp; renderer = downcast&lt;RenderEmbeddedObject&gt;(*this-&gt;renderer());
712     auto contentRect = renderer.contentBoxRect();
713     int contentWidth = contentRect.width();
714     int contentHeight = contentRect.height();
715 
716     m_plugInDimensionsSpecified = renderer.style().logicalWidth().isSpecified() || renderer.style().logicalHeight().isSpecified();
717 
718     if (isTopLevelFullPagePlugin(renderer)) {
719         LOG(Plugins, &quot;%p Plug-in is top level full page, set to play&quot;, this);
720         m_snapshotDecision = NeverSnapshot;
721         return;
722     }
723 
724     if (isSmallerThanTinySizingThreshold(renderer)) {
725         LOG(Plugins, &quot;%p Plug-in is very small %dx%d, set to play&quot;, this, contentWidth, contentHeight);
</pre>
</td>
</tr>
</table>
<center><a href="HTMLPlugInElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLSelectElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
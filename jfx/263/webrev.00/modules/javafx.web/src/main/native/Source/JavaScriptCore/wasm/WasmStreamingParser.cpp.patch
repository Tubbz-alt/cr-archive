diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp
@@ -26,12 +26,13 @@
 #include "config.h"
 #include "WasmStreamingParser.h"
 
 #if ENABLE(WEBASSEMBLY)
 
-#include "WasmModuleParser.h"
+#include "WasmOps.h"
 #include "WasmSectionParser.h"
+#include "WasmSignatureInlines.h"
 #include <wtf/Optional.h>
 #include <wtf/UnalignedAccess.h>
 
 namespace JSC { namespace Wasm {
 
@@ -65,12 +66,13 @@
     m_errorMessage = makeString("WebAssembly.Module doesn't parse at byte "_s, String::number(m_offset), ": "_s, makeString(args)...);
     dataLogLnIf(WasmStreamingParserInternal::verbose, m_errorMessage);
     return State::FatalError;
 }
 
-StreamingParser::StreamingParser(ModuleInformation& info)
+StreamingParser::StreamingParser(ModuleInformation& info, StreamingParserClient& client)
     : m_info(info)
+    , m_client(client)
 {
     dataLogLnIf(WasmStreamingParserInternal::verbose, "starting validation");
 }
 
 auto StreamingParser::parseModuleHeader(Vector<uint8_t>&& data) -> State
@@ -118,10 +120,12 @@
     WASM_PARSER_FAIL_IF(functionCount == std::numeric_limits<uint32_t>::max(), "Code section's count is too big ", functionCount);
     WASM_PARSER_FAIL_IF(functionCount != m_info->functions.size(), "Code section count ", functionCount, " exceeds the declared number of functions ", m_info->functions.size());
 
     if (m_functionIndex == m_functionCount) {
         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != m_nextOffset, "parsing ended before the end of ", m_section, " section");
+        if (!m_client.didReceiveSectionData(m_section))
+            return State::FatalError;
         return State::SectionID;
     }
     return State::FunctionSize;
 }
 
@@ -137,13 +141,18 @@
     auto& function = m_info->functions[m_functionIndex];
     function.start = m_offset;
     function.end = m_offset + m_functionSize;
     function.data = WTFMove(data);
     dataLogLnIf(WasmStreamingParserInternal::verbose, "Processing function starting at: ", function.start, " and ending at: ", function.end);
+    if (!m_client.didReceiveFunctionData(m_functionIndex, function))
+        return State::FatalError;
     ++m_functionIndex;
+
     if (m_functionIndex == m_functionCount) {
         WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != (m_offset + m_functionSize), "parsing ended before the end of ", m_section, " section");
+        if (!m_client.didReceiveSectionData(m_section))
+            return State::FatalError;
         return State::SectionID;
     }
     return State::FunctionSize;
 }
 
@@ -170,10 +179,12 @@
     }
     }
 
     WASM_PARSER_FAIL_IF(parser.length() != parser.offset(), "parsing ended before the end of ", m_section, " section");
 
+    if (!m_client.didReceiveSectionData(m_section))
+        return State::FatalError;
     return State::SectionID;
 }
 
 auto StreamingParser::consume(const uint8_t* bytes, size_t bytesSize, size_t& offsetInBytes, size_t requiredSize) -> Optional<Vector<uint8_t>>
 {
@@ -376,14 +387,19 @@
     case State::Finished:
     case State::FatalError:
         break;
 
     case State::SectionID:
+        if (m_functionIndex != m_info->functions.size()) {
+            m_state = fail("Number of functions parsed (", m_functionCount, ") does not match the number of declared functions (", m_info->functions.size(), ")");
+            break;
+        }
         if (m_remaining.isEmpty()) {
             if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
                 m_info->nameSection->setHash(m_hasher.computeHexDigest());
             m_state = State::Finished;
+            m_client.didFinishParsing();
         } else
             m_state = failOnState(State::SectionID);
         break;
     }
     return m_state;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DatePrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  *  Copyright (C) 2008, 2009 Torch Mobile, Inc. All rights reserved.
   5  *  Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
   6  *
   7  *  This library is free software; you can redistribute it and/or
   8  *  modify it under the terms of the GNU Lesser General Public
   9  *  License as published by the Free Software Foundation; either
  10  *  version 2 of the License, or (at your option) any later version.
  11  *
  12  *  This library is distributed in the hope that it will be useful,
  13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  *  Lesser General Public License for more details.
  16  *
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;DatePrototype.h&quot;
  26 
  27 #include &quot;DateConversion.h&quot;
  28 #include &quot;DateInstance.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;JSCBuiltins.h&quot;
  31 #include &quot;JSDateMath.h&quot;
  32 #include &quot;JSGlobalObject.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSString.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;ObjectPrototype.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &lt;limits.h&gt;
  39 #include &lt;locale.h&gt;
  40 #include &lt;math.h&gt;
  41 #include &lt;stdlib.h&gt;
  42 #include &lt;time.h&gt;
  43 #include &lt;wtf/Assertions.h&gt;
  44 #include &lt;wtf/MathExtras.h&gt;
  45 
  46 #if HAVE(LANGINFO_H)
  47 #include &lt;langinfo.h&gt;
  48 #endif
  49 
  50 #if HAVE(SYS_PARAM_H)
  51 #include &lt;sys/param.h&gt;
  52 #endif
  53 
  54 #if HAVE(SYS_TIME_H)
  55 #include &lt;sys/time.h&gt;
  56 #endif
  57 
  58 #if HAVE(SYS_TIMEB_H)
  59 #include &lt;sys/timeb.h&gt;
  60 #endif
  61 
  62 #if !(OS(DARWIN) &amp;&amp; USE(CF))
  63 #include &lt;unicode/udat.h&gt;
  64 #endif
  65 
  66 #if USE(CF)
  67 #include &lt;CoreFoundation/CoreFoundation.h&gt;
  68 #endif
  69 
  70 namespace JSC {
  71 
<a name="1" id="anc1"></a><span class="line-modified">  72 using namespace WTF;</span>
<span class="line-modified">  73 </span>
<span class="line-modified">  74 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState*);</span>
<span class="line-modified">  75 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState*);</span>
<span class="line-modified">  76 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState*);</span>
<span class="line-modified">  77 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState*);</span>
<span class="line-modified">  78 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState*);</span>
<span class="line-modified">  79 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState*);</span>
<span class="line-modified">  80 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState*);</span>
<span class="line-modified">  81 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState*);</span>
<span class="line-modified">  82 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState*);</span>
<span class="line-modified">  83 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState*);</span>
<span class="line-modified">  84 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState*);</span>
<span class="line-modified">  85 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState*);</span>
<span class="line-modified">  86 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState*);</span>
<span class="line-modified">  87 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState*);</span>
<span class="line-modified">  88 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState*);</span>
<span class="line-modified">  89 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState*);</span>
<span class="line-modified">  90 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState*);</span>
<span class="line-modified">  91 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState*);</span>
<span class="line-modified">  92 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState*);</span>
<span class="line-modified">  93 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState*);</span>
<span class="line-modified">  94 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState*);</span>
<span class="line-modified">  95 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState*);</span>
<span class="line-modified">  96 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState*);</span>
<span class="line-modified">  97 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState*);</span>
<span class="line-modified">  98 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState*);</span>
<span class="line-modified">  99 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState*);</span>
<span class="line-modified"> 100 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState*);</span>
<span class="line-modified"> 101 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState*);</span>
<span class="line-modified"> 102 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState*);</span>
<span class="line-modified"> 103 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState*);</span>
<span class="line-modified"> 104 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState*);</span>
<span class="line-modified"> 105 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState*);</span>
<span class="line-modified"> 106 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState*);</span>
<span class="line-modified"> 107 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState*);</span>
<span class="line-modified"> 108 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState*);</span>
<span class="line-modified"> 109 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState*);</span>
<span class="line-modified"> 110 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState*);</span>
<span class="line-modified"> 111 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState*);</span>
<span class="line-modified"> 112 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState*);</span>
<span class="line-modified"> 113 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState*);</span>
<span class="line-modified"> 114 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState*);</span>
<span class="line-modified"> 115 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState*);</span>
<span class="line-removed"> 116 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState*);</span>
<span class="line-removed"> 117 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState*);</span>
 118 
 119 }
 120 
 121 #include &quot;DatePrototype.lut.h&quot;
 122 
 123 namespace JSC {
 124 
 125 enum LocaleDateTimeFormat { LocaleDateAndTime, LocaleDate, LocaleTime };
 126 
 127 #if OS(DARWIN) &amp;&amp; USE(CF)
 128 
 129 // FIXME: Since this is superior to the strftime-based version, why limit this to OS(DARWIN)?
 130 // Instead we should consider using this whenever USE(CF) is true.
 131 
 132 static CFDateFormatterStyle styleFromArgString(const String&amp; string, CFDateFormatterStyle defaultStyle)
 133 {
 134     if (string == &quot;short&quot;)
 135         return kCFDateFormatterShortStyle;
 136     if (string == &quot;medium&quot;)
 137         return kCFDateFormatterMediumStyle;
 138     if (string == &quot;long&quot;)
 139         return kCFDateFormatterLongStyle;
 140     if (string == &quot;full&quot;)
 141         return kCFDateFormatterFullStyle;
 142     return defaultStyle;
 143 }
 144 
<a name="2" id="anc2"></a><span class="line-modified"> 145 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)</span>
 146 {
<a name="3" id="anc3"></a><span class="line-modified"> 147     VM&amp; vm = exec-&gt;vm();</span>
 148     CFDateFormatterStyle dateStyle = (format != LocaleTime ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 149     CFDateFormatterStyle timeStyle = (format != LocaleDate ? kCFDateFormatterLongStyle : kCFDateFormatterNoStyle);
 150 
 151     bool useCustomFormat = false;
 152     String customFormatString;
 153 
<a name="4" id="anc4"></a><span class="line-modified"> 154     String arg0String = exec-&gt;argument(0).toWTFString(exec);</span>
<span class="line-modified"> 155     if (arg0String == &quot;custom&quot; &amp;&amp; !exec-&gt;argument(1).isUndefined()) {</span>
 156         useCustomFormat = true;
<a name="5" id="anc5"></a><span class="line-modified"> 157         customFormatString = exec-&gt;argument(1).toWTFString(exec);</span>
<span class="line-modified"> 158     } else if (format == LocaleDateAndTime &amp;&amp; !exec-&gt;argument(1).isUndefined()) {</span>
 159         dateStyle = styleFromArgString(arg0String, dateStyle);
<a name="6" id="anc6"></a><span class="line-modified"> 160         timeStyle = styleFromArgString(exec-&gt;argument(1).toWTFString(exec), timeStyle);</span>
<span class="line-modified"> 161     } else if (format != LocaleTime &amp;&amp; !exec-&gt;argument(0).isUndefined())</span>
 162         dateStyle = styleFromArgString(arg0String, dateStyle);
<a name="7" id="anc7"></a><span class="line-modified"> 163     else if (format != LocaleDate &amp;&amp; !exec-&gt;argument(0).isUndefined())</span>
 164         timeStyle = styleFromArgString(arg0String, timeStyle);
 165 
 166     CFAbsoluteTime absoluteTime = floor(timeInMilliseconds / msPerSecond) - kCFAbsoluteTimeIntervalSince1970;
 167 
 168     auto formatter = adoptCF(CFDateFormatterCreate(kCFAllocatorDefault, adoptCF(CFLocaleCopyCurrent()).get(), dateStyle, timeStyle));
 169     if (useCustomFormat)
 170         CFDateFormatterSetFormat(formatter.get(), customFormatString.createCFString().get());
 171     return jsNontrivialString(vm, adoptCF(CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatter.get(), absoluteTime)).get());
 172 }
 173 
 174 #elif !UCONFIG_NO_FORMATTING
 175 
<a name="8" id="anc8"></a><span class="line-modified"> 176 static JSCell* formatLocaleDate(ExecState* exec, DateInstance*, double timeInMilliseconds, LocaleDateTimeFormat format)</span>
 177 {
<a name="9" id="anc9"></a><span class="line-modified"> 178     VM&amp; vm = exec-&gt;vm();</span>
 179     UDateFormatStyle timeStyle = (format != LocaleDate ? UDAT_LONG : UDAT_NONE);
 180     UDateFormatStyle dateStyle = (format != LocaleTime ? UDAT_LONG : UDAT_NONE);
 181 
 182     UErrorCode status = U_ZERO_ERROR;
 183     UDateFormat* df = udat_open(timeStyle, dateStyle, 0, 0, -1, 0, 0, &amp;status);
 184     if (!df)
 185         return jsEmptyString(vm);
 186 
 187     UChar buffer[128];
 188     int32_t length;
 189     length = udat_format(df, timeInMilliseconds, buffer, 128, 0, &amp;status);
 190     udat_close(df);
 191     if (status != U_ZERO_ERROR)
 192         return jsEmptyString(vm);
 193 
 194     return jsNontrivialString(vm, String(buffer, length));
 195 }
 196 
 197 #else
 198 
<a name="10" id="anc10"></a><span class="line-modified"> 199 static JSCell* formatLocaleDate(ExecState* exec, const GregorianDateTime&amp; gdt, LocaleDateTimeFormat format)</span>
 200 {
<a name="11" id="anc11"></a><span class="line-modified"> 201     VM&amp; vm = exec-&gt;vm();</span>
 202 #if OS(WINDOWS)
 203     SYSTEMTIME systemTime;
 204     memset(&amp;systemTime, 0, sizeof(systemTime));
 205     systemTime.wYear = gdt.year();
 206     systemTime.wMonth = gdt.month() + 1;
 207     systemTime.wDay = gdt.monthDay();
 208     systemTime.wDayOfWeek = gdt.weekDay();
 209     systemTime.wHour = gdt.hour();
 210     systemTime.wMinute = gdt.minute();
 211     systemTime.wSecond = gdt.second();
 212 
 213     Vector&lt;UChar, 128&gt; buffer;
 214     size_t length = 0;
 215 
 216     if (format == LocaleDate) {
 217         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0));
 218         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 219     } else if (format == LocaleTime) {
 220         buffer.resize(GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 221         length = GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data(), buffer.size());
 222     } else if (format == LocaleDateAndTime) {
 223         buffer.resize(GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, 0, 0) + GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, 0, 0));
 224         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_LONGDATE, &amp;systemTime, 0, buffer.data(), buffer.size());
 225         if (length) {
 226             buffer[length - 1] = &#39; &#39;;
 227             length += GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &amp;systemTime, 0, buffer.data() + length, buffer.size() - length);
 228         }
 229     } else
 230         RELEASE_ASSERT_NOT_REACHED();
 231 
 232     //  Remove terminating null character.
 233     if (length)
 234         length--;
 235 
 236     return jsNontrivialString(vm, String(buffer.data(), length));
 237 
 238 #else // OS(WINDOWS)
 239 
 240 #if HAVE(LANGINFO_H)
 241     static const nl_item formats[] = { D_T_FMT, D_FMT, T_FMT };
 242 #else
 243     static const char* const formatStrings[] = { &quot;%#c&quot;, &quot;%#x&quot;, &quot;%X&quot; };
 244 #endif
 245 
 246     // Offset year if needed
 247     struct tm localTM = gdt;
 248     int year = gdt.year();
 249     bool yearNeedsOffset = year &lt; 1900 || year &gt; 2038;
 250     if (yearNeedsOffset)
 251         localTM.tm_year = equivalentYearForDST(year) - 1900;
 252 
 253 #if HAVE(LANGINFO_H)
 254     // We do not allow strftime to generate dates with 2-digits years,
 255     // both to avoid ambiguity, and a crash in strncpy, for years that
 256     // need offset.
 257     char* formatString = strdup(nl_langinfo(formats[format]));
 258     char* yPos = strchr(formatString, &#39;y&#39;);
 259     if (yPos)
 260         *yPos = &#39;Y&#39;;
 261 #endif
 262 
 263     // Do the formatting
 264     const int bufsize = 128;
 265     char timebuffer[bufsize];
 266 
 267 #if HAVE(LANGINFO_H)
 268     size_t ret = strftime(timebuffer, bufsize, formatString, &amp;localTM);
 269     free(formatString);
 270 #else
 271     size_t ret = strftime(timebuffer, bufsize, formatStrings[format], &amp;localTM);
 272 #endif
 273 
 274     if (ret == 0)
 275         return jsEmptyString(vm);
 276 
 277     // Copy original into the buffer
 278     if (yearNeedsOffset &amp;&amp; format != LocaleTime) {
 279         static const int yearLen = 5;   // FIXME will be a problem in the year 10,000
 280         char yearString[yearLen];
 281 
 282         snprintf(yearString, yearLen, &quot;%d&quot;, localTM.tm_year + 1900);
 283         char* yearLocation = strstr(timebuffer, yearString);
 284         snprintf(yearString, yearLen, &quot;%d&quot;, year);
 285 
 286         strncpy(yearLocation, yearString, yearLen - 1);
 287     }
 288 
 289     // Convert multi-byte result to UNICODE.
 290     // If __STDC_ISO_10646__ is defined, wide character represents
 291     // UTF-16 (or UTF-32) code point. In most modern Unix like system
 292     // (e.g. Linux with glibc 2.2 and above) the macro is defined,
 293     // and wide character represents UTF-32 code point.
 294     // Here we static_cast potential UTF-32 to UTF-16, it should be
 295     // safe because date and (or) time related characters in different languages
 296     // should be in UNICODE BMP. If mbstowcs fails, we just fall
 297     // back on using multi-byte result as-is.
 298 #ifdef __STDC_ISO_10646__
 299     UChar buffer[bufsize];
 300     wchar_t tempbuffer[bufsize];
 301     size_t length = mbstowcs(tempbuffer, timebuffer, bufsize - 1);
 302     if (length != static_cast&lt;size_t&gt;(-1)) {
 303         for (size_t i = 0; i &lt; length; ++i)
 304             buffer[i] = static_cast&lt;UChar&gt;(tempbuffer[i]);
 305         return jsNontrivialString(vm, String(buffer, length));
 306     }
 307 #endif
 308 
 309     return jsNontrivialString(vm, timebuffer);
 310 #endif // OS(WINDOWS)
 311 }
 312 
<a name="12" id="anc12"></a><span class="line-modified"> 313 static JSCell* formatLocaleDate(ExecState* exec, DateInstance* dateObject, double, LocaleDateTimeFormat format)</span>
 314 {
<a name="13" id="anc13"></a><span class="line-modified"> 315     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 316     const GregorianDateTime* gregorianDateTime = dateObject-&gt;gregorianDateTime(exec);</span>
 317     if (!gregorianDateTime)
 318         return jsNontrivialString(vm, &quot;Invalid Date&quot;_s);
<a name="14" id="anc14"></a><span class="line-modified"> 319     return formatLocaleDate(exec, *gregorianDateTime, format);</span>
 320 }
 321 
 322 #endif // OS(DARWIN) &amp;&amp; USE(CF)
 323 
<a name="15" id="anc15"></a><span class="line-modified"> 324 static EncodedJSValue formateDateInstance(ExecState* exec, DateTimeFormat format, bool asUTCVariant)</span>
 325 {
<a name="16" id="anc16"></a><span class="line-modified"> 326     VM&amp; vm = exec-&gt;vm();</span>
 327     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="17" id="anc17"></a><span class="line-modified"> 328     JSValue thisValue = exec-&gt;thisValue();</span>
 329     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 330     if (UNLIKELY(!thisDateObj))
<a name="18" id="anc18"></a><span class="line-modified"> 331         return throwVMTypeError(exec, scope);</span>
 332 
 333     const GregorianDateTime* gregorianDateTime = asUTCVariant
<a name="19" id="anc19"></a><span class="line-modified"> 334         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)</span>
<span class="line-modified"> 335         : thisDateObj-&gt;gregorianDateTime(exec);</span>
 336     if (!gregorianDateTime)
 337         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 338 
 339     return JSValue::encode(jsNontrivialString(vm, formatDateTime(*gregorianDateTime, format, asUTCVariant)));
 340 }
 341 
 342 // Converts a list of arguments sent to a Date member function into milliseconds, updating
 343 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 344 //
 345 // Format of member function: f([hour,] [min,] [sec,] [ms])
<a name="20" id="anc20"></a><span class="line-modified"> 346 static bool fillStructuresUsingTimeArgs(ExecState* exec, int maxArgs, double* ms, GregorianDateTime* t)</span>
 347 {
<a name="21" id="anc21"></a><span class="line-modified"> 348     VM&amp; vm = exec-&gt;vm();</span>
 349     auto scope = DECLARE_THROW_SCOPE(vm);
 350 
 351     double milliseconds = 0;
 352     bool ok = true;
 353     int idx = 0;
<a name="22" id="anc22"></a><span class="line-modified"> 354     int numArgs = exec-&gt;argumentCount();</span>
 355 
 356     // JS allows extra trailing arguments -- ignore them
 357     if (numArgs &gt; maxArgs)
 358         numArgs = maxArgs;
 359 
 360     // hours
 361     if (maxArgs &gt;= 4 &amp;&amp; idx &lt; numArgs) {
 362         t-&gt;setHour(0);
<a name="23" id="anc23"></a><span class="line-modified"> 363         double hours = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 364         RETURN_IF_EXCEPTION(scope, false);
 365         ok = std::isfinite(hours);
 366         milliseconds += hours * msPerHour;
 367     }
 368 
 369     // minutes
 370     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 371         t-&gt;setMinute(0);
<a name="24" id="anc24"></a><span class="line-modified"> 372         double minutes = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 373         RETURN_IF_EXCEPTION(scope, false);
 374         ok = std::isfinite(minutes);
 375         milliseconds += minutes * msPerMinute;
 376     }
 377 
 378     // seconds
 379     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
 380         t-&gt;setSecond(0);
<a name="25" id="anc25"></a><span class="line-modified"> 381         double seconds = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 382         RETURN_IF_EXCEPTION(scope, false);
 383         ok = std::isfinite(seconds);
 384         milliseconds += seconds * msPerSecond;
 385     }
 386 
 387     if (!ok)
 388         return false;
 389 
 390     // milliseconds
 391     if (idx &lt; numArgs) {
<a name="26" id="anc26"></a><span class="line-modified"> 392         double millis = exec-&gt;uncheckedArgument(idx).toIntegerPreserveNaN(exec);</span>
 393         RETURN_IF_EXCEPTION(scope, false);
 394         ok = std::isfinite(millis);
 395         milliseconds += millis;
 396     } else
 397         milliseconds += *ms;
 398 
 399     *ms = milliseconds;
 400     return ok;
 401 }
 402 
 403 // Converts a list of arguments sent to a Date member function into years, months, and milliseconds, updating
 404 // ms (representing milliseconds) and t (representing the rest of the date structure) appropriately.
 405 //
 406 // Format of member function: f([years,] [months,] [days])
<a name="27" id="anc27"></a><span class="line-modified"> 407 static bool fillStructuresUsingDateArgs(ExecState *exec, int maxArgs, double *ms, GregorianDateTime *t)</span>
 408 {
<a name="28" id="anc28"></a><span class="line-modified"> 409     VM&amp; vm = exec-&gt;vm();</span>
 410     auto scope = DECLARE_THROW_SCOPE(vm);
 411 
 412     int idx = 0;
 413     bool ok = true;
<a name="29" id="anc29"></a><span class="line-modified"> 414     int numArgs = exec-&gt;argumentCount();</span>
 415 
 416     // JS allows extra trailing arguments -- ignore them
 417     if (numArgs &gt; maxArgs)
 418         numArgs = maxArgs;
 419 
 420     // years
 421     if (maxArgs &gt;= 3 &amp;&amp; idx &lt; numArgs) {
<a name="30" id="anc30"></a><span class="line-modified"> 422         double years = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 423         RETURN_IF_EXCEPTION(scope, false);
 424         ok = std::isfinite(years);
 425         t-&gt;setYear(toInt32(years));
 426     }
 427     // months
 428     if (maxArgs &gt;= 2 &amp;&amp; idx &lt; numArgs &amp;&amp; ok) {
<a name="31" id="anc31"></a><span class="line-modified"> 429         double months = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 430         RETURN_IF_EXCEPTION(scope, false);
 431         ok = std::isfinite(months);
 432         t-&gt;setMonth(toInt32(months));
 433     }
 434     // days
 435     if (idx &lt; numArgs &amp;&amp; ok) {
<a name="32" id="anc32"></a><span class="line-modified"> 436         double days = exec-&gt;uncheckedArgument(idx++).toIntegerPreserveNaN(exec);</span>
 437         RETURN_IF_EXCEPTION(scope, false);
 438         ok = std::isfinite(days);
 439         t-&gt;setMonthDay(0);
 440         *ms += days * msPerDay;
 441     }
 442 
 443     return ok;
 444 }
 445 
 446 const ClassInfo DatePrototype::s_info = {&quot;Object&quot;, &amp;JSNonFinalObject::s_info, &amp;dateTable, nullptr, CREATE_METHOD_TABLE(DatePrototype)};
 447 
 448 /* Source for DatePrototype.lut.h
 449 @begin dateTable
 450   toString              dateProtoFuncToString                DontEnum|Function       0
 451   toISOString           dateProtoFuncToISOString             DontEnum|Function       0
 452   toDateString          dateProtoFuncToDateString            DontEnum|Function       0
 453   toTimeString          dateProtoFuncToTimeString            DontEnum|Function       0
 454   toLocaleString        dateProtoFuncToLocaleString          DontEnum|Function       0
 455   toLocaleDateString    dateProtoFuncToLocaleDateString      DontEnum|Function       0
 456   toLocaleTimeString    dateProtoFuncToLocaleTimeString      DontEnum|Function       0
<a name="33" id="anc33"></a><span class="line-modified"> 457   valueOf               dateProtoFuncGetTime                 DontEnum|Function       0</span>
<span class="line-modified"> 458   getTime               dateProtoFuncGetTime                 DontEnum|Function       0</span>
<span class="line-modified"> 459   getFullYear           dateProtoFuncGetFullYear             DontEnum|Function       0</span>
<span class="line-modified"> 460   getUTCFullYear        dateProtoFuncGetUTCFullYear          DontEnum|Function       0</span>
<span class="line-modified"> 461   getMonth              dateProtoFuncGetMonth                DontEnum|Function       0</span>
<span class="line-modified"> 462   getUTCMonth           dateProtoFuncGetUTCMonth             DontEnum|Function       0</span>
<span class="line-modified"> 463   getDate               dateProtoFuncGetDate                 DontEnum|Function       0</span>
<span class="line-modified"> 464   getUTCDate            dateProtoFuncGetUTCDate              DontEnum|Function       0</span>
<span class="line-modified"> 465   getDay                dateProtoFuncGetDay                  DontEnum|Function       0</span>
<span class="line-modified"> 466   getUTCDay             dateProtoFuncGetUTCDay               DontEnum|Function       0</span>
<span class="line-modified"> 467   getHours              dateProtoFuncGetHours                DontEnum|Function       0</span>
<span class="line-modified"> 468   getUTCHours           dateProtoFuncGetUTCHours             DontEnum|Function       0</span>
<span class="line-modified"> 469   getMinutes            dateProtoFuncGetMinutes              DontEnum|Function       0</span>
<span class="line-modified"> 470   getUTCMinutes         dateProtoFuncGetUTCMinutes           DontEnum|Function       0</span>
<span class="line-modified"> 471   getSeconds            dateProtoFuncGetSeconds              DontEnum|Function       0</span>
<span class="line-modified"> 472   getUTCSeconds         dateProtoFuncGetUTCSeconds           DontEnum|Function       0</span>
<span class="line-modified"> 473   getMilliseconds       dateProtoFuncGetMilliSeconds         DontEnum|Function       0</span>
<span class="line-modified"> 474   getUTCMilliseconds    dateProtoFuncGetUTCMilliseconds      DontEnum|Function       0</span>
<span class="line-modified"> 475   getTimezoneOffset     dateProtoFuncGetTimezoneOffset       DontEnum|Function       0</span>

 476   setTime               dateProtoFuncSetTime                 DontEnum|Function       1
 477   setMilliseconds       dateProtoFuncSetMilliSeconds         DontEnum|Function       1
 478   setUTCMilliseconds    dateProtoFuncSetUTCMilliseconds      DontEnum|Function       1
 479   setSeconds            dateProtoFuncSetSeconds              DontEnum|Function       2
 480   setUTCSeconds         dateProtoFuncSetUTCSeconds           DontEnum|Function       2
 481   setMinutes            dateProtoFuncSetMinutes              DontEnum|Function       3
 482   setUTCMinutes         dateProtoFuncSetUTCMinutes           DontEnum|Function       3
 483   setHours              dateProtoFuncSetHours                DontEnum|Function       4
 484   setUTCHours           dateProtoFuncSetUTCHours             DontEnum|Function       4
 485   setDate               dateProtoFuncSetDate                 DontEnum|Function       1
 486   setUTCDate            dateProtoFuncSetUTCDate              DontEnum|Function       1
 487   setMonth              dateProtoFuncSetMonth                DontEnum|Function       2
 488   setUTCMonth           dateProtoFuncSetUTCMonth             DontEnum|Function       2
 489   setFullYear           dateProtoFuncSetFullYear             DontEnum|Function       3
 490   setUTCFullYear        dateProtoFuncSetUTCFullYear          DontEnum|Function       3
 491   setYear               dateProtoFuncSetYear                 DontEnum|Function       1
<a name="34" id="anc34"></a><span class="line-removed"> 492   getYear               dateProtoFuncGetYear                 DontEnum|Function       0</span>
 493   toJSON                dateProtoFuncToJSON                  DontEnum|Function       1
 494 @end
 495 */
 496 
 497 // ECMA 15.9.4
 498 
 499 DatePrototype::DatePrototype(VM&amp; vm, Structure* structure)
 500     : Base(vm, structure)
 501 {
 502 }
 503 
 504 void DatePrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 505 {
 506     Base::finishCreation(vm);
 507     ASSERT(inherits(vm, info()));
 508 
 509     Identifier toUTCStringName = Identifier::fromString(vm, &quot;toUTCString&quot;_s);
 510     JSFunction* toUTCStringFunction = JSFunction::create(vm, globalObject, 0, toUTCStringName.string(), dateProtoFuncToUTCString);
 511     putDirectWithoutTransition(vm, toUTCStringName, toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 512     putDirectWithoutTransition(vm, Identifier::fromString(vm, &quot;toGMTString&quot;_s), toUTCStringFunction, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 513 
 514 #if ENABLE(INTL)
 515     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleString&quot;, datePrototypeToLocaleStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 516     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleDateString&quot;, datePrototypeToLocaleDateStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 517     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(&quot;toLocaleTimeString&quot;, datePrototypeToLocaleTimeStringCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 518 #endif
 519 
 520     JSFunction* toPrimitiveFunction = JSFunction::create(vm, globalObject, 1, &quot;[Symbol.toPrimitive]&quot;_s, dateProtoFuncToPrimitiveSymbol, NoIntrinsic);
 521     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toPrimitiveSymbol, toPrimitiveFunction, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 522 
 523     // The constructor will be added later, after DateConstructor has been built.
 524 }
 525 
 526 // Functions
 527 
<a name="35" id="anc35"></a><span class="line-modified"> 528 EncodedJSValue JSC_HOST_CALL dateProtoFuncToString(ExecState* exec)</span>
 529 {
 530     const bool asUTCVariant = false;
<a name="36" id="anc36"></a><span class="line-modified"> 531     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);</span>
 532 }
 533 
<a name="37" id="anc37"></a><span class="line-modified"> 534 EncodedJSValue JSC_HOST_CALL dateProtoFuncToUTCString(ExecState* exec)</span>
 535 {
 536     const bool asUTCVariant = true;
<a name="38" id="anc38"></a><span class="line-modified"> 537     return formateDateInstance(exec, DateTimeFormatDateAndTime, asUTCVariant);</span>
 538 }
 539 
<a name="39" id="anc39"></a><span class="line-modified"> 540 EncodedJSValue JSC_HOST_CALL dateProtoFuncToISOString(ExecState* exec)</span>
 541 {
<a name="40" id="anc40"></a><span class="line-modified"> 542     VM&amp; vm = exec-&gt;vm();</span>
 543     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="41" id="anc41"></a><span class="line-modified"> 544     JSValue thisValue = exec-&gt;thisValue();</span>
 545     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 546     if (UNLIKELY(!thisDateObj))
<a name="42" id="anc42"></a><span class="line-modified"> 547         return throwVMTypeError(exec, scope);</span>
 548 
 549     if (!std::isfinite(thisDateObj-&gt;internalNumber()))
<a name="43" id="anc43"></a><span class="line-modified"> 550         return throwVMError(exec, scope, createRangeError(exec, &quot;Invalid Date&quot;_s));</span>
 551 
<a name="44" id="anc44"></a><span class="line-modified"> 552     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 553     if (!gregorianDateTime)
 554         return JSValue::encode(jsNontrivialString(vm, String(&quot;Invalid Date&quot;_s)));
 555     // Maximum amount of space we need in buffer: 7 (max. digits in year) + 2 * 5 (2 characters each for month, day, hour, minute, second) + 4 (. + 3 digits for milliseconds)
 556     // 6 for formatting and one for null termination = 28. We add one extra character to allow us to force null termination.
 557     char buffer[28];
 558     // If the year is outside the bounds of 0 and 9999 inclusive we want to use the extended year format (ES 15.9.1.15.1).
 559     int ms = static_cast&lt;int&gt;(fmod(thisDateObj-&gt;internalNumber(), msPerSecond));
 560     if (ms &lt; 0)
 561         ms += msPerSecond;
 562 
 563     int charactersWritten;
 564     if (gregorianDateTime-&gt;year() &gt; 9999 || gregorianDateTime-&gt;year() &lt; 0)
 565         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%+07d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 566     else
 567         charactersWritten = snprintf(buffer, sizeof(buffer), &quot;%04d-%02d-%02dT%02d:%02d:%02d.%03dZ&quot;, gregorianDateTime-&gt;year(), gregorianDateTime-&gt;month() + 1, gregorianDateTime-&gt;monthDay(), gregorianDateTime-&gt;hour(), gregorianDateTime-&gt;minute(), gregorianDateTime-&gt;second(), ms);
 568 
 569     ASSERT(charactersWritten &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(charactersWritten) &lt; sizeof(buffer));
 570     if (static_cast&lt;unsigned&gt;(charactersWritten) &gt;= sizeof(buffer))
 571         return JSValue::encode(jsEmptyString(vm));
 572 
 573     return JSValue::encode(jsNontrivialString(vm, String(buffer, charactersWritten)));
 574 }
 575 
<a name="45" id="anc45"></a><span class="line-modified"> 576 EncodedJSValue JSC_HOST_CALL dateProtoFuncToDateString(ExecState* exec)</span>
 577 {
 578     const bool asUTCVariant = false;
<a name="46" id="anc46"></a><span class="line-modified"> 579     return formateDateInstance(exec, DateTimeFormatDate, asUTCVariant);</span>
 580 }
 581 
<a name="47" id="anc47"></a><span class="line-modified"> 582 EncodedJSValue JSC_HOST_CALL dateProtoFuncToTimeString(ExecState* exec)</span>
 583 {
 584     const bool asUTCVariant = false;
<a name="48" id="anc48"></a><span class="line-modified"> 585     return formateDateInstance(exec, DateTimeFormatTime, asUTCVariant);</span>
 586 }
 587 
<a name="49" id="anc49"></a><span class="line-modified"> 588 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleString(ExecState* exec)</span>
 589 {
<a name="50" id="anc50"></a><span class="line-modified"> 590     VM&amp; vm = exec-&gt;vm();</span>
 591     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="51" id="anc51"></a><span class="line-modified"> 592     JSValue thisValue = exec-&gt;thisValue();</span>
 593     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 594     if (UNLIKELY(!thisDateObj))
<a name="52" id="anc52"></a><span class="line-modified"> 595         return throwVMTypeError(exec, scope);</span>
 596 
<a name="53" id="anc53"></a><span class="line-modified"> 597     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDateAndTime));</span>
 598 }
 599 
<a name="54" id="anc54"></a><span class="line-modified"> 600 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleDateString(ExecState* exec)</span>
 601 {
<a name="55" id="anc55"></a><span class="line-modified"> 602     VM&amp; vm = exec-&gt;vm();</span>
 603     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="56" id="anc56"></a><span class="line-modified"> 604     JSValue thisValue = exec-&gt;thisValue();</span>
 605     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 606     if (UNLIKELY(!thisDateObj))
<a name="57" id="anc57"></a><span class="line-modified"> 607         return throwVMTypeError(exec, scope);</span>
 608 
<a name="58" id="anc58"></a><span class="line-modified"> 609     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleDate));</span>
 610 }
 611 
<a name="59" id="anc59"></a><span class="line-modified"> 612 EncodedJSValue JSC_HOST_CALL dateProtoFuncToLocaleTimeString(ExecState* exec)</span>
 613 {
<a name="60" id="anc60"></a><span class="line-modified"> 614     VM&amp; vm = exec-&gt;vm();</span>
 615     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="61" id="anc61"></a><span class="line-modified"> 616     JSValue thisValue = exec-&gt;thisValue();</span>
 617     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 618     if (UNLIKELY(!thisDateObj))
<a name="62" id="anc62"></a><span class="line-modified"> 619         return throwVMTypeError(exec, scope);</span>
 620 
<a name="63" id="anc63"></a><span class="line-modified"> 621     return JSValue::encode(formatLocaleDate(exec, thisDateObj, thisDateObj-&gt;internalNumber(), LocaleTime));</span>
 622 }
 623 
<a name="64" id="anc64"></a><span class="line-modified"> 624 EncodedJSValue JSC_HOST_CALL dateProtoFuncToPrimitiveSymbol(ExecState* exec)</span>
 625 {
<a name="65" id="anc65"></a><span class="line-modified"> 626     VM&amp; vm = exec-&gt;vm();</span>
 627     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="66" id="anc66"></a><span class="line-modified"> 628     JSValue thisValue = exec-&gt;thisValue();</span>
 629     if (!thisValue.isObject())
<a name="67" id="anc67"></a><span class="line-modified"> 630         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected |this| to be an object.&quot;);</span>
 631     JSObject* thisObject = jsCast&lt;JSObject*&gt;(thisValue);
 632 
<a name="68" id="anc68"></a><span class="line-modified"> 633     if (!exec-&gt;argumentCount())</span>
<span class="line-modified"> 634         return throwVMTypeError(exec, scope, &quot;Date.prototype[Symbol.toPrimitive] expected a first argument.&quot;);</span>
 635 
<a name="69" id="anc69"></a><span class="line-modified"> 636     JSValue hintValue = exec-&gt;uncheckedArgument(0);</span>
<span class="line-modified"> 637     PreferredPrimitiveType type = toPreferredPrimitiveType(exec, hintValue);</span>
 638     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 639 
 640     if (type == NoPreference)
 641         type = PreferString;
 642 
<a name="70" id="anc70"></a><span class="line-modified"> 643     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;ordinaryToPrimitive(exec, type)));</span>
 644 }
 645 
<a name="71" id="anc71"></a><span class="line-modified"> 646 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTime(ExecState* exec)</span>
 647 {
<a name="72" id="anc72"></a><span class="line-modified"> 648     VM&amp; vm = exec-&gt;vm();</span>
 649     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="73" id="anc73"></a><span class="line-modified"> 650     JSValue thisValue = exec-&gt;thisValue();</span>
 651     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 652     if (UNLIKELY(!thisDateObj))
<a name="74" id="anc74"></a><span class="line-modified"> 653         return throwVMTypeError(exec, scope);</span>
 654 
 655     return JSValue::encode(jsNumber(thisDateObj-&gt;internalNumber()));
 656 }
 657 
<a name="75" id="anc75"></a><span class="line-modified"> 658 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetFullYear(ExecState* exec)</span>
 659 {
<a name="76" id="anc76"></a><span class="line-modified"> 660     VM&amp; vm = exec-&gt;vm();</span>
 661     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="77" id="anc77"></a><span class="line-modified"> 662     JSValue thisValue = exec-&gt;thisValue();</span>
 663     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 664     if (UNLIKELY(!thisDateObj))
<a name="78" id="anc78"></a><span class="line-modified"> 665         return throwVMTypeError(exec, scope);</span>
 666 
<a name="79" id="anc79"></a><span class="line-modified"> 667     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 668     if (!gregorianDateTime)
 669         return JSValue::encode(jsNaN());
 670     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 671 }
 672 
<a name="80" id="anc80"></a><span class="line-modified"> 673 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCFullYear(ExecState* exec)</span>
 674 {
<a name="81" id="anc81"></a><span class="line-modified"> 675     VM&amp; vm = exec-&gt;vm();</span>
 676     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="82" id="anc82"></a><span class="line-modified"> 677     JSValue thisValue = exec-&gt;thisValue();</span>
 678     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 679     if (UNLIKELY(!thisDateObj))
<a name="83" id="anc83"></a><span class="line-modified"> 680         return throwVMTypeError(exec, scope);</span>
 681 
<a name="84" id="anc84"></a><span class="line-modified"> 682     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 683     if (!gregorianDateTime)
 684         return JSValue::encode(jsNaN());
 685     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year()));
 686 }
 687 
<a name="85" id="anc85"></a><span class="line-modified"> 688 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMonth(ExecState* exec)</span>
 689 {
<a name="86" id="anc86"></a><span class="line-modified"> 690     VM&amp; vm = exec-&gt;vm();</span>
 691     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="87" id="anc87"></a><span class="line-modified"> 692     JSValue thisValue = exec-&gt;thisValue();</span>
 693     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 694     if (UNLIKELY(!thisDateObj))
<a name="88" id="anc88"></a><span class="line-modified"> 695         return throwVMTypeError(exec, scope);</span>
 696 
<a name="89" id="anc89"></a><span class="line-modified"> 697     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 698     if (!gregorianDateTime)
 699         return JSValue::encode(jsNaN());
 700     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 701 }
 702 
<a name="90" id="anc90"></a><span class="line-modified"> 703 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMonth(ExecState* exec)</span>
 704 {
<a name="91" id="anc91"></a><span class="line-modified"> 705     VM&amp; vm = exec-&gt;vm();</span>
 706     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="92" id="anc92"></a><span class="line-modified"> 707     JSValue thisValue = exec-&gt;thisValue();</span>
 708     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 709     if (UNLIKELY(!thisDateObj))
<a name="93" id="anc93"></a><span class="line-modified"> 710         return throwVMTypeError(exec, scope);</span>
 711 
<a name="94" id="anc94"></a><span class="line-modified"> 712     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 713     if (!gregorianDateTime)
 714         return JSValue::encode(jsNaN());
 715     return JSValue::encode(jsNumber(gregorianDateTime-&gt;month()));
 716 }
 717 
<a name="95" id="anc95"></a><span class="line-modified"> 718 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDate(ExecState* exec)</span>
 719 {
<a name="96" id="anc96"></a><span class="line-modified"> 720     VM&amp; vm = exec-&gt;vm();</span>
 721     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="97" id="anc97"></a><span class="line-modified"> 722     JSValue thisValue = exec-&gt;thisValue();</span>
 723     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 724     if (UNLIKELY(!thisDateObj))
<a name="98" id="anc98"></a><span class="line-modified"> 725         return throwVMTypeError(exec, scope);</span>
 726 
<a name="99" id="anc99"></a><span class="line-modified"> 727     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 728     if (!gregorianDateTime)
 729         return JSValue::encode(jsNaN());
 730     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 731 }
 732 
<a name="100" id="anc100"></a><span class="line-modified"> 733 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDate(ExecState* exec)</span>
 734 {
<a name="101" id="anc101"></a><span class="line-modified"> 735     VM&amp; vm = exec-&gt;vm();</span>
 736     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="102" id="anc102"></a><span class="line-modified"> 737     JSValue thisValue = exec-&gt;thisValue();</span>
 738     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 739     if (UNLIKELY(!thisDateObj))
<a name="103" id="anc103"></a><span class="line-modified"> 740         return throwVMTypeError(exec, scope);</span>
 741 
<a name="104" id="anc104"></a><span class="line-modified"> 742     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 743     if (!gregorianDateTime)
 744         return JSValue::encode(jsNaN());
 745     return JSValue::encode(jsNumber(gregorianDateTime-&gt;monthDay()));
 746 }
 747 
<a name="105" id="anc105"></a><span class="line-modified"> 748 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetDay(ExecState* exec)</span>
 749 {
<a name="106" id="anc106"></a><span class="line-modified"> 750     VM&amp; vm = exec-&gt;vm();</span>
 751     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="107" id="anc107"></a><span class="line-modified"> 752     JSValue thisValue = exec-&gt;thisValue();</span>
 753     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 754     if (UNLIKELY(!thisDateObj))
<a name="108" id="anc108"></a><span class="line-modified"> 755         return throwVMTypeError(exec, scope);</span>
 756 
<a name="109" id="anc109"></a><span class="line-modified"> 757     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 758     if (!gregorianDateTime)
 759         return JSValue::encode(jsNaN());
 760     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 761 }
 762 
<a name="110" id="anc110"></a><span class="line-modified"> 763 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCDay(ExecState* exec)</span>
 764 {
<a name="111" id="anc111"></a><span class="line-modified"> 765     VM&amp; vm = exec-&gt;vm();</span>
 766     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="112" id="anc112"></a><span class="line-modified"> 767     JSValue thisValue = exec-&gt;thisValue();</span>
 768     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 769     if (UNLIKELY(!thisDateObj))
<a name="113" id="anc113"></a><span class="line-modified"> 770         return throwVMTypeError(exec, scope);</span>
 771 
<a name="114" id="anc114"></a><span class="line-modified"> 772     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 773     if (!gregorianDateTime)
 774         return JSValue::encode(jsNaN());
 775     return JSValue::encode(jsNumber(gregorianDateTime-&gt;weekDay()));
 776 }
 777 
<a name="115" id="anc115"></a><span class="line-modified"> 778 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetHours(ExecState* exec)</span>
 779 {
<a name="116" id="anc116"></a><span class="line-modified"> 780     VM&amp; vm = exec-&gt;vm();</span>
 781     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="117" id="anc117"></a><span class="line-modified"> 782     JSValue thisValue = exec-&gt;thisValue();</span>
 783     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 784     if (UNLIKELY(!thisDateObj))
<a name="118" id="anc118"></a><span class="line-modified"> 785         return throwVMTypeError(exec, scope);</span>
 786 
<a name="119" id="anc119"></a><span class="line-modified"> 787     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 788     if (!gregorianDateTime)
 789         return JSValue::encode(jsNaN());
 790     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 791 }
 792 
<a name="120" id="anc120"></a><span class="line-modified"> 793 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCHours(ExecState* exec)</span>
 794 {
<a name="121" id="anc121"></a><span class="line-modified"> 795     VM&amp; vm = exec-&gt;vm();</span>
 796     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="122" id="anc122"></a><span class="line-modified"> 797     JSValue thisValue = exec-&gt;thisValue();</span>
 798     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 799     if (UNLIKELY(!thisDateObj))
<a name="123" id="anc123"></a><span class="line-modified"> 800         return throwVMTypeError(exec, scope);</span>
 801 
<a name="124" id="anc124"></a><span class="line-modified"> 802     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 803     if (!gregorianDateTime)
 804         return JSValue::encode(jsNaN());
 805     return JSValue::encode(jsNumber(gregorianDateTime-&gt;hour()));
 806 }
 807 
<a name="125" id="anc125"></a><span class="line-modified"> 808 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMinutes(ExecState* exec)</span>
 809 {
<a name="126" id="anc126"></a><span class="line-modified"> 810     VM&amp; vm = exec-&gt;vm();</span>
 811     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="127" id="anc127"></a><span class="line-modified"> 812     JSValue thisValue = exec-&gt;thisValue();</span>
 813     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 814     if (UNLIKELY(!thisDateObj))
<a name="128" id="anc128"></a><span class="line-modified"> 815         return throwVMTypeError(exec, scope);</span>
 816 
<a name="129" id="anc129"></a><span class="line-modified"> 817     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 818     if (!gregorianDateTime)
 819         return JSValue::encode(jsNaN());
 820     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 821 }
 822 
<a name="130" id="anc130"></a><span class="line-modified"> 823 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMinutes(ExecState* exec)</span>
 824 {
<a name="131" id="anc131"></a><span class="line-modified"> 825     VM&amp; vm = exec-&gt;vm();</span>
 826     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="132" id="anc132"></a><span class="line-modified"> 827     JSValue thisValue = exec-&gt;thisValue();</span>
 828     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 829     if (UNLIKELY(!thisDateObj))
<a name="133" id="anc133"></a><span class="line-modified"> 830         return throwVMTypeError(exec, scope);</span>
 831 
<a name="134" id="anc134"></a><span class="line-modified"> 832     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 833     if (!gregorianDateTime)
 834         return JSValue::encode(jsNaN());
 835     return JSValue::encode(jsNumber(gregorianDateTime-&gt;minute()));
 836 }
 837 
<a name="135" id="anc135"></a><span class="line-modified"> 838 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetSeconds(ExecState* exec)</span>
 839 {
<a name="136" id="anc136"></a><span class="line-modified"> 840     VM&amp; vm = exec-&gt;vm();</span>
 841     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="137" id="anc137"></a><span class="line-modified"> 842     JSValue thisValue = exec-&gt;thisValue();</span>
 843     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 844     if (UNLIKELY(!thisDateObj))
<a name="138" id="anc138"></a><span class="line-modified"> 845         return throwVMTypeError(exec, scope);</span>
 846 
<a name="139" id="anc139"></a><span class="line-modified"> 847     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 848     if (!gregorianDateTime)
 849         return JSValue::encode(jsNaN());
 850     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 851 }
 852 
<a name="140" id="anc140"></a><span class="line-modified"> 853 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCSeconds(ExecState* exec)</span>
 854 {
<a name="141" id="anc141"></a><span class="line-modified"> 855     VM&amp; vm = exec-&gt;vm();</span>
 856     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="142" id="anc142"></a><span class="line-modified"> 857     JSValue thisValue = exec-&gt;thisValue();</span>
 858     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 859     if (UNLIKELY(!thisDateObj))
<a name="143" id="anc143"></a><span class="line-modified"> 860         return throwVMTypeError(exec, scope);</span>
 861 
<a name="144" id="anc144"></a><span class="line-modified"> 862     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTimeUTC(exec);</span>
 863     if (!gregorianDateTime)
 864         return JSValue::encode(jsNaN());
 865     return JSValue::encode(jsNumber(gregorianDateTime-&gt;second()));
 866 }
 867 
<a name="145" id="anc145"></a><span class="line-modified"> 868 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetMilliSeconds(ExecState* exec)</span>
 869 {
<a name="146" id="anc146"></a><span class="line-modified"> 870     VM&amp; vm = exec-&gt;vm();</span>
 871     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="147" id="anc147"></a><span class="line-modified"> 872     JSValue thisValue = exec-&gt;thisValue();</span>
 873     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 874     if (UNLIKELY(!thisDateObj))
<a name="148" id="anc148"></a><span class="line-modified"> 875         return throwVMTypeError(exec, scope);</span>
 876 
 877     double milli = thisDateObj-&gt;internalNumber();
 878     if (std::isnan(milli))
 879         return JSValue::encode(jsNaN());
 880 
 881     double secs = floor(milli / msPerSecond);
 882     double ms = milli - secs * msPerSecond;
<a name="149" id="anc149"></a><span class="line-modified"> 883     return JSValue::encode(jsNumber(ms));</span>

 884 }
 885 
<a name="150" id="anc150"></a><span class="line-modified"> 886 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetUTCMilliseconds(ExecState* exec)</span>
 887 {
<a name="151" id="anc151"></a><span class="line-modified"> 888     VM&amp; vm = exec-&gt;vm();</span>
 889     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="152" id="anc152"></a><span class="line-modified"> 890     JSValue thisValue = exec-&gt;thisValue();</span>
 891     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 892     if (UNLIKELY(!thisDateObj))
<a name="153" id="anc153"></a><span class="line-modified"> 893         return throwVMTypeError(exec, scope);</span>
 894 
 895     double milli = thisDateObj-&gt;internalNumber();
 896     if (std::isnan(milli))
 897         return JSValue::encode(jsNaN());
 898 
 899     double secs = floor(milli / msPerSecond);
 900     double ms = milli - secs * msPerSecond;
<a name="154" id="anc154"></a><span class="line-modified"> 901     return JSValue::encode(jsNumber(ms));</span>

 902 }
 903 
<a name="155" id="anc155"></a><span class="line-modified"> 904 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetTimezoneOffset(ExecState* exec)</span>
 905 {
<a name="156" id="anc156"></a><span class="line-modified"> 906     VM&amp; vm = exec-&gt;vm();</span>
 907     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="157" id="anc157"></a><span class="line-modified"> 908     JSValue thisValue = exec-&gt;thisValue();</span>
 909     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 910     if (UNLIKELY(!thisDateObj))
<a name="158" id="anc158"></a><span class="line-modified"> 911         return throwVMTypeError(exec, scope);</span>
 912 
<a name="159" id="anc159"></a><span class="line-modified"> 913     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
 914     if (!gregorianDateTime)
 915         return JSValue::encode(jsNaN());
<a name="160" id="anc160"></a><span class="line-modified"> 916     return JSValue::encode(jsNumber(-gregorianDateTime-&gt;utcOffset() / minutesPerHour));</span>
 917 }
 918 
<a name="161" id="anc161"></a><span class="line-modified"> 919 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetTime(ExecState* exec)</span>
 920 {
<a name="162" id="anc162"></a><span class="line-modified"> 921     VM&amp; vm = exec-&gt;vm();</span>
 922     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="163" id="anc163"></a><span class="line-modified"> 923     JSValue thisValue = exec-&gt;thisValue();</span>
 924     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 925     if (UNLIKELY(!thisDateObj))
<a name="164" id="anc164"></a><span class="line-modified"> 926         return throwVMTypeError(exec, scope);</span>
 927 
<a name="165" id="anc165"></a><span class="line-modified"> 928     double milli = timeClip(exec-&gt;argument(0).toNumber(exec));</span>
 929     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 930     thisDateObj-&gt;setInternalNumber(milli);
 931     return JSValue::encode(jsNumber(milli));
 932 }
 933 
<a name="166" id="anc166"></a><span class="line-modified"> 934 static EncodedJSValue setNewValueFromTimeArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)</span>
 935 {
<a name="167" id="anc167"></a><span class="line-modified"> 936     VM&amp; vm = exec-&gt;vm();</span>
 937     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="168" id="anc168"></a><span class="line-modified"> 938     JSValue thisValue = exec-&gt;thisValue();</span>
 939     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 940     if (UNLIKELY(!thisDateObj))
<a name="169" id="anc169"></a><span class="line-modified"> 941         return throwVMTypeError(exec, scope);</span>
 942 
 943     double milli = thisDateObj-&gt;internalNumber();
 944 
<a name="170" id="anc170"></a><span class="line-modified"> 945     if (!exec-&gt;argumentCount() || std::isnan(milli)) {</span>
 946         thisDateObj-&gt;setInternalNumber(PNaN);
 947         return JSValue::encode(jsNaN());
 948     }
 949 
 950     double secs = floor(milli / msPerSecond);
 951     double ms = milli - secs * msPerSecond;
 952 
 953     const GregorianDateTime* other = inputTimeType == WTF::UTCTime
<a name="171" id="anc171"></a><span class="line-modified"> 954         ? thisDateObj-&gt;gregorianDateTimeUTC(exec)</span>
<span class="line-modified"> 955         : thisDateObj-&gt;gregorianDateTime(exec);</span>
 956     if (!other)
 957         return JSValue::encode(jsNaN());
 958 
<a name="172" id="anc172"></a><span class="line-modified"> 959     GregorianDateTime gregorianDateTime;</span>
<span class="line-modified"> 960     gregorianDateTime.copyFrom(*other);</span>
<span class="line-removed"> 961     bool success = fillStructuresUsingTimeArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);</span>
 962     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 963     if (!success) {
 964         thisDateObj-&gt;setInternalNumber(PNaN);
 965         return JSValue::encode(jsNaN());
 966     }
 967 
 968     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
 969     double result = timeClip(newUTCDate);
 970     thisDateObj-&gt;setInternalNumber(result);
 971     return JSValue::encode(jsNumber(result));
 972 }
 973 
<a name="173" id="anc173"></a><span class="line-modified"> 974 static EncodedJSValue setNewValueFromDateArgs(ExecState* exec, int numArgsToUse, WTF::TimeType inputTimeType)</span>
 975 {
<a name="174" id="anc174"></a><span class="line-modified"> 976     VM&amp; vm = exec-&gt;vm();</span>
 977     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="175" id="anc175"></a><span class="line-modified"> 978     JSValue thisValue = exec-&gt;thisValue();</span>
 979     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
 980     if (UNLIKELY(!thisDateObj))
<a name="176" id="anc176"></a><span class="line-modified"> 981         return throwVMTypeError(exec, scope);</span>
 982 
<a name="177" id="anc177"></a><span class="line-modified"> 983     if (!exec-&gt;argumentCount()) {</span>
 984         thisDateObj-&gt;setInternalNumber(PNaN);
 985         return JSValue::encode(jsNaN());
 986     }
 987 
 988     double milli = thisDateObj-&gt;internalNumber();
 989     double ms = 0;
 990 
 991     GregorianDateTime gregorianDateTime;
 992     if (numArgsToUse == 3 &amp;&amp; std::isnan(milli))
 993         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
 994     else {
 995         ms = milli - floor(milli / msPerSecond) * msPerSecond;
 996         const GregorianDateTime* other = inputTimeType == WTF::UTCTime
<a name="178" id="anc178"></a><span class="line-modified"> 997             ? thisDateObj-&gt;gregorianDateTimeUTC(exec)</span>
<span class="line-modified"> 998             : thisDateObj-&gt;gregorianDateTime(exec);</span>
 999         if (!other)
1000             return JSValue::encode(jsNaN());
<a name="179" id="anc179"></a><span class="line-modified">1001         gregorianDateTime.copyFrom(*other);</span>
1002     }
1003 
<a name="180" id="anc180"></a><span class="line-modified">1004     bool success = fillStructuresUsingDateArgs(exec, numArgsToUse, &amp;ms, &amp;gregorianDateTime);</span>
1005     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1006     if (!success) {
1007         thisDateObj-&gt;setInternalNumber(PNaN);
1008         return JSValue::encode(jsNaN());
1009     }
1010 
1011     double newUTCDate = gregorianDateTimeToMS(vm, gregorianDateTime, ms, inputTimeType);
1012     double result = timeClip(newUTCDate);
1013     thisDateObj-&gt;setInternalNumber(result);
1014     return JSValue::encode(jsNumber(result));
1015 }
1016 
<a name="181" id="anc181"></a><span class="line-modified">1017 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMilliSeconds(ExecState* exec)</span>
1018 {
<a name="182" id="anc182"></a><span class="line-modified">1019     return setNewValueFromTimeArgs(exec, 1, WTF::LocalTime);</span>
1020 }
1021 
<a name="183" id="anc183"></a><span class="line-modified">1022 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMilliseconds(ExecState* exec)</span>
1023 {
<a name="184" id="anc184"></a><span class="line-modified">1024     return setNewValueFromTimeArgs(exec, 1, WTF::UTCTime);</span>
1025 }
1026 
<a name="185" id="anc185"></a><span class="line-modified">1027 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetSeconds(ExecState* exec)</span>
1028 {
<a name="186" id="anc186"></a><span class="line-modified">1029     return setNewValueFromTimeArgs(exec, 2, WTF::LocalTime);</span>
1030 }
1031 
<a name="187" id="anc187"></a><span class="line-modified">1032 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCSeconds(ExecState* exec)</span>
1033 {
<a name="188" id="anc188"></a><span class="line-modified">1034     return setNewValueFromTimeArgs(exec, 2, WTF::UTCTime);</span>
1035 }
1036 
<a name="189" id="anc189"></a><span class="line-modified">1037 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMinutes(ExecState* exec)</span>
1038 {
<a name="190" id="anc190"></a><span class="line-modified">1039     return setNewValueFromTimeArgs(exec, 3, WTF::LocalTime);</span>
1040 }
1041 
<a name="191" id="anc191"></a><span class="line-modified">1042 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMinutes(ExecState* exec)</span>
1043 {
<a name="192" id="anc192"></a><span class="line-modified">1044     return setNewValueFromTimeArgs(exec, 3, WTF::UTCTime);</span>
1045 }
1046 
<a name="193" id="anc193"></a><span class="line-modified">1047 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetHours(ExecState* exec)</span>
1048 {
<a name="194" id="anc194"></a><span class="line-modified">1049     return setNewValueFromTimeArgs(exec, 4, WTF::LocalTime);</span>
1050 }
1051 
<a name="195" id="anc195"></a><span class="line-modified">1052 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCHours(ExecState* exec)</span>
1053 {
<a name="196" id="anc196"></a><span class="line-modified">1054     return setNewValueFromTimeArgs(exec, 4, WTF::UTCTime);</span>
1055 }
1056 
<a name="197" id="anc197"></a><span class="line-modified">1057 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetDate(ExecState* exec)</span>
1058 {
<a name="198" id="anc198"></a><span class="line-modified">1059     return setNewValueFromDateArgs(exec, 1, WTF::LocalTime);</span>
1060 }
1061 
<a name="199" id="anc199"></a><span class="line-modified">1062 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCDate(ExecState* exec)</span>
1063 {
<a name="200" id="anc200"></a><span class="line-modified">1064     return setNewValueFromDateArgs(exec, 1, WTF::UTCTime);</span>
1065 }
1066 
<a name="201" id="anc201"></a><span class="line-modified">1067 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetMonth(ExecState* exec)</span>
1068 {
<a name="202" id="anc202"></a><span class="line-modified">1069     return setNewValueFromDateArgs(exec, 2, WTF::LocalTime);</span>
1070 }
1071 
<a name="203" id="anc203"></a><span class="line-modified">1072 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCMonth(ExecState* exec)</span>
1073 {
<a name="204" id="anc204"></a><span class="line-modified">1074     return setNewValueFromDateArgs(exec, 2, WTF::UTCTime);</span>
1075 }
1076 
<a name="205" id="anc205"></a><span class="line-modified">1077 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetFullYear(ExecState* exec)</span>
1078 {
<a name="206" id="anc206"></a><span class="line-modified">1079     return setNewValueFromDateArgs(exec, 3, WTF::LocalTime);</span>
1080 }
1081 
<a name="207" id="anc207"></a><span class="line-modified">1082 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetUTCFullYear(ExecState* exec)</span>
1083 {
<a name="208" id="anc208"></a><span class="line-modified">1084     return setNewValueFromDateArgs(exec, 3, WTF::UTCTime);</span>
1085 }
1086 
<a name="209" id="anc209"></a><span class="line-modified">1087 EncodedJSValue JSC_HOST_CALL dateProtoFuncSetYear(ExecState* exec)</span>
1088 {
<a name="210" id="anc210"></a><span class="line-modified">1089     VM&amp; vm = exec-&gt;vm();</span>
1090     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="211" id="anc211"></a><span class="line-modified">1091     JSValue thisValue = exec-&gt;thisValue();</span>
1092     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1093     if (UNLIKELY(!thisDateObj))
<a name="212" id="anc212"></a><span class="line-modified">1094         return throwVMTypeError(exec, scope);</span>
1095 
<a name="213" id="anc213"></a><span class="line-modified">1096     if (!exec-&gt;argumentCount()) {</span>
1097         thisDateObj-&gt;setInternalNumber(PNaN);
1098         return JSValue::encode(jsNaN());
1099     }
1100 
1101     double milli = thisDateObj-&gt;internalNumber();
1102     double ms = 0;
1103 
1104     GregorianDateTime gregorianDateTime;
1105     if (std::isnan(milli))
1106         // Based on ECMA 262 B.2.5 (setYear)
1107         // the time must be reset to +0 if it is NaN.
1108         msToGregorianDateTime(vm, 0, WTF::UTCTime, gregorianDateTime);
1109     else {
1110         double secs = floor(milli / msPerSecond);
1111         ms = milli - secs * msPerSecond;
<a name="214" id="anc214"></a><span class="line-modified">1112         if (const GregorianDateTime* other = thisDateObj-&gt;gregorianDateTime(exec))</span>
<span class="line-modified">1113             gregorianDateTime.copyFrom(*other);</span>
1114     }
1115 
<a name="215" id="anc215"></a><span class="line-modified">1116     double year = exec-&gt;argument(0).toIntegerPreserveNaN(exec);</span>
1117     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1118     if (!std::isfinite(year)) {
1119         thisDateObj-&gt;setInternalNumber(PNaN);
1120         return JSValue::encode(jsNaN());
1121     }
1122 
1123     gregorianDateTime.setYear(toInt32((year &gt;= 0 &amp;&amp; year &lt;= 99) ? (year + 1900) : year));
1124     double timeInMilliseconds = gregorianDateTimeToMS(vm, gregorianDateTime, ms, WTF::LocalTime);
1125     double result = timeClip(timeInMilliseconds);
1126     thisDateObj-&gt;setInternalNumber(result);
1127     return JSValue::encode(jsNumber(result));
1128 }
1129 
<a name="216" id="anc216"></a><span class="line-modified">1130 EncodedJSValue JSC_HOST_CALL dateProtoFuncGetYear(ExecState* exec)</span>
1131 {
<a name="217" id="anc217"></a><span class="line-modified">1132     VM&amp; vm = exec-&gt;vm();</span>
1133     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="218" id="anc218"></a><span class="line-modified">1134     JSValue thisValue = exec-&gt;thisValue();</span>
1135     auto* thisDateObj = jsDynamicCast&lt;DateInstance*&gt;(vm, thisValue);
1136     if (UNLIKELY(!thisDateObj))
<a name="219" id="anc219"></a><span class="line-modified">1137         return throwVMTypeError(exec, scope);</span>
1138 
<a name="220" id="anc220"></a><span class="line-modified">1139     const GregorianDateTime* gregorianDateTime = thisDateObj-&gt;gregorianDateTime(exec);</span>
1140     if (!gregorianDateTime)
1141         return JSValue::encode(jsNaN());
1142 
1143     // NOTE: IE returns the full year even in getYear.
1144     return JSValue::encode(jsNumber(gregorianDateTime-&gt;year() - 1900));
1145 }
1146 
<a name="221" id="anc221"></a><span class="line-modified">1147 EncodedJSValue JSC_HOST_CALL dateProtoFuncToJSON(ExecState* exec)</span>
1148 {
<a name="222" id="anc222"></a><span class="line-modified">1149     VM&amp; vm = exec-&gt;vm();</span>
1150     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="223" id="anc223"></a><span class="line-modified">1151     JSValue thisValue = exec-&gt;thisValue();</span>
<span class="line-modified">1152     JSObject* object = jsCast&lt;JSObject*&gt;(thisValue.toThis(exec, NotStrictMode));</span>
1153     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1154 
<a name="224" id="anc224"></a><span class="line-modified">1155     JSValue timeValue = object-&gt;toPrimitive(exec, PreferNumber);</span>
1156     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<a name="225" id="anc225"></a><span class="line-modified">1157     if (timeValue.isNumber() &amp;&amp; !(timeValue.isInt32() || std::isfinite(timeValue.asDouble())))</span>
1158         return JSValue::encode(jsNull());
1159 
<a name="226" id="anc226"></a><span class="line-modified">1160     JSValue toISOValue = object-&gt;get(exec, vm.propertyNames-&gt;toISOString);</span>
1161     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1162 
1163     CallData callData;
1164     CallType callType = getCallData(vm, toISOValue, callData);
1165     if (callType == CallType::None)
<a name="227" id="anc227"></a><span class="line-modified">1166         return throwVMTypeError(exec, scope, &quot;toISOString is not a function&quot;_s);</span>
1167 
<a name="228" id="anc228"></a><span class="line-modified">1168     JSValue result = call(exec, asObject(toISOValue), callType, callData, object, *vm.emptyList);</span>
1169     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1170     return JSValue::encode(result);
1171 }
1172 
1173 } // namespace JSC
<a name="229" id="anc229"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="229" type="hidden" />
</body>
</html>
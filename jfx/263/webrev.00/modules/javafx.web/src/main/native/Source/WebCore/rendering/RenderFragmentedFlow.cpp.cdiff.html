<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFragmentContainer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,11 ***</span>
  
  #include &quot;HitTestRequest.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;InlineElementBox.h&quot;
  #include &quot;Node.h&quot;
<span class="line-removed">- #include &quot;PODIntervalTree.h&quot;</span>
  #include &quot;RenderBoxFragmentInfo.h&quot;
  #include &quot;RenderFragmentContainer.h&quot;
  #include &quot;RenderInline.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
<span class="line-new-header">--- 32,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,35 ***</span>
  
      for (auto&amp; fragment : m_fragmentList)
          fragment-&gt;repaintFragmentedFlowContent(repaintRect);
  }
  
  RenderFragmentContainer* RenderFragmentedFlow::fragmentAtBlockOffset(const RenderBox* clampBox, LayoutUnit offset, bool extendLastFragment) const
  {
      ASSERT(!m_fragmentsInvalidated);
  
      if (m_fragmentList.isEmpty())
          return nullptr;
  
      if (m_fragmentList.size() == 1 &amp;&amp; extendLastFragment)
          return m_fragmentList.first();
  
      if (offset &lt;= 0)
<span class="line-modified">!         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(m_fragmentList.first()) : m_fragmentList.first();</span>
  
      FragmentSearchAdapter adapter(offset);
<span class="line-modified">!     m_fragmentIntervalTree.allOverlapsWithAdapter&lt;FragmentSearchAdapter&gt;(adapter);</span>
  
      // If no fragment was found, the offset is in the flow thread overflow.
      // The last fragment will contain the offset if extendLastFragment is set or if the last fragment is a set.
<span class="line-modified">!     if (!adapter.result() &amp;&amp; (extendLastFragment || m_fragmentList.last()-&gt;isRenderFragmentContainerSet()))</span>
<span class="line-modified">!         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(m_fragmentList.last()) : m_fragmentList.last();</span>
  
<span class="line-modified">!     RenderFragmentContainer* fragment = adapter.result();</span>
<span class="line-removed">-     if (!clampBox)</span>
<span class="line-removed">-         return fragment;</span>
<span class="line-removed">-     return fragment ? clampBox-&gt;clampToStartAndEndFragments(fragment) : nullptr;</span>
  }
  
  LayoutPoint RenderFragmentedFlow::adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp; boxModelObject, const LayoutPoint&amp; startPoint) const
  {
      LayoutPoint referencePoint = startPoint;
<span class="line-new-header">--- 216,63 ---</span>
  
      for (auto&amp; fragment : m_fragmentList)
          fragment-&gt;repaintFragmentedFlowContent(repaintRect);
  }
  
<span class="line-added">+ class RenderFragmentedFlow::FragmentSearchAdapter {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     explicit FragmentSearchAdapter(LayoutUnit offset)</span>
<span class="line-added">+         : m_offset(offset)</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     const LayoutUnit&amp; lowValue() const { return m_offset; }</span>
<span class="line-added">+     const LayoutUnit&amp; highValue() const { return m_offset; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void collectIfNeeded(const PODInterval&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt;&amp; interval)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_result)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         if (interval.low() &lt;= m_offset &amp;&amp; interval.high() &gt; m_offset)</span>
<span class="line-added">+             m_result = interval.data();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderFragmentContainer* result() const { return m_result.get(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     LayoutUnit m_offset;</span>
<span class="line-added">+     WeakPtr&lt;RenderFragmentContainer&gt; m_result;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  RenderFragmentContainer* RenderFragmentedFlow::fragmentAtBlockOffset(const RenderBox* clampBox, LayoutUnit offset, bool extendLastFragment) const
  {
      ASSERT(!m_fragmentsInvalidated);
  
      if (m_fragmentList.isEmpty())
          return nullptr;
  
      if (m_fragmentList.size() == 1 &amp;&amp; extendLastFragment)
          return m_fragmentList.first();
  
<span class="line-added">+     auto clamp = [clampBox](RenderFragmentContainer* fragment)  {</span>
<span class="line-added">+         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(fragment) : fragment;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      if (offset &lt;= 0)
<span class="line-modified">!         return clamp(m_fragmentList.first());</span>
  
      FragmentSearchAdapter adapter(offset);
<span class="line-modified">!     m_fragmentIntervalTree.allOverlapsWithAdapter(adapter);</span>
<span class="line-added">+     if (auto* fragment = adapter.result())</span>
<span class="line-added">+         return clamp(fragment);</span>
  
      // If no fragment was found, the offset is in the flow thread overflow.
      // The last fragment will contain the offset if extendLastFragment is set or if the last fragment is a set.
<span class="line-modified">!     if (extendLastFragment || m_fragmentList.last()-&gt;isRenderFragmentContainerSet())</span>
<span class="line-modified">!         return clamp(m_fragmentList.last());</span>
  
<span class="line-modified">!     return nullptr;</span>
  }
  
  LayoutPoint RenderFragmentedFlow::adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp; boxModelObject, const LayoutPoint&amp; startPoint) const
  {
      LayoutPoint referencePoint = startPoint;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 779,21 ***</span>
  }
  
  void RenderFragmentedFlow::updateFragmentsFragmentedFlowPortionRect()
  {
      LayoutUnit logicalHeight;
<span class="line-modified">!     // FIXME: Optimize not to clear the interval all the time. This implies manually managing the tree nodes lifecycle.</span>
      m_fragmentIntervalTree.clear();
      for (auto&amp; fragment : m_fragmentList) {
          LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
          LayoutUnit fragmentLogicalHeight = std::min&lt;LayoutUnit&gt;(RenderFragmentedFlow::maxLogicalHeight() - logicalHeight, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
  
          LayoutRect fragmentRect(style().direction() == TextDirection::LTR ? 0_lu : logicalWidth() - fragmentLogicalWidth, logicalHeight, fragmentLogicalWidth, fragmentLogicalHeight);
  
          fragment-&gt;setFragmentedFlowPortionRect(isHorizontalWritingMode() ? fragmentRect : fragmentRect.transposedRect());
  
<span class="line-modified">!         m_fragmentIntervalTree.add(FragmentIntervalTree::createInterval(logicalHeight, logicalHeight + fragmentLogicalHeight, makeWeakPtr(fragment)));</span>
  
          logicalHeight += fragmentLogicalHeight;
      }
  }
  
<span class="line-new-header">--- 806,21 ---</span>
  }
  
  void RenderFragmentedFlow::updateFragmentsFragmentedFlowPortionRect()
  {
      LayoutUnit logicalHeight;
<span class="line-modified">!     // FIXME: Optimize not to clear the interval tree all the time. This would involve manually managing the tree nodes&#39; lifecycle.</span>
      m_fragmentIntervalTree.clear();
      for (auto&amp; fragment : m_fragmentList) {
          LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
          LayoutUnit fragmentLogicalHeight = std::min&lt;LayoutUnit&gt;(RenderFragmentedFlow::maxLogicalHeight() - logicalHeight, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
  
          LayoutRect fragmentRect(style().direction() == TextDirection::LTR ? 0_lu : logicalWidth() - fragmentLogicalWidth, logicalHeight, fragmentLogicalWidth, fragmentLogicalHeight);
  
          fragment-&gt;setFragmentedFlowPortionRect(isHorizontalWritingMode() ? fragmentRect : fragmentRect.transposedRect());
  
<span class="line-modified">!         m_fragmentIntervalTree.add({ logicalHeight, logicalHeight + fragmentLogicalHeight, makeWeakPtr(fragment) });</span>
  
          logicalHeight += fragmentLogicalHeight;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,18 ***</span>
      }
  
      return currentBlock-&gt;isHorizontalWritingMode() ? blockRect.y() : blockRect.x();
  }
  
<span class="line-removed">- void RenderFragmentedFlow::FragmentSearchAdapter::collectIfNeeded(const FragmentInterval&amp; interval)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_result)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     if (interval.low() &lt;= m_offset &amp;&amp; interval.high() &gt; m_offset)</span>
<span class="line-removed">-         m_result = interval.data();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void RenderFragmentedFlow::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
  {
      if (this == repaintContainer)
          return;
  
<span class="line-new-header">--- 907,10 ---</span>
</pre>
<center><a href="RenderFragmentContainer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
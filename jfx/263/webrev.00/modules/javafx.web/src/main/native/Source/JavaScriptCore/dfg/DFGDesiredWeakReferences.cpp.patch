diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWeakReferences.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWeakReferences.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWeakReferences.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDesiredWeakReferences.cpp
@@ -65,21 +65,24 @@
     return m_references.contains(cell);
 }
 
 void DesiredWeakReferences::reallyAdd(VM& vm, CommonData* common)
 {
+    ASSERT(vm.heap.isDeferred());
     for (JSCell* target : m_references) {
         if (Structure* structure = jsDynamicCast<Structure*>(vm, target)) {
-            common->weakStructureReferences.append(
-                WriteBarrier<Structure>(vm, m_codeBlock, structure));
+            ConcurrentJSLocker locker(m_codeBlock->m_lock);
+            // We do not emit WriteBarrier here since (1) GC is deferred and (2) we emit write-barrier on CodeBlock when finishing DFG::Plan::reallyAdd.
+            common->weakStructureReferences.append(structure->id());
         } else {
             // There are weird relationships in how optimized CodeBlocks
             // point to other CodeBlocks. We don't want to have them be
             // part of the weak pointer set. For example, an optimized CodeBlock
             // having a weak pointer to itself will cause it to get collected.
             RELEASE_ASSERT(!jsDynamicCast<CodeBlock*>(vm, target));
 
+            ConcurrentJSLocker locker(m_codeBlock->m_lock);
             common->weakReferences.append(
                 WriteBarrier<JSCell>(vm, m_codeBlock, target));
         }
     }
 }

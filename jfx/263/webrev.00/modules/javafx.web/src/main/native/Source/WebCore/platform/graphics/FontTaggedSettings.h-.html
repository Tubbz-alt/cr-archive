<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontTaggedSettings.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2016 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;array&gt;
 30 #include &lt;wtf/HashTraits.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace WTF {
 34 class TextStream;
 35 }
 36 
 37 namespace WebCore {
 38 
 39 typedef std::array&lt;char, 4&gt; FontTag;
 40 
 41 inline FontTag fontFeatureTag(const char arr[4]) { return {{ arr[0], arr[1], arr[2], arr[3] }}; }
 42 
 43 struct FourCharacterTagHash {
 44     static unsigned hash(const FontTag&amp; characters) { return (characters[0] &lt;&lt; 24) | (characters[1] &lt;&lt; 16) | (characters[2] &lt;&lt; 8) | characters[3]; }
 45     static bool equal(const FontTag&amp; a, const FontTag&amp; b) { return a == b; }
 46     static const bool safeToCompareToEmptyOrDeleted = true;
 47 };
 48 
 49 struct FourCharacterTagHashTraits : WTF::GenericHashTraits&lt;FontTag&gt; {
 50     static const bool emptyValueIsZero = true;
 51     static void constructDeletedValue(FontTag&amp; slot) { new (NotNull, std::addressof(slot)) FontTag({{ ff, ff, ff, ff }}); }
 52     static bool isDeletedValue(const FontTag&amp; value) { return value == FontTag({{ ff, ff, ff, ff }}); }
 53 
 54 private:
 55     const static char ff = static_cast&lt;char&gt;(0xFF);
 56 };
 57 
 58 template &lt;typename T&gt;
 59 class FontTaggedSetting {
 60 public:
 61     FontTaggedSetting() = delete;
 62     FontTaggedSetting(const FontTag&amp;, T value);
 63     FontTaggedSetting(FontTag&amp;&amp;, T value);
 64 
 65     bool operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 66     bool operator!=(const FontTaggedSetting&lt;T&gt;&amp; other) const { return !(*this == other); }
 67     bool operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 68 
 69     const FontTag&amp; tag() const { return m_tag; }
 70     T value() const { return m_value; }
 71     bool enabled() const { return value(); }
 72 
 73 private:
 74     FontTag m_tag;
 75     T m_value;
 76 };
 77 
 78 template &lt;typename T&gt;
 79 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(const FontTag&amp; tag, T value)
 80     : m_tag(tag)
 81     , m_value(value)
 82 {
 83 }
 84 
 85 template &lt;typename T&gt;
 86 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(FontTag&amp;&amp; tag, T value)
 87     : m_tag(WTFMove(tag))
 88     , m_value(value)
 89 {
 90 }
 91 
 92 template &lt;typename T&gt;
 93 bool FontTaggedSetting&lt;T&gt;::operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const
 94 {
 95     return m_tag == other.m_tag &amp;&amp; m_value == other.m_value;
 96 }
 97 
 98 template &lt;typename T&gt;
 99 bool FontTaggedSetting&lt;T&gt;::operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const
100 {
101     return (m_tag &lt; other.m_tag) || (m_tag == other.m_tag &amp;&amp; m_value &lt; other.m_value);
102 }
103 
104 template &lt;typename T&gt;
105 class FontTaggedSettings {
106 public:
107     void insert(FontTaggedSetting&lt;T&gt;&amp;&amp;);
108     bool operator==(const FontTaggedSettings&lt;T&gt;&amp; other) const { return m_list == other.m_list; }
109     bool operator!=(const FontTaggedSettings&lt;T&gt;&amp; other) const { return !(*this == other); }
110 
111     bool isEmpty() const { return !size(); }
112     size_t size() const { return m_list.size(); }
113     const FontTaggedSetting&lt;T&gt;&amp; operator[](int index) const { return m_list[index]; }
114     const FontTaggedSetting&lt;T&gt;&amp; at(size_t index) const { return m_list.at(index); }
115 
116     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator begin() const { return m_list.begin(); }
117     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator end() const { return m_list.end(); }
118 
119     unsigned hash() const;
120 
121 private:
122     Vector&lt;FontTaggedSetting&lt;T&gt;&gt; m_list;
123 };
124 
125 template &lt;typename T&gt;
126 void FontTaggedSettings&lt;T&gt;::insert(FontTaggedSetting&lt;T&gt;&amp;&amp; feature)
127 {
128     // This vector will almost always have 0 or 1 items in it. Don&#39;t bother with the overhead of a binary search or a hash set.
129     size_t i;
130     for (i = 0; i &lt; m_list.size(); ++i) {
131         if (!(feature &lt; m_list[i]))
132             break;
133     }
134     if (i &lt; m_list.size() &amp;&amp; feature.tag() == m_list[i].tag())
135         m_list.remove(i);
136     m_list.insert(i, WTFMove(feature));
137 }
138 
139 typedef FontTaggedSetting&lt;int&gt; FontFeature;
140 typedef FontTaggedSettings&lt;int&gt; FontFeatureSettings;
141 
142 template &lt;&gt; unsigned FontFeatureSettings::hash() const;
143 
144 #if ENABLE(VARIATION_FONTS)
145 
146 typedef FontTaggedSettings&lt;float&gt; FontVariationSettings;
147 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FontVariationSettings&amp;);
148 
149 template &lt;&gt; unsigned FontVariationSettings::hash() const;
150 
151 #else
152 
153 struct FontVariationSettings {
154     bool isEmpty() const { return true; }
155 };
156 
157 #endif
158 
159 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerModelObject.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
176 
177     // Returns true if the composited layers were actually updated.
178     bool didRecalcStyleWithNoPendingLayout();
179 
180     // GraphicsLayers buffer state, which gets pushed to the underlying platform layers
181     // at specific times.
182     void scheduleLayerFlush(bool canThrottle = false);
183     void flushPendingLayerChanges(bool isFlushRoot = true);
184 
185     // Called when the GraphicsLayer for the given RenderLayer has flushed changes inside of flushPendingLayerChanges().
186     void didChangePlatformLayerForLayer(RenderLayer&amp;, const GraphicsLayer*);
187 
188     // Called when something outside WebKit affects the visible rect (e.g. delegated scrolling). Might schedule a layer flush.
189     void didChangeVisibleRect();
190 
191     // Rebuild the tree of compositing layers
192     bool updateCompositingLayers(CompositingUpdateType, RenderLayer* updateRoot = nullptr);
193     // This is only used when state changes and we do not exepect a style update or layout to happen soon (e.g. when
194     // we discover that an iframe is overlapped during painting).
195     void scheduleCompositingLayerUpdate();
<span class="line-modified">196     // This is used to cancel any pending update timers when the document goes into page cache.</span>
197     void cancelCompositingLayerUpdate();
198 
199     // Update the compositing state of the given layer. Returns true if that state changed.
200     enum CompositingChangeRepaint { CompositingChangeRepaintNow, CompositingChangeWillRepaintLater };
201     enum class LayoutUpToDate {
202         Yes, No
203     };
204 
205     struct RequiresCompositingData {
206         LayoutUpToDate layoutUpToDate { LayoutUpToDate::Yes };
207         RenderLayer::ViewportConstrainedNotCompositedReason nonCompositedForPositionReason { RenderLayer::NoNotCompositedReason };
208         bool reevaluateAfterLayout { false };
209     };
210 
<span class="line-modified">211     bool updateLayerCompositingState(RenderLayer&amp;, RequiresCompositingData&amp;, CompositingChangeRepaint = CompositingChangeRepaintNow);</span>
212 
213     // Whether layer&#39;s backing needs a graphics layer to do clipping by an ancestor (non-stacking-context parent with overflow).
214     bool clippedByAncestor(RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
215 
216     bool updateAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
217 
218     // Returns the ScrollingNodeID for the containing async-scrollable layer that scrolls this renderer&#39;s border box.
219     // May return 0 for position-fixed content.
220     static ScrollingNodeID asyncScrollableContainerNodeID(const RenderObject&amp;);
221 
222     // Whether layer&#39;s backing needs a graphics layer to clip z-order children of the given layer.
223     static bool clipsCompositingDescendants(const RenderLayer&amp;);
224 
225     // Whether the given layer needs an extra &#39;contents&#39; layer.
226     bool needsContentsCompositingLayer(const RenderLayer&amp;) const;
227 
228     bool fixedLayerIntersectsViewport(const RenderLayer&amp;) const;
229 
230     bool supportsFixedRootBackgroundCompositing() const;
231     bool needsFixedRootBackgroundLayer(const RenderLayer&amp;) const;
</pre>
<hr />
<pre>
330     void deviceOrPageScaleFactorChanged();
331 
332     void windowScreenDidChange(PlatformDisplayID);
333 
334     GraphicsLayer* layerForHorizontalScrollbar() const { return m_layerForHorizontalScrollbar.get(); }
335     GraphicsLayer* layerForVerticalScrollbar() const { return m_layerForVerticalScrollbar.get(); }
336     GraphicsLayer* layerForScrollCorner() const { return m_layerForScrollCorner.get(); }
337 #if ENABLE(RUBBER_BANDING)
338     GraphicsLayer* layerForOverhangAreas() const { return m_layerForOverhangAreas.get(); }
339     GraphicsLayer* layerForContentShadow() const { return m_contentShadowLayer.get(); }
340 
341     GraphicsLayer* updateLayerForTopOverhangArea(bool wantsLayer);
342     GraphicsLayer* updateLayerForBottomOverhangArea(bool wantsLayer);
343     GraphicsLayer* updateLayerForHeader(bool wantsLayer);
344     GraphicsLayer* updateLayerForFooter(bool wantsLayer);
345 #endif
346 
347     // FIXME: make the coordinated/async terminology consistent.
348     bool isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp;) const;
349     bool useCoordinatedScrollingForLayer(const RenderLayer&amp;) const;
<span class="line-modified">350     ScrollPositioningBehavior computeCoordinatedPositioningForLayer(const RenderLayer&amp;) const;</span>
351     bool isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp;) const;
352 
353     ScrollableArea* scrollableAreaForScrollLayerID(ScrollingNodeID) const;
354 
355     void removeFromScrollCoordinatedLayers(RenderLayer&amp;);
356 
357     void willRemoveScrollingLayerWithBacking(RenderLayer&amp;, RenderLayerBacking&amp;);
358     void didAddScrollingLayer(RenderLayer&amp;);
359 
360     void resetTrackedRepaintRects();
361     void setTracksRepaints(bool tracksRepaints) { m_isTrackingRepaints = tracksRepaints; }
362 
363     bool viewHasTransparentBackground(Color* backgroundColor = nullptr) const;
364 
365     bool hasNonMainLayersWithTiledBacking() const { return m_layersWithTiledBackingCount; }
366 
367     OptionSet&lt;CompositingReason&gt; reasonsForCompositing(const RenderLayer&amp;) const;
368 
369     void setLayerFlushThrottlingEnabled(bool);
370     void disableLayerFlushThrottlingTemporarilyForInteraction();
</pre>
<hr />
<pre>
373 
374     const Color&amp; rootExtendedBackgroundColor() const { return m_rootExtendedBackgroundColor; }
375 
376     void updateRootContentLayerClipping();
377 
378 #if ENABLE(CSS_SCROLL_SNAP)
379     void updateScrollSnapPropertiesWithFrameView(const FrameView&amp;) const;
380 #endif
381 
382     // For testing.
383     void startTrackingLayerFlushes() { m_layerFlushCount = 0; }
384     unsigned layerFlushCount() const { return m_layerFlushCount; }
385 
386     void startTrackingCompositingUpdates() { m_compositingUpdateCount = 0; }
387     unsigned compositingUpdateCount() const { return m_compositingUpdateCount; }
388 
389 private:
390     class BackingSharingState;
391     struct CompositingState;
392     struct OverlapExtent;

393 
394     // Returns true if the policy changed.
395     bool updateCompositingPolicy();
396 
397     // GraphicsLayerClient implementation
398     void notifyFlushRequired(const GraphicsLayer*) override;
<span class="line-modified">399     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp;, GraphicsLayerPaintBehavior) override;</span>
400     void customPositionForVisibleRectComputation(const GraphicsLayer*, FloatPoint&amp;) const override;
401     bool isTrackingRepaints() const override { return m_isTrackingRepaints; }
402 
403     // GraphicsLayerUpdaterClient implementation
404     void flushLayersSoon(GraphicsLayerUpdater&amp;) override;
405 
406     // Copy the accelerated compositing related flags from Settings
407     void cacheAcceleratedCompositingFlags();
408     void cacheAcceleratedCompositingFlagsAfterLayout();
409 
410     // Whether the given RL needs a compositing layer.
411     bool needsToBeComposited(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
412     // Whether the layer has an intrinsic need for compositing layer.
413     bool requiresCompositingLayer(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
414     // Whether the layer could ever be composited.
415     bool canBeComposited(const RenderLayer&amp;) const;
416     bool needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp;, const RenderStyle* oldStyle) const;
417 
418     // Make or destroy the backing for this layer; returns true if backing changed.
419     enum class BackingRequired { No, Yes, Unknown };
</pre>
<hr />
<pre>
423 
424     // Repaint this and its child layers.
425     void recursiveRepaintLayer(RenderLayer&amp;);
426 
427     void computeExtent(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
428     void addToOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
429     void addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp;, const RenderLayer&amp;, const RenderLayer* ancestorLayer = nullptr) const;
430     void updateOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap = false) const;
431     bool layerOverlaps(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
432 
433     void updateCompositingLayersTimerFired();
434 
435     void computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);
436     void traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);
437 
438     enum class UpdateLevel {
439         AllDescendants          = 1 &lt;&lt; 0,
440         CompositedChildren      = 1 &lt;&lt; 1,
441     };
442     // Recurses down the tree, parenting descendant compositing layers and collecting an array of child layers for the current compositing layer.
<span class="line-modified">443     void updateBackingAndHierarchy(RenderLayer&amp;, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childGraphicsLayersOfEnclosingLayer, struct ScrollingTreeState&amp;, OptionSet&lt;UpdateLevel&gt; = { }, int depth = 0);</span>
444 
445     bool layerHas3DContent(const RenderLayer&amp;) const;
446     bool isRunningTransformAnimation(RenderLayerModelObject&amp;) const;
447 
448     void appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;);
449 
450     bool needsCompositingForContentOrOverlays() const;
451 
452     void ensureRootLayer();
453     void destroyRootLayer();
454 
455     void attachRootLayer(RootLayerAttachment);
456     void detachRootLayer();
457 
458     void rootLayerAttachmentChanged();
459 
460     void updateOverflowControlsLayers();
461 
462     void updateScrollLayerPosition();
463     void updateScrollLayerClipping();
</pre>
<hr />
<pre>
481 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
482     RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const override;
483 #endif
484 
485     // Non layout-dependent
486     bool requiresCompositingForAnimation(RenderLayerModelObject&amp;) const;
487     bool requiresCompositingForTransform(RenderLayerModelObject&amp;) const;
488     bool requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp;) const;
489     bool requiresCompositingForVideo(RenderLayerModelObject&amp;) const;
490     bool requiresCompositingForCanvas(RenderLayerModelObject&amp;) const;
491     bool requiresCompositingForFilters(RenderLayerModelObject&amp;) const;
492     bool requiresCompositingForWillChange(RenderLayerModelObject&amp;) const;
493 
494     // Layout-dependent
495     bool requiresCompositingForPlugin(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
496     bool requiresCompositingForFrame(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
497     bool requiresCompositingForScrollableFrame(RequiresCompositingData&amp;) const;
498     bool requiresCompositingForPosition(RenderLayerModelObject&amp;, const RenderLayer&amp;, RequiresCompositingData&amp;) const;
499     bool requiresCompositingForOverflowScrolling(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
500     bool requiresCompositingForEditableImage(RenderLayerModelObject&amp;) const;
<span class="line-modified">501     bool requiresCompositingForIndirectReason(const RenderLayer&amp;, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp;) const;</span>
502 
503     static ScrollPositioningBehavior layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp;, const RenderLayer&amp; compositedAncestor);
504 
505     static bool styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle);
506 
507     enum class ScrollingNodeChangeFlags {
508         Layer           = 1 &lt;&lt; 0,
509         LayerGeometry   = 1 &lt;&lt; 1,
510     };
511 
512     ScrollingNodeID attachScrollingNode(RenderLayer&amp;, ScrollingNodeType, struct ScrollingTreeState&amp;);
513     ScrollingNodeID registerScrollingNodeID(ScrollingCoordinator&amp;, ScrollingNodeID, ScrollingNodeType, struct ScrollingTreeState&amp;);
514 
<span class="line-modified">515     OptionSet&lt;ScrollCoordinationRole&gt; coordinatedScrollingRolesForLayer(const RenderLayer&amp;) const;</span>
516 
517     // Returns the ScrollingNodeID which acts as the parent for children.
<span class="line-modified">518     ScrollingNodeID updateScrollCoordinationForLayer(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
519 
520     // These return the ScrollingNodeID which acts as the parent for children.
521     ScrollingNodeID updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
522     ScrollingNodeID updateScrollingNodeForScrollingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
523     ScrollingNodeID updateScrollingNodeForScrollingProxyRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
524     ScrollingNodeID updateScrollingNodeForFrameHostingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
<span class="line-modified">525     ScrollingNodeID updateScrollingNodeForPositioningRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
526 
527     void updateScrollingNodeLayers(ScrollingNodeID, RenderLayer&amp;, ScrollingCoordinator&amp;);
528 
529     void detachScrollCoordinatedLayer(RenderLayer&amp;, OptionSet&lt;ScrollCoordinationRole&gt;);
530     void detachScrollCoordinatedLayerWithRole(RenderLayer&amp;, ScrollingCoordinator&amp;, ScrollCoordinationRole);
531 
532     FixedPositionViewportConstraints computeFixedViewportConstraints(RenderLayer&amp;) const;
533     StickyPositionViewportConstraints computeStickyViewportConstraints(RenderLayer&amp;) const;
534 
535     LayoutRect rootParentRelativeScrollableRect() const;
536     LayoutRect parentRelativeScrollableRect(const RenderLayer&amp;, const RenderLayer* ancestorLayer) const;
537 
538     // Returns list of layers and their clip rects required to clip the given layer, which include clips in the
539     // containing block chain between the given layer and its composited ancestor.
540     Vector&lt;CompositedClipData&gt; computeAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
541 
542     bool requiresScrollLayer(RootLayerAttachment) const;
543     bool requiresHorizontalScrollbarLayer() const;
544     bool requiresVerticalScrollbarLayer() const;
545     bool requiresScrollCornerLayer() const;
</pre>
</td>
<td>
<hr />
<pre>
176 
177     // Returns true if the composited layers were actually updated.
178     bool didRecalcStyleWithNoPendingLayout();
179 
180     // GraphicsLayers buffer state, which gets pushed to the underlying platform layers
181     // at specific times.
182     void scheduleLayerFlush(bool canThrottle = false);
183     void flushPendingLayerChanges(bool isFlushRoot = true);
184 
185     // Called when the GraphicsLayer for the given RenderLayer has flushed changes inside of flushPendingLayerChanges().
186     void didChangePlatformLayerForLayer(RenderLayer&amp;, const GraphicsLayer*);
187 
188     // Called when something outside WebKit affects the visible rect (e.g. delegated scrolling). Might schedule a layer flush.
189     void didChangeVisibleRect();
190 
191     // Rebuild the tree of compositing layers
192     bool updateCompositingLayers(CompositingUpdateType, RenderLayer* updateRoot = nullptr);
193     // This is only used when state changes and we do not exepect a style update or layout to happen soon (e.g. when
194     // we discover that an iframe is overlapped during painting).
195     void scheduleCompositingLayerUpdate();
<span class="line-modified">196     // This is used to cancel any pending update timers when the document goes into back/forward cache.</span>
197     void cancelCompositingLayerUpdate();
198 
199     // Update the compositing state of the given layer. Returns true if that state changed.
200     enum CompositingChangeRepaint { CompositingChangeRepaintNow, CompositingChangeWillRepaintLater };
201     enum class LayoutUpToDate {
202         Yes, No
203     };
204 
205     struct RequiresCompositingData {
206         LayoutUpToDate layoutUpToDate { LayoutUpToDate::Yes };
207         RenderLayer::ViewportConstrainedNotCompositedReason nonCompositedForPositionReason { RenderLayer::NoNotCompositedReason };
208         bool reevaluateAfterLayout { false };
209     };
210 
<span class="line-modified">211     bool updateLayerCompositingState(RenderLayer&amp;, const RenderLayer* compositingAncestor, RequiresCompositingData&amp;, CompositingChangeRepaint = CompositingChangeRepaintNow);</span>
212 
213     // Whether layer&#39;s backing needs a graphics layer to do clipping by an ancestor (non-stacking-context parent with overflow).
214     bool clippedByAncestor(RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
215 
216     bool updateAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
217 
218     // Returns the ScrollingNodeID for the containing async-scrollable layer that scrolls this renderer&#39;s border box.
219     // May return 0 for position-fixed content.
220     static ScrollingNodeID asyncScrollableContainerNodeID(const RenderObject&amp;);
221 
222     // Whether layer&#39;s backing needs a graphics layer to clip z-order children of the given layer.
223     static bool clipsCompositingDescendants(const RenderLayer&amp;);
224 
225     // Whether the given layer needs an extra &#39;contents&#39; layer.
226     bool needsContentsCompositingLayer(const RenderLayer&amp;) const;
227 
228     bool fixedLayerIntersectsViewport(const RenderLayer&amp;) const;
229 
230     bool supportsFixedRootBackgroundCompositing() const;
231     bool needsFixedRootBackgroundLayer(const RenderLayer&amp;) const;
</pre>
<hr />
<pre>
330     void deviceOrPageScaleFactorChanged();
331 
332     void windowScreenDidChange(PlatformDisplayID);
333 
334     GraphicsLayer* layerForHorizontalScrollbar() const { return m_layerForHorizontalScrollbar.get(); }
335     GraphicsLayer* layerForVerticalScrollbar() const { return m_layerForVerticalScrollbar.get(); }
336     GraphicsLayer* layerForScrollCorner() const { return m_layerForScrollCorner.get(); }
337 #if ENABLE(RUBBER_BANDING)
338     GraphicsLayer* layerForOverhangAreas() const { return m_layerForOverhangAreas.get(); }
339     GraphicsLayer* layerForContentShadow() const { return m_contentShadowLayer.get(); }
340 
341     GraphicsLayer* updateLayerForTopOverhangArea(bool wantsLayer);
342     GraphicsLayer* updateLayerForBottomOverhangArea(bool wantsLayer);
343     GraphicsLayer* updateLayerForHeader(bool wantsLayer);
344     GraphicsLayer* updateLayerForFooter(bool wantsLayer);
345 #endif
346 
347     // FIXME: make the coordinated/async terminology consistent.
348     bool isViewportConstrainedFixedOrStickyLayer(const RenderLayer&amp;) const;
349     bool useCoordinatedScrollingForLayer(const RenderLayer&amp;) const;
<span class="line-modified">350     ScrollPositioningBehavior computeCoordinatedPositioningForLayer(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;</span>
351     bool isLayerForIFrameWithScrollCoordinatedContents(const RenderLayer&amp;) const;
352 
353     ScrollableArea* scrollableAreaForScrollLayerID(ScrollingNodeID) const;
354 
355     void removeFromScrollCoordinatedLayers(RenderLayer&amp;);
356 
357     void willRemoveScrollingLayerWithBacking(RenderLayer&amp;, RenderLayerBacking&amp;);
358     void didAddScrollingLayer(RenderLayer&amp;);
359 
360     void resetTrackedRepaintRects();
361     void setTracksRepaints(bool tracksRepaints) { m_isTrackingRepaints = tracksRepaints; }
362 
363     bool viewHasTransparentBackground(Color* backgroundColor = nullptr) const;
364 
365     bool hasNonMainLayersWithTiledBacking() const { return m_layersWithTiledBackingCount; }
366 
367     OptionSet&lt;CompositingReason&gt; reasonsForCompositing(const RenderLayer&amp;) const;
368 
369     void setLayerFlushThrottlingEnabled(bool);
370     void disableLayerFlushThrottlingTemporarilyForInteraction();
</pre>
<hr />
<pre>
373 
374     const Color&amp; rootExtendedBackgroundColor() const { return m_rootExtendedBackgroundColor; }
375 
376     void updateRootContentLayerClipping();
377 
378 #if ENABLE(CSS_SCROLL_SNAP)
379     void updateScrollSnapPropertiesWithFrameView(const FrameView&amp;) const;
380 #endif
381 
382     // For testing.
383     void startTrackingLayerFlushes() { m_layerFlushCount = 0; }
384     unsigned layerFlushCount() const { return m_layerFlushCount; }
385 
386     void startTrackingCompositingUpdates() { m_compositingUpdateCount = 0; }
387     unsigned compositingUpdateCount() const { return m_compositingUpdateCount; }
388 
389 private:
390     class BackingSharingState;
391     struct CompositingState;
392     struct OverlapExtent;
<span class="line-added">393     struct UpdateBackingTraversalState;</span>
394 
395     // Returns true if the policy changed.
396     bool updateCompositingPolicy();
397 
398     // GraphicsLayerClient implementation
399     void notifyFlushRequired(const GraphicsLayer*) override;
<span class="line-modified">400     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, const FloatRect&amp;, GraphicsLayerPaintBehavior) override;</span>
401     void customPositionForVisibleRectComputation(const GraphicsLayer*, FloatPoint&amp;) const override;
402     bool isTrackingRepaints() const override { return m_isTrackingRepaints; }
403 
404     // GraphicsLayerUpdaterClient implementation
405     void flushLayersSoon(GraphicsLayerUpdater&amp;) override;
406 
407     // Copy the accelerated compositing related flags from Settings
408     void cacheAcceleratedCompositingFlags();
409     void cacheAcceleratedCompositingFlagsAfterLayout();
410 
411     // Whether the given RL needs a compositing layer.
412     bool needsToBeComposited(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
413     // Whether the layer has an intrinsic need for compositing layer.
414     bool requiresCompositingLayer(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
415     // Whether the layer could ever be composited.
416     bool canBeComposited(const RenderLayer&amp;) const;
417     bool needsCompositingUpdateForStyleChangeOnNonCompositedLayer(RenderLayer&amp;, const RenderStyle* oldStyle) const;
418 
419     // Make or destroy the backing for this layer; returns true if backing changed.
420     enum class BackingRequired { No, Yes, Unknown };
</pre>
<hr />
<pre>
424 
425     // Repaint this and its child layers.
426     void recursiveRepaintLayer(RenderLayer&amp;);
427 
428     void computeExtent(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
429     void addToOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
430     void addDescendantsToOverlapMapRecursive(LayerOverlapMap&amp;, const RenderLayer&amp;, const RenderLayer* ancestorLayer = nullptr) const;
431     void updateOverlapMap(LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;, bool didPushContainer, bool addLayerToOverlap, bool addDescendantsToOverlap = false) const;
432     bool layerOverlaps(const LayerOverlapMap&amp;, const RenderLayer&amp;, OverlapExtent&amp;) const;
433 
434     void updateCompositingLayersTimerFired();
435 
436     void computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);
437     void traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp;, LayerOverlapMap&amp;, CompositingState&amp;, BackingSharingState&amp;, bool&amp; descendantHas3DTransform);
438 
439     enum class UpdateLevel {
440         AllDescendants          = 1 &lt;&lt; 0,
441         CompositedChildren      = 1 &lt;&lt; 1,
442     };
443     // Recurses down the tree, parenting descendant compositing layers and collecting an array of child layers for the current compositing layer.
<span class="line-modified">444     void updateBackingAndHierarchy(RenderLayer&amp;, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childGraphicsLayersOfEnclosingLayer, struct UpdateBackingTraversalState&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;UpdateLevel&gt; = { });</span>
445 
446     bool layerHas3DContent(const RenderLayer&amp;) const;
447     bool isRunningTransformAnimation(RenderLayerModelObject&amp;) const;
448 
449     void appendDocumentOverlayLayers(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;);
450 
451     bool needsCompositingForContentOrOverlays() const;
452 
453     void ensureRootLayer();
454     void destroyRootLayer();
455 
456     void attachRootLayer(RootLayerAttachment);
457     void detachRootLayer();
458 
459     void rootLayerAttachmentChanged();
460 
461     void updateOverflowControlsLayers();
462 
463     void updateScrollLayerPosition();
464     void updateScrollLayerClipping();
</pre>
<hr />
<pre>
482 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)
483     RefPtr&lt;DisplayRefreshMonitor&gt; createDisplayRefreshMonitor(PlatformDisplayID) const override;
484 #endif
485 
486     // Non layout-dependent
487     bool requiresCompositingForAnimation(RenderLayerModelObject&amp;) const;
488     bool requiresCompositingForTransform(RenderLayerModelObject&amp;) const;
489     bool requiresCompositingForBackfaceVisibility(RenderLayerModelObject&amp;) const;
490     bool requiresCompositingForVideo(RenderLayerModelObject&amp;) const;
491     bool requiresCompositingForCanvas(RenderLayerModelObject&amp;) const;
492     bool requiresCompositingForFilters(RenderLayerModelObject&amp;) const;
493     bool requiresCompositingForWillChange(RenderLayerModelObject&amp;) const;
494 
495     // Layout-dependent
496     bool requiresCompositingForPlugin(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
497     bool requiresCompositingForFrame(RenderLayerModelObject&amp;, RequiresCompositingData&amp;) const;
498     bool requiresCompositingForScrollableFrame(RequiresCompositingData&amp;) const;
499     bool requiresCompositingForPosition(RenderLayerModelObject&amp;, const RenderLayer&amp;, RequiresCompositingData&amp;) const;
500     bool requiresCompositingForOverflowScrolling(const RenderLayer&amp;, RequiresCompositingData&amp;) const;
501     bool requiresCompositingForEditableImage(RenderLayerModelObject&amp;) const;
<span class="line-modified">502     IndirectCompositingReason computeIndirectCompositingReason(const RenderLayer&amp;, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking) const;</span>
503 
504     static ScrollPositioningBehavior layerScrollBehahaviorRelativeToCompositedAncestor(const RenderLayer&amp;, const RenderLayer&amp; compositedAncestor);
505 
506     static bool styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle);
507 
508     enum class ScrollingNodeChangeFlags {
509         Layer           = 1 &lt;&lt; 0,
510         LayerGeometry   = 1 &lt;&lt; 1,
511     };
512 
513     ScrollingNodeID attachScrollingNode(RenderLayer&amp;, ScrollingNodeType, struct ScrollingTreeState&amp;);
514     ScrollingNodeID registerScrollingNodeID(ScrollingCoordinator&amp;, ScrollingNodeID, ScrollingNodeType, struct ScrollingTreeState&amp;);
515 
<span class="line-modified">516     OptionSet&lt;ScrollCoordinationRole&gt; coordinatedScrollingRolesForLayer(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;</span>
517 
518     // Returns the ScrollingNodeID which acts as the parent for children.
<span class="line-modified">519     ScrollingNodeID updateScrollCoordinationForLayer(RenderLayer&amp;, const RenderLayer* compositingAncestor, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
520 
521     // These return the ScrollingNodeID which acts as the parent for children.
522     ScrollingNodeID updateScrollingNodeForViewportConstrainedRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
523     ScrollingNodeID updateScrollingNodeForScrollingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
524     ScrollingNodeID updateScrollingNodeForScrollingProxyRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
525     ScrollingNodeID updateScrollingNodeForFrameHostingRole(RenderLayer&amp;, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);
<span class="line-modified">526     ScrollingNodeID updateScrollingNodeForPositioningRole(RenderLayer&amp;, const RenderLayer* compositingAncestor, struct ScrollingTreeState&amp;, OptionSet&lt;ScrollingNodeChangeFlags&gt;);</span>
527 
528     void updateScrollingNodeLayers(ScrollingNodeID, RenderLayer&amp;, ScrollingCoordinator&amp;);
529 
530     void detachScrollCoordinatedLayer(RenderLayer&amp;, OptionSet&lt;ScrollCoordinationRole&gt;);
531     void detachScrollCoordinatedLayerWithRole(RenderLayer&amp;, ScrollingCoordinator&amp;, ScrollCoordinationRole);
532 
533     FixedPositionViewportConstraints computeFixedViewportConstraints(RenderLayer&amp;) const;
534     StickyPositionViewportConstraints computeStickyViewportConstraints(RenderLayer&amp;) const;
535 
536     LayoutRect rootParentRelativeScrollableRect() const;
537     LayoutRect parentRelativeScrollableRect(const RenderLayer&amp;, const RenderLayer* ancestorLayer) const;
538 
539     // Returns list of layers and their clip rects required to clip the given layer, which include clips in the
540     // containing block chain between the given layer and its composited ancestor.
541     Vector&lt;CompositedClipData&gt; computeAncestorClippingStack(const RenderLayer&amp;, const RenderLayer* compositingAncestor) const;
542 
543     bool requiresScrollLayer(RootLayerAttachment) const;
544     bool requiresHorizontalScrollbarLayer() const;
545     bool requiresVerticalScrollbarLayer() const;
546     bool requiresScrollCornerLayer() const;
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerCompositor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerModelObject.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
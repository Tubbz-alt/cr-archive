<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeSpecializationKind.h&quot;
 30 #include &quot;DirectArguments.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;FunctionCodeBlock.h&quot;
 33 #include &quot;JSImmutableButterfly.h&quot;
 34 #include &quot;ScopedArguments.h&quot;
 35 #include &quot;SlowPathReturnType.h&quot;
 36 #include &quot;StackAlignment.h&quot;
 37 #include &quot;VMInlines.h&quot;
 38 #include &lt;wtf/StdLibExtras.h&gt;
 39 
 40 namespace JSC {
 41 
 42 // The purpose of this namespace is to include slow paths that are shared
 43 // between the interpreter and baseline JIT. They are written to be agnostic
 44 // with respect to the slow-path calling convention, but they do rely on the
 45 // JS code being executed more-or-less directly from bytecode (so the call
 46 // frame layout is unmodified, making it potentially awkward to use these
 47 // from any optimizing JIT, like the DFG).
 48 
 49 namespace CommonSlowPaths {
 50 
 51 ALWAYS_INLINE int numberOfExtraSlots(int argumentCountIncludingThis)
 52 {
 53     int frameSize = argumentCountIncludingThis + CallFrame::headerSizeInRegisters;
 54     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
 55     return alignedFrameSize - frameSize;
 56 }
 57 
 58 ALWAYS_INLINE int numberOfStackPaddingSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 59 {
 60     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 61         return 0;
 62     int alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
 63     int alignedFrameSizeForParameters = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), codeBlock-&gt;numParameters() + CallFrame::headerSizeInRegisters);
 64     return alignedFrameSizeForParameters - alignedFrameSize;
 65 }
 66 
 67 ALWAYS_INLINE int numberOfStackPaddingSlotsWithExtraSlots(CodeBlock* codeBlock, int argumentCountIncludingThis)
 68 {
 69     if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
 70         return 0;
 71     return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
 72 }
 73 
 74 ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(CallFrame* callFrame, CodeSpecializationKind kind)
 75 {
 76     JSFunction* callee = jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee());
 77     ASSERT(!callee-&gt;isHostFunction());
 78     return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
 79 }
 80 
 81 ALWAYS_INLINE int arityCheckFor(VM&amp; vm, CallFrame* callFrame, CodeSpecializationKind kind)
 82 {
 83     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(callFrame, kind);
 84     ASSERT(callFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));
 85     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, callFrame-&gt;argumentCountIncludingThis());
 86 
 87     Register* newStack = callFrame-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);
 88 
 89     if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
 90         return -1;
 91     return padding;
 92 }
 93 
 94 inline bool opInByVal(JSGlobalObject* globalObject, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)
 95 {
 96     VM&amp; vm = getVM(globalObject);
 97     auto scope = DECLARE_THROW_SCOPE(vm);
 98     if (!baseVal.isObject()) {
 99         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseVal));
100         return false;
101     }
102 
103     JSObject* baseObj = asObject(baseVal);
104     if (arrayProfile)
105         arrayProfile-&gt;observeStructure(baseObj-&gt;structure(vm));
106 
107     uint32_t i;
108     if (propName.getUInt32(i)) {
109         if (arrayProfile)
110             arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
111         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, i));
112     }
113 
114     auto property = propName.toPropertyKey(globalObject);
115     RETURN_IF_EXCEPTION(scope, false);
116     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, property));
117 }
118 
119 inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
120 {
121     switch (object.type()) {
122     case DirectArgumentsType: {
123         DirectArguments* directArguments = jsCast&lt;DirectArguments*&gt;(&amp;object);
124         if (directArguments-&gt;isMappedArgumentInDFG(index))
125             return true;
126         break;
127     }
128     case ScopedArgumentsType: {
129         ScopedArguments* scopedArguments = jsCast&lt;ScopedArguments*&gt;(&amp;object);
130         if (scopedArguments-&gt;isMappedArgumentInDFG(index))
131             return true;
132         break;
133     }
134     default:
135         break;
136     }
137     return false;
138 }
139 
140 static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)
141 {
142     auto scope = DECLARE_THROW_SCOPE(vm);
143     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
144         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);
145         RETURN_IF_EXCEPTION(scope, void());
146     }
147     if (result)
148         *result = baseObject-&gt;structure(vm);
149     scope.release();
150     baseObject-&gt;putDirect(vm, propertyName, value, slot);
151 }
152 
153 static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)
154 {
155     auto scope = DECLARE_THROW_SCOPE(vm);
156     if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
157         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);
158         RETURN_IF_EXCEPTION(scope, void());
159     }
160     scope.release();
161     baseObject-&gt;putDirectAccessor(globalObject, propertyName, accessor, attribute);
162 }
163 
164 inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
165 {
166     JSGlobalObject* globalObject = structure-&gt;globalObject();
167     Structure* originalStructure = globalObject-&gt;originalArrayStructureForIndexingType(immutableButterfly-&gt;indexingMode());
168     ASSERT(originalStructure-&gt;indexingMode() == immutableButterfly-&gt;indexingMode());
169     ASSERT(isCopyOnWrite(immutableButterfly-&gt;indexingMode()));
170     ASSERT(!structure-&gt;outOfLineCapacity());
171 
172     JSArray* result = JSArray::createWithButterfly(vm, nullptr, originalStructure, immutableButterfly-&gt;toButterfly());
173     // FIXME: This works but it&#39;s slow. If we cared enough about the perf when having a bad time then we could fix it.
174     if (UNLIKELY(originalStructure != structure)) {
175         ASSERT(hasSlowPutArrayStorage(structure-&gt;indexingMode()));
176         ASSERT(globalObject-&gt;isHavingABadTime());
177 
178         result-&gt;switchToSlowPutArrayStorage(vm);
179         ASSERT(result-&gt;butterfly() != immutableButterfly-&gt;toButterfly());
180         ASSERT(!result-&gt;butterfly()-&gt;arrayStorage()-&gt;m_sparseMap.get());
181         ASSERT(result-&gt;structureID() == structure-&gt;id());
182     }
183 
184     return result;
185 }
186 
187 } // namespace CommonSlowPaths
188 
189 class CallFrame;
190 struct Instruction;
191 
192 #define SLOW_PATH
193 
194 #define SLOW_PATH_DECL(name) \
195 extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(CallFrame* callFrame, const Instruction* pc)
196 
197 #define SLOW_PATH_HIDDEN_DECL(name) \
198 SLOW_PATH_DECL(name) WTF_INTERNAL
199 
200 SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
201 SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
202 SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
203 SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
204 SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);
205 SLOW_PATH_HIDDEN_DECL(slow_path_create_arguments_butterfly);
206 SLOW_PATH_HIDDEN_DECL(slow_path_create_this);
207 SLOW_PATH_HIDDEN_DECL(slow_path_enter);
208 SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
209 SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
210 SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
211 SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
212 SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
213 SLOW_PATH_HIDDEN_DECL(slow_path_not);
214 SLOW_PATH_HIDDEN_DECL(slow_path_eq);
215 SLOW_PATH_HIDDEN_DECL(slow_path_neq);
216 SLOW_PATH_HIDDEN_DECL(slow_path_stricteq);
217 SLOW_PATH_HIDDEN_DECL(slow_path_nstricteq);
218 SLOW_PATH_HIDDEN_DECL(slow_path_less);
219 SLOW_PATH_HIDDEN_DECL(slow_path_lesseq);
220 SLOW_PATH_HIDDEN_DECL(slow_path_greater);
221 SLOW_PATH_HIDDEN_DECL(slow_path_greatereq);
222 SLOW_PATH_HIDDEN_DECL(slow_path_inc);
223 SLOW_PATH_HIDDEN_DECL(slow_path_dec);
224 SLOW_PATH_HIDDEN_DECL(slow_path_to_number);
225 SLOW_PATH_HIDDEN_DECL(slow_path_to_numeric);
226 SLOW_PATH_HIDDEN_DECL(slow_path_to_string);
227 SLOW_PATH_HIDDEN_DECL(slow_path_to_object);
228 SLOW_PATH_HIDDEN_DECL(slow_path_negate);
229 SLOW_PATH_HIDDEN_DECL(slow_path_add);
230 SLOW_PATH_HIDDEN_DECL(slow_path_mul);
231 SLOW_PATH_HIDDEN_DECL(slow_path_sub);
232 SLOW_PATH_HIDDEN_DECL(slow_path_div);
233 SLOW_PATH_HIDDEN_DECL(slow_path_mod);
234 SLOW_PATH_HIDDEN_DECL(slow_path_pow);
235 SLOW_PATH_HIDDEN_DECL(slow_path_lshift);
236 SLOW_PATH_HIDDEN_DECL(slow_path_rshift);
237 SLOW_PATH_HIDDEN_DECL(slow_path_urshift);
238 SLOW_PATH_HIDDEN_DECL(slow_path_unsigned);
239 SLOW_PATH_HIDDEN_DECL(slow_path_bitnot);
240 SLOW_PATH_HIDDEN_DECL(slow_path_bitand);
241 SLOW_PATH_HIDDEN_DECL(slow_path_bitor);
242 SLOW_PATH_HIDDEN_DECL(slow_path_bitxor);
243 SLOW_PATH_HIDDEN_DECL(slow_path_typeof);
244 SLOW_PATH_HIDDEN_DECL(slow_path_is_object);
245 SLOW_PATH_HIDDEN_DECL(slow_path_is_object_or_null);
246 SLOW_PATH_HIDDEN_DECL(slow_path_is_function);
247 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_id);
248 SLOW_PATH_HIDDEN_DECL(slow_path_in_by_val);
249 SLOW_PATH_HIDDEN_DECL(slow_path_del_by_val);
250 SLOW_PATH_HIDDEN_DECL(slow_path_strcat);
251 SLOW_PATH_HIDDEN_DECL(slow_path_to_primitive);
252 SLOW_PATH_HIDDEN_DECL(slow_path_to_property_key);
253 SLOW_PATH_HIDDEN_DECL(slow_path_get_enumerable_length);
254 SLOW_PATH_HIDDEN_DECL(slow_path_has_generic_property);
255 SLOW_PATH_HIDDEN_DECL(slow_path_has_structure_property);
256 SLOW_PATH_HIDDEN_DECL(slow_path_has_indexed_property);
257 SLOW_PATH_HIDDEN_DECL(slow_path_get_direct_pname);
258 SLOW_PATH_HIDDEN_DECL(slow_path_get_property_enumerator);
259 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_structure_pname);
260 SLOW_PATH_HIDDEN_DECL(slow_path_enumerator_generic_pname);
261 SLOW_PATH_HIDDEN_DECL(slow_path_to_index_string);
262 SLOW_PATH_HIDDEN_DECL(slow_path_profile_type_clear_log);
263 SLOW_PATH_HIDDEN_DECL(slow_path_unreachable);
264 SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
265 SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
266 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
267 SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
268 SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);
269 SLOW_PATH_HIDDEN_DECL(slow_path_create_promise);
270 SLOW_PATH_HIDDEN_DECL(slow_path_create_generator);
271 SLOW_PATH_HIDDEN_DECL(slow_path_create_async_generator);
272 SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
273 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
274 SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
275 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
276 SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
277 SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
278 SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
279 SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);
280 SLOW_PATH_HIDDEN_DECL(slow_path_new_promise);
281 SLOW_PATH_HIDDEN_DECL(slow_path_new_generator);
282 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
283 SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
284 SLOW_PATH_HIDDEN_DECL(slow_path_spread);
285 
286 using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(CallFrame*, const Instruction*);
287 
288 } // namespace JSC
    </pre>
  </body>
</html>
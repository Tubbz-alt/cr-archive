<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Algorithm.h&quot;
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;BExport.h&quot;
 31 #include &quot;BInline.h&quot;
 32 #include &quot;BPlatform.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;cstddef&gt;
 35 #include &lt;inttypes.h&gt;
 36 
 37 #if ((BOS(DARWIN) || BOS(LINUX)) &amp;&amp; \
 38     (BCPU(X86_64) || (BCPU(ARM64) &amp;&amp; !defined(__ILP32__) &amp;&amp; (!BPLATFORM(IOS_FAMILY) || BPLATFORM(IOS)))))
 39 #define GIGACAGE_ENABLED 1
 40 #else
 41 #define GIGACAGE_ENABLED 0
 42 #endif
 43 
 44 
 45 namespace Gigacage {
 46 
 47 enum Kind {
<a name="1" id="anc1"></a>
 48     Primitive,
 49     JSValue,
<a name="2" id="anc2"></a><span class="line-added"> 50     NumberOfKinds</span>
 51 };
 52 
 53 BINLINE const char* name(Kind kind)
 54 {
 55     switch (kind) {
<a name="3" id="anc3"></a>

 56     case Primitive:
 57         return &quot;Primitive&quot;;
 58     case JSValue:
 59         return &quot;JSValue&quot;;
<a name="4" id="anc4"></a><span class="line-added"> 60     case NumberOfKinds:</span>
<span class="line-added"> 61         break;</span>
 62     }
 63     BCRASH();
 64     return nullptr;
 65 }
 66 
 67 #if GIGACAGE_ENABLED
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69 constexpr size_t configSizeToProtect = 16 * bmalloc::Sizes::kB;</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71 #if BOS_EFFECTIVE_ADDRESS_WIDTH &lt; 48</span>
 72 constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
 73 constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;
<a name="6" id="anc6"></a>
 74 constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;
<a name="7" id="anc7"></a>
 75 #else
 76 constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
 77 constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;
<a name="8" id="anc8"></a>
 78 constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;
<a name="9" id="anc9"></a>
 79 #endif
 80 
 81 // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
 82 // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
 83 #if BOS(LINUX)
<a name="10" id="anc10"></a>
 84 #define GIGACAGE_ALLOCATION_CAN_FAIL 1
<a name="11" id="anc11"></a><span class="line-added"> 85 #else</span>
<span class="line-added"> 86 #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
 87 #endif
 88 
 89 
 90 static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
 91 static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
 92 static_assert(primitiveGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 93 static_assert(jsValueGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 94 
 95 constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
 96 
 97 constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
 98 constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
 99 
<a name="12" id="anc12"></a><span class="line-modified">100 struct Config {</span>
<span class="line-added">101     void* basePtr(Kind kind) const</span>
<span class="line-added">102     {</span>
<span class="line-added">103         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">104         return basePtrs[kind];</span>
<span class="line-added">105     }</span>
106 
<a name="13" id="anc13"></a><span class="line-modified">107     void setBasePtr(Kind kind, void* ptr)</span>
<span class="line-modified">108     {</span>
<span class="line-added">109         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">110         basePtrs[kind] = ptr;</span>
<span class="line-added">111     }</span>
112 
<a name="14" id="anc14"></a><span class="line-modified">113     union {</span>
<span class="line-modified">114         struct {</span>
<span class="line-modified">115             // All the fields in this struct should be chosen such that their</span>
<span class="line-modified">116             // initial value is 0 / null / falsy because Config is instantiated</span>
<span class="line-added">117             // as a global singleton.</span>
<span class="line-added">118 </span>
<span class="line-added">119             bool isEnabled;</span>
<span class="line-added">120             bool isPermanentlyFrozen;</span>
<span class="line-added">121             bool disablingPrimitiveGigacageIsForbidden;</span>
<span class="line-added">122             bool shouldBeEnabled;</span>
<span class="line-added">123 </span>
<span class="line-added">124             // We would like to just put the std::once_flag for these functions</span>
<span class="line-added">125             // here, but we can&#39;t because std::once_flag has a implicitly-deleted</span>
<span class="line-added">126             // default constructor. So, we use a boolean instead.</span>
<span class="line-added">127             bool shouldBeEnabledHasBeenCalled;</span>
<span class="line-added">128             bool ensureGigacageHasBeenCalled;</span>
<span class="line-added">129 </span>
<span class="line-added">130             void* start;</span>
<span class="line-added">131             size_t totalSize;</span>
<span class="line-added">132             void* basePtrs[NumberOfKinds];</span>
<span class="line-added">133         };</span>
<span class="line-added">134         char ensureSize[configSizeToProtect];</span>
<span class="line-added">135     };</span>
136 };
<a name="15" id="anc15"></a><span class="line-added">137 static_assert(sizeof(Config) == configSizeToProtect, &quot;Gigacage Config must fit in configSizeToProtect&quot;);</span>
<span class="line-added">138 </span>
<span class="line-added">139 extern &quot;C&quot; alignas(configSizeToProtect) BEXPORT Config g_gigacageConfig;</span>
140 
<a name="16" id="anc16"></a><span class="line-modified">141 // These constants are needed by the LLInt.</span>
<span class="line-modified">142 constexpr ptrdiff_t offsetOfPrimitiveGigacageBasePtr = Kind::Primitive * sizeof(void*);</span>
<span class="line-added">143 constexpr ptrdiff_t offsetOfJSValueGigacageBasePtr = Kind::JSValue * sizeof(void*);</span>
144 
<a name="17" id="anc17"></a><span class="line-modified">145 </span>
<span class="line-added">146 BINLINE bool isEnabled() { return g_gigacageConfig.isEnabled; }</span>
147 
148 BEXPORT void ensureGigacage();
149 
150 BEXPORT void disablePrimitiveGigacage();
151 
152 // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
153 BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
154 BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
155 
<a name="18" id="anc18"></a><span class="line-modified">156 BEXPORT void forbidDisablingPrimitiveGigacage();</span>




157 
<a name="19" id="anc19"></a><span class="line-modified">158 BEXPORT bool isDisablingPrimitiveGigacageForbidden();</span>
<span class="line-modified">159 inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageForbidden(); }</span>
<span class="line-modified">160 inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageForbidden(); }</span>










161 
<a name="20" id="anc20"></a><span class="line-modified">162 BINLINE void* basePtr(Kind kind)</span>
163 {
<a name="21" id="anc21"></a><span class="line-modified">164     return g_gigacageConfig.basePtr(kind);</span>
165 }
166 
<a name="22" id="anc22"></a><span class="line-modified">167 BINLINE void* addressOfBasePtr(Kind kind)</span>
168 {
<a name="23" id="anc23"></a><span class="line-modified">169     RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">170     return &amp;g_gigacageConfig.basePtrs[kind];</span>
171 }
172 
173 BINLINE bool isEnabled(Kind kind)
174 {
<a name="24" id="anc24"></a><span class="line-modified">175     return !!g_gigacageConfig.basePtr(kind);</span>
176 }
177 
178 BINLINE size_t size(Kind kind)
179 {
180     switch (kind) {
<a name="25" id="anc25"></a>

181     case Primitive:
182         return static_cast&lt;size_t&gt;(primitiveGigacageSize);
183     case JSValue:
184         return static_cast&lt;size_t&gt;(jsValueGigacageSize);
<a name="26" id="anc26"></a><span class="line-added">185     case NumberOfKinds:</span>
<span class="line-added">186         break;</span>
187     }
188     BCRASH();
189     return 0;
190 }
191 
192 BINLINE size_t alignment(Kind kind)
193 {
194     return size(kind);
195 }
196 
197 BINLINE size_t mask(Kind kind)
198 {
199     return gigacageSizeToMask(size(kind));
200 }
201 
202 template&lt;typename Func&gt;
203 void forEachKind(const Func&amp; func)
204 {
205     func(Primitive);
206     func(JSValue);
207 }
208 
209 template&lt;typename T&gt;
210 BINLINE T* caged(Kind kind, T* ptr)
211 {
212     BASSERT(ptr);
<a name="27" id="anc27"></a><span class="line-modified">213     void* gigacageBasePtr = g_gigacageConfig.basePtr(kind);</span>
214     if (!gigacageBasePtr)
215         return ptr;
216     return reinterpret_cast&lt;T*&gt;(
217         reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
218             reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
219 }
220 
221 template&lt;typename T&gt;
222 BINLINE T* cagedMayBeNull(Kind kind, T* ptr)
223 {
224     if (!ptr)
225         return ptr;
226     return caged(kind, ptr);
227 }
228 
229 BINLINE bool isCaged(Kind kind, const void* ptr)
230 {
231     return caged(kind, ptr) == ptr;
232 }
233 
<a name="28" id="anc28"></a><span class="line-added">234 BINLINE bool contains(const void* ptr)</span>
<span class="line-added">235 {</span>
<span class="line-added">236     auto* start = reinterpret_cast&lt;const uint8_t*&gt;(g_gigacageConfig.start);</span>
<span class="line-added">237     auto* p = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-added">238     return static_cast&lt;size_t&gt;(p - start) &lt; g_gigacageConfig.totalSize;</span>
<span class="line-added">239 }</span>
<span class="line-added">240 </span>
241 BEXPORT bool shouldBeEnabled();
242 
243 #else // GIGACAGE_ENABLED
244 
<a name="29" id="anc29"></a><span class="line-modified">245 BINLINE void* basePtr(Kind)</span>
246 {
247     BCRASH();
248     static void* unreachable;
249     return unreachable;
250 }
251 BINLINE size_t size(Kind) { BCRASH(); return 0; }
252 BINLINE void ensureGigacage() { }
<a name="30" id="anc30"></a><span class="line-modified">253 BINLINE bool contains(const void*) { return false; }</span>
<span class="line-added">254 BINLINE bool isEnabled() { return false; }</span>
255 BINLINE bool isCaged(Kind, const void*) { return true; }
256 BINLINE bool isEnabled(Kind) { return false; }
257 template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
258 template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<a name="31" id="anc31"></a><span class="line-modified">259 BINLINE void forbidDisablingPrimitiveGigacage() { }</span>
260 BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
261 BINLINE void disablePrimitiveGigacage() { }
262 BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
263 BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
264 
265 #endif // GIGACAGE_ENABLED
266 
267 } // namespace Gigacage
268 
269 
270 
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
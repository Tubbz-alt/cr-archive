<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/GPRInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;MacroAssembler.h&quot;
 29 #include &lt;array&gt;
 30 #include &lt;wtf/PrintStream.h&gt;
 31 
 32 namespace JSC {
 33 
 34 enum NoResultTag { NoResult };
 35 
 36 // We use the same conventions in the baseline JIT as in the LLint. If you
 37 // change mappings in the GPRInfo, you should change them in the offlineasm
 38 // compiler adequately. The register naming conventions are described at the
 39 // top of the LowLevelInterpreter.asm file.
 40 
 41 typedef MacroAssembler::RegisterID GPRReg;
 42 static constexpr GPRReg InvalidGPRReg { GPRReg::InvalidGPRReg };
 43 
 44 #if ENABLE(ASSEMBLER)
 45 
 46 #if USE(JSVALUE64)
 47 class JSValueRegs {
 48 public:
 49     constexpr JSValueRegs()
 50         : m_gpr(InvalidGPRReg)
 51     {
 52     }
 53 
 54     constexpr explicit JSValueRegs(GPRReg gpr)
 55         : m_gpr(gpr)
 56     {
 57     }
 58 
 59     static JSValueRegs payloadOnly(GPRReg gpr)
 60     {
 61         return JSValueRegs(gpr);
 62     }
 63 
 64     static JSValueRegs withTwoAvailableRegs(GPRReg gpr, GPRReg)
 65     {
 66         return JSValueRegs(gpr);
 67     }
 68 
 69     bool operator!() const { return m_gpr == InvalidGPRReg; }
 70     explicit operator bool() const { return m_gpr != InvalidGPRReg; }
 71 
 72     bool operator==(JSValueRegs other) { return m_gpr == other.m_gpr; }
 73     bool operator!=(JSValueRegs other) { return !(*this == other); }
 74 
 75     GPRReg gpr() const { return m_gpr; }
 76     GPRReg tagGPR() const { return InvalidGPRReg; }
 77     GPRReg payloadGPR() const { return m_gpr; }
 78 
 79     bool uses(GPRReg gpr) const { return m_gpr == gpr; }
 80 
 81     void dump(PrintStream&amp;) const;
 82 
 83 private:
 84     GPRReg m_gpr;
 85 };
 86 
 87 class JSValueSource {
 88 public:
 89     JSValueSource()
 90         : m_offset(notAddress())
 91         , m_base(InvalidGPRReg)
 92     {
 93     }
 94 
 95     JSValueSource(JSValueRegs regs)
 96         : m_offset(notAddress())
 97         , m_base(regs.gpr())
 98     {
 99     }
100 
101     explicit JSValueSource(GPRReg gpr)
102         : m_offset(notAddress())
103         , m_base(gpr)
104     {
105     }
106 
107     JSValueSource(MacroAssembler::Address address)
108         : m_offset(address.offset)
109         , m_base(address.base)
110     {
111         ASSERT(m_offset != notAddress());
112         ASSERT(m_base != InvalidGPRReg);
113     }
114 
115     static JSValueSource unboxedCell(GPRReg payloadGPR)
116     {
117         return JSValueSource(payloadGPR);
118     }
119 
120     bool operator!() const { return m_base == InvalidGPRReg; }
121     explicit operator bool() const { return m_base != InvalidGPRReg; }
122 
123     bool isAddress() const { return m_offset != notAddress(); }
124 
125     int32_t offset() const
126     {
127         ASSERT(isAddress());
128         return m_offset;
129     }
130 
131     GPRReg base() const
132     {
133         ASSERT(isAddress());
134         return m_base;
135     }
136 
137     GPRReg gpr() const
138     {
139         ASSERT(!isAddress());
140         return m_base;
141     }
142 
143     GPRReg payloadGPR() const { return gpr(); }
144 
145     JSValueRegs regs() const
146     {
147         return JSValueRegs(gpr());
148     }
149 
150     MacroAssembler::Address asAddress() const { return MacroAssembler::Address(base(), offset()); }
151 
152 private:
153     static inline int32_t notAddress() { return 0x80000000; }
154 
155     int32_t m_offset;
156     GPRReg m_base;
157 };
158 #endif // USE(JSVALUE64)
159 
160 #if USE(JSVALUE32_64)
161 class JSValueRegs {
162 public:
163     JSValueRegs()
164         : m_tagGPR(InvalidGPRReg)
165         , m_payloadGPR(InvalidGPRReg)
166     {
167     }
168 
169     JSValueRegs(GPRReg tagGPR, GPRReg payloadGPR)
170         : m_tagGPR(tagGPR)
171         , m_payloadGPR(payloadGPR)
172     {
173     }
174 
175     static JSValueRegs withTwoAvailableRegs(GPRReg gpr1, GPRReg gpr2)
176     {
177         return JSValueRegs(gpr1, gpr2);
178     }
179 
180     static JSValueRegs payloadOnly(GPRReg gpr)
181     {
182         return JSValueRegs(InvalidGPRReg, gpr);
183     }
184 
185     bool operator!() const { return !static_cast&lt;bool&gt;(*this); }
186     explicit operator bool() const
187     {
188         return static_cast&lt;GPRReg&gt;(m_tagGPR) != InvalidGPRReg
189             || static_cast&lt;GPRReg&gt;(m_payloadGPR) != InvalidGPRReg;
190     }
191 
192     bool operator==(JSValueRegs other) const
193     {
194         return m_tagGPR == other.m_tagGPR
195             &amp;&amp; m_payloadGPR == other.m_payloadGPR;
196     }
197     bool operator!=(JSValueRegs other) const { return !(*this == other); }
198 
199     GPRReg tagGPR() const { return m_tagGPR; }
200     GPRReg payloadGPR() const { return m_payloadGPR; }
201     GPRReg gpr(WhichValueWord which) const
202     {
203         switch (which) {
204         case TagWord:
205             return tagGPR();
206         case PayloadWord:
207             return payloadGPR();
208         }
209         ASSERT_NOT_REACHED();
210         return tagGPR();
211     }
212 
213     bool uses(GPRReg gpr) const { return m_tagGPR == gpr || m_payloadGPR == gpr; }
214 
215     void dump(PrintStream&amp;) const;
216 
217 private:
218     GPRReg m_tagGPR;
219     GPRReg m_payloadGPR;
220 };
221 
222 class JSValueSource {
223 public:
224     JSValueSource()
225         : m_offset(notAddress())
226         , m_baseOrTag(InvalidGPRReg)
227         , m_payload(InvalidGPRReg)
228         , m_tagType(0)
229     {
230     }
231 
232     JSValueSource(JSValueRegs regs)
233         : m_offset(notAddress())
234         , m_baseOrTag(regs.tagGPR())
235         , m_payload(regs.payloadGPR())
236         , m_tagType(0)
237     {
238     }
239 
240     JSValueSource(GPRReg tagGPR, GPRReg payloadGPR)
241         : m_offset(notAddress())
242         , m_baseOrTag(tagGPR)
243         , m_payload(payloadGPR)
244         , m_tagType(0)
245     {
246     }
247 
248     JSValueSource(MacroAssembler::Address address)
249         : m_offset(address.offset)
250         , m_baseOrTag(address.base)
251         , m_payload(InvalidGPRReg)
252         , m_tagType(0)
253     {
254         ASSERT(m_offset != notAddress());
255         ASSERT(m_baseOrTag != InvalidGPRReg);
256     }
257 
258     static JSValueSource unboxedCell(GPRReg payloadGPR)
259     {
260         JSValueSource result;
261         result.m_offset = notAddress();
262         result.m_baseOrTag = InvalidGPRReg;
263         result.m_payload = payloadGPR;
264         result.m_tagType = static_cast&lt;int8_t&gt;(JSValue::CellTag);
265         return result;
266     }
267 
268     bool operator!() const { return !static_cast&lt;bool&gt;(*this); }
269     explicit operator bool() const
270     {
271         return m_baseOrTag != InvalidGPRReg || m_payload != InvalidGPRReg;
272     }
273 
274     bool isAddress() const
275     {
276         ASSERT(!!*this);
277         return m_offset != notAddress();
278     }
279 
280     int32_t offset() const
281     {
282         ASSERT(isAddress());
283         return m_offset;
284     }
285 
286     GPRReg base() const
287     {
288         ASSERT(isAddress());
289         return m_baseOrTag;
290     }
291 
292     GPRReg tagGPR() const
293     {
294         ASSERT(!isAddress() &amp;&amp; m_baseOrTag != InvalidGPRReg);
295         return m_baseOrTag;
296     }
297 
298     GPRReg payloadGPR() const
299     {
300         ASSERT(!isAddress());
301         return m_payload;
302     }
303 
304     bool hasKnownTag() const
305     {
306         ASSERT(!!*this);
307         ASSERT(!isAddress());
308         return m_baseOrTag == InvalidGPRReg;
309     }
310 
311     uint32_t tag() const
312     {
313         return static_cast&lt;int32_t&gt;(m_tagType);
314     }
315 
316     JSValueRegs regs() const
317     {
318         return JSValueRegs(tagGPR(), payloadGPR());
319     }
320 
321     MacroAssembler::Address asAddress(unsigned additionalOffset = 0) const { return MacroAssembler::Address(base(), offset() + additionalOffset); }
322 
323 private:
324     static inline int32_t notAddress() { return 0x80000000; }
325 
326     int32_t m_offset;
327     GPRReg m_baseOrTag;
328     GPRReg m_payload;
329     int8_t m_tagType; // Contains the low bits of the tag.
330 };
331 #endif // USE(JSVALUE32_64)
332 
333 #if CPU(X86)
334 #define NUMBER_OF_ARGUMENT_REGISTERS 0u
335 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 0u
336 
337 class GPRInfo {
338 public:
339     typedef GPRReg RegisterType;
<a name="2" id="anc2"></a><span class="line-modified">340     static constexpr unsigned numberOfRegisters = 6;</span>
<span class="line-modified">341     static constexpr unsigned numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;</span>
342 
343     // Temporary registers.
<a name="3" id="anc3"></a><span class="line-modified">344     static constexpr GPRReg regT0 = X86Registers::eax;</span>
<span class="line-modified">345     static constexpr GPRReg regT1 = X86Registers::edx;</span>
<span class="line-modified">346     static constexpr GPRReg regT2 = X86Registers::ecx;</span>
<span class="line-modified">347     static constexpr GPRReg regT3 = X86Registers::ebx; // Callee-save</span>
<span class="line-modified">348     static constexpr GPRReg regT4 = X86Registers::esi; // Callee-save</span>
<span class="line-modified">349     static constexpr GPRReg regT5 = X86Registers::edi; // Callee-save</span>
<span class="line-modified">350     static constexpr GPRReg callFrameRegister = X86Registers::ebp;</span>
351     // These constants provide the names for the general purpose argument &amp; return value registers.
<a name="4" id="anc4"></a><span class="line-modified">352     static constexpr GPRReg argumentGPR0 = X86Registers::ecx; // regT2</span>
<span class="line-modified">353     static constexpr GPRReg argumentGPR1 = X86Registers::edx; // regT1</span>
<span class="line-modified">354     static constexpr GPRReg argumentGPR2 = X86Registers::eax; // regT0</span>
<span class="line-modified">355     static constexpr GPRReg argumentGPR3 = X86Registers::ebx; // regT3</span>
<span class="line-modified">356     static constexpr GPRReg nonArgGPR0 = X86Registers::esi; // regT4</span>
<span class="line-modified">357     static constexpr GPRReg returnValueGPR = X86Registers::eax; // regT0</span>
<span class="line-modified">358     static constexpr GPRReg returnValueGPR2 = X86Registers::edx; // regT1</span>
<span class="line-modified">359     static constexpr GPRReg nonPreservedNonReturnGPR = X86Registers::ecx;</span>
360 
361     static GPRReg toRegister(unsigned index)
362     {
363         ASSERT(index &lt; numberOfRegisters);
364         static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5 };
365         return registerForIndex[index];
366     }
367 
368     static GPRReg toArgumentRegister(unsigned)
369     {
370         UNREACHABLE_FOR_PLATFORM();
371         return InvalidGPRReg;
372     }
373 
374     static unsigned toIndex(GPRReg reg)
375     {
376         ASSERT(reg != InvalidGPRReg);
377         ASSERT(static_cast&lt;int&gt;(reg) &lt; 8);
378         static const unsigned indexForRegister[8] = { 0, 2, 1, 3, InvalidIndex, InvalidIndex, 4, 5 };
379         unsigned result = indexForRegister[reg];
380         return result;
381     }
382 
383     static const char* debugName(GPRReg reg)
384     {
385         ASSERT(reg != InvalidGPRReg);
386         return MacroAssembler::gprName(reg);
387     }
388 
<a name="5" id="anc5"></a><span class="line-modified">389     static constexpr unsigned InvalidIndex = 0xffffffff;</span>
390 };
391 
392 #endif // CPU(X86)
393 
394 #if CPU(X86_64)
395 #if !OS(WINDOWS)
396 #define NUMBER_OF_ARGUMENT_REGISTERS 6u
397 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 5u
398 #else
399 #define NUMBER_OF_ARGUMENT_REGISTERS 4u
400 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 7u
401 #endif
402 
403 class GPRInfo {
404 public:
405     typedef GPRReg RegisterType;
<a name="6" id="anc6"></a><span class="line-modified">406     static constexpr unsigned numberOfRegisters = 11;</span>
<span class="line-modified">407     static constexpr unsigned numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;</span>
408 
409     // These registers match the baseline JIT.
<a name="7" id="anc7"></a><span class="line-modified">410     static constexpr GPRReg callFrameRegister = X86Registers::ebp;</span>
<span class="line-modified">411     static constexpr GPRReg numberTagRegister = X86Registers::r14;</span>
<span class="line-modified">412     static constexpr GPRReg notCellMaskRegister = X86Registers::r15;</span>
413 
414     // Temporary registers.
<a name="8" id="anc8"></a><span class="line-modified">415     static constexpr GPRReg regT0 = X86Registers::eax;</span>
416 #if !OS(WINDOWS)
<a name="9" id="anc9"></a><span class="line-modified">417     static constexpr GPRReg regT1 = X86Registers::esi;</span>
<span class="line-modified">418     static constexpr GPRReg regT2 = X86Registers::edx;</span>
<span class="line-modified">419     static constexpr GPRReg regT3 = X86Registers::ecx;</span>
<span class="line-modified">420     static constexpr GPRReg regT4 = X86Registers::r8;</span>
<span class="line-modified">421     static constexpr GPRReg regT5 = X86Registers::r10;</span>
<span class="line-modified">422     static constexpr GPRReg regT6 = X86Registers::edi;</span>
<span class="line-modified">423     static constexpr GPRReg regT7 = X86Registers::r9;</span>
424 #else
<a name="10" id="anc10"></a><span class="line-modified">425     static constexpr GPRReg regT1 = X86Registers::edx;</span>
<span class="line-modified">426     static constexpr GPRReg regT2 = X86Registers::r8;</span>
<span class="line-modified">427     static constexpr GPRReg regT3 = X86Registers::r9;</span>
<span class="line-modified">428     static constexpr GPRReg regT4 = X86Registers::r10;</span>
<span class="line-modified">429     static constexpr GPRReg regT5 = X86Registers::ecx;</span>
430 #endif
431 
<a name="11" id="anc11"></a><span class="line-modified">432     static constexpr GPRReg regCS0 = X86Registers::ebx;</span>
433 
434 #if !OS(WINDOWS)
<a name="12" id="anc12"></a><span class="line-modified">435     static constexpr GPRReg regCS1 = X86Registers::r12;</span>
<span class="line-modified">436     static constexpr GPRReg regCS2 = X86Registers::r13;</span>
<span class="line-modified">437     static constexpr GPRReg regCS3 = X86Registers::r14;</span>
<span class="line-modified">438     static constexpr GPRReg regCS4 = X86Registers::r15;</span>
439 #else
<a name="13" id="anc13"></a><span class="line-modified">440     static constexpr GPRReg regCS1 = X86Registers::esi;</span>
<span class="line-modified">441     static constexpr GPRReg regCS2 = X86Registers::edi;</span>
<span class="line-modified">442     static constexpr GPRReg regCS3 = X86Registers::r12;</span>
<span class="line-modified">443     static constexpr GPRReg regCS4 = X86Registers::r13;</span>
<span class="line-modified">444     static constexpr GPRReg regCS5 = X86Registers::r14;</span>
<span class="line-modified">445     static constexpr GPRReg regCS6 = X86Registers::r15;</span>
446 #endif
447 
448     // These constants provide the names for the general purpose argument &amp; return value registers.
449 #if !OS(WINDOWS)
<a name="14" id="anc14"></a><span class="line-modified">450     static constexpr GPRReg argumentGPR0 = X86Registers::edi; // regT6</span>
<span class="line-modified">451     static constexpr GPRReg argumentGPR1 = X86Registers::esi; // regT1</span>
<span class="line-modified">452     static constexpr GPRReg argumentGPR2 = X86Registers::edx; // regT2</span>
<span class="line-modified">453     static constexpr GPRReg argumentGPR3 = X86Registers::ecx; // regT3</span>
<span class="line-modified">454     static constexpr GPRReg argumentGPR4 = X86Registers::r8; // regT4</span>
<span class="line-modified">455     static constexpr GPRReg argumentGPR5 = X86Registers::r9; // regT7</span>
456 #else
<a name="15" id="anc15"></a><span class="line-modified">457     static constexpr GPRReg argumentGPR0 = X86Registers::ecx; // regT5</span>
<span class="line-modified">458     static constexpr GPRReg argumentGPR1 = X86Registers::edx; // regT1</span>
<span class="line-modified">459     static constexpr GPRReg argumentGPR2 = X86Registers::r8; // regT2</span>
<span class="line-modified">460     static constexpr GPRReg argumentGPR3 = X86Registers::r9; // regT3</span>
461 #endif
<a name="16" id="anc16"></a><span class="line-modified">462     static constexpr GPRReg nonArgGPR0 = X86Registers::r10; // regT5 (regT4 on Windows)</span>
<span class="line-modified">463     static constexpr GPRReg returnValueGPR = X86Registers::eax; // regT0</span>
<span class="line-modified">464     static constexpr GPRReg returnValueGPR2 = X86Registers::edx; // regT1 or regT2</span>
<span class="line-modified">465     static constexpr GPRReg nonPreservedNonReturnGPR = X86Registers::r10; // regT5 (regT4 on Windows)</span>
<span class="line-modified">466     static constexpr GPRReg nonPreservedNonArgumentGPR0 = X86Registers::r10; // regT5 (regT4 on Windows)</span>
<span class="line-modified">467     static constexpr GPRReg nonPreservedNonArgumentGPR1 = X86Registers::eax;</span>
468 
469     // FIXME: I believe that all uses of this are dead in the sense that it just causes the scratch
470     // register allocator to select a different register and potentially spill things. It would be better
471     // if we instead had a more explicit way of saying that we don&#39;t have a scratch register.
<a name="17" id="anc17"></a><span class="line-modified">472     static constexpr GPRReg patchpointScratchRegister = MacroAssembler::s_scratchRegister;</span>
473 
474     static GPRReg toRegister(unsigned index)
475     {
476         ASSERT(index &lt; numberOfRegisters);
477 #if !OS(WINDOWS)
478         static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5, regT6, regT7, regCS0, regCS1, regCS2 };
479 #else
480         static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5, regCS0, regCS1, regCS2, regCS3, regCS4 };
481 #endif
482         return registerForIndex[index];
483     }
484 
485     static GPRReg toArgumentRegister(unsigned index)
486     {
487         ASSERT(index &lt; numberOfArgumentRegisters);
488 #if !OS(WINDOWS)
489         static const GPRReg registerForIndex[numberOfArgumentRegisters] = { argumentGPR0, argumentGPR1, argumentGPR2, argumentGPR3, argumentGPR4, argumentGPR5 };
490 #else
491         static const GPRReg registerForIndex[numberOfArgumentRegisters] = { argumentGPR0, argumentGPR1, argumentGPR2, argumentGPR3 };
492 #endif
493         return registerForIndex[index];
494     }
495 
496     static unsigned toIndex(GPRReg reg)
497     {
498         ASSERT(reg != InvalidGPRReg);
499         ASSERT(static_cast&lt;int&gt;(reg) &lt; 16);
500 #if !OS(WINDOWS)
501         static const unsigned indexForRegister[16] = { 0, 3, 2, 8, InvalidIndex, InvalidIndex, 1, 6, 4, 7, 5, InvalidIndex, 9, 10, InvalidIndex, InvalidIndex };
502 #else
503         static const unsigned indexForRegister[16] = { 0, 5, 1, 6, InvalidIndex, InvalidIndex, 7, 8, 2, 3, 4, InvalidIndex, 9, 10, InvalidIndex, InvalidIndex };
504 #endif
505         return indexForRegister[reg];
506     }
507 
508     static const char* debugName(GPRReg reg)
509     {
510         ASSERT(reg != InvalidGPRReg);
511         return MacroAssembler::gprName(reg);
512     }
513 
514     static const std::array&lt;GPRReg, 3&gt;&amp; reservedRegisters()
515     {
516         static const std::array&lt;GPRReg, 3&gt; reservedRegisters { {
517             MacroAssembler::s_scratchRegister,
<a name="18" id="anc18"></a><span class="line-modified">518             numberTagRegister,</span>
<span class="line-modified">519             notCellMaskRegister,</span>
520         } };
521         return reservedRegisters;
522     }
523 
<a name="19" id="anc19"></a><span class="line-modified">524     static constexpr unsigned InvalidIndex = 0xffffffff;</span>
525 };
526 
527 #endif // CPU(X86_64)
528 
529 #if CPU(ARM_THUMB2)
530 #define NUMBER_OF_ARGUMENT_REGISTERS 4u
<a name="20" id="anc20"></a><span class="line-modified">531 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 2u</span>
532 
533 class GPRInfo {
534 public:
535     typedef GPRReg RegisterType;
<a name="21" id="anc21"></a><span class="line-modified">536     static constexpr unsigned numberOfRegisters = 9;</span>
<span class="line-modified">537     static constexpr unsigned numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;</span>
538 
539     // Temporary registers.
<a name="22" id="anc22"></a><span class="line-modified">540     static constexpr GPRReg regT0 = ARMRegisters::r0;</span>
<span class="line-modified">541     static constexpr GPRReg regT1 = ARMRegisters::r1;</span>
<span class="line-modified">542     static constexpr GPRReg regT2 = ARMRegisters::r2;</span>
<span class="line-modified">543     static constexpr GPRReg regT3 = ARMRegisters::r3;</span>
<span class="line-modified">544     static constexpr GPRReg regT4 = ARMRegisters::r8;</span>
<span class="line-modified">545     static constexpr GPRReg regT5 = ARMRegisters::r9;</span>
<span class="line-modified">546     static constexpr GPRReg regT6 = ARMRegisters::r5;</span>
<span class="line-modified">547     static constexpr GPRReg regT7 = ARMRegisters::r4;</span>
<span class="line-modified">548     static constexpr GPRReg regCS0 = ARMRegisters::r11;</span>
<span class="line-modified">549     static constexpr GPRReg regCS1 = ARMRegisters::r10;</span>
550     // These registers match the baseline JIT.
<a name="23" id="anc23"></a><span class="line-modified">551     static constexpr GPRReg callFrameRegister = ARMRegisters::fp;</span>
552     // These constants provide the names for the general purpose argument &amp; return value registers.
<a name="24" id="anc24"></a><span class="line-modified">553     static constexpr GPRReg argumentGPR0 = ARMRegisters::r0; // regT0</span>
<span class="line-modified">554     static constexpr GPRReg argumentGPR1 = ARMRegisters::r1; // regT1</span>
<span class="line-modified">555     static constexpr GPRReg argumentGPR2 = ARMRegisters::r2; // regT2</span>
<span class="line-modified">556     static constexpr GPRReg argumentGPR3 = ARMRegisters::r3; // regT3</span>
<span class="line-modified">557     static constexpr GPRReg nonArgGPR0 = ARMRegisters::r4; // regT7</span>
<span class="line-modified">558     static constexpr GPRReg returnValueGPR = ARMRegisters::r0; // regT0</span>
<span class="line-modified">559     static constexpr GPRReg returnValueGPR2 = ARMRegisters::r1; // regT1</span>
<span class="line-modified">560     static constexpr GPRReg nonPreservedNonReturnGPR = ARMRegisters::r5;</span>

561 
562     static GPRReg toRegister(unsigned index)
563     {
564         ASSERT(index &lt; numberOfRegisters);
<a name="25" id="anc25"></a><span class="line-modified">565         static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5, regT6, regT7, regCS1 };</span>
566         return registerForIndex[index];
567     }
568 
569     static GPRReg toArgumentRegister(unsigned index)
570     {
571         ASSERT(index &lt; numberOfArgumentRegisters);
572         static const GPRReg registerForIndex[numberOfArgumentRegisters] = { argumentGPR0, argumentGPR1, argumentGPR2, argumentGPR3 };
573         return registerForIndex[index];
574     }
575 
576     static unsigned toIndex(GPRReg reg)
577     {
578         ASSERT(reg != InvalidGPRReg);
579         ASSERT(static_cast&lt;int&gt;(reg) &lt; 16);
580         static const unsigned indexForRegister[16] =
<a name="26" id="anc26"></a><span class="line-modified">581             { 0, 1, 2, 3, 7, 6, InvalidIndex, InvalidIndex, 4, 5, 8, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex };</span>
582         unsigned result = indexForRegister[reg];
583         return result;
584     }
585 
586     static const char* debugName(GPRReg reg)
587     {
588         ASSERT(reg != InvalidGPRReg);
589         return MacroAssembler::gprName(reg);
590     }
591 
<a name="27" id="anc27"></a><span class="line-modified">592     static constexpr unsigned InvalidIndex = 0xffffffff;</span>
593 };
594 
595 #endif // CPU(ARM)
596 
597 #if CPU(ARM64)
598 #define NUMBER_OF_ARGUMENT_REGISTERS 8u
599 // Callee Saves includes x19..x28 and FP registers q8..q15
600 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 18u
601 
602 class GPRInfo {
603 public:
604     typedef GPRReg RegisterType;
<a name="28" id="anc28"></a><span class="line-modified">605     static constexpr unsigned numberOfRegisters = 16;</span>
<span class="line-modified">606     static constexpr unsigned numberOfArgumentRegisters = 8;</span>
607 
608     // These registers match the baseline JIT.
<a name="29" id="anc29"></a><span class="line-modified">609     static constexpr GPRReg callFrameRegister = ARM64Registers::fp;</span>
<span class="line-modified">610     static constexpr GPRReg numberTagRegister = ARM64Registers::x27;</span>
<span class="line-modified">611     static constexpr GPRReg notCellMaskRegister = ARM64Registers::x28;</span>
<span class="line-modified">612     static constexpr GPRReg dataTempRegister = MacroAssembler::dataTempRegister;</span>
<span class="line-modified">613     static constexpr GPRReg memoryTempRegister = MacroAssembler::memoryTempRegister;</span>
614     // Temporary registers.
<a name="30" id="anc30"></a><span class="line-modified">615     static constexpr GPRReg regT0 = ARM64Registers::x0;</span>
<span class="line-modified">616     static constexpr GPRReg regT1 = ARM64Registers::x1;</span>
<span class="line-modified">617     static constexpr GPRReg regT2 = ARM64Registers::x2;</span>
<span class="line-modified">618     static constexpr GPRReg regT3 = ARM64Registers::x3;</span>
<span class="line-modified">619     static constexpr GPRReg regT4 = ARM64Registers::x4;</span>
<span class="line-modified">620     static constexpr GPRReg regT5 = ARM64Registers::x5;</span>
<span class="line-modified">621     static constexpr GPRReg regT6 = ARM64Registers::x6;</span>
<span class="line-modified">622     static constexpr GPRReg regT7 = ARM64Registers::x7;</span>
<span class="line-modified">623     static constexpr GPRReg regT8 = ARM64Registers::x8;</span>
<span class="line-modified">624     static constexpr GPRReg regT9 = ARM64Registers::x9;</span>
<span class="line-modified">625     static constexpr GPRReg regT10 = ARM64Registers::x10;</span>
<span class="line-modified">626     static constexpr GPRReg regT11 = ARM64Registers::x11;</span>
<span class="line-modified">627     static constexpr GPRReg regT12 = ARM64Registers::x12;</span>
<span class="line-modified">628     static constexpr GPRReg regT13 = ARM64Registers::x13;</span>
<span class="line-modified">629     static constexpr GPRReg regT14 = ARM64Registers::x14;</span>
<span class="line-modified">630     static constexpr GPRReg regT15 = ARM64Registers::x15;</span>
<span class="line-modified">631     static constexpr GPRReg regCS0 = ARM64Registers::x19; // Used by FTL only</span>
<span class="line-modified">632     static constexpr GPRReg regCS1 = ARM64Registers::x20; // Used by FTL only</span>
<span class="line-modified">633     static constexpr GPRReg regCS2 = ARM64Registers::x21; // Used by FTL only</span>
<span class="line-modified">634     static constexpr GPRReg regCS3 = ARM64Registers::x22; // Used by FTL only</span>
<span class="line-modified">635     static constexpr GPRReg regCS4 = ARM64Registers::x23; // Used by FTL only</span>
<span class="line-modified">636     static constexpr GPRReg regCS5 = ARM64Registers::x24; // Used by FTL only</span>
<span class="line-modified">637     static constexpr GPRReg regCS6 = ARM64Registers::x25; // Used by FTL only</span>
<span class="line-modified">638     static constexpr GPRReg regCS7 = ARM64Registers::x26;</span>
<span class="line-modified">639     static constexpr GPRReg regCS8 = ARM64Registers::x27; // numberTag</span>
<span class="line-modified">640     static constexpr GPRReg regCS9 = ARM64Registers::x28; // notCellMask</span>
641     // These constants provide the names for the general purpose argument &amp; return value registers.
<a name="31" id="anc31"></a><span class="line-modified">642     static constexpr GPRReg argumentGPR0 = ARM64Registers::x0; // regT0</span>
<span class="line-modified">643     static constexpr GPRReg argumentGPR1 = ARM64Registers::x1; // regT1</span>
<span class="line-modified">644     static constexpr GPRReg argumentGPR2 = ARM64Registers::x2; // regT2</span>
<span class="line-modified">645     static constexpr GPRReg argumentGPR3 = ARM64Registers::x3; // regT3</span>
<span class="line-modified">646     static constexpr GPRReg argumentGPR4 = ARM64Registers::x4; // regT4</span>
<span class="line-modified">647     static constexpr GPRReg argumentGPR5 = ARM64Registers::x5; // regT5</span>
<span class="line-modified">648     static constexpr GPRReg argumentGPR6 = ARM64Registers::x6; // regT6</span>
<span class="line-modified">649     static constexpr GPRReg argumentGPR7 = ARM64Registers::x7; // regT7</span>
<span class="line-modified">650     static constexpr GPRReg nonArgGPR0 = ARM64Registers::x8; // regT8</span>
<span class="line-modified">651     static constexpr GPRReg returnValueGPR = ARM64Registers::x0; // regT0</span>
<span class="line-modified">652     static constexpr GPRReg returnValueGPR2 = ARM64Registers::x1; // regT1</span>
<span class="line-modified">653     static constexpr GPRReg nonPreservedNonReturnGPR = ARM64Registers::x2;</span>
<span class="line-modified">654     static constexpr GPRReg nonPreservedNonArgumentGPR0 = ARM64Registers::x8;</span>
<span class="line-modified">655     static constexpr GPRReg nonPreservedNonArgumentGPR1 = ARM64Registers::x9;</span>
<span class="line-modified">656     static constexpr GPRReg patchpointScratchRegister = ARM64Registers::ip0;</span>

657 
658     // GPRReg mapping is direct, the machine register numbers can
659     // be used directly as indices into the GPR RegisterBank.
660     COMPILE_ASSERT(ARM64Registers::q0 == 0, q0_is_0);
661     COMPILE_ASSERT(ARM64Registers::q1 == 1, q1_is_1);
662     COMPILE_ASSERT(ARM64Registers::q2 == 2, q2_is_2);
663     COMPILE_ASSERT(ARM64Registers::q3 == 3, q3_is_3);
664     COMPILE_ASSERT(ARM64Registers::q4 == 4, q4_is_4);
665     COMPILE_ASSERT(ARM64Registers::q5 == 5, q5_is_5);
666     COMPILE_ASSERT(ARM64Registers::q6 == 6, q6_is_6);
667     COMPILE_ASSERT(ARM64Registers::q7 == 7, q7_is_7);
668     COMPILE_ASSERT(ARM64Registers::q8 == 8, q8_is_8);
669     COMPILE_ASSERT(ARM64Registers::q9 == 9, q9_is_9);
670     COMPILE_ASSERT(ARM64Registers::q10 == 10, q10_is_10);
671     COMPILE_ASSERT(ARM64Registers::q11 == 11, q11_is_11);
672     COMPILE_ASSERT(ARM64Registers::q12 == 12, q12_is_12);
673     COMPILE_ASSERT(ARM64Registers::q13 == 13, q13_is_13);
674     COMPILE_ASSERT(ARM64Registers::q14 == 14, q14_is_14);
675     COMPILE_ASSERT(ARM64Registers::q15 == 15, q15_is_15);
676     static GPRReg toRegister(unsigned index)
677     {
678         return (GPRReg)index;
679     }
680     static unsigned toIndex(GPRReg reg)
681     {
682         if (reg &gt; regT15)
683             return InvalidIndex;
684         return (unsigned)reg;
685     }
686 
687     static GPRReg toArgumentRegister(unsigned index)
688     {
689         ASSERT(index &lt; numberOfArgumentRegisters);
690         return toRegister(index);
691     }
692 
693     static const char* debugName(GPRReg reg)
694     {
695         ASSERT(reg != InvalidGPRReg);
696         return MacroAssembler::gprName(reg);
697     }
698 
699     static const std::array&lt;GPRReg, 4&gt;&amp; reservedRegisters()
700     {
701         static const std::array&lt;GPRReg, 4&gt; reservedRegisters { {
702             dataTempRegister,
703             memoryTempRegister,
<a name="32" id="anc32"></a><span class="line-modified">704             numberTagRegister,</span>
<span class="line-modified">705             notCellMaskRegister,</span>
706         } };
707         return reservedRegisters;
708     }
709 
<a name="33" id="anc33"></a><span class="line-modified">710     static constexpr unsigned InvalidIndex = 0xffffffff;</span>
711 };
712 
713 #endif // CPU(ARM64)
714 
715 #if CPU(MIPS)
716 #define NUMBER_OF_ARGUMENT_REGISTERS 4u
<a name="34" id="anc34"></a><span class="line-modified">717 #define NUMBER_OF_CALLEE_SAVES_REGISTERS 2u</span>
718 
719 class GPRInfo {
720 public:
721     typedef GPRReg RegisterType;
<a name="35" id="anc35"></a><span class="line-modified">722     static constexpr unsigned numberOfRegisters = 11;</span>
<span class="line-modified">723     static constexpr unsigned numberOfArgumentRegisters = NUMBER_OF_ARGUMENT_REGISTERS;</span>
724 
725     // regT0 must be v0 for returning a 32-bit value.
726     // regT1 must be v1 for returning a pair of 32-bit value.
727 
728     // Temporary registers.
<a name="36" id="anc36"></a><span class="line-modified">729     static constexpr GPRReg regT0 = MIPSRegisters::v0;</span>
<span class="line-modified">730     static constexpr GPRReg regT1 = MIPSRegisters::v1;</span>
<span class="line-modified">731     static constexpr GPRReg regT2 = MIPSRegisters::t2;</span>
<span class="line-modified">732     static constexpr GPRReg regT3 = MIPSRegisters::t3;</span>
<span class="line-modified">733     static constexpr GPRReg regT4 = MIPSRegisters::t4;</span>
<span class="line-modified">734     static constexpr GPRReg regT5 = MIPSRegisters::t5;</span>
<span class="line-modified">735     static constexpr GPRReg regT6 = MIPSRegisters::t6;</span>
<span class="line-modified">736     static constexpr GPRReg regT7 = MIPSRegisters::a0;</span>
<span class="line-modified">737     static constexpr GPRReg regT8 = MIPSRegisters::a1;</span>
<span class="line-modified">738     static constexpr GPRReg regT9 = MIPSRegisters::a2;</span>
<span class="line-modified">739     static constexpr GPRReg regT10 = MIPSRegisters::a3;</span>
740     // These registers match the baseline JIT.
<a name="37" id="anc37"></a><span class="line-modified">741     static constexpr GPRReg callFrameRegister = MIPSRegisters::fp;</span>
742     // These constants provide the names for the general purpose argument &amp; return value registers.
<a name="38" id="anc38"></a><span class="line-modified">743     static constexpr GPRReg argumentGPR0 = MIPSRegisters::a0;</span>
<span class="line-modified">744     static constexpr GPRReg argumentGPR1 = MIPSRegisters::a1;</span>
<span class="line-modified">745     static constexpr GPRReg argumentGPR2 = MIPSRegisters::a2;</span>
<span class="line-modified">746     static constexpr GPRReg argumentGPR3 = MIPSRegisters::a3;</span>
<span class="line-modified">747     static constexpr GPRReg nonArgGPR0 = regT4;</span>
<span class="line-modified">748     static constexpr GPRReg returnValueGPR = regT0;</span>
<span class="line-modified">749     static constexpr GPRReg returnValueGPR2 = regT1;</span>
<span class="line-modified">750     static constexpr GPRReg nonPreservedNonReturnGPR = regT2;</span>
<span class="line-modified">751     static constexpr GPRReg regCS0 = MIPSRegisters::s0;</span>
<span class="line-added">752     static constexpr GPRReg regCS1 = MIPSRegisters::s1;</span>
753 
754     static GPRReg toRegister(unsigned index)
755     {
756         ASSERT(index &lt; numberOfRegisters);
757         static const GPRReg registerForIndex[numberOfRegisters] = { regT0, regT1, regT2, regT3, regT4, regT5, regT6, regT7, regT8, regT9, regT10 };
758         return registerForIndex[index];
759     }
760 
761     static GPRReg toArgumentRegister(unsigned index)
762     {
763         ASSERT(index &lt; numberOfArgumentRegisters);
764         static const GPRReg registerForIndex[numberOfArgumentRegisters] = { argumentGPR0, argumentGPR1, argumentGPR2, argumentGPR3 };
765         return registerForIndex[index];
766     }
767 
768     static unsigned toIndex(GPRReg reg)
769     {
770         ASSERT(reg != InvalidGPRReg);
771         ASSERT(reg &lt; 32);
772         static const unsigned indexForRegister[32] = {
773             InvalidIndex, InvalidIndex, 0, 1, 7, 8, 9, 10,
774             InvalidIndex, InvalidIndex, 2, 3, 4, 5, 6, InvalidIndex,
775             InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex,
776             InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex, InvalidIndex
777         };
778         unsigned result = indexForRegister[reg];
779         return result;
780     }
781 
782     static const char* debugName(GPRReg reg)
783     {
784         ASSERT(reg != InvalidGPRReg);
785         return MacroAssembler::gprName(reg);
786     }
787 
<a name="39" id="anc39"></a><span class="line-modified">788     static constexpr unsigned InvalidIndex = 0xffffffff;</span>
789 };
790 
791 #endif // CPU(MIPS)
792 
793 // The baseline JIT uses &quot;accumulator&quot; style execution with regT0 (for 64-bit)
794 // and regT0 + regT1 (for 32-bit) serving as the accumulator register(s) for
795 // passing results of one opcode to the next. Hence:
796 COMPILE_ASSERT(GPRInfo::regT0 == GPRInfo::returnValueGPR, regT0_must_equal_returnValueGPR);
797 #if USE(JSVALUE32_64)
798 COMPILE_ASSERT(GPRInfo::regT1 == GPRInfo::returnValueGPR2, regT1_must_equal_returnValueGPR2);
799 #endif
800 
801 inline GPRReg extractResult(GPRReg result) { return result; }
802 #if USE(JSVALUE64)
803 inline GPRReg extractResult(JSValueRegs result) { return result.gpr(); }
804 #else
805 inline JSValueRegs extractResult(JSValueRegs result) { return result; }
806 #endif
807 inline NoResultTag extractResult(NoResultTag) { return NoResult; }
808 
809 // We use this hack to get the GPRInfo from the GPRReg type in templates because our code is bad and we should feel bad..
810 constexpr GPRInfo toInfoFromReg(GPRReg) { return GPRInfo(); }
811 
812 #endif // ENABLE(ASSEMBLER)
813 
814 } // namespace JSC
815 
816 namespace WTF {
817 
818 inline void printInternal(PrintStream&amp; out, JSC::GPRReg reg)
819 {
820 #if ENABLE(ASSEMBLER)
821     out.print(&quot;%&quot;, JSC::GPRInfo::debugName(reg));
822 #else
823     out.printf(&quot;%%r%d&quot;, reg);
824 #endif
825 }
826 
827 } // namespace WTF
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
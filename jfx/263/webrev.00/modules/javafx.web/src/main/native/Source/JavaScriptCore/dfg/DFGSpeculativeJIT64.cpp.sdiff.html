<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStackLayoutPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGSpeculativeJIT.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;AtomicsObject.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGDoesGC.h&quot;
  37 #include &quot;DFGOperations.h&quot;
  38 #include &quot;DFGSlowPathGenerator.h&quot;

  39 #include &quot;DirectArguments.h&quot;
  40 #include &quot;GetterSetter.h&quot;
  41 #include &quot;HasOwnPropertyCache.h&quot;
  42 #include &quot;JSCInlines.h&quot;
  43 #include &quot;JSLexicalEnvironment.h&quot;
  44 #include &quot;JSMap.h&quot;
  45 #include &quot;JSPropertyNameEnumerator.h&quot;
  46 #include &quot;JSSet.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;SetupVarargsFrame.h&quot;
  49 #include &quot;SpillRegistersMode.h&quot;
  50 #include &quot;StringPrototype.h&quot;
  51 #include &quot;SuperSampler.h&quot;
  52 #include &quot;Watchdog.h&quot;
  53 
  54 namespace JSC { namespace DFG {
  55 
  56 #if USE(JSVALUE64)
  57 
  58 void SpeculativeJIT::boxInt52(GPRReg sourceGPR, GPRReg targetGPR, DataFormat format)
</pre>
<hr />
<pre>
  84 GPRReg SpeculativeJIT::fillJSValue(Edge edge)
  85 {
  86     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  87     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  88 
  89     switch (info.registerFormat()) {
  90     case DataFormatNone: {
  91         GPRReg gpr = allocate();
  92 
  93         if (edge-&gt;hasConstant()) {
  94             JSValue jsValue = edge-&gt;asJSValue();
  95             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
  96             info.fillJSValue(*m_stream, gpr, DataFormatJS);
  97             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
  98         } else {
  99             DataFormat spillFormat = info.spillFormat();
 100             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 101             switch (spillFormat) {
 102             case DataFormatInt32: {
 103                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
<span class="line-modified"> 104                 m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);</span>
 105                 spillFormat = DataFormatJSInt32;
 106                 break;
 107             }
 108 
 109             default:
 110                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 111                 DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat &amp; DataFormatJS, spillFormat);
 112                 break;
 113             }
 114             info.fillJSValue(*m_stream, gpr, spillFormat);
 115         }
 116         return gpr;
 117     }
 118 
 119     case DataFormatInt32: {
 120         GPRReg gpr = info.gpr();
 121         // If the register has already been locked we need to take a copy.
 122         // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 123         if (m_gprs.isLocked(gpr)) {
 124             GPRReg result = allocate();
<span class="line-modified"> 125             m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr, result);</span>
 126             return result;
 127         }
 128         m_gprs.lock(gpr);
<span class="line-modified"> 129         m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);</span>
 130         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 131         return gpr;
 132     }
 133 
 134     case DataFormatCell:
 135         // No retag required on JSVALUE64!
 136     case DataFormatJS:
 137     case DataFormatJSInt32:
 138     case DataFormatJSDouble:
 139     case DataFormatJSCell:
 140     case DataFormatJSBoolean: {
 141         GPRReg gpr = info.gpr();
 142         m_gprs.lock(gpr);
 143         return gpr;
 144     }
 145 
 146     case DataFormatBoolean:
 147     case DataFormatStorage:
 148     case DataFormatDouble:
 149     case DataFormatInt52:
</pre>
<hr />
<pre>
 165 {
 166     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 167     RegisterSet usedRegisters = this-&gt;usedRegisters();
 168     if (spillMode == DontSpill) {
 169         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 170         usedRegisters.set(baseGPR, false);
 171         usedRegisters.set(resultGPR, false);
 172     }
 173     JITGetByIdGenerator gen(
 174         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 175         JSValueRegs(baseGPR), JSValueRegs(resultGPR), type);
 176     gen.generateFastPath(m_jit);
 177 
 178     JITCompiler::JumpList slowCases;
 179     slowCases.append(slowPathTarget);
 180     slowCases.append(gen.slowPathJump());
 181 
 182     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 183         slowCases, this, appropriateOptimizingGetByIdFunction(type),
 184         spillMode, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 185         resultGPR, gen.stubInfo(), baseGPR, identifierUID(identifierNumber));</span>
 186 
 187     m_jit.addGetById(gen, slowPath.get());
 188     addSlowPathGenerator(WTFMove(slowPath));
 189 }
 190 
 191 void SpeculativeJIT::cachedGetByIdWithThis(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 192 {
 193     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 194     RegisterSet usedRegisters = this-&gt;usedRegisters();
 195     // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 196     usedRegisters.set(baseGPR, false);
 197     usedRegisters.set(thisGPR, false);
 198     usedRegisters.set(resultGPR, false);
 199 
 200     JITGetByIdWithThisGenerator gen(
 201         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="line-modified"> 202         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR), AccessType::GetWithThis);</span>
 203     gen.generateFastPath(m_jit);
 204 
 205     JITCompiler::JumpList slowCases;
 206     slowCases.append(slowPathTarget);
 207     slowCases.append(gen.slowPathJump());
 208 
 209     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 210         slowCases, this, operationGetByIdWithThisOptimize,
 211         DontSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 212         resultGPR, gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));</span>
 213 
 214     m_jit.addGetByIdWithThis(gen, slowPath.get());
 215     addSlowPathGenerator(WTFMove(slowPath));
 216 }
 217 
 218 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 219 {
 220     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 221     GPRReg argGPR = arg.gpr();
 222 
 223     GPRTemporary result(this);
 224     GPRReg resultGPR = result.gpr();
 225 
 226     m_jit.move(TrustedImm32(0), resultGPR);
 227 
 228     JITCompiler::JumpList done;
 229     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 230         if (!isKnownNotCell(operand.node()))
 231             done.append(m_jit.branchIfCell(JSValueRegs(argGPR)));
 232     } else {
</pre>
<hr />
<pre>
 240 
 241         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
 242             JITCompiler::Zero,
 243             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 244             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 245         done.append(isNotMasqueradesAsUndefined);
 246 
 247         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 248         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 249         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 250         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 251         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 252         m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultGPR);
 253         done.append(m_jit.jump());
 254         if (!isKnownCell(operand.node()))
 255             notCell.link(&amp;m_jit);
 256     }
 257 
 258     if (!isKnownNotOther(operand.node())) {
 259         m_jit.move(argGPR, resultGPR);
<span class="line-modified"> 260         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="line-modified"> 261         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(ValueNull), resultGPR);</span>
 262     }
 263 
 264     done.link(&amp;m_jit);
 265 
<span class="line-modified"> 266     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
 267     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
 268 }
 269 
 270 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 271 {
 272     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 273     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 274 
 275     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 276     GPRReg argGPR = arg.gpr();
 277 
 278     GPRTemporary result(this, Reuse, arg);
 279     GPRReg resultGPR = result.gpr();
 280 
 281     // First, handle the case where &quot;operand&quot; is a cell.
 282     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 283         if (!isKnownNotCell(operand.node())) {
 284             JITCompiler::Jump isCell = m_jit.branchIfCell(JSValueRegs(argGPR));
 285             addBranch(isCell, notTaken);
 286         }
</pre>
<hr />
<pre>
 302         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 303         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 304         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 305         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, taken);
 306 
 307         if (!isKnownCell(operand.node())) {
 308             jump(notTaken, ForceJump);
 309             notCell.link(&amp;m_jit);
 310         }
 311     }
 312 
 313     if (isKnownNotOther(operand.node()))
 314         jump(notTaken);
 315     else {
 316         JITCompiler::RelationalCondition condition = JITCompiler::Equal;
 317         if (taken == nextBlock()) {
 318             condition = JITCompiler::NotEqual;
 319             std::swap(taken, notTaken);
 320         }
 321         m_jit.move(argGPR, resultGPR);
<span class="line-modified"> 322         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="line-modified"> 323         branch64(condition, resultGPR, JITCompiler::TrustedImm64(ValueNull), taken);</span>
 324         jump(notTaken);
 325     }
 326 }
 327 
 328 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 329 {
 330     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 331     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 332 
 333     // The branch instruction will branch to the taken block.
 334     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 335     if (taken == nextBlock()) {
 336         invert = !invert;
 337         BasicBlock* tmp = taken;
 338         taken = notTaken;
 339         notTaken = tmp;
 340     }
 341 
 342     JSValueOperand arg1(this, node-&gt;child1());
 343     JSValueOperand arg2(this, node-&gt;child2());
 344     GPRReg arg1GPR = arg1.gpr();
 345     GPRReg arg2GPR = arg2.gpr();
 346 
 347     GPRTemporary result(this);
 348     GPRReg resultGPR = result.gpr();
 349 
 350     arg1.use();
 351     arg2.use();
 352 
 353     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 354         // see if we get lucky: if the arguments are cells and they reference the same
 355         // cell, then they must be strictly equal.
 356         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 357 
 358         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 359         callOperation(operationCompareStrictEqCell, resultGPR, arg1GPR, arg2GPR);</span>
 360         silentFillAllRegisters();
 361         m_jit.exceptionCheck();
 362 
 363         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 364     } else {
 365         m_jit.or64(arg1GPR, arg2GPR, resultGPR);
 366 
 367         JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 368 
 369         JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1GPR);
 370         JITCompiler::Jump leftDouble = m_jit.branchIfNumber(arg1GPR);
 371         leftOK.link(&amp;m_jit);
 372         JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2GPR);
 373         JITCompiler::Jump rightDouble = m_jit.branchIfNumber(arg2GPR);
 374         rightOK.link(&amp;m_jit);
 375 
 376         branch64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1GPR, arg2GPR, taken);
 377         jump(notTaken, ForceJump);
 378 
 379         twoCellsCase.link(&amp;m_jit);
 380         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 381 
 382         leftDouble.link(&amp;m_jit);
 383         rightDouble.link(&amp;m_jit);
 384 
 385         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 386         callOperation(operationCompareStrictEq, resultGPR, arg1GPR, arg2GPR);</span>
 387         silentFillAllRegisters();
 388         m_jit.exceptionCheck();
 389 
 390         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 391     }
 392 
 393     jump(notTaken);
 394 }
 395 
 396 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 397 {
 398     JSValueOperand arg1(this, node-&gt;child1());
 399     JSValueOperand arg2(this, node-&gt;child2());
 400     JSValueRegs arg1Regs = arg1.jsValueRegs();
 401     JSValueRegs arg2Regs = arg2.jsValueRegs();
 402 
 403     GPRTemporary result(this);
 404     GPRReg resultGPR = result.gpr();
 405 
 406     arg1.use();
 407     arg2.use();
 408 
 409     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 410         // see if we get lucky: if the arguments are cells and they reference the same
 411         // cell, then they must be strictly equal.
 412         // FIXME: this should flush registers instead of silent spill/fill.
 413         JITCompiler::Jump notEqualCase = m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr());
 414 
 415         m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 416 
 417         JITCompiler::Jump done = m_jit.jump();
 418 
 419         notEqualCase.link(&amp;m_jit);
 420 
 421         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 422         callOperation(operationCompareStrictEqCell, resultGPR, arg1Regs, arg2Regs);</span>
 423         silentFillAllRegisters();
 424         m_jit.exceptionCheck();
 425 
 426         done.link(&amp;m_jit);
 427         unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 428         return;
 429     }
 430 
 431     m_jit.or64(arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 432 
 433     JITCompiler::JumpList slowPathCases;
 434 
 435     JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 436 
 437     JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1Regs);
 438     slowPathCases.append(m_jit.branchIfNumber(arg1Regs, InvalidGPRReg));
 439     leftOK.link(&amp;m_jit);
 440     JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2Regs);
 441     slowPathCases.append(m_jit.branchIfNumber(arg2Regs, InvalidGPRReg));
 442     rightOK.link(&amp;m_jit);
 443 
 444     m_jit.compare64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 445 
 446     JITCompiler::Jump done = m_jit.jump();
 447 
 448     twoCellsCase.link(&amp;m_jit);
 449     slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
 450 
 451     m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 452 
<span class="line-modified"> 453     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, arg1Regs, arg2Regs));</span>
 454 
 455     done.link(&amp;m_jit);
 456 
 457     unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 458 }
 459 
 460 void SpeculativeJIT::emitCall(Node* node)
 461 {
 462     CallLinkInfo::CallType callType;
 463     bool isVarargs = false;
 464     bool isForwardVarargs = false;
 465     bool isTail = false;
 466     bool isEmulatedTail = false;
 467     bool isDirect = false;
 468     switch (node-&gt;op()) {
 469     case Call:
 470     case CallEval:
 471         callType = CallLinkInfo::Call;
 472         break;
 473     case TailCall:
</pre>
<hr />
<pre>
 526         isDirect = true;
 527         break;
 528     case DirectTailCall:
 529         callType = CallLinkInfo::DirectTailCall;
 530         isTail = true;
 531         isDirect = true;
 532         break;
 533     case DirectTailCallInlinedCaller:
 534         callType = CallLinkInfo::DirectCall;
 535         isEmulatedTail = true;
 536         isDirect = true;
 537         break;
 538     default:
 539         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 540         break;
 541     }
 542 
 543     GPRReg calleeGPR = InvalidGPRReg;
 544     CallFrameShuffleData shuffleData;
 545 

 546     ExecutableBase* executable = nullptr;
 547     FunctionExecutable* functionExecutable = nullptr;
 548     if (isDirect) {
 549         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 550         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 551     }
 552 
 553     unsigned numPassedArgs = 0;
 554     unsigned numAllocatedArgs = 0;
 555 
 556     // Gotta load the arguments somehow. Varargs is trickier.
 557     if (isVarargs || isForwardVarargs) {
 558         RELEASE_ASSERT(!isDirect);
 559         CallVarargsData* data = node-&gt;callVarargsData();
 560 
 561         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 562 
 563         if (isForwardVarargs) {
 564             flushRegisters();
 565             if (node-&gt;child3())
</pre>
<hr />
<pre>
 567 
 568             GPRReg scratchGPR1;
 569             GPRReg scratchGPR2;
 570             GPRReg scratchGPR3;
 571 
 572             scratchGPR1 = JITCompiler::selectScratchGPR();
 573             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 574             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 575 
 576             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 577             JITCompiler::JumpList slowCase;
 578             InlineCallFrame* inlineCallFrame;
 579             if (node-&gt;child3())
 580                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 581             else
 582                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 583             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 584             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 585             JITCompiler::Jump done = m_jit.jump();
 586             slowCase.link(&amp;m_jit);
<span class="line-modified"> 587             callOperation(operationThrowStackOverflowForVarargs);</span>
 588             m_jit.exceptionCheck();
 589             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 590             done.link(&amp;m_jit);
 591         } else {
 592             GPRReg argumentsGPR;
 593             GPRReg scratchGPR1;
 594             GPRReg scratchGPR2;
 595             GPRReg scratchGPR3;
 596 
 597             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 598                 if (reservedGPR != InvalidGPRReg)
 599                     lock(reservedGPR);
 600                 JSValueOperand arguments(this, node-&gt;child3());
 601                 argumentsGPR = arguments.gpr();
 602                 if (reservedGPR != InvalidGPRReg)
 603                     unlock(reservedGPR);
 604                 flushRegisters();
 605 
 606                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsGPR, reservedGPR);
 607                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, reservedGPR);
 608                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, scratchGPR2, reservedGPR);
 609             };
 610 
 611             loadArgumentsGPR(InvalidGPRReg);
 612 
 613             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 614 
 615             // Right now, arguments is in argumentsGPR and the register file is flushed.
<span class="line-modified"> 616             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
 617             m_jit.exceptionCheck();
 618 
 619             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 620             // Reconstruct the arguments operand while preserving the callee frame.
 621             loadArgumentsGPR(GPRInfo::returnValueGPR);
 622             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 623             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 624             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 625 
<span class="line-modified"> 626             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
 627             m_jit.exceptionCheck();
 628             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 629         }
 630 
 631         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 632 
 633         // We don&#39;t need the arguments array anymore.
 634         if (isVarargs)
 635             use(node-&gt;child3());
 636 
 637         // Now set up the &quot;this&quot; argument.
 638         JSValueOperand thisArgument(this, node-&gt;child2());
 639         GPRReg thisArgumentGPR = thisArgument.gpr();
 640         thisArgument.use();
 641 
 642         m_jit.store64(thisArgumentGPR, JITCompiler::calleeArgumentSlot(0));
 643     } else {
 644         // The call instruction&#39;s first child is the function; the subsequent children are the
 645         // arguments.
 646         numPassedArgs = node-&gt;numChildren() - 1;
</pre>
<hr />
<pre>
 655             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 656                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 657 
 658                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 659                 // do this adjustment now since we will have already emitted code that relied on the
 660                 // value of m_parameterSlots.
 661                 DFG_ASSERT(
 662                     m_jit.graph(), node,
 663                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 664                     &lt;= m_jit.graph().m_parameterSlots);
 665             }
 666         }
 667 
 668         if (isTail) {
 669             Edge calleeEdge = m_jit.graph().child(node, 0);
 670             JSValueOperand callee(this, calleeEdge);
 671             calleeGPR = callee.gpr();
 672             if (!isDirect)
 673                 callee.use();
 674 
<span class="line-modified"> 675             shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;</span>
 676             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 677             shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
 678             shuffleData.args.resize(numAllocatedArgs);
 679             shuffleData.numPassedArgs = numPassedArgs;
 680 
 681             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 682                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 683                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 684                 if (!isDirect)
 685                     use(argEdge);
 686                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 687             }
 688 
 689             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 690                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 691 
 692             shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
 693         } else {
<span class="line-modified"> 694             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCount));</span>
 695 
 696             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 697                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 698                 JSValueOperand arg(this, argEdge);
 699                 GPRReg argGPR = arg.gpr();
 700                 use(argEdge);
 701 
 702                 m_jit.store64(argGPR, JITCompiler::calleeArgumentSlot(i));
 703             }
 704 
 705             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 706                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 707         }
 708     }
 709 
 710     if (!isTail || isVarargs || isForwardVarargs) {
 711         Edge calleeEdge = m_jit.graph().child(node, 0);
 712         JSValueOperand callee(this, calleeEdge);
 713         calleeGPR = callee.gpr();
 714         callee.use();
</pre>
<hr />
<pre>
 738         // mismatch (the callframe is slided) and tail calls.
 739         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 740     };
 741 
 742     CallLinkInfo* callLinkInfo = m_jit.codeBlock()-&gt;addCallLinkInfo();
 743     callLinkInfo-&gt;setUpCall(callType, m_currentNode-&gt;origin.semantic, calleeGPR);
 744 
 745     if (node-&gt;op() == CallEval) {
 746         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 747         // which we have created a prototypical eval call frame. This means that we have to
 748         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 749         // register file to ourselves.
 750 
 751         m_jit.emitStoreCallSiteIndex(callSite);
 752         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 753         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 754 
 755         // Now we need to make room for:
 756         // - The caller frame and PC of a call to operationCallEval.
 757         // - Potentially two arguments on the stack.
<span class="line-modified"> 758         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;</span>
 759         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 760         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="line-modified"> 761         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);</span>
 762         prepareForExternalCall();
 763         m_jit.appendCall(operationCallEval);
 764         m_jit.exceptionCheck();
 765         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
 766 
 767         // This is the part where we meant to make a normal call. Oops.
 768         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 769         m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<span class="line-modified"> 770         m_jit.emitDumbVirtualCall(vm(), callLinkInfo);</span>
 771 
 772         done.link(&amp;m_jit);
 773         setResultAndResetStack();
 774         return;
 775     }
 776 
 777     if (isDirect) {
 778         callLinkInfo-&gt;setExecutableDuringCompilation(executable);
<span class="line-modified"> 779         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);</span>
 780 
 781         if (isTail) {
 782             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 783 
 784             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 785             JITCompiler::Label mainPath = m_jit.label();
 786 
 787             m_jit.emitStoreCallSiteIndex(callSite);
 788 
 789             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 790             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 791 
 792             JITCompiler::Call call = m_jit.nearTailCall();
 793 
 794             JITCompiler::Label slowPath = m_jit.label();
 795             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 796 
 797             silentSpillAllRegisters(InvalidGPRReg);
 798             callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 799             silentFillAllRegisters();
</pre>
<hr />
<pre>
 845     }
 846 
 847     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 848 
 849     JITCompiler::Jump done = m_jit.jump();
 850 
 851     slowPath.link(&amp;m_jit);
 852 
 853     if (node-&gt;op() == TailCall) {
 854         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 855         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 856         callFrameShuffler.prepareForSlowPath();
 857     } else {
 858         m_jit.move(calleeGPR, GPRInfo::regT0); // Callee needs to be in regT0
 859 
 860         if (isTail)
 861             m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
 862     }
 863 
 864     m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2

 865     JITCompiler::Call slowCall = m_jit.nearCall();
 866 
 867     done.link(&amp;m_jit);
 868 
 869     if (isTail)
 870         m_jit.abortWithReason(JITDidReturnFromTailCall);
 871     else
 872         setResultAndResetStack();
 873 
 874     m_jit.addJSCall(fastCall, slowCall, targetToCheck, callLinkInfo);
 875 }
 876 
 877 // Clang should allow unreachable [[clang::fallthrough]] in template functions if any template expansion uses it
 878 // http://llvm.org/bugs/show_bug.cgi?id=18619
 879 IGNORE_WARNINGS_BEGIN(&quot;implicit-fallthrough&quot;)
 880 template&lt;bool strict&gt;
 881 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 882 {
 883     AbstractValue&amp; value = m_state.forNode(edge);
 884     SpeculatedType type = value.m_type;
</pre>
<hr />
<pre>
1188             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1189             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1190             info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1191             return gpr;
1192         }
1193 
1194         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1195         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1196 
1197         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1198         if (type &amp; ~SpecCellCheck)
1199             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1200         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1201         return gpr;
1202     }
1203 
1204     case DataFormatCell:
1205     case DataFormatJSCell: {
1206         GPRReg gpr = info.gpr();
1207         m_gprs.lock(gpr);
<span class="line-modified">1208         if (!ASSERT_DISABLED) {</span>
1209             MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
1210             m_jit.abortWithReason(DFGIsNotCell);
1211             checkCell.link(&amp;m_jit);
1212         }
1213         return gpr;
1214     }
1215 
1216     case DataFormatJS: {
1217         GPRReg gpr = info.gpr();
1218         m_gprs.lock(gpr);
1219         if (type &amp; ~SpecCellCheck)
1220             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1221         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1222         return gpr;
1223     }
1224 
1225     case DataFormatJSInt32:
1226     case DataFormatInt32:
1227     case DataFormatJSDouble:
1228     case DataFormatJSBoolean:
</pre>
<hr />
<pre>
1255     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1256     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1257 
1258     switch (info.registerFormat()) {
1259     case DataFormatNone: {
1260         GPRReg gpr = allocate();
1261 
1262         if (edge-&gt;hasConstant()) {
1263             JSValue jsValue = edge-&gt;asJSValue();
1264             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1265             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1266             info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1267             return gpr;
1268         }
1269         DFG_ASSERT(m_jit.graph(), m_currentNode, info.spillFormat() &amp; DataFormatJS, info.spillFormat());
1270         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1271         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1272 
1273         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1274         if (type &amp; ~SpecBoolean) {
<span class="line-modified">1275             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
1276             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="line-modified">1277             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
1278         }
1279         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1280         return gpr;
1281     }
1282 
1283     case DataFormatBoolean:
1284     case DataFormatJSBoolean: {
1285         GPRReg gpr = info.gpr();
1286         m_gprs.lock(gpr);
1287         return gpr;
1288     }
1289 
1290     case DataFormatJS: {
1291         GPRReg gpr = info.gpr();
1292         m_gprs.lock(gpr);
1293         if (type &amp; ~SpecBoolean) {
<span class="line-modified">1294             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
1295             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="line-modified">1296             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
1297         }
1298         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1299         return gpr;
1300     }
1301 
1302     case DataFormatJSInt32:
1303     case DataFormatInt32:
1304     case DataFormatJSDouble:
1305     case DataFormatJSCell:
1306     case DataFormatCell:
1307     case DataFormatDouble:
1308     case DataFormatStorage:
1309     case DataFormatInt52:
1310     case DataFormatStrictInt52:
1311         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1312 
1313     default:
1314         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1315         return InvalidGPRReg;
1316     }
1317 }
1318 
1319 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1320 {
1321     SpeculateCellOperand op1(this, objectChild);
1322     JSValueOperand op2(this, otherChild);
1323     GPRTemporary result(this);
1324 
1325     GPRReg op1GPR = op1.gpr();
1326     GPRReg op2GPR = op2.gpr();
1327     GPRReg resultGPR = result.gpr();
1328 
1329     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1330 
1331     // At this point we know that we can perform a straight-forward equality comparison on pointer
1332     // values because we are doing strict equality.
1333     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
<span class="line-modified">1334     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
1335     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1336 }
1337 
1338 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1339 {
1340     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1341     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1342 
1343     SpeculateCellOperand op1(this, objectChild);
1344     JSValueOperand op2(this, otherChild);
1345 
1346     GPRReg op1GPR = op1.gpr();
1347     GPRReg op2GPR = op2.gpr();
1348 
1349     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1350 
1351     if (taken == nextBlock()) {
1352         branchPtr(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1353         jump(taken);
1354     } else {
</pre>
<hr />
<pre>
1396             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1397         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1398             m_jit.branchTest8(
1399                 MacroAssembler::NonZero,
1400                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1401                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1402     }
1403 
1404     // At this point we know that we can perform a straight-forward equality comparison on pointer
1405     // values because both left and right are pointers to objects that have no special equality
1406     // protocols.
1407     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1408     MacroAssembler::Jump done = m_jit.jump();
1409 
1410     rightNotCell.link(&amp;m_jit);
1411 
1412     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1413     // prove that it is either null or undefined.
1414     if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
1415         m_jit.move(op2GPR, resultGPR);
<span class="line-modified">1416         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
1417 
1418         typeCheck(
1419             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
1420             m_jit.branch64(
1421                 MacroAssembler::NotEqual, resultGPR,
<span class="line-modified">1422                 MacroAssembler::TrustedImm64(ValueNull)));</span>
1423     }
1424     m_jit.move(TrustedImm32(0), result.gpr());
1425 
1426     done.link(&amp;m_jit);
<span class="line-modified">1427     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
1428     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1429 }
1430 
1431 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1432 {
1433     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1434     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1435 
1436     SpeculateCellOperand op1(this, leftChild);
1437     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1438     GPRTemporary result(this);
1439 
1440     GPRReg op1GPR = op1.gpr();
1441     GPRReg op2GPR = op2.gpr();
1442     GPRReg resultGPR = result.gpr();
1443 
1444     bool masqueradesAsUndefinedWatchpointValid =
1445         masqueradesAsUndefinedWatchpointIsStillValid();
1446 
1447     if (masqueradesAsUndefinedWatchpointValid) {
</pre>
<hr />
<pre>
1472             m_jit.branchTest8(
1473                 MacroAssembler::NonZero,
1474                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1475                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1476     }
1477 
1478     // At this point we know that we can perform a straight-forward equality comparison on pointer
1479     // values because both left and right are pointers to objects that have no special equality
1480     // protocols.
1481     branch64(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1482 
1483     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1484     // prove that it is either null or undefined.
1485     if (!needsTypeCheck(rightChild, SpecCellCheck | SpecOther))
1486         rightNotCell.link(&amp;m_jit);
1487     else {
1488         jump(notTaken, ForceJump);
1489 
1490         rightNotCell.link(&amp;m_jit);
1491         m_jit.move(op2GPR, resultGPR);
<span class="line-modified">1492         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
1493 
1494         typeCheck(
1495             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
1496                 MacroAssembler::NotEqual, resultGPR,
<span class="line-modified">1497                 MacroAssembler::TrustedImm64(ValueNull)));</span>
1498     }
1499 
1500     jump(notTaken);
1501 }
1502 
1503 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1504 {
1505     SpeculateCellOperand symbol(this, symbolEdge);
1506     JSValueOperand untyped(this, untypedEdge);
1507     GPRTemporary result(this, Reuse, symbol, untyped);
1508 
1509     GPRReg symbolGPR = symbol.gpr();
1510     GPRReg untypedGPR = untyped.gpr();
1511     GPRReg resultGPR = result.gpr();
1512 
1513     speculateSymbol(symbolEdge, symbolGPR);
1514 
1515     // At this point we know that we can perform a straight-forward equality comparison on pointer
1516     // values because we are doing strict equality.
1517     m_jit.compare64(MacroAssembler::Equal, symbolGPR, untypedGPR, resultGPR);
1518     unblessedBooleanResult(resultGPR, node);
1519 }
1520 
1521 void SpeculativeJIT::compileInt52Compare(Node* node, MacroAssembler::RelationalCondition condition)
1522 {
1523     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1524     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1525     GPRTemporary result(this, Reuse, op1, op2);
1526 
1527     m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
1528 
1529     // If we add a DataFormatBool, we should use it here.
<span class="line-modified">1530     m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
1531     jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
1532 }
1533 
1534 void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
1535 {
1536     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1537     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1538 
1539     // The branch instruction will branch to the taken block.
1540     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
1541     if (taken == nextBlock()) {
1542         condition = JITCompiler::invert(condition);
1543         BasicBlock* tmp = taken;
1544         taken = notTaken;
1545         notTaken = tmp;
1546     }
1547 
1548     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1549     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1550 
</pre>
<hr />
<pre>
1595             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1596     } else {
1597         DFG_TYPE_CHECK(
1598             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1599 
1600         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1601             m_jit.branchTest8(
1602                 MacroAssembler::Zero,
1603                 MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1604                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1605 
1606         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1607         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1608             m_jit.branchPtr(
1609                 MacroAssembler::Equal,
1610                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1611                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1612 
1613         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1614     }
<span class="line-modified">1615     m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
1616     MacroAssembler::Jump done = m_jit.jump();
1617 
1618     notCell.link(&amp;m_jit);
1619 
1620     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1621         m_jit.move(valueGPR, resultGPR);
<span class="line-modified">1622         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
1623         typeCheck(
1624             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1625                 MacroAssembler::NotEqual,
1626                 resultGPR,
<span class="line-modified">1627                 MacroAssembler::TrustedImm64(ValueNull)));</span>
1628     }
<span class="line-modified">1629     m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
1630 
1631     done.link(&amp;m_jit);
1632 
1633     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1634 }
1635 
1636 void SpeculativeJIT::compileLogicalNot(Node* node)
1637 {
1638     switch (node-&gt;child1().useKind()) {
1639     case ObjectOrOtherUse: {
1640         compileObjectOrOtherLogicalNot(node-&gt;child1());
1641         return;
1642     }
1643 
1644     case Int32Use: {
1645         SpeculateInt32Operand value(this, node-&gt;child1());
1646         GPRTemporary result(this, Reuse, value);
1647         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
<span class="line-modified">1648         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
1649         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1650         return;
1651     }
1652 
1653     case DoubleRepUse: {
1654         SpeculateDoubleOperand value(this, node-&gt;child1());
1655         FPRTemporary scratch(this);
1656         GPRTemporary result(this);
<span class="line-modified">1657         m_jit.move(TrustedImm32(ValueFalse), result.gpr());</span>
1658         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1659         m_jit.xor32(TrustedImm32(true), result.gpr());
1660         nonZero.link(&amp;m_jit);
1661         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1662         return;
1663     }
1664 
1665     case BooleanUse:
1666     case KnownBooleanUse: {
1667         if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1668             SpeculateBooleanOperand value(this, node-&gt;child1());
1669             GPRTemporary result(this, Reuse, value);
1670 
1671             m_jit.move(value.gpr(), result.gpr());
1672             m_jit.xor64(TrustedImm32(true), result.gpr());
1673 
1674             jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1675             return;
1676         }
1677 
1678         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1679         GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
1680 
1681         m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">1682         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
1683         typeCheck(
1684             JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
1685                 JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<span class="line-modified">1686         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueTrue)), result.gpr());</span>
1687 
1688         // If we add a DataFormatBool, we should use it here.
1689         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1690         return;
1691     }
1692 
1693     case UntypedUse: {
1694         JSValueOperand arg1(this, node-&gt;child1());
1695         GPRTemporary result(this);
1696 
1697         GPRReg arg1GPR = arg1.gpr();
1698         GPRReg resultGPR = result.gpr();
1699 
1700         FPRTemporary valueFPR(this);
1701         FPRTemporary tempFPR(this);
1702 
1703         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1704         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1705         Optional&lt;GPRTemporary&gt; scratch;
1706         GPRReg scratchGPR = InvalidGPRReg;
1707         if (shouldCheckMasqueradesAsUndefined) {
1708             scratch.emplace(this);
1709             scratchGPR = scratch-&gt;gpr();
1710         }
1711         bool negateResult = true;
1712         m_jit.emitConvertValueToBoolean(vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
<span class="line-modified">1713         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
1714         jsValueResult(resultGPR, node, DataFormatJSBoolean);
1715         return;
1716     }
1717     case StringUse:
1718         return compileStringZeroLength(node);
1719 
1720     case StringOrOtherUse:
1721         return compileLogicalNotStringOrOther(node);
1722 
1723     default:
1724         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
1725         break;
1726     }
1727 }
1728 
1729 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1730 {
1731     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1732     GPRTemporary scratch(this);
1733     GPRTemporary structure;
</pre>
<hr />
<pre>
1752         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1753             JITCompiler::Zero,
1754             MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1755             TrustedImm32(MasqueradesAsUndefined));
1756 
1757         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1758         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1759             m_jit.branchPtr(
1760                 MacroAssembler::Equal,
1761                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1762                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1763 
1764         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1765     }
1766     jump(taken, ForceJump);
1767 
1768     notCell.link(&amp;m_jit);
1769 
1770     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1771         m_jit.move(valueGPR, scratchGPR);
<span class="line-modified">1772         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), scratchGPR);</span>
1773         typeCheck(
1774             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
<span class="line-modified">1775                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(ValueNull)));</span>
1776     }
1777     jump(notTaken);
1778 
1779     noResult(m_currentNode);
1780 }
1781 
1782 void SpeculativeJIT::emitBranch(Node* node)
1783 {
1784     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1785     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1786 
1787     switch (node-&gt;child1().useKind()) {
1788     case ObjectOrOtherUse: {
1789         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1790         return;
1791     }
1792 
1793     case Int32Use:
1794     case DoubleRepUse: {
1795         if (node-&gt;child1().useKind() == Int32Use) {
</pre>
<hr />
<pre>
1854             value.use();
1855         } else {
1856             GPRTemporary result(this);
1857             FPRTemporary fprValue(this);
1858             FPRTemporary fprTemp(this);
1859             Optional&lt;GPRTemporary&gt; scratch;
1860 
1861             GPRReg scratchGPR = InvalidGPRReg;
1862             bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1863             if (shouldCheckMasqueradesAsUndefined) {
1864                 scratch.emplace(this);
1865                 scratchGPR = scratch-&gt;gpr();
1866             }
1867 
1868             GPRReg resultGPR = result.gpr();
1869             FPRReg valueFPR = fprValue.fpr();
1870             FPRReg tempFPR = fprTemp.fpr();
1871 
1872             if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
1873                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
<span class="line-modified">1874                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::tagTypeNumberRegister, taken);</span>
1875             }
1876 
1877             if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
1878                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1879                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1880             }
1881 
1882             value.use();
1883 
1884             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1885             auto truthy = m_jit.branchIfTruthy(vm(), JSValueRegs(valueGPR), resultGPR, scratchGPR, valueFPR, tempFPR, shouldCheckMasqueradesAsUndefined, globalObject);
1886             addBranch(truthy, taken);
1887             jump(notTaken);
1888         }
1889 
1890         noResult(node, UseChildrenCalledExplicitly);
1891         return;
1892     }
1893 
1894     default:
</pre>
<hr />
<pre>
1910 #endif
1911 
1912     switch (op) {
1913     case JSConstant:
1914     case DoubleConstant:
1915     case Int52Constant:
1916     case PhantomDirectArguments:
1917     case PhantomClonedArguments:
1918         initConstantInfo(node);
1919         break;
1920 
1921     case LazyJSConstant:
1922         compileLazyJSConstant(node);
1923         break;
1924 
1925     case Identity: {
1926         compileIdentity(node);
1927         break;
1928     }
1929 





1930     case GetLocal: {
<span class="line-modified">1931         AbstractValue&amp; value = m_state.operand(node-&gt;local());</span>
1932 
1933         // If the CFA is tracking this variable and it found that the variable
1934         // cannot have been assigned, then don&#39;t attempt to proceed.
1935         if (value.isClear()) {
1936             m_compileOkay = false;
1937             break;
1938         }
1939 
1940         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1941         case FlushedDouble: {
1942             FPRTemporary result(this);
1943             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1944             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1945             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1946             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1947             break;
1948         }
1949 
1950         case FlushedInt32: {
1951             GPRTemporary result(this);
</pre>
<hr />
<pre>
1982             if (isCellSpeculation(value.m_type))
1983                 format = DataFormatJSCell;
1984             else if (isBooleanSpeculation(value.m_type))
1985                 format = DataFormatJSBoolean;
1986             else
1987                 format = DataFormatJS;
1988 
1989             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), result.gpr(), format);
1990             break;
1991         }
1992         break;
1993     }
1994 
1995     case MovHint: {
1996         compileMovHint(m_currentNode);
1997         noResult(node);
1998         break;
1999     }
2000 
2001     case ZombieHint: {
<span class="line-modified">2002         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);</span>
2003         noResult(node);
2004         break;
2005     }
2006 
2007     case ExitOK: {
2008         noResult(node);
2009         break;
2010     }
2011 
2012     case SetLocal: {
2013         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
2014         case FlushedDouble: {
2015             SpeculateDoubleOperand value(this, node-&gt;child1());
2016             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2017             noResult(node);
2018             // Indicate that it&#39;s no longer necessary to retrieve the value of
2019             // this bytecode variable from registers or other locations in the stack,
2020             // but that it is stored as a double.
2021             recordSetLocal(DataFormatDouble);
2022             break;
</pre>
<hr />
<pre>
2087     case ArithBitNot:
2088         compileBitwiseNot(node);
2089         break;
2090 
2091     case ValueBitAnd:
2092     case ValueBitXor:
2093     case ValueBitOr:
2094         compileValueBitwiseOp(node);
2095         break;
2096 
2097     case ArithBitAnd:
2098     case ArithBitOr:
2099     case ArithBitXor:
2100         compileBitwiseOp(node);
2101         break;
2102 
2103     case ValueBitLShift:
2104         compileValueLShiftOp(node);
2105         break;
2106 
<span class="line-modified">2107     case BitRShift:</span>




2108     case ArithBitLShift:
2109     case BitURShift:
2110         compileShiftOp(node);
2111         break;
2112 
2113     case UInt32ToNumber: {
2114         compileUInt32ToNumber(node);
2115         break;
2116     }
2117 
2118     case DoubleAsInt32: {
2119         compileDoubleAsInt32(node);
2120         break;
2121     }
2122 
2123     case ValueToInt32: {
2124         compileValueToInt32(node);
2125         break;
2126     }
2127 
</pre>
<hr />
<pre>
2326         break;
2327 
2328     case CompareStrictEq:
2329         if (compileStrictEq(node))
2330             return;
2331         break;
2332 
2333     case CompareEqPtr:
2334         compileCompareEqPtr(node);
2335         break;
2336 
2337     case SameValue:
2338         compileSameValue(node);
2339         break;
2340 
2341     case StringCharCodeAt: {
2342         compileGetCharCodeAt(node);
2343         break;
2344     }
2345 





2346     case StringCharAt: {
2347         // Relies on StringCharAt node having same basic layout as GetByVal
2348         compileGetByValOnString(node);
2349         break;
2350     }
2351 
2352     case StringFromCharCode: {
2353         compileFromCharCode(node);
2354         break;
2355     }
2356 






2357     case CheckArray: {
2358         checkArray(node);
2359         break;
2360     }
2361 
2362     case Arrayify:
2363     case ArrayifyToStructure: {
2364         arrayify(node);
2365         break;
2366     }
2367 
2368     case GetByVal: {
2369         switch (node-&gt;arrayMode().type()) {
2370         case Array::AnyTypedArray:
2371         case Array::ForceExit:
2372         case Array::SelectUsingArguments:
2373         case Array::SelectUsingPredictions:
2374         case Array::Unprofiled:
2375             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2376             break;
2377         case Array::Undecided: {
2378             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2379             GPRTemporary result(this, Reuse, index);
2380             GPRReg indexGPR = index.gpr();
2381             GPRReg resultGPR = result.gpr();
2382 
2383             speculationCheck(OutOfBounds, JSValueRegs(), node,
2384                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2385 
2386             use(m_graph.varArgChild(node, 0));
2387             index.use();
2388 
<span class="line-modified">2389             m_jit.move(MacroAssembler::TrustedImm64(ValueUndefined), resultGPR);</span>
2390             jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
2391             break;
2392         }
2393         case Array::Generic: {
<span class="line-modified">2394             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">2395                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="line-modified">2396                     compileGetByValForObjectWithString(node);</span>
<span class="line-modified">2397                     break;</span>







2398                 }
2399 
<span class="line-modified">2400                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="line-modified">2401                     compileGetByValForObjectWithSymbol(node);</span>
<span class="line-modified">2402                     break;</span>
<span class="line-modified">2403                 }</span>








2404             }
<span class="line-modified">2405             JSValueOperand base(this, m_graph.varArgChild(node, 0));</span>
<span class="line-modified">2406             JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>





2407             GPRReg baseGPR = base.gpr();
2408             GPRReg propertyGPR = property.gpr();

2409 
<span class="line-modified">2410             flushRegisters();</span>
<span class="line-modified">2411             GPRFlushedCallResult result(this);</span>
<span class="line-modified">2412             callOperation(operationGetByVal, result.gpr(), baseGPR, propertyGPR);</span>
<span class="line-removed">2413             m_jit.exceptionCheck();</span>
2414 
<span class="line-modified">2415             jsValueResult(result.gpr(), node);</span>


























2416             break;
2417         }
2418         case Array::Int32:
2419         case Array::Contiguous: {
2420             if (node-&gt;arrayMode().isInBounds()) {
2421                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2422                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2423 
2424                 GPRReg propertyReg = property.gpr();
2425                 GPRReg storageReg = storage.gpr();
2426 
2427                 if (!m_compileOkay)
2428                     return;
2429 
2430                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2431 
2432                 GPRTemporary result(this);
2433 
2434                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.gpr());
2435                 if (node-&gt;arrayMode().isSaneChain()) {
</pre>
<hr />
<pre>
2453             GPRReg baseReg = base.gpr();
2454             GPRReg propertyReg = property.gpr();
2455             GPRReg storageReg = storage.gpr();
2456 
2457             if (!m_compileOkay)
2458                 return;
2459 
2460             GPRTemporary result(this);
2461             GPRReg resultReg = result.gpr();
2462 
2463             MacroAssembler::JumpList slowCases;
2464 
2465             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2466 
2467             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2468             slowCases.append(m_jit.branchIfEmpty(resultReg));
2469 
2470             addSlowPathGenerator(
2471                 slowPathCall(
2472                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2473                     result.gpr(), baseReg, propertyReg));</span>
2474 
2475             jsValueResult(resultReg, node);
2476             break;
2477         }
2478 
2479         case Array::Double: {
2480             if (node-&gt;arrayMode().isInBounds()) {
2481                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2482                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2483 
2484                 GPRReg propertyReg = property.gpr();
2485                 GPRReg storageReg = storage.gpr();
2486 
2487                 if (!m_compileOkay)
2488                     return;
2489 
2490                 FPRTemporary result(this);
2491                 FPRReg resultReg = result.fpr();
2492 
2493                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
</pre>
<hr />
<pre>
2509 
2510             if (!m_compileOkay)
2511                 return;
2512 
2513             GPRTemporary result(this);
2514             FPRTemporary temp(this);
2515             GPRReg resultReg = result.gpr();
2516             FPRReg tempReg = temp.fpr();
2517 
2518             MacroAssembler::JumpList slowCases;
2519 
2520             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2521 
2522             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2523             slowCases.append(m_jit.branchIfNaN(tempReg));
2524             boxDouble(tempReg, resultReg);
2525 
2526             addSlowPathGenerator(
2527                 slowPathCall(
2528                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2529                     result.gpr(), baseReg, propertyReg));</span>
2530 
2531             jsValueResult(resultReg, node);
2532             break;
2533         }
2534 
2535         case Array::ArrayStorage:
2536         case Array::SlowPutArrayStorage: {
2537             if (node-&gt;arrayMode().isInBounds()) {
2538                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2539                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2540 
2541                 GPRReg propertyReg = property.gpr();
2542                 GPRReg storageReg = storage.gpr();
2543 
2544                 if (!m_compileOkay)
2545                     return;
2546 
2547                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2548 
2549                 GPRTemporary result(this);
</pre>
<hr />
<pre>
2561             GPRReg baseReg = base.gpr();
2562             GPRReg propertyReg = property.gpr();
2563             GPRReg storageReg = storage.gpr();
2564 
2565             if (!m_compileOkay)
2566                 return;
2567 
2568             GPRTemporary result(this);
2569             GPRReg resultReg = result.gpr();
2570 
2571             MacroAssembler::JumpList slowCases;
2572 
2573             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2574 
2575             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), resultReg);
2576             slowCases.append(m_jit.branchIfEmpty(resultReg));
2577 
2578             addSlowPathGenerator(
2579                 slowPathCall(
2580                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2581                     result.gpr(), baseReg, propertyReg));</span>
2582 
2583             jsValueResult(resultReg, node);
2584             break;
2585         }
2586         case Array::String:
2587             compileGetByValOnString(node);
2588             break;
2589         case Array::DirectArguments:
2590             compileGetByValOnDirectArguments(node);
2591             break;
2592         case Array::ScopedArguments:
2593             compileGetByValOnScopedArguments(node);
2594             break;
2595         case Array::Int8Array:
2596         case Array::Int16Array:
2597         case Array::Int32Array:
2598         case Array::Uint8Array:
2599         case Array::Uint8ClampedArray:
2600         case Array::Uint16Array:
2601         case Array::Uint32Array:
</pre>
<hr />
<pre>
2639                     compilePutByValForCellWithString(node, child1, child2, child3);
2640                     alreadyHandled = true;
2641                     break;
2642                 }
2643 
2644                 if (child2.useKind() == SymbolUse) {
2645                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2646                     alreadyHandled = true;
2647                     break;
2648                 }
2649             }
2650 
2651             JSValueOperand arg1(this, child1);
2652             JSValueOperand arg2(this, child2);
2653             JSValueOperand arg3(this, child3);
2654             GPRReg arg1GPR = arg1.gpr();
2655             GPRReg arg2GPR = arg2.gpr();
2656             GPRReg arg3GPR = arg3.gpr();
2657             flushRegisters();
2658             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2659                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, arg1GPR, arg2GPR, arg3GPR);</span>
2660             else
<span class="line-modified">2661                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, arg1GPR, arg2GPR, arg3GPR);</span>
2662             m_jit.exceptionCheck();
2663 
2664             noResult(node);
2665             alreadyHandled = true;
2666             break;
2667         }
2668         default:
2669             break;
2670         }
2671 
2672         if (alreadyHandled)
2673             break;
2674 
2675         SpeculateCellOperand base(this, child1);
2676         SpeculateStrictInt32Operand property(this, child2);
2677 
2678         GPRReg baseReg = base.gpr();
2679         GPRReg propertyReg = property.gpr();
2680 
2681         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2726 
2727                 m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2728                 m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2729 
2730                 inBounds.link(&amp;m_jit);
2731             }
2732 
2733             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2734 
2735             base.use();
2736             property.use();
2737             value.use();
2738             storage.use();
2739 
2740             if (arrayMode.isOutOfBounds()) {
2741                 addSlowPathGenerator(slowPathCall(
2742                     slowCase, this,
2743                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2744                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2745                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="line-modified">2746                     NoResult, baseReg, propertyReg, valueReg));</span>
2747             }
2748 
2749             noResult(node, UseChildrenCalledExplicitly);
2750             break;
2751         }
2752 
2753         case Array::Double: {
2754             compileDoublePutByVal(node, base, property);
2755             break;
2756         }
2757 
2758         case Array::ArrayStorage:
2759         case Array::SlowPutArrayStorage: {
2760             JSValueOperand value(this, child3);
2761 
2762             GPRReg valueReg = value.gpr();
2763 
2764             if (!m_compileOkay)
2765                 return;
2766 
</pre>
<hr />
<pre>
2810 
2811                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2812                 }
2813                 notHoleValue.link(&amp;m_jit);
2814             }
2815 
2816             // Store the value to the array.
2817             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2818 
2819             base.use();
2820             property.use();
2821             value.use();
2822             storage.use();
2823 
2824             if (!slowCases.empty()) {
2825                 addSlowPathGenerator(slowPathCall(
2826                     slowCases, this,
2827                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2828                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2829                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="line-modified">2830                     NoResult, baseReg, propertyReg, valueReg));</span>
2831             }
2832 
2833             noResult(node, UseChildrenCalledExplicitly);
2834             break;
2835         }
2836 
2837         case Array::Int8Array:
2838         case Array::Int16Array:
2839         case Array::Int32Array:
2840         case Array::Uint8Array:
2841         case Array::Uint8ClampedArray:
2842         case Array::Uint16Array:
2843         case Array::Uint32Array:
2844         case Array::Float32Array:
2845         case Array::Float64Array: {
2846             TypedArrayType type = arrayMode.typedArrayType();
2847             if (isInt(type))
2848                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2849             else
2850                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
</pre>
<hr />
<pre>
2872     case AtomicsExchange:
2873     case AtomicsLoad:
2874     case AtomicsOr:
2875     case AtomicsStore:
2876     case AtomicsSub:
2877     case AtomicsXor: {
2878         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2879         Edge baseEdge = m_jit.graph().child(node, 0);
2880         Edge indexEdge = m_jit.graph().child(node, 1);
2881         Edge argEdges[maxNumExtraAtomicsArgs];
2882         for (unsigned i = numExtraArgs; i--;)
2883             argEdges[i] = m_jit.graph().child(node, 2 + i);
2884         Edge storageEdge = m_jit.graph().child(node, 2 + numExtraArgs);
2885 
2886         GPRReg baseGPR;
2887         GPRReg indexGPR;
2888         GPRReg argGPRs[2];
2889         GPRReg resultGPR;
2890 
2891         auto callSlowPath = [&amp;] () {

2892             switch (node-&gt;op()) {
2893             case AtomicsAdd:
<span class="line-modified">2894                 callOperation(operationAtomicsAdd, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2895                 break;
2896             case AtomicsAnd:
<span class="line-modified">2897                 callOperation(operationAtomicsAnd, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2898                 break;
2899             case AtomicsCompareExchange:
<span class="line-modified">2900                 callOperation(operationAtomicsCompareExchange, resultGPR, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);</span>
2901                 break;
2902             case AtomicsExchange:
<span class="line-modified">2903                 callOperation(operationAtomicsExchange, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2904                 break;
2905             case AtomicsLoad:
<span class="line-modified">2906                 callOperation(operationAtomicsLoad, resultGPR, baseGPR, indexGPR);</span>
2907                 break;
2908             case AtomicsOr:
<span class="line-modified">2909                 callOperation(operationAtomicsOr, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2910                 break;
2911             case AtomicsStore:
<span class="line-modified">2912                 callOperation(operationAtomicsStore, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2913                 break;
2914             case AtomicsSub:
<span class="line-modified">2915                 callOperation(operationAtomicsSub, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2916                 break;
2917             case AtomicsXor:
<span class="line-modified">2918                 callOperation(operationAtomicsXor, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
2919                 break;
2920             default:
2921                 RELEASE_ASSERT_NOT_REACHED();
2922                 break;
2923             }
2924         };
2925 
2926         if (!storageEdge) {
2927             // We are in generic mode!
2928             JSValueOperand base(this, baseEdge);
2929             JSValueOperand index(this, indexEdge);
2930             Optional&lt;JSValueOperand&gt; args[2];
2931             baseGPR = base.gpr();
2932             indexGPR = index.gpr();
2933             for (unsigned i = numExtraArgs; i--;) {
2934                 args[i].emplace(this, argEdges[i]);
2935                 argGPRs[i] = args[i]-&gt;gpr();
2936             }
2937 
2938             flushRegisters();
</pre>
<hr />
<pre>
3069             m_jit.boxInt32(indexGPR, JSValueRegs(indexGPR));
3070             for (unsigned i = numExtraArgs; i--;)
3071                 m_jit.boxInt32(argGPRs[i], JSValueRegs(argGPRs[i]));
3072             callSlowPath();
3073             silentFillAllRegisters();
3074             m_jit.exceptionCheck();
3075         }
3076 
3077         success.link(&amp;m_jit);
3078         setIntTypedArrayLoadResult(node, resultGPR, type);
3079         break;
3080     }
3081 
3082     case AtomicsIsLockFree: {
3083         if (node-&gt;child1().useKind() != Int32Use) {
3084             JSValueOperand operand(this, node-&gt;child1());
3085             GPRReg operandGPR = operand.gpr();
3086             flushRegisters();
3087             GPRFlushedCallResult result(this);
3088             GPRReg resultGPR = result.gpr();
<span class="line-modified">3089             callOperation(operationAtomicsIsLockFree, resultGPR, operandGPR);</span>
3090             m_jit.exceptionCheck();
3091             jsValueResult(resultGPR, node);
3092             break;
3093         }
3094 
3095         SpeculateInt32Operand operand(this, node-&gt;child1());
3096         GPRTemporary result(this);
3097         GPRReg operandGPR = operand.gpr();
3098         GPRReg resultGPR = result.gpr();
<span class="line-modified">3099         m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
3100         JITCompiler::JumpList done;
3101         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
3102         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
3103         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
<span class="line-modified">3104         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
3105         done.link(&amp;m_jit);
3106         jsValueResult(resultGPR, node);
3107         break;
3108     }
3109 
3110     case RegExpExec: {
3111         compileRegExpExec(node);
3112         break;
3113     }
3114 
3115     case RegExpExecNonGlobalOrSticky: {
3116         compileRegExpExecNonGlobalOrSticky(node);
3117         break;
3118     }
3119 
3120     case RegExpMatchFastGlobal: {
3121         compileRegExpMatchFastGlobal(node);
3122         break;
3123     }
3124 
</pre>
<hr />
<pre>
3205                     MacroAssembler::TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3206                 slowCase = m_jit.branchIfNaN(tempFPR);
3207                 boxDouble(tempFPR, valueGPR);
3208             } else {
3209                 m_jit.load64(
3210                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3211                     valueGPR);
3212                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3213                 // length and the new length.
3214                 m_jit.store64(
3215                 MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3216                 slowCase = m_jit.branchIfEmpty(valueGPR);
3217             }
3218 
3219             addSlowPathGenerator(
3220                 slowPathMove(
3221                     undefinedCase, this,
3222                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3223             addSlowPathGenerator(
3224                 slowPathCall(
<span class="line-modified">3225                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, baseGPR));</span>
3226 
3227             // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
3228             jsValueResult(valueGPR, node);
3229             break;
3230         }
3231 
3232         case Array::ArrayStorage: {
3233             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
3234 
3235             JITCompiler::Jump undefinedCase =
3236                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3237 
3238             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3239 
3240             JITCompiler::JumpList slowCases;
3241             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset())));
3242 
3243             m_jit.load64(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), valueGPR);
3244             slowCases.append(m_jit.branchIfEmpty(valueGPR));
3245 
3246             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
3247 
3248             m_jit.store64(MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight,  ArrayStorage::vectorOffset()));
3249             m_jit.sub32(MacroAssembler::TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
3250 
3251             addSlowPathGenerator(
3252                 slowPathMove(
3253                     undefinedCase, this,
3254                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3255 
3256             addSlowPathGenerator(
3257                 slowPathCall(
<span class="line-modified">3258                     slowCases, this, operationArrayPop, valueGPR, baseGPR));</span>
3259 
3260             jsValueResult(valueGPR, node);
3261             break;
3262         }
3263 
3264         default:
3265             CRASH();
3266             break;
3267         }
3268         break;
3269     }
3270 
3271     case DFG::Jump: {
3272         jump(node-&gt;targetBlock());
3273         noResult(node);
3274         break;
3275     }
3276 
3277     case Branch:
3278         emitBranch(node);
</pre>
<hr />
<pre>
3299         break;
3300     }
3301 
3302     case Throw: {
3303         compileThrow(node);
3304         break;
3305     }
3306 
3307     case ThrowStaticError: {
3308         compileThrowStaticError(node);
3309         break;
3310     }
3311 
3312     case BooleanToNumber: {
3313         switch (node-&gt;child1().useKind()) {
3314         case BooleanUse: {
3315             JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
3316             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3317 
3318             m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">3319             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
3320             DFG_TYPE_CHECK(
3321                 JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
3322                     JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
3323 
3324             int32Result(result.gpr(), node);
3325             break;
3326         }
3327 
3328         case UntypedUse: {
3329             JSValueOperand value(this, node-&gt;child1());
3330             GPRTemporary result(this);
3331 
3332             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3333                 m_jit.move(value.gpr(), result.gpr());
3334                 m_jit.and32(TrustedImm32(1), result.gpr());
3335                 int32Result(result.gpr(), node);
3336                 break;
3337             }
3338 
3339             m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">3340             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
3341             JITCompiler::Jump isBoolean = m_jit.branchTest64(
3342                 JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
3343             m_jit.move(value.gpr(), result.gpr());
3344             JITCompiler::Jump done = m_jit.jump();
3345             isBoolean.link(&amp;m_jit);
<span class="line-modified">3346             m_jit.or64(GPRInfo::tagTypeNumberRegister, result.gpr());</span>
3347             done.link(&amp;m_jit);
3348 
3349             jsValueResult(result.gpr(), node);
3350             break;
3351         }
3352 
3353         default:
3354             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
3355             break;
3356         }
3357         break;
3358     }
3359 
3360     case ToPrimitive: {
3361         compileToPrimitive(node);
3362         break;
3363     }
3364 





3365     case ToNumber: {
3366         JSValueOperand argument(this, node-&gt;child1());
3367         GPRTemporary result(this, Reuse, argument);
3368 
3369         GPRReg argumentGPR = argument.gpr();
3370         GPRReg resultGPR = result.gpr();
3371 
3372         argument.use();
3373 
3374         // We have several attempts to remove ToNumber. But ToNumber still exists.
3375         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3376         // Instead of the slow path generator, we emit callOperation here.
3377         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3378             flushRegisters();
<span class="line-modified">3379             callOperation(operationToNumber, resultGPR, argumentGPR);</span>
3380             m_jit.exceptionCheck();
3381         } else {
3382             MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
3383             m_jit.move(argumentGPR, resultGPR);
3384             MacroAssembler::Jump done = m_jit.jump();
3385 
3386             notNumber.link(&amp;m_jit);
3387             silentSpillAllRegisters(resultGPR);
<span class="line-modified">3388             callOperation(operationToNumber, resultGPR, argumentGPR);</span>
3389             silentFillAllRegisters();
3390             m_jit.exceptionCheck();
3391 
3392             done.link(&amp;m_jit);
3393         }
3394 
3395         jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
3396         break;
3397     }
3398 





3399     case ToString:
3400     case CallStringConstructor:
3401     case StringValueOf: {
3402         compileToStringOrCallStringConstructorOrStringValueOf(node);
3403         break;
3404     }
3405 
3406     case NewStringObject: {
3407         compileNewStringObject(node);
3408         break;
3409     }
3410 
3411     case NewSymbol: {
3412         compileNewSymbol(node);
3413         break;
3414     }
3415 
3416     case NewArray: {
3417         compileNewArray(node);
3418         break;
</pre>
<hr />
<pre>
3457     case ToThis: {
3458         compileToThis(node);
3459         break;
3460     }
3461 
3462     case ObjectCreate: {
3463         compileObjectCreate(node);
3464         break;
3465     }
3466 
3467     case ObjectKeys: {
3468         compileObjectKeys(node);
3469         break;
3470     }
3471 
3472     case CreateThis: {
3473         compileCreateThis(node);
3474         break;
3475     }
3476 















3477     case NewObject: {
3478         compileNewObject(node);
3479         break;
3480     }
3481 




















3482     case GetCallee: {
3483         compileGetCallee(node);
3484         break;
3485     }
3486 
3487     case SetCallee: {
3488         compileSetCallee(node);
3489         break;
3490     }
3491 
3492     case GetArgumentCountIncludingThis: {
3493         compileGetArgumentCountIncludingThis(node);
3494         break;
3495     }
3496 
3497     case SetArgumentCountIncludingThis:
3498         compileSetArgumentCountIncludingThis(node);
3499         break;
3500 
3501     case GetRestLength: {
</pre>
<hr />
<pre>
3511         compileSkipScope(node);
3512         break;
3513 
3514     case GetGlobalObject:
3515         compileGetGlobalObject(node);
3516         break;
3517 
3518     case GetGlobalThis:
3519         compileGetGlobalThis(node);
3520         break;
3521 
3522     case GetClosureVar: {
3523         compileGetClosureVar(node);
3524         break;
3525     }
3526     case PutClosureVar: {
3527         compilePutClosureVar(node);
3528         break;
3529     }
3530 










3531     case TryGetById: {
<span class="line-modified">3532         compileGetById(node, AccessType::TryGet);</span>
3533         break;
3534     }
3535 
3536     case GetByIdDirect: {
<span class="line-modified">3537         compileGetById(node, AccessType::GetDirect);</span>
3538         break;
3539     }
3540 
3541     case GetByIdDirectFlush: {
<span class="line-modified">3542         compileGetByIdFlush(node, AccessType::GetDirect);</span>
3543         break;
3544     }
3545 
3546     case GetById: {
<span class="line-modified">3547         compileGetById(node, AccessType::Get);</span>
3548         break;
3549     }
3550 
3551     case GetByIdFlush: {
<span class="line-modified">3552         compileGetByIdFlush(node, AccessType::Get);</span>
3553         break;
3554     }
3555 
3556     case GetByIdWithThis: {
3557         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3558             SpeculateCellOperand base(this, node-&gt;child1());
3559             GPRReg baseGPR = base.gpr();
3560             SpeculateCellOperand thisValue(this, node-&gt;child2());
3561             GPRReg thisValueGPR = thisValue.gpr();
3562 
3563             GPRFlushedCallResult result(this);
3564             GPRReg resultGPR = result.gpr();
3565 
3566             flushRegisters();
3567 
3568             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), JITCompiler::JumpList());
3569 
3570             jsValueResult(resultGPR, node);
3571 
3572         } else {
</pre>
<hr />
<pre>
3611         break;
3612     }
3613 
3614     case CheckNotEmpty: {
3615         compileCheckNotEmpty(node);
3616         break;
3617     }
3618 
3619     case AssertNotEmpty: {
3620         if (validationEnabled()) {
3621             JSValueOperand operand(this, node-&gt;child1());
3622             GPRReg input = operand.gpr();
3623             auto done = m_jit.branchIfNotEmpty(input);
3624             m_jit.breakpoint();
3625             done.link(&amp;m_jit);
3626         }
3627         noResult(node);
3628         break;
3629     }
3630 
<span class="line-modified">3631     case CheckStringIdent:</span>
<span class="line-modified">3632         compileCheckStringIdent(node);</span>
3633         break;
3634 
3635     case GetExecutable: {
3636         compileGetExecutable(node);
3637         break;
3638     }
3639 
3640     case CheckStructureOrEmpty: {
3641         SpeculateCellOperand cell(this, node-&gt;child1());
3642         GPRReg cellGPR = cell.gpr();
3643 
3644         GPRReg tempGPR = InvalidGPRReg;
3645         Optional&lt;GPRTemporary&gt; temp;
3646         if (node-&gt;structureSet().size() &gt; 1) {
3647             temp.emplace(this);
3648             tempGPR = temp-&gt;gpr();
3649         }
3650 
3651         MacroAssembler::Jump isEmpty;
3652         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
</pre>
<hr />
<pre>
3755         compilePutById(node);
3756         break;
3757     }
3758 
3759     case PutByIdWithThis: {
3760         compilePutByIdWithThis(node);
3761         break;
3762     }
3763 
3764     case PutByValWithThis: {
3765         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
3766         GPRReg baseGPR = base.gpr();
3767         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
3768         GPRReg thisValueGPR = thisValue.gpr();
3769         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
3770         GPRReg propertyGPR = property.gpr();
3771         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
3772         GPRReg valueGPR = value.gpr();
3773 
3774         flushRegisters();
<span class="line-modified">3775         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, NoResult, baseGPR, thisValueGPR, propertyGPR, valueGPR);</span>
3776         m_jit.exceptionCheck();
3777 
3778         noResult(node);
3779         break;
3780     }
3781 
3782     case PutByIdDirect: {
3783         compilePutByIdDirect(node);
3784         break;
3785     }
3786 
3787     case PutGetterById:
3788     case PutSetterById: {
3789         compilePutAccessorById(node);
3790         break;
3791     }
3792 
3793     case PutGetterSetterById: {
3794         compilePutGetterSetterById(node);
3795         break;
</pre>
<hr />
<pre>
3860     case OverridesHasInstance: {
3861         compileOverridesHasInstance(node);
3862         break;
3863     }
3864 
3865     case InstanceOf: {
3866         compileInstanceOf(node);
3867         break;
3868     }
3869 
3870     case InstanceOfCustom: {
3871         compileInstanceOfCustom(node);
3872         break;
3873     }
3874 
3875     case IsEmpty: {
3876         JSValueOperand value(this, node-&gt;child1());
3877         GPRTemporary result(this, Reuse, value);
3878 
3879         m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
<span class="line-modified">3880         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
3881 
3882         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3883         break;
3884     }
3885 
3886     case IsUndefined: {
3887         JSValueOperand value(this, node-&gt;child1());
3888         GPRTemporary result(this);
3889         GPRTemporary localGlobalObject(this);
3890         GPRTemporary remoteGlobalObject(this);
3891         GPRTemporary scratch(this);
3892 
3893         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
3894 
<span class="line-modified">3895         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(ValueUndefined), result.gpr());</span>
3896         JITCompiler::Jump done = m_jit.jump();
3897 
3898         isCell.link(&amp;m_jit);
3899         JITCompiler::Jump notMasqueradesAsUndefined;
3900         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
3901             m_jit.move(TrustedImm32(0), result.gpr());
3902             notMasqueradesAsUndefined = m_jit.jump();
3903         } else {
3904             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
3905                 JITCompiler::NonZero,
3906                 JITCompiler::Address(value.gpr(), JSCell::typeInfoFlagsOffset()),
3907                 TrustedImm32(MasqueradesAsUndefined));
3908             m_jit.move(TrustedImm32(0), result.gpr());
3909             notMasqueradesAsUndefined = m_jit.jump();
3910 
3911             isMasqueradesAsUndefined.link(&amp;m_jit);
3912             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
3913             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
3914             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
3915             m_jit.emitLoadStructure(vm(), value.gpr(), result.gpr(), scratch.gpr());
3916             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
3917             m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
3918         }
3919 
3920         notMasqueradesAsUndefined.link(&amp;m_jit);
3921         done.link(&amp;m_jit);
<span class="line-modified">3922         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
3923         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3924         break;
3925     }
3926 
3927     case IsUndefinedOrNull: {
3928         JSValueOperand value(this, node-&gt;child1());
3929         GPRTemporary result(this, Reuse, value);
3930 
3931         GPRReg valueGPR = value.gpr();
3932         GPRReg resultGPR = result.gpr();
3933 
3934         m_jit.move(valueGPR, resultGPR);
<span class="line-modified">3935         m_jit.and64(CCallHelpers::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="line-modified">3936         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(ValueNull), resultGPR);</span>
3937 
3938         unblessedBooleanResult(resultGPR, node);
3939         break;
3940     }
3941 
3942     case IsBoolean: {
3943         JSValueOperand value(this, node-&gt;child1());
3944         GPRTemporary result(this, Reuse, value);
3945 
3946         m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">3947         m_jit.xor64(JITCompiler::TrustedImm32(ValueFalse), result.gpr());</span>
3948         m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
<span class="line-modified">3949         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
3950         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3951         break;
3952     }
3953 
3954     case IsNumber: {
3955         JSValueOperand value(this, node-&gt;child1());
3956         GPRTemporary result(this, Reuse, value);
3957 
<span class="line-modified">3958         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::tagTypeNumberRegister, result.gpr());</span>
<span class="line-modified">3959         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
3960         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
3961         break;
3962     }
3963 
3964     case NumberIsInteger: {
3965         JSValueOperand value(this, node-&gt;child1());
3966         GPRTemporary result(this, Reuse, value);
3967 
3968         FPRTemporary temp1(this);
3969         FPRTemporary temp2(this);
3970 
3971         JSValueRegs valueRegs = JSValueRegs(value.gpr());
3972         GPRReg resultGPR = result.gpr();
3973 
3974         FPRReg tempFPR1 = temp1.fpr();
3975         FPRReg tempFPR2 = temp2.fpr();
3976 
3977         MacroAssembler::JumpList done;
3978 
3979         auto isInt32 = m_jit.branchIfInt32(valueRegs);
3980         auto notNumber = m_jit.branchIfNotDoubleKnownNotInt32(valueRegs);
3981 
3982         // We&#39;re a double here.
3983         m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
3984         m_jit.urshift64(TrustedImm32(52), resultGPR);
3985         m_jit.and32(TrustedImm32(0x7ff), resultGPR);
3986         auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
<span class="line-modified">3987         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
3988         done.append(m_jit.jump());
3989 
3990         notNanNorInfinity.link(&amp;m_jit);
3991         m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
3992         m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
<span class="line-modified">3993         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
3994         done.append(m_jit.jump());
3995 
3996         isInt32.link(&amp;m_jit);
<span class="line-modified">3997         m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
3998         done.append(m_jit.jump());
3999 
4000         notNumber.link(&amp;m_jit);
<span class="line-modified">4001         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
4002 
4003         done.link(&amp;m_jit);
4004         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4005         break;
4006     }
4007 
4008     case MapHash: {
4009         switch (node-&gt;child1().useKind()) {
4010         case BooleanUse:
4011         case Int32Use:
4012         case SymbolUse:
4013         case ObjectUse: {
4014             JSValueOperand input(this, node-&gt;child1(), ManualOperandSpeculation);
4015             GPRTemporary result(this, Reuse, input);
4016             GPRTemporary temp(this);
4017 
4018             GPRReg inputGPR = input.gpr();
4019             GPRReg resultGPR = result.gpr();
4020             GPRReg tempGPR = temp.gpr();
4021 
</pre>
<hr />
<pre>
4046 
4047             if (node-&gt;child1().useKind() == StringUse)
4048                 speculateString(node-&gt;child1(), inputGPR);
4049             else {
4050                 auto isString = m_jit.branchIfString(inputGPR);
4051                 m_jit.move(inputGPR, resultGPR);
4052                 m_jit.wangsInt64Hash(resultGPR, tempGPR);
4053                 done.append(m_jit.jump());
4054                 isString.link(&amp;m_jit);
4055             }
4056 
4057             m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4058             slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4059             m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4060             m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4061             slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4062             done.append(m_jit.jump());
4063 
4064             slowPath.link(&amp;m_jit);
4065             silentSpillAllRegisters(resultGPR);
<span class="line-modified">4066             callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));</span>
4067             silentFillAllRegisters();
4068             m_jit.exceptionCheck();
4069 
4070             done.link(&amp;m_jit);
4071             int32Result(resultGPR, node);
4072             break;
4073         }
4074         default:
4075             RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
4076             break;
4077         }
4078 
4079         if (node-&gt;child1().useKind() != UntypedUse)
4080             break;
4081 
4082         JSValueOperand input(this, node-&gt;child1());
4083         GPRTemporary temp(this);
4084         GPRTemporary result(this);
4085 
4086         GPRReg inputGPR = input.gpr();
</pre>
<hr />
<pre>
4089 
4090         MacroAssembler::JumpList straightHash;
4091         MacroAssembler::JumpList done;
4092         straightHash.append(m_jit.branchIfNotCell(inputGPR));
4093         MacroAssembler::JumpList slowPath;
4094         straightHash.append(m_jit.branchIfNotString(inputGPR));
4095         m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4096         slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4097         m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4098         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4099         slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4100         done.append(m_jit.jump());
4101 
4102         straightHash.link(&amp;m_jit);
4103         m_jit.move(inputGPR, resultGPR);
4104         m_jit.wangsInt64Hash(resultGPR, tempGPR);
4105         done.append(m_jit.jump());
4106 
4107         slowPath.link(&amp;m_jit);
4108         silentSpillAllRegisters(resultGPR);
<span class="line-modified">4109         callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));</span>
4110         silentFillAllRegisters();
4111         m_jit.exceptionCheck();
4112 
4113         done.link(&amp;m_jit);
4114         int32Result(resultGPR, node);
4115         break;
4116     }
4117 
4118     case NormalizeMapKey: {
4119         compileNormalizeMapKey(node);
4120         break;
4121     }
4122 
4123     case GetMapBucket: {
4124         SpeculateCellOperand map(this, node-&gt;child1());
4125         JSValueOperand key(this, node-&gt;child2(), ManualOperandSpeculation);
4126         SpeculateInt32Operand hash(this, node-&gt;child3());
4127         GPRTemporary mask(this);
4128         GPRTemporary index(this);
4129         GPRTemporary buffer(this);
</pre>
<hr />
<pre>
4207             slowPathCases.append(m_jit.branchIfString(keyGPR));
4208             // The first is a string, but the second is not, we continue to loop around.
4209             loopAround.append(m_jit.jump());
4210             break;
4211         }
4212         default:
4213             RELEASE_ASSERT_NOT_REACHED();
4214         }
4215 
4216 
4217         if (!loopAround.empty())
4218             loopAround.link(&amp;m_jit);
4219 
4220         m_jit.add32(TrustedImm32(1), indexGPR);
4221         m_jit.jump().linkTo(loop, &amp;m_jit);
4222 
4223         if (!slowPathCases.empty()) {
4224             slowPathCases.link(&amp;m_jit);
4225             silentSpillAllRegisters(indexGPR);
4226             if (node-&gt;child1().useKind() == MapObjectUse)
<span class="line-modified">4227                 callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);</span>
4228             else
<span class="line-modified">4229                 callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);</span>
4230             silentFillAllRegisters();
4231             m_jit.exceptionCheck();
4232             done.append(m_jit.jump());
4233         }
4234 
4235         notPresentInTable.link(&amp;m_jit);
4236         if (node-&gt;child1().useKind() == MapObjectUse)
4237             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelMapBucket()), resultGPR);
4238         else
4239             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelSetBucket()), resultGPR);
4240         done.link(&amp;m_jit);
4241         cellResult(resultGPR, node);
4242         break;
4243     }
4244 
4245     case GetMapBucketHead:
4246         compileGetMapBucketHead(node);
4247         break;
4248 
4249     case GetMapBucketNext:
</pre>
<hr />
<pre>
4338     case Call:
4339     case TailCall:
4340     case TailCallInlinedCaller:
4341     case Construct:
4342     case CallVarargs:
4343     case TailCallVarargs:
4344     case TailCallVarargsInlinedCaller:
4345     case CallForwardVarargs:
4346     case ConstructVarargs:
4347     case ConstructForwardVarargs:
4348     case TailCallForwardVarargs:
4349     case TailCallForwardVarargsInlinedCaller:
4350     case CallEval:
4351     case DirectCall:
4352     case DirectConstruct:
4353     case DirectTailCall:
4354     case DirectTailCallInlinedCaller:
4355         emitCall(node);
4356         break;
4357 





4358     case LoadVarargs: {
4359         compileLoadVarargs(node);
4360         break;
4361     }
4362 
4363     case ForwardVarargs: {
4364         compileForwardVarargs(node);
4365         break;
4366     }
4367 
4368     case CreateActivation: {
4369         compileCreateActivation(node);
4370         break;
4371     }
4372 
4373     case PushWithScope: {
4374         compilePushWithScope(node);
4375         break;
4376     }
4377 
</pre>
<hr />
<pre>
4387 
4388     case PutToArguments: {
4389         compilePutToArguments(node);
4390         break;
4391     }
4392 
4393     case GetArgument: {
4394         compileGetArgument(node);
4395         break;
4396     }
4397 
4398     case CreateScopedArguments: {
4399         compileCreateScopedArguments(node);
4400         break;
4401     }
4402 
4403     case CreateClonedArguments: {
4404         compileCreateClonedArguments(node);
4405         break;
4406     }






4407     case CreateRest: {
4408         compileCreateRest(node);
4409         break;
4410     }
4411 
4412     case NewFunction:
4413     case NewGeneratorFunction:
4414     case NewAsyncGeneratorFunction:
4415     case NewAsyncFunction:
4416         compileNewFunction(node);
4417         break;
4418 
4419     case SetFunctionName:
4420         compileSetFunctionName(node);
4421         break;
4422 
4423     case InById:
4424         compileInById(node);
4425         break;
4426 
</pre>
<hr />
<pre>
4503         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4504         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4505         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4506         m_jit.add32(structureIDGPR, hashGPR);
4507         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4508         if (hasOneBitSet(sizeof(HasOwnPropertyCache::Entry))) // is a power of 2
4509             m_jit.lshift32(TrustedImm32(getLSBSet(sizeof(HasOwnPropertyCache::Entry))), hashGPR);
4510         else
4511             m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4512         ASSERT(vm().hasOwnPropertyCache());
4513         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
4514         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4515             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4516         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4517         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4518         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4519         auto done = m_jit.jump();
4520 
4521         slowPath.link(&amp;m_jit);
4522         silentSpillAllRegisters(resultGPR);
<span class="line-modified">4523         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyGPR);</span>
4524         silentFillAllRegisters();
4525         m_jit.exceptionCheck();
4526 
4527         done.link(&amp;m_jit);
<span class="line-modified">4528         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
4529         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4530         break;
4531     }
4532 
4533     case CountExecution:
4534         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4535         break;
4536 
4537     case SuperSamplerBegin:
4538         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4539         break;
4540 
4541     case SuperSamplerEnd:
4542         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4543         break;
4544 
4545     case ForceOSRExit: {
4546         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4547         break;
4548     }
</pre>
<hr />
<pre>
4805                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4806                     emitLittleEndianCode();
4807                     auto done = m_jit.jump();
4808                     isBigEndian.link(&amp;m_jit);
4809                     emitBigEndianCode();
4810                     done.link(&amp;m_jit);
4811                 }
4812 
4813                 break;
4814             }
4815             default:
4816                 RELEASE_ASSERT_NOT_REACHED();
4817             }
4818 
4819             doubleResult(resultFPR, node);
4820         }
4821 
4822         break;
4823     }
4824 





4825     case DataViewSet: {
4826         SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
4827         GPRReg dataViewGPR = dataView.gpr();
4828         speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
4829 
4830         SpeculateInt32Operand index(this, m_graph.varArgChild(node, 1));
4831         GPRReg indexGPR = index.gpr();
4832 
4833         Optional&lt;SpeculateStrictInt52Operand&gt; int52Value;
4834         Optional&lt;SpeculateDoubleOperand&gt; doubleValue;
4835         Optional&lt;SpeculateInt32Operand&gt; int32Value;
4836         Optional&lt;FPRTemporary&gt; fprTemporary;
4837         GPRReg valueGPR = InvalidGPRReg;
4838         FPRReg valueFPR = InvalidFPRReg;
4839         FPRReg tempFPR = InvalidFPRReg;
4840 
4841         DataViewData data = node-&gt;dataViewData();
4842 
4843         Edge&amp; valueEdge = m_graph.varArgChild(node, 2);
4844         switch (valueEdge.useKind()) {
</pre>
<hr />
<pre>
5010             default:
5011                 RELEASE_ASSERT_NOT_REACHED();
5012             }
5013         }
5014 
5015         noResult(node);
5016         break;
5017     }
5018 
5019 #if ENABLE(FTL_JIT)
5020     case CheckTierUpInLoop: {
5021         MacroAssembler::Jump callTierUp = m_jit.branchAdd32(
5022             MacroAssembler::PositiveOrZero,
5023             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5024             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5025 
5026         MacroAssembler::Label toNextOperation = m_jit.label();
5027 
5028         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5029         silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
<span class="line-modified">5030         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5031 
5032         addSlowPathGeneratorLambda([=]() {
5033             callTierUp.link(&amp;m_jit);
5034 
5035             silentSpill(savePlans);
<span class="line-modified">5036             callOperation(triggerTierUpNowInLoop, TrustedImm32(bytecodeIndex));</span>
5037             silentFill(savePlans);
5038 
5039             m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5040         });
5041         break;
5042     }
5043 
5044     case CheckTierUpAtReturn: {
5045         MacroAssembler::Jump done = m_jit.branchAdd32(
5046             MacroAssembler::Signed,
5047             TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
5048             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5049 
5050         silentSpillAllRegisters(InvalidGPRReg);
<span class="line-modified">5051         callOperation(triggerTierUpNow);</span>
5052         silentFillAllRegisters();
5053 
5054         done.link(&amp;m_jit);
5055         break;
5056     }
5057 
5058     case CheckTierUpAndOSREnter: {
5059         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
5060 
5061         GPRTemporary temp(this);
5062         GPRReg tempGPR = temp.gpr();
5063 
<span class="line-modified">5064         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5065         auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
5066         DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
5067         JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
5068         static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
5069         static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
5070 
5071         MacroAssembler::Jump forceOSREntry = m_jit.branchTest8(MacroAssembler::NonZero, MacroAssembler::AbsoluteAddress(forceEntryTrigger));
5072         MacroAssembler::Jump overflowedCounter = m_jit.branchAdd32(
5073             MacroAssembler::PositiveOrZero,
5074             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5075             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5076         MacroAssembler::Label toNextOperation = m_jit.label();
5077 
5078         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5079         silentSpillAllRegistersImpl(false, savePlans, tempGPR);
5080 
5081         unsigned streamIndex = m_stream-&gt;size();
5082         m_jit.jitCode()-&gt;bytecodeIndexToStreamIndex.add(bytecodeIndex, streamIndex);
5083 
5084         addSlowPathGeneratorLambda([=]() {
5085             forceOSREntry.link(&amp;m_jit);
5086             overflowedCounter.link(&amp;m_jit);
5087 
5088             silentSpill(savePlans);
<span class="line-modified">5089             callOperation(triggerOSREntryNow, tempGPR, TrustedImm32(bytecodeIndex));</span>
5090 
5091             if (savePlans.isEmpty())
5092                 m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
5093             else {
5094                 MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
5095                 silentFill(savePlans);
5096                 m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5097                 osrEnter.link(&amp;m_jit);
5098             }
5099             m_jit.emitRestoreCalleeSaves();
5100             m_jit.farJump(tempGPR, GPRInfo::callFrameRegister);
5101         });
5102         break;
5103     }
5104 
5105 #else // ENABLE(FTL_JIT)
5106     case CheckTierUpInLoop:
5107     case CheckTierUpAtReturn:
5108     case CheckTierUpAndOSREnter:
5109         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
5110         break;
5111 #endif // ENABLE(FTL_JIT)
5112 
5113     case FilterCallLinkStatus:
<span class="line-modified">5114     case FilterGetByIdStatus:</span>
5115     case FilterPutByIdStatus:
5116     case FilterInByIdStatus:
5117         m_interpreter.filterICStatus(node);
5118         noResult(node);
5119         break;
5120 
5121     case LastNodeType:
5122     case EntrySwitch:
5123     case InitializeEntrypointArguments:
5124     case Phi:
5125     case Upsilon:
5126     case ExtractOSREntryLocal:
5127     case CheckInBounds:
5128     case ArithIMul:
5129     case MultiGetByOffset:
5130     case MultiPutByOffset:
5131     case FiatInt52:
5132     case CheckBadCell:
5133     case BottomValue:
5134     case PhantomNewObject:
5135     case PhantomNewFunction:
5136     case PhantomNewGeneratorFunction:
5137     case PhantomNewAsyncFunction:
5138     case PhantomNewAsyncGeneratorFunction:

5139     case PhantomCreateActivation:
5140     case PhantomNewRegexp:
5141     case GetMyArgumentByVal:
5142     case GetMyArgumentByValOutOfBounds:
5143     case GetVectorLength:
5144     case PutHint:
5145     case CheckStructureImmediate:
5146     case MaterializeCreateActivation:

5147     case PutStack:
5148     case KillStack:
5149     case GetStack:
5150     case PhantomCreateRest:
5151     case PhantomSpread:
5152     case PhantomNewArrayWithSpread:
5153     case PhantomNewArrayBuffer:
5154     case IdentityWithProfile:
5155     case CPUIntrinsic:
5156         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected node&quot;);
5157         break;
5158     }
5159 
5160     if (!m_compileOkay)
5161         return;
5162 
5163     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
5164         use(node);
5165 }
5166 
5167 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
5168 {
<span class="line-modified">5169     m_jit.move(TrustedImm32(ValueTrue), gpr);</span>
5170 }
5171 
5172 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
5173 {
<span class="line-modified">5174     m_jit.move(TrustedImm32(ValueFalse), gpr);</span>
5175 }
5176 
5177 void SpeculativeJIT::blessBoolean(GPRReg gpr)
5178 {
<span class="line-modified">5179     m_jit.or32(TrustedImm32(ValueFalse), gpr);</span>
5180 }
5181 
5182 void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
5183 {
5184     JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
5185     GPRReg valueGPR = value.gpr();
5186 
5187     JITCompiler::Jump notInt32 = m_jit.branchIfNotInt32(valueGPR);
5188 
5189     m_jit.signExtend32ToPtr(valueGPR, resultGPR);
5190     JITCompiler::Jump done = m_jit.jump();
5191 
5192     notInt32.link(&amp;m_jit);
5193     silentSpillAllRegisters(resultGPR);
5194     callOperation(operationConvertBoxedDoubleToInt52, resultGPR, valueGPR);
5195     silentFillAllRegisters();
5196 
5197     DFG_TYPE_CHECK(
5198         JSValueRegs(valueGPR), valueEdge, SpecInt32Only | SpecAnyIntAsDouble,
5199         m_jit.branch64(
</pre>
<hr />
<pre>
5230     callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
5231 
5232     DFG_TYPE_CHECK(
5233         JSValueRegs(), edge, SpecAnyIntAsDouble,
5234         m_jit.branch64(
5235             JITCompiler::Equal, resultGPR,
5236             JITCompiler::TrustedImm64(JSValue::notInt52)));
5237 }
5238 
5239 void SpeculativeJIT::compileArithRandom(Node* node)
5240 {
5241     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
5242     GPRTemporary temp1(this);
5243     GPRTemporary temp2(this);
5244     GPRTemporary temp3(this);
5245     FPRTemporary result(this);
5246     m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
5247     doubleResult(result.fpr(), node);
5248 }
5249 


























































































































































































5250 #endif
5251 
5252 } } // namespace JSC::DFG
5253 
5254 #endif
</pre>
</td>
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGSpeculativeJIT.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;AtomicsObject.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGDoesGC.h&quot;
  37 #include &quot;DFGOperations.h&quot;
  38 #include &quot;DFGSlowPathGenerator.h&quot;
<span class="line-added">  39 #include &quot;DateInstance.h&quot;</span>
  40 #include &quot;DirectArguments.h&quot;
  41 #include &quot;GetterSetter.h&quot;
  42 #include &quot;HasOwnPropertyCache.h&quot;
  43 #include &quot;JSCInlines.h&quot;
  44 #include &quot;JSLexicalEnvironment.h&quot;
  45 #include &quot;JSMap.h&quot;
  46 #include &quot;JSPropertyNameEnumerator.h&quot;
  47 #include &quot;JSSet.h&quot;
  48 #include &quot;ObjectPrototype.h&quot;
  49 #include &quot;SetupVarargsFrame.h&quot;
  50 #include &quot;SpillRegistersMode.h&quot;
  51 #include &quot;StringPrototype.h&quot;
  52 #include &quot;SuperSampler.h&quot;
  53 #include &quot;Watchdog.h&quot;
  54 
  55 namespace JSC { namespace DFG {
  56 
  57 #if USE(JSVALUE64)
  58 
  59 void SpeculativeJIT::boxInt52(GPRReg sourceGPR, GPRReg targetGPR, DataFormat format)
</pre>
<hr />
<pre>
  85 GPRReg SpeculativeJIT::fillJSValue(Edge edge)
  86 {
  87     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  88     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  89 
  90     switch (info.registerFormat()) {
  91     case DataFormatNone: {
  92         GPRReg gpr = allocate();
  93 
  94         if (edge-&gt;hasConstant()) {
  95             JSValue jsValue = edge-&gt;asJSValue();
  96             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
  97             info.fillJSValue(*m_stream, gpr, DataFormatJS);
  98             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
  99         } else {
 100             DataFormat spillFormat = info.spillFormat();
 101             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 102             switch (spillFormat) {
 103             case DataFormatInt32: {
 104                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
<span class="line-modified"> 105                 m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
 106                 spillFormat = DataFormatJSInt32;
 107                 break;
 108             }
 109 
 110             default:
 111                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 112                 DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat &amp; DataFormatJS, spillFormat);
 113                 break;
 114             }
 115             info.fillJSValue(*m_stream, gpr, spillFormat);
 116         }
 117         return gpr;
 118     }
 119 
 120     case DataFormatInt32: {
 121         GPRReg gpr = info.gpr();
 122         // If the register has already been locked we need to take a copy.
 123         // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 124         if (m_gprs.isLocked(gpr)) {
 125             GPRReg result = allocate();
<span class="line-modified"> 126             m_jit.or64(GPRInfo::numberTagRegister, gpr, result);</span>
 127             return result;
 128         }
 129         m_gprs.lock(gpr);
<span class="line-modified"> 130         m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
 131         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 132         return gpr;
 133     }
 134 
 135     case DataFormatCell:
 136         // No retag required on JSVALUE64!
 137     case DataFormatJS:
 138     case DataFormatJSInt32:
 139     case DataFormatJSDouble:
 140     case DataFormatJSCell:
 141     case DataFormatJSBoolean: {
 142         GPRReg gpr = info.gpr();
 143         m_gprs.lock(gpr);
 144         return gpr;
 145     }
 146 
 147     case DataFormatBoolean:
 148     case DataFormatStorage:
 149     case DataFormatDouble:
 150     case DataFormatInt52:
</pre>
<hr />
<pre>
 166 {
 167     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 168     RegisterSet usedRegisters = this-&gt;usedRegisters();
 169     if (spillMode == DontSpill) {
 170         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 171         usedRegisters.set(baseGPR, false);
 172         usedRegisters.set(resultGPR, false);
 173     }
 174     JITGetByIdGenerator gen(
 175         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 176         JSValueRegs(baseGPR), JSValueRegs(resultGPR), type);
 177     gen.generateFastPath(m_jit);
 178 
 179     JITCompiler::JumpList slowCases;
 180     slowCases.append(slowPathTarget);
 181     slowCases.append(gen.slowPathJump());
 182 
 183     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 184         slowCases, this, appropriateOptimizingGetByIdFunction(type),
 185         spillMode, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 186         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, identifierUID(identifierNumber));</span>
 187 
 188     m_jit.addGetById(gen, slowPath.get());
 189     addSlowPathGenerator(WTFMove(slowPath));
 190 }
 191 
 192 void SpeculativeJIT::cachedGetByIdWithThis(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 193 {
 194     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 195     RegisterSet usedRegisters = this-&gt;usedRegisters();
 196     // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 197     usedRegisters.set(baseGPR, false);
 198     usedRegisters.set(thisGPR, false);
 199     usedRegisters.set(resultGPR, false);
 200 
 201     JITGetByIdWithThisGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="line-modified"> 203         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR));</span>
 204     gen.generateFastPath(m_jit);
 205 
 206     JITCompiler::JumpList slowCases;
 207     slowCases.append(slowPathTarget);
 208     slowCases.append(gen.slowPathJump());
 209 
 210     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 211         slowCases, this, operationGetByIdWithThisOptimize,
 212         DontSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="line-modified"> 213         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));</span>
 214 
 215     m_jit.addGetByIdWithThis(gen, slowPath.get());
 216     addSlowPathGenerator(WTFMove(slowPath));
 217 }
 218 
 219 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 220 {
 221     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 222     GPRReg argGPR = arg.gpr();
 223 
 224     GPRTemporary result(this);
 225     GPRReg resultGPR = result.gpr();
 226 
 227     m_jit.move(TrustedImm32(0), resultGPR);
 228 
 229     JITCompiler::JumpList done;
 230     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 231         if (!isKnownNotCell(operand.node()))
 232             done.append(m_jit.branchIfCell(JSValueRegs(argGPR)));
 233     } else {
</pre>
<hr />
<pre>
 241 
 242         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
 243             JITCompiler::Zero,
 244             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 245             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 246         done.append(isNotMasqueradesAsUndefined);
 247 
 248         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 249         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 250         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 251         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 252         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 253         m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultGPR);
 254         done.append(m_jit.jump());
 255         if (!isKnownCell(operand.node()))
 256             notCell.link(&amp;m_jit);
 257     }
 258 
 259     if (!isKnownNotOther(operand.node())) {
 260         m_jit.move(argGPR, resultGPR);
<span class="line-modified"> 261         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified"> 262         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
 263     }
 264 
 265     done.link(&amp;m_jit);
 266 
<span class="line-modified"> 267     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
 268     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
 269 }
 270 
 271 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 272 {
 273     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 274     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 275 
 276     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 277     GPRReg argGPR = arg.gpr();
 278 
 279     GPRTemporary result(this, Reuse, arg);
 280     GPRReg resultGPR = result.gpr();
 281 
 282     // First, handle the case where &quot;operand&quot; is a cell.
 283     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 284         if (!isKnownNotCell(operand.node())) {
 285             JITCompiler::Jump isCell = m_jit.branchIfCell(JSValueRegs(argGPR));
 286             addBranch(isCell, notTaken);
 287         }
</pre>
<hr />
<pre>
 303         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 304         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 305         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 306         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, taken);
 307 
 308         if (!isKnownCell(operand.node())) {
 309             jump(notTaken, ForceJump);
 310             notCell.link(&amp;m_jit);
 311         }
 312     }
 313 
 314     if (isKnownNotOther(operand.node()))
 315         jump(notTaken);
 316     else {
 317         JITCompiler::RelationalCondition condition = JITCompiler::Equal;
 318         if (taken == nextBlock()) {
 319             condition = JITCompiler::NotEqual;
 320             std::swap(taken, notTaken);
 321         }
 322         m_jit.move(argGPR, resultGPR);
<span class="line-modified"> 323         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified"> 324         branch64(condition, resultGPR, JITCompiler::TrustedImm64(JSValue::ValueNull), taken);</span>
 325         jump(notTaken);
 326     }
 327 }
 328 
 329 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 330 {
 331     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 332     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 333 
 334     // The branch instruction will branch to the taken block.
 335     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 336     if (taken == nextBlock()) {
 337         invert = !invert;
 338         BasicBlock* tmp = taken;
 339         taken = notTaken;
 340         notTaken = tmp;
 341     }
 342 
 343     JSValueOperand arg1(this, node-&gt;child1());
 344     JSValueOperand arg2(this, node-&gt;child2());
 345     GPRReg arg1GPR = arg1.gpr();
 346     GPRReg arg2GPR = arg2.gpr();
 347 
 348     GPRTemporary result(this);
 349     GPRReg resultGPR = result.gpr();
 350 
 351     arg1.use();
 352     arg2.use();
 353 
 354     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 355         // see if we get lucky: if the arguments are cells and they reference the same
 356         // cell, then they must be strictly equal.
 357         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 358 
 359         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 360         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 361         silentFillAllRegisters();
 362         m_jit.exceptionCheck();
 363 
 364         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 365     } else {
 366         m_jit.or64(arg1GPR, arg2GPR, resultGPR);
 367 
 368         JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 369 
 370         JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1GPR);
 371         JITCompiler::Jump leftDouble = m_jit.branchIfNumber(arg1GPR);
 372         leftOK.link(&amp;m_jit);
 373         JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2GPR);
 374         JITCompiler::Jump rightDouble = m_jit.branchIfNumber(arg2GPR);
 375         rightOK.link(&amp;m_jit);
 376 
 377         branch64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1GPR, arg2GPR, taken);
 378         jump(notTaken, ForceJump);
 379 
 380         twoCellsCase.link(&amp;m_jit);
 381         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 382 
 383         leftDouble.link(&amp;m_jit);
 384         rightDouble.link(&amp;m_jit);
 385 
 386         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 387         callOperation(operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 388         silentFillAllRegisters();
 389         m_jit.exceptionCheck();
 390 
 391         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 392     }
 393 
 394     jump(notTaken);
 395 }
 396 
 397 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 398 {
 399     JSValueOperand arg1(this, node-&gt;child1());
 400     JSValueOperand arg2(this, node-&gt;child2());
 401     JSValueRegs arg1Regs = arg1.jsValueRegs();
 402     JSValueRegs arg2Regs = arg2.jsValueRegs();
 403 
 404     GPRTemporary result(this);
 405     GPRReg resultGPR = result.gpr();
 406 
 407     arg1.use();
 408     arg2.use();
 409 
 410     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 411         // see if we get lucky: if the arguments are cells and they reference the same
 412         // cell, then they must be strictly equal.
 413         // FIXME: this should flush registers instead of silent spill/fill.
 414         JITCompiler::Jump notEqualCase = m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr());
 415 
 416         m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 417 
 418         JITCompiler::Jump done = m_jit.jump();
 419 
 420         notEqualCase.link(&amp;m_jit);
 421 
 422         silentSpillAllRegisters(resultGPR);
<span class="line-modified"> 423         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 424         silentFillAllRegisters();
 425         m_jit.exceptionCheck();
 426 
 427         done.link(&amp;m_jit);
 428         unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 429         return;
 430     }
 431 
 432     m_jit.or64(arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 433 
 434     JITCompiler::JumpList slowPathCases;
 435 
 436     JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 437 
 438     JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1Regs);
 439     slowPathCases.append(m_jit.branchIfNumber(arg1Regs, InvalidGPRReg));
 440     leftOK.link(&amp;m_jit);
 441     JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2Regs);
 442     slowPathCases.append(m_jit.branchIfNumber(arg2Regs, InvalidGPRReg));
 443     rightOK.link(&amp;m_jit);
 444 
 445     m_jit.compare64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 446 
 447     JITCompiler::Jump done = m_jit.jump();
 448 
 449     twoCellsCase.link(&amp;m_jit);
 450     slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
 451 
 452     m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 453 
<span class="line-modified"> 454     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
 455 
 456     done.link(&amp;m_jit);
 457 
 458     unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 459 }
 460 
 461 void SpeculativeJIT::emitCall(Node* node)
 462 {
 463     CallLinkInfo::CallType callType;
 464     bool isVarargs = false;
 465     bool isForwardVarargs = false;
 466     bool isTail = false;
 467     bool isEmulatedTail = false;
 468     bool isDirect = false;
 469     switch (node-&gt;op()) {
 470     case Call:
 471     case CallEval:
 472         callType = CallLinkInfo::Call;
 473         break;
 474     case TailCall:
</pre>
<hr />
<pre>
 527         isDirect = true;
 528         break;
 529     case DirectTailCall:
 530         callType = CallLinkInfo::DirectTailCall;
 531         isTail = true;
 532         isDirect = true;
 533         break;
 534     case DirectTailCallInlinedCaller:
 535         callType = CallLinkInfo::DirectCall;
 536         isEmulatedTail = true;
 537         isDirect = true;
 538         break;
 539     default:
 540         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 541         break;
 542     }
 543 
 544     GPRReg calleeGPR = InvalidGPRReg;
 545     CallFrameShuffleData shuffleData;
 546 
<span class="line-added"> 547     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
 548     ExecutableBase* executable = nullptr;
 549     FunctionExecutable* functionExecutable = nullptr;
 550     if (isDirect) {
 551         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 552         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 553     }
 554 
 555     unsigned numPassedArgs = 0;
 556     unsigned numAllocatedArgs = 0;
 557 
 558     // Gotta load the arguments somehow. Varargs is trickier.
 559     if (isVarargs || isForwardVarargs) {
 560         RELEASE_ASSERT(!isDirect);
 561         CallVarargsData* data = node-&gt;callVarargsData();
 562 
 563         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 564 
 565         if (isForwardVarargs) {
 566             flushRegisters();
 567             if (node-&gt;child3())
</pre>
<hr />
<pre>
 569 
 570             GPRReg scratchGPR1;
 571             GPRReg scratchGPR2;
 572             GPRReg scratchGPR3;
 573 
 574             scratchGPR1 = JITCompiler::selectScratchGPR();
 575             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 576             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 577 
 578             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 579             JITCompiler::JumpList slowCase;
 580             InlineCallFrame* inlineCallFrame;
 581             if (node-&gt;child3())
 582                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 583             else
 584                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 585             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 586             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 587             JITCompiler::Jump done = m_jit.jump();
 588             slowCase.link(&amp;m_jit);
<span class="line-modified"> 589             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
 590             m_jit.exceptionCheck();
 591             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 592             done.link(&amp;m_jit);
 593         } else {
 594             GPRReg argumentsGPR;
 595             GPRReg scratchGPR1;
 596             GPRReg scratchGPR2;
 597             GPRReg scratchGPR3;
 598 
 599             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 600                 if (reservedGPR != InvalidGPRReg)
 601                     lock(reservedGPR);
 602                 JSValueOperand arguments(this, node-&gt;child3());
 603                 argumentsGPR = arguments.gpr();
 604                 if (reservedGPR != InvalidGPRReg)
 605                     unlock(reservedGPR);
 606                 flushRegisters();
 607 
 608                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsGPR, reservedGPR);
 609                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, reservedGPR);
 610                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, scratchGPR2, reservedGPR);
 611             };
 612 
 613             loadArgumentsGPR(InvalidGPRReg);
 614 
 615             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 616 
 617             // Right now, arguments is in argumentsGPR and the register file is flushed.
<span class="line-modified"> 618             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
 619             m_jit.exceptionCheck();
 620 
 621             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 622             // Reconstruct the arguments operand while preserving the callee frame.
 623             loadArgumentsGPR(GPRInfo::returnValueGPR);
 624             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 625             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 626             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 627 
<span class="line-modified"> 628             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
 629             m_jit.exceptionCheck();
 630             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 631         }
 632 
 633         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 634 
 635         // We don&#39;t need the arguments array anymore.
 636         if (isVarargs)
 637             use(node-&gt;child3());
 638 
 639         // Now set up the &quot;this&quot; argument.
 640         JSValueOperand thisArgument(this, node-&gt;child2());
 641         GPRReg thisArgumentGPR = thisArgument.gpr();
 642         thisArgument.use();
 643 
 644         m_jit.store64(thisArgumentGPR, JITCompiler::calleeArgumentSlot(0));
 645     } else {
 646         // The call instruction&#39;s first child is the function; the subsequent children are the
 647         // arguments.
 648         numPassedArgs = node-&gt;numChildren() - 1;
</pre>
<hr />
<pre>
 657             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 658                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 659 
 660                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 661                 // do this adjustment now since we will have already emitted code that relied on the
 662                 // value of m_parameterSlots.
 663                 DFG_ASSERT(
 664                     m_jit.graph(), node,
 665                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 666                     &lt;= m_jit.graph().m_parameterSlots);
 667             }
 668         }
 669 
 670         if (isTail) {
 671             Edge calleeEdge = m_jit.graph().child(node, 0);
 672             JSValueOperand callee(this, calleeEdge);
 673             calleeGPR = callee.gpr();
 674             if (!isDirect)
 675                 callee.use();
 676 
<span class="line-modified"> 677             shuffleData.numberTagRegister = GPRInfo::numberTagRegister;</span>
 678             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 679             shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
 680             shuffleData.args.resize(numAllocatedArgs);
 681             shuffleData.numPassedArgs = numPassedArgs;
 682 
 683             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 684                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 685                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 686                 if (!isDirect)
 687                     use(argEdge);
 688                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 689             }
 690 
 691             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 692                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 693 
 694             shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
 695         } else {
<span class="line-modified"> 696             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
 697 
 698             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 699                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 700                 JSValueOperand arg(this, argEdge);
 701                 GPRReg argGPR = arg.gpr();
 702                 use(argEdge);
 703 
 704                 m_jit.store64(argGPR, JITCompiler::calleeArgumentSlot(i));
 705             }
 706 
 707             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 708                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 709         }
 710     }
 711 
 712     if (!isTail || isVarargs || isForwardVarargs) {
 713         Edge calleeEdge = m_jit.graph().child(node, 0);
 714         JSValueOperand callee(this, calleeEdge);
 715         calleeGPR = callee.gpr();
 716         callee.use();
</pre>
<hr />
<pre>
 740         // mismatch (the callframe is slided) and tail calls.
 741         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 742     };
 743 
 744     CallLinkInfo* callLinkInfo = m_jit.codeBlock()-&gt;addCallLinkInfo();
 745     callLinkInfo-&gt;setUpCall(callType, m_currentNode-&gt;origin.semantic, calleeGPR);
 746 
 747     if (node-&gt;op() == CallEval) {
 748         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 749         // which we have created a prototypical eval call frame. This means that we have to
 750         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 751         // register file to ourselves.
 752 
 753         m_jit.emitStoreCallSiteIndex(callSite);
 754         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 755         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 756 
 757         // Now we need to make room for:
 758         // - The caller frame and PC of a call to operationCallEval.
 759         // - Potentially two arguments on the stack.
<span class="line-modified"> 760         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
 761         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 762         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="line-modified"> 763         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);</span>
 764         prepareForExternalCall();
 765         m_jit.appendCall(operationCallEval);
 766         m_jit.exceptionCheck();
 767         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
 768 
 769         // This is the part where we meant to make a normal call. Oops.
 770         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 771         m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<span class="line-modified"> 772         m_jit.emitDumbVirtualCall(vm(), globalObject, callLinkInfo);</span>
 773 
 774         done.link(&amp;m_jit);
 775         setResultAndResetStack();
 776         return;
 777     }
 778 
 779     if (isDirect) {
 780         callLinkInfo-&gt;setExecutableDuringCompilation(executable);
<span class="line-modified"> 781         callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
 782 
 783         if (isTail) {
 784             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 785 
 786             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 787             JITCompiler::Label mainPath = m_jit.label();
 788 
 789             m_jit.emitStoreCallSiteIndex(callSite);
 790 
 791             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 792             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 793 
 794             JITCompiler::Call call = m_jit.nearTailCall();
 795 
 796             JITCompiler::Label slowPath = m_jit.label();
 797             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 798 
 799             silentSpillAllRegisters(InvalidGPRReg);
 800             callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 801             silentFillAllRegisters();
</pre>
<hr />
<pre>
 847     }
 848 
 849     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 850 
 851     JITCompiler::Jump done = m_jit.jump();
 852 
 853     slowPath.link(&amp;m_jit);
 854 
 855     if (node-&gt;op() == TailCall) {
 856         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 857         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 858         callFrameShuffler.prepareForSlowPath();
 859     } else {
 860         m_jit.move(calleeGPR, GPRInfo::regT0); // Callee needs to be in regT0
 861 
 862         if (isTail)
 863             m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
 864     }
 865 
 866     m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2
<span class="line-added"> 867     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3); // JSGlobalObject needs to be in regT3</span>
 868     JITCompiler::Call slowCall = m_jit.nearCall();
 869 
 870     done.link(&amp;m_jit);
 871 
 872     if (isTail)
 873         m_jit.abortWithReason(JITDidReturnFromTailCall);
 874     else
 875         setResultAndResetStack();
 876 
 877     m_jit.addJSCall(fastCall, slowCall, targetToCheck, callLinkInfo);
 878 }
 879 
 880 // Clang should allow unreachable [[clang::fallthrough]] in template functions if any template expansion uses it
 881 // http://llvm.org/bugs/show_bug.cgi?id=18619
 882 IGNORE_WARNINGS_BEGIN(&quot;implicit-fallthrough&quot;)
 883 template&lt;bool strict&gt;
 884 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 885 {
 886     AbstractValue&amp; value = m_state.forNode(edge);
 887     SpeculatedType type = value.m_type;
</pre>
<hr />
<pre>
1191             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1192             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1193             info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1194             return gpr;
1195         }
1196 
1197         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1198         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1199 
1200         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1201         if (type &amp; ~SpecCellCheck)
1202             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1203         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1204         return gpr;
1205     }
1206 
1207     case DataFormatCell:
1208     case DataFormatJSCell: {
1209         GPRReg gpr = info.gpr();
1210         m_gprs.lock(gpr);
<span class="line-modified">1211         if (ASSERT_ENABLED) {</span>
1212             MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
1213             m_jit.abortWithReason(DFGIsNotCell);
1214             checkCell.link(&amp;m_jit);
1215         }
1216         return gpr;
1217     }
1218 
1219     case DataFormatJS: {
1220         GPRReg gpr = info.gpr();
1221         m_gprs.lock(gpr);
1222         if (type &amp; ~SpecCellCheck)
1223             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1224         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1225         return gpr;
1226     }
1227 
1228     case DataFormatJSInt32:
1229     case DataFormatInt32:
1230     case DataFormatJSDouble:
1231     case DataFormatJSBoolean:
</pre>
<hr />
<pre>
1258     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1259     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1260 
1261     switch (info.registerFormat()) {
1262     case DataFormatNone: {
1263         GPRReg gpr = allocate();
1264 
1265         if (edge-&gt;hasConstant()) {
1266             JSValue jsValue = edge-&gt;asJSValue();
1267             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1268             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1269             info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1270             return gpr;
1271         }
1272         DFG_ASSERT(m_jit.graph(), m_currentNode, info.spillFormat() &amp; DataFormatJS, info.spillFormat());
1273         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1274         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1275 
1276         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1277         if (type &amp; ~SpecBoolean) {
<span class="line-modified">1278             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1279             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="line-modified">1280             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1281         }
1282         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1283         return gpr;
1284     }
1285 
1286     case DataFormatBoolean:
1287     case DataFormatJSBoolean: {
1288         GPRReg gpr = info.gpr();
1289         m_gprs.lock(gpr);
1290         return gpr;
1291     }
1292 
1293     case DataFormatJS: {
1294         GPRReg gpr = info.gpr();
1295         m_gprs.lock(gpr);
1296         if (type &amp; ~SpecBoolean) {
<span class="line-modified">1297             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1298             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="line-modified">1299             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1300         }
1301         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1302         return gpr;
1303     }
1304 
1305     case DataFormatJSInt32:
1306     case DataFormatInt32:
1307     case DataFormatJSDouble:
1308     case DataFormatJSCell:
1309     case DataFormatCell:
1310     case DataFormatDouble:
1311     case DataFormatStorage:
1312     case DataFormatInt52:
1313     case DataFormatStrictInt52:
1314         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1315 
1316     default:
1317         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1318         return InvalidGPRReg;
1319     }
1320 }
1321 
1322 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1323 {
1324     SpeculateCellOperand op1(this, objectChild);
1325     JSValueOperand op2(this, otherChild);
1326     GPRTemporary result(this);
1327 
1328     GPRReg op1GPR = op1.gpr();
1329     GPRReg op2GPR = op2.gpr();
1330     GPRReg resultGPR = result.gpr();
1331 
1332     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1333 
1334     // At this point we know that we can perform a straight-forward equality comparison on pointer
1335     // values because we are doing strict equality.
1336     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
<span class="line-modified">1337     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1338     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1339 }
1340 
1341 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1342 {
1343     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1344     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1345 
1346     SpeculateCellOperand op1(this, objectChild);
1347     JSValueOperand op2(this, otherChild);
1348 
1349     GPRReg op1GPR = op1.gpr();
1350     GPRReg op2GPR = op2.gpr();
1351 
1352     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1353 
1354     if (taken == nextBlock()) {
1355         branchPtr(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1356         jump(taken);
1357     } else {
</pre>
<hr />
<pre>
1399             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1400         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1401             m_jit.branchTest8(
1402                 MacroAssembler::NonZero,
1403                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1404                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1405     }
1406 
1407     // At this point we know that we can perform a straight-forward equality comparison on pointer
1408     // values because both left and right are pointers to objects that have no special equality
1409     // protocols.
1410     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1411     MacroAssembler::Jump done = m_jit.jump();
1412 
1413     rightNotCell.link(&amp;m_jit);
1414 
1415     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1416     // prove that it is either null or undefined.
1417     if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
1418         m_jit.move(op2GPR, resultGPR);
<span class="line-modified">1419         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1420 
1421         typeCheck(
1422             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
1423             m_jit.branch64(
1424                 MacroAssembler::NotEqual, resultGPR,
<span class="line-modified">1425                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1426     }
1427     m_jit.move(TrustedImm32(0), result.gpr());
1428 
1429     done.link(&amp;m_jit);
<span class="line-modified">1430     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1431     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1432 }
1433 
1434 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1435 {
1436     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1437     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1438 
1439     SpeculateCellOperand op1(this, leftChild);
1440     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1441     GPRTemporary result(this);
1442 
1443     GPRReg op1GPR = op1.gpr();
1444     GPRReg op2GPR = op2.gpr();
1445     GPRReg resultGPR = result.gpr();
1446 
1447     bool masqueradesAsUndefinedWatchpointValid =
1448         masqueradesAsUndefinedWatchpointIsStillValid();
1449 
1450     if (masqueradesAsUndefinedWatchpointValid) {
</pre>
<hr />
<pre>
1475             m_jit.branchTest8(
1476                 MacroAssembler::NonZero,
1477                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1478                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1479     }
1480 
1481     // At this point we know that we can perform a straight-forward equality comparison on pointer
1482     // values because both left and right are pointers to objects that have no special equality
1483     // protocols.
1484     branch64(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1485 
1486     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1487     // prove that it is either null or undefined.
1488     if (!needsTypeCheck(rightChild, SpecCellCheck | SpecOther))
1489         rightNotCell.link(&amp;m_jit);
1490     else {
1491         jump(notTaken, ForceJump);
1492 
1493         rightNotCell.link(&amp;m_jit);
1494         m_jit.move(op2GPR, resultGPR);
<span class="line-modified">1495         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1496 
1497         typeCheck(
1498             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
1499                 MacroAssembler::NotEqual, resultGPR,
<span class="line-modified">1500                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1501     }
1502 
1503     jump(notTaken);
1504 }
1505 
1506 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1507 {
1508     SpeculateCellOperand symbol(this, symbolEdge);
1509     JSValueOperand untyped(this, untypedEdge);
1510     GPRTemporary result(this, Reuse, symbol, untyped);
1511 
1512     GPRReg symbolGPR = symbol.gpr();
1513     GPRReg untypedGPR = untyped.gpr();
1514     GPRReg resultGPR = result.gpr();
1515 
1516     speculateSymbol(symbolEdge, symbolGPR);
1517 
1518     // At this point we know that we can perform a straight-forward equality comparison on pointer
1519     // values because we are doing strict equality.
1520     m_jit.compare64(MacroAssembler::Equal, symbolGPR, untypedGPR, resultGPR);
1521     unblessedBooleanResult(resultGPR, node);
1522 }
1523 
1524 void SpeculativeJIT::compileInt52Compare(Node* node, MacroAssembler::RelationalCondition condition)
1525 {
1526     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1527     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1528     GPRTemporary result(this, Reuse, op1, op2);
1529 
1530     m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
1531 
1532     // If we add a DataFormatBool, we should use it here.
<span class="line-modified">1533     m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1534     jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
1535 }
1536 
1537 void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
1538 {
1539     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1540     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1541 
1542     // The branch instruction will branch to the taken block.
1543     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
1544     if (taken == nextBlock()) {
1545         condition = JITCompiler::invert(condition);
1546         BasicBlock* tmp = taken;
1547         taken = notTaken;
1548         notTaken = tmp;
1549     }
1550 
1551     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1552     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1553 
</pre>
<hr />
<pre>
1598             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1599     } else {
1600         DFG_TYPE_CHECK(
1601             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1602 
1603         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1604             m_jit.branchTest8(
1605                 MacroAssembler::Zero,
1606                 MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1607                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1608 
1609         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1610         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1611             m_jit.branchPtr(
1612                 MacroAssembler::Equal,
1613                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1614                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1615 
1616         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1617     }
<span class="line-modified">1618     m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1619     MacroAssembler::Jump done = m_jit.jump();
1620 
1621     notCell.link(&amp;m_jit);
1622 
1623     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1624         m_jit.move(valueGPR, resultGPR);
<span class="line-modified">1625         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1626         typeCheck(
1627             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1628                 MacroAssembler::NotEqual,
1629                 resultGPR,
<span class="line-modified">1630                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1631     }
<span class="line-modified">1632     m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
1633 
1634     done.link(&amp;m_jit);
1635 
1636     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1637 }
1638 
1639 void SpeculativeJIT::compileLogicalNot(Node* node)
1640 {
1641     switch (node-&gt;child1().useKind()) {
1642     case ObjectOrOtherUse: {
1643         compileObjectOrOtherLogicalNot(node-&gt;child1());
1644         return;
1645     }
1646 
1647     case Int32Use: {
1648         SpeculateInt32Operand value(this, node-&gt;child1());
1649         GPRTemporary result(this, Reuse, value);
1650         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
<span class="line-modified">1651         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1652         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1653         return;
1654     }
1655 
1656     case DoubleRepUse: {
1657         SpeculateDoubleOperand value(this, node-&gt;child1());
1658         FPRTemporary scratch(this);
1659         GPRTemporary result(this);
<span class="line-modified">1660         m_jit.move(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1661         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1662         m_jit.xor32(TrustedImm32(true), result.gpr());
1663         nonZero.link(&amp;m_jit);
1664         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1665         return;
1666     }
1667 
1668     case BooleanUse:
1669     case KnownBooleanUse: {
1670         if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1671             SpeculateBooleanOperand value(this, node-&gt;child1());
1672             GPRTemporary result(this, Reuse, value);
1673 
1674             m_jit.move(value.gpr(), result.gpr());
1675             m_jit.xor64(TrustedImm32(true), result.gpr());
1676 
1677             jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1678             return;
1679         }
1680 
1681         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1682         GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
1683 
1684         m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">1685         m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1686         typeCheck(
1687             JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
1688                 JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<span class="line-modified">1689         m_jit.xor64(TrustedImm32(JSValue::ValueTrue), result.gpr());</span>
1690 
1691         // If we add a DataFormatBool, we should use it here.
1692         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1693         return;
1694     }
1695 
1696     case UntypedUse: {
1697         JSValueOperand arg1(this, node-&gt;child1());
1698         GPRTemporary result(this);
1699 
1700         GPRReg arg1GPR = arg1.gpr();
1701         GPRReg resultGPR = result.gpr();
1702 
1703         FPRTemporary valueFPR(this);
1704         FPRTemporary tempFPR(this);
1705 
1706         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1707         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1708         Optional&lt;GPRTemporary&gt; scratch;
1709         GPRReg scratchGPR = InvalidGPRReg;
1710         if (shouldCheckMasqueradesAsUndefined) {
1711             scratch.emplace(this);
1712             scratchGPR = scratch-&gt;gpr();
1713         }
1714         bool negateResult = true;
1715         m_jit.emitConvertValueToBoolean(vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
<span class="line-modified">1716         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1717         jsValueResult(resultGPR, node, DataFormatJSBoolean);
1718         return;
1719     }
1720     case StringUse:
1721         return compileStringZeroLength(node);
1722 
1723     case StringOrOtherUse:
1724         return compileLogicalNotStringOrOther(node);
1725 
1726     default:
1727         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
1728         break;
1729     }
1730 }
1731 
1732 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1733 {
1734     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1735     GPRTemporary scratch(this);
1736     GPRTemporary structure;
</pre>
<hr />
<pre>
1755         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1756             JITCompiler::Zero,
1757             MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1758             TrustedImm32(MasqueradesAsUndefined));
1759 
1760         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1761         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1762             m_jit.branchPtr(
1763                 MacroAssembler::Equal,
1764                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1765                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1766 
1767         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1768     }
1769     jump(taken, ForceJump);
1770 
1771     notCell.link(&amp;m_jit);
1772 
1773     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1774         m_jit.move(valueGPR, scratchGPR);
<span class="line-modified">1775         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), scratchGPR);</span>
1776         typeCheck(
1777             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
<span class="line-modified">1778                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1779     }
1780     jump(notTaken);
1781 
1782     noResult(m_currentNode);
1783 }
1784 
1785 void SpeculativeJIT::emitBranch(Node* node)
1786 {
1787     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1788     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1789 
1790     switch (node-&gt;child1().useKind()) {
1791     case ObjectOrOtherUse: {
1792         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1793         return;
1794     }
1795 
1796     case Int32Use:
1797     case DoubleRepUse: {
1798         if (node-&gt;child1().useKind() == Int32Use) {
</pre>
<hr />
<pre>
1857             value.use();
1858         } else {
1859             GPRTemporary result(this);
1860             FPRTemporary fprValue(this);
1861             FPRTemporary fprTemp(this);
1862             Optional&lt;GPRTemporary&gt; scratch;
1863 
1864             GPRReg scratchGPR = InvalidGPRReg;
1865             bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1866             if (shouldCheckMasqueradesAsUndefined) {
1867                 scratch.emplace(this);
1868                 scratchGPR = scratch-&gt;gpr();
1869             }
1870 
1871             GPRReg resultGPR = result.gpr();
1872             FPRReg valueFPR = fprValue.fpr();
1873             FPRReg tempFPR = fprTemp.fpr();
1874 
1875             if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
1876                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
<span class="line-modified">1877                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::numberTagRegister, taken);</span>
1878             }
1879 
1880             if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
1881                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1882                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1883             }
1884 
1885             value.use();
1886 
1887             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1888             auto truthy = m_jit.branchIfTruthy(vm(), JSValueRegs(valueGPR), resultGPR, scratchGPR, valueFPR, tempFPR, shouldCheckMasqueradesAsUndefined, globalObject);
1889             addBranch(truthy, taken);
1890             jump(notTaken);
1891         }
1892 
1893         noResult(node, UseChildrenCalledExplicitly);
1894         return;
1895     }
1896 
1897     default:
</pre>
<hr />
<pre>
1913 #endif
1914 
1915     switch (op) {
1916     case JSConstant:
1917     case DoubleConstant:
1918     case Int52Constant:
1919     case PhantomDirectArguments:
1920     case PhantomClonedArguments:
1921         initConstantInfo(node);
1922         break;
1923 
1924     case LazyJSConstant:
1925         compileLazyJSConstant(node);
1926         break;
1927 
1928     case Identity: {
1929         compileIdentity(node);
1930         break;
1931     }
1932 
<span class="line-added">1933     case Inc:</span>
<span class="line-added">1934     case Dec:</span>
<span class="line-added">1935         compileIncOrDec(node);</span>
<span class="line-added">1936         break;</span>
<span class="line-added">1937 </span>
1938     case GetLocal: {
<span class="line-modified">1939         AbstractValue&amp; value = m_state.operand(node-&gt;operand());</span>
1940 
1941         // If the CFA is tracking this variable and it found that the variable
1942         // cannot have been assigned, then don&#39;t attempt to proceed.
1943         if (value.isClear()) {
1944             m_compileOkay = false;
1945             break;
1946         }
1947 
1948         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1949         case FlushedDouble: {
1950             FPRTemporary result(this);
1951             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1952             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1953             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1954             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1955             break;
1956         }
1957 
1958         case FlushedInt32: {
1959             GPRTemporary result(this);
</pre>
<hr />
<pre>
1990             if (isCellSpeculation(value.m_type))
1991                 format = DataFormatJSCell;
1992             else if (isBooleanSpeculation(value.m_type))
1993                 format = DataFormatJSBoolean;
1994             else
1995                 format = DataFormatJS;
1996 
1997             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), result.gpr(), format);
1998             break;
1999         }
2000         break;
2001     }
2002 
2003     case MovHint: {
2004         compileMovHint(m_currentNode);
2005         noResult(node);
2006         break;
2007     }
2008 
2009     case ZombieHint: {
<span class="line-modified">2010         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);</span>
2011         noResult(node);
2012         break;
2013     }
2014 
2015     case ExitOK: {
2016         noResult(node);
2017         break;
2018     }
2019 
2020     case SetLocal: {
2021         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
2022         case FlushedDouble: {
2023             SpeculateDoubleOperand value(this, node-&gt;child1());
2024             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2025             noResult(node);
2026             // Indicate that it&#39;s no longer necessary to retrieve the value of
2027             // this bytecode variable from registers or other locations in the stack,
2028             // but that it is stored as a double.
2029             recordSetLocal(DataFormatDouble);
2030             break;
</pre>
<hr />
<pre>
2095     case ArithBitNot:
2096         compileBitwiseNot(node);
2097         break;
2098 
2099     case ValueBitAnd:
2100     case ValueBitXor:
2101     case ValueBitOr:
2102         compileValueBitwiseOp(node);
2103         break;
2104 
2105     case ArithBitAnd:
2106     case ArithBitOr:
2107     case ArithBitXor:
2108         compileBitwiseOp(node);
2109         break;
2110 
2111     case ValueBitLShift:
2112         compileValueLShiftOp(node);
2113         break;
2114 
<span class="line-modified">2115     case ValueBitRShift:</span>
<span class="line-added">2116         compileValueBitRShift(node);</span>
<span class="line-added">2117         break;</span>
<span class="line-added">2118 </span>
<span class="line-added">2119     case ArithBitRShift:</span>
2120     case ArithBitLShift:
2121     case BitURShift:
2122         compileShiftOp(node);
2123         break;
2124 
2125     case UInt32ToNumber: {
2126         compileUInt32ToNumber(node);
2127         break;
2128     }
2129 
2130     case DoubleAsInt32: {
2131         compileDoubleAsInt32(node);
2132         break;
2133     }
2134 
2135     case ValueToInt32: {
2136         compileValueToInt32(node);
2137         break;
2138     }
2139 
</pre>
<hr />
<pre>
2338         break;
2339 
2340     case CompareStrictEq:
2341         if (compileStrictEq(node))
2342             return;
2343         break;
2344 
2345     case CompareEqPtr:
2346         compileCompareEqPtr(node);
2347         break;
2348 
2349     case SameValue:
2350         compileSameValue(node);
2351         break;
2352 
2353     case StringCharCodeAt: {
2354         compileGetCharCodeAt(node);
2355         break;
2356     }
2357 
<span class="line-added">2358     case StringCodePointAt: {</span>
<span class="line-added">2359         compileStringCodePointAt(node);</span>
<span class="line-added">2360         break;</span>
<span class="line-added">2361     }</span>
<span class="line-added">2362 </span>
2363     case StringCharAt: {
2364         // Relies on StringCharAt node having same basic layout as GetByVal
2365         compileGetByValOnString(node);
2366         break;
2367     }
2368 
2369     case StringFromCharCode: {
2370         compileFromCharCode(node);
2371         break;
2372     }
2373 
<span class="line-added">2374     case CheckNeutered: {</span>
<span class="line-added">2375         compileCheckNeutered(node);</span>
<span class="line-added">2376         break;</span>
<span class="line-added">2377     }</span>
<span class="line-added">2378 </span>
<span class="line-added">2379     case CheckArrayOrEmpty:</span>
2380     case CheckArray: {
2381         checkArray(node);
2382         break;
2383     }
2384 
2385     case Arrayify:
2386     case ArrayifyToStructure: {
2387         arrayify(node);
2388         break;
2389     }
2390 
2391     case GetByVal: {
2392         switch (node-&gt;arrayMode().type()) {
2393         case Array::AnyTypedArray:
2394         case Array::ForceExit:
2395         case Array::SelectUsingArguments:
2396         case Array::SelectUsingPredictions:
2397         case Array::Unprofiled:
2398             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2399             break;
2400         case Array::Undecided: {
2401             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2402             GPRTemporary result(this, Reuse, index);
2403             GPRReg indexGPR = index.gpr();
2404             GPRReg resultGPR = result.gpr();
2405 
2406             speculationCheck(OutOfBounds, JSValueRegs(), node,
2407                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2408 
2409             use(m_graph.varArgChild(node, 0));
2410             index.use();
2411 
<span class="line-modified">2412             m_jit.move(MacroAssembler::TrustedImm64(JSValue::ValueUndefined), resultGPR);</span>
2413             jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
2414             break;
2415         }
2416         case Array::Generic: {
<span class="line-modified">2417             if (m_graph.m_slowGetByVal.contains(node)) {</span>
<span class="line-modified">2418                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">2419                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="line-modified">2420                         compileGetByValForObjectWithString(node);</span>
<span class="line-added">2421                         break;</span>
<span class="line-added">2422                     }</span>
<span class="line-added">2423 </span>
<span class="line-added">2424                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="line-added">2425                         compileGetByValForObjectWithSymbol(node);</span>
<span class="line-added">2426                         break;</span>
<span class="line-added">2427                     }</span>
2428                 }
2429 
<span class="line-modified">2430                 JSValueOperand base(this, m_graph.varArgChild(node, 0));</span>
<span class="line-modified">2431                 JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="line-modified">2432                 GPRReg baseGPR = base.gpr();</span>
<span class="line-modified">2433                 GPRReg propertyGPR = property.gpr();</span>
<span class="line-added">2434 </span>
<span class="line-added">2435                 flushRegisters();</span>
<span class="line-added">2436                 GPRFlushedCallResult result(this);</span>
<span class="line-added">2437                 callOperation(operationGetByVal, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR);</span>
<span class="line-added">2438                 m_jit.exceptionCheck();</span>
<span class="line-added">2439 </span>
<span class="line-added">2440                 jsValueResult(result.gpr(), node);</span>
<span class="line-added">2441                 break;</span>
2442             }
<span class="line-modified">2443 </span>
<span class="line-modified">2444             speculate(node, m_graph.varArgChild(node, 0));</span>
<span class="line-added">2445             speculate(node, m_graph.varArgChild(node, 1));</span>
<span class="line-added">2446 </span>
<span class="line-added">2447             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="line-added">2448             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="line-added">2449             GPRTemporary result(this, Reuse, property);</span>
2450             GPRReg baseGPR = base.gpr();
2451             GPRReg propertyGPR = property.gpr();
<span class="line-added">2452             GPRReg resultGPR = result.gpr();</span>
2453 
<span class="line-modified">2454             CodeOrigin codeOrigin = node-&gt;origin.semantic;</span>
<span class="line-modified">2455             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());</span>
<span class="line-modified">2456             RegisterSet usedRegisters = this-&gt;usedRegisters();</span>

2457 
<span class="line-modified">2458             JITCompiler::JumpList slowCases;</span>
<span class="line-added">2459             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))</span>
<span class="line-added">2460                 slowCases.append(m_jit.branchIfNotCell(baseGPR));</span>
<span class="line-added">2461 </span>
<span class="line-added">2462             JITGetByValGenerator gen(</span>
<span class="line-added">2463                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,</span>
<span class="line-added">2464                 JSValueRegs(baseGPR), JSValueRegs(propertyGPR), JSValueRegs(resultGPR));</span>
<span class="line-added">2465 </span>
<span class="line-added">2466             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="line-added">2467                 gen.stubInfo()-&gt;propertyIsString = true;</span>
<span class="line-added">2468             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="line-added">2469                 gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-added">2470             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="line-added">2471                 gen.stubInfo()-&gt;propertyIsSymbol = true;</span>
<span class="line-added">2472 </span>
<span class="line-added">2473             gen.generateFastPath(m_jit);</span>
<span class="line-added">2474 </span>
<span class="line-added">2475             slowCases.append(gen.slowPathJump());</span>
<span class="line-added">2476 </span>
<span class="line-added">2477             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(</span>
<span class="line-added">2478                 slowCases, this, operationGetByValOptimize,</span>
<span class="line-added">2479                 resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseGPR, propertyGPR);</span>
<span class="line-added">2480 </span>
<span class="line-added">2481             m_jit.addGetByVal(gen, slowPath.get());</span>
<span class="line-added">2482             addSlowPathGenerator(WTFMove(slowPath));</span>
<span class="line-added">2483 </span>
<span class="line-added">2484             jsValueResult(resultGPR, node);</span>
2485             break;
2486         }
2487         case Array::Int32:
2488         case Array::Contiguous: {
2489             if (node-&gt;arrayMode().isInBounds()) {
2490                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2491                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2492 
2493                 GPRReg propertyReg = property.gpr();
2494                 GPRReg storageReg = storage.gpr();
2495 
2496                 if (!m_compileOkay)
2497                     return;
2498 
2499                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2500 
2501                 GPRTemporary result(this);
2502 
2503                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.gpr());
2504                 if (node-&gt;arrayMode().isSaneChain()) {
</pre>
<hr />
<pre>
2522             GPRReg baseReg = base.gpr();
2523             GPRReg propertyReg = property.gpr();
2524             GPRReg storageReg = storage.gpr();
2525 
2526             if (!m_compileOkay)
2527                 return;
2528 
2529             GPRTemporary result(this);
2530             GPRReg resultReg = result.gpr();
2531 
2532             MacroAssembler::JumpList slowCases;
2533 
2534             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2535 
2536             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2537             slowCases.append(m_jit.branchIfEmpty(resultReg));
2538 
2539             addSlowPathGenerator(
2540                 slowPathCall(
2541                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2542                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2543 
2544             jsValueResult(resultReg, node);
2545             break;
2546         }
2547 
2548         case Array::Double: {
2549             if (node-&gt;arrayMode().isInBounds()) {
2550                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2551                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2552 
2553                 GPRReg propertyReg = property.gpr();
2554                 GPRReg storageReg = storage.gpr();
2555 
2556                 if (!m_compileOkay)
2557                     return;
2558 
2559                 FPRTemporary result(this);
2560                 FPRReg resultReg = result.fpr();
2561 
2562                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
</pre>
<hr />
<pre>
2578 
2579             if (!m_compileOkay)
2580                 return;
2581 
2582             GPRTemporary result(this);
2583             FPRTemporary temp(this);
2584             GPRReg resultReg = result.gpr();
2585             FPRReg tempReg = temp.fpr();
2586 
2587             MacroAssembler::JumpList slowCases;
2588 
2589             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2590 
2591             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2592             slowCases.append(m_jit.branchIfNaN(tempReg));
2593             boxDouble(tempReg, resultReg);
2594 
2595             addSlowPathGenerator(
2596                 slowPathCall(
2597                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2598                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2599 
2600             jsValueResult(resultReg, node);
2601             break;
2602         }
2603 
2604         case Array::ArrayStorage:
2605         case Array::SlowPutArrayStorage: {
2606             if (node-&gt;arrayMode().isInBounds()) {
2607                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2608                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2609 
2610                 GPRReg propertyReg = property.gpr();
2611                 GPRReg storageReg = storage.gpr();
2612 
2613                 if (!m_compileOkay)
2614                     return;
2615 
2616                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2617 
2618                 GPRTemporary result(this);
</pre>
<hr />
<pre>
2630             GPRReg baseReg = base.gpr();
2631             GPRReg propertyReg = property.gpr();
2632             GPRReg storageReg = storage.gpr();
2633 
2634             if (!m_compileOkay)
2635                 return;
2636 
2637             GPRTemporary result(this);
2638             GPRReg resultReg = result.gpr();
2639 
2640             MacroAssembler::JumpList slowCases;
2641 
2642             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2643 
2644             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), resultReg);
2645             slowCases.append(m_jit.branchIfEmpty(resultReg));
2646 
2647             addSlowPathGenerator(
2648                 slowPathCall(
2649                     slowCases, this, operationGetByValObjectInt,
<span class="line-modified">2650                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2651 
2652             jsValueResult(resultReg, node);
2653             break;
2654         }
2655         case Array::String:
2656             compileGetByValOnString(node);
2657             break;
2658         case Array::DirectArguments:
2659             compileGetByValOnDirectArguments(node);
2660             break;
2661         case Array::ScopedArguments:
2662             compileGetByValOnScopedArguments(node);
2663             break;
2664         case Array::Int8Array:
2665         case Array::Int16Array:
2666         case Array::Int32Array:
2667         case Array::Uint8Array:
2668         case Array::Uint8ClampedArray:
2669         case Array::Uint16Array:
2670         case Array::Uint32Array:
</pre>
<hr />
<pre>
2708                     compilePutByValForCellWithString(node, child1, child2, child3);
2709                     alreadyHandled = true;
2710                     break;
2711                 }
2712 
2713                 if (child2.useKind() == SymbolUse) {
2714                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2715                     alreadyHandled = true;
2716                     break;
2717                 }
2718             }
2719 
2720             JSValueOperand arg1(this, child1);
2721             JSValueOperand arg2(this, child2);
2722             JSValueOperand arg3(this, child3);
2723             GPRReg arg1GPR = arg1.gpr();
2724             GPRReg arg2GPR = arg2.gpr();
2725             GPRReg arg3GPR = arg3.gpr();
2726             flushRegisters();
2727             if (node-&gt;op() == PutByValDirect)
<span class="line-modified">2728                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
2729             else
<span class="line-modified">2730                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
2731             m_jit.exceptionCheck();
2732 
2733             noResult(node);
2734             alreadyHandled = true;
2735             break;
2736         }
2737         default:
2738             break;
2739         }
2740 
2741         if (alreadyHandled)
2742             break;
2743 
2744         SpeculateCellOperand base(this, child1);
2745         SpeculateStrictInt32Operand property(this, child2);
2746 
2747         GPRReg baseReg = base.gpr();
2748         GPRReg propertyReg = property.gpr();
2749 
2750         switch (arrayMode.type()) {
</pre>
<hr />
<pre>
2795 
2796                 m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2797                 m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2798 
2799                 inBounds.link(&amp;m_jit);
2800             }
2801 
2802             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2803 
2804             base.use();
2805             property.use();
2806             value.use();
2807             storage.use();
2808 
2809             if (arrayMode.isOutOfBounds()) {
2810                 addSlowPathGenerator(slowPathCall(
2811                     slowCase, this,
2812                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2813                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2814                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="line-modified">2815                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
2816             }
2817 
2818             noResult(node, UseChildrenCalledExplicitly);
2819             break;
2820         }
2821 
2822         case Array::Double: {
2823             compileDoublePutByVal(node, base, property);
2824             break;
2825         }
2826 
2827         case Array::ArrayStorage:
2828         case Array::SlowPutArrayStorage: {
2829             JSValueOperand value(this, child3);
2830 
2831             GPRReg valueReg = value.gpr();
2832 
2833             if (!m_compileOkay)
2834                 return;
2835 
</pre>
<hr />
<pre>
2879 
2880                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2881                 }
2882                 notHoleValue.link(&amp;m_jit);
2883             }
2884 
2885             // Store the value to the array.
2886             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2887 
2888             base.use();
2889             property.use();
2890             value.use();
2891             storage.use();
2892 
2893             if (!slowCases.empty()) {
2894                 addSlowPathGenerator(slowPathCall(
2895                     slowCases, this,
2896                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2897                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2898                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="line-modified">2899                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
2900             }
2901 
2902             noResult(node, UseChildrenCalledExplicitly);
2903             break;
2904         }
2905 
2906         case Array::Int8Array:
2907         case Array::Int16Array:
2908         case Array::Int32Array:
2909         case Array::Uint8Array:
2910         case Array::Uint8ClampedArray:
2911         case Array::Uint16Array:
2912         case Array::Uint32Array:
2913         case Array::Float32Array:
2914         case Array::Float64Array: {
2915             TypedArrayType type = arrayMode.typedArrayType();
2916             if (isInt(type))
2917                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2918             else
2919                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
</pre>
<hr />
<pre>
2941     case AtomicsExchange:
2942     case AtomicsLoad:
2943     case AtomicsOr:
2944     case AtomicsStore:
2945     case AtomicsSub:
2946     case AtomicsXor: {
2947         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2948         Edge baseEdge = m_jit.graph().child(node, 0);
2949         Edge indexEdge = m_jit.graph().child(node, 1);
2950         Edge argEdges[maxNumExtraAtomicsArgs];
2951         for (unsigned i = numExtraArgs; i--;)
2952             argEdges[i] = m_jit.graph().child(node, 2 + i);
2953         Edge storageEdge = m_jit.graph().child(node, 2 + numExtraArgs);
2954 
2955         GPRReg baseGPR;
2956         GPRReg indexGPR;
2957         GPRReg argGPRs[2];
2958         GPRReg resultGPR;
2959 
2960         auto callSlowPath = [&amp;] () {
<span class="line-added">2961             auto globalObjectImmPtr = TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic));</span>
2962             switch (node-&gt;op()) {
2963             case AtomicsAdd:
<span class="line-modified">2964                 callOperation(operationAtomicsAdd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2965                 break;
2966             case AtomicsAnd:
<span class="line-modified">2967                 callOperation(operationAtomicsAnd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2968                 break;
2969             case AtomicsCompareExchange:
<span class="line-modified">2970                 callOperation(operationAtomicsCompareExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);</span>
2971                 break;
2972             case AtomicsExchange:
<span class="line-modified">2973                 callOperation(operationAtomicsExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2974                 break;
2975             case AtomicsLoad:
<span class="line-modified">2976                 callOperation(operationAtomicsLoad, resultGPR, globalObjectImmPtr, baseGPR, indexGPR);</span>
2977                 break;
2978             case AtomicsOr:
<span class="line-modified">2979                 callOperation(operationAtomicsOr, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2980                 break;
2981             case AtomicsStore:
<span class="line-modified">2982                 callOperation(operationAtomicsStore, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2983                 break;
2984             case AtomicsSub:
<span class="line-modified">2985                 callOperation(operationAtomicsSub, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2986                 break;
2987             case AtomicsXor:
<span class="line-modified">2988                 callOperation(operationAtomicsXor, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2989                 break;
2990             default:
2991                 RELEASE_ASSERT_NOT_REACHED();
2992                 break;
2993             }
2994         };
2995 
2996         if (!storageEdge) {
2997             // We are in generic mode!
2998             JSValueOperand base(this, baseEdge);
2999             JSValueOperand index(this, indexEdge);
3000             Optional&lt;JSValueOperand&gt; args[2];
3001             baseGPR = base.gpr();
3002             indexGPR = index.gpr();
3003             for (unsigned i = numExtraArgs; i--;) {
3004                 args[i].emplace(this, argEdges[i]);
3005                 argGPRs[i] = args[i]-&gt;gpr();
3006             }
3007 
3008             flushRegisters();
</pre>
<hr />
<pre>
3139             m_jit.boxInt32(indexGPR, JSValueRegs(indexGPR));
3140             for (unsigned i = numExtraArgs; i--;)
3141                 m_jit.boxInt32(argGPRs[i], JSValueRegs(argGPRs[i]));
3142             callSlowPath();
3143             silentFillAllRegisters();
3144             m_jit.exceptionCheck();
3145         }
3146 
3147         success.link(&amp;m_jit);
3148         setIntTypedArrayLoadResult(node, resultGPR, type);
3149         break;
3150     }
3151 
3152     case AtomicsIsLockFree: {
3153         if (node-&gt;child1().useKind() != Int32Use) {
3154             JSValueOperand operand(this, node-&gt;child1());
3155             GPRReg operandGPR = operand.gpr();
3156             flushRegisters();
3157             GPRFlushedCallResult result(this);
3158             GPRReg resultGPR = result.gpr();
<span class="line-modified">3159             callOperation(operationAtomicsIsLockFree, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
3160             m_jit.exceptionCheck();
3161             jsValueResult(resultGPR, node);
3162             break;
3163         }
3164 
3165         SpeculateInt32Operand operand(this, node-&gt;child1());
3166         GPRTemporary result(this);
3167         GPRReg operandGPR = operand.gpr();
3168         GPRReg resultGPR = result.gpr();
<span class="line-modified">3169         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
3170         JITCompiler::JumpList done;
3171         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
3172         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
3173         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
<span class="line-modified">3174         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
3175         done.link(&amp;m_jit);
3176         jsValueResult(resultGPR, node);
3177         break;
3178     }
3179 
3180     case RegExpExec: {
3181         compileRegExpExec(node);
3182         break;
3183     }
3184 
3185     case RegExpExecNonGlobalOrSticky: {
3186         compileRegExpExecNonGlobalOrSticky(node);
3187         break;
3188     }
3189 
3190     case RegExpMatchFastGlobal: {
3191         compileRegExpMatchFastGlobal(node);
3192         break;
3193     }
3194 
</pre>
<hr />
<pre>
3275                     MacroAssembler::TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3276                 slowCase = m_jit.branchIfNaN(tempFPR);
3277                 boxDouble(tempFPR, valueGPR);
3278             } else {
3279                 m_jit.load64(
3280                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3281                     valueGPR);
3282                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3283                 // length and the new length.
3284                 m_jit.store64(
3285                 MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3286                 slowCase = m_jit.branchIfEmpty(valueGPR);
3287             }
3288 
3289             addSlowPathGenerator(
3290                 slowPathMove(
3291                     undefinedCase, this,
3292                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3293             addSlowPathGenerator(
3294                 slowPathCall(
<span class="line-modified">3295                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
3296 
3297             // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
3298             jsValueResult(valueGPR, node);
3299             break;
3300         }
3301 
3302         case Array::ArrayStorage: {
3303             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
3304 
3305             JITCompiler::Jump undefinedCase =
3306                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3307 
3308             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3309 
3310             JITCompiler::JumpList slowCases;
3311             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset())));
3312 
3313             m_jit.load64(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), valueGPR);
3314             slowCases.append(m_jit.branchIfEmpty(valueGPR));
3315 
3316             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
3317 
3318             m_jit.store64(MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight,  ArrayStorage::vectorOffset()));
3319             m_jit.sub32(MacroAssembler::TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
3320 
3321             addSlowPathGenerator(
3322                 slowPathMove(
3323                     undefinedCase, this,
3324                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3325 
3326             addSlowPathGenerator(
3327                 slowPathCall(
<span class="line-modified">3328                     slowCases, this, operationArrayPop, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
3329 
3330             jsValueResult(valueGPR, node);
3331             break;
3332         }
3333 
3334         default:
3335             CRASH();
3336             break;
3337         }
3338         break;
3339     }
3340 
3341     case DFG::Jump: {
3342         jump(node-&gt;targetBlock());
3343         noResult(node);
3344         break;
3345     }
3346 
3347     case Branch:
3348         emitBranch(node);
</pre>
<hr />
<pre>
3369         break;
3370     }
3371 
3372     case Throw: {
3373         compileThrow(node);
3374         break;
3375     }
3376 
3377     case ThrowStaticError: {
3378         compileThrowStaticError(node);
3379         break;
3380     }
3381 
3382     case BooleanToNumber: {
3383         switch (node-&gt;child1().useKind()) {
3384         case BooleanUse: {
3385             JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
3386             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3387 
3388             m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">3389             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
3390             DFG_TYPE_CHECK(
3391                 JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
3392                     JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
3393 
3394             int32Result(result.gpr(), node);
3395             break;
3396         }
3397 
3398         case UntypedUse: {
3399             JSValueOperand value(this, node-&gt;child1());
3400             GPRTemporary result(this);
3401 
3402             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3403                 m_jit.move(value.gpr(), result.gpr());
3404                 m_jit.and32(TrustedImm32(1), result.gpr());
3405                 int32Result(result.gpr(), node);
3406                 break;
3407             }
3408 
3409             m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">3410             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
3411             JITCompiler::Jump isBoolean = m_jit.branchTest64(
3412                 JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
3413             m_jit.move(value.gpr(), result.gpr());
3414             JITCompiler::Jump done = m_jit.jump();
3415             isBoolean.link(&amp;m_jit);
<span class="line-modified">3416             m_jit.or64(GPRInfo::numberTagRegister, result.gpr());</span>
3417             done.link(&amp;m_jit);
3418 
3419             jsValueResult(result.gpr(), node);
3420             break;
3421         }
3422 
3423         default:
3424             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
3425             break;
3426         }
3427         break;
3428     }
3429 
3430     case ToPrimitive: {
3431         compileToPrimitive(node);
3432         break;
3433     }
3434 
<span class="line-added">3435     case ToPropertyKey: {</span>
<span class="line-added">3436         compileToPropertyKey(node);</span>
<span class="line-added">3437         break;</span>
<span class="line-added">3438     }</span>
<span class="line-added">3439 </span>
3440     case ToNumber: {
3441         JSValueOperand argument(this, node-&gt;child1());
3442         GPRTemporary result(this, Reuse, argument);
3443 
3444         GPRReg argumentGPR = argument.gpr();
3445         GPRReg resultGPR = result.gpr();
3446 
3447         argument.use();
3448 
3449         // We have several attempts to remove ToNumber. But ToNumber still exists.
3450         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3451         // Instead of the slow path generator, we emit callOperation here.
3452         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3453             flushRegisters();
<span class="line-modified">3454             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
3455             m_jit.exceptionCheck();
3456         } else {
3457             MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
3458             m_jit.move(argumentGPR, resultGPR);
3459             MacroAssembler::Jump done = m_jit.jump();
3460 
3461             notNumber.link(&amp;m_jit);
3462             silentSpillAllRegisters(resultGPR);
<span class="line-modified">3463             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
3464             silentFillAllRegisters();
3465             m_jit.exceptionCheck();
3466 
3467             done.link(&amp;m_jit);
3468         }
3469 
3470         jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
3471         break;
3472     }
3473 
<span class="line-added">3474     case ToNumeric: {</span>
<span class="line-added">3475         compileToNumeric(node);</span>
<span class="line-added">3476         break;</span>
<span class="line-added">3477     }</span>
<span class="line-added">3478 </span>
3479     case ToString:
3480     case CallStringConstructor:
3481     case StringValueOf: {
3482         compileToStringOrCallStringConstructorOrStringValueOf(node);
3483         break;
3484     }
3485 
3486     case NewStringObject: {
3487         compileNewStringObject(node);
3488         break;
3489     }
3490 
3491     case NewSymbol: {
3492         compileNewSymbol(node);
3493         break;
3494     }
3495 
3496     case NewArray: {
3497         compileNewArray(node);
3498         break;
</pre>
<hr />
<pre>
3537     case ToThis: {
3538         compileToThis(node);
3539         break;
3540     }
3541 
3542     case ObjectCreate: {
3543         compileObjectCreate(node);
3544         break;
3545     }
3546 
3547     case ObjectKeys: {
3548         compileObjectKeys(node);
3549         break;
3550     }
3551 
3552     case CreateThis: {
3553         compileCreateThis(node);
3554         break;
3555     }
3556 
<span class="line-added">3557     case CreatePromise: {</span>
<span class="line-added">3558         compileCreatePromise(node);</span>
<span class="line-added">3559         break;</span>
<span class="line-added">3560     }</span>
<span class="line-added">3561 </span>
<span class="line-added">3562     case CreateGenerator: {</span>
<span class="line-added">3563         compileCreateGenerator(node);</span>
<span class="line-added">3564         break;</span>
<span class="line-added">3565     }</span>
<span class="line-added">3566 </span>
<span class="line-added">3567     case CreateAsyncGenerator: {</span>
<span class="line-added">3568         compileCreateAsyncGenerator(node);</span>
<span class="line-added">3569         break;</span>
<span class="line-added">3570     }</span>
<span class="line-added">3571 </span>
3572     case NewObject: {
3573         compileNewObject(node);
3574         break;
3575     }
3576 
<span class="line-added">3577     case NewPromise: {</span>
<span class="line-added">3578         compileNewPromise(node);</span>
<span class="line-added">3579         break;</span>
<span class="line-added">3580     }</span>
<span class="line-added">3581 </span>
<span class="line-added">3582     case NewGenerator: {</span>
<span class="line-added">3583         compileNewGenerator(node);</span>
<span class="line-added">3584         break;</span>
<span class="line-added">3585     }</span>
<span class="line-added">3586 </span>
<span class="line-added">3587     case NewAsyncGenerator: {</span>
<span class="line-added">3588         compileNewAsyncGenerator(node);</span>
<span class="line-added">3589         break;</span>
<span class="line-added">3590     }</span>
<span class="line-added">3591 </span>
<span class="line-added">3592     case NewArrayIterator: {</span>
<span class="line-added">3593         compileNewArrayIterator(node);</span>
<span class="line-added">3594         break;</span>
<span class="line-added">3595     }</span>
<span class="line-added">3596 </span>
3597     case GetCallee: {
3598         compileGetCallee(node);
3599         break;
3600     }
3601 
3602     case SetCallee: {
3603         compileSetCallee(node);
3604         break;
3605     }
3606 
3607     case GetArgumentCountIncludingThis: {
3608         compileGetArgumentCountIncludingThis(node);
3609         break;
3610     }
3611 
3612     case SetArgumentCountIncludingThis:
3613         compileSetArgumentCountIncludingThis(node);
3614         break;
3615 
3616     case GetRestLength: {
</pre>
<hr />
<pre>
3626         compileSkipScope(node);
3627         break;
3628 
3629     case GetGlobalObject:
3630         compileGetGlobalObject(node);
3631         break;
3632 
3633     case GetGlobalThis:
3634         compileGetGlobalThis(node);
3635         break;
3636 
3637     case GetClosureVar: {
3638         compileGetClosureVar(node);
3639         break;
3640     }
3641     case PutClosureVar: {
3642         compilePutClosureVar(node);
3643         break;
3644     }
3645 
<span class="line-added">3646     case GetInternalField: {</span>
<span class="line-added">3647         compileGetInternalField(node);</span>
<span class="line-added">3648         break;</span>
<span class="line-added">3649     }</span>
<span class="line-added">3650 </span>
<span class="line-added">3651     case PutInternalField: {</span>
<span class="line-added">3652         compilePutInternalField(node);</span>
<span class="line-added">3653         break;</span>
<span class="line-added">3654     }</span>
<span class="line-added">3655 </span>
3656     case TryGetById: {
<span class="line-modified">3657         compileGetById(node, AccessType::TryGetById);</span>
3658         break;
3659     }
3660 
3661     case GetByIdDirect: {
<span class="line-modified">3662         compileGetById(node, AccessType::GetByIdDirect);</span>
3663         break;
3664     }
3665 
3666     case GetByIdDirectFlush: {
<span class="line-modified">3667         compileGetByIdFlush(node, AccessType::GetByIdDirect);</span>
3668         break;
3669     }
3670 
3671     case GetById: {
<span class="line-modified">3672         compileGetById(node, AccessType::GetById);</span>
3673         break;
3674     }
3675 
3676     case GetByIdFlush: {
<span class="line-modified">3677         compileGetByIdFlush(node, AccessType::GetById);</span>
3678         break;
3679     }
3680 
3681     case GetByIdWithThis: {
3682         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3683             SpeculateCellOperand base(this, node-&gt;child1());
3684             GPRReg baseGPR = base.gpr();
3685             SpeculateCellOperand thisValue(this, node-&gt;child2());
3686             GPRReg thisValueGPR = thisValue.gpr();
3687 
3688             GPRFlushedCallResult result(this);
3689             GPRReg resultGPR = result.gpr();
3690 
3691             flushRegisters();
3692 
3693             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), JITCompiler::JumpList());
3694 
3695             jsValueResult(resultGPR, node);
3696 
3697         } else {
</pre>
<hr />
<pre>
3736         break;
3737     }
3738 
3739     case CheckNotEmpty: {
3740         compileCheckNotEmpty(node);
3741         break;
3742     }
3743 
3744     case AssertNotEmpty: {
3745         if (validationEnabled()) {
3746             JSValueOperand operand(this, node-&gt;child1());
3747             GPRReg input = operand.gpr();
3748             auto done = m_jit.branchIfNotEmpty(input);
3749             m_jit.breakpoint();
3750             done.link(&amp;m_jit);
3751         }
3752         noResult(node);
3753         break;
3754     }
3755 
<span class="line-modified">3756     case CheckIdent:</span>
<span class="line-modified">3757         compileCheckIdent(node);</span>
3758         break;
3759 
3760     case GetExecutable: {
3761         compileGetExecutable(node);
3762         break;
3763     }
3764 
3765     case CheckStructureOrEmpty: {
3766         SpeculateCellOperand cell(this, node-&gt;child1());
3767         GPRReg cellGPR = cell.gpr();
3768 
3769         GPRReg tempGPR = InvalidGPRReg;
3770         Optional&lt;GPRTemporary&gt; temp;
3771         if (node-&gt;structureSet().size() &gt; 1) {
3772             temp.emplace(this);
3773             tempGPR = temp-&gt;gpr();
3774         }
3775 
3776         MacroAssembler::Jump isEmpty;
3777         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
</pre>
<hr />
<pre>
3880         compilePutById(node);
3881         break;
3882     }
3883 
3884     case PutByIdWithThis: {
3885         compilePutByIdWithThis(node);
3886         break;
3887     }
3888 
3889     case PutByValWithThis: {
3890         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
3891         GPRReg baseGPR = base.gpr();
3892         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
3893         GPRReg thisValueGPR = thisValue.gpr();
3894         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
3895         GPRReg propertyGPR = property.gpr();
3896         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
3897         GPRReg valueGPR = value.gpr();
3898 
3899         flushRegisters();
<span class="line-modified">3900         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, thisValueGPR, propertyGPR, valueGPR);</span>
3901         m_jit.exceptionCheck();
3902 
3903         noResult(node);
3904         break;
3905     }
3906 
3907     case PutByIdDirect: {
3908         compilePutByIdDirect(node);
3909         break;
3910     }
3911 
3912     case PutGetterById:
3913     case PutSetterById: {
3914         compilePutAccessorById(node);
3915         break;
3916     }
3917 
3918     case PutGetterSetterById: {
3919         compilePutGetterSetterById(node);
3920         break;
</pre>
<hr />
<pre>
3985     case OverridesHasInstance: {
3986         compileOverridesHasInstance(node);
3987         break;
3988     }
3989 
3990     case InstanceOf: {
3991         compileInstanceOf(node);
3992         break;
3993     }
3994 
3995     case InstanceOfCustom: {
3996         compileInstanceOfCustom(node);
3997         break;
3998     }
3999 
4000     case IsEmpty: {
4001         JSValueOperand value(this, node-&gt;child1());
4002         GPRTemporary result(this, Reuse, value);
4003 
4004         m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
<span class="line-modified">4005         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4006 
4007         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4008         break;
4009     }
4010 
4011     case IsUndefined: {
4012         JSValueOperand value(this, node-&gt;child1());
4013         GPRTemporary result(this);
4014         GPRTemporary localGlobalObject(this);
4015         GPRTemporary remoteGlobalObject(this);
4016         GPRTemporary scratch(this);
4017 
4018         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
4019 
<span class="line-modified">4020         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::ValueUndefined), result.gpr());</span>
4021         JITCompiler::Jump done = m_jit.jump();
4022 
4023         isCell.link(&amp;m_jit);
4024         JITCompiler::Jump notMasqueradesAsUndefined;
4025         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
4026             m_jit.move(TrustedImm32(0), result.gpr());
4027             notMasqueradesAsUndefined = m_jit.jump();
4028         } else {
4029             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
4030                 JITCompiler::NonZero,
4031                 JITCompiler::Address(value.gpr(), JSCell::typeInfoFlagsOffset()),
4032                 TrustedImm32(MasqueradesAsUndefined));
4033             m_jit.move(TrustedImm32(0), result.gpr());
4034             notMasqueradesAsUndefined = m_jit.jump();
4035 
4036             isMasqueradesAsUndefined.link(&amp;m_jit);
4037             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
4038             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
4039             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
4040             m_jit.emitLoadStructure(vm(), value.gpr(), result.gpr(), scratch.gpr());
4041             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
4042             m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
4043         }
4044 
4045         notMasqueradesAsUndefined.link(&amp;m_jit);
4046         done.link(&amp;m_jit);
<span class="line-modified">4047         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4048         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4049         break;
4050     }
4051 
4052     case IsUndefinedOrNull: {
4053         JSValueOperand value(this, node-&gt;child1());
4054         GPRTemporary result(this, Reuse, value);
4055 
4056         GPRReg valueGPR = value.gpr();
4057         GPRReg resultGPR = result.gpr();
4058 
4059         m_jit.move(valueGPR, resultGPR);
<span class="line-modified">4060         m_jit.and64(CCallHelpers::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified">4061         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
4062 
4063         unblessedBooleanResult(resultGPR, node);
4064         break;
4065     }
4066 
4067     case IsBoolean: {
4068         JSValueOperand value(this, node-&gt;child1());
4069         GPRTemporary result(this, Reuse, value);
4070 
4071         m_jit.move(value.gpr(), result.gpr());
<span class="line-modified">4072         m_jit.xor64(JITCompiler::TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4073         m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
<span class="line-modified">4074         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4075         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4076         break;
4077     }
4078 
4079     case IsNumber: {
4080         JSValueOperand value(this, node-&gt;child1());
4081         GPRTemporary result(this, Reuse, value);
4082 
<span class="line-modified">4083         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::numberTagRegister, result.gpr());</span>
<span class="line-modified">4084         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4085         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4086         break;
4087     }
4088 
4089     case NumberIsInteger: {
4090         JSValueOperand value(this, node-&gt;child1());
4091         GPRTemporary result(this, Reuse, value);
4092 
4093         FPRTemporary temp1(this);
4094         FPRTemporary temp2(this);
4095 
4096         JSValueRegs valueRegs = JSValueRegs(value.gpr());
4097         GPRReg resultGPR = result.gpr();
4098 
4099         FPRReg tempFPR1 = temp1.fpr();
4100         FPRReg tempFPR2 = temp2.fpr();
4101 
4102         MacroAssembler::JumpList done;
4103 
4104         auto isInt32 = m_jit.branchIfInt32(valueRegs);
4105         auto notNumber = m_jit.branchIfNotDoubleKnownNotInt32(valueRegs);
4106 
4107         // We&#39;re a double here.
4108         m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
4109         m_jit.urshift64(TrustedImm32(52), resultGPR);
4110         m_jit.and32(TrustedImm32(0x7ff), resultGPR);
4111         auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
<span class="line-modified">4112         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4113         done.append(m_jit.jump());
4114 
4115         notNanNorInfinity.link(&amp;m_jit);
4116         m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
4117         m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
<span class="line-modified">4118         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4119         done.append(m_jit.jump());
4120 
4121         isInt32.link(&amp;m_jit);
<span class="line-modified">4122         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
4123         done.append(m_jit.jump());
4124 
4125         notNumber.link(&amp;m_jit);
<span class="line-modified">4126         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4127 
4128         done.link(&amp;m_jit);
4129         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4130         break;
4131     }
4132 
4133     case MapHash: {
4134         switch (node-&gt;child1().useKind()) {
4135         case BooleanUse:
4136         case Int32Use:
4137         case SymbolUse:
4138         case ObjectUse: {
4139             JSValueOperand input(this, node-&gt;child1(), ManualOperandSpeculation);
4140             GPRTemporary result(this, Reuse, input);
4141             GPRTemporary temp(this);
4142 
4143             GPRReg inputGPR = input.gpr();
4144             GPRReg resultGPR = result.gpr();
4145             GPRReg tempGPR = temp.gpr();
4146 
</pre>
<hr />
<pre>
4171 
4172             if (node-&gt;child1().useKind() == StringUse)
4173                 speculateString(node-&gt;child1(), inputGPR);
4174             else {
4175                 auto isString = m_jit.branchIfString(inputGPR);
4176                 m_jit.move(inputGPR, resultGPR);
4177                 m_jit.wangsInt64Hash(resultGPR, tempGPR);
4178                 done.append(m_jit.jump());
4179                 isString.link(&amp;m_jit);
4180             }
4181 
4182             m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4183             slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4184             m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4185             m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4186             slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4187             done.append(m_jit.jump());
4188 
4189             slowPath.link(&amp;m_jit);
4190             silentSpillAllRegisters(resultGPR);
<span class="line-modified">4191             callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
4192             silentFillAllRegisters();
4193             m_jit.exceptionCheck();
4194 
4195             done.link(&amp;m_jit);
4196             int32Result(resultGPR, node);
4197             break;
4198         }
4199         default:
4200             RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
4201             break;
4202         }
4203 
4204         if (node-&gt;child1().useKind() != UntypedUse)
4205             break;
4206 
4207         JSValueOperand input(this, node-&gt;child1());
4208         GPRTemporary temp(this);
4209         GPRTemporary result(this);
4210 
4211         GPRReg inputGPR = input.gpr();
</pre>
<hr />
<pre>
4214 
4215         MacroAssembler::JumpList straightHash;
4216         MacroAssembler::JumpList done;
4217         straightHash.append(m_jit.branchIfNotCell(inputGPR));
4218         MacroAssembler::JumpList slowPath;
4219         straightHash.append(m_jit.branchIfNotString(inputGPR));
4220         m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4221         slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4222         m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4223         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4224         slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4225         done.append(m_jit.jump());
4226 
4227         straightHash.link(&amp;m_jit);
4228         m_jit.move(inputGPR, resultGPR);
4229         m_jit.wangsInt64Hash(resultGPR, tempGPR);
4230         done.append(m_jit.jump());
4231 
4232         slowPath.link(&amp;m_jit);
4233         silentSpillAllRegisters(resultGPR);
<span class="line-modified">4234         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
4235         silentFillAllRegisters();
4236         m_jit.exceptionCheck();
4237 
4238         done.link(&amp;m_jit);
4239         int32Result(resultGPR, node);
4240         break;
4241     }
4242 
4243     case NormalizeMapKey: {
4244         compileNormalizeMapKey(node);
4245         break;
4246     }
4247 
4248     case GetMapBucket: {
4249         SpeculateCellOperand map(this, node-&gt;child1());
4250         JSValueOperand key(this, node-&gt;child2(), ManualOperandSpeculation);
4251         SpeculateInt32Operand hash(this, node-&gt;child3());
4252         GPRTemporary mask(this);
4253         GPRTemporary index(this);
4254         GPRTemporary buffer(this);
</pre>
<hr />
<pre>
4332             slowPathCases.append(m_jit.branchIfString(keyGPR));
4333             // The first is a string, but the second is not, we continue to loop around.
4334             loopAround.append(m_jit.jump());
4335             break;
4336         }
4337         default:
4338             RELEASE_ASSERT_NOT_REACHED();
4339         }
4340 
4341 
4342         if (!loopAround.empty())
4343             loopAround.link(&amp;m_jit);
4344 
4345         m_jit.add32(TrustedImm32(1), indexGPR);
4346         m_jit.jump().linkTo(loop, &amp;m_jit);
4347 
4348         if (!slowPathCases.empty()) {
4349             slowPathCases.link(&amp;m_jit);
4350             silentSpillAllRegisters(indexGPR);
4351             if (node-&gt;child1().useKind() == MapObjectUse)
<span class="line-modified">4352                 callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
4353             else
<span class="line-modified">4354                 callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
4355             silentFillAllRegisters();
4356             m_jit.exceptionCheck();
4357             done.append(m_jit.jump());
4358         }
4359 
4360         notPresentInTable.link(&amp;m_jit);
4361         if (node-&gt;child1().useKind() == MapObjectUse)
4362             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelMapBucket()), resultGPR);
4363         else
4364             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelSetBucket()), resultGPR);
4365         done.link(&amp;m_jit);
4366         cellResult(resultGPR, node);
4367         break;
4368     }
4369 
4370     case GetMapBucketHead:
4371         compileGetMapBucketHead(node);
4372         break;
4373 
4374     case GetMapBucketNext:
</pre>
<hr />
<pre>
4463     case Call:
4464     case TailCall:
4465     case TailCallInlinedCaller:
4466     case Construct:
4467     case CallVarargs:
4468     case TailCallVarargs:
4469     case TailCallVarargsInlinedCaller:
4470     case CallForwardVarargs:
4471     case ConstructVarargs:
4472     case ConstructForwardVarargs:
4473     case TailCallForwardVarargs:
4474     case TailCallForwardVarargsInlinedCaller:
4475     case CallEval:
4476     case DirectCall:
4477     case DirectConstruct:
4478     case DirectTailCall:
4479     case DirectTailCallInlinedCaller:
4480         emitCall(node);
4481         break;
4482 
<span class="line-added">4483     case VarargsLength: {</span>
<span class="line-added">4484         compileVarargsLength(node);</span>
<span class="line-added">4485         break;</span>
<span class="line-added">4486     }</span>
<span class="line-added">4487 </span>
4488     case LoadVarargs: {
4489         compileLoadVarargs(node);
4490         break;
4491     }
4492 
4493     case ForwardVarargs: {
4494         compileForwardVarargs(node);
4495         break;
4496     }
4497 
4498     case CreateActivation: {
4499         compileCreateActivation(node);
4500         break;
4501     }
4502 
4503     case PushWithScope: {
4504         compilePushWithScope(node);
4505         break;
4506     }
4507 
</pre>
<hr />
<pre>
4517 
4518     case PutToArguments: {
4519         compilePutToArguments(node);
4520         break;
4521     }
4522 
4523     case GetArgument: {
4524         compileGetArgument(node);
4525         break;
4526     }
4527 
4528     case CreateScopedArguments: {
4529         compileCreateScopedArguments(node);
4530         break;
4531     }
4532 
4533     case CreateClonedArguments: {
4534         compileCreateClonedArguments(node);
4535         break;
4536     }
<span class="line-added">4537 </span>
<span class="line-added">4538     case CreateArgumentsButterfly: {</span>
<span class="line-added">4539         compileCreateArgumentsButterfly(node);</span>
<span class="line-added">4540         break;</span>
<span class="line-added">4541     }</span>
<span class="line-added">4542 </span>
4543     case CreateRest: {
4544         compileCreateRest(node);
4545         break;
4546     }
4547 
4548     case NewFunction:
4549     case NewGeneratorFunction:
4550     case NewAsyncGeneratorFunction:
4551     case NewAsyncFunction:
4552         compileNewFunction(node);
4553         break;
4554 
4555     case SetFunctionName:
4556         compileSetFunctionName(node);
4557         break;
4558 
4559     case InById:
4560         compileInById(node);
4561         break;
4562 
</pre>
<hr />
<pre>
4639         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4640         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4641         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4642         m_jit.add32(structureIDGPR, hashGPR);
4643         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4644         if (hasOneBitSet(sizeof(HasOwnPropertyCache::Entry))) // is a power of 2
4645             m_jit.lshift32(TrustedImm32(getLSBSet(sizeof(HasOwnPropertyCache::Entry))), hashGPR);
4646         else
4647             m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4648         ASSERT(vm().hasOwnPropertyCache());
4649         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
4650         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4651             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4652         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4653         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4654         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4655         auto done = m_jit.jump();
4656 
4657         slowPath.link(&amp;m_jit);
4658         silentSpillAllRegisters(resultGPR);
<span class="line-modified">4659         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyGPR);</span>
4660         silentFillAllRegisters();
4661         m_jit.exceptionCheck();
4662 
4663         done.link(&amp;m_jit);
<span class="line-modified">4664         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4665         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4666         break;
4667     }
4668 
4669     case CountExecution:
4670         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4671         break;
4672 
4673     case SuperSamplerBegin:
4674         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4675         break;
4676 
4677     case SuperSamplerEnd:
4678         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4679         break;
4680 
4681     case ForceOSRExit: {
4682         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4683         break;
4684     }
</pre>
<hr />
<pre>
4941                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4942                     emitLittleEndianCode();
4943                     auto done = m_jit.jump();
4944                     isBigEndian.link(&amp;m_jit);
4945                     emitBigEndianCode();
4946                     done.link(&amp;m_jit);
4947                 }
4948 
4949                 break;
4950             }
4951             default:
4952                 RELEASE_ASSERT_NOT_REACHED();
4953             }
4954 
4955             doubleResult(resultFPR, node);
4956         }
4957 
4958         break;
4959     }
4960 
<span class="line-added">4961     case DateGetInt32OrNaN:</span>
<span class="line-added">4962     case DateGetTime:</span>
<span class="line-added">4963         compileDateGet(node);</span>
<span class="line-added">4964         break;</span>
<span class="line-added">4965 </span>
4966     case DataViewSet: {
4967         SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
4968         GPRReg dataViewGPR = dataView.gpr();
4969         speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
4970 
4971         SpeculateInt32Operand index(this, m_graph.varArgChild(node, 1));
4972         GPRReg indexGPR = index.gpr();
4973 
4974         Optional&lt;SpeculateStrictInt52Operand&gt; int52Value;
4975         Optional&lt;SpeculateDoubleOperand&gt; doubleValue;
4976         Optional&lt;SpeculateInt32Operand&gt; int32Value;
4977         Optional&lt;FPRTemporary&gt; fprTemporary;
4978         GPRReg valueGPR = InvalidGPRReg;
4979         FPRReg valueFPR = InvalidFPRReg;
4980         FPRReg tempFPR = InvalidFPRReg;
4981 
4982         DataViewData data = node-&gt;dataViewData();
4983 
4984         Edge&amp; valueEdge = m_graph.varArgChild(node, 2);
4985         switch (valueEdge.useKind()) {
</pre>
<hr />
<pre>
5151             default:
5152                 RELEASE_ASSERT_NOT_REACHED();
5153             }
5154         }
5155 
5156         noResult(node);
5157         break;
5158     }
5159 
5160 #if ENABLE(FTL_JIT)
5161     case CheckTierUpInLoop: {
5162         MacroAssembler::Jump callTierUp = m_jit.branchAdd32(
5163             MacroAssembler::PositiveOrZero,
5164             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5165             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5166 
5167         MacroAssembler::Label toNextOperation = m_jit.label();
5168 
5169         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5170         silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
<span class="line-modified">5171         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5172 
5173         addSlowPathGeneratorLambda([=]() {
5174             callTierUp.link(&amp;m_jit);
5175 
5176             silentSpill(savePlans);
<span class="line-modified">5177             callOperation(operationTriggerTierUpNowInLoop, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
5178             silentFill(savePlans);
5179 
5180             m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5181         });
5182         break;
5183     }
5184 
5185     case CheckTierUpAtReturn: {
5186         MacroAssembler::Jump done = m_jit.branchAdd32(
5187             MacroAssembler::Signed,
5188             TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
5189             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5190 
5191         silentSpillAllRegisters(InvalidGPRReg);
<span class="line-modified">5192         callOperation(operationTriggerTierUpNow, &amp;vm());</span>
5193         silentFillAllRegisters();
5194 
5195         done.link(&amp;m_jit);
5196         break;
5197     }
5198 
5199     case CheckTierUpAndOSREnter: {
5200         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
5201 
5202         GPRTemporary temp(this);
5203         GPRReg tempGPR = temp.gpr();
5204 
<span class="line-modified">5205         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5206         auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
5207         DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
5208         JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
5209         static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
5210         static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
5211 
5212         MacroAssembler::Jump forceOSREntry = m_jit.branchTest8(MacroAssembler::NonZero, MacroAssembler::AbsoluteAddress(forceEntryTrigger));
5213         MacroAssembler::Jump overflowedCounter = m_jit.branchAdd32(
5214             MacroAssembler::PositiveOrZero,
5215             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5216             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5217         MacroAssembler::Label toNextOperation = m_jit.label();
5218 
5219         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5220         silentSpillAllRegistersImpl(false, savePlans, tempGPR);
5221 
5222         unsigned streamIndex = m_stream-&gt;size();
5223         m_jit.jitCode()-&gt;bytecodeIndexToStreamIndex.add(bytecodeIndex, streamIndex);
5224 
5225         addSlowPathGeneratorLambda([=]() {
5226             forceOSREntry.link(&amp;m_jit);
5227             overflowedCounter.link(&amp;m_jit);
5228 
5229             silentSpill(savePlans);
<span class="line-modified">5230             callOperation(operationTriggerOSREntryNow, tempGPR, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
5231 
5232             if (savePlans.isEmpty())
5233                 m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
5234             else {
5235                 MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
5236                 silentFill(savePlans);
5237                 m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5238                 osrEnter.link(&amp;m_jit);
5239             }
5240             m_jit.emitRestoreCalleeSaves();
5241             m_jit.farJump(tempGPR, GPRInfo::callFrameRegister);
5242         });
5243         break;
5244     }
5245 
5246 #else // ENABLE(FTL_JIT)
5247     case CheckTierUpInLoop:
5248     case CheckTierUpAtReturn:
5249     case CheckTierUpAndOSREnter:
5250         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
5251         break;
5252 #endif // ENABLE(FTL_JIT)
5253 
5254     case FilterCallLinkStatus:
<span class="line-modified">5255     case FilterGetByStatus:</span>
5256     case FilterPutByIdStatus:
5257     case FilterInByIdStatus:
5258         m_interpreter.filterICStatus(node);
5259         noResult(node);
5260         break;
5261 
5262     case LastNodeType:
5263     case EntrySwitch:
5264     case InitializeEntrypointArguments:
5265     case Phi:
5266     case Upsilon:
5267     case ExtractOSREntryLocal:
5268     case CheckInBounds:
5269     case ArithIMul:
5270     case MultiGetByOffset:
5271     case MultiPutByOffset:
5272     case FiatInt52:
5273     case CheckBadCell:
5274     case BottomValue:
5275     case PhantomNewObject:
5276     case PhantomNewFunction:
5277     case PhantomNewGeneratorFunction:
5278     case PhantomNewAsyncFunction:
5279     case PhantomNewAsyncGeneratorFunction:
<span class="line-added">5280     case PhantomNewArrayIterator:</span>
5281     case PhantomCreateActivation:
5282     case PhantomNewRegexp:
5283     case GetMyArgumentByVal:
5284     case GetMyArgumentByValOutOfBounds:
5285     case GetVectorLength:
5286     case PutHint:
5287     case CheckStructureImmediate:
5288     case MaterializeCreateActivation:
<span class="line-added">5289     case MaterializeNewInternalFieldObject:</span>
5290     case PutStack:
5291     case KillStack:
5292     case GetStack:
5293     case PhantomCreateRest:
5294     case PhantomSpread:
5295     case PhantomNewArrayWithSpread:
5296     case PhantomNewArrayBuffer:
5297     case IdentityWithProfile:
5298     case CPUIntrinsic:
5299         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected node&quot;);
5300         break;
5301     }
5302 
5303     if (!m_compileOkay)
5304         return;
5305 
5306     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
5307         use(node);
5308 }
5309 
5310 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
5311 {
<span class="line-modified">5312     m_jit.move(TrustedImm32(JSValue::ValueTrue), gpr);</span>
5313 }
5314 
5315 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
5316 {
<span class="line-modified">5317     m_jit.move(TrustedImm32(JSValue::ValueFalse), gpr);</span>
5318 }
5319 
5320 void SpeculativeJIT::blessBoolean(GPRReg gpr)
5321 {
<span class="line-modified">5322     m_jit.or32(TrustedImm32(JSValue::ValueFalse), gpr);</span>
5323 }
5324 
5325 void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
5326 {
5327     JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
5328     GPRReg valueGPR = value.gpr();
5329 
5330     JITCompiler::Jump notInt32 = m_jit.branchIfNotInt32(valueGPR);
5331 
5332     m_jit.signExtend32ToPtr(valueGPR, resultGPR);
5333     JITCompiler::Jump done = m_jit.jump();
5334 
5335     notInt32.link(&amp;m_jit);
5336     silentSpillAllRegisters(resultGPR);
5337     callOperation(operationConvertBoxedDoubleToInt52, resultGPR, valueGPR);
5338     silentFillAllRegisters();
5339 
5340     DFG_TYPE_CHECK(
5341         JSValueRegs(valueGPR), valueEdge, SpecInt32Only | SpecAnyIntAsDouble,
5342         m_jit.branch64(
</pre>
<hr />
<pre>
5373     callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
5374 
5375     DFG_TYPE_CHECK(
5376         JSValueRegs(), edge, SpecAnyIntAsDouble,
5377         m_jit.branch64(
5378             JITCompiler::Equal, resultGPR,
5379             JITCompiler::TrustedImm64(JSValue::notInt52)));
5380 }
5381 
5382 void SpeculativeJIT::compileArithRandom(Node* node)
5383 {
5384     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
5385     GPRTemporary temp1(this);
5386     GPRTemporary temp2(this);
5387     GPRTemporary temp3(this);
5388     FPRTemporary result(this);
5389     m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
5390     doubleResult(result.fpr(), node);
5391 }
5392 
<span class="line-added">5393 void SpeculativeJIT::compileStringCodePointAt(Node* node)</span>
<span class="line-added">5394 {</span>
<span class="line-added">5395     // We emit CheckArray on this node as we do in StringCharCodeAt node so that we do not need to check SpecString here.</span>
<span class="line-added">5396     // And CheckArray also ensures that this String is not a rope.</span>
<span class="line-added">5397     SpeculateCellOperand string(this, node-&gt;child1());</span>
<span class="line-added">5398     SpeculateStrictInt32Operand index(this, node-&gt;child2());</span>
<span class="line-added">5399     StorageOperand storage(this, node-&gt;child3());</span>
<span class="line-added">5400     GPRTemporary scratch1(this);</span>
<span class="line-added">5401     GPRTemporary scratch2(this);</span>
<span class="line-added">5402     GPRTemporary scratch3(this);</span>
<span class="line-added">5403 </span>
<span class="line-added">5404     GPRReg stringGPR = string.gpr();</span>
<span class="line-added">5405     GPRReg indexGPR = index.gpr();</span>
<span class="line-added">5406     GPRReg storageGPR = storage.gpr();</span>
<span class="line-added">5407     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">5408     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">5409     GPRReg scratch3GPR = scratch3.gpr();</span>
<span class="line-added">5410 </span>
<span class="line-added">5411     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), scratch1GPR);</span>
<span class="line-added">5412     m_jit.load32(CCallHelpers::Address(scratch1GPR, StringImpl::lengthMemoryOffset()), scratch2GPR);</span>
<span class="line-added">5413 </span>
<span class="line-added">5414     // unsigned comparison so we can filter out negative indices and indices that are too large</span>
<span class="line-added">5415     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, scratch2GPR));</span>
<span class="line-added">5416 </span>
<span class="line-added">5417     // Load the character into scratch1GPR</span>
<span class="line-added">5418     auto is16Bit = m_jit.branchTest32(CCallHelpers::Zero, CCallHelpers::Address(scratch1GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="line-added">5419 </span>
<span class="line-added">5420     CCallHelpers::JumpList done;</span>
<span class="line-added">5421 </span>
<span class="line-added">5422     m_jit.load8(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesOne, 0), scratch1GPR);</span>
<span class="line-added">5423     done.append(m_jit.jump());</span>
<span class="line-added">5424 </span>
<span class="line-added">5425     is16Bit.link(&amp;m_jit);</span>
<span class="line-added">5426     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesTwo, 0), scratch1GPR);</span>
<span class="line-added">5427     // This is ok. indexGPR must be positive int32_t here and adding 1 never causes overflow if we treat indexGPR as uint32_t.</span>
<span class="line-added">5428     m_jit.add32(CCallHelpers::TrustedImm32(1), indexGPR, scratch3GPR);</span>
<span class="line-added">5429     done.append(m_jit.branch32(CCallHelpers::AboveOrEqual, scratch3GPR, scratch2GPR));</span>
<span class="line-added">5430     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch1GPR, scratch2GPR);</span>
<span class="line-added">5431     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xd800)));</span>
<span class="line-added">5432     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, scratch3GPR, CCallHelpers::TimesTwo, 0), scratch3GPR);</span>
<span class="line-added">5433     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch3GPR, scratch2GPR);</span>
<span class="line-added">5434     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xdc00)));</span>
<span class="line-added">5435     m_jit.lshift32(CCallHelpers::TrustedImm32(10), scratch1GPR);</span>
<span class="line-added">5436     m_jit.getEffectiveAddress(CCallHelpers::BaseIndex(scratch1GPR, scratch3GPR, CCallHelpers::TimesOne, -U16_SURROGATE_OFFSET), scratch1GPR);</span>
<span class="line-added">5437     done.link(&amp;m_jit);</span>
<span class="line-added">5438 </span>
<span class="line-added">5439     int32Result(scratch1GPR, m_currentNode);</span>
<span class="line-added">5440 }</span>
<span class="line-added">5441 </span>
<span class="line-added">5442 void SpeculativeJIT::compileDateGet(Node* node)</span>
<span class="line-added">5443 {</span>
<span class="line-added">5444     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">5445     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">5446     speculateDateObject(node-&gt;child1(), baseGPR);</span>
<span class="line-added">5447 </span>
<span class="line-added">5448     auto emitGetCodeWithCallback = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation, auto callback) {</span>
<span class="line-added">5449         JSValueRegsTemporary result(this);</span>
<span class="line-added">5450         FPRTemporary temp1(this);</span>
<span class="line-added">5451         FPRTemporary temp2(this);</span>
<span class="line-added">5452 </span>
<span class="line-added">5453         JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">5454         FPRReg temp1FPR = temp1.fpr();</span>
<span class="line-added">5455         FPRReg temp2FPR = temp2.fpr();</span>
<span class="line-added">5456 </span>
<span class="line-added">5457         CCallHelpers::JumpList slowCases;</span>
<span class="line-added">5458 </span>
<span class="line-added">5459         m_jit.loadPtr(CCallHelpers::Address(baseGPR, DateInstance::offsetOfData()), resultRegs.payloadGPR());</span>
<span class="line-added">5460         slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, resultRegs.payloadGPR()));</span>
<span class="line-added">5461         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="line-added">5462         m_jit.loadDouble(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDoubleOffset), temp2FPR);</span>
<span class="line-added">5463         slowCases.append(m_jit.branchDouble(CCallHelpers::DoubleNotEqualOrUnordered, temp1FPR, temp2FPR));</span>
<span class="line-added">5464         m_jit.load32(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDataOffset), resultRegs.payloadGPR());</span>
<span class="line-added">5465         callback(resultRegs.payloadGPR());</span>
<span class="line-added">5466         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="line-added">5467 </span>
<span class="line-added">5468         addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultRegs, &amp;vm(), baseGPR));</span>
<span class="line-added">5469 </span>
<span class="line-added">5470         jsValueResult(resultRegs, node);</span>
<span class="line-added">5471     };</span>
<span class="line-added">5472 </span>
<span class="line-added">5473     auto emitGetCode = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation) {</span>
<span class="line-added">5474         emitGetCodeWithCallback(cachedDoubleOffset, cachedDataOffset, operation, [] (GPRReg) { });</span>
<span class="line-added">5475     };</span>
<span class="line-added">5476 </span>
<span class="line-added">5477     switch (node-&gt;intrinsic()) {</span>
<span class="line-added">5478     case DatePrototypeGetTimeIntrinsic: {</span>
<span class="line-added">5479         FPRTemporary result(this);</span>
<span class="line-added">5480         FPRReg resultFPR = result.fpr();</span>
<span class="line-added">5481         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), resultFPR);</span>
<span class="line-added">5482         doubleResult(resultFPR, node);</span>
<span class="line-added">5483         break;</span>
<span class="line-added">5484     }</span>
<span class="line-added">5485 </span>
<span class="line-added">5486     // We do not have any timezone offset which affects on milliseconds.</span>
<span class="line-added">5487     // So Date#getMilliseconds and Date#getUTCMilliseconds have the same implementation.</span>
<span class="line-added">5488     case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="line-added">5489     case DatePrototypeGetUTCMillisecondsIntrinsic: {</span>
<span class="line-added">5490         JSValueRegsTemporary result(this);</span>
<span class="line-added">5491         FPRTemporary temp1(this);</span>
<span class="line-added">5492         FPRTemporary temp2(this);</span>
<span class="line-added">5493         FPRTemporary temp3(this);</span>
<span class="line-added">5494         JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">5495         FPRReg temp1FPR = temp1.fpr();</span>
<span class="line-added">5496         FPRReg temp2FPR = temp2.fpr();</span>
<span class="line-added">5497         FPRReg temp3FPR = temp3.fpr();</span>
<span class="line-added">5498 </span>
<span class="line-added">5499         m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="line-added">5500         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="line-added">5501         auto isNaN = m_jit.branchIfNaN(temp1FPR);</span>
<span class="line-added">5502 </span>
<span class="line-added">5503         static const double msPerSecondConstant = msPerSecond;</span>
<span class="line-added">5504         m_jit.loadDouble(TrustedImmPtr(&amp;msPerSecondConstant), temp2FPR);</span>
<span class="line-added">5505         m_jit.divDouble(temp1FPR, temp2FPR, temp3FPR);</span>
<span class="line-added">5506         m_jit.floorDouble(temp3FPR, temp3FPR);</span>
<span class="line-added">5507         m_jit.mulDouble(temp3FPR, temp2FPR, temp3FPR);</span>
<span class="line-added">5508         m_jit.subDouble(temp1FPR, temp3FPR, temp1FPR);</span>
<span class="line-added">5509         m_jit.truncateDoubleToInt32(temp1FPR, resultRegs.payloadGPR());</span>
<span class="line-added">5510         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="line-added">5511 </span>
<span class="line-added">5512         isNaN.link(&amp;m_jit);</span>
<span class="line-added">5513         jsValueResult(resultRegs, node);</span>
<span class="line-added">5514         break;</span>
<span class="line-added">5515     }</span>
<span class="line-added">5516 </span>
<span class="line-added">5517     case DatePrototypeGetFullYearIntrinsic:</span>
<span class="line-added">5518         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetFullYear);</span>
<span class="line-added">5519         break;</span>
<span class="line-added">5520     case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="line-added">5521         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfYear(), operationDateGetUTCFullYear);</span>
<span class="line-added">5522         break;</span>
<span class="line-added">5523     case DatePrototypeGetMonthIntrinsic:</span>
<span class="line-added">5524         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonth(), operationDateGetMonth);</span>
<span class="line-added">5525         break;</span>
<span class="line-added">5526     case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="line-added">5527         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonth(), operationDateGetUTCMonth);</span>
<span class="line-added">5528         break;</span>
<span class="line-added">5529     case DatePrototypeGetDateIntrinsic:</span>
<span class="line-added">5530         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonthDay(), operationDateGetDate);</span>
<span class="line-added">5531         break;</span>
<span class="line-added">5532     case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="line-added">5533         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonthDay(), operationDateGetUTCDate);</span>
<span class="line-added">5534         break;</span>
<span class="line-added">5535     case DatePrototypeGetDayIntrinsic:</span>
<span class="line-added">5536         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfWeekDay(), operationDateGetDay);</span>
<span class="line-added">5537         break;</span>
<span class="line-added">5538     case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="line-added">5539         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfWeekDay(), operationDateGetUTCDay);</span>
<span class="line-added">5540         break;</span>
<span class="line-added">5541     case DatePrototypeGetHoursIntrinsic:</span>
<span class="line-added">5542         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfHour(), operationDateGetHours);</span>
<span class="line-added">5543         break;</span>
<span class="line-added">5544     case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="line-added">5545         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfHour(), operationDateGetUTCHours);</span>
<span class="line-added">5546         break;</span>
<span class="line-added">5547     case DatePrototypeGetMinutesIntrinsic:</span>
<span class="line-added">5548         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMinute(), operationDateGetMinutes);</span>
<span class="line-added">5549         break;</span>
<span class="line-added">5550     case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="line-added">5551         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMinute(), operationDateGetUTCMinutes);</span>
<span class="line-added">5552         break;</span>
<span class="line-added">5553     case DatePrototypeGetSecondsIntrinsic:</span>
<span class="line-added">5554         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfSecond(), operationDateGetSeconds);</span>
<span class="line-added">5555         break;</span>
<span class="line-added">5556     case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="line-added">5557         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfSecond(), operationDateGetUTCSeconds);</span>
<span class="line-added">5558         break;</span>
<span class="line-added">5559 </span>
<span class="line-added">5560     case DatePrototypeGetTimezoneOffsetIntrinsic: {</span>
<span class="line-added">5561         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfUTCOffsetInMinute(), operationDateGetTimezoneOffset, [&amp;] (GPRReg offsetGPR) {</span>
<span class="line-added">5562             m_jit.neg32(offsetGPR);</span>
<span class="line-added">5563         });</span>
<span class="line-added">5564         break;</span>
<span class="line-added">5565     }</span>
<span class="line-added">5566 </span>
<span class="line-added">5567     case DatePrototypeGetYearIntrinsic: {</span>
<span class="line-added">5568         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetYear, [&amp;] (GPRReg yearGPR) {</span>
<span class="line-added">5569             m_jit.sub32(TrustedImm32(1900), yearGPR);</span>
<span class="line-added">5570         });</span>
<span class="line-added">5571         break;</span>
<span class="line-added">5572     }</span>
<span class="line-added">5573 </span>
<span class="line-added">5574     default:</span>
<span class="line-added">5575         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">5576     }</span>
<span class="line-added">5577 }</span>
<span class="line-added">5578 </span>
5579 #endif
5580 
5581 } } // namespace JSC::DFG
5582 
5583 #endif
</pre>
</td>
</tr>
</table>
<center><a href="DFGSpeculativeJIT32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStackLayoutPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
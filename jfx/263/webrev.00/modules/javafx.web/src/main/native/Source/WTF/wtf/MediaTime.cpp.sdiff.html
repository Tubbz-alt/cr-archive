<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/MediaTime.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MathExtras.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaTime.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/MediaTime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &lt;wtf/MediaTime.h&gt;
 31 
 32 #include &lt;algorithm&gt;
 33 #include &lt;cstdlib&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/CheckedArithmetic.h&gt;
 36 #include &lt;wtf/JSONValues.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/PrintStream.h&gt;
 39 #include &lt;wtf/text/StringBuilder.h&gt;

 40 
 41 namespace WTF {
 42 


 43 static uint32_t greatestCommonDivisor(uint32_t a, uint32_t b)
 44 {
 45     ASSERT(a);
 46     ASSERT(b);
 47 
 48     // Euclid&#39;s Algorithm
 49     uint32_t temp = 0;
 50     while (b) {
 51         temp = b;
 52         b = a % b;
 53         a = temp;
 54     }
 55 
 56     ASSERT(a);
 57     return a;
 58 }
 59 
 60 static uint32_t leastCommonMultiple(uint32_t a, uint32_t b, uint32_t &amp;result)
 61 {
 62     return safeMultiply(a, b / greatestCommonDivisor(a, b), result);
 63 }
 64 
 65 static int64_t signum(int64_t val)
 66 {
 67     return (0 &lt; val) - (val &lt; 0);
 68 }
 69 
 70 const uint32_t MediaTime::MaximumTimeScale = 1000000000;
 71 
<span class="line-removed"> 72 MediaTime::MediaTime()</span>
<span class="line-removed"> 73     : m_timeValue(0)</span>
<span class="line-removed"> 74     , m_timeScale(DefaultTimeScale)</span>
<span class="line-removed"> 75     , m_timeFlags(Valid)</span>
<span class="line-removed"> 76 {</span>
<span class="line-removed"> 77 }</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79 MediaTime::MediaTime(int64_t value, uint32_t scale, uint8_t flags)</span>
<span class="line-removed"> 80     : m_timeValue(value)</span>
<span class="line-removed"> 81     , m_timeScale(scale)</span>
<span class="line-removed"> 82     , m_timeFlags(flags)</span>
<span class="line-removed"> 83 {</span>
<span class="line-removed"> 84     if (scale || isInvalid())</span>
<span class="line-removed"> 85         return;</span>
<span class="line-removed"> 86 </span>
<span class="line-removed"> 87     *this = value &lt; 0 ? negativeInfiniteTime() : positiveInfiniteTime();</span>
<span class="line-removed"> 88 }</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90 MediaTime::~MediaTime()</span>
<span class="line-removed"> 91 {</span>
<span class="line-removed"> 92 }</span>
<span class="line-removed"> 93 </span>
 94 MediaTime::MediaTime(const MediaTime&amp; rhs)
 95 {
 96     *this = rhs;
 97 }
 98 
 99 MediaTime MediaTime::createWithFloat(float floatTime)
100 {
101     if (floatTime != floatTime)
102         return invalidTime();
103     if (std::isinf(floatTime))
104         return std::signbit(floatTime) ? negativeInfiniteTime() : positiveInfiniteTime();
105 
106     MediaTime value(0, DefaultTimeScale, Valid | DoubleValue);
107     value.m_timeValueAsDouble = floatTime;
108     return value;
109 }
110 
111 MediaTime MediaTime::createWithFloat(float floatTime, uint32_t timeScale)
112 {
113     if (floatTime != floatTime)
</pre>
<hr />
<pre>
439 
440     int64_t rhsRemain = rhs.m_timeValue % rhs.m_timeScale;
441     int64_t lhsRemain = m_timeValue % m_timeScale;
442     lhsFactor = lhsRemain * rhs.m_timeScale;
443     rhsFactor = rhsRemain * m_timeScale;
444 
445     if (lhsFactor == rhsFactor)
446         return EqualTo;
447     return lhsFactor &gt; rhsFactor ? GreaterThan : LessThan;
448 }
449 
450 bool MediaTime::isBetween(const MediaTime&amp; a, const MediaTime&amp; b) const
451 {
452     if (a &gt; b)
453         return *this &gt; b &amp;&amp; *this &lt; a;
454     return *this &gt; a &amp;&amp; *this &lt; b;
455 }
456 
457 const MediaTime&amp; MediaTime::zeroTime()
458 {
<span class="line-modified">459     static const MediaTime* time = new MediaTime(0, 1, Valid);</span>
<span class="line-modified">460     return *time;</span>
461 }
462 
463 const MediaTime&amp; MediaTime::invalidTime()
464 {
<span class="line-modified">465     static const MediaTime* time = new MediaTime(-1, 1, 0);</span>
<span class="line-modified">466     return *time;</span>
467 }
468 
469 const MediaTime&amp; MediaTime::positiveInfiniteTime()
470 {
<span class="line-modified">471     static const MediaTime* time = new MediaTime(0, 1, PositiveInfinite | Valid);</span>
<span class="line-modified">472     return *time;</span>
473 }
474 
475 const MediaTime&amp; MediaTime::negativeInfiniteTime()
476 {
<span class="line-modified">477     static const MediaTime* time = new MediaTime(-1, 1, NegativeInfinite | Valid);</span>
<span class="line-modified">478     return *time;</span>
479 }
480 
481 const MediaTime&amp; MediaTime::indefiniteTime()
482 {
<span class="line-modified">483     static const MediaTime* time = new MediaTime(0, 1, Indefinite | Valid);</span>
<span class="line-modified">484     return *time;</span>
485 }
486 
487 MediaTime MediaTime::toTimeScale(uint32_t timeScale, RoundingFlags flags) const
488 {
489     MediaTime result = *this;
490     result.setTimeScale(timeScale, flags);
491     return result;
492 }
493 
494 void MediaTime::setTimeScale(uint32_t timeScale, RoundingFlags flags)
495 {
496     if (hasDoubleValue()) {
497         *this = MediaTime::createWithDouble(m_timeValueAsDouble, timeScale);
498         return;
499     }
500 
501     if (!timeScale) {
502         *this = m_timeValue &lt; 0 ? negativeInfiniteTime() : positiveInfiniteTime();
503         return;
504     }
</pre>
<hr />
<pre>
568         break;
569 
570     case RoundingFlags::TowardNegativeInfinity:
571         if (remainder &lt; 0)
572             m_timeValue--;
573         break;
574     }
575 }
576 
577 void MediaTime::dump(PrintStream&amp; out) const
578 {
579     out.print(&quot;{&quot;);
580     if (!hasDoubleValue())
581         out.print(m_timeValue, &quot;/&quot;, m_timeScale, &quot; = &quot;);
582     out.print(toDouble(), &quot;}&quot;);
583 }
584 
585 String MediaTime::toString() const
586 {
587     StringBuilder builder;
<span class="line-removed">588 </span>
589     builder.append(&#39;{&#39;);
<span class="line-modified">590     if (!hasDoubleValue()) {</span>
<span class="line-modified">591         builder.appendNumber(m_timeValue);</span>
<span class="line-modified">592         builder.append(&#39;/&#39;);</span>
<span class="line-modified">593         builder.appendNumber(m_timeScale);</span>
<span class="line-modified">594         builder.appendLiteral(&quot; = &quot;);</span>
<span class="line-removed">595     }</span>
<span class="line-removed">596     builder.appendFixedPrecisionNumber(toDouble());</span>
597     builder.append(&#39;}&#39;);
598     return builder.toString();
599 }
600 
601 Ref&lt;JSON::Object&gt; MediaTime::toJSONObject() const
602 {
603     auto object = JSON::Object::create();
604 
605     if (hasDoubleValue()) {
606         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
607         return object;
608     }
609 
<span class="line-modified">610     if (isInvalid() || isIndefinite())</span>


611         object-&gt;setString(&quot;value&quot;_s, &quot;NaN&quot;_s);
612     else if (isPositiveInfinite())
613         object-&gt;setString(&quot;value&quot;_s, &quot;POSITIVE_INFINITY&quot;_s);
614     else if (isNegativeInfinite())
615         object-&gt;setString(&quot;value&quot;_s, &quot;NEGATIVE_INFINITY&quot;_s);
616     else
617         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
618 
619     object-&gt;setDouble(&quot;numerator&quot;_s, static_cast&lt;double&gt;(m_timeValue));
620     object-&gt;setInteger(&quot;denominator&quot;_s, m_timeScale);
621     object-&gt;setInteger(&quot;flags&quot;_s, m_timeFlags);
622 
623     return object;
624 }
625 
626 String MediaTime::toJSONString() const
627 {
628     return toJSONObject()-&gt;toJSONString();
629 }
630 
</pre>
<hr />
<pre>
635     if (rhs.isNegativeInfinite() || rhs.isPositiveInfinite())
636         return MediaTime::positiveInfiniteTime();
637     if (rhs.hasDoubleValue())
638         return MediaTime::createWithDouble(fabs(rhs.m_timeValueAsDouble));
639 
640     MediaTime val = rhs;
641     val.m_timeValue = std::abs(rhs.m_timeValue);
642     return val;
643 }
644 
645 String MediaTimeRange::toJSONString() const
646 {
647     auto object = JSON::Object::create();
648 
649     object-&gt;setObject(&quot;start&quot;_s, start.toJSONObject());
650     object-&gt;setObject(&quot;end&quot;_s, end.toJSONObject());
651 
652     return object-&gt;toJSONString();
653 }
654 









655 }
</pre>
</td>
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &lt;wtf/MediaTime.h&gt;
 31 
 32 #include &lt;algorithm&gt;
 33 #include &lt;cstdlib&gt;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/CheckedArithmetic.h&gt;
 36 #include &lt;wtf/JSONValues.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/PrintStream.h&gt;
 39 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-added"> 40 #include &lt;wtf/text/TextStream.h&gt;</span>
 41 
 42 namespace WTF {
 43 
<span class="line-added"> 44 static_assert(std::is_trivially_destructible_v&lt;MediaTime&gt;, &quot;MediaTime should be trivially destructible.&quot;);</span>
<span class="line-added"> 45 </span>
 46 static uint32_t greatestCommonDivisor(uint32_t a, uint32_t b)
 47 {
 48     ASSERT(a);
 49     ASSERT(b);
 50 
 51     // Euclid&#39;s Algorithm
 52     uint32_t temp = 0;
 53     while (b) {
 54         temp = b;
 55         b = a % b;
 56         a = temp;
 57     }
 58 
 59     ASSERT(a);
 60     return a;
 61 }
 62 
 63 static uint32_t leastCommonMultiple(uint32_t a, uint32_t b, uint32_t &amp;result)
 64 {
 65     return safeMultiply(a, b / greatestCommonDivisor(a, b), result);
 66 }
 67 
 68 static int64_t signum(int64_t val)
 69 {
 70     return (0 &lt; val) - (val &lt; 0);
 71 }
 72 
 73 const uint32_t MediaTime::MaximumTimeScale = 1000000000;
 74 






















 75 MediaTime::MediaTime(const MediaTime&amp; rhs)
 76 {
 77     *this = rhs;
 78 }
 79 
 80 MediaTime MediaTime::createWithFloat(float floatTime)
 81 {
 82     if (floatTime != floatTime)
 83         return invalidTime();
 84     if (std::isinf(floatTime))
 85         return std::signbit(floatTime) ? negativeInfiniteTime() : positiveInfiniteTime();
 86 
 87     MediaTime value(0, DefaultTimeScale, Valid | DoubleValue);
 88     value.m_timeValueAsDouble = floatTime;
 89     return value;
 90 }
 91 
 92 MediaTime MediaTime::createWithFloat(float floatTime, uint32_t timeScale)
 93 {
 94     if (floatTime != floatTime)
</pre>
<hr />
<pre>
420 
421     int64_t rhsRemain = rhs.m_timeValue % rhs.m_timeScale;
422     int64_t lhsRemain = m_timeValue % m_timeScale;
423     lhsFactor = lhsRemain * rhs.m_timeScale;
424     rhsFactor = rhsRemain * m_timeScale;
425 
426     if (lhsFactor == rhsFactor)
427         return EqualTo;
428     return lhsFactor &gt; rhsFactor ? GreaterThan : LessThan;
429 }
430 
431 bool MediaTime::isBetween(const MediaTime&amp; a, const MediaTime&amp; b) const
432 {
433     if (a &gt; b)
434         return *this &gt; b &amp;&amp; *this &lt; a;
435     return *this &gt; a &amp;&amp; *this &lt; b;
436 }
437 
438 const MediaTime&amp; MediaTime::zeroTime()
439 {
<span class="line-modified">440     static const MediaTime time(0, 1, Valid);</span>
<span class="line-modified">441     return time;</span>
442 }
443 
444 const MediaTime&amp; MediaTime::invalidTime()
445 {
<span class="line-modified">446     static const MediaTime time(-1, 1, 0);</span>
<span class="line-modified">447     return time;</span>
448 }
449 
450 const MediaTime&amp; MediaTime::positiveInfiniteTime()
451 {
<span class="line-modified">452     static const MediaTime time(0, 1, PositiveInfinite | Valid);</span>
<span class="line-modified">453     return time;</span>
454 }
455 
456 const MediaTime&amp; MediaTime::negativeInfiniteTime()
457 {
<span class="line-modified">458     static const MediaTime time(-1, 1, NegativeInfinite | Valid);</span>
<span class="line-modified">459     return time;</span>
460 }
461 
462 const MediaTime&amp; MediaTime::indefiniteTime()
463 {
<span class="line-modified">464     static const MediaTime time(0, 1, Indefinite | Valid);</span>
<span class="line-modified">465     return time;</span>
466 }
467 
468 MediaTime MediaTime::toTimeScale(uint32_t timeScale, RoundingFlags flags) const
469 {
470     MediaTime result = *this;
471     result.setTimeScale(timeScale, flags);
472     return result;
473 }
474 
475 void MediaTime::setTimeScale(uint32_t timeScale, RoundingFlags flags)
476 {
477     if (hasDoubleValue()) {
478         *this = MediaTime::createWithDouble(m_timeValueAsDouble, timeScale);
479         return;
480     }
481 
482     if (!timeScale) {
483         *this = m_timeValue &lt; 0 ? negativeInfiniteTime() : positiveInfiniteTime();
484         return;
485     }
</pre>
<hr />
<pre>
549         break;
550 
551     case RoundingFlags::TowardNegativeInfinity:
552         if (remainder &lt; 0)
553             m_timeValue--;
554         break;
555     }
556 }
557 
558 void MediaTime::dump(PrintStream&amp; out) const
559 {
560     out.print(&quot;{&quot;);
561     if (!hasDoubleValue())
562         out.print(m_timeValue, &quot;/&quot;, m_timeScale, &quot; = &quot;);
563     out.print(toDouble(), &quot;}&quot;);
564 }
565 
566 String MediaTime::toString() const
567 {
568     StringBuilder builder;

569     builder.append(&#39;{&#39;);
<span class="line-modified">570     if (!hasDoubleValue())</span>
<span class="line-modified">571         builder.append(m_timeValue, &#39;/&#39;, m_timeScale, &quot; = &quot;);</span>
<span class="line-modified">572     builder.append(toDouble());</span>
<span class="line-modified">573     if (isInvalid())</span>
<span class="line-modified">574         builder.appendLiteral(&quot;, invalid&quot;);</span>


575     builder.append(&#39;}&#39;);
576     return builder.toString();
577 }
578 
579 Ref&lt;JSON::Object&gt; MediaTime::toJSONObject() const
580 {
581     auto object = JSON::Object::create();
582 
583     if (hasDoubleValue()) {
584         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
585         return object;
586     }
587 
<span class="line-modified">588     if (isInvalid())</span>
<span class="line-added">589         object-&gt;setBoolean(&quot;invalid&quot;_s, true);</span>
<span class="line-added">590     else if (isIndefinite())</span>
591         object-&gt;setString(&quot;value&quot;_s, &quot;NaN&quot;_s);
592     else if (isPositiveInfinite())
593         object-&gt;setString(&quot;value&quot;_s, &quot;POSITIVE_INFINITY&quot;_s);
594     else if (isNegativeInfinite())
595         object-&gt;setString(&quot;value&quot;_s, &quot;NEGATIVE_INFINITY&quot;_s);
596     else
597         object-&gt;setDouble(&quot;value&quot;_s, toDouble());
598 
599     object-&gt;setDouble(&quot;numerator&quot;_s, static_cast&lt;double&gt;(m_timeValue));
600     object-&gt;setInteger(&quot;denominator&quot;_s, m_timeScale);
601     object-&gt;setInteger(&quot;flags&quot;_s, m_timeFlags);
602 
603     return object;
604 }
605 
606 String MediaTime::toJSONString() const
607 {
608     return toJSONObject()-&gt;toJSONString();
609 }
610 
</pre>
<hr />
<pre>
615     if (rhs.isNegativeInfinite() || rhs.isPositiveInfinite())
616         return MediaTime::positiveInfiniteTime();
617     if (rhs.hasDoubleValue())
618         return MediaTime::createWithDouble(fabs(rhs.m_timeValueAsDouble));
619 
620     MediaTime val = rhs;
621     val.m_timeValue = std::abs(rhs.m_timeValue);
622     return val;
623 }
624 
625 String MediaTimeRange::toJSONString() const
626 {
627     auto object = JSON::Object::create();
628 
629     object-&gt;setObject(&quot;start&quot;_s, start.toJSONObject());
630     object-&gt;setObject(&quot;end&quot;_s, end.toJSONObject());
631 
632     return object-&gt;toJSONString();
633 }
634 
<span class="line-added">635 #ifndef NDEBUG</span>
<span class="line-added">636 </span>
<span class="line-added">637 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const MediaTime&amp; time)</span>
<span class="line-added">638 {</span>
<span class="line-added">639     return stream &lt;&lt; time.toJSONString();</span>
<span class="line-added">640 }</span>
<span class="line-added">641 </span>
<span class="line-added">642 #endif</span>
<span class="line-added">643 </span>
644 }
</pre>
</td>
</tr>
</table>
<center><a href="MathExtras.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaTime.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
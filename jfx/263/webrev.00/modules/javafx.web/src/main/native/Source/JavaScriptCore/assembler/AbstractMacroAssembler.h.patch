diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h
@@ -194,16 +194,18 @@
     struct ImplicitAddress {
         ImplicitAddress(RegisterID base)
             : base(base)
             , offset(0)
         {
+            ASSERT(base != RegisterID::InvalidGPRReg);
         }
 
         ImplicitAddress(Address address)
             : base(address.base)
             , offset(address.offset)
         {
+            ASSERT(base != RegisterID::InvalidGPRReg);
         }
 
         RegisterID base;
         int32_t offset;
     };
@@ -957,10 +959,18 @@
     void addLinkTask(const Functor& functor)
     {
         m_linkTasks.append(createSharedTask<void(LinkBuffer&)>(functor));
     }
 
+#if COMPILER(GCC)
+    // Workaround for GCC demanding that memcpy "must be the name of a function with external linkage".
+    static void* memcpy(void* dst, const void* src, size_t size)
+    {
+        return std::memcpy(dst, src, size);
+    }
+#endif
+
     void emitNops(size_t memoryToFillWithNopsInBytes)
     {
 #if CPU(ARM64)
         RELEASE_ASSERT(memoryToFillWithNopsInBytes % 4 == 0);
         for (unsigned i = 0; i < memoryToFillWithNopsInBytes / 4; ++i)
@@ -968,11 +978,11 @@
 #else
         AssemblerBuffer& buffer = m_assembler.buffer();
         size_t startCodeSize = buffer.codeSize();
         size_t targetCodeSize = startCodeSize + memoryToFillWithNopsInBytes;
         buffer.ensureSpace(memoryToFillWithNopsInBytes);
-        AssemblerType::fillNops(static_cast<char*>(buffer.data()) + startCodeSize, memoryToFillWithNopsInBytes, memcpy);
+        AssemblerType::template fillNops<memcpy>(static_cast<char*>(buffer.data()) + startCodeSize, memoryToFillWithNopsInBytes);
         buffer.setCodeSize(targetCodeSize);
 #endif
     }
 
     ALWAYS_INLINE void tagReturnAddress() { }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007-2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DragController.h&quot;
  28 
  29 #include &quot;HTMLAnchorElement.h&quot;
  30 #include &quot;SVGAElement.h&quot;
  31 
  32 #if ENABLE(DRAG_SUPPORT)
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;DataTransfer.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;DocumentFragment.h&quot;
  38 #include &quot;DragActions.h&quot;
  39 #include &quot;DragClient.h&quot;
  40 #include &quot;DragData.h&quot;
  41 #include &quot;DragImage.h&quot;
  42 #include &quot;DragState.h&quot;
  43 #include &quot;Editing.h&quot;
  44 #include &quot;Editor.h&quot;
  45 #include &quot;EditorClient.h&quot;
  46 #include &quot;ElementAncestorIterator.h&quot;
  47 #include &quot;EventHandler.h&quot;
  48 #include &quot;File.h&quot;
  49 #include &quot;FloatRect.h&quot;
  50 #include &quot;FocusController.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoadRequest.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameSelection.h&quot;
  55 #include &quot;FrameView.h&quot;
  56 #include &quot;HTMLAttachmentElement.h&quot;
  57 #include &quot;HTMLImageElement.h&quot;
  58 #include &quot;HTMLInputElement.h&quot;
  59 #include &quot;HTMLParserIdioms.h&quot;
  60 #include &quot;HTMLPlugInElement.h&quot;
  61 #include &quot;HitTestRequest.h&quot;
  62 #include &quot;HitTestResult.h&quot;
  63 #include &quot;Image.h&quot;
  64 #include &quot;ImageOrientation.h&quot;
  65 #include &quot;MoveSelectionCommand.h&quot;
  66 #include &quot;Page.h&quot;
  67 #include &quot;Pasteboard.h&quot;
  68 #include &quot;PlatformKeyboardEvent.h&quot;
  69 #include &quot;PluginDocument.h&quot;
  70 #include &quot;PluginViewBase.h&quot;
  71 #include &quot;Position.h&quot;
  72 #include &quot;PromisedAttachmentInfo.h&quot;
  73 #include &quot;RenderAttachment.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderImage.h&quot;
  76 #include &quot;RenderView.h&quot;
  77 #include &quot;ReplaceSelectionCommand.h&quot;
  78 #include &quot;ResourceRequest.h&quot;
  79 #include &quot;SecurityOrigin.h&quot;
  80 #include &quot;Settings.h&quot;
  81 #include &quot;ShadowRoot.h&quot;
  82 #include &quot;StyleProperties.h&quot;
  83 #include &quot;Text.h&quot;
  84 #include &quot;TextEvent.h&quot;
  85 #include &quot;VisiblePosition.h&quot;
  86 #include &quot;WebContentReader.h&quot;
  87 #include &quot;markup.h&quot;
  88 
  89 #if ENABLE(DATA_INTERACTION)
  90 #include &quot;SelectionRect.h&quot;
  91 #endif
  92 
  93 #include &lt;wtf/RefPtr.h&gt;
  94 #include &lt;wtf/SetForScope.h&gt;
  95 #endif
  96 
  97 #if ENABLE(DATA_DETECTION)
  98 #include &quot;DataDetection.h&quot;
  99 #endif
 100 
 101 namespace WebCore {
 102 
 103 bool isDraggableLink(const Element&amp; element)
 104 {
 105     if (is&lt;HTMLAnchorElement&gt;(element)) {
 106         auto&amp; anchorElement = downcast&lt;HTMLAnchorElement&gt;(element);
 107         if (!anchorElement.isLiveLink())
 108             return false;
 109 #if ENABLE(DATA_DETECTION)
 110         return !DataDetection::isDataDetectorURL(anchorElement.href());
 111 #else
 112         return true;
 113 #endif
 114     }
 115     if (is&lt;SVGAElement&gt;(element))
 116         return element.isLink();
 117     return false;
 118 }
 119 
 120 #if ENABLE(DRAG_SUPPORT)
 121 
 122 static PlatformMouseEvent createMouseEvent(const DragData&amp; dragData)
 123 {
 124     bool shiftKey = false;
 125     bool ctrlKey = false;
 126     bool altKey = false;
 127     bool metaKey = false;
 128 
 129     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
 130 
 131     return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
 132                               LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
 133                               metaKey, WallTime::now(), ForceAtClick, NoTap);
 134 }
 135 
 136 DragController::DragController(Page&amp; page, std::unique_ptr&lt;DragClient&gt;&amp;&amp; client)
 137     : m_page(page)
 138     , m_client(WTFMove(client))
 139 {
 140 }
 141 
 142 DragController::~DragController() = default;
 143 
 144 static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 145 {
 146     chosePlainText = false;
 147 
 148     Document&amp; document = context.ownerDocument();
 149     if (dragData.containsCompatibleContent()) {
 150         if (auto fragment = frame.editor().webContentFromPasteboard(*Pasteboard::createForDragAndDrop(dragData), context, allowPlainText, chosePlainText))
 151             return fragment;
 152 
 153         if (dragData.containsURL(DragData::DoNotConvertFilenames)) {
 154             String title;
 155             String url = dragData.asURL(DragData::DoNotConvertFilenames, &amp;title);
 156             if (!url.isEmpty()) {
 157                 auto anchor = HTMLAnchorElement::create(document);
 158                 anchor-&gt;setHref(url);
 159                 if (title.isEmpty()) {
 160                     // Try the plain text first because the url might be normalized or escaped.
 161                     if (dragData.containsPlainText())
 162                         title = dragData.asPlainText();
 163                     if (title.isEmpty())
 164                         title = url;
 165                 }
 166                 anchor-&gt;appendChild(document.createTextNode(title));
 167                 auto fragment = document.createDocumentFragment();
 168                 fragment-&gt;appendChild(anchor);
 169                 return fragment;
 170             }
 171         }
 172     }
 173     if (allowPlainText &amp;&amp; dragData.containsPlainText()) {
 174         chosePlainText = true;
 175         return createFragmentFromText(context, dragData.asPlainText()).ptr();
 176     }
 177 
 178     return nullptr;
 179 }
 180 
 181 #if !PLATFORM(IOS_FAMILY)
 182 
 183 DragOperation DragController::platformGenericDragOperation()
 184 {
 185     return DragOperationMove;
 186 }
 187 
 188 #endif
 189 
 190 bool DragController::dragIsMove(FrameSelection&amp; selection, const DragData&amp; dragData)
 191 {
 192     const VisibleSelection&amp; visibleSelection = selection.selection();
 193     return m_documentUnderMouse == m_dragInitiator &amp;&amp; visibleSelection.isContentEditable() &amp;&amp; visibleSelection.isRange() &amp;&amp; !isCopyKeyDown(dragData);
 194 }
 195 
 196 void DragController::clearDragCaret()
 197 {
 198     m_page.dragCaretController().clear();
 199 }
 200 
 201 void DragController::dragEnded()
 202 {
 203     m_dragInitiator = nullptr;
 204     m_didInitiateDrag = false;
 205     m_documentUnderMouse = nullptr;
 206     clearDragCaret();
 207     removeAllDroppedImagePlaceholders();
 208 
 209     client().dragEnded();
 210 }
 211 
 212 DragOperation DragController::dragEntered(const DragData&amp; dragData)
 213 {
 214     return dragEnteredOrUpdated(dragData);
 215 }
 216 
 217 void DragController::dragExited(const DragData&amp; dragData)
 218 {
 219     auto&amp; mainFrame = m_page.mainFrame();
 220     if (mainFrame.view())
 221         mainFrame.eventHandler().cancelDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 222     mouseMovedIntoDocument(nullptr);
 223     if (m_fileInputElementUnderMouse)
 224         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 225     m_fileInputElementUnderMouse = nullptr;
 226 }
 227 
 228 DragOperation DragController::dragUpdated(const DragData&amp; dragData)
 229 {
 230     return dragEnteredOrUpdated(dragData);
 231 }
 232 
 233 inline static bool dragIsHandledByDocument(DragHandlingMethod dragHandlingMethod)
 234 {
 235     return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
 236 }
 237 
 238 bool DragController::performDragOperation(const DragData&amp; dragData)
 239 {
 240     if (!m_droppedImagePlaceholders.isEmpty() &amp;&amp; m_droppedImagePlaceholderRange &amp;&amp; tryToUpdateDroppedImagePlaceholders(dragData)) {
 241         m_droppedImagePlaceholders.clear();
 242         m_droppedImagePlaceholderRange = nullptr;
 243         m_documentUnderMouse = nullptr;
 244         clearDragCaret();
 245         return true;
 246     }
 247 
 248     removeAllDroppedImagePlaceholders();
 249 
 250     SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
 251     TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
 252 
 253     m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 254 
 255     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
 256     if (m_documentUnderMouse)
 257         shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
 258 
 259     if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
 260         client().willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);
 261         Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 262         bool preventedDefault = false;
 263         if (mainFrame-&gt;view())
 264             preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 265         if (preventedDefault) {
 266             clearDragCaret();
 267             m_documentUnderMouse = nullptr;
 268             return true;
 269         }
 270     }
 271 
 272     if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
 273         client().didConcludeEditDrag();
 274         m_documentUnderMouse = nullptr;
 275         clearDragCaret();
 276         return true;
 277     }
 278 
 279     m_documentUnderMouse = nullptr;
 280     clearDragCaret();
 281 
 282     if (operationForLoad(dragData) == DragOperationNone)
 283         return false;
 284 
 285     auto urlString = dragData.asURL();
 286     if (urlString.isEmpty())
 287         return false;
 288 
 289     client().willPerformDragDestinationAction(DragDestinationActionLoad, dragData);
 290     FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };
 291     frameLoadRequest.setIsRequestFromClientOrUserInput();
 292     m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
 293     return true;
 294 }
 295 
 296 void DragController::mouseMovedIntoDocument(Document* newDocument)
 297 {
 298     if (m_documentUnderMouse == newDocument)
 299         return;
 300 
 301     // If we were over another document clear the selection
 302     if (m_documentUnderMouse)
 303         clearDragCaret();
 304     m_documentUnderMouse = newDocument;
 305 }
 306 
 307 DragOperation DragController::dragEnteredOrUpdated(const DragData&amp; dragData)
 308 {
 309     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(dragData.clientPosition()));
 310 
 311     m_dragDestinationAction = dragData.dragDestinationAction();
 312     if (m_dragDestinationAction == DragDestinationActionNone) {
 313         clearDragCaret(); // FIXME: Why not call mouseMovedIntoDocument(nullptr)?
 314         return DragOperationNone;
 315     }
 316 
 317     DragOperation dragOperation = DragOperationNone;
 318     m_dragHandlingMethod = tryDocumentDrag(dragData, m_dragDestinationAction, dragOperation);
 319     if (m_dragHandlingMethod == DragHandlingMethod::None &amp;&amp; (m_dragDestinationAction &amp; DragDestinationActionLoad)) {
 320         dragOperation = operationForLoad(dragData);
 321         if (dragOperation != DragOperationNone)
 322             m_dragHandlingMethod = DragHandlingMethod::PageLoad;
 323     } else if (m_dragHandlingMethod == DragHandlingMethod::SetColor)
 324         dragOperation = DragOperationCopy;
 325 
 326     updateSupportedTypeIdentifiersForDragHandlingMethod(m_dragHandlingMethod, dragData);
 327     return dragOperation;
 328 }
 329 
 330 static HTMLInputElement* asFileInput(Node&amp; node)
 331 {
 332     if (!is&lt;HTMLInputElement&gt;(node))
 333         return nullptr;
 334 
 335     auto* inputElement = &amp;downcast&lt;HTMLInputElement&gt;(node);
 336 
 337     // If this is a button inside of the a file input, move up to the file input.
 338     if (inputElement-&gt;isTextButton() &amp;&amp; is&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode())) {
 339         auto&amp; host = *downcast&lt;ShadowRoot&gt;(inputElement-&gt;treeScope().rootNode()).host();
 340         inputElement = is&lt;HTMLInputElement&gt;(host) ? &amp;downcast&lt;HTMLInputElement&gt;(host) : nullptr;
 341     }
 342 
 343     return inputElement &amp;&amp; inputElement-&gt;isFileUpload() ? inputElement : nullptr;
 344 }
 345 
 346 #if ENABLE(INPUT_TYPE_COLOR)
 347 
 348 static bool isEnabledColorInput(Node&amp; node)
 349 {
 350     if (!is&lt;HTMLInputElement&gt;(node))
 351         return false;
 352     auto&amp; input = downcast&lt;HTMLInputElement&gt;(node);
 353     return input.isColorControl() &amp;&amp; !input.isDisabledFormControl();
 354 }
 355 
 356 static bool isInShadowTreeOfEnabledColorInput(Node&amp; node)
 357 {
 358     auto* host = node.shadowHost();
 359     return host &amp;&amp; isEnabledColorInput(*host);
 360 }
 361 
 362 #endif
 363 
 364 // This can return null if an empty document is loaded.
 365 static Element* elementUnderMouse(Document* documentUnderMouse, const IntPoint&amp; p)
 366 {
 367     Frame* frame = documentUnderMouse-&gt;frame();
 368     float zoomFactor = frame ? frame-&gt;pageZoomFactor() : 1;
 369     LayoutPoint point(p.x() * zoomFactor, p.y() * zoomFactor);
 370 
 371     HitTestResult result(point);
 372     documentUnderMouse-&gt;hitTest(HitTestRequest(), result);
 373 
 374     auto* node = result.innerNode();
 375     if (!node)
 376         return nullptr;
 377     // FIXME: Use parentElementInComposedTree here.
 378     auto* element = is&lt;Element&gt;(*node) ? &amp;downcast&lt;Element&gt;(*node) : node-&gt;parentElement();
 379     auto* host = element-&gt;shadowHost();
 380     return host ? host : element;
 381 }
 382 
 383 #if !ENABLE(DATA_INTERACTION)
 384 
 385 void DragController::updateSupportedTypeIdentifiersForDragHandlingMethod(DragHandlingMethod, const DragData&amp;) const
 386 {
 387 }
 388 
 389 #endif
 390 
 391 DragHandlingMethod DragController::tryDocumentDrag(const DragData&amp; dragData, DragDestinationAction actionMask, DragOperation&amp; dragOperation)
 392 {
 393     if (!m_documentUnderMouse)
 394         return DragHandlingMethod::None;
 395 
 396     if (m_dragInitiator &amp;&amp; !m_documentUnderMouse-&gt;securityOrigin().canReceiveDragData(m_dragInitiator-&gt;securityOrigin()))
 397         return DragHandlingMethod::None;
 398 
 399     bool isHandlingDrag = false;
 400     if (actionMask &amp; DragDestinationActionDHTML) {
 401         isHandlingDrag = tryDHTMLDrag(dragData, dragOperation);
 402         // Do not continue if m_documentUnderMouse has been reset by tryDHTMLDrag.
 403         // tryDHTMLDrag fires dragenter event. The event listener that listens
 404         // to this event may create a nested message loop (open a modal dialog),
 405         // which could process dragleave event and reset m_documentUnderMouse in
 406         // dragExited.
 407         if (!m_documentUnderMouse)
 408             return DragHandlingMethod::None;
 409     }
 410 
 411     // It&#39;s unclear why this check is after tryDHTMLDrag.
 412     // We send drag events in tryDHTMLDrag and that may be the reason.
 413     RefPtr&lt;FrameView&gt; frameView = m_documentUnderMouse-&gt;view();
 414     if (!frameView)
 415         return DragHandlingMethod::None;
 416 
 417     if (isHandlingDrag) {
 418         clearDragCaret();
 419         m_numberOfItemsToBeAccepted = dragData.numberOfFiles();
 420         return DragHandlingMethod::NonDefault;
 421     }
 422 
 423     if ((actionMask &amp; DragDestinationActionEdit) &amp;&amp; canProcessDrag(dragData)) {
 424         if (dragData.containsColor()) {
 425             dragOperation = DragOperationGeneric;
 426             return DragHandlingMethod::SetColor;
 427         }
 428 
 429         IntPoint point = frameView-&gt;windowToContents(dragData.clientPosition());
 430         Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 431         if (!element)
 432             return DragHandlingMethod::None;
 433 
 434         HTMLInputElement* elementAsFileInput = asFileInput(*element);
 435         if (m_fileInputElementUnderMouse != elementAsFileInput) {
 436             if (m_fileInputElementUnderMouse)
 437                 m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 438             m_fileInputElementUnderMouse = elementAsFileInput;
 439         }
 440 
 441         if (!m_fileInputElementUnderMouse)
 442             m_page.dragCaretController().setCaretPosition(m_documentUnderMouse-&gt;frame()-&gt;visiblePositionForPoint(point));
 443         else
 444             clearDragCaret();
 445 
 446         Frame* innerFrame = element-&gt;document().frame();
 447         dragOperation = dragIsMove(innerFrame-&gt;selection(), dragData) ? DragOperationMove : DragOperationCopy;
 448 
 449         unsigned numberOfFiles = dragData.numberOfFiles();
 450         if (m_fileInputElementUnderMouse) {
 451             if (m_fileInputElementUnderMouse-&gt;isDisabledFormControl())
 452                 m_numberOfItemsToBeAccepted = 0;
 453             else if (m_fileInputElementUnderMouse-&gt;multiple())
 454                 m_numberOfItemsToBeAccepted = numberOfFiles;
 455             else if (numberOfFiles &gt; 1)
 456                 m_numberOfItemsToBeAccepted = 0;
 457             else
 458                 m_numberOfItemsToBeAccepted = 1;
 459 
 460             if (!m_numberOfItemsToBeAccepted)
 461                 dragOperation = DragOperationNone;
 462             m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(m_numberOfItemsToBeAccepted);
 463         } else {
 464             // We are not over a file input element. The dragged item(s) will loaded into the view,
 465             // dropped as text paths on other input elements, or handled by script on the page.
 466             m_numberOfItemsToBeAccepted = numberOfFiles;
 467         }
 468 
 469         if (m_fileInputElementUnderMouse)
 470             return DragHandlingMethod::UploadFile;
 471 
 472         if (m_page.dragCaretController().isContentRichlyEditable())
 473             return DragHandlingMethod::EditRichText;
 474 
 475         return DragHandlingMethod::EditPlainText;
 476     }
 477 
 478     // We are not over an editable region. Make sure we&#39;re clearing any prior drag cursor.
 479     clearDragCaret();
 480     if (m_fileInputElementUnderMouse)
 481         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 482     m_fileInputElementUnderMouse = nullptr;
 483     return DragHandlingMethod::None;
 484 }
 485 
 486 DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
 487 {
 488     m_dragSourceAction = client().dragSourceActionMaskForPoint(rootViewPoint);
 489     return m_dragSourceAction;
 490 }
 491 
 492 DragOperation DragController::operationForLoad(const DragData&amp; dragData)
 493 {
 494     Document* document = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 495 
 496     bool pluginDocumentAcceptsDrags = false;
 497 
 498     if (is&lt;PluginDocument&gt;(document)) {
 499         const Widget* widget = downcast&lt;PluginDocument&gt;(*document).pluginWidget();
 500         const PluginViewBase* pluginView = is&lt;PluginViewBase&gt;(widget) ? downcast&lt;PluginViewBase&gt;(widget) : nullptr;
 501 
 502         if (pluginView)
 503             pluginDocumentAcceptsDrags = pluginView-&gt;shouldAllowNavigationFromDrags();
 504     }
 505 
 506     if (document &amp;&amp; (m_didInitiateDrag || (is&lt;PluginDocument&gt;(*document) &amp;&amp; !pluginDocumentAcceptsDrags) || document-&gt;hasEditableStyle()))
 507         return DragOperationNone;
 508     return dragOperation(dragData);
 509 }
 510 
 511 static bool setSelectionToDragCaret(Frame* frame, VisibleSelection&amp; dragCaret, RefPtr&lt;Range&gt;&amp; range, const IntPoint&amp; point)
 512 {
 513     Ref&lt;Frame&gt; protector(*frame);
 514     frame-&gt;selection().setSelection(dragCaret);
 515     if (frame-&gt;selection().selection().isNone()) {
 516         dragCaret = frame-&gt;visiblePositionForPoint(point);
 517         frame-&gt;selection().setSelection(dragCaret);
 518         range = dragCaret.toNormalizedRange();
 519     }
 520     return !frame-&gt;selection().isNone() &amp;&amp; frame-&gt;selection().selection().isContentEditable();
 521 }
 522 
 523 bool DragController::dispatchTextInputEventFor(Frame* innerFrame, const DragData&amp; dragData)
 524 {
 525     ASSERT(m_page.dragCaretController().hasCaret());
 526     String text = m_page.dragCaretController().isContentRichlyEditable() ? emptyString() : dragData.asPlainText();
 527     Element* target = innerFrame-&gt;editor().findEventTargetFrom(m_page.dragCaretController().caretPosition());
 528     // FIXME: What guarantees target is not null?
 529     auto event = TextEvent::createForDrop(&amp;innerFrame-&gt;windowProxy(), text);
 530     target-&gt;dispatchEvent(event);
 531     return !event-&gt;defaultPrevented();
 532 }
 533 
 534 bool DragController::concludeEditDrag(const DragData&amp; dragData)
 535 {
 536     RefPtr&lt;HTMLInputElement&gt; fileInput = m_fileInputElementUnderMouse;
 537     if (m_fileInputElementUnderMouse) {
 538         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 539         m_fileInputElementUnderMouse = nullptr;
 540     }
 541 
 542     if (!m_documentUnderMouse)
 543         return false;
 544 
 545     IntPoint point = m_documentUnderMouse-&gt;view()-&gt;windowToContents(dragData.clientPosition());
 546     Element* element = elementUnderMouse(m_documentUnderMouse.get(), point);
 547     if (!element)
 548         return false;
 549     RefPtr&lt;Frame&gt; innerFrame = element-&gt;document().frame();
 550     ASSERT(innerFrame);
 551 
 552     if (m_page.dragCaretController().hasCaret() &amp;&amp; !dispatchTextInputEventFor(innerFrame.get(), dragData))
 553         return true;
 554 
 555     if (dragData.containsColor()) {
 556         Color color = dragData.asColor();
 557         if (!color.isValid())
 558             return false;
 559 #if ENABLE(INPUT_TYPE_COLOR)
 560         if (isEnabledColorInput(*element)) {
 561             auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
 562             input.setValue(color.serialized(), DispatchInputAndChangeEvent);
 563             return true;
 564         }
 565 #endif
 566         auto innerRange = innerFrame-&gt;selection().toNormalizedRange();
 567         if (!innerRange)
 568             return false;
 569         auto style = MutableStyleProperties::create();
 570         style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
 571         if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
 572             return false;
 573         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 574         innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
 575         return true;
 576     }
 577 
 578     if (dragData.containsFiles() &amp;&amp; fileInput) {
 579         // fileInput should be the element we hit tested for, unless it was made
 580         // display:none in a drop event handler.
 581         ASSERT(fileInput == element || !fileInput-&gt;renderer());
 582         if (fileInput-&gt;isDisabledFormControl())
 583             return false;
 584 
 585         return fileInput-&gt;receiveDroppedFiles(dragData);
 586     }
 587 
 588     if (!m_page.dragController().canProcessDrag(dragData))
 589         return false;
 590 
 591     VisibleSelection dragCaret = m_page.dragCaretController().caretPosition();
 592     RefPtr&lt;Range&gt; range = dragCaret.toNormalizedRange();
 593     RefPtr&lt;Element&gt; rootEditableElement = innerFrame-&gt;selection().selection().rootEditableElement();
 594 
 595     // For range to be null a WebKit client must have done something bad while
 596     // manually controlling drag behaviour
 597     if (!range)
 598         return false;
 599 
 600     ResourceCacheValidationSuppressor validationSuppressor(range-&gt;ownerDocument().cachedResourceLoader());
 601     auto&amp; editor = innerFrame-&gt;editor();
 602     bool isMove = dragIsMove(innerFrame-&gt;selection(), dragData);
 603     if (isMove || dragCaret.isContentRichlyEditable()) {
 604         bool chosePlainText = false;
 605         RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
 606         if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
 607             return false;
 608 
 609         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 610 
 611         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 612             return true;
 613 
 614         if (isMove) {
 615             // NSTextView behavior is to always smart delete on moving a selection,
 616             // but only to smart insert if the selection granularity is word granularity.
 617             bool smartDelete = editor.smartInsertDeleteEnabled();
 618             bool smartInsert = smartDelete &amp;&amp; innerFrame-&gt;selection().granularity() == WordGranularity &amp;&amp; dragData.canSmartReplace();
 619             MoveSelectionCommand::create(fragment.releaseNonNull(), dragCaret.base(), smartInsert, smartDelete)-&gt;apply();
 620         } else {
 621             if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point)) {
 622                 OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::PreventNesting };
 623                 if (dragData.canSmartReplace())
 624                     options.add(ReplaceSelectionCommand::SmartReplace);
 625                 if (chosePlainText)
 626                     options.add(ReplaceSelectionCommand::MatchStyle);
 627                 ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.releaseNonNull(), options, EditAction::InsertFromDrop)-&gt;apply();
 628             }
 629         }
 630     } else {
 631         String text = dragData.asPlainText();
 632         if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
 633             return false;
 634 
 635         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);
 636         RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
 637         if (!fragment)
 638             return false;
 639 
 640         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 641             return true;
 642 
 643         if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point))
 644             ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.get(), { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MatchStyle, ReplaceSelectionCommand::PreventNesting }, EditAction::InsertFromDrop)-&gt;apply();
 645     }
 646 
 647     if (rootEditableElement) {
 648         if (Frame* frame = rootEditableElement-&gt;document().frame())
 649             frame-&gt;eventHandler().updateDragStateAfterEditDragIfNeeded(*rootEditableElement);
 650     }
 651 
 652     return true;
 653 }
 654 
 655 bool DragController::canProcessDrag(const DragData&amp; dragData)
 656 {
 657     IntPoint point = m_page.mainFrame().view()-&gt;windowToContents(dragData.clientPosition());
 658     HitTestResult result = HitTestResult(point);
 659     if (!m_page.mainFrame().contentRenderer())
 660         return false;
 661 
 662     result = m_page.mainFrame().eventHandler().hitTestResultAtPoint(point, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);
 663 
 664     auto* dragNode = result.innerNonSharedNode();
 665     if (!dragNode)
 666         return false;
 667 
 668     DragData::DraggingPurpose dragPurpose = DragData::DraggingPurpose::ForEditing;
 669     if (asFileInput(*dragNode))
 670         dragPurpose = DragData::DraggingPurpose::ForFileUpload;
 671 #if ENABLE(INPUT_TYPE_COLOR)
 672     else if (isEnabledColorInput(*dragNode) || isInShadowTreeOfEnabledColorInput(*dragNode))
 673         dragPurpose = DragData::DraggingPurpose::ForColorControl;
 674 #endif
 675 
 676     if (!dragData.containsCompatibleContent(dragPurpose))
 677         return false;
 678 
 679     if (dragPurpose == DragData::DraggingPurpose::ForFileUpload)
 680         return true;
 681 
 682 #if ENABLE(INPUT_TYPE_COLOR)
 683     if (dragPurpose == DragData::DraggingPurpose::ForColorControl)
 684         return true;
 685 #endif
 686 
 687     if (is&lt;HTMLPlugInElement&gt;(*dragNode)) {
 688         if (!downcast&lt;HTMLPlugInElement&gt;(*dragNode).canProcessDrag() &amp;&amp; !dragNode-&gt;hasEditableStyle())
 689             return false;
 690     } else if (!dragNode-&gt;hasEditableStyle())
 691         return false;
 692 
 693     if (m_didInitiateDrag &amp;&amp; m_documentUnderMouse == m_dragInitiator &amp;&amp; result.isSelected())
 694         return false;
 695 
 696     return true;
 697 }
 698 
 699 static DragOperation defaultOperationForDrag(DragOperation srcOpMask)
 700 {
 701     // This is designed to match IE&#39;s operation fallback for the case where
 702     // the page calls preventDefault() in a drag event but doesn&#39;t set dropEffect.
 703     if (srcOpMask == DragOperationEvery)
 704         return DragOperationCopy;
 705     if (srcOpMask == DragOperationNone)
 706         return DragOperationNone;
 707     if (srcOpMask &amp; DragOperationMove)
 708         return DragOperationMove;
 709     if (srcOpMask &amp; DragOperationGeneric)
 710         return DragController::platformGenericDragOperation();
 711     if (srcOpMask &amp; DragOperationCopy)
 712         return DragOperationCopy;
 713     if (srcOpMask &amp; DragOperationLink)
 714         return DragOperationLink;
 715 
 716     // FIXME: Does IE really return &quot;generic&quot; even if no operations were allowed by the source?
 717     return DragOperationGeneric;
 718 }
 719 
 720 bool DragController::tryDHTMLDrag(const DragData&amp; dragData, DragOperation&amp; operation)
 721 {
 722     ASSERT(m_documentUnderMouse);
 723     Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 724     RefPtr&lt;FrameView&gt; viewProtector = mainFrame-&gt;view();
 725     if (!viewProtector)
 726         return false;
 727 
 728     DragOperation sourceOperation = dragData.draggingSourceOperationMask();
 729     auto targetResponse = mainFrame-&gt;eventHandler().updateDragAndDrop(createMouseEvent(dragData), [&amp;dragData]() { return Pasteboard::createForDragAndDrop(dragData); }, sourceOperation, dragData.containsFiles());
 730     if (!targetResponse.accept)
 731         return false;
 732 
 733     if (!targetResponse.operation)
 734         operation = defaultOperationForDrag(sourceOperation);
 735     else if (!(sourceOperation &amp; targetResponse.operation.value())) // The element picked an operation which is not supported by the source
 736         operation = DragOperationNone;
 737     else
 738         operation = targetResponse.operation.value();
 739 
 740     return true;
 741 }
 742 
 743 static bool imageElementIsDraggable(const HTMLImageElement&amp; image, const Frame&amp; sourceFrame)
 744 {
 745     if (sourceFrame.settings().loadsImagesAutomatically())
 746         return true;
 747 
 748     auto* renderer = image.renderer();
 749     if (!is&lt;RenderImage&gt;(renderer))
 750         return false;
 751 
 752     auto* cachedImage = downcast&lt;RenderImage&gt;(*renderer).cachedImage();
 753     return cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred() &amp;&amp; cachedImage-&gt;imageForRenderer(renderer);
 754 }
 755 
 756 #if ENABLE(ATTACHMENT_ELEMENT)
 757 
 758 static RefPtr&lt;HTMLAttachmentElement&gt; enclosingAttachmentElement(Element&amp; element)
 759 {
 760     if (is&lt;HTMLAttachmentElement&gt;(element))
 761         return downcast&lt;HTMLAttachmentElement&gt;(&amp;element);
 762 
 763     if (is&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement()))
 764         return downcast&lt;HTMLAttachmentElement&gt;(element.parentOrShadowHostElement());
 765 
 766     return { };
 767 }
 768 
 769 #endif
 770 
 771 Element* DragController::draggableElement(const Frame* sourceFrame, Element* startElement, const IntPoint&amp; dragOrigin, DragState&amp; state) const
 772 {
 773     state.type = (sourceFrame-&gt;selection().contains(dragOrigin)) ? DragSourceActionSelection : DragSourceActionNone;
 774     if (!startElement)
 775         return nullptr;
 776 #if ENABLE(ATTACHMENT_ELEMENT)
 777     if (auto attachment = enclosingAttachmentElement(*startElement)) {
 778         auto selection = sourceFrame-&gt;selection().selection();
 779         bool isSingleAttachmentSelection = selection.start() == Position(attachment.get(), Position::PositionIsBeforeAnchor) &amp;&amp; selection.end() == Position(attachment.get(), Position::PositionIsAfterAnchor);
 780         bool isAttachmentElementInCurrentSelection = false;
 781         if (auto selectedRange = selection.toNormalizedRange()) {
 782             auto compareResult = selectedRange-&gt;compareNode(*attachment);
 783             isAttachmentElementInCurrentSelection = !compareResult.hasException() &amp;&amp; compareResult.releaseReturnValue() == Range::NODE_INSIDE;
 784         }
 785 
 786         if (!isAttachmentElementInCurrentSelection || isSingleAttachmentSelection) {
 787             state.type = DragSourceActionAttachment;
 788             return attachment.get();
 789         }
 790     }
 791 #endif
 792 
 793     for (auto* element = startElement; element; element = element-&gt;parentOrShadowHostElement()) {
 794         auto* renderer = element-&gt;renderer();
 795         if (!renderer)
 796             continue;
 797 
 798         UserDrag dragMode = renderer-&gt;style().userDrag();
 799         if ((m_dragSourceAction &amp; DragSourceActionDHTML) &amp;&amp; dragMode == UserDrag::Element) {
 800             state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionDHTML);
 801             return element;
 802         }
 803         if (dragMode == UserDrag::Auto) {
 804             if ((m_dragSourceAction &amp; DragSourceActionImage)
 805                 &amp;&amp; is&lt;HTMLImageElement&gt;(*element)
 806                 &amp;&amp; imageElementIsDraggable(downcast&lt;HTMLImageElement&gt;(*element), *sourceFrame)) {
 807                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionImage);
 808                 return element;
 809             }
 810             if ((m_dragSourceAction &amp; DragSourceActionLink) &amp;&amp; isDraggableLink(*element)) {
 811                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionLink);
 812                 return element;
 813             }
 814 #if ENABLE(ATTACHMENT_ELEMENT)
 815             if ((m_dragSourceAction &amp; DragSourceActionAttachment)
 816                 &amp;&amp; is&lt;HTMLAttachmentElement&gt;(*element)
 817                 &amp;&amp; downcast&lt;HTMLAttachmentElement&gt;(*element).file()) {
 818                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionAttachment);
 819                 return element;
 820             }
 821 #endif
 822 #if ENABLE(INPUT_TYPE_COLOR)
 823             if ((m_dragSourceAction &amp; DragSourceActionColor) &amp;&amp; isEnabledColorInput(*element)) {
 824                 state.type = static_cast&lt;DragSourceAction&gt;(state.type | DragSourceActionColor);
 825                 return element;
 826             }
 827 #endif
 828         }
 829     }
 830 
 831     // We either have nothing to drag or we have a selection and we&#39;re not over a draggable element.
 832     if (state.type &amp; DragSourceActionSelection &amp;&amp; m_dragSourceAction &amp; DragSourceActionSelection)
 833         return startElement;
 834 
 835     return nullptr;
 836 }
 837 
 838 static CachedImage* getCachedImage(Element&amp; element)
 839 {
 840     RenderObject* renderer = element.renderer();
 841     if (!is&lt;RenderImage&gt;(renderer))
 842         return nullptr;
 843     auto&amp; image = downcast&lt;RenderImage&gt;(*renderer);
 844     return image.cachedImage();
 845 }
 846 
 847 static Image* getImage(Element&amp; element)
 848 {
 849     CachedImage* cachedImage = getCachedImage(element);
 850     // Don&#39;t use cachedImage-&gt;imageForRenderer() here as that may return BitmapImages for cached SVG Images.
 851     // Users of getImage() want access to the SVGImage, in order to figure out the filename extensions,
 852     // which would be empty when asking the cached BitmapImages.
 853     return (cachedImage &amp;&amp; !cachedImage-&gt;errorOccurred()) ?
 854         cachedImage-&gt;image() : nullptr;
 855 }
 856 
 857 static void selectElement(Element&amp; element)
 858 {
 859     RefPtr&lt;Range&gt; range = element.document().createRange();
 860     range-&gt;selectNode(element);
 861     element.document().frame()-&gt;selection().setSelection(VisibleSelection(*range, DOWNSTREAM));
 862 }
 863 
 864 static IntPoint dragLocForDHTMLDrag(const IntPoint&amp; mouseDraggedPoint, const IntPoint&amp; dragOrigin, const IntPoint&amp; dragImageOffset, bool isLinkImage)
 865 {
 866     // dragImageOffset is the cursor position relative to the lower-left corner of the image.
 867 #if PLATFORM(MAC)
 868     // We add in the Y dimension because we are a flipped view, so adding moves the image down.
 869     const int yOffset = dragImageOffset.y();
 870 #else
 871     const int yOffset = -dragImageOffset.y();
 872 #endif
 873 
 874     if (isLinkImage)
 875         return IntPoint(mouseDraggedPoint.x() - dragImageOffset.x(), mouseDraggedPoint.y() + yOffset);
 876 
 877     return IntPoint(dragOrigin.x() - dragImageOffset.x(), dragOrigin.y() + yOffset);
 878 }
 879 
 880 static FloatPoint dragImageAnchorPointForSelectionDrag(Frame&amp; frame, const IntPoint&amp; mouseDraggedPoint)
 881 {
 882     IntRect draggingRect = enclosingIntRect(frame.selection().selectionBounds());
 883 
 884     float x = (mouseDraggedPoint.x() - draggingRect.x()) / (float)draggingRect.width();
 885     float y = (mouseDraggedPoint.y() - draggingRect.y()) / (float)draggingRect.height();
 886 
 887     return FloatPoint { x, y };
 888 }
 889 
 890 static IntPoint dragLocForSelectionDrag(Frame&amp; src)
 891 {
 892     IntRect draggingRect = enclosingIntRect(src.selection().selectionBounds());
 893     int xpos = draggingRect.maxX();
 894     xpos = draggingRect.x() &lt; xpos ? draggingRect.x() : xpos;
 895     int ypos = draggingRect.maxY();
 896 #if PLATFORM(COCOA)
 897     // Deal with flipped coordinates on Mac
 898     ypos = draggingRect.y() &gt; ypos ? draggingRect.y() : ypos;
 899 #else
 900     ypos = draggingRect.y() &lt; ypos ? draggingRect.y() : ypos;
 901 #endif
 902     return IntPoint(xpos, ypos);
 903 }
 904 
 905 bool DragController::startDrag(Frame&amp; src, const DragState&amp; state, DragOperation srcOp, const PlatformMouseEvent&amp; dragEvent, const IntPoint&amp; dragOrigin, HasNonDefaultPasteboardData hasData)
 906 {
 907     if (!src.view() || !src.contentRenderer() || !state.source)
 908         return false;
 909 
 910     Ref&lt;Frame&gt; protector(src);
 911     HitTestResult hitTestResult = src.eventHandler().hitTestResultAtPoint(dragOrigin, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);
 912 
 913     bool sourceContainsHitNode = state.source-&gt;containsIncludingShadowDOM(hitTestResult.innerNode());
 914     if (!sourceContainsHitNode) {
 915         // The original node being dragged isn&#39;t under the drag origin anymore... maybe it was
 916         // hidden or moved out from under the cursor. Regardless, we don&#39;t want to start a drag on
 917         // something that&#39;s not actually under the drag origin.
 918         return false;
 919     }
 920 
 921     URL linkURL = hitTestResult.absoluteLinkURL();
 922     URL imageURL = hitTestResult.absoluteImageURL();
 923 
 924     IntPoint mouseDraggedPoint = src.view()-&gt;windowToContents(dragEvent.position());
 925 
 926     m_draggingImageURL = URL();
 927     m_sourceDragOperation = srcOp;
 928 
 929     DragImage dragImage;
 930     IntPoint dragLoc(0, 0);
 931     IntPoint dragImageOffset(0, 0);
 932 
 933     ASSERT(state.dataTransfer);
 934 
 935     DataTransfer&amp; dataTransfer = *state.dataTransfer;
 936     if (state.type == DragSourceActionDHTML) {
 937         dragImage = DragImage { dataTransfer.createDragImage(dragImageOffset) };
 938         // We allow DHTML/JS to set the drag image, even if its a link, image or text we&#39;re dragging.
 939         // This is in the spirit of the IE API, which allows overriding of pasteboard data and DragOp.
 940         if (dragImage) {
 941             dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, !linkURL.isEmpty());
 942             m_dragOffset = dragImageOffset;
 943         }
 944     }
 945 
 946     if (state.type == DragSourceActionSelection || !imageURL.isEmpty() || !linkURL.isEmpty()) {
 947         // Selection, image, and link drags receive a default set of allowed drag operations that
 948         // follows from:
 949         // http://trac.webkit.org/browser/trunk/WebKit/mac/WebView/WebHTMLView.mm?rev=48526#L3430
 950         m_sourceDragOperation = static_cast&lt;DragOperation&gt;(m_sourceDragOperation | DragOperationGeneric | DragOperationCopy);
 951     }
 952 
 953     ASSERT(state.source);
 954     Element&amp; element = *state.source;
 955 
 956     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || client().useLegacyDragClient();
 957 
 958     IntRect dragImageBounds;
 959     Image* image = getImage(element);
 960     if (state.type == DragSourceActionSelection) {
 961         PasteboardWriterData pasteboardWriterData;
 962 
 963         if (hasData == HasNonDefaultPasteboardData::No) {
 964             if (src.selection().selection().isNone()) {
 965                 // The page may have cleared out the selection in the dragstart handler, in which case we should bail
 966                 // out of the drag, since there is no content to write to the pasteboard.
 967                 return false;
 968             }
 969 
 970             // FIXME: This entire block is almost identical to the code in Editor::copy, and the code should be shared.
 971             RefPtr&lt;Range&gt; selectionRange = src.selection().toNormalizedRange();
 972             ASSERT(selectionRange);
 973 
 974             src.editor().willWriteSelectionToPasteboard(selectionRange.get());
 975 
 976             if (enclosingTextFormControl(src.selection().selection().start())) {
 977                 if (mustUseLegacyDragClient)
 978                     dataTransfer.pasteboard().writePlainText(src.editor().selectedTextForDataTransfer(), Pasteboard::CannotSmartReplace);
 979                 else {
 980                     PasteboardWriterData::PlainText plainText;
 981                     plainText.canSmartCopyOrDelete = false;
 982                     plainText.text = src.editor().selectedTextForDataTransfer();
 983                     pasteboardWriterData.setPlainText(WTFMove(plainText));
 984                 }
 985             } else {
 986                 if (mustUseLegacyDragClient) {
 987 #if PLATFORM(COCOA) || PLATFORM(GTK)
 988                     src.editor().writeSelectionToPasteboard(dataTransfer.pasteboard());
 989 #else
 990                     // FIXME: Convert all other platforms to match Mac and delete this.
 991                     dataTransfer.pasteboard().writeSelection(*selectionRange, src.editor().canSmartCopyOrDelete(), src, IncludeImageAltTextForDataTransfer);
 992 #endif
 993                 } else {
 994 #if PLATFORM(COCOA)
 995                     src.editor().writeSelection(pasteboardWriterData);
 996 #endif
 997                 }
 998             }
 999 
1000             src.editor().didWriteSelectionToPasteboard();
1001         }
1002         client().willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);
1003         if (!dragImage) {
1004             TextIndicatorData textIndicator;
1005             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1006             if (textIndicator.contentImage)
1007                 dragImage.setIndicatorData(textIndicator);
1008             dragLoc = dragLocForSelectionDrag(src);
1009             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1010         }
1011 
1012         if (!dragImage)
1013             return false;
1014 
1015         if (mustUseLegacyDragClient) {
1016             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1017             return true;
1018         }
1019 
1020         DragItem dragItem;
1021         dragItem.imageAnchorPoint = dragImageAnchorPointForSelectionDrag(src, mouseDraggedPoint);
1022         dragItem.image = WTFMove(dragImage);
1023         dragItem.data = WTFMove(pasteboardWriterData);
1024 
1025         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1026 
1027         return true;
1028     }
1029 
1030     if (!src.document()-&gt;securityOrigin().canDisplay(linkURL)) {
1031         src.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to drag local resource: &quot; + linkURL.stringCenterEllipsizedToLength());
1032         return false;
1033     }
1034 
1035     if (!imageURL.isEmpty() &amp;&amp; image &amp;&amp; !image-&gt;isNull() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionImage)) {
1036         // We shouldn&#39;t be starting a drag for an image that can&#39;t provide an extension.
1037         // This is an early detection for problems encountered later upon drop.
1038         ASSERT(!image-&gt;filenameExtension().isEmpty());
1039 
1040 #if ENABLE(ATTACHMENT_ELEMENT)
1041         auto attachmentInfo = promisedAttachmentInfo(src, element);
1042 #else
1043         PromisedAttachmentInfo attachmentInfo;
1044 #endif
1045 
1046         if (hasData == HasNonDefaultPasteboardData::No) {
1047             m_draggingImageURL = imageURL;
1048             if (element.isContentRichlyEditable())
1049                 selectElement(element);
1050             if (!attachmentInfo)
1051                 declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
1052         }
1053 
1054         client().willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);
1055 
1056         if (!dragImage)
1057             doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
1058         else {
1059             // DHTML defined drag image
1060             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(attachmentInfo));
1061         }
1062 
1063         return true;
1064     }
1065 
1066     if (!linkURL.isEmpty() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionLink)) {
1067         PasteboardWriterData pasteboardWriterData;
1068 
1069         String textContentWithSimplifiedWhiteSpace = hitTestResult.textContent().simplifyWhiteSpace();
1070 
1071         if (hasData == HasNonDefaultPasteboardData::No) {
1072             // Simplify whitespace so the title put on the dataTransfer resembles what the user sees
1073             // on the web page. This includes replacing newlines with spaces.
1074             if (mustUseLegacyDragClient)
1075                 src.editor().copyURL(linkURL, textContentWithSimplifiedWhiteSpace, dataTransfer.pasteboard());
1076             else
1077                 pasteboardWriterData.setURLData(src.editor().pasteboardWriterURL(linkURL, textContentWithSimplifiedWhiteSpace));
1078         } else {
1079             // Make sure the pasteboard also contains trustworthy link data
1080             // but don&#39;t overwrite more general pasteboard types.
1081             PasteboardURL pasteboardURL;
1082             pasteboardURL.url = linkURL;
1083             pasteboardURL.title = hitTestResult.textContent();
1084             dataTransfer.pasteboard().writeTrustworthyWebURLsPboardType(pasteboardURL);
1085         }
1086 
1087         const VisibleSelection&amp; sourceSelection = src.selection().selection();
1088         if (sourceSelection.isCaret() &amp;&amp; sourceSelection.isContentEditable()) {
1089             // a user can initiate a drag on a link without having any text
1090             // selected.  In this case, we should expand the selection to
1091             // the enclosing anchor element
1092             Position pos = sourceSelection.base();
1093             Node* node = enclosingAnchorElement(pos);
1094             if (node)
1095                 src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
1096         }
1097 
1098         client().willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);
1099         if (!dragImage) {
1100             TextIndicatorData textIndicator;
1101             dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
1102             if (dragImage) {
1103                 m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
1104                 dragLoc = IntPoint(dragOrigin.x() + m_dragOffset.x(), dragOrigin.y() + m_dragOffset.y());
1105                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1106                 if (textIndicator.contentImage)
1107                     dragImage.setIndicatorData(textIndicator);
1108             }
1109         }
1110 
1111         if (mustUseLegacyDragClient) {
1112             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1113             return true;
1114         }
1115 
1116         DragItem dragItem;
1117         dragItem.imageAnchorPoint = dragImage ? anchorPointForLinkDragImage(dragImage.get()) : FloatPoint();
1118         dragItem.image = WTFMove(dragImage);
1119         dragItem.data = WTFMove(pasteboardWriterData);
1120 
1121         beginDrag(WTFMove(dragItem), src, dragOrigin, mouseDraggedPoint, dataTransfer, DragSourceActionSelection);
1122 
1123         return true;
1124     }
1125 
1126 #if ENABLE(ATTACHMENT_ELEMENT)
1127     if (is&lt;HTMLAttachmentElement&gt;(element) &amp;&amp; m_dragSourceAction &amp; DragSourceActionAttachment) {
1128         auto&amp; attachment = downcast&lt;HTMLAttachmentElement&gt;(element);
1129         auto* attachmentRenderer = attachment.renderer();
1130 
1131         src.editor().setIgnoreSelectionChanges(true);
1132         auto previousSelection = src.selection().selection();
1133         selectElement(element);
1134 
1135         PromisedAttachmentInfo promisedAttachment;
1136         if (hasData == HasNonDefaultPasteboardData::No) {
1137             promisedAttachment = promisedAttachmentInfo(src, attachment);
1138             auto&amp; editor = src.editor();
1139             if (!promisedAttachment &amp;&amp; editor.client()) {
1140 #if PLATFORM(COCOA)
1141                 // Otherwise, if no file URL is specified, call out to the injected bundle to populate the pasteboard with data.
1142                 editor.willWriteSelectionToPasteboard(src.selection().toNormalizedRange().get());
1143                 editor.writeSelectionToPasteboard(dataTransfer.pasteboard());
1144                 editor.didWriteSelectionToPasteboard();
1145 #endif
1146             }
1147         }
1148 
1149         client().willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);
1150 
1151         if (!dragImage) {
1152             TextIndicatorData textIndicator;
1153             if (attachmentRenderer)
1154                 attachmentRenderer-&gt;setShouldDrawBorder(false);
1155             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1156             if (attachmentRenderer)
1157                 attachmentRenderer-&gt;setShouldDrawBorder(true);
1158             if (textIndicator.contentImage)
1159                 dragImage.setIndicatorData(textIndicator);
1160             dragLoc = dragLocForSelectionDrag(src);
1161             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1162         }
1163         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(promisedAttachment));
1164         if (!element.isContentRichlyEditable())
1165             src.selection().setSelection(previousSelection);
1166         src.editor().setIgnoreSelectionChanges(false);
1167         return true;
1168     }
1169 #endif
1170 
1171 #if ENABLE(INPUT_TYPE_COLOR)
1172     bool isColorControl = is&lt;HTMLInputElement&gt;(state.source) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*state.source).isColorControl();
1173     if (isColorControl &amp;&amp; m_dragSourceAction &amp; DragSourceActionColor) {
1174         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*state.source);
1175         auto color = input.valueAsColor();
1176 
1177         Path visiblePath;
1178         dragImage = DragImage { createDragImageForColor(color, input.boundsInRootViewSpace(), input.document().page()-&gt;pageScaleFactor(), visiblePath) };
1179         dragImage.setVisiblePath(visiblePath);
1180         dataTransfer.pasteboard().write(color);
1181         dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
1182         dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
1183 
1184         client().willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);
1185         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1186         return true;
1187     }
1188 #endif
1189 
1190     if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
1191         ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
1192         client().willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);
1193         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1194         return true;
1195     }
1196 
1197     return false;
1198 }
1199 
1200 void DragController::doImageDrag(Element&amp; element, const IntPoint&amp; dragOrigin, const IntRect&amp; layoutRect, Frame&amp; frame, IntPoint&amp; dragImageOffset, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; attachmentInfo)
1201 {
1202     IntPoint mouseDownPoint = dragOrigin;
1203     DragImage dragImage;
1204     IntPoint scaledOrigin;
1205 
1206     if (!element.renderer())
1207         return;
1208 
1209     ImageOrientation orientation = element.renderer()-&gt;imageOrientation();
1210 
1211     Image* image = getImage(element);
1212     if (image &amp;&amp; !layoutRect.isEmpty() &amp;&amp; shouldUseCachedImageForDragImage(*image) &amp;&amp; (dragImage = DragImage { createDragImageFromImage(image, orientation) })) {
1213         dragImage = DragImage { fitDragImageToMaxSize(dragImage.get(), layoutRect.size(), maxDragImageSize()) };
1214         IntSize fittedSize = dragImageSize(dragImage.get());
1215 
1216         dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1217         dragImage = DragImage { dissolveDragImageToFraction(dragImage.get(), DragImageAlpha) };
1218 
1219         // Properly orient the drag image and orient it differently if it&#39;s smaller than the original.
1220         float scale = fittedSize.width() / (float)layoutRect.width();
1221         float dx = scale * (layoutRect.x() - mouseDownPoint.x());
1222         float originY = layoutRect.y();
1223 #if PLATFORM(COCOA)
1224         // Compensate for accursed flipped coordinates in Cocoa.
1225         originY += layoutRect.height();
1226 #endif
1227         float dy = scale * (originY - mouseDownPoint.y());
1228         scaledOrigin = IntPoint((int)(dx + 0.5), (int)(dy + 0.5));
1229     } else {
1230         if (CachedImage* cachedImage = getCachedImage(element)) {
1231             dragImage = DragImage { createDragImageIconForCachedImageFilename(cachedImage-&gt;response().suggestedFilename()) };
1232             if (dragImage) {
1233                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1234                 scaledOrigin = IntPoint(DragIconRightInset - dragImageSize(dragImage.get()).width(), DragIconBottomInset);
1235             }
1236         }
1237     }
1238 
1239     if (!dragImage)
1240         return;
1241 
1242     dragImageOffset = mouseDownPoint + scaledOrigin;
1243     doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
1244 }
1245 
1246 void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
1247 {
1248     ASSERT(!client().useLegacyDragClient());
1249 
1250     m_didInitiateDrag = true;
1251     m_dragInitiator = frame.document();
1252 
1253     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1254     Ref&lt;Frame&gt; mainFrameProtector(m_page.mainFrame());
1255     RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
1256 
1257     auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
1258     auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
1259 
1260     client().beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);
1261 }
1262 
1263 void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
1264 {
1265     m_didInitiateDrag = true;
1266     m_dragInitiator = frame.document();
1267     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1268     Ref&lt;Frame&gt; frameProtector(m_page.mainFrame());
1269     RefPtr&lt;FrameView&gt; viewProtector = frameProtector-&gt;view();
1270 
1271     DragItem item;
1272     item.image = WTFMove(image);
1273     item.sourceAction = state.type;
1274     item.promisedAttachmentInfo = WTFMove(promisedAttachmentInfo);
1275 
1276     auto eventPositionInRootViewCoordinates = frame.view()-&gt;contentsToRootView(eventPos);
1277     auto dragLocationInRootViewCoordinates = frame.view()-&gt;contentsToRootView(dragLoc);
1278     item.eventPositionInContentCoordinates = viewProtector-&gt;rootViewToContents(eventPositionInRootViewCoordinates);
1279     item.dragLocationInContentCoordinates = viewProtector-&gt;rootViewToContents(dragLocationInRootViewCoordinates);
1280     item.dragLocationInWindowCoordinates = viewProtector-&gt;contentsToWindow(item.dragLocationInContentCoordinates);
1281     if (auto element = state.source) {
1282         auto dataTransferImageElement = state.dataTransfer-&gt;dragImageElement();
1283         if (state.type == DragSourceActionDHTML) {
1284             // If the drag image has been customized, fall back to positioning the preview relative to the drag event location.
1285             IntSize dragPreviewSize;
1286             if (dataTransferImageElement)
1287                 dragPreviewSize = dataTransferImageElement-&gt;boundsInRootViewSpace().size();
1288             else {
1289                 dragPreviewSize = dragImageSize(item.image.get());
1290                 if (auto* page = frame.page())
1291                     dragPreviewSize.scale(1 / page-&gt;deviceScaleFactor());
1292             }
1293             item.dragPreviewFrameInRootViewCoordinates = { dragLocationInRootViewCoordinates, WTFMove(dragPreviewSize) };
1294         } else {
1295             // We can position the preview using the bounds of the drag source element.
1296             item.dragPreviewFrameInRootViewCoordinates = element-&gt;boundsInRootViewSpace();
1297         }
1298 
1299         RefPtr&lt;Element&gt; link;
1300         if (element-&gt;isLink())
1301             link = element;
1302         else {
1303             for (auto&amp; currentElement : elementLineage(element.get())) {
1304                 if (currentElement.isLink()) {
1305                     link = &amp;currentElement;
1306                     break;
1307                 }
1308             }
1309         }
1310         if (link) {
1311             auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
1312             item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
1313             item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
1314         }
1315     }
1316     client().startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());
1317     // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
1318     if (!frameProtector-&gt;page())
1319         return;
1320 
1321     cleanupAfterSystemDrag();
1322 }
1323 
1324 void DragController::removeAllDroppedImagePlaceholders()
1325 {
1326     m_droppedImagePlaceholderRange = nullptr;
1327     for (auto&amp; placeholder : std::exchange(m_droppedImagePlaceholders, { })) {
1328         if (placeholder-&gt;isConnected())
1329             placeholder-&gt;remove();
1330     }
1331 }
1332 
1333 bool DragController::tryToUpdateDroppedImagePlaceholders(const DragData&amp; dragData)
1334 {
1335     ASSERT(!m_droppedImagePlaceholders.isEmpty());
1336     ASSERT(m_droppedImagePlaceholderRange);
1337 
1338     auto document = makeRef(m_droppedImagePlaceholders[0]-&gt;document());
1339     auto frame = makeRefPtr(document-&gt;frame());
1340     if (!frame)
1341         return false;
1342 
1343     WebContentReader reader(*frame, *m_droppedImagePlaceholderRange, true);
1344     auto pasteboard = Pasteboard::createForDragAndDrop(dragData);
1345     pasteboard-&gt;read(reader);
1346 
1347     if (!reader.fragment)
1348         return false;
1349 
1350     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; imageElements;
1351     for (auto&amp; imageElement : descendantsOfType&lt;HTMLImageElement&gt;(*reader.fragment))
1352         imageElements.append(imageElement);
1353 
1354     if (imageElements.size() != m_droppedImagePlaceholders.size()) {
1355         ASSERT_NOT_REACHED();
1356         return false;
1357     }
1358 
1359     for (size_t i = 0; i &lt; imageElements.size(); ++i) {
1360         auto&amp; imageElement = imageElements[i];
1361         auto&amp; placeholder = m_droppedImagePlaceholders[i];
1362         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, imageElement-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr));
1363 #if ENABLE(ATTACHMENT_ELEMENT)
1364         if (auto attachment = imageElement-&gt;attachmentElement())
1365             placeholder-&gt;setAttachmentElement(attachment.releaseNonNull());
1366 #endif
1367     }
1368     return true;
1369 }
1370 
1371 void DragController::insertDroppedImagePlaceholdersAtCaret(const Vector&lt;IntSize&gt;&amp; imageSizes)
1372 {
1373     auto&amp; caretController = m_page.dragCaretController();
1374     if (!caretController.isContentRichlyEditable())
1375         return;
1376 
1377     auto dropCaret = caretController.caretPosition();
1378     if (dropCaret.isNull())
1379         return;
1380 
1381     auto document = makeRefPtr(dropCaret.deepEquivalent().document());
1382     if (!document)
1383         return;
1384 
1385     auto frame = makeRefPtr(document-&gt;frame());
1386     if (!frame)
1387         return;
1388 
1389     TemporarySelectionChange selectionChange(*frame, WTF::nullopt, { TemporarySelectionOption::IgnoreSelectionChanges });
1390 
1391     auto fragment = DocumentFragment::create(*document);
1392     for (auto&amp; size : imageSizes) {
1393         ASSERT(!size.isEmpty());
1394         auto image = HTMLImageElement::create(*document);
1395         image-&gt;setAttributeWithoutSynchronization(HTMLNames::widthAttr, AtomString::number(size.width()));
1396         image-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(size.height()));
1397         image-&gt;setInlineStyleProperty(CSSPropertyMaxWidth, 100, CSSUnitType::CSS_PERCENTAGE);
1398         image-&gt;setInlineStyleProperty(CSSPropertyBackgroundColor, Color(Color::black).colorWithAlpha(0.05).cssText());
1399         image-&gt;setIsDroppedImagePlaceholder();
1400         fragment-&gt;appendChild(WTFMove(image));
1401     }
1402 
1403     frame-&gt;selection().setSelection(dropCaret);
1404 
1405     auto command = ReplaceSelectionCommand::create(*document, WTFMove(fragment), { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SmartReplace }, EditAction::InsertFromDrop);
1406     command-&gt;apply();
1407 
1408     auto insertedContentRange = command-&gt;insertedContentRange();
1409     if (!insertedContentRange) {
1410         ASSERT_NOT_REACHED();
1411         return;
1412     }
1413 
1414     auto container = makeRefPtr(insertedContentRange-&gt;commonAncestorContainer());
1415     if (!is&lt;ContainerNode&gt;(container)) {
1416         ASSERT_NOT_REACHED();
1417         return;
1418     }
1419 
1420     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; placeholders;
1421     for (auto&amp; placeholder : descendantsOfType&lt;HTMLImageElement&gt;(downcast&lt;ContainerNode&gt;(*container))) {
1422         auto intersectsNode = insertedContentRange-&gt;intersectsNode(placeholder);
1423         if (!intersectsNode.hasException() &amp;&amp; intersectsNode.returnValue())
1424             placeholders.append(placeholder);
1425     }
1426 
1427     if (placeholders.size() != imageSizes.size()) {
1428         ASSERT_NOT_REACHED();
1429         return;
1430     }
1431 
1432     for (size_t i = 0; i &lt; placeholders.size(); ++i) {
1433         auto&amp; placeholder = placeholders[i];
1434         auto imageSize = imageSizes[i];
1435         double clientWidth = placeholder-&gt;clientWidth();
1436         double heightRespectingAspectRatio = (imageSize.height() * clientWidth) / imageSize.width();
1437         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(heightRespectingAspectRatio));
1438     }
1439 
1440     document-&gt;updateLayout();
1441 
1442     m_droppedImagePlaceholders = WTFMove(placeholders);
1443     m_droppedImagePlaceholderRange = WTFMove(insertedContentRange);
1444 
1445     frame-&gt;selection().clear();
1446     caretController.setCaretPosition(m_droppedImagePlaceholderRange-&gt;startPosition());
1447 }
1448 
1449 void DragController::finalizeDroppedImagePlaceholder(HTMLImageElement&amp; placeholder)
1450 {
1451     ASSERT(placeholder.isDroppedImagePlaceholder());
1452     placeholder.removeAttribute(HTMLNames::heightAttr);
1453     placeholder.removeInlineStyleProperty(CSSPropertyBackgroundColor);
1454 }
1455 
1456 // Manual drag caret manipulation
1457 void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
1458 {
1459     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
1460     if (!m_documentUnderMouse)
1461         return;
1462     Frame* frame = m_documentUnderMouse-&gt;frame();
1463     FrameView* frameView = frame-&gt;view();
1464     if (!frameView)
1465         return;
1466     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
1467 
1468     m_page.dragCaretController().setCaretPosition(frame-&gt;visiblePositionForPoint(framePoint));
1469 }
1470 
1471 bool DragController::shouldUseCachedImageForDragImage(const Image&amp; image) const
1472 {
1473 #if ENABLE(DATA_INTERACTION)
1474     UNUSED_PARAM(image);
1475     return true;
1476 #else
1477     return image.size().height() * image.size().width() &lt;= MaxOriginalImageArea;
1478 #endif
1479 }
1480 
1481 #if !PLATFORM(COCOA)
1482 
1483 String DragController::platformContentTypeForBlobType(const String&amp; type) const
1484 {
1485     return type;
1486 }
1487 
1488 #endif
1489 
1490 #if ENABLE(ATTACHMENT_ELEMENT)
1491 
1492 PromisedAttachmentInfo DragController::promisedAttachmentInfo(Frame&amp; frame, Element&amp; element)
1493 {
1494     auto* client = frame.editor().client();
1495     if (!client || !client-&gt;supportsClientSideAttachmentData())
1496         return { };
1497 
1498     RefPtr&lt;HTMLAttachmentElement&gt; attachment;
1499     if (is&lt;HTMLAttachmentElement&gt;(element))
1500         attachment = &amp;downcast&lt;HTMLAttachmentElement&gt;(element);
1501     else if (is&lt;HTMLImageElement&gt;(element))
1502         attachment = downcast&lt;HTMLImageElement&gt;(element).attachmentElement();
1503 
1504     if (!attachment)
1505         return { };
1506 
1507     Vector&lt;String&gt; additionalTypes;
1508     Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt; additionalData;
1509 #if PLATFORM(COCOA)
1510     frame.editor().getPasteboardTypesAndDataForAttachment(element, additionalTypes, additionalData);
1511 #endif
1512 
1513     if (auto* file = attachment-&gt;file())
1514         return { file-&gt;url(), platformContentTypeForBlobType(file-&gt;type()), file-&gt;name(), { }, WTFMove(additionalTypes), WTFMove(additionalData) };
1515 
1516     return { { }, { }, { }, attachment-&gt;uniqueIdentifier(), WTFMove(additionalTypes), WTFMove(additionalData) };
1517 }
1518 
1519 #endif // ENABLE(ATTACHMENT_ELEMENT)
1520 
1521 #endif // ENABLE(DRAG_SUPPORT)
1522 
1523 } // namespace WebCore
    </pre>
  </body>
</html>
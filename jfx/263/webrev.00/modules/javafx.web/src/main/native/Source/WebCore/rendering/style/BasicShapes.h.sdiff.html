<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BasicShapes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BorderData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;Length.h&quot;
 33 #include &quot;LengthSize.h&quot;
 34 #include &quot;WindRule.h&quot;
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/RefPtr.h&gt;
 37 #include &lt;wtf/TypeCasts.h&gt;
 38 #include &lt;wtf/Vector.h&gt;
 39 




 40 namespace WebCore {
 41 
 42 class FloatRect;
 43 class Path;
 44 class RenderBox;
 45 class SVGPathByteStream;
 46 
 47 class BasicShape : public RefCounted&lt;BasicShape&gt; {
 48 public:
 49     virtual ~BasicShape() = default;
 50 
<span class="line-modified"> 51     enum Type {</span>
<span class="line-modified"> 52         BasicShapePolygonType,</span>
<span class="line-modified"> 53         BasicShapePathType,</span>
<span class="line-modified"> 54         BasicShapeCircleType,</span>
<span class="line-modified"> 55         BasicShapeEllipseType,</span>
<span class="line-modified"> 56         BasicShapeInsetType</span>
 57     };
 58 
 59     virtual Type type() const = 0;
 60 
 61     virtual const Path&amp; path(const FloatRect&amp;) = 0;
 62     virtual WindRule windRule() const { return WindRule::NonZero; }
 63 
 64     virtual bool canBlend(const BasicShape&amp;) const = 0;
 65     virtual Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const = 0;
 66 
 67     virtual bool operator==(const BasicShape&amp;) const = 0;


 68 };
 69 
 70 class BasicShapeCenterCoordinate {
 71 public:
 72     enum Direction {
 73         TopLeft,
 74         BottomRight
 75     };
 76 
 77     BasicShapeCenterCoordinate()
<span class="line-removed"> 78         : m_direction(TopLeft)</span>
<span class="line-removed"> 79         , m_length(Undefined)</span>
 80     {
 81         updateComputedLength();
 82     }
 83 
 84     BasicShapeCenterCoordinate(Direction direction, Length length)
 85         : m_direction(direction)
 86         , m_length(length)
 87     {
 88         updateComputedLength();
 89     }
 90 
 91     Direction direction() const { return m_direction; }
 92     const Length&amp; length() const { return m_length; }
 93     const Length&amp; computedLength() const { return m_computedLength; }
 94 
 95     BasicShapeCenterCoordinate blend(const BasicShapeCenterCoordinate&amp; from, double progress) const
 96     {
 97         return BasicShapeCenterCoordinate(TopLeft, WebCore::blend(from.m_computedLength, m_computedLength, progress));
 98     }
 99 
100     bool operator==(const BasicShapeCenterCoordinate&amp; other) const
101     {
102         return m_direction == other.m_direction
103             &amp;&amp; m_length == other.m_length
104             &amp;&amp; m_computedLength == other.m_computedLength;
105     }
106 
107 private:
108     void updateComputedLength();
109 
<span class="line-modified">110     Direction m_direction;</span>
<span class="line-modified">111     Length m_length;</span>
112     Length m_computedLength;
113 };
114 
115 class BasicShapeRadius {
116 public:
117     enum Type {
118         Value,
119         ClosestSide,
120         FarthestSide
121     };
<span class="line-modified">122     BasicShapeRadius()</span>
<span class="line-modified">123         : m_value(Undefined),</span>
<span class="line-removed">124         m_type(ClosestSide)</span>
<span class="line-removed">125     { }</span>
126 
127     explicit BasicShapeRadius(Length v)
128         : m_value(v)
129         , m_type(Value)
130     { }
131     explicit BasicShapeRadius(Type t)
132         : m_value(Undefined)
133         , m_type(t)
134     { }
135 
136     const Length&amp; value() const { return m_value; }
137     Type type() const { return m_type; }
138 
139     bool canBlend(const BasicShapeRadius&amp; other) const
140     {
141         // FIXME determine how to interpolate between keywords. See bug 125108.
142         return m_type == Value &amp;&amp; other.type() == Value;
143     }
144 
145     BasicShapeRadius blend(const BasicShapeRadius&amp; from, double progress) const
146     {
147         if (m_type != Value || from.type() != Value)
148             return BasicShapeRadius(from);
149 
150         return BasicShapeRadius(WebCore::blend(from.value(), value(), progress));
151     }
152 
153     bool operator==(const BasicShapeRadius&amp; other) const
154     {
155         return m_value == other.m_value &amp;&amp; m_type == other.m_type;
156     }
157 
158 private:
<span class="line-modified">159     Length m_value;</span>
<span class="line-modified">160     Type m_type;</span>
<span class="line-removed">161 </span>
162 };
163 
164 class BasicShapeCircle final : public BasicShape {
165 public:
166     static Ref&lt;BasicShapeCircle&gt; create() { return adoptRef(*new BasicShapeCircle); }
167 
168     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
169     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
170     const BasicShapeRadius&amp; radius() const { return m_radius; }
171     float floatValueForRadiusInBox(float boxWidth, float boxHeight) const;
172 
173     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
174     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
175     void setRadius(BasicShapeRadius radius) { m_radius = WTFMove(radius); }
176 
177 private:
178     BasicShapeCircle() = default;
179 
<span class="line-modified">180     Type type() const override { return BasicShapeCircleType; }</span>
181 
182     const Path&amp; path(const FloatRect&amp;) override;
183 
184     bool canBlend(const BasicShape&amp;) const override;
185     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
186 
187     bool operator==(const BasicShape&amp;) const override;
188 


189     BasicShapeCenterCoordinate m_centerX;
190     BasicShapeCenterCoordinate m_centerY;
191     BasicShapeRadius m_radius;
192 };
193 
194 class BasicShapeEllipse final : public BasicShape {
195 public:
196     static Ref&lt;BasicShapeEllipse&gt; create() { return adoptRef(*new BasicShapeEllipse); }
197 
198     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
199     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
200     const BasicShapeRadius&amp; radiusX() const { return m_radiusX; }
201     const BasicShapeRadius&amp; radiusY() const { return m_radiusY; }
202     float floatValueForRadiusInBox(const BasicShapeRadius&amp;, float center, float boxWidthOrHeight) const;
203 
204     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
205     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
206     void setRadiusX(BasicShapeRadius radiusX) { m_radiusX = WTFMove(radiusX); }
207     void setRadiusY(BasicShapeRadius radiusY) { m_radiusY = WTFMove(radiusY); }
208 
209 private:
210     BasicShapeEllipse() = default;
211 
<span class="line-modified">212     Type type() const override { return BasicShapeEllipseType; }</span>
213 
214     const Path&amp; path(const FloatRect&amp;) override;
215 
216     bool canBlend(const BasicShape&amp;) const override;
217     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
218 
219     bool operator==(const BasicShape&amp;) const override;
220 


221     BasicShapeCenterCoordinate m_centerX;
222     BasicShapeCenterCoordinate m_centerY;
223     BasicShapeRadius m_radiusX;
224     BasicShapeRadius m_radiusY;
225 };
226 
227 class BasicShapePolygon final : public BasicShape {
228 public:
229     static Ref&lt;BasicShapePolygon&gt; create() { return adoptRef(*new BasicShapePolygon); }
230 
231     const Vector&lt;Length&gt;&amp; values() const { return m_values; }
232     const Length&amp; getXAt(unsigned i) const { return m_values[2 * i]; }
233     const Length&amp; getYAt(unsigned i) const { return m_values[2 * i + 1]; }
234 
235     void setWindRule(WindRule windRule) { m_windRule = windRule; }
236     void appendPoint(Length x, Length y) { m_values.append(WTFMove(x)); m_values.append(WTFMove(y)); }
237 
238     WindRule windRule() const override { return m_windRule; }
239 
240 private:
241     BasicShapePolygon() = default;
242 
<span class="line-modified">243     Type type() const override { return BasicShapePolygonType; }</span>
244 
245     const Path&amp; path(const FloatRect&amp;) override;
246 
247     bool canBlend(const BasicShape&amp;) const override;
248     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
249 
250     bool operator==(const BasicShape&amp;) const override;
251 


252     WindRule m_windRule { WindRule::NonZero };
253     Vector&lt;Length&gt; m_values;
254 };
255 
256 class BasicShapePath final : public BasicShape {
257 public:
258     static Ref&lt;BasicShapePath&gt; create(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
259     {
260         return adoptRef(*new BasicShapePath(WTFMove(byteStream)));
261     }
262 
263     void setWindRule(WindRule windRule) { m_windRule = windRule; }
264     WindRule windRule() const override { return m_windRule; }
265 
266     const SVGPathByteStream* pathData() const { return m_byteStream.get(); }
267 
268 private:
269     BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp;);
270 
<span class="line-modified">271     Type type() const override { return BasicShapePathType; }</span>
272 
273     const Path&amp; path(const FloatRect&amp;) override;
274 
275     bool canBlend(const BasicShape&amp;) const override;
276     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
277 
278     bool operator==(const BasicShape&amp;) const override;
279 


280     std::unique_ptr&lt;SVGPathByteStream&gt; m_byteStream;
281     WindRule m_windRule { WindRule::NonZero };
282 };
283 
284 class BasicShapeInset final : public BasicShape {
285 public:
286     static Ref&lt;BasicShapeInset&gt; create() { return adoptRef(*new BasicShapeInset); }
287 
288     const Length&amp; top() const { return m_top; }
289     const Length&amp; right() const { return m_right; }
290     const Length&amp; bottom() const { return m_bottom; }
291     const Length&amp; left() const { return m_left; }
292 
293     const LengthSize&amp; topLeftRadius() const { return m_topLeftRadius; }
294     const LengthSize&amp; topRightRadius() const { return m_topRightRadius; }
295     const LengthSize&amp; bottomRightRadius() const { return m_bottomRightRadius; }
296     const LengthSize&amp; bottomLeftRadius() const { return m_bottomLeftRadius; }
297 
298     void setTop(Length top) { m_top = WTFMove(top); }
299     void setRight(Length right) { m_right = WTFMove(right); }
300     void setBottom(Length bottom) { m_bottom = WTFMove(bottom); }
301     void setLeft(Length left) { m_left = WTFMove(left); }
302 
303     void setTopLeftRadius(LengthSize radius) { m_topLeftRadius = WTFMove(radius); }
304     void setTopRightRadius(LengthSize radius) { m_topRightRadius = WTFMove(radius); }
305     void setBottomRightRadius(LengthSize radius) { m_bottomRightRadius = WTFMove(radius); }
306     void setBottomLeftRadius(LengthSize radius) { m_bottomLeftRadius = WTFMove(radius); }
307 
308 private:
309     BasicShapeInset() = default;
310 
<span class="line-modified">311     Type type() const override { return BasicShapeInsetType; }</span>
312 
313     const Path&amp; path(const FloatRect&amp;) override;
314 
315     bool canBlend(const BasicShape&amp;) const override;
316     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
317 
318     bool operator==(const BasicShape&amp;) const override;
319 


320     Length m_right;
321     Length m_top;
322     Length m_bottom;
323     Length m_left;
324 
325     LengthSize m_topLeftRadius;
326     LengthSize m_topRightRadius;
327     LengthSize m_bottomRightRadius;
328     LengthSize m_bottomLeftRadius;
329 };
330 




331 } // namespace WebCore
332 
333 #define SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(ToValueTypeName, predicate) \
334 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
335     static bool isType(const WebCore::BasicShape&amp; basicShape) { return basicShape.type() == WebCore::predicate; } \
336 SPECIALIZE_TYPE_TRAITS_END()
337 
<span class="line-modified">338 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeCircle, BasicShape::BasicShapeCircleType)</span>
<span class="line-modified">339 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeEllipse, BasicShape::BasicShapeEllipseType)</span>
<span class="line-modified">340 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePolygon, BasicShape::BasicShapePolygonType)</span>
<span class="line-modified">341 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePath, BasicShape::BasicShapePathType)</span>
<span class="line-modified">342 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeInset, BasicShape::BasicShapeInsetType)</span>
</pre>
</td>
<td>
<hr />
<pre>
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;Length.h&quot;
 33 #include &quot;LengthSize.h&quot;
 34 #include &quot;WindRule.h&quot;
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/RefPtr.h&gt;
 37 #include &lt;wtf/TypeCasts.h&gt;
 38 #include &lt;wtf/Vector.h&gt;
 39 
<span class="line-added"> 40 namespace WTF {</span>
<span class="line-added"> 41 class TextStream;</span>
<span class="line-added"> 42 }</span>
<span class="line-added"> 43 </span>
 44 namespace WebCore {
 45 
 46 class FloatRect;
 47 class Path;
 48 class RenderBox;
 49 class SVGPathByteStream;
 50 
 51 class BasicShape : public RefCounted&lt;BasicShape&gt; {
 52 public:
 53     virtual ~BasicShape() = default;
 54 
<span class="line-modified"> 55     enum class Type {</span>
<span class="line-modified"> 56         Polygon,</span>
<span class="line-modified"> 57         Path,</span>
<span class="line-modified"> 58         Circle,</span>
<span class="line-modified"> 59         Ellipse,</span>
<span class="line-modified"> 60         Inset</span>
 61     };
 62 
 63     virtual Type type() const = 0;
 64 
 65     virtual const Path&amp; path(const FloatRect&amp;) = 0;
 66     virtual WindRule windRule() const { return WindRule::NonZero; }
 67 
 68     virtual bool canBlend(const BasicShape&amp;) const = 0;
 69     virtual Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const = 0;
 70 
 71     virtual bool operator==(const BasicShape&amp;) const = 0;
<span class="line-added"> 72 </span>
<span class="line-added"> 73     virtual void dump(TextStream&amp;) const = 0;</span>
 74 };
 75 
 76 class BasicShapeCenterCoordinate {
 77 public:
 78     enum Direction {
 79         TopLeft,
 80         BottomRight
 81     };
 82 
 83     BasicShapeCenterCoordinate()


 84     {
 85         updateComputedLength();
 86     }
 87 
 88     BasicShapeCenterCoordinate(Direction direction, Length length)
 89         : m_direction(direction)
 90         , m_length(length)
 91     {
 92         updateComputedLength();
 93     }
 94 
 95     Direction direction() const { return m_direction; }
 96     const Length&amp; length() const { return m_length; }
 97     const Length&amp; computedLength() const { return m_computedLength; }
 98 
 99     BasicShapeCenterCoordinate blend(const BasicShapeCenterCoordinate&amp; from, double progress) const
100     {
101         return BasicShapeCenterCoordinate(TopLeft, WebCore::blend(from.m_computedLength, m_computedLength, progress));
102     }
103 
104     bool operator==(const BasicShapeCenterCoordinate&amp; other) const
105     {
106         return m_direction == other.m_direction
107             &amp;&amp; m_length == other.m_length
108             &amp;&amp; m_computedLength == other.m_computedLength;
109     }
110 
111 private:
112     void updateComputedLength();
113 
<span class="line-modified">114     Direction m_direction { TopLeft };</span>
<span class="line-modified">115     Length m_length { Undefined };</span>
116     Length m_computedLength;
117 };
118 
119 class BasicShapeRadius {
120 public:
121     enum Type {
122         Value,
123         ClosestSide,
124         FarthestSide
125     };
<span class="line-modified">126 </span>
<span class="line-modified">127     BasicShapeRadius() = default;</span>


128 
129     explicit BasicShapeRadius(Length v)
130         : m_value(v)
131         , m_type(Value)
132     { }
133     explicit BasicShapeRadius(Type t)
134         : m_value(Undefined)
135         , m_type(t)
136     { }
137 
138     const Length&amp; value() const { return m_value; }
139     Type type() const { return m_type; }
140 
141     bool canBlend(const BasicShapeRadius&amp; other) const
142     {
143         // FIXME determine how to interpolate between keywords. See bug 125108.
144         return m_type == Value &amp;&amp; other.type() == Value;
145     }
146 
147     BasicShapeRadius blend(const BasicShapeRadius&amp; from, double progress) const
148     {
149         if (m_type != Value || from.type() != Value)
150             return BasicShapeRadius(from);
151 
152         return BasicShapeRadius(WebCore::blend(from.value(), value(), progress));
153     }
154 
155     bool operator==(const BasicShapeRadius&amp; other) const
156     {
157         return m_value == other.m_value &amp;&amp; m_type == other.m_type;
158     }
159 
160 private:
<span class="line-modified">161     Length m_value { Undefined };</span>
<span class="line-modified">162     Type m_type { ClosestSide };</span>

163 };
164 
165 class BasicShapeCircle final : public BasicShape {
166 public:
167     static Ref&lt;BasicShapeCircle&gt; create() { return adoptRef(*new BasicShapeCircle); }
168 
169     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
170     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
171     const BasicShapeRadius&amp; radius() const { return m_radius; }
172     float floatValueForRadiusInBox(float boxWidth, float boxHeight) const;
173 
174     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
175     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
176     void setRadius(BasicShapeRadius radius) { m_radius = WTFMove(radius); }
177 
178 private:
179     BasicShapeCircle() = default;
180 
<span class="line-modified">181     Type type() const override { return Type::Circle; }</span>
182 
183     const Path&amp; path(const FloatRect&amp;) override;
184 
185     bool canBlend(const BasicShape&amp;) const override;
186     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
187 
188     bool operator==(const BasicShape&amp;) const override;
189 
<span class="line-added">190     void dump(TextStream&amp;) const final;</span>
<span class="line-added">191 </span>
192     BasicShapeCenterCoordinate m_centerX;
193     BasicShapeCenterCoordinate m_centerY;
194     BasicShapeRadius m_radius;
195 };
196 
197 class BasicShapeEllipse final : public BasicShape {
198 public:
199     static Ref&lt;BasicShapeEllipse&gt; create() { return adoptRef(*new BasicShapeEllipse); }
200 
201     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
202     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
203     const BasicShapeRadius&amp; radiusX() const { return m_radiusX; }
204     const BasicShapeRadius&amp; radiusY() const { return m_radiusY; }
205     float floatValueForRadiusInBox(const BasicShapeRadius&amp;, float center, float boxWidthOrHeight) const;
206 
207     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
208     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
209     void setRadiusX(BasicShapeRadius radiusX) { m_radiusX = WTFMove(radiusX); }
210     void setRadiusY(BasicShapeRadius radiusY) { m_radiusY = WTFMove(radiusY); }
211 
212 private:
213     BasicShapeEllipse() = default;
214 
<span class="line-modified">215     Type type() const override { return Type::Ellipse; }</span>
216 
217     const Path&amp; path(const FloatRect&amp;) override;
218 
219     bool canBlend(const BasicShape&amp;) const override;
220     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
221 
222     bool operator==(const BasicShape&amp;) const override;
223 
<span class="line-added">224     void dump(TextStream&amp;) const final;</span>
<span class="line-added">225 </span>
226     BasicShapeCenterCoordinate m_centerX;
227     BasicShapeCenterCoordinate m_centerY;
228     BasicShapeRadius m_radiusX;
229     BasicShapeRadius m_radiusY;
230 };
231 
232 class BasicShapePolygon final : public BasicShape {
233 public:
234     static Ref&lt;BasicShapePolygon&gt; create() { return adoptRef(*new BasicShapePolygon); }
235 
236     const Vector&lt;Length&gt;&amp; values() const { return m_values; }
237     const Length&amp; getXAt(unsigned i) const { return m_values[2 * i]; }
238     const Length&amp; getYAt(unsigned i) const { return m_values[2 * i + 1]; }
239 
240     void setWindRule(WindRule windRule) { m_windRule = windRule; }
241     void appendPoint(Length x, Length y) { m_values.append(WTFMove(x)); m_values.append(WTFMove(y)); }
242 
243     WindRule windRule() const override { return m_windRule; }
244 
245 private:
246     BasicShapePolygon() = default;
247 
<span class="line-modified">248     Type type() const override { return Type::Polygon; }</span>
249 
250     const Path&amp; path(const FloatRect&amp;) override;
251 
252     bool canBlend(const BasicShape&amp;) const override;
253     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
254 
255     bool operator==(const BasicShape&amp;) const override;
256 
<span class="line-added">257     void dump(TextStream&amp;) const final;</span>
<span class="line-added">258 </span>
259     WindRule m_windRule { WindRule::NonZero };
260     Vector&lt;Length&gt; m_values;
261 };
262 
263 class BasicShapePath final : public BasicShape {
264 public:
265     static Ref&lt;BasicShapePath&gt; create(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
266     {
267         return adoptRef(*new BasicShapePath(WTFMove(byteStream)));
268     }
269 
270     void setWindRule(WindRule windRule) { m_windRule = windRule; }
271     WindRule windRule() const override { return m_windRule; }
272 
273     const SVGPathByteStream* pathData() const { return m_byteStream.get(); }
274 
275 private:
276     BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp;);
277 
<span class="line-modified">278     Type type() const override { return Type::Path; }</span>
279 
280     const Path&amp; path(const FloatRect&amp;) override;
281 
282     bool canBlend(const BasicShape&amp;) const override;
283     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
284 
285     bool operator==(const BasicShape&amp;) const override;
286 
<span class="line-added">287     void dump(TextStream&amp;) const final;</span>
<span class="line-added">288 </span>
289     std::unique_ptr&lt;SVGPathByteStream&gt; m_byteStream;
290     WindRule m_windRule { WindRule::NonZero };
291 };
292 
293 class BasicShapeInset final : public BasicShape {
294 public:
295     static Ref&lt;BasicShapeInset&gt; create() { return adoptRef(*new BasicShapeInset); }
296 
297     const Length&amp; top() const { return m_top; }
298     const Length&amp; right() const { return m_right; }
299     const Length&amp; bottom() const { return m_bottom; }
300     const Length&amp; left() const { return m_left; }
301 
302     const LengthSize&amp; topLeftRadius() const { return m_topLeftRadius; }
303     const LengthSize&amp; topRightRadius() const { return m_topRightRadius; }
304     const LengthSize&amp; bottomRightRadius() const { return m_bottomRightRadius; }
305     const LengthSize&amp; bottomLeftRadius() const { return m_bottomLeftRadius; }
306 
307     void setTop(Length top) { m_top = WTFMove(top); }
308     void setRight(Length right) { m_right = WTFMove(right); }
309     void setBottom(Length bottom) { m_bottom = WTFMove(bottom); }
310     void setLeft(Length left) { m_left = WTFMove(left); }
311 
312     void setTopLeftRadius(LengthSize radius) { m_topLeftRadius = WTFMove(radius); }
313     void setTopRightRadius(LengthSize radius) { m_topRightRadius = WTFMove(radius); }
314     void setBottomRightRadius(LengthSize radius) { m_bottomRightRadius = WTFMove(radius); }
315     void setBottomLeftRadius(LengthSize radius) { m_bottomLeftRadius = WTFMove(radius); }
316 
317 private:
318     BasicShapeInset() = default;
319 
<span class="line-modified">320     Type type() const override { return Type::Inset; }</span>
321 
322     const Path&amp; path(const FloatRect&amp;) override;
323 
324     bool canBlend(const BasicShape&amp;) const override;
325     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
326 
327     bool operator==(const BasicShape&amp;) const override;
328 
<span class="line-added">329     void dump(TextStream&amp;) const final;</span>
<span class="line-added">330 </span>
331     Length m_right;
332     Length m_top;
333     Length m_bottom;
334     Length m_left;
335 
336     LengthSize m_topLeftRadius;
337     LengthSize m_topRightRadius;
338     LengthSize m_bottomRightRadius;
339     LengthSize m_bottomLeftRadius;
340 };
341 
<span class="line-added">342 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShapeRadius&amp;);</span>
<span class="line-added">343 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShapeCenterCoordinate&amp;);</span>
<span class="line-added">344 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShape&amp;);</span>
<span class="line-added">345 </span>
346 } // namespace WebCore
347 
348 #define SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(ToValueTypeName, predicate) \
349 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
350     static bool isType(const WebCore::BasicShape&amp; basicShape) { return basicShape.type() == WebCore::predicate; } \
351 SPECIALIZE_TYPE_TRAITS_END()
352 
<span class="line-modified">353 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeCircle, BasicShape::Type::Circle)</span>
<span class="line-modified">354 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeEllipse, BasicShape::Type::Ellipse)</span>
<span class="line-modified">355 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePolygon, BasicShape::Type::Polygon)</span>
<span class="line-modified">356 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePath, BasicShape::Type::Path)</span>
<span class="line-modified">357 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeInset, BasicShape::Type::Inset)</span>
</pre>
</td>
</tr>
</table>
<center><a href="BasicShapes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BorderData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
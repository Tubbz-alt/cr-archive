<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/MediaDocument.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MediaDocument.h&quot;
 28 
 29 #if ENABLE(VIDEO)
 30 
 31 #include &quot;Chrome.h&quot;
 32 #include &quot;ChromeClient.h&quot;
 33 #include &quot;CustomHeaderFields.h&quot;
 34 #include &quot;DocumentLoader.h&quot;
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;FrameLoader.h&quot;
 38 #include &quot;FrameLoaderClient.h&quot;
 39 #include &quot;HTMLBodyElement.h&quot;
 40 #include &quot;HTMLEmbedElement.h&quot;
 41 #include &quot;HTMLHeadElement.h&quot;
 42 #include &quot;HTMLHtmlElement.h&quot;
 43 #include &quot;HTMLMetaElement.h&quot;
 44 #include &quot;HTMLNames.h&quot;
 45 #include &quot;HTMLSourceElement.h&quot;
 46 #include &quot;HTMLVideoElement.h&quot;
 47 #include &quot;KeyboardEvent.h&quot;
 48 #include &quot;NodeList.h&quot;
 49 #include &quot;Page.h&quot;
 50 #include &quot;RawDataDocumentParser.h&quot;
 51 #include &quot;RuntimeEnabledFeatures.h&quot;
 52 #include &quot;ScriptController.h&quot;
 53 #include &quot;ShadowRoot.h&quot;
 54 #include &quot;TypedElementDescendantIterator.h&quot;
 55 #include &lt;wtf/IsoMallocInlines.h&gt;
 56 #include &lt;wtf/text/StringBuilder.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaDocument);
 61 
 62 using namespace HTMLNames;
 63 
 64 // FIXME: Share more code with PluginDocumentParser.
 65 class MediaDocumentParser final : public RawDataDocumentParser {
 66 public:
 67     static Ref&lt;MediaDocumentParser&gt; create(MediaDocument&amp; document)
 68     {
 69         return adoptRef(*new MediaDocumentParser(document));
 70     }
 71 
 72 private:
 73     MediaDocumentParser(MediaDocument&amp; document)
 74         : RawDataDocumentParser { document }
 75         , m_outgoingReferrer { document.outgoingReferrer() }
 76     {
 77     }
 78 
 79     void appendBytes(DocumentWriter&amp;, const char*, size_t) final;
 80     void createDocumentStructure();
 81 
 82     HTMLMediaElement* m_mediaElement { nullptr };
 83     String m_outgoingReferrer;
 84 };
 85 
 86 void MediaDocumentParser::createDocumentStructure()
 87 {
 88     auto&amp; document = *this-&gt;document();
 89 
 90     auto rootElement = HTMLHtmlElement::create(document);
 91     document.appendChild(rootElement);
 92     document.setCSSTarget(rootElement.ptr());
 93     rootElement-&gt;insertedByParser();
 94 
 95     if (document.frame())
 96         document.frame()-&gt;injectUserScripts(InjectAtDocumentStart);
 97 
 98 #if PLATFORM(IOS_FAMILY)
 99     auto headElement = HTMLHeadElement::create(document);
100     rootElement-&gt;appendChild(headElement);
101 
102     auto metaElement = HTMLMetaElement::create(document);
103     metaElement-&gt;setAttributeWithoutSynchronization(nameAttr, AtomString(&quot;viewport&quot;, AtomString::ConstructFromLiteral));
104     metaElement-&gt;setAttributeWithoutSynchronization(contentAttr, AtomString(&quot;width=device-width,initial-scale=1&quot;, AtomString::ConstructFromLiteral));
105     headElement-&gt;appendChild(metaElement);
106 #endif
107 
108     auto body = HTMLBodyElement::create(document);
109     rootElement-&gt;appendChild(body);
110 
111     auto videoElement = HTMLVideoElement::create(document);
112     m_mediaElement = videoElement.ptr();
113     videoElement-&gt;setAttributeWithoutSynchronization(controlsAttr, emptyAtom());
114     videoElement-&gt;setAttributeWithoutSynchronization(autoplayAttr, emptyAtom());
115     videoElement-&gt;setAttributeWithoutSynchronization(srcAttr, document.url().string());
116     if (auto loader = makeRefPtr(document.loader()))
117         videoElement-&gt;setAttributeWithoutSynchronization(typeAttr, loader-&gt;responseMIMEType());
118 
119     if (!RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled()) {
120         StringBuilder elementStyle;
121         elementStyle.appendLiteral(&quot;max-width: 100%; max-height: 100%;&quot;);
122 #if PLATFORM(IOS_FAMILY)
123         elementStyle.appendLiteral(&quot;width: 100%; height: auto;&quot;);
124 #endif
125         videoElement-&gt;setAttribute(styleAttr, elementStyle.toString());
126     }
127 
128     body-&gt;appendChild(videoElement);
129 
130     RefPtr&lt;Frame&gt; frame = document.frame();
131     if (!frame)
132         return;
133 
134     frame-&gt;loader().activeDocumentLoader()-&gt;setMainResourceDataBufferingPolicy(DataBufferingPolicy::DoNotBufferData);
135     frame-&gt;loader().setOutgoingReferrer(document.completeURL(m_outgoingReferrer));
136 }
137 
138 void MediaDocumentParser::appendBytes(DocumentWriter&amp;, const char*, size_t)
139 {
140     if (m_mediaElement)
141         return;
142 
143     createDocumentStructure();
144     finish();
145 }
146 
147 MediaDocument::MediaDocument(Frame* frame, const URL&amp; url)
148     : HTMLDocument(frame, url, MediaDocumentClass)
149 {
150     setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
151     lockCompatibilityMode();
152     if (frame)
153         m_outgoingReferrer = frame-&gt;loader().outgoingReferrer();
154 }
155 
156 MediaDocument::~MediaDocument()
157 {
158 }
159 
160 Ref&lt;DocumentParser&gt; MediaDocument::createParser()
161 {
162     return MediaDocumentParser::create(*this);
163 }
164 
165 static inline HTMLVideoElement* descendantVideoElement(ContainerNode&amp; node)
166 {
167     if (is&lt;HTMLVideoElement&gt;(node))
168         return downcast&lt;HTMLVideoElement&gt;(&amp;node);
169 
170     return descendantsOfType&lt;HTMLVideoElement&gt;(node).first();
171 }
172 
173 static inline HTMLVideoElement* ancestorVideoElement(Node* node)
174 {
175     while (node &amp;&amp; !is&lt;HTMLVideoElement&gt;(*node))
176         node = node-&gt;parentOrShadowHostNode();
177 
178     return downcast&lt;HTMLVideoElement&gt;(node);
179 }
180 
181 void MediaDocument::defaultEventHandler(Event&amp; event)
182 {
183     // Modern media controls have their own event handling to determine when to
184     // pause or resume playback.
185     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
186         return;
187 
188     // Match the default Quicktime plugin behavior to allow
189     // clicking and double-clicking to pause and play the media.
190     if (!is&lt;Node&gt;(event.target()))
191         return;
192     auto&amp; targetNode = downcast&lt;Node&gt;(*event.target());
193 
194     if (auto video = makeRefPtr(ancestorVideoElement(&amp;targetNode))) {
195         if (event.type() == eventNames().clickEvent) {
196             if (!video-&gt;canPlay()) {
197                 video-&gt;pause();
198                 event.setDefaultHandled();
199             }
200         } else if (event.type() == eventNames().dblclickEvent) {
201             if (video-&gt;canPlay()) {
202                 video-&gt;play();
203                 event.setDefaultHandled();
204             }
205         }
206     }
207 
208     if (!is&lt;ContainerNode&gt;(targetNode))
209         return;
210     auto&amp; targetContainer = downcast&lt;ContainerNode&gt;(targetNode);
211 
212     if (event.type() == eventNames().keydownEvent &amp;&amp; is&lt;KeyboardEvent&gt;(event)) {
213         auto video = makeRefPtr(descendantVideoElement(targetContainer));
214         if (!video)
215             return;
216 
217         auto&amp; keyboardEvent = downcast&lt;KeyboardEvent&gt;(event);
218         if (keyboardEvent.keyIdentifier() == &quot;U+0020&quot;) { // space
219             if (video-&gt;paused()) {
220                 if (video-&gt;canPlay())
221                     video-&gt;play();
222             } else
223                 video-&gt;pause();
224             keyboardEvent.setDefaultHandled();
225         }
226     }
227 }
228 
229 void MediaDocument::replaceMediaElementTimerFired()
230 {
231     auto htmlBody = makeRefPtr(bodyOrFrameset());
232     if (!htmlBody)
233         return;
234 
235     // Set body margin width and height to 0 as that is what a PluginDocument uses.
236     htmlBody-&gt;setAttributeWithoutSynchronization(marginwidthAttr, AtomString(&quot;0&quot;, AtomString::ConstructFromLiteral));
237     htmlBody-&gt;setAttributeWithoutSynchronization(marginheightAttr, AtomString(&quot;0&quot;, AtomString::ConstructFromLiteral));
238 
239     if (auto videoElement = makeRefPtr(descendantVideoElement(*htmlBody))) {
240         auto embedElement = HTMLEmbedElement::create(*this);
241 
242         embedElement-&gt;setAttributeWithoutSynchronization(widthAttr, AtomString(&quot;100%&quot;, AtomString::ConstructFromLiteral));
243         embedElement-&gt;setAttributeWithoutSynchronization(heightAttr, AtomString(&quot;100%&quot;, AtomString::ConstructFromLiteral));
244         embedElement-&gt;setAttributeWithoutSynchronization(nameAttr, AtomString(&quot;plugin&quot;, AtomString::ConstructFromLiteral));
245         embedElement-&gt;setAttributeWithoutSynchronization(srcAttr, url().string());
246 
247         ASSERT(loader());
248         if (auto loader = makeRefPtr(this-&gt;loader()))
249             embedElement-&gt;setAttributeWithoutSynchronization(typeAttr, loader-&gt;writer().mimeType());
250 
251         videoElement-&gt;parentNode()-&gt;replaceChild(embedElement, *videoElement);
252     }
253 }
254 
255 void MediaDocument::mediaElementNaturalSizeChanged(const IntSize&amp; newSize)
256 {
257     if (ownerElement())
258         return;
259 
260     if (newSize.isZero())
261         return;
262 
263     if (page())
264         page()-&gt;chrome().client().imageOrMediaDocumentSizeChanged(newSize);
265 }
266 
267 }
268 
269 #endif
    </pre>
  </body>
</html>
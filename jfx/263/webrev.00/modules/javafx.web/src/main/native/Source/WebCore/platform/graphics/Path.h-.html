<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2006, 2009, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #ifndef Path_h
 29 #define Path_h
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;WindRule.h&quot;
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Function.h&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if USE(CG)
 38 
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #include &lt;CoreGraphics/CGPath.h&gt;
 41 typedef struct CGPath PlatformPath;
 42 
 43 #elif USE(DIRECT2D)
 44 #include &quot;COMPtr.h&quot;
 45 
 46 interface ID2D1Geometry;
 47 interface ID2D1GeometryGroup;
 48 interface ID2D1PathGeometry;
 49 interface ID2D1GeometrySink;
 50 
 51 typedef ID2D1GeometryGroup PlatformPath;
 52 
 53 #elif USE(CAIRO)
 54 
 55 namespace WebCore {
 56 class CairoPath;
 57 }
 58 typedef WebCore::CairoPath PlatformPath;
 59 
 60 #elif USE(WINGDI)
 61 
 62 namespace WebCore {
 63 class PlatformPath;
 64 }
 65 typedef WebCore::PlatformPath PlatformPath;
 66 
 67 #elif PLATFORM(JAVA)
 68 #include &lt;wtf/RefPtr.h&gt;
 69 #include &quot;RQRef.h&quot;
 70 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPath;
 71 
 72 #else
 73 
 74 typedef void PlatformPath;
 75 
 76 #endif
 77 
 78 #if PLATFORM(JAVA)
 79 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPathPtr;
 80 #else
 81 typedef PlatformPath* PlatformPathPtr;
 82 #endif
 83 
 84 namespace WTF {
 85 class TextStream;
 86 }
 87 
 88 namespace WebCore {
 89 
 90     class AffineTransform;
 91     class FloatPoint;
 92     class FloatRoundedRect;
 93     class FloatSize;
 94     class GraphicsContext;
 95     class PathTraversalState;
 96     class RoundedRect;
 97     class StrokeStyleApplier;
 98 
 99     enum PathElementType {
100         PathElementMoveToPoint, // The points member will contain 1 value.
101         PathElementAddLineToPoint, // The points member will contain 1 value.
102         PathElementAddQuadCurveToPoint, // The points member will contain 2 values.
103         PathElementAddCurveToPoint, // The points member will contain 3 values.
104         PathElementCloseSubpath // The points member will contain no values.
105     };
106 
107     // The points in the structure are the same as those that would be used with the
108     // add... method. For example, a line returns the endpoint, while a cubic returns
109     // two tangent points and the endpoint.
110     struct PathElement {
111         PathElementType type;
112         FloatPoint* points;
113     };
114 
115     using PathApplierFunction = WTF::Function&lt;void (const PathElement&amp;)&gt;;
116 
117     class Path {
118         WTF_MAKE_FAST_ALLOCATED;
119     public:
120         WEBCORE_EXPORT Path();
121 #if USE(CG)
122         Path(RetainPtr&lt;CGMutablePathRef&gt;);
123 #endif
124         WEBCORE_EXPORT ~Path();
125 
126         WEBCORE_EXPORT Path(const Path&amp;);
127         WEBCORE_EXPORT Path(Path&amp;&amp;);
128         WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);
129         WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);
130 
131         static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);
132 
133         bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;
134         bool strokeContains(StrokeStyleApplier*, const FloatPoint&amp;) const;
135         // fastBoundingRect() should equal or contain boundingRect(); boundingRect()
136         // should perfectly bound the points within the path.
137         FloatRect boundingRect() const;
138         WEBCORE_EXPORT FloatRect fastBoundingRect() const;
139         FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;
140 
141         float length() const;
142         PathTraversalState traversalStateAtLength(float length, bool&amp; success) const;
143         FloatPoint pointAtLength(float length, bool&amp; success) const;
144         float normalAngleAtLength(float length, bool&amp; success) const;
145 
146         WEBCORE_EXPORT void clear();
147         bool isNull() const { return !m_path; }
148         bool isEmpty() const;
149         // Gets the current point of the current path, which is conceptually the final point reached by the path so far.
150         // Note the Path can be empty (isEmpty() == true) and still have a current point.
151         bool hasCurrentPoint() const;
152         FloatPoint currentPoint() const;
153 
154         WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);
155         WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);
156         WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);
157         WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);
158         void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);
159         WEBCORE_EXPORT void closeSubpath();
160 
161         void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);
162         void addRect(const FloatRect&amp;);
163         void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);
164         void addEllipse(const FloatRect&amp;);
165 
166         enum RoundedRectStrategy {
167             PreferNativeRoundedRect,
168             PreferBezierRoundedRect
169         };
170 
171         WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = PreferNativeRoundedRect);
172         WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = PreferNativeRoundedRect);
173         void addRoundedRect(const RoundedRect&amp;);
174 
175         void addPath(const Path&amp;, const AffineTransform&amp;);
176 
177         void translate(const FloatSize&amp;);
178 
179         // To keep Path() cheap, it does not allocate a PlatformPath immediately
180         // meaning Path::platformPath() can return null.
181 #if USE(DIRECT2D)
182         PlatformPathPtr platformPath() const { return m_path.get(); }
183 #else
184         PlatformPathPtr platformPath() const { return m_path; }
185 #endif
186         // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.
187         WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();
188 
189         WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;
190         void transform(const AffineTransform&amp;);
191 
192         static float circleControlPoint()
193         {
194             // Approximation of control point positions on a bezier to simulate a quarter of a circle.
195             // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3
196             return 0.447715;
197         }
198 
199         void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);
200 
201 #if USE(CG) || USE(DIRECT2D)
202         void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);
203 #endif
204 
205 #if USE(DIRECT2D)
206         ID2D1GeometrySink* activePath() const { return m_activePath.get(); }
207         void appendGeometry(ID2D1Geometry*);
208         void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;
209         void drawDidComplete();
210 
211         HRESULT initializePathState();
212         void openFigureAtCurrentPointIfNecessary();
213         void closeAnyOpenGeometries();
214 #endif
215 
216 #ifndef NDEBUG
217         void dump() const;
218 #endif
219 
220     private:
221 #if USE(DIRECT2D)
222         COMPtr&lt;ID2D1GeometryGroup&gt; m_path;
223         COMPtr&lt;ID2D1PathGeometry&gt; m_activePathGeometry;
224         COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;
225         size_t m_openFigureCount { 0 };
226 #else
227         PlatformPathPtr m_path { nullptr };
228 #endif
229     };
230 
231 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
232 
233 }
234 
235 #endif
    </pre>
  </body>
</html>
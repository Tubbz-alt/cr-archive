<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  5  * Copyright (C) 2011 Dirk Schulze &lt;krit@webkit.org&gt;
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;RenderSVGResourceClipper.h&quot;
 25 
 26 #include &quot;ElementIterator.h&quot;
 27 #include &quot;Frame.h&quot;
 28 #include &quot;FrameView.h&quot;
 29 #include &quot;HitTestRequest.h&quot;
 30 #include &quot;HitTestResult.h&quot;
 31 #include &quot;IntRect.h&quot;
 32 #include &quot;RenderObject.h&quot;
 33 #include &quot;RenderStyle.h&quot;
 34 #include &quot;RenderView.h&quot;
 35 #include &quot;SVGNames.h&quot;
 36 #include &quot;SVGRenderingContext.h&quot;
 37 #include &quot;SVGResources.h&quot;
 38 #include &quot;SVGResourcesCache.h&quot;
 39 #include &quot;SVGUseElement.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGResourceClipper);
 45 
 46 RenderSVGResourceClipper::RenderSVGResourceClipper(SVGClipPathElement&amp; element, RenderStyle&amp;&amp; style)
 47     : RenderSVGResourceContainer(element, WTFMove(style))
 48 {
 49 }
 50 
 51 RenderSVGResourceClipper::~RenderSVGResourceClipper() = default;
 52 
 53 void RenderSVGResourceClipper::removeAllClientsFromCache(bool markForInvalidation)
 54 {
 55     m_clipBoundaries = FloatRect();
 56     m_clipper.clear();
 57 
 58     markAllClientsForInvalidation(markForInvalidation ? LayoutAndBoundariesInvalidation : ParentOnlyInvalidation);
 59 }
 60 
 61 void RenderSVGResourceClipper::removeClientFromCache(RenderElement&amp; client, bool markForInvalidation)
 62 {
 63     m_clipper.remove(&amp;client);
 64 
 65     markClientForInvalidation(client, markForInvalidation ? BoundariesInvalidation : ParentOnlyInvalidation);
 66 }
 67 
 68 bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
 69 {
 70     ASSERT(context);
 71     ASSERT_UNUSED(resourceMode, !resourceMode);
 72 
 73     return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);
 74 }
 75 
 76 bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
 77 {
 78     // If the current clip-path gets clipped itself, we have to fallback to masking.
<a name="1" id="anc1"></a><span class="line-modified"> 79     if (!style().svgStyle().clipperResource().isEmpty())</span>
 80         return false;
 81     WindRule clipRule = WindRule::NonZero;
 82     Path clipPath = Path();
 83 
 84     // If clip-path only contains one visible shape or path, we can use path-based clipping. Invisible
 85     // shapes don&#39;t affect the clipping and can be ignored. If clip-path contains more than one
 86     // visible shape, the additive clipping may not work, caused by the clipRule. EvenOdd
 87     // as well as NonZero can cause self-clipping of the elements.
 88     // See also http://www.w3.org/TR/SVG/painting.html#FillRuleProperty
 89     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
 90         RenderObject* renderer = childNode-&gt;renderer();
 91         if (!renderer)
 92             continue;
 93         // Only shapes or paths are supported for direct clipping. We need to fallback to masking for texts.
 94         if (renderer-&gt;isSVGText())
 95             return false;
 96         if (!childNode-&gt;isSVGElement() || !downcast&lt;SVGElement&gt;(*childNode).isSVGGraphicsElement())
 97             continue;
 98         SVGGraphicsElement&amp; styled = downcast&lt;SVGGraphicsElement&gt;(*childNode);
 99         const RenderStyle&amp; style = renderer-&gt;style();
100         if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
101              continue;
102         const SVGRenderStyle&amp; svgStyle = style.svgStyle();
103         // Current shape in clip-path gets clipped too. Fallback to masking.
<a name="2" id="anc2"></a><span class="line-modified">104         if (!svgStyle.clipperResource().isEmpty())</span>
105             return false;
106         // Fallback to masking, if there is more than one clipping path.
107         if (clipPath.isEmpty()) {
108             clipPath = styled.toClipPath();
109             clipRule = svgStyle.clipRule();
110         } else
111             return false;
112     }
113     // Only one visible shape/path was found. Directly continue clipping and transform the content to userspace if necessary.
114     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
115         AffineTransform transform;
116         transform.translate(objectBoundingBox.location());
117         transform.scale(objectBoundingBox.size());
118         clipPath.transform(transform);
119     }
120 
121     // Transform path by animatedLocalTransform.
122     clipPath.transform(animatedLocalTransform);
123 
124     // The SVG specification wants us to clip everything, if clip-path doesn&#39;t have a child.
125     if (clipPath.isEmpty())
126         clipPath.addRect(FloatRect());
127     context.clipPath(clipPath, clipRule);
128     return true;
129 }
130 
131 bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, const FloatRect&amp; repaintRect, GraphicsContext&amp; context)
132 {
133     ClipperMaskImage&amp; clipperMaskImage = addRendererToClipper(renderer);
134     bool shouldCreateClipperMaskImage = !clipperMaskImage;
135 
136     AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
137 
138     if (shouldCreateClipperMaskImage &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))
139         return true;
140 
141     AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
142 
143     if (shouldCreateClipperMaskImage &amp;&amp; !repaintRect.isEmpty()) {
144         // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<a name="3" id="anc3"></a><span class="line-modified">145         clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpaceSRGB, Unaccelerated, &amp;context);</span>
146         if (!clipperMaskImage)
147             return false;
148 
149         GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();
150         maskContext.concatCTM(animatedLocalTransform);
151 
152         // clipPath can also be clipped by another clipPath.
153         auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
154         RenderSVGResourceClipper* clipper;
155         bool succeeded;
156         if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
157             GraphicsContextStateSaver stateSaver(maskContext);
158 
159             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))
160                 return false;
161 
162             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
163             // The context restore applies the clipping on non-CG platforms.
164         } else
165             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
166 
167         if (!succeeded)
168             clipperMaskImage.reset();
169     }
170 
171     if (!clipperMaskImage)
172         return false;
173 
174     SVGRenderingContext::clipToImageBuffer(context, absoluteTransform, repaintRect, clipperMaskImage, shouldCreateClipperMaskImage);
175     return true;
176 }
177 
178 bool RenderSVGResourceClipper::drawContentIntoMaskImage(const ClipperMaskImage&amp; clipperMaskImage, const FloatRect&amp; objectBoundingBox)
179 {
180     ASSERT(clipperMaskImage);
181 
182     GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();
183 
184     AffineTransform maskContentTransformation;
185     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
186         maskContentTransformation.translate(objectBoundingBox.location());
187         maskContentTransformation.scale(objectBoundingBox.size());
188         maskContext.concatCTM(maskContentTransformation);
189     }
190 
191     // Switch to a paint behavior where all children of this &lt;clipPath&gt; will be rendered using special constraints:
192     // - fill-opacity/stroke-opacity/opacity set to 1
193     // - masker/filter not applied when rendering the children
194     // - fill is set to the initial fill paint server (solid, black)
195     // - stroke is set to the initial stroke paint server (none)
196     auto oldBehavior = view().frameView().paintBehavior();
197     view().frameView().setPaintBehavior(oldBehavior | PaintBehavior::RenderingSVGMask);
198 
199     // Draw all clipPath children into a global mask.
200     for (auto&amp; child : childrenOfType&lt;SVGElement&gt;(clipPathElement())) {
201         auto renderer = child.renderer();
202         if (!renderer)
203             continue;
204         if (renderer-&gt;needsLayout()) {
205             view().frameView().setPaintBehavior(oldBehavior);
206             return false;
207         }
208         const RenderStyle&amp; style = renderer-&gt;style();
209         if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
210             continue;
211 
212         WindRule newClipRule = style.svgStyle().clipRule();
213         bool isUseElement = child.hasTagName(SVGNames::useTag);
214         if (isUseElement) {
215             SVGUseElement&amp; useElement = downcast&lt;SVGUseElement&gt;(child);
216             renderer = useElement.rendererClipChild();
217             if (!renderer)
218                 continue;
219             if (!useElement.hasAttributeWithoutSynchronization(SVGNames::clip_ruleAttr))
220                 newClipRule = renderer-&gt;style().svgStyle().clipRule();
221         }
222 
223         // Only shapes, paths and texts are allowed for clipping.
224         if (!renderer-&gt;isSVGShape() &amp;&amp; !renderer-&gt;isSVGText())
225             continue;
226 
227         maskContext.setFillRule(newClipRule);
228 
229         // In the case of a &lt;use&gt; element, we obtained its renderere above, to retrieve its clipRule.
230         // We have to pass the &lt;use&gt; renderer itself to renderSubtreeToImageBuffer() to apply it&#39;s x/y/transform/etc. values when rendering.
231         // So if isUseElement is true, refetch the childNode-&gt;renderer(), as renderer got overridden above.
232         SVGRenderingContext::renderSubtreeToImageBuffer(clipperMaskImage.get(), isUseElement ? *child.renderer() : *renderer, maskContentTransformation);
233     }
234 
235     view().frameView().setPaintBehavior(oldBehavior);
236     return true;
237 }
238 
239 void RenderSVGResourceClipper::calculateClipContentRepaintRect()
240 {
241     // This is a rough heuristic to appraise the clip size and doesn&#39;t consider clip on clip.
242     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
243         RenderObject* renderer = childNode-&gt;renderer();
244         if (!childNode-&gt;isSVGElement() || !renderer)
245             continue;
246         if (!renderer-&gt;isSVGShape() &amp;&amp; !renderer-&gt;isSVGText() &amp;&amp; !childNode-&gt;hasTagName(SVGNames::useTag))
247             continue;
248         const RenderStyle&amp; style = renderer-&gt;style();
249         if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
250              continue;
251         m_clipBoundaries.unite(renderer-&gt;localToParentTransform().mapRect(renderer-&gt;repaintRectInLocalCoordinates()));
252     }
253     m_clipBoundaries = clipPathElement().animatedLocalTransform().mapRect(m_clipBoundaries);
254 }
255 
256 ClipperMaskImage&amp; RenderSVGResourceClipper::addRendererToClipper(const RenderObject&amp; object)
257 {
258     return m_clipper.add(&amp;object, ClipperMaskImage()).iterator-&gt;value;
259 }
260 
261 bool RenderSVGResourceClipper::hitTestClipContent(const FloatRect&amp; objectBoundingBox, const FloatPoint&amp; nodeAtPoint)
262 {
263     FloatPoint point = nodeAtPoint;
264     if (!SVGRenderSupport::pointInClippingArea(*this, point))
265         return false;
266 
267     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
268         AffineTransform transform;
269         transform.translate(objectBoundingBox.location());
270         transform.scale(objectBoundingBox.size());
271         point = transform.inverse().valueOr(AffineTransform()).mapPoint(point);
272     }
273 
274     point = clipPathElement().animatedLocalTransform().inverse().valueOr(AffineTransform()).mapPoint(point);
275 
276     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
277         RenderObject* renderer = childNode-&gt;renderer();
278         if (!childNode-&gt;isSVGElement() || !renderer)
279             continue;
280         if (!renderer-&gt;isSVGShape() &amp;&amp; !renderer-&gt;isSVGText() &amp;&amp; !childNode-&gt;hasTagName(SVGNames::useTag))
281             continue;
<a name="4" id="anc4"></a>









282         IntPoint hitPoint;
283         HitTestResult result(hitPoint);
284         if (renderer-&gt;nodeAtFloatPoint(HitTestRequest(HitTestRequest::SVGClipContent | HitTestRequest::DisallowUserAgentShadowContent), result, point, HitTestForeground))
285             return true;
286     }
287 
288     return false;
289 }
290 
291 FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
292 {
293     // Resource was not layouted yet. Give back the boundingBox of the object.
294     if (selfNeedsLayout()) {
295         addRendererToClipper(object);
296         return object.objectBoundingBox();
297     }
298 
299     if (m_clipBoundaries.isEmpty())
300         calculateClipContentRepaintRect();
301 
302     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
303         FloatRect objectBoundingBox = object.objectBoundingBox();
304         AffineTransform transform;
305         transform.translate(objectBoundingBox.location());
306         transform.scale(objectBoundingBox.size());
307         return transform.mapRect(m_clipBoundaries);
308     }
309 
310     return m_clipBoundaries;
311 }
312 
313 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
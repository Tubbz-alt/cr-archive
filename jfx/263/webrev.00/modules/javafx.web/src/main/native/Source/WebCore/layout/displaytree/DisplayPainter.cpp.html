<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayPainter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DisplayPainter.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;CachedImage.h&quot;
 32 #include &quot;Color.h&quot;
 33 #include &quot;DisplayBox.h&quot;
 34 #include &quot;GraphicsContext.h&quot;
 35 #include &quot;InlineFormattingState.h&quot;
 36 #include &quot;InlineTextItem.h&quot;
 37 #include &quot;IntRect.h&quot;
 38 #include &quot;LayoutContainer.h&quot;
 39 #include &quot;LayoutDescendantIterator.h&quot;
 40 #include &quot;LayoutState.h&quot;
 41 #include &quot;RenderStyle.h&quot;
 42 #include &quot;TextRun.h&quot;
 43 
 44 namespace WebCore {
 45 namespace Display {
 46 
 47 static void paintBoxDecoration(GraphicsContext&amp; context, const Box&amp; absoluteDisplayBox, const RenderStyle&amp; style, bool needsMarginPainting)
 48 {
 49     auto decorationBoxTopLeft = needsMarginPainting ? absoluteDisplayBox.rectWithMargin().topLeft() : absoluteDisplayBox.topLeft();
 50     auto decorationBoxSize = needsMarginPainting ? absoluteDisplayBox.rectWithMargin().size() : LayoutSize(absoluteDisplayBox.borderBoxWidth(), absoluteDisplayBox.borderBoxHeight());
 51     // Background color
 52     if (style.hasBackground()) {
 53         context.fillRect({ decorationBoxTopLeft, decorationBoxSize }, style.backgroundColor());
 54         if (style.hasBackgroundImage()) {
 55             auto&amp; backgroundLayer = style.backgroundLayers();
 56             if (backgroundLayer.image() &amp;&amp; backgroundLayer.image()-&gt;cachedImage() &amp;&amp; backgroundLayer.image()-&gt;cachedImage()-&gt;image())
 57                 context.drawImage(*backgroundLayer.image()-&gt;cachedImage()-&gt;image(), { decorationBoxTopLeft, backgroundLayer.image()-&gt;cachedImage()-&gt;image()-&gt;size() });
 58         }
 59     }
 60 
 61     // Border
 62     if (style.hasVisibleBorder()) {
 63 
 64         auto drawBorderSide = [&amp;](auto start, auto end, const auto&amp; borderStyle) {
 65             if (!borderStyle.width())
 66                 return;
 67             if (borderStyle.style() == BorderStyle::None || borderStyle.style() == BorderStyle::Hidden)
 68                 return;
 69             context.setStrokeColor(borderStyle.color());
 70             context.setStrokeThickness(borderStyle.width());
 71             context.drawLine(start, end);
 72         };
 73 
 74         context.setFillColor(Color::transparent);
 75 
 76         auto decorationBoxWidth = decorationBoxSize.width();
 77         auto decorationBoxHeight = decorationBoxSize.height();
 78 
 79         // Top
 80         {
 81             auto borderWidth = style.borderTop().width();
 82             auto start = LayoutPoint { decorationBoxTopLeft };
 83             auto end = LayoutPoint { start.x() + decorationBoxWidth, start.y() + borderWidth };
 84             drawBorderSide(start, end, style.borderTop());
 85         }
 86 
 87         // Right
 88         {
 89             auto borderWidth = style.borderRight().width();
 90             auto start = LayoutPoint { decorationBoxTopLeft.x() + decorationBoxWidth - borderWidth, decorationBoxTopLeft.y() };
 91             auto end = LayoutPoint { start.x() + borderWidth, decorationBoxTopLeft.y() + decorationBoxHeight };
 92             drawBorderSide(start, end, style.borderRight());
 93         }
 94 
 95         // Bottom
 96         {
 97             auto borderWidth = style.borderBottom().width();
 98             auto start = LayoutPoint { decorationBoxTopLeft.x(), decorationBoxTopLeft.y() + decorationBoxHeight - borderWidth };
 99             auto end = LayoutPoint { start.x() + decorationBoxWidth, start.y() + borderWidth };
100             drawBorderSide(start, end, style.borderBottom());
101         }
102 
103         // Left
104         {
105             auto borderWidth = style.borderLeft().width();
106             auto start = decorationBoxTopLeft;
107             auto end = LayoutPoint { start.x() + borderWidth, decorationBoxTopLeft.y() + decorationBoxHeight };
108             drawBorderSide(start, end, style.borderLeft());
109         }
110     }
111 }
112 
113 static void paintInlineContent(GraphicsContext&amp; context, LayoutPoint absoluteOffset, const Layout::InlineFormattingState&amp; formattingState)
114 {
115     auto* displayInlineContent = formattingState.displayInlineContent();
116     if (!displayInlineContent)
117         return;
118 
119     auto&amp; displayRuns = displayInlineContent-&gt;runs;
120     if (displayRuns.isEmpty())
121         return;
122 
123     for (auto&amp; run : displayRuns) {
124         if (auto&amp; textContext = run.textContext()) {
125             auto&amp; style = run.style();
126             context.setStrokeColor(style.color());
127             context.setFillColor(style.color());
128 
129             auto absoluteLeft = absoluteOffset.x() + run.left();
130             // FIXME: Add non-baseline align painting
131             auto&amp; lineBox = displayInlineContent-&gt;lineBoxForRun(run);
132             auto baselineOffset = absoluteOffset.y() + lineBox.top() + lineBox.baselineOffset();
133             auto expansionContext = textContext-&gt;expansion();
134             auto textRun = TextRun { textContext-&gt;content(), run.left() - lineBox.left(),
135                 expansionContext ? expansionContext-&gt;horizontalExpansion : 0,
136                 expansionContext ? expansionContext-&gt;behavior : DefaultExpansion };
137             textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
138             context.drawText(style.fontCascade(), textRun, { absoluteLeft, baselineOffset });
139         } else if (auto* cachedImage = run.image()) {
140             auto runAbsoluteRect = FloatRect { absoluteOffset.x() + run.left(), absoluteOffset.y() + run.top(), run.width(), run.height() };
141             context.drawImage(*cachedImage-&gt;image(), runAbsoluteRect);
142         }
143     }
144 }
145 
146 static Box absoluteDisplayBox(const Layout::LayoutState&amp; layoutState, const Layout::Box&amp; layoutBox)
147 {
148     // Should never really happen but table code is way too incomplete.
149     if (!layoutState.hasDisplayBox(layoutBox))
150         return { };
151     if (layoutBox.isInitialContainingBlock())
152         return layoutState.displayBoxForLayoutBox(layoutBox);
153 
154     auto absoluteBox = Box { layoutState.displayBoxForLayoutBox(layoutBox) };
155     for (auto* container = layoutBox.containingBlock(); container != &amp;layoutBox.initialContainingBlock(); container = container-&gt;containingBlock())
156         absoluteBox.moveBy(layoutState.displayBoxForLayoutBox(*container).topLeft());
157     return absoluteBox;
158 }
159 
160 static bool isPaintRootCandidate(const Layout::Box&amp; layoutBox)
161 {
162     return layoutBox.isPositioned();
163 }
164 
165 using LayoutBoxList = Vector&lt;const Layout::Box*&gt;;
166 
167 enum PaintPhase { Decoration, Content };
168 static void paintSubtree(GraphicsContext&amp; context, const Layout::LayoutState&amp; layoutState, const Layout::Box&amp; paintRootBox, const IntRect&amp; dirtyRect, PaintPhase paintPhase)
169 {
170     auto paint = [&amp;] (auto&amp; layoutBox) {
171         if (layoutBox.style().visibility() != Visibility::Visible)
172             return;
173         auto absoluteDisplayBox = Display::absoluteDisplayBox(layoutState, layoutBox);
174         if (!dirtyRect.intersects(snappedIntRect(absoluteDisplayBox.rect())))
175             return;
176 
177         if (paintPhase == PaintPhase::Decoration) {
178             if (layoutBox.isAnonymous())
179                 return;
180             paintBoxDecoration(context, absoluteDisplayBox, layoutBox.style(), layoutBox.isBodyBox());
181             return;
182         }
183         // Only inline content for now.
184         if (layoutBox.establishesInlineFormattingContext()) {
185             auto&amp; container = downcast&lt;Layout::Container&gt;(layoutBox);
186             paintInlineContent(context, absoluteDisplayBox.topLeft(), layoutState.establishedInlineFormattingState(container));
187         }
188     };
189 
190     paint(paintRootBox);
191     if (!is&lt;Layout::Container&gt;(paintRootBox) || !downcast&lt;Layout::Container&gt;(paintRootBox).hasChild())
192         return;
193 
194     LayoutBoxList layoutBoxList;
195     layoutBoxList.append(downcast&lt;Layout::Container&gt;(paintRootBox).firstChild());
196     while (!layoutBoxList.isEmpty()) {
197         while (true) {
198             auto&amp; layoutBox = *layoutBoxList.last();
199             if (isPaintRootCandidate(layoutBox))
200                 break;
201             paint(layoutBox);
202             if (!is&lt;Layout::Container&gt;(layoutBox) || !downcast&lt;Layout::Container&gt;(layoutBox).hasChild())
203                 break;
204             layoutBoxList.append(downcast&lt;Layout::Container&gt;(layoutBox).firstChild());
205         }
206         while (!layoutBoxList.isEmpty()) {
207             auto&amp; layoutBox = *layoutBoxList.takeLast();
208             // Stay within.
209             if (&amp;layoutBox == &amp;paintRootBox)
210                 return;
211             if (auto* nextSibling = layoutBox.nextSibling()) {
212                 layoutBoxList.append(nextSibling);
213                 break;
214             }
215         }
216     }
217 }
218 
219 static LayoutRect collectPaintRootsAndContentRect(const Layout::LayoutState&amp; layoutState, const Layout::Box&amp; rootLayoutBox, LayoutBoxList&amp; positiveZOrderList, LayoutBoxList&amp; negativeZOrderList)
220 {
221     auto appendPaintRoot = [&amp;] (const auto&amp; layoutBox) {
222         if (layoutBox.style().usedZIndex() &lt; 0) {
223             negativeZOrderList.append(&amp;layoutBox);
224             return;
225         }
226         positiveZOrderList.append(&amp;layoutBox);
227     };
228 
229     auto contentRect = LayoutRect { layoutState.displayBoxForLayoutBox(rootLayoutBox).rect() };
230 
231     // Initial BFC is always a paint root.
232     appendPaintRoot(rootLayoutBox);
233     LayoutBoxList layoutBoxList;
234     layoutBoxList.append(&amp;rootLayoutBox);
235     while (!layoutBoxList.isEmpty()) {
236         while (true) {
237             auto&amp; layoutBox = *layoutBoxList.last();
238             if (layoutBox.style().visibility() != Visibility::Visible)
239                 break;
240             if (isPaintRootCandidate(layoutBox))
241                 appendPaintRoot(layoutBox);
242             contentRect.uniteIfNonZero(Display::absoluteDisplayBox(layoutState, layoutBox).rect());
243             if (!is&lt;Layout::Container&gt;(layoutBox) || !downcast&lt;Layout::Container&gt;(layoutBox).hasChild())
244                 break;
245             layoutBoxList.append(downcast&lt;Layout::Container&gt;(layoutBox).firstChild());
246         }
247         while (!layoutBoxList.isEmpty()) {
248             auto&amp; layoutBox = *layoutBoxList.takeLast();
249             if (auto* nextSibling = layoutBox.nextSibling()) {
250                 layoutBoxList.append(nextSibling);
251                 break;
252             }
253         }
254     }
255 
256     auto compareZIndex = [] (const Layout::Box* a, const Layout::Box* b) {
257         return a-&gt;style().usedZIndex() &lt; b-&gt;style().usedZIndex();
258     };
259 
260     std::stable_sort(positiveZOrderList.begin(), positiveZOrderList.end(), compareZIndex);
261     std::stable_sort(negativeZOrderList.begin(), negativeZOrderList.end(), compareZIndex);
262     return contentRect;
263 }
264 
265 void Painter::paint(const Layout::LayoutState&amp; layoutState, GraphicsContext&amp; context, const IntRect&amp; dirtyRect)
266 {
267     auto&amp; rootLayoutBox = layoutState.root();
268     if (!rootLayoutBox.firstChild())
269         return;
270 
271     Vector&lt;const Layout::Box*&gt; negativeZOrderList;
272     Vector&lt;const Layout::Box*&gt; positiveZOrderList;
273     auto contentRect = collectPaintRootsAndContentRect(layoutState, rootLayoutBox, positiveZOrderList, negativeZOrderList);
274 
275     // Fill the entire content area.
276     context.fillRect(contentRect, Color::white);
277 
278     for (auto&amp; paintRootBox : negativeZOrderList) {
279         paintSubtree(context, layoutState, *paintRootBox, dirtyRect, PaintPhase::Decoration);
280         paintSubtree(context, layoutState, *paintRootBox, dirtyRect, PaintPhase::Content);
281     }
282 
283     for (auto&amp; paintRootBox : positiveZOrderList) {
284         paintSubtree(context, layoutState, *paintRootBox, dirtyRect, PaintPhase::Decoration);
285         paintSubtree(context, layoutState, *paintRootBox, dirtyRect, PaintPhase::Content);
286     }
287 }
288 
289 void Painter::paintInlineFlow(const Layout::LayoutState&amp; layoutState, GraphicsContext&amp; context)
290 {
291     auto&amp; layoutRoot = layoutState.root();
292 
293     ASSERT(layoutRoot.establishesInlineFormattingContext());
294 
295     paintInlineContent(context, { }, layoutState.establishedInlineFormattingState(layoutRoot));
296 }
297 
298 }
299 }
300 
301 #endif
    </pre>
  </body>
</html>
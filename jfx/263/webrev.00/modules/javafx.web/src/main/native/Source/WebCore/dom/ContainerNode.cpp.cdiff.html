<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompositionEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContainerNodeAlgorithms.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
  #include &quot;RenderBox.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RenderTreeUpdater.h&quot;
  #include &quot;RenderWidget.h&quot;
  #include &quot;RootInlineBox.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;SVGDocumentExtensions.h&quot;
  #include &quot;SVGElement.h&quot;
  #include &quot;SVGNames.h&quot;
  #include &quot;SVGUseElement.h&quot;
  #include &quot;ScriptDisallowedScope.h&quot;
<span class="line-new-header">--- 50,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,11 ***</span>
  static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp;);
  
  ChildNodesLazySnapshot* ChildNodesLazySnapshot::latestSnapshot;
  
  unsigned ScriptDisallowedScope::s_count = 0;
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  ScriptDisallowedScope::EventAllowedScope* ScriptDisallowedScope::EventAllowedScope::s_currentScope = nullptr;
  #endif
  
  ALWAYS_INLINE NodeVector ContainerNode::removeAllChildrenWithScriptAssertion(ChildChangeSource source, DeferChildrenChanged deferChildrenChanged)
  {
<span class="line-new-header">--- 72,11 ---</span>
  static void dispatchChildRemovalEvents(Ref&lt;Node&gt;&amp;);
  
  ChildNodesLazySnapshot* ChildNodesLazySnapshot::latestSnapshot;
  
  unsigned ScriptDisallowedScope::s_count = 0;
<span class="line-modified">! #if ASSERT_ENABLED</span>
  ScriptDisallowedScope::EventAllowedScope* ScriptDisallowedScope::EventAllowedScope::s_currentScope = nullptr;
  #endif
  
  ALWAYS_INLINE NodeVector ContainerNode::removeAllChildrenWithScriptAssertion(ChildChangeSource source, DeferChildrenChanged deferChildrenChanged)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,30 ***</span>
      } while (currentNode);
  
      return false;
  }
  
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; checkAcceptChild(ContainerNode&amp; newParent, Node&amp; newChild, const Node* refChild, Document::AcceptChildOperation operation)</span>
  {
      if (containsIncludingHostElements(newChild, newParent))
          return Exception { HierarchyRequestError };
  
      // Use common case fast path if possible.
      if ((newChild.isElementNode() || newChild.isTextNode()) &amp;&amp; newParent.isElementNode()) {
          ASSERT(!newParent.isDocumentTypeNode());
          ASSERT(isChildTypeAllowed(newParent, newChild));
<span class="line-modified">!         if (operation == Document::AcceptChildOperation::InsertOrAdd &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
              return Exception { NotFoundError };
          return { };
      }
  
      // This should never happen, but also protect release builds from tree corruption.
      ASSERT(!newChild.isPseudoElement());
      if (newChild.isPseudoElement())
          return Exception { HierarchyRequestError };
  
<span class="line-modified">!     if (operation == Document::AcceptChildOperation::InsertOrAdd &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
          return Exception { NotFoundError };
  
      if (is&lt;Document&gt;(newParent)) {
          if (!downcast&lt;Document&gt;(newParent).canAcceptChild(newChild, refChild, operation))
              return Exception { HierarchyRequestError };
<span class="line-new-header">--- 308,31 ---</span>
      } while (currentNode);
  
      return false;
  }
  
<span class="line-modified">! enum class ShouldValidateChildParent { No, Yes };</span>
<span class="line-added">+ static inline ExceptionOr&lt;void&gt; checkAcceptChild(ContainerNode&amp; newParent, Node&amp; newChild, const Node* refChild, Document::AcceptChildOperation operation, ShouldValidateChildParent shouldValidateChildParent)</span>
  {
      if (containsIncludingHostElements(newChild, newParent))
          return Exception { HierarchyRequestError };
  
      // Use common case fast path if possible.
      if ((newChild.isElementNode() || newChild.isTextNode()) &amp;&amp; newParent.isElementNode()) {
          ASSERT(!newParent.isDocumentTypeNode());
          ASSERT(isChildTypeAllowed(newParent, newChild));
<span class="line-modified">!         if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
              return Exception { NotFoundError };
          return { };
      }
  
      // This should never happen, but also protect release builds from tree corruption.
      ASSERT(!newChild.isPseudoElement());
      if (newChild.isPseudoElement())
          return Exception { HierarchyRequestError };
  
<span class="line-modified">!     if (shouldValidateChildParent == ShouldValidateChildParent::Yes &amp;&amp; refChild &amp;&amp; refChild-&gt;parentNode() != &amp;newParent)</span>
          return Exception { NotFoundError };
  
      if (is&lt;Document&gt;(newParent)) {
          if (!downcast&lt;Document&gt;(newParent).canAcceptChild(newChild, refChild, operation))
              return Exception { HierarchyRequestError };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 352,17 ***</span>
  }
  
  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  ExceptionOr&lt;void&gt; ContainerNode::ensurePreInsertionValidity(Node&amp; newChild, Node* refChild)
  {
<span class="line-modified">!     return checkAcceptChild(*this, newChild, refChild, Document::AcceptChildOperation::InsertOrAdd);</span>
  }
  
  // https://dom.spec.whatwg.org/#concept-node-replace
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; checkPreReplacementValidity(ContainerNode&amp; newParent, Node&amp; newChild, Node&amp; oldChild)</span>
  {
<span class="line-modified">!     return checkAcceptChild(newParent, newChild, &amp;oldChild, Document::AcceptChildOperation::Replace);</span>
  }
  
  ExceptionOr&lt;void&gt; ContainerNode::insertBefore(Node&amp; newChild, Node* refChild)
  {
      // Check that this node is not &quot;floating&quot;.
<span class="line-new-header">--- 352,17 ---</span>
  }
  
  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  ExceptionOr&lt;void&gt; ContainerNode::ensurePreInsertionValidity(Node&amp; newChild, Node* refChild)
  {
<span class="line-modified">!     return checkAcceptChild(*this, newChild, refChild, Document::AcceptChildOperation::InsertOrAdd, ShouldValidateChildParent::Yes);</span>
  }
  
  // https://dom.spec.whatwg.org/#concept-node-replace
<span class="line-modified">! static inline ExceptionOr&lt;void&gt; checkPreReplacementValidity(ContainerNode&amp; newParent, Node&amp; newChild, Node&amp; oldChild, ShouldValidateChildParent shouldValidateChildParent)</span>
  {
<span class="line-modified">!     return checkAcceptChild(newParent, newChild, &amp;oldChild, Document::AcceptChildOperation::Replace, shouldValidateChildParent);</span>
  }
  
  ExceptionOr&lt;void&gt; ContainerNode::insertBefore(Node&amp; newChild, Node* refChild)
  {
      // Check that this node is not &quot;floating&quot;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,18 ***</span>
      ASSERT(refCount() || parentOrShadowHostNode());
  
      Ref&lt;ContainerNode&gt; protectedThis(*this);
  
      // Make sure replacing the old child with the new is ok
<span class="line-modified">!     auto validityResult = checkPreReplacementValidity(*this, newChild, oldChild);</span>
      if (validityResult.hasException())
          return validityResult.releaseException();
  
<span class="line-removed">-     // NotFoundError: Raised if oldChild is not a child of this node.</span>
<span class="line-removed">-     if (oldChild.parentNode() != this)</span>
<span class="line-removed">-         return Exception { NotFoundError };</span>
<span class="line-removed">- </span>
      RefPtr&lt;Node&gt; refChild = oldChild.nextSibling();
      if (refChild.get() == &amp;newChild)
          refChild = refChild-&gt;nextSibling();
  
      NodeVector targets;
<span class="line-new-header">--- 487,14 ---</span>
      ASSERT(refCount() || parentOrShadowHostNode());
  
      Ref&lt;ContainerNode&gt; protectedThis(*this);
  
      // Make sure replacing the old child with the new is ok
<span class="line-modified">!     auto validityResult = checkPreReplacementValidity(*this, newChild, oldChild, ShouldValidateChildParent::Yes);</span>
      if (validityResult.hasException())
          return validityResult.releaseException();
  
      RefPtr&lt;Node&gt; refChild = oldChild.nextSibling();
      if (refChild.get() == &amp;newChild)
          refChild = refChild-&gt;nextSibling();
  
      NodeVector targets;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,11 ***</span>
              return collectResult.releaseException();
      }
  
      // Do this one more time because collectChildrenAndRemoveFromOldParent() fires a MutationEvent.
      for (auto&amp; child : targets) {
<span class="line-modified">!         validityResult = checkPreReplacementValidity(*this, child, oldChild);</span>
          if (validityResult.hasException())
              return validityResult.releaseException();
      }
  
      // Remove the node we&#39;re replacing.
<span class="line-new-header">--- 505,11 ---</span>
              return collectResult.releaseException();
      }
  
      // Do this one more time because collectChildrenAndRemoveFromOldParent() fires a MutationEvent.
      for (auto&amp; child : targets) {
<span class="line-modified">!         validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
          if (validityResult.hasException())
              return validityResult.releaseException();
      }
  
      // Remove the node we&#39;re replacing.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,11 ***</span>
          if (removeResult.hasException())
              return removeResult.releaseException();
  
          // Does this one more time because removeChild() fires a MutationEvent.
          for (auto&amp; child : targets) {
<span class="line-modified">!             validityResult = checkPreReplacementValidity(*this, child, oldChild);</span>
              if (validityResult.hasException())
                  return validityResult.releaseException();
          }
      }
  
<span class="line-new-header">--- 523,11 ---</span>
          if (removeResult.hasException())
              return removeResult.releaseException();
  
          // Does this one more time because removeChild() fires a MutationEvent.
          for (auto&amp; child : targets) {
<span class="line-modified">!             validityResult = checkPreReplacementValidity(*this, child, oldChild, ShouldValidateChildParent::No);</span>
              if (validityResult.hasException())
                  return validityResult.releaseException();
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,22 ***</span>
      return ensureRareData().ensureNodeLists().addCachedTagCollectionNS(*this, namespaceURI.isEmpty() ? nullAtom() : namespaceURI, localName);
  }
  
  Ref&lt;NodeList&gt; ContainerNode::getElementsByName(const String&amp; elementName)
  {
<span class="line-modified">!     return ensureRareData().ensureNodeLists().addCacheWithAtomicName&lt;NameNodeList&gt;(*this, elementName);</span>
  }
  
  Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByClassName(const AtomString&amp; classNames)
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;ClassCollection&gt;(*this, ByClass, classNames);
  }
  
  Ref&lt;RadioNodeList&gt; ContainerNode::radioNodeList(const AtomString&amp; name)
  {
      ASSERT(hasTagName(HTMLNames::formTag) || hasTagName(HTMLNames::fieldsetTag));
<span class="line-modified">!     return ensureRareData().ensureNodeLists().addCacheWithAtomicName&lt;RadioNodeList&gt;(*this, name);</span>
  }
  
  Ref&lt;HTMLCollection&gt; ContainerNode::children()
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;NodeChildren&gt;::traversalType&gt;&gt;(*this, NodeChildren);
<span class="line-new-header">--- 889,22 ---</span>
      return ensureRareData().ensureNodeLists().addCachedTagCollectionNS(*this, namespaceURI.isEmpty() ? nullAtom() : namespaceURI, localName);
  }
  
  Ref&lt;NodeList&gt; ContainerNode::getElementsByName(const String&amp; elementName)
  {
<span class="line-modified">!     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;NameNodeList&gt;(*this, elementName);</span>
  }
  
  Ref&lt;HTMLCollection&gt; ContainerNode::getElementsByClassName(const AtomString&amp; classNames)
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;ClassCollection&gt;(*this, ByClass, classNames);
  }
  
  Ref&lt;RadioNodeList&gt; ContainerNode::radioNodeList(const AtomString&amp; name)
  {
      ASSERT(hasTagName(HTMLNames::formTag) || hasTagName(HTMLNames::fieldsetTag));
<span class="line-modified">!     return ensureRareData().ensureNodeLists().addCacheWithAtomName&lt;RadioNodeList&gt;(*this, name);</span>
  }
  
  Ref&lt;HTMLCollection&gt; ContainerNode::children()
  {
      return ensureRareData().ensureNodeLists().addCachedCollection&lt;GenericCachedHTMLCollection&lt;CollectionTypeTraits&lt;NodeChildren&gt;::traversalType&gt;&gt;(*this, NodeChildren);
</pre>
<center><a href="CompositionEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ContainerNodeAlgorithms.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
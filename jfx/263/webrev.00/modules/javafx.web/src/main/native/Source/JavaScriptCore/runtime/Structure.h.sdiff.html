<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Structure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureChain.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ClassInfo.h&quot;
 29 #include &quot;ConcurrentJSLock.h&quot;
 30 #include &quot;IndexingType.h&quot;
 31 #include &quot;JSCJSValue.h&quot;
 32 #include &quot;JSCast.h&quot;
 33 #include &quot;JSType.h&quot;

 34 #include &quot;PropertyName.h&quot;
 35 #include &quot;PropertyNameArray.h&quot;
 36 #include &quot;PropertyOffset.h&quot;
 37 #include &quot;PutPropertySlot.h&quot;
 38 #include &quot;StructureIDBlob.h&quot;
 39 #include &quot;StructureRareData.h&quot;
 40 #include &quot;StructureTransitionTable.h&quot;
<span class="line-modified"> 41 #include &quot;JSTypeInfo.h&quot;</span>
 42 #include &quot;Watchpoint.h&quot;
 43 #include &quot;WriteBarrierInlines.h&quot;
 44 #include &lt;wtf/PrintStream.h&gt;
 45 
 46 namespace WTF {
 47 
 48 class UniquedStringImpl;
 49 
 50 } // namespace WTF
 51 
 52 namespace JSC {
 53 
 54 class DeferGC;
 55 class LLIntOffsetsExtractor;
 56 class PropertyNameArray;
 57 class PropertyNameArrayData;
 58 class PropertyTable;
 59 class StructureChain;
 60 class StructureShape;
 61 class SlotVisitor;
 62 class JSString;
 63 struct DumpContext;


 64 
 65 // The out-of-line property storage capacity to use when first allocating out-of-line
 66 // storage. Note that all objects start out without having any out-of-line storage;
 67 // this comes into play only on the first property store that exhausts inline storage.
<span class="line-modified"> 68 static const unsigned initialOutOfLineCapacity = 4;</span>
 69 
 70 // The factor by which to grow out-of-line storage when it is exhausted, after the
 71 // initial allocation.
<span class="line-modified"> 72 static const unsigned outOfLineGrowthFactor = 2;</span>
 73 
 74 struct PropertyMapEntry {
 75     UniquedStringImpl* key;
 76     PropertyOffset offset;
 77     uint8_t attributes;
 78 
 79     PropertyMapEntry()
 80         : key(nullptr)
 81         , offset(invalidOffset)
 82         , attributes(0)
 83     {
 84     }
 85 
 86     PropertyMapEntry(UniquedStringImpl* key, PropertyOffset offset, unsigned attributes)
 87         : key(key)
 88         , offset(offset)
 89         , attributes(attributes)
 90     {
 91         ASSERT(this-&gt;attributes == attributes);
 92     }
</pre>
<hr />
<pre>
103 
104 private:
105     const Structure* m_structure;
106 };
107 
108 class DeferredStructureTransitionWatchpointFire : public DeferredWatchpointFire {
109     WTF_MAKE_NONCOPYABLE(DeferredStructureTransitionWatchpointFire);
110 public:
111     JS_EXPORT_PRIVATE DeferredStructureTransitionWatchpointFire(VM&amp;, Structure*);
112     JS_EXPORT_PRIVATE ~DeferredStructureTransitionWatchpointFire();
113 
114     void dump(PrintStream&amp; out) const override;
115 
116     const Structure* structure() const { return m_structure; }
117 
118 private:
119     const Structure* m_structure;
120 };
121 
122 class Structure final : public JSCell {


123 public:
124     friend class StructureTransitionTable;
125 
126     typedef JSCell Base;
<span class="line-modified">127     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
128 
129     enum PolyProtoTag { PolyProto };
130     static Structure* create(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
131     static Structure* create(PolyProtoTag, VM&amp;, JSGlobalObject*, JSObject* prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
132 
133     ~Structure();
134 
135     template&lt;typename CellType, SubspaceAccess&gt;
136     static IsoSubspace* subspaceFor(VM&amp; vm)
137     {
138         return &amp;vm.structureSpace;
139     }
140 
141     JS_EXPORT_PRIVATE static bool isValidPrototype(JSValue);
142 
143 protected:
144     void finishCreation(VM&amp; vm)
145     {
146         Base::finishCreation(vm);
147         ASSERT(m_prototype.get().isEmpty() || isValidPrototype(m_prototype.get()));
</pre>
<hr />
<pre>
167         ASSERT(!vm.structureStructure);
168     }
169 
170 public:
171     StructureID id() const { return m_blob.structureID(); }
172     int32_t objectInitializationBlob() const { return m_blob.blobExcludingStructureID(); }
173     int64_t idBlob() const { return m_blob.blob(); }
174 
175     bool isProxy() const
176     {
177         JSType type = m_blob.type();
178         return type == ImpureProxyType || type == PureForwardingProxyType || type == ProxyObjectType;
179     }
180 
181     static void dumpStatistics();
182 
183     JS_EXPORT_PRIVATE static Structure* addPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
184     JS_EXPORT_PRIVATE static Structure* addNewPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;, PutPropertySlot::Context = PutPropertySlot::UnknownContext, DeferredStructureTransitionWatchpointFire* = nullptr);
185     static Structure* addPropertyTransitionToExistingStructureConcurrently(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
186     JS_EXPORT_PRIVATE static Structure* addPropertyTransitionToExistingStructure(Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
<span class="line-modified">187     static Structure* removePropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;);</span>


188     static Structure* changePrototypeTransition(VM&amp;, Structure*, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp;);
189     JS_EXPORT_PRIVATE static Structure* attributeChangeTransition(VM&amp;, Structure*, PropertyName, unsigned attributes);
190     JS_EXPORT_PRIVATE static Structure* toCacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
<span class="line-modified">191     static Structure* toUncacheableDictionaryTransition(VM&amp;, Structure*);</span>
192     JS_EXPORT_PRIVATE static Structure* sealTransition(VM&amp;, Structure*);
193     JS_EXPORT_PRIVATE static Structure* freezeTransition(VM&amp;, Structure*);
194     static Structure* preventExtensionsTransition(VM&amp;, Structure*);
195     static Structure* nonPropertyTransition(VM&amp;, Structure*, NonPropertyTransition);
196     JS_EXPORT_PRIVATE static Structure* nonPropertyTransitionSlow(VM&amp;, Structure*, NonPropertyTransition);
197 
198     JS_EXPORT_PRIVATE bool isSealed(VM&amp;);
199     JS_EXPORT_PRIVATE bool isFrozen(VM&amp;);
200     bool isStructureExtensible() const { return !didPreventExtensions(); }
201 
202     JS_EXPORT_PRIVATE Structure* flattenDictionaryStructure(VM&amp;, JSObject*);
203 
<span class="line-modified">204     static const bool needsDestruction = true;</span>
205     static void destroy(JSCell*);
206 
207     // Versions that take a func will call it after making the change but while still holding
208     // the lock. The callback is not called if there is no change being made, like if you call
209     // removePropertyWithoutTransition() and the property is not found.
210     template&lt;typename Func&gt;
211     PropertyOffset addPropertyWithoutTransition(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
212     template&lt;typename Func&gt;
213     PropertyOffset removePropertyWithoutTransition(VM&amp;, PropertyName, const Func&amp;);
214     void setPrototypeWithoutTransition(VM&amp;, JSValue prototype);
215 
216     bool isDictionary() const { return dictionaryKind() != NoneDictionaryKind; }
217     bool isUncacheableDictionary() const { return dictionaryKind() == UncachedDictionaryKind; }
218 
219     bool prototypeQueriesAreCacheable()
220     {
221         return !typeInfo().prohibitsPropertyCaching();
222     }
223 
224     bool propertyAccessesAreCacheable()
</pre>
<hr />
<pre>
228             &amp;&amp; !(typeInfo().getOwnPropertySlotIsImpure() &amp;&amp; !typeInfo().newImpurePropertyFiresWatchpoints());
229     }
230 
231     bool propertyAccessesAreCacheableForAbsence()
232     {
233         return !typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence();
234     }
235 
236     bool needImpurePropertyWatchpoint()
237     {
238         return propertyAccessesAreCacheable()
239             &amp;&amp; typeInfo().getOwnPropertySlotIsImpure()
240             &amp;&amp; typeInfo().newImpurePropertyFiresWatchpoints();
241     }
242 
243     bool isImmutablePrototypeExoticObject()
244     {
245         return typeInfo().isImmutablePrototypeExoticObject();
246     }
247 
<span class="line-modified">248     // We use SlowPath in GetByIdStatus for structures that may get new impure properties later to prevent</span>
249     // DFG from inlining property accesses since structures don&#39;t transition when a new impure property appears.
250     bool takesSlowPathInDFGForImpureProperty()
251     {
252         return typeInfo().getOwnPropertySlotIsImpure();
253     }
254 
255     // Type accessors.
256     TypeInfo typeInfo() const { return m_blob.typeInfo(m_outOfLineTypeFlags); }
257     bool isObject() const { return typeInfo().isObject(); }
258 
259     IndexingType indexingType() const { return m_blob.indexingModeIncludingHistory() &amp; AllWritableArrayTypes; }
260     IndexingType indexingMode() const  { return m_blob.indexingModeIncludingHistory() &amp; AllArrayTypes; }
261     IndexingType indexingModeIncludingHistory() const { return m_blob.indexingModeIncludingHistory(); }
262 
263     inline bool mayInterceptIndexedAccesses() const;
264 
265     bool holesMustForwardToPrototype(VM&amp;, JSObject*) const;
266 
267     JSGlobalObject* globalObject() const { return m_globalObject.get(); }
268 
</pre>
<hr />
<pre>
275         return !m_prototype.get().isEmpty();
276     }
277     ALWAYS_INLINE bool hasPolyProto() const
278     {
279         return !hasMonoProto();
280     }
281     ALWAYS_INLINE JSValue storedPrototype() const
282     {
283         ASSERT(hasMonoProto());
284         return m_prototype.get();
285     }
286     JSValue storedPrototype(const JSObject*) const;
287     JSObject* storedPrototypeObject(const JSObject*) const;
288     Structure* storedPrototypeStructure(const JSObject*) const;
289 
290     JSObject* storedPrototypeObject() const;
291     Structure* storedPrototypeStructure() const;
292     JSValue prototypeForLookup(JSGlobalObject*) const;
293     JSValue prototypeForLookup(JSGlobalObject*, JSCell* base) const;
294     StructureChain* prototypeChain(VM&amp;, JSGlobalObject*, JSObject* base) const;
<span class="line-modified">295     StructureChain* prototypeChain(ExecState*, JSObject* base) const;</span>
296     static void visitChildren(JSCell*, SlotVisitor&amp;);
297 
298     // A Structure is cheap to mark during GC if doing so would only add a small and bounded amount
299     // to our heap footprint. For example, if the structure refers to a global object that is not
300     // yet marked, then as far as we know, the decision to mark this Structure would lead to a large
301     // increase in footprint because no other object refers to that global object. This method
302     // returns true if all user-controlled (and hence unbounded in size) objects referenced from the
303     // Structure are already marked.
304     bool isCheapDuringGC(VM&amp;);
305 
306     // Returns true if this structure is now marked.
307     bool markIfCheap(SlotVisitor&amp;);
308 
309     bool hasRareData() const
310     {
311         return isRareData(m_previousOrRareData.get());
312     }
313 
314     StructureRareData* rareData()
315     {
</pre>
<hr />
<pre>
333 
334     StructureRareData* ensureRareData(VM&amp; vm)
335     {
336         if (!hasRareData())
337             allocateRareData(vm);
338         return rareData();
339     }
340 
341     Structure* previousID() const
342     {
343         ASSERT(structure()-&gt;classInfo() == info());
344         // This is so written because it&#39;s used concurrently. We only load from m_previousOrRareData
345         // once, and this load is guaranteed atomic.
346         JSCell* cell = m_previousOrRareData.get();
347         if (isRareData(cell))
348             return static_cast&lt;StructureRareData*&gt;(cell)-&gt;previousID();
349         return static_cast&lt;Structure*&gt;(cell);
350     }
351     bool transitivelyTransitionedFrom(Structure* structureToFind);
352 
<span class="line-modified">353     PropertyOffset lastOffset() const { return m_offset; }</span>

































354 
<span class="line-modified">355     void setLastOffset(PropertyOffset offset) { m_offset = offset; }</span>













356 
<span class="line-modified">357     static unsigned outOfLineCapacity(PropertyOffset lastOffset)</span>
358     {
<span class="line-modified">359         unsigned outOfLineSize = Structure::outOfLineSize(lastOffset);</span>
360 
361         // This algorithm completely determines the out-of-line property storage growth algorithm.
362         // The JSObject code will only trigger a resize if the value returned by this algorithm
363         // changed between the new and old structure. So, it&#39;s important to keep this simple because
364         // it&#39;s on a fast path.
365 
366         if (!outOfLineSize)
367             return 0;
368 
369         if (outOfLineSize &lt;= initialOutOfLineCapacity)
370             return initialOutOfLineCapacity;
371 
372         ASSERT(outOfLineSize &gt; initialOutOfLineCapacity);
373         COMPILE_ASSERT(outOfLineGrowthFactor == 2, outOfLineGrowthFactor_is_two);
374         return WTF::roundUpToPowerOfTwo(outOfLineSize);
375     }
376 
<span class="line-modified">377     static unsigned outOfLineSize(PropertyOffset lastOffset)</span>
378     {
<span class="line-modified">379         return numberOfOutOfLineSlotsForLastOffset(lastOffset);</span>
380     }
381 
382     unsigned outOfLineCapacity() const
383     {
<span class="line-modified">384         return outOfLineCapacity(m_offset);</span>
385     }
386     unsigned outOfLineSize() const
387     {
<span class="line-modified">388         return outOfLineSize(m_offset);</span>
389     }
390     bool hasInlineStorage() const
391     {
392         return !!m_inlineCapacity;
393     }
394     unsigned inlineCapacity() const
395     {
396         return m_inlineCapacity;
397     }
398     unsigned inlineSize() const
399     {
<span class="line-modified">400         return std::min&lt;unsigned&gt;(m_offset + 1, m_inlineCapacity);</span>
<span class="line-removed">401     }</span>
<span class="line-removed">402     unsigned totalStorageSize() const</span>
<span class="line-removed">403     {</span>
<span class="line-removed">404         return numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>
405     }
406     unsigned totalStorageCapacity() const
407     {
408         ASSERT(structure()-&gt;classInfo() == info());
409         return outOfLineCapacity() + inlineCapacity();
410     }
411 
412     bool isValidOffset(PropertyOffset offset) const
413     {
414         return JSC::isValidOffset(offset)
<span class="line-modified">415             &amp;&amp; offset &lt;= m_offset</span>
416             &amp;&amp; (offset &lt; m_inlineCapacity || offset &gt;= firstOutOfLineOffset);
417     }
418 
419     bool hijacksIndexingHeader() const
420     {
421         return isTypedView(m_classInfo-&gt;typedArrayStorageType);
422     }
423 
424     bool couldHaveIndexingHeader() const
425     {
426         return hasIndexedProperties(indexingType())
427             || hijacksIndexingHeader();
428     }
429 
430     bool hasIndexingHeader(const JSCell*) const;
431 
432     bool masqueradesAsUndefined(JSGlobalObject* lexicalGlobalObject);
433 
434     PropertyOffset get(VM&amp;, PropertyName);
435     PropertyOffset get(VM&amp;, PropertyName, unsigned&amp; attributes);
</pre>
<hr />
<pre>
448     PropertyOffset getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes);
449 
450     Vector&lt;PropertyMapEntry&gt; getPropertiesConcurrently();
451 
452     void setHasGetterSetterPropertiesWithProtoCheck(bool is__proto__)
453     {
454         setHasGetterSetterProperties(true);
455         if (!is__proto__)
456             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
457     }
458 
459     void setContainsReadOnlyProperties() { setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true); }
460 
461     void setHasCustomGetterSetterPropertiesWithProtoCheck(bool is__proto__)
462     {
463         setHasCustomGetterSetterProperties(true);
464         if (!is__proto__)
465             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
466     }
467 
<span class="line-removed">468     bool isEmpty() const</span>
<span class="line-removed">469     {</span>
<span class="line-removed">470         ASSERT(checkOffsetConsistency());</span>
<span class="line-removed">471         return !JSC::isValidOffset(m_offset);</span>
<span class="line-removed">472     }</span>
<span class="line-removed">473 </span>
474     void setCachedPropertyNameEnumerator(VM&amp;, JSPropertyNameEnumerator*);
475     JSPropertyNameEnumerator* cachedPropertyNameEnumerator() const;
<span class="line-modified">476     bool canCachePropertyNameEnumerator() const;</span>
477     bool canAccessPropertiesQuicklyForEnumeration() const;
478 
479     void setCachedOwnKeys(VM&amp;, JSImmutableButterfly*);
480     JSImmutableButterfly* cachedOwnKeys() const;
481     JSImmutableButterfly* cachedOwnKeysIgnoringSentinel() const;
482     bool canCacheOwnKeys() const;
483 
484     void getPropertyNamesFromStructure(VM&amp;, PropertyNameArray&amp;, EnumerationMode);
485 
486     JSString* objectToStringValue()
487     {
488         if (!hasRareData())
489             return 0;
490         return rareData()-&gt;objectToStringValue();
491     }
492 
<span class="line-modified">493     void setObjectToStringValue(ExecState*, VM&amp;, JSString* value, PropertySlot toStringTagSymbolSlot);</span>
494 
495     const ClassInfo* classInfo() const { return m_classInfo; }
496 
497     static ptrdiff_t structureIDOffset()
498     {
499         return OBJECT_OFFSETOF(Structure, m_blob) + StructureIDBlob::structureIDOffset();
500     }
501 
502     static ptrdiff_t prototypeOffset()
503     {
504         return OBJECT_OFFSETOF(Structure, m_prototype);
505     }
506 
507     static ptrdiff_t globalObjectOffset()
508     {
509         return OBJECT_OFFSETOF(Structure, m_globalObject);
510     }
511 
512     static ptrdiff_t classInfoOffset()
513     {
</pre>
<hr />
<pre>
599     {
600         if (LIKELY(didWatchInternalProperties()))
601             return;
602         startWatchingInternalProperties(vm);
603     }
604 
605     Ref&lt;StructureShape&gt; toStructureShape(JSValue, bool&amp; sawPolyProtoStructure);
606 
607     void dump(PrintStream&amp;) const;
608     void dumpInContext(PrintStream&amp;, DumpContext*) const;
609     void dumpBrief(PrintStream&amp;, const CString&amp;) const;
610 
611     static void dumpContextHeader(PrintStream&amp;);
612 
613     ConcurrentJSLock&amp; lock() { return m_lock; }
614 
615     unsigned propertyHash() const { return m_propertyHash; }
616 
617     static bool shouldConvertToPolyProto(const Structure* a, const Structure* b);
618 






619     DECLARE_EXPORT_INFO;
620 
621 private:
622     typedef enum {
623         NoneDictionaryKind = 0,
624         CachedDictionaryKind = 1,
625         UncachedDictionaryKind = 2
626     } DictionaryKind;
627 
628 public:
629 #define DEFINE_BITFIELD(type, lowerName, upperName, width, offset) \
<span class="line-modified">630     static const uint32_t s_##lowerName##Shift = offset;\</span>
<span class="line-modified">631     static const uint32_t s_##lowerName##Mask = ((1 &lt;&lt; (width - 1)) | ((1 &lt;&lt; (width - 1)) - 1));\</span>

632     type lowerName() const { return static_cast&lt;type&gt;((m_bitField &gt;&gt; offset) &amp; s_##lowerName##Mask); }\
633     void set##upperName(type newValue) \
634     {\
635         m_bitField &amp;= ~(s_##lowerName##Mask &lt;&lt; offset);\
636         m_bitField |= (newValue &amp; s_##lowerName##Mask) &lt;&lt; offset;\
637     }
638 
639     DEFINE_BITFIELD(DictionaryKind, dictionaryKind, DictionaryKind, 2, 0);
640     DEFINE_BITFIELD(bool, isPinnedPropertyTable, IsPinnedPropertyTable, 1, 2);
641     DEFINE_BITFIELD(bool, hasGetterSetterProperties, HasGetterSetterProperties, 1, 3);
642     DEFINE_BITFIELD(bool, hasReadOnlyOrGetterSetterPropertiesExcludingProto, HasReadOnlyOrGetterSetterPropertiesExcludingProto, 1, 4);
643     DEFINE_BITFIELD(bool, isQuickPropertyAccessAllowedForEnumeration, IsQuickPropertyAccessAllowedForEnumeration, 1, 5);
<span class="line-modified">644     DEFINE_BITFIELD(unsigned, attributesInPrevious, AttributesInPrevious, 14, 6);</span>
645     DEFINE_BITFIELD(bool, didPreventExtensions, DidPreventExtensions, 1, 20);
646     DEFINE_BITFIELD(bool, didTransition, DidTransition, 1, 21);
647     DEFINE_BITFIELD(bool, staticPropertiesReified, StaticPropertiesReified, 1, 22);
648     DEFINE_BITFIELD(bool, hasBeenFlattenedBefore, HasBeenFlattenedBefore, 1, 23);
649     DEFINE_BITFIELD(bool, hasCustomGetterSetterProperties, HasCustomGetterSetterProperties, 1, 24);
650     DEFINE_BITFIELD(bool, didWatchInternalProperties, DidWatchInternalProperties, 1, 25);
651     DEFINE_BITFIELD(bool, transitionWatchpointIsLikelyToBeFired, TransitionWatchpointIsLikelyToBeFired, 1, 26);
652     DEFINE_BITFIELD(bool, hasBeenDictionary, HasBeenDictionary, 1, 27);
<span class="line-modified">653     DEFINE_BITFIELD(bool, isAddingPropertyForTransition, IsAddingPropertyForTransition, 1, 28);</span>
654     DEFINE_BITFIELD(bool, hasUnderscoreProtoPropertyExcludingOriginalProto, HasUnderscoreProtoPropertyExcludingOriginalProto, 1, 29);



655 
656 private:
657     friend class LLIntOffsetsExtractor;
658 
659     JS_EXPORT_PRIVATE Structure(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType, unsigned inlineCapacity);
660     Structure(VM&amp;);
661     Structure(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire*);
662 
663     static Structure* create(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
664 
665     static Structure* addPropertyTransitionToExistingStructureImpl(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
666 
667     // This will return the structure that has a usable property table, that property table,
668     // and the list of structures that we visited before we got to it. If it returns a
669     // non-null structure, it will also lock the structure that it returns; it is your job
670     // to unlock it.
671     void findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp;, PropertyTable*&amp;);
672 
673     static Structure* toDictionaryTransition(VM&amp;, Structure*, DictionaryKind, DeferredStructureTransitionWatchpointFire* = nullptr);
674 
675     enum class ShouldPin { No, Yes };
676     template&lt;ShouldPin, typename Func&gt;
677     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
678     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes);
<span class="line-modified">679     template&lt;typename Func&gt;</span>
<span class="line-modified">680     PropertyOffset remove(PropertyName, const Func&amp;);</span>
<span class="line-modified">681     PropertyOffset remove(PropertyName);</span>
682 
683     void checkConsistency();
684 
685     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
686     PropertyTable* ensurePropertyTableIfNotEmpty(VM&amp; vm)
687     {
688         if (PropertyTable* result = m_propertyTableUnsafe.get())
689             return result;
690         if (!previousID())
691             return nullptr;
692         return materializePropertyTable(vm);
693     }
694 
695     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
696     PropertyTable* ensurePropertyTable(VM&amp; vm)
697     {
698         if (PropertyTable* result = m_propertyTableUnsafe.get())
699             return result;
700         return materializePropertyTable(vm);
701     }
</pre>
<hr />
<pre>
706     }
707 
708     // This will grab the lock. Do not call when holding the Structure&#39;s lock.
709     JS_EXPORT_PRIVATE PropertyTable* materializePropertyTable(VM&amp;, bool setPropertyTable = true);
710 
711     void setPropertyTable(VM&amp; vm, PropertyTable* table);
712 
713     PropertyTable* takePropertyTableOrCloneIfPinned(VM&amp;);
714     PropertyTable* copyPropertyTableForPinning(VM&amp;);
715 
716     void setPreviousID(VM&amp;, Structure*);
717 
718     void clearPreviousID()
719     {
720         if (hasRareData())
721             rareData()-&gt;clearPreviousID();
722         else
723             m_previousOrRareData.clear();
724     }
725 
<span class="line-modified">726     int transitionCount() const</span>
727     {
<span class="line-modified">728         // Since the number of transitions is always the same as m_offset, we keep the size of Structure down by not storing both.</span>
<span class="line-modified">729         return numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>

730     }
731 
732     bool isValid(JSGlobalObject*, StructureChain* cachedPrototypeChain, JSObject* base) const;
733 
734     // You have to hold the structure lock to do these.
735     JS_EXPORT_PRIVATE void pin(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
736     void pinForCaching(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
737 
738     bool isRareData(JSCell* cell) const
739     {
740         return cell &amp;&amp; cell-&gt;structureID() != structureID();
741     }
742 
743     template&lt;typename DetailsFunc&gt;
744     bool checkOffsetConsistency(PropertyTable*, const DetailsFunc&amp;) const;
745     bool checkOffsetConsistency() const;
746 
747     JS_EXPORT_PRIVATE void allocateRareData(VM&amp;);
748 
749     void startWatchingInternalProperties(VM&amp;);
750 
<span class="line-modified">751     static const int s_maxTransitionLength = 64;</span>
<span class="line-modified">752     static const int s_maxTransitionLengthForNonEvalPutById = 512;</span>
753 
754     // These need to be properly aligned at the beginning of the &#39;Structure&#39;
755     // part of the object.
756     StructureIDBlob m_blob;
757     TypeInfo::OutOfLineTypeFlags m_outOfLineTypeFlags;
758 
759     uint8_t m_inlineCapacity;
760 
761     ConcurrentJSLock m_lock;
762 
763     uint32_t m_bitField;
764 
765     WriteBarrier&lt;JSGlobalObject&gt; m_globalObject;
766     WriteBarrier&lt;Unknown&gt; m_prototype;
767     mutable WriteBarrier&lt;StructureChain&gt; m_cachedPrototypeChain;
768 
769     WriteBarrier&lt;JSCell&gt; m_previousOrRareData;
770 
<span class="line-modified">771     RefPtr&lt;UniquedStringImpl&gt; m_nameInPrevious;</span>
772 
773     const ClassInfo* m_classInfo;
774 
775     StructureTransitionTable m_transitionTable;
776 
777     // Should be accessed through ensurePropertyTable(). During GC, it may be set to 0 by another thread.
778     // During a Heap Snapshot GC we avoid clearing the table so it is safe to use.
779     WriteBarrier&lt;PropertyTable&gt; m_propertyTableUnsafe;
780 
781     mutable InlineWatchpointSet m_transitionWatchpointSet;
782 
783     COMPILE_ASSERT(firstOutOfLineOffset &lt; 256, firstOutOfLineOffset_fits);
784 
<span class="line-modified">785     // m_offset does not account for anonymous slots</span>
<span class="line-modified">786     PropertyOffset m_offset;</span>
787 
788     uint32_t m_propertyHash;




789 };
790 
791 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ClassInfo.h&quot;
 29 #include &quot;ConcurrentJSLock.h&quot;
 30 #include &quot;IndexingType.h&quot;
 31 #include &quot;JSCJSValue.h&quot;
 32 #include &quot;JSCast.h&quot;
 33 #include &quot;JSType.h&quot;
<span class="line-added"> 34 #include &quot;JSTypeInfo.h&quot;</span>
 35 #include &quot;PropertyName.h&quot;
 36 #include &quot;PropertyNameArray.h&quot;
 37 #include &quot;PropertyOffset.h&quot;
 38 #include &quot;PutPropertySlot.h&quot;
 39 #include &quot;StructureIDBlob.h&quot;
 40 #include &quot;StructureRareData.h&quot;
 41 #include &quot;StructureTransitionTable.h&quot;
<span class="line-modified"> 42 #include &quot;TinyBloomFilter.h&quot;</span>
 43 #include &quot;Watchpoint.h&quot;
 44 #include &quot;WriteBarrierInlines.h&quot;
 45 #include &lt;wtf/PrintStream.h&gt;
 46 
 47 namespace WTF {
 48 
 49 class UniquedStringImpl;
 50 
 51 } // namespace WTF
 52 
 53 namespace JSC {
 54 
 55 class DeferGC;
 56 class LLIntOffsetsExtractor;
 57 class PropertyNameArray;
 58 class PropertyNameArrayData;
 59 class PropertyTable;
 60 class StructureChain;
 61 class StructureShape;
 62 class SlotVisitor;
 63 class JSString;
 64 struct DumpContext;
<span class="line-added"> 65 struct HashTable;</span>
<span class="line-added"> 66 struct HashTableValue;</span>
 67 
 68 // The out-of-line property storage capacity to use when first allocating out-of-line
 69 // storage. Note that all objects start out without having any out-of-line storage;
 70 // this comes into play only on the first property store that exhausts inline storage.
<span class="line-modified"> 71 static constexpr unsigned initialOutOfLineCapacity = 4;</span>
 72 
 73 // The factor by which to grow out-of-line storage when it is exhausted, after the
 74 // initial allocation.
<span class="line-modified"> 75 static constexpr unsigned outOfLineGrowthFactor = 2;</span>
 76 
 77 struct PropertyMapEntry {
 78     UniquedStringImpl* key;
 79     PropertyOffset offset;
 80     uint8_t attributes;
 81 
 82     PropertyMapEntry()
 83         : key(nullptr)
 84         , offset(invalidOffset)
 85         , attributes(0)
 86     {
 87     }
 88 
 89     PropertyMapEntry(UniquedStringImpl* key, PropertyOffset offset, unsigned attributes)
 90         : key(key)
 91         , offset(offset)
 92         , attributes(attributes)
 93     {
 94         ASSERT(this-&gt;attributes == attributes);
 95     }
</pre>
<hr />
<pre>
106 
107 private:
108     const Structure* m_structure;
109 };
110 
111 class DeferredStructureTransitionWatchpointFire : public DeferredWatchpointFire {
112     WTF_MAKE_NONCOPYABLE(DeferredStructureTransitionWatchpointFire);
113 public:
114     JS_EXPORT_PRIVATE DeferredStructureTransitionWatchpointFire(VM&amp;, Structure*);
115     JS_EXPORT_PRIVATE ~DeferredStructureTransitionWatchpointFire();
116 
117     void dump(PrintStream&amp; out) const override;
118 
119     const Structure* structure() const { return m_structure; }
120 
121 private:
122     const Structure* m_structure;
123 };
124 
125 class Structure final : public JSCell {
<span class="line-added">126     static constexpr uint16_t shortInvalidOffset = std::numeric_limits&lt;uint16_t&gt;::max() - 1;</span>
<span class="line-added">127     static constexpr uint16_t useRareDataFlag = std::numeric_limits&lt;uint16_t&gt;::max();</span>
128 public:
129     friend class StructureTransitionTable;
130 
131     typedef JSCell Base;
<span class="line-modified">132     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
133 
134     enum PolyProtoTag { PolyProto };
135     static Structure* create(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
136     static Structure* create(PolyProtoTag, VM&amp;, JSGlobalObject*, JSObject* prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType = NonArray, unsigned inlineCapacity = 0);
137 
138     ~Structure();
139 
140     template&lt;typename CellType, SubspaceAccess&gt;
141     static IsoSubspace* subspaceFor(VM&amp; vm)
142     {
143         return &amp;vm.structureSpace;
144     }
145 
146     JS_EXPORT_PRIVATE static bool isValidPrototype(JSValue);
147 
148 protected:
149     void finishCreation(VM&amp; vm)
150     {
151         Base::finishCreation(vm);
152         ASSERT(m_prototype.get().isEmpty() || isValidPrototype(m_prototype.get()));
</pre>
<hr />
<pre>
172         ASSERT(!vm.structureStructure);
173     }
174 
175 public:
176     StructureID id() const { return m_blob.structureID(); }
177     int32_t objectInitializationBlob() const { return m_blob.blobExcludingStructureID(); }
178     int64_t idBlob() const { return m_blob.blob(); }
179 
180     bool isProxy() const
181     {
182         JSType type = m_blob.type();
183         return type == ImpureProxyType || type == PureForwardingProxyType || type == ProxyObjectType;
184     }
185 
186     static void dumpStatistics();
187 
188     JS_EXPORT_PRIVATE static Structure* addPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
189     JS_EXPORT_PRIVATE static Structure* addNewPropertyTransition(VM&amp;, Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;, PutPropertySlot::Context = PutPropertySlot::UnknownContext, DeferredStructureTransitionWatchpointFire* = nullptr);
190     static Structure* addPropertyTransitionToExistingStructureConcurrently(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
191     JS_EXPORT_PRIVATE static Structure* addPropertyTransitionToExistingStructure(Structure*, PropertyName, unsigned attributes, PropertyOffset&amp;);
<span class="line-modified">192     static Structure* removeNewPropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
<span class="line-added">193     static Structure* removePropertyTransition(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
<span class="line-added">194     static Structure* removePropertyTransitionFromExistingStructure(VM&amp;, Structure*, PropertyName, PropertyOffset&amp;, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
195     static Structure* changePrototypeTransition(VM&amp;, Structure*, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp;);
196     JS_EXPORT_PRIVATE static Structure* attributeChangeTransition(VM&amp;, Structure*, PropertyName, unsigned attributes);
197     JS_EXPORT_PRIVATE static Structure* toCacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
<span class="line-modified">198     static Structure* toUncacheableDictionaryTransition(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);</span>
199     JS_EXPORT_PRIVATE static Structure* sealTransition(VM&amp;, Structure*);
200     JS_EXPORT_PRIVATE static Structure* freezeTransition(VM&amp;, Structure*);
201     static Structure* preventExtensionsTransition(VM&amp;, Structure*);
202     static Structure* nonPropertyTransition(VM&amp;, Structure*, NonPropertyTransition);
203     JS_EXPORT_PRIVATE static Structure* nonPropertyTransitionSlow(VM&amp;, Structure*, NonPropertyTransition);
204 
205     JS_EXPORT_PRIVATE bool isSealed(VM&amp;);
206     JS_EXPORT_PRIVATE bool isFrozen(VM&amp;);
207     bool isStructureExtensible() const { return !didPreventExtensions(); }
208 
209     JS_EXPORT_PRIVATE Structure* flattenDictionaryStructure(VM&amp;, JSObject*);
210 
<span class="line-modified">211     static constexpr bool needsDestruction = true;</span>
212     static void destroy(JSCell*);
213 
214     // Versions that take a func will call it after making the change but while still holding
215     // the lock. The callback is not called if there is no change being made, like if you call
216     // removePropertyWithoutTransition() and the property is not found.
217     template&lt;typename Func&gt;
218     PropertyOffset addPropertyWithoutTransition(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
219     template&lt;typename Func&gt;
220     PropertyOffset removePropertyWithoutTransition(VM&amp;, PropertyName, const Func&amp;);
221     void setPrototypeWithoutTransition(VM&amp;, JSValue prototype);
222 
223     bool isDictionary() const { return dictionaryKind() != NoneDictionaryKind; }
224     bool isUncacheableDictionary() const { return dictionaryKind() == UncachedDictionaryKind; }
225 
226     bool prototypeQueriesAreCacheable()
227     {
228         return !typeInfo().prohibitsPropertyCaching();
229     }
230 
231     bool propertyAccessesAreCacheable()
</pre>
<hr />
<pre>
235             &amp;&amp; !(typeInfo().getOwnPropertySlotIsImpure() &amp;&amp; !typeInfo().newImpurePropertyFiresWatchpoints());
236     }
237 
238     bool propertyAccessesAreCacheableForAbsence()
239     {
240         return !typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence();
241     }
242 
243     bool needImpurePropertyWatchpoint()
244     {
245         return propertyAccessesAreCacheable()
246             &amp;&amp; typeInfo().getOwnPropertySlotIsImpure()
247             &amp;&amp; typeInfo().newImpurePropertyFiresWatchpoints();
248     }
249 
250     bool isImmutablePrototypeExoticObject()
251     {
252         return typeInfo().isImmutablePrototypeExoticObject();
253     }
254 
<span class="line-modified">255     // We use SlowPath in GetByStatus for structures that may get new impure properties later to prevent</span>
256     // DFG from inlining property accesses since structures don&#39;t transition when a new impure property appears.
257     bool takesSlowPathInDFGForImpureProperty()
258     {
259         return typeInfo().getOwnPropertySlotIsImpure();
260     }
261 
262     // Type accessors.
263     TypeInfo typeInfo() const { return m_blob.typeInfo(m_outOfLineTypeFlags); }
264     bool isObject() const { return typeInfo().isObject(); }
265 
266     IndexingType indexingType() const { return m_blob.indexingModeIncludingHistory() &amp; AllWritableArrayTypes; }
267     IndexingType indexingMode() const  { return m_blob.indexingModeIncludingHistory() &amp; AllArrayTypes; }
268     IndexingType indexingModeIncludingHistory() const { return m_blob.indexingModeIncludingHistory(); }
269 
270     inline bool mayInterceptIndexedAccesses() const;
271 
272     bool holesMustForwardToPrototype(VM&amp;, JSObject*) const;
273 
274     JSGlobalObject* globalObject() const { return m_globalObject.get(); }
275 
</pre>
<hr />
<pre>
282         return !m_prototype.get().isEmpty();
283     }
284     ALWAYS_INLINE bool hasPolyProto() const
285     {
286         return !hasMonoProto();
287     }
288     ALWAYS_INLINE JSValue storedPrototype() const
289     {
290         ASSERT(hasMonoProto());
291         return m_prototype.get();
292     }
293     JSValue storedPrototype(const JSObject*) const;
294     JSObject* storedPrototypeObject(const JSObject*) const;
295     Structure* storedPrototypeStructure(const JSObject*) const;
296 
297     JSObject* storedPrototypeObject() const;
298     Structure* storedPrototypeStructure() const;
299     JSValue prototypeForLookup(JSGlobalObject*) const;
300     JSValue prototypeForLookup(JSGlobalObject*, JSCell* base) const;
301     StructureChain* prototypeChain(VM&amp;, JSGlobalObject*, JSObject* base) const;
<span class="line-modified">302     StructureChain* prototypeChain(JSGlobalObject*, JSObject* base) const;</span>
303     static void visitChildren(JSCell*, SlotVisitor&amp;);
304 
305     // A Structure is cheap to mark during GC if doing so would only add a small and bounded amount
306     // to our heap footprint. For example, if the structure refers to a global object that is not
307     // yet marked, then as far as we know, the decision to mark this Structure would lead to a large
308     // increase in footprint because no other object refers to that global object. This method
309     // returns true if all user-controlled (and hence unbounded in size) objects referenced from the
310     // Structure are already marked.
311     bool isCheapDuringGC(VM&amp;);
312 
313     // Returns true if this structure is now marked.
314     bool markIfCheap(SlotVisitor&amp;);
315 
316     bool hasRareData() const
317     {
318         return isRareData(m_previousOrRareData.get());
319     }
320 
321     StructureRareData* rareData()
322     {
</pre>
<hr />
<pre>
340 
341     StructureRareData* ensureRareData(VM&amp; vm)
342     {
343         if (!hasRareData())
344             allocateRareData(vm);
345         return rareData();
346     }
347 
348     Structure* previousID() const
349     {
350         ASSERT(structure()-&gt;classInfo() == info());
351         // This is so written because it&#39;s used concurrently. We only load from m_previousOrRareData
352         // once, and this load is guaranteed atomic.
353         JSCell* cell = m_previousOrRareData.get();
354         if (isRareData(cell))
355             return static_cast&lt;StructureRareData*&gt;(cell)-&gt;previousID();
356         return static_cast&lt;Structure*&gt;(cell);
357     }
358     bool transitivelyTransitionedFrom(Structure* structureToFind);
359 
<span class="line-modified">360     PropertyOffset maxOffset() const</span>
<span class="line-added">361     {</span>
<span class="line-added">362         uint16_t maxOffset = m_maxOffset;</span>
<span class="line-added">363         if (maxOffset == shortInvalidOffset)</span>
<span class="line-added">364             return invalidOffset;</span>
<span class="line-added">365         if (maxOffset == useRareDataFlag)</span>
<span class="line-added">366             return rareData()-&gt;m_maxOffset;</span>
<span class="line-added">367         return maxOffset;</span>
<span class="line-added">368     }</span>
<span class="line-added">369 </span>
<span class="line-added">370     void setMaxOffset(VM&amp; vm, PropertyOffset offset)</span>
<span class="line-added">371     {</span>
<span class="line-added">372         if (offset == invalidOffset)</span>
<span class="line-added">373             m_maxOffset = shortInvalidOffset;</span>
<span class="line-added">374         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)</span>
<span class="line-added">375             m_maxOffset = offset;</span>
<span class="line-added">376         else if (m_maxOffset == useRareDataFlag)</span>
<span class="line-added">377             rareData()-&gt;m_maxOffset = offset;</span>
<span class="line-added">378         else {</span>
<span class="line-added">379             ensureRareData(vm)-&gt;m_maxOffset = offset;</span>
<span class="line-added">380             WTF::storeStoreFence();</span>
<span class="line-added">381             m_maxOffset = useRareDataFlag;</span>
<span class="line-added">382         }</span>
<span class="line-added">383     }</span>
<span class="line-added">384 </span>
<span class="line-added">385     PropertyOffset transitionOffset() const</span>
<span class="line-added">386     {</span>
<span class="line-added">387         uint16_t transitionOffset = m_transitionOffset;</span>
<span class="line-added">388         if (transitionOffset == shortInvalidOffset)</span>
<span class="line-added">389             return invalidOffset;</span>
<span class="line-added">390         if (transitionOffset == useRareDataFlag)</span>
<span class="line-added">391             return rareData()-&gt;m_transitionOffset;</span>
<span class="line-added">392         return transitionOffset;</span>
<span class="line-added">393     }</span>
394 
<span class="line-modified">395     void setTransitionOffset(VM&amp; vm, PropertyOffset offset)</span>
<span class="line-added">396     {</span>
<span class="line-added">397         if (offset == invalidOffset)</span>
<span class="line-added">398             m_transitionOffset = shortInvalidOffset;</span>
<span class="line-added">399         else if (offset &lt; useRareDataFlag &amp;&amp; offset &lt; shortInvalidOffset)</span>
<span class="line-added">400             m_transitionOffset = offset;</span>
<span class="line-added">401         else if (m_transitionOffset == useRareDataFlag)</span>
<span class="line-added">402             rareData()-&gt;m_transitionOffset = offset;</span>
<span class="line-added">403         else {</span>
<span class="line-added">404             ensureRareData(vm)-&gt;m_transitionOffset = offset;</span>
<span class="line-added">405             WTF::storeStoreFence();</span>
<span class="line-added">406             m_transitionOffset = useRareDataFlag;</span>
<span class="line-added">407         }</span>
<span class="line-added">408     }</span>
409 
<span class="line-modified">410     static unsigned outOfLineCapacity(PropertyOffset maxOffset)</span>
411     {
<span class="line-modified">412         unsigned outOfLineSize = Structure::outOfLineSize(maxOffset);</span>
413 
414         // This algorithm completely determines the out-of-line property storage growth algorithm.
415         // The JSObject code will only trigger a resize if the value returned by this algorithm
416         // changed between the new and old structure. So, it&#39;s important to keep this simple because
417         // it&#39;s on a fast path.
418 
419         if (!outOfLineSize)
420             return 0;
421 
422         if (outOfLineSize &lt;= initialOutOfLineCapacity)
423             return initialOutOfLineCapacity;
424 
425         ASSERT(outOfLineSize &gt; initialOutOfLineCapacity);
426         COMPILE_ASSERT(outOfLineGrowthFactor == 2, outOfLineGrowthFactor_is_two);
427         return WTF::roundUpToPowerOfTwo(outOfLineSize);
428     }
429 
<span class="line-modified">430     static unsigned outOfLineSize(PropertyOffset maxOffset)</span>
431     {
<span class="line-modified">432         return numberOfOutOfLineSlotsForMaxOffset(maxOffset);</span>
433     }
434 
435     unsigned outOfLineCapacity() const
436     {
<span class="line-modified">437         return outOfLineCapacity(maxOffset());</span>
438     }
439     unsigned outOfLineSize() const
440     {
<span class="line-modified">441         return outOfLineSize(maxOffset());</span>
442     }
443     bool hasInlineStorage() const
444     {
445         return !!m_inlineCapacity;
446     }
447     unsigned inlineCapacity() const
448     {
449         return m_inlineCapacity;
450     }
451     unsigned inlineSize() const
452     {
<span class="line-modified">453         return std::min&lt;unsigned&gt;(maxOffset() + 1, m_inlineCapacity);</span>




454     }
455     unsigned totalStorageCapacity() const
456     {
457         ASSERT(structure()-&gt;classInfo() == info());
458         return outOfLineCapacity() + inlineCapacity();
459     }
460 
461     bool isValidOffset(PropertyOffset offset) const
462     {
463         return JSC::isValidOffset(offset)
<span class="line-modified">464             &amp;&amp; offset &lt;= maxOffset()</span>
465             &amp;&amp; (offset &lt; m_inlineCapacity || offset &gt;= firstOutOfLineOffset);
466     }
467 
468     bool hijacksIndexingHeader() const
469     {
470         return isTypedView(m_classInfo-&gt;typedArrayStorageType);
471     }
472 
473     bool couldHaveIndexingHeader() const
474     {
475         return hasIndexedProperties(indexingType())
476             || hijacksIndexingHeader();
477     }
478 
479     bool hasIndexingHeader(const JSCell*) const;
480 
481     bool masqueradesAsUndefined(JSGlobalObject* lexicalGlobalObject);
482 
483     PropertyOffset get(VM&amp;, PropertyName);
484     PropertyOffset get(VM&amp;, PropertyName, unsigned&amp; attributes);
</pre>
<hr />
<pre>
497     PropertyOffset getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes);
498 
499     Vector&lt;PropertyMapEntry&gt; getPropertiesConcurrently();
500 
501     void setHasGetterSetterPropertiesWithProtoCheck(bool is__proto__)
502     {
503         setHasGetterSetterProperties(true);
504         if (!is__proto__)
505             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
506     }
507 
508     void setContainsReadOnlyProperties() { setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true); }
509 
510     void setHasCustomGetterSetterPropertiesWithProtoCheck(bool is__proto__)
511     {
512         setHasCustomGetterSetterProperties(true);
513         if (!is__proto__)
514             setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
515     }
516 






517     void setCachedPropertyNameEnumerator(VM&amp;, JSPropertyNameEnumerator*);
518     JSPropertyNameEnumerator* cachedPropertyNameEnumerator() const;
<span class="line-modified">519     bool canCachePropertyNameEnumerator(VM&amp;) const;</span>
520     bool canAccessPropertiesQuicklyForEnumeration() const;
521 
522     void setCachedOwnKeys(VM&amp;, JSImmutableButterfly*);
523     JSImmutableButterfly* cachedOwnKeys() const;
524     JSImmutableButterfly* cachedOwnKeysIgnoringSentinel() const;
525     bool canCacheOwnKeys() const;
526 
527     void getPropertyNamesFromStructure(VM&amp;, PropertyNameArray&amp;, EnumerationMode);
528 
529     JSString* objectToStringValue()
530     {
531         if (!hasRareData())
532             return 0;
533         return rareData()-&gt;objectToStringValue();
534     }
535 
<span class="line-modified">536     void setObjectToStringValue(JSGlobalObject*, VM&amp;, JSString* value, PropertySlot toStringTagSymbolSlot);</span>
537 
538     const ClassInfo* classInfo() const { return m_classInfo; }
539 
540     static ptrdiff_t structureIDOffset()
541     {
542         return OBJECT_OFFSETOF(Structure, m_blob) + StructureIDBlob::structureIDOffset();
543     }
544 
545     static ptrdiff_t prototypeOffset()
546     {
547         return OBJECT_OFFSETOF(Structure, m_prototype);
548     }
549 
550     static ptrdiff_t globalObjectOffset()
551     {
552         return OBJECT_OFFSETOF(Structure, m_globalObject);
553     }
554 
555     static ptrdiff_t classInfoOffset()
556     {
</pre>
<hr />
<pre>
642     {
643         if (LIKELY(didWatchInternalProperties()))
644             return;
645         startWatchingInternalProperties(vm);
646     }
647 
648     Ref&lt;StructureShape&gt; toStructureShape(JSValue, bool&amp; sawPolyProtoStructure);
649 
650     void dump(PrintStream&amp;) const;
651     void dumpInContext(PrintStream&amp;, DumpContext*) const;
652     void dumpBrief(PrintStream&amp;, const CString&amp;) const;
653 
654     static void dumpContextHeader(PrintStream&amp;);
655 
656     ConcurrentJSLock&amp; lock() { return m_lock; }
657 
658     unsigned propertyHash() const { return m_propertyHash; }
659 
660     static bool shouldConvertToPolyProto(const Structure* a, const Structure* b);
661 
<span class="line-added">662     struct PropertyHashEntry {</span>
<span class="line-added">663         const HashTable* table;</span>
<span class="line-added">664         const HashTableValue* value;</span>
<span class="line-added">665     };</span>
<span class="line-added">666     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(PropertyName) const;</span>
<span class="line-added">667 </span>
668     DECLARE_EXPORT_INFO;
669 
670 private:
671     typedef enum {
672         NoneDictionaryKind = 0,
673         CachedDictionaryKind = 1,
674         UncachedDictionaryKind = 2
675     } DictionaryKind;
676 
677 public:
678 #define DEFINE_BITFIELD(type, lowerName, upperName, width, offset) \
<span class="line-modified">679     static constexpr uint32_t s_##lowerName##Shift = offset;\</span>
<span class="line-modified">680     static constexpr uint32_t s_##lowerName##Mask = ((1 &lt;&lt; (width - 1)) | ((1 &lt;&lt; (width - 1)) - 1));\</span>
<span class="line-added">681     static constexpr uint32_t s_bitWidthOf##upperName = width;\</span>
682     type lowerName() const { return static_cast&lt;type&gt;((m_bitField &gt;&gt; offset) &amp; s_##lowerName##Mask); }\
683     void set##upperName(type newValue) \
684     {\
685         m_bitField &amp;= ~(s_##lowerName##Mask &lt;&lt; offset);\
686         m_bitField |= (newValue &amp; s_##lowerName##Mask) &lt;&lt; offset;\
687     }
688 
689     DEFINE_BITFIELD(DictionaryKind, dictionaryKind, DictionaryKind, 2, 0);
690     DEFINE_BITFIELD(bool, isPinnedPropertyTable, IsPinnedPropertyTable, 1, 2);
691     DEFINE_BITFIELD(bool, hasGetterSetterProperties, HasGetterSetterProperties, 1, 3);
692     DEFINE_BITFIELD(bool, hasReadOnlyOrGetterSetterPropertiesExcludingProto, HasReadOnlyOrGetterSetterPropertiesExcludingProto, 1, 4);
693     DEFINE_BITFIELD(bool, isQuickPropertyAccessAllowedForEnumeration, IsQuickPropertyAccessAllowedForEnumeration, 1, 5);
<span class="line-modified">694     DEFINE_BITFIELD(unsigned, transitionPropertyAttributes, TransitionPropertyAttributes, 14, 6);</span>
695     DEFINE_BITFIELD(bool, didPreventExtensions, DidPreventExtensions, 1, 20);
696     DEFINE_BITFIELD(bool, didTransition, DidTransition, 1, 21);
697     DEFINE_BITFIELD(bool, staticPropertiesReified, StaticPropertiesReified, 1, 22);
698     DEFINE_BITFIELD(bool, hasBeenFlattenedBefore, HasBeenFlattenedBefore, 1, 23);
699     DEFINE_BITFIELD(bool, hasCustomGetterSetterProperties, HasCustomGetterSetterProperties, 1, 24);
700     DEFINE_BITFIELD(bool, didWatchInternalProperties, DidWatchInternalProperties, 1, 25);
701     DEFINE_BITFIELD(bool, transitionWatchpointIsLikelyToBeFired, TransitionWatchpointIsLikelyToBeFired, 1, 26);
702     DEFINE_BITFIELD(bool, hasBeenDictionary, HasBeenDictionary, 1, 27);
<span class="line-modified">703     DEFINE_BITFIELD(bool, protectPropertyTableWhileTransitioning, ProtectPropertyTableWhileTransitioning, 1, 28);</span>
704     DEFINE_BITFIELD(bool, hasUnderscoreProtoPropertyExcludingOriginalProto, HasUnderscoreProtoPropertyExcludingOriginalProto, 1, 29);
<span class="line-added">705     DEFINE_BITFIELD(bool, isPropertyDeletionTransition, IsPropertyDeletionTransition, 1, 30);</span>
<span class="line-added">706 </span>
<span class="line-added">707     static_assert(s_bitWidthOfTransitionPropertyAttributes &lt;= sizeof(TransitionPropertyAttributes) * 8);</span>
708 
709 private:
710     friend class LLIntOffsetsExtractor;
711 
712     JS_EXPORT_PRIVATE Structure(VM&amp;, JSGlobalObject*, JSValue prototype, const TypeInfo&amp;, const ClassInfo*, IndexingType, unsigned inlineCapacity);
713     Structure(VM&amp;);
714     Structure(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire*);
715 
716     static Structure* create(VM&amp;, Structure*, DeferredStructureTransitionWatchpointFire* = nullptr);
717 
718     static Structure* addPropertyTransitionToExistingStructureImpl(Structure*, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp;);
719 
720     // This will return the structure that has a usable property table, that property table,
721     // and the list of structures that we visited before we got to it. If it returns a
722     // non-null structure, it will also lock the structure that it returns; it is your job
723     // to unlock it.
724     void findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp;, PropertyTable*&amp;);
725 
726     static Structure* toDictionaryTransition(VM&amp;, Structure*, DictionaryKind, DeferredStructureTransitionWatchpointFire* = nullptr);
727 
728     enum class ShouldPin { No, Yes };
729     template&lt;ShouldPin, typename Func&gt;
730     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes, const Func&amp;);
731     PropertyOffset add(VM&amp;, PropertyName, unsigned attributes);
<span class="line-modified">732     template&lt;ShouldPin, typename Func&gt;</span>
<span class="line-modified">733     PropertyOffset remove(VM&amp;, PropertyName, const Func&amp;);</span>
<span class="line-modified">734     PropertyOffset remove(VM&amp;, PropertyName);</span>
735 
736     void checkConsistency();
737 
738     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
739     PropertyTable* ensurePropertyTableIfNotEmpty(VM&amp; vm)
740     {
741         if (PropertyTable* result = m_propertyTableUnsafe.get())
742             return result;
743         if (!previousID())
744             return nullptr;
745         return materializePropertyTable(vm);
746     }
747 
748     // This may grab the lock, or not. Do not call when holding the Structure&#39;s lock.
749     PropertyTable* ensurePropertyTable(VM&amp; vm)
750     {
751         if (PropertyTable* result = m_propertyTableUnsafe.get())
752             return result;
753         return materializePropertyTable(vm);
754     }
</pre>
<hr />
<pre>
759     }
760 
761     // This will grab the lock. Do not call when holding the Structure&#39;s lock.
762     JS_EXPORT_PRIVATE PropertyTable* materializePropertyTable(VM&amp;, bool setPropertyTable = true);
763 
764     void setPropertyTable(VM&amp; vm, PropertyTable* table);
765 
766     PropertyTable* takePropertyTableOrCloneIfPinned(VM&amp;);
767     PropertyTable* copyPropertyTableForPinning(VM&amp;);
768 
769     void setPreviousID(VM&amp;, Structure*);
770 
771     void clearPreviousID()
772     {
773         if (hasRareData())
774             rareData()-&gt;clearPreviousID();
775         else
776             m_previousOrRareData.clear();
777     }
778 
<span class="line-modified">779     int transitionCountEstimate() const</span>
780     {
<span class="line-modified">781         // Since the number of transitions is often the same as the last offset (except if there are deletes)</span>
<span class="line-modified">782         // we keep the size of Structure down by not storing both.</span>
<span class="line-added">783         return numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);</span>
784     }
785 
786     bool isValid(JSGlobalObject*, StructureChain* cachedPrototypeChain, JSObject* base) const;
787 
788     // You have to hold the structure lock to do these.
789     JS_EXPORT_PRIVATE void pin(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
790     void pinForCaching(const AbstractLocker&amp;, VM&amp;, PropertyTable*);
791 
792     bool isRareData(JSCell* cell) const
793     {
794         return cell &amp;&amp; cell-&gt;structureID() != structureID();
795     }
796 
797     template&lt;typename DetailsFunc&gt;
798     bool checkOffsetConsistency(PropertyTable*, const DetailsFunc&amp;) const;
799     bool checkOffsetConsistency() const;
800 
801     JS_EXPORT_PRIVATE void allocateRareData(VM&amp;);
802 
803     void startWatchingInternalProperties(VM&amp;);
804 
<span class="line-modified">805     static constexpr int s_maxTransitionLength = 64;</span>
<span class="line-modified">806     static constexpr int s_maxTransitionLengthForNonEvalPutById = 512;</span>
807 
808     // These need to be properly aligned at the beginning of the &#39;Structure&#39;
809     // part of the object.
810     StructureIDBlob m_blob;
811     TypeInfo::OutOfLineTypeFlags m_outOfLineTypeFlags;
812 
813     uint8_t m_inlineCapacity;
814 
815     ConcurrentJSLock m_lock;
816 
817     uint32_t m_bitField;
818 
819     WriteBarrier&lt;JSGlobalObject&gt; m_globalObject;
820     WriteBarrier&lt;Unknown&gt; m_prototype;
821     mutable WriteBarrier&lt;StructureChain&gt; m_cachedPrototypeChain;
822 
823     WriteBarrier&lt;JSCell&gt; m_previousOrRareData;
824 
<span class="line-modified">825     RefPtr&lt;UniquedStringImpl&gt; m_transitionPropertyName;</span>
826 
827     const ClassInfo* m_classInfo;
828 
829     StructureTransitionTable m_transitionTable;
830 
831     // Should be accessed through ensurePropertyTable(). During GC, it may be set to 0 by another thread.
832     // During a Heap Snapshot GC we avoid clearing the table so it is safe to use.
833     WriteBarrier&lt;PropertyTable&gt; m_propertyTableUnsafe;
834 
835     mutable InlineWatchpointSet m_transitionWatchpointSet;
836 
837     COMPILE_ASSERT(firstOutOfLineOffset &lt; 256, firstOutOfLineOffset_fits);
838 
<span class="line-modified">839     uint16_t m_transitionOffset;</span>
<span class="line-modified">840     uint16_t m_maxOffset;</span>
841 
842     uint32_t m_propertyHash;
<span class="line-added">843     TinyBloomFilter m_seenProperties;</span>
<span class="line-added">844 </span>
<span class="line-added">845     friend class VMInspector;</span>
<span class="line-added">846     friend class JSDollarVMHelper;</span>
847 };
848 
849 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Structure.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureChain.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../layouttree/LayoutTreeBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 


 31 #include &quot;LayoutBox.h&quot;


 32 #include &quot;TableFormattingState.h&quot;
 33 #include &lt;wtf/IsoMallocInlines.h&gt;
 34 
 35 namespace WebCore {
 36 namespace Layout {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
 39 













 40 // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<span class="line-modified"> 41 TableFormattingContext::TableFormattingContext(const Box&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
 42     : FormattingContext(formattingContextRoot, formattingState)
 43 {
 44 }
 45 
<span class="line-modified"> 46 void TableFormattingContext::layout() const</span>
 47 {
 48     auto&amp; grid = formattingState().tableGrid();














 49     auto&amp; cellList = grid.cells();
 50     ASSERT(!cellList.isEmpty());
<span class="line-removed"> 51     // Layout and position each table cell (and compute row height as well).</span>
<span class="line-removed"> 52     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed"> 53     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-removed"> 54     auto&amp; rowList = grid.rows();</span>
 55     for (auto&amp; cell : cellList) {
 56         auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<span class="line-modified"> 57         ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59         auto&amp; cellDisplayBox = layoutState.displayBoxForLayoutBox(cellLayoutBox);</span>
<span class="line-modified"> 60         // FIXME: Add support for column and row spanning.</span>
<span class="line-modified"> 61         auto cellPosition = cell-&gt;position;</span>
<span class="line-modified"> 62         auto&amp; row = rowList.at(cellPosition.y());</span>
<span class="line-modified"> 63         auto&amp; column = columnList.at(cellPosition.x());</span>
<span class="line-modified"> 64         cellDisplayBox.setContentBoxWidth(column.logicalWidth());</span>
<span class="line-modified"> 65         // FIXME: Do not use blanks.</span>
<span class="line-modified"> 66         cellDisplayBox.setBorder({ });</span>
<span class="line-modified"> 67         cellDisplayBox.setPadding({ });</span>
<span class="line-modified"> 68         cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified"> 69         cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71         cellDisplayBox.setTopLeft({ column.logicalLeft(), row.logicalTop() });</span>
<span class="line-modified"> 72 </span>
<span class="line-modified"> 73         layoutState.createFormattingContext(cellLayoutBox)-&gt;layout();</span>
<span class="line-modified"> 74 </span>
<span class="line-modified"> 75         // FIXME: This requires a 2 pass layout.</span>
<span class="line-modified"> 76         auto heightAndMargin = Geometry::tableCellHeightAndMargin(layoutState, cellLayoutBox);</span>
<span class="line-modified"> 77         cellDisplayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified"> 78         cellDisplayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-modified"> 79 </span>
<span class="line-modified"> 80         row.setLogicalHeight(std::max(row.logicalHeight(), heightAndMargin.height));</span>
<span class="line-modified"> 81         // FIXME: This also requires spanning support/check.</span>
<span class="line-modified"> 82         if (!cellPosition.x() &amp;&amp; cellPosition.y()) {</span>
<span class="line-modified"> 83             auto&amp; previousRow = rowList.at(cellPosition.y() - 1);</span>
<span class="line-modified"> 84             row.setLogicalTop(previousRow.logicalBottom());</span>
<span class="line-modified"> 85         }</span>

















 86     }
 87 }
 88 
<span class="line-modified"> 89 FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints() const</span>





























 90 {
 91     // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
 92     // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
 93     // can actually be streched way over.
<span class="line-modified"> 94 </span>
<span class="line-modified"> 95     // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified"> 96     ensureTableGrid();</span>
<span class="line-modified"> 97     // 2. Compute the minimum width of each column.</span>
<span class="line-modified"> 98     computePreferredWidthForColumns();</span>
<span class="line-modified"> 99     // 3. Compute the width of the table.</span>
<span class="line-modified">100     auto width = computedTableWidth();</span>
<span class="line-modified">101     // This is the actual computed table width that we want to present as min/max width.</span>
<span class="line-removed">102     return { width, width };</span>
103 }
104 
<span class="line-modified">105 void TableFormattingContext::ensureTableGrid() const</span>
106 {
<span class="line-modified">107     auto&amp; tableWrapperBox = downcast&lt;Container&gt;(root());</span>
108     auto&amp; tableGrid = formattingState().tableGrid();


























109 
<span class="line-modified">110     for (auto* section = tableWrapperBox.firstChild(); section; section = section-&gt;nextSibling()) {</span>

111         ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
112         for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
113             ASSERT(row-&gt;isTableRow());
114             for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
115                 ASSERT(cell-&gt;isTableCell());
116                 tableGrid.appendCell(*cell);
117             }
118         }
119     }
120 }
121 
<span class="line-modified">122 void TableFormattingContext::computePreferredWidthForColumns() const</span>
123 {
124     auto&amp; formattingState = this-&gt;formattingState();
125     auto&amp; grid = formattingState.tableGrid();

126 
127     // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
128     //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
129     //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
130     for (auto&amp; cell : grid.cells()) {
<span class="line-modified">131         ASSERT(cell-&gt;tableCellBox.establishesFormattingContext());</span>

132 
<span class="line-modified">133         auto intrinsicWidth = layoutState().createFormattingContext(cell-&gt;tableCellBox)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">134         intrinsicWidth = Geometry::constrainByMinMaxWidth(cell-&gt;tableCellBox, intrinsicWidth);</span>
<span class="line-modified">135         formattingState.setIntrinsicWidthConstraints(intrinsicWidth);</span>









136 
137         auto columnSpan = cell-&gt;size.width();
<span class="line-modified">138         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth.minimum / columnSpan, intrinsicWidth.maximum / columnSpan };</span>
139         auto initialPosition = cell-&gt;position;
140         for (auto i = 0; i &lt; columnSpan; ++i)
141             grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
142     }
143     // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
144     //    The minimum is that required by the cell with the largest minimum cell width (or the column &#39;width&#39;, whichever is larger).
145     //    The maximum is that required by the cell with the largest maximum cell width (or the column &#39;width&#39;, whichever is larger).
146     auto&amp; columns = grid.columnsContext().columns();
147     int numberOfRows = grid.rows().size();
148     int numberOfColumns = columns.size();
149     for (int columnIndex = 0; columnIndex &lt; numberOfColumns; ++columnIndex) {
150         auto columnIntrinsicWidths = FormattingContext::IntrinsicWidthConstraints { };
151         for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
152             auto* slot = grid.slot({ columnIndex, rowIndex });
153             columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
154             columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
155         }







156         columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
157     }
<span class="line-removed">158     // FIXME: Take column group elements into account.</span>
159 }
160 
<span class="line-modified">161 LayoutUnit TableFormattingContext::computedTableWidth() const</span>
162 {




163     // Column and caption widths influence the final table width as follows:
164     // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
165     // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
166     // If the used width is greater than MIN, the extra width should be distributed over the columns.
167     // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
168     // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
169     // less than that of the containing block, use max(MAX, CAPMIN).



170 
<span class="line-modified">171     // FIXME: This kind of code usually lives in *FormattingContextGeometry class.</span>
<span class="line-modified">172     auto&amp; tableWrapperBox = root();</span>
<span class="line-modified">173     auto&amp; style = tableWrapperBox.style();</span>
<span class="line-modified">174     auto&amp; containingBlock = *tableWrapperBox.containingBlock();</span>
<span class="line-modified">175     auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(containingBlock);</span>
<span class="line-modified">176     auto containingBlockWidth = containingBlockDisplayBox.contentBoxWidth();</span>



177 
<span class="line-modified">178     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">179     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-removed">180     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-removed">181 </span>
<span class="line-removed">182     auto width = Geometry::computedValueIfNotAuto(style.width(), containingBlockWidth);</span>
<span class="line-removed">183     LayoutUnit usedWidth;</span>
<span class="line-removed">184     if (width) {</span>
<span class="line-removed">185         if (*width &gt; tableWidthConstraints.minimum) {</span>
<span class="line-removed">186             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
<span class="line-removed">187             usedWidth = *width;</span>
<span class="line-removed">188         } else {</span>
<span class="line-removed">189             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-removed">190             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
191         }
<span class="line-modified">192     } else {</span>
<span class="line-modified">193         if (tableWidthConstraints.minimum &gt; containingBlockWidth) {</span>
<span class="line-modified">194             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-modified">195             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
<span class="line-modified">196         } else if (tableWidthConstraints.maximum &lt; containingBlockWidth) {</span>
<span class="line-modified">197             usedWidth = tableWidthConstraints.maximum;</span>
<span class="line-modified">198             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Maximum);</span>
<span class="line-modified">199         } else {</span>
<span class="line-modified">200             usedWidth = containingBlockWidth;</span>
<span class="line-removed">201             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
202         }

















203     }
<span class="line-removed">204     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-removed">205     LayoutUnit columnLogicalLeft;</span>
<span class="line-removed">206     auto&amp; columns = columnsContext.columns();</span>
<span class="line-removed">207     for (auto&amp; column : columns) {</span>
<span class="line-removed">208         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-removed">209         columnLogicalLeft += column.logicalWidth();</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211     return usedWidth;</span>
212 }
213 
<span class="line-modified">214 void TableFormattingContext::distributeAvailableWidth(LayoutUnit extraHorizontalSpace) const</span>
215 {
<span class="line-removed">216     // FIXME: Right now just distribute the extra space equaly among the columns.</span>
217     auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
218     ASSERT(!columns.isEmpty());
219 
<span class="line-removed">220     auto columnExtraSpace = extraHorizontalSpace / columns.size();</span>
221     for (auto&amp; column : columns)
<span class="line-modified">222         column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>
223 }
224 
225 }
226 }
227 
228 #endif
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #include &quot;DisplayBox.h&quot;</span>
<span class="line-added"> 32 #include &quot;InvalidationState.h&quot;</span>
 33 #include &quot;LayoutBox.h&quot;
<span class="line-added"> 34 #include &quot;LayoutChildIterator.h&quot;</span>
<span class="line-added"> 35 #include &quot;LayoutContext.h&quot;</span>
 36 #include &quot;TableFormattingState.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
 43 
<span class="line-added"> 44 // FIXME: This is temporary. Remove this function when table formatting is complete.</span>
<span class="line-added"> 45 void TableFormattingContext::initializeDisplayBoxToBlank(Display::Box&amp; displayBox) const</span>
<span class="line-added"> 46 {</span>
<span class="line-added"> 47     displayBox.setBorder({ });</span>
<span class="line-added"> 48     displayBox.setPadding({ });</span>
<span class="line-added"> 49     displayBox.setHorizontalMargin({ });</span>
<span class="line-added"> 50     displayBox.setHorizontalComputedMargin({ });</span>
<span class="line-added"> 51     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added"> 52     displayBox.setTopLeft({ });</span>
<span class="line-added"> 53     displayBox.setContentBoxWidth({ });</span>
<span class="line-added"> 54     displayBox.setContentBoxHeight({ });</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
 57 // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<span class="line-modified"> 58 TableFormattingContext::TableFormattingContext(const Container&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
 59     : FormattingContext(formattingContextRoot, formattingState)
 60 {
 61 }
 62 
<span class="line-modified"> 63 void TableFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp;)</span>
 64 {
 65     auto&amp; grid = formattingState().tableGrid();
<span class="line-added"> 66     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     computeAndDistributeExtraHorizontalSpace();</span>
<span class="line-added"> 69     // 1. Position each column.</span>
<span class="line-added"> 70     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-added"> 71     auto horizontalSpacing = grid.horizontalSpacing();</span>
<span class="line-added"> 72     auto columnLogicalLeft = horizontalSpacing;</span>
<span class="line-added"> 73     for (auto&amp; column : columnsContext.columns()) {</span>
<span class="line-added"> 74         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-added"> 75         columnLogicalLeft += (column.logicalWidth() + horizontalSpacing);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     // 2. Layout each table cell (and compute row height as well).</span>
<span class="line-added"> 79     auto&amp; columnList = columnsContext.columns();</span>
 80     auto&amp; cellList = grid.cells();
 81     ASSERT(!cellList.isEmpty());




 82     for (auto&amp; cell : cellList) {
 83         auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<span class="line-modified"> 84         layoutTableCellBox(cellLayoutBox, columnList.at(cell-&gt;position.x()), invalidationState, horizontalConstraints);</span>
<span class="line-modified"> 85         // FIXME: Add support for column and row spanning and this requires a 2 pass layout.</span>
<span class="line-modified"> 86         auto&amp; row = grid.rows().at(cell-&gt;position.y());</span>
<span class="line-modified"> 87         row.setLogicalHeight(std::max(row.logicalHeight(), geometryForBox(cellLayoutBox).marginBoxHeight()));</span>
<span class="line-modified"> 88     }</span>
<span class="line-modified"> 89     // This is after the second pass when cell heights are fully computed.</span>
<span class="line-modified"> 90     auto rowLogicalTop = grid.verticalSpacing();</span>
<span class="line-modified"> 91     for (auto&amp; row : grid.rows()) {</span>
<span class="line-modified"> 92         row.setLogicalTop(rowLogicalTop);</span>
<span class="line-modified"> 93         rowLogicalTop += (row.logicalHeight() + grid.verticalSpacing());</span>
<span class="line-modified"> 94     }</span>
<span class="line-modified"> 95 </span>
<span class="line-modified"> 96     // 3. Finalize size and position.</span>
<span class="line-modified"> 97     positionTableCells();</span>
<span class="line-modified"> 98     setComputedGeometryForSections();</span>
<span class="line-modified"> 99     setComputedGeometryForRows();</span>
<span class="line-modified">100 }</span>
<span class="line-modified">101 </span>
<span class="line-modified">102 void TableFormattingContext::layoutTableCellBox(const Box&amp; cellLayoutBox, const TableGrid::Column&amp; column, InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints)</span>
<span class="line-modified">103 {</span>
<span class="line-modified">104     computeBorderAndPadding(cellLayoutBox, horizontalConstraints);</span>
<span class="line-modified">105     // Margins do not apply to internal table elements.</span>
<span class="line-modified">106     auto&amp; cellDisplayBox = formattingState().displayBox(cellLayoutBox);</span>
<span class="line-modified">107     cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified">108     cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified">109     // Don&#39;t know the actual position yet.</span>
<span class="line-modified">110     cellDisplayBox.setTopLeft({ });</span>
<span class="line-modified">111     cellDisplayBox.setContentBoxWidth(column.logicalWidth() - cellDisplayBox.horizontalMarginBorderAndPadding());</span>
<span class="line-modified">112 </span>
<span class="line-added">113     ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-added">114     if (is&lt;Container&gt;(cellLayoutBox) &amp;&amp; downcast&lt;Container&gt;(cellLayoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-added">115         LayoutContext::createFormattingContext(downcast&lt;Container&gt;(cellLayoutBox), layoutState())-&gt;layoutInFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(cellDisplayBox), Geometry::verticalConstraintsForInFlow(cellDisplayBox));</span>
<span class="line-added">116     cellDisplayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">117     cellDisplayBox.setContentBoxHeight(geometry().tableCellHeightAndMargin(cellLayoutBox).contentHeight);</span>
<span class="line-added">118     // FIXME: Check what to do with out-of-flow content.</span>
<span class="line-added">119 }</span>
<span class="line-added">120 </span>
<span class="line-added">121 void TableFormattingContext::positionTableCells()</span>
<span class="line-added">122 {</span>
<span class="line-added">123     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">124     auto&amp; rowList = grid.rows();</span>
<span class="line-added">125     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-added">126     for (auto&amp; cell : grid.cells()) {</span>
<span class="line-added">127         auto&amp; cellDisplayBox = formattingState().displayBox(cell-&gt;tableCellBox);</span>
<span class="line-added">128         cellDisplayBox.setTop(rowList.at(cell-&gt;position.y()).logicalTop());</span>
<span class="line-added">129         cellDisplayBox.setLeft(columnList.at(cell-&gt;position.x()).logicalLeft());</span>
130     }
131 }
132 
<span class="line-modified">133 void TableFormattingContext::setComputedGeometryForRows()</span>
<span class="line-added">134 {</span>
<span class="line-added">135     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">136     auto rowWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">137 </span>
<span class="line-added">138     auto&amp; rowList = grid.rows();</span>
<span class="line-added">139     for (auto&amp; row : rowList) {</span>
<span class="line-added">140         auto&amp; rowDisplayBox = formattingState().displayBox(row.box());</span>
<span class="line-added">141         initializeDisplayBoxToBlank(rowDisplayBox);</span>
<span class="line-added">142         rowDisplayBox.setContentBoxHeight(row.logicalHeight());</span>
<span class="line-added">143         rowDisplayBox.setContentBoxWidth(rowWidth);</span>
<span class="line-added">144         rowDisplayBox.setTop(row.logicalTop());</span>
<span class="line-added">145     }</span>
<span class="line-added">146 }</span>
<span class="line-added">147 </span>
<span class="line-added">148 void TableFormattingContext::setComputedGeometryForSections()</span>
<span class="line-added">149 {</span>
<span class="line-added">150     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">151     auto sectionWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">152 </span>
<span class="line-added">153     for (auto&amp; section : childrenOfType&lt;Box&gt;(root())) {</span>
<span class="line-added">154         auto&amp; sectionDisplayBox = formattingState().displayBox(section);</span>
<span class="line-added">155         initializeDisplayBoxToBlank(sectionDisplayBox);</span>
<span class="line-added">156         // FIXME: Size table sections properly.</span>
<span class="line-added">157         sectionDisplayBox.setContentBoxWidth(sectionWidth);</span>
<span class="line-added">158         sectionDisplayBox.setContentBoxHeight(grid.rows().last().logicalBottom() + grid.verticalSpacing());</span>
<span class="line-added">159     }</span>
<span class="line-added">160 }</span>
<span class="line-added">161 </span>
<span class="line-added">162 FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints()</span>
163 {
164     // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
165     // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
166     // can actually be streched way over.
<span class="line-modified">167     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">168     if (!grid.hasComputedWidthConstraints()) {</span>
<span class="line-modified">169         // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified">170         ensureTableGrid();</span>
<span class="line-modified">171         // 2. Compute the minimum/maximum width of each column.</span>
<span class="line-modified">172         computePreferredWidthForColumns();</span>
<span class="line-modified">173     }</span>
<span class="line-modified">174     return grid.widthConstraints();</span>

175 }
176 
<span class="line-modified">177 void TableFormattingContext::ensureTableGrid()</span>
178 {
<span class="line-modified">179     auto&amp; tableBox = root();</span>
180     auto&amp; tableGrid = formattingState().tableGrid();
<span class="line-added">181     tableGrid.setHorizontalSpacing(LayoutUnit { tableBox.style().horizontalBorderSpacing() });</span>
<span class="line-added">182     tableGrid.setVerticalSpacing(LayoutUnit { tableBox.style().verticalBorderSpacing() });</span>
<span class="line-added">183 </span>
<span class="line-added">184     auto* firstChild = tableBox.firstChild();</span>
<span class="line-added">185     const Box* tableCaption = nullptr;</span>
<span class="line-added">186     const Box* colgroup = nullptr;</span>
<span class="line-added">187     // Table caption is an optional element; if used, it is always the first child of a &lt;table&gt;.</span>
<span class="line-added">188     if (firstChild-&gt;isTableCaption())</span>
<span class="line-added">189         tableCaption = firstChild;</span>
<span class="line-added">190     // The &lt;colgroup&gt; must appear after any optional &lt;caption&gt; element but before any &lt;thead&gt;, &lt;th&gt;, &lt;tbody&gt;, &lt;tfoot&gt; and &lt;tr&gt; element.</span>
<span class="line-added">191     auto* colgroupCandidate = firstChild;</span>
<span class="line-added">192     if (tableCaption)</span>
<span class="line-added">193         colgroupCandidate = tableCaption-&gt;nextSibling();</span>
<span class="line-added">194     if (colgroupCandidate-&gt;isTableColumnGroup())</span>
<span class="line-added">195         colgroup = colgroupCandidate;</span>
<span class="line-added">196 </span>
<span class="line-added">197     if (colgroup) {</span>
<span class="line-added">198         auto&amp; columnsContext = tableGrid.columnsContext();</span>
<span class="line-added">199         for (auto* column = downcast&lt;Container&gt;(*colgroup).firstChild(); column; column = column-&gt;nextSibling()) {</span>
<span class="line-added">200             ASSERT(column-&gt;isTableColumn());</span>
<span class="line-added">201             auto columnSpanCount = column-&gt;columnSpan();</span>
<span class="line-added">202             ASSERT(columnSpanCount &gt; 0);</span>
<span class="line-added">203             while (columnSpanCount--)</span>
<span class="line-added">204                 columnsContext.addColumn(column);</span>
<span class="line-added">205         }</span>
<span class="line-added">206     }</span>
207 
<span class="line-modified">208     auto* firstSection = colgroup ? colgroup-&gt;nextSibling() : tableCaption ? tableCaption-&gt;nextSibling() : firstChild;</span>
<span class="line-added">209     for (auto* section = firstSection; section; section = section-&gt;nextSibling()) {</span>
210         ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
211         for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
212             ASSERT(row-&gt;isTableRow());
213             for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
214                 ASSERT(cell-&gt;isTableCell());
215                 tableGrid.appendCell(*cell);
216             }
217         }
218     }
219 }
220 
<span class="line-modified">221 void TableFormattingContext::computePreferredWidthForColumns()</span>
222 {
223     auto&amp; formattingState = this-&gt;formattingState();
224     auto&amp; grid = formattingState.tableGrid();
<span class="line-added">225     ASSERT(!grid.hasComputedWidthConstraints());</span>
226 
227     // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
228     //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
229     //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
230     for (auto&amp; cell : grid.cells()) {
<span class="line-modified">231         auto&amp; tableCellBox = cell-&gt;tableCellBox;</span>
<span class="line-added">232         ASSERT(tableCellBox.establishesFormattingContext());</span>
233 
<span class="line-modified">234         auto intrinsicWidth = formattingState.intrinsicWidthConstraintsForBox(tableCellBox);</span>
<span class="line-modified">235         if (!intrinsicWidth) {</span>
<span class="line-modified">236             intrinsicWidth = IntrinsicWidthConstraints { };</span>
<span class="line-added">237             if (is&lt;Container&gt;(tableCellBox))</span>
<span class="line-added">238                 intrinsicWidth = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(tableCellBox), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">239             intrinsicWidth = geometry().constrainByMinMaxWidth(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">240             auto border = geometry().computedBorder(tableCellBox);</span>
<span class="line-added">241             auto padding = *geometry().computedPadding(tableCellBox, { });</span>
<span class="line-added">242 </span>
<span class="line-added">243             intrinsicWidth-&gt;expand(border.horizontal.width() + padding.horizontal.width());</span>
<span class="line-added">244             formattingState.setIntrinsicWidthConstraintsForBox(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">245         }</span>
246 
247         auto columnSpan = cell-&gt;size.width();
<span class="line-modified">248         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth-&gt;minimum / columnSpan, intrinsicWidth-&gt;maximum / columnSpan };</span>
249         auto initialPosition = cell-&gt;position;
250         for (auto i = 0; i &lt; columnSpan; ++i)
251             grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
252     }
253     // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
254     //    The minimum is that required by the cell with the largest minimum cell width (or the column &#39;width&#39;, whichever is larger).
255     //    The maximum is that required by the cell with the largest maximum cell width (or the column &#39;width&#39;, whichever is larger).
256     auto&amp; columns = grid.columnsContext().columns();
257     int numberOfRows = grid.rows().size();
258     int numberOfColumns = columns.size();
259     for (int columnIndex = 0; columnIndex &lt; numberOfColumns; ++columnIndex) {
260         auto columnIntrinsicWidths = FormattingContext::IntrinsicWidthConstraints { };
261         for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
262             auto* slot = grid.slot({ columnIndex, rowIndex });
263             columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
264             columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
265         }
<span class="line-added">266         // Now that we have the content driven min/max widths, check if &lt;col&gt; sets a preferred width on this column.</span>
<span class="line-added">267         if (auto* columnBox = columns[columnIndex].columnBox()) {</span>
<span class="line-added">268             if (auto columnPreferredWidth = geometry().computedColumnWidth(*columnBox)) {</span>
<span class="line-added">269                 // Let&#39;s stay at least as wide as the preferred width.</span>
<span class="line-added">270                 columnIntrinsicWidths.minimum = std::max(columnIntrinsicWidths.minimum, *columnPreferredWidth);</span>
<span class="line-added">271             }</span>
<span class="line-added">272         }</span>
273         columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
274     }

275 }
276 
<span class="line-modified">277 void TableFormattingContext::computeAndDistributeExtraHorizontalSpace()</span>
278 {
<span class="line-added">279     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">280     ASSERT(grid.hasComputedWidthConstraints());</span>
<span class="line-added">281     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-added">282 </span>
283     // Column and caption widths influence the final table width as follows:
284     // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
285     // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
286     // If the used width is greater than MIN, the extra width should be distributed over the columns.
287     // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
288     // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
289     // less than that of the containing block, use max(MAX, CAPMIN).
<span class="line-added">290     auto distributeExtraHorizontalSpace = [&amp;](auto extraHorizontalSpace) {</span>
<span class="line-added">291         auto&amp; columns = grid.columnsContext().columns();</span>
<span class="line-added">292         ASSERT(!columns.isEmpty());</span>
293 
<span class="line-modified">294         auto tableMinimumContentWidth = tableWidthConstraints.minimum - grid.totalHorizontalSpacing();</span>
<span class="line-modified">295         auto adjustabledHorizontalSpace = tableMinimumContentWidth;</span>
<span class="line-modified">296         auto numberOfColumns = columns.size();</span>
<span class="line-modified">297         // Fixed width columns don&#39;t participate in available space distribution.</span>
<span class="line-modified">298         for (auto&amp; column : columns) {</span>
<span class="line-modified">299             if (!column.hasFixedWidth())</span>
<span class="line-added">300                 continue;</span>
<span class="line-added">301             auto columnFixedWidth = *column.columnBox()-&gt;columnWidth();</span>
<span class="line-added">302             column.setLogicalWidth(columnFixedWidth);</span>
303 
<span class="line-modified">304             --numberOfColumns;</span>
<span class="line-modified">305             adjustabledHorizontalSpace -= columnFixedWidth;</span>











306         }
<span class="line-modified">307         if (!numberOfColumns || !adjustabledHorizontalSpace)</span>
<span class="line-modified">308             return;</span>
<span class="line-modified">309         // FIXME: Right now just distribute the extra space equaly among the columns using the minimum width.</span>
<span class="line-modified">310         ASSERT(adjustabledHorizontalSpace &gt; 0);</span>
<span class="line-modified">311         for (auto&amp; column : columns) {</span>
<span class="line-modified">312             if (column.hasFixedWidth())</span>
<span class="line-modified">313                 continue;</span>
<span class="line-modified">314             auto columnExtraSpace = extraHorizontalSpace / adjustabledHorizontalSpace * column.widthConstraints().minimum;</span>
<span class="line-modified">315             column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>

316         }
<span class="line-added">317     };</span>
<span class="line-added">318 </span>
<span class="line-added">319     auto&amp; tableBox = root();</span>
<span class="line-added">320     auto containingBlockWidth = geometryForBox(*tableBox.containingBlock(), EscapeReason::TableNeedsAccessToTableWrapper).contentBoxWidth();</span>
<span class="line-added">321     auto contentWidth = geometry().computedContentWidth(tableBox, containingBlockWidth);</span>
<span class="line-added">322     if (contentWidth) {</span>
<span class="line-added">323         if (*contentWidth &gt; tableWidthConstraints.minimum)</span>
<span class="line-added">324             distributeExtraHorizontalSpace(*contentWidth - tableWidthConstraints.minimum);</span>
<span class="line-added">325         else</span>
<span class="line-added">326             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">327     } else {</span>
<span class="line-added">328         if (tableWidthConstraints.minimum &gt; containingBlockWidth)</span>
<span class="line-added">329             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">330         else if (tableWidthConstraints.maximum &lt; containingBlockWidth)</span>
<span class="line-added">331             useAsContentLogicalWidth(WidthConstraintsType::Maximum);</span>
<span class="line-added">332         else</span>
<span class="line-added">333             distributeExtraHorizontalSpace(containingBlockWidth - tableWidthConstraints.minimum);</span>
334     }








335 }
336 
<span class="line-modified">337 void TableFormattingContext::useAsContentLogicalWidth(WidthConstraintsType type)</span>
338 {

339     auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
340     ASSERT(!columns.isEmpty());
341 

342     for (auto&amp; column : columns)
<span class="line-modified">343         column.setLogicalWidth(type == WidthConstraintsType::Minimum ? column.widthConstraints().minimum : column.widthConstraints().maximum);</span>
344 }
345 
346 }
347 }
348 
349 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../layouttree/LayoutTreeBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TableFormattingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp
@@ -36,10 +36,14 @@
 #include <wtf/Assertions.h>
 #include <wtf/MathExtras.h>
 #include <wtf/Optional.h>
 #include <wtf/text/TextStream.h>
 
+#if PLATFORM(JAVA)
+#include <wtf/java/JavaMath.h>
+#endif
+
 #if CPU(X86_64)
 #include <emmintrin.h>
 #endif
 
 namespace WebCore {
@@ -252,11 +256,15 @@
                 (p[2] * m[2][3]) + (p[3] * m[3][3]);
 }
 
 static double v3Length(Vector3 a)
 {
-    return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));
+#if PLATFORM(JAVA)
+    return javamath::hypot(a[0], a[1], a[2]);
+#else
+    return std::hypot(a[0], a[1], a[2]);
+#endif
 }
 
 static void v3Scale(Vector3 v, double desiredLength)
 {
     double len = v3Length(v);
@@ -298,12 +306,12 @@
     double row1y = matrix[1][1];
     result.translateX = matrix[3][0];
     result.translateY = matrix[3][1];
 
     // Compute scaling factors.
-    result.scaleX = sqrt(row0x * row0x + row0y * row0y);
-    result.scaleY = sqrt(row1x * row1x + row1y * row1y);
+    result.scaleX = std::hypot(row0x, row0y);
+    result.scaleY = std::hypot(row1x, row1y);
 
     // If determinant is negative, one axis was flipped.
     double determinant = row0x * row1y - row0y * row1x;
     if (determinant < 0) {
         // Flip axis with minimum unit vector dot product.
@@ -811,11 +819,15 @@
 }
 
 TransformationMatrix& TransformationMatrix::rotate3d(double x, double y, double z, double angle)
 {
     // Normalize the axis of rotation
-    double length = sqrt(x * x + y * y + z * z);
+#if PLATFORM(JAVA)
+    double length = javamath::hypot(x, y, z);
+#else
+    double length = std::hypot(x, y, z);
+#endif
     if (length == 0) {
         // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
         return *this;
     } else if (length != 1) {
         x /= length;

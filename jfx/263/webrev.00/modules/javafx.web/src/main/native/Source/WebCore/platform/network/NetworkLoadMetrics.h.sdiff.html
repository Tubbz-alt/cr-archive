<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/NetworkLoadMetrics.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPParsers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NetworkStorageSession.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/NetworkLoadMetrics.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 53         reset();
 54     }
 55 
 56     NetworkLoadMetrics isolatedCopy() const
 57     {
 58         NetworkLoadMetrics copy;
 59 
 60         copy.domainLookupStart = domainLookupStart;
 61         copy.domainLookupEnd = domainLookupEnd;
 62         copy.connectStart = connectStart;
 63         copy.secureConnectionStart = secureConnectionStart;
 64         copy.connectEnd = connectEnd;
 65         copy.requestStart = requestStart;
 66         copy.responseStart = responseStart;
 67         copy.responseEnd = responseEnd;
 68         copy.complete = complete;
 69         copy.protocol = protocol.isolatedCopy();
 70 
 71         copy.remoteAddress = remoteAddress.isolatedCopy();
 72         copy.connectionIdentifier = connectionIdentifier.isolatedCopy();
<span class="line-removed"> 73         copy.priority = priority;</span>
 74         copy.tlsProtocol = tlsProtocol.isolatedCopy();
 75         copy.tlsCipher = tlsCipher.isolatedCopy();

 76         copy.requestHeaders = requestHeaders.isolatedCopy();
 77 
 78         copy.requestHeaderBytesSent = requestHeaderBytesSent;
 79         copy.requestBodyBytesSent = requestBodyBytesSent;
 80         copy.responseHeaderBytesReceived = responseHeaderBytesReceived;
 81         copy.responseBodyBytesReceived = responseBodyBytesReceived;
 82         copy.responseBodyDecodedSize = responseBodyDecodedSize;
 83 
 84         return copy;
 85     }
 86 
 87     void reset()
 88     {
 89         domainLookupStart = Seconds(-1);
 90         domainLookupEnd = Seconds(-1);
 91         connectStart = Seconds(-1);
 92         secureConnectionStart = Seconds(-1);
 93         connectEnd = Seconds(-1);
 94         requestStart = Seconds(0);
 95         responseStart = Seconds(0);
 96         responseEnd = Seconds(0);
 97         complete = false;
 98         protocol = String();
 99         clearNonTimingData();
100     }
101 
102     void clearNonTimingData()
103     {
104         remoteAddress = String();
105         connectionIdentifier = String();
<span class="line-removed">106         priority = NetworkLoadPriority::Unknown;</span>
107         tlsProtocol = String();
108         tlsCipher = String();

109         requestHeaders.clear();
110         requestHeaderBytesSent = std::numeric_limits&lt;uint32_t&gt;::max();
111         requestBodyBytesSent = std::numeric_limits&lt;uint64_t&gt;::max();
112         responseHeaderBytesReceived = std::numeric_limits&lt;uint32_t&gt;::max();
113         responseBodyBytesReceived = std::numeric_limits&lt;uint64_t&gt;::max();
114         responseBodyDecodedSize = std::numeric_limits&lt;uint64_t&gt;::max();
115     }
116 
117     bool operator==(const NetworkLoadMetrics&amp; other) const
118     {
119         return domainLookupStart == other.domainLookupStart
120             &amp;&amp; domainLookupEnd == other.domainLookupEnd
121             &amp;&amp; connectStart == other.connectStart
122             &amp;&amp; secureConnectionStart == other.secureConnectionStart
123             &amp;&amp; connectEnd == other.connectEnd
124             &amp;&amp; requestStart == other.requestStart
125             &amp;&amp; responseStart == other.responseStart
126             &amp;&amp; responseEnd == other.responseEnd
127             &amp;&amp; complete == other.complete
128             &amp;&amp; protocol == other.protocol
129             &amp;&amp; remoteAddress == other.remoteAddress
130             &amp;&amp; connectionIdentifier == other.connectionIdentifier
<span class="line-removed">131             &amp;&amp; priority == other.priority</span>
132             &amp;&amp; tlsProtocol == other.tlsProtocol
133             &amp;&amp; tlsCipher == other.tlsCipher

134             &amp;&amp; requestHeaders == other.requestHeaders
135             &amp;&amp; requestHeaderBytesSent == other.requestHeaderBytesSent
136             &amp;&amp; requestBodyBytesSent == other.requestBodyBytesSent
137             &amp;&amp; responseHeaderBytesReceived == other.responseHeaderBytesReceived
138             &amp;&amp; responseBodyBytesReceived == other.responseBodyBytesReceived
139             &amp;&amp; responseBodyDecodedSize == other.responseBodyDecodedSize;
140     }
141 
142     bool operator!=(const NetworkLoadMetrics&amp; other) const
143     {
144         return !(*this == other);
145     }
146 
147     bool isComplete() const { return complete; }
148     void markComplete() { complete = true; }
149 
150     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
151     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, NetworkLoadMetrics&amp;);
152 
153     // These should be treated as deltas to LoadTiming&#39;s fetchStart.
154     // They should be in ascending order as listed here.
155     Seconds domainLookupStart;     // -1 if no DNS.
156     Seconds domainLookupEnd;       // -1 if no DNS.
157     Seconds connectStart;          // -1 if reused connection.
158     Seconds secureConnectionStart; // -1 if no secure connection.
159     Seconds connectEnd;            // -1 if reused connection.
160     Seconds requestStart;
161     Seconds responseStart;
162     Seconds responseEnd;
163 
164     // ALPN Protocol ID: https://w3c.github.io/resource-timing/#bib-RFC7301
165     String protocol;
166 
167     String remoteAddress;
168     String connectionIdentifier;
<span class="line-removed">169     NetworkLoadPriority priority;</span>
170 
171     String tlsProtocol;
172     String tlsCipher;
173 
174     // Whether or not all of the properties (0 or otherwise) have been set.

175     bool complete { false };
176 
177     HTTPHeaderMap requestHeaders;
178 
<span class="line-modified">179     uint32_t requestHeaderBytesSent;</span>
<span class="line-modified">180     uint32_t responseHeaderBytesReceived;</span>
181     uint64_t requestBodyBytesSent;
182     uint64_t responseBodyBytesReceived;
183     uint64_t responseBodyDecodedSize;
184 };
185 
186 #if PLATFORM(COCOA)
187 WEBCORE_EXPORT void copyTimingData(NSDictionary *timingData, NetworkLoadMetrics&amp;);
188 #endif
189 
<span class="line-removed">190 #if PLATFORM(COCOA) &amp;&amp; !HAVE(TIMINGDATAOPTIONS)</span>
<span class="line-removed">191 WEBCORE_EXPORT void setCollectsTimingData();</span>
<span class="line-removed">192 #endif</span>
<span class="line-removed">193 </span>
194 template&lt;class Encoder&gt;
195 void NetworkLoadMetrics::encode(Encoder&amp; encoder) const
196 {
197     encoder &lt;&lt; domainLookupStart;
198     encoder &lt;&lt; domainLookupEnd;
199     encoder &lt;&lt; connectStart;
200     encoder &lt;&lt; secureConnectionStart;
201     encoder &lt;&lt; connectEnd;
202     encoder &lt;&lt; requestStart;
203     encoder &lt;&lt; responseStart;
204     encoder &lt;&lt; responseEnd;
205     encoder &lt;&lt; complete;
206     encoder &lt;&lt; protocol;
207     encoder &lt;&lt; remoteAddress;
208     encoder &lt;&lt; connectionIdentifier;
<span class="line-removed">209     encoder &lt;&lt; priority;</span>
210     encoder &lt;&lt; tlsProtocol;
211     encoder &lt;&lt; tlsCipher;

212     encoder &lt;&lt; requestHeaders;
213     encoder &lt;&lt; requestHeaderBytesSent;
214     encoder &lt;&lt; requestBodyBytesSent;
215     encoder &lt;&lt; responseHeaderBytesReceived;
216     encoder &lt;&lt; responseBodyBytesReceived;
217     encoder &lt;&lt; responseBodyDecodedSize;
218 }
219 
220 template&lt;class Decoder&gt;
221 bool NetworkLoadMetrics::decode(Decoder&amp; decoder, NetworkLoadMetrics&amp; metrics)
222 {
223     return decoder.decode(metrics.domainLookupStart)
224         &amp;&amp; decoder.decode(metrics.domainLookupEnd)
225         &amp;&amp; decoder.decode(metrics.connectStart)
226         &amp;&amp; decoder.decode(metrics.secureConnectionStart)
227         &amp;&amp; decoder.decode(metrics.connectEnd)
228         &amp;&amp; decoder.decode(metrics.requestStart)
229         &amp;&amp; decoder.decode(metrics.responseStart)
230         &amp;&amp; decoder.decode(metrics.responseEnd)
231         &amp;&amp; decoder.decode(metrics.complete)
232         &amp;&amp; decoder.decode(metrics.protocol)
233         &amp;&amp; decoder.decode(metrics.remoteAddress)
234         &amp;&amp; decoder.decode(metrics.connectionIdentifier)
<span class="line-removed">235         &amp;&amp; decoder.decode(metrics.priority)</span>
236         &amp;&amp; decoder.decode(metrics.tlsProtocol)
237         &amp;&amp; decoder.decode(metrics.tlsCipher)

238         &amp;&amp; decoder.decode(metrics.requestHeaders)
239         &amp;&amp; decoder.decode(metrics.requestHeaderBytesSent)
240         &amp;&amp; decoder.decode(metrics.requestBodyBytesSent)
241         &amp;&amp; decoder.decode(metrics.responseHeaderBytesReceived)
242         &amp;&amp; decoder.decode(metrics.responseBodyBytesReceived)
243         &amp;&amp; decoder.decode(metrics.responseBodyDecodedSize);
244 }
245 
246 } // namespace WebCore
247 
248 // NetworkLoadMetrics should not be stored by the WTF::Persistence::Decoder.
249 namespace WTF {
250 namespace Persistence {
251 
252 template&lt;&gt; struct Coder&lt;Optional&lt;WebCore::NetworkLoadPriority&gt;&gt; {
253     static NO_RETURN_DUE_TO_ASSERT void encode(Encoder&amp;, const Optional&lt;WebCore::NetworkLoadPriority&gt;&amp;)
254     {
255         ASSERT_NOT_REACHED();
256     }
257 
</pre>
</td>
<td>
<hr />
<pre>
 53         reset();
 54     }
 55 
 56     NetworkLoadMetrics isolatedCopy() const
 57     {
 58         NetworkLoadMetrics copy;
 59 
 60         copy.domainLookupStart = domainLookupStart;
 61         copy.domainLookupEnd = domainLookupEnd;
 62         copy.connectStart = connectStart;
 63         copy.secureConnectionStart = secureConnectionStart;
 64         copy.connectEnd = connectEnd;
 65         copy.requestStart = requestStart;
 66         copy.responseStart = responseStart;
 67         copy.responseEnd = responseEnd;
 68         copy.complete = complete;
 69         copy.protocol = protocol.isolatedCopy();
 70 
 71         copy.remoteAddress = remoteAddress.isolatedCopy();
 72         copy.connectionIdentifier = connectionIdentifier.isolatedCopy();

 73         copy.tlsProtocol = tlsProtocol.isolatedCopy();
 74         copy.tlsCipher = tlsCipher.isolatedCopy();
<span class="line-added"> 75         copy.priority = priority;</span>
 76         copy.requestHeaders = requestHeaders.isolatedCopy();
 77 
 78         copy.requestHeaderBytesSent = requestHeaderBytesSent;
 79         copy.requestBodyBytesSent = requestBodyBytesSent;
 80         copy.responseHeaderBytesReceived = responseHeaderBytesReceived;
 81         copy.responseBodyBytesReceived = responseBodyBytesReceived;
 82         copy.responseBodyDecodedSize = responseBodyDecodedSize;
 83 
 84         return copy;
 85     }
 86 
 87     void reset()
 88     {
 89         domainLookupStart = Seconds(-1);
 90         domainLookupEnd = Seconds(-1);
 91         connectStart = Seconds(-1);
 92         secureConnectionStart = Seconds(-1);
 93         connectEnd = Seconds(-1);
 94         requestStart = Seconds(0);
 95         responseStart = Seconds(0);
 96         responseEnd = Seconds(0);
 97         complete = false;
 98         protocol = String();
 99         clearNonTimingData();
100     }
101 
102     void clearNonTimingData()
103     {
104         remoteAddress = String();
105         connectionIdentifier = String();

106         tlsProtocol = String();
107         tlsCipher = String();
<span class="line-added">108         priority = NetworkLoadPriority::Unknown;</span>
109         requestHeaders.clear();
110         requestHeaderBytesSent = std::numeric_limits&lt;uint32_t&gt;::max();
111         requestBodyBytesSent = std::numeric_limits&lt;uint64_t&gt;::max();
112         responseHeaderBytesReceived = std::numeric_limits&lt;uint32_t&gt;::max();
113         responseBodyBytesReceived = std::numeric_limits&lt;uint64_t&gt;::max();
114         responseBodyDecodedSize = std::numeric_limits&lt;uint64_t&gt;::max();
115     }
116 
117     bool operator==(const NetworkLoadMetrics&amp; other) const
118     {
119         return domainLookupStart == other.domainLookupStart
120             &amp;&amp; domainLookupEnd == other.domainLookupEnd
121             &amp;&amp; connectStart == other.connectStart
122             &amp;&amp; secureConnectionStart == other.secureConnectionStart
123             &amp;&amp; connectEnd == other.connectEnd
124             &amp;&amp; requestStart == other.requestStart
125             &amp;&amp; responseStart == other.responseStart
126             &amp;&amp; responseEnd == other.responseEnd
127             &amp;&amp; complete == other.complete
128             &amp;&amp; protocol == other.protocol
129             &amp;&amp; remoteAddress == other.remoteAddress
130             &amp;&amp; connectionIdentifier == other.connectionIdentifier

131             &amp;&amp; tlsProtocol == other.tlsProtocol
132             &amp;&amp; tlsCipher == other.tlsCipher
<span class="line-added">133             &amp;&amp; priority == other.priority</span>
134             &amp;&amp; requestHeaders == other.requestHeaders
135             &amp;&amp; requestHeaderBytesSent == other.requestHeaderBytesSent
136             &amp;&amp; requestBodyBytesSent == other.requestBodyBytesSent
137             &amp;&amp; responseHeaderBytesReceived == other.responseHeaderBytesReceived
138             &amp;&amp; responseBodyBytesReceived == other.responseBodyBytesReceived
139             &amp;&amp; responseBodyDecodedSize == other.responseBodyDecodedSize;
140     }
141 
142     bool operator!=(const NetworkLoadMetrics&amp; other) const
143     {
144         return !(*this == other);
145     }
146 
147     bool isComplete() const { return complete; }
148     void markComplete() { complete = true; }
149 
150     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
151     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, NetworkLoadMetrics&amp;);
152 
153     // These should be treated as deltas to LoadTiming&#39;s fetchStart.
154     // They should be in ascending order as listed here.
155     Seconds domainLookupStart;     // -1 if no DNS.
156     Seconds domainLookupEnd;       // -1 if no DNS.
157     Seconds connectStart;          // -1 if reused connection.
158     Seconds secureConnectionStart; // -1 if no secure connection.
159     Seconds connectEnd;            // -1 if reused connection.
160     Seconds requestStart;
161     Seconds responseStart;
162     Seconds responseEnd;
163 
164     // ALPN Protocol ID: https://w3c.github.io/resource-timing/#bib-RFC7301
165     String protocol;
166 
167     String remoteAddress;
168     String connectionIdentifier;

169 
170     String tlsProtocol;
171     String tlsCipher;
172 
173     // Whether or not all of the properties (0 or otherwise) have been set.
<span class="line-added">174     NetworkLoadPriority priority;</span>
175     bool complete { false };
176 
177     HTTPHeaderMap requestHeaders;
178 
<span class="line-modified">179     uint64_t requestHeaderBytesSent;</span>
<span class="line-modified">180     uint64_t responseHeaderBytesReceived;</span>
181     uint64_t requestBodyBytesSent;
182     uint64_t responseBodyBytesReceived;
183     uint64_t responseBodyDecodedSize;
184 };
185 
186 #if PLATFORM(COCOA)
187 WEBCORE_EXPORT void copyTimingData(NSDictionary *timingData, NetworkLoadMetrics&amp;);
188 #endif
189 




190 template&lt;class Encoder&gt;
191 void NetworkLoadMetrics::encode(Encoder&amp; encoder) const
192 {
193     encoder &lt;&lt; domainLookupStart;
194     encoder &lt;&lt; domainLookupEnd;
195     encoder &lt;&lt; connectStart;
196     encoder &lt;&lt; secureConnectionStart;
197     encoder &lt;&lt; connectEnd;
198     encoder &lt;&lt; requestStart;
199     encoder &lt;&lt; responseStart;
200     encoder &lt;&lt; responseEnd;
201     encoder &lt;&lt; complete;
202     encoder &lt;&lt; protocol;
203     encoder &lt;&lt; remoteAddress;
204     encoder &lt;&lt; connectionIdentifier;

205     encoder &lt;&lt; tlsProtocol;
206     encoder &lt;&lt; tlsCipher;
<span class="line-added">207     encoder &lt;&lt; priority;</span>
208     encoder &lt;&lt; requestHeaders;
209     encoder &lt;&lt; requestHeaderBytesSent;
210     encoder &lt;&lt; requestBodyBytesSent;
211     encoder &lt;&lt; responseHeaderBytesReceived;
212     encoder &lt;&lt; responseBodyBytesReceived;
213     encoder &lt;&lt; responseBodyDecodedSize;
214 }
215 
216 template&lt;class Decoder&gt;
217 bool NetworkLoadMetrics::decode(Decoder&amp; decoder, NetworkLoadMetrics&amp; metrics)
218 {
219     return decoder.decode(metrics.domainLookupStart)
220         &amp;&amp; decoder.decode(metrics.domainLookupEnd)
221         &amp;&amp; decoder.decode(metrics.connectStart)
222         &amp;&amp; decoder.decode(metrics.secureConnectionStart)
223         &amp;&amp; decoder.decode(metrics.connectEnd)
224         &amp;&amp; decoder.decode(metrics.requestStart)
225         &amp;&amp; decoder.decode(metrics.responseStart)
226         &amp;&amp; decoder.decode(metrics.responseEnd)
227         &amp;&amp; decoder.decode(metrics.complete)
228         &amp;&amp; decoder.decode(metrics.protocol)
229         &amp;&amp; decoder.decode(metrics.remoteAddress)
230         &amp;&amp; decoder.decode(metrics.connectionIdentifier)

231         &amp;&amp; decoder.decode(metrics.tlsProtocol)
232         &amp;&amp; decoder.decode(metrics.tlsCipher)
<span class="line-added">233         &amp;&amp; decoder.decode(metrics.priority)</span>
234         &amp;&amp; decoder.decode(metrics.requestHeaders)
235         &amp;&amp; decoder.decode(metrics.requestHeaderBytesSent)
236         &amp;&amp; decoder.decode(metrics.requestBodyBytesSent)
237         &amp;&amp; decoder.decode(metrics.responseHeaderBytesReceived)
238         &amp;&amp; decoder.decode(metrics.responseBodyBytesReceived)
239         &amp;&amp; decoder.decode(metrics.responseBodyDecodedSize);
240 }
241 
242 } // namespace WebCore
243 
244 // NetworkLoadMetrics should not be stored by the WTF::Persistence::Decoder.
245 namespace WTF {
246 namespace Persistence {
247 
248 template&lt;&gt; struct Coder&lt;Optional&lt;WebCore::NetworkLoadPriority&gt;&gt; {
249     static NO_RETURN_DUE_TO_ASSERT void encode(Encoder&amp;, const Optional&lt;WebCore::NetworkLoadPriority&gt;&amp;)
250     {
251         ASSERT_NOT_REACHED();
252     }
253 
</pre>
</td>
</tr>
</table>
<center><a href="HTTPParsers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NetworkStorageSession.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
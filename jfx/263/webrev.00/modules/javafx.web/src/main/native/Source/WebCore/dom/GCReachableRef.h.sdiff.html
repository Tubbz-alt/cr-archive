<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/GCReachableRef.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FullscreenManager.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericEventQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/GCReachableRef.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57 
 58     ~GCReachableRef()
 59     {
 60         if (m_ptr)
 61             GCReachableRefMap::remove(*m_ptr);
 62     }
 63 
 64     GCReachableRef(GCReachableRef&amp;&amp; other)
 65         : m_ptr(WTFMove(other.m_ptr))
 66     {
 67     }
 68 
 69     T* operator-&gt;() const { return &amp;get(); }
 70     T* ptr() const RETURNS_NONNULL { return &amp;get(); }
 71     T&amp; get() const { ASSERT(m_ptr); return *m_ptr; }
 72     operator T&amp;() const { return get(); }
 73     bool operator!() const { return !get(); }
 74 
 75     // Hash table deleted values, which are only constructed and never copied or destroyed.
 76     GCReachableRef(WTF::HashTableDeletedValueType)
<span class="line-modified"> 77         : m_ptr(RefPtr&lt;T&gt;::hashTableDeletedValue())</span>
 78     { }
 79     bool isHashTableDeletedValue() const { return m_ptr.isHashTableDeletedValue(); }
 80 
 81     GCReachableRef(WTF::HashTableEmptyValueType)
 82         : m_ptr(nullptr)
 83     { }
 84     bool isHashTableEmptyValue() const { return !m_ptr; }
 85 
 86     const T* ptrAllowingHashTableEmptyValue() const { ASSERT(m_ptr || isHashTableEmptyValue()); return m_ptr.get(); }
 87     T* ptrAllowingHashTableEmptyValue() { ASSERT(m_ptr || isHashTableEmptyValue()); return m_ptr.get(); }
 88 
 89     void assignToHashTableEmptyValue(GCReachableRef&amp;&amp; reference)
 90     {
 91         ASSERT(!m_ptr);
 92         m_ptr = WTFMove(reference.m_ptr);
 93         ASSERT(m_ptr);
 94     }
 95 
 96 private:
 97     RefPtr&lt;T&gt; m_ptr;
</pre>
</td>
<td>
<hr />
<pre>
 57 
 58     ~GCReachableRef()
 59     {
 60         if (m_ptr)
 61             GCReachableRefMap::remove(*m_ptr);
 62     }
 63 
 64     GCReachableRef(GCReachableRef&amp;&amp; other)
 65         : m_ptr(WTFMove(other.m_ptr))
 66     {
 67     }
 68 
 69     T* operator-&gt;() const { return &amp;get(); }
 70     T* ptr() const RETURNS_NONNULL { return &amp;get(); }
 71     T&amp; get() const { ASSERT(m_ptr); return *m_ptr; }
 72     operator T&amp;() const { return get(); }
 73     bool operator!() const { return !get(); }
 74 
 75     // Hash table deleted values, which are only constructed and never copied or destroyed.
 76     GCReachableRef(WTF::HashTableDeletedValueType)
<span class="line-modified"> 77         : m_ptr(RefPtr&lt;T&gt;::PtrTraits::hashTableDeletedValue())</span>
 78     { }
 79     bool isHashTableDeletedValue() const { return m_ptr.isHashTableDeletedValue(); }
 80 
 81     GCReachableRef(WTF::HashTableEmptyValueType)
 82         : m_ptr(nullptr)
 83     { }
 84     bool isHashTableEmptyValue() const { return !m_ptr; }
 85 
 86     const T* ptrAllowingHashTableEmptyValue() const { ASSERT(m_ptr || isHashTableEmptyValue()); return m_ptr.get(); }
 87     T* ptrAllowingHashTableEmptyValue() { ASSERT(m_ptr || isHashTableEmptyValue()); return m_ptr.get(); }
 88 
 89     void assignToHashTableEmptyValue(GCReachableRef&amp;&amp; reference)
 90     {
 91         ASSERT(!m_ptr);
 92         m_ptr = WTFMove(reference.m_ptr);
 93         ASSERT(m_ptr);
 94     }
 95 
 96 private:
 97     RefPtr&lt;T&gt; m_ptr;
</pre>
</td>
</tr>
</table>
<center><a href="FullscreenManager.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericEventQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
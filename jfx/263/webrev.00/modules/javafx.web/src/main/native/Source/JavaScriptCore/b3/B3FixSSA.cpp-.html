<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3FixSSA.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3FixSSA.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;B3BasicBlockInlines.h&quot;
 32 #include &quot;B3BreakCriticalEdges.h&quot;
 33 #include &quot;B3Dominators.h&quot;
 34 #include &quot;B3InsertionSetInlines.h&quot;
 35 #include &quot;B3PhaseScope.h&quot;
 36 #include &quot;B3ProcedureInlines.h&quot;
 37 #include &quot;B3SSACalculator.h&quot;
 38 #include &quot;B3UpsilonValue.h&quot;
 39 #include &quot;B3ValueInlines.h&quot;
 40 #include &quot;B3Variable.h&quot;
 41 #include &quot;B3VariableLiveness.h&quot;
 42 #include &quot;B3VariableValue.h&quot;
 43 #include &lt;wtf/CommaPrinter.h&gt;
 44 #include &lt;wtf/IndexSet.h&gt;
 45 #include &lt;wtf/IndexSparseSet.h&gt;
 46 
 47 namespace JSC { namespace B3 {
 48 
 49 namespace {
 50 
 51 namespace B3FixSSAInternal {
 52 static const bool verbose = false;
 53 }
 54 
 55 void killDeadVariables(Procedure&amp; proc)
 56 {
 57     IndexSet&lt;Variable*&gt; liveVariables;
 58     for (Value* value : proc.values()) {
 59         if (value-&gt;opcode() == Get)
 60             liveVariables.add(value-&gt;as&lt;VariableValue&gt;()-&gt;variable());
 61     }
 62 
 63     for (Value* value : proc.values()) {
 64         if (value-&gt;opcode() == Set &amp;&amp; !liveVariables.contains(value-&gt;as&lt;VariableValue&gt;()-&gt;variable()))
 65             value-&gt;replaceWithNop();
 66     }
 67 
 68     for (Variable* variable : proc.variables()) {
 69         if (!liveVariables.contains(variable))
 70             proc.deleteVariable(variable);
 71     }
 72 }
 73 
 74 void fixSSALocally(Procedure&amp; proc)
 75 {
 76     IndexSparseSet&lt;KeyValuePair&lt;unsigned, Value*&gt;&gt; mapping(proc.variables().size());
 77     for (BasicBlock* block : proc.blocksInPreOrder()) {
 78         mapping.clear();
 79 
 80         for (unsigned valueIndex = 0; valueIndex &lt; block-&gt;size(); ++valueIndex) {
 81             Value* value = block-&gt;at(valueIndex);
 82             value-&gt;performSubstitution();
 83 
 84             switch (value-&gt;opcode()) {
 85             case Get: {
 86                 VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;();
 87                 Variable* variable = variableValue-&gt;variable();
 88 
 89                 if (KeyValuePair&lt;unsigned, Value*&gt;* replacement = mapping.get(variable-&gt;index()))
 90                     value-&gt;replaceWithIdentity(replacement-&gt;value);
 91                 break;
 92             }
 93 
 94             case Set: {
 95                 VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;();
 96                 Variable* variable = variableValue-&gt;variable();
 97 
 98                 mapping.set(variable-&gt;index(), value-&gt;child(0));
 99                 break;
100             }
101 
102             default:
103                 break;
104             }
105         }
106     }
107 }
108 
109 void fixSSAGlobally(Procedure&amp; proc)
110 {
111     VariableLiveness liveness(proc);
112 
113     // Kill any dead Set&#39;s. Each Set creates work for us, so this is profitable.
114     for (BasicBlock* block : proc) {
115         VariableLiveness::LocalCalc localCalc(liveness, block);
116         for (unsigned valueIndex = block-&gt;size(); valueIndex--;) {
117             Value* value = block-&gt;at(valueIndex);
118             if (value-&gt;opcode() == Set &amp;&amp; !localCalc.isLive(value-&gt;as&lt;VariableValue&gt;()-&gt;variable()))
119                 value-&gt;replaceWithNop();
120             localCalc.execute(valueIndex);
121         }
122     }
123 
124     VariableLiveness::LiveAtHead liveAtHead = liveness.liveAtHead();
125 
126     SSACalculator ssa(proc);
127 
128     // Create a SSACalculator::Variable (&quot;calcVar&quot;) for every variable.
129     Vector&lt;Variable*&gt; calcVarToVariable;
130     IndexMap&lt;Variable*, SSACalculator::Variable*&gt; variableToCalcVar(proc.variables().size());
131 
132     for (Variable* variable : proc.variables()) {
133         SSACalculator::Variable* calcVar = ssa.newVariable();
134         RELEASE_ASSERT(calcVar-&gt;index() == calcVarToVariable.size());
135         calcVarToVariable.append(variable);
136         variableToCalcVar[variable] = calcVar;
137     }
138 
139     // Create Defs for all of the stores to the stack variable.
140     for (BasicBlock* block : proc) {
141         for (Value* value : *block) {
142             if (value-&gt;opcode() != Set)
143                 continue;
144 
145             Variable* variable = value-&gt;as&lt;VariableValue&gt;()-&gt;variable();
146 
147             if (SSACalculator::Variable* calcVar = variableToCalcVar[variable])
148                 ssa.newDef(calcVar, block, value-&gt;child(0));
149         }
150     }
151 
152     // Decide where Phis are to be inserted. This creates them but does not insert them.
153     {
154         TimingScope timingScope(&quot;fixSSA: computePhis&quot;);
155         ssa.computePhis(
156             [&amp;] (SSACalculator::Variable* calcVar, BasicBlock* block) -&gt; Value* {
157                 Variable* variable = calcVarToVariable[calcVar-&gt;index()];
158                 if (!liveAtHead.isLiveAtHead(block, variable))
159                     return nullptr;
160 
161                 Value* phi = proc.add&lt;Value&gt;(Phi, variable-&gt;type(), block-&gt;at(0)-&gt;origin());
162                 if (B3FixSSAInternal::verbose) {
163                     dataLog(
164                         &quot;Adding Phi for &quot;, pointerDump(variable), &quot; at &quot;, *block, &quot;: &quot;,
165                         deepDump(proc, phi), &quot;\n&quot;);
166                 }
167                 return phi;
168             });
169     }
170 
171     // Now perform the conversion.
172     TimingScope timingScope(&quot;fixSSA: convert&quot;);
173     InsertionSet insertionSet(proc);
174     IndexSparseSet&lt;KeyValuePair&lt;unsigned, Value*&gt;&gt; mapping(proc.variables().size());
175     IndexSet&lt;Value*&gt; valuesToDelete;
176     for (BasicBlock* block : proc.blocksInPreOrder()) {
177         mapping.clear();
178 
179         auto ensureMapping = [&amp;] (Variable* variable, unsigned valueIndex, Origin origin) -&gt; Value* {
180             KeyValuePair&lt;unsigned, Value*&gt;* found = mapping.get(variable-&gt;index());
181             if (found)
182                 return found-&gt;value;
183 
184             SSACalculator::Variable* calcVar = variableToCalcVar[variable];
185             SSACalculator::Def* def = ssa.reachingDefAtHead(block, calcVar);
186             if (def) {
187                 mapping.set(variable-&gt;index(), def-&gt;value());
188                 return def-&gt;value();
189             }
190 
191             return insertionSet.insertBottom(valueIndex, origin, variable-&gt;type());
192         };
193 
194         for (SSACalculator::Def* phiDef : ssa.phisForBlock(block)) {
195             Variable* variable = calcVarToVariable[phiDef-&gt;variable()-&gt;index()];
196 
197             insertionSet.insertValue(0, phiDef-&gt;value());
198             mapping.set(variable-&gt;index(), phiDef-&gt;value());
199         }
200 
201         for (unsigned valueIndex = 0; valueIndex &lt; block-&gt;size(); ++valueIndex) {
202             Value* value = block-&gt;at(valueIndex);
203             value-&gt;performSubstitution();
204 
205             switch (value-&gt;opcode()) {
206             case Get: {
207                 VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;();
208                 Variable* variable = variableValue-&gt;variable();
209 
210                 value-&gt;replaceWithIdentity(ensureMapping(variable, valueIndex, value-&gt;origin()));
211                 valuesToDelete.add(value);
212                 break;
213             }
214 
215             case Set: {
216                 VariableValue* variableValue = value-&gt;as&lt;VariableValue&gt;();
217                 Variable* variable = variableValue-&gt;variable();
218 
219                 mapping.set(variable-&gt;index(), value-&gt;child(0));
220                 value-&gt;replaceWithNop();
221                 break;
222             }
223 
224             default:
225                 break;
226             }
227         }
228 
229         unsigned upsilonInsertionPoint = block-&gt;size() - 1;
230         Origin upsilonOrigin = block-&gt;last()-&gt;origin();
231         for (BasicBlock* successorBlock : block-&gt;successorBlocks()) {
232             for (SSACalculator::Def* phiDef : ssa.phisForBlock(successorBlock)) {
233                 Value* phi = phiDef-&gt;value();
234                 SSACalculator::Variable* calcVar = phiDef-&gt;variable();
235                 Variable* variable = calcVarToVariable[calcVar-&gt;index()];
236 
237                 Value* mappedValue = ensureMapping(variable, upsilonInsertionPoint, upsilonOrigin);
238                 if (B3FixSSAInternal::verbose) {
239                     dataLog(
240                         &quot;Mapped value for &quot;, *variable, &quot; with successor Phi &quot;, *phi,
241                         &quot; at end of &quot;, *block, &quot;: &quot;, pointerDump(mappedValue), &quot;\n&quot;);
242                 }
243 
244                 insertionSet.insert&lt;UpsilonValue&gt;(
245                     upsilonInsertionPoint, upsilonOrigin, mappedValue-&gt;foldIdentity(), phi);
246             }
247         }
248 
249         insertionSet.execute(block);
250     }
251 
252     // This is isn&#39;t strictly necessary, but it leaves the IR nice and tidy, which is particularly
253     // useful for phases that do size estimates.
254     for (BasicBlock* block : proc) {
255         block-&gt;values().removeAllMatching(
256             [&amp;] (Value* value) -&gt; bool {
257                 if (!valuesToDelete.contains(value) &amp;&amp; value-&gt;opcode() != Nop)
258                     return false;
259 
260                 proc.deleteValue(value);
261                 return true;
262             });
263     }
264 
265     if (B3FixSSAInternal::verbose) {
266         dataLog(&quot;B3 after SSA conversion:\n&quot;);
267         dataLog(proc);
268     }
269 }
270 
271 } // anonymous namespace
272 
273 void demoteValues(Procedure&amp; proc, const IndexSet&lt;Value*&gt;&amp; values)
274 {
275     HashMap&lt;Value*, Variable*&gt; map;
276     HashMap&lt;Value*, Variable*&gt; phiMap;
277 
278     // Create stack slots.
279     for (Value* value : values.values(proc.values())) {
280         map.add(value, proc.addVariable(value-&gt;type()));
281 
282         if (value-&gt;opcode() == Phi)
283             phiMap.add(value, proc.addVariable(value-&gt;type()));
284     }
285 
286     if (B3FixSSAInternal::verbose) {
287         dataLog(&quot;Demoting values as follows:\n&quot;);
288         dataLog(&quot;   map = &quot;);
289         CommaPrinter comma;
290         for (auto&amp; entry : map)
291             dataLog(comma, *entry.key, &quot;=&gt;&quot;, *entry.value);
292         dataLog(&quot;\n&quot;);
293         dataLog(&quot;   phiMap = &quot;);
294         comma = CommaPrinter();
295         for (auto&amp; entry : phiMap)
296             dataLog(comma, *entry.key, &quot;=&gt;&quot;, *entry.value);
297         dataLog(&quot;\n&quot;);
298     }
299 
300     // Change accesses to the values to accesses to the stack slots.
301     InsertionSet insertionSet(proc);
302     for (BasicBlock* block : proc) {
303         if (block-&gt;numPredecessors()) {
304             // Deal with terminals that produce values (i.e. patchpoint terminals, like the ones we
305             // generate for the allocation fast path).
306             Value* value = block-&gt;predecessor(0)-&gt;last();
307             Variable* variable = map.get(value);
308             if (variable) {
309                 RELEASE_ASSERT(block-&gt;numPredecessors() == 1); // Critical edges better be broken.
310                 insertionSet.insert&lt;VariableValue&gt;(0, Set, value-&gt;origin(), variable, value);
311             }
312         }
313 
314         for (unsigned valueIndex = 0; valueIndex &lt; block-&gt;size(); ++valueIndex) {
315             Value* value = block-&gt;at(valueIndex);
316 
317             if (value-&gt;opcode() == Phi) {
318                 if (Variable* variable = phiMap.get(value)) {
319                     value-&gt;replaceWithIdentity(
320                         insertionSet.insert&lt;VariableValue&gt;(
321                             valueIndex, Get, value-&gt;origin(), variable));
322                 }
323             } else {
324                 for (Value*&amp; child : value-&gt;children()) {
325                     if (Variable* variable = map.get(child)) {
326                         child = insertionSet.insert&lt;VariableValue&gt;(
327                             valueIndex, Get, value-&gt;origin(), variable);
328                     }
329                 }
330 
331                 if (UpsilonValue* upsilon = value-&gt;as&lt;UpsilonValue&gt;()) {
332                     if (Variable* variable = phiMap.get(upsilon-&gt;phi())) {
333                         insertionSet.insert&lt;VariableValue&gt;(
334                             valueIndex, Set, upsilon-&gt;origin(), variable, upsilon-&gt;child(0));
335                         value-&gt;replaceWithNop();
336                     }
337                 }
338             }
339 
340             if (Variable* variable = map.get(value)) {
341                 if (valueIndex + 1 &lt; block-&gt;size()) {
342                     insertionSet.insert&lt;VariableValue&gt;(
343                         valueIndex + 1, Set, value-&gt;origin(), variable, value);
344                 }
345             }
346         }
347         insertionSet.execute(block);
348     }
349 }
350 
351 bool fixSSA(Procedure&amp; proc)
352 {
353     PhaseScope phaseScope(proc, &quot;fixSSA&quot;);
354 
355     if (proc.variables().isEmpty())
356         return false;
357 
358     // Lots of variables have trivial local liveness. We can allocate those without any
359     // trouble.
360     fixSSALocally(proc);
361 
362     // Just for sanity, remove any unused variables first. It&#39;s unlikely that this code has any
363     // bugs having to do with dead variables, but it would be silly to have to fix such a bug if
364     // it did arise.
365     killDeadVariables(proc);
366 
367     if (proc.variables().isEmpty())
368         return false;
369 
370     breakCriticalEdges(proc);
371 
372     fixSSAGlobally(proc);
373 
374     return true;
375 }
376 
377 } } // namespace JSC::B3
378 
379 #endif // ENABLE(B3_JIT)
380 
    </pre>
  </body>
</html>
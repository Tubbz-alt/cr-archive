<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;UnlinkedCodeBlock.h&quot;
 29 
 30 #include &quot;BytecodeGenerator.h&quot;
 31 #include &quot;BytecodeLivenessAnalysis.h&quot;
 32 #include &quot;BytecodeRewriter.h&quot;
 33 #include &quot;ClassInfo.h&quot;
 34 #include &quot;CodeCache.h&quot;
 35 #include &quot;ExecutableInfo.h&quot;
 36 #include &quot;FunctionOverrides.h&quot;
 37 #include &quot;InstructionStream.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;JSString.h&quot;
 40 #include &quot;Opcode.h&quot;
 41 #include &quot;Parser.h&quot;
 42 #include &quot;PreciseJumpTargetsInlines.h&quot;
 43 #include &quot;SourceProvider.h&quot;
 44 #include &quot;Structure.h&quot;
 45 #include &quot;SymbolTable.h&quot;
 46 #include &quot;UnlinkedEvalCodeBlock.h&quot;
 47 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 48 #include &quot;UnlinkedMetadataTableInlines.h&quot;
 49 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 50 #include &quot;UnlinkedProgramCodeBlock.h&quot;
 51 #include &lt;wtf/DataLog.h&gt;
 52 
 53 namespace JSC {
 54 
 55 const ClassInfo UnlinkedCodeBlock::s_info = { &quot;UnlinkedCodeBlock&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedCodeBlock) };
 56 
 57 UnlinkedCodeBlock::UnlinkedCodeBlock(VM&amp; vm, Structure* structure, CodeType codeType, const ExecutableInfo&amp; info, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
 58     : Base(vm, structure)
 59     , m_usesEval(info.usesEval())
 60     , m_isStrictMode(info.isStrictMode())
 61     , m_isConstructor(info.isConstructor())
 62     , m_hasCapturedVariables(false)
 63     , m_isBuiltinFunction(info.isBuiltinFunction())
 64     , m_superBinding(static_cast&lt;unsigned&gt;(info.superBinding()))
 65     , m_scriptMode(static_cast&lt;unsigned&gt;(info.scriptMode()))
 66     , m_isArrowFunctionContext(info.isArrowFunctionContext())
 67     , m_isClassContext(info.isClassContext())
 68     , m_hasTailCalls(false)
 69     , m_constructorKind(static_cast&lt;unsigned&gt;(info.constructorKind()))
 70     , m_derivedContextType(static_cast&lt;unsigned&gt;(info.derivedContextType()))
 71     , m_evalContextType(static_cast&lt;unsigned&gt;(info.evalContextType()))
 72     , m_codeType(static_cast&lt;unsigned&gt;(codeType))
 73     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
 74     , m_age(0)
 75     , m_hasCheckpoints(false)
 76     , m_parseMode(info.parseMode())
 77     , m_codeGenerationMode(codeGenerationMode)
 78     , m_metadata(UnlinkedMetadataTable::create())
 79 {
 80     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(info.constructorKind()));
 81     ASSERT(m_codeType == static_cast&lt;unsigned&gt;(codeType));
 82     ASSERT(m_didOptimize == static_cast&lt;unsigned&gt;(MixedTriState));
 83     if (info.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {
 84         createRareDataIfNecessary(holdLock(cellLock()));
 85         m_rareData-&gt;m_needsClassFieldInitializer = static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::Yes);
 86     }
 87 }
 88 
 89 void UnlinkedCodeBlock::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 90 {
 91     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
 92     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 93     Base::visitChildren(thisObject, visitor);
 94     auto locker = holdLock(thisObject-&gt;cellLock());
 95     if (visitor.isFirstVisit())
 96         thisObject-&gt;m_age = std::min&lt;unsigned&gt;(static_cast&lt;unsigned&gt;(thisObject-&gt;m_age) + 1, maxAge);
 97     for (auto&amp; barrier : thisObject-&gt;m_functionDecls)
 98         visitor.append(barrier);
 99     for (auto&amp; barrier : thisObject-&gt;m_functionExprs)
100         visitor.append(barrier);
101     visitor.appendValues(thisObject-&gt;m_constantRegisters.data(), thisObject-&gt;m_constantRegisters.size());
102     size_t extraMemory = thisObject-&gt;m_metadata-&gt;sizeInBytes();
103     if (thisObject-&gt;m_instructions)
104         extraMemory += thisObject-&gt;m_instructions-&gt;sizeInBytes();
105     visitor.reportExtraMemoryVisited(extraMemory);
106 }
107 
108 size_t UnlinkedCodeBlock::estimatedSize(JSCell* cell, VM&amp; vm)
109 {
110     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
111     size_t extraSize = thisObject-&gt;m_metadata-&gt;sizeInBytes();
112     if (thisObject-&gt;m_instructions)
113         extraSize += thisObject-&gt;m_instructions-&gt;sizeInBytes();
114     return Base::estimatedSize(cell, vm) + extraSize;
115 }
116 
117 int UnlinkedCodeBlock::lineNumberForBytecodeIndex(BytecodeIndex bytecodeIndex)
118 {
119     ASSERT(bytecodeIndex.offset() &lt; instructions().size());
120     int divot { 0 };
121     int startOffset { 0 };
122     int endOffset { 0 };
123     unsigned line { 0 };
124     unsigned column { 0 };
125     expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset, line, column);
126     return line;
127 }
128 
129 inline void UnlinkedCodeBlock::getLineAndColumn(const ExpressionRangeInfo&amp; info,
130     unsigned&amp; line, unsigned&amp; column) const
131 {
132     switch (info.mode) {
133     case ExpressionRangeInfo::FatLineMode:
134         info.decodeFatLineMode(line, column);
135         break;
136     case ExpressionRangeInfo::FatColumnMode:
137         info.decodeFatColumnMode(line, column);
138         break;
139     case ExpressionRangeInfo::FatLineAndColumnMode: {
140         unsigned fatIndex = info.position;
141         ExpressionRangeInfo::FatPosition&amp; fatPos = m_rareData-&gt;m_expressionInfoFatPositions[fatIndex];
142         line = fatPos.line;
143         column = fatPos.column;
144         break;
145     }
146     } // switch
147 }
148 
149 #ifndef NDEBUG
150 static void dumpLineColumnEntry(size_t index, const InstructionStream&amp; instructionStream, unsigned instructionOffset, unsigned line, unsigned column)
151 {
152     const auto instruction = instructionStream.at(instructionOffset);
153     const char* event = &quot;&quot;;
154     if (instruction-&gt;is&lt;OpDebug&gt;()) {
155         switch (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType) {
156         case WillExecuteProgram: event = &quot; WillExecuteProgram&quot;; break;
157         case DidExecuteProgram: event = &quot; DidExecuteProgram&quot;; break;
158         case DidEnterCallFrame: event = &quot; DidEnterCallFrame&quot;; break;
159         case DidReachDebuggerStatement: event = &quot; DidReachDebuggerStatement&quot;; break;
160         case WillLeaveCallFrame: event = &quot; WillLeaveCallFrame&quot;; break;
161         case WillExecuteStatement: event = &quot; WillExecuteStatement&quot;; break;
162         case WillExecuteExpression: event = &quot; WillExecuteExpression&quot;; break;
163         }
164     }
165     dataLogF(&quot;  [%zu] pc %u @ line %u col %u : %s%s\n&quot;, index, instructionOffset, line, column, instruction-&gt;name(), event);
166 }
167 
168 void UnlinkedCodeBlock::dumpExpressionRangeInfo()
169 {
170     RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;
171 
172     size_t size = m_expressionInfo.size();
173     dataLogF(&quot;UnlinkedCodeBlock %p expressionRangeInfo[%zu] {\n&quot;, this, size);
174     for (size_t i = 0; i &lt; size; i++) {
175         ExpressionRangeInfo&amp; info = expressionInfo[i];
176         unsigned line;
177         unsigned column;
178         getLineAndColumn(info, line, column);
179         dumpLineColumnEntry(i, instructions(), info.instructionOffset, line, column);
180     }
181     dataLog(&quot;}\n&quot;);
182 }
183 #endif
184 
185 void UnlinkedCodeBlock::expressionRangeForBytecodeIndex(BytecodeIndex bytecodeIndex,
186     int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
187 {
188     ASSERT(bytecodeIndex.offset() &lt; instructions().size());
189 
190     if (!m_expressionInfo.size()) {
191         startOffset = 0;
192         endOffset = 0;
193         divot = 0;
194         line = 0;
195         column = 0;
196         return;
197     }
198 
199     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;
200 
201     int low = 0;
202     int high = expressionInfo.size();
203     while (low &lt; high) {
204         int mid = low + (high - low) / 2;
205         if (expressionInfo[mid].instructionOffset &lt;= bytecodeIndex.offset())
206             low = mid + 1;
207         else
208             high = mid;
209     }
210 
211     if (!low)
212         low = 1;
213 
214     const ExpressionRangeInfo&amp; info = expressionInfo[low - 1];
215     startOffset = info.startOffset;
216     endOffset = info.endOffset;
217     divot = info.divotPoint;
218     getLineAndColumn(info, line, column);
219 }
220 
221 bool UnlinkedCodeBlock::typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot)
222 {
223     static constexpr bool verbose = false;
224     if (!m_rareData) {
225         if (verbose)
226             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
227         startDivot = UINT_MAX;
228         endDivot = UINT_MAX;
229         return false;
230     }
231 
232     auto iter = m_rareData-&gt;m_typeProfilerInfoMap.find(bytecodeOffset);
233     if (iter == m_rareData-&gt;m_typeProfilerInfoMap.end()) {
234         if (verbose)
235             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
236         startDivot = UINT_MAX;
237         endDivot = UINT_MAX;
238         return false;
239     }
240 
241     RareData::TypeProfilerExpressionRange&amp; range = iter-&gt;value;
242     startDivot = range.m_startDivot;
243     endDivot = range.m_endDivot;
244     return true;
245 }
246 
247 UnlinkedCodeBlock::~UnlinkedCodeBlock()
248 {
249 }
250 
251 const InstructionStream&amp; UnlinkedCodeBlock::instructions() const
252 {
253     ASSERT(m_instructions.get());
254     return *m_instructions;
255 }
256 
257 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeIndex(BytecodeIndex bytecodeIndex, RequiredHandler requiredHandler)
258 {
259     return handlerForIndex(bytecodeIndex.offset(), requiredHandler);
260 }
261 
262 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
263 {
264     if (!m_rareData)
265         return nullptr;
266     return UnlinkedHandlerInfo::handlerForIndex&lt;UnlinkedHandlerInfo&gt;(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);
267 }
268 
269 void UnlinkedCodeBlock::dump(PrintStream&amp;) const
270 {
271 }
272 
273 BytecodeLivenessAnalysis&amp; UnlinkedCodeBlock::livenessAnalysisSlow(CodeBlock* codeBlock)
274 {
275     RELEASE_ASSERT(codeBlock-&gt;unlinkedCodeBlock() == this);
276 
277     {
278         ConcurrentJSLocker locker(m_lock);
279         if (!m_liveness) {
280             // There is a chance two compiler threads raced to the slow path.
281             // Grabbing the lock above defends against computing liveness twice.
282             m_liveness = makeUnique&lt;BytecodeLivenessAnalysis&gt;(codeBlock);
283         }
284     }
285 
286     return *m_liveness;
287 }
288 
289 int UnlinkedCodeBlock::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
290 {
291     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
292     return m_outOfLineJumpTargets.get(bytecodeOffset);
293 }
294 
295 } // namespace JSC
    </pre>
  </body>
</html>
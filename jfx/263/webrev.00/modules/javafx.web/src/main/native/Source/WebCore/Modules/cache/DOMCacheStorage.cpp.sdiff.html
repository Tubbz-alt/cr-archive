<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMCacheEngine.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DOMCacheStorage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCacheStorage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCacheStorage.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;
 30 #include &quot;ClientOrigin.h&quot;

 31 #include &quot;JSDOMCache.h&quot;
 32 #include &quot;JSFetchResponse.h&quot;
 33 #include &quot;ScriptExecutionContext.h&quot;
 34 
<span class="line-removed"> 35 </span>
 36 namespace WebCore {
 37 using namespace WebCore::DOMCacheEngine;
 38 
 39 DOMCacheStorage::DOMCacheStorage(ScriptExecutionContext&amp; context, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 40     : ActiveDOMObject(&amp;context)
 41     , m_connection(WTFMove(connection))
 42 {
 43     suspendIfNeeded();
 44 }
 45 


 46 Optional&lt;ClientOrigin&gt; DOMCacheStorage::origin() const
 47 {
 48     auto* origin = scriptExecutionContext() ? scriptExecutionContext()-&gt;securityOrigin() : nullptr;
 49     if (!origin)
 50         return WTF::nullopt;
 51 
 52     return ClientOrigin { scriptExecutionContext()-&gt;topOrigin().data(), origin-&gt;data() };
 53 }
 54 
 55 static void doSequentialMatch(size_t index, Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 56 {
 57     if (index &gt;= caches.size()) {
 58         completionHandler(nullptr);
 59         return;
 60     }
 61 
 62     auto&amp; cache = caches[index].get();
<span class="line-modified"> 63     cache.doMatch(WTFMove(info), WTFMove(options), [caches = WTFMove(caches), info, options, completionHandler = WTFMove(completionHandler), index](ExceptionOr&lt;FetchResponse*&gt;&amp;&amp; result) mutable {</span>
 64         if (result.hasException()) {
 65             completionHandler(result.releaseException());
 66             return;
 67         }
 68         if (result.returnValue()) {
<span class="line-modified"> 69             completionHandler(result.returnValue());</span>
 70             return;
 71         }
 72         doSequentialMatch(++index, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 73     });
 74 }
 75 
 76 static inline void startSequentialMatch(Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 77 {
 78     doSequentialMatch(0, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 79 }
 80 
 81 static inline Ref&lt;DOMCache&gt; copyCache(const Ref&lt;DOMCache&gt;&amp; cache)
 82 {
 83     return cache.copyRef();
 84 }
 85 
 86 void DOMCacheStorage::doSequentialMatch(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 87 {
<span class="line-modified"> 88     startSequentialMatch(WTF::map(m_caches, copyCache), WTFMove(info), WTFMove(options), [this, pendingActivity = makePendingActivity(*this), promise = WTFMove(promise)](ExceptionOr&lt;FetchResponse*&gt;&amp;&amp; result) mutable {</span>
<span class="line-removed"> 89         if (m_isStopped)</span>
<span class="line-removed"> 90             return;</span>
 91         if (result.hasException()) {
 92             promise-&gt;reject(result.releaseException());
 93             return;
 94         }
 95         if (!result.returnValue()) {
 96             promise-&gt;resolve();
 97             return;
 98         }
 99         promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());
100     });
101 }
102 
103 void DOMCacheStorage::match(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
104 {
105     retrieveCaches([this, info = WTFMove(info), options = WTFMove(options), promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
106         if (exception) {
<span class="line-modified">107             promise-&gt;reject(WTFMove(exception.value()));</span>
108             return;
109         }
110 
111         if (!options.cacheName.isNull()) {
112             auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == options.cacheName; });
113             if (position != notFound) {
114                 m_caches[position]-&gt;match(WTFMove(info), WTFMove(options), WTFMove(promise));
115                 return;
116             }
117             promise-&gt;resolve();
118             return;
119         }
120 
121         this-&gt;doSequentialMatch(WTFMove(info), WTFMove(options), WTFMove(promise));
122     });
123 }
124 
125 void DOMCacheStorage::has(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
126 {
127     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
128         if (exception) {
129             promise.reject(WTFMove(exception.value()));
130             return;
131         }
132         promise.resolve(m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; }) != notFound);
133     });
134 }
135 
136 Ref&lt;DOMCache&gt; DOMCacheStorage::findCacheOrCreate(CacheInfo&amp;&amp; info)
137 {
138    auto position = m_caches.findMatching([&amp;] (const auto&amp; cache) { return info.identifier == cache-&gt;identifier(); });
139    if (position != notFound)
140        return m_caches[position].copyRef();
141    return DOMCache::create(*scriptExecutionContext(), WTFMove(info.name), info.identifier, m_connection.copyRef());
142 }
143 
<span class="line-modified">144 void DOMCacheStorage::retrieveCaches(WTF::Function&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
145 {
146     auto origin = this-&gt;origin();
<span class="line-modified">147     if (!origin)</span>

148         return;

149 
150     m_connection-&gt;retrieveCaches(*origin, m_updateCounter, [this, callback = WTFMove(callback), pendingActivity = makePendingActivity(*this)](CacheInfosOrError&amp;&amp; result) mutable {
<span class="line-modified">151         if (!m_isStopped) {</span>
<span class="line-modified">152             if (!result.has_value()) {</span>
<span class="line-modified">153                 callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">154                 return;</span>
<span class="line-modified">155             }</span>



156 
<span class="line-modified">157             auto&amp; cachesInfo = result.value();</span>
158 
<span class="line-modified">159             if (m_updateCounter != cachesInfo.updateCounter) {</span>
<span class="line-modified">160                 m_updateCounter = cachesInfo.updateCounter;</span>
161 
<span class="line-modified">162                 m_caches = WTF::map(WTFMove(cachesInfo.infos), [this] (CacheInfo&amp;&amp; info) {</span>
<span class="line-modified">163                     return findCacheOrCreate(WTFMove(info));</span>
<span class="line-modified">164                 });</span>
<span class="line-removed">165             }</span>
<span class="line-removed">166             callback(WTF::nullopt);</span>
167         }

168     });
169 }
170 
171 static void logConsolePersistencyError(ScriptExecutionContext* context, const String&amp; cacheName)
172 {
173     if (!context)
174         return;
175 
176     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, makeString(&quot;There was an error making &quot;, cacheName, &quot; persistent on the filesystem&quot;));
177 }
178 
179 void DOMCacheStorage::open(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
180 {
181     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
182         if (exception) {
<span class="line-modified">183             promise.reject(WTFMove(exception.value()));</span>
184             return;
185         }
186         doOpen(name, WTFMove(promise));
187     });
188 }
189 
190 void DOMCacheStorage::doOpen(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
191 {
192     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
193     if (position != notFound) {
<span class="line-modified">194         auto&amp; cache = m_caches[position];</span>
<span class="line-removed">195         promise.resolve(DOMCache::create(*scriptExecutionContext(), String { cache-&gt;name() }, cache-&gt;identifier(), m_connection.copyRef()));</span>
196         return;
197     }
198 
199     m_connection-&gt;open(*origin(), name, [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<span class="line-modified">200         if (!m_isStopped) {</span>
<span class="line-modified">201             if (!result.has_value())</span>
<span class="line-modified">202                 promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">203             else {</span>
<span class="line-modified">204                 if (result.value().hadStorageError)</span>
<span class="line-modified">205                     logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-modified">206 </span>
<span class="line-modified">207                 auto cache = DOMCache::create(*scriptExecutionContext(), String { name }, result.value().identifier, m_connection.copyRef());</span>
<span class="line-modified">208                 promise.resolve(cache);</span>
<span class="line-removed">209                 m_caches.append(WTFMove(cache));</span>
<span class="line-removed">210             }</span>
211         }
212     });
213 }
214 
215 void DOMCacheStorage::remove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
216 {
217     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
218         if (exception) {
<span class="line-modified">219             promise.reject(WTFMove(exception.value()));</span>
220             return;
221         }
222         doRemove(name, WTFMove(promise));
223     });
224 }
225 
226 void DOMCacheStorage::doRemove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
227 {
228     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
229     if (position == notFound) {
230         promise.resolve(false);
231         return;
232     }
233 
234     m_connection-&gt;remove(m_caches[position]-&gt;identifier(), [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<span class="line-modified">235         if (!m_isStopped) {</span>
<span class="line-modified">236             if (!result.has_value())</span>
<span class="line-modified">237                 promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">238             else {</span>
<span class="line-modified">239                 if (result.value().hadStorageError)</span>
<span class="line-modified">240                     logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-removed">241                 promise.resolve(!!result.value().identifier);</span>
<span class="line-removed">242             }</span>
243         }
244     });
245 }
246 
247 void DOMCacheStorage::keys(KeysPromise&amp;&amp; promise)
248 {
249     retrieveCaches([this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
250         if (exception) {
251             promise.reject(WTFMove(exception.value()));
252             return;
253         }
254 
255         promise.resolve(WTF::map(m_caches, [] (const auto&amp; cache) {
256             return cache-&gt;name();
257         }));
258     });
259 }
260 
261 void DOMCacheStorage::stop()
262 {
263     m_isStopped = true;
264 }
265 
266 const char* DOMCacheStorage::activeDOMObjectName() const
267 {
268     return &quot;CacheStorage&quot;;
269 }
270 
<span class="line-removed">271 bool DOMCacheStorage::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">272 {</span>
<span class="line-removed">273     return !hasPendingActivity();</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCacheStorage.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;
 30 #include &quot;ClientOrigin.h&quot;
<span class="line-added"> 31 #include &quot;EventLoop.h&quot;</span>
 32 #include &quot;JSDOMCache.h&quot;
 33 #include &quot;JSFetchResponse.h&quot;
 34 #include &quot;ScriptExecutionContext.h&quot;
 35 

 36 namespace WebCore {
 37 using namespace WebCore::DOMCacheEngine;
 38 
 39 DOMCacheStorage::DOMCacheStorage(ScriptExecutionContext&amp; context, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 40     : ActiveDOMObject(&amp;context)
 41     , m_connection(WTFMove(connection))
 42 {
 43     suspendIfNeeded();
 44 }
 45 
<span class="line-added"> 46 DOMCacheStorage::~DOMCacheStorage() = default;</span>
<span class="line-added"> 47 </span>
 48 Optional&lt;ClientOrigin&gt; DOMCacheStorage::origin() const
 49 {
 50     auto* origin = scriptExecutionContext() ? scriptExecutionContext()-&gt;securityOrigin() : nullptr;
 51     if (!origin)
 52         return WTF::nullopt;
 53 
 54     return ClientOrigin { scriptExecutionContext()-&gt;topOrigin().data(), origin-&gt;data() };
 55 }
 56 
 57 static void doSequentialMatch(size_t index, Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 58 {
 59     if (index &gt;= caches.size()) {
 60         completionHandler(nullptr);
 61         return;
 62     }
 63 
 64     auto&amp; cache = caches[index].get();
<span class="line-modified"> 65     cache.doMatch(WTFMove(info), WTFMove(options), [caches = WTFMove(caches), info, options, completionHandler = WTFMove(completionHandler), index](auto&amp;&amp; result) mutable {</span>
 66         if (result.hasException()) {
 67             completionHandler(result.releaseException());
 68             return;
 69         }
 70         if (result.returnValue()) {
<span class="line-modified"> 71             completionHandler(result.releaseReturnValue());</span>
 72             return;
 73         }
 74         doSequentialMatch(++index, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 75     });
 76 }
 77 
 78 static inline void startSequentialMatch(Vector&lt;Ref&lt;DOMCache&gt;&gt;&amp;&amp; caches, DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMCache::MatchCallback&amp;&amp; completionHandler)
 79 {
 80     doSequentialMatch(0, WTFMove(caches), WTFMove(info), WTFMove(options), WTFMove(completionHandler));
 81 }
 82 
 83 static inline Ref&lt;DOMCache&gt; copyCache(const Ref&lt;DOMCache&gt;&amp; cache)
 84 {
 85     return cache.copyRef();
 86 }
 87 
 88 void DOMCacheStorage::doSequentialMatch(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 89 {
<span class="line-modified"> 90     startSequentialMatch(WTF::map(m_caches, copyCache), WTFMove(info), WTFMove(options), [pendingActivity = makePendingActivity(*this), promise = WTFMove(promise)](auto&amp;&amp; result) mutable {</span>


 91         if (result.hasException()) {
 92             promise-&gt;reject(result.releaseException());
 93             return;
 94         }
 95         if (!result.returnValue()) {
 96             promise-&gt;resolve();
 97             return;
 98         }
 99         promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());
100     });
101 }
102 
103 void DOMCacheStorage::match(DOMCache::RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
104 {
105     retrieveCaches([this, info = WTFMove(info), options = WTFMove(options), promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
106         if (exception) {
<span class="line-modified">107             promise-&gt;reject(WTFMove(*exception));</span>
108             return;
109         }
110 
111         if (!options.cacheName.isNull()) {
112             auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == options.cacheName; });
113             if (position != notFound) {
114                 m_caches[position]-&gt;match(WTFMove(info), WTFMove(options), WTFMove(promise));
115                 return;
116             }
117             promise-&gt;resolve();
118             return;
119         }
120 
121         this-&gt;doSequentialMatch(WTFMove(info), WTFMove(options), WTFMove(promise));
122     });
123 }
124 
125 void DOMCacheStorage::has(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
126 {
127     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
128         if (exception) {
129             promise.reject(WTFMove(exception.value()));
130             return;
131         }
132         promise.resolve(m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; }) != notFound);
133     });
134 }
135 
136 Ref&lt;DOMCache&gt; DOMCacheStorage::findCacheOrCreate(CacheInfo&amp;&amp; info)
137 {
138    auto position = m_caches.findMatching([&amp;] (const auto&amp; cache) { return info.identifier == cache-&gt;identifier(); });
139    if (position != notFound)
140        return m_caches[position].copyRef();
141    return DOMCache::create(*scriptExecutionContext(), WTFMove(info.name), info.identifier, m_connection.copyRef());
142 }
143 
<span class="line-modified">144 void DOMCacheStorage::retrieveCaches(CompletionHandler&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
145 {
146     auto origin = this-&gt;origin();
<span class="line-modified">147     if (!origin) {</span>
<span class="line-added">148         callback(convertToExceptionAndLog(scriptExecutionContext(), DOMCacheEngine::Error::Stopped));</span>
149         return;
<span class="line-added">150     }</span>
151 
152     m_connection-&gt;retrieveCaches(*origin, m_updateCounter, [this, callback = WTFMove(callback), pendingActivity = makePendingActivity(*this)](CacheInfosOrError&amp;&amp; result) mutable {
<span class="line-modified">153         if (m_isStopped) {</span>
<span class="line-modified">154             callback(DOMCacheEngine::convertToException(DOMCacheEngine::Error::Stopped));</span>
<span class="line-modified">155             return;</span>
<span class="line-modified">156         }</span>
<span class="line-modified">157         if (!result.has_value()) {</span>
<span class="line-added">158             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-added">159             return;</span>
<span class="line-added">160         }</span>
161 
<span class="line-modified">162         auto&amp; cachesInfo = result.value();</span>
163 
<span class="line-modified">164         if (m_updateCounter != cachesInfo.updateCounter) {</span>
<span class="line-modified">165             m_updateCounter = cachesInfo.updateCounter;</span>
166 
<span class="line-modified">167             m_caches = WTF::map(WTFMove(cachesInfo.infos), [this] (CacheInfo&amp;&amp; info) {</span>
<span class="line-modified">168                 return findCacheOrCreate(WTFMove(info));</span>
<span class="line-modified">169             });</span>


170         }
<span class="line-added">171         callback(WTF::nullopt);</span>
172     });
173 }
174 
175 static void logConsolePersistencyError(ScriptExecutionContext* context, const String&amp; cacheName)
176 {
177     if (!context)
178         return;
179 
180     context-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, makeString(&quot;There was an error making &quot;, cacheName, &quot; persistent on the filesystem&quot;));
181 }
182 
183 void DOMCacheStorage::open(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
184 {
185     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
186         if (exception) {
<span class="line-modified">187             promise.reject(WTFMove(*exception));</span>
188             return;
189         }
190         doOpen(name, WTFMove(promise));
191     });
192 }
193 
194 void DOMCacheStorage::doOpen(const String&amp; name, DOMPromiseDeferred&lt;IDLInterface&lt;DOMCache&gt;&gt;&amp;&amp; promise)
195 {
196     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
197     if (position != notFound) {
<span class="line-modified">198         promise.resolve(DOMCache::create(*scriptExecutionContext(), String { m_caches[position]-&gt;name() }, m_caches[position]-&gt;identifier(), m_connection.copyRef()));</span>

199         return;
200     }
201 
202     m_connection-&gt;open(*origin(), name, [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<span class="line-modified">203         if (!result.has_value())</span>
<span class="line-modified">204             promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">205         else {</span>
<span class="line-modified">206             if (result.value().hadStorageError)</span>
<span class="line-modified">207                 logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-modified">208 </span>
<span class="line-modified">209             auto cache = DOMCache::create(*scriptExecutionContext(), String { name }, result.value().identifier, m_connection.copyRef());</span>
<span class="line-modified">210             promise.resolve(cache);</span>
<span class="line-modified">211             m_caches.append(WTFMove(cache));</span>


212         }
213     });
214 }
215 
216 void DOMCacheStorage::remove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
217 {
218     retrieveCaches([this, name, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
219         if (exception) {
<span class="line-modified">220             promise.reject(WTFMove(*exception));</span>
221             return;
222         }
223         doRemove(name, WTFMove(promise));
224     });
225 }
226 
227 void DOMCacheStorage::doRemove(const String&amp; name, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
228 {
229     auto position = m_caches.findMatching([&amp;](auto&amp; item) { return item-&gt;name() == name; });
230     if (position == notFound) {
231         promise.resolve(false);
232         return;
233     }
234 
235     m_connection-&gt;remove(m_caches[position]-&gt;identifier(), [this, name, promise = WTFMove(promise), pendingActivity = makePendingActivity(*this)](const CacheIdentifierOrError&amp; result) mutable {
<span class="line-modified">236         if (!result.has_value())</span>
<span class="line-modified">237             promise.reject(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));</span>
<span class="line-modified">238         else {</span>
<span class="line-modified">239             if (result.value().hadStorageError)</span>
<span class="line-modified">240                 logConsolePersistencyError(scriptExecutionContext(), name);</span>
<span class="line-modified">241             promise.resolve(!!result.value().identifier);</span>


242         }
243     });
244 }
245 
246 void DOMCacheStorage::keys(KeysPromise&amp;&amp; promise)
247 {
248     retrieveCaches([this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
249         if (exception) {
250             promise.reject(WTFMove(exception.value()));
251             return;
252         }
253 
254         promise.resolve(WTF::map(m_caches, [] (const auto&amp; cache) {
255             return cache-&gt;name();
256         }));
257     });
258 }
259 
260 void DOMCacheStorage::stop()
261 {
262     m_isStopped = true;
263 }
264 
265 const char* DOMCacheStorage::activeDOMObjectName() const
266 {
267     return &quot;CacheStorage&quot;;
268 }
269 





270 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DOMCacheEngine.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DOMCacheStorage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
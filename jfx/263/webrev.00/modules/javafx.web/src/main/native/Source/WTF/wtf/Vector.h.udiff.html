<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Variant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  *  Copyright (C) 2005-2017 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -44,10 +44,12 @@</span>
  class LLIntOffsetsExtractor;
  }
  
  namespace WTF {
  
<span class="udiff-line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Vector);</span>
<span class="udiff-line-added">+ </span>
  template &lt;bool needsDestruction, typename T&gt;
  struct VectorDestructor;
  
  template&lt;typename T&gt;
  struct VectorDestructor&lt;false, T&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -202,14 +204,11 @@</span>
  struct VectorFiller&lt;true, T&gt;
  {
      static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
      {
          static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
<span class="udiff-line-modified-removed">- #if COMPILER(GCC_COMPATIBLE) &amp;&amp; defined(_FORTIFY_SOURCE)</span>
<span class="udiff-line-removed">-         if (!__builtin_constant_p(dstEnd - dst) || (!(dstEnd - dst)))</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-             memset(dst, val, dstEnd - dst);</span>
<span class="udiff-line-modified-added">+         memset(dst, val, dstEnd - dst);</span>
      }
  };
  
  template&lt;bool canCompareWithMemcmp, typename T&gt;
  struct VectorComparer;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,38 +276,37 @@</span>
      {
          return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
      }
  };
  
<span class="udiff-line-modified-removed">- template&lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, typename Malloc&gt;</span>
  class VectorBufferBase {
      WTF_MAKE_NONCOPYABLE(VectorBufferBase);
  public:
      void allocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="udiff-line-modified-removed">-         m_buffer = static_cast&lt;T*&gt;(fastMalloc(sizeToAllocate));</span>
<span class="udiff-line-modified-added">+         m_buffer = static_cast&lt;T*&gt;(Malloc::malloc(sizeToAllocate));</span>
      }
  
      bool tryAllocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              return false;
  
          size_t sizeToAllocate = newCapacity * sizeof(T);
<span class="udiff-line-modified-removed">-         T* newBuffer;</span>
<span class="udiff-line-modified-removed">-         if (tryFastMalloc(sizeToAllocate).getValue(newBuffer)) {</span>
<span class="udiff-line-modified-removed">-             m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="udiff-line-modified-removed">-             m_buffer = newBuffer;</span>
<span class="udiff-line-modified-removed">-             return true;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-modified-added">+         T* newBuffer = static_cast&lt;T*&gt;(Malloc::tryMalloc(sizeToAllocate));</span>
<span class="udiff-line-modified-added">+         if (!newBuffer)</span>
<span class="udiff-line-modified-added">+             return false;</span>
<span class="udiff-line-modified-added">+         m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="udiff-line-modified-added">+         m_buffer = newBuffer;</span>
<span class="udiff-line-modified-added">+         return true;</span>
      }
  
      bool shouldReallocateBuffer(size_t newCapacity) const
      {
          return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,11 +317,11 @@</span>
          ASSERT(shouldReallocateBuffer(newCapacity));
          if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="udiff-line-modified-removed">-         m_buffer = static_cast&lt;T*&gt;(fastRealloc(m_buffer, sizeToAllocate));</span>
<span class="udiff-line-modified-added">+         m_buffer = static_cast&lt;T*&gt;(Malloc::realloc(m_buffer, sizeToAllocate));</span>
      }
  
      void deallocateBuffer(T* bufferToDeallocate)
      {
          if (!bufferToDeallocate)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,24 +330,24 @@</span>
          if (m_buffer == bufferToDeallocate) {
              m_buffer = 0;
              m_capacity = 0;
          }
  
<span class="udiff-line-modified-removed">-         fastFree(bufferToDeallocate);</span>
<span class="udiff-line-modified-added">+         Malloc::free(bufferToDeallocate);</span>
      }
  
      T* buffer() { return m_buffer; }
      const T* buffer() const { return m_buffer; }
      static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
      size_t capacity() const { return m_capacity; }
  
<span class="udiff-line-modified-removed">-     MallocPtr&lt;T&gt; releaseBuffer()</span>
<span class="udiff-line-modified-added">+     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
      {
          T* buffer = m_buffer;
          m_buffer = 0;
          m_capacity = 0;
<span class="udiff-line-modified-removed">-         return adoptMallocPtr(buffer);</span>
<span class="udiff-line-modified-added">+         return adoptMallocPtr&lt;T, Malloc&gt;(buffer);</span>
      }
  
  protected:
      VectorBufferBase()
          : m_buffer(0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,17 +371,16 @@</span>
      T* m_buffer;
      unsigned m_capacity;
      unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
  };
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="udiff-line-removed">- class VectorBuffer;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename Malloc = VectorMalloc&gt; class VectorBuffer;</span>
  
<span class="udiff-line-modified-removed">- template&lt;typename T&gt;</span>
<span class="udiff-line-modified-removed">- class VectorBuffer&lt;T, 0&gt; : private VectorBufferBase&lt;T&gt; {</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ class VectorBuffer&lt;T, 0, Malloc&gt; : private VectorBufferBase&lt;T, Malloc&gt; {</span>
  private:
<span class="udiff-line-modified-removed">-     typedef VectorBufferBase&lt;T&gt; Base;</span>
<span class="udiff-line-modified-added">+     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
  public:
      VectorBuffer()
      {
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,11 +396,11 @@</span>
      ~VectorBuffer()
      {
          deallocateBuffer(buffer());
      }
  
<span class="udiff-line-modified-removed">-     void swap(VectorBuffer&lt;T, 0&gt;&amp; other, size_t, size_t)</span>
<span class="udiff-line-modified-added">+     void swap(VectorBuffer&lt;T, 0, Malloc&gt;&amp; other, size_t, size_t)</span>
      {
          std::swap(m_buffer, other.m_buffer);
          std::swap(m_capacity, other.m_capacity);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -435,15 +432,15 @@</span>
      friend class JSC::LLIntOffsetsExtractor;
      using Base::m_buffer;
      using Base::m_capacity;
  };
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="udiff-line-modified-removed">- class VectorBuffer : private VectorBufferBase&lt;T&gt; {</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ class VectorBuffer : private VectorBufferBase&lt;T, Malloc&gt; {</span>
      WTF_MAKE_NONCOPYABLE(VectorBuffer);
  private:
<span class="udiff-line-modified-removed">-     typedef VectorBufferBase&lt;T&gt; Base;</span>
<span class="udiff-line-modified-added">+     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
  public:
      VectorBuffer()
          : Base(inlineBuffer(), inlineCapacity, 0)
      {
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -546,14 +543,14 @@</span>
  
      using Base::buffer;
      using Base::capacity;
      using Base::bufferMemoryOffset;
  
<span class="udiff-line-modified-removed">-     MallocPtr&lt;T&gt; releaseBuffer()</span>
<span class="udiff-line-modified-added">+     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
      {
          if (buffer() == inlineBuffer())
<span class="udiff-line-modified-removed">-             return nullptr;</span>
<span class="udiff-line-modified-added">+             return { };</span>
          return Base::releaseBuffer();
      }
  
  protected:
      using Base::m_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -588,12 +585,12 @@</span>
      const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
  
  #if ASAN_ENABLED
      // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
      // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
<span class="udiff-line-modified-removed">-     static const size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="udiff-line-modified-removed">-     static const size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
<span class="udiff-line-modified-added">+     static constexpr size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="udiff-line-modified-added">+     static constexpr size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
      typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
  #else
      typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
  #endif
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,15 +601,15 @@</span>
          ASSERT_NOT_REACHED();
      }
  };
  
  // Template default values are in Forward.h.
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- class Vector : private VectorBuffer&lt;T, inlineCapacity&gt; {</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; {</span>
      WTF_MAKE_FAST_ALLOCATED;
  private:
<span class="udiff-line-modified-removed">-     typedef VectorBuffer&lt;T, inlineCapacity&gt; Base;</span>
<span class="udiff-line-modified-added">+     typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</span>
      typedef VectorTypeOperations&lt;T&gt; TypeOperations;
      friend class JSC::LLIntOffsetsExtractor;
  
  public:
      typedef T ValueType;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -667,25 +664,30 @@</span>
  
          result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
          return result;
      }
  
<span class="udiff-line-added">+     Vector(WTF::HashTableDeletedValueType)</span>
<span class="udiff-line-added">+         : Base(0, std::numeric_limits&lt;decltype(m_size)&gt;::max())</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ~Vector()
      {
          if (m_size)
              TypeOperations::destruct(begin(), end());
  
          asanSetBufferSizeToFullCapacity(0);
      }
  
      Vector(const Vector&amp;);
<span class="udiff-line-modified-removed">-     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="udiff-line-modified-removed">-     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
<span class="udiff-line-modified-added">+     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="udiff-line-modified-added">+     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
  
      Vector&amp; operator=(const Vector&amp;);
<span class="udiff-line-modified-removed">-     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="udiff-line-modified-removed">-     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
<span class="udiff-line-modified-added">+     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="udiff-line-modified-added">+     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
  
      Vector(Vector&amp;&amp;);
      Vector&amp; operator=(Vector&amp;&amp;);
  
      size_t size() const { return m_size; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -777,15 +779,16 @@</span>
      template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
      template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
  
      template&lt;typename U&gt; void append(const U*, size_t);
      template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
<span class="udiff-line-added">+     template&lt;typename U, size_t otherCapacity&gt; void appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp;);</span>
      template&lt;typename U&gt; bool tryAppend(const U*, size_t);
  
      template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
      template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
<span class="udiff-line-modified-removed">-     template&lt;typename U, size_t c, typename OH&gt; void insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp;);</span>
<span class="udiff-line-modified-added">+     template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt; void insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp;);</span>
  
      void remove(size_t position);
      void remove(size_t position, size_t length);
      template&lt;typename U&gt; bool removeFirst(const U&amp;);
      template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -802,13 +805,13 @@</span>
      void fill(const T&amp;, size_t);
      void fill(const T&amp; val) { fill(val, size()); }
  
      template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
  
<span class="udiff-line-modified-removed">-     MallocPtr&lt;T&gt; releaseBuffer();</span>
<span class="udiff-line-modified-added">+     MallocPtr&lt;T, Malloc&gt; releaseBuffer();</span>
  
<span class="udiff-line-modified-removed">-     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
<span class="udiff-line-modified-added">+     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
      {
  #if ASAN_ENABLED
          if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
              return;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -828,10 +831,12 @@</span>
  
      void checkConsistency();
  
      template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
  
<span class="udiff-line-added">+     bool isHashTableDeletedValue() const { return m_size == std::numeric_limits&lt;decltype(m_size)&gt;::max(); }</span>
<span class="udiff-line-added">+ </span>
  private:
      void expandCapacity(size_t newMinCapacity);
      T* expandCapacity(size_t newMinCapacity, T*);
      bool tryExpandCapacity(size_t newMinCapacity);
      const T* tryExpandCapacity(size_t newMinCapacity, const T*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -874,33 +879,33 @@</span>
  #if ASAN_ENABLED
      using Base::endOfBuffer;
  #endif
  };
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="udiff-line-modified-removed">- Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="udiff-line-modified-added">+ Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
  {
      if (&amp;other == this)
          return *this;
  
      if (size() &gt; other.size())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -920,13 +925,13 @@</span>
      return *this;
  }
  
  inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="udiff-line-modified-removed">- Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="udiff-line-modified-added">+ Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
  {
      // If the inline capacities match, we should call the more specific
      // template.  If the inline capacities don&#39;t match, the two objects
      // shouldn&#39;t be allocated the same address.
      ASSERT(!typelessPointersAreEqual(&amp;other, this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,74 +951,74 @@</span>
      m_size = other.size();
  
      return *this;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
  {
      swap(other);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
  {
      swap(other);
      return *this;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::contains(const U&amp; value) const</span>
<span class="udiff-line-modified-added">+ bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::contains(const U&amp; value) const</span>
  {
      return find(value) != notFound;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="udiff-line-modified-removed">- size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::findMatching(const MatchFunction&amp; matches) const</span>
<span class="udiff-line-modified-added">+ size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::findMatching(const MatchFunction&amp; matches) const</span>
  {
      for (size_t i = 0; i &lt; size(); ++i) {
          if (matches(at(i)))
              return i;
      }
      return notFound;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::find(const U&amp; value) const</span>
<span class="udiff-line-modified-added">+ size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::find(const U&amp; value) const</span>
  {
      return findMatching([&amp;](auto&amp; item) {
          return item == value;
      });
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverseFind(const U&amp; value) const</span>
<span class="udiff-line-modified-added">+ size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverseFind(const U&amp; value) const</span>
  {
      for (size_t i = 1; i &lt;= size(); ++i) {
          const size_t index = size() - i;
          if (at(index) == value)
              return index;
      }
      return notFound;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendIfNotContains(const U&amp; value)</span>
<span class="udiff-line-modified-added">+ bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendIfNotContains(const U&amp; value)</span>
  {
      if (contains(value))
          return false;
      append(value);
      return true;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::fill(const T&amp; val, size_t newSize)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::fill(const T&amp; val, size_t newSize)</span>
  {
      if (size() &gt; newSize)
          shrink(newSize);
      else if (newSize &gt; capacity()) {
          clear();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1026,44 +1031,44 @@</span>
      std::fill(begin(), end(), val);
      TypeOperations::uninitializedFill(end(), begin() + newSize, val);
      m_size = newSize;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename Iterator&gt;
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendRange(Iterator start, Iterator end)</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendRange(Iterator start, Iterator end)</span>
  {
      for (Iterator it = start; it != end; ++it)
          append(*it);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity)</span>
  {
      reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          expandCapacity(newMinCapacity);
          return ptr;
      }
      size_t index = ptr - begin();
      expandCapacity(newMinCapacity);
      return begin() + index;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
  {
      return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          if (!tryExpandCapacity(newMinCapacity))
              return 0;
          return ptr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1072,20 +1077,20 @@</span>
      if (!tryExpandCapacity(newMinCapacity))
          return 0;
      return begin() + index;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
<span class="udiff-line-modified-added">+ inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
  {
      expandCapacity(newMinCapacity);
      return ptr;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resize(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resize(size_t size)</span>
  {
      if (size &lt;= m_size) {
          TypeOperations::destruct(begin() + size, end());
          asanBufferSizeWillChangeTo(size);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1097,40 +1102,40 @@</span>
      }
  
      m_size = size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resizeToFit(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resizeToFit(size_t size)</span>
  {
      reserveCapacity(size);
      resize(size);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrink(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrink(size_t size)</span>
  {
      ASSERT(size &lt;= m_size);
      TypeOperations::destruct(begin() + size, end());
      asanBufferSizeWillChangeTo(size);
      m_size = size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::grow(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::grow(size_t size)</span>
  {
      ASSERT(size &gt;= m_size);
      if (size &gt; capacity())
          expandCapacity(size);
      asanBufferSizeWillChangeTo(size);
      if (begin())
          TypeOperations::initializeIfNonPOD(end(), begin() + size);
      m_size = size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1141,12 +1146,12 @@</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1155,12 +1160,12 @@</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1169,12 +1174,12 @@</span>
  #else
      UNUSED_PARAM(newSize);
  #endif
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveCapacity(size_t newCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return;
      T* oldBuffer = begin();
      T* oldEnd = end();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1188,12 +1193,12 @@</span>
  
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryReserveCapacity(size_t newCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryReserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return true;
      T* oldBuffer = begin();
      T* oldEnd = end();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1211,21 +1216,21 @@</span>
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
      return true;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
  {
      ASSERT(!m_size);
      ASSERT(capacity() == inlineCapacity);
      if (initialCapacity &gt; inlineCapacity)
          Base::allocateBuffer(initialCapacity);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrinkCapacity(size_t newCapacity)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrinkCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &gt;= capacity())
          return;
  
      if (newCapacity &lt; size())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1251,13 +1256,13 @@</span>
      Base::restoreInlineBufferIfNeeded();
  
      asanSetInitialBufferSizeTo(size());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(const U* data, size_t dataSize)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
          ASSERT(begin());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1268,13 +1273,13 @@</span>
      T* dest = end();
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryAppend(const U* data, size_t dataSize)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryAppend(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = tryExpandCapacity(newSize, data);
          if (!data)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1288,13 +1293,13 @@</span>
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
      return true;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(U&amp;&amp; value)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(U&amp;&amp; value)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;U&gt;(value));
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1302,13 +1307,13 @@</span>
      }
  
      appendSlowCase(std::forward&lt;U&gt;(value));
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1316,13 +1321,13 @@</span>
      }
  
      constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1330,13 +1335,13 @@</span>
      }
  
      return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendSlowCase(U&amp;&amp; value)</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendSlowCase(U&amp;&amp; value)</span>
  {
      ASSERT(size() == capacity());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      ptr = expandCapacity(size() + 1, ptr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1345,13 +1350,13 @@</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      expandCapacity(size() + 1);
      ASSERT(begin());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1359,13 +1364,13 @@</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">- bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
<span class="udiff-line-modified-added">+ bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      if (UNLIKELY(!tryExpandCapacity(size() + 1)))
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1378,44 +1383,55 @@</span>
  }
  
  // This version of append saves a branch in the case where you know that the
  // vector&#39;s capacity is large enough for the append to succeed.
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedAppend(U&amp;&amp; value)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedAppend(U&amp;&amp; value)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;U&gt;(value));
      ++m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U, size_t otherCapacity&gt;
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
  {
      append(val.begin(), val.size());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-added">+ template&lt;typename U, size_t otherCapacity&gt;</span>
<span class="udiff-line-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp; val)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     size_t newSize = m_size + val.size();</span>
<span class="udiff-line-added">+     if (newSize &gt; capacity())</span>
<span class="udiff-line-added">+         expandCapacity(newSize);</span>
<span class="udiff-line-added">+     for (auto&amp; item : val)</span>
<span class="udiff-line-added">+         uncheckedAppend(WTFMove(item));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
<span class="udiff-line-modified-added">+ void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1428,13 +1444,13 @@</span>
      TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
      m_size = newSize;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, U&amp;&amp; value)</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, U&amp;&amp; value)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      if (size() == capacity()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1448,30 +1464,30 @@</span>
      TypeOperations::moveOverlapping(spot, end(), spot + 1);
      new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- template&lt;typename U, size_t c, typename OH&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp; val)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp; val)</span>
  {
      insert(position, val.begin(), val.size());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
      T* spot = begin() + position;
      spot-&gt;~T();
      TypeOperations::moveOverlapping(spot + 1, end(), spot);
      asanBufferSizeWillChangeTo(m_size - 1);
      --m_size;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position, size_t length)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position, size_t length)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
      T* beginSpot = begin() + position;
      T* endSpot = beginSpot + length;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1479,44 +1495,44 @@</span>
      TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
      asanBufferSizeWillChangeTo(m_size - length);
      m_size -= length;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirst(const U&amp; value)</span>
<span class="udiff-line-modified-added">+ inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirst(const U&amp; value)</span>
  {
      return removeFirstMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="udiff-line-modified-removed">- inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
<span class="udiff-line-modified-added">+ inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      for (size_t i = startIndex; i &lt; size(); ++i) {
          if (matches(at(i))) {
              remove(i);
              return true;
          }
      }
      return false;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAll(const U&amp; value)</span>
<span class="udiff-line-modified-added">+ inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAll(const U&amp; value)</span>
  {
      return removeAllMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="udiff-line-modified-removed">- inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
<span class="udiff-line-modified-added">+ inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      iterator holeBegin = end();
      iterator holeEnd = end();
      unsigned matchCount = 0;
      for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1537,30 +1553,30 @@</span>
      asanBufferSizeWillChangeTo(m_size - matchCount);
      m_size -= matchCount;
      return matchCount;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverse()</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverse()</span>
  {
      for (size_t i = 0; i &lt; m_size / 2; ++i)
          std::swap(at(i), at(m_size - 1 - i));
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MapFunction, typename R&gt;
<span class="udiff-line-modified-removed">- inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::map(MapFunction mapFunction) const</span>
<span class="udiff-line-modified-added">+ inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::map(MapFunction mapFunction) const</span>
  {
      Vector&lt;R&gt; result;
      result.reserveInitialCapacity(size());
      for (size_t i = 0; i &lt; size(); ++i)
          result.uncheckedAppend(mapFunction(at(i)));
      return result;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline MallocPtr&lt;T&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::releaseBuffer()</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline MallocPtr&lt;T, Malloc&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::releaseBuffer()</span>
  {
      // FIXME: Find a way to preserve annotations on the returned buffer.
      // ASan requires that all annotations are removed before deallocation,
      // and MallocPtr doesn&#39;t implement that.
      asanSetBufferSizeToFullCapacity();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1569,61 +1585,61 @@</span>
      if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
          // If the vector had some data, but no buffer to release,
          // that means it was using the inline buffer. In that case,
          // we create a brand new buffer so the caller always gets one.
          size_t bytes = m_size * sizeof(T);
<span class="udiff-line-modified-removed">-         buffer = adoptMallocPtr(static_cast&lt;T*&gt;(fastMalloc(bytes)));</span>
<span class="udiff-line-modified-added">+         buffer = adoptMallocPtr&lt;T, Malloc&gt;(static_cast&lt;T*&gt;(Malloc::malloc(bytes)));</span>
          memcpy(buffer.get(), data(), bytes);
      }
      m_size = 0;
      // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
      return buffer;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::checkConsistency()</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::checkConsistency()</span>
  {
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      for (size_t i = 0; i &lt; size(); ++i)
          ValueCheck&lt;T&gt;::checkConsistency(at(i));
  #endif
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; b)</span>
  {
      a.swap(b);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- bool operator==(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="udiff-line-modified-added">+ bool operator==(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
  {
      if (a.size() != b.size())
          return false;
  
      return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline bool operator!=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="udiff-line-modified-added">+ inline bool operator!=(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
  {
      return !(a == b);
  }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
      typedef Vector&lt;T&gt; TraitType;
      static void checkConsistency(const Vector&lt;T&gt;&amp; v)
      {
          v.checkConsistency();
      }
  };
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="udiff-line-modified-removed">- inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::isolatedCopy() const</span>
<span class="udiff-line-modified-added">+ inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::isolatedCopy() const</span>
  {
      Vector&lt;U&gt; copy;
      copy.reserveInitialCapacity(size());
      for (const auto&amp; element : *this)
          copy.uncheckedAppend(element.isolatedCopy());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1637,12 +1653,12 @@</span>
      size_t newSize = end - vector.begin();
      vector.shrink(newSize);
      return newSize;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; vector)</span>
<span class="udiff-line-modified-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; vector)</span>
  {
      return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
  }
  
  template&lt;typename SourceType&gt;
</pre>
<center><a href="Variant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
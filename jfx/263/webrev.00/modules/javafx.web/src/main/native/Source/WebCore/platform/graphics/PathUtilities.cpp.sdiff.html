<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathUtilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PathTraversalState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pattern.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathUtilities.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
476         const auto&amp; fromEdge = (i &gt; 0) ? poly[i - 1] : poly[poly.size() - 1];
477         auto corner = cornerType(fromEdge, toEdge);
478         if (corner == CornerType::TopLeft) {
479             ASSERT(!topLeft);
480             topLeft = *fromEdge.second;
481         } else if (corner == CornerType::BottomRight) {
482             ASSERT(!bottomRight);
483             bottomRight = *fromEdge.second;
484         }
485     }
486     if (!topLeft || !bottomRight)
487         return Optional&lt;FloatRect&gt;();
488     return FloatRect(topLeft.value(), bottomRight.value());
489 }
490 
491 Path PathUtilities::pathWithShrinkWrappedRectsForOutline(const Vector&lt;FloatRect&gt;&amp; rects, const BorderData&amp; borderData,
492     float outlineOffset, TextDirection direction, WritingMode writingMode, float deviceScaleFactor)
493 {
494     ASSERT(borderData.hasBorderRadius());
495 
<span class="line-modified">496     FloatSize topLeftRadius { borderData.topLeft().width.value(), borderData.topLeft().height.value() };</span>
<span class="line-modified">497     FloatSize topRightRadius { borderData.topRight().width.value(), borderData.topRight().height.value() };</span>
<span class="line-modified">498     FloatSize bottomRightRadius { borderData.bottomRight().width.value(), borderData.bottomRight().height.value() };</span>
<span class="line-modified">499     FloatSize bottomLeftRadius { borderData.bottomLeft().width.value(), borderData.bottomLeft().height.value() };</span>
500 
501     auto roundedRect = [topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius, outlineOffset, deviceScaleFactor] (const FloatRect&amp; rect)
502     {
503         auto radii = adjustedtRadiiForHuggingCurve(topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius, outlineOffset);
504         radii.scale(calcBorderRadiiConstraintScaleFor(rect, radii));
505         RoundedRect roundedRect(LayoutRect(rect),
506             RoundedRect::Radii(LayoutSize(radii.topLeft()), LayoutSize(radii.topRight()), LayoutSize(radii.bottomLeft()), LayoutSize(radii.bottomRight())));
507         Path path;
508         path.addRoundedRect(roundedRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
509         return path;
510     };
511 
512     if (rects.size() == 1)
513         return roundedRect(rects.at(0));
514 
515     FloatPointGraph graph;
516     const auto polys = polygonsForRect(rects, graph);
517     // Fall back to corner painting with no radius for empty and disjoint rectangles.
518     if (!polys.size() || polys.size() &gt; 1)
519         return Path();
</pre>
</td>
<td>
<hr />
<pre>
476         const auto&amp; fromEdge = (i &gt; 0) ? poly[i - 1] : poly[poly.size() - 1];
477         auto corner = cornerType(fromEdge, toEdge);
478         if (corner == CornerType::TopLeft) {
479             ASSERT(!topLeft);
480             topLeft = *fromEdge.second;
481         } else if (corner == CornerType::BottomRight) {
482             ASSERT(!bottomRight);
483             bottomRight = *fromEdge.second;
484         }
485     }
486     if (!topLeft || !bottomRight)
487         return Optional&lt;FloatRect&gt;();
488     return FloatRect(topLeft.value(), bottomRight.value());
489 }
490 
491 Path PathUtilities::pathWithShrinkWrappedRectsForOutline(const Vector&lt;FloatRect&gt;&amp; rects, const BorderData&amp; borderData,
492     float outlineOffset, TextDirection direction, WritingMode writingMode, float deviceScaleFactor)
493 {
494     ASSERT(borderData.hasBorderRadius());
495 
<span class="line-modified">496     FloatSize topLeftRadius { borderData.topLeftRadius().width.value(), borderData.topLeftRadius().height.value() };</span>
<span class="line-modified">497     FloatSize topRightRadius { borderData.topRightRadius().width.value(), borderData.topRightRadius().height.value() };</span>
<span class="line-modified">498     FloatSize bottomRightRadius { borderData.bottomRightRadius().width.value(), borderData.bottomRightRadius().height.value() };</span>
<span class="line-modified">499     FloatSize bottomLeftRadius { borderData.bottomLeftRadius().width.value(), borderData.bottomLeftRadius().height.value() };</span>
500 
501     auto roundedRect = [topLeftRadius, topRightRadius, bottomRightRadius, bottomLeftRadius, outlineOffset, deviceScaleFactor] (const FloatRect&amp; rect)
502     {
503         auto radii = adjustedtRadiiForHuggingCurve(topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius, outlineOffset);
504         radii.scale(calcBorderRadiiConstraintScaleFor(rect, radii));
505         RoundedRect roundedRect(LayoutRect(rect),
506             RoundedRect::Radii(LayoutSize(radii.topLeft()), LayoutSize(radii.topRight()), LayoutSize(radii.bottomLeft()), LayoutSize(radii.bottomRight())));
507         Path path;
508         path.addRoundedRect(roundedRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor));
509         return path;
510     };
511 
512     if (rects.size() == 1)
513         return roundedRect(rects.at(0));
514 
515     FloatPointGraph graph;
516     const auto polys = polygonsForRect(rects, graph);
517     // Fall back to corner painting with no radius for empty and disjoint rectangles.
518     if (!polys.size() || polys.size() &gt; 1)
519         return Path();
</pre>
</td>
</tr>
</table>
<center><a href="PathTraversalState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pattern.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
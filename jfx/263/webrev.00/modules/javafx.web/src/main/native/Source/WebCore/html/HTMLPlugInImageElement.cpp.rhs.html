<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;HTMLPlugInImageElement.h&quot;
 23 
 24 #include &quot;Chrome.h&quot;
 25 #include &quot;ChromeClient.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;EventNames.h&quot;
 29 #include &quot;Frame.h&quot;
 30 #include &quot;FrameLoaderClient.h&quot;
 31 #include &quot;HTMLImageLoader.h&quot;
 32 #include &quot;JSDOMConvertBoolean.h&quot;
 33 #include &quot;JSDOMConvertInterface.h&quot;
 34 #include &quot;JSDOMConvertStrings.h&quot;
 35 #include &quot;JSShadowRoot.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 36 #include &quot;LegacySchemeRegistry.h&quot;</span>
 37 #include &quot;LocalizedStrings.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MouseEvent.h&quot;
 40 #include &quot;Page.h&quot;
 41 #include &quot;PlatformMouseEvent.h&quot;
 42 #include &quot;PlugInClient.h&quot;
 43 #include &quot;PluginViewBase.h&quot;
 44 #include &quot;RenderImage.h&quot;
 45 #include &quot;RenderSnapshottedPlugIn.h&quot;
 46 #include &quot;RenderTreeUpdater.h&quot;
<a name="2" id="anc2"></a>
 47 #include &quot;ScriptController.h&quot;
 48 #include &quot;SecurityOrigin.h&quot;
 49 #include &quot;Settings.h&quot;
 50 #include &quot;ShadowRoot.h&quot;
 51 #include &quot;StyleTreeResolver.h&quot;
 52 #include &quot;SubframeLoader.h&quot;
 53 #include &quot;TypedElementDescendantIterator.h&quot;
 54 #include &quot;UserGestureIndicator.h&quot;
 55 #include &lt;JavaScriptCore/CatchScope.h&gt;
<a name="3" id="anc3"></a><span class="line-added"> 56 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;</span>
 57 #include &lt;wtf/IsoMallocInlines.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
 62 
 63 static const int sizingTinyDimensionThreshold = 40;
 64 static const float sizingFullPageAreaRatioThreshold = 0.96;
 65 static const Seconds autostartSoonAfterUserGestureThreshold = 5_s;
 66 
 67 // This delay should not exceed the snapshot delay in PluginView.cpp
 68 static const Seconds simulatedMouseClickTimerDelay { 750_ms };
 69 
 70 #if PLATFORM(COCOA)
 71 static const Seconds removeSnapshotTimerDelay { 1500_ms };
 72 #endif
 73 
 74 static const String titleText(Page&amp; page, const String&amp; mimeType)
 75 {
 76     if (mimeType.isEmpty())
 77         return snapshottedPlugInLabelTitle();
 78 
 79     // FIXME: It&#39;s not consistent to get a string from the page&#39;s chrome client, but then cache it globally.
 80     // If it&#39;s global, it should come from elsewhere. If it&#39;s per-page then it should be cached per page.
 81     static NeverDestroyed&lt;HashMap&lt;String, String&gt;&gt; mimeTypeToLabelTitleMap;
 82     return mimeTypeToLabelTitleMap.get().ensure(mimeType, [&amp;] {
 83         auto title = page.chrome().client().plugInStartLabelTitle(mimeType);
 84         if (!title.isEmpty())
 85             return title;
 86         return snapshottedPlugInLabelTitle();
 87     }).iterator-&gt;value;
 88 };
 89 
 90 static const String subtitleText(Page&amp; page, const String&amp; mimeType)
 91 {
 92     if (mimeType.isEmpty())
 93         return snapshottedPlugInLabelSubtitle();
 94 
 95     // FIXME: It&#39;s not consistent to get a string from the page&#39;s chrome client, but then cache it globally.
 96     // If it&#39;s global, it should come from elsewhere. If it&#39;s per-page then it should be cached per page.
 97     static NeverDestroyed&lt;HashMap&lt;String, String&gt;&gt; mimeTypeToLabelSubtitleMap;
 98     return mimeTypeToLabelSubtitleMap.get().ensure(mimeType, [&amp;] {
 99         auto subtitle = page.chrome().client().plugInStartLabelSubtitle(mimeType);
100         if (!subtitle.isEmpty())
101             return subtitle;
102         return snapshottedPlugInLabelSubtitle();
103     }).iterator-&gt;value;
104 };
105 
106 HTMLPlugInImageElement::HTMLPlugInImageElement(const QualifiedName&amp; tagName, Document&amp; document)
107     : HTMLPlugInElement(tagName, document)
108     , m_simulatedMouseClickTimer(*this, &amp;HTMLPlugInImageElement::simulatedMouseClickTimerFired, simulatedMouseClickTimerDelay)
109     , m_removeSnapshotTimer(*this, &amp;HTMLPlugInImageElement::removeSnapshotTimerFired)
110     , m_createdDuringUserGesture(UserGestureIndicator::processingUserGesture())
111 {
112     setHasCustomStyleResolveCallbacks();
113 }
114 
115 void HTMLPlugInImageElement::finishCreating()
116 {
117     scheduleUpdateForAfterStyleResolution();
118 }
119 
120 HTMLPlugInImageElement::~HTMLPlugInImageElement()
121 {
122     if (m_needsDocumentActivationCallbacks)
123         document().unregisterForDocumentSuspensionCallbacks(*this);
124 }
125 
126 void HTMLPlugInImageElement::setDisplayState(DisplayState state)
127 {
128 #if PLATFORM(COCOA)
129     if (state == RestartingWithPendingMouseClick || state == Restarting) {
130         m_isRestartedPlugin = true;
131         m_snapshotDecision = NeverSnapshot;
132         invalidateStyleAndLayerComposition();
133         if (displayState() == DisplayingSnapshot)
134             m_removeSnapshotTimer.startOneShot(removeSnapshotTimerDelay);
135     }
136 #endif
137 
138     HTMLPlugInElement::setDisplayState(state);
139 }
140 
141 RenderEmbeddedObject* HTMLPlugInImageElement::renderEmbeddedObject() const
142 {
143     // HTMLObjectElement and HTMLEmbedElement may return arbitrary renderers when using fallback content.
144     return is&lt;RenderEmbeddedObject&gt;(renderer()) ? downcast&lt;RenderEmbeddedObject&gt;(renderer()) : nullptr;
145 }
146 
147 bool HTMLPlugInImageElement::isImageType()
148 {
149     if (m_serviceType.isEmpty() &amp;&amp; protocolIs(m_url, &quot;data&quot;))
150         m_serviceType = mimeTypeFromDataURL(m_url);
151 
152     if (auto frame = makeRefPtr(document().frame()))
153         return frame-&gt;loader().client().objectContentType(document().completeURL(m_url), m_serviceType) == ObjectContentType::Image;
154 
155     return Image::supportsType(m_serviceType);
156 }
157 
158 bool HTMLPlugInImageElement::canLoadURL(const String&amp; relativeURL) const
159 {
160     return canLoadURL(document().completeURL(relativeURL));
161 }
162 
163 // Note that unlike HTMLFrameElementBase::canLoadURL this uses SecurityOrigin::canAccess.
164 bool HTMLPlugInImageElement::canLoadURL(const URL&amp; completeURL) const
165 {
166     if (WTF::protocolIsJavaScript(completeURL)) {
167         RefPtr&lt;Document&gt; contentDocument = this-&gt;contentDocument();
168         if (contentDocument &amp;&amp; !document().securityOrigin().canAccess(contentDocument-&gt;securityOrigin()))
169             return false;
170     }
171 
172     return !isProhibitedSelfReference(completeURL);
173 }
174 
175 // We don&#39;t use m_url, or m_serviceType as they may not be the final values
176 // that &lt;object&gt; uses depending on &lt;param&gt; values.
177 bool HTMLPlugInImageElement::wouldLoadAsPlugIn(const String&amp; relativeURL, const String&amp; serviceType)
178 {
179     ASSERT(document().frame());
180     URL completedURL;
181     if (!relativeURL.isEmpty())
182         completedURL = document().completeURL(relativeURL);
183     return document().frame()-&gt;loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
184 }
185 
186 RenderPtr&lt;RenderElement&gt; HTMLPlugInImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
187 {
<a name="4" id="anc4"></a><span class="line-modified">188     ASSERT(document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
189 
190     if (displayState() &gt;= PreparingPluginReplacement)
191         return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
192 
193     // Once a plug-in element creates its renderer, it needs to be told when the document goes
<a name="5" id="anc5"></a><span class="line-modified">194     // inactive or reactivates so it can clear the renderer before going into the back/forward cache.</span>
195     if (!m_needsDocumentActivationCallbacks) {
196         m_needsDocumentActivationCallbacks = true;
197         document().registerForDocumentSuspensionCallbacks(*this);
198     }
199 
200     if (displayState() == DisplayingSnapshot) {
201         auto renderSnapshottedPlugIn = createRenderer&lt;RenderSnapshottedPlugIn&gt;(*this, WTFMove(style));
202         renderSnapshottedPlugIn-&gt;updateSnapshot(m_snapshotImage.get());
203         return renderSnapshottedPlugIn;
204     }
205 
206     if (useFallbackContent())
207         return RenderElement::createFor(*this, WTFMove(style));
208 
209     if (isImageType())
210         return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style));
211 
212     return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
213 }
214 
215 bool HTMLPlugInImageElement::childShouldCreateRenderer(const Node&amp; child) const
216 {
217     if (is&lt;RenderSnapshottedPlugIn&gt;(renderer()) &amp;&amp; !hasShadowRootParent(child))
218         return false;
219 
220     return HTMLPlugInElement::childShouldCreateRenderer(child);
221 }
222 
223 void HTMLPlugInImageElement::willRecalcStyle(Style::Change change)
224 {
225     // Make sure style recalcs scheduled by a child shadow tree don&#39;t trigger reconstruction and cause flicker.
226     if (change == Style::NoChange &amp;&amp; styleValidity() == Style::Validity::Valid)
227         return;
228 
229     // FIXME: There shoudn&#39;t be need to force render tree reconstruction here.
230     // It is only done because loading and load event dispatching is tied to render tree construction.
231     if (!useFallbackContent() &amp;&amp; needsWidgetUpdate() &amp;&amp; renderer() &amp;&amp; !isImageType() &amp;&amp; displayState() != DisplayingSnapshot)
232         invalidateStyleAndRenderersForSubtree();
233 }
234 
235 void HTMLPlugInImageElement::didRecalcStyle(Style::Change styleChange)
236 {
237     scheduleUpdateForAfterStyleResolution();
238 
239     HTMLPlugInElement::didRecalcStyle(styleChange);
240 }
241 
242 void HTMLPlugInImageElement::didAttachRenderers()
243 {
244     m_needsWidgetUpdate = true;
245     scheduleUpdateForAfterStyleResolution();
246 
247     // Update the RenderImageResource of the associated RenderImage.
248     if (m_imageLoader &amp;&amp; is&lt;RenderImage&gt;(renderer())) {
249         auto&amp; renderImageResource = downcast&lt;RenderImage&gt;(*renderer()).imageResource();
250         if (!renderImageResource.cachedImage())
251             renderImageResource.setCachedImage(m_imageLoader-&gt;image());
252     }
253 
254     HTMLPlugInElement::didAttachRenderers();
255 }
256 
257 void HTMLPlugInImageElement::willDetachRenderers()
258 {
259     auto widget = makeRefPtr(pluginWidget(PluginLoadingPolicy::DoNotLoad));
260     if (is&lt;PluginViewBase&gt;(widget))
261         downcast&lt;PluginViewBase&gt;(*widget).willDetachRenderer();
262 
263     HTMLPlugInElement::willDetachRenderers();
264 }
265 
266 void HTMLPlugInImageElement::scheduleUpdateForAfterStyleResolution()
267 {
268     if (m_hasUpdateScheduledForAfterStyleResolution)
269         return;
270 
271     document().incrementLoadEventDelayCount();
272 
273     m_hasUpdateScheduledForAfterStyleResolution = true;
274 
275     Style::queuePostResolutionCallback([protectedThis = makeRef(*this)] {
276         protectedThis-&gt;updateAfterStyleResolution();
277     });
278 }
279 
280 void HTMLPlugInImageElement::updateAfterStyleResolution()
281 {
282     m_hasUpdateScheduledForAfterStyleResolution = false;
283 
284     // Do this after style resolution, since the image or widget load might complete synchronously
285     // and cause us to re-enter otherwise. Also, we can&#39;t really answer the question &quot;do I have a renderer&quot;
286     // accurately until after style resolution.
287 
288     if (renderer() &amp;&amp; !useFallbackContent()) {
289         if (isImageType()) {
290             if (!m_imageLoader)
291                 m_imageLoader = makeUnique&lt;HTMLImageLoader&gt;(*this);
292             if (m_needsImageReload)
293                 m_imageLoader-&gt;updateFromElementIgnoringPreviousError();
294             else
295                 m_imageLoader-&gt;updateFromElement();
296         } else {
297             if (needsWidgetUpdate() &amp;&amp; renderEmbeddedObject() &amp;&amp; !renderEmbeddedObject()-&gt;isPluginUnavailable())
298                 updateWidget(CreatePlugins::No);
299         }
300     }
301 
302     // Either we reloaded the image just now, or we had some reason not to.
303     // Either way, clear the flag now, since we don&#39;t need to remember to try again.
304     m_needsImageReload = false;
305 
306     document().decrementLoadEventDelayCount();
307 }
308 
309 void HTMLPlugInImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
310 {
311     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
312     if (m_needsDocumentActivationCallbacks) {
313         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
314         newDocument.registerForDocumentSuspensionCallbacks(*this);
315     }
316 
317     if (m_imageLoader)
318         m_imageLoader-&gt;elementDidMoveToNewDocument();
319 
320     if (m_hasUpdateScheduledForAfterStyleResolution) {
321         oldDocument.decrementLoadEventDelayCount();
322         newDocument.incrementLoadEventDelayCount();
323     }
324 
325     HTMLPlugInElement::didMoveToNewDocument(oldDocument, newDocument);
326 }
327 
328 void HTMLPlugInImageElement::prepareForDocumentSuspension()
329 {
330     if (renderer())
331         RenderTreeUpdater::tearDownRenderers(*this);
332 
333     HTMLPlugInElement::prepareForDocumentSuspension();
334 }
335 
336 void HTMLPlugInImageElement::resumeFromDocumentSuspension()
337 {
338     scheduleUpdateForAfterStyleResolution();
339     invalidateStyleAndRenderersForSubtree();
340 
341     HTMLPlugInElement::resumeFromDocumentSuspension();
342 }
343 
344 void HTMLPlugInImageElement::updateSnapshot(Image* image)
345 {
346     if (displayState() &gt; DisplayingSnapshot)
347         return;
348 
349     m_snapshotImage = image;
350 
351     auto* renderer = this-&gt;renderer();
352     if (!renderer)
353         return;
354 
355     if (is&lt;RenderSnapshottedPlugIn&gt;(*renderer)) {
356         downcast&lt;RenderSnapshottedPlugIn&gt;(*renderer).updateSnapshot(image);
357         return;
358     }
359 
360     if (is&lt;RenderEmbeddedObject&gt;(*renderer))
361         renderer-&gt;repaint();
362 }
363 
364 static DOMWrapperWorld&amp; plugInImageElementIsolatedWorld()
365 {
<a name="6" id="anc6"></a><span class="line-modified">366     static auto&amp; isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, &quot;Plugin&quot;_s).leakRef();</span>
367     return isolatedWorld;
368 }
369 
370 void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
371 {
372     HTMLPlugInElement::didAddUserAgentShadowRoot(root);
373     if (displayState() &gt;= PreparingPluginReplacement)
374         return;
375 
376     auto* page = document().page();
377     if (!page)
378         return;
379 
380     // Reset any author styles that may apply as we only want explicit
381     // styles defined in the injected user agents stylesheets to specify
382     // the look-and-feel of the snapshotted plug-in overlay.
383     root.setResetStyleInheritance(true);
384 
385     String mimeType = serviceType();
386 
387     auto&amp; isolatedWorld = plugInImageElementIsolatedWorld();
388     document().ensurePlugInsInjectedScript(isolatedWorld);
389 
390     auto&amp; scriptController = document().frame()-&gt;script();
391     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(isolatedWorld));
392 
393     auto&amp; vm = globalObject.vm();
394     JSC::JSLockHolder lock(vm);
395     auto scope = DECLARE_CATCH_SCOPE(vm);
<a name="7" id="anc7"></a><span class="line-modified">396     auto&amp; lexicalGlobalObject = globalObject;</span>
397 
398     JSC::MarkedArgumentBuffer argList;
<a name="8" id="anc8"></a><span class="line-modified">399     argList.append(toJS&lt;IDLInterface&lt;ShadowRoot&gt;&gt;(lexicalGlobalObject, globalObject, root));</span>
<span class="line-modified">400     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, titleText(*page, mimeType)));</span>
<span class="line-modified">401     argList.append(toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, subtitleText(*page, mimeType)));</span>
402 
403     // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
404     // If no snapshot was found then we want the overlay to be visible.
405     argList.append(toJS&lt;IDLBoolean&gt;(!m_snapshotImage));
406     ASSERT(!argList.hasOverflowed());
407 
408     // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
<a name="9" id="anc9"></a><span class="line-modified">409     auto* overlay = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createOverlay&quot;)).toObject(&amp;lexicalGlobalObject);</span>
410     ASSERT(!overlay == !!scope.exception());
411     if (!overlay) {
412         scope.clearException();
413         return;
414     }
415     JSC::CallData callData;
416     auto callType = overlay-&gt;methodTable(vm)-&gt;getCallData(overlay, callData);
417     if (callType == JSC::CallType::None)
418         return;
419 
<a name="10" id="anc10"></a><span class="line-modified">420     call(&amp;lexicalGlobalObject, overlay, callType, callData, &amp;globalObject, argList);</span>
421     scope.clearException();
422 }
423 
424 bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
425 {
426     static NeverDestroyed&lt;AtomString&gt; selector(&quot;.snapshot-overlay&quot;, AtomString::ConstructFromLiteral);
427     auto shadow = userAgentShadowRoot();
428     if (!shadow)
429         return false;
430     if (!is&lt;Node&gt;(target))
431         return false;
432     auto queryResult = shadow-&gt;querySelector(selector.get());
433     if (queryResult.hasException())
434         return false;
435     auto snapshotLabel = makeRefPtr(queryResult.releaseReturnValue());
436     return snapshotLabel &amp;&amp; snapshotLabel-&gt;contains(downcast&lt;Node&gt;(target));
437 }
438 
439 void HTMLPlugInImageElement::removeSnapshotTimerFired()
440 {
441     m_snapshotImage = nullptr;
442     m_isRestartedPlugin = false;
443     invalidateStyleAndLayerComposition();
444     if (renderer())
445         renderer()-&gt;repaint();
446 }
447 
448 void HTMLPlugInImageElement::restartSimilarPlugIns()
449 {
450     // Restart any other snapshotted plugins in the page with the same origin. Note that they
451     // may be in different frames, so traverse from the top of the document.
452 
453     auto plugInOrigin = m_loadedUrl.host();
454     String mimeType = serviceType();
455     Vector&lt;Ref&lt;HTMLPlugInImageElement&gt;&gt; similarPlugins;
456 
457     if (!document().page())
458         return;
459 
460     for (RefPtr&lt;Frame&gt; frame = &amp;document().page()-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
461         if (!frame-&gt;loader().subframeLoader().containsPlugins())
462             continue;
463 
464         if (!frame-&gt;document())
465             continue;
466 
467         for (auto&amp; element : descendantsOfType&lt;HTMLPlugInImageElement&gt;(*frame-&gt;document())) {
468             if (plugInOrigin == element.loadedUrl().host() &amp;&amp; mimeType == element.serviceType())
469                 similarPlugins.append(element);
470         }
471     }
472 
473     for (auto&amp; plugInToRestart : similarPlugins) {
474         if (plugInToRestart-&gt;displayState() &lt;= HTMLPlugInElement::DisplayingSnapshot) {
475             LOG(Plugins, &quot;%p Plug-in looks similar to a restarted plug-in. Restart.&quot;, plugInToRestart.ptr());
476             plugInToRestart-&gt;restartSnapshottedPlugIn();
477         }
478         plugInToRestart-&gt;m_snapshotDecision = NeverSnapshot;
479     }
480 }
481 
482 void HTMLPlugInImageElement::userDidClickSnapshot(MouseEvent&amp; event, bool forwardEvent)
483 {
484     if (forwardEvent)
485         m_pendingClickEventFromSnapshot = &amp;event;
486 
487     auto plugInOrigin = m_loadedUrl.host();
<a name="11" id="anc11"></a><span class="line-modified">488     if (document().page() &amp;&amp; !LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()-&gt;mainFrame().document()-&gt;baseURL().protocol().toStringWithoutCopying()) &amp;&amp; document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled())</span>
<span class="line-modified">489         document().page()-&gt;plugInClient()-&gt;didStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), plugInOrigin.toString(), serviceType());</span>
490 
491     LOG(Plugins, &quot;%p User clicked on snapshotted plug-in. Restart.&quot;, this);
492     restartSnapshottedPlugIn();
493     if (forwardEvent)
494         setDisplayState(RestartingWithPendingMouseClick);
495     restartSimilarPlugIns();
496 }
497 
498 void HTMLPlugInImageElement::setIsPrimarySnapshottedPlugIn(bool isPrimarySnapshottedPlugIn)
499 {
500     if (!document().page() || !document().page()-&gt;settings().primaryPlugInSnapshotDetectionEnabled() || document().page()-&gt;settings().snapshotAllPlugIns())
501         return;
502 
503     if (isPrimarySnapshottedPlugIn) {
504         if (m_plugInWasCreated) {
505             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page. Restart.&quot;, this);
506             restartSnapshottedPlugIn();
507             restartSimilarPlugIns();
508         } else {
509             LOG(Plugins, &quot;%p Plug-in was detected as the primary element in the page, but is not yet created. Will restart later.&quot;, this);
510             m_deferredPromotionToPrimaryPlugIn = true;
511         }
512     }
513 }
514 
515 void HTMLPlugInImageElement::restartSnapshottedPlugIn()
516 {
517     if (displayState() &gt;= RestartingWithPendingMouseClick)
518         return;
519 
520     setDisplayState(Restarting);
521     invalidateStyleAndRenderersForSubtree();
522 }
523 
524 void HTMLPlugInImageElement::dispatchPendingMouseClick()
525 {
526     ASSERT(!m_simulatedMouseClickTimer.isActive());
527     m_simulatedMouseClickTimer.restart();
528 }
529 
530 void HTMLPlugInImageElement::simulatedMouseClickTimerFired()
531 {
532     ASSERT(displayState() == RestartingWithPendingMouseClick);
533     ASSERT(m_pendingClickEventFromSnapshot);
534 
535     setDisplayState(Playing);
536     dispatchSimulatedClick(m_pendingClickEventFromSnapshot.get(), SendMouseOverUpDownEvents, DoNotShowPressedLook);
537 
538     m_pendingClickEventFromSnapshot = nullptr;
539 }
540 
541 static bool documentHadRecentUserGesture(Document&amp; document)
542 {
543     MonotonicTime lastKnownUserGestureTimestamp = document.lastHandledUserGestureTimestamp();
544     if (document.frame() != &amp;document.page()-&gt;mainFrame() &amp;&amp; document.page()-&gt;mainFrame().document())
545         lastKnownUserGestureTimestamp = std::max(lastKnownUserGestureTimestamp, document.page()-&gt;mainFrame().document()-&gt;lastHandledUserGestureTimestamp());
546 
547     return MonotonicTime::now() - lastKnownUserGestureTimestamp &lt; autostartSoonAfterUserGestureThreshold;
548 }
549 
550 void HTMLPlugInImageElement::checkSizeChangeForSnapshotting()
551 {
552     if (!m_needsCheckForSizeChange || m_snapshotDecision != MaySnapshotWhenResized || documentHadRecentUserGesture(document()))
553         return;
554 
555     m_needsCheckForSizeChange = false;
556 
557     auto contentBoxRect = downcast&lt;RenderBox&gt;(*renderer()).contentBoxRect();
558     int contentWidth = contentBoxRect.width();
559     int contentHeight = contentBoxRect.height();
560 
561     if (contentWidth &lt;= sizingTinyDimensionThreshold || contentHeight &lt;= sizingTinyDimensionThreshold)
562         return;
563 
564     LOG(Plugins, &quot;%p Plug-in originally avoided snapshotting because it was sized %dx%d. Now it is %dx%d. Tell it to snapshot.\n&quot;, this, m_sizeWhenSnapshotted.width(), m_sizeWhenSnapshotted.height(), contentWidth, contentHeight);
565     setDisplayState(WaitingForSnapshot);
566     m_snapshotDecision = Snapshotted;
567     auto widget = makeRefPtr(pluginWidget());
568     if (is&lt;PluginViewBase&gt;(widget))
569         downcast&lt;PluginViewBase&gt;(*widget).beginSnapshottingRunningPlugin();
570 }
571 
572 static inline bool is100Percent(Length length)
573 {
574     return length.isPercent() &amp;&amp; length.percent() == 100;
575 }
576 
577 static inline bool isSmallerThanTinySizingThreshold(const RenderEmbeddedObject&amp; renderer)
578 {
579     auto contentRect = renderer.contentBoxRect();
580     return contentRect.width() &lt;= sizingTinyDimensionThreshold || contentRect.height() &lt;= sizingTinyDimensionThreshold;
581 }
582 
583 bool HTMLPlugInImageElement::isTopLevelFullPagePlugin(const RenderEmbeddedObject&amp; renderer) const
584 {
585     ASSERT(document().frame());
586     auto&amp; frame = *document().frame();
587     if (!frame.isMainFrame())
588         return false;
589 
590     auto&amp; style = renderer.style();
591     auto visibleSize = frame.view()-&gt;visibleSize();
592     auto contentRect = renderer.contentBoxRect();
593     float contentWidth = contentRect.width();
594     float contentHeight = contentRect.height();
595     return is100Percent(style.width()) &amp;&amp; is100Percent(style.height()) &amp;&amp; contentWidth * contentHeight &gt; visibleSize.area().unsafeGet() * sizingFullPageAreaRatioThreshold;
596 }
597 
598 void HTMLPlugInImageElement::checkSnapshotStatus()
599 {
600     if (!is&lt;RenderSnapshottedPlugIn&gt;(*renderer())) {
601         if (displayState() == Playing)
602             checkSizeChangeForSnapshotting();
603         return;
604     }
605 
606     // If width and height styles were previously not set and we&#39;ve snapshotted the plugin we may need to restart the plugin so that its state can be updated appropriately.
607     if (!document().page()-&gt;settings().snapshotAllPlugIns() &amp;&amp; displayState() &lt;= DisplayingSnapshot &amp;&amp; !m_plugInDimensionsSpecified) {
608         auto&amp; renderer = downcast&lt;RenderSnapshottedPlugIn&gt;(*this-&gt;renderer());
609         if (!renderer.style().logicalWidth().isSpecified() &amp;&amp; !renderer.style().logicalHeight().isSpecified())
610             return;
611 
612         m_plugInDimensionsSpecified = true;
613         if (isTopLevelFullPagePlugin(renderer)) {
614             m_snapshotDecision = NeverSnapshot;
615             restartSnapshottedPlugIn();
616         } else if (isSmallerThanTinySizingThreshold(renderer)) {
617             m_snapshotDecision = MaySnapshotWhenResized;
618             restartSnapshottedPlugIn();
619         }
620         return;
621     }
622 
623     // Notify the shadow root that the size changed so that we may update the overlay layout.
624     ensureUserAgentShadowRoot().dispatchEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
625 }
626 
627 void HTMLPlugInImageElement::subframeLoaderWillCreatePlugIn(const URL&amp; url)
628 {
629     LOG(Plugins, &quot;%p Plug-in URL: %s&quot;, this, m_url.utf8().data());
630     LOG(Plugins, &quot;   Actual URL: %s&quot;, url.string().utf8().data());
631     LOG(Plugins, &quot;   MIME type: %s&quot;, serviceType().utf8().data());
632 
633     m_loadedUrl = url;
634     m_plugInWasCreated = false;
635     m_deferredPromotionToPrimaryPlugIn = false;
636 
637     if (!document().page() || !document().page()-&gt;settings().plugInSnapshottingEnabled()) {
638         m_snapshotDecision = NeverSnapshot;
639         return;
640     }
641 
642     if (displayState() == Restarting) {
643         LOG(Plugins, &quot;%p Plug-in is explicitly restarting&quot;, this);
644         m_snapshotDecision = NeverSnapshot;
645         setDisplayState(Playing);
646         return;
647     }
648 
649     if (displayState() == RestartingWithPendingMouseClick) {
650         LOG(Plugins, &quot;%p Plug-in is explicitly restarting but also waiting for a click&quot;, this);
651         m_snapshotDecision = NeverSnapshot;
652         return;
653     }
654 
655     if (m_snapshotDecision == NeverSnapshot) {
656         LOG(Plugins, &quot;%p Plug-in is blessed, allow it to start&quot;, this);
657         return;
658     }
659 
660     bool inMainFrame = document().frame()-&gt;isMainFrame();
661 
662     if (document().isPluginDocument() &amp;&amp; inMainFrame) {
663         LOG(Plugins, &quot;%p Plug-in document in main frame&quot;, this);
664         m_snapshotDecision = NeverSnapshot;
665         return;
666     }
667 
668     if (UserGestureIndicator::processingUserGesture()) {
669         LOG(Plugins, &quot;%p Script is currently processing user gesture, set to play&quot;, this);
670         m_snapshotDecision = NeverSnapshot;
671         return;
672     }
673 
674     if (m_createdDuringUserGesture) {
675         LOG(Plugins, &quot;%p Plug-in was created when processing user gesture, set to play&quot;, this);
676         m_snapshotDecision = NeverSnapshot;
677         return;
678     }
679 
680     if (documentHadRecentUserGesture(document())) {
681         LOG(Plugins, &quot;%p Plug-in was created shortly after a user gesture, set to play&quot;, this);
682         m_snapshotDecision = NeverSnapshot;
683         return;
684     }
685 
686     if (document().page()-&gt;settings().snapshotAllPlugIns()) {
687         LOG(Plugins, &quot;%p Plug-in forced to snapshot by user preference&quot;, this);
688         m_snapshotDecision = Snapshotted;
689         setDisplayState(WaitingForSnapshot);
690         return;
691     }
692 
693     if (document().page()-&gt;settings().autostartOriginPlugInSnapshottingEnabled() &amp;&amp; document().page()-&gt;plugInClient() &amp;&amp; document().page()-&gt;plugInClient()-&gt;shouldAutoStartFromOrigin(document().page()-&gt;mainFrame().document()-&gt;baseURL().host().toString(), url.host().toString(), serviceType())) {
694         LOG(Plugins, &quot;%p Plug-in from (%s, %s) is marked to auto-start, set to play&quot;, this, document().page()-&gt;mainFrame().document()-&gt;baseURL().host().utf8().data(), url.host().utf8().data());
695         m_snapshotDecision = NeverSnapshot;
696         return;
697     }
698 
699     if (m_loadedUrl.isEmpty() &amp;&amp; !serviceType().isEmpty()) {
700         LOG(Plugins, &quot;%p Plug-in has no src URL but does have a valid mime type %s, set to play&quot;, this, serviceType().utf8().data());
701         m_snapshotDecision = MaySnapshotWhenContentIsSet;
702         return;
703     }
704 
<a name="12" id="anc12"></a><span class="line-modified">705     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) &amp;&amp; !m_loadedUrl.host().isEmpty() &amp;&amp; m_loadedUrl.host() == document().page()-&gt;mainFrame().document()-&gt;baseURL().host()) {</span>
706         LOG(Plugins, &quot;%p Plug-in is served from page&#39;s domain, set to play&quot;, this);
707         m_snapshotDecision = NeverSnapshot;
708         return;
709     }
710 
711     auto&amp; renderer = downcast&lt;RenderEmbeddedObject&gt;(*this-&gt;renderer());
712     auto contentRect = renderer.contentBoxRect();
713     int contentWidth = contentRect.width();
714     int contentHeight = contentRect.height();
715 
716     m_plugInDimensionsSpecified = renderer.style().logicalWidth().isSpecified() || renderer.style().logicalHeight().isSpecified();
717 
718     if (isTopLevelFullPagePlugin(renderer)) {
719         LOG(Plugins, &quot;%p Plug-in is top level full page, set to play&quot;, this);
720         m_snapshotDecision = NeverSnapshot;
721         return;
722     }
723 
724     if (isSmallerThanTinySizingThreshold(renderer)) {
725         LOG(Plugins, &quot;%p Plug-in is very small %dx%d, set to play&quot;, this, contentWidth, contentHeight);
726         m_sizeWhenSnapshotted = IntSize(contentWidth, contentHeight);
727         m_snapshotDecision = MaySnapshotWhenResized;
728         return;
729     }
730 
731     if (!document().page()-&gt;plugInClient()) {
732         LOG(Plugins, &quot;%p There is no plug-in client. Set to wait for snapshot&quot;, this);
733         m_snapshotDecision = NeverSnapshot;
734         setDisplayState(WaitingForSnapshot);
735         return;
736     }
737 
738     LOG(Plugins, &quot;%p Plug-in from (%s, %s) is not auto-start, sized at %dx%d, set to wait for snapshot&quot;, this, document().topDocument().baseURL().host().utf8().data(), url.host().utf8().data(), contentWidth, contentHeight);
739     m_snapshotDecision = Snapshotted;
740     setDisplayState(WaitingForSnapshot);
741 }
742 
743 void HTMLPlugInImageElement::subframeLoaderDidCreatePlugIn(const Widget&amp; widget)
744 {
745     m_plugInWasCreated = true;
746 
747     if (is&lt;PluginViewBase&gt;(widget) &amp;&amp; downcast&lt;PluginViewBase&gt;(widget).shouldAlwaysAutoStart()) {
748         LOG(Plugins, &quot;%p Plug-in should auto-start, set to play&quot;, this);
749         m_snapshotDecision = NeverSnapshot;
750         setDisplayState(Playing);
751         return;
752     }
753 
754     if (m_deferredPromotionToPrimaryPlugIn) {
755         LOG(Plugins, &quot;%p Plug-in was created, previously deferred promotion to primary. Will promote&quot;, this);
756         setIsPrimarySnapshottedPlugIn(true);
757         m_deferredPromotionToPrimaryPlugIn = false;
758     }
759 }
760 
761 void HTMLPlugInImageElement::defaultEventHandler(Event&amp; event)
762 {
763     if (is&lt;RenderEmbeddedObject&gt;(renderer()) &amp;&amp; displayState() == WaitingForSnapshot &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; event.type() == eventNames().clickEvent) {
764         auto&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
765         if (mouseEvent.button() == LeftButton) {
766             userDidClickSnapshot(mouseEvent, true);
767             mouseEvent.setDefaultHandled();
768             return;
769         }
770     }
771     HTMLPlugInElement::defaultEventHandler(event);
772 }
773 
774 bool HTMLPlugInImageElement::canLoadPlugInContent(const String&amp; relativeURL, const String&amp; mimeType) const
775 {
776     // Elements in user agent show tree should load whatever the embedding document policy is.
777     if (isInUserAgentShadowTree())
778         return true;
779 
780     URL completedURL;
781     if (!relativeURL.isEmpty())
782         completedURL = document().completeURL(relativeURL);
783 
784     ASSERT(document().contentSecurityPolicy());
785     const ContentSecurityPolicy&amp; contentSecurityPolicy = *document().contentSecurityPolicy();
786 
787     contentSecurityPolicy.upgradeInsecureRequestIfNeeded(completedURL, ContentSecurityPolicy::InsecureRequestType::Load);
788 
789     if (!contentSecurityPolicy.allowObjectFromSource(completedURL))
790         return false;
791 
792     auto&amp; declaredMimeType = document().isPluginDocument() &amp;&amp; document().ownerElement() ?
793         document().ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::typeAttr) : attributeWithoutSynchronization(HTMLNames::typeAttr);
794     return contentSecurityPolicy.allowPluginType(mimeType, declaredMimeType, completedURL);
795 }
796 
797 bool HTMLPlugInImageElement::requestObject(const String&amp; relativeURL, const String&amp; mimeType, const Vector&lt;String&gt;&amp; paramNames, const Vector&lt;String&gt;&amp; paramValues)
798 {
799     ASSERT(document().frame());
800 
801     if (relativeURL.isEmpty() &amp;&amp; mimeType.isEmpty())
802         return false;
803 
804     if (!canLoadPlugInContent(relativeURL, mimeType)) {
805         renderEmbeddedObject()-&gt;setPluginUnavailabilityReason(RenderEmbeddedObject::PluginBlockedByContentSecurityPolicy);
806         return false;
807     }
808 
809     if (HTMLPlugInElement::requestObject(relativeURL, mimeType, paramNames, paramValues))
810         return true;
811 
812     return document().frame()-&gt;loader().subframeLoader().requestObject(*this, relativeURL, getNameAttribute(), mimeType, paramNames, paramValues);
813 }
814 
815 void HTMLPlugInImageElement::updateImageLoaderWithNewURLSoon()
816 {
817     if (m_needsImageReload)
818         return;
819 
820     m_needsImageReload = true;
821     scheduleUpdateForAfterStyleResolution();
822     invalidateStyle();
823 }
824 
825 } // namespace WebCore
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
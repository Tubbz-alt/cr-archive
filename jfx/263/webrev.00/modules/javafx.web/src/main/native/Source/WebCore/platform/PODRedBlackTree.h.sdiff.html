<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PODIntervalTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pasteboard.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.

  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 // A red-black tree, which is a form of a balanced binary tree. It
 27 // supports efficient insertion, deletion and queries of comparable
 28 // elements. The same element may be inserted multiple times. The
 29 // algorithmic complexity of common operations is:
 30 //
 31 //   Insertion: O(lg(n))
 32 //   Deletion:  O(lg(n))
 33 //   Querying:  O(lg(n))
 34 //
<span class="line-removed"> 35 // The data type T that is stored in this red-black tree must be only</span>
<span class="line-removed"> 36 // Plain Old Data (POD), or bottom out into POD. It must _not_ rely on</span>
<span class="line-removed"> 37 // having its destructor called. This implementation internally</span>
<span class="line-removed"> 38 // allocates storage in large chunks and does not call the destructor</span>
<span class="line-removed"> 39 // on each object.</span>
<span class="line-removed"> 40 //</span>
 41 // Type T must supply a default constructor, a copy constructor, and
 42 // the &quot;&lt;&quot; and &quot;==&quot; operators.
 43 //
 44 // In debug mode, printing of the data contained in the tree is
<span class="line-modified"> 45 // enabled. This requires the template specialization to be available:</span>
<span class="line-removed"> 46 //</span>
<span class="line-removed"> 47 //   template&lt;&gt; struct WebCore::ValueToString&lt;T&gt; {</span>
<span class="line-removed"> 48 //       static String string(const T&amp; t);</span>
<span class="line-removed"> 49 //   };</span>
<span class="line-removed"> 50 //</span>
<span class="line-removed"> 51 // Note that when complex types are stored in this red/black tree, it</span>
<span class="line-removed"> 52 // is possible that single invocations of the &quot;&lt;&quot; and &quot;==&quot; operators</span>
<span class="line-removed"> 53 // will be insufficient to describe the ordering of elements in the</span>
<span class="line-removed"> 54 // tree during queries. As a concrete example, consider the case where</span>
<span class="line-removed"> 55 // intervals are stored in the tree sorted by low endpoint. The &quot;&lt;&quot;</span>
<span class="line-removed"> 56 // operator on the Interval class only compares the low endpoint, but</span>
<span class="line-removed"> 57 // the &quot;==&quot; operator takes into account the high endpoint as well.</span>
<span class="line-removed"> 58 // This makes the necessary logic for querying and deletion somewhat</span>
<span class="line-removed"> 59 // more complex. In order to properly handle such situations, the</span>
<span class="line-removed"> 60 // property &quot;needsFullOrderingComparisons&quot; must be set to true on</span>
<span class="line-removed"> 61 // the tree.</span>
 62 //
 63 // This red-black tree is designed to be _augmented_; subclasses can
 64 // add additional and summary information to each node to efficiently
 65 // store and index more complex data structures. A concrete example is
 66 // the IntervalTree, which extends each node with a summary statistic
 67 // to efficiently store one-dimensional intervals.
 68 //
 69 // The design of this red-black tree comes from Cormen, Leiserson,
 70 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 71 
<span class="line-modified"> 72 #ifndef PODRedBlackTree_h</span>
<span class="line-removed"> 73 #define PODRedBlackTree_h</span>
 74 
 75 #include &lt;wtf/Assertions.h&gt;
 76 #include &lt;wtf/Noncopyable.h&gt;
<span class="line-modified"> 77 #include &lt;wtf/text/ValueToString.h&gt;</span>
 78 #ifndef NDEBUG
 79 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-modified"> 80 #include &lt;wtf/text/WTFString.h&gt;</span>
 81 #endif
 82 



 83 namespace WebCore {
 84 
<span class="line-modified"> 85 template&lt;class T&gt;</span>
<span class="line-modified"> 86 class PODRedBlackTree {</span>
<span class="line-removed"> 87     WTF_MAKE_FAST_ALLOCATED;</span>
 88 public:
<span class="line-modified"> 89     class Node;</span>
 90 
<span class="line-modified"> 91     // Visitor interface for walking all of the tree&#39;s elements.</span>
<span class="line-removed"> 92     class Visitor {</span>
<span class="line-removed"> 93     public:</span>
<span class="line-removed"> 94         virtual void visit(const T&amp; data) = 0;</span>
<span class="line-removed"> 95     protected:</span>
<span class="line-removed"> 96         virtual ~Visitor() = default;</span>
<span class="line-removed"> 97     };</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99     PODRedBlackTree()</span>
<span class="line-removed">100         : m_root(0)</span>
<span class="line-removed">101         , m_needsFullOrderingComparisons(false)</span>
<span class="line-removed">102 #ifndef NDEBUG</span>
<span class="line-removed">103         , m_verboseDebugging(false)</span>
<span class="line-removed">104 #endif</span>
<span class="line-removed">105     {</span>
<span class="line-removed">106     }</span>
<span class="line-removed">107 </span>
<span class="line-removed">108     virtual ~PODRedBlackTree()</span>
109     {
110         clear();
111     }
112 
<span class="line-removed">113     // Clearing will delete the contents of the tree. After this call</span>
<span class="line-removed">114     // isInitialized will return false.</span>
115     void clear()
116     {
<span class="line-modified">117         markFree(m_root);</span>
<span class="line-modified">118         m_root = 0;</span>






119     }
120 
121     void add(const T&amp; data)
122     {
<span class="line-modified">123         Node* node = new Node(data);</span>
<span class="line-modified">124         insertNode(node);</span>




125     }
126 
127     // Returns true if the datum was found in the tree.
128     bool remove(const T&amp; data)
129     {
130         Node* node = treeSearch(data);
131         if (node) {
132             deleteNode(node);
133             return true;
134         }
135         return false;
136     }
137 
138     bool contains(const T&amp; data) const
139     {
140         return treeSearch(data);
141     }
142 
<span class="line-modified">143     void visitInorder(Visitor* visitor) const</span>
144     {
<span class="line-modified">145         if (!m_root)</span>
<span class="line-removed">146             return;</span>
<span class="line-removed">147         visitInorderImpl(m_root, visitor);</span>
<span class="line-removed">148     }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150     int size() const</span>
<span class="line-removed">151     {</span>
<span class="line-removed">152         Counter counter;</span>
<span class="line-removed">153         visitInorder(&amp;counter);</span>
<span class="line-removed">154         return counter.count();</span>
155     }
156 
<span class="line-modified">157     // See the class documentation for an explanation of this property.</span>
<span class="line-removed">158     void setNeedsFullOrderingComparisons(bool needsFullOrderingComparisons)</span>
<span class="line-removed">159     {</span>
<span class="line-removed">160         m_needsFullOrderingComparisons = needsFullOrderingComparisons;</span>
<span class="line-removed">161     }</span>
162 
<span class="line-modified">163     virtual bool checkInvariants() const</span>
164     {
165         int blackCount;
<span class="line-modified">166         return checkInvariantsFromNode(m_root, &amp;blackCount);</span>
167     }
168 
<span class="line-modified">169 #ifndef NDEBUG</span>
<span class="line-removed">170     // Dumps the tree&#39;s contents to the logging info stream for</span>
<span class="line-removed">171     // debugging purposes.</span>
172     void dump() const
173     {
<span class="line-modified">174         dumpFromNode(m_root, 0);</span>
175     }
176 
177     // Turns on or off verbose debugging of the tree, causing many
178     // messages to be logged during insertion and other operations in
179     // debug mode.
180     void setVerboseDebugging(bool verboseDebugging)
181     {
182         m_verboseDebugging = verboseDebugging;
183     }

184 #endif
185 
<span class="line-modified">186     enum Color {</span>
<span class="line-modified">187         Red = 1,</span>
<span class="line-removed">188         Black</span>
<span class="line-removed">189     };</span>
190 
<span class="line-removed">191     // The base Node class which is stored in the tree. Nodes are only</span>
<span class="line-removed">192     // an internal concept; users of the tree deal only with the data</span>
<span class="line-removed">193     // they store in it.</span>
194     class Node {
195         WTF_MAKE_FAST_ALLOCATED;
196         WTF_MAKE_NONCOPYABLE(Node);
197     public:
<span class="line-modified">198         // Constructor. Newly-created nodes are colored red.</span>
<span class="line-modified">199         explicit Node(const T&amp; data)</span>
<span class="line-removed">200             : m_left(0)</span>
<span class="line-removed">201             , m_right(0)</span>
<span class="line-removed">202             , m_parent(0)</span>
<span class="line-removed">203             , m_color(Red)</span>
<span class="line-removed">204             , m_data(data)</span>
205         {
206         }
207 
<span class="line-removed">208         virtual ~Node() = default;</span>
<span class="line-removed">209 </span>
210         Color color() const { return m_color; }
211         void setColor(Color color) { m_color = color; }
212 
<span class="line-removed">213         // Fetches the user data.</span>
214         T&amp; data() { return m_data; }
215 
<span class="line-modified">216         // Copies all user-level fields from the source node, but not</span>
<span class="line-removed">217         // internal fields. For example, the base implementation of this</span>
<span class="line-removed">218         // method copies the &quot;m_data&quot; field, but not the child or parent</span>
<span class="line-removed">219         // fields. Any augmentation information also does not need to be</span>
<span class="line-removed">220         // copied, as it will be recomputed. Subclasses must call the</span>
<span class="line-removed">221         // superclass implementation.</span>
<span class="line-removed">222         virtual void copyFrom(Node* src) { m_data = src-&gt;data(); }</span>
223 
224         Node* left() const { return m_left; }
225         void setLeft(Node* node) { m_left = node; }
226 
227         Node* right() const { return m_right; }
228         void setRight(Node* node) { m_right = node; }
229 
230         Node* parent() const { return m_parent; }
231         void setParent(Node* node) { m_parent = node; }
232 
233     private:
<span class="line-modified">234         Node* m_left;</span>
<span class="line-modified">235         Node* m_right;</span>
<span class="line-modified">236         Node* m_parent;</span>
<span class="line-modified">237         Color m_color;</span>
238         T m_data;
239     };
240 
<span class="line-removed">241 protected:</span>
242     // Returns the root of the tree, which is needed by some subclasses.
243     Node* root() const { return m_root; }
244 
245 private:
<span class="line-modified">246     // This virtual method is the hook that subclasses should use when</span>
247     // augmenting the red-black tree with additional per-node summary
248     // information. For example, in the case of an interval tree, this
249     // is used to compute the maximum endpoint of the subtree below the
250     // given node based on the values in the left and right children. It
251     // is guaranteed that this will be called in the correct order to
252     // properly update such summary information based only on the values
<span class="line-modified">253     // in the left and right children. This method should return true if</span>
254     // the node&#39;s summary information changed.
<span class="line-modified">255     virtual bool updateNode(Node*) { return false; }</span>
<span class="line-removed">256 </span>
<span class="line-removed">257     //----------------------------------------------------------------------</span>
<span class="line-removed">258     // Generic binary search tree operations</span>
<span class="line-removed">259     //</span>
<span class="line-removed">260 </span>
<span class="line-removed">261     // Searches the tree for the given datum.</span>
<span class="line-removed">262     Node* treeSearch(const T&amp; data) const</span>
263     {
<span class="line-modified">264         if (m_needsFullOrderingComparisons)</span>
<span class="line-removed">265             return treeSearchFullComparisons(m_root, data);</span>
<span class="line-removed">266 </span>
<span class="line-removed">267         return treeSearchNormal(m_root, data);</span>
268     }
269 
<span class="line-modified">270     // Searches the tree using the normal comparison operations,</span>
<span class="line-removed">271     // suitable for simple data types such as numbers.</span>
<span class="line-removed">272     Node* treeSearchNormal(Node* current, const T&amp; data) const</span>
273     {
<span class="line-modified">274         while (current) {</span>
275             if (current-&gt;data() == data)
276                 return current;
277             if (data &lt; current-&gt;data())
278                 current = current-&gt;left();
279             else
280                 current = current-&gt;right();
281         }
<span class="line-modified">282         return 0;</span>
<span class="line-removed">283     }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     // Searches the tree using multiple comparison operations, required</span>
<span class="line-removed">286     // for data types with more complex behavior such as intervals.</span>
<span class="line-removed">287     Node* treeSearchFullComparisons(Node* current, const T&amp; data) const</span>
<span class="line-removed">288     {</span>
<span class="line-removed">289         if (!current)</span>
<span class="line-removed">290             return 0;</span>
<span class="line-removed">291         if (data &lt; current-&gt;data())</span>
<span class="line-removed">292             return treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">293         if (current-&gt;data() &lt; data)</span>
<span class="line-removed">294             return treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">295         if (data == current-&gt;data())</span>
<span class="line-removed">296             return current;</span>
<span class="line-removed">297 </span>
<span class="line-removed">298         // We may need to traverse both the left and right subtrees.</span>
<span class="line-removed">299         Node* result = treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">300         if (!result)</span>
<span class="line-removed">301             result = treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">302         return result;</span>
303     }
304 
305     void treeInsert(Node* z)
306     {
<span class="line-modified">307         Node* y = 0;</span>
308         Node* x = m_root;
309         while (x) {
310             y = x;
311             if (z-&gt;data() &lt; x-&gt;data())
312                 x = x-&gt;left();
313             else
314                 x = x-&gt;right();
315         }
316         z-&gt;setParent(y);
317         if (!y)
318             m_root = z;
319         else {
320             if (z-&gt;data() &lt; y-&gt;data())
321                 y-&gt;setLeft(z);
322             else
323                 y-&gt;setRight(z);
324         }
325     }
326 
327     // Finds the node following the given one in sequential ordering of
328     // their data, or null if none exists.
<span class="line-modified">329     Node* treeSuccessor(Node* x)</span>
330     {
331         if (x-&gt;right())
332             return treeMinimum(x-&gt;right());
333         Node* y = x-&gt;parent();
334         while (y &amp;&amp; x == y-&gt;right()) {
335             x = y;
336             y = y-&gt;parent();
337         }
338         return y;
339     }
340 
<span class="line-modified">341     // Finds the minimum element in the sub-tree rooted at the given</span>
<span class="line-modified">342     // node.</span>
<span class="line-removed">343     Node* treeMinimum(Node* x)</span>
344     {
345         while (x-&gt;left())
346             x = x-&gt;left();
347         return x;
348     }
349 
<span class="line-modified">350     // Helper for maintaining the augmented red-black tree.</span>
<span class="line-removed">351     void propagateUpdates(Node* start)</span>
352     {
<span class="line-modified">353         bool shouldContinue = true;</span>
<span class="line-modified">354         while (start &amp;&amp; shouldContinue) {</span>
<span class="line-modified">355             shouldContinue = updateNode(start);</span>
<span class="line-modified">356             start = start-&gt;parent();</span>
<span class="line-removed">357         }</span>
358     }
359 
360     //----------------------------------------------------------------------
361     // Red-Black tree operations
362     //
363 
364     // Left-rotates the subtree rooted at x.
365     // Returns the new root of the subtree (x&#39;s right child).
366     Node* leftRotate(Node* x)
367     {
368         // Set y.
369         Node* y = x-&gt;right();
370 
371         // Turn y&#39;s left subtree into x&#39;s right subtree.
372         x-&gt;setRight(y-&gt;left());
373         if (y-&gt;left())
374             y-&gt;left()-&gt;setParent(x);
375 
376         // Link x&#39;s parent to y.
377         y-&gt;setParent(x-&gt;parent());
378         if (!x-&gt;parent())
379             m_root = y;
380         else {
381             if (x == x-&gt;parent()-&gt;left())
382                 x-&gt;parent()-&gt;setLeft(y);
383             else
384                 x-&gt;parent()-&gt;setRight(y);
385         }
386 
387         // Put x on y&#39;s left.
388         y-&gt;setLeft(x);
389         x-&gt;setParent(y);
390 
391         // Update nodes lowest to highest.
<span class="line-modified">392         updateNode(x);</span>
<span class="line-modified">393         updateNode(y);</span>
394         return y;
395     }
396 






397     // Right-rotates the subtree rooted at y.
398     // Returns the new root of the subtree (y&#39;s left child).
399     Node* rightRotate(Node* y)
400     {
401         // Set x.
402         Node* x = y-&gt;left();
403 
404         // Turn x&#39;s right subtree into y&#39;s left subtree.
405         y-&gt;setLeft(x-&gt;right());
406         if (x-&gt;right())
407             x-&gt;right()-&gt;setParent(y);
408 
409         // Link y&#39;s parent to x.
410         x-&gt;setParent(y-&gt;parent());
411         if (!y-&gt;parent())
412             m_root = x;
413         else {
414             if (y == y-&gt;parent()-&gt;left())
415                 y-&gt;parent()-&gt;setLeft(x);
416             else
417                 y-&gt;parent()-&gt;setRight(x);
418         }
419 
420         // Put y on x&#39;s right.
421         x-&gt;setRight(y);
422         y-&gt;setParent(x);
423 
424         // Update nodes lowest to highest.
<span class="line-modified">425         updateNode(y);</span>
<span class="line-modified">426         updateNode(x);</span>
427         return x;
428     }
429 
430     // Inserts the given node into the tree.
431     void insertNode(Node* x)
432     {
433         treeInsert(x);
434         x-&gt;setColor(Red);
<span class="line-modified">435         updateNode(x);</span>
436 
437         logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
438 
439         // The node from which to start propagating updates upwards.
440         Node* updateStart = x-&gt;parent();
441 
442         while (x != m_root &amp;&amp; x-&gt;parent()-&gt;color() == Red) {
443             if (x-&gt;parent() == x-&gt;parent()-&gt;parent()-&gt;left()) {
444                 Node* y = x-&gt;parent()-&gt;parent()-&gt;right();
445                 if (y &amp;&amp; y-&gt;color() == Red) {
446                     // Case 1
447                     logIfVerbose(&quot;  Case 1/1&quot;);
448                     x-&gt;parent()-&gt;setColor(Black);
449                     y-&gt;setColor(Black);
450                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">451                     updateNode(x-&gt;parent());</span>
452                     x = x-&gt;parent()-&gt;parent();
<span class="line-modified">453                     updateNode(x);</span>
454                     updateStart = x-&gt;parent();
455                 } else {
456                     if (x == x-&gt;parent()-&gt;right()) {
457                         logIfVerbose(&quot;  Case 1/2&quot;);
458                         // Case 2
459                         x = x-&gt;parent();
460                         leftRotate(x);
461                     }
462                     // Case 3
463                     logIfVerbose(&quot;  Case 1/3&quot;);
464                     x-&gt;parent()-&gt;setColor(Black);
465                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
466                     Node* newSubTreeRoot = rightRotate(x-&gt;parent()-&gt;parent());
467                     updateStart = newSubTreeRoot-&gt;parent();
468                 }
469             } else {
470                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot; exchanged.
471                 Node* y = x-&gt;parent()-&gt;parent()-&gt;left();
472                 if (y &amp;&amp; y-&gt;color() == Red) {
473                     // Case 1
474                     logIfVerbose(&quot;  Case 2/1&quot;);
475                     x-&gt;parent()-&gt;setColor(Black);
476                     y-&gt;setColor(Black);
477                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">478                     updateNode(x-&gt;parent());</span>
479                     x = x-&gt;parent()-&gt;parent();
<span class="line-modified">480                     updateNode(x);</span>
481                     updateStart = x-&gt;parent();
482                 } else {
483                     if (x == x-&gt;parent()-&gt;left()) {
484                         // Case 2
485                         logIfVerbose(&quot;  Case 2/2&quot;);
486                         x = x-&gt;parent();
487                         rightRotate(x);
488                     }
489                     // Case 3
490                     logIfVerbose(&quot;  Case 2/3&quot;);
491                     x-&gt;parent()-&gt;setColor(Black);
492                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
493                     Node* newSubTreeRoot = leftRotate(x-&gt;parent()-&gt;parent());
494                     updateStart = newSubTreeRoot-&gt;parent();
495                 }
496             }
497         }
498 
499         propagateUpdates(updateStart);
500 
501         m_root-&gt;setColor(Black);
502     }
503 
504     // Restores the red-black property to the tree after splicing out
<span class="line-modified">505     // a node. Note that x may be null, which is why xParent must be</span>
<span class="line-removed">506     // supplied.</span>
507     void deleteFixup(Node* x, Node* xParent)
508     {
509         while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
510             if (x == xParent-&gt;left()) {
511                 // Note: the text points out that w can not be null.
512                 // The reason is not obvious from simply looking at
513                 // the code; it comes about from the properties of the
514                 // red-black tree.
515                 Node* w = xParent-&gt;right();
516                 ASSERT(w); // x&#39;s sibling should not be null.
517                 if (w-&gt;color() == Red) {
518                     // Case 1
519                     w-&gt;setColor(Black);
520                     xParent-&gt;setColor(Red);
521                     leftRotate(xParent);
522                     w = xParent-&gt;right();
523                 }
524                 if ((!w-&gt;left() || w-&gt;left()-&gt;color() == Black)
525                     &amp;&amp; (!w-&gt;right() || w-&gt;right()-&gt;color() == Black)) {
526                     // Case 2
</pre>
<hr />
<pre>
610         else
611             x = y-&gt;right();
612 
613         // X is the child of y which might potentially replace y in
614         // the tree. X might be null at this point.
615         Node* xParent;
616         if (x) {
617             x-&gt;setParent(y-&gt;parent());
618             xParent = x-&gt;parent();
619         } else
620             xParent = y-&gt;parent();
621         if (!y-&gt;parent())
622             m_root = x;
623         else {
624             if (y == y-&gt;parent()-&gt;left())
625                 y-&gt;parent()-&gt;setLeft(x);
626             else
627                 y-&gt;parent()-&gt;setRight(x);
628         }
629         if (y != z) {
<span class="line-modified">630             z-&gt;copyFrom(y);</span>
631             // This node has changed location in the tree and must be updated.
<span class="line-modified">632             updateNode(z);</span>
633             // The parent and its parents may now be out of date.
634             propagateUpdates(z-&gt;parent());
635         }
636 
637         // If we haven&#39;t already updated starting from xParent, do so now.
638         if (xParent &amp;&amp; xParent != y &amp;&amp; xParent != z)
639             propagateUpdates(xParent);
640         if (y-&gt;color() == Black)
641             deleteFixup(x, xParent);
642 
643         delete y;
644     }
645 
<span class="line-removed">646     // Visits the subtree rooted at the given node in order.</span>
<span class="line-removed">647     void visitInorderImpl(Node* node, Visitor* visitor) const</span>
<span class="line-removed">648     {</span>
<span class="line-removed">649         if (node-&gt;left())</span>
<span class="line-removed">650             visitInorderImpl(node-&gt;left(), visitor);</span>
<span class="line-removed">651         visitor-&gt;visit(node-&gt;data());</span>
<span class="line-removed">652         if (node-&gt;right())</span>
<span class="line-removed">653             visitInorderImpl(node-&gt;right(), visitor);</span>
<span class="line-removed">654     }</span>
<span class="line-removed">655 </span>
<span class="line-removed">656     void markFree(Node *node)</span>
<span class="line-removed">657     {</span>
<span class="line-removed">658         if (!node)</span>
<span class="line-removed">659             return;</span>
<span class="line-removed">660 </span>
<span class="line-removed">661         if (node-&gt;left())</span>
<span class="line-removed">662             markFree(node-&gt;left());</span>
<span class="line-removed">663         if (node-&gt;right())</span>
<span class="line-removed">664             markFree(node-&gt;right());</span>
<span class="line-removed">665         delete node;</span>
<span class="line-removed">666     }</span>
<span class="line-removed">667 </span>
<span class="line-removed">668     //----------------------------------------------------------------------</span>
<span class="line-removed">669     // Helper class for size()</span>
<span class="line-removed">670 </span>
<span class="line-removed">671     // A Visitor which simply counts the number of visited elements.</span>
<span class="line-removed">672     class Counter : public Visitor {</span>
<span class="line-removed">673         WTF_MAKE_NONCOPYABLE(Counter);</span>
<span class="line-removed">674     public:</span>
<span class="line-removed">675         Counter()</span>
<span class="line-removed">676             : m_count(0) { }</span>
<span class="line-removed">677 </span>
<span class="line-removed">678         void visit(const T&amp;) override { ++m_count; }</span>
<span class="line-removed">679         int count() const { return m_count; }</span>
<span class="line-removed">680 </span>
<span class="line-removed">681     private:</span>
<span class="line-removed">682         int m_count;</span>
<span class="line-removed">683     };</span>
<span class="line-removed">684 </span>
685     //----------------------------------------------------------------------
686     // Verification and debugging routines
687     //
688 


689     // Returns in the &quot;blackCount&quot; parameter the number of black
690     // children along all paths to all leaves of the given node.
<span class="line-modified">691     bool checkInvariantsFromNode(Node* node, int* blackCount) const</span>
692     {
693         // Base case is a leaf node.
694         if (!node) {
<span class="line-modified">695             *blackCount = 1;</span>
696             return true;
697         }
698 
699         // Each node is either red or black.
700         if (!(node-&gt;color() == Red || node-&gt;color() == Black))
701             return false;
702 
703         // Every leaf (or null) is black.
704 
705         if (node-&gt;color() == Red) {
706             // Both of its children are black.
707             if (!((!node-&gt;left() || node-&gt;left()-&gt;color() == Black)))
708                 return false;
709             if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
710                 return false;
711         }
712 
<span class="line-modified">713         // Every simple path to a leaf node contains the same number of</span>
<span class="line-removed">714         // black nodes.</span>
715         int leftCount = 0, rightCount = 0;
<span class="line-modified">716         bool leftValid = checkInvariantsFromNode(node-&gt;left(), &amp;leftCount);</span>
<span class="line-modified">717         bool rightValid = checkInvariantsFromNode(node-&gt;right(), &amp;rightCount);</span>
718         if (!leftValid || !rightValid)
719             return false;
<span class="line-modified">720         *blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
721         return leftCount == rightCount;
722     }
723 


724 #ifdef NDEBUG
725     void logIfVerbose(const char*) const { }
726 #else
727     void logIfVerbose(const char* output) const
728     {
729         if (m_verboseDebugging)
730             LOG_ERROR(&quot;%s&quot;, output);
731     }
732 #endif
733 
734 #ifndef NDEBUG
<span class="line-modified">735     // Dumps the subtree rooted at the given node.</span>
<span class="line-modified">736     void dumpFromNode(Node* node, int indentation) const</span>
737     {
738         StringBuilder builder;
739         for (int i = 0; i &lt; indentation; i++)
740             builder.append(&#39; &#39;);
741         builder.append(&#39;-&#39;);
742         if (node) {
743             builder.append(&#39; &#39;);
<span class="line-modified">744             builder.append(ValueToString&lt;T&gt;::string(node-&gt;data()));</span>


745             builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
746         }
<span class="line-modified">747         LOG_ERROR(&quot;%s&quot;, builder.toString().ascii().data());</span>
748         if (node) {
<span class="line-modified">749             dumpFromNode(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">750             dumpFromNode(node-&gt;right(), indentation + 2);</span>
751         }
752     }
<span class="line-removed">753 #endif</span>
754 
<span class="line-modified">755     //----------------------------------------------------------------------</span>
<span class="line-removed">756     // Data members</span>
757 
<span class="line-modified">758     Node* m_root;</span>
<span class="line-removed">759     bool m_needsFullOrderingComparisons;</span>
760 #ifndef NDEBUG
<span class="line-modified">761     bool m_verboseDebugging;</span>
762 #endif
763 };
764 
765 } // namespace WebCore
<span class="line-removed">766 </span>
<span class="line-removed">767 #endif // PODRedBlackTree_h</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<span class="line-added">  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // A red-black tree, which is a form of a balanced binary tree. It
 28 // supports efficient insertion, deletion and queries of comparable
 29 // elements. The same element may be inserted multiple times. The
 30 // algorithmic complexity of common operations is:
 31 //
 32 //   Insertion: O(lg(n))
 33 //   Deletion:  O(lg(n))
 34 //   Querying:  O(lg(n))
 35 //






 36 // Type T must supply a default constructor, a copy constructor, and
 37 // the &quot;&lt;&quot; and &quot;==&quot; operators.
 38 //
 39 // In debug mode, printing of the data contained in the tree is
<span class="line-modified"> 40 // enabled. This makes use of WTF::TextStream.</span>
















 41 //
 42 // This red-black tree is designed to be _augmented_; subclasses can
 43 // add additional and summary information to each node to efficiently
 44 // store and index more complex data structures. A concrete example is
 45 // the IntervalTree, which extends each node with a summary statistic
 46 // to efficiently store one-dimensional intervals.
 47 //
 48 // The design of this red-black tree comes from Cormen, Leiserson,
 49 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 50 
<span class="line-modified"> 51 #pragma once</span>

 52 
 53 #include &lt;wtf/Assertions.h&gt;
 54 #include &lt;wtf/Noncopyable.h&gt;
<span class="line-modified"> 55 </span>
 56 #ifndef NDEBUG
 57 #include &lt;wtf/text/StringBuilder.h&gt;
<span class="line-modified"> 58 #include &lt;wtf/text/TextStream.h&gt;</span>
 59 #endif
 60 
<span class="line-added"> 61 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types too.</span>
<span class="line-added"> 62 // FIXME: Extend WTF::RedBlackTree and implement this on top of it rather than keeping two quite similar class templates around.</span>
<span class="line-added"> 63 </span>
 64 namespace WebCore {
 65 
<span class="line-modified"> 66 template&lt;typename T, typename NodeUpdaterType&gt; class PODRedBlackTree {</span>
<span class="line-modified"> 67     WTF_MAKE_NONCOPYABLE(PODRedBlackTree);</span>

 68 public:
<span class="line-modified"> 69     PODRedBlackTree() = default;</span>
 70 
<span class="line-modified"> 71     ~PODRedBlackTree()</span>

















 72     {
 73         clear();
 74     }
 75 


 76     void clear()
 77     {
<span class="line-modified"> 78         if (!m_root)</span>
<span class="line-modified"> 79             return;</span>
<span class="line-added"> 80         Node* next;</span>
<span class="line-added"> 81         for (Node* node = treeMinimum(m_root); node; node = next) {</span>
<span class="line-added"> 82             next = treeSuccessorInPostOrder(node);</span>
<span class="line-added"> 83             delete node;</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85         m_root = nullptr;</span>
 86     }
 87 
 88     void add(const T&amp; data)
 89     {
<span class="line-modified"> 90         add(T { data });</span>
<span class="line-modified"> 91     }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     void add(T&amp;&amp; data)</span>
<span class="line-added"> 94     {</span>
<span class="line-added"> 95         insertNode(new Node(WTFMove(data)));</span>
 96     }
 97 
 98     // Returns true if the datum was found in the tree.
 99     bool remove(const T&amp; data)
100     {
101         Node* node = treeSearch(data);
102         if (node) {
103             deleteNode(node);
104             return true;
105         }
106         return false;
107     }
108 
109     bool contains(const T&amp; data) const
110     {
111         return treeSearch(data);
112     }
113 
<span class="line-modified">114     bool isEmpty() const</span>
115     {
<span class="line-modified">116         return !m_root;</span>









117     }
118 
<span class="line-modified">119 #ifndef NDEBUG</span>




120 
<span class="line-modified">121     bool checkInvariants() const</span>
122     {
123         int blackCount;
<span class="line-modified">124         return checkInvariantsFromNode(m_root, blackCount);</span>
125     }
126 
<span class="line-modified">127     // Dumps the tree&#39;s contents to the logging info stream for debugging purposes.</span>


128     void dump() const
129     {
<span class="line-modified">130         dumpSubtree(m_root, 0);</span>
131     }
132 
133     // Turns on or off verbose debugging of the tree, causing many
134     // messages to be logged during insertion and other operations in
135     // debug mode.
136     void setVerboseDebugging(bool verboseDebugging)
137     {
138         m_verboseDebugging = verboseDebugging;
139     }
<span class="line-added">140 </span>
141 #endif
142 
<span class="line-modified">143 protected:</span>
<span class="line-modified">144     enum Color { Red, Black };</span>


145 



146     class Node {
147         WTF_MAKE_FAST_ALLOCATED;
148         WTF_MAKE_NONCOPYABLE(Node);
149     public:
<span class="line-modified">150         explicit Node(T&amp;&amp; data)</span>
<span class="line-modified">151             : m_data(WTFMove(data))</span>





152         {
153         }
154 


155         Color color() const { return m_color; }
156         void setColor(Color color) { m_color = color; }
157 

158         T&amp; data() { return m_data; }
159 
<span class="line-modified">160         void moveDataFrom(Node&amp; src) { m_data = WTFMove(src.m_data); }</span>






161 
162         Node* left() const { return m_left; }
163         void setLeft(Node* node) { m_left = node; }
164 
165         Node* right() const { return m_right; }
166         void setRight(Node* node) { m_right = node; }
167 
168         Node* parent() const { return m_parent; }
169         void setParent(Node* node) { m_parent = node; }
170 
171     private:
<span class="line-modified">172         Node* m_left { nullptr };</span>
<span class="line-modified">173         Node* m_right { nullptr };</span>
<span class="line-modified">174         Node* m_parent { nullptr };</span>
<span class="line-modified">175         Color m_color { Red };</span>
176         T m_data;
177     };
178 

179     // Returns the root of the tree, which is needed by some subclasses.
180     Node* root() const { return m_root; }
181 
182 private:
<span class="line-modified">183     // The update function is the hook that subclasses should use when</span>
184     // augmenting the red-black tree with additional per-node summary
185     // information. For example, in the case of an interval tree, this
186     // is used to compute the maximum endpoint of the subtree below the
187     // given node based on the values in the left and right children. It
188     // is guaranteed that this will be called in the correct order to
189     // properly update such summary information based only on the values
<span class="line-modified">190     // in the left and right children. The function should return true if</span>
191     // the node&#39;s summary information changed.
<span class="line-modified">192     static bool updateNode(Node&amp; node)</span>







193     {
<span class="line-modified">194         return NodeUpdaterType::update(node);</span>



195     }
196 
<span class="line-modified">197     Node* treeSearch(const T&amp; data) const</span>


198     {
<span class="line-modified">199         for (auto* current = m_root; current; ) {</span>
200             if (current-&gt;data() == data)
201                 return current;
202             if (data &lt; current-&gt;data())
203                 current = current-&gt;left();
204             else
205                 current = current-&gt;right();
206         }
<span class="line-modified">207         return nullptr;</span>




















208     }
209 
210     void treeInsert(Node* z)
211     {
<span class="line-modified">212         Node* y = nullptr;</span>
213         Node* x = m_root;
214         while (x) {
215             y = x;
216             if (z-&gt;data() &lt; x-&gt;data())
217                 x = x-&gt;left();
218             else
219                 x = x-&gt;right();
220         }
221         z-&gt;setParent(y);
222         if (!y)
223             m_root = z;
224         else {
225             if (z-&gt;data() &lt; y-&gt;data())
226                 y-&gt;setLeft(z);
227             else
228                 y-&gt;setRight(z);
229         }
230     }
231 
232     // Finds the node following the given one in sequential ordering of
233     // their data, or null if none exists.
<span class="line-modified">234     static Node* treeSuccessor(Node* x)</span>
235     {
236         if (x-&gt;right())
237             return treeMinimum(x-&gt;right());
238         Node* y = x-&gt;parent();
239         while (y &amp;&amp; x == y-&gt;right()) {
240             x = y;
241             y = y-&gt;parent();
242         }
243         return y;
244     }
245 
<span class="line-modified">246     // Finds the minimum element in the sub-tree rooted at the given node.</span>
<span class="line-modified">247     static Node* treeMinimum(Node* x)</span>

248     {
249         while (x-&gt;left())
250             x = x-&gt;left();
251         return x;
252     }
253 
<span class="line-modified">254     static Node* treeSuccessorInPostOrder(Node* x)</span>

255     {
<span class="line-modified">256         Node* y = x-&gt;parent();</span>
<span class="line-modified">257         if (y &amp;&amp; x == y-&gt;left() &amp;&amp; y-&gt;right())</span>
<span class="line-modified">258             return treeMinimum(y-&gt;right());</span>
<span class="line-modified">259         return y;</span>

260     }
261 
262     //----------------------------------------------------------------------
263     // Red-Black tree operations
264     //
265 
266     // Left-rotates the subtree rooted at x.
267     // Returns the new root of the subtree (x&#39;s right child).
268     Node* leftRotate(Node* x)
269     {
270         // Set y.
271         Node* y = x-&gt;right();
272 
273         // Turn y&#39;s left subtree into x&#39;s right subtree.
274         x-&gt;setRight(y-&gt;left());
275         if (y-&gt;left())
276             y-&gt;left()-&gt;setParent(x);
277 
278         // Link x&#39;s parent to y.
279         y-&gt;setParent(x-&gt;parent());
280         if (!x-&gt;parent())
281             m_root = y;
282         else {
283             if (x == x-&gt;parent()-&gt;left())
284                 x-&gt;parent()-&gt;setLeft(y);
285             else
286                 x-&gt;parent()-&gt;setRight(y);
287         }
288 
289         // Put x on y&#39;s left.
290         y-&gt;setLeft(x);
291         x-&gt;setParent(y);
292 
293         // Update nodes lowest to highest.
<span class="line-modified">294         updateNode(*x);</span>
<span class="line-modified">295         updateNode(*y);</span>
296         return y;
297     }
298 
<span class="line-added">299     static void propagateUpdates(Node* start)</span>
<span class="line-added">300     {</span>
<span class="line-added">301         while (start &amp;&amp; updateNode(*start))</span>
<span class="line-added">302             start = start-&gt;parent();</span>
<span class="line-added">303     }</span>
<span class="line-added">304 </span>
305     // Right-rotates the subtree rooted at y.
306     // Returns the new root of the subtree (y&#39;s left child).
307     Node* rightRotate(Node* y)
308     {
309         // Set x.
310         Node* x = y-&gt;left();
311 
312         // Turn x&#39;s right subtree into y&#39;s left subtree.
313         y-&gt;setLeft(x-&gt;right());
314         if (x-&gt;right())
315             x-&gt;right()-&gt;setParent(y);
316 
317         // Link y&#39;s parent to x.
318         x-&gt;setParent(y-&gt;parent());
319         if (!y-&gt;parent())
320             m_root = x;
321         else {
322             if (y == y-&gt;parent()-&gt;left())
323                 y-&gt;parent()-&gt;setLeft(x);
324             else
325                 y-&gt;parent()-&gt;setRight(x);
326         }
327 
328         // Put y on x&#39;s right.
329         x-&gt;setRight(y);
330         y-&gt;setParent(x);
331 
332         // Update nodes lowest to highest.
<span class="line-modified">333         updateNode(*y);</span>
<span class="line-modified">334         updateNode(*x);</span>
335         return x;
336     }
337 
338     // Inserts the given node into the tree.
339     void insertNode(Node* x)
340     {
341         treeInsert(x);
342         x-&gt;setColor(Red);
<span class="line-modified">343         updateNode(*x);</span>
344 
345         logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
346 
347         // The node from which to start propagating updates upwards.
348         Node* updateStart = x-&gt;parent();
349 
350         while (x != m_root &amp;&amp; x-&gt;parent()-&gt;color() == Red) {
351             if (x-&gt;parent() == x-&gt;parent()-&gt;parent()-&gt;left()) {
352                 Node* y = x-&gt;parent()-&gt;parent()-&gt;right();
353                 if (y &amp;&amp; y-&gt;color() == Red) {
354                     // Case 1
355                     logIfVerbose(&quot;  Case 1/1&quot;);
356                     x-&gt;parent()-&gt;setColor(Black);
357                     y-&gt;setColor(Black);
358                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">359                     updateNode(*x-&gt;parent());</span>
360                     x = x-&gt;parent()-&gt;parent();
<span class="line-modified">361                     updateNode(*x);</span>
362                     updateStart = x-&gt;parent();
363                 } else {
364                     if (x == x-&gt;parent()-&gt;right()) {
365                         logIfVerbose(&quot;  Case 1/2&quot;);
366                         // Case 2
367                         x = x-&gt;parent();
368                         leftRotate(x);
369                     }
370                     // Case 3
371                     logIfVerbose(&quot;  Case 1/3&quot;);
372                     x-&gt;parent()-&gt;setColor(Black);
373                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
374                     Node* newSubTreeRoot = rightRotate(x-&gt;parent()-&gt;parent());
375                     updateStart = newSubTreeRoot-&gt;parent();
376                 }
377             } else {
378                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot; exchanged.
379                 Node* y = x-&gt;parent()-&gt;parent()-&gt;left();
380                 if (y &amp;&amp; y-&gt;color() == Red) {
381                     // Case 1
382                     logIfVerbose(&quot;  Case 2/1&quot;);
383                     x-&gt;parent()-&gt;setColor(Black);
384                     y-&gt;setColor(Black);
385                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<span class="line-modified">386                     updateNode(*x-&gt;parent());</span>
387                     x = x-&gt;parent()-&gt;parent();
<span class="line-modified">388                     updateNode(*x);</span>
389                     updateStart = x-&gt;parent();
390                 } else {
391                     if (x == x-&gt;parent()-&gt;left()) {
392                         // Case 2
393                         logIfVerbose(&quot;  Case 2/2&quot;);
394                         x = x-&gt;parent();
395                         rightRotate(x);
396                     }
397                     // Case 3
398                     logIfVerbose(&quot;  Case 2/3&quot;);
399                     x-&gt;parent()-&gt;setColor(Black);
400                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
401                     Node* newSubTreeRoot = leftRotate(x-&gt;parent()-&gt;parent());
402                     updateStart = newSubTreeRoot-&gt;parent();
403                 }
404             }
405         }
406 
407         propagateUpdates(updateStart);
408 
409         m_root-&gt;setColor(Black);
410     }
411 
412     // Restores the red-black property to the tree after splicing out
<span class="line-modified">413     // a node. Note that x may be null, which is why xParent must be supplied.</span>

414     void deleteFixup(Node* x, Node* xParent)
415     {
416         while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
417             if (x == xParent-&gt;left()) {
418                 // Note: the text points out that w can not be null.
419                 // The reason is not obvious from simply looking at
420                 // the code; it comes about from the properties of the
421                 // red-black tree.
422                 Node* w = xParent-&gt;right();
423                 ASSERT(w); // x&#39;s sibling should not be null.
424                 if (w-&gt;color() == Red) {
425                     // Case 1
426                     w-&gt;setColor(Black);
427                     xParent-&gt;setColor(Red);
428                     leftRotate(xParent);
429                     w = xParent-&gt;right();
430                 }
431                 if ((!w-&gt;left() || w-&gt;left()-&gt;color() == Black)
432                     &amp;&amp; (!w-&gt;right() || w-&gt;right()-&gt;color() == Black)) {
433                     // Case 2
</pre>
<hr />
<pre>
517         else
518             x = y-&gt;right();
519 
520         // X is the child of y which might potentially replace y in
521         // the tree. X might be null at this point.
522         Node* xParent;
523         if (x) {
524             x-&gt;setParent(y-&gt;parent());
525             xParent = x-&gt;parent();
526         } else
527             xParent = y-&gt;parent();
528         if (!y-&gt;parent())
529             m_root = x;
530         else {
531             if (y == y-&gt;parent()-&gt;left())
532                 y-&gt;parent()-&gt;setLeft(x);
533             else
534                 y-&gt;parent()-&gt;setRight(x);
535         }
536         if (y != z) {
<span class="line-modified">537             z-&gt;moveDataFrom(*y);</span>
538             // This node has changed location in the tree and must be updated.
<span class="line-modified">539             updateNode(*z);</span>
540             // The parent and its parents may now be out of date.
541             propagateUpdates(z-&gt;parent());
542         }
543 
544         // If we haven&#39;t already updated starting from xParent, do so now.
545         if (xParent &amp;&amp; xParent != y &amp;&amp; xParent != z)
546             propagateUpdates(xParent);
547         if (y-&gt;color() == Black)
548             deleteFixup(x, xParent);
549 
550         delete y;
551     }
552 







































553     //----------------------------------------------------------------------
554     // Verification and debugging routines
555     //
556 
<span class="line-added">557 #ifndef NDEBUG</span>
<span class="line-added">558 </span>
559     // Returns in the &quot;blackCount&quot; parameter the number of black
560     // children along all paths to all leaves of the given node.
<span class="line-modified">561     bool checkInvariantsFromNode(Node* node, int&amp; blackCount) const</span>
562     {
563         // Base case is a leaf node.
564         if (!node) {
<span class="line-modified">565             blackCount = 1;</span>
566             return true;
567         }
568 
569         // Each node is either red or black.
570         if (!(node-&gt;color() == Red || node-&gt;color() == Black))
571             return false;
572 
573         // Every leaf (or null) is black.
574 
575         if (node-&gt;color() == Red) {
576             // Both of its children are black.
577             if (!((!node-&gt;left() || node-&gt;left()-&gt;color() == Black)))
578                 return false;
579             if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
580                 return false;
581         }
582 
<span class="line-modified">583         // Every simple path to a leaf node contains the same number of black nodes.</span>

584         int leftCount = 0, rightCount = 0;
<span class="line-modified">585         bool leftValid = checkInvariantsFromNode(node-&gt;left(), leftCount);</span>
<span class="line-modified">586         bool rightValid = checkInvariantsFromNode(node-&gt;right(), rightCount);</span>
587         if (!leftValid || !rightValid)
588             return false;
<span class="line-modified">589         blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
590         return leftCount == rightCount;
591     }
592 
<span class="line-added">593 #endif</span>
<span class="line-added">594 </span>
595 #ifdef NDEBUG
596     void logIfVerbose(const char*) const { }
597 #else
598     void logIfVerbose(const char* output) const
599     {
600         if (m_verboseDebugging)
601             LOG_ERROR(&quot;%s&quot;, output);
602     }
603 #endif
604 
605 #ifndef NDEBUG
<span class="line-modified">606 </span>
<span class="line-modified">607     void dumpSubtree(Node* node, int indentation) const</span>
608     {
609         StringBuilder builder;
610         for (int i = 0; i &lt; indentation; i++)
611             builder.append(&#39; &#39;);
612         builder.append(&#39;-&#39;);
613         if (node) {
614             builder.append(&#39; &#39;);
<span class="line-modified">615             TextStream stream;</span>
<span class="line-added">616             stream &lt;&lt; node-&gt;data();</span>
<span class="line-added">617             builder.append(stream.release());</span>
618             builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
619         }
<span class="line-modified">620         LOG_ERROR(&quot;%s&quot;, builder.toString().utf8().data());</span>
621         if (node) {
<span class="line-modified">622             dumpSubtree(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">623             dumpSubtree(node-&gt;right(), indentation + 2);</span>
624         }
625     }

626 
<span class="line-modified">627 #endif</span>

628 
<span class="line-modified">629     Node* m_root { nullptr };</span>

630 #ifndef NDEBUG
<span class="line-modified">631     bool m_verboseDebugging { false };</span>
632 #endif
633 };
634 
635 } // namespace WebCore


</pre>
</td>
</tr>
</table>
<center><a href="PODIntervalTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Pasteboard.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
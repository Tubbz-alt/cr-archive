<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCCallSpecial.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCCallSpecial.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;CCallHelpers.h&quot;</span>
<span class="line-added"> 32 </span>
 33 namespace JSC { namespace B3 { namespace Air {
 34 
 35 CCallSpecial::CCallSpecial()
 36 {
 37     m_clobberedRegs = RegisterSet::allRegisters();
 38     m_clobberedRegs.exclude(RegisterSet::stackRegisters());
 39     m_clobberedRegs.exclude(RegisterSet::reservedHardwareRegisters());
 40     m_clobberedRegs.exclude(RegisterSet::calleeSaveRegisters());
 41     m_clobberedRegs.clear(GPRInfo::returnValueGPR);
 42     m_clobberedRegs.clear(GPRInfo::returnValueGPR2);
 43     m_clobberedRegs.clear(FPRInfo::returnValueFPR);
 44 }
 45 
 46 CCallSpecial::~CCallSpecial()
 47 {
 48 }
 49 
 50 void CCallSpecial::forEachArg(Inst&amp; inst, const ScopedLambda&lt;Inst::EachArgCallback&gt;&amp; callback)
 51 {
 52     for (unsigned i = 0; i &lt; numCalleeArgs; ++i)
 53         callback(inst.args[calleeArgOffset + i], Arg::Use, GP, pointerWidth());
 54     for (unsigned i = 0; i &lt; numReturnGPArgs; ++i)
 55         callback(inst.args[returnGPArgOffset + i], Arg::Def, GP, pointerWidth());
 56     for (unsigned i = 0; i &lt; numReturnFPArgs; ++i)
 57         callback(inst.args[returnFPArgOffset + i], Arg::Def, FP, Width64);
 58 
 59     for (unsigned i = argArgOffset; i &lt; inst.args.size(); ++i) {
 60         // For the type, we can just query the arg&#39;s bank. The arg will have a bank, because we
 61         // require these args to be argument registers.
 62         Bank bank = inst.args[i].bank();
 63         callback(inst.args[i], Arg::Use, bank, conservativeWidth(bank));
 64     }
 65 }
 66 
 67 bool CCallSpecial::isValid(Inst&amp; inst)
 68 {
 69     if (inst.args.size() &lt; argArgOffset)
 70         return false;
 71 
 72     for (unsigned i = 0; i &lt; numCalleeArgs; ++i) {
 73         Arg&amp; arg = inst.args[i + calleeArgOffset];
 74         if (!arg.isGP())
 75             return false;
 76         switch (arg.kind()) {
 77         case Arg::Imm:
 78             if (is32Bit())
 79                 break;
 80             return false;
 81         case Arg::BigImm:
 82             if (is64Bit())
 83                 break;
 84             return false;
 85         case Arg::Tmp:
 86         case Arg::Addr:
 87         case Arg::ExtendedOffsetAddr:
 88         case Arg::Stack:
 89         case Arg::CallArg:
 90             break;
 91         default:
 92             return false;
 93         }
 94     }
 95 
 96     // Return args need to be exact.
 97     if (inst.args[returnGPArgOffset + 0] != Tmp(GPRInfo::returnValueGPR))
 98         return false;
 99     if (inst.args[returnGPArgOffset + 1] != Tmp(GPRInfo::returnValueGPR2))
100         return false;
101     if (inst.args[returnFPArgOffset + 0] != Tmp(FPRInfo::returnValueFPR))
102         return false;
103 
104     for (unsigned i = argArgOffset; i &lt; inst.args.size(); ++i) {
105         if (!inst.args[i].isReg())
106             return false;
107 
108         if (inst.args[i] == Tmp(scratchRegister))
109             return false;
110     }
111     return true;
112 }
113 
114 bool CCallSpecial::admitsStack(Inst&amp;, unsigned argIndex)
115 {
116     // The callee can be on the stack unless targeting ARM64, where we can&#39;t later properly
117     // handle an Addr callee argument in generate() due to disallowed scratch register usage.
118     if (argIndex == calleeArgOffset)
119         return !isARM64();
120 
121     return false;
122 }
123 
124 bool CCallSpecial::admitsExtendedOffsetAddr(Inst&amp; inst, unsigned argIndex)
125 {
126     return admitsStack(inst, argIndex);
127 }
128 
129 void CCallSpecial::reportUsedRegisters(Inst&amp;, const RegisterSet&amp;)
130 {
131 }
132 
133 CCallHelpers::Jump CCallSpecial::generate(Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp;)
134 {
135     switch (inst.args[calleeArgOffset].kind()) {
136     case Arg::Imm:
137     case Arg::BigImm:
138         jit.move(inst.args[calleeArgOffset].asTrustedImmPtr(), scratchRegister);
139         jit.call(scratchRegister, B3CCallPtrTag);
140         break;
141     case Arg::Tmp:
142         jit.call(inst.args[calleeArgOffset].gpr(), B3CCallPtrTag);
143         break;
144     case Arg::Addr:
145     case Arg::ExtendedOffsetAddr:
146         jit.call(inst.args[calleeArgOffset].asAddress(), B3CCallPtrTag);
147         break;
148     default:
149         RELEASE_ASSERT_NOT_REACHED();
150         break;
151     }
152     return CCallHelpers::Jump();
153 }
154 
155 RegisterSet CCallSpecial::extraEarlyClobberedRegs(Inst&amp;)
156 {
157     return m_emptyRegs;
158 }
159 
160 RegisterSet CCallSpecial::extraClobberedRegs(Inst&amp;)
161 {
162     return m_clobberedRegs;
163 }
164 
165 void CCallSpecial::dumpImpl(PrintStream&amp; out) const
166 {
167     out.print(&quot;CCall&quot;);
168 }
169 
170 void CCallSpecial::deepDumpImpl(PrintStream&amp; out) const
171 {
172     out.print(&quot;function call that uses the C calling convention.&quot;);
173 }
174 
175 } } } // namespace JSC::B3::Air
176 
177 #endif // ENABLE(B3_JIT)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
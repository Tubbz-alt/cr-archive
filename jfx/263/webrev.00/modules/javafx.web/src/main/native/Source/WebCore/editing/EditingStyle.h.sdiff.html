<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditingStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 43 
 44 class CSSStyleDeclaration;
 45 class CSSComputedStyleDeclaration;
 46 class CSSPrimitiveValue;
 47 class CSSValue;
 48 class ComputedStyleExtractor;
 49 class Document;
 50 class Element;
 51 class HTMLElement;
 52 class MutableStyleProperties;
 53 class Node;
 54 class Position;
 55 class QualifiedName;
 56 class RenderStyle;
 57 class StyleProperties;
 58 class StyledElement;
 59 class VisibleSelection;
 60 
 61 enum class TextDecorationChange { None, Add, Remove };
 62 



 63 class EditingStyle : public RefCounted&lt;EditingStyle&gt; {
 64 public:
 65 
 66     enum PropertiesToInclude { AllProperties, OnlyEditingInheritableProperties, EditingPropertiesInEffect };
 67 
 68     enum ShouldPreserveWritingDirection { PreserveWritingDirection, DoNotPreserveWritingDirection };
 69     enum ShouldExtractMatchingStyle { ExtractMatchingStyle, DoNotExtractMatchingStyle };
 70     static float NoFontDelta;
 71 
 72     static Ref&lt;EditingStyle&gt; create()
 73     {
 74         return adoptRef(*new EditingStyle);
 75     }
 76 
 77     static Ref&lt;EditingStyle&gt; create(Node* node, PropertiesToInclude propertiesToInclude = OnlyEditingInheritableProperties)
 78     {
 79         return adoptRef(*new EditingStyle(node, propertiesToInclude));
 80     }
 81 
 82     static Ref&lt;EditingStyle&gt; create(const Position&amp; position, PropertiesToInclude propertiesToInclude = OnlyEditingInheritableProperties)
</pre>
<hr />
<pre>
124     void collapseTextDecorationProperties();
125     enum ShouldIgnoreTextOnlyProperties { IgnoreTextOnlyProperties, DoNotIgnoreTextOnlyProperties };
126     TriState triStateOfStyle(EditingStyle*) const;
127     TriState triStateOfStyle(const VisibleSelection&amp;) const;
128     bool conflictsWithInlineStyleOfElement(StyledElement&amp; element) const { return conflictsWithInlineStyleOfElement(element, nullptr, nullptr); }
129     bool conflictsWithInlineStyleOfElement(StyledElement&amp; element, RefPtr&lt;MutableStyleProperties&gt;&amp; newInlineStyle, EditingStyle* extractedStyle) const
130     {
131         return conflictsWithInlineStyleOfElement(element, &amp;newInlineStyle, extractedStyle);
132     }
133     bool conflictsWithImplicitStyleOfElement(HTMLElement&amp;, EditingStyle* extractedStyle = nullptr, ShouldExtractMatchingStyle = DoNotExtractMatchingStyle) const;
134     bool conflictsWithImplicitStyleOfAttributes(HTMLElement&amp;) const;
135     bool extractConflictingImplicitStyleOfAttributes(HTMLElement&amp;, ShouldPreserveWritingDirection, EditingStyle* extractedStyle, Vector&lt;QualifiedName&gt;&amp; conflictingAttributes, ShouldExtractMatchingStyle) const;
136     bool styleIsPresentInComputedStyleOfNode(Node&amp;) const;
137 
138     static bool elementIsStyledSpanOrHTMLEquivalent(const HTMLElement&amp;);
139 
140     void prepareToApplyAt(const Position&amp;, ShouldPreserveWritingDirection = DoNotPreserveWritingDirection);
141     void mergeTypingStyle(Document&amp;);
142     enum CSSPropertyOverrideMode { OverrideValues, DoNotOverrideValues };
143     void mergeInlineStyleOfElement(StyledElement&amp;, CSSPropertyOverrideMode, PropertiesToInclude = AllProperties);
<span class="line-modified">144     static Ref&lt;EditingStyle&gt; wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate);</span>
145     void mergeStyleFromRules(StyledElement&amp;);
<span class="line-modified">146     void mergeStyleFromRulesForSerialization(StyledElement&amp;);</span>
147     void removeStyleFromRulesAndContext(StyledElement&amp;, Node* context);
148     void removePropertiesInElementDefaultStyle(Element&amp;);
149     void forceInline();
150     void addDisplayContents();
151     bool convertPositionStyle();
152     bool isFloating();
153     int legacyFontSize(Document&amp;) const;
154 
155     float fontSizeDelta() const { return m_fontSizeDelta; }
156     bool hasFontSizeDelta() const { return m_fontSizeDelta != NoFontDelta; }
157     bool shouldUseFixedDefaultFontSize() const { return m_shouldUseFixedDefaultFontSize; }
158 
159     void setUnderlineChange(TextDecorationChange change) { m_underlineChange = static_cast&lt;unsigned&gt;(change); }
160     TextDecorationChange underlineChange() const { return static_cast&lt;TextDecorationChange&gt;(m_underlineChange); }
161     void setStrikeThroughChange(TextDecorationChange change) { m_strikeThroughChange = static_cast&lt;unsigned&gt;(change); }
162     TextDecorationChange strikeThroughChange() const { return static_cast&lt;TextDecorationChange&gt;(m_strikeThroughChange); }
163 
164     WEBCORE_EXPORT bool hasStyle(CSSPropertyID, const String&amp; value);
165     WEBCORE_EXPORT static RefPtr&lt;EditingStyle&gt; styleAtSelectionStart(const VisibleSelection&amp;, bool shouldUseBackgroundColorInEffect = false);
166     static WritingDirection textDirectionForSelection(const VisibleSelection&amp;, EditingStyle* typingStyle, bool&amp; hasNestedOrMultipleEmbeddings);
167 
168     Ref&lt;EditingStyle&gt; inverseTransformColorIfNeeded(Element&amp;);
169 
170 private:
171     EditingStyle();
172     EditingStyle(Node*, PropertiesToInclude);
173     EditingStyle(const Position&amp;, PropertiesToInclude);
174     WEBCORE_EXPORT explicit EditingStyle(const CSSStyleDeclaration*);
175     explicit EditingStyle(const StyleProperties*);
176     EditingStyle(CSSPropertyID, const String&amp; value);
177     EditingStyle(CSSPropertyID, CSSValueID);
178     void init(Node*, PropertiesToInclude);
179     void removeTextFillAndStrokeColorsIfNeeded(const RenderStyle*);
180     void setProperty(CSSPropertyID, const String&amp; value, bool important = false);
181     void extractFontSizeDelta();
182     template&lt;typename T&gt; TriState triStateOfStyle(T&amp; styleToCompare, ShouldIgnoreTextOnlyProperties) const;
183     bool conflictsWithInlineStyleOfElement(StyledElement&amp;, RefPtr&lt;MutableStyleProperties&gt;* newInlineStyle, EditingStyle* extractedStyle) const;
<span class="line-modified">184     void mergeInlineAndImplicitStyleOfElement(StyledElement&amp;, CSSPropertyOverrideMode, PropertiesToInclude);</span>
185     void mergeStyle(const StyleProperties*, CSSPropertyOverrideMode);
186 
187     RefPtr&lt;MutableStyleProperties&gt; m_mutableStyle;
188     unsigned m_shouldUseFixedDefaultFontSize : 1;
189     unsigned m_underlineChange : 2;
190     unsigned m_strikeThroughChange : 2;
191     float m_fontSizeDelta = NoFontDelta;
192 
193     friend class HTMLElementEquivalent;
194     friend class HTMLAttributeEquivalent;
195     friend class HTMLTextDecorationEquivalent;
196 };
197 
198 class StyleChange {
199 public:
200     StyleChange() { }
201     StyleChange(EditingStyle*, const Position&amp;);
202 
203     const StyleProperties* cssStyle() const { return m_cssStyle.get(); }
204     bool applyBold() const { return m_applyBold; }
</pre>
</td>
<td>
<hr />
<pre>
 43 
 44 class CSSStyleDeclaration;
 45 class CSSComputedStyleDeclaration;
 46 class CSSPrimitiveValue;
 47 class CSSValue;
 48 class ComputedStyleExtractor;
 49 class Document;
 50 class Element;
 51 class HTMLElement;
 52 class MutableStyleProperties;
 53 class Node;
 54 class Position;
 55 class QualifiedName;
 56 class RenderStyle;
 57 class StyleProperties;
 58 class StyledElement;
 59 class VisibleSelection;
 60 
 61 enum class TextDecorationChange { None, Add, Remove };
 62 
<span class="line-added"> 63 // FIXME: &quot;Keep&quot; should be &quot;Resolve&quot; instead and resolve all generic font family names.</span>
<span class="line-added"> 64 enum class StandardFontFamilySerializationMode : uint8_t { Keep, Strip };</span>
<span class="line-added"> 65 </span>
 66 class EditingStyle : public RefCounted&lt;EditingStyle&gt; {
 67 public:
 68 
 69     enum PropertiesToInclude { AllProperties, OnlyEditingInheritableProperties, EditingPropertiesInEffect };
 70 
 71     enum ShouldPreserveWritingDirection { PreserveWritingDirection, DoNotPreserveWritingDirection };
 72     enum ShouldExtractMatchingStyle { ExtractMatchingStyle, DoNotExtractMatchingStyle };
 73     static float NoFontDelta;
 74 
 75     static Ref&lt;EditingStyle&gt; create()
 76     {
 77         return adoptRef(*new EditingStyle);
 78     }
 79 
 80     static Ref&lt;EditingStyle&gt; create(Node* node, PropertiesToInclude propertiesToInclude = OnlyEditingInheritableProperties)
 81     {
 82         return adoptRef(*new EditingStyle(node, propertiesToInclude));
 83     }
 84 
 85     static Ref&lt;EditingStyle&gt; create(const Position&amp; position, PropertiesToInclude propertiesToInclude = OnlyEditingInheritableProperties)
</pre>
<hr />
<pre>
127     void collapseTextDecorationProperties();
128     enum ShouldIgnoreTextOnlyProperties { IgnoreTextOnlyProperties, DoNotIgnoreTextOnlyProperties };
129     TriState triStateOfStyle(EditingStyle*) const;
130     TriState triStateOfStyle(const VisibleSelection&amp;) const;
131     bool conflictsWithInlineStyleOfElement(StyledElement&amp; element) const { return conflictsWithInlineStyleOfElement(element, nullptr, nullptr); }
132     bool conflictsWithInlineStyleOfElement(StyledElement&amp; element, RefPtr&lt;MutableStyleProperties&gt;&amp; newInlineStyle, EditingStyle* extractedStyle) const
133     {
134         return conflictsWithInlineStyleOfElement(element, &amp;newInlineStyle, extractedStyle);
135     }
136     bool conflictsWithImplicitStyleOfElement(HTMLElement&amp;, EditingStyle* extractedStyle = nullptr, ShouldExtractMatchingStyle = DoNotExtractMatchingStyle) const;
137     bool conflictsWithImplicitStyleOfAttributes(HTMLElement&amp;) const;
138     bool extractConflictingImplicitStyleOfAttributes(HTMLElement&amp;, ShouldPreserveWritingDirection, EditingStyle* extractedStyle, Vector&lt;QualifiedName&gt;&amp; conflictingAttributes, ShouldExtractMatchingStyle) const;
139     bool styleIsPresentInComputedStyleOfNode(Node&amp;) const;
140 
141     static bool elementIsStyledSpanOrHTMLEquivalent(const HTMLElement&amp;);
142 
143     void prepareToApplyAt(const Position&amp;, ShouldPreserveWritingDirection = DoNotPreserveWritingDirection);
144     void mergeTypingStyle(Document&amp;);
145     enum CSSPropertyOverrideMode { OverrideValues, DoNotOverrideValues };
146     void mergeInlineStyleOfElement(StyledElement&amp;, CSSPropertyOverrideMode, PropertiesToInclude = AllProperties);
<span class="line-modified">147     static Ref&lt;EditingStyle&gt; wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate, StandardFontFamilySerializationMode);</span>
148     void mergeStyleFromRules(StyledElement&amp;);
<span class="line-modified">149     void mergeStyleFromRulesForSerialization(StyledElement&amp;, StandardFontFamilySerializationMode);</span>
150     void removeStyleFromRulesAndContext(StyledElement&amp;, Node* context);
151     void removePropertiesInElementDefaultStyle(Element&amp;);
152     void forceInline();
153     void addDisplayContents();
154     bool convertPositionStyle();
155     bool isFloating();
156     int legacyFontSize(Document&amp;) const;
157 
158     float fontSizeDelta() const { return m_fontSizeDelta; }
159     bool hasFontSizeDelta() const { return m_fontSizeDelta != NoFontDelta; }
160     bool shouldUseFixedDefaultFontSize() const { return m_shouldUseFixedDefaultFontSize; }
161 
162     void setUnderlineChange(TextDecorationChange change) { m_underlineChange = static_cast&lt;unsigned&gt;(change); }
163     TextDecorationChange underlineChange() const { return static_cast&lt;TextDecorationChange&gt;(m_underlineChange); }
164     void setStrikeThroughChange(TextDecorationChange change) { m_strikeThroughChange = static_cast&lt;unsigned&gt;(change); }
165     TextDecorationChange strikeThroughChange() const { return static_cast&lt;TextDecorationChange&gt;(m_strikeThroughChange); }
166 
167     WEBCORE_EXPORT bool hasStyle(CSSPropertyID, const String&amp; value);
168     WEBCORE_EXPORT static RefPtr&lt;EditingStyle&gt; styleAtSelectionStart(const VisibleSelection&amp;, bool shouldUseBackgroundColorInEffect = false);
169     static WritingDirection textDirectionForSelection(const VisibleSelection&amp;, EditingStyle* typingStyle, bool&amp; hasNestedOrMultipleEmbeddings);
170 
171     Ref&lt;EditingStyle&gt; inverseTransformColorIfNeeded(Element&amp;);
172 
173 private:
174     EditingStyle();
175     EditingStyle(Node*, PropertiesToInclude);
176     EditingStyle(const Position&amp;, PropertiesToInclude);
177     WEBCORE_EXPORT explicit EditingStyle(const CSSStyleDeclaration*);
178     explicit EditingStyle(const StyleProperties*);
179     EditingStyle(CSSPropertyID, const String&amp; value);
180     EditingStyle(CSSPropertyID, CSSValueID);
181     void init(Node*, PropertiesToInclude);
182     void removeTextFillAndStrokeColorsIfNeeded(const RenderStyle*);
183     void setProperty(CSSPropertyID, const String&amp; value, bool important = false);
184     void extractFontSizeDelta();
185     template&lt;typename T&gt; TriState triStateOfStyle(T&amp; styleToCompare, ShouldIgnoreTextOnlyProperties) const;
186     bool conflictsWithInlineStyleOfElement(StyledElement&amp;, RefPtr&lt;MutableStyleProperties&gt;* newInlineStyle, EditingStyle* extractedStyle) const;
<span class="line-modified">187     void mergeInlineAndImplicitStyleOfElement(StyledElement&amp;, CSSPropertyOverrideMode, PropertiesToInclude, StandardFontFamilySerializationMode);</span>
188     void mergeStyle(const StyleProperties*, CSSPropertyOverrideMode);
189 
190     RefPtr&lt;MutableStyleProperties&gt; m_mutableStyle;
191     unsigned m_shouldUseFixedDefaultFontSize : 1;
192     unsigned m_underlineChange : 2;
193     unsigned m_strikeThroughChange : 2;
194     float m_fontSizeDelta = NoFontDelta;
195 
196     friend class HTMLElementEquivalent;
197     friend class HTMLAttributeEquivalent;
198     friend class HTMLTextDecorationEquivalent;
199 };
200 
201 class StyleChange {
202 public:
203     StyleChange() { }
204     StyleChange(EditingStyle*, const Position&amp;);
205 
206     const StyleProperties* cssStyle() const { return m_cssStyle.get(); }
207     bool applyBold() const { return m_applyBold; }
</pre>
</td>
</tr>
</table>
<center><a href="EditingStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/ApplyStyleCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../domjit/DOMJITIDLConvert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CompositeEditCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/ApplyStyleCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 401             // Last styled node was not parent node of this text node, but we wish to style this
 402             // text node. To make this possible, add a style span to surround this text node.
 403             auto span = createStyleSpanElement(document());
 404             surroundNodeRangeWithElement(*node, *node, span.copyRef());
 405             element = WTFMove(span);
 406         }  else {
 407             // Only handle HTML elements and text nodes.
 408             continue;
 409         }
 410         lastStyledNode = node;
 411 
 412         RefPtr&lt;MutableStyleProperties&gt; inlineStyle = copyStyleOrCreateEmpty(element-&gt;inlineStyle());
 413         float currentFontSize = computedFontSize(node);
 414         float desiredFontSize = std::max(MinimumFontSize, startingFontSizes.get(node) + style-&gt;fontSizeDelta());
 415         RefPtr&lt;CSSValue&gt; value = inlineStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
 416         if (value) {
 417             element-&gt;removeInlineStyleProperty(CSSPropertyFontSize);
 418             currentFontSize = computedFontSize(node);
 419         }
 420         if (currentFontSize != desiredFontSize) {
<span class="line-modified"> 421             inlineStyle-&gt;setProperty(CSSPropertyFontSize, CSSValuePool::singleton().createValue(desiredFontSize, CSSPrimitiveValue::CSS_PX), false);</span>
 422             setNodeAttribute(*element, styleAttr, inlineStyle-&gt;asText());
 423         }
 424         if (inlineStyle-&gt;isEmpty()) {
 425             removeNodeAttribute(*element, styleAttr);
 426             if (isSpanWithoutAttributesOrUnstyledStyleSpan(*element))
 427                 unstyledSpans.append(element.releaseNonNull());
 428         }
 429     }
 430 
 431     for (auto&amp; unstyledSpan : unstyledSpans)
 432         removeNodePreservingChildren(unstyledSpan);
 433 }
 434 
 435 static ContainerNode* dummySpanAncestorForNode(const Node* node)
 436 {
 437     while (node &amp;&amp; (!is&lt;Element&gt;(*node) || !isStyleSpanOrSpanWithOnlyStyleAttribute(downcast&lt;Element&gt;(*node))))
 438         node = node-&gt;parentNode();
 439 
 440     return node ? node-&gt;parentNode() : nullptr;
 441 }
</pre>
<hr />
<pre>
1480         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), uTag));
1481 
1482     if (styleChange.applyLineThrough())
1483         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), strikeTag));
1484 
1485     if (styleChange.applySubscript())
1486         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), subTag));
1487     else if (styleChange.applySuperscript())
1488         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), supTag));
1489 
1490     if (m_styledInlineElement &amp;&amp; addStyledElement == AddStyledElement)
1491         surroundNodeRangeWithElement(*startNode, *endNode, m_styledInlineElement-&gt;cloneElementWithoutChildren(document()));
1492 }
1493 
1494 float ApplyStyleCommand::computedFontSize(Node* node)
1495 {
1496     if (!node)
1497         return 0;
1498 
1499     auto value = ComputedStyleExtractor(node).propertyValue(CSSPropertyFontSize);
<span class="line-modified">1500     return downcast&lt;CSSPrimitiveValue&gt;(*value).floatValue(CSSPrimitiveValue::CSS_PX);</span>
1501 }
1502 
1503 void ApplyStyleCommand::joinChildTextNodes(Node* node, const Position&amp; start, const Position&amp; end)
1504 {
1505     if (!node)
1506         return;
1507 
1508     Position newStart = start;
1509     Position newEnd = end;
1510 
1511     Vector&lt;Ref&lt;Text&gt;&gt; textNodes;
1512     for (Text* textNode = TextNodeTraversal::firstChild(*node); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
1513         textNodes.append(*textNode);
1514 
1515     for (auto&amp; childText : textNodes) {
1516         Node* next = childText-&gt;nextSibling();
1517         if (!is&lt;Text&gt;(next))
1518             continue;
1519 
1520         Text&amp; nextText = downcast&lt;Text&gt;(*next);
</pre>
</td>
<td>
<hr />
<pre>
 401             // Last styled node was not parent node of this text node, but we wish to style this
 402             // text node. To make this possible, add a style span to surround this text node.
 403             auto span = createStyleSpanElement(document());
 404             surroundNodeRangeWithElement(*node, *node, span.copyRef());
 405             element = WTFMove(span);
 406         }  else {
 407             // Only handle HTML elements and text nodes.
 408             continue;
 409         }
 410         lastStyledNode = node;
 411 
 412         RefPtr&lt;MutableStyleProperties&gt; inlineStyle = copyStyleOrCreateEmpty(element-&gt;inlineStyle());
 413         float currentFontSize = computedFontSize(node);
 414         float desiredFontSize = std::max(MinimumFontSize, startingFontSizes.get(node) + style-&gt;fontSizeDelta());
 415         RefPtr&lt;CSSValue&gt; value = inlineStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
 416         if (value) {
 417             element-&gt;removeInlineStyleProperty(CSSPropertyFontSize);
 418             currentFontSize = computedFontSize(node);
 419         }
 420         if (currentFontSize != desiredFontSize) {
<span class="line-modified"> 421             inlineStyle-&gt;setProperty(CSSPropertyFontSize, CSSValuePool::singleton().createValue(desiredFontSize, CSSUnitType::CSS_PX), false);</span>
 422             setNodeAttribute(*element, styleAttr, inlineStyle-&gt;asText());
 423         }
 424         if (inlineStyle-&gt;isEmpty()) {
 425             removeNodeAttribute(*element, styleAttr);
 426             if (isSpanWithoutAttributesOrUnstyledStyleSpan(*element))
 427                 unstyledSpans.append(element.releaseNonNull());
 428         }
 429     }
 430 
 431     for (auto&amp; unstyledSpan : unstyledSpans)
 432         removeNodePreservingChildren(unstyledSpan);
 433 }
 434 
 435 static ContainerNode* dummySpanAncestorForNode(const Node* node)
 436 {
 437     while (node &amp;&amp; (!is&lt;Element&gt;(*node) || !isStyleSpanOrSpanWithOnlyStyleAttribute(downcast&lt;Element&gt;(*node))))
 438         node = node-&gt;parentNode();
 439 
 440     return node ? node-&gt;parentNode() : nullptr;
 441 }
</pre>
<hr />
<pre>
1480         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), uTag));
1481 
1482     if (styleChange.applyLineThrough())
1483         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), strikeTag));
1484 
1485     if (styleChange.applySubscript())
1486         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), subTag));
1487     else if (styleChange.applySuperscript())
1488         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), supTag));
1489 
1490     if (m_styledInlineElement &amp;&amp; addStyledElement == AddStyledElement)
1491         surroundNodeRangeWithElement(*startNode, *endNode, m_styledInlineElement-&gt;cloneElementWithoutChildren(document()));
1492 }
1493 
1494 float ApplyStyleCommand::computedFontSize(Node* node)
1495 {
1496     if (!node)
1497         return 0;
1498 
1499     auto value = ComputedStyleExtractor(node).propertyValue(CSSPropertyFontSize);
<span class="line-modified">1500     return downcast&lt;CSSPrimitiveValue&gt;(*value).floatValue(CSSUnitType::CSS_PX);</span>
1501 }
1502 
1503 void ApplyStyleCommand::joinChildTextNodes(Node* node, const Position&amp; start, const Position&amp; end)
1504 {
1505     if (!node)
1506         return;
1507 
1508     Position newStart = start;
1509     Position newEnd = end;
1510 
1511     Vector&lt;Ref&lt;Text&gt;&gt; textNodes;
1512     for (Text* textNode = TextNodeTraversal::firstChild(*node); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
1513         textNodes.append(*textNode);
1514 
1515     for (auto&amp; childText : textNodes) {
1516         Node* next = childText-&gt;nextSibling();
1517         if (!is&lt;Text&gt;(next))
1518             continue;
1519 
1520         Text&amp; nextText = downcast&lt;Text&gt;(*next);
</pre>
</td>
</tr>
</table>
<center><a href="../domjit/DOMJITIDLConvert.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CompositeEditCommand.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
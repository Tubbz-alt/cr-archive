<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ActiveDOMObject.h&quot;
 29 #include &quot;AsyncAudioDecoder.h&quot;
 30 #include &quot;AudioBus.h&quot;
 31 #include &quot;AudioDestinationNode.h&quot;
 32 #include &quot;EventTarget.h&quot;
<span class="line-removed"> 33 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 34 #include &quot;MediaCanStartListener.h&quot;
 35 #include &quot;MediaProducer.h&quot;
 36 #include &quot;PlatformMediaSession.h&quot;
 37 #include &quot;ScriptExecutionContext.h&quot;
 38 #include &quot;VisibilityChangeClient.h&quot;
 39 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 40 #include &lt;JavaScriptCore/Float32Array.h&gt;
 41 #include &lt;atomic&gt;
 42 #include &lt;wtf/HashSet.h&gt;
 43 #include &lt;wtf/LoggerHelper.h&gt;
 44 #include &lt;wtf/MainThread.h&gt;
 45 #include &lt;wtf/RefPtr.h&gt;
 46 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 47 #include &lt;wtf/Threading.h&gt;

 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/AtomStringHash.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 class AnalyserNode;
 54 class AudioBuffer;
 55 class AudioBufferCallback;
 56 class AudioBufferSourceNode;
 57 class AudioListener;
 58 class AudioSummingJunction;
 59 class BiquadFilterNode;
 60 class ChannelMergerNode;
 61 class ChannelSplitterNode;
 62 class ConvolverNode;
 63 class DelayNode;
 64 class Document;
 65 class DynamicsCompressorNode;
 66 class GainNode;
<span class="line-removed"> 67 class GenericEventQueue;</span>
 68 class HTMLMediaElement;

 69 class MediaElementAudioSourceNode;
 70 class MediaStream;
 71 class MediaStreamAudioDestinationNode;
 72 class MediaStreamAudioSourceNode;
 73 class OscillatorNode;
 74 class PannerNode;
 75 class PeriodicWave;
 76 class ScriptProcessorNode;
 77 class SecurityOrigin;
 78 class WaveShaperNode;
 79 


 80 // AudioContext is the cornerstone of the web audio API and all AudioNodes are created from it.
 81 // For thread safety between the audio thread and the main thread, it has a rendering graph locking mechanism.
 82 
 83 class AudioContext
 84     : public ActiveDOMObject
 85     , public ThreadSafeRefCounted&lt;AudioContext&gt;
 86     , public EventTargetWithInlineData
 87     , public MediaCanStartListener
 88     , public MediaProducer
 89     , private PlatformMediaSessionClient
 90     , private VisibilityChangeClient
 91 #if !RELEASE_LOG_DISABLED
 92     , private LoggerHelper
 93 #endif
 94 {
 95     WTF_MAKE_ISO_ALLOCATED(AudioContext);
 96 public:
 97     // Create an AudioContext for rendering to the audio hardware.
 98     static RefPtr&lt;AudioContext&gt; create(Document&amp;);
 99 
</pre>
<hr />
<pre>
107 
108     Document* hostingDocument() const final;
109 
110     AudioDestinationNode* destination() { return m_destinationNode.get(); }
111     size_t currentSampleFrame() const { return m_destinationNode ? m_destinationNode-&gt;currentSampleFrame() : 0; }
112     double currentTime() const { return m_destinationNode ? m_destinationNode-&gt;currentTime() : 0.; }
113     float sampleRate() const { return m_destinationNode ? m_destinationNode-&gt;sampleRate() : 0.f; }
114     unsigned long activeSourceCount() const { return static_cast&lt;unsigned long&gt;(m_activeSourceCount); }
115 
116     void incrementActiveSourceCount();
117     void decrementActiveSourceCount();
118 
119     ExceptionOr&lt;Ref&lt;AudioBuffer&gt;&gt; createBuffer(unsigned numberOfChannels, size_t numberOfFrames, float sampleRate);
120     ExceptionOr&lt;Ref&lt;AudioBuffer&gt;&gt; createBuffer(ArrayBuffer&amp;, bool mixToMono);
121 
122     // Asynchronous audio file data decoding.
123     void decodeAudioData(Ref&lt;ArrayBuffer&gt;&amp;&amp;, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp;, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp;);
124 
125     AudioListener* listener() { return m_listener.get(); }
126 
<span class="line-modified">127     using ActiveDOMObject::suspend;</span>
<span class="line-modified">128     using ActiveDOMObject::resume;</span>
<span class="line-removed">129 </span>
<span class="line-removed">130     void suspend(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);</span>
<span class="line-removed">131     void resume(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);</span>
132     void close(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
133 
134     enum class State { Suspended, Running, Interrupted, Closed };
135     State state() const;
136     bool isClosed() const { return m_state == State::Closed; }
137 
138     bool wouldTaintOrigin(const URL&amp;) const;
139 
140     // The AudioNode create methods are called on the main thread (from JavaScript).
141     ExceptionOr&lt;Ref&lt;AudioBufferSourceNode&gt;&gt; createBufferSource();
142 #if ENABLE(VIDEO)
143     ExceptionOr&lt;Ref&lt;MediaElementAudioSourceNode&gt;&gt; createMediaElementSource(HTMLMediaElement&amp;);
144 #endif
145 #if ENABLE(MEDIA_STREAM)
146     ExceptionOr&lt;Ref&lt;MediaStreamAudioSourceNode&gt;&gt; createMediaStreamSource(MediaStream&amp;);
147     ExceptionOr&lt;Ref&lt;MediaStreamAudioDestinationNode&gt;&gt; createMediaStreamDestination();
148 #endif
149     ExceptionOr&lt;Ref&lt;GainNode&gt;&gt; createGain();
150     ExceptionOr&lt;Ref&lt;BiquadFilterNode&gt;&gt; createBiquadFilter();
151     ExceptionOr&lt;Ref&lt;WaveShaperNode&gt;&gt; createWaveShaper();
</pre>
<hr />
<pre>
275     void addBehaviorRestriction(BehaviorRestrictions restriction) { m_restrictions |= restriction; }
276     void removeBehaviorRestriction(BehaviorRestrictions restriction) { m_restrictions &amp;= ~restriction; }
277 
278     void isPlayingAudioDidChange();
279 
280     void nodeWillBeginPlayback();
281 
282 #if !RELEASE_LOG_DISABLED
283     const Logger&amp; logger() const final { return m_logger.get(); }
284     const void* logIdentifier() const final { return m_logIdentifier; }
285     WTFLogChannel&amp; logChannel() const final;
286     const void* nextAudioNodeLogIdentifier() { return childLogIdentifier(++m_nextAudioNodeIdentifier); }
287     const void* nextAudioParameterLogIdentifier() { return childLogIdentifier(++m_nextAudioParameterIdentifier); }
288 #endif
289 
290     void postTask(WTF::Function&lt;void()&gt;&amp;&amp;);
291     bool isStopped() const { return m_isStopScheduled; }
292     const SecurityOrigin* origin() const;
293     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message);
294 



295 protected:
296     explicit AudioContext(Document&amp;);
<span class="line-modified">297     AudioContext(Document&amp;, unsigned numberOfChannels, size_t numberOfFrames, float sampleRate);</span>
298 
299     static bool isSampleRateRangeGood(float sampleRate);
300     void clearPendingActivity();
301     void makePendingActivity();
302 
303 private:
304     void constructCommon();
305 
306     void lazyInitialize();
307     void uninitialize();
308 
309     bool willBeginPlayback();
310     bool willPausePlayback();
311 
312     bool userGestureRequiredForAudioStart() const { return !isOfflineContext() &amp;&amp; m_restrictions &amp; RequireUserGestureForAudioStartRestriction; }
313     bool pageConsentRequiredForAudioStart() const { return !isOfflineContext() &amp;&amp; m_restrictions &amp; RequirePageConsentForAudioStartRestriction; }
314 
315     void setState(State);
316 
317     void clear();
318 
319     void scheduleNodeDeletion();
320 
321     void mediaCanStart(Document&amp;) override;
322 
323     // EventTarget
<span class="line-removed">324     ScriptExecutionContext* scriptExecutionContext() const final;</span>
325     void dispatchEvent(Event&amp;) final;
326 
327     // MediaProducer
328     MediaProducer::MediaStateFlags mediaState() const override;
329     void pageMutedStateDidChange() override;
330 
331     // The context itself keeps a reference to all source nodes.  The source nodes, then reference all nodes they&#39;re connected to.
332     // In turn, these nodes reference all nodes they&#39;re connected to.  All nodes are ultimately connected to the AudioDestinationNode.
333     // When the context dereferences a source node, it will be deactivated from the rendering graph along with all other nodes it is
334     // uniquely connected to.  See the AudioNode::ref() and AudioNode::deref() methods for more details.
335     void refNode(AudioNode&amp;);
336     void derefNode(AudioNode&amp;);
337 
338     // ActiveDOMObject API.


339     void stop() override;
<span class="line-removed">340     bool canSuspendForDocumentSuspension() const override;</span>
341     const char* activeDOMObjectName() const override;
342 
343     // When the context goes away, there might still be some sources which haven&#39;t finished playing.
344     // Make sure to dereference them here.
345     void derefUnfinishedSourceNodes();
346 
347     // PlatformMediaSessionClient
348     PlatformMediaSession::MediaType mediaType() const override { return PlatformMediaSession::WebAudio; }
349     PlatformMediaSession::MediaType presentationType() const override { return PlatformMediaSession::WebAudio; }
350     PlatformMediaSession::CharacteristicsFlags characteristics() const override { return m_state == State::Running ? PlatformMediaSession::HasAudio : PlatformMediaSession::HasNothing; }
351     void mayResumePlayback(bool shouldResume) override;
352     void suspendPlayback() override;
353     bool canReceiveRemoteControlCommands() const override { return false; }
354     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override { }
355     bool supportsSeeking() const override { return false; }
356     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override { return false; }
357     String sourceApplicationIdentifier() const override;
358     bool canProduceAudio() const final { return true; }
359     bool isSuspended() const final;
360     bool processingUserGestureForMedia() const final;
</pre>
<hr />
<pre>
400     bool m_isDeletionScheduled { false };
401     bool m_isStopScheduled { false };
402     bool m_isInitialized { false };
403     bool m_isAudioThreadFinished { false };
404     bool m_automaticPullNodesNeedUpdating { false };
405     bool m_isOfflineContext { false };
406 
407     // Only accessed when the graph lock is held.
408     HashSet&lt;AudioSummingJunction*&gt; m_dirtySummingJunctions;
409     HashSet&lt;AudioNodeOutput*&gt; m_dirtyAudioNodeOutputs;
410 
411     // For the sake of thread safety, we maintain a seperate Vector of automatic pull nodes for rendering in m_renderingAutomaticPullNodes.
412     // It will be copied from m_automaticPullNodes by updateAutomaticPullNodes() at the very start or end of the rendering quantum.
413     HashSet&lt;AudioNode*&gt; m_automaticPullNodes;
414     Vector&lt;AudioNode*&gt; m_renderingAutomaticPullNodes;
415     // Only accessed in the audio thread.
416     Vector&lt;AudioNode*&gt; m_deferredFinishDerefList;
417     Vector&lt;Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;&gt; m_stateReactions;
418 
419     std::unique_ptr&lt;PlatformMediaSession&gt; m_mediaSession;
<span class="line-modified">420     std::unique_ptr&lt;GenericEventQueue&gt; m_eventQueue;</span>
421 
422     RefPtr&lt;AudioBuffer&gt; m_renderTarget;
423     RefPtr&lt;AudioDestinationNode&gt; m_destinationNode;
424     RefPtr&lt;AudioListener&gt; m_listener;
425 
426     unsigned m_connectionCount { 0 };
427 
428     // Graph locking.
429     Lock m_contextGraphMutex;
430     // FIXME: Using volatile seems incorrect.
431     // https://bugs.webkit.org/show_bug.cgi?id=180332
432     Thread* volatile m_audioThread { nullptr };
433     Thread* volatile m_graphOwnerThread { nullptr }; // if the lock is held then this is the thread which owns it, otherwise == nullptr.
434 
435     std::unique_ptr&lt;AsyncAudioDecoder&gt; m_audioDecoder;
436 
437     // This is considering 32 is large enough for multiple channels audio.
438     // It is somewhat arbitrary and could be increased if necessary.
439     enum { MaxNumberOfChannels = 32 };
440 
</pre>
</td>
<td>
<hr />
<pre>
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ActiveDOMObject.h&quot;
 29 #include &quot;AsyncAudioDecoder.h&quot;
 30 #include &quot;AudioBus.h&quot;
 31 #include &quot;AudioDestinationNode.h&quot;
 32 #include &quot;EventTarget.h&quot;

 33 #include &quot;MediaCanStartListener.h&quot;
 34 #include &quot;MediaProducer.h&quot;
 35 #include &quot;PlatformMediaSession.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &quot;VisibilityChangeClient.h&quot;
 38 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 39 #include &lt;JavaScriptCore/Float32Array.h&gt;
 40 #include &lt;atomic&gt;
 41 #include &lt;wtf/HashSet.h&gt;
 42 #include &lt;wtf/LoggerHelper.h&gt;
 43 #include &lt;wtf/MainThread.h&gt;
 44 #include &lt;wtf/RefPtr.h&gt;
 45 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 46 #include &lt;wtf/Threading.h&gt;
<span class="line-added"> 47 #include &lt;wtf/UniqueRef.h&gt;</span>
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/AtomStringHash.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 class AnalyserNode;
 54 class AudioBuffer;
 55 class AudioBufferCallback;
 56 class AudioBufferSourceNode;
 57 class AudioListener;
 58 class AudioSummingJunction;
 59 class BiquadFilterNode;
 60 class ChannelMergerNode;
 61 class ChannelSplitterNode;
 62 class ConvolverNode;
 63 class DelayNode;
 64 class Document;
 65 class DynamicsCompressorNode;
 66 class GainNode;

 67 class HTMLMediaElement;
<span class="line-added"> 68 class MainThreadGenericEventQueue;</span>
 69 class MediaElementAudioSourceNode;
 70 class MediaStream;
 71 class MediaStreamAudioDestinationNode;
 72 class MediaStreamAudioSourceNode;
 73 class OscillatorNode;
 74 class PannerNode;
 75 class PeriodicWave;
 76 class ScriptProcessorNode;
 77 class SecurityOrigin;
 78 class WaveShaperNode;
 79 
<span class="line-added"> 80 template&lt;typename IDLType&gt; class DOMPromiseDeferred;</span>
<span class="line-added"> 81 </span>
 82 // AudioContext is the cornerstone of the web audio API and all AudioNodes are created from it.
 83 // For thread safety between the audio thread and the main thread, it has a rendering graph locking mechanism.
 84 
 85 class AudioContext
 86     : public ActiveDOMObject
 87     , public ThreadSafeRefCounted&lt;AudioContext&gt;
 88     , public EventTargetWithInlineData
 89     , public MediaCanStartListener
 90     , public MediaProducer
 91     , private PlatformMediaSessionClient
 92     , private VisibilityChangeClient
 93 #if !RELEASE_LOG_DISABLED
 94     , private LoggerHelper
 95 #endif
 96 {
 97     WTF_MAKE_ISO_ALLOCATED(AudioContext);
 98 public:
 99     // Create an AudioContext for rendering to the audio hardware.
100     static RefPtr&lt;AudioContext&gt; create(Document&amp;);
101 
</pre>
<hr />
<pre>
109 
110     Document* hostingDocument() const final;
111 
112     AudioDestinationNode* destination() { return m_destinationNode.get(); }
113     size_t currentSampleFrame() const { return m_destinationNode ? m_destinationNode-&gt;currentSampleFrame() : 0; }
114     double currentTime() const { return m_destinationNode ? m_destinationNode-&gt;currentTime() : 0.; }
115     float sampleRate() const { return m_destinationNode ? m_destinationNode-&gt;sampleRate() : 0.f; }
116     unsigned long activeSourceCount() const { return static_cast&lt;unsigned long&gt;(m_activeSourceCount); }
117 
118     void incrementActiveSourceCount();
119     void decrementActiveSourceCount();
120 
121     ExceptionOr&lt;Ref&lt;AudioBuffer&gt;&gt; createBuffer(unsigned numberOfChannels, size_t numberOfFrames, float sampleRate);
122     ExceptionOr&lt;Ref&lt;AudioBuffer&gt;&gt; createBuffer(ArrayBuffer&amp;, bool mixToMono);
123 
124     // Asynchronous audio file data decoding.
125     void decodeAudioData(Ref&lt;ArrayBuffer&gt;&amp;&amp;, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp;, RefPtr&lt;AudioBufferCallback&gt;&amp;&amp;);
126 
127     AudioListener* listener() { return m_listener.get(); }
128 
<span class="line-modified">129     void suspendRendering(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);</span>
<span class="line-modified">130     void resumeRendering(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);</span>



131     void close(DOMPromiseDeferred&lt;void&gt;&amp;&amp;);
132 
133     enum class State { Suspended, Running, Interrupted, Closed };
134     State state() const;
135     bool isClosed() const { return m_state == State::Closed; }
136 
137     bool wouldTaintOrigin(const URL&amp;) const;
138 
139     // The AudioNode create methods are called on the main thread (from JavaScript).
140     ExceptionOr&lt;Ref&lt;AudioBufferSourceNode&gt;&gt; createBufferSource();
141 #if ENABLE(VIDEO)
142     ExceptionOr&lt;Ref&lt;MediaElementAudioSourceNode&gt;&gt; createMediaElementSource(HTMLMediaElement&amp;);
143 #endif
144 #if ENABLE(MEDIA_STREAM)
145     ExceptionOr&lt;Ref&lt;MediaStreamAudioSourceNode&gt;&gt; createMediaStreamSource(MediaStream&amp;);
146     ExceptionOr&lt;Ref&lt;MediaStreamAudioDestinationNode&gt;&gt; createMediaStreamDestination();
147 #endif
148     ExceptionOr&lt;Ref&lt;GainNode&gt;&gt; createGain();
149     ExceptionOr&lt;Ref&lt;BiquadFilterNode&gt;&gt; createBiquadFilter();
150     ExceptionOr&lt;Ref&lt;WaveShaperNode&gt;&gt; createWaveShaper();
</pre>
<hr />
<pre>
274     void addBehaviorRestriction(BehaviorRestrictions restriction) { m_restrictions |= restriction; }
275     void removeBehaviorRestriction(BehaviorRestrictions restriction) { m_restrictions &amp;= ~restriction; }
276 
277     void isPlayingAudioDidChange();
278 
279     void nodeWillBeginPlayback();
280 
281 #if !RELEASE_LOG_DISABLED
282     const Logger&amp; logger() const final { return m_logger.get(); }
283     const void* logIdentifier() const final { return m_logIdentifier; }
284     WTFLogChannel&amp; logChannel() const final;
285     const void* nextAudioNodeLogIdentifier() { return childLogIdentifier(++m_nextAudioNodeIdentifier); }
286     const void* nextAudioParameterLogIdentifier() { return childLogIdentifier(++m_nextAudioParameterIdentifier); }
287 #endif
288 
289     void postTask(WTF::Function&lt;void()&gt;&amp;&amp;);
290     bool isStopped() const { return m_isStopScheduled; }
291     const SecurityOrigin* origin() const;
292     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message);
293 
<span class="line-added">294     // EventTarget</span>
<span class="line-added">295     ScriptExecutionContext* scriptExecutionContext() const final;</span>
<span class="line-added">296 </span>
297 protected:
298     explicit AudioContext(Document&amp;);
<span class="line-modified">299     AudioContext(Document&amp;, AudioBuffer* renderTarget);</span>
300 
301     static bool isSampleRateRangeGood(float sampleRate);
302     void clearPendingActivity();
303     void makePendingActivity();
304 
305 private:
306     void constructCommon();
307 
308     void lazyInitialize();
309     void uninitialize();
310 
311     bool willBeginPlayback();
312     bool willPausePlayback();
313 
314     bool userGestureRequiredForAudioStart() const { return !isOfflineContext() &amp;&amp; m_restrictions &amp; RequireUserGestureForAudioStartRestriction; }
315     bool pageConsentRequiredForAudioStart() const { return !isOfflineContext() &amp;&amp; m_restrictions &amp; RequirePageConsentForAudioStartRestriction; }
316 
317     void setState(State);
318 
319     void clear();
320 
321     void scheduleNodeDeletion();
322 
323     void mediaCanStart(Document&amp;) override;
324 
325     // EventTarget

326     void dispatchEvent(Event&amp;) final;
327 
328     // MediaProducer
329     MediaProducer::MediaStateFlags mediaState() const override;
330     void pageMutedStateDidChange() override;
331 
332     // The context itself keeps a reference to all source nodes.  The source nodes, then reference all nodes they&#39;re connected to.
333     // In turn, these nodes reference all nodes they&#39;re connected to.  All nodes are ultimately connected to the AudioDestinationNode.
334     // When the context dereferences a source node, it will be deactivated from the rendering graph along with all other nodes it is
335     // uniquely connected to.  See the AudioNode::ref() and AudioNode::deref() methods for more details.
336     void refNode(AudioNode&amp;);
337     void derefNode(AudioNode&amp;);
338 
339     // ActiveDOMObject API.
<span class="line-added">340     void suspend(ReasonForSuspension) final;</span>
<span class="line-added">341     void resume() final;</span>
342     void stop() override;

343     const char* activeDOMObjectName() const override;
344 
345     // When the context goes away, there might still be some sources which haven&#39;t finished playing.
346     // Make sure to dereference them here.
347     void derefUnfinishedSourceNodes();
348 
349     // PlatformMediaSessionClient
350     PlatformMediaSession::MediaType mediaType() const override { return PlatformMediaSession::WebAudio; }
351     PlatformMediaSession::MediaType presentationType() const override { return PlatformMediaSession::WebAudio; }
352     PlatformMediaSession::CharacteristicsFlags characteristics() const override { return m_state == State::Running ? PlatformMediaSession::HasAudio : PlatformMediaSession::HasNothing; }
353     void mayResumePlayback(bool shouldResume) override;
354     void suspendPlayback() override;
355     bool canReceiveRemoteControlCommands() const override { return false; }
356     void didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType, const PlatformMediaSession::RemoteCommandArgument*) override { }
357     bool supportsSeeking() const override { return false; }
358     bool shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType) const override { return false; }
359     String sourceApplicationIdentifier() const override;
360     bool canProduceAudio() const final { return true; }
361     bool isSuspended() const final;
362     bool processingUserGestureForMedia() const final;
</pre>
<hr />
<pre>
402     bool m_isDeletionScheduled { false };
403     bool m_isStopScheduled { false };
404     bool m_isInitialized { false };
405     bool m_isAudioThreadFinished { false };
406     bool m_automaticPullNodesNeedUpdating { false };
407     bool m_isOfflineContext { false };
408 
409     // Only accessed when the graph lock is held.
410     HashSet&lt;AudioSummingJunction*&gt; m_dirtySummingJunctions;
411     HashSet&lt;AudioNodeOutput*&gt; m_dirtyAudioNodeOutputs;
412 
413     // For the sake of thread safety, we maintain a seperate Vector of automatic pull nodes for rendering in m_renderingAutomaticPullNodes.
414     // It will be copied from m_automaticPullNodes by updateAutomaticPullNodes() at the very start or end of the rendering quantum.
415     HashSet&lt;AudioNode*&gt; m_automaticPullNodes;
416     Vector&lt;AudioNode*&gt; m_renderingAutomaticPullNodes;
417     // Only accessed in the audio thread.
418     Vector&lt;AudioNode*&gt; m_deferredFinishDerefList;
419     Vector&lt;Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;&gt; m_stateReactions;
420 
421     std::unique_ptr&lt;PlatformMediaSession&gt; m_mediaSession;
<span class="line-modified">422     UniqueRef&lt;MainThreadGenericEventQueue&gt; m_eventQueue;</span>
423 
424     RefPtr&lt;AudioBuffer&gt; m_renderTarget;
425     RefPtr&lt;AudioDestinationNode&gt; m_destinationNode;
426     RefPtr&lt;AudioListener&gt; m_listener;
427 
428     unsigned m_connectionCount { 0 };
429 
430     // Graph locking.
431     Lock m_contextGraphMutex;
432     // FIXME: Using volatile seems incorrect.
433     // https://bugs.webkit.org/show_bug.cgi?id=180332
434     Thread* volatile m_audioThread { nullptr };
435     Thread* volatile m_graphOwnerThread { nullptr }; // if the lock is held then this is the thread which owns it, otherwise == nullptr.
436 
437     std::unique_ptr&lt;AsyncAudioDecoder&gt; m_audioDecoder;
438 
439     // This is considering 32 is large enough for multiple channels audio.
440     // It is somewhat arbitrary and could be increased if necessary.
441     enum { MaxNumberOfChannels = 32 };
442 
</pre>
</td>
</tr>
</table>
<center><a href="AudioContext.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioContext.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureCacheCV.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -38,10 +38,23 @@</span>
  
  #if USE(OPENGL_ES)
  #include &lt;OpenGLES/ES3/glext.h&gt;
  #endif
  
<span class="udiff-line-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+ #define EGL_EGL_PROTOTYPES 0</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/egl.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/eglext.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/eglext_angle.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/entry_points_egl.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;</span>
<span class="udiff-line-added">+ // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.</span>
<span class="udiff-line-added">+ #define GL_ANGLE_explicit_context</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/gl2ext.h&gt;</span>
<span class="udiff-line-added">+ #include &lt;ANGLE/gl2ext_angle.h&gt;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  #include &quot;CoreVideoSoftLink.h&quot;
  
  namespace WebCore {
  
  #if HAVE(IOSURFACE)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -49,11 +62,11 @@</span>
      Unknown,
      Video,
      Full,
  };
  
<span class="udiff-line-modified-removed">- enum class TransferFunction {</span>
<span class="udiff-line-modified-added">+ enum class TransferFunctionCV {</span>
      Unknown,
      kITU_R_709_2,
      kITU_R_601_4,
      kSMPTE_240M_1995,
      kDCI_P3,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -83,27 +96,27 @@</span>
      default:
          return PixelRange::Unknown;
      }
  }
  
<span class="udiff-line-modified-removed">- static TransferFunction transferFunctionFromString(CFStringRef string)</span>
<span class="udiff-line-modified-added">+ static TransferFunctionCV transferFunctionFromString(CFStringRef string)</span>
  {
      if (!string || CFGetTypeID(string) != CFStringGetTypeID())
<span class="udiff-line-modified-removed">-         return TransferFunction::Unknown;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::Unknown;</span>
      if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
<span class="udiff-line-modified-removed">-         return TransferFunction::kITU_R_709_2;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kITU_R_709_2;</span>
      if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
<span class="udiff-line-modified-removed">-         return TransferFunction::kITU_R_601_4;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kITU_R_601_4;</span>
      if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
<span class="udiff-line-modified-removed">-         return TransferFunction::kSMPTE_240M_1995;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kSMPTE_240M_1995;</span>
      if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
<span class="udiff-line-modified-removed">-         return TransferFunction::kDCI_P3;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kDCI_P3;</span>
      if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
<span class="udiff-line-modified-removed">-         return TransferFunction::kP3_D65;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kP3_D65;</span>
      if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
<span class="udiff-line-modified-removed">-         return TransferFunction::kITU_R_2020;</span>
<span class="udiff-line-modified-removed">-     return TransferFunction::Unknown;</span>
<span class="udiff-line-modified-added">+         return TransferFunctionCV::kITU_R_2020;</span>
<span class="udiff-line-modified-added">+     return TransferFunctionCV::Unknown;</span>
  }
  
  struct GLfloatColor {
      union {
          struct {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -234,13 +247,13 @@</span>
          rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
          rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
      );
  }
  
<span class="udiff-line-modified-removed">- static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunction transferFunction)</span>
<span class="udiff-line-modified-added">+ static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunctionCV transferFunction)</span>
  {
<span class="udiff-line-modified-removed">-     using MapKey = std::pair&lt;PixelRange, TransferFunction&gt;;</span>
<span class="udiff-line-modified-added">+     using MapKey = std::pair&lt;PixelRange, TransferFunctionCV&gt;;</span>
      using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
  
      static NeverDestroyed&lt;MatrixMap&gt; matrices;
      static dispatch_once_t onceToken;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -335,18 +348,18 @@</span>
      static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
      static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
      static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
  
      dispatch_once(&amp;onceToken, ^{
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_601_4), r601VideoMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_601_4), r601FullMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_709_2), r709VideoMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_709_2), r709FullMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kITU_R_2020), bt2020VideoMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kITU_R_2020), bt2020FullMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunction::kSMPTE_240M_1995), smpte240MVideoMatrix);</span>
<span class="udiff-line-modified-removed">-         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunction::kSMPTE_240M_1995), smpte240MFullMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_601_4), r601VideoMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_601_4), r601FullMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_709_2), r709VideoMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_709_2), r709FullMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_2020), bt2020VideoMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_2020), bt2020FullMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kSMPTE_240M_1995), smpte240MVideoMatrix);</span>
<span class="udiff-line-modified-added">+         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kSMPTE_240M_1995), smpte240MFullMatrix);</span>
      });
  
      // We should never be asked to handle a Pixel Format whose range value is unknown.
      ASSERT(range != PixelRange::Unknown);
      if (range == PixelRange::Unknown)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,20 +367,20 @@</span>
  
      auto iterator = matrices.get().find({range, transferFunction});
  
      // Assume unknown transfer functions are r.601:
      if (iterator == matrices.get().end())
<span class="udiff-line-modified-removed">-         iterator = matrices.get().find({range, TransferFunction::kITU_R_601_4});</span>
<span class="udiff-line-modified-added">+         iterator = matrices.get().find({range, TransferFunctionCV::kITU_R_601_4});</span>
  
      ASSERT(iterator != matrices.get().end());
      return iterator-&gt;second;
  }
  #endif // HAVE(IOSURFACE)
  
<span class="udiff-line-modified-removed">- VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContext3D&amp; context)</span>
<span class="udiff-line-modified-added">+ VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContextGLOpenGL&amp; context)</span>
      : m_sharedContext(context)
<span class="udiff-line-modified-removed">-     , m_context(GraphicsContext3D::createShared(context))</span>
<span class="udiff-line-modified-added">+     , m_context(GraphicsContextGLOpenGL::createShared(context))</span>
      , m_framebuffer(context.createFramebuffer())
  {
  }
  
  VideoTextureCopierCV::~VideoTextureCopierCV()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -389,66 +402,66 @@</span>
  static StringMap&amp; enumToStringMap()
  {
      static NeverDestroyed&lt;StringMap&gt; map;
      if (map.get().empty()) {
          StringMap stringMap;
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16F));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32F));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R8I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R16I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::R32I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16F));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32F));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG8I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG16I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32UI));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG32I));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SRGB8_ALPHA8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA4));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB10_A2));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT16));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT24));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_COMPONENT32F));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH24_STENCIL8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH32F_STENCIL8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGB));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RGBA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE_ALPHA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::LUMINANCE));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::ALPHA));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RED));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::RG_INTEGER));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::DEPTH_STENCIL));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_BYTE));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_6_5));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::BYTE));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::HALF_FLOAT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_SHORT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::SHORT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::INT));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::UNSIGNED_INT_24_8));</span>
<span class="udiff-line-modified-removed">-         map.get().emplace(STRINGIFY_PAIR(GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16F));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32F));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16F));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32F));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32UI));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32I));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8_ALPHA8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA4));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB10_A2));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT16));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT24));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT32F));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH24_STENCIL8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH32F_STENCIL8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RED));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG_INTEGER));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_STENCIL));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_BYTE));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_6_5));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::BYTE));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::HALF_FLOAT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SHORT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::INT));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_24_8));</span>
<span class="udiff-line-modified-added">+         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
  
  #if USE(OPENGL_ES)
          map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
          map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
          map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -499,48 +512,44 @@</span>
      vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
      vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
      vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
      vertexShaderSource.appendLiteral(&quot;}\n&quot;);
  
<span class="udiff-line-modified-removed">-     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);</span>
<span class="udiff-line-modified-added">+     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
      m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
      m_context-&gt;compileShaderDirect(vertexShader);
  
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
      if (!value) {
          LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          return false;
      }
  
      StringBuilder fragmentShaderSource;
  
<span class="udiff-line-modified-removed">- #if USE(OPENGL_ES)</span>
<span class="udiff-line-modified-added">+ #if USE(OPENGL_ES) || USE(ANGLE)</span>
      fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
      fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<span class="udiff-line-modified-removed">- #elif USE(OPENGL)</span>
<span class="udiff-line-modified-added">+ #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
      fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
<span class="udiff-line-removed">- #elif USE(ANGLE)</span>
<span class="udiff-line-removed">-     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="udiff-line-removed">-     ASSERT_NOT_REACHED();</span>
  #else
  #error Unsupported configuration
  #endif
      fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
<span class="udiff-line-modified-removed">- #if USE(OPENGL_ES)</span>
<span class="udiff-line-modified-added">+ #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
      fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<span class="udiff-line-modified-removed">- #elif USE(OPENGL)</span>
<span class="udiff-line-modified-added">+ #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
      fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
<span class="udiff-line-removed">- #elif USE(ANGLE)</span>
<span class="udiff-line-removed">-     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="udiff-line-removed">-     ASSERT_NOT_REACHED();</span>
  #else
  #error Unsupported configuration
  #endif
      fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -550,15 +559,15 @@</span>
      fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
      fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
  
<span class="udiff-line-modified-removed">-     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
<span class="udiff-line-modified-added">+     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
      m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
      m_context-&gt;compileShaderDirect(fragmentShader);
  
<span class="udiff-line-modified-removed">-     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
      if (!value) {
          LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          m_context-&gt;deleteShader(fragmentShader);
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -567,11 +576,11 @@</span>
      m_program = m_context-&gt;createProgram();
      m_context-&gt;attachShader(m_program, vertexShader);
      m_context-&gt;attachShader(m_program, fragmentShader);
      m_context-&gt;linkProgram(m_program);
  
<span class="udiff-line-modified-removed">-     m_context-&gt;getProgramiv(m_program, GraphicsContext3D::LINK_STATUS, &amp;value);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getProgramiv(m_program, GraphicsContextGL::LINK_STATUS, &amp;value);</span>
      if (!value) {
          LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          m_context-&gt;deleteShader(fragmentShader);
          m_context-&gt;deleteProgram(m_program);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -595,12 +604,12 @@</span>
      m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
  
      m_vertexBuffer = m_context-&gt;createBuffer();
      float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
  
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContext3D::STATIC_DRAW);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContextGL::STATIC_DRAW);</span>
  
      return true;
  }
  
  bool VideoTextureCopierCV::initializeUVContextObjects()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -616,46 +625,44 @@</span>
          &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
          &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
          &quot;   if (u_flipY == 1) {\n&quot;
          &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
          &quot;   }\n&quot;
<span class="udiff-line-modified-removed">- #if USE(OPENGL_ES)</span>
<span class="udiff-line-modified-added">+ #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
          &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
          &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<span class="udiff-line-modified-removed">- #elif USE(OPENGL)</span>
<span class="udiff-line-modified-added">+ #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
          &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
          &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
<span class="udiff-line-removed">- #elif USE(ANGLE)</span>
<span class="udiff-line-removed">-         // FIXME: determine how to access rectangular textures via ANGLE.</span>
  #else
  #error Unsupported configuration
  #endif
          &quot;}\n&quot;_s
      };
  
<span class="udiff-line-modified-removed">-     Platform3DObject vertexShader = m_context-&gt;createShader(GraphicsContext3D::VERTEX_SHADER);</span>
<span class="udiff-line-modified-added">+     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
      m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
      m_context-&gt;compileShaderDirect(vertexShader);
  
<span class="udiff-line-modified-removed">-     GC3Dint status = 0;</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;getShaderiv(vertexShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);</span>
<span class="udiff-line-modified-added">+     GCGLint status = 0;</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
      if (!status) {
          LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          return false;
      }
  
      String fragmentShaderSource {
<span class="udiff-line-modified-removed">- #if USE(OPENGL_ES)</span>
<span class="udiff-line-modified-added">+ #if USE(OPENGL_ES) || USE(ANGLE)</span>
          &quot;precision mediump float;\n&quot;
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
          &quot;#define SAMPLERTYPE sampler2D\n&quot;
          &quot;#define TEXTUREFUNC texture2D\n&quot;
<span class="udiff-line-modified-removed">- #elif USE(OPENGL)</span>
<span class="udiff-line-modified-added">+ #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
          &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
          &quot;#define TEXTUREFUNC texture2DRect\n&quot;
<span class="udiff-line-removed">- #elif USE(ANGLE)</span>
<span class="udiff-line-removed">-         // FIXME: determine how to access rectangular textures via ANGLE.</span>
  #else
  #error Unsupported configuration
  #endif
          &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
          &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,15 +676,15 @@</span>
          &quot;    yuv.a = 1.0;\n&quot;
          &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
          &quot;}\n&quot;_s
      };
  
<span class="udiff-line-modified-removed">-     Platform3DObject fragmentShader = m_context-&gt;createShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
<span class="udiff-line-modified-added">+     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
      m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
      m_context-&gt;compileShaderDirect(fragmentShader);
  
<span class="udiff-line-modified-removed">-     m_context-&gt;getShaderiv(fragmentShader, GraphicsContext3D::COMPILE_STATUS, &amp;status);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
      if (!status) {
          LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          m_context-&gt;deleteShader(fragmentShader);
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -686,11 +693,11 @@</span>
      m_yuvProgram = m_context-&gt;createProgram();
      m_context-&gt;attachShader(m_yuvProgram, vertexShader);
      m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
      m_context-&gt;linkProgram(m_yuvProgram);
  
<span class="udiff-line-modified-removed">-     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContext3D::LINK_STATUS, &amp;status);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContextGL::LINK_STATUS, &amp;status);</span>
      if (!status) {
          LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
          m_context-&gt;deleteShader(vertexShader);
          m_context-&gt;deleteShader(fragmentShader);
          m_context-&gt;deleteProgram(m_yuvProgram);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,20 +719,75 @@</span>
      m_context-&gt;deleteShader(fragmentShader);
  
      m_yuvVertexBuffer = m_context-&gt;createBuffer();
      float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
  
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_yuvVertexBuffer);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContext3D::STATIC_DRAW);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_yuvVertexBuffer);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContextGL::STATIC_DRAW);</span>
      m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
<span class="udiff-line-modified-removed">-     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)</span>
<span class="udiff-line-modified-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+ void* VideoTextureCopierCV::attachIOSurfaceToTexture(GCGLenum target, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type, IOSurfaceRef surface, GCGLuint plane)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto display = m_context-&gt;platformDisplay();</span>
<span class="udiff-line-added">+     EGLint eglTextureTarget = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (target == GraphicsContextGL::TEXTURE_RECTANGLE_ARB)</span>
<span class="udiff-line-added">+         eglTextureTarget = EGL_TEXTURE_RECTANGLE_ANGLE;</span>
<span class="udiff-line-added">+     else if (target == GraphicsContextGL::TEXTURE_2D)</span>
<span class="udiff-line-added">+         eglTextureTarget = EGL_TEXTURE_2D;</span>
<span class="udiff-line-added">+     else {</span>
<span class="udiff-line-added">+         LOG(WebGL, &quot;Unknown texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (eglTextureTarget != GraphicsContextGL::EGLIOSurfaceTextureTarget) {</span>
<span class="udiff-line-added">+         LOG(WebGL, &quot;Mismatch in EGL texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const EGLint surfaceAttributes[] = {</span>
<span class="udiff-line-added">+         EGL_WIDTH, width,</span>
<span class="udiff-line-added">+         EGL_HEIGHT, height,</span>
<span class="udiff-line-added">+         EGL_IOSURFACE_PLANE_ANGLE, static_cast&lt;EGLint&gt;(plane),</span>
<span class="udiff-line-added">+         EGL_TEXTURE_TARGET, static_cast&lt;EGLint&gt;(eglTextureTarget),</span>
<span class="udiff-line-added">+         EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, static_cast&lt;EGLint&gt;(internalFormat),</span>
<span class="udiff-line-added">+         EGL_TEXTURE_FORMAT, EGL_TEXTURE_RGBA,</span>
<span class="udiff-line-added">+         EGL_TEXTURE_TYPE_ANGLE, static_cast&lt;EGLint&gt;(type),</span>
<span class="udiff-line-added">+         // Only has an effect on the iOS Simulator.</span>
<span class="udiff-line-added">+         EGL_IOSURFACE_USAGE_HINT_ANGLE, EGL_IOSURFACE_READ_HINT_ANGLE,</span>
<span class="udiff-line-added">+         EGL_NONE, EGL_NONE</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     EGLSurface pbuffer = EGL_CreatePbufferFromClientBuffer(display, EGL_IOSURFACE_ANGLE, surface, m_context-&gt;platformConfig(), surfaceAttributes);</span>
<span class="udiff-line-added">+     if (!pbuffer)</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     if (!EGL_BindTexImage(display, pbuffer, EGL_BACK_BUFFER)) {</span>
<span class="udiff-line-added">+         EGL_DestroySurface(display, pbuffer);</span>
<span class="udiff-line-added">+         return nullptr;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return pbuffer;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void VideoTextureCopierCV::detachIOSurfaceFromTexture(void* handle)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto display = m_context-&gt;platformDisplay();</span>
<span class="udiff-line-added">+     EGL_ReleaseTexImage(display, handle, EGL_BACK_BUFFER);</span>
<span class="udiff-line-added">+     EGL_DestroySurface(display, handle);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)</span>
  {
<span class="udiff-line-added">+     // CVOpenGLTextureCache seems to be disabled since the deprecation of</span>
<span class="udiff-line-added">+     // OpenGL. To avoid porting unused code to the ANGLE code paths, remove it.</span>
<span class="udiff-line-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     UNUSED_PARAM(outputTarget);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="udiff-line-added">+ #else</span>
      if (!m_textureCache) {
          m_textureCache = TextureCacheCV::create(m_context);
          if (!m_textureCache)
              return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -736,10 +798,11 @@</span>
          // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
          swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
  #endif
          return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
      }
<span class="udiff-line-added">+ #endif // USE(ANGLE)</span>
  
  #if HAVE(IOSURFACE)
      // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
      OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
      if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -766,23 +829,23 @@</span>
              LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
              return false;
          }
      }
  
<span class="udiff-line-modified-removed">-     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
  
      // Allocate memory for the output texture.
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);</span>
<span class="udiff-line-modified-removed">-     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);</span>
<span class="udiff-line-modified-removed">-     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="udiff-line-modified-added">+     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="udiff-line-modified-added">+     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
          LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
          return false;
      }
  
      m_context-&gt;useProgram(m_yuvProgram);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -793,43 +856,59 @@</span>
      auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
      auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
      auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
  
  #if USE(OPENGL_ES)
<span class="udiff-line-modified-removed">-     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;</span>
<span class="udiff-line-modified-added">+     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_2D;</span>
  #elif USE(OPENGL)
<span class="udiff-line-modified-removed">-     GC3Denum videoTextureTarget = GL_TEXTURE_RECTANGLE_ARB;</span>
<span class="udiff-line-modified-added">+     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_RECTANGLE_ARB;</span>
  #elif USE(ANGLE)
<span class="udiff-line-modified-removed">-     // FIXME: determine how to access rectangular textures via ANGLE.</span>
<span class="udiff-line-removed">-     GC3Denum videoTextureTarget = GraphicsContext3D::TEXTURE_2D;</span>
<span class="udiff-line-modified-added">+     GCGLenum videoTextureTarget = GraphicsContextGL::IOSurfaceTextureTarget;</span>
  #else
  #error Unsupported configuration
  #endif
      auto uvTexture = m_context-&gt;createTexture();
<span class="udiff-line-modified-removed">-     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE1);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE1);</span>
      m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContext3D::RG, GraphicsContext3D::UNSIGNED_BYTE, surface, 1)) {</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     auto uvHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 1);</span>
<span class="udiff-line-added">+     if (!uvHandle) {</span>
          m_context-&gt;deleteTexture(uvTexture);
          return false;
      }
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::RG, GraphicsContextGL::UNSIGNED_BYTE, surface, 1)) {</span>
<span class="udiff-line-added">+         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif // USE(ANGLE)</span>
  
      auto yTexture = m_context-&gt;createTexture();
<span class="udiff-line-modified-removed">-     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
      m_context-&gt;bindTexture(videoTextureTarget, yTexture);
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContext3D::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContext3D::LUMINANCE, GraphicsContext3D::UNSIGNED_BYTE, surface, 0)) {</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     auto yHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RED, yPlaneWidth, yPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 0);</span>
<span class="udiff-line-added">+     if (!yHandle) {</span>
<span class="udiff-line-added">+         m_context-&gt;deleteTexture(yTexture);</span>
<span class="udiff-line-added">+         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContextGL::LUMINANCE, GraphicsContextGL::UNSIGNED_BYTE, surface, 0)) {</span>
          m_context-&gt;deleteTexture(yTexture);
          m_context-&gt;deleteTexture(uvTexture);
          return false;
      }
<span class="udiff-line-added">+ #endif // USE(ANGLE)</span>
  
      // Configure the drawing parameters.
      m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
      m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
      m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -840,21 +919,25 @@</span>
      auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
      auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
      m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
  
      // Do the actual drawing.
<span class="udiff-line-modified-removed">-     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
  
<span class="udiff-line-modified-removed">- #if USE(OPENGL_ES)</span>
<span class="udiff-line-modified-added">+ #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
      // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
      // two EAGL contexts.
      m_context-&gt;flush();
  #endif
  
      // Clean-up.
      m_context-&gt;deleteTexture(yTexture);
      m_context-&gt;deleteTexture(uvTexture);
<span class="udiff-line-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     detachIOSurfaceFromTexture(yHandle);</span>
<span class="udiff-line-added">+     detachIOSurfaceFromTexture(uvHandle);</span>
<span class="udiff-line-added">+ #endif</span>
  
      m_lastSurface = surface;
      m_lastSurfaceSeed = newSurfaceSeed;
      m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
      m_lastFlipY = flipY;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -863,79 +946,99 @@</span>
  #else
      return false;
  #endif // HAVE(IOSURFACE)
  }
  
<span class="udiff-line-modified-removed">- bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
<span class="udiff-line-modified-added">+ bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
  {
      if (!inputVideoTexture)
          return false;
  
      GLfloat lowerLeft[2] = { 0, 0 };
      GLfloat lowerRight[2] = { 0, 0 };
      GLfloat upperRight[2] = { 0, 0 };
      GLfloat upperLeft[2] = { 0, 0 };
<span class="udiff-line-added">+     PlatformGLObject videoTextureName;</span>
<span class="udiff-line-added">+     GCGLenum videoTextureTarget;</span>
<span class="udiff-line-added">+ </span>
  #if USE(OPENGL_ES)
<span class="udiff-line-modified-removed">-     Platform3DObject videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);</span>
<span class="udiff-line-modified-removed">-     GC3Denum videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);</span>
<span class="udiff-line-modified-added">+     videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);</span>
<span class="udiff-line-modified-added">+     videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);</span>
      CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
  #elif USE(OPENGL)
<span class="udiff-line-modified-removed">-     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="udiff-line-modified-removed">-     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
<span class="udiff-line-modified-added">+     videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="udiff-line-modified-added">+     videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
      CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
  #elif USE(ANGLE)
<span class="udiff-line-modified-removed">-     Platform3DObject videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="udiff-line-modified-removed">-     GC3Denum videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
<span class="udiff-line-modified-removed">-     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);</span>
<span class="udiff-line-modified-added">+     // CVOpenGLTextureCacheCreateTextureFromImage seems to always return</span>
<span class="udiff-line-modified-added">+     // kCVReturnPixelBufferNotOpenGLCompatible on desktop macOS now, so this</span>
<span class="udiff-line-modified-added">+     // entire code path seems to be unused. Assume the IOSurface path will be</span>
<span class="udiff-line-added">+     // taken when using ANGLE.</span>
<span class="udiff-line-added">+     UNUSED_PARAM(lowerLeft);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(lowerRight);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(upperLeft);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(upperRight);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(width);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(height);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(outputTexture);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(outputTarget);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(level);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(internalFormat);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(format);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(type);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(flipY);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(swapColorChannels);</span>
      // FIXME: determine how to access rectangular textures via ANGLE.
<span class="udiff-line-modified-removed">-     ASSERT_NOT_REACHED();</span>
<span class="udiff-line-modified-added">+     UNIMPLEMENTED();</span>
<span class="udiff-line-added">+     return false;</span>
  #endif
  
      if (lowerLeft[1] &lt; upperRight[1])
          flipY = !flipY;
  
      return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
  }
  
<span class="udiff-line-modified-removed">- bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(Platform3DObject videoTextureName, GC3Denum videoTextureTarget, size_t width, size_t height, Platform3DObject outputTexture, GC3Denum outputTarget, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
<span class="udiff-line-modified-added">+ bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(PlatformGLObject videoTextureName, GCGLenum videoTextureTarget, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
  {
      LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
  
      if (!m_program) {
          if (!initializeContextObjects()) {
              LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
              return false;
          }
      }
  
<span class="udiff-line-modified-removed">-     m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebuffer);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
  
      // Allocate memory for the output texture.
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, outputTexture);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2DDirect(GraphicsContext3D::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     m_context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0, GraphicsContext3D::TEXTURE_2D, outputTexture, level);</span>
<span class="udiff-line-modified-removed">-     GC3Denum status = m_context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER);</span>
<span class="udiff-line-modified-removed">-     if (status != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="udiff-line-modified-added">+     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="udiff-line-modified-added">+     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
          LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
          return false;
      }
  
      m_context-&gt;useProgram(m_program);
      m_context-&gt;viewport(0, 0, width, height);
  
      // Bind and set up the texture for the video source.
<span class="udiff-line-modified-removed">-     m_context-&gt;activeTexture(GraphicsContext3D::TEXTURE0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
      m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
  
      // Configure the drawing parameters.
      m_context-&gt;uniform1i(m_textureUniformLocation, 0);
  #if USE(OPENGL_ES)
      m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -947,13 +1050,13 @@</span>
      m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
      m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
  
      // Do the actual drawing.
      m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContext3D::FLOAT, false, 0, 0);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;drawArrays(GraphicsContext3D::TRIANGLES, 0, 6);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
  
  #if USE(OPENGL_ES)
      // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
      // two EAGL contexts.
      m_context-&gt;flush();
</pre>
<center><a href="TextureCacheCV.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VideoTextureCopierCV.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
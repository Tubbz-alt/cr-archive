diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.h
@@ -40,11 +40,11 @@
 
 namespace bmalloc {
 
 class Scavenger : public StaticPerProcess<Scavenger> {
 public:
-    BEXPORT Scavenger(std::lock_guard<Mutex>&);
+    BEXPORT Scavenger(const LockHolder&);
 
     ~Scavenger() = delete;
 
     void scavenge();
 
@@ -75,22 +75,26 @@
     void enableMiniMode();
 
 private:
     enum class State { Sleep, Run, RunSoon };
 
-    void runHoldingLock();
-    void runSoonHoldingLock();
+    void run(const LockHolder&);
+    void runSoon(const LockHolder&);
 
-    void scheduleIfUnderMemoryPressureHoldingLock(size_t bytes);
+    void scheduleIfUnderMemoryPressure(const LockHolder&, size_t bytes);
 
     BNO_RETURN static void threadEntryPoint(Scavenger*);
     BNO_RETURN void threadRunLoop();
 
     void setSelfQOSClass();
     void setThreadName(const char*);
 
     std::chrono::milliseconds timeSinceLastFullScavenge();
+#if BUSE(PARTIAL_SCAVENGE)
+    std::chrono::milliseconds timeSinceLastPartialScavenge();
+    void partialScavenge();
+#endif
 
     std::atomic<State> m_state { State::Sleep };
     size_t m_scavengerBytes { 0 };
     std::chrono::milliseconds m_waitTime;
     bool m_isProbablyGrowing { false };
@@ -99,10 +103,13 @@
     Mutex m_scavengingMutex;
     std::condition_variable_any m_condition;
 
     std::thread m_thread;
     std::chrono::steady_clock::time_point m_lastFullScavengeTime { std::chrono::steady_clock::now() };
+#if BUSE(PARTIAL_SCAVENGE)
+    std::chrono::steady_clock::time_point m_lastPartialScavengeTime { std::chrono::steady_clock::now() };
+#endif
 
 #if BOS(DARWIN)
     dispatch_source_t m_pressureHandlerDispatchSource;
     qos_class_t m_requestedScavengerThreadQOSClass { QOS_CLASS_USER_INITIATED };
 #endif

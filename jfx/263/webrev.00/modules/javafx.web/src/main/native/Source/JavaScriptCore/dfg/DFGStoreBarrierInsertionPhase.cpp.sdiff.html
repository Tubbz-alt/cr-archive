<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGStackLayoutPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStrengthReductionPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStoreBarrierInsertionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 27 #include &quot;DFGStoreBarrierInsertionPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGAbstractInterpreterInlines.h&quot;
 32 #include &quot;DFGBlockMapInlines.h&quot;
 33 #include &quot;DFGDoesGC.h&quot;
 34 #include &quot;DFGGraph.h&quot;
 35 #include &quot;DFGInPlaceAbstractState.h&quot;
 36 #include &quot;DFGInsertionSet.h&quot;
 37 #include &quot;DFGPhase.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &lt;wtf/CommaPrinter.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 
 42 namespace JSC { namespace DFG {
 43 
 44 namespace {
 45 
 46 namespace DFGStoreBarrierInsertionPhaseInternal {
<span class="line-modified"> 47 static const bool verbose = false;</span>
 48 }
 49 
 50 enum class PhaseMode {
 51     // Does only a local analysis for store barrier insertion and assumes that pointers live
 52     // from predecessor blocks may need barriers. Assumes CPS conventions. Does not use AI for
 53     // eliminating store barriers, but does a best effort to eliminate barriers when you&#39;re
 54     // storing a non-cell value by using Node::result() and by looking at constants. The local
 55     // analysis is based on GC epochs, so it will eliminate a lot of locally redundant barriers.
 56     Fast,
 57 
 58     // Does a global analysis for store barrier insertion. Reuses the GC-epoch-based analysis
 59     // used by Fast, but adds a conservative merge rule for propagating information from one
 60     // block to the next. This will ensure for example that if a value V coming from multiple
 61     // predecessors in B didn&#39;t need any more barriers at the end of each predecessor (either
 62     // because it was the last allocated object in that predecessor or because it just had a
 63     // barrier executed), then until we hit another GC point in B, we won&#39;t need another barrier
 64     // on V. Uses AI for eliminating barriers when we know that the value being stored is not a
 65     // cell. Assumes SSA conventions.
 66     Global
 67 };
</pre>
<hr />
<pre>
264                     break;
265                 }
266                 break;
267             }
268 
269             case PutById:
270             case PutByIdFlush:
271             case PutByIdDirect:
272             case PutStructure: {
273                 considerBarrier(m_node-&gt;child1());
274                 break;
275             }
276 
277             case RecordRegExpCachedResult: {
278                 considerBarrier(m_graph.varArgChild(m_node, 0));
279                 break;
280             }
281 
282             case PutClosureVar:
283             case PutToArguments:
<span class="line-modified">284             case SetRegExpObjectLastIndex: {</span>

285                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
286                 break;
287             }
288 
289             case MultiPutByOffset: {
290                 considerBarrier(m_node-&gt;child1());
291                 break;
292             }
293 
294             case PutByOffset: {
295                 considerBarrier(m_node-&gt;child2(), m_node-&gt;child3());
296                 break;
297             }
298 
299             case PutGlobalVariable: {
300                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
301                 break;
302             }
303 
304             case SetFunctionName: {
305                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
306                 break;
307             }
308 
309             case NukeStructureAndSetButterfly: {
310                 considerBarrier(m_node-&gt;child1());
311                 break;
312             }
313 
314             default:
315                 break;
316             }
317 
318             if (doesGC(m_graph, m_node))
319                 m_currentEpoch.bump();
320 
321             switch (m_node-&gt;op()) {
322             case NewObject:



323             case NewArray:
324             case NewArrayWithSize:
325             case NewArrayBuffer:

326             case NewTypedArray:
327             case NewRegexp:
328             case NewStringObject:
329             case NewSymbol:
330             case MaterializeNewObject:
331             case MaterializeCreateActivation:
332             case MakeRope:
333             case CreateActivation:
334             case CreateDirectArguments:
335             case CreateScopedArguments:
336             case CreateClonedArguments:

337             case NewFunction:
338             case NewGeneratorFunction:
339             case NewAsyncGeneratorFunction:
340             case NewAsyncFunction:
341             case AllocatePropertyStorage:
342             case ReallocatePropertyStorage:
343                 // Nodes that allocate get to set their epoch because for those nodes we know
344                 // that they will be the newest object in the heap.
345                 m_node-&gt;setEpoch(m_currentEpoch);
346                 break;
347 
348             case Upsilon:
349                 // Assume the worst for Phis so that we don&#39;t have to worry about Phi shadows.
350                 m_node-&gt;phi()-&gt;setEpoch(Epoch());
351                 m_node-&gt;setEpoch(Epoch());
352                 break;
353 
354             default:
355                 // For nodes that aren&#39;t guaranteed to allocate, we say that their return value
356                 // (if there is one) could be arbitrarily old.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 27 #include &quot;DFGStoreBarrierInsertionPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGAbstractInterpreterInlines.h&quot;
 32 #include &quot;DFGBlockMapInlines.h&quot;
 33 #include &quot;DFGDoesGC.h&quot;
 34 #include &quot;DFGGraph.h&quot;
 35 #include &quot;DFGInPlaceAbstractState.h&quot;
 36 #include &quot;DFGInsertionSet.h&quot;
 37 #include &quot;DFGPhase.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &lt;wtf/CommaPrinter.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 
 42 namespace JSC { namespace DFG {
 43 
 44 namespace {
 45 
 46 namespace DFGStoreBarrierInsertionPhaseInternal {
<span class="line-modified"> 47 static constexpr bool verbose = false;</span>
 48 }
 49 
 50 enum class PhaseMode {
 51     // Does only a local analysis for store barrier insertion and assumes that pointers live
 52     // from predecessor blocks may need barriers. Assumes CPS conventions. Does not use AI for
 53     // eliminating store barriers, but does a best effort to eliminate barriers when you&#39;re
 54     // storing a non-cell value by using Node::result() and by looking at constants. The local
 55     // analysis is based on GC epochs, so it will eliminate a lot of locally redundant barriers.
 56     Fast,
 57 
 58     // Does a global analysis for store barrier insertion. Reuses the GC-epoch-based analysis
 59     // used by Fast, but adds a conservative merge rule for propagating information from one
 60     // block to the next. This will ensure for example that if a value V coming from multiple
 61     // predecessors in B didn&#39;t need any more barriers at the end of each predecessor (either
 62     // because it was the last allocated object in that predecessor or because it just had a
 63     // barrier executed), then until we hit another GC point in B, we won&#39;t need another barrier
 64     // on V. Uses AI for eliminating barriers when we know that the value being stored is not a
 65     // cell. Assumes SSA conventions.
 66     Global
 67 };
</pre>
<hr />
<pre>
264                     break;
265                 }
266                 break;
267             }
268 
269             case PutById:
270             case PutByIdFlush:
271             case PutByIdDirect:
272             case PutStructure: {
273                 considerBarrier(m_node-&gt;child1());
274                 break;
275             }
276 
277             case RecordRegExpCachedResult: {
278                 considerBarrier(m_graph.varArgChild(m_node, 0));
279                 break;
280             }
281 
282             case PutClosureVar:
283             case PutToArguments:
<span class="line-modified">284             case SetRegExpObjectLastIndex:</span>
<span class="line-added">285             case PutInternalField: {</span>
286                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
287                 break;
288             }
289 
290             case MultiPutByOffset: {
291                 considerBarrier(m_node-&gt;child1());
292                 break;
293             }
294 
295             case PutByOffset: {
296                 considerBarrier(m_node-&gt;child2(), m_node-&gt;child3());
297                 break;
298             }
299 
300             case PutGlobalVariable: {
301                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
302                 break;
303             }
304 
305             case SetFunctionName: {
306                 considerBarrier(m_node-&gt;child1(), m_node-&gt;child2());
307                 break;
308             }
309 
310             case NukeStructureAndSetButterfly: {
311                 considerBarrier(m_node-&gt;child1());
312                 break;
313             }
314 
315             default:
316                 break;
317             }
318 
319             if (doesGC(m_graph, m_node))
320                 m_currentEpoch.bump();
321 
322             switch (m_node-&gt;op()) {
323             case NewObject:
<span class="line-added">324             case NewPromise:</span>
<span class="line-added">325             case NewGenerator:</span>
<span class="line-added">326             case NewAsyncGenerator:</span>
327             case NewArray:
328             case NewArrayWithSize:
329             case NewArrayBuffer:
<span class="line-added">330             case NewArrayIterator:</span>
331             case NewTypedArray:
332             case NewRegexp:
333             case NewStringObject:
334             case NewSymbol:
335             case MaterializeNewObject:
336             case MaterializeCreateActivation:
337             case MakeRope:
338             case CreateActivation:
339             case CreateDirectArguments:
340             case CreateScopedArguments:
341             case CreateClonedArguments:
<span class="line-added">342             case CreateArgumentsButterfly:</span>
343             case NewFunction:
344             case NewGeneratorFunction:
345             case NewAsyncGeneratorFunction:
346             case NewAsyncFunction:
347             case AllocatePropertyStorage:
348             case ReallocatePropertyStorage:
349                 // Nodes that allocate get to set their epoch because for those nodes we know
350                 // that they will be the newest object in the heap.
351                 m_node-&gt;setEpoch(m_currentEpoch);
352                 break;
353 
354             case Upsilon:
355                 // Assume the worst for Phis so that we don&#39;t have to worry about Phi shadows.
356                 m_node-&gt;phi()-&gt;setEpoch(Epoch());
357                 m_node-&gt;setEpoch(Epoch());
358                 break;
359 
360             default:
361                 // For nodes that aren&#39;t guaranteed to allocate, we say that their return value
362                 // (if there is one) could be arbitrarily old.
</pre>
</td>
</tr>
</table>
<center><a href="DFGStackLayoutPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStrengthReductionPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
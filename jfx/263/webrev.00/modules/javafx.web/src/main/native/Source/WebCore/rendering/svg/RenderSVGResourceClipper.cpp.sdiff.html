<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderSVGRect.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceFilter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGResourceClipper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59 }
 60 
 61 void RenderSVGResourceClipper::removeClientFromCache(RenderElement&amp; client, bool markForInvalidation)
 62 {
 63     m_clipper.remove(&amp;client);
 64 
 65     markClientForInvalidation(client, markForInvalidation ? BoundariesInvalidation : ParentOnlyInvalidation);
 66 }
 67 
 68 bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
 69 {
 70     ASSERT(context);
 71     ASSERT_UNUSED(resourceMode, !resourceMode);
 72 
 73     return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);
 74 }
 75 
 76 bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
 77 {
 78     // If the current clip-path gets clipped itself, we have to fallback to masking.
<span class="line-modified"> 79     if (!style().svgStyle().clipperResource().isEmpty())</span>
 80         return false;
 81     WindRule clipRule = WindRule::NonZero;
 82     Path clipPath = Path();
 83 
 84     // If clip-path only contains one visible shape or path, we can use path-based clipping. Invisible
 85     // shapes don&#39;t affect the clipping and can be ignored. If clip-path contains more than one
 86     // visible shape, the additive clipping may not work, caused by the clipRule. EvenOdd
 87     // as well as NonZero can cause self-clipping of the elements.
 88     // See also http://www.w3.org/TR/SVG/painting.html#FillRuleProperty
 89     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
 90         RenderObject* renderer = childNode-&gt;renderer();
 91         if (!renderer)
 92             continue;
 93         // Only shapes or paths are supported for direct clipping. We need to fallback to masking for texts.
 94         if (renderer-&gt;isSVGText())
 95             return false;
 96         if (!childNode-&gt;isSVGElement() || !downcast&lt;SVGElement&gt;(*childNode).isSVGGraphicsElement())
 97             continue;
 98         SVGGraphicsElement&amp; styled = downcast&lt;SVGGraphicsElement&gt;(*childNode);
 99         const RenderStyle&amp; style = renderer-&gt;style();
100         if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
101              continue;
102         const SVGRenderStyle&amp; svgStyle = style.svgStyle();
103         // Current shape in clip-path gets clipped too. Fallback to masking.
<span class="line-modified">104         if (!svgStyle.clipperResource().isEmpty())</span>
105             return false;
106         // Fallback to masking, if there is more than one clipping path.
107         if (clipPath.isEmpty()) {
108             clipPath = styled.toClipPath();
109             clipRule = svgStyle.clipRule();
110         } else
111             return false;
112     }
113     // Only one visible shape/path was found. Directly continue clipping and transform the content to userspace if necessary.
114     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
115         AffineTransform transform;
116         transform.translate(objectBoundingBox.location());
117         transform.scale(objectBoundingBox.size());
118         clipPath.transform(transform);
119     }
120 
121     // Transform path by animatedLocalTransform.
122     clipPath.transform(animatedLocalTransform);
123 
124     // The SVG specification wants us to clip everything, if clip-path doesn&#39;t have a child.
125     if (clipPath.isEmpty())
126         clipPath.addRect(FloatRect());
127     context.clipPath(clipPath, clipRule);
128     return true;
129 }
130 
131 bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, const FloatRect&amp; repaintRect, GraphicsContext&amp; context)
132 {
133     ClipperMaskImage&amp; clipperMaskImage = addRendererToClipper(renderer);
134     bool shouldCreateClipperMaskImage = !clipperMaskImage;
135 
136     AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
137 
138     if (shouldCreateClipperMaskImage &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))
139         return true;
140 
141     AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
142 
143     if (shouldCreateClipperMaskImage &amp;&amp; !repaintRect.isEmpty()) {
144         // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<span class="line-modified">145         clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpaceSRGB, Unaccelerated, &amp;context);</span>
146         if (!clipperMaskImage)
147             return false;
148 
149         GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();
150         maskContext.concatCTM(animatedLocalTransform);
151 
152         // clipPath can also be clipped by another clipPath.
153         auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
154         RenderSVGResourceClipper* clipper;
155         bool succeeded;
156         if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
157             GraphicsContextStateSaver stateSaver(maskContext);
158 
159             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))
160                 return false;
161 
162             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
163             // The context restore applies the clipping on non-CG platforms.
164         } else
165             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
</pre>
<hr />
<pre>
262 {
263     FloatPoint point = nodeAtPoint;
264     if (!SVGRenderSupport::pointInClippingArea(*this, point))
265         return false;
266 
267     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
268         AffineTransform transform;
269         transform.translate(objectBoundingBox.location());
270         transform.scale(objectBoundingBox.size());
271         point = transform.inverse().valueOr(AffineTransform()).mapPoint(point);
272     }
273 
274     point = clipPathElement().animatedLocalTransform().inverse().valueOr(AffineTransform()).mapPoint(point);
275 
276     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
277         RenderObject* renderer = childNode-&gt;renderer();
278         if (!childNode-&gt;isSVGElement() || !renderer)
279             continue;
280         if (!renderer-&gt;isSVGShape() &amp;&amp; !renderer-&gt;isSVGText() &amp;&amp; !childNode-&gt;hasTagName(SVGNames::useTag))
281             continue;










282         IntPoint hitPoint;
283         HitTestResult result(hitPoint);
284         if (renderer-&gt;nodeAtFloatPoint(HitTestRequest(HitTestRequest::SVGClipContent | HitTestRequest::DisallowUserAgentShadowContent), result, point, HitTestForeground))
285             return true;
286     }
287 
288     return false;
289 }
290 
291 FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
292 {
293     // Resource was not layouted yet. Give back the boundingBox of the object.
294     if (selfNeedsLayout()) {
295         addRendererToClipper(object);
296         return object.objectBoundingBox();
297     }
298 
299     if (m_clipBoundaries.isEmpty())
300         calculateClipContentRepaintRect();
301 
</pre>
</td>
<td>
<hr />
<pre>
 59 }
 60 
 61 void RenderSVGResourceClipper::removeClientFromCache(RenderElement&amp; client, bool markForInvalidation)
 62 {
 63     m_clipper.remove(&amp;client);
 64 
 65     markClientForInvalidation(client, markForInvalidation ? BoundariesInvalidation : ParentOnlyInvalidation);
 66 }
 67 
 68 bool RenderSVGResourceClipper::applyResource(RenderElement&amp; renderer, const RenderStyle&amp;, GraphicsContext*&amp; context, OptionSet&lt;RenderSVGResourceMode&gt; resourceMode)
 69 {
 70     ASSERT(context);
 71     ASSERT_UNUSED(resourceMode, !resourceMode);
 72 
 73     return applyClippingToContext(renderer, renderer.objectBoundingBox(), renderer.repaintRectInLocalCoordinates(), *context);
 74 }
 75 
 76 bool RenderSVGResourceClipper::pathOnlyClipping(GraphicsContext&amp; context, const AffineTransform&amp; animatedLocalTransform, const FloatRect&amp; objectBoundingBox)
 77 {
 78     // If the current clip-path gets clipped itself, we have to fallback to masking.
<span class="line-modified"> 79     if (style().clipPath())</span>
 80         return false;
 81     WindRule clipRule = WindRule::NonZero;
 82     Path clipPath = Path();
 83 
 84     // If clip-path only contains one visible shape or path, we can use path-based clipping. Invisible
 85     // shapes don&#39;t affect the clipping and can be ignored. If clip-path contains more than one
 86     // visible shape, the additive clipping may not work, caused by the clipRule. EvenOdd
 87     // as well as NonZero can cause self-clipping of the elements.
 88     // See also http://www.w3.org/TR/SVG/painting.html#FillRuleProperty
 89     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
 90         RenderObject* renderer = childNode-&gt;renderer();
 91         if (!renderer)
 92             continue;
 93         // Only shapes or paths are supported for direct clipping. We need to fallback to masking for texts.
 94         if (renderer-&gt;isSVGText())
 95             return false;
 96         if (!childNode-&gt;isSVGElement() || !downcast&lt;SVGElement&gt;(*childNode).isSVGGraphicsElement())
 97             continue;
 98         SVGGraphicsElement&amp; styled = downcast&lt;SVGGraphicsElement&gt;(*childNode);
 99         const RenderStyle&amp; style = renderer-&gt;style();
100         if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
101              continue;
102         const SVGRenderStyle&amp; svgStyle = style.svgStyle();
103         // Current shape in clip-path gets clipped too. Fallback to masking.
<span class="line-modified">104         if (style.clipPath())</span>
105             return false;
106         // Fallback to masking, if there is more than one clipping path.
107         if (clipPath.isEmpty()) {
108             clipPath = styled.toClipPath();
109             clipRule = svgStyle.clipRule();
110         } else
111             return false;
112     }
113     // Only one visible shape/path was found. Directly continue clipping and transform the content to userspace if necessary.
114     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
115         AffineTransform transform;
116         transform.translate(objectBoundingBox.location());
117         transform.scale(objectBoundingBox.size());
118         clipPath.transform(transform);
119     }
120 
121     // Transform path by animatedLocalTransform.
122     clipPath.transform(animatedLocalTransform);
123 
124     // The SVG specification wants us to clip everything, if clip-path doesn&#39;t have a child.
125     if (clipPath.isEmpty())
126         clipPath.addRect(FloatRect());
127     context.clipPath(clipPath, clipRule);
128     return true;
129 }
130 
131 bool RenderSVGResourceClipper::applyClippingToContext(RenderElement&amp; renderer, const FloatRect&amp; objectBoundingBox, const FloatRect&amp; repaintRect, GraphicsContext&amp; context)
132 {
133     ClipperMaskImage&amp; clipperMaskImage = addRendererToClipper(renderer);
134     bool shouldCreateClipperMaskImage = !clipperMaskImage;
135 
136     AffineTransform animatedLocalTransform = clipPathElement().animatedLocalTransform();
137 
138     if (shouldCreateClipperMaskImage &amp;&amp; pathOnlyClipping(context, animatedLocalTransform, objectBoundingBox))
139         return true;
140 
141     AffineTransform absoluteTransform = SVGRenderingContext::calculateTransformationToOutermostCoordinateSystem(renderer);
142 
143     if (shouldCreateClipperMaskImage &amp;&amp; !repaintRect.isEmpty()) {
144         // FIXME (149469): This image buffer should not be unconditionally unaccelerated. Making it match the context breaks nested clipping, though.
<span class="line-modified">145         clipperMaskImage = SVGRenderingContext::createImageBuffer(repaintRect, absoluteTransform, ColorSpace::SRGB, RenderingMode::Unaccelerated, &amp;context);</span>
146         if (!clipperMaskImage)
147             return false;
148 
149         GraphicsContext&amp; maskContext = clipperMaskImage-&gt;context();
150         maskContext.concatCTM(animatedLocalTransform);
151 
152         // clipPath can also be clipped by another clipPath.
153         auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
154         RenderSVGResourceClipper* clipper;
155         bool succeeded;
156         if (resources &amp;&amp; (clipper = resources-&gt;clipper())) {
157             GraphicsContextStateSaver stateSaver(maskContext);
158 
159             if (!clipper-&gt;applyClippingToContext(*this, objectBoundingBox, repaintRect, maskContext))
160                 return false;
161 
162             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
163             // The context restore applies the clipping on non-CG platforms.
164         } else
165             succeeded = drawContentIntoMaskImage(clipperMaskImage, objectBoundingBox);
</pre>
<hr />
<pre>
262 {
263     FloatPoint point = nodeAtPoint;
264     if (!SVGRenderSupport::pointInClippingArea(*this, point))
265         return false;
266 
267     if (clipPathElement().clipPathUnits() == SVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX) {
268         AffineTransform transform;
269         transform.translate(objectBoundingBox.location());
270         transform.scale(objectBoundingBox.size());
271         point = transform.inverse().valueOr(AffineTransform()).mapPoint(point);
272     }
273 
274     point = clipPathElement().animatedLocalTransform().inverse().valueOr(AffineTransform()).mapPoint(point);
275 
276     for (Node* childNode = clipPathElement().firstChild(); childNode; childNode = childNode-&gt;nextSibling()) {
277         RenderObject* renderer = childNode-&gt;renderer();
278         if (!childNode-&gt;isSVGElement() || !renderer)
279             continue;
280         if (!renderer-&gt;isSVGShape() &amp;&amp; !renderer-&gt;isSVGText() &amp;&amp; !childNode-&gt;hasTagName(SVGNames::useTag))
281             continue;
<span class="line-added">282 </span>
<span class="line-added">283         const RenderStyle&amp; style = renderer-&gt;style();</span>
<span class="line-added">284         if (is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {</span>
<span class="line-added">285             auto&amp; clipPath = downcast&lt;ReferenceClipPathOperation&gt;(*style.clipPath());</span>
<span class="line-added">286             AtomString id(clipPath.fragment());</span>
<span class="line-added">287             RenderSVGResourceClipper* clipper = getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document(), id);</span>
<span class="line-added">288             if (clipper == this)</span>
<span class="line-added">289                 continue;</span>
<span class="line-added">290         }</span>
<span class="line-added">291 </span>
292         IntPoint hitPoint;
293         HitTestResult result(hitPoint);
294         if (renderer-&gt;nodeAtFloatPoint(HitTestRequest(HitTestRequest::SVGClipContent | HitTestRequest::DisallowUserAgentShadowContent), result, point, HitTestForeground))
295             return true;
296     }
297 
298     return false;
299 }
300 
301 FloatRect RenderSVGResourceClipper::resourceBoundingBox(const RenderObject&amp; object)
302 {
303     // Resource was not layouted yet. Give back the boundingBox of the object.
304     if (selfNeedsLayout()) {
305         addRendererToClipper(object);
306         return object.objectBoundingBox();
307     }
308 
309     if (m_clipBoundaries.isEmpty())
310         calculateClipContentRepaintRect();
311 
</pre>
</td>
</tr>
</table>
<center><a href="RenderSVGRect.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceFilter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
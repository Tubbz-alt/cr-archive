<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSLazyEventListener.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSImageDataCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSLazyEventListener.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSLazyEventListener.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,11 ***</span>
  #ifndef NDEBUG
      eventListenerCounter.increment();
  #endif
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  static inline bool isCloneInShadowTreeOfSVGUseElement(Node&amp; originalNode, EventTarget&amp; eventTarget)
  {
      if (!eventTarget.isNode())
          return false;
  
<span class="line-new-header">--- 78,11 ---</span>
  #ifndef NDEBUG
      eventListenerCounter.increment();
  #endif
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  static inline bool isCloneInShadowTreeOfSVGUseElement(Node&amp; originalNode, EventTarget&amp; eventTarget)
  {
      if (!eventTarget.isNode())
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,43 ***</span>
          return nullptr;
  
      VM&amp; vm = globalObject-&gt;vm();
      JSLockHolder lock(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
  
      MarkedArgumentBuffer args;
      args.append(jsNontrivialString(vm, m_eventParameterName));
<span class="line-modified">!     args.append(jsStringWithCache(exec, m_code));</span>
      ASSERT(!args.hasOverflowed());
  
      // We want all errors to refer back to the line on which our attribute was
      // declared, regardless of any newlines in our JavaScript source text.
      int overrideLineNumber = m_sourcePosition.m_line.oneBasedInt();
  
<span class="line-modified">!     JSObject* jsFunction = constructFunctionSkippingEvalEnabledCheck(exec,</span>
<span class="line-modified">!         exec-&gt;lexicalGlobalObject(), args, Identifier::fromString(vm, m_functionName),</span>
          SourceOrigin { m_sourceURL, CachedScriptFetcher::create(document.charset()) },
          m_sourceURL, m_sourcePosition, overrideLineNumber);
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         reportCurrentException(exec);</span>
          scope.clearException();
          return nullptr;
      }
  
      JSFunction* listenerAsFunction = jsCast&lt;JSFunction*&gt;(jsFunction);
  
      if (m_originalNode) {
          if (!wrapper()) {
              // Ensure that &#39;node&#39; has a JavaScript wrapper to mark the event listener we&#39;re creating.
              // FIXME: Should pass the global object associated with the node
<span class="line-modified">!             setWrapper(vm, asObject(toJS(exec, globalObject, *m_originalNode)));</span>
          }
  
          // Add the event&#39;s home element to the scope
          // (and the document, and the form - see JSHTMLElement::eventHandlerScope)
<span class="line-modified">!         listenerAsFunction-&gt;setScope(vm, jsCast&lt;JSNode*&gt;(wrapper())-&gt;pushEventHandlerScope(exec, listenerAsFunction-&gt;scope()));</span>
      }
  
      return jsFunction;
  }
  
<span class="line-new-header">--- 144,43 ---</span>
          return nullptr;
  
      VM&amp; vm = globalObject-&gt;vm();
      JSLockHolder lock(vm);
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
  
      MarkedArgumentBuffer args;
      args.append(jsNontrivialString(vm, m_eventParameterName));
<span class="line-modified">!     args.append(jsStringWithCache(lexicalGlobalObject, m_code));</span>
      ASSERT(!args.hasOverflowed());
  
      // We want all errors to refer back to the line on which our attribute was
      // declared, regardless of any newlines in our JavaScript source text.
      int overrideLineNumber = m_sourcePosition.m_line.oneBasedInt();
  
<span class="line-modified">!     JSObject* jsFunction = constructFunctionSkippingEvalEnabledCheck(</span>
<span class="line-modified">!         lexicalGlobalObject, args, Identifier::fromString(vm, m_functionName),</span>
          SourceOrigin { m_sourceURL, CachedScriptFetcher::create(document.charset()) },
          m_sourceURL, m_sourcePosition, overrideLineNumber);
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         reportCurrentException(lexicalGlobalObject);</span>
          scope.clearException();
          return nullptr;
      }
  
      JSFunction* listenerAsFunction = jsCast&lt;JSFunction*&gt;(jsFunction);
  
      if (m_originalNode) {
          if (!wrapper()) {
              // Ensure that &#39;node&#39; has a JavaScript wrapper to mark the event listener we&#39;re creating.
              // FIXME: Should pass the global object associated with the node
<span class="line-modified">!             setWrapper(vm, asObject(toJS(lexicalGlobalObject, globalObject, *m_originalNode)));</span>
          }
  
          // Add the event&#39;s home element to the scope
          // (and the document, and the form - see JSHTMLElement::eventHandlerScope)
<span class="line-modified">!         listenerAsFunction-&gt;setScope(vm, jsCast&lt;JSNode*&gt;(wrapper())-&gt;pushEventHandlerScope(lexicalGlobalObject, listenerAsFunction-&gt;scope()));</span>
      }
  
      return jsFunction;
  }
  
</pre>
<center><a href="JSImageDataCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSLazyEventListener.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoCellSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoCellSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoCellSetInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoCellSet.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24  */
25 
26 #pragma once
27 
28 #include &quot;MarkedBlock.h&quot;
29 #include &lt;wtf/Bitmap.h&gt;
30 #include &lt;wtf/ConcurrentVector.h&gt;
31 #include &lt;wtf/FastBitVector.h&gt;
32 #include &lt;wtf/SentinelLinkedList.h&gt;
33 #include &lt;wtf/SharedTask.h&gt;
34 
35 namespace JSC {
36 
37 class HeapCell;
38 class IsoSubspace;
39 
40 // Create a set of cells that are in an IsoSubspace. This allows concurrent O(1) set insertion and
41 // removal. Each such set should be thought of as a 0.8% increase in object size for objects in that
42 // IsoSubspace (it&#39;s like adding 1 bit every 16 bytes, or 1 bit every 128 bits).
<span class="line-modified">43 class IsoCellSet : public BasicRawSentinelNode&lt;IsoCellSet&gt; {</span>
44 public:
45     IsoCellSet(IsoSubspace&amp; subspace);
46     ~IsoCellSet();
47 
48     bool add(HeapCell* cell); // Returns true if the cell was newly added.
49 
50     bool remove(HeapCell* cell); // Returns true if the cell was previously present and got removed.
51 
52     bool contains(HeapCell* cell) const;
53 
54     JS_EXPORT_PRIVATE Ref&lt;SharedTask&lt;MarkedBlock::Handle*()&gt;&gt; parallelNotEmptyMarkedBlockSource();
55 
56     // This will have to do a combined search over whatever Subspace::forEachMarkedCell uses and
57     // our m_blocksWithBits.
58     template&lt;typename Func&gt;
59     void forEachMarkedCell(const Func&amp;);
60 
61     template&lt;typename Func&gt;
62     Ref&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; forEachMarkedCellInParallel(const Func&amp;);
63 
64     template&lt;typename Func&gt;
65     void forEachLiveCell(const Func&amp;);
66 
67 private:
68     friend class IsoSubspace;
69 
<span class="line-modified">70     Bitmap&lt;MarkedBlock::atomsPerBlock&gt;* addSlow(size_t blockIndex);</span>
71 
<span class="line-modified">72     void didResizeBits(size_t newSize);</span>
<span class="line-modified">73     void didRemoveBlock(size_t blockIndex);</span>
74     void sweepToFreeList(MarkedBlock::Handle*);



75 
76     IsoSubspace&amp; m_subspace;
77 
78     // Idea: sweeping to free-list clears bits for those cells that were free-listed. The first time
79     // we add a cell in a block, that block gets a free-list. Unless we do something that obviously
80     // clears all bits for a block, we keep it set in blocksWithBits.
81 
82     FastBitVector m_blocksWithBits;
83     ConcurrentVector&lt;std::unique_ptr&lt;Bitmap&lt;MarkedBlock::atomsPerBlock&gt;&gt;&gt; m_bits;
84 };
85 
86 } // namespace JSC
87 
</pre>
</td>
<td>
<hr />
<pre>
23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24  */
25 
26 #pragma once
27 
28 #include &quot;MarkedBlock.h&quot;
29 #include &lt;wtf/Bitmap.h&gt;
30 #include &lt;wtf/ConcurrentVector.h&gt;
31 #include &lt;wtf/FastBitVector.h&gt;
32 #include &lt;wtf/SentinelLinkedList.h&gt;
33 #include &lt;wtf/SharedTask.h&gt;
34 
35 namespace JSC {
36 
37 class HeapCell;
38 class IsoSubspace;
39 
40 // Create a set of cells that are in an IsoSubspace. This allows concurrent O(1) set insertion and
41 // removal. Each such set should be thought of as a 0.8% increase in object size for objects in that
42 // IsoSubspace (it&#39;s like adding 1 bit every 16 bytes, or 1 bit every 128 bits).
<span class="line-modified">43 class IsoCellSet : public PackedRawSentinelNode&lt;IsoCellSet&gt; {</span>
44 public:
45     IsoCellSet(IsoSubspace&amp; subspace);
46     ~IsoCellSet();
47 
48     bool add(HeapCell* cell); // Returns true if the cell was newly added.
49 
50     bool remove(HeapCell* cell); // Returns true if the cell was previously present and got removed.
51 
52     bool contains(HeapCell* cell) const;
53 
54     JS_EXPORT_PRIVATE Ref&lt;SharedTask&lt;MarkedBlock::Handle*()&gt;&gt; parallelNotEmptyMarkedBlockSource();
55 
56     // This will have to do a combined search over whatever Subspace::forEachMarkedCell uses and
57     // our m_blocksWithBits.
58     template&lt;typename Func&gt;
59     void forEachMarkedCell(const Func&amp;);
60 
61     template&lt;typename Func&gt;
62     Ref&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; forEachMarkedCellInParallel(const Func&amp;);
63 
64     template&lt;typename Func&gt;
65     void forEachLiveCell(const Func&amp;);
66 
67 private:
68     friend class IsoSubspace;
69 
<span class="line-modified">70     Bitmap&lt;MarkedBlock::atomsPerBlock&gt;* addSlow(unsigned blockIndex);</span>
71 
<span class="line-modified">72     void didResizeBits(unsigned newSize);</span>
<span class="line-modified">73     void didRemoveBlock(unsigned blockIndex);</span>
74     void sweepToFreeList(MarkedBlock::Handle*);
<span class="line-added">75     void clearLowerTierCell(unsigned);</span>
<span class="line-added">76 </span>
<span class="line-added">77     Bitmap&lt;MarkedBlock::maxNumberOfLowerTierCells&gt; m_lowerTierBits;</span>
78 
79     IsoSubspace&amp; m_subspace;
80 
81     // Idea: sweeping to free-list clears bits for those cells that were free-listed. The first time
82     // we add a cell in a block, that block gets a free-list. Unless we do something that obviously
83     // clears all bits for a block, we keep it set in blocksWithBits.
84 
85     FastBitVector m_blocksWithBits;
86     ConcurrentVector&lt;std::unique_ptr&lt;Bitmap&lt;MarkedBlock::atomsPerBlock&gt;&gt;&gt; m_bits;
87 };
88 
89 } // namespace JSC
90 
</pre>
</td>
</tr>
</table>
<center><a href="IsoCellSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoCellSetInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
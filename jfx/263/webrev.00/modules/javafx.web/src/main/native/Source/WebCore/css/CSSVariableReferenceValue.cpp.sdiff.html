<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSValuePool.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSVariableReferenceValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSVariableReferenceValue.h&quot;
 32 
 33 #include &quot;RenderStyle.h&quot;

 34 #include &quot;StyleResolver.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 String CSSVariableReferenceValue::customCSSText() const
 39 {
 40     if (!m_serialized) {
 41         m_serialized = true;
 42         m_stringValue = m_data-&gt;tokenRange().serialize();
 43     }
 44     return m_stringValue;
 45 }
 46 
<span class="line-modified"> 47 static bool resolveTokenRange(CSSParserTokenRange, Vector&lt;CSSParserToken&gt;&amp;, ApplyCascadedPropertyState&amp;);</span>
 48 
<span class="line-modified"> 49 static bool resolveVariableFallback(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
 50 {
 51     if (range.atEnd())
 52         return false;
 53     ASSERT(range.peek().type() == CommaToken);
 54     range.consume();
<span class="line-modified"> 55     return resolveTokenRange(range, result, state);</span>
 56 }
 57 
<span class="line-modified"> 58 static bool resolveVariableReference(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
 59 {
<span class="line-modified"> 60     auto&amp; registeredProperties = state.styleResolver-&gt;document().getCSSRegisteredCustomPropertySet();</span>
<span class="line-modified"> 61     auto&amp; style = *state.styleResolver-&gt;style();</span>
 62 
 63     range.consumeWhitespace();
 64     ASSERT(range.peek().type() == IdentToken);
 65     String variableName = range.consumeIncludingWhitespace().value().toString();
 66     ASSERT(range.atEnd() || (range.peek().type() == CommaToken));
 67 
 68     // Apply this variable first, in case it is still unresolved
<span class="line-modified"> 69     state.styleResolver-&gt;applyCascadedCustomProperty(variableName, state);</span>
 70 
 71     // Apply fallback to detect cycles
 72     Vector&lt;CSSParserToken&gt; fallbackResult;
<span class="line-modified"> 73     bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, state);</span>
 74 
 75     auto* property = style.getCustomProperty(variableName);
 76 
 77     if (!property || property-&gt;isUnset()) {
 78         auto* registered = registeredProperties.get(variableName);
 79         if (registered &amp;&amp; registered-&gt;initialValue())
 80             property = registered-&gt;initialValue();
 81     }
 82 
 83     if (!property || property-&gt;isInvalid()) {
 84         if (fallbackReturn)
 85             result.appendVector(fallbackResult);
 86         return fallbackReturn;
 87     }
 88 
 89     ASSERT(property-&gt;isResolved());
 90     result.appendVector(property-&gt;tokens());
 91 
 92     return true;
 93 }
 94 
<span class="line-modified"> 95 static bool resolveTokenRange(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
 96 {
 97     bool success = true;
 98     while (!range.atEnd()) {
 99         if (range.peek().functionId() == CSSValueVar || range.peek().functionId() == CSSValueEnv)
<span class="line-modified">100             success &amp;= resolveVariableReference(range.consumeBlock(), result, state);</span>
101         else
102             result.append(range.consume());
103     }
104     return success;
105 }
106 
<span class="line-modified">107 RefPtr&lt;CSSVariableData&gt; CSSVariableReferenceValue::resolveVariableReferences(ApplyCascadedPropertyState&amp; state) const</span>
108 {
109     Vector&lt;CSSParserToken&gt; resolvedTokens;
110     CSSParserTokenRange range = m_data-&gt;tokenRange();
111 
<span class="line-modified">112     if (!resolveTokenRange(range, resolvedTokens, state))</span>
113         return nullptr;
114 
115     return CSSVariableData::create(resolvedTokens);
116 }
117 
118 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSVariableReferenceValue.h&quot;
 32 
 33 #include &quot;RenderStyle.h&quot;
<span class="line-added"> 34 #include &quot;StyleBuilder.h&quot;</span>
 35 #include &quot;StyleResolver.h&quot;
 36 
 37 namespace WebCore {
 38 
 39 String CSSVariableReferenceValue::customCSSText() const
 40 {
 41     if (!m_serialized) {
 42         m_serialized = true;
 43         m_stringValue = m_data-&gt;tokenRange().serialize();
 44     }
 45     return m_stringValue;
 46 }
 47 
<span class="line-modified"> 48 static bool resolveTokenRange(CSSParserTokenRange, Vector&lt;CSSParserToken&gt;&amp;, Style::BuilderState&amp;);</span>
 49 
<span class="line-modified"> 50 static bool resolveVariableFallback(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
 51 {
 52     if (range.atEnd())
 53         return false;
 54     ASSERT(range.peek().type() == CommaToken);
 55     range.consume();
<span class="line-modified"> 56     return resolveTokenRange(range, result, builderState);</span>
 57 }
 58 
<span class="line-modified"> 59 static bool resolveVariableReference(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
 60 {
<span class="line-modified"> 61     auto&amp; registeredProperties = builderState.document().getCSSRegisteredCustomPropertySet();</span>
<span class="line-modified"> 62     auto&amp; style = builderState.style();</span>
 63 
 64     range.consumeWhitespace();
 65     ASSERT(range.peek().type() == IdentToken);
 66     String variableName = range.consumeIncludingWhitespace().value().toString();
 67     ASSERT(range.atEnd() || (range.peek().type() == CommaToken));
 68 
 69     // Apply this variable first, in case it is still unresolved
<span class="line-modified"> 70     builderState.builder().applyCustomProperty(variableName);</span>
 71 
 72     // Apply fallback to detect cycles
 73     Vector&lt;CSSParserToken&gt; fallbackResult;
<span class="line-modified"> 74     bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, builderState);</span>
 75 
 76     auto* property = style.getCustomProperty(variableName);
 77 
 78     if (!property || property-&gt;isUnset()) {
 79         auto* registered = registeredProperties.get(variableName);
 80         if (registered &amp;&amp; registered-&gt;initialValue())
 81             property = registered-&gt;initialValue();
 82     }
 83 
 84     if (!property || property-&gt;isInvalid()) {
 85         if (fallbackReturn)
 86             result.appendVector(fallbackResult);
 87         return fallbackReturn;
 88     }
 89 
 90     ASSERT(property-&gt;isResolved());
 91     result.appendVector(property-&gt;tokens());
 92 
 93     return true;
 94 }
 95 
<span class="line-modified"> 96 static bool resolveTokenRange(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
 97 {
 98     bool success = true;
 99     while (!range.atEnd()) {
100         if (range.peek().functionId() == CSSValueVar || range.peek().functionId() == CSSValueEnv)
<span class="line-modified">101             success &amp;= resolveVariableReference(range.consumeBlock(), result, builderState);</span>
102         else
103             result.append(range.consume());
104     }
105     return success;
106 }
107 
<span class="line-modified">108 RefPtr&lt;CSSVariableData&gt; CSSVariableReferenceValue::resolveVariableReferences(Style::BuilderState&amp; builderState) const</span>
109 {
110     Vector&lt;CSSParserToken&gt; resolvedTokens;
111     CSSParserTokenRange range = m_data-&gt;tokenRange();
112 
<span class="line-modified">113     if (!resolveTokenRange(range, resolvedTokens, builderState))</span>
114         return nullptr;
115 
116     return CSSVariableData::create(resolvedTokens);
117 }
118 
119 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CSSValuePool.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSVariableReferenceValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
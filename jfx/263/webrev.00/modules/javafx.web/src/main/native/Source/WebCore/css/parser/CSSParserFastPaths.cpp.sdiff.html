<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserFastPaths.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  47 static inline bool isSimpleLengthPropertyID(CSSPropertyID propertyId, bool&amp; acceptsNegativeNumbers)
  48 {
  49     switch (propertyId) {
  50     case CSSPropertyFontSize:
  51     case CSSPropertyHeight:
  52     case CSSPropertyWidth:
  53     case CSSPropertyMinHeight:
  54     case CSSPropertyMinWidth:
  55     case CSSPropertyPaddingBottom:
  56     case CSSPropertyPaddingLeft:
  57     case CSSPropertyPaddingRight:
  58     case CSSPropertyPaddingTop:
  59     case CSSPropertyInlineSize:
  60     case CSSPropertyBlockSize:
  61     case CSSPropertyMinInlineSize:
  62     case CSSPropertyMinBlockSize:
  63     case CSSPropertyPaddingBlockEnd:
  64     case CSSPropertyPaddingBlockStart:
  65     case CSSPropertyPaddingInlineEnd:
  66     case CSSPropertyPaddingInlineStart:



  67     case CSSPropertyShapeMargin:
  68         acceptsNegativeNumbers = false;
  69         return true;
  70     case CSSPropertyBottom:
  71     case CSSPropertyCx:
  72     case CSSPropertyCy:
  73     case CSSPropertyLeft:
  74     case CSSPropertyInsetBlockEnd:
  75     case CSSPropertyInsetBlockStart:
  76     case CSSPropertyInsetInlineEnd:
  77     case CSSPropertyInsetInlineStart:
  78     case CSSPropertyMarginBottom:
  79     case CSSPropertyMarginLeft:
  80     case CSSPropertyMarginRight:
  81     case CSSPropertyMarginTop:
  82     case CSSPropertyRight:
  83     case CSSPropertyTop:
  84     case CSSPropertyMarginBlockEnd:
  85     case CSSPropertyMarginBlockStart:
  86     case CSSPropertyMarginInlineEnd:
  87     case CSSPropertyMarginInlineStart:
  88     case CSSPropertyX:
  89     case CSSPropertyY:
<span class="line-removed">  90     case CSSPropertyR:</span>
<span class="line-removed">  91     case CSSPropertyRx:</span>
<span class="line-removed">  92     case CSSPropertyRy:</span>
  93         acceptsNegativeNumbers = true;
  94         return true;
  95     default:
  96         return false;
  97     }
  98 }
  99 
 100 template &lt;typename CharacterType&gt;
<span class="line-modified"> 101 static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)</span>
 102 {
 103     if (length &gt; 2 &amp;&amp; (characters[length - 2] | 0x20) == &#39;p&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;x&#39;) {
 104         length -= 2;
<span class="line-modified"> 105         unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
 106     } else if (length &gt; 1 &amp;&amp; characters[length - 1] == &#39;%&#39;) {
 107         length -= 1;
<span class="line-modified"> 108         unit = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;</span>
 109     }
 110 
 111     // We rely on charactersToDouble for validation as well. The function
 112     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 113     // not represent a double.
 114     bool ok;
 115     number = charactersToDouble(characters, length, &amp;ok);
 116     if (!ok)
 117         return false;
 118     return true;
 119 }
 120 
 121 template &lt;typename CharacterType&gt;
<span class="line-modified"> 122 static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)</span>
 123 {
 124     // Just support deg and rad for now.
 125     if (length &lt; 4)
 126         return false;
 127 
 128     if ((characters[length - 3] | 0x20) == &#39;d&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;e&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;g&#39;) {
 129         length -= 3;
<span class="line-modified"> 130         unit = CSSPrimitiveValue::UnitType::CSS_DEG;</span>
 131     } else if ((characters[length - 3] | 0x20) == &#39;r&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;a&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;d&#39;) {
 132         length -= 3;
<span class="line-modified"> 133         unit = CSSPrimitiveValue::UnitType::CSS_RAD;</span>
 134     } else
 135         return false;
 136 
 137     // We rely on charactersToDouble for validation as well. The function
 138     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 139     // not represent a double.
 140     bool ok;
 141     number = charactersToDouble(characters, length, &amp;ok);
 142     if (!ok)
 143         return false;
 144     return true;
 145 }
 146 
 147 static RefPtr&lt;CSSValue&gt; parseSimpleLengthValue(CSSPropertyID propertyId, const String&amp; string, CSSParserMode cssParserMode)
 148 {
 149     ASSERT(!string.isEmpty());
 150     bool acceptsNegativeNumbers = false;
 151 
 152     // In @viewport, width and height are shorthands, not simple length values.
 153     if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
 154         return nullptr;
 155 
 156     unsigned length = string.length();
 157     double number;
<span class="line-modified"> 158     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
 159 
 160     if (string.is8Bit()) {
 161         if (!parseSimpleLength(string.characters8(), length, unit, number))
 162             return nullptr;
 163     } else {
 164         if (!parseSimpleLength(string.characters16(), length, unit, number))
 165             return nullptr;
 166     }
 167 
<span class="line-modified"> 168     if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER) {</span>
 169         if (number &amp;&amp; cssParserMode != SVGAttributeMode)
 170             return nullptr;
<span class="line-modified"> 171         unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
 172     }
 173 
 174     if (number &lt; 0 &amp;&amp; !acceptsNegativeNumbers)
 175         return nullptr;
 176     if (std::isinf(number))
 177         return nullptr;
 178 
 179     return CSSPrimitiveValue::create(number, unit);
 180 }
 181 
 182 static inline bool isColorPropertyID(CSSPropertyID propertyId)
 183 {
 184     switch (propertyId) {
 185     case CSSPropertyColor:
 186     case CSSPropertyBackgroundColor:
 187     case CSSPropertyBorderBottomColor:
 188     case CSSPropertyBorderLeftColor:
 189     case CSSPropertyBorderRightColor:
 190     case CSSPropertyBorderTopColor:
 191     case CSSPropertyFill:
</pre>
<hr />
<pre>
 263 
 264     if (++position == length) {
 265         value = localValue;
 266         return length;
 267     }
 268 
 269     double fraction = 0;
 270     double scale = 1;
 271 
 272     const double maxScale = 1000000;
 273     while (position &lt; length &amp;&amp; scale &lt; maxScale) {
 274         fraction = fraction * 10 + string[position++] - &#39;0&#39;;
 275         scale *= 10;
 276     }
 277 
 278     value = localValue + fraction / scale;
 279     return length;
 280 }
 281 
 282 template &lt;typename CharacterType&gt;
<span class="line-modified"> 283 static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSPrimitiveValue::UnitType&amp; expect, int&amp; value)</span>
 284 {
 285     const CharacterType* current = string;
 286     double localValue = 0;
 287     bool negative = false;
 288     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 289         current++;
 290     if (current != end &amp;&amp; *current == &#39;-&#39;) {
 291         negative = true;
 292         current++;
 293     }
 294     if (current == end || !isASCIIDigit(*current))
 295         return false;
 296     while (current != end &amp;&amp; isASCIIDigit(*current)) {
 297         double newValue = localValue * 10 + *current++ - &#39;0&#39;;
 298         if (newValue &gt;= 255) {
 299             // Clamp values at 255.
 300             localValue = 255;
 301             while (current != end &amp;&amp; isASCIIDigit(*current))
 302                 ++current;
 303             break;
 304         }
 305         localValue = newValue;
 306     }
 307 
 308     if (current == end)
 309         return false;
 310 
<span class="line-modified"> 311     if (expect == CSSPrimitiveValue::UnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))</span>
 312         return false;
 313 
 314     if (*current == &#39;.&#39;) {
 315         // We already parsed the integral part, try to parse
 316         // the fraction part of the percentage value.
 317         double percentage = 0;
 318         int numCharactersParsed = parseDouble(current, end, &#39;%&#39;, percentage);
 319         if (!numCharactersParsed)
 320             return false;
 321         current += numCharactersParsed;
 322         if (*current != &#39;%&#39;)
 323             return false;
 324         localValue += percentage;
 325     }
 326 
<span class="line-modified"> 327     if (expect == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)</span>
 328         return false;
 329 
 330     if (*current == &#39;%&#39;) {
<span class="line-modified"> 331         expect = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;</span>
<span class="line-modified"> 332         localValue = localValue / 100.0 * 256.0;</span>
 333         // Clamp values at 255 for percentages over 100%
 334         if (localValue &gt; 255)
 335             localValue = 255;
 336         current++;
 337     } else {
<span class="line-modified"> 338         expect = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
 339     }
 340 
 341     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 342         current++;
 343     if (current == end || *current++ != terminator)
 344         return false;
 345     // Clamp negative values at zero.
 346     value = negative ? 0 : static_cast&lt;int&gt;(localValue);
 347     string = current;
 348     return true;
 349 }
 350 
 351 template &lt;typename CharacterType&gt;
 352 static inline bool isTenthAlpha(const CharacterType* string, const int length)
 353 {
 354     // &quot;0.X&quot;
 355     if (length == 3 &amp;&amp; string[0] == &#39;0&#39; &amp;&amp; string[1] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[2]))
 356         return true;
 357 
 358     // &quot;.X&quot;
</pre>
<hr />
<pre>
 383 
 384     if (string[length - 1] != terminator || !isASCIIDigit(string[length - 2]))
 385         return false;
 386 
 387     if (string[0] != &#39;0&#39; &amp;&amp; string[0] != &#39;1&#39; &amp;&amp; string[0] != &#39;.&#39;) {
 388         if (checkForValidDouble(string, end, terminator)) {
 389             value = negative ? 0 : 255;
 390             string = end;
 391             return true;
 392         }
 393         return false;
 394     }
 395 
 396     if (length == 2 &amp;&amp; string[0] != &#39;.&#39;) {
 397         value = !negative &amp;&amp; string[0] == &#39;1&#39; ? 255 : 0;
 398         string = end;
 399         return true;
 400     }
 401 
 402     if (isTenthAlpha(string, length - 1)) {
<span class="line-modified"> 403         static const int tenthAlphaValues[] = { 0, 25, 51, 76, 102, 127, 153, 179, 204, 230 };</span>
 404         value = negative ? 0 : tenthAlphaValues[string[length - 2] - &#39;0&#39;];
 405         string = end;
 406         return true;
 407     }
 408 
 409     double alpha = 0;
 410     if (!parseDouble(string, end, terminator, alpha))
 411         return false;
<span class="line-modified"> 412     value = negative ? 0 : static_cast&lt;int&gt;(alpha * nextafter(256.0, 0.0));</span>


 413     string = end;
 414     return true;
 415 }
 416 
 417 template &lt;typename CharacterType&gt;
 418 static inline bool mightBeRGBA(const CharacterType* characters, unsigned length)
 419 {
 420     if (length &lt; 5)
 421         return false;
 422     return characters[4] == &#39;(&#39;
 423         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 424         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 425         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;)
 426         &amp;&amp; isASCIIAlphaCaselessEqual(characters[3], &#39;a&#39;);
 427 }
 428 
 429 template &lt;typename CharacterType&gt;
 430 static inline bool mightBeRGB(const CharacterType* characters, unsigned length)
 431 {
 432     if (length &lt; 4)
 433         return false;
 434     return characters[3] == &#39;(&#39;
 435         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 436         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 437         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;);
 438 }
 439 
 440 template &lt;typename CharacterType&gt;
 441 static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
 442 {
<span class="line-modified"> 443     CSSPrimitiveValue::UnitType expect = CSSPrimitiveValue::UnitType::CSS_UNKNOWN;</span>
 444 
 445     if (length &gt;= 4 &amp;&amp; characters[0] == &#39;#&#39;) {
 446         RGBA32 rgb;
 447         if (Color::parseHexColor(characters + 1, length - 1, rgb))
 448             return Color(rgb);
 449     }
 450 
 451     if (quirksMode &amp;&amp; (length == 3 || length == 6)) {
 452         RGBA32 rgb;
 453         if (Color::parseHexColor(characters, length, rgb))
 454             return Color(rgb);
 455     }
 456 
 457     // Try rgba() syntax.
 458     if (mightBeRGBA(characters, length)) {
 459         const CharacterType* current = characters + 5;
 460         const CharacterType* end = characters + length;
 461         int red;
 462         int green;
 463         int blue;
</pre>
<hr />
<pre>
 480     if (mightBeRGB(characters, length)) {
 481         const CharacterType* current = characters + 4;
 482         const CharacterType* end = characters + length;
 483         int red;
 484         int green;
 485         int blue;
 486         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 487             return Color();
 488         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 489             return Color();
 490         if (!parseColorIntOrPercentage(current, end, &#39;)&#39;, expect, blue))
 491             return Color();
 492         if (current != end)
 493             return Color();
 494         return Color(makeRGB(red, green, blue));
 495     }
 496 
 497     return Color();
 498 }
 499 
<span class="line-modified"> 500 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode)</span>
 501 {
 502     ASSERT(!string.isEmpty());
 503     CSSValueID valueID = cssValueKeywordID(string);
 504     if (StyleColor::isColorKeyword(valueID)) {
 505         if (!isValueAllowedInMode(valueID, parserMode))
 506             return nullptr;
<span class="line-modified"> 507         return CSSValuePool::singleton().createIdentifierValue(valueID);</span>
 508     }
 509 
 510     bool quirksMode = isQuirksModeBehavior(parserMode);
 511 
 512     // Fast path for hex colors and rgb()/rgba() colors
 513     Color color;
 514     if (string.is8Bit())
 515         color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
 516     else
 517         color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
 518     if (!color.isValid())
 519         return nullptr;
<span class="line-modified"> 520     return CSSValuePool::singleton().createColorValue(color);</span>
 521 }
 522 
 523 bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, const CSSParserContext&amp; context)
 524 {
 525 #if !ENABLE(OVERFLOW_SCROLLING_TOUCH)
 526     UNUSED_PARAM(context);
 527 #endif
 528 
 529     if (valueID == CSSValueInvalid || !isValueAllowedInMode(valueID, context.mode))
 530         return false;
 531 
 532     switch (propertyId) {
 533     case CSSPropertyAlignmentBaseline:
 534         // auto | baseline | before-edge | text-before-edge | middle |
 535         // central | after-edge | text-after-edge | ideographic | alphabetic |
 536         // hanging | mathematical
 537         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueBaseline
 538             || valueID == CSSValueMiddle || (valueID &gt;= CSSValueBeforeEdge &amp;&amp; valueID &lt;= CSSValueMathematical);
 539     case CSSPropertyAll:
 540         return false; // Only accepts css-wide keywords
</pre>
<hr />
<pre>
 572     case CSSPropertyDirection: // ltr | rtl
 573         return valueID == CSSValueLtr || valueID == CSSValueRtl;
 574     case CSSPropertyDisplay:
 575         // inline | block | list-item | inline-block | table |
 576         // inline-table | table-row-group | table-header-group | table-footer-group | table-row |
 577         // table-column-group | table-column | table-cell | table-caption | -webkit-box | -webkit-inline-box | none
 578         // flex | inline-flex | -webkit-flex | -webkit-inline-flex | grid | inline-grid
 579         return (valueID &gt;= CSSValueInline &amp;&amp; valueID &lt;= CSSValueContents) || valueID == CSSValueNone
 580             || valueID == CSSValueGrid || valueID == CSSValueInlineGrid || valueID == CSSValueFlowRoot;
 581     case CSSPropertyDominantBaseline:
 582         // auto | use-script | no-change | reset-size | ideographic |
 583         // alphabetic | hanging | mathematical | central | middle |
 584         // text-after-edge | text-before-edge
 585         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueMiddle
 586             || (valueID &gt;= CSSValueUseScript &amp;&amp; valueID &lt;= CSSValueResetSize)
 587             || (valueID &gt;= CSSValueCentral &amp;&amp; valueID &lt;= CSSValueMathematical);
 588     case CSSPropertyEmptyCells: // show | hide
 589         return valueID == CSSValueShow || valueID == CSSValueHide;
 590     case CSSPropertyFloat: // left | right | none
 591         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;


 592     case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
 593         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
 594 #if ENABLE(CSS_COMPOSITING)
 595     case CSSPropertyIsolation: // auto | isolate
 596         return valueID == CSSValueAuto || valueID == CSSValueIsolate;
 597 #endif
 598     case CSSPropertyListStylePosition: // inside | outside
 599         return valueID == CSSValueInside || valueID == CSSValueOutside;
 600     case CSSPropertyListStyleType:
 601         // See section CSS_PROP_LIST_STYLE_TYPE of file CSSValueKeywords.in
 602         // for the list of supported list-style-types.
 603         return (valueID &gt;= CSSValueDisc &amp;&amp; valueID &lt;= CSSValueKatakanaIroha) || valueID == CSSValueNone;
 604     case CSSPropertyMaskType:
 605         return valueID == CSSValueLuminance || valueID == CSSValueAlpha;
 606     case CSSPropertyObjectFit:
 607         return valueID == CSSValueFill || valueID == CSSValueContain || valueID == CSSValueCover || valueID == CSSValueNone || valueID == CSSValueScaleDown;
 608     case CSSPropertyOutlineStyle: // (&lt;border-style&gt; except hidden) | auto
 609         return valueID == CSSValueAuto || valueID == CSSValueNone || (valueID &gt;= CSSValueInset &amp;&amp; valueID &lt;= CSSValueDouble);
 610     // FIXME-NEWPARSER: Support?
 611     // case CSSPropertyOverflowAnchor:
 612     //    return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAuto;
 613     case CSSPropertyOverflowWrap: // normal | break-word
 614     case CSSPropertyWordWrap:
 615         return valueID == CSSValueNormal || valueID == CSSValueBreakWord;
 616     case CSSPropertyOverflowX: // visible | hidden | scroll | auto | overlay (overlay is a synonym for auto)
 617         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay;
 618     case CSSPropertyOverflowY: // visible | hidden | scroll | auto | overlay | -webkit-paged-x | -webkit-paged-y (overlay is a synonym for auto)
 619         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay || valueID == CSSValueWebkitPagedX || valueID == CSSValueWebkitPagedY;
 620     case CSSPropertyBreakAfter:
 621     case CSSPropertyBreakBefore:
 622         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValuePage || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueRecto || valueID == CSSValueVerso || valueID == CSSValueAvoidColumn || valueID == CSSValueColumn;
 623     case CSSPropertyBreakInside:
 624         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
 625     case CSSPropertyPointerEvents:
 626         // none | visiblePainted | visibleFill | visibleStroke | visible |
 627         // painted | fill | stroke | auto | all | bounding-box
<span class="line-modified"> 628         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);</span>
 629     case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
 630         return valueID == CSSValueStatic
 631             || valueID == CSSValueRelative
 632             || valueID == CSSValueAbsolute
 633             || valueID == CSSValueFixed
 634             || valueID == CSSValueSticky || valueID == CSSValueWebkitSticky;
 635     case CSSPropertyResize: // none | both | horizontal | vertical | auto
 636         return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
<span class="line-removed"> 637     // FIXME-NEWPARSER: Investigate this property.</span>
<span class="line-removed"> 638     // case CSSPropertyScrollBehavior: // auto | smooth</span>
<span class="line-removed"> 639     //     ASSERT(RuntimeEnabledFeatures::cssomSmoothScrollEnabled());</span>
<span class="line-removed"> 640     //   return valueID == CSSValueAuto || valueID == CSSValueSmooth;</span>
 641     case CSSPropertyShapeRendering:
 642         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
 643     case CSSPropertyStrokeLinejoin:
 644         return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
 645     case CSSPropertyStrokeLinecap:
 646         return valueID == CSSValueButt || valueID == CSSValueRound || valueID == CSSValueSquare;
 647     case CSSPropertyTableLayout: // auto | fixed
 648         return valueID == CSSValueAuto || valueID == CSSValueFixed;
 649     case CSSPropertyTextAlign:
 650         return (valueID &gt;= CSSValueWebkitAuto &amp;&amp; valueID &lt;= CSSValueWebkitMatchParent) || valueID == CSSValueStart || valueID == CSSValueEnd;
 651 #if ENABLE(CSS3_TEXT)
 652     case CSSPropertyWebkitTextAlignLast:
 653         // auto | start | end | left | right | center | justify
 654         return (valueID &gt;= CSSValueLeft &amp;&amp; valueID &lt;= CSSValueJustify) || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueAuto;
 655 #endif
 656     case CSSPropertyTextAnchor:
 657         return valueID == CSSValueStart || valueID == CSSValueMiddle || valueID == CSSValueEnd;
 658 // FIXME-NEWPARSER: Support
 659 //    case CSSPropertyTextCombineUpright:
 660 //        return valueID == CSSValueNone || valueID == CSSValueAll;
</pre>
<hr />
<pre>
 838     case CSSPropertyBorderRightStyle:
 839     case CSSPropertyBorderTopStyle:
 840     case CSSPropertyBoxSizing:
 841     case CSSPropertyBreakAfter:
 842     case CSSPropertyBreakBefore:
 843     case CSSPropertyBreakInside:
 844     case CSSPropertyCaptionSide:
 845     case CSSPropertyClear:
 846     case CSSPropertyColumnFill:
 847     case CSSPropertyWebkitColumnProgression:
 848     case CSSPropertyColumnRuleStyle:
 849     case CSSPropertyDirection:
 850     case CSSPropertyDisplay:
 851     case CSSPropertyEmptyCells:
 852     case CSSPropertyFlexDirection:
 853     case CSSPropertyFlexWrap:
 854     case CSSPropertyFloat:
 855     case CSSPropertyFontVariantAlternates:
 856     case CSSPropertyFontVariantCaps:
 857     case CSSPropertyFontVariantPosition:

 858     case CSSPropertyImageRendering:
 859     case CSSPropertyListStylePosition:
 860     case CSSPropertyListStyleType:
 861     case CSSPropertyObjectFit:
 862     case CSSPropertyOutlineStyle:
 863     case CSSPropertyOverflowWrap:
 864     case CSSPropertyOverflowX:
 865     case CSSPropertyOverflowY:
 866     case CSSPropertyPointerEvents:
 867     case CSSPropertyPosition:
 868     case CSSPropertyResize:
 869     case CSSPropertyTableLayout:
 870     case CSSPropertyTextAlign:
 871     case CSSPropertyTextOverflow:
 872     case CSSPropertyTextRendering:
 873     case CSSPropertyTextTransform:
 874     case CSSPropertyTransformStyle:
 875     case CSSPropertyUnicodeBidi:
 876     case CSSPropertyVisibility:
 877     case CSSPropertyWebkitAppearance:
</pre>
<hr />
<pre>
 920     case CSSPropertyColorInterpolationFilters:
 921     case CSSPropertyColorRendering:
 922     case CSSPropertyDominantBaseline:
 923     case CSSPropertyFillRule:
 924     case CSSPropertyMaskType:
 925     case CSSPropertyShapeRendering:
 926     case CSSPropertyStrokeLinecap:
 927     case CSSPropertyStrokeLinejoin:
 928     case CSSPropertyTextAnchor:
 929     case CSSPropertyVectorEffect:
 930     case CSSPropertyWritingMode:
 931 
 932     // FIXME-NEWPARSER: Treat all as a keyword property.
 933     // case CSSPropertyAll:
 934 
 935     // FIXME-NEWPARSER: Add the following unprefixed properties:
 936     // case CSSPropertyBackfaceVisibility:
 937     // case CSSPropertyFontKerning:
 938     // case CSSPropertyHyphens:
 939     // case CSSPropertyOverflowAnchor:
<span class="line-removed"> 940     // case CSSPropertyScrollBehavior:</span>
 941     // case CSSPropertyScrollSnapType:
 942     // case CSSPropertyTextAlignLast:
 943     // case CSSPropertyTextCombineUpright:
 944     // case CSSPropertyTextDecorationStyle:
 945     // case CSSPropertyTextJustify:
 946     // case CSSPropertyTextOrientation:
 947     // case CSSPropertyUserSelect:
 948 #if ENABLE(CSS_TRAILING_WORD)
 949     case CSSPropertyAppleTrailingWord:
 950 #endif
 951 #if ENABLE(CSS_COMPOSITING)
 952     case CSSPropertyIsolation:
 953     case CSSPropertyMixBlendMode:
 954 #endif
 955 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 956     case CSSPropertyWebkitBoxDecorationBreak:
 957 #endif
 958 #if ENABLE(CURSOR_VISIBILITY)
 959     case CSSPropertyWebkitCursorVisibility:
 960 #endif
</pre>
<hr />
<pre>
1020     if (valueID == CSSValueInitial)
1021         return CSSValuePool::singleton().createExplicitInitialValue();
1022     if (valueID == CSSValueUnset)
1023         return CSSValuePool::singleton().createUnsetValue();
1024     if (valueID == CSSValueRevert)
1025         return CSSValuePool::singleton().createRevertValue();
1026 
1027     if (CSSParserFastPaths::isValidKeywordPropertyAndValue(propertyId, valueID, context))
1028         return CSSPrimitiveValue::createIdentifier(valueID);
1029     return nullptr;
1030 }
1031 
1032 template &lt;typename CharType&gt;
1033 static bool parseTransformTranslateArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1034 {
1035     while (expectedCount) {
1036         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1037         if (delimiter == notFound)
1038             return false;
1039         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="line-modified">1040         CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
1041         double number;
1042         if (!parseSimpleLength(pos, argumentLength, unit, number))
1043             return false;
<span class="line-modified">1044         if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)</span>
<span class="line-modified">1045             unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
<span class="line-modified">1046         if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER || (unit == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))</span>
1047             return false;
1048         transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1049         pos += argumentLength + 1;
1050         --expectedCount;
1051     }
1052     return true;
1053 }
1054 
1055 template &lt;typename CharType&gt;
1056 static bool parseTransformAngleArgument(CharType*&amp; pos, CharType* end, CSSFunctionValue* transformValue)
1057 {
1058     size_t delimiter = WTF::find(pos, end - pos, &#39;)&#39;);
1059     if (delimiter == notFound)
1060         return false;
1061 
1062     unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="line-modified">1063     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
1064     double number;
1065     if (!parseSimpleAngle(pos, argumentLength, unit, number))
1066         return false;
<span class="line-modified">1067     if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)</span>
<span class="line-modified">1068         unit = CSSPrimitiveValue::UnitType::CSS_DEG;</span>
1069 
1070     transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1071     pos += argumentLength + 1;
1072 
1073     return true;
1074 }
1075 
1076 template &lt;typename CharType&gt;
1077 static bool parseTransformNumberArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1078 {
1079     while (expectedCount) {
1080         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1081         if (delimiter == notFound)
1082             return false;
1083         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1084         bool ok;
1085         double number = charactersToDouble(pos, argumentLength, &amp;ok);
1086         if (!ok)
1087             return false;
<span class="line-modified">1088         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSPrimitiveValue::UnitType::CSS_NUMBER));</span>
1089         pos += argumentLength + 1;
1090         --expectedCount;
1091     }
1092     return true;
1093 }
1094 
1095 static const int kShortestValidTransformStringLength = 9; // &quot;rotate(0)&quot;
1096 
1097 template &lt;typename CharType&gt;
1098 static RefPtr&lt;CSSFunctionValue&gt; parseSimpleTransformValue(CharType*&amp; pos, CharType* end)
1099 {
1100     if (end - pos &lt; kShortestValidTransformStringLength)
1101         return nullptr;
1102 
1103     const bool isTranslate = toASCIILower(pos[0]) == &#39;t&#39;
1104         &amp;&amp; toASCIILower(pos[1]) == &#39;r&#39;
1105         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1106         &amp;&amp; toASCIILower(pos[3]) == &#39;n&#39;
1107         &amp;&amp; toASCIILower(pos[4]) == &#39;s&#39;
1108         &amp;&amp; toASCIILower(pos[5]) == &#39;l&#39;
</pre>
<hr />
<pre>
1283     }
1284     return transformList;
1285 }
1286 
1287 static RefPtr&lt;CSSValue&gt; parseSimpleTransform(CSSPropertyID propertyID, const String&amp; string)
1288 {
1289     ASSERT(!string.isEmpty());
1290     if (propertyID != CSSPropertyTransform)
1291         return nullptr;
1292     if (string.is8Bit())
1293         return parseSimpleTransformList(string.characters8(), string.length());
1294     return parseSimpleTransformList(string.characters16(), string.length());
1295 }
1296 
1297 static RefPtr&lt;CSSValue&gt; parseCaretColor(const String&amp; string, CSSParserMode parserMode)
1298 {
1299     ASSERT(!string.isEmpty());
1300     CSSValueID valueID = cssValueKeywordID(string);
1301     if (valueID == CSSValueAuto)
1302         return CSSValuePool::singleton().createIdentifierValue(valueID);
<span class="line-modified">1303     return CSSParserFastPaths::parseColor(string, parserMode);</span>
1304 }
1305 
1306 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
1307 {
1308     if (auto result = parseSimpleLengthValue(propertyID, string, context.mode))
1309         return result;
1310     if (propertyID == CSSPropertyCaretColor)
1311         return parseCaretColor(string, context.mode);
1312     if (isColorPropertyID(propertyID))
<span class="line-modified">1313         return parseColor(string, context.mode);</span>
1314     if (auto result = parseKeywordValue(propertyID, string, context))
1315         return result;
1316     return parseSimpleTransform(propertyID, string);
1317 }
1318 
1319 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  47 static inline bool isSimpleLengthPropertyID(CSSPropertyID propertyId, bool&amp; acceptsNegativeNumbers)
  48 {
  49     switch (propertyId) {
  50     case CSSPropertyFontSize:
  51     case CSSPropertyHeight:
  52     case CSSPropertyWidth:
  53     case CSSPropertyMinHeight:
  54     case CSSPropertyMinWidth:
  55     case CSSPropertyPaddingBottom:
  56     case CSSPropertyPaddingLeft:
  57     case CSSPropertyPaddingRight:
  58     case CSSPropertyPaddingTop:
  59     case CSSPropertyInlineSize:
  60     case CSSPropertyBlockSize:
  61     case CSSPropertyMinInlineSize:
  62     case CSSPropertyMinBlockSize:
  63     case CSSPropertyPaddingBlockEnd:
  64     case CSSPropertyPaddingBlockStart:
  65     case CSSPropertyPaddingInlineEnd:
  66     case CSSPropertyPaddingInlineStart:
<span class="line-added">  67     case CSSPropertyR:</span>
<span class="line-added">  68     case CSSPropertyRx:</span>
<span class="line-added">  69     case CSSPropertyRy:</span>
  70     case CSSPropertyShapeMargin:
  71         acceptsNegativeNumbers = false;
  72         return true;
  73     case CSSPropertyBottom:
  74     case CSSPropertyCx:
  75     case CSSPropertyCy:
  76     case CSSPropertyLeft:
  77     case CSSPropertyInsetBlockEnd:
  78     case CSSPropertyInsetBlockStart:
  79     case CSSPropertyInsetInlineEnd:
  80     case CSSPropertyInsetInlineStart:
  81     case CSSPropertyMarginBottom:
  82     case CSSPropertyMarginLeft:
  83     case CSSPropertyMarginRight:
  84     case CSSPropertyMarginTop:
  85     case CSSPropertyRight:
  86     case CSSPropertyTop:
  87     case CSSPropertyMarginBlockEnd:
  88     case CSSPropertyMarginBlockStart:
  89     case CSSPropertyMarginInlineEnd:
  90     case CSSPropertyMarginInlineStart:
  91     case CSSPropertyX:
  92     case CSSPropertyY:



  93         acceptsNegativeNumbers = true;
  94         return true;
  95     default:
  96         return false;
  97     }
  98 }
  99 
 100 template &lt;typename CharacterType&gt;
<span class="line-modified"> 101 static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)</span>
 102 {
 103     if (length &gt; 2 &amp;&amp; (characters[length - 2] | 0x20) == &#39;p&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;x&#39;) {
 104         length -= 2;
<span class="line-modified"> 105         unit = CSSUnitType::CSS_PX;</span>
 106     } else if (length &gt; 1 &amp;&amp; characters[length - 1] == &#39;%&#39;) {
 107         length -= 1;
<span class="line-modified"> 108         unit = CSSUnitType::CSS_PERCENTAGE;</span>
 109     }
 110 
 111     // We rely on charactersToDouble for validation as well. The function
 112     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 113     // not represent a double.
 114     bool ok;
 115     number = charactersToDouble(characters, length, &amp;ok);
 116     if (!ok)
 117         return false;
 118     return true;
 119 }
 120 
 121 template &lt;typename CharacterType&gt;
<span class="line-modified"> 122 static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)</span>
 123 {
 124     // Just support deg and rad for now.
 125     if (length &lt; 4)
 126         return false;
 127 
 128     if ((characters[length - 3] | 0x20) == &#39;d&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;e&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;g&#39;) {
 129         length -= 3;
<span class="line-modified"> 130         unit = CSSUnitType::CSS_DEG;</span>
 131     } else if ((characters[length - 3] | 0x20) == &#39;r&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;a&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;d&#39;) {
 132         length -= 3;
<span class="line-modified"> 133         unit = CSSUnitType::CSS_RAD;</span>
 134     } else
 135         return false;
 136 
 137     // We rely on charactersToDouble for validation as well. The function
 138     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 139     // not represent a double.
 140     bool ok;
 141     number = charactersToDouble(characters, length, &amp;ok);
 142     if (!ok)
 143         return false;
 144     return true;
 145 }
 146 
 147 static RefPtr&lt;CSSValue&gt; parseSimpleLengthValue(CSSPropertyID propertyId, const String&amp; string, CSSParserMode cssParserMode)
 148 {
 149     ASSERT(!string.isEmpty());
 150     bool acceptsNegativeNumbers = false;
 151 
 152     // In @viewport, width and height are shorthands, not simple length values.
 153     if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
 154         return nullptr;
 155 
 156     unsigned length = string.length();
 157     double number;
<span class="line-modified"> 158     CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
 159 
 160     if (string.is8Bit()) {
 161         if (!parseSimpleLength(string.characters8(), length, unit, number))
 162             return nullptr;
 163     } else {
 164         if (!parseSimpleLength(string.characters16(), length, unit, number))
 165             return nullptr;
 166     }
 167 
<span class="line-modified"> 168     if (unit == CSSUnitType::CSS_NUMBER) {</span>
 169         if (number &amp;&amp; cssParserMode != SVGAttributeMode)
 170             return nullptr;
<span class="line-modified"> 171         unit = CSSUnitType::CSS_PX;</span>
 172     }
 173 
 174     if (number &lt; 0 &amp;&amp; !acceptsNegativeNumbers)
 175         return nullptr;
 176     if (std::isinf(number))
 177         return nullptr;
 178 
 179     return CSSPrimitiveValue::create(number, unit);
 180 }
 181 
 182 static inline bool isColorPropertyID(CSSPropertyID propertyId)
 183 {
 184     switch (propertyId) {
 185     case CSSPropertyColor:
 186     case CSSPropertyBackgroundColor:
 187     case CSSPropertyBorderBottomColor:
 188     case CSSPropertyBorderLeftColor:
 189     case CSSPropertyBorderRightColor:
 190     case CSSPropertyBorderTopColor:
 191     case CSSPropertyFill:
</pre>
<hr />
<pre>
 263 
 264     if (++position == length) {
 265         value = localValue;
 266         return length;
 267     }
 268 
 269     double fraction = 0;
 270     double scale = 1;
 271 
 272     const double maxScale = 1000000;
 273     while (position &lt; length &amp;&amp; scale &lt; maxScale) {
 274         fraction = fraction * 10 + string[position++] - &#39;0&#39;;
 275         scale *= 10;
 276     }
 277 
 278     value = localValue + fraction / scale;
 279     return length;
 280 }
 281 
 282 template &lt;typename CharacterType&gt;
<span class="line-modified"> 283 static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSUnitType&amp; expect, int&amp; value)</span>
 284 {
 285     const CharacterType* current = string;
 286     double localValue = 0;
 287     bool negative = false;
 288     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 289         current++;
 290     if (current != end &amp;&amp; *current == &#39;-&#39;) {
 291         negative = true;
 292         current++;
 293     }
 294     if (current == end || !isASCIIDigit(*current))
 295         return false;
 296     while (current != end &amp;&amp; isASCIIDigit(*current)) {
 297         double newValue = localValue * 10 + *current++ - &#39;0&#39;;
 298         if (newValue &gt;= 255) {
 299             // Clamp values at 255.
 300             localValue = 255;
 301             while (current != end &amp;&amp; isASCIIDigit(*current))
 302                 ++current;
 303             break;
 304         }
 305         localValue = newValue;
 306     }
 307 
 308     if (current == end)
 309         return false;
 310 
<span class="line-modified"> 311     if (expect == CSSUnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))</span>
 312         return false;
 313 
 314     if (*current == &#39;.&#39;) {
 315         // We already parsed the integral part, try to parse
 316         // the fraction part of the percentage value.
 317         double percentage = 0;
 318         int numCharactersParsed = parseDouble(current, end, &#39;%&#39;, percentage);
 319         if (!numCharactersParsed)
 320             return false;
 321         current += numCharactersParsed;
 322         if (*current != &#39;%&#39;)
 323             return false;
 324         localValue += percentage;
 325     }
 326 
<span class="line-modified"> 327     if (expect == CSSUnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)</span>
 328         return false;
 329 
 330     if (*current == &#39;%&#39;) {
<span class="line-modified"> 331         expect = CSSUnitType::CSS_PERCENTAGE;</span>
<span class="line-modified"> 332         localValue = localValue / 100.0 * 255.0;</span>
 333         // Clamp values at 255 for percentages over 100%
 334         if (localValue &gt; 255)
 335             localValue = 255;
 336         current++;
 337     } else {
<span class="line-modified"> 338         expect = CSSUnitType::CSS_NUMBER;</span>
 339     }
 340 
 341     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 342         current++;
 343     if (current == end || *current++ != terminator)
 344         return false;
 345     // Clamp negative values at zero.
 346     value = negative ? 0 : static_cast&lt;int&gt;(localValue);
 347     string = current;
 348     return true;
 349 }
 350 
 351 template &lt;typename CharacterType&gt;
 352 static inline bool isTenthAlpha(const CharacterType* string, const int length)
 353 {
 354     // &quot;0.X&quot;
 355     if (length == 3 &amp;&amp; string[0] == &#39;0&#39; &amp;&amp; string[1] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[2]))
 356         return true;
 357 
 358     // &quot;.X&quot;
</pre>
<hr />
<pre>
 383 
 384     if (string[length - 1] != terminator || !isASCIIDigit(string[length - 2]))
 385         return false;
 386 
 387     if (string[0] != &#39;0&#39; &amp;&amp; string[0] != &#39;1&#39; &amp;&amp; string[0] != &#39;.&#39;) {
 388         if (checkForValidDouble(string, end, terminator)) {
 389             value = negative ? 0 : 255;
 390             string = end;
 391             return true;
 392         }
 393         return false;
 394     }
 395 
 396     if (length == 2 &amp;&amp; string[0] != &#39;.&#39;) {
 397         value = !negative &amp;&amp; string[0] == &#39;1&#39; ? 255 : 0;
 398         string = end;
 399         return true;
 400     }
 401 
 402     if (isTenthAlpha(string, length - 1)) {
<span class="line-modified"> 403         static const int tenthAlphaValues[] = { 0, 26, 51, 77, 102, 128, 153, 179, 204, 230 };</span>
 404         value = negative ? 0 : tenthAlphaValues[string[length - 2] - &#39;0&#39;];
 405         string = end;
 406         return true;
 407     }
 408 
 409     double alpha = 0;
 410     if (!parseDouble(string, end, terminator, alpha))
 411         return false;
<span class="line-modified"> 412 </span>
<span class="line-added"> 413     // W3 standard stipulates a 2.55 alpha value multiplication factor.</span>
<span class="line-added"> 414     value = negative ? 0 : static_cast&lt;int&gt;(lroundf(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * 255.0f));</span>
 415     string = end;
 416     return true;
 417 }
 418 
 419 template &lt;typename CharacterType&gt;
 420 static inline bool mightBeRGBA(const CharacterType* characters, unsigned length)
 421 {
 422     if (length &lt; 5)
 423         return false;
 424     return characters[4] == &#39;(&#39;
 425         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 426         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 427         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;)
 428         &amp;&amp; isASCIIAlphaCaselessEqual(characters[3], &#39;a&#39;);
 429 }
 430 
 431 template &lt;typename CharacterType&gt;
 432 static inline bool mightBeRGB(const CharacterType* characters, unsigned length)
 433 {
 434     if (length &lt; 4)
 435         return false;
 436     return characters[3] == &#39;(&#39;
 437         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 438         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 439         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;);
 440 }
 441 
 442 template &lt;typename CharacterType&gt;
 443 static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
 444 {
<span class="line-modified"> 445     CSSUnitType expect = CSSUnitType::CSS_UNKNOWN;</span>
 446 
 447     if (length &gt;= 4 &amp;&amp; characters[0] == &#39;#&#39;) {
 448         RGBA32 rgb;
 449         if (Color::parseHexColor(characters + 1, length - 1, rgb))
 450             return Color(rgb);
 451     }
 452 
 453     if (quirksMode &amp;&amp; (length == 3 || length == 6)) {
 454         RGBA32 rgb;
 455         if (Color::parseHexColor(characters, length, rgb))
 456             return Color(rgb);
 457     }
 458 
 459     // Try rgba() syntax.
 460     if (mightBeRGBA(characters, length)) {
 461         const CharacterType* current = characters + 5;
 462         const CharacterType* end = characters + length;
 463         int red;
 464         int green;
 465         int blue;
</pre>
<hr />
<pre>
 482     if (mightBeRGB(characters, length)) {
 483         const CharacterType* current = characters + 4;
 484         const CharacterType* end = characters + length;
 485         int red;
 486         int green;
 487         int blue;
 488         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 489             return Color();
 490         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 491             return Color();
 492         if (!parseColorIntOrPercentage(current, end, &#39;)&#39;, expect, blue))
 493             return Color();
 494         if (current != end)
 495             return Color();
 496         return Color(makeRGB(red, green, blue));
 497     }
 498 
 499     return Color();
 500 }
 501 
<span class="line-modified"> 502 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode, CSSValuePool&amp; valuePool)</span>
 503 {
 504     ASSERT(!string.isEmpty());
 505     CSSValueID valueID = cssValueKeywordID(string);
 506     if (StyleColor::isColorKeyword(valueID)) {
 507         if (!isValueAllowedInMode(valueID, parserMode))
 508             return nullptr;
<span class="line-modified"> 509         return valuePool.createIdentifierValue(valueID);</span>
 510     }
 511 
 512     bool quirksMode = isQuirksModeBehavior(parserMode);
 513 
 514     // Fast path for hex colors and rgb()/rgba() colors
 515     Color color;
 516     if (string.is8Bit())
 517         color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
 518     else
 519         color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
 520     if (!color.isValid())
 521         return nullptr;
<span class="line-modified"> 522     return valuePool.createColorValue(color);</span>
 523 }
 524 
 525 bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, const CSSParserContext&amp; context)
 526 {
 527 #if !ENABLE(OVERFLOW_SCROLLING_TOUCH)
 528     UNUSED_PARAM(context);
 529 #endif
 530 
 531     if (valueID == CSSValueInvalid || !isValueAllowedInMode(valueID, context.mode))
 532         return false;
 533 
 534     switch (propertyId) {
 535     case CSSPropertyAlignmentBaseline:
 536         // auto | baseline | before-edge | text-before-edge | middle |
 537         // central | after-edge | text-after-edge | ideographic | alphabetic |
 538         // hanging | mathematical
 539         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueBaseline
 540             || valueID == CSSValueMiddle || (valueID &gt;= CSSValueBeforeEdge &amp;&amp; valueID &lt;= CSSValueMathematical);
 541     case CSSPropertyAll:
 542         return false; // Only accepts css-wide keywords
</pre>
<hr />
<pre>
 574     case CSSPropertyDirection: // ltr | rtl
 575         return valueID == CSSValueLtr || valueID == CSSValueRtl;
 576     case CSSPropertyDisplay:
 577         // inline | block | list-item | inline-block | table |
 578         // inline-table | table-row-group | table-header-group | table-footer-group | table-row |
 579         // table-column-group | table-column | table-cell | table-caption | -webkit-box | -webkit-inline-box | none
 580         // flex | inline-flex | -webkit-flex | -webkit-inline-flex | grid | inline-grid
 581         return (valueID &gt;= CSSValueInline &amp;&amp; valueID &lt;= CSSValueContents) || valueID == CSSValueNone
 582             || valueID == CSSValueGrid || valueID == CSSValueInlineGrid || valueID == CSSValueFlowRoot;
 583     case CSSPropertyDominantBaseline:
 584         // auto | use-script | no-change | reset-size | ideographic |
 585         // alphabetic | hanging | mathematical | central | middle |
 586         // text-after-edge | text-before-edge
 587         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueMiddle
 588             || (valueID &gt;= CSSValueUseScript &amp;&amp; valueID &lt;= CSSValueResetSize)
 589             || (valueID &gt;= CSSValueCentral &amp;&amp; valueID &lt;= CSSValueMathematical);
 590     case CSSPropertyEmptyCells: // show | hide
 591         return valueID == CSSValueShow || valueID == CSSValueHide;
 592     case CSSPropertyFloat: // left | right | none
 593         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;
<span class="line-added"> 594     case CSSPropertyImageOrientation: // from-image | none</span>
<span class="line-added"> 595         return valueID == CSSValueFromImage || valueID == CSSValueNone;</span>
 596     case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
 597         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
 598 #if ENABLE(CSS_COMPOSITING)
 599     case CSSPropertyIsolation: // auto | isolate
 600         return valueID == CSSValueAuto || valueID == CSSValueIsolate;
 601 #endif
 602     case CSSPropertyListStylePosition: // inside | outside
 603         return valueID == CSSValueInside || valueID == CSSValueOutside;
 604     case CSSPropertyListStyleType:
 605         // See section CSS_PROP_LIST_STYLE_TYPE of file CSSValueKeywords.in
 606         // for the list of supported list-style-types.
 607         return (valueID &gt;= CSSValueDisc &amp;&amp; valueID &lt;= CSSValueKatakanaIroha) || valueID == CSSValueNone;
 608     case CSSPropertyMaskType:
 609         return valueID == CSSValueLuminance || valueID == CSSValueAlpha;
 610     case CSSPropertyObjectFit:
 611         return valueID == CSSValueFill || valueID == CSSValueContain || valueID == CSSValueCover || valueID == CSSValueNone || valueID == CSSValueScaleDown;
 612     case CSSPropertyOutlineStyle: // (&lt;border-style&gt; except hidden) | auto
 613         return valueID == CSSValueAuto || valueID == CSSValueNone || (valueID &gt;= CSSValueInset &amp;&amp; valueID &lt;= CSSValueDouble);
 614     // FIXME-NEWPARSER: Support?
 615     // case CSSPropertyOverflowAnchor:
 616     //    return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAuto;
 617     case CSSPropertyOverflowWrap: // normal | break-word
 618     case CSSPropertyWordWrap:
 619         return valueID == CSSValueNormal || valueID == CSSValueBreakWord;
 620     case CSSPropertyOverflowX: // visible | hidden | scroll | auto | overlay (overlay is a synonym for auto)
 621         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay;
 622     case CSSPropertyOverflowY: // visible | hidden | scroll | auto | overlay | -webkit-paged-x | -webkit-paged-y (overlay is a synonym for auto)
 623         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay || valueID == CSSValueWebkitPagedX || valueID == CSSValueWebkitPagedY;
 624     case CSSPropertyBreakAfter:
 625     case CSSPropertyBreakBefore:
 626         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValuePage || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueRecto || valueID == CSSValueVerso || valueID == CSSValueAvoidColumn || valueID == CSSValueColumn;
 627     case CSSPropertyBreakInside:
 628         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
 629     case CSSPropertyPointerEvents:
 630         // none | visiblePainted | visibleFill | visibleStroke | visible |
 631         // painted | fill | stroke | auto | all | bounding-box
<span class="line-modified"> 632         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || valueID == CSSValueBoundingBox || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);</span>
 633     case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
 634         return valueID == CSSValueStatic
 635             || valueID == CSSValueRelative
 636             || valueID == CSSValueAbsolute
 637             || valueID == CSSValueFixed
 638             || valueID == CSSValueSticky || valueID == CSSValueWebkitSticky;
 639     case CSSPropertyResize: // none | both | horizontal | vertical | auto
 640         return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;




 641     case CSSPropertyShapeRendering:
 642         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
 643     case CSSPropertyStrokeLinejoin:
 644         return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
 645     case CSSPropertyStrokeLinecap:
 646         return valueID == CSSValueButt || valueID == CSSValueRound || valueID == CSSValueSquare;
 647     case CSSPropertyTableLayout: // auto | fixed
 648         return valueID == CSSValueAuto || valueID == CSSValueFixed;
 649     case CSSPropertyTextAlign:
 650         return (valueID &gt;= CSSValueWebkitAuto &amp;&amp; valueID &lt;= CSSValueWebkitMatchParent) || valueID == CSSValueStart || valueID == CSSValueEnd;
 651 #if ENABLE(CSS3_TEXT)
 652     case CSSPropertyWebkitTextAlignLast:
 653         // auto | start | end | left | right | center | justify
 654         return (valueID &gt;= CSSValueLeft &amp;&amp; valueID &lt;= CSSValueJustify) || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueAuto;
 655 #endif
 656     case CSSPropertyTextAnchor:
 657         return valueID == CSSValueStart || valueID == CSSValueMiddle || valueID == CSSValueEnd;
 658 // FIXME-NEWPARSER: Support
 659 //    case CSSPropertyTextCombineUpright:
 660 //        return valueID == CSSValueNone || valueID == CSSValueAll;
</pre>
<hr />
<pre>
 838     case CSSPropertyBorderRightStyle:
 839     case CSSPropertyBorderTopStyle:
 840     case CSSPropertyBoxSizing:
 841     case CSSPropertyBreakAfter:
 842     case CSSPropertyBreakBefore:
 843     case CSSPropertyBreakInside:
 844     case CSSPropertyCaptionSide:
 845     case CSSPropertyClear:
 846     case CSSPropertyColumnFill:
 847     case CSSPropertyWebkitColumnProgression:
 848     case CSSPropertyColumnRuleStyle:
 849     case CSSPropertyDirection:
 850     case CSSPropertyDisplay:
 851     case CSSPropertyEmptyCells:
 852     case CSSPropertyFlexDirection:
 853     case CSSPropertyFlexWrap:
 854     case CSSPropertyFloat:
 855     case CSSPropertyFontVariantAlternates:
 856     case CSSPropertyFontVariantCaps:
 857     case CSSPropertyFontVariantPosition:
<span class="line-added"> 858     case CSSPropertyImageOrientation:</span>
 859     case CSSPropertyImageRendering:
 860     case CSSPropertyListStylePosition:
 861     case CSSPropertyListStyleType:
 862     case CSSPropertyObjectFit:
 863     case CSSPropertyOutlineStyle:
 864     case CSSPropertyOverflowWrap:
 865     case CSSPropertyOverflowX:
 866     case CSSPropertyOverflowY:
 867     case CSSPropertyPointerEvents:
 868     case CSSPropertyPosition:
 869     case CSSPropertyResize:
 870     case CSSPropertyTableLayout:
 871     case CSSPropertyTextAlign:
 872     case CSSPropertyTextOverflow:
 873     case CSSPropertyTextRendering:
 874     case CSSPropertyTextTransform:
 875     case CSSPropertyTransformStyle:
 876     case CSSPropertyUnicodeBidi:
 877     case CSSPropertyVisibility:
 878     case CSSPropertyWebkitAppearance:
</pre>
<hr />
<pre>
 921     case CSSPropertyColorInterpolationFilters:
 922     case CSSPropertyColorRendering:
 923     case CSSPropertyDominantBaseline:
 924     case CSSPropertyFillRule:
 925     case CSSPropertyMaskType:
 926     case CSSPropertyShapeRendering:
 927     case CSSPropertyStrokeLinecap:
 928     case CSSPropertyStrokeLinejoin:
 929     case CSSPropertyTextAnchor:
 930     case CSSPropertyVectorEffect:
 931     case CSSPropertyWritingMode:
 932 
 933     // FIXME-NEWPARSER: Treat all as a keyword property.
 934     // case CSSPropertyAll:
 935 
 936     // FIXME-NEWPARSER: Add the following unprefixed properties:
 937     // case CSSPropertyBackfaceVisibility:
 938     // case CSSPropertyFontKerning:
 939     // case CSSPropertyHyphens:
 940     // case CSSPropertyOverflowAnchor:

 941     // case CSSPropertyScrollSnapType:
 942     // case CSSPropertyTextAlignLast:
 943     // case CSSPropertyTextCombineUpright:
 944     // case CSSPropertyTextDecorationStyle:
 945     // case CSSPropertyTextJustify:
 946     // case CSSPropertyTextOrientation:
 947     // case CSSPropertyUserSelect:
 948 #if ENABLE(CSS_TRAILING_WORD)
 949     case CSSPropertyAppleTrailingWord:
 950 #endif
 951 #if ENABLE(CSS_COMPOSITING)
 952     case CSSPropertyIsolation:
 953     case CSSPropertyMixBlendMode:
 954 #endif
 955 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 956     case CSSPropertyWebkitBoxDecorationBreak:
 957 #endif
 958 #if ENABLE(CURSOR_VISIBILITY)
 959     case CSSPropertyWebkitCursorVisibility:
 960 #endif
</pre>
<hr />
<pre>
1020     if (valueID == CSSValueInitial)
1021         return CSSValuePool::singleton().createExplicitInitialValue();
1022     if (valueID == CSSValueUnset)
1023         return CSSValuePool::singleton().createUnsetValue();
1024     if (valueID == CSSValueRevert)
1025         return CSSValuePool::singleton().createRevertValue();
1026 
1027     if (CSSParserFastPaths::isValidKeywordPropertyAndValue(propertyId, valueID, context))
1028         return CSSPrimitiveValue::createIdentifier(valueID);
1029     return nullptr;
1030 }
1031 
1032 template &lt;typename CharType&gt;
1033 static bool parseTransformTranslateArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1034 {
1035     while (expectedCount) {
1036         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1037         if (delimiter == notFound)
1038             return false;
1039         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="line-modified">1040         CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
1041         double number;
1042         if (!parseSimpleLength(pos, argumentLength, unit, number))
1043             return false;
<span class="line-modified">1044         if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)</span>
<span class="line-modified">1045             unit = CSSUnitType::CSS_PX;</span>
<span class="line-modified">1046         if (unit == CSSUnitType::CSS_NUMBER || (unit == CSSUnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))</span>
1047             return false;
1048         transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1049         pos += argumentLength + 1;
1050         --expectedCount;
1051     }
1052     return true;
1053 }
1054 
1055 template &lt;typename CharType&gt;
1056 static bool parseTransformAngleArgument(CharType*&amp; pos, CharType* end, CSSFunctionValue* transformValue)
1057 {
1058     size_t delimiter = WTF::find(pos, end - pos, &#39;)&#39;);
1059     if (delimiter == notFound)
1060         return false;
1061 
1062     unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="line-modified">1063     CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
1064     double number;
1065     if (!parseSimpleAngle(pos, argumentLength, unit, number))
1066         return false;
<span class="line-modified">1067     if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)</span>
<span class="line-modified">1068         unit = CSSUnitType::CSS_DEG;</span>
1069 
1070     transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1071     pos += argumentLength + 1;
1072 
1073     return true;
1074 }
1075 
1076 template &lt;typename CharType&gt;
1077 static bool parseTransformNumberArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1078 {
1079     while (expectedCount) {
1080         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1081         if (delimiter == notFound)
1082             return false;
1083         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1084         bool ok;
1085         double number = charactersToDouble(pos, argumentLength, &amp;ok);
1086         if (!ok)
1087             return false;
<span class="line-modified">1088         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSUnitType::CSS_NUMBER));</span>
1089         pos += argumentLength + 1;
1090         --expectedCount;
1091     }
1092     return true;
1093 }
1094 
1095 static const int kShortestValidTransformStringLength = 9; // &quot;rotate(0)&quot;
1096 
1097 template &lt;typename CharType&gt;
1098 static RefPtr&lt;CSSFunctionValue&gt; parseSimpleTransformValue(CharType*&amp; pos, CharType* end)
1099 {
1100     if (end - pos &lt; kShortestValidTransformStringLength)
1101         return nullptr;
1102 
1103     const bool isTranslate = toASCIILower(pos[0]) == &#39;t&#39;
1104         &amp;&amp; toASCIILower(pos[1]) == &#39;r&#39;
1105         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1106         &amp;&amp; toASCIILower(pos[3]) == &#39;n&#39;
1107         &amp;&amp; toASCIILower(pos[4]) == &#39;s&#39;
1108         &amp;&amp; toASCIILower(pos[5]) == &#39;l&#39;
</pre>
<hr />
<pre>
1283     }
1284     return transformList;
1285 }
1286 
1287 static RefPtr&lt;CSSValue&gt; parseSimpleTransform(CSSPropertyID propertyID, const String&amp; string)
1288 {
1289     ASSERT(!string.isEmpty());
1290     if (propertyID != CSSPropertyTransform)
1291         return nullptr;
1292     if (string.is8Bit())
1293         return parseSimpleTransformList(string.characters8(), string.length());
1294     return parseSimpleTransformList(string.characters16(), string.length());
1295 }
1296 
1297 static RefPtr&lt;CSSValue&gt; parseCaretColor(const String&amp; string, CSSParserMode parserMode)
1298 {
1299     ASSERT(!string.isEmpty());
1300     CSSValueID valueID = cssValueKeywordID(string);
1301     if (valueID == CSSValueAuto)
1302         return CSSValuePool::singleton().createIdentifierValue(valueID);
<span class="line-modified">1303     return CSSParserFastPaths::parseColor(string, parserMode, CSSValuePool::singleton());</span>
1304 }
1305 
1306 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
1307 {
1308     if (auto result = parseSimpleLengthValue(propertyID, string, context.mode))
1309         return result;
1310     if (propertyID == CSSPropertyCaretColor)
1311         return parseCaretColor(string, context.mode);
1312     if (isColorPropertyID(propertyID))
<span class="line-modified">1313         return parseColor(string, context.mode, CSSValuePool::singleton());</span>
1314     if (auto result = parseKeywordValue(propertyID, string, context))
1315         return result;
1316     return parseSimpleTransform(propertyID, string);
1317 }
1318 
1319 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserFastPaths.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
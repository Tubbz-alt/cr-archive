<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGWatchpointCollectionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGWorklist.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 88             m_thread.m_plan = nullptr;
 89             m_thread.m_worklist.m_numberOfActiveThreads--;
 90         }
 91 
 92     private:
 93         ThreadBody&amp; m_thread;
 94     };
 95 
 96     WorkResult work() override
 97     {
 98         WorkScope workScope(*this);
 99 
100         LockHolder locker(m_data.m_rightToRun);
101         {
102             LockHolder locker(*m_worklist.m_lock);
103             if (m_plan-&gt;stage() == Plan::Cancelled)
104                 return WorkResult::Continue;
105             m_plan-&gt;notifyCompiling();
106         }
107 
<span class="line-modified">108         if (Options::verboseCompilationQueue())</span>
<span class="line-removed">109             dataLog(m_worklist, &quot;: Compiling &quot;, m_plan-&gt;key(), &quot; asynchronously\n&quot;);</span>
110 
111         // There&#39;s no way for the GC to be safepointing since we own rightToRun.
112         if (m_plan-&gt;vm()-&gt;heap.worldIsStopped()) {
<span class="line-modified">113             dataLog(&quot;Heap is stoped but here we are! (1)\n&quot;);</span>
114             RELEASE_ASSERT_NOT_REACHED();
115         }
116         m_plan-&gt;compileInThread(&amp;m_data);
117         if (m_plan-&gt;stage() != Plan::Cancelled) {
118             if (m_plan-&gt;vm()-&gt;heap.worldIsStopped()) {
119                 dataLog(&quot;Heap is stopped but here we are! (2)\n&quot;);
120                 RELEASE_ASSERT_NOT_REACHED();
121             }
122         }
123 
124         {
125             LockHolder locker(*m_worklist.m_lock);
126             if (m_plan-&gt;stage() == Plan::Cancelled)
127                 return WorkResult::Continue;
128 
129             m_plan-&gt;notifyReady();
130 
131             if (Options::verboseCompilationQueue()) {
132                 m_worklist.dump(locker, WTF::dataFile());
133                 dataLog(&quot;: Compiled &quot;, m_plan-&gt;key(), &quot; asynchronously\n&quot;);
134             }
135 
<span class="line-removed">136             m_worklist.m_readyPlans.append(m_plan);</span>
<span class="line-removed">137 </span>
138             RELEASE_ASSERT(!m_plan-&gt;vm()-&gt;heap.worldIsStopped());

139             m_worklist.m_planCompiled.notifyAll();
140         }
141 
142         return WorkResult::Continue;
143     }
144 
145     void threadDidStart() override
146     {
<span class="line-modified">147         if (Options::verboseCompilationQueue())</span>
<span class="line-removed">148             dataLog(m_worklist, &quot;: Thread started\n&quot;);</span>
149 
150         if (m_relativePriority)
151             Thread::current().changePriority(m_relativePriority);
152 
153         m_compilationScope = makeUnique&lt;CompilationScope&gt;();
154     }
155 
156     void threadIsStopping(const AbstractLocker&amp;) override
157     {
158         // We&#39;re holding the Worklist::m_lock, so we should be careful not to deadlock.
159 
<span class="line-modified">160         if (Options::verboseCompilationQueue())</span>
<span class="line-removed">161             dataLog(m_worklist, &quot;: Thread will stop\n&quot;);</span>
162 
163         ASSERT(!m_plan);
164 
165         m_compilationScope = nullptr;
166         m_plan = nullptr;
167     }
168 
169 private:
170     Worklist&amp; m_worklist;
171     ThreadData&amp; m_data;
172     int m_relativePriority;
173     std::unique_ptr&lt;CompilationScope&gt; m_compilationScope;
174     RefPtr&lt;Plan&gt; m_plan;
175 };
176 
177 static CString createWorklistName(CString&amp;&amp; tierName)
178 {
179 #if OS(LINUX)
180     return toCString(WTFMove(tierName), &quot;Worker&quot;);
181 #else
</pre>
<hr />
<pre>
320 
321 void Worklist::removeAllReadyPlansForVM(VM&amp; vm)
322 {
323     Vector&lt;RefPtr&lt;Plan&gt;, 8&gt; myReadyPlans;
324     removeAllReadyPlansForVM(vm, myReadyPlans);
325 }
326 
327 Worklist::State Worklist::completeAllReadyPlansForVM(VM&amp; vm, CompilationKey requestedKey)
328 {
329     DeferGC deferGC(vm.heap);
330     Vector&lt;RefPtr&lt;Plan&gt;, 8&gt; myReadyPlans;
331 
332     removeAllReadyPlansForVM(vm, myReadyPlans);
333 
334     State resultingState = NotKnown;
335 
336     while (!myReadyPlans.isEmpty()) {
337         RefPtr&lt;Plan&gt; plan = myReadyPlans.takeLast();
338         CompilationKey currentKey = plan-&gt;key();
339 
<span class="line-modified">340         if (Options::verboseCompilationQueue())</span>
<span class="line-removed">341             dataLog(*this, &quot;: Completing &quot;, currentKey, &quot;\n&quot;);</span>
342 
343         RELEASE_ASSERT(plan-&gt;stage() == Plan::Ready);
344 
345         plan-&gt;finalizeAndNotifyCallback();
346 
347         if (currentKey == requestedKey)
348             resultingState = Compiled;
349     }
350 
351     if (!!requestedKey &amp;&amp; resultingState == NotKnown) {
352         LockHolder locker(*m_lock);
353         if (m_plans.contains(requestedKey))
354             resultingState = Compiling;
355     }
356 
357     return resultingState;
358 }
359 
360 void Worklist::completeAllPlansForVM(VM&amp; vm)
361 {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 88             m_thread.m_plan = nullptr;
 89             m_thread.m_worklist.m_numberOfActiveThreads--;
 90         }
 91 
 92     private:
 93         ThreadBody&amp; m_thread;
 94     };
 95 
 96     WorkResult work() override
 97     {
 98         WorkScope workScope(*this);
 99 
100         LockHolder locker(m_data.m_rightToRun);
101         {
102             LockHolder locker(*m_worklist.m_lock);
103             if (m_plan-&gt;stage() == Plan::Cancelled)
104                 return WorkResult::Continue;
105             m_plan-&gt;notifyCompiling();
106         }
107 
<span class="line-modified">108         dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, &quot;: Compiling &quot;, m_plan-&gt;key(), &quot; asynchronously&quot;);</span>

109 
110         // There&#39;s no way for the GC to be safepointing since we own rightToRun.
111         if (m_plan-&gt;vm()-&gt;heap.worldIsStopped()) {
<span class="line-modified">112             dataLog(&quot;Heap is stopped but here we are! (1)\n&quot;);</span>
113             RELEASE_ASSERT_NOT_REACHED();
114         }
115         m_plan-&gt;compileInThread(&amp;m_data);
116         if (m_plan-&gt;stage() != Plan::Cancelled) {
117             if (m_plan-&gt;vm()-&gt;heap.worldIsStopped()) {
118                 dataLog(&quot;Heap is stopped but here we are! (2)\n&quot;);
119                 RELEASE_ASSERT_NOT_REACHED();
120             }
121         }
122 
123         {
124             LockHolder locker(*m_worklist.m_lock);
125             if (m_plan-&gt;stage() == Plan::Cancelled)
126                 return WorkResult::Continue;
127 
128             m_plan-&gt;notifyReady();
129 
130             if (Options::verboseCompilationQueue()) {
131                 m_worklist.dump(locker, WTF::dataFile());
132                 dataLog(&quot;: Compiled &quot;, m_plan-&gt;key(), &quot; asynchronously\n&quot;);
133             }
134 


135             RELEASE_ASSERT(!m_plan-&gt;vm()-&gt;heap.worldIsStopped());
<span class="line-added">136             m_worklist.m_readyPlans.append(WTFMove(m_plan));</span>
137             m_worklist.m_planCompiled.notifyAll();
138         }
139 
140         return WorkResult::Continue;
141     }
142 
143     void threadDidStart() override
144     {
<span class="line-modified">145         dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, &quot;: Thread started&quot;);</span>

146 
147         if (m_relativePriority)
148             Thread::current().changePriority(m_relativePriority);
149 
150         m_compilationScope = makeUnique&lt;CompilationScope&gt;();
151     }
152 
153     void threadIsStopping(const AbstractLocker&amp;) override
154     {
155         // We&#39;re holding the Worklist::m_lock, so we should be careful not to deadlock.
156 
<span class="line-modified">157         dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, &quot;: Thread will stop&quot;);</span>

158 
159         ASSERT(!m_plan);
160 
161         m_compilationScope = nullptr;
162         m_plan = nullptr;
163     }
164 
165 private:
166     Worklist&amp; m_worklist;
167     ThreadData&amp; m_data;
168     int m_relativePriority;
169     std::unique_ptr&lt;CompilationScope&gt; m_compilationScope;
170     RefPtr&lt;Plan&gt; m_plan;
171 };
172 
173 static CString createWorklistName(CString&amp;&amp; tierName)
174 {
175 #if OS(LINUX)
176     return toCString(WTFMove(tierName), &quot;Worker&quot;);
177 #else
</pre>
<hr />
<pre>
316 
317 void Worklist::removeAllReadyPlansForVM(VM&amp; vm)
318 {
319     Vector&lt;RefPtr&lt;Plan&gt;, 8&gt; myReadyPlans;
320     removeAllReadyPlansForVM(vm, myReadyPlans);
321 }
322 
323 Worklist::State Worklist::completeAllReadyPlansForVM(VM&amp; vm, CompilationKey requestedKey)
324 {
325     DeferGC deferGC(vm.heap);
326     Vector&lt;RefPtr&lt;Plan&gt;, 8&gt; myReadyPlans;
327 
328     removeAllReadyPlansForVM(vm, myReadyPlans);
329 
330     State resultingState = NotKnown;
331 
332     while (!myReadyPlans.isEmpty()) {
333         RefPtr&lt;Plan&gt; plan = myReadyPlans.takeLast();
334         CompilationKey currentKey = plan-&gt;key();
335 
<span class="line-modified">336         dataLogLnIf(Options::verboseCompilationQueue(), *this, &quot;: Completing &quot;, currentKey);</span>

337 
338         RELEASE_ASSERT(plan-&gt;stage() == Plan::Ready);
339 
340         plan-&gt;finalizeAndNotifyCallback();
341 
342         if (currentKey == requestedKey)
343             resultingState = Compiled;
344     }
345 
346     if (!!requestedKey &amp;&amp; resultingState == NotKnown) {
347         LockHolder locker(*m_lock);
348         if (m_plans.contains(requestedKey))
349             resultingState = Compiling;
350     }
351 
352     return resultingState;
353 }
354 
355 void Worklist::completeAllPlansForVM(VM&amp; vm)
356 {
</pre>
</td>
</tr>
</table>
<center><a href="DFGWatchpointCollectionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGWorklist.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
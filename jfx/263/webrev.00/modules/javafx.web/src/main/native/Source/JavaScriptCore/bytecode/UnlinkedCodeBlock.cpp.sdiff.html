<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SuperSampler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55 const ClassInfo UnlinkedCodeBlock::s_info = { &quot;UnlinkedCodeBlock&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedCodeBlock) };
 56 
 57 UnlinkedCodeBlock::UnlinkedCodeBlock(VM&amp; vm, Structure* structure, CodeType codeType, const ExecutableInfo&amp; info, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
 58     : Base(vm, structure)
 59     , m_usesEval(info.usesEval())
 60     , m_isStrictMode(info.isStrictMode())
 61     , m_isConstructor(info.isConstructor())
 62     , m_hasCapturedVariables(false)
 63     , m_isBuiltinFunction(info.isBuiltinFunction())
 64     , m_superBinding(static_cast&lt;unsigned&gt;(info.superBinding()))
 65     , m_scriptMode(static_cast&lt;unsigned&gt;(info.scriptMode()))
 66     , m_isArrowFunctionContext(info.isArrowFunctionContext())
 67     , m_isClassContext(info.isClassContext())
 68     , m_hasTailCalls(false)
 69     , m_constructorKind(static_cast&lt;unsigned&gt;(info.constructorKind()))
 70     , m_derivedContextType(static_cast&lt;unsigned&gt;(info.derivedContextType()))
 71     , m_evalContextType(static_cast&lt;unsigned&gt;(info.evalContextType()))
 72     , m_codeType(static_cast&lt;unsigned&gt;(codeType))
 73     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
 74     , m_age(0)

 75     , m_parseMode(info.parseMode())
 76     , m_codeGenerationMode(codeGenerationMode)
 77     , m_metadata(UnlinkedMetadataTable::create())
 78 {
<span class="line-removed"> 79     for (auto&amp; constantRegisterIndex : m_linkTimeConstants)</span>
<span class="line-removed"> 80         constantRegisterIndex = 0;</span>
 81     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(info.constructorKind()));
 82     ASSERT(m_codeType == static_cast&lt;unsigned&gt;(codeType));
 83     ASSERT(m_didOptimize == static_cast&lt;unsigned&gt;(MixedTriState));




 84 }
 85 
 86 void UnlinkedCodeBlock::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 87 {
 88     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
 89     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 90     Base::visitChildren(thisObject, visitor);
 91     auto locker = holdLock(thisObject-&gt;cellLock());
 92     if (visitor.isFirstVisit())
 93         thisObject-&gt;m_age = std::min&lt;unsigned&gt;(static_cast&lt;unsigned&gt;(thisObject-&gt;m_age) + 1, maxAge);
<span class="line-modified"> 94     for (FunctionExpressionVector::iterator ptr = thisObject-&gt;m_functionDecls.begin(), end = thisObject-&gt;m_functionDecls.end(); ptr != end; ++ptr)</span>
<span class="line-modified"> 95         visitor.append(*ptr);</span>
<span class="line-modified"> 96     for (FunctionExpressionVector::iterator ptr = thisObject-&gt;m_functionExprs.begin(), end = thisObject-&gt;m_functionExprs.end(); ptr != end; ++ptr)</span>
<span class="line-modified"> 97         visitor.append(*ptr);</span>
 98     visitor.appendValues(thisObject-&gt;m_constantRegisters.data(), thisObject-&gt;m_constantRegisters.size());
 99     size_t extraMemory = thisObject-&gt;m_metadata-&gt;sizeInBytes();
100     if (thisObject-&gt;m_instructions)
101         extraMemory += thisObject-&gt;m_instructions-&gt;sizeInBytes();
102     visitor.reportExtraMemoryVisited(extraMemory);
103 }
104 
105 size_t UnlinkedCodeBlock::estimatedSize(JSCell* cell, VM&amp; vm)
106 {
107     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
108     size_t extraSize = thisObject-&gt;m_metadata-&gt;sizeInBytes();
109     if (thisObject-&gt;m_instructions)
110         extraSize += thisObject-&gt;m_instructions-&gt;sizeInBytes();
111     return Base::estimatedSize(cell, vm) + extraSize;
112 }
113 
<span class="line-modified">114 int UnlinkedCodeBlock::lineNumberForBytecodeOffset(unsigned bytecodeOffset)</span>
115 {
<span class="line-modified">116     ASSERT(bytecodeOffset &lt; instructions().size());</span>
117     int divot { 0 };
118     int startOffset { 0 };
119     int endOffset { 0 };
120     unsigned line { 0 };
121     unsigned column { 0 };
<span class="line-modified">122     expressionRangeForBytecodeOffset(bytecodeOffset, divot, startOffset, endOffset, line, column);</span>
123     return line;
124 }
125 
126 inline void UnlinkedCodeBlock::getLineAndColumn(const ExpressionRangeInfo&amp; info,
127     unsigned&amp; line, unsigned&amp; column) const
128 {
129     switch (info.mode) {
130     case ExpressionRangeInfo::FatLineMode:
131         info.decodeFatLineMode(line, column);
132         break;
133     case ExpressionRangeInfo::FatColumnMode:
134         info.decodeFatColumnMode(line, column);
135         break;
136     case ExpressionRangeInfo::FatLineAndColumnMode: {
137         unsigned fatIndex = info.position;
138         ExpressionRangeInfo::FatPosition&amp; fatPos = m_rareData-&gt;m_expressionInfoFatPositions[fatIndex];
139         line = fatPos.line;
140         column = fatPos.column;
141         break;
142     }
143     } // switch
144 }
145 
146 #ifndef NDEBUG
147 static void dumpLineColumnEntry(size_t index, const InstructionStream&amp; instructionStream, unsigned instructionOffset, unsigned line, unsigned column)
148 {
149     const auto instruction = instructionStream.at(instructionOffset);
150     const char* event = &quot;&quot;;
151     if (instruction-&gt;is&lt;OpDebug&gt;()) {
152         switch (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType) {
153         case WillExecuteProgram: event = &quot; WillExecuteProgram&quot;; break;
154         case DidExecuteProgram: event = &quot; DidExecuteProgram&quot;; break;
155         case DidEnterCallFrame: event = &quot; DidEnterCallFrame&quot;; break;
<span class="line-modified">156         case DidReachBreakpoint: event = &quot; DidReachBreakpoint&quot;; break;</span>
157         case WillLeaveCallFrame: event = &quot; WillLeaveCallFrame&quot;; break;
158         case WillExecuteStatement: event = &quot; WillExecuteStatement&quot;; break;
159         case WillExecuteExpression: event = &quot; WillExecuteExpression&quot;; break;
160         }
161     }
162     dataLogF(&quot;  [%zu] pc %u @ line %u col %u : %s%s\n&quot;, index, instructionOffset, line, column, instruction-&gt;name(), event);
163 }
164 
165 void UnlinkedCodeBlock::dumpExpressionRangeInfo()
166 {
<span class="line-modified">167     Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
168 
169     size_t size = m_expressionInfo.size();
170     dataLogF(&quot;UnlinkedCodeBlock %p expressionRangeInfo[%zu] {\n&quot;, this, size);
171     for (size_t i = 0; i &lt; size; i++) {
172         ExpressionRangeInfo&amp; info = expressionInfo[i];
173         unsigned line;
174         unsigned column;
175         getLineAndColumn(info, line, column);
176         dumpLineColumnEntry(i, instructions(), info.instructionOffset, line, column);
177     }
178     dataLog(&quot;}\n&quot;);
179 }
180 #endif
181 
<span class="line-modified">182 void UnlinkedCodeBlock::expressionRangeForBytecodeOffset(unsigned bytecodeOffset,</span>
183     int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
184 {
<span class="line-modified">185     ASSERT(bytecodeOffset &lt; instructions().size());</span>
186 
187     if (!m_expressionInfo.size()) {
188         startOffset = 0;
189         endOffset = 0;
190         divot = 0;
191         line = 0;
192         column = 0;
193         return;
194     }
195 
<span class="line-modified">196     const Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
197 
198     int low = 0;
199     int high = expressionInfo.size();
200     while (low &lt; high) {
201         int mid = low + (high - low) / 2;
<span class="line-modified">202         if (expressionInfo[mid].instructionOffset &lt;= bytecodeOffset)</span>
203             low = mid + 1;
204         else
205             high = mid;
206     }
207 
208     if (!low)
209         low = 1;
210 
211     const ExpressionRangeInfo&amp; info = expressionInfo[low - 1];
212     startOffset = info.startOffset;
213     endOffset = info.endOffset;
214     divot = info.divotPoint;
215     getLineAndColumn(info, line, column);
216 }
217 
<span class="line-removed">218 void UnlinkedCodeBlock::addExpressionInfo(unsigned instructionOffset,</span>
<span class="line-removed">219     int divot, int startOffset, int endOffset, unsigned line, unsigned column)</span>
<span class="line-removed">220 {</span>
<span class="line-removed">221     if (divot &gt; ExpressionRangeInfo::MaxDivot) {</span>
<span class="line-removed">222         // Overflow has occurred, we can only give line number info for errors for this region</span>
<span class="line-removed">223         divot = 0;</span>
<span class="line-removed">224         startOffset = 0;</span>
<span class="line-removed">225         endOffset = 0;</span>
<span class="line-removed">226     } else if (startOffset &gt; ExpressionRangeInfo::MaxOffset) {</span>
<span class="line-removed">227         // If the start offset is out of bounds we clear both offsets</span>
<span class="line-removed">228         // so we only get the divot marker. Error message will have to be reduced</span>
<span class="line-removed">229         // to line and charPosition number.</span>
<span class="line-removed">230         startOffset = 0;</span>
<span class="line-removed">231         endOffset = 0;</span>
<span class="line-removed">232     } else if (endOffset &gt; ExpressionRangeInfo::MaxOffset) {</span>
<span class="line-removed">233         // The end offset is only used for additional context, and is much more likely</span>
<span class="line-removed">234         // to overflow (eg. function call arguments) so we are willing to drop it without</span>
<span class="line-removed">235         // dropping the rest of the range.</span>
<span class="line-removed">236         endOffset = 0;</span>
<span class="line-removed">237     }</span>
<span class="line-removed">238 </span>
<span class="line-removed">239     unsigned positionMode =</span>
<span class="line-removed">240         (line &lt;= ExpressionRangeInfo::MaxFatLineModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatLineModeColumn)</span>
<span class="line-removed">241         ? ExpressionRangeInfo::FatLineMode</span>
<span class="line-removed">242         : (line &lt;= ExpressionRangeInfo::MaxFatColumnModeLine &amp;&amp; column &lt;= ExpressionRangeInfo::MaxFatColumnModeColumn)</span>
<span class="line-removed">243         ? ExpressionRangeInfo::FatColumnMode</span>
<span class="line-removed">244         : ExpressionRangeInfo::FatLineAndColumnMode;</span>
<span class="line-removed">245 </span>
<span class="line-removed">246     ExpressionRangeInfo info;</span>
<span class="line-removed">247     info.instructionOffset = instructionOffset;</span>
<span class="line-removed">248     info.divotPoint = divot;</span>
<span class="line-removed">249     info.startOffset = startOffset;</span>
<span class="line-removed">250     info.endOffset = endOffset;</span>
<span class="line-removed">251 </span>
<span class="line-removed">252     info.mode = positionMode;</span>
<span class="line-removed">253     switch (positionMode) {</span>
<span class="line-removed">254     case ExpressionRangeInfo::FatLineMode:</span>
<span class="line-removed">255         info.encodeFatLineMode(line, column);</span>
<span class="line-removed">256         break;</span>
<span class="line-removed">257     case ExpressionRangeInfo::FatColumnMode:</span>
<span class="line-removed">258         info.encodeFatColumnMode(line, column);</span>
<span class="line-removed">259         break;</span>
<span class="line-removed">260     case ExpressionRangeInfo::FatLineAndColumnMode: {</span>
<span class="line-removed">261         createRareDataIfNecessary();</span>
<span class="line-removed">262         unsigned fatIndex = m_rareData-&gt;m_expressionInfoFatPositions.size();</span>
<span class="line-removed">263         ExpressionRangeInfo::FatPosition fatPos = { line, column };</span>
<span class="line-removed">264         m_rareData-&gt;m_expressionInfoFatPositions.append(fatPos);</span>
<span class="line-removed">265         info.position = fatIndex;</span>
<span class="line-removed">266     }</span>
<span class="line-removed">267     } // switch</span>
<span class="line-removed">268 </span>
<span class="line-removed">269     m_expressionInfo.append(info);</span>
<span class="line-removed">270 }</span>
<span class="line-removed">271 </span>
272 bool UnlinkedCodeBlock::typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot)
273 {
<span class="line-modified">274     static const bool verbose = false;</span>
275     if (!m_rareData) {
276         if (verbose)
277             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
278         startDivot = UINT_MAX;
279         endDivot = UINT_MAX;
280         return false;
281     }
282 
283     auto iter = m_rareData-&gt;m_typeProfilerInfoMap.find(bytecodeOffset);
284     if (iter == m_rareData-&gt;m_typeProfilerInfoMap.end()) {
285         if (verbose)
286             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
287         startDivot = UINT_MAX;
288         endDivot = UINT_MAX;
289         return false;
290     }
291 
292     RareData::TypeProfilerExpressionRange&amp; range = iter-&gt;value;
293     startDivot = range.m_startDivot;
294     endDivot = range.m_endDivot;
295     return true;
296 }
297 
<span class="line-removed">298 void UnlinkedCodeBlock::addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot)</span>
<span class="line-removed">299 {</span>
<span class="line-removed">300     createRareDataIfNecessary();</span>
<span class="line-removed">301     RareData::TypeProfilerExpressionRange range;</span>
<span class="line-removed">302     range.m_startDivot = startDivot;</span>
<span class="line-removed">303     range.m_endDivot = endDivot;</span>
<span class="line-removed">304     m_rareData-&gt;m_typeProfilerInfoMap.set(instructionOffset, range);</span>
<span class="line-removed">305 }</span>
<span class="line-removed">306 </span>
307 UnlinkedCodeBlock::~UnlinkedCodeBlock()
308 {
309 }
310 
<span class="line-removed">311 void UnlinkedCodeBlock::setInstructions(std::unique_ptr&lt;InstructionStream&gt; instructions)</span>
<span class="line-removed">312 {</span>
<span class="line-removed">313     ASSERT(instructions);</span>
<span class="line-removed">314     {</span>
<span class="line-removed">315         auto locker = holdLock(cellLock());</span>
<span class="line-removed">316         m_instructions = WTFMove(instructions);</span>
<span class="line-removed">317         m_metadata-&gt;finalize();</span>
<span class="line-removed">318     }</span>
<span class="line-removed">319     Heap::heap(this)-&gt;reportExtraMemoryAllocated(m_instructions-&gt;sizeInBytes() + m_metadata-&gt;sizeInBytes());</span>
<span class="line-removed">320 }</span>
<span class="line-removed">321 </span>
322 const InstructionStream&amp; UnlinkedCodeBlock::instructions() const
323 {
324     ASSERT(m_instructions.get());
325     return *m_instructions;
326 }
327 
<span class="line-modified">328 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler requiredHandler)</span>
329 {
<span class="line-modified">330     return handlerForIndex(bytecodeOffset, requiredHandler);</span>
331 }
332 
333 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
334 {
335     if (!m_rareData)
336         return nullptr;
<span class="line-modified">337     return UnlinkedHandlerInfo::handlerForIndex(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);</span>
<span class="line-removed">338 }</span>
<span class="line-removed">339 </span>
<span class="line-removed">340 void UnlinkedCodeBlock::applyModification(BytecodeRewriter&amp; rewriter, InstructionStreamWriter&amp; instructions)</span>
<span class="line-removed">341 {</span>
<span class="line-removed">342     // Before applying the changes, we adjust the jumps based on the original bytecode offset, the offset to the jump target, and</span>
<span class="line-removed">343     // the insertion information.</span>
<span class="line-removed">344 </span>
<span class="line-removed">345     rewriter.adjustJumpTargets();</span>
<span class="line-removed">346 </span>
<span class="line-removed">347     // Then, exception handlers should be adjusted.</span>
<span class="line-removed">348     if (m_rareData) {</span>
<span class="line-removed">349         for (UnlinkedHandlerInfo&amp; handler : m_rareData-&gt;m_exceptionHandlers) {</span>
<span class="line-removed">350             handler.target = rewriter.adjustAbsoluteOffset(handler.target);</span>
<span class="line-removed">351             handler.start = rewriter.adjustAbsoluteOffset(handler.start);</span>
<span class="line-removed">352             handler.end = rewriter.adjustAbsoluteOffset(handler.end);</span>
<span class="line-removed">353         }</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         for (size_t i = 0; i &lt; m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.size(); ++i)</span>
<span class="line-removed">356             m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets[i] = rewriter.adjustAbsoluteOffset(m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets[i]);</span>
<span class="line-removed">357 </span>
<span class="line-removed">358         if (!m_rareData-&gt;m_typeProfilerInfoMap.isEmpty()) {</span>
<span class="line-removed">359             HashMap&lt;unsigned, RareData::TypeProfilerExpressionRange&gt; adjustedTypeProfilerInfoMap;</span>
<span class="line-removed">360             for (auto&amp; entry : m_rareData-&gt;m_typeProfilerInfoMap)</span>
<span class="line-removed">361                 adjustedTypeProfilerInfoMap.set(rewriter.adjustAbsoluteOffset(entry.key), entry.value);</span>
<span class="line-removed">362             m_rareData-&gt;m_typeProfilerInfoMap.swap(adjustedTypeProfilerInfoMap);</span>
<span class="line-removed">363         }</span>
<span class="line-removed">364     }</span>
<span class="line-removed">365 </span>
<span class="line-removed">366     for (size_t i = 0; i &lt; m_propertyAccessInstructions.size(); ++i)</span>
<span class="line-removed">367         m_propertyAccessInstructions[i] = rewriter.adjustAbsoluteOffset(m_propertyAccessInstructions[i]);</span>
<span class="line-removed">368 </span>
<span class="line-removed">369     for (size_t i = 0; i &lt; m_expressionInfo.size(); ++i)</span>
<span class="line-removed">370         m_expressionInfo[i].instructionOffset = rewriter.adjustAbsoluteOffset(m_expressionInfo[i].instructionOffset);</span>
<span class="line-removed">371 </span>
<span class="line-removed">372     // Then, modify the unlinked instructions.</span>
<span class="line-removed">373     rewriter.applyModification();</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     // And recompute the jump target based on the modified unlinked instructions.</span>
<span class="line-removed">376     m_jumpTargets.clear();</span>
<span class="line-removed">377     recomputePreciseJumpTargets(this, instructions, m_jumpTargets);</span>
<span class="line-removed">378 }</span>
<span class="line-removed">379 </span>
<span class="line-removed">380 void UnlinkedCodeBlock::shrinkToFit()</span>
<span class="line-removed">381 {</span>
<span class="line-removed">382     auto locker = holdLock(cellLock());</span>
<span class="line-removed">383 </span>
<span class="line-removed">384     m_jumpTargets.shrinkToFit();</span>
<span class="line-removed">385     m_propertyAccessInstructions.shrinkToFit();</span>
<span class="line-removed">386     m_identifiers.shrinkToFit();</span>
<span class="line-removed">387     m_constantRegisters.shrinkToFit();</span>
<span class="line-removed">388     m_constantsSourceCodeRepresentation.shrinkToFit();</span>
<span class="line-removed">389     m_functionDecls.shrinkToFit();</span>
<span class="line-removed">390     m_functionExprs.shrinkToFit();</span>
<span class="line-removed">391     m_expressionInfo.shrinkToFit();</span>
<span class="line-removed">392 </span>
<span class="line-removed">393     if (m_rareData) {</span>
<span class="line-removed">394         m_rareData-&gt;m_exceptionHandlers.shrinkToFit();</span>
<span class="line-removed">395         m_rareData-&gt;m_switchJumpTables.shrinkToFit();</span>
<span class="line-removed">396         m_rareData-&gt;m_stringSwitchJumpTables.shrinkToFit();</span>
<span class="line-removed">397         m_rareData-&gt;m_expressionInfoFatPositions.shrinkToFit();</span>
<span class="line-removed">398         m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.shrinkToFit();</span>
<span class="line-removed">399         m_rareData-&gt;m_bitVectors.shrinkToFit();</span>
<span class="line-removed">400         m_rareData-&gt;m_constantIdentifierSets.shrinkToFit();</span>
<span class="line-removed">401     }</span>
402 }
403 
404 void UnlinkedCodeBlock::dump(PrintStream&amp;) const
405 {
406 }
407 
408 BytecodeLivenessAnalysis&amp; UnlinkedCodeBlock::livenessAnalysisSlow(CodeBlock* codeBlock)
409 {
410     RELEASE_ASSERT(codeBlock-&gt;unlinkedCodeBlock() == this);
411 
412     {
413         ConcurrentJSLocker locker(m_lock);
414         if (!m_liveness) {
415             // There is a chance two compiler threads raced to the slow path.
416             // Grabbing the lock above defends against computing liveness twice.
417             m_liveness = makeUnique&lt;BytecodeLivenessAnalysis&gt;(codeBlock);
418         }
419     }
420 
421     return *m_liveness;
422 }
423 
<span class="line-removed">424 void UnlinkedCodeBlock::addOutOfLineJumpTarget(InstructionStream::Offset bytecodeOffset, int target)</span>
<span class="line-removed">425 {</span>
<span class="line-removed">426     RELEASE_ASSERT(target);</span>
<span class="line-removed">427     m_outOfLineJumpTargets.set(bytecodeOffset, target);</span>
<span class="line-removed">428 }</span>
<span class="line-removed">429 </span>
430 int UnlinkedCodeBlock::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
431 {
432     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
433     return m_outOfLineJumpTargets.get(bytecodeOffset);
434 }
435 
436 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 55 const ClassInfo UnlinkedCodeBlock::s_info = { &quot;UnlinkedCodeBlock&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedCodeBlock) };
 56 
 57 UnlinkedCodeBlock::UnlinkedCodeBlock(VM&amp; vm, Structure* structure, CodeType codeType, const ExecutableInfo&amp; info, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
 58     : Base(vm, structure)
 59     , m_usesEval(info.usesEval())
 60     , m_isStrictMode(info.isStrictMode())
 61     , m_isConstructor(info.isConstructor())
 62     , m_hasCapturedVariables(false)
 63     , m_isBuiltinFunction(info.isBuiltinFunction())
 64     , m_superBinding(static_cast&lt;unsigned&gt;(info.superBinding()))
 65     , m_scriptMode(static_cast&lt;unsigned&gt;(info.scriptMode()))
 66     , m_isArrowFunctionContext(info.isArrowFunctionContext())
 67     , m_isClassContext(info.isClassContext())
 68     , m_hasTailCalls(false)
 69     , m_constructorKind(static_cast&lt;unsigned&gt;(info.constructorKind()))
 70     , m_derivedContextType(static_cast&lt;unsigned&gt;(info.derivedContextType()))
 71     , m_evalContextType(static_cast&lt;unsigned&gt;(info.evalContextType()))
 72     , m_codeType(static_cast&lt;unsigned&gt;(codeType))
 73     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
 74     , m_age(0)
<span class="line-added"> 75     , m_hasCheckpoints(false)</span>
 76     , m_parseMode(info.parseMode())
 77     , m_codeGenerationMode(codeGenerationMode)
 78     , m_metadata(UnlinkedMetadataTable::create())
 79 {


 80     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(info.constructorKind()));
 81     ASSERT(m_codeType == static_cast&lt;unsigned&gt;(codeType));
 82     ASSERT(m_didOptimize == static_cast&lt;unsigned&gt;(MixedTriState));
<span class="line-added"> 83     if (info.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {</span>
<span class="line-added"> 84         createRareDataIfNecessary(holdLock(cellLock()));</span>
<span class="line-added"> 85         m_rareData-&gt;m_needsClassFieldInitializer = static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::Yes);</span>
<span class="line-added"> 86     }</span>
 87 }
 88 
 89 void UnlinkedCodeBlock::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 90 {
 91     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
 92     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 93     Base::visitChildren(thisObject, visitor);
 94     auto locker = holdLock(thisObject-&gt;cellLock());
 95     if (visitor.isFirstVisit())
 96         thisObject-&gt;m_age = std::min&lt;unsigned&gt;(static_cast&lt;unsigned&gt;(thisObject-&gt;m_age) + 1, maxAge);
<span class="line-modified"> 97     for (auto&amp; barrier : thisObject-&gt;m_functionDecls)</span>
<span class="line-modified"> 98         visitor.append(barrier);</span>
<span class="line-modified"> 99     for (auto&amp; barrier : thisObject-&gt;m_functionExprs)</span>
<span class="line-modified">100         visitor.append(barrier);</span>
101     visitor.appendValues(thisObject-&gt;m_constantRegisters.data(), thisObject-&gt;m_constantRegisters.size());
102     size_t extraMemory = thisObject-&gt;m_metadata-&gt;sizeInBytes();
103     if (thisObject-&gt;m_instructions)
104         extraMemory += thisObject-&gt;m_instructions-&gt;sizeInBytes();
105     visitor.reportExtraMemoryVisited(extraMemory);
106 }
107 
108 size_t UnlinkedCodeBlock::estimatedSize(JSCell* cell, VM&amp; vm)
109 {
110     UnlinkedCodeBlock* thisObject = jsCast&lt;UnlinkedCodeBlock*&gt;(cell);
111     size_t extraSize = thisObject-&gt;m_metadata-&gt;sizeInBytes();
112     if (thisObject-&gt;m_instructions)
113         extraSize += thisObject-&gt;m_instructions-&gt;sizeInBytes();
114     return Base::estimatedSize(cell, vm) + extraSize;
115 }
116 
<span class="line-modified">117 int UnlinkedCodeBlock::lineNumberForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
118 {
<span class="line-modified">119     ASSERT(bytecodeIndex.offset() &lt; instructions().size());</span>
120     int divot { 0 };
121     int startOffset { 0 };
122     int endOffset { 0 };
123     unsigned line { 0 };
124     unsigned column { 0 };
<span class="line-modified">125     expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset, line, column);</span>
126     return line;
127 }
128 
129 inline void UnlinkedCodeBlock::getLineAndColumn(const ExpressionRangeInfo&amp; info,
130     unsigned&amp; line, unsigned&amp; column) const
131 {
132     switch (info.mode) {
133     case ExpressionRangeInfo::FatLineMode:
134         info.decodeFatLineMode(line, column);
135         break;
136     case ExpressionRangeInfo::FatColumnMode:
137         info.decodeFatColumnMode(line, column);
138         break;
139     case ExpressionRangeInfo::FatLineAndColumnMode: {
140         unsigned fatIndex = info.position;
141         ExpressionRangeInfo::FatPosition&amp; fatPos = m_rareData-&gt;m_expressionInfoFatPositions[fatIndex];
142         line = fatPos.line;
143         column = fatPos.column;
144         break;
145     }
146     } // switch
147 }
148 
149 #ifndef NDEBUG
150 static void dumpLineColumnEntry(size_t index, const InstructionStream&amp; instructionStream, unsigned instructionOffset, unsigned line, unsigned column)
151 {
152     const auto instruction = instructionStream.at(instructionOffset);
153     const char* event = &quot;&quot;;
154     if (instruction-&gt;is&lt;OpDebug&gt;()) {
155         switch (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType) {
156         case WillExecuteProgram: event = &quot; WillExecuteProgram&quot;; break;
157         case DidExecuteProgram: event = &quot; DidExecuteProgram&quot;; break;
158         case DidEnterCallFrame: event = &quot; DidEnterCallFrame&quot;; break;
<span class="line-modified">159         case DidReachDebuggerStatement: event = &quot; DidReachDebuggerStatement&quot;; break;</span>
160         case WillLeaveCallFrame: event = &quot; WillLeaveCallFrame&quot;; break;
161         case WillExecuteStatement: event = &quot; WillExecuteStatement&quot;; break;
162         case WillExecuteExpression: event = &quot; WillExecuteExpression&quot;; break;
163         }
164     }
165     dataLogF(&quot;  [%zu] pc %u @ line %u col %u : %s%s\n&quot;, index, instructionOffset, line, column, instruction-&gt;name(), event);
166 }
167 
168 void UnlinkedCodeBlock::dumpExpressionRangeInfo()
169 {
<span class="line-modified">170     RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
171 
172     size_t size = m_expressionInfo.size();
173     dataLogF(&quot;UnlinkedCodeBlock %p expressionRangeInfo[%zu] {\n&quot;, this, size);
174     for (size_t i = 0; i &lt; size; i++) {
175         ExpressionRangeInfo&amp; info = expressionInfo[i];
176         unsigned line;
177         unsigned column;
178         getLineAndColumn(info, line, column);
179         dumpLineColumnEntry(i, instructions(), info.instructionOffset, line, column);
180     }
181     dataLog(&quot;}\n&quot;);
182 }
183 #endif
184 
<span class="line-modified">185 void UnlinkedCodeBlock::expressionRangeForBytecodeIndex(BytecodeIndex bytecodeIndex,</span>
186     int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
187 {
<span class="line-modified">188     ASSERT(bytecodeIndex.offset() &lt; instructions().size());</span>
189 
190     if (!m_expressionInfo.size()) {
191         startOffset = 0;
192         endOffset = 0;
193         divot = 0;
194         line = 0;
195         column = 0;
196         return;
197     }
198 
<span class="line-modified">199     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo = m_expressionInfo;</span>
200 
201     int low = 0;
202     int high = expressionInfo.size();
203     while (low &lt; high) {
204         int mid = low + (high - low) / 2;
<span class="line-modified">205         if (expressionInfo[mid].instructionOffset &lt;= bytecodeIndex.offset())</span>
206             low = mid + 1;
207         else
208             high = mid;
209     }
210 
211     if (!low)
212         low = 1;
213 
214     const ExpressionRangeInfo&amp; info = expressionInfo[low - 1];
215     startOffset = info.startOffset;
216     endOffset = info.endOffset;
217     divot = info.divotPoint;
218     getLineAndColumn(info, line, column);
219 }
220 






















































221 bool UnlinkedCodeBlock::typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot)
222 {
<span class="line-modified">223     static constexpr bool verbose = false;</span>
224     if (!m_rareData) {
225         if (verbose)
226             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
227         startDivot = UINT_MAX;
228         endDivot = UINT_MAX;
229         return false;
230     }
231 
232     auto iter = m_rareData-&gt;m_typeProfilerInfoMap.find(bytecodeOffset);
233     if (iter == m_rareData-&gt;m_typeProfilerInfoMap.end()) {
234         if (verbose)
235             dataLogF(&quot;Don&#39;t have assignment info for offset:%u\n&quot;, bytecodeOffset);
236         startDivot = UINT_MAX;
237         endDivot = UINT_MAX;
238         return false;
239     }
240 
241     RareData::TypeProfilerExpressionRange&amp; range = iter-&gt;value;
242     startDivot = range.m_startDivot;
243     endDivot = range.m_endDivot;
244     return true;
245 }
246 









247 UnlinkedCodeBlock::~UnlinkedCodeBlock()
248 {
249 }
250 











251 const InstructionStream&amp; UnlinkedCodeBlock::instructions() const
252 {
253     ASSERT(m_instructions.get());
254     return *m_instructions;
255 }
256 
<span class="line-modified">257 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeIndex(BytecodeIndex bytecodeIndex, RequiredHandler requiredHandler)</span>
258 {
<span class="line-modified">259     return handlerForIndex(bytecodeIndex.offset(), requiredHandler);</span>
260 }
261 
262 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
263 {
264     if (!m_rareData)
265         return nullptr;
<span class="line-modified">266     return UnlinkedHandlerInfo::handlerForIndex&lt;UnlinkedHandlerInfo&gt;(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);</span>
































































267 }
268 
269 void UnlinkedCodeBlock::dump(PrintStream&amp;) const
270 {
271 }
272 
273 BytecodeLivenessAnalysis&amp; UnlinkedCodeBlock::livenessAnalysisSlow(CodeBlock* codeBlock)
274 {
275     RELEASE_ASSERT(codeBlock-&gt;unlinkedCodeBlock() == this);
276 
277     {
278         ConcurrentJSLocker locker(m_lock);
279         if (!m_liveness) {
280             // There is a chance two compiler threads raced to the slow path.
281             // Grabbing the lock above defends against computing liveness twice.
282             m_liveness = makeUnique&lt;BytecodeLivenessAnalysis&gt;(codeBlock);
283         }
284     }
285 
286     return *m_liveness;
287 }
288 






289 int UnlinkedCodeBlock::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
290 {
291     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
292     return m_outOfLineJumpTargets.get(bytecodeOffset);
293 }
294 
295 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="SuperSampler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedCodeBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
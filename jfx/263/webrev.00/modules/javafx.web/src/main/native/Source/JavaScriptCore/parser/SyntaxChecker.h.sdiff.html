<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/SyntaxChecker.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SourceProviderCacheItem.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VariableEnvironment.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/SyntaxChecker.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
123     typedef int TemplateString;
124     typedef int TemplateStringList;
125     typedef int TemplateLiteral;
126     typedef int FormalParameterList;
127     typedef int FunctionBody;
128     typedef int ClassExpression;
129     typedef int ModuleName;
130     typedef int ImportSpecifier;
131     typedef int ImportSpecifierList;
132     typedef int ExportSpecifier;
133     typedef int ExportSpecifierList;
134     typedef int Statement;
135     typedef int ClauseList;
136     typedef int Clause;
137     typedef int BinaryOperand;
138     typedef int DestructuringPattern;
139     typedef DestructuringPattern ArrayPattern;
140     typedef DestructuringPattern ObjectPattern;
141     typedef DestructuringPattern RestPattern;
142 
<span class="line-modified">143     static const bool CreatesAST = false;</span>
<span class="line-modified">144     static const bool NeedsFreeVariableInfo = false;</span>
<span class="line-modified">145     static const bool CanUseFunctionCache = true;</span>
<span class="line-modified">146     static const unsigned DontBuildKeywords = LexexFlagsDontBuildKeywords;</span>
<span class="line-modified">147     static const unsigned DontBuildStrings = LexerFlagsDontBuildStrings;</span>
148 
149     int createSourceElements() { return SourceElementsResult; }
150     ExpressionType makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionType, bool, int, int, int, int, size_t, bool) { return CallExpr; }
151     ExpressionType createCommaExpr(const JSTokenLocation&amp;, ExpressionType expr) { return expr; }
152     ExpressionType appendToCommaExpr(const JSTokenLocation&amp;, ExpressionType&amp; head, ExpressionType, ExpressionType next) { head = next; return next; }
153     ExpressionType makeAssignNode(const JSTokenLocation&amp;, ExpressionType, Operator, ExpressionType, bool, bool, int, int, int) { return AssignmentExpr; }
154     ExpressionType makePrefixNode(const JSTokenLocation&amp;, ExpressionType, Operator, int, int, int) { return PreExpr; }
155     ExpressionType makePostfixNode(const JSTokenLocation&amp;, ExpressionType, Operator, int, int, int) { return PostExpr; }
156     ExpressionType makeTypeOfNode(const JSTokenLocation&amp;, ExpressionType) { return TypeofExpr; }
157     ExpressionType makeDeleteNode(const JSTokenLocation&amp;, ExpressionType, int, int, int) { return DeleteExpr; }
158     ExpressionType makeNegateNode(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
159     ExpressionType makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
160     ExpressionType createLogicalNot(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
161     ExpressionType createUnaryPlus(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
162     ExpressionType createVoid(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
163     ExpressionType createImportExpr(const JSTokenLocation&amp;, ExpressionType, int, int, int) { return ImportExpr; }
164     ExpressionType createThisExpr(const JSTokenLocation&amp;) { return ThisExpr; }
165     ExpressionType createSuperExpr(const JSTokenLocation&amp;) { return SuperExpr; }
166     ExpressionType createNewTargetExpr(const JSTokenLocation&amp;) { return NewTargetExpr; }
167     ExpressionType createImportMetaExpr(const JSTokenLocation&amp;, ExpressionType) { return ImportMetaExpr; }
</pre>
<hr />
<pre>
219     {
220         if (!complete)
221             return Property(type);
222         ASSERT(name);
223         return Property(name, type);
224     }
225     Property createProperty(int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)
226     {
227         return Property(type);
228     }
229     Property createProperty(VM&amp; vm, ParserArena&amp; parserArena, double name, int, PropertyNode::Type type, PropertyNode::PutType, bool complete, SuperBinding, ClassElementTag)
230     {
231         if (!complete)
232             return Property(type);
233         return Property(&amp;parserArena.identifierArena().makeNumericIdentifier(vm, name), type);
234     }
235     Property createProperty(int, int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)
236     {
237         return Property(type);
238     }




239     int createPropertyList(const JSTokenLocation&amp;, Property) { return PropertyListResult; }
240     int createPropertyList(const JSTokenLocation&amp;, Property, int) { return PropertyListResult; }
241     int createElementList(int, int) { return ElementsListResult; }
242     int createElementList(int, int, int) { return ElementsListResult; }
243     int createElementList(int) { return ElementsListResult; }
244     int createFormalParameterList() { return FormalParameterListResult; }
245     void appendParameter(int, DestructuringPattern, int) { }
246     int createClause(int, int) { return ClauseResult; }
247     int createClauseList(int) { return ClauseListResult; }
248     int createClauseList(int, int) { return ClauseListResult; }
249     int createFuncDeclStatement(const JSTokenLocation&amp;, const ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { return StatementResult; }

250     int createClassDeclStatement(const JSTokenLocation&amp;, ClassExpression,
251         const JSTextPosition&amp;, const JSTextPosition&amp;, int, int) { return StatementResult; }
252     int createBlockStatement(const JSTokenLocation&amp;, int, int, int, VariableEnvironment&amp;, DeclarationStacks::FunctionStack&amp;&amp;) { return StatementResult; }
253     int createExprStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
254     int createIfStatement(const JSTokenLocation&amp;, int, int, int, int) { return StatementResult; }
255     int createIfStatement(const JSTokenLocation&amp;, int, int, int, int, int) { return StatementResult; }
256     int createForLoop(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
257     int createForInLoop(const JSTokenLocation&amp;, int, int, int, const JSTokenLocation&amp;, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
258     int createForOfLoop(bool, const JSTokenLocation&amp;, int, int, int, const JSTokenLocation&amp;, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
259     int createEmptyStatement(const JSTokenLocation&amp;) { return StatementResult; }
260     int createDeclarationStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
261     int createReturnStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
262     int createBreakStatement(const JSTokenLocation&amp;, int, int) { return StatementResult; }
263     int createBreakStatement(const JSTokenLocation&amp;, const Identifier*, int, int) { return StatementResult; }
264     int createContinueStatement(const JSTokenLocation&amp;, int, int) { return StatementResult; }
265     int createContinueStatement(const JSTokenLocation&amp;, const Identifier*, int, int) { return StatementResult; }
266     int createTryStatement(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
267     int createSwitchStatement(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;, DeclarationStacks::FunctionStack&amp;&amp;) { return StatementResult; }
268     int createWhileStatement(const JSTokenLocation&amp;, int, int, int, int) { return StatementResult; }
269     int createWithStatement(const JSTokenLocation&amp;, int, int, int, int, int, int) { return StatementResult; }
</pre>
<hr />
<pre>
312         if (!m_topBinaryExpr)
313             m_topBinaryExpr = expr;
314         else
315             m_topBinaryExpr = BinaryExpr;
316         operandStackDepth++;
317     }
318 
319     // Logic to handle datastructures used during parsing of binary expressions
320     void operatorStackPop(int&amp; operatorStackDepth) { operatorStackDepth--; }
321     bool operatorStackShouldReduce(int) { return true; }
322     BinaryOperand getFromOperandStack(int) { return m_topBinaryExpr; }
323     void shrinkOperandStackBy(int&amp; operandStackDepth, int amount) { operandStackDepth -= amount; }
324     void appendBinaryOperation(const JSTokenLocation&amp;, int&amp; operandStackDepth, int&amp;, BinaryOperand, BinaryOperand) { operandStackDepth++; }
325     void operatorStackAppend(int&amp; operatorStackDepth, int, int) { operatorStackDepth++; }
326     int popOperandStack(int&amp;) { int res = m_topBinaryExpr; m_topBinaryExpr = 0; return res; }
327 
328     void appendUnaryToken(int&amp; stackDepth, int tok, int) { stackDepth = 1; m_topUnaryToken = tok; }
329     int unaryTokenStackLastType(int&amp;) { return m_topUnaryToken; }
330     JSTextPosition unaryTokenStackLastStart(int&amp;) { return JSTextPosition(0, 0, 0); }
331     void unaryTokenStackRemoveLast(int&amp; stackDepth) { stackDepth = 0; }


332 
<span class="line-modified">333     void assignmentStackAppend(int, int, int, int, int, Operator) { }</span>
<span class="line-modified">334     int createAssignment(const JSTokenLocation&amp;, int, int, int, int, int) { RELEASE_ASSERT_NOT_REACHED(); return AssignmentExpr; }</span>
335     const Identifier* getName(const Property&amp; property) const { return property.name; }
336     PropertyNode::Type getType(const Property&amp; property) const { return property.type; }
337     bool isResolve(ExpressionType expr) const { return expr == ResolveExpr || expr == ResolveEvalExpr; }
338     ExpressionType createDestructuringAssignment(const JSTokenLocation&amp;, int, ExpressionType)
339     {
340         return DestructuringAssignment;
341     }
342 
343     ArrayPattern createArrayPattern(const JSTokenLocation&amp;)
344     {
345         return ArrayDestructuring;
346     }
347     void appendArrayPatternSkipEntry(ArrayPattern, const JSTokenLocation&amp;)
348     {
349     }
350     void appendArrayPatternEntry(ArrayPattern, const JSTokenLocation&amp;, DestructuringPattern, int)
351     {
352     }
353     void appendArrayPatternRestEntry(ArrayPattern, const JSTokenLocation&amp;, DestructuringPattern)
354     {
</pre>
<hr />
<pre>
413     {
414         return type == ArrayLiteralExpr;
415     }
416 
417     bool isObjectOrArrayLiteral(ExpressionType type)
418     {
419         return isObjectLiteral(type) || isArrayLiteral(type);
420     }
421 
422     bool isFunctionCall(ExpressionType type)
423     {
424         return type == CallExpr;
425     }
426 
427     bool shouldSkipPauseLocation(int) const { return true; }
428 
429     void setEndOffset(int, int) { }
430     int endOffset(int) { return 0; }
431     void setStartOffset(int, int) { }
432 
<span class="line-modified">433     JSTextPosition breakpointLocation(int) { return JSTextPosition(-1, 0, 0); }</span>
434 
435     void propagateArgumentsUse() { }
436 
437 private:
438     int m_topBinaryExpr;
439     int m_topUnaryToken;
440 };
441 
442 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
123     typedef int TemplateString;
124     typedef int TemplateStringList;
125     typedef int TemplateLiteral;
126     typedef int FormalParameterList;
127     typedef int FunctionBody;
128     typedef int ClassExpression;
129     typedef int ModuleName;
130     typedef int ImportSpecifier;
131     typedef int ImportSpecifierList;
132     typedef int ExportSpecifier;
133     typedef int ExportSpecifierList;
134     typedef int Statement;
135     typedef int ClauseList;
136     typedef int Clause;
137     typedef int BinaryOperand;
138     typedef int DestructuringPattern;
139     typedef DestructuringPattern ArrayPattern;
140     typedef DestructuringPattern ObjectPattern;
141     typedef DestructuringPattern RestPattern;
142 
<span class="line-modified">143     static constexpr bool CreatesAST = false;</span>
<span class="line-modified">144     static constexpr bool NeedsFreeVariableInfo = false;</span>
<span class="line-modified">145     static constexpr bool CanUseFunctionCache = true;</span>
<span class="line-modified">146     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildKeywords = LexerFlags::DontBuildKeywords;</span>
<span class="line-modified">147     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildStrings = LexerFlags::DontBuildStrings;</span>
148 
149     int createSourceElements() { return SourceElementsResult; }
150     ExpressionType makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionType, bool, int, int, int, int, size_t, bool) { return CallExpr; }
151     ExpressionType createCommaExpr(const JSTokenLocation&amp;, ExpressionType expr) { return expr; }
152     ExpressionType appendToCommaExpr(const JSTokenLocation&amp;, ExpressionType&amp; head, ExpressionType, ExpressionType next) { head = next; return next; }
153     ExpressionType makeAssignNode(const JSTokenLocation&amp;, ExpressionType, Operator, ExpressionType, bool, bool, int, int, int) { return AssignmentExpr; }
154     ExpressionType makePrefixNode(const JSTokenLocation&amp;, ExpressionType, Operator, int, int, int) { return PreExpr; }
155     ExpressionType makePostfixNode(const JSTokenLocation&amp;, ExpressionType, Operator, int, int, int) { return PostExpr; }
156     ExpressionType makeTypeOfNode(const JSTokenLocation&amp;, ExpressionType) { return TypeofExpr; }
157     ExpressionType makeDeleteNode(const JSTokenLocation&amp;, ExpressionType, int, int, int) { return DeleteExpr; }
158     ExpressionType makeNegateNode(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
159     ExpressionType makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
160     ExpressionType createLogicalNot(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
161     ExpressionType createUnaryPlus(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
162     ExpressionType createVoid(const JSTokenLocation&amp;, ExpressionType) { return UnaryExpr; }
163     ExpressionType createImportExpr(const JSTokenLocation&amp;, ExpressionType, int, int, int) { return ImportExpr; }
164     ExpressionType createThisExpr(const JSTokenLocation&amp;) { return ThisExpr; }
165     ExpressionType createSuperExpr(const JSTokenLocation&amp;) { return SuperExpr; }
166     ExpressionType createNewTargetExpr(const JSTokenLocation&amp;) { return NewTargetExpr; }
167     ExpressionType createImportMetaExpr(const JSTokenLocation&amp;, ExpressionType) { return ImportMetaExpr; }
</pre>
<hr />
<pre>
219     {
220         if (!complete)
221             return Property(type);
222         ASSERT(name);
223         return Property(name, type);
224     }
225     Property createProperty(int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)
226     {
227         return Property(type);
228     }
229     Property createProperty(VM&amp; vm, ParserArena&amp; parserArena, double name, int, PropertyNode::Type type, PropertyNode::PutType, bool complete, SuperBinding, ClassElementTag)
230     {
231         if (!complete)
232             return Property(type);
233         return Property(&amp;parserArena.identifierArena().makeNumericIdentifier(vm, name), type);
234     }
235     Property createProperty(int, int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)
236     {
237         return Property(type);
238     }
<span class="line-added">239     Property createProperty(const Identifier*, int, int, PropertyNode::Type type, PropertyNode::PutType, bool, SuperBinding, ClassElementTag)</span>
<span class="line-added">240     {</span>
<span class="line-added">241         return Property(type);</span>
<span class="line-added">242     }</span>
243     int createPropertyList(const JSTokenLocation&amp;, Property) { return PropertyListResult; }
244     int createPropertyList(const JSTokenLocation&amp;, Property, int) { return PropertyListResult; }
245     int createElementList(int, int) { return ElementsListResult; }
246     int createElementList(int, int, int) { return ElementsListResult; }
247     int createElementList(int) { return ElementsListResult; }
248     int createFormalParameterList() { return FormalParameterListResult; }
249     void appendParameter(int, DestructuringPattern, int) { }
250     int createClause(int, int) { return ClauseResult; }
251     int createClauseList(int) { return ClauseListResult; }
252     int createClauseList(int, int) { return ClauseListResult; }
253     int createFuncDeclStatement(const JSTokenLocation&amp;, const ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { return StatementResult; }
<span class="line-added">254     int createDefineField(const JSTokenLocation&amp;, const Identifier*, int, DefineFieldNode::Type) { return 0; }</span>
255     int createClassDeclStatement(const JSTokenLocation&amp;, ClassExpression,
256         const JSTextPosition&amp;, const JSTextPosition&amp;, int, int) { return StatementResult; }
257     int createBlockStatement(const JSTokenLocation&amp;, int, int, int, VariableEnvironment&amp;, DeclarationStacks::FunctionStack&amp;&amp;) { return StatementResult; }
258     int createExprStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
259     int createIfStatement(const JSTokenLocation&amp;, int, int, int, int) { return StatementResult; }
260     int createIfStatement(const JSTokenLocation&amp;, int, int, int, int, int) { return StatementResult; }
261     int createForLoop(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
262     int createForInLoop(const JSTokenLocation&amp;, int, int, int, const JSTokenLocation&amp;, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
263     int createForOfLoop(bool, const JSTokenLocation&amp;, int, int, int, const JSTokenLocation&amp;, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
264     int createEmptyStatement(const JSTokenLocation&amp;) { return StatementResult; }
265     int createDeclarationStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
266     int createReturnStatement(const JSTokenLocation&amp;, int, int, int) { return StatementResult; }
267     int createBreakStatement(const JSTokenLocation&amp;, int, int) { return StatementResult; }
268     int createBreakStatement(const JSTokenLocation&amp;, const Identifier*, int, int) { return StatementResult; }
269     int createContinueStatement(const JSTokenLocation&amp;, int, int) { return StatementResult; }
270     int createContinueStatement(const JSTokenLocation&amp;, const Identifier*, int, int) { return StatementResult; }
271     int createTryStatement(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;) { return StatementResult; }
272     int createSwitchStatement(const JSTokenLocation&amp;, int, int, int, int, int, int, VariableEnvironment&amp;, DeclarationStacks::FunctionStack&amp;&amp;) { return StatementResult; }
273     int createWhileStatement(const JSTokenLocation&amp;, int, int, int, int) { return StatementResult; }
274     int createWithStatement(const JSTokenLocation&amp;, int, int, int, int, int, int) { return StatementResult; }
</pre>
<hr />
<pre>
317         if (!m_topBinaryExpr)
318             m_topBinaryExpr = expr;
319         else
320             m_topBinaryExpr = BinaryExpr;
321         operandStackDepth++;
322     }
323 
324     // Logic to handle datastructures used during parsing of binary expressions
325     void operatorStackPop(int&amp; operatorStackDepth) { operatorStackDepth--; }
326     bool operatorStackShouldReduce(int) { return true; }
327     BinaryOperand getFromOperandStack(int) { return m_topBinaryExpr; }
328     void shrinkOperandStackBy(int&amp; operandStackDepth, int amount) { operandStackDepth -= amount; }
329     void appendBinaryOperation(const JSTokenLocation&amp;, int&amp; operandStackDepth, int&amp;, BinaryOperand, BinaryOperand) { operandStackDepth++; }
330     void operatorStackAppend(int&amp; operatorStackDepth, int, int) { operatorStackDepth++; }
331     int popOperandStack(int&amp;) { int res = m_topBinaryExpr; m_topBinaryExpr = 0; return res; }
332 
333     void appendUnaryToken(int&amp; stackDepth, int tok, int) { stackDepth = 1; m_topUnaryToken = tok; }
334     int unaryTokenStackLastType(int&amp;) { return m_topUnaryToken; }
335     JSTextPosition unaryTokenStackLastStart(int&amp;) { return JSTextPosition(0, 0, 0); }
336     void unaryTokenStackRemoveLast(int&amp; stackDepth) { stackDepth = 0; }
<span class="line-added">337     int unaryTokenStackDepth() const { return 0; }</span>
<span class="line-added">338     void setUnaryTokenStackDepth(int) { }</span>
339 
<span class="line-modified">340     void assignmentStackAppend(int&amp; assignmentStackDepth, int, int, int, int, Operator) { assignmentStackDepth = 1; }</span>
<span class="line-modified">341     int createAssignment(const JSTokenLocation&amp;, int&amp; assignmentStackDepth, int, int, int, int) { assignmentStackDepth = 0; return AssignmentExpr; }</span>
342     const Identifier* getName(const Property&amp; property) const { return property.name; }
343     PropertyNode::Type getType(const Property&amp; property) const { return property.type; }
344     bool isResolve(ExpressionType expr) const { return expr == ResolveExpr || expr == ResolveEvalExpr; }
345     ExpressionType createDestructuringAssignment(const JSTokenLocation&amp;, int, ExpressionType)
346     {
347         return DestructuringAssignment;
348     }
349 
350     ArrayPattern createArrayPattern(const JSTokenLocation&amp;)
351     {
352         return ArrayDestructuring;
353     }
354     void appendArrayPatternSkipEntry(ArrayPattern, const JSTokenLocation&amp;)
355     {
356     }
357     void appendArrayPatternEntry(ArrayPattern, const JSTokenLocation&amp;, DestructuringPattern, int)
358     {
359     }
360     void appendArrayPatternRestEntry(ArrayPattern, const JSTokenLocation&amp;, DestructuringPattern)
361     {
</pre>
<hr />
<pre>
420     {
421         return type == ArrayLiteralExpr;
422     }
423 
424     bool isObjectOrArrayLiteral(ExpressionType type)
425     {
426         return isObjectLiteral(type) || isArrayLiteral(type);
427     }
428 
429     bool isFunctionCall(ExpressionType type)
430     {
431         return type == CallExpr;
432     }
433 
434     bool shouldSkipPauseLocation(int) const { return true; }
435 
436     void setEndOffset(int, int) { }
437     int endOffset(int) { return 0; }
438     void setStartOffset(int, int) { }
439 
<span class="line-modified">440     JSTextPosition breakpointLocation(int) { return { }; }</span>
441 
442     void propagateArgumentsUse() { }
443 
444 private:
445     int m_topBinaryExpr;
446     int m_topUnaryToken;
447 };
448 
449 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="SourceProviderCacheItem.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VariableEnvironment.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
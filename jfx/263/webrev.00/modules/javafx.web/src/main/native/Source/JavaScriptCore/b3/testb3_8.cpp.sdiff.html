<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_8.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="testb3_6.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../bindings/ScriptFunctionCall.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_8.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;testb3.h&quot;
  28 


  29 #if ENABLE(B3_JIT)
  30 
  31 template&lt;typename T&gt;
  32 void testAtomicWeakCAS()
  33 {
  34     constexpr Type type = NativeTraits&lt;T&gt;::type;
  35     constexpr Width width = NativeTraits&lt;T&gt;::width;
  36 
  37     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
  38         if (isX86()) {
  39             checkUsesInstruction(compilation, &quot;lock&quot;);
  40             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
  41         } else {
  42             if (fenced) {
  43                 checkUsesInstruction(compilation, &quot;ldax&quot;);
  44                 checkUsesInstruction(compilation, &quot;stlx&quot;);
  45             } else {
  46                 checkUsesInstruction(compilation, &quot;ldx&quot;);
  47                 checkUsesInstruction(compilation, &quot;stx&quot;);
  48             }
</pre>
<hr />
<pre>
 857     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000000));
 858 
 859     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 60));
 860     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -60));
 861     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000));
 862     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000));
 863     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000));
 864     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000));
 865     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000000));
 866     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000000));
 867 }
 868 
 869 void testFastForwardCopy32()
 870 {
 871 #if CPU(X86_64)
 872     for (const bool aligned : { true, false }) {
 873         for (const bool overlap : { false, true }) {
 874             for (size_t arrsize : { 1, 4, 5, 6, 8, 10, 12, 16, 20, 40, 100, 1000}) {
 875                 size_t overlapAmount = 5;
 876 

 877                 uint32_t* arr1, *arr2;
 878 
 879                 if (overlap) {
<span class="line-modified"> 880                     arr1 = new uint32_t[arrsize * 2];</span>

 881                     arr2 = arr1 + (arrsize - overlapAmount);
 882                 } else {
<span class="line-modified"> 883                     arr1 = new uint32_t[arrsize];</span>
<span class="line-modified"> 884                     arr2 = new uint32_t[arrsize];</span>


 885                 }
 886 
 887                 if (!aligned &amp;&amp; arrsize &lt; 3)
 888                     continue;
 889                 if (overlap &amp;&amp; arrsize &lt;= overlapAmount + 3)
 890                     continue;
 891 
 892                 if (!aligned) {
 893                     ++arr1;
 894                     ++arr2;
 895                     arrsize -= 1;
 896                     overlapAmount -= 1;
 897                 }
 898 
 899                 for (size_t i = 0; i &lt; arrsize; ++i)
 900                     arr1[i] = i;
 901 
 902                 fastForwardCopy32(arr2, arr1, arrsize);
 903 
 904                 if (overlap) {
 905                     for (size_t i = 0; i &lt; arrsize - overlapAmount; ++i)
 906                         CHECK(arr2[i] == i);
 907                     for (size_t i = arrsize - overlapAmount; i &lt; arrsize; ++i)
 908                         CHECK(arr2[i] == i - (arrsize - overlapAmount));
 909                 } else {
 910                     for (size_t i = 0; i &lt; arrsize; ++i)
 911                         CHECK(arr2[i] == i);
 912                 }
 913 
 914                 if (!aligned) {
 915                     --arr1;
 916                     --arr2;
 917                 }
<span class="line-removed"> 918 </span>
<span class="line-removed"> 919                 if (!overlap) {</span>
<span class="line-removed"> 920                     delete[] arr1;</span>
<span class="line-removed"> 921                     delete[] arr2;</span>
<span class="line-removed"> 922                 } else</span>
<span class="line-removed"> 923                     delete[] arr1;</span>
 924             }
 925         }
 926     }
 927 #endif
 928 }
 929 
 930 void testByteCopyLoop()
 931 {
 932     Procedure proc;
 933     BasicBlock* root = proc.addBlock();
 934     BasicBlock* head = proc.addBlock();
 935     BasicBlock* update = proc.addBlock();
 936     BasicBlock* continuation = proc.addBlock();
 937 
 938     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 939     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 940     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 941     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 942     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 943     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
</pre>
</td>
<td>
<hr />
<pre>
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;testb3.h&quot;
  28 
<span class="line-added">  29 #include &lt;wtf/UniqueArray.h&gt;</span>
<span class="line-added">  30 </span>
  31 #if ENABLE(B3_JIT)
  32 
  33 template&lt;typename T&gt;
  34 void testAtomicWeakCAS()
  35 {
  36     constexpr Type type = NativeTraits&lt;T&gt;::type;
  37     constexpr Width width = NativeTraits&lt;T&gt;::width;
  38 
  39     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
  40         if (isX86()) {
  41             checkUsesInstruction(compilation, &quot;lock&quot;);
  42             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
  43         } else {
  44             if (fenced) {
  45                 checkUsesInstruction(compilation, &quot;ldax&quot;);
  46                 checkUsesInstruction(compilation, &quot;stlx&quot;);
  47             } else {
  48                 checkUsesInstruction(compilation, &quot;ldx&quot;);
  49                 checkUsesInstruction(compilation, &quot;stx&quot;);
  50             }
</pre>
<hr />
<pre>
 859     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000000));
 860 
 861     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 60));
 862     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -60));
 863     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000));
 864     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000));
 865     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000));
 866     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000));
 867     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000000));
 868     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000000));
 869 }
 870 
 871 void testFastForwardCopy32()
 872 {
 873 #if CPU(X86_64)
 874     for (const bool aligned : { true, false }) {
 875         for (const bool overlap : { false, true }) {
 876             for (size_t arrsize : { 1, 4, 5, 6, 8, 10, 12, 16, 20, 40, 100, 1000}) {
 877                 size_t overlapAmount = 5;
 878 
<span class="line-added"> 879                 UniqueArray&lt;uint32_t&gt; array1, array2;</span>
 880                 uint32_t* arr1, *arr2;
 881 
 882                 if (overlap) {
<span class="line-modified"> 883                     array1 = makeUniqueArray&lt;uint32_t&gt;(arrsize * 2);</span>
<span class="line-added"> 884                     arr1 = &amp;array1[0];</span>
 885                     arr2 = arr1 + (arrsize - overlapAmount);
 886                 } else {
<span class="line-modified"> 887                     array1 = makeUniqueArray&lt;uint32_t&gt;(arrsize);</span>
<span class="line-modified"> 888                     array2 = makeUniqueArray&lt;uint32_t&gt;(arrsize);</span>
<span class="line-added"> 889                     arr1 = &amp;array1[0];</span>
<span class="line-added"> 890                     arr2 = &amp;array2[0];</span>
 891                 }
 892 
 893                 if (!aligned &amp;&amp; arrsize &lt; 3)
 894                     continue;
 895                 if (overlap &amp;&amp; arrsize &lt;= overlapAmount + 3)
 896                     continue;
 897 
 898                 if (!aligned) {
 899                     ++arr1;
 900                     ++arr2;
 901                     arrsize -= 1;
 902                     overlapAmount -= 1;
 903                 }
 904 
 905                 for (size_t i = 0; i &lt; arrsize; ++i)
 906                     arr1[i] = i;
 907 
 908                 fastForwardCopy32(arr2, arr1, arrsize);
 909 
 910                 if (overlap) {
 911                     for (size_t i = 0; i &lt; arrsize - overlapAmount; ++i)
 912                         CHECK(arr2[i] == i);
 913                     for (size_t i = arrsize - overlapAmount; i &lt; arrsize; ++i)
 914                         CHECK(arr2[i] == i - (arrsize - overlapAmount));
 915                 } else {
 916                     for (size_t i = 0; i &lt; arrsize; ++i)
 917                         CHECK(arr2[i] == i);
 918                 }
 919 
 920                 if (!aligned) {
 921                     --arr1;
 922                     --arr2;
 923                 }






 924             }
 925         }
 926     }
 927 #endif
 928 }
 929 
 930 void testByteCopyLoop()
 931 {
 932     Procedure proc;
 933     BasicBlock* root = proc.addBlock();
 934     BasicBlock* head = proc.addBlock();
 935     BasicBlock* update = proc.addBlock();
 936     BasicBlock* continuation = proc.addBlock();
 937 
 938     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 939     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 940     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 941     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 942     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 943     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
</pre>
</td>
</tr>
</table>
<center><a href="testb3_6.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../bindings/ScriptFunctionCall.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ParseInt.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSCJSValue.h&quot;
 29 #include &quot;Lexer.h&quot;
 30 #include &lt;wtf/dtoa.h&gt;
 31 
 32 namespace JSC {
 33 
 34 static const double mantissaOverflowLowerBound = 9007199254740992.0;
 35 
 36 ALWAYS_INLINE static int parseDigit(unsigned short c, int radix)
 37 {
 38     int digit = -1;
 39 
 40     if (isASCIIDigit(c))
 41         digit = c - &#39;0&#39;;
 42     else if (isASCIIUpper(c))
 43         digit = c - &#39;A&#39; + 10;
 44     else if (isASCIILower(c))
 45         digit = c - &#39;a&#39; + 10;
 46 
 47     if (digit &gt;= radix)
 48         return -1;
 49     return digit;
 50 }
 51 
 52 static double parseIntOverflow(const LChar* s, unsigned length, int radix)
 53 {
 54     double number = 0.0;
 55     double radixMultiplier = 1.0;
 56 
 57     for (const LChar* p = s + length - 1; p &gt;= s; p--) {
 58         if (radixMultiplier == std::numeric_limits&lt;double&gt;::infinity()) {
 59             if (*p != &#39;0&#39;) {
 60                 number = std::numeric_limits&lt;double&gt;::infinity();
 61                 break;
 62             }
 63         } else {
 64             int digit = parseDigit(*p, radix);
 65             number += digit * radixMultiplier;
 66         }
 67 
 68         radixMultiplier *= radix;
 69     }
 70 
 71     return number;
 72 }
 73 
 74 static double parseIntOverflow(const UChar* s, unsigned length, int radix)
 75 {
 76     double number = 0.0;
 77     double radixMultiplier = 1.0;
 78 
 79     for (const UChar* p = s + length - 1; p &gt;= s; p--) {
 80         if (radixMultiplier == std::numeric_limits&lt;double&gt;::infinity()) {
 81             if (*p != &#39;0&#39;) {
 82                 number = std::numeric_limits&lt;double&gt;::infinity();
 83                 break;
 84             }
 85         } else {
 86             int digit = parseDigit(*p, radix);
 87             number += digit * radixMultiplier;
 88         }
 89 
 90         radixMultiplier *= radix;
 91     }
 92 
 93     return number;
 94 }
 95 
 96 static double parseIntOverflow(StringView string, int radix)
 97 {
 98     if (string.is8Bit())
 99         return parseIntOverflow(string.characters8(), string.length(), radix);
100     return parseIntOverflow(string.characters16(), string.length(), radix);
101 }
102 
103 ALWAYS_INLINE static bool isStrWhiteSpace(UChar c)
104 {
105     // https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type
106     return Lexer&lt;UChar&gt;::isWhiteSpace(c) || Lexer&lt;UChar&gt;::isLineTerminator(c);
107 }
108 
109 // ES5.1 15.1.2.2
110 template &lt;typename CharType&gt;
111 ALWAYS_INLINE
112 static double parseInt(StringView s, const CharType* data, int radix)
113 {
114     // 1. Let inputString be ToString(string).
115     // 2. Let S be a newly created substring of inputString consisting of the first character that is not a
116     //    StrWhiteSpaceChar and all characters following that character. (In other words, remove leading white
117     //    space.) If inputString does not contain any such characters, let S be the empty string.
118     int length = s.length();
119     int p = 0;
120     while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
121         ++p;
122 
123     // 3. Let sign be 1.
124     // 4. If S is not empty and the first character of S is a minus sign -, let sign be -1.
125     // 5. If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove the first character from S.
126     double sign = 1;
127     if (p &lt; length) {
128         if (data[p] == &#39;+&#39;)
129             ++p;
130         else if (data[p] == &#39;-&#39;) {
131             sign = -1;
132             ++p;
133         }
134     }
135 
136     // 6. Let R = ToInt32(radix).
137     // 7. Let stripPrefix be true.
138     // 8. If R != 0,then
139     //   b. If R != 16, let stripPrefix be false.
140     // 9. Else, R == 0
141     //   a. LetR = 10.
142     // 10. If stripPrefix is true, then
143     //   a. If the length of S is at least 2 and the first two characters of S are either ―0x or ―0X,
144     //      then remove the first two characters from S and let R = 16.
145     // 11. If S contains any character that is not a radix-R digit, then let Z be the substring of S
146     //     consisting of all characters before the first such character; otherwise, let Z be S.
147     if ((radix == 0 || radix == 16) &amp;&amp; length - p &gt;= 2 &amp;&amp; data[p] == &#39;0&#39; &amp;&amp; (data[p + 1] == &#39;x&#39; || data[p + 1] == &#39;X&#39;)) {
148         radix = 16;
149         p += 2;
150     } else if (radix == 0)
151         radix = 10;
152 
153     // 8.a If R &lt; 2 or R &gt; 36, then return NaN.
154     if (radix &lt; 2 || radix &gt; 36)
155         return PNaN;
156 
157     // 13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation, using the letters
158     //     A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z contains more than 20 significant
159     //     digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation;
160     //     and if R is not 2, 4, 8, 10, 16, or 32, then mathInt may be an implementation-dependent approximation to the
161     //     mathematical integer value that is represented by Z in radix-R notation.)
162     // 14. Let number be the Number value for mathInt.
163     int firstDigitPosition = p;
164     bool sawDigit = false;
165     double number = 0;
166     while (p &lt; length) {
167         int digit = parseDigit(data[p], radix);
168         if (digit == -1)
169             break;
170         sawDigit = true;
171         number *= radix;
172         number += digit;
173         ++p;
174     }
175 
176     // 12. If Z is empty, return NaN.
177     if (!sawDigit)
178         return PNaN;
179 
180     // Alternate code path for certain large numbers.
181     if (number &gt;= mantissaOverflowLowerBound) {
182         if (radix == 10) {
183             size_t parsedLength;
184             number = parseDouble(s.substring(firstDigitPosition, p - firstDigitPosition), parsedLength);
185         } else if (radix == 2 || radix == 4 || radix == 8 || radix == 16 || radix == 32)
186             number = parseIntOverflow(s.substring(firstDigitPosition, p - firstDigitPosition), radix);
187     }
188 
189     // 15. Return sign x number.
190     return sign * number;
191 }
192 
193 ALWAYS_INLINE static double parseInt(StringView s, int radix)
194 {
195     if (s.is8Bit())
196         return parseInt(s, s.characters8(), radix);
197     return parseInt(s, s.characters16(), radix);
198 }
199 
200 template&lt;typename CallbackWhenNoException&gt;
<a name="1" id="anc1"></a><span class="line-modified">201 static ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(StringView)&gt;::type toStringView(JSGlobalObject* globalObject, JSValue value, CallbackWhenNoException callback)</span>
202 {
<a name="2" id="anc2"></a><span class="line-modified">203     VM&amp; vm = getVM(globalObject);</span>
204     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="3" id="anc3"></a><span class="line-modified">205     JSString* string = value.toStringOrNull(globalObject);</span>
206     EXCEPTION_ASSERT(!!scope.exception() == !string);
207     if (UNLIKELY(!string))
208         return { };
<a name="4" id="anc4"></a><span class="line-modified">209     auto viewWithString = string-&gt;viewWithUnderlyingString(globalObject);</span>
210     RETURN_IF_EXCEPTION(scope, { });
211     RELEASE_AND_RETURN(scope, callback(viewWithString.view));
212 }
213 
214 // Mapping from integers 0..35 to digit identifying this value, for radix 2..36.
215 const char radixDigits[] = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;
216 
217 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
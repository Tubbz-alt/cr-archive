<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/cache/MemoryCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller &lt;mueller@kde.org&gt;
  4     Copyright (C) 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
  5 
  6     This library is free software; you can redistribute it and/or
  7     modify it under the terms of the GNU Library General Public
  8     License as published by the Free Software Foundation; either
  9     version 2 of the License, or (at your option) any later version.
 10 
 11     This library is distributed in the hope that it will be useful,
 12     but WITHOUT ANY WARRANTY; without even the implied warranty of
 13     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14     Library General Public License for more details.
 15 
 16     You should have received a copy of the GNU Library General Public License
 17     along with this library; see the file COPYING.LIB.  If not, write to
 18     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19     Boston, MA 02110-1301, USA.
 20 
 21     This class provides all functionality needed for loading images, style sheets and html
 22     pages from the web. It has a memory cache for these objects.
 23 */
 24 
 25 #pragma once
 26 
 27 #include &quot;NativeImage.h&quot;
 28 #include &quot;SecurityOriginHash.h&quot;
 29 #include &quot;Timer.h&quot;
 30 #include &lt;pal/SessionID.h&gt;
 31 #include &lt;wtf/Forward.h&gt;
 32 #include &lt;wtf/Function.h&gt;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/HashSet.h&gt;
 35 #include &lt;wtf/ListHashSet.h&gt;
 36 #include &lt;wtf/Noncopyable.h&gt;
 37 #include &lt;wtf/Vector.h&gt;
 38 #include &lt;wtf/text/StringHash.h&gt;
 39 #include &lt;wtf/text/WTFString.h&gt;
 40 
 41 namespace WebCore  {
 42 
 43 class CachedResource;
 44 class CookieJar;
 45 class ResourceRequest;
 46 class ResourceResponse;
 47 class ScriptExecutionContext;
 48 class SecurityOrigin;
 49 
 50 // This cache holds subresources used by Web pages: images, scripts, stylesheets, etc.
 51 
 52 // The cache keeps a flexible but bounded window of dead resources that grows/shrinks
 53 // depending on the live resource load. Here&#39;s an example of cache growth over time,
 54 // with a min dead resource capacity of 25% and a max dead resource capacity of 50%:
 55 
 56 //        |-----|                              Dead: -
 57 //        |----------|                         Live: +
 58 //      --|----------|                         Cache boundary: | (objects outside this mark have been evicted)
 59 //      --|----------++++++++++|
 60 // -------|-----+++++++++++++++|
 61 // -------|-----+++++++++++++++|+++++
 62 
 63 class MemoryCache {
 64     WTF_MAKE_NONCOPYABLE(MemoryCache); WTF_MAKE_FAST_ALLOCATED;
 65     friend NeverDestroyed&lt;MemoryCache&gt;;
 66     friend class Internals;
 67 public:
 68     struct TypeStatistic {
 69         int count;
 70         int size;
 71         int liveSize;
 72         int decodedSize;
 73 
 74         TypeStatistic()
 75             : count(0)
 76             , size(0)
 77             , liveSize(0)
 78             , decodedSize(0)
 79         {
 80         }
 81 
 82         void addResource(CachedResource&amp;);
 83     };
 84 
 85     struct Statistics {
 86         TypeStatistic images;
 87         TypeStatistic cssStyleSheets;
 88         TypeStatistic scripts;
 89         TypeStatistic xslStyleSheets;
 90         TypeStatistic fonts;
 91     };
 92 
 93     WEBCORE_EXPORT static MemoryCache&amp; singleton();
 94 
 95     WEBCORE_EXPORT CachedResource* resourceForRequest(const ResourceRequest&amp;, PAL::SessionID);
 96 
 97     bool add(CachedResource&amp;);
 98     void remove(CachedResource&amp;);
 99 
100     static bool shouldRemoveFragmentIdentifier(const URL&amp;);
101     static URL removeFragmentIdentifierIfNeeded(const URL&amp;);
102 
103     void revalidationSucceeded(CachedResource&amp; revalidatingResource, const ResourceResponse&amp;);
104     void revalidationFailed(CachedResource&amp; revalidatingResource);
105 
106     void forEachResource(const WTF::Function&lt;void(CachedResource&amp;)&gt;&amp;);
107     void forEachSessionResource(PAL::SessionID, const WTF::Function&lt;void(CachedResource&amp;)&gt;&amp;);
108     WEBCORE_EXPORT void destroyDecodedDataForAllImages();
109 
110     // Sets the cache&#39;s memory capacities, in bytes. These will hold only approximately,
111     // since the decoded cost of resources like scripts and stylesheets is not known.
112     //  - minDeadBytes: The maximum number of bytes that dead resources should consume when the cache is under pressure.
113     //  - maxDeadBytes: The maximum number of bytes that dead resources should consume when the cache is not under pressure.
114     //  - totalBytes: The maximum number of bytes that the cache should consume overall.
115     WEBCORE_EXPORT void setCapacities(unsigned minDeadBytes, unsigned maxDeadBytes, unsigned totalBytes);
116 
117     // Turn the cache on and off.  Disabling the cache will remove all resources from the cache.  They may
118     // still live on if they are referenced by some Web page though.
119     WEBCORE_EXPORT void setDisabled(bool);
120     bool disabled() const { return m_disabled; }
121 
122     WEBCORE_EXPORT void evictResources();
123     WEBCORE_EXPORT void evictResources(PAL::SessionID);
124 
125     void prune();
126     void pruneSoon();
127     unsigned size() const { return m_liveSize + m_deadSize; }
128 
129     void setDeadDecodedDataDeletionInterval(Seconds interval) { m_deadDecodedDataDeletionInterval = interval; }
130     Seconds deadDecodedDataDeletionInterval() const { return m_deadDecodedDataDeletionInterval; }
131 
132     // Calls to put the cached resource into and out of LRU lists.
133     void insertInLRUList(CachedResource&amp;);
134     void removeFromLRUList(CachedResource&amp;);
135 
136     // Called to adjust the cache totals when a resource changes size.
137     void adjustSize(bool live, long long delta);
138 
139     // Track decoded resources that are in the cache and referenced by a Web page.
140     void insertInLiveDecodedResourcesList(CachedResource&amp;);
141     void removeFromLiveDecodedResourcesList(CachedResource&amp;);
142 
143     void addToLiveResourcesSize(CachedResource&amp;);
144     void removeFromLiveResourcesSize(CachedResource&amp;);
145 
146     static void removeRequestFromSessionCaches(ScriptExecutionContext&amp;, const ResourceRequest&amp;);
147 
148     // Function to collect cache statistics for the caches window in the Safari Debug menu.
149     WEBCORE_EXPORT Statistics getStatistics();
150 
151     void resourceAccessed(CachedResource&amp;);
152     bool inLiveDecodedResourcesList(CachedResource&amp; resource) const { return m_liveDecodedResources.contains(&amp;resource); }
153 
154     typedef HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; SecurityOriginSet;
155     WEBCORE_EXPORT void removeResourcesWithOrigin(SecurityOrigin&amp;);
156     WEBCORE_EXPORT void removeResourcesWithOrigins(PAL::SessionID, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
157     WEBCORE_EXPORT void getOriginsWithCache(SecurityOriginSet&amp; origins);
158     WEBCORE_EXPORT HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsWithCache(PAL::SessionID) const;
159 
<a name="1" id="anc1"></a>


160     // pruneDead*() - Flush decoded and encoded data from resources not referenced by Web pages.
161     // pruneLive*() - Flush decoded data from resources still referenced by Web pages.
162     WEBCORE_EXPORT void pruneDeadResources(); // Automatically decide how much to prune.
163     WEBCORE_EXPORT void pruneLiveResources(bool shouldDestroyDecodedDataForAllLiveResources = false);
164 
165     WEBCORE_EXPORT void pruneDeadResourcesToSize(unsigned targetSize);
166     WEBCORE_EXPORT void pruneLiveResourcesToSize(unsigned targetSize, bool shouldDestroyDecodedDataForAllLiveResources = false);
167 
168 private:
169     typedef HashMap&lt;std::pair&lt;URL, String /* partitionName */&gt;, CachedResource*&gt; CachedResourceMap;
170     typedef ListHashSet&lt;CachedResource*&gt; LRUList;
171 
172     MemoryCache();
173     ~MemoryCache(); // Not implemented to make sure nobody accidentally calls delete -- WebCore does not delete singletons.
174 
175     LRUList&amp; lruListFor(CachedResource&amp;);
176 
177     void dumpStats();
178     void dumpLRULists(bool includeLive) const;
179 
180     unsigned liveCapacity() const;
181     unsigned deadCapacity() const;
182     bool needsPruning() const;
183 
184     CachedResource* resourceForRequestImpl(const ResourceRequest&amp;, CachedResourceMap&amp;);
185 
186     CachedResourceMap&amp; ensureSessionResourceMap(PAL::SessionID);
187     CachedResourceMap* sessionResourceMap(PAL::SessionID) const;
188 
189     bool m_disabled { false };
190     bool m_inPruneResources { false };
191 
192     unsigned m_capacity;
193     unsigned m_minDeadCapacity { 0 };
194     unsigned m_maxDeadCapacity;
195     Seconds m_deadDecodedDataDeletionInterval;
196 
197     unsigned m_liveSize { 0 }; // The number of bytes currently consumed by &quot;live&quot; resources in the cache.
198     unsigned m_deadSize { 0 }; // The number of bytes currently consumed by &quot;dead&quot; resources in the cache.
199 
200     // Size-adjusted and popularity-aware LRU list collection for cache objects.  This collection can hold
201     // more resources than the cached resource map, since it can also hold &quot;stale&quot; multiple versions of objects that are
202     // waiting to die when the clients referencing them go away.
203     Vector&lt;std::unique_ptr&lt;LRUList&gt;, 32&gt; m_allResources;
204 
205     // List just for live resources with decoded data.  Access to this list is based off of painting the resource.
206     LRUList m_liveDecodedResources;
207 
208     // A URL-based map of all resources that are in the cache (including the freshest version of objects that are currently being
209     // referenced by a Web page).
210     typedef HashMap&lt;PAL::SessionID, std::unique_ptr&lt;CachedResourceMap&gt;&gt; SessionCachedResourceMap;
211     SessionCachedResourceMap m_sessionResources;
212 
213     Timer m_pruneTimer;
214 };
215 
216 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
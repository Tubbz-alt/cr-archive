<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AtomicsObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AsyncIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicsObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AtomicsObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
      macro(wait, Wait, 4)                                                \
      macro(wake, Wake, 3)                                                \
      macro(xor, Xor, 3)
  
  #define DECLARE_FUNC_PROTO(lowerName, upperName, count)                 \
<span class="line-modified">!     EncodedJSValue JSC_HOST_CALL atomicsFunc ## upperName(ExecState*);</span>
  FOR_EACH_ATOMICS_FUNC(DECLARE_FUNC_PROTO)
  #undef DECLARE_FUNC_PROTO
  
  const ClassInfo AtomicsObject::s_info = { &quot;Atomics&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AtomicsObject) };
  
<span class="line-new-header">--- 50,11 ---</span>
      macro(wait, Wait, 4)                                                \
      macro(wake, Wake, 3)                                                \
      macro(xor, Xor, 3)
  
  #define DECLARE_FUNC_PROTO(lowerName, upperName, count)                 \
<span class="line-modified">!     EncodedJSValue JSC_HOST_CALL atomicsFunc ## upperName(JSGlobalObject*, CallFrame*);</span>
  FOR_EACH_ATOMICS_FUNC(DECLARE_FUNC_PROTO)
  #undef DECLARE_FUNC_PROTO
  
  const ClassInfo AtomicsObject::s_info = { &quot;Atomics&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AtomicsObject) };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,59 ***</span>
  }
  
  namespace {
  
  template&lt;typename Adaptor, typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgsCase(ExecState* exec, const JSValue* args, ThrowScope&amp; scope, JSArrayBufferView* typedArrayView, unsigned accessIndex, const Func&amp; func)</span>
  {
      JSGenericTypedArrayView&lt;Adaptor&gt;* typedArray = jsCast&lt;JSGenericTypedArrayView&lt;Adaptor&gt;*&gt;(typedArrayView);
  
      double extraArgs[Func::numExtraArgs + 1]; // Add 1 to avoid 0 size array error in VS.
      for (unsigned i = 0; i &lt; Func::numExtraArgs; ++i) {
<span class="line-modified">!         double value = args[2 + i].toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
          extraArgs[i] = value;
      }
  
      return JSValue::encode(func(typedArray-&gt;typedVector() + accessIndex, extraArgs));
  }
  
<span class="line-modified">! unsigned validatedAccessIndex(VM&amp; vm, ExecState* exec, JSValue accessIndexValue, JSArrayBufferView* typedArrayView)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!accessIndexValue.isInt32())) {
<span class="line-modified">!         double accessIndexDouble = accessIndexValue.toNumber(exec);</span>
          RETURN_IF_EXCEPTION(scope, 0);
          if (accessIndexDouble == 0)
              accessIndexValue = jsNumber(0);
          else {
              accessIndexValue = jsNumber(accessIndexDouble);
              if (!accessIndexValue.isInt32()) {
<span class="line-modified">!                 throwRangeError(exec, scope, &quot;Access index is not an integer.&quot;_s);</span>
                  return 0;
              }
          }
      }
      int32_t accessIndex = accessIndexValue.asInt32();
  
      ASSERT(typedArrayView-&gt;length() &lt;= static_cast&lt;unsigned&gt;(INT_MAX));
      if (static_cast&lt;unsigned&gt;(accessIndex) &gt;= typedArrayView-&gt;length()) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;Access index out of bounds for atomic access.&quot;_s);</span>
          return 0;
      }
  
      return accessIndex;
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgs(VM&amp; vm, ExecState* exec, const JSValue* args, const Func&amp; func)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue typedArrayValue = args[0];
      if (!typedArrayValue.isCell()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array argument must be a cell.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      JSCell* typedArrayCell = typedArrayValue.asCell();
  
<span class="line-new-header">--- 87,59 ---</span>
  }
  
  namespace {
  
  template&lt;typename Adaptor, typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgsCase(JSGlobalObject* globalObject, const JSValue* args, ThrowScope&amp; scope, JSArrayBufferView* typedArrayView, unsigned accessIndex, const Func&amp; func)</span>
  {
      JSGenericTypedArrayView&lt;Adaptor&gt;* typedArray = jsCast&lt;JSGenericTypedArrayView&lt;Adaptor&gt;*&gt;(typedArrayView);
  
      double extraArgs[Func::numExtraArgs + 1]; // Add 1 to avoid 0 size array error in VS.
      for (unsigned i = 0; i &lt; Func::numExtraArgs; ++i) {
<span class="line-modified">!         double value = args[2 + i].toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
          extraArgs[i] = value;
      }
  
      return JSValue::encode(func(typedArray-&gt;typedVector() + accessIndex, extraArgs));
  }
  
<span class="line-modified">! unsigned validatedAccessIndex(VM&amp; vm, JSGlobalObject* globalObject, JSValue accessIndexValue, JSArrayBufferView* typedArrayView)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (UNLIKELY(!accessIndexValue.isInt32())) {
<span class="line-modified">!         double accessIndexDouble = accessIndexValue.toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, 0);
          if (accessIndexDouble == 0)
              accessIndexValue = jsNumber(0);
          else {
              accessIndexValue = jsNumber(accessIndexDouble);
              if (!accessIndexValue.isInt32()) {
<span class="line-modified">!                 throwRangeError(globalObject, scope, &quot;Access index is not an integer.&quot;_s);</span>
                  return 0;
              }
          }
      }
      int32_t accessIndex = accessIndexValue.asInt32();
  
      ASSERT(typedArrayView-&gt;length() &lt;= static_cast&lt;unsigned&gt;(INT_MAX));
      if (static_cast&lt;unsigned&gt;(accessIndex) &gt;= typedArrayView-&gt;length()) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;Access index out of bounds for atomic access.&quot;_s);</span>
          return 0;
      }
  
      return accessIndex;
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgs(VM&amp; vm, JSGlobalObject* globalObject, const JSValue* args, const Func&amp; func)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue typedArrayValue = args[0];
      if (!typedArrayValue.isCell()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array argument must be a cell.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      JSCell* typedArrayCell = typedArrayValue.asCell();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,73 ***</span>
      case Uint8ArrayType:
      case Uint16ArrayType:
      case Uint32ArrayType:
          break;
      default:
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array argument must be an Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, or Uint32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      JSArrayBufferView* typedArrayView = jsCast&lt;JSArrayBufferView*&gt;(typedArrayCell);
      if (!typedArrayView-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array argument must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, exec, args[1], typedArrayView);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      switch (type) {
      case Int8ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int8Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      case Int16ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int16Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      case Int32ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int32Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint8ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint8Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint16ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint16Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint32ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint32Adaptor&gt;(exec, args, scope, typedArrayView, accessIndex, func);</span>
      default:
          RELEASE_ASSERT_NOT_REACHED();
          return JSValue::encode(jsUndefined());
      }
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgs(ExecState* exec, const Func&amp; func)</span>
  {
      JSValue args[2 + Func::numExtraArgs];
      for (unsigned i = 2 + Func::numExtraArgs; i--;)
<span class="line-modified">!         args[i] = exec-&gt;argument(i);</span>
<span class="line-modified">!     return atomicOperationWithArgs(exec-&gt;vm(), exec, args, func);</span>
  }
  
  struct AddFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeAdd(ptr, toInt32(args[0])));
      }
  };
  
  struct AndFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeAnd(ptr, toInt32(args[0])));
      }
  };
  
  struct CompareExchangeFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 2;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          T expected = static_cast&lt;T&gt;(toInt32(args[0]));
<span class="line-new-header">--- 151,73 ---</span>
      case Uint8ArrayType:
      case Uint16ArrayType:
      case Uint32ArrayType:
          break;
      default:
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array argument must be an Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, or Uint32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      JSArrayBufferView* typedArrayView = jsCast&lt;JSArrayBufferView*&gt;(typedArrayCell);
      if (!typedArrayView-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array argument must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, globalObject, args[1], typedArrayView);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      switch (type) {
      case Int8ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      case Int16ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      case Int32ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Int32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint8ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint8Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint16ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint16Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      case Uint32ArrayType:
<span class="line-modified">!         return atomicOperationWithArgsCase&lt;Uint32Adaptor&gt;(globalObject, args, scope, typedArrayView, accessIndex, func);</span>
      default:
          RELEASE_ASSERT_NOT_REACHED();
          return JSValue::encode(jsUndefined());
      }
  }
  
  template&lt;typename Func&gt;
<span class="line-modified">! EncodedJSValue atomicOperationWithArgs(JSGlobalObject* globalObject, CallFrame* callFrame, const Func&amp; func)</span>
  {
      JSValue args[2 + Func::numExtraArgs];
      for (unsigned i = 2 + Func::numExtraArgs; i--;)
<span class="line-modified">!         args[i] = callFrame-&gt;argument(i);</span>
<span class="line-modified">!     return atomicOperationWithArgs(globalObject-&gt;vm(), globalObject, args, func);</span>
  }
  
  struct AddFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeAdd(ptr, toInt32(args[0])));
      }
  };
  
  struct AndFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeAnd(ptr, toInt32(args[0])));
      }
  };
  
  struct CompareExchangeFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 2;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          T expected = static_cast&lt;T&gt;(toInt32(args[0]));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,41 ***</span>
          return jsNumber(WTF::atomicCompareExchangeStrong(ptr, expected, newValue));
      }
  };
  
  struct ExchangeFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchange(ptr, static_cast&lt;T&gt;(toInt32(args[0]))));
      }
  };
  
  struct LoadFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 0;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double*) const
      {
          return jsNumber(WTF::atomicLoadFullyFenced(ptr));
      }
  };
  
  struct OrFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeOr(ptr, toInt32(args[0])));
      }
  };
  
  struct StoreFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          double valueAsInt = args[0];
<span class="line-new-header">--- 225,41 ---</span>
          return jsNumber(WTF::atomicCompareExchangeStrong(ptr, expected, newValue));
      }
  };
  
  struct ExchangeFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchange(ptr, static_cast&lt;T&gt;(toInt32(args[0]))));
      }
  };
  
  struct LoadFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 0;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double*) const
      {
          return jsNumber(WTF::atomicLoadFullyFenced(ptr));
      }
  };
  
  struct OrFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeOr(ptr, toInt32(args[0])));
      }
  };
  
  struct StoreFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          double valueAsInt = args[0];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 268,35 ***</span>
          return jsNumber(valueAsInt);
      }
  };
  
  struct SubFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeSub(ptr, toInt32(args[0])));
      }
  };
  
  struct XorFunc {
<span class="line-modified">!     static const unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeXor(ptr, toInt32(args[0])));
      }
  };
  
<span class="line-modified">! EncodedJSValue isLockFree(ExecState* exec, JSValue arg)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     int32_t size = arg.toInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      bool result;
      switch (size) {
      case 1:
<span class="line-new-header">--- 268,35 ---</span>
          return jsNumber(valueAsInt);
      }
  };
  
  struct SubFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeSub(ptr, toInt32(args[0])));
      }
  };
  
  struct XorFunc {
<span class="line-modified">!     static constexpr unsigned numExtraArgs = 1;</span>
  
      template&lt;typename T&gt;
      JSValue operator()(T* ptr, const double* args) const
      {
          return jsNumber(WTF::atomicExchangeXor(ptr, toInt32(args[0])));
      }
  };
  
<span class="line-modified">! EncodedJSValue isLockFree(JSGlobalObject* globalObject, JSValue arg)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     int32_t size = arg.toInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      bool result;
      switch (size) {
      case 1:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,84 ***</span>
      return JSValue::encode(jsBoolean(result));
  }
  
  } // anonymous namespace
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncAdd(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, AddFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncAnd(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, AndFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncCompareExchange(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, CompareExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncExchange(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, ExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncIsLockFree(ExecState* exec)</span>
  {
<span class="line-modified">!     return isLockFree(exec, exec-&gt;argument(0));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncLoad(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, LoadFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncOr(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, OrFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncStore(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, StoreFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncSub(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, SubFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncWait(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, exec-&gt;argument(0));</span>
      if (!typedArray) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      if (!typedArray-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, exec, exec-&gt;argument(1), typedArray);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
  
<span class="line-modified">!     int32_t expectedValue = exec-&gt;argument(2).toInt32(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
<span class="line-modified">!     double timeoutInMilliseconds = exec-&gt;argument(3).toNumber(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      if (!vm.m_typedArrayController-&gt;isAtomicsWaitAllowedOnCurrentThread()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Atomics.wait cannot be called from the current thread.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      Seconds timeout = Seconds::fromMilliseconds(timeoutInMilliseconds);
  
<span class="line-new-header">--- 311,84 ---</span>
      return JSValue::encode(jsBoolean(result));
  }
  
  } // anonymous namespace
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncAdd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, AddFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncAnd(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, AndFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncCompareExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, CompareExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncExchange(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, ExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncIsLockFree(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return isLockFree(globalObject, callFrame-&gt;argument(0));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncLoad(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, LoadFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncOr(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, OrFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncStore(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, StoreFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncSub(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, SubFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncWait(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!typedArray) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      if (!typedArray-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
  
<span class="line-modified">!     int32_t expectedValue = callFrame-&gt;argument(2).toInt32(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
<span class="line-modified">!     double timeoutInMilliseconds = callFrame-&gt;argument(3).toNumber(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      if (!vm.m_typedArrayController-&gt;isAtomicsWaitAllowedOnCurrentThread()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Atomics.wait cannot be called from the current thread.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      Seconds timeout = Seconds::fromMilliseconds(timeoutInMilliseconds);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,11 ***</span>
      //
      // 4. If timeout is not provided or is undefined then let t be +inf. Otherwise:
      //     a. Let q be ? ToNumber(timeout).
      //     b. If q is NaN then let t be +inf, otherwise let t be max(0, q).
      //
<span class="line-modified">!     // exec-&gt;argument(3) returns undefined if it&#39;s not provided and ToNumber(undefined) returns NaN,</span>
      // so NaN is the only special case.
      if (!std::isnan(timeout))
          timeout = std::max(0_s, timeout);
      else
          timeout = Seconds::infinity();
<span class="line-new-header">--- 396,11 ---</span>
      //
      // 4. If timeout is not provided or is undefined then let t be +inf. Otherwise:
      //     a. Let q be ? ToNumber(timeout).
      //     b. If q is NaN then let t be +inf, otherwise let t be max(0, q).
      //
<span class="line-modified">!     // callFrame-&gt;argument(3) returns undefined if it&#39;s not provided and ToNumber(undefined) returns NaN,</span>
      // so NaN is the only special case.
      if (!std::isnan(timeout))
          timeout = std::max(0_s, timeout);
      else
          timeout = Seconds::infinity();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,123 ***</span>
      else
          resultString = &quot;ok&quot;;
      return JSValue::encode(jsString(vm, resultString));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncWake(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, exec-&gt;argument(0));</span>
      if (!typedArray) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      if (!typedArray-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, exec, exec-&gt;argument(1), typedArray);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
  
<span class="line-modified">!     JSValue countValue = exec-&gt;argument(2);</span>
      unsigned count = UINT_MAX;
      if (!countValue.isUndefined()) {
<span class="line-modified">!         int32_t countInt = countValue.toInt32(exec);</span>
          RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
          count = std::max(0, countInt);
      }
  
      return JSValue::encode(jsNumber(ParkingLot::unparkCount(ptr, count)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncXor(ExecState* exec)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(exec, XorFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsAdd(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, AddFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsAnd(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, AndFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsCompareExchange(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue expected, EncodedJSValue newValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(expected), JSValue::decode(newValue)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, CompareExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsExchange(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, ExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsIsLockFree(ExecState* exec, EncodedJSValue size)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">!     return isLockFree(exec, JSValue::decode(size));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsLoad(ExecState* exec, EncodedJSValue base, EncodedJSValue index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, LoadFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsOr(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, OrFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsStore(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, StoreFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsSub(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, SubFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsXor(ExecState* exec, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, exec, args, XorFunc());</span>
  }
  
  } // namespace JSC
  
<span class="line-new-header">--- 426,137 ---</span>
      else
          resultString = &quot;ok&quot;;
      return JSValue::encode(jsString(vm, resultString));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncWake(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSInt32Array* typedArray = jsDynamicCast&lt;JSInt32Array*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!typedArray) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must be an Int32Array.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
      if (!typedArray-&gt;isShared()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Typed array for wait/wake must wrap a SharedArrayBuffer.&quot;_s);</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     unsigned accessIndex = validatedAccessIndex(vm, globalObject, callFrame-&gt;argument(1), typedArray);</span>
      RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
  
      int32_t* ptr = typedArray-&gt;typedVector() + accessIndex;
  
<span class="line-modified">!     JSValue countValue = callFrame-&gt;argument(2);</span>
      unsigned count = UINT_MAX;
      if (!countValue.isUndefined()) {
<span class="line-modified">!         int32_t countInt = countValue.toInt32(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
          count = std::max(0, countInt);
      }
  
      return JSValue::encode(jsNumber(ParkingLot::unparkCount(ptr, count)));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL atomicsFuncXor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return atomicOperationWithArgs(globalObject, callFrame, XorFunc());</span>
  }
  
<span class="line-modified">! IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JIT_OPERATION operationAtomicsAdd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, AddFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsAnd(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, AndFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsCompareExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue expected, EncodedJSValue newValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(expected), JSValue::decode(newValue)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, CompareExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsExchange(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, ExchangeFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsIsLockFree(JSGlobalObject* globalObject, EncodedJSValue size)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">!     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     return isLockFree(globalObject, JSValue::decode(size));</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsLoad(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, LoadFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsOr(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, OrFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsStore(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, StoreFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsSub(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, SubFunc());</span>
  }
  
<span class="line-modified">! EncodedJSValue JIT_OPERATION operationAtomicsXor(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue index, EncodedJSValue operand)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
      JSValue args[] = {JSValue::decode(base), JSValue::decode(index), JSValue::decode(operand)};
<span class="line-modified">!     return atomicOperationWithArgs(vm, globalObject, args, XorFunc());</span>
  }
  
<span class="line-added">+ IGNORE_WARNINGS_END</span>
<span class="line-added">+ </span>
  } // namespace JSC
  
</pre>
<center><a href="AsyncIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AtomicsObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTextContentElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;SVGTextContentElement.h&quot;
 24 
 25 #include &quot;CSSPropertyNames.h&quot;
 26 #include &quot;CSSValueKeywords.h&quot;
 27 #include &quot;DOMPoint.h&quot;
 28 #include &quot;Frame.h&quot;
 29 #include &quot;FrameSelection.h&quot;
 30 #include &quot;RenderObject.h&quot;
 31 #include &quot;RenderSVGResource.h&quot;
 32 #include &quot;RenderSVGText.h&quot;
 33 #include &quot;SVGNames.h&quot;
 34 #include &quot;SVGPoint.h&quot;
 35 #include &quot;SVGRect.h&quot;
 36 #include &quot;SVGTextQuery.h&quot;
 37 #include &quot;XMLNames.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGTextContentElement);
 44 
 45 SVGTextContentElement::SVGTextContentElement(const QualifiedName&amp; tagName, Document&amp; document)
 46     : SVGGraphicsElement(tagName, document)
<a name="1" id="anc1"></a>
 47 {
 48     static std::once_flag onceFlag;
 49     std::call_once(onceFlag, [] {
 50         PropertyRegistry::registerProperty&lt;SVGNames::textLengthAttr, &amp;SVGTextContentElement::m_textLength&gt;();
 51         PropertyRegistry::registerProperty&lt;SVGNames::lengthAdjustAttr, SVGLengthAdjustType, &amp;SVGTextContentElement::m_lengthAdjust&gt;();
 52     });
 53 }
 54 
 55 unsigned SVGTextContentElement::getNumberOfChars()
 56 {
 57     document().updateLayoutIgnorePendingStylesheets();
 58     return SVGTextQuery(renderer()).numberOfCharacters();
 59 }
 60 
 61 float SVGTextContentElement::getComputedTextLength()
 62 {
 63     document().updateLayoutIgnorePendingStylesheets();
 64     return SVGTextQuery(renderer()).textLength();
 65 }
 66 
 67 ExceptionOr&lt;float&gt; SVGTextContentElement::getSubStringLength(unsigned charnum, unsigned nchars)
 68 {
 69     unsigned numberOfChars = getNumberOfChars();
 70     if (charnum &gt;= numberOfChars)
 71         return Exception { IndexSizeError };
 72 
 73     nchars = std::min(nchars, numberOfChars - charnum);
 74     return SVGTextQuery(renderer()).subStringLength(charnum, nchars);
 75 }
 76 
 77 ExceptionOr&lt;Ref&lt;SVGPoint&gt;&gt; SVGTextContentElement::getStartPositionOfChar(unsigned charnum)
 78 {
 79     if (charnum &gt; getNumberOfChars())
 80         return Exception { IndexSizeError };
 81 
 82     return SVGPoint::create(SVGTextQuery(renderer()).startPositionOfCharacter(charnum));
 83 }
 84 
 85 ExceptionOr&lt;Ref&lt;SVGPoint&gt;&gt; SVGTextContentElement::getEndPositionOfChar(unsigned charnum)
 86 {
 87     if (charnum &gt; getNumberOfChars())
 88         return Exception { IndexSizeError };
 89 
 90     return SVGPoint::create(SVGTextQuery(renderer()).endPositionOfCharacter(charnum));
 91 }
 92 
 93 ExceptionOr&lt;Ref&lt;SVGRect&gt;&gt; SVGTextContentElement::getExtentOfChar(unsigned charnum)
 94 {
 95     if (charnum &gt; getNumberOfChars())
 96         return Exception { IndexSizeError };
 97 
 98     return SVGRect::create(SVGTextQuery(renderer()).extentOfCharacter(charnum));
 99 }
100 
101 ExceptionOr&lt;float&gt; SVGTextContentElement::getRotationOfChar(unsigned charnum)
102 {
103     if (charnum &gt; getNumberOfChars())
104         return Exception { IndexSizeError };
105 
106     return SVGTextQuery(renderer()).rotationOfCharacter(charnum);
107 }
108 
109 int SVGTextContentElement::getCharNumAtPosition(DOMPointInit&amp;&amp; pointInit)
110 {
111     document().updateLayoutIgnorePendingStylesheets();
112     FloatPoint transformPoint {static_cast&lt;float&gt;(pointInit.x), static_cast&lt;float&gt;(pointInit.y)};
113     return SVGTextQuery(renderer()).characterNumberAtPosition(transformPoint);
114 }
115 
116 ExceptionOr&lt;void&gt; SVGTextContentElement::selectSubString(unsigned charnum, unsigned nchars)
117 {
118     unsigned numberOfChars = getNumberOfChars();
119     if (charnum &gt;= numberOfChars)
120         return Exception { IndexSizeError };
121 
122     nchars = std::min(nchars, numberOfChars - charnum);
123 
124     ASSERT(document().frame());
125 
126     FrameSelection&amp; selection = document().frame()-&gt;selection();
127 
128     // Find selection start
129     VisiblePosition start(firstPositionInNode(const_cast&lt;SVGTextContentElement*&gt;(this)));
130     for (unsigned i = 0; i &lt; charnum; ++i)
131         start = start.next();
132 
133     // Find selection end
134     VisiblePosition end(start);
135     for (unsigned i = 0; i &lt; nchars; ++i)
136         end = end.next();
137 
138     selection.setSelection(VisibleSelection(start, end));
139 
140     return { };
141 }
142 
143 bool SVGTextContentElement::isPresentationAttribute(const QualifiedName&amp; name) const
144 {
145     if (name.matches(XMLNames::spaceAttr))
146         return true;
147     return SVGGraphicsElement::isPresentationAttribute(name);
148 }
149 
150 void SVGTextContentElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
151 {
152     if (name.matches(XMLNames::spaceAttr)) {
153         if (value == &quot;preserve&quot;)
154             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValuePre);
155         else
156             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValueNowrap);
157         return;
158     }
159 
160     SVGGraphicsElement::collectStyleForPresentationAttribute(name, value, style);
161 }
162 
163 void SVGTextContentElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
164 {
165     SVGParsingError parseError = NoError;
166 
167     if (name == SVGNames::lengthAdjustAttr) {
168         auto propertyValue = SVGPropertyTraits&lt;SVGLengthAdjustType&gt;::fromString(value);
169         if (propertyValue &gt; 0)
170             m_lengthAdjust-&gt;setBaseValInternal&lt;SVGLengthAdjustType&gt;(propertyValue);
171     } else if (name == SVGNames::textLengthAttr)
<a name="2" id="anc2"></a><span class="line-modified">172         m_textLength-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Other, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
173 
174     reportAttributeParsingError(parseError, name, value);
175 
176     SVGGraphicsElement::parseAttribute(name, value);
<a name="3" id="anc3"></a>
177 }
178 
179 void SVGTextContentElement::svgAttributeChanged(const QualifiedName&amp; attrName)
180 {
181     if (PropertyRegistry::isKnownAttribute(attrName)) {
182         if (attrName == SVGNames::textLengthAttr)
183             m_specifiedTextLength = m_textLength-&gt;baseVal()-&gt;value();
184 
185         if (auto renderer = this-&gt;renderer()) {
186             InstanceInvalidationGuard guard(*this);
187             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
188         }
189         return;
190     }
191 
192     SVGGraphicsElement::svgAttributeChanged(attrName);
<a name="4" id="anc4"></a>
193 }
194 
195 SVGAnimatedLength&amp; SVGTextContentElement::textLengthAnimated()
196 {
<a name="5" id="anc5"></a><span class="line-modified">197     static NeverDestroyed&lt;SVGLengthValue&gt; defaultTextLength(SVGLengthMode::Other);</span>
198     if (m_textLength-&gt;baseVal()-&gt;value() == defaultTextLength)
<a name="6" id="anc6"></a><span class="line-modified">199         m_textLength-&gt;baseVal()-&gt;value() = { getComputedTextLength(), SVGLengthType::Number };</span>
200     return m_textLength;
201 }
202 
203 bool SVGTextContentElement::selfHasRelativeLengths() const
204 {
205     // Any element of the &lt;text&gt; subtree is advertized as using relative lengths.
206     // On any window size change, we have to relayout the text subtree, as the
207     // effective &#39;on-screen&#39; font size may change.
208     return true;
209 }
210 
211 SVGTextContentElement* SVGTextContentElement::elementFromRenderer(RenderObject* renderer)
212 {
213     if (!renderer)
214         return nullptr;
215 
216     if (!renderer-&gt;isSVGText() &amp;&amp; !renderer-&gt;isSVGInline())
217         return nullptr;
218 
219     SVGElement* element = downcast&lt;SVGElement&gt;(renderer-&gt;node());
220     ASSERT(element);
221 
222     if (!is&lt;SVGTextContentElement&gt;(element))
223         return nullptr;
224 
225     return downcast&lt;SVGTextContentElement&gt;(element);
226 }
227 
228 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h
@@ -117,10 +117,11 @@
     Undetermined
 };
 
 enum class IndirectCompositingReason {
     None,
+    Clipping,
     Stacking,
     OverflowScrollPositioning,
     Overlap,
     BackgroundLayer,
     GraphicalEffect, // opacity, mask, filter, transform etc.
@@ -133,12 +134,13 @@
     const ScrollAlignment& alignX { ScrollAlignment::alignCenterIfNeeded };
     const ScrollAlignment& alignY { ScrollAlignment::alignCenterIfNeeded };
     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 };
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);
 class RenderLayer final : public ScrollableArea {
-    WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderLayer);
 public:
     friend class RenderReplica;
     friend class RenderLayerFilters;
     friend class RenderLayerBacking;
     friend class RenderLayerCompositor;
@@ -160,10 +162,11 @@
     RenderLayer* previousSibling() const { return m_previous; }
     RenderLayer* nextSibling() const { return m_next; }
     RenderLayer* firstChild() const { return m_first; }
     RenderLayer* lastChild() const { return m_last; }
     bool isDescendantOf(const RenderLayer&) const;
+    RenderLayer* commonAncestorWithLayer(const RenderLayer&) const;
 
     // This does an ancestor tree walk. Avoid it!
     const RenderLayer* root() const
     {
         const RenderLayer* curr = this;
@@ -173,12 +176,16 @@
     }
 
     void addChild(RenderLayer& newChild, RenderLayer* beforeChild = nullptr);
     void removeChild(RenderLayer&);
 
-    void insertOnlyThisLayer();
-    void removeOnlyThisLayer();
+    enum class LayerChangeTiming {
+        StyleChange,
+        RenderTreeConstruction,
+    };
+    void insertOnlyThisLayer(LayerChangeTiming);
+    void removeOnlyThisLayer(LayerChangeTiming);
 
     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 
     // isStackingContext is true for layers that we've determined should be stacking contexts for painting.
     // Not all stacking contexts are CSS stacking contexts.
@@ -203,11 +210,11 @@
     void dirtyStackingContextZOrderLists();
 
     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 #endif
 
 private:
@@ -430,10 +437,12 @@
     void panScrollFromPoint(const IntPoint&);
 
     // Scrolling methods for layers that can scroll their overflow.
     void scrollByRecursively(const IntSize& delta, ScrollableArea** scrolledArea = nullptr);
 
+    bool requestScrollPositionUpdate(const ScrollPosition&, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) override;
+
     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
 
     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 
@@ -645,11 +654,11 @@
     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint& location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 
-    int zIndex() const { return renderer().style().zIndex(); }
+    int zIndex() const { return renderer().style().usedZIndex(); }
 
     enum PaintLayerFlag {
         PaintLayerHaveTransparency                      = 1 << 0,
         PaintLayerAppliedTransform                      = 1 << 1,
         PaintLayerTemporaryClipRects                    = 1 << 2,
@@ -787,10 +796,12 @@
     bool has3DTransform() const { return m_transform && !m_transform->isAffine(); }
     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 
     void filterNeedsRepaint();
     bool hasFilter() const { return renderer().hasFilter(); }
+    bool hasFilterOutsets() const { return !filterOutsets().isZero(); }
+    IntOutsets filterOutsets() const;
     bool hasBackdropFilter() const
     {
 #if ENABLE(FILTERS_LEVEL_2)
         return renderer().hasBackdropFilter();
 #else
@@ -895,11 +906,11 @@
     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 
     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 
-    WEBCORE_EXPORT bool isTransparentOrFullyClippedRespectingParentFrames() const;
+    WEBCORE_EXPORT bool isTransparentRespectingParentFrames() const;
 
     void invalidateEventRegion();
 
 private:
 
@@ -924,12 +935,12 @@
 
     bool isDirtyStackingContext() const { return m_zOrderListsDirty && isStackingContext(); }
 
     void updateZOrderLists();
     void rebuildZOrderLists();
-    void rebuildZOrderLists(std::unique_ptr<Vector<RenderLayer*>>&, std::unique_ptr<Vector<RenderLayer*>>&);
-    void collectLayers(bool includeHiddenLayers, std::unique_ptr<Vector<RenderLayer*>>&, std::unique_ptr<Vector<RenderLayer*>>&);
+    void rebuildZOrderLists(std::unique_ptr<Vector<RenderLayer*>>&, std::unique_ptr<Vector<RenderLayer*>>&, OptionSet<Compositing>&);
+    void collectLayers(bool includeHiddenLayers, std::unique_ptr<Vector<RenderLayer*>>&, std::unique_ptr<Vector<RenderLayer*>>&, OptionSet<Compositing>&);
     void clearZOrderLists();
 
     void updateNormalFlowList();
 
     struct LayerPaintingInfo {
@@ -1236,12 +1247,12 @@
     bool m_hasCompositedScrollableOverflow : 1;
 
     bool m_hasTransformedAncestor : 1;
     bool m_has3DTransformedAncestor : 1;
 
-    unsigned m_indirectCompositingReason : 3;
-    unsigned m_viewportConstrainedNotCompositedReason : 2;
+    unsigned m_indirectCompositingReason : 4; // IndirectCompositingReason
+    unsigned m_viewportConstrainedNotCompositedReason : 2; // ViewportConstrainedNotCompositedReason
 
 #if PLATFORM(IOS_FAMILY)
 #if ENABLE(IOS_TOUCH_EVENTS)
     bool m_registeredAsTouchEventListenerForScrolling : 1;
 #endif
@@ -1250,16 +1261,16 @@
 
     bool m_requiresScrollPositionReconciliation : 1;
     bool m_containsDirtyOverlayScrollbars : 1;
     bool m_updatingMarqueePosition : 1;
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     bool m_layerListMutationAllowed : 1;
 #endif
 
 #if ENABLE(CSS_COMPOSITING)
-    unsigned m_blendMode : 5;
+    unsigned m_blendMode : 5; // BlendMode
     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
     bool m_hasNotIsolatedBlendingDescendants : 1;
     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
 #endif
 
@@ -1358,11 +1369,11 @@
 inline RenderLayer* RenderLayer::paintOrderParent() const
 {
     return m_isNormalFlowOnly ? m_parent : stackingContext();
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 class LayerListMutationDetector {
 public:
     LayerListMutationDetector(RenderLayer& layer)
         : m_layer(layer)
         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
@@ -1377,11 +1388,11 @@
 
 private:
     RenderLayer& m_layer;
     bool m_previousMutationAllowedState;
 };
-#endif
+#endif // ASSERT_ENABLED
 
 void makeMatrixRenderable(TransformationMatrix&, bool has3DRendering);
 
 bool compositedWithOwnBackingStore(const RenderLayer&);
 

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableAccessData.cpp
@@ -29,12 +29,11 @@
 #if ENABLE(DFG_JIT)
 
 namespace JSC { namespace DFG {
 
 VariableAccessData::VariableAccessData()
-    : m_local(static_cast<VirtualRegister>(std::numeric_limits<int>::min()))
-    , m_prediction(SpecNone)
+    : m_prediction(SpecNone)
     , m_argumentAwarePrediction(SpecNone)
     , m_flags(0)
     , m_shouldNeverUnbox(false)
     , m_structureCheckHoistingFailed(false)
     , m_checkArrayHoistingFailed(false)
@@ -43,14 +42,14 @@
     , m_doubleFormatState(EmptyDoubleFormatState)
 {
     clearVotes();
 }
 
-VariableAccessData::VariableAccessData(VirtualRegister local)
-    : m_local(local)
-    , m_prediction(SpecNone)
+VariableAccessData::VariableAccessData(Operand operand)
+    : m_prediction(SpecNone)
     , m_argumentAwarePrediction(SpecNone)
+    , m_operand(operand)
     , m_flags(0)
     , m_shouldNeverUnbox(false)
     , m_structureCheckHoistingFailed(false)
     , m_checkArrayHoistingFailed(false)
     , m_isProfitableToUnbox(false)
@@ -85,11 +84,11 @@
 
 bool VariableAccessData::shouldUseDoubleFormatAccordingToVote()
 {
     // We don't support this facility for arguments, yet.
     // FIXME: make this work for arguments.
-    if (local().isArgument())
+    if (operand().isArgument())
         return false;
 
     // If the variable is not a number prediction, then this doesn't
     // make any sense.
     if (!isFullNumberSpeculation(prediction())) {
@@ -119,11 +118,11 @@
 
 bool VariableAccessData::tallyVotesForShouldUseDoubleFormat()
 {
     ASSERT(isRoot());
 
-    if (local().isArgument() || shouldNeverUnbox()
+    if (operand().isArgument() || shouldNeverUnbox()
         || (flags() & NodeBytecodeUsesAsArrayIndex))
         return DFG::mergeDoubleFormatState(m_doubleFormatState, NotUsingDoubleFormat);
 
     if (m_doubleFormatState == CantUseDoubleFormat)
         return false;
@@ -174,11 +173,11 @@
     // The hardware has to support it.
     if (!enableInt52())
         return false;
 
     // We punt for machine arguments.
-    if (m_local.isArgument())
+    if (operand().isArgument())
         return false;
 
     // The argument-aware prediction -- which merges all of an (inlined or machine)
     // argument's variable access datas' predictions -- must possibly be Int52Any.
     return isInt32OrInt52Speculation(argumentAwarePrediction());

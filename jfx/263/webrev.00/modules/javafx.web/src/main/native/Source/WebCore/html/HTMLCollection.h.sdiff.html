<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCollection.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLCanvasElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLDialogElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCollection.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37     const Vector&lt;Element*&gt;* findElementsWithId(const AtomString&amp; id) const;
 38     const Vector&lt;Element*&gt;* findElementsWithName(const AtomString&amp; name) const;
 39     const Vector&lt;AtomString&gt;&amp; propertyNames() const { return m_propertyNames; }
 40 
 41     void appendToIdCache(const AtomString&amp; id, Element&amp;);
 42     void appendToNameCache(const AtomString&amp; name, Element&amp;);
 43     void didPopulate();
 44 
 45     size_t memoryCost() const;
 46 
 47 private:
 48     typedef HashMap&lt;AtomStringImpl*, Vector&lt;Element*&gt;&gt; StringToElementsMap;
 49 
 50     const Vector&lt;Element*&gt;* find(const StringToElementsMap&amp;, const AtomString&amp; key) const;
 51     void append(StringToElementsMap&amp;, const AtomString&amp; key, Element&amp;);
 52 
 53     StringToElementsMap m_idMap;
 54     StringToElementsMap m_nameMap;
 55     Vector&lt;AtomString&gt; m_propertyNames;
 56 
<span class="line-modified"> 57 #if !ASSERT_DISABLED</span>
 58     bool m_didPopulate { false };
 59 #endif
 60 };
 61 
 62 // HTMLCollection subclasses NodeList to maintain legacy ObjC API compatibility.
 63 class HTMLCollection : public NodeList {
 64     WTF_MAKE_ISO_ALLOCATED(HTMLCollection);
 65 public:
 66     virtual ~HTMLCollection();
 67 
 68     // DOM API
 69     Element* item(unsigned index) const override = 0; // Tighten return type from NodeList::item().
 70     virtual Element* namedItem(const AtomString&amp; name) const = 0;
 71     const Vector&lt;AtomString&gt;&amp; supportedPropertyNames();
 72     bool isSupportedPropertyName(const String&amp; name);
 73 
 74     // Non-DOM API
 75     Vector&lt;Ref&lt;Element&gt;&gt; namedItems(const AtomString&amp; name) const;
 76     size_t memoryCost() const override;
 77 
</pre>
<hr />
<pre>
137 
138 inline void CollectionNamedElementCache::appendToIdCache(const AtomString&amp; id, Element&amp; element)
139 {
140     append(m_idMap, id, element);
141 }
142 
143 inline void CollectionNamedElementCache::appendToNameCache(const AtomString&amp; name, Element&amp; element)
144 {
145     append(m_nameMap, name, element);
146 }
147 
148 inline size_t CollectionNamedElementCache::memoryCost() const
149 {
150     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
151     // It is safe to access m_idMap.size(), m_nameMap.size(), and m_propertyNames.size() because they don&#39;t chase pointers.
152     return (m_idMap.size() + m_nameMap.size()) * sizeof(Element*) + m_propertyNames.size() * sizeof(AtomString);
153 }
154 
155 inline void CollectionNamedElementCache::didPopulate()
156 {
<span class="line-modified">157 #if !ASSERT_DISABLED</span>
158     m_didPopulate = true;
159 #endif
160     if (size_t cost = memoryCost())
161         reportExtraMemoryAllocatedForCollectionIndexCache(cost);
162 }
163 
164 inline const Vector&lt;Element*&gt;* CollectionNamedElementCache::find(const StringToElementsMap&amp; map, const AtomString&amp; key) const
165 {
166     ASSERT(m_didPopulate);
167     auto it = map.find(key.impl());
168     return it != map.end() ? &amp;it-&gt;value : nullptr;
169 }
170 
171 inline void CollectionNamedElementCache::append(StringToElementsMap&amp; map, const AtomString&amp; key, Element&amp; element)
172 {
173     if (!m_idMap.contains(key.impl()) &amp;&amp; !m_nameMap.contains(key.impl()))
174         m_propertyNames.append(key);
175     map.add(key.impl(), Vector&lt;Element*&gt;()).iterator-&gt;value.append(&amp;element);
176 }
177 
</pre>
</td>
<td>
<hr />
<pre>
 37     const Vector&lt;Element*&gt;* findElementsWithId(const AtomString&amp; id) const;
 38     const Vector&lt;Element*&gt;* findElementsWithName(const AtomString&amp; name) const;
 39     const Vector&lt;AtomString&gt;&amp; propertyNames() const { return m_propertyNames; }
 40 
 41     void appendToIdCache(const AtomString&amp; id, Element&amp;);
 42     void appendToNameCache(const AtomString&amp; name, Element&amp;);
 43     void didPopulate();
 44 
 45     size_t memoryCost() const;
 46 
 47 private:
 48     typedef HashMap&lt;AtomStringImpl*, Vector&lt;Element*&gt;&gt; StringToElementsMap;
 49 
 50     const Vector&lt;Element*&gt;* find(const StringToElementsMap&amp;, const AtomString&amp; key) const;
 51     void append(StringToElementsMap&amp;, const AtomString&amp; key, Element&amp;);
 52 
 53     StringToElementsMap m_idMap;
 54     StringToElementsMap m_nameMap;
 55     Vector&lt;AtomString&gt; m_propertyNames;
 56 
<span class="line-modified"> 57 #if ASSERT_ENABLED</span>
 58     bool m_didPopulate { false };
 59 #endif
 60 };
 61 
 62 // HTMLCollection subclasses NodeList to maintain legacy ObjC API compatibility.
 63 class HTMLCollection : public NodeList {
 64     WTF_MAKE_ISO_ALLOCATED(HTMLCollection);
 65 public:
 66     virtual ~HTMLCollection();
 67 
 68     // DOM API
 69     Element* item(unsigned index) const override = 0; // Tighten return type from NodeList::item().
 70     virtual Element* namedItem(const AtomString&amp; name) const = 0;
 71     const Vector&lt;AtomString&gt;&amp; supportedPropertyNames();
 72     bool isSupportedPropertyName(const String&amp; name);
 73 
 74     // Non-DOM API
 75     Vector&lt;Ref&lt;Element&gt;&gt; namedItems(const AtomString&amp; name) const;
 76     size_t memoryCost() const override;
 77 
</pre>
<hr />
<pre>
137 
138 inline void CollectionNamedElementCache::appendToIdCache(const AtomString&amp; id, Element&amp; element)
139 {
140     append(m_idMap, id, element);
141 }
142 
143 inline void CollectionNamedElementCache::appendToNameCache(const AtomString&amp; name, Element&amp; element)
144 {
145     append(m_nameMap, name, element);
146 }
147 
148 inline size_t CollectionNamedElementCache::memoryCost() const
149 {
150     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
151     // It is safe to access m_idMap.size(), m_nameMap.size(), and m_propertyNames.size() because they don&#39;t chase pointers.
152     return (m_idMap.size() + m_nameMap.size()) * sizeof(Element*) + m_propertyNames.size() * sizeof(AtomString);
153 }
154 
155 inline void CollectionNamedElementCache::didPopulate()
156 {
<span class="line-modified">157 #if ASSERT_ENABLED</span>
158     m_didPopulate = true;
159 #endif
160     if (size_t cost = memoryCost())
161         reportExtraMemoryAllocatedForCollectionIndexCache(cost);
162 }
163 
164 inline const Vector&lt;Element*&gt;* CollectionNamedElementCache::find(const StringToElementsMap&amp; map, const AtomString&amp; key) const
165 {
166     ASSERT(m_didPopulate);
167     auto it = map.find(key.impl());
168     return it != map.end() ? &amp;it-&gt;value : nullptr;
169 }
170 
171 inline void CollectionNamedElementCache::append(StringToElementsMap&amp; map, const AtomString&amp; key, Element&amp; element)
172 {
173     if (!m_idMap.contains(key.impl()) &amp;&amp; !m_nameMap.contains(key.impl()))
174         m_propertyNames.append(key);
175     map.add(key.impl(), Vector&lt;Element*&gt;()).iterator-&gt;value.append(&amp;element);
176 }
177 
</pre>
</td>
</tr>
</table>
<center><a href="HTMLCanvasElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLDialogElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
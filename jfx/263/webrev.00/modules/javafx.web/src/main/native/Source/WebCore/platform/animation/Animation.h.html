<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/animation/Animation.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
  3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;CSSPropertyNames.h&quot;
 28 #include &quot;RenderStyleConstants.h&quot;
 29 #include &quot;StyleScope.h&quot;
 30 #include &quot;TimingFunction.h&quot;
 31 
 32 namespace WebCore {
 33 
 34 class Animation : public RefCounted&lt;Animation&gt; {
 35 public:
 36     WEBCORE_EXPORT ~Animation();
 37 
 38     static Ref&lt;Animation&gt; create() { return adoptRef(*new Animation); }
 39     static Ref&lt;Animation&gt; create(const Animation&amp; other) { return adoptRef(*new Animation(other)); }
 40 
 41     bool isDelaySet() const { return m_delaySet; }
 42     bool isDirectionSet() const { return m_directionSet; }
 43     bool isDurationSet() const { return m_durationSet; }
 44     bool isFillModeSet() const { return m_fillModeSet; }
 45     bool isIterationCountSet() const { return m_iterationCountSet; }
 46     bool isNameSet() const { return m_nameSet; }
 47     bool isPlayStateSet() const { return m_playStateSet; }
 48     bool isPropertySet() const { return m_propertySet; }
 49     bool isTimingFunctionSet() const { return m_timingFunctionSet; }
 50 
 51     // Flags this to be the special &quot;none&quot; animation (animation-name: none)
 52     bool isNoneAnimation() const { return m_isNone; }
 53 
 54     // We can make placeholder Animation objects to keep the comma-separated lists
 55     // of properties in sync. isValidAnimation means this is not a placeholder.
 56     bool isValidAnimation() const { return !m_isNone &amp;&amp; !m_name.isEmpty(); }
 57 
 58     bool isEmpty() const
 59     {
 60         return !m_directionSet &amp;&amp; !m_durationSet &amp;&amp; !m_fillModeSet
 61             &amp;&amp; !m_nameSet &amp;&amp; !m_playStateSet &amp;&amp; !m_iterationCountSet
 62             &amp;&amp; !m_delaySet &amp;&amp; !m_timingFunctionSet &amp;&amp; !m_propertySet;
 63     }
 64 
 65     bool isEmptyOrZeroDuration() const
 66     {
 67         return isEmpty() || (m_duration == 0 &amp;&amp; m_delay &lt;= 0);
 68     }
 69 
 70     void clearDelay() { m_delaySet = false; }
 71     void clearDirection() { m_directionSet = false; }
 72     void clearDuration() { m_durationSet = false; }
 73     void clearFillMode() { m_fillModeSet = false; }
 74     void clearIterationCount() { m_iterationCountSet = false; }
 75     void clearName() { m_nameSet = false; }
 76     void clearPlayState() { m_playStateSet = false; }
 77     void clearProperty() { m_propertySet = false; }
 78     void clearTimingFunction() { m_timingFunctionSet = false; }
 79 
 80     void clearAll()
 81     {
 82         clearDelay();
 83         clearDirection();
 84         clearDuration();
 85         clearFillMode();
 86         clearIterationCount();
 87         clearName();
 88         clearPlayState();
 89         clearProperty();
 90         clearTimingFunction();
 91     }
 92 
 93     double delay() const { return m_delay; }
 94 
 95     enum AnimationMode {
 96         AnimateAll,
 97         AnimateNone,
 98         AnimateSingleProperty,
 99         AnimateUnknownProperty
100     };
101 
102     enum AnimationDirection {
103         AnimationDirectionNormal,
104         AnimationDirectionAlternate,
105         AnimationDirectionReverse,
106         AnimationDirectionAlternateReverse
107     };
108 
109     AnimationDirection direction() const { return static_cast&lt;AnimationDirection&gt;(m_direction); }
110     bool directionIsForwards() const { return m_direction == AnimationDirectionNormal || m_direction == AnimationDirectionAlternate; }
111 
112     AnimationFillMode fillMode() const { return static_cast&lt;AnimationFillMode&gt;(m_fillMode); }
113 
114     double duration() const { return m_duration; }
115 
116     enum { IterationCountInfinite = -1 };
117     double iterationCount() const { return m_iterationCount; }
118     const String&amp; name() const { return m_name; }
119     Style::ScopeOrdinal nameStyleScopeOrdinal() const { return m_nameStyleScopeOrdinal; }
120     AnimationPlayState playState() const { return static_cast&lt;AnimationPlayState&gt;(m_playState); }
121     CSSPropertyID property() const { return m_property; }
122     const String&amp; unknownProperty() const { return m_unknownProperty; }
123     TimingFunction* timingFunction() const { return m_timingFunction.get(); }
124     AnimationMode animationMode() const { return static_cast&lt;AnimationMode&gt;(m_mode); }
125 
126     void setDelay(double c) { m_delay = c; m_delaySet = true; }
127     void setDirection(AnimationDirection d) { m_direction = d; m_directionSet = true; }
128     void setDuration(double d) { ASSERT(d &gt;= 0); m_duration = d; m_durationSet = true; }
129     void setFillMode(AnimationFillMode f) { m_fillMode = static_cast&lt;unsigned&gt;(f); m_fillModeSet = true; }
130     void setIterationCount(double c) { m_iterationCount = c; m_iterationCountSet = true; }
131     void setName(const String&amp; name, Style::ScopeOrdinal scope = Style::ScopeOrdinal::Element)
132     {
133         m_name = name;
134         m_nameStyleScopeOrdinal = scope;
135         m_nameSet = true;
136     }
137     void setPlayState(AnimationPlayState d) { m_playState = static_cast&lt;unsigned&gt;(d); m_playStateSet = true; }
138     void setProperty(CSSPropertyID t) { m_property = t; m_propertySet = true; }
139     void setUnknownProperty(const String&amp; property) { m_unknownProperty = property; }
140     void setTimingFunction(RefPtr&lt;TimingFunction&gt;&amp;&amp; function) { m_timingFunction = WTFMove(function); m_timingFunctionSet = true; }
141     void setAnimationMode(AnimationMode mode) { m_mode = static_cast&lt;unsigned&gt;(mode); }
142 
143     void setIsNoneAnimation(bool n) { m_isNone = n; }
144 
145     Animation&amp; operator=(const Animation&amp; o);
146 
147     // return true if all members of this class match (excluding m_next)
148     bool animationsMatch(const Animation&amp;, bool matchProperties = true) const;
149 
150     // return true every Animation in the chain (defined by m_next) match
151     bool operator==(const Animation&amp; o) const { return animationsMatch(o); }
152     bool operator!=(const Animation&amp; o) const { return !(*this == o); }
153 
154     bool fillsBackwards() const { return m_fillModeSet &amp;&amp; (fillMode() == AnimationFillMode::Backwards || fillMode() == AnimationFillMode::Both); }
155     bool fillsForwards() const { return m_fillModeSet &amp;&amp; (fillMode() == AnimationFillMode::Forwards || fillMode() == AnimationFillMode::Both); }
156 
157 private:
158     WEBCORE_EXPORT Animation();
159     Animation(const Animation&amp; o);
160 
161     // Packs with m_refCount from the base class.
162     CSSPropertyID m_property { CSSPropertyInvalid };
163 
164     String m_name;
165     String m_unknownProperty;
166     double m_iterationCount;
167     double m_delay;
168     double m_duration;
169     RefPtr&lt;TimingFunction&gt; m_timingFunction;
170 
171     Style::ScopeOrdinal m_nameStyleScopeOrdinal { Style::ScopeOrdinal::Element };
172 
173     unsigned m_mode : 2; // AnimationMode
174     unsigned m_direction : 2; // AnimationDirection
175     unsigned m_fillMode : 2; // AnimationFillMode
176     unsigned m_playState : 2; // AnimationPlayState
177 
178     bool m_delaySet : 1;
179     bool m_directionSet : 1;
180     bool m_durationSet : 1;
181     bool m_fillModeSet : 1;
182     bool m_iterationCountSet : 1;
183     bool m_nameSet : 1;
184     bool m_playStateSet : 1;
185     bool m_propertySet : 1;
186     bool m_timingFunctionSet : 1;
187 
188     bool m_isNone : 1;
189 
190 public:
191     static double initialDelay() { return 0; }
192     static AnimationDirection initialDirection() { return AnimationDirectionNormal; }
193     static double initialDuration() { return 0; }
194     static AnimationFillMode initialFillMode() { return AnimationFillMode::None; }
195     static double initialIterationCount() { return 1.0; }
196     static const String&amp; initialName();
197     static AnimationPlayState initialPlayState() { return AnimationPlayState::Playing; }
198     static CSSPropertyID initialProperty() { return CSSPropertyInvalid; }
199     static Ref&lt;TimingFunction&gt; initialTimingFunction() { return CubicBezierTimingFunction::create(); }
200 };
201 
202 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, AnimationPlayState);
203 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, Animation::AnimationMode);
204 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, Animation::AnimationDirection);
205 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Animation&amp;);
206 
207 } // namespace WebCore
    </pre>
  </body>
</html>
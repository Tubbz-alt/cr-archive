<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirInst.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirArg.h&quot;
 31 #include &quot;AirKind.h&quot;
 32 #include &quot;MacroAssembler.h&quot;
 33 #include &lt;wtf/ScopedLambda.h&gt;
 34 
 35 namespace JSC {
 36 
 37 class CCallHelpers;
 38 class RegisterSet;
 39 
 40 namespace B3 {
 41 
 42 class Value;
 43 
 44 namespace Air {
 45 
 46 struct GenerationContext;
 47 
 48 struct Inst {
 49     typedef Vector&lt;Arg, 3&gt; ArgList;
 50 
 51     Inst()
 52         : origin(nullptr)
 53     {
 54     }
 55 
 56     Inst(Kind kind, Value* origin)
 57         : origin(origin)
 58         , kind(kind)
 59     {
 60     }
 61 
 62     template&lt;typename... Arguments&gt;
 63     Inst(Kind kind, Value* origin, Arg arg, Arguments... arguments)
 64         : args{ arg, arguments... }
 65         , origin(origin)
 66         , kind(kind)
 67     {
 68     }
 69 
 70     Inst(Kind kind, Value* origin, const ArgList&amp; arguments)
 71         : args(arguments)
 72         , origin(origin)
 73         , kind(kind)
 74     {
 75     }
 76 
 77     Inst(Kind kind, Value* origin, ArgList&amp;&amp; arguments)
 78         : args(WTFMove(arguments))
 79         , origin(origin)
 80         , kind(kind)
 81     {
 82     }
 83 
 84     explicit operator bool() const { return origin || kind || args.size(); }
 85 
 86     void append() { }
 87 
 88     template&lt;typename... Arguments&gt;
 89     void append(Arg arg, Arguments... arguments)
 90     {
 91         args.append(arg);
 92         append(arguments...);
 93     }
 94 
 95     // Note that these functors all avoid using &quot;const&quot; because we want to use them for things that
 96     // edit IR. IR is meant to be edited; if you&#39;re carrying around a &quot;const Inst&amp;&quot; then you&#39;re
 97     // probably doing it wrong.
 98 
 99     // This only walks those Tmps that are explicitly mentioned, and it doesn&#39;t tell you their role
100     // or type.
101     template&lt;typename Functor&gt;
102     void forEachTmpFast(const Functor&amp; functor)
103     {
104         for (Arg&amp; arg : args)
105             arg.forEachTmpFast(functor);
106     }
107 
108     typedef void EachArgCallback(Arg&amp;, Arg::Role, Bank, Width);
109 
110     // Calls the functor with (arg, role, type, width). This function is auto-generated by
111     // opcode_generator.rb.
112     template&lt;typename Functor&gt;
113     void forEachArg(const Functor&amp;);
114 
115     // Calls the functor with (tmp, role, type, width).
116     template&lt;typename Functor&gt;
117     void forEachTmp(const Functor&amp; functor)
118     {
119         forEachArg(
120             [&amp;] (Arg&amp; arg, Arg::Role role, Bank bank, Width width) {
121                 arg.forEachTmp(role, bank, width, functor);
122             });
123     }
124 
125     // Thing can be either Arg, Tmp, or StackSlot*.
126     template&lt;typename Thing, typename Functor&gt;
127     void forEach(const Functor&amp;);
128 
129     // Reports any additional registers clobbered by this operation. Note that for efficiency,
130     // extraClobberedRegs() only works for the Patch opcode.
131     RegisterSet extraClobberedRegs();
132     RegisterSet extraEarlyClobberedRegs();
133 
134     // Iterate over all Def&#39;s that happen at the end of an instruction. You supply a pair
135     // instructions. The instructions must appear next to each other, in that order, in some basic
136     // block. You can pass null for the first instruction when analyzing what happens at the top of
137     // a basic block. You can pass null for the second instruction when analyzing what happens at the
138     // bottom of a basic block.
139     template&lt;typename Thing, typename Functor&gt;
140     static void forEachDef(Inst* prevInst, Inst* nextInst, const Functor&amp;);
141 
142     // Iterate over all Def&#39;s that happen at the end of this instruction, including extra clobbered
143     // registers. Note that Thing can only be Arg or Tmp when you use this functor.
144     template&lt;typename Thing, typename Functor&gt;
145     static void forEachDefWithExtraClobberedRegs(Inst* prevInst, Inst* nextInst, const Functor&amp;);
146 
147     // Some summaries about all arguments. These are useful for needsPadding().
148     bool hasEarlyDef();
149     bool hasLateUseOrDef();
150 
151     // Check if there needs to be a padding Nop between these two instructions.
152     static bool needsPadding(Inst* prevInst, Inst* nextInst);
153 
154     // Use this to report which registers are live. This should be done just before codegen. Note
155     // that for efficiency, reportUsedRegisters() only works for the Patch opcode.
156     void reportUsedRegisters(const RegisterSet&amp;);
157 
158     // Is this instruction in one of the valid forms right now? This function is auto-generated by
159     // opcode_generator.rb.
160     bool isValidForm();
161 
162     // Assuming this instruction is in a valid form right now, will it still be in one of the valid
163     // forms if we put an Addr referencing the stack (or a StackSlot or CallArg, of course) in the
164     // given index? Spilling uses this: it walks the args by index to find Tmps that need spilling;
165     // if it finds one, it calls this to see if it can replace the Arg::Tmp with an Arg::Addr. If it
166     // finds a non-Tmp Arg, then it calls that Arg&#39;s forEachTmp to do a replacement that way.
167     //
168     // This function is auto-generated by opcode_generator.rb.
169     bool admitsStack(unsigned argIndex);
170     bool admitsStack(Arg&amp;);
171 
172     bool admitsExtendedOffsetAddr(unsigned argIndex);
173     bool admitsExtendedOffsetAddr(Arg&amp;);
174 
175     // Defined by opcode_generator.rb.
176     bool isTerminal();
177 
178     // Returns true if this instruction can have any effects other than control flow or arguments.
179     bool hasNonArgNonControlEffects();
180 
181     // Returns true if this instruction can have any effects other than what is implied by arguments.
182     // For example, &quot;Move $42, (%rax)&quot; will return false because the effect of storing to (%rax) is
183     // implied by the second argument.
184     bool hasNonArgEffects();
185 
186     // Tells you if this operation has arg effects.
187     bool hasArgEffects();
188 
189     // Tells you if this operation has non-control effects.
190     bool hasNonControlEffects() { return hasNonArgNonControlEffects() || hasArgEffects(); }
191 
192     // Generate some code for this instruction. This is, like, literally our backend. If this is the
193     // terminal, it returns the jump that needs to be linked for the &quot;then&quot; case, with the &quot;else&quot;
194     // case being fall-through. This function is auto-generated by opcode_generator.rb.
195     MacroAssembler::Jump generate(CCallHelpers&amp;, GenerationContext&amp;);
196 
197     // If source arguments benefits from being aliased to a destination argument,
198     // this return the index of the destination argument.
199     // The source are assumed to be at (index - 1) and (index - 2)
200     // For example,
201     //     Add Tmp1, Tmp2, Tmp3
202     // returns 2 if 0 and 1 benefit from aliasing to Tmp3.
203     Optional&lt;unsigned&gt; shouldTryAliasingDef();
204 
205     // This computes a hash for comparing this to JSAir&#39;s Inst.
206     unsigned jsHash() const;
207 
208     void dump(PrintStream&amp;) const;
209 
210     ArgList args;
211     Value* origin; // The B3::Value that this originated from.
212     Kind kind;
213 
214 private:
215     template&lt;typename Func&gt;
216     void forEachArgSimple(const Func&amp;);
217     void forEachArgCustom(ScopedLambda&lt;EachArgCallback&gt;);
218 };
219 
220 } } } // namespace JSC::B3::Air
221 
222 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
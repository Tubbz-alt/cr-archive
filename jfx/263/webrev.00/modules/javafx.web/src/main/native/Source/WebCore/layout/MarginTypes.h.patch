diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/MarginTypes.h b/modules/javafx.web/src/main/native/Source/WebCore/layout/MarginTypes.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/MarginTypes.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/MarginTypes.h
@@ -73,17 +73,23 @@
 struct UsedHorizontalMargin {
     LayoutUnit start;
     LayoutUnit end;
 };
 
-struct EstimatedMarginBefore {
+struct PrecomputedMarginBefore {
     LayoutUnit usedValue() const { return collapsedValue.valueOr(nonCollapsedValue); }
     LayoutUnit nonCollapsedValue;
     Optional<LayoutUnit> collapsedValue;
     bool isCollapsedThrough { false };
 };
 
+// FIXME: This structure might need to change to indicate that the cached value is not necessarily the same as the box's computed margin value.
+// This only matters in case of collapse through margins when they collapse into another sibling box.
+// <div style="margin: 1px"></div><div style="margin: 10px"></div> <- the second div's before/after marings collapse through and the same time they collapse into
+// the first div. When the parent computes its before margin, it should see the second div's collapsed through margin as the value to collapse width (adjoining margin value).
+// So while the first div's before margin is not 10px, the cached value is 10px so that when we compute the parent's margin we just need to check the fist
+// inflow child's cached margin value.
 struct PositiveAndNegativeVerticalMargin {
     struct Values {
         bool isNonZero() const { return positive.valueOr(0) || negative.valueOr(0); }
 
         Optional<LayoutUnit> positive;

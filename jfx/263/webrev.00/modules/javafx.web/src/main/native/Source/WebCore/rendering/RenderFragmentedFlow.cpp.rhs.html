<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1. Redistributions of source code must retain the above
   9  *    copyright notice, this list of conditions and the following
  10  *    disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above
  12  *    copyright notice, this list of conditions and the following
  13  *    disclaimer in the documentation and/or other materials
  14  *    provided with the distribution.
  15  *
  16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
  20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  27  * SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;RenderFragmentedFlow.h&quot;
  32 
  33 #include &quot;HitTestRequest.h&quot;
  34 #include &quot;HitTestResult.h&quot;
  35 #include &quot;InlineElementBox.h&quot;
  36 #include &quot;Node.h&quot;
<a name="1" id="anc1"></a>
  37 #include &quot;RenderBoxFragmentInfo.h&quot;
  38 #include &quot;RenderFragmentContainer.h&quot;
  39 #include &quot;RenderInline.h&quot;
  40 #include &quot;RenderLayer.h&quot;
  41 #include &quot;RenderLayerCompositor.h&quot;
  42 #include &quot;RenderLayoutState.h&quot;
  43 #include &quot;RenderTableCell.h&quot;
  44 #include &quot;RenderTableSection.h&quot;
  45 #include &quot;RenderTheme.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;TransformState.h&quot;
  48 #include &lt;wtf/IsoMallocInlines.h&gt;
  49 #include &lt;wtf/StackStats.h&gt;
  50 
  51 namespace WebCore {
  52 
  53 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFragmentedFlow);
  54 
  55 RenderFragmentedFlow::RenderFragmentedFlow(Document&amp; document, RenderStyle&amp;&amp; style)
  56     : RenderBlockFlow(document, WTFMove(style))
  57     , m_currentFragmentMaintainer(nullptr)
  58     , m_fragmentsInvalidated(false)
  59     , m_fragmentsHaveUniformLogicalWidth(true)
  60     , m_fragmentsHaveUniformLogicalHeight(true)
  61     , m_pageLogicalSizeChanged(false)
  62 {
  63     setIsRenderFragmentedFlow(true);
  64 }
  65 
  66 void RenderFragmentedFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
  67 {
  68     RenderBlockFlow::styleDidChange(diff, oldStyle);
  69 
  70     if (oldStyle &amp;&amp; oldStyle-&gt;writingMode() != style().writingMode())
  71         invalidateFragments();
  72 }
  73 
  74 void RenderFragmentedFlow::removeFlowChildInfo(RenderElement&amp; child)
  75 {
  76     if (is&lt;RenderBlockFlow&gt;(child))
  77         removeLineFragmentInfo(downcast&lt;RenderBlockFlow&gt;(child));
  78     if (is&lt;RenderBox&gt;(child))
  79         removeRenderBoxFragmentInfo(downcast&lt;RenderBox&gt;(child));
  80 }
  81 
  82 void RenderFragmentedFlow::removeFragmentFromThread(RenderFragmentContainer* RenderFragmentContainer)
  83 {
  84     ASSERT(RenderFragmentContainer);
  85     m_fragmentList.remove(RenderFragmentContainer);
  86 }
  87 
  88 void RenderFragmentedFlow::invalidateFragments(MarkingBehavior markingParents)
  89 {
  90     if (m_fragmentsInvalidated) {
  91         ASSERT(selfNeedsLayout());
  92         return;
  93     }
  94 
  95     m_fragmentRangeMap.clear();
  96     m_breakBeforeToFragmentMap.clear();
  97     m_breakAfterToFragmentMap.clear();
  98     if (m_lineToFragmentMap)
  99         m_lineToFragmentMap-&gt;clear();
 100     setNeedsLayout(markingParents);
 101 
 102     m_fragmentsInvalidated = true;
 103 }
 104 
 105 void RenderFragmentedFlow::validateFragments()
 106 {
 107     if (m_fragmentsInvalidated) {
 108         m_fragmentsInvalidated = false;
 109         m_fragmentsHaveUniformLogicalWidth = true;
 110         m_fragmentsHaveUniformLogicalHeight = true;
 111 
 112         if (hasFragments()) {
 113             LayoutUnit previousFragmentLogicalWidth;
 114             LayoutUnit previousFragmentLogicalHeight;
 115             bool firstFragmentVisited = false;
 116 
 117             for (auto&amp; fragment : m_fragmentList) {
 118                 ASSERT(!fragment-&gt;needsLayout() || fragment-&gt;isRenderFragmentContainerSet());
 119 
 120                 fragment-&gt;deleteAllRenderBoxFragmentInfo();
 121 
 122                 LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
 123                 LayoutUnit fragmentLogicalHeight = fragment-&gt;pageLogicalHeight();
 124 
 125                 if (!firstFragmentVisited)
 126                     firstFragmentVisited = true;
 127                 else {
 128                     if (m_fragmentsHaveUniformLogicalWidth &amp;&amp; previousFragmentLogicalWidth != fragmentLogicalWidth)
 129                         m_fragmentsHaveUniformLogicalWidth = false;
 130                     if (m_fragmentsHaveUniformLogicalHeight &amp;&amp; previousFragmentLogicalHeight != fragmentLogicalHeight)
 131                         m_fragmentsHaveUniformLogicalHeight = false;
 132                 }
 133 
 134                 previousFragmentLogicalWidth = fragmentLogicalWidth;
 135             }
 136 
 137             setFragmentRangeForBox(*this, m_fragmentList.first(), m_fragmentList.last());
 138         }
 139     }
 140 
 141     updateLogicalWidth(); // Called to get the maximum logical width for the fragment.
 142     updateFragmentsFragmentedFlowPortionRect();
 143 }
 144 
 145 void RenderFragmentedFlow::layout()
 146 {
 147     StackStats::LayoutCheckPoint layoutCheckPoint;
 148 
 149     m_pageLogicalSizeChanged = m_fragmentsInvalidated &amp;&amp; everHadLayout();
 150 
 151     validateFragments();
 152 
 153     RenderBlockFlow::layout();
 154 
 155     m_pageLogicalSizeChanged = false;
 156 }
 157 
 158 void RenderFragmentedFlow::updateLogicalWidth()
 159 {
 160     LayoutUnit logicalWidth = initialLogicalWidth();
 161     for (auto&amp; fragment : m_fragmentList) {
 162         ASSERT(!fragment-&gt;needsLayout() || fragment-&gt;isRenderFragmentContainerSet());
 163         logicalWidth = std::max(fragment-&gt;pageLogicalWidth(), logicalWidth);
 164     }
 165     setLogicalWidth(logicalWidth);
 166 
 167     // If the fragments have non-uniform logical widths, then insert inset information for the RenderFragmentedFlow.
 168     for (auto&amp; fragment : m_fragmentList) {
 169         LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
 170         LayoutUnit logicalLeft = style().direction() == TextDirection::LTR ? 0_lu : logicalWidth - fragmentLogicalWidth;
 171         fragment-&gt;setRenderBoxFragmentInfo(this, logicalLeft, fragmentLogicalWidth, false);
 172     }
 173 }
 174 
 175 RenderBox::LogicalExtentComputedValues RenderFragmentedFlow::computeLogicalHeight(LayoutUnit, LayoutUnit logicalTop) const
 176 {
 177     LogicalExtentComputedValues computedValues;
 178     computedValues.m_position = logicalTop;
 179     computedValues.m_extent = 0;
 180 
 181     const LayoutUnit maxFlowSize = RenderFragmentedFlow::maxLogicalHeight();
 182     for (auto&amp; fragment : m_fragmentList) {
 183         ASSERT(!fragment-&gt;needsLayout() || fragment-&gt;isRenderFragmentContainerSet());
 184 
 185         LayoutUnit distanceToMaxSize = maxFlowSize - computedValues.m_extent;
 186         computedValues.m_extent += std::min(distanceToMaxSize, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
 187 
 188         // If we reached the maximum size there&#39;s no point in going further.
 189         if (computedValues.m_extent == maxFlowSize)
 190             return computedValues;
 191     }
 192     return computedValues;
 193 }
 194 
 195 bool RenderFragmentedFlow::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
 196 {
 197     if (hitTestAction == HitTestBlockBackground)
 198         return false;
 199     return RenderBlockFlow::nodeAtPoint(request, result, locationInContainer, accumulatedOffset, hitTestAction);
 200 }
 201 
 202 bool RenderFragmentedFlow::shouldRepaint(const LayoutRect&amp; r) const
 203 {
 204     if (view().printing() || r.isEmpty())
 205         return false;
 206 
 207     return true;
 208 }
 209 
 210 void RenderFragmentedFlow::repaintRectangleInFragments(const LayoutRect&amp; repaintRect) const
 211 {
 212     if (!shouldRepaint(repaintRect) || !hasValidFragmentInfo())
 213         return;
 214 
 215     LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext()); // We can&#39;t use layout state to repaint, since the fragments are somewhere else.
 216 
 217     for (auto&amp; fragment : m_fragmentList)
 218         fragment-&gt;repaintFragmentedFlowContent(repaintRect);
 219 }
 220 
<a name="2" id="anc2"></a><span class="line-added"> 221 class RenderFragmentedFlow::FragmentSearchAdapter {</span>
<span class="line-added"> 222 public:</span>
<span class="line-added"> 223     explicit FragmentSearchAdapter(LayoutUnit offset)</span>
<span class="line-added"> 224         : m_offset(offset)</span>
<span class="line-added"> 225     {</span>
<span class="line-added"> 226     }</span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228     const LayoutUnit&amp; lowValue() const { return m_offset; }</span>
<span class="line-added"> 229     const LayoutUnit&amp; highValue() const { return m_offset; }</span>
<span class="line-added"> 230 </span>
<span class="line-added"> 231     void collectIfNeeded(const PODInterval&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt;&amp; interval)</span>
<span class="line-added"> 232     {</span>
<span class="line-added"> 233         if (m_result)</span>
<span class="line-added"> 234             return;</span>
<span class="line-added"> 235         if (interval.low() &lt;= m_offset &amp;&amp; interval.high() &gt; m_offset)</span>
<span class="line-added"> 236             m_result = interval.data();</span>
<span class="line-added"> 237     }</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     RenderFragmentContainer* result() const { return m_result.get(); }</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241 private:</span>
<span class="line-added"> 242     LayoutUnit m_offset;</span>
<span class="line-added"> 243     WeakPtr&lt;RenderFragmentContainer&gt; m_result;</span>
<span class="line-added"> 244 };</span>
<span class="line-added"> 245 </span>
 246 RenderFragmentContainer* RenderFragmentedFlow::fragmentAtBlockOffset(const RenderBox* clampBox, LayoutUnit offset, bool extendLastFragment) const
 247 {
 248     ASSERT(!m_fragmentsInvalidated);
 249 
 250     if (m_fragmentList.isEmpty())
 251         return nullptr;
 252 
 253     if (m_fragmentList.size() == 1 &amp;&amp; extendLastFragment)
 254         return m_fragmentList.first();
 255 
<a name="3" id="anc3"></a><span class="line-added"> 256     auto clamp = [clampBox](RenderFragmentContainer* fragment)  {</span>
<span class="line-added"> 257         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(fragment) : fragment;</span>
<span class="line-added"> 258     };</span>
<span class="line-added"> 259 </span>
 260     if (offset &lt;= 0)
<a name="4" id="anc4"></a><span class="line-modified"> 261         return clamp(m_fragmentList.first());</span>
 262 
 263     FragmentSearchAdapter adapter(offset);
<a name="5" id="anc5"></a><span class="line-modified"> 264     m_fragmentIntervalTree.allOverlapsWithAdapter(adapter);</span>
<span class="line-added"> 265     if (auto* fragment = adapter.result())</span>
<span class="line-added"> 266         return clamp(fragment);</span>
 267 
 268     // If no fragment was found, the offset is in the flow thread overflow.
 269     // The last fragment will contain the offset if extendLastFragment is set or if the last fragment is a set.
<a name="6" id="anc6"></a><span class="line-modified"> 270     if (extendLastFragment || m_fragmentList.last()-&gt;isRenderFragmentContainerSet())</span>
<span class="line-modified"> 271         return clamp(m_fragmentList.last());</span>
 272 
<a name="7" id="anc7"></a><span class="line-modified"> 273     return nullptr;</span>



 274 }
 275 
 276 LayoutPoint RenderFragmentedFlow::adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp; boxModelObject, const LayoutPoint&amp; startPoint) const
 277 {
 278     LayoutPoint referencePoint = startPoint;
 279 
 280     const RenderBlock* objContainingBlock = boxModelObject.containingBlock();
 281     // FIXME: This needs to be adapted for different writing modes inside the flow thread.
 282     RenderFragmentContainer* startFragment = fragmentAtBlockOffset(objContainingBlock, referencePoint.y());
 283     if (startFragment) {
 284         // Take into account the offset coordinates of the fragment.
 285         RenderBoxModelObject* startFragmentBox = startFragment;
 286         RenderBoxModelObject* currObject = startFragmentBox;
 287         RenderBoxModelObject* currOffsetParent;
 288         while ((currOffsetParent = currObject-&gt;offsetParent())) {
 289             referencePoint.move(currObject-&gt;offsetLeft(), currObject-&gt;offsetTop());
 290 
 291             // Since we&#39;re looking for the offset relative to the body, we must also
 292             // take into consideration the borders of the fragment&#39;s offsetParent.
 293             if (is&lt;RenderBox&gt;(*currOffsetParent) &amp;&amp; !currOffsetParent-&gt;isBody())
 294                 referencePoint.move(downcast&lt;RenderBox&gt;(*currOffsetParent).borderLeft(), downcast&lt;RenderBox&gt;(*currOffsetParent).borderTop());
 295 
 296             currObject = currOffsetParent;
 297         }
 298 
 299         // We need to check if any of this box&#39;s containing blocks start in a different fragment
 300         // and if so, drop the object&#39;s top position (which was computed relative to its containing block
 301         // and is no longer valid) and recompute it using the fragment in which it flows as reference.
 302         bool wasComputedRelativeToOtherFragment = false;
 303         while (objContainingBlock &amp;&amp; !is&lt;RenderView&gt;(*objContainingBlock)) {
 304             // Check if this object is in a different fragment.
 305             RenderFragmentContainer* parentStartFragment = nullptr;
 306             RenderFragmentContainer* parentEndFragment = nullptr;
 307             if (getFragmentRangeForBox(objContainingBlock, parentStartFragment, parentEndFragment) &amp;&amp; parentStartFragment != startFragment) {
 308                 wasComputedRelativeToOtherFragment = true;
 309                 break;
 310             }
 311             objContainingBlock = objContainingBlock-&gt;containingBlock();
 312         }
 313 
 314         if (wasComputedRelativeToOtherFragment) {
 315             if (is&lt;RenderBox&gt;(boxModelObject)) {
 316                 // Use borderBoxRectInFragment to account for variations such as percentage margins.
 317                 LayoutRect borderBoxRect = downcast&lt;RenderBox&gt;(boxModelObject).borderBoxRectInFragment(startFragment, RenderBox::DoNotCacheRenderBoxFragmentInfo);
 318                 referencePoint.move(borderBoxRect.location().x(), 0_lu);
 319             }
 320 
 321             // Get the logical top coordinate of the current object.
 322             LayoutUnit top;
 323             if (is&lt;RenderBlock&gt;(boxModelObject))
 324                 top = downcast&lt;RenderBlock&gt;(boxModelObject).offsetFromLogicalTopOfFirstPage();
 325             else {
 326                 if (boxModelObject.containingBlock())
 327                     top = boxModelObject.containingBlock()-&gt;offsetFromLogicalTopOfFirstPage();
 328 
 329                 if (is&lt;RenderBox&gt;(boxModelObject))
 330                     top += downcast&lt;RenderBox&gt;(boxModelObject).topLeftLocation().y();
 331                 else if (is&lt;RenderInline&gt;(boxModelObject))
 332                     top -= downcast&lt;RenderInline&gt;(boxModelObject).borderTop();
 333             }
 334 
 335             // Get the logical top of the fragment this object starts in
 336             // and compute the object&#39;s top, relative to the fragment&#39;s top.
 337             LayoutUnit fragmentLogicalTop = startFragment-&gt;pageLogicalTopForOffset(top);
 338             LayoutUnit topRelativeToFragment = top - fragmentLogicalTop;
 339             referencePoint.setY(startFragmentBox-&gt;offsetTop() + topRelativeToFragment);
 340 
 341             // Since the top has been overridden, check if the
 342             // relative/sticky positioning must be reconsidered.
 343             if (boxModelObject.isRelativelyPositioned())
 344                 referencePoint.move(0_lu, boxModelObject.relativePositionOffset().height());
 345             else if (boxModelObject.isStickilyPositioned())
 346                 referencePoint.move(0_lu, boxModelObject.stickyPositionOffset().height());
 347         }
 348 
 349         // Since we&#39;re looking for the offset relative to the body, we must also
 350         // take into consideration the borders of the fragment.
 351         referencePoint.move(startFragmentBox-&gt;borderLeft(), startFragmentBox-&gt;borderTop());
 352     }
 353 
 354     return referencePoint;
 355 }
 356 
 357 LayoutUnit RenderFragmentedFlow::pageLogicalTopForOffset(LayoutUnit offset) const
 358 {
 359     RenderFragmentContainer* fragment = fragmentAtBlockOffset(0, offset, false);
 360     return fragment ? fragment-&gt;pageLogicalTopForOffset(offset) : 0_lu;
 361 }
 362 
 363 LayoutUnit RenderFragmentedFlow::pageLogicalWidthForOffset(LayoutUnit offset) const
 364 {
 365     RenderFragmentContainer* fragment = fragmentAtBlockOffset(0, offset, true);
 366     return fragment ? fragment-&gt;pageLogicalWidth() : contentLogicalWidth();
 367 }
 368 
 369 LayoutUnit RenderFragmentedFlow::pageLogicalHeightForOffset(LayoutUnit offset) const
 370 {
 371     RenderFragmentContainer* fragment = fragmentAtBlockOffset(0, offset, false);
 372     if (!fragment)
 373         return 0;
 374 
 375     return fragment-&gt;pageLogicalHeight();
 376 }
 377 
 378 LayoutUnit RenderFragmentedFlow::pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule pageBoundaryRule) const
 379 {
 380     RenderFragmentContainer* fragment = fragmentAtBlockOffset(0, offset, false);
 381     if (!fragment)
 382         return 0;
 383 
 384     LayoutUnit pageLogicalTop = fragment-&gt;pageLogicalTopForOffset(offset);
 385     LayoutUnit pageLogicalHeight = fragment-&gt;pageLogicalHeight();
 386     LayoutUnit pageLogicalBottom = pageLogicalTop + pageLogicalHeight;
 387     LayoutUnit remainingHeight = pageLogicalBottom - offset;
 388     if (pageBoundaryRule == IncludePageBoundary) {
 389         // If IncludePageBoundary is set, the line exactly on the top edge of a
 390         // fragment will act as being part of the previous fragment.
 391         remainingHeight = intMod(remainingHeight, pageLogicalHeight);
 392     }
 393     return remainingHeight;
 394 }
 395 
 396 RenderFragmentContainer* RenderFragmentedFlow::mapFromFlowToFragment(TransformState&amp; transformState) const
 397 {
 398     if (!hasValidFragmentInfo())
 399         return nullptr;
 400 
 401     RenderFragmentContainer* RenderFragmentContainer = currentFragment();
 402     if (!RenderFragmentContainer) {
 403         LayoutRect boxRect = transformState.mappedQuad().enclosingBoundingBox();
 404         flipForWritingMode(boxRect);
 405 
 406         LayoutPoint center = boxRect.center();
 407         RenderFragmentContainer = fragmentAtBlockOffset(this, isHorizontalWritingMode() ? center.y() : center.x(), true);
 408         if (!RenderFragmentContainer)
 409             return nullptr;
 410     }
 411 
 412     LayoutRect flippedFragmentRect(RenderFragmentContainer-&gt;fragmentedFlowPortionRect());
 413     flipForWritingMode(flippedFragmentRect);
 414 
 415     transformState.move(RenderFragmentContainer-&gt;contentBoxRect().location() - flippedFragmentRect.location());
 416 
 417     return RenderFragmentContainer;
 418 }
 419 
 420 void RenderFragmentedFlow::removeRenderBoxFragmentInfo(RenderBox&amp; box)
 421 {
 422     if (!hasFragments())
 423         return;
 424 
 425     // If the fragment chain was invalidated the next layout will clear the box information from all the fragments.
 426     if (m_fragmentsInvalidated) {
 427         ASSERT(selfNeedsLayout());
 428         return;
 429     }
 430 
 431     RenderFragmentContainer* startFragment = nullptr;
 432     RenderFragmentContainer* endFragment = nullptr;
 433     if (getFragmentRangeForBox(&amp;box, startFragment, endFragment)) {
 434         for (auto it = m_fragmentList.find(startFragment), end = m_fragmentList.end(); it != end; ++it) {
 435             RenderFragmentContainer* fragment = *it;
 436             fragment-&gt;removeRenderBoxFragmentInfo(box);
 437             if (fragment == endFragment)
 438                 break;
 439         }
 440     }
 441 
 442 #ifndef NDEBUG
 443     // We have to make sure we did not leave any RenderBoxFragmentInfo attached.
 444     for (auto&amp; fragment : m_fragmentList)
 445         ASSERT(!fragment-&gt;renderBoxFragmentInfo(&amp;box));
 446 #endif
 447 
 448     m_fragmentRangeMap.remove(&amp;box);
 449 }
 450 
 451 void RenderFragmentedFlow::removeLineFragmentInfo(const RenderBlockFlow&amp; blockFlow)
 452 {
 453     if (!m_lineToFragmentMap || blockFlow.lineLayoutPath() == SimpleLinesPath)
 454         return;
 455 
 456     for (auto* curr = blockFlow.firstRootBox(); curr; curr = curr-&gt;nextRootBox())
 457         m_lineToFragmentMap-&gt;remove(curr);
 458 
 459     ASSERT_WITH_SECURITY_IMPLICATION(checkLinesConsistency(blockFlow));
 460 }
 461 
 462 void RenderFragmentedFlow::logicalWidthChangedInFragmentsForBlock(const RenderBlock* block, bool&amp; relayoutChildren)
 463 {
 464     if (!hasValidFragmentInfo())
 465         return;
 466 
 467     auto it = m_fragmentRangeMap.find(block);
 468     if (it == m_fragmentRangeMap.end())
 469         return;
 470 
 471     RenderFragmentContainerRange&amp; range = it-&gt;value;
 472     bool rangeInvalidated = range.rangeInvalidated();
 473     range.clearRangeInvalidated();
 474 
 475     // If there will be a relayout anyway skip the next steps because they only verify
 476     // the state of the ranges.
 477     if (relayoutChildren)
 478         return;
 479 
 480     // Not necessary for the flow thread, since we already computed the correct info for it.
 481     // If the fragments have changed invalidate the children.
 482     if (block == this) {
 483         relayoutChildren = m_pageLogicalSizeChanged;
 484         return;
 485     }
 486 
 487     RenderFragmentContainer* startFragment = nullptr;
 488     RenderFragmentContainer* endFragment = nullptr;
 489     if (!getFragmentRangeForBox(block, startFragment, endFragment))
 490         return;
 491 
 492     for (auto it = m_fragmentList.find(startFragment), end = m_fragmentList.end(); it != end; ++it) {
 493         RenderFragmentContainer* fragment = *it;
 494         ASSERT(!fragment-&gt;needsLayout() || fragment-&gt;isRenderFragmentContainerSet());
 495 
 496         // We have no information computed for this fragment so we need to do it.
 497         std::unique_ptr&lt;RenderBoxFragmentInfo&gt; oldInfo = fragment-&gt;takeRenderBoxFragmentInfo(block);
 498         if (!oldInfo) {
 499             relayoutChildren = rangeInvalidated;
 500             return;
 501         }
 502 
 503         LayoutUnit oldLogicalWidth = oldInfo-&gt;logicalWidth();
 504         RenderBoxFragmentInfo* newInfo = block-&gt;renderBoxFragmentInfo(fragment);
 505         if (!newInfo || newInfo-&gt;logicalWidth() != oldLogicalWidth) {
 506             relayoutChildren = true;
 507             return;
 508         }
 509 
 510         if (fragment == endFragment)
 511             break;
 512     }
 513 }
 514 
 515 LayoutUnit RenderFragmentedFlow::contentLogicalWidthOfFirstFragment() const
 516 {
 517     RenderFragmentContainer* firstValidFragmentInFlow = firstFragment();
 518     if (!firstValidFragmentInFlow)
 519         return 0;
 520     return isHorizontalWritingMode() ? firstValidFragmentInFlow-&gt;contentWidth() : firstValidFragmentInFlow-&gt;contentHeight();
 521 }
 522 
 523 LayoutUnit RenderFragmentedFlow::contentLogicalHeightOfFirstFragment() const
 524 {
 525     RenderFragmentContainer* firstValidFragmentInFlow = firstFragment();
 526     if (!firstValidFragmentInFlow)
 527         return 0;
 528     return isHorizontalWritingMode() ? firstValidFragmentInFlow-&gt;contentHeight() : firstValidFragmentInFlow-&gt;contentWidth();
 529 }
 530 
 531 LayoutUnit RenderFragmentedFlow::contentLogicalLeftOfFirstFragment() const
 532 {
 533     RenderFragmentContainer* firstValidFragmentInFlow = firstFragment();
 534     if (!firstValidFragmentInFlow)
 535         return 0;
 536     return isHorizontalWritingMode() ? firstValidFragmentInFlow-&gt;fragmentedFlowPortionRect().x() : firstValidFragmentInFlow-&gt;fragmentedFlowPortionRect().y();
 537 }
 538 
 539 RenderFragmentContainer* RenderFragmentedFlow::firstFragment() const
 540 {
 541     if (!hasFragments())
 542         return nullptr;
 543     return m_fragmentList.first();
 544 }
 545 
 546 RenderFragmentContainer* RenderFragmentedFlow::lastFragment() const
 547 {
 548     if (!hasFragments())
 549         return nullptr;
 550     return m_fragmentList.last();
 551 }
 552 
 553 void RenderFragmentedFlow::clearRenderBoxFragmentInfoAndCustomStyle(const RenderBox&amp; box,
 554     const RenderFragmentContainer* newStartFragment, const RenderFragmentContainer* newEndFragment,
 555     const RenderFragmentContainer* oldStartFragment, const RenderFragmentContainer* oldEndFragment)
 556 {
 557     ASSERT(newStartFragment &amp;&amp; newEndFragment &amp;&amp; oldStartFragment &amp;&amp; oldEndFragment);
 558 
 559     bool insideOldFragmentRange = false;
 560     bool insideNewFragmentRange = false;
 561     for (auto&amp; fragment : m_fragmentList) {
 562         if (oldStartFragment == fragment)
 563             insideOldFragmentRange = true;
 564         if (newStartFragment == fragment)
 565             insideNewFragmentRange = true;
 566 
 567         if (!(insideOldFragmentRange &amp;&amp; insideNewFragmentRange)) {
 568             if (fragment-&gt;renderBoxFragmentInfo(&amp;box))
 569                 fragment-&gt;removeRenderBoxFragmentInfo(box);
 570         }
 571 
 572         if (oldEndFragment == fragment)
 573             insideOldFragmentRange = false;
 574         if (newEndFragment == fragment)
 575             insideNewFragmentRange = false;
 576     }
 577 }
 578 
 579 void RenderFragmentedFlow::setFragmentRangeForBox(const RenderBox&amp; box, RenderFragmentContainer* startFragment, RenderFragmentContainer* endFragment)
 580 {
 581     ASSERT(hasFragments());
 582     ASSERT(startFragment &amp;&amp; endFragment &amp;&amp; startFragment-&gt;fragmentedFlow() == this &amp;&amp; endFragment-&gt;fragmentedFlow() == this);
 583     auto result = m_fragmentRangeMap.set(&amp;box, RenderFragmentContainerRange(startFragment, endFragment));
 584     if (result.isNewEntry)
 585         return;
 586 
 587     // If nothing changed, just bail.
 588     auto&amp; range = result.iterator-&gt;value;
 589     if (range.startFragment() == startFragment &amp;&amp; range.endFragment() == endFragment)
 590         return;
 591     clearRenderBoxFragmentInfoAndCustomStyle(box, startFragment, endFragment, range.startFragment(), range.endFragment());
 592 }
 593 
 594 bool RenderFragmentedFlow::hasCachedFragmentRangeForBox(const RenderBox&amp; box) const
 595 {
 596     return m_fragmentRangeMap.contains(&amp;box);
 597 }
 598 
 599 bool RenderFragmentedFlow::getFragmentRangeForBoxFromCachedInfo(const RenderBox* box, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const
 600 {
 601     ASSERT(box);
 602     ASSERT(hasValidFragmentInfo());
 603     ASSERT((startFragment == nullptr) &amp;&amp; (endFragment == nullptr));
 604 
 605     auto it = m_fragmentRangeMap.find(box);
 606     if (it != m_fragmentRangeMap.end()) {
 607         const RenderFragmentContainerRange&amp; range = it-&gt;value;
 608         startFragment = range.startFragment();
 609         endFragment = range.endFragment();
 610         ASSERT(m_fragmentList.contains(startFragment) &amp;&amp; m_fragmentList.contains(endFragment));
 611         return true;
 612     }
 613 
 614     return false;
 615 }
 616 
 617 bool RenderFragmentedFlow::getFragmentRangeForBox(const RenderBox* box, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const
 618 {
 619     ASSERT(box);
 620 
 621     startFragment = endFragment = nullptr;
 622     if (!hasValidFragmentInfo()) // We clear the ranges when we invalidate the fragments.
 623         return false;
 624 
 625     if (m_fragmentList.size() == 1) {
 626         startFragment = endFragment = m_fragmentList.first();
 627         return true;
 628     }
 629 
 630     if (getFragmentRangeForBoxFromCachedInfo(box, startFragment, endFragment))
 631         return true;
 632 
 633     return false;
 634 }
 635 
 636 bool RenderFragmentedFlow::computedFragmentRangeForBox(const RenderBox* box, RenderFragmentContainer*&amp; startFragment, RenderFragmentContainer*&amp; endFragment) const
 637 {
 638     ASSERT(box);
 639 
 640     startFragment = endFragment = nullptr;
 641     if (!hasValidFragmentInfo()) // We clear the ranges when we invalidate the fragments.
 642         return false;
 643 
 644     if (getFragmentRangeForBox(box, startFragment, endFragment))
 645         return true;
 646 
 647     // Search the fragment range using the information provided by the containing block chain.
 648     auto* containingBlock = const_cast&lt;RenderBox*&gt;(box);
 649     while (!containingBlock-&gt;isRenderFragmentedFlow()) {
 650         InlineElementBox* boxWrapper = containingBlock-&gt;inlineBoxWrapper();
 651         if (boxWrapper &amp;&amp; boxWrapper-&gt;root().containingFragment()) {
 652             startFragment = endFragment = boxWrapper-&gt;root().containingFragment();
 653             ASSERT(m_fragmentList.contains(startFragment));
 654             return true;
 655         }
 656 
 657         // FIXME: Use the containingBlock() value once we patch all the layout systems to be fragment range aware
 658         // (e.g. if we use containingBlock() the shadow controls of a video element won&#39;t get the range from the
 659         // video box because it&#39;s not a block; they need to be patched separately).
 660         ASSERT(containingBlock-&gt;parent());
 661         containingBlock = &amp;containingBlock-&gt;parent()-&gt;enclosingBox();
 662         ASSERT(containingBlock);
 663 
 664         // If a box doesn&#39;t have a cached fragment range it usually means the box belongs to a line so startFragment should be equal with endFragment.
 665         // FIXME: Find the cases when this startFragment should not be equal with endFragment and make sure these boxes have cached fragment ranges.
 666         if (containingBlock &amp;&amp; hasCachedFragmentRangeForBox(*containingBlock)) {
 667             startFragment = endFragment = fragmentAtBlockOffset(containingBlock, containingBlock-&gt;offsetFromLogicalTopOfFirstPage(), true);
 668             return true;
 669         }
 670     }
 671     ASSERT_NOT_REACHED();
 672     return false;
 673 }
 674 
 675 bool RenderFragmentedFlow::fragmentInRange(const RenderFragmentContainer* targetFragment, const RenderFragmentContainer* startFragment, const RenderFragmentContainer* endFragment) const
 676 {
 677     ASSERT(targetFragment);
 678 
 679     for (auto it = m_fragmentList.find(const_cast&lt;RenderFragmentContainer*&gt;(startFragment)), end = m_fragmentList.end(); it != end; ++it) {
 680         const RenderFragmentContainer* currFragment = *it;
 681         if (targetFragment == currFragment)
 682             return true;
 683         if (currFragment == endFragment)
 684             break;
 685     }
 686 
 687     return false;
 688 }
 689 
 690 bool RenderFragmentedFlow::objectShouldFragmentInFlowFragment(const RenderObject* object, const RenderFragmentContainer* fragment) const
 691 {
 692     ASSERT(object);
 693     ASSERT(fragment);
 694 
 695     RenderFragmentedFlow* fragmentedFlow = object-&gt;enclosingFragmentedFlow();
 696     if (fragmentedFlow != this)
 697         return false;
 698 
 699     if (!m_fragmentList.contains(const_cast&lt;RenderFragmentContainer*&gt;(fragment)))
 700         return false;
 701 
 702     RenderFragmentContainer* enclosingBoxStartFragment = nullptr;
 703     RenderFragmentContainer* enclosingBoxEndFragment = nullptr;
 704     // If the box has no range, do not check fragmentInRange. Boxes inside inlines do not get ranges.
 705     // Instead, the containing RootInlineBox will abort when trying to paint inside the wrong fragment.
 706     if (computedFragmentRangeForBox(&amp;object-&gt;enclosingBox(), enclosingBoxStartFragment, enclosingBoxEndFragment)
 707         &amp;&amp; !fragmentInRange(fragment, enclosingBoxStartFragment, enclosingBoxEndFragment))
 708         return false;
 709 
 710     return object-&gt;isBox() || object-&gt;isRenderInline();
 711 }
 712 
 713 bool RenderFragmentedFlow::objectInFlowFragment(const RenderObject* object, const RenderFragmentContainer* fragment) const
 714 {
 715     ASSERT(object);
 716     ASSERT(fragment);
 717 
 718     RenderFragmentedFlow* fragmentedFlow = object-&gt;enclosingFragmentedFlow();
 719     if (fragmentedFlow != this)
 720         return false;
 721 
 722     if (!m_fragmentList.contains(const_cast&lt;RenderFragmentContainer*&gt;(fragment)))
 723         return false;
 724 
 725     RenderFragmentContainer* enclosingBoxStartFragment = nullptr;
 726     RenderFragmentContainer* enclosingBoxEndFragment = nullptr;
 727     if (!getFragmentRangeForBox(&amp;object-&gt;enclosingBox(), enclosingBoxStartFragment, enclosingBoxEndFragment))
 728         return false;
 729 
 730     if (!fragmentInRange(fragment, enclosingBoxStartFragment, enclosingBoxEndFragment))
 731         return false;
 732 
 733     if (object-&gt;isBox())
 734         return true;
 735 
 736     LayoutRect objectABBRect = object-&gt;absoluteBoundingBoxRect(true);
 737     if (!objectABBRect.width())
 738         objectABBRect.setWidth(1);
 739     if (!objectABBRect.height())
 740         objectABBRect.setHeight(1);
 741     if (objectABBRect.intersects(fragment-&gt;absoluteBoundingBoxRect(true)))
 742         return true;
 743 
 744     if (fragment == lastFragment()) {
 745         // If the object does not intersect any of the enclosing box fragments
 746         // then the object is in last fragment.
 747         for (auto it = m_fragmentList.find(enclosingBoxStartFragment), end = m_fragmentList.end(); it != end; ++it) {
 748             const RenderFragmentContainer* currFragment = *it;
 749             if (currFragment == fragment)
 750                 break;
 751             if (objectABBRect.intersects(currFragment-&gt;absoluteBoundingBoxRect(true)))
 752                 return false;
 753         }
 754         return true;
 755     }
 756 
 757     return false;
 758 }
 759 
 760 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 761 bool RenderFragmentedFlow::checkLinesConsistency(const RenderBlockFlow&amp; removedBlock) const
 762 {
 763     if (!m_lineToFragmentMap)
 764         return true;
 765 
 766     for (auto&amp; linePair : *m_lineToFragmentMap.get()) {
 767         const RootInlineBox* line = linePair.key;
 768         RenderFragmentContainer* fragment = linePair.value;
 769         if (&amp;line-&gt;blockFlow() == &amp;removedBlock)
 770             return false;
 771         if (line-&gt;blockFlow().fragmentedFlowState() == NotInsideFragmentedFlow)
 772             return false;
 773         if (!m_fragmentList.contains(fragment))
 774             return false;
 775     }
 776 
 777     return true;
 778 }
 779 #endif
 780 
 781 void RenderFragmentedFlow::clearLinesToFragmentMap()
 782 {
 783     if (m_lineToFragmentMap)
 784         m_lineToFragmentMap-&gt;clear();
 785 }
 786 
 787 void RenderFragmentedFlow::deleteLines()
 788 {
 789     clearLinesToFragmentMap();
 790     RenderBlockFlow::deleteLines();
 791 }
 792 
 793 void RenderFragmentedFlow::willBeDestroyed()
 794 {
 795     clearLinesToFragmentMap();
 796     RenderBlockFlow::willBeDestroyed();
 797 }
 798 
 799 void RenderFragmentedFlow::markFragmentsForOverflowLayoutIfNeeded()
 800 {
 801     if (!hasFragments())
 802         return;
 803 
 804     for (auto&amp; fragment : m_fragmentList)
 805         fragment-&gt;setNeedsSimplifiedNormalFlowLayout();
 806 }
 807 
 808 void RenderFragmentedFlow::updateFragmentsFragmentedFlowPortionRect()
 809 {
 810     LayoutUnit logicalHeight;
<a name="8" id="anc8"></a><span class="line-modified"> 811     // FIXME: Optimize not to clear the interval tree all the time. This would involve manually managing the tree nodes&#39; lifecycle.</span>
 812     m_fragmentIntervalTree.clear();
 813     for (auto&amp; fragment : m_fragmentList) {
 814         LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
 815         LayoutUnit fragmentLogicalHeight = std::min&lt;LayoutUnit&gt;(RenderFragmentedFlow::maxLogicalHeight() - logicalHeight, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
 816 
 817         LayoutRect fragmentRect(style().direction() == TextDirection::LTR ? 0_lu : logicalWidth() - fragmentLogicalWidth, logicalHeight, fragmentLogicalWidth, fragmentLogicalHeight);
 818 
 819         fragment-&gt;setFragmentedFlowPortionRect(isHorizontalWritingMode() ? fragmentRect : fragmentRect.transposedRect());
 820 
<a name="9" id="anc9"></a><span class="line-modified"> 821         m_fragmentIntervalTree.add({ logicalHeight, logicalHeight + fragmentLogicalHeight, makeWeakPtr(fragment) });</span>
 822 
 823         logicalHeight += fragmentLogicalHeight;
 824     }
 825 }
 826 
 827 // Even if we require the break to occur at offsetBreakInFragmentedFlow, because fragments may have min/max-height values,
 828 // it is possible that the break will occur at a different offset than the original one required.
 829 // offsetBreakAdjustment measures the different between the requested break offset and the current break offset.
 830 bool RenderFragmentedFlow::addForcedFragmentBreak(const RenderBlock* block, LayoutUnit offsetBreakInFragmentedFlow, RenderBox*, bool, LayoutUnit* offsetBreakAdjustment)
 831 {
 832     // We need to update the fragments flow thread portion rect because we are going to process
 833     // a break on these fragments.
 834     updateFragmentsFragmentedFlowPortionRect();
 835 
 836     // Simulate a fragment break at offsetBreakInFragmentedFlow. If it points inside an auto logical height fragment,
 837     // then it determines the fragment computed auto height.
 838     RenderFragmentContainer* fragment = fragmentAtBlockOffset(block, offsetBreakInFragmentedFlow);
 839     if (!fragment)
 840         return false;
 841 
 842     LayoutUnit currentFragmentOffsetInFragmentedFlow = isHorizontalWritingMode() ? fragment-&gt;fragmentedFlowPortionRect().y() : fragment-&gt;fragmentedFlowPortionRect().x();
 843 
 844     currentFragmentOffsetInFragmentedFlow += isHorizontalWritingMode() ? fragment-&gt;fragmentedFlowPortionRect().height() : fragment-&gt;fragmentedFlowPortionRect().width();
 845 
 846     if (offsetBreakAdjustment)
 847         *offsetBreakAdjustment = std::max&lt;LayoutUnit&gt;(0, currentFragmentOffsetInFragmentedFlow - offsetBreakInFragmentedFlow);
 848 
 849     return false;
 850 }
 851 
 852 void RenderFragmentedFlow::collectLayerFragments(LayerFragments&amp; layerFragments, const LayoutRect&amp; layerBoundingBox, const LayoutRect&amp; dirtyRect)
 853 {
 854     ASSERT(!m_fragmentsInvalidated);
 855 
 856     for (auto&amp; fragment : m_fragmentList)
 857         fragment-&gt;collectLayerFragments(layerFragments, layerBoundingBox, dirtyRect);
 858 }
 859 
 860 LayoutRect RenderFragmentedFlow::fragmentsBoundingBox(const LayoutRect&amp; layerBoundingBox)
 861 {
 862     ASSERT(!m_fragmentsInvalidated);
 863 
 864     LayoutRect result;
 865     for (auto&amp; fragment : m_fragmentList) {
 866         LayerFragments fragments;
 867         fragment-&gt;collectLayerFragments(fragments, layerBoundingBox, LayoutRect::infiniteRect());
 868         for (const auto&amp; fragment : fragments) {
 869             LayoutRect fragmentRect(layerBoundingBox);
 870             fragmentRect.intersect(fragment.paginationClip);
 871             fragmentRect.move(fragment.paginationOffset);
 872             result.unite(fragmentRect);
 873         }
 874     }
 875 
 876     return result;
 877 }
 878 
 879 LayoutUnit RenderFragmentedFlow::offsetFromLogicalTopOfFirstFragment(const RenderBlock* currentBlock) const
 880 {
 881     // As a last resort, take the slow path.
 882     LayoutRect blockRect(0_lu, 0_lu, currentBlock-&gt;width(), currentBlock-&gt;height());
 883     while (currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock) &amp;&amp; !currentBlock-&gt;isRenderFragmentedFlow()) {
 884         RenderBlock* containerBlock = currentBlock-&gt;containingBlock();
 885         ASSERT(containerBlock);
 886         if (!containerBlock)
 887             return 0;
 888         LayoutPoint currentBlockLocation = currentBlock-&gt;location();
 889         if (is&lt;RenderTableCell&gt;(*currentBlock)) {
 890             if (auto* section = downcast&lt;RenderTableCell&gt;(*currentBlock).section())
 891                 currentBlockLocation.moveBy(section-&gt;location());
 892         }
 893 
 894         if (containerBlock-&gt;style().writingMode() != currentBlock-&gt;style().writingMode()) {
 895             // We have to put the block rect in container coordinates
 896             // and we have to take into account both the container and current block flipping modes
 897             if (containerBlock-&gt;style().isFlippedBlocksWritingMode()) {
 898                 if (containerBlock-&gt;isHorizontalWritingMode())
 899                     blockRect.setY(currentBlock-&gt;height() - blockRect.maxY());
 900                 else
 901                     blockRect.setX(currentBlock-&gt;width() - blockRect.maxX());
 902             }
 903             currentBlock-&gt;flipForWritingMode(blockRect);
 904         }
 905         blockRect.moveBy(currentBlockLocation);
 906         currentBlock = containerBlock;
 907     }
 908 
 909     return currentBlock-&gt;isHorizontalWritingMode() ? blockRect.y() : blockRect.x();
 910 }
 911 
<a name="10" id="anc10"></a>







 912 void RenderFragmentedFlow::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
 913 {
 914     if (this == repaintContainer)
 915         return;
 916 
 917     if (RenderFragmentContainer* fragment = mapFromFlowToFragment(transformState)) {
 918         // FIXME: The cast below is probably not the best solution, we may need to find a better way.
 919         const RenderObject* fragmentObject = static_cast&lt;const RenderObject*&gt;(fragment);
 920 
 921         // If the repaint container is nullptr, we have to climb up to the RenderView, otherwise swap
 922         // it with the fragment&#39;s repaint container.
 923         repaintContainer = repaintContainer ? fragment-&gt;containerForRepaint() : nullptr;
 924 
 925         if (RenderFragmentedFlow* fragmentFragmentedFlow = fragment-&gt;enclosingFragmentedFlow()) {
 926             RenderFragmentContainer* startFragment = nullptr;
 927             RenderFragmentContainer* endFragment = nullptr;
 928             if (fragmentFragmentedFlow-&gt;getFragmentRangeForBox(fragment, startFragment, endFragment)) {
 929                 CurrentRenderFragmentContainerMaintainer fragmentMaintainer(*startFragment);
 930                 fragmentObject-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
 931                 return;
 932             }
 933         }
 934 
 935         fragmentObject-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
 936     }
 937 }
 938 
 939 // FIXME: Make this function faster. Walking the render tree is slow, better use a caching mechanism (e.g. |cachedOffsetFromLogicalTopOfFirstFragment|).
 940 LayoutRect RenderFragmentedFlow::mapFromLocalToFragmentedFlow(const RenderBox* box, const LayoutRect&amp; localRect) const
 941 {
 942     LayoutRect boxRect = localRect;
 943 
 944     while (box &amp;&amp; box != this) {
 945         RenderBlock* containerBlock = box-&gt;containingBlock();
 946         ASSERT(containerBlock);
 947         if (!containerBlock)
 948             return LayoutRect();
 949         LayoutPoint currentBoxLocation = box-&gt;location();
 950 
 951         if (containerBlock-&gt;style().writingMode() != box-&gt;style().writingMode())
 952             box-&gt;flipForWritingMode(boxRect);
 953 
 954         boxRect.moveBy(currentBoxLocation);
 955         box = containerBlock;
 956     }
 957 
 958     return boxRect;
 959 }
 960 
 961 // FIXME: Make this function faster. Walking the render tree is slow, better use a caching mechanism (e.g. |cachedOffsetFromLogicalTopOfFirstFragment|).
 962 LayoutRect RenderFragmentedFlow::mapFromFragmentedFlowToLocal(const RenderBox* box, const LayoutRect&amp; rect) const
 963 {
 964     LayoutRect localRect = rect;
 965     if (box == this)
 966         return localRect;
 967 
 968     RenderBlock* containerBlock = box-&gt;containingBlock();
 969     ASSERT(containerBlock);
 970     if (!containerBlock)
 971         return LayoutRect();
 972     localRect = mapFromFragmentedFlowToLocal(containerBlock, localRect);
 973 
 974     LayoutPoint currentBoxLocation = box-&gt;location();
 975     localRect.moveBy(-currentBoxLocation);
 976 
 977     if (containerBlock-&gt;style().writingMode() != box-&gt;style().writingMode())
 978         box-&gt;flipForWritingMode(localRect);
 979 
 980     return localRect;
 981 }
 982 
 983 void RenderFragmentedFlow::flipForWritingModeLocalCoordinates(LayoutRect&amp; rect) const
 984 {
 985     if (!style().isFlippedBlocksWritingMode())
 986         return;
 987 
 988     if (isHorizontalWritingMode())
 989         rect.setY(0 - rect.maxY());
 990     else
 991         rect.setX(0 - rect.maxX());
 992 }
 993 
 994 void RenderFragmentedFlow::addFragmentsVisualEffectOverflow(const RenderBox* box)
 995 {
 996     RenderFragmentContainer* startFragment = nullptr;
 997     RenderFragmentContainer* endFragment = nullptr;
 998     if (!getFragmentRangeForBox(box, startFragment, endFragment))
 999         return;
1000 
1001     for (auto iter = m_fragmentList.find(startFragment), end = m_fragmentList.end(); iter != end; ++iter) {
1002         RenderFragmentContainer* fragment = *iter;
1003 
1004         LayoutRect borderBox = box-&gt;borderBoxRectInFragment(fragment);
1005         borderBox = box-&gt;applyVisualEffectOverflow(borderBox);
1006         borderBox = fragment-&gt;rectFlowPortionForBox(box, borderBox);
1007 
1008         fragment-&gt;addVisualOverflowForBox(box, borderBox);
1009         if (fragment == endFragment)
1010             break;
1011     }
1012 }
1013 
1014 void RenderFragmentedFlow::addFragmentsVisualOverflowFromTheme(const RenderBlock* block)
1015 {
1016     RenderFragmentContainer* startFragment = nullptr;
1017     RenderFragmentContainer* endFragment = nullptr;
1018     if (!getFragmentRangeForBox(block, startFragment, endFragment))
1019         return;
1020 
1021     for (auto iter = m_fragmentList.find(startFragment), end = m_fragmentList.end(); iter != end; ++iter) {
1022         RenderFragmentContainer* fragment = *iter;
1023 
1024         LayoutRect borderBox = block-&gt;borderBoxRectInFragment(fragment);
1025         borderBox = fragment-&gt;rectFlowPortionForBox(block, borderBox);
1026 
1027         FloatRect inflatedRect = borderBox;
1028         block-&gt;theme().adjustRepaintRect(*block, inflatedRect);
1029 
1030         fragment-&gt;addVisualOverflowForBox(block, snappedIntRect(LayoutRect(inflatedRect)));
1031         if (fragment == endFragment)
1032             break;
1033     }
1034 }
1035 
1036 void RenderFragmentedFlow::addFragmentsOverflowFromChild(const RenderBox* box, const RenderBox* child, const LayoutSize&amp; delta)
1037 {
1038     RenderFragmentContainer* startFragment = nullptr;
1039     RenderFragmentContainer* endFragment = nullptr;
1040     if (!getFragmentRangeForBox(child, startFragment, endFragment))
1041         return;
1042 
1043     RenderFragmentContainer* containerStartFragment = nullptr;
1044     RenderFragmentContainer* containerEndFragment = nullptr;
1045     if (!getFragmentRangeForBox(box, containerStartFragment, containerEndFragment))
1046         return;
1047 
1048     for (auto iter = m_fragmentList.find(startFragment), end = m_fragmentList.end(); iter != end; ++iter) {
1049         RenderFragmentContainer* fragment = *iter;
1050         if (!fragmentInRange(fragment, containerStartFragment, containerEndFragment)) {
1051             if (fragment == endFragment)
1052                 break;
1053             continue;
1054         }
1055 
1056         LayoutRect childLayoutOverflowRect = fragment-&gt;layoutOverflowRectForBoxForPropagation(child);
1057         childLayoutOverflowRect.move(delta);
1058 
1059         fragment-&gt;addLayoutOverflowForBox(box, childLayoutOverflowRect);
1060 
1061         if (child-&gt;hasSelfPaintingLayer() || box-&gt;hasOverflowClip()) {
1062             if (fragment == endFragment)
1063                 break;
1064             continue;
1065         }
1066         LayoutRect childVisualOverflowRect = fragment-&gt;visualOverflowRectForBoxForPropagation(*child);
1067         childVisualOverflowRect.move(delta);
1068         fragment-&gt;addVisualOverflowForBox(box, childVisualOverflowRect);
1069 
1070         if (fragment == endFragment)
1071             break;
1072     }
1073 }
1074 
1075 void RenderFragmentedFlow::addFragmentsLayoutOverflow(const RenderBox* box, const LayoutRect&amp; layoutOverflow)
1076 {
1077     RenderFragmentContainer* startFragment = nullptr;
1078     RenderFragmentContainer* endFragment = nullptr;
1079     if (!getFragmentRangeForBox(box, startFragment, endFragment))
1080         return;
1081 
1082     for (auto iter = m_fragmentList.find(startFragment), end = m_fragmentList.end(); iter != end; ++iter) {
1083         RenderFragmentContainer* fragment = *iter;
1084         LayoutRect layoutOverflowInFragment = fragment-&gt;rectFlowPortionForBox(box, layoutOverflow);
1085 
1086         fragment-&gt;addLayoutOverflowForBox(box, layoutOverflowInFragment);
1087 
1088         if (fragment == endFragment)
1089             break;
1090     }
1091 }
1092 
1093 void RenderFragmentedFlow::addFragmentsVisualOverflow(const RenderBox* box, const LayoutRect&amp; visualOverflow)
1094 {
1095     RenderFragmentContainer* startFragment = nullptr;
1096     RenderFragmentContainer* endFragment = nullptr;
1097     if (!getFragmentRangeForBox(box, startFragment, endFragment))
1098         return;
1099 
1100     for (RenderFragmentContainerList::iterator iter = m_fragmentList.find(startFragment); iter != m_fragmentList.end(); ++iter) {
1101         RenderFragmentContainer* fragment = *iter;
1102         LayoutRect visualOverflowInFragment = fragment-&gt;rectFlowPortionForBox(box, visualOverflow);
1103 
1104         fragment-&gt;addVisualOverflowForBox(box, visualOverflowInFragment);
1105 
1106         if (fragment == endFragment)
1107             break;
1108     }
1109 }
1110 
1111 void RenderFragmentedFlow::clearFragmentsOverflow(const RenderBox* box)
1112 {
1113     RenderFragmentContainer* startFragment = nullptr;
1114     RenderFragmentContainer* endFragment = nullptr;
1115     if (!getFragmentRangeForBox(box, startFragment, endFragment))
1116         return;
1117 
1118     for (auto iter = m_fragmentList.find(startFragment), end = m_fragmentList.end(); iter != end; ++iter) {
1119         RenderFragmentContainer* fragment = *iter;
1120         RenderBoxFragmentInfo* boxInfo = fragment-&gt;renderBoxFragmentInfo(box);
1121         if (boxInfo &amp;&amp; boxInfo-&gt;overflow())
1122             boxInfo-&gt;clearOverflow();
1123 
1124         if (fragment == endFragment)
1125             break;
1126     }
1127 }
1128 
1129 RenderFragmentContainer* RenderFragmentedFlow::currentFragment() const
1130 {
1131     return m_currentFragmentMaintainer ? &amp;m_currentFragmentMaintainer-&gt;fragment() : nullptr;
1132 }
1133 
1134 ContainingFragmentMap&amp; RenderFragmentedFlow::containingFragmentMap()
1135 {
1136     if (!m_lineToFragmentMap)
1137         m_lineToFragmentMap = makeUnique&lt;ContainingFragmentMap&gt;();
1138 
1139     return *m_lineToFragmentMap.get();
1140 }
1141 
1142 
1143 } // namespace WebCore
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
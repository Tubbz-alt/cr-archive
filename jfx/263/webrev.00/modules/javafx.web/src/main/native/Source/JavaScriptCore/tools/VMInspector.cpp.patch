diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp
@@ -54,17 +54,17 @@
 }
 
 void VMInspector::add(VM* vm)
 {
     auto locker = holdLock(m_lock);
-    m_list.append(vm);
+    m_vmList.append(vm);
 }
 
 void VMInspector::remove(VM* vm)
 {
     auto locker = holdLock(m_lock);
-    m_list.remove(vm);
+    m_vmList.remove(vm);
 }
 
 auto VMInspector::lock(Seconds timeout) -> Expected<Locker, Error>
 {
     // This function may be called from a signal handler (e.g. via visit()). Hence,
@@ -104,10 +104,17 @@
     }
     return false;
 };
 #endif // ENABLE(JIT)
 
+void VMInspector::forEachVM(Function<FunctorStatus(VM&)>&& func)
+{
+    VMInspector& inspector = instance();
+    Locker lock(inspector.getLock());
+    inspector.iterate(func);
+}
+
 auto VMInspector::isValidExecutableMemory(const VMInspector::Locker&, void* machinePC) -> Expected<bool, Error>
 {
 #if ENABLE(JIT)
     bool found = false;
     bool hasTimeout = false;
@@ -195,45 +202,45 @@
     UNUSED_PARAM(machinePC);
     return nullptr;
 #endif
 }
 
-bool VMInspector::currentThreadOwnsJSLock(ExecState* exec)
+bool VMInspector::currentThreadOwnsJSLock(JSGlobalObject* globalObject)
 {
-    return exec->vm().currentThreadIsHoldingAPILock();
+    return globalObject->vm().currentThreadIsHoldingAPILock();
 }
 
-static bool ensureCurrentThreadOwnsJSLock(ExecState* exec)
+static bool ensureCurrentThreadOwnsJSLock(JSGlobalObject* globalObject)
 {
-    if (VMInspector::currentThreadOwnsJSLock(exec))
+    if (VMInspector::currentThreadOwnsJSLock(globalObject))
         return true;
     dataLog("ERROR: current thread does not own the JSLock\n");
     return false;
 }
 
-void VMInspector::gc(ExecState* exec)
+void VMInspector::gc(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
-    if (!ensureCurrentThreadOwnsJSLock(exec))
+    VM& vm = globalObject->vm();
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return;
     vm.heap.collectNow(Sync, CollectionScope::Full);
 }
 
-void VMInspector::edenGC(ExecState* exec)
+void VMInspector::edenGC(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
-    if (!ensureCurrentThreadOwnsJSLock(exec))
+    VM& vm = globalObject->vm();
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return;
     vm.heap.collectSync(CollectionScope::Eden);
 }
 
 bool VMInspector::isInHeap(Heap* heap, void* ptr)
 {
     MarkedBlock* candidate = MarkedBlock::blockFor(ptr);
     if (heap->objectSpace().blocks().set().contains(candidate))
         return true;
-    for (LargeAllocation* allocation : heap->objectSpace().largeAllocations()) {
+    for (PreciseAllocation* allocation : heap->objectSpace().preciseAllocations()) {
         if (allocation->contains(ptr))
             return true;
     }
     return false;
 }
@@ -263,13 +270,13 @@
     CellAddressCheckFunctor functor(candidate);
     heap->objectSpace().forEachLiveCell(iterationScope, functor);
     return functor.found;
 }
 
-bool VMInspector::isValidCodeBlock(ExecState* exec, CodeBlock* candidate)
+bool VMInspector::isValidCodeBlock(JSGlobalObject* globalObject, CodeBlock* candidate)
 {
-    if (!ensureCurrentThreadOwnsJSLock(exec))
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return false;
 
     struct CodeBlockValidationFunctor {
         CodeBlockValidationFunctor(CodeBlock* candidate)
             : candidate(candidate)
@@ -284,19 +291,20 @@
 
         CodeBlock* candidate;
         mutable bool found { false };
     };
 
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     CodeBlockValidationFunctor functor(candidate);
     vm.heap.forEachCodeBlock(functor);
     return functor.found;
 }
 
-CodeBlock* VMInspector::codeBlockForFrame(CallFrame* topCallFrame, unsigned frameNumber)
+CodeBlock* VMInspector::codeBlockForFrame(JSGlobalObject* globalObject, CallFrame* topCallFrame, unsigned frameNumber)
 {
-    if (!ensureCurrentThreadOwnsJSLock(topCallFrame))
+    VM& vm = globalObject->vm();
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return nullptr;
 
     if (!topCallFrame)
         return nullptr;
 
@@ -321,11 +329,11 @@
         mutable unsigned nextFrame { 0 };
         mutable CodeBlock* codeBlock { nullptr };
     };
 
     FetchCodeBlockFunctor functor(frameNumber);
-    topCallFrame->iterate(functor);
+    topCallFrame->iterate(vm, functor);
     return functor.codeBlock;
 }
 
 class DumpFrameFunctor {
 public:
@@ -357,16 +365,16 @@
     Action m_action;
     unsigned m_framesToSkip;
     mutable unsigned m_currentFrame { 0 };
 };
 
-void VMInspector::dumpCallFrame(CallFrame* callFrame, unsigned framesToSkip)
+void VMInspector::dumpCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame, unsigned framesToSkip)
 {
-    if (!ensureCurrentThreadOwnsJSLock(callFrame))
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return;
     DumpFrameFunctor functor(DumpFrameFunctor::DumpOne, framesToSkip);
-    callFrame->iterate(functor);
+    callFrame->iterate(globalObject->vm(), functor);
 }
 
 void VMInspector::dumpRegisters(CallFrame* callFrame)
 {
     CodeBlock* codeBlock = callFrame->codeBlock();
@@ -387,12 +395,12 @@
     dataLogF("-----------------------------------------------------------------------------\n");
 
     const Register* it;
     const Register* end;
 
-    it = callFrame->registers() + CallFrameSlot::thisArgument + callFrame->argumentCount();
-    end = callFrame->registers() + CallFrameSlot::thisArgument - 1;
+    it = callFrame->registers() + (CallFrameSlot::thisArgument + callFrame->argumentCount());
+    end = callFrame->registers() + (CallFrameSlot::thisArgument - 1);
     while (it > end) {
         JSValue v = it->jsValue();
         int registerNumber = it - callFrame->registers();
         String name = codeBlock->nameForRegister(VirtualRegister(registerNumber));
         dataLogF("[r% 3d %14s]      | %10p | 0x%-16llx %s\n", registerNumber, name.ascii().data(), it, (long long)JSValue::encode(v), valueAsString(v).data());
@@ -400,16 +408,16 @@
     }
 
     dataLogF("-----------------------------------------------------------------------------\n");
     dataLogF("[ArgumentCount]            | %10p | %lu \n", it, (unsigned long) callFrame->argumentCount());
 
-    callFrame->iterate([&] (StackVisitor& visitor) {
+    callFrame->iterate(vm, [&] (StackVisitor& visitor) {
         if (visitor->callFrame() == callFrame) {
             unsigned line = 0;
             unsigned unusedColumn = 0;
             visitor->computeLineAndColumn(line, unusedColumn);
-            dataLogF("[ReturnVPC]                | %10p | %d (line %d)\n", it, visitor->bytecodeOffset(), line);
+            dataLogF("[ReturnVPC]                | %10p | %d (line %d)\n", it, visitor->bytecodeIndex().offset(), line);
             return StackVisitor::Done;
         }
         return StackVisitor::Continue;
     });
 
@@ -418,11 +426,11 @@
     --it;
     dataLogF("[CodeBlock]                | %10p | 0x%-16llx ", it, (long long)codeBlock);
     dataLogLn(codeBlock);
     --it;
 #if ENABLE(JIT)
-    AbstractPC pc = callFrame->abstractReturnPC(callFrame->vm());
+    AbstractPC pc = callFrame->abstractReturnPC(vm);
     if (pc.hasJITReturnAddress())
         dataLogF("[ReturnPC]                 | %10p | %p \n", it, pc.jitReturnAddress().value());
     --it;
 #endif
     dataLogF("[CallerFrame]              | %10p | %p \n", it, callFrame->callerFrame());
@@ -456,23 +464,23 @@
         } while (it != end);
     }
     dataLogF("-----------------------------------------------------------------------------\n");
 }
 
-void VMInspector::dumpStack(CallFrame* topCallFrame, unsigned framesToSkip)
+void VMInspector::dumpStack(JSGlobalObject* globalObject, CallFrame* topCallFrame, unsigned framesToSkip)
 {
-    if (!ensureCurrentThreadOwnsJSLock(topCallFrame))
+    if (!ensureCurrentThreadOwnsJSLock(globalObject))
         return;
     if (!topCallFrame)
         return;
     DumpFrameFunctor functor(DumpFrameFunctor::DumpAll, framesToSkip);
-    topCallFrame->iterate(functor);
+    topCallFrame->iterate(globalObject->vm(), functor);
 }
 
 void VMInspector::dumpValue(JSValue value)
 {
-    dataLog(value);
+    dataLogLn(value);
 }
 
 void VMInspector::dumpCellMemory(JSCell* cell)
 {
     dumpCellMemoryToStream(cell, WTF::dataFile());

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/filters/FilterEffect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Alex Mathews &lt;possessedpenguinbob@gmail.com&gt;
  3  * Copyright (C) 2009 Dirk Schulze &lt;krit@webkit.org&gt;
  4  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ColorSpace.h&quot;
 25 #include &quot;FloatRect.h&quot;
 26 #include &quot;IntRect.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 27 #include &quot;IntRectExtent.h&quot;</span>
 28 #include &lt;JavaScriptCore/Uint8ClampedArray.h&gt;
 29 #include &lt;wtf/MathExtras.h&gt;
 30 #include &lt;wtf/RefCounted.h&gt;
 31 #include &lt;wtf/RefPtr.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace WTF {
 35 class TextStream;
 36 }
 37 
 38 namespace WebCore {
 39 
 40 class Filter;
 41 class FilterEffect;
 42 class ImageBuffer;
 43 
 44 typedef Vector&lt;RefPtr&lt;FilterEffect&gt;&gt; FilterEffectVector;
 45 
 46 enum FilterEffectType {
 47     FilterEffectTypeUnknown,
 48     FilterEffectTypeImage,
 49     FilterEffectTypeTile,
 50     FilterEffectTypeSourceInput
 51 };
 52 
 53 class FilterEffect : public RefCounted&lt;FilterEffect&gt; {
 54 public:
 55     virtual ~FilterEffect();
 56 
 57     void clearResult();
 58     void clearResultsRecursive();
 59 
 60     ImageBuffer* imageBufferResult();
 61     RefPtr&lt;Uint8ClampedArray&gt; unmultipliedResult(const IntRect&amp;);
 62     RefPtr&lt;Uint8ClampedArray&gt; premultipliedResult(const IntRect&amp;);
 63 
 64     void copyUnmultipliedResult(Uint8ClampedArray&amp; destination, const IntRect&amp;);
 65     void copyPremultipliedResult(Uint8ClampedArray&amp; destination, const IntRect&amp;);
 66 
 67     FilterEffectVector&amp; inputEffects() { return m_inputEffects; }
 68     FilterEffect* inputEffect(unsigned) const;
 69     unsigned numberOfEffectInputs() const { return m_inputEffects.size(); }
 70     unsigned totalNumberOfEffectInputs() const;
 71 
 72     inline bool hasResult() const
 73     {
 74         // This function needs platform specific checks, if the memory managment is not done by FilterEffect.
 75         return m_imageBufferResult
 76             || m_unmultipliedImageResult
 77             || m_premultipliedImageResult;
 78     }
 79 
 80     FloatRect drawingRegionOfInputImage(const IntRect&amp;) const;
 81     IntRect requestedRegionOfInputImageData(const IntRect&amp;) const;
 82 
 83     // Recurses on inputs.
 84     FloatRect determineFilterPrimitiveSubregion();
 85 
 86     // Solid black image with different alpha values.
 87     bool isAlphaImage() const { return m_alphaImage; }
 88     void setIsAlphaImage(bool alphaImage) { m_alphaImage = alphaImage; }
 89 
 90     IntRect absolutePaintRect() const { return m_absolutePaintRect; }
 91     void setAbsolutePaintRect(const IntRect&amp; absolutePaintRect) { m_absolutePaintRect = absolutePaintRect; }
 92 
 93     FloatRect maxEffectRect() const { return m_maxEffectRect; }
 94     void setMaxEffectRect(const FloatRect&amp; maxEffectRect) { m_maxEffectRect = maxEffectRect; }
 95 
 96     void apply();
 97 
 98     // Correct any invalid pixels, if necessary, in the result of a filter operation.
 99     // This method is used to ensure valid pixel values on filter inputs and the final result.
100     // Only the arithmetic composite filter ever needs to perform correction.
101     virtual void correctFilterResultIfNeeded() { }
102 
103     virtual void determineAbsolutePaintRect();
104 
105     virtual FilterEffectType filterEffectType() const { return FilterEffectTypeUnknown; }
106 
<a name="2" id="anc2"></a><span class="line-added">107     virtual IntOutsets outsets() const { return IntOutsets(); }</span>
<span class="line-added">108 </span>
109     enum class RepresentationType { TestOutput, Debugging };
110     virtual WTF::TextStream&amp; externalRepresentation(WTF::TextStream&amp;, RepresentationType = RepresentationType::TestOutput) const;
111 
112     // The following functions are SVG specific and will move to RenderSVGResourceFilterPrimitive.
113     // See bug https://bugs.webkit.org/show_bug.cgi?id=45614.
114     bool hasX() const { return m_hasX; }
115     void setHasX(bool value) { m_hasX = value; }
116 
117     bool hasY() const { return m_hasY; }
118     void setHasY(bool value) { m_hasY = value; }
119 
120     bool hasWidth() const { return m_hasWidth; }
121     void setHasWidth(bool value) { m_hasWidth = value; }
122 
123     bool hasHeight() const { return m_hasHeight; }
124     void setHasHeight(bool value) { m_hasHeight = value; }
125 
126     FloatRect filterPrimitiveSubregion() const { return m_filterPrimitiveSubregion; }
127     void setFilterPrimitiveSubregion(const FloatRect&amp; filterPrimitiveSubregion) { m_filterPrimitiveSubregion = filterPrimitiveSubregion; }
128 
129     FloatRect effectBoundaries() const { return m_effectBoundaries; }
130     void setEffectBoundaries(const FloatRect&amp; effectBoundaries) { m_effectBoundaries = effectBoundaries; }
131 
132     void setUnclippedAbsoluteSubregion(const FloatRect&amp; r) { m_absoluteUnclippedSubregion = r; }
133 
134     FloatPoint mapPointFromUserSpaceToBuffer(FloatPoint) const;
135 
136     Filter&amp; filter() { return m_filter; }
137     const Filter&amp; filter() const { return m_filter; }
138 
139     bool clipsToBounds() const { return m_clipsToBounds; }
140     void setClipsToBounds(bool value) { m_clipsToBounds = value; }
141 
142     ColorSpace operatingColorSpace() const { return m_operatingColorSpace; }
143     virtual void setOperatingColorSpace(ColorSpace colorSpace) { m_operatingColorSpace = colorSpace; }
144     ColorSpace resultColorSpace() const { return m_resultColorSpace; }
145     virtual void setResultColorSpace(ColorSpace colorSpace) { m_resultColorSpace = colorSpace; }
146 
147     virtual void transformResultColorSpace(FilterEffect* in, const int) { in-&gt;transformResultColorSpace(m_operatingColorSpace); }
148     void transformResultColorSpace(ColorSpace);
149 
150 protected:
151     FilterEffect(Filter&amp;);
152 
153     virtual const char* filterName() const = 0;
154 
155     ImageBuffer* createImageBufferResult();
156     Uint8ClampedArray* createUnmultipliedImageResult();
157     Uint8ClampedArray* createPremultipliedImageResult();
158 
159     // Return true if the filter will only operate correctly on valid RGBA values, with
160     // alpha in [0,255] and each color component in [0, alpha].
161     virtual bool requiresValidPreMultipliedPixels() { return true; }
162 
163     // If a pre-multiplied image, check every pixel for validity and correct if necessary.
164     void forceValidPreMultipliedPixels();
165 
166     void clipAbsolutePaintRect();
167 
168     static Vector&lt;float&gt; normalizedFloats(const Vector&lt;float&gt;&amp; values)
169     {
170         Vector&lt;float&gt; normalizedValues(values.size());
171         for (size_t i = 0; i &lt; values.size(); ++i)
172             normalizedValues[i] = normalizedFloat(values[i]);
173         return normalizedValues;
174     }
175 
176 private:
177     virtual void platformApplySoftware() = 0;
178 
179     void copyImageBytes(const Uint8ClampedArray&amp; source, Uint8ClampedArray&amp; destination, const IntRect&amp;) const;
180 
181     Filter&amp; m_filter;
182     FilterEffectVector m_inputEffects;
183 
184     std::unique_ptr&lt;ImageBuffer&gt; m_imageBufferResult;
185     RefPtr&lt;Uint8ClampedArray&gt; m_unmultipliedImageResult;
186     RefPtr&lt;Uint8ClampedArray&gt; m_premultipliedImageResult;
187 
188     IntRect m_absolutePaintRect;
189 
190     // The maximum size of a filter primitive. In SVG this is the primitive subregion in absolute coordinate space.
191     // The absolute paint rect should never be bigger than m_maxEffectRect.
192     FloatRect m_maxEffectRect;
193 
194     // The subregion of a filter primitive according to the SVG Filter specification in local coordinates.
195     // This is SVG specific and needs to move to RenderSVGResourceFilterPrimitive.
196     FloatRect m_filterPrimitiveSubregion;
197 
198     // x, y, width and height of the actual SVGFE*Element. Is needed to determine the subregion of the
199     // filter primitive on a later step.
200     FloatRect m_effectBoundaries;
201 
202     // filterPrimitiveSubregion mapped to absolute coordinates before clipping.
203     FloatRect m_absoluteUnclippedSubregion;
204 
205     bool m_alphaImage { false };
206     bool m_hasX { false };
207     bool m_hasY { false };
208     bool m_hasWidth { false };
209     bool m_hasHeight { false };
210 
211     // Should the effect clip to its primitive region, or expand to use the combined region of its inputs.
212     bool m_clipsToBounds { true };
213 
<a name="3" id="anc3"></a><span class="line-modified">214     ColorSpace m_operatingColorSpace { ColorSpace::LinearRGB };</span>
<span class="line-modified">215     ColorSpace m_resultColorSpace { ColorSpace::SRGB };</span>
216 };
217 
218 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FilterEffect&amp;);
219 
220 } // namespace WebCore
221 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
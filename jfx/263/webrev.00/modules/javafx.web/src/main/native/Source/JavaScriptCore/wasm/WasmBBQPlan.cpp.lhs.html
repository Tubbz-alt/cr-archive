<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmBBQPlan.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
<a name="1" id="anc1"></a>
 32 #include &quot;WasmAirIRGenerator.h&quot;
 33 #include &quot;WasmB3IRGenerator.h&quot;
 34 #include &quot;WasmBinding.h&quot;
 35 #include &quot;WasmCallee.h&quot;
 36 #include &quot;WasmCallingConvention.h&quot;
 37 #include &quot;WasmFaultSignalHandler.h&quot;
<a name="2" id="anc2"></a>
 38 #include &quot;WasmMemory.h&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 39 #include &quot;WasmModuleParser.h&quot;</span>
 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WasmTierUpCount.h&quot;
<a name="4" id="anc4"></a><span class="line-removed"> 42 #include &quot;WasmValidate.h&quot;</span>
 43 #include &lt;wtf/DataLog.h&gt;
 44 #include &lt;wtf/Locker.h&gt;
 45 #include &lt;wtf/MonotonicTime.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 #include &lt;wtf/SystemTracing.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace JSC { namespace Wasm {
 51 
 52 namespace WasmBBQPlanInternal {
<a name="5" id="anc5"></a><span class="line-modified"> 53 static const bool verbose = false;</span>
 54 }
 55 
<a name="6" id="anc6"></a><span class="line-modified"> 56 BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; info, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-modified"> 57     : Base(context, WTFMove(info), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-modified"> 58     , m_state(State::Validated)</span>
<span class="line-modified"> 59     , m_asyncWork(work)</span>
 60 {
<a name="7" id="anc7"></a>
 61 }
 62 
<a name="8" id="anc8"></a><span class="line-modified"> 63 BBQPlan::BBQPlan(Context* context, Vector&lt;uint8_t&gt;&amp;&amp; source, AsyncWork work, CompletionTask&amp;&amp; task, CreateEmbedderWrapper&amp;&amp; createEmbedderWrapper, ThrowWasmException throwWasmException)</span>
<span class="line-removed"> 64     : Base(context, ModuleInformation::create(), WTFMove(task), WTFMove(createEmbedderWrapper), throwWasmException)</span>
<span class="line-removed"> 65     , m_source(WTFMove(source))</span>
<span class="line-removed"> 66     , m_state(State::Initial)</span>
<span class="line-removed"> 67     , m_asyncWork(work)</span>
 68 {
<a name="9" id="anc9"></a><span class="line-modified"> 69 }</span>




 70 
<a name="10" id="anc10"></a><span class="line-modified"> 71 BBQPlan::BBQPlan(Context* context, AsyncWork work, CompletionTask&amp;&amp; task)</span>
<span class="line-modified"> 72     : Base(context, WTFMove(task))</span>
<span class="line-modified"> 73     , m_state(State::Initial)</span>
<span class="line-modified"> 74     , m_asyncWork(work)</span>
<span class="line-modified"> 75 {</span>
 76 }
 77 
<a name="11" id="anc11"></a><span class="line-modified"> 78 const char* BBQPlan::stateString(State state)</span>
 79 {
<a name="12" id="anc12"></a><span class="line-modified"> 80     switch (state) {</span>
<span class="line-modified"> 81     case State::Initial: return &quot;Initial&quot;;</span>
<span class="line-modified"> 82     case State::Validated: return &quot;Validated&quot;;</span>
<span class="line-modified"> 83     case State::Prepared: return &quot;Prepared&quot;;</span>
<span class="line-modified"> 84     case State::Compiled: return &quot;Compiled&quot;;</span>
<span class="line-modified"> 85     case State::Completed: return &quot;Completed&quot;;</span>














 86     }
<a name="13" id="anc13"></a><span class="line-removed"> 87     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 88 }</span>
 89 
<a name="14" id="anc14"></a><span class="line-modified"> 90 void BBQPlan::moveToState(State state)</span>
<span class="line-modified"> 91 {</span>
<span class="line-modified"> 92     ASSERT(state &gt;= m_state);</span>
<span class="line-modified"> 93     dataLogLnIf(WasmBBQPlanInternal::verbose &amp;&amp; state != m_state, &quot;moving to state: &quot;, stateString(state), &quot; from state: &quot;, stateString(m_state));</span>
<span class="line-removed"> 94     m_state = state;</span>
<span class="line-removed"> 95 }</span>
 96 
<a name="15" id="anc15"></a><span class="line-modified"> 97 bool BBQPlan::parseAndValidateModule(const uint8_t* source, size_t sourceLength)</span>
<span class="line-modified"> 98 {</span>
<span class="line-modified"> 99     if (m_state != State::Initial)</span>
<span class="line-modified">100         return true;</span>

101 
<a name="16" id="anc16"></a><span class="line-modified">102     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;starting validation&quot;);</span>
<span class="line-modified">103     MonotonicTime startTime;</span>
<span class="line-modified">104     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-modified">105         startTime = MonotonicTime::now();</span>


106 
<a name="17" id="anc17"></a>
107     {
<a name="18" id="anc18"></a><span class="line-modified">108         ModuleParser moduleParser(source, sourceLength, m_moduleInformation);</span>
<span class="line-modified">109         auto parseResult = moduleParser.parse();</span>
<span class="line-modified">110         if (!parseResult) {</span>
<span class="line-modified">111             Base::fail(holdLock(m_lock), WTFMove(parseResult.error()));</span>
<span class="line-modified">112             return false;</span>




















113         }
114     }
115 
<a name="19" id="anc19"></a><span class="line-modified">116     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">117     for (unsigned functionIndex = 0; functionIndex &lt; functions.size(); ++functionIndex) {</span>
<span class="line-modified">118         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">119         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);</span>
<span class="line-modified">120         size_t functionLength = function.end - function.start;</span>
<span class="line-removed">121         ASSERT(functionLength &lt;= sourceLength);</span>
<span class="line-removed">122         ASSERT(functionLength == function.data.size());</span>
<span class="line-removed">123         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">124         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
125 
<a name="20" id="anc20"></a><span class="line-modified">126         auto validationResult = validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get());</span>
<span class="line-modified">127         if (!validationResult) {</span>
<span class="line-modified">128             if (WasmBBQPlanInternal::verbose) {</span>
<span class="line-modified">129                 for (unsigned i = 0; i &lt; functionLength; ++i)</span>
<span class="line-modified">130                     dataLog(RawPointer(reinterpret_cast&lt;void*&gt;(function.data[i])), &quot;, &quot;);</span>
<span class="line-modified">131                 dataLogLn();</span>






















132             }
<a name="21" id="anc21"></a><span class="line-removed">133             Base::fail(holdLock(m_lock), makeString(validationResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">134             return false;</span>
135         }
136     }
137 
<a name="22" id="anc22"></a><span class="line-modified">138     if (WasmBBQPlanInternal::verbose || Options::reportCompileTimes())</span>
<span class="line-removed">139         dataLogLn(&quot;Took &quot;, (MonotonicTime::now() - startTime).microseconds(), &quot; us to validate module&quot;);</span>
140 
<a name="23" id="anc23"></a><span class="line-modified">141     moveToState(State::Validated);</span>
<span class="line-modified">142     if (m_asyncWork == Validation)</span>
<span class="line-modified">143         complete(holdLock(m_lock));</span>
<span class="line-modified">144     return true;</span>
145 }
146 
<a name="24" id="anc24"></a><span class="line-modified">147 void BBQPlan::prepare()</span>
148 {
<a name="25" id="anc25"></a><span class="line-modified">149     ASSERT(m_state == State::Validated);</span>
<span class="line-removed">150     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting preparation&quot;);</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     auto tryReserveCapacity = [this] (auto&amp; vector, size_t size, const char* what) {</span>
<span class="line-removed">153         if (UNLIKELY(!vector.tryReserveCapacity(size))) {</span>
<span class="line-removed">154             fail(holdLock(m_lock), WTF::makeString(&quot;Failed allocating enough space for &quot;, size, what));</span>
<span class="line-removed">155             return false;</span>
<span class="line-removed">156         }</span>
<span class="line-removed">157         return true;</span>
<span class="line-removed">158     };</span>
159 
<a name="26" id="anc26"></a><span class="line-modified">160     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-modified">161     if (!tryReserveCapacity(m_wasmToWasmExitStubs, m_moduleInformation-&gt;importFunctionSignatureIndices.size(), &quot; WebAssembly to JavaScript stubs&quot;)</span>
<span class="line-modified">162         || !tryReserveCapacity(m_unlinkedWasmToWasmCalls, functions.size(), &quot; unlinked WebAssembly to WebAssembly calls&quot;)</span>
<span class="line-modified">163         || !tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-removed">164         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-removed">165         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-removed">166         return;</span>
167 
<a name="27" id="anc27"></a><span class="line-modified">168     m_unlinkedWasmToWasmCalls.resize(functions.size());</span>
<span class="line-removed">169     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-removed">170     m_compilationContexts.resize(functions.size());</span>
<span class="line-removed">171     m_tierUpCounts.resize(functions.size());</span>
<span class="line-removed">172 </span>
<span class="line-removed">173     for (unsigned importIndex = 0; importIndex &lt; m_moduleInformation-&gt;imports.size(); ++importIndex) {</span>
<span class="line-removed">174         Import* import = &amp;m_moduleInformation-&gt;imports[importIndex];</span>
<span class="line-removed">175         if (import-&gt;kind != ExternalKind::Function)</span>
<span class="line-removed">176             continue;</span>
<span class="line-removed">177         unsigned importFunctionIndex = m_wasmToWasmExitStubs.size();</span>
<span class="line-removed">178         dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Processing import function number &quot;, importFunctionIndex, &quot;: &quot;, makeString(import-&gt;module), &quot;: &quot;, makeString(import-&gt;field));</span>
<span class="line-removed">179         auto binding = wasmToWasm(importFunctionIndex);</span>
<span class="line-removed">180         if (UNLIKELY(!binding)) {</span>
<span class="line-removed">181             switch (binding.error()) {</span>
<span class="line-removed">182             case BindingFailure::OutOfMemory:</span>
<span class="line-removed">183                 return fail(holdLock(m_lock), makeString(&quot;Out of executable memory at import &quot;, String::number(importIndex)));</span>
<span class="line-removed">184             }</span>
<span class="line-removed">185             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">186         }</span>
<span class="line-removed">187         m_wasmToWasmExitStubs.uncheckedAppend(binding.value());</span>
<span class="line-removed">188     }</span>
189 
<a name="28" id="anc28"></a><span class="line-modified">190     const uint32_t importFunctionCount = m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">191     for (const auto&amp; exp : m_moduleInformation-&gt;exports) {</span>
<span class="line-modified">192         if (exp.kindIndex &gt;= importFunctionCount)</span>
<span class="line-modified">193             m_exportedFunctionIndices.add(exp.kindIndex - importFunctionCount);</span>


194     }
<a name="29" id="anc29"></a>
195 
<a name="30" id="anc30"></a><span class="line-modified">196     for (const auto&amp; element : m_moduleInformation-&gt;elements) {</span>
<span class="line-modified">197         for (const uint32_t elementIndex : element.functionIndices) {</span>
<span class="line-modified">198             if (elementIndex &gt;= importFunctionCount)</span>
<span class="line-modified">199                 m_exportedFunctionIndices.add(elementIndex - importFunctionCount);</span>























200         }
<a name="31" id="anc31"></a>

201     }
202 
<a name="32" id="anc32"></a><span class="line-modified">203     if (m_moduleInformation-&gt;startFunctionIndexSpace &amp;&amp; m_moduleInformation-&gt;startFunctionIndexSpace &gt;= importFunctionCount)</span>
<span class="line-removed">204         m_exportedFunctionIndices.add(*m_moduleInformation-&gt;startFunctionIndexSpace - importFunctionCount);</span>
<span class="line-removed">205 </span>
<span class="line-removed">206     moveToState(State::Prepared);</span>
207 }
208 
<a name="33" id="anc33"></a><span class="line-modified">209 // We don&#39;t have a semaphore class... and this does kinda interesting things.</span>
<span class="line-removed">210 class BBQPlan::ThreadCountHolder {</span>
<span class="line-removed">211 public:</span>
<span class="line-removed">212     ThreadCountHolder(BBQPlan&amp; plan)</span>
<span class="line-removed">213         : m_plan(plan)</span>
<span class="line-removed">214     {</span>
<span class="line-removed">215         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">216         m_plan.m_numberOfActiveThreads++;</span>
<span class="line-removed">217     }</span>
<span class="line-removed">218 </span>
<span class="line-removed">219     ~ThreadCountHolder()</span>
<span class="line-removed">220     {</span>
<span class="line-removed">221         LockHolder locker(m_plan.m_lock);</span>
<span class="line-removed">222         m_plan.m_numberOfActiveThreads--;</span>
<span class="line-removed">223 </span>
<span class="line-removed">224         if (!m_plan.m_numberOfActiveThreads &amp;&amp; !m_plan.hasWork())</span>
<span class="line-removed">225             m_plan.complete(locker);</span>
<span class="line-removed">226     }</span>
<span class="line-removed">227 </span>
<span class="line-removed">228     BBQPlan&amp; m_plan;</span>
<span class="line-removed">229 };</span>
<span class="line-removed">230 </span>
<span class="line-removed">231 void BBQPlan::compileFunctions(CompilationEffort effort)</span>
232 {
<a name="34" id="anc34"></a><span class="line-modified">233     ASSERT(m_state &gt;= State::Prepared);</span>
<span class="line-modified">234     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting compilation&quot;);</span>
<span class="line-modified">235 </span>
<span class="line-modified">236     if (!hasWork())</span>
<span class="line-modified">237         return;</span>
<span class="line-modified">238 </span>
<span class="line-removed">239     Optional&lt;TraceScope&gt; traceScope;</span>
<span class="line-removed">240     if (Options::useTracePoints())</span>
<span class="line-removed">241         traceScope.emplace(WebAssemblyCompileStart, WebAssemblyCompileEnd);</span>
<span class="line-removed">242     ThreadCountHolder holder(*this);</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     size_t bytesCompiled = 0;</span>
<span class="line-removed">245     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-removed">246     while (true) {</span>
<span class="line-removed">247         if (effort == Partial &amp;&amp; bytesCompiled &gt;= Options::webAssemblyPartialCompileLimit())</span>
<span class="line-removed">248             return;</span>
<span class="line-removed">249 </span>
<span class="line-removed">250         uint32_t functionIndex;</span>
251         {
<a name="35" id="anc35"></a><span class="line-modified">252             auto locker = holdLock(m_lock);</span>
<span class="line-modified">253             if (m_currentIndex &gt;= functions.size()) {</span>
<span class="line-modified">254                 if (hasWork())</span>
<span class="line-removed">255                     moveToState(State::Compiled);</span>
256                 return;
257             }
<a name="36" id="anc36"></a><span class="line-removed">258             functionIndex = m_currentIndex;</span>
<span class="line-removed">259             ++m_currentIndex;</span>
<span class="line-removed">260         }</span>
261 
<a name="37" id="anc37"></a><span class="line-modified">262         const auto&amp; function = functions[functionIndex];</span>
<span class="line-modified">263         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">264         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">265         unsigned functionIndexSpace = m_wasmToWasmExitStubs.size() + functionIndex;</span>
<span class="line-removed">266         ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-removed">267         ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
<span class="line-removed">268 </span>
<span class="line-removed">269         m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>
<span class="line-removed">270         if (Options::useBBQTierUpChecks())</span>
<span class="line-removed">271             m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-removed">272         else</span>
<span class="line-removed">273             m_tierUpCounts[functionIndex] = nullptr;</span>
<span class="line-removed">274         TierUpCount* tierUp = m_tierUpCounts[functionIndex].get();</span>
<span class="line-removed">275         Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-removed">276         unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-removed">277 </span>
<span class="line-removed">278         // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-removed">279         // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-removed">280         // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-removed">281         bool forceUsingB3 = false;</span>
<span class="line-removed">282         if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-removed">283             forceUsingB3 = true;</span>
<span class="line-removed">284 </span>
<span class="line-removed">285         if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-removed">286             parseAndCompileResult = parseAndCompileAir(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex, tierUp, m_throwWasmException);</span>
<span class="line-removed">287         else</span>
<span class="line-removed">288             parseAndCompileResult = parseAndCompile(m_compilationContexts[functionIndex], function.data.data(), function.data.size(), signature, m_unlinkedWasmToWasmCalls[functionIndex], osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp, m_throwWasmException);</span>
<span class="line-removed">289 </span>
<span class="line-removed">290         if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-removed">291             auto locker = holdLock(m_lock);</span>
<span class="line-removed">292             if (!m_errorMessage) {</span>
<span class="line-removed">293                 // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-removed">294                 fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
<span class="line-removed">295             }</span>
<span class="line-removed">296             m_currentIndex = functions.size();</span>
<span class="line-removed">297             return;</span>
298         }
299 
<a name="38" id="anc38"></a><span class="line-modified">300         m_wasmInternalFunctions[functionIndex] = WTFMove(*parseAndCompileResult);</span>





301 
<a name="39" id="anc39"></a><span class="line-modified">302         if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">303             auto locker = holdLock(m_lock);</span>
<span class="line-modified">304             auto result = m_embedderToWasmInternalFunctions.add(functionIndex, m_createEmbedderWrapper(m_compilationContexts[functionIndex], signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-removed">305             ASSERT_UNUSED(result, result.isNewEntry);</span>
306         }
<a name="40" id="anc40"></a>
307 
<a name="41" id="anc41"></a><span class="line-modified">308         bytesCompiled += function.data.size();</span>









309     }
310 }
311 
<a name="42" id="anc42"></a><span class="line-modified">312 void BBQPlan::complete(const AbstractLocker&amp; locker)</span>
313 {
<a name="43" id="anc43"></a><span class="line-modified">314     ASSERT(m_state != State::Compiled || m_currentIndex &gt;= m_moduleInformation-&gt;functions.size());</span>
<span class="line-modified">315     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Starting Completion&quot;);</span>
<span class="line-removed">316 </span>
<span class="line-removed">317     if (!failed() &amp;&amp; m_state == State::Compiled) {</span>
<span class="line-removed">318         for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-removed">319             CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-removed">320             SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-removed">321             const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-removed">322             const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-removed">323             ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>
<span class="line-removed">324             {</span>
<span class="line-removed">325                 LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">326                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">327                     Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">328                     return;</span>
<span class="line-removed">329                 }</span>
<span class="line-removed">330 </span>
<span class="line-removed">331                 m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-removed">332                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-removed">333                     WTFMove(context.wasmEntrypointByproducts));</span>
<span class="line-removed">334             }</span>
<span class="line-removed">335 </span>
<span class="line-removed">336             if (auto embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-removed">337                 LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-removed">338                 if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-removed">339                     Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-removed">340                     return;</span>
<span class="line-removed">341                 }</span>
342 
<a name="44" id="anc44"></a><span class="line-modified">343                 embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">344                     FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">345                     WTFMove(context.embedderEntrypointByproducts));</span>
<span class="line-modified">346             }</span>
347         }
348 
<a name="45" id="anc45"></a><span class="line-modified">349         for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-modified">350             for (auto&amp; call : unlinked) {</span>
<span class="line-modified">351                 MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-modified">352                 if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-removed">353                     // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-removed">354                     executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-removed">355                 } else</span>
<span class="line-removed">356                     executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-removed">357                 MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-removed">358             }</span>
<span class="line-removed">359         }</span>
<span class="line-removed">360     }</span>
361 
<a name="46" id="anc46"></a><span class="line-modified">362     if (!isComplete()) {</span>
<span class="line-removed">363         moveToState(State::Completed);</span>
<span class="line-removed">364         runCompletionTasks(locker);</span>
365     }
366 }
367 
<a name="47" id="anc47"></a><span class="line-modified">368 void BBQPlan::work(CompilationEffort effort)</span>
369 {
<a name="48" id="anc48"></a><span class="line-modified">370     switch (m_state) {</span>
<span class="line-removed">371     case State::Initial:</span>
<span class="line-removed">372         parseAndValidateModule(m_source.data(), m_source.size());</span>
<span class="line-removed">373         if (!hasWork()) {</span>
<span class="line-removed">374             ASSERT(isComplete());</span>
<span class="line-removed">375             return;</span>
<span class="line-removed">376         }</span>
<span class="line-removed">377         FALLTHROUGH;</span>
<span class="line-removed">378     case State::Validated:</span>
<span class="line-removed">379         prepare();</span>
<span class="line-removed">380         return;</span>
<span class="line-removed">381     case State::Prepared:</span>
<span class="line-removed">382         compileFunctions(effort);</span>
<span class="line-removed">383         return;</span>
<span class="line-removed">384     default:</span>
<span class="line-removed">385         break;</span>
<span class="line-removed">386     }</span>
<span class="line-removed">387     return;</span>
388 }
389 
390 } } // namespace JSC::Wasm
391 
392 #endif // ENABLE(WEBASSEMBLY)
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  3  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BytecodeDumper.h&quot;
 29 
 30 #include &quot;ArithProfile.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;B3Type.h&quot;</span>
<span class="line-added"> 32 #include &quot;BytecodeGenerator.h&quot;</span>
 33 #include &quot;BytecodeStructs.h&quot;
 34 #include &quot;CallLinkStatus.h&quot;
 35 #include &quot;CodeBlock.h&quot;
 36 #include &quot;Error.h&quot;
 37 #include &quot;HeapInlines.h&quot;
 38 #include &quot;InterpreterInlines.h&quot;
 39 #include &quot;PolymorphicAccess.h&quot;
 40 #include &quot;PutByIdFlags.h&quot;
 41 #include &quot;StructureInlines.h&quot;
 42 #include &quot;ToThisStatus.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 43 #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
 44 #include &quot;UnlinkedMetadataTableInlines.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 45 #include &quot;WasmFunctionCodeBlock.h&quot;</span>
<span class="line-added"> 46 #include &quot;WasmGeneratorTraits.h&quot;</span>
<span class="line-added"> 47 #include &quot;WasmModuleInformation.h&quot;</span>
<span class="line-added"> 48 #include &quot;WasmOps.h&quot;</span>
<span class="line-added"> 49 #include &quot;WasmSignatureInlines.h&quot;</span>
 50 
 51 namespace JSC {
 52 
<a name="4" id="anc4"></a><span class="line-modified"> 53 static ALWAYS_INLINE bool isConstantRegisterIndex(int index)</span>

 54 {
<a name="5" id="anc5"></a><span class="line-modified"> 55     return index &gt;= FirstConstantRegisterIndex;</span>
 56 }
 57 
<a name="6" id="anc6"></a><span class="line-modified"> 58 void BytecodeDumperBase::printLocationAndOp(InstructionStream::Offset location, const char* op)</span>

 59 {
<a name="7" id="anc7"></a><span class="line-modified"> 60     m_currentLocation = location;</span>
<span class="line-added"> 61     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);</span>
 62 }
 63 
<a name="8" id="anc8"></a><span class="line-modified"> 64 void BytecodeDumperBase::dumpValue(VirtualRegister reg)</span>
 65 {
<a name="9" id="anc9"></a><span class="line-modified"> 66     m_out.printf(&quot;%s&quot;, registerName(reg).data());</span>
<span class="line-added"> 67 }</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 template&lt;typename Traits&gt;</span>
<span class="line-added"> 70 void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Traits&gt; label)</span>
<span class="line-added"> 71 {</span>
<span class="line-added"> 72     int target = label.target();</span>
<span class="line-added"> 73     if (!target)</span>
<span class="line-added"> 74         target = outOfLineJumpOffset(m_currentLocation);</span>
<span class="line-added"> 75     InstructionStream::Offset targetOffset = target + m_currentLocation;</span>
<span class="line-added"> 76     m_out.print(target, &quot;(-&gt;&quot;, targetOffset, &quot;)&quot;);</span>
 77 }
 78 
<a name="10" id="anc10"></a><span class="line-added"> 79 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;JSGeneratorTraits&gt;);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 82 template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Wasm::GeneratorTraits&gt;);</span>
<span class="line-added"> 83 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added"> 84 </span>
 85 template&lt;class Block&gt;
<a name="11" id="anc11"></a><span class="line-modified"> 86 CString BytecodeDumper&lt;Block&gt;::registerName(VirtualRegister r) const</span>
 87 {
<a name="12" id="anc12"></a><span class="line-modified"> 88     if (r.isConstant())</span>
 89         return constantName(r);
 90 
<a name="13" id="anc13"></a><span class="line-modified"> 91     return toCString(r);</span>
 92 }
 93 
<a name="14" id="anc14"></a><span class="line-modified"> 94 template &lt;class Block&gt;</span>
<span class="line-modified"> 95 int BytecodeDumper&lt;Block&gt;::outOfLineJumpOffset(InstructionStream::Offset offset) const</span>
 96 {
<a name="15" id="anc15"></a><span class="line-modified"> 97     return m_block-&gt;outOfLineJumpOffset(offset);</span>

 98 }
 99 
100 template&lt;class Block&gt;
<a name="16" id="anc16"></a><span class="line-modified">101 CString BytecodeDumper&lt;Block&gt;::constantName(VirtualRegister reg) const</span>
102 {
<a name="17" id="anc17"></a><span class="line-modified">103     auto value = block()-&gt;getConstant(reg);</span>
<span class="line-modified">104     return toCString(value, &quot;(&quot;, reg, &quot;)&quot;);</span>
105 }
106 
107 template&lt;class Block&gt;
108 void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
109 {
110     ::JSC::dumpBytecode(this, it.offset(), it.ptr());
<a name="18" id="anc18"></a><span class="line-modified">111     this-&gt;m_out.print(&quot;\n&quot;);</span>
112 }
113 
114 template&lt;class Block&gt;
115 void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
116 {
117     BytecodeDumper dumper(block, out);
118     dumper.dumpBytecode(it, statusMap);
119 }
120 
121 template&lt;class Block&gt;
<a name="19" id="anc19"></a><span class="line-modified">122 VM&amp; CodeBlockBytecodeDumper&lt;Block&gt;::vm() const</span>
123 {
<a name="20" id="anc20"></a><span class="line-modified">124     return this-&gt;block()-&gt;vm();</span>
<span class="line-modified">125 }</span>
<span class="line-added">126 </span>
<span class="line-added">127 template&lt;class Block&gt;</span>
<span class="line-added">128 const Identifier&amp; CodeBlockBytecodeDumper&lt;Block&gt;::identifier(int index) const</span>
<span class="line-added">129 {</span>
<span class="line-added">130     return this-&gt;block()-&gt;identifier(index);</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 template&lt;class Block&gt;</span>
<span class="line-added">134 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpIdentifiers()</span>
<span class="line-added">135 {</span>
<span class="line-added">136     if (size_t count = this-&gt;block()-&gt;numberOfIdentifiers()) {</span>
<span class="line-added">137         this-&gt;m_out.printf(&quot;\nIdentifiers:\n&quot;);</span>
138         size_t i = 0;
139         do {
<a name="21" id="anc21"></a><span class="line-modified">140             this-&gt;m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);</span>
141             ++i;
142         } while (i != count);
143     }
144 }
145 
146 template&lt;class Block&gt;
<a name="22" id="anc22"></a><span class="line-modified">147 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpConstants()</span>
148 {
<a name="23" id="anc23"></a><span class="line-modified">149     if (!this-&gt;block()-&gt;constantRegisters().isEmpty()) {</span>
<span class="line-modified">150         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
151         size_t i = 0;
<a name="24" id="anc24"></a><span class="line-modified">152         for (const auto&amp; constant : this-&gt;block()-&gt;constantRegisters()) {</span>
153             const char* sourceCodeRepresentationDescription = nullptr;
<a name="25" id="anc25"></a><span class="line-modified">154             switch (this-&gt;block()-&gt;constantsSourceCodeRepresentation()[i]) {</span>
155             case SourceCodeRepresentation::Double:
156                 sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
157                 break;
158             case SourceCodeRepresentation::Integer:
159                 sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
160                 break;
161             case SourceCodeRepresentation::Other:
162                 sourceCodeRepresentationDescription = &quot;&quot;;
163                 break;
<a name="26" id="anc26"></a><span class="line-added">164             case SourceCodeRepresentation::LinkTimeConstant:</span>
<span class="line-added">165                 sourceCodeRepresentationDescription = &quot;: in source as linke-time-constant&quot;;</span>
<span class="line-added">166                 break;</span>
167             }
<a name="27" id="anc27"></a><span class="line-modified">168             this-&gt;m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);</span>
169             ++i;
170         }
171     }
172 }
173 
174 template&lt;class Block&gt;
<a name="28" id="anc28"></a><span class="line-modified">175 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()</span>
176 {
<a name="29" id="anc29"></a><span class="line-modified">177     if (unsigned count = this-&gt;block()-&gt;numberOfExceptionHandlers()) {</span>
<span class="line-modified">178         this-&gt;m_out.printf(&quot;\nException Handlers:\n&quot;);</span>
179         unsigned i = 0;
180         do {
<a name="30" id="anc30"></a><span class="line-modified">181             const auto&amp; handler = this-&gt;block()-&gt;exceptionHandler(i);</span>
<span class="line-modified">182             this-&gt;m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());</span>
183             ++i;
184         } while (i &lt; count);
185     }
186 }
187 
188 template&lt;class Block&gt;
<a name="31" id="anc31"></a><span class="line-modified">189 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()</span>
190 {
<a name="32" id="anc32"></a><span class="line-modified">191     if (unsigned count = this-&gt;block()-&gt;numberOfSwitchJumpTables()) {</span>
<span class="line-modified">192         this-&gt;m_out.printf(&quot;Switch Jump Tables:\n&quot;);</span>
193         unsigned i = 0;
194         do {
<a name="33" id="anc33"></a><span class="line-modified">195             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">196             const auto&amp; switchJumpTable = this-&gt;block()-&gt;switchJumpTable(i);</span>
197             int entry = 0;
198             auto end = switchJumpTable.branchOffsets.end();
199             for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
200                 if (!*iter)
201                     continue;
<a name="34" id="anc34"></a><span class="line-modified">202                 this-&gt;m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);</span>
203             }
<a name="35" id="anc35"></a><span class="line-modified">204             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
205             ++i;
206         } while (i &lt; count);
207     }
208 }
209 
210 template&lt;class Block&gt;
<a name="36" id="anc36"></a><span class="line-modified">211 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()</span>
212 {
<a name="37" id="anc37"></a><span class="line-modified">213     if (unsigned count = this-&gt;block()-&gt;numberOfStringSwitchJumpTables()) {</span>
<span class="line-modified">214         this-&gt;m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);</span>
215         unsigned i = 0;
216         do {
<a name="38" id="anc38"></a><span class="line-modified">217             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">218             const auto&amp; stringSwitchJumpTable = this-&gt;block()-&gt;stringSwitchJumpTable(i);</span>
219             auto end = stringSwitchJumpTable.offsetTable.end();
220             for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
<a name="39" id="anc39"></a><span class="line-modified">221                 this-&gt;m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);</span>
<span class="line-modified">222             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
223             ++i;
224         } while (i &lt; count);
225     }
226 }
227 
228 template&lt;class Block&gt;
<a name="40" id="anc40"></a><span class="line-modified">229 void CodeBlockBytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)</span>
230 {
231     size_t instructionCount = 0;
232     size_t wide16InstructionCount = 0;
233     size_t wide32InstructionCount = 0;
234     size_t instructionWithMetadataCount = 0;
235 
236     for (const auto&amp; instruction : instructions) {
237         if (instruction-&gt;isWide16())
238             ++wide16InstructionCount;
239         else if (instruction-&gt;isWide32())
240             ++wide32InstructionCount;
241         if (instruction-&gt;hasMetadata())
242             ++instructionWithMetadataCount;
243         ++instructionCount;
244     }
245 
246     out.print(*block);
247     out.printf(
248         &quot;: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions, %lu instructions with metadata); %lu bytes (%lu metadata bytes); %d parameter(s); %d callee register(s); %d variable(s)&quot;,
249         static_cast&lt;unsigned long&gt;(instructionCount),
250         static_cast&lt;unsigned long&gt;(wide16InstructionCount),
251         static_cast&lt;unsigned long&gt;(wide32InstructionCount),
252         static_cast&lt;unsigned long&gt;(instructionWithMetadataCount),
253         static_cast&lt;unsigned long&gt;(instructions.sizeInBytes() + block-&gt;metadataSizeInBytes()),
254         static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
255         block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
256     out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
257     out.printf(&quot;\n&quot;);
258 
<a name="41" id="anc41"></a><span class="line-modified">259     CodeBlockBytecodeDumper&lt;Block&gt; dumper(block, out);</span>
260     for (const auto&amp; it : instructions)
261         dumper.dumpBytecode(it, statusMap);
262 
263     dumper.dumpIdentifiers();
264     dumper.dumpConstants();
265     dumper.dumpExceptionHandlers();
266     dumper.dumpSwitchJumpTables();
267     dumper.dumpStringSwitchJumpTables();
268 
269     out.printf(&quot;\n&quot;);
270 }
271 
<a name="42" id="anc42"></a>
272 template class BytecodeDumper&lt;CodeBlock&gt;;
<a name="43" id="anc43"></a><span class="line-added">273 template class CodeBlockBytecodeDumper&lt;UnlinkedCodeBlockGenerator&gt;;</span>
<span class="line-added">274 template class CodeBlockBytecodeDumper&lt;CodeBlock&gt;;</span>
<span class="line-added">275 </span>
<span class="line-added">276 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">277 </span>
<span class="line-added">278 namespace Wasm {</span>
<span class="line-added">279 </span>
<span class="line-added">280 void BytecodeDumper::dumpBlock(FunctionCodeBlock* block, const ModuleInformation&amp; moduleInformation, PrintStream&amp; out)</span>
<span class="line-added">281 {</span>
<span class="line-added">282     size_t instructionCount = 0;</span>
<span class="line-added">283     size_t wide16InstructionCount = 0;</span>
<span class="line-added">284     size_t wide32InstructionCount = 0;</span>
<span class="line-added">285 </span>
<span class="line-added">286     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">287         if (it-&gt;isWide16())</span>
<span class="line-added">288             ++wide16InstructionCount;</span>
<span class="line-added">289         else if (it-&gt;isWide32())</span>
<span class="line-added">290             ++wide32InstructionCount;</span>
<span class="line-added">291         ++instructionCount;</span>
<span class="line-added">292     }</span>
<span class="line-added">293 </span>
<span class="line-added">294     size_t functionIndexSpace = moduleInformation.importFunctionCount() + block-&gt;functionIndex();</span>
<span class="line-added">295     out.print(makeString(IndexOrName(functionIndexSpace, moduleInformation.nameSection-&gt;get(functionIndexSpace))));</span>
<span class="line-added">296 </span>
<span class="line-added">297     const auto&amp; function = moduleInformation.functions[block-&gt;functionIndex()];</span>
<span class="line-added">298     SignatureIndex signatureIndex = moduleInformation.internalFunctionSignatureIndices[block-&gt;functionIndex()];</span>
<span class="line-added">299     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">300     out.print(&quot; : &quot;, signature, &quot;\n&quot;);</span>
<span class="line-added">301     out.print(&quot;wasm size: &quot;, function.data.size(), &quot; bytes\n&quot;);</span>
<span class="line-added">302 </span>
<span class="line-added">303     out.printf(</span>
<span class="line-added">304         &quot;bytecode: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions); %lu bytes; %d parameter(s); %d local(s); %d callee register(s)\n&quot;,</span>
<span class="line-added">305         static_cast&lt;unsigned long&gt;(instructionCount),</span>
<span class="line-added">306         static_cast&lt;unsigned long&gt;(wide16InstructionCount),</span>
<span class="line-added">307         static_cast&lt;unsigned long&gt;(wide32InstructionCount),</span>
<span class="line-added">308         static_cast&lt;unsigned long&gt;(block-&gt;instructions().sizeInBytes()),</span>
<span class="line-added">309         block-&gt;numArguments(),</span>
<span class="line-added">310         block-&gt;numVars(),</span>
<span class="line-added">311         block-&gt;numCalleeLocals());</span>
<span class="line-added">312 </span>
<span class="line-added">313     BytecodeDumper dumper(block, out);</span>
<span class="line-added">314     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">315         dumpWasm(&amp;dumper, it.offset(), it.ptr());</span>
<span class="line-added">316         out.print(&quot;\n&quot;);</span>
<span class="line-added">317     }</span>
<span class="line-added">318 </span>
<span class="line-added">319     dumper.dumpConstants();</span>
<span class="line-added">320 </span>
<span class="line-added">321     out.printf(&quot;\n&quot;);</span>
<span class="line-added">322 }</span>
<span class="line-added">323 </span>
<span class="line-added">324 void BytecodeDumper::dumpConstants()</span>
<span class="line-added">325 {</span>
<span class="line-added">326     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">327     if (!block-&gt;constants().isEmpty()) {</span>
<span class="line-added">328         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
<span class="line-added">329         unsigned i = 0;</span>
<span class="line-added">330         for (const auto&amp; constant : block-&gt;constants()) {</span>
<span class="line-added">331             Type type = block-&gt;constantTypes()[i];</span>
<span class="line-added">332             this-&gt;m_out.print(&quot;   const&quot;, i, &quot; : &quot;, type, &quot; = &quot;, formatConstant(type, constant), &quot;\n&quot;);</span>
<span class="line-added">333             ++i;</span>
<span class="line-added">334         }</span>
<span class="line-added">335     }</span>
<span class="line-added">336 }</span>
<span class="line-added">337 </span>
<span class="line-added">338 CString BytecodeDumper::constantName(VirtualRegister index) const</span>
<span class="line-added">339 {</span>
<span class="line-added">340     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">341     auto value = formatConstant(block-&gt;getConstantType(index), block-&gt;getConstant(index));</span>
<span class="line-added">342     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 CString BytecodeDumper::formatConstant(Type type, uint64_t constant) const</span>
<span class="line-added">346 {</span>
<span class="line-added">347     switch (type) {</span>
<span class="line-added">348     case Type::I32:</span>
<span class="line-added">349         return toCString(static_cast&lt;int32_t&gt;(constant));</span>
<span class="line-added">350     case Type::I64:</span>
<span class="line-added">351         return toCString(constant);</span>
<span class="line-added">352     case Type::F32:</span>
<span class="line-added">353         return toCString(bitwise_cast&lt;float&gt;(static_cast&lt;int32_t&gt;(constant)));</span>
<span class="line-added">354         break;</span>
<span class="line-added">355     case Type::F64:</span>
<span class="line-added">356         return toCString(bitwise_cast&lt;double&gt;(constant));</span>
<span class="line-added">357         break;</span>
<span class="line-added">358     case Type::Anyref:</span>
<span class="line-added">359     case Type::Funcref:</span>
<span class="line-added">360         if (JSValue::decode(constant) == jsNull())</span>
<span class="line-added">361             return &quot;null&quot;;</span>
<span class="line-added">362         return toCString(RawPointer(bitwise_cast&lt;void*&gt;(constant)));</span>
<span class="line-added">363     default:</span>
<span class="line-added">364         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">365         return &quot;&quot;;</span>
<span class="line-added">366     }</span>
<span class="line-added">367 }</span>
<span class="line-added">368 </span>
<span class="line-added">369 } // namespace Wasm</span>
370 
<a name="44" id="anc44"></a><span class="line-added">371 #endif // ENABLE(WEBASSEMBLY)</span>
372 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
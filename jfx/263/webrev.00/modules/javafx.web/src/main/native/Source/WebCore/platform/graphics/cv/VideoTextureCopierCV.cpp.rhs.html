<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/cv/VideoTextureCopierCV.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2016 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;VideoTextureCopierCV.h&quot;
  28 
  29 #if HAVE(CORE_VIDEO)
  30 
  31 #include &quot;FourCC.h&quot;
  32 #include &quot;Logging.h&quot;
  33 #include &quot;TextureCacheCV.h&quot;
  34 #include &lt;pal/spi/cocoa/IOSurfaceSPI.h&gt;
  35 #include &lt;wtf/NeverDestroyed.h&gt;
  36 #include &lt;wtf/StdMap.h&gt;
  37 #include &lt;wtf/text/StringBuilder.h&gt;
  38 
  39 #if USE(OPENGL_ES)
  40 #include &lt;OpenGLES/ES3/glext.h&gt;
  41 #endif
  42 
<a name="1" id="anc1"></a><span class="line-added">  43 #if USE(ANGLE)</span>
<span class="line-added">  44 #define EGL_EGL_PROTOTYPES 0</span>
<span class="line-added">  45 #include &lt;ANGLE/egl.h&gt;</span>
<span class="line-added">  46 #include &lt;ANGLE/eglext.h&gt;</span>
<span class="line-added">  47 #include &lt;ANGLE/eglext_angle.h&gt;</span>
<span class="line-added">  48 #include &lt;ANGLE/entry_points_egl.h&gt;</span>
<span class="line-added">  49 #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;</span>
<span class="line-added">  50 // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.</span>
<span class="line-added">  51 #define GL_ANGLE_explicit_context</span>
<span class="line-added">  52 #include &lt;ANGLE/gl2ext.h&gt;</span>
<span class="line-added">  53 #include &lt;ANGLE/gl2ext_angle.h&gt;</span>
<span class="line-added">  54 #endif</span>
<span class="line-added">  55 </span>
  56 #include &quot;CoreVideoSoftLink.h&quot;
  57 
  58 namespace WebCore {
  59 
  60 #if HAVE(IOSURFACE)
  61 enum class PixelRange {
  62     Unknown,
  63     Video,
  64     Full,
  65 };
  66 
<a name="2" id="anc2"></a><span class="line-modified">  67 enum class TransferFunctionCV {</span>
  68     Unknown,
  69     kITU_R_709_2,
  70     kITU_R_601_4,
  71     kSMPTE_240M_1995,
  72     kDCI_P3,
  73     kP3_D65,
  74     kITU_R_2020,
  75 };
  76 
  77 static PixelRange pixelRangeFromPixelFormat(OSType pixelFormat)
  78 {
  79     switch (pixelFormat) {
  80     case kCVPixelFormatType_4444AYpCbCr8:
  81     case kCVPixelFormatType_4444AYpCbCr16:
  82     case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
  83     case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
  84     case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
  85     case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
  86     case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
  87         return PixelRange::Video;
  88     case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
  89     case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
  90     case kCVPixelFormatType_422YpCbCr8FullRange:
  91     case kCVPixelFormatType_ARGB2101010LEPacked:
  92     case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
  93     case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
  94     case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
  95         return PixelRange::Full;
  96     default:
  97         return PixelRange::Unknown;
  98     }
  99 }
 100 
<a name="3" id="anc3"></a><span class="line-modified"> 101 static TransferFunctionCV transferFunctionFromString(CFStringRef string)</span>
 102 {
 103     if (!string || CFGetTypeID(string) != CFStringGetTypeID())
<a name="4" id="anc4"></a><span class="line-modified"> 104         return TransferFunctionCV::Unknown;</span>
 105     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_709_2))
<a name="5" id="anc5"></a><span class="line-modified"> 106         return TransferFunctionCV::kITU_R_709_2;</span>
 107     if (CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_601_4))
<a name="6" id="anc6"></a><span class="line-modified"> 108         return TransferFunctionCV::kITU_R_601_4;</span>
 109     if (CFEqual(string, kCVImageBufferYCbCrMatrix_SMPTE_240M_1995))
<a name="7" id="anc7"></a><span class="line-modified"> 110         return TransferFunctionCV::kSMPTE_240M_1995;</span>
 111     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_DCI_P3() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_DCI_P3))
<a name="8" id="anc8"></a><span class="line-modified"> 112         return TransferFunctionCV::kDCI_P3;</span>
 113     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_P3_D65() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_P3_D65))
<a name="9" id="anc9"></a><span class="line-modified"> 114         return TransferFunctionCV::kP3_D65;</span>
 115     if (canLoad_CoreVideo_kCVImageBufferYCbCrMatrix_ITU_R_2020() &amp;&amp; CFEqual(string, kCVImageBufferYCbCrMatrix_ITU_R_2020))
<a name="10" id="anc10"></a><span class="line-modified"> 116         return TransferFunctionCV::kITU_R_2020;</span>
<span class="line-modified"> 117     return TransferFunctionCV::Unknown;</span>
 118 }
 119 
 120 struct GLfloatColor {
 121     union {
 122         struct {
 123             GLfloat r;
 124             GLfloat g;
 125             GLfloat b;
 126         } rgb;
 127         struct {
 128             GLfloat y;
 129             GLfloat cb;
 130             GLfloat cr;
 131         } ycbcr;
 132     };
 133 
 134     constexpr GLfloatColor(GLfloat r, GLfloat g, GLfloat b)
 135         : rgb { r, g, b }
 136     {
 137     }
 138 
 139     constexpr GLfloatColor(int r, int g, int b, GLfloat scale)
 140         : rgb { r / scale, g / scale, b / scale}
 141     {
 142     }
 143 
 144     static constexpr GLfloat abs(GLfloat value)
 145     {
 146         return value &gt;= 0 ? value : -value;
 147     }
 148 
 149     constexpr bool isApproximatelyEqualTo(const GLfloatColor&amp; color, GLfloat maxDelta) const
 150     {
 151         return abs(rgb.r - color.rgb.r) &lt; abs(maxDelta)
 152             &amp;&amp; abs(rgb.g - color.rgb.g) &lt; abs(maxDelta)
 153             &amp;&amp; abs(rgb.b - color.rgb.b) &lt; abs(maxDelta);
 154     }
 155 };
 156 
 157 struct GLfloatColors {
 158     static constexpr GLfloatColor black   {0, 0, 0};
 159     static constexpr GLfloatColor white   {1, 1, 1};
 160     static constexpr GLfloatColor red     {1, 0, 0};
 161     static constexpr GLfloatColor green   {0, 1, 0};
 162     static constexpr GLfloatColor blue    {0, 0, 1};
 163     static constexpr GLfloatColor cyan    {0, 1, 1};
 164     static constexpr GLfloatColor magenta {1, 0, 1};
 165     static constexpr GLfloatColor yellow  {1, 1, 0};
 166 };
 167 
 168 struct YCbCrMatrix {
 169     union {
 170         GLfloat rows[4][4];
 171         GLfloat data[16];
 172     };
 173 
 174     constexpr YCbCrMatrix(PixelRange, GLfloat cbCoefficient, GLfloat crCoefficient);
 175 
 176     operator Vector&lt;GLfloat&gt;() const
 177     {
 178         Vector&lt;GLfloat&gt; vector;
 179         vector.append(data, 16);
 180         return vector;
 181     }
 182 
 183     constexpr GLfloatColor operator*(const GLfloatColor&amp;) const;
 184 };
 185 
 186 constexpr YCbCrMatrix::YCbCrMatrix(PixelRange range, GLfloat cbCoefficient, GLfloat crCoefficient)
 187     : rows { }
 188 {
 189     // The conversion from YCbCr -&gt; RGB generally takes the form:
 190     // Y = Kr * R + Kg * G + Kb * B
 191     // Cb = (B - Y) / (2 * (1 - Kb))
 192     // Cr = (R - Y) / (2 * (1 - Kr))
 193     // Where the values of Kb and Kr are defined in a specification and Kg is derived from: Kr + Kg + Kb = 1
 194     //
 195     // Solving the above equations for R, B, and G derives the following:
 196     // R = Y + (2 * (1 - Kr)) * Cr
 197     // B = Y + (2 * (1 - Kb)) * Cb
 198     // G = Y - (2 * (1 - Kb)) * (Kb / Kg) * Cb - ((1 - Kr) * 2) * (Kr / Kg) * Cr
 199     //
 200     // When the color values are Video range, Y has a range of [16, 235] with a width of 219, and Cb &amp; Cr have
 201     // a range of [16, 240] with a width of 224. When the color values are Full range, Y, Cb, and Cr all have
 202     // a range of [0, 255] with a width of 256.
 203 
 204     GLfloat cgCoefficient = 1 - cbCoefficient - crCoefficient;
 205     GLfloat yScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 219.f;
 206     GLfloat cbcrScalingFactor = range == PixelRange::Full ? 1.f : 255.f / 224.f;
 207 
 208     rows[0][0] = yScalingFactor;
 209     rows[0][1] = 0;
 210     rows[0][2] = cbcrScalingFactor * 2 * (1 - crCoefficient);
 211     rows[0][3] = 0;
 212 
 213     rows[1][0] = yScalingFactor;
 214     rows[1][1] = -cbcrScalingFactor * 2 * (1 - cbCoefficient) * (cbCoefficient / cgCoefficient);
 215     rows[1][2] = -cbcrScalingFactor * 2 * (1 - crCoefficient) * (crCoefficient / cgCoefficient);
 216     rows[1][3] = 0;
 217 
 218     rows[2][0] = yScalingFactor;
 219     rows[2][1] = cbcrScalingFactor * 2 * (1 - cbCoefficient);
 220     rows[2][2] = 0;
 221     rows[2][3] = 0;
 222 
 223     rows[3][0] = 0;
 224     rows[3][1] = 0;
 225     rows[3][2] = 0;
 226     rows[3][3] = 1;
 227 
 228     // Configure the final column of the matrix to convert Cb and Cr to [-128, 128]
 229     // and, in the case of video-range, to convert Y to [16, 240]:
 230     for (auto rowNumber = 0; rowNumber &lt; 3; ++rowNumber) {
 231         auto&amp; row = rows[rowNumber];
 232         auto&amp; x = row[0];
 233         auto&amp; y = row[1];
 234         auto&amp; z = row[2];
 235         auto&amp; w = row[3];
 236 
 237         w -= (y + z) * 128 / 255;
 238         if (range == PixelRange::Video)
 239             w -= x * 16 / 255;
 240     }
 241 }
 242 
 243 constexpr GLfloatColor YCbCrMatrix::operator*(const GLfloatColor&amp; color) const
 244 {
 245     return GLfloatColor(
 246         rows[0][0] * color.rgb.r + rows[0][1] * color.rgb.g + rows[0][2] * color.rgb.b + rows[0][3],
 247         rows[1][0] * color.rgb.r + rows[1][1] * color.rgb.g + rows[1][2] * color.rgb.b + rows[1][3],
 248         rows[2][0] * color.rgb.r + rows[2][1] * color.rgb.g + rows[2][2] * color.rgb.b + rows[2][3]
 249     );
 250 }
 251 
<a name="11" id="anc11"></a><span class="line-modified"> 252 static const Vector&lt;GLfloat&gt; YCbCrToRGBMatrixForRangeAndTransferFunction(PixelRange range, TransferFunctionCV transferFunction)</span>
 253 {
<a name="12" id="anc12"></a><span class="line-modified"> 254     using MapKey = std::pair&lt;PixelRange, TransferFunctionCV&gt;;</span>
 255     using MatrixMap = StdMap&lt;MapKey, Vector&lt;GLfloat&gt;&gt;;
 256 
 257     static NeverDestroyed&lt;MatrixMap&gt; matrices;
 258     static dispatch_once_t onceToken;
 259 
 260     // Matrices are derived from the components in the ITU R.601 rev 4 specification
 261     // https://www.itu.int/rec/R-REC-BT.601
 262     constexpr static YCbCrMatrix r601VideoMatrix { PixelRange::Video, 0.114f, 0.299f };
 263     constexpr static YCbCrMatrix r601FullMatrix { PixelRange::Full, 0.114f, 0.299f };
 264 
 265     static_assert((r601VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 video matrix does not produce black color&quot;);
 266     static_assert((r601VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 video matrix does not produce white color&quot;);
 267     static_assert((r601VideoMatrix * GLfloatColor(81,  90,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 video matrix does not produce red color&quot;);
 268     static_assert((r601VideoMatrix * GLfloatColor(145, 54,  34,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 video matrix does not produce green color&quot;);
 269     static_assert((r601VideoMatrix * GLfloatColor(41,  240, 110, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 video matrix does not produce blue color&quot;);
 270     static_assert((r601VideoMatrix * GLfloatColor(210, 16,  146, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 video matrix does not produce yellow color&quot;);
 271     static_assert((r601VideoMatrix * GLfloatColor(106, 202, 222, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 video matrix does not produce magenta color&quot;);
 272     static_assert((r601VideoMatrix * GLfloatColor(170, 166, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 video matrix does not produce cyan color&quot;);
 273 
 274     static_assert((r601FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.610 full matrix does not produce black color&quot;);
 275     static_assert((r601FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.610 full matrix does not produce white color&quot;);
 276     static_assert((r601FullMatrix * GLfloatColor(76,  85,  255, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.610 full matrix does not produce red color&quot;);
 277     static_assert((r601FullMatrix * GLfloatColor(150, 44,  21,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.610 full matrix does not produce green color&quot;);
 278     static_assert((r601FullMatrix * GLfloatColor(29,  255, 107, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.610 full matrix does not produce blue color&quot;);
 279     static_assert((r601FullMatrix * GLfloatColor(226, 0,   149, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.610 full matrix does not produce yellow color&quot;);
 280     static_assert((r601FullMatrix * GLfloatColor(105, 212, 235, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.610 full matrix does not produce magenta color&quot;);
 281     static_assert((r601FullMatrix * GLfloatColor(179, 171, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.610 full matrix does not produce cyan color&quot;);
 282 
 283     // Matrices are derived from the components in the ITU R.709 rev 2 specification
 284     // https://www.itu.int/rec/R-REC-BT.709-2-199510-S
 285     constexpr static YCbCrMatrix r709VideoMatrix { PixelRange::Video, 0.0722, 0.2126 };
 286     constexpr static YCbCrMatrix r709FullMatrix { PixelRange::Full, 0.0722, 0.2126 };
 287 
 288     static_assert((r709VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 video matrix does not produce black color&quot;);
 289     static_assert((r709VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 video matrix does not produce white color&quot;);
 290     static_assert((r709VideoMatrix * GLfloatColor(63,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 video matrix does not produce red color&quot;);
 291     static_assert((r709VideoMatrix * GLfloatColor(173, 42,  26,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 video matrix does not produce green color&quot;);
 292     static_assert((r709VideoMatrix * GLfloatColor(32,  240, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 video matrix does not produce blue color&quot;);
 293     static_assert((r709VideoMatrix * GLfloatColor(219, 16,  138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 video matrix does not produce yellow color&quot;);
 294     static_assert((r709VideoMatrix * GLfloatColor(78,  214, 230, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 video matrix does not produce magenta color&quot;);
 295     static_assert((r709VideoMatrix * GLfloatColor(188, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 video matrix does not produce cyan color&quot;);
 296 
 297     static_assert((r709FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;r.709 full matrix does not produce black color&quot;);
 298     static_assert((r709FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;r.709 full matrix does not produce white color&quot;);
 299     static_assert((r709FullMatrix * GLfloatColor(54,  99,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;r.709 full matrix does not produce red color&quot;);
 300     static_assert((r709FullMatrix * GLfloatColor(182, 30,  12,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;r.709 full matrix does not produce green color&quot;);
 301     static_assert((r709FullMatrix * GLfloatColor(18,  256, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;r.709 full matrix does not produce blue color&quot;);
 302     static_assert((r709FullMatrix * GLfloatColor(237, 1,   140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;r.709 full matrix does not produce yellow color&quot;);
 303     static_assert((r709FullMatrix * GLfloatColor(73,  226, 244, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;r.709 full matrix does not produce magenta color&quot;);
 304     static_assert((r709FullMatrix * GLfloatColor(201, 157, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;r.709 full matrix does not produce cyan color&quot;);
 305 
 306     // Matrices are derived from the components in the ITU-R BT.2020-2 specification
 307     // https://www.itu.int/rec/R-REC-BT.2020
 308     constexpr static YCbCrMatrix bt2020VideoMatrix { PixelRange::Video, 0.0593, 0.2627 };
 309     constexpr static YCbCrMatrix bt2020FullMatrix { PixelRange::Full, 0.0593, 0.2627 };
 310 
 311     static_assert((bt2020VideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce black color&quot;);
 312     static_assert((bt2020VideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce white color&quot;);
 313     static_assert((bt2020VideoMatrix * GLfloatColor(74,  97,  240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 video matrix does not produce red color&quot;);
 314     static_assert((bt2020VideoMatrix * GLfloatColor(164, 47,  25,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 video matrix does not produce green color&quot;);
 315     static_assert((bt2020VideoMatrix * GLfloatColor(29,  240, 119, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce blue color&quot;);
 316     static_assert((bt2020VideoMatrix * GLfloatColor(222, 16,  137, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 video matrix does not produce yellow color&quot;);
 317     static_assert((bt2020VideoMatrix * GLfloatColor(87,  209, 231, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 video matrix does not produce magenta color&quot;);
 318     static_assert((bt2020VideoMatrix * GLfloatColor(177, 159, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 video matrix does not produce cyan color&quot;);
 319 
 320     static_assert((bt2020FullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce black color&quot;);
 321     static_assert((bt2020FullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce white color&quot;);
 322     static_assert((bt2020FullMatrix * GLfloatColor(67,  92,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;bt.2020 full matrix does not produce red color&quot;);
 323     static_assert((bt2020FullMatrix * GLfloatColor(173, 36,  11,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;bt.2020 full matrix does not produce green color&quot;);
 324     static_assert((bt2020FullMatrix * GLfloatColor(15,  256, 118, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce blue color&quot;);
 325     static_assert((bt2020FullMatrix * GLfloatColor(240, 0,   138, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;bt.2020 full matrix does not produce yellow color&quot;);
 326     static_assert((bt2020FullMatrix * GLfloatColor(82,  220, 245, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;bt.2020 full matrix does not produce magenta color&quot;);
 327     static_assert((bt2020FullMatrix * GLfloatColor(188, 164, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;bt.2020 full matrix does not produce cyan color&quot;);
 328 
 329     // Matrices are derived from the components in the SMPTE 240M-1999 specification
 330     // http://ieeexplore.ieee.org/document/7291461/
 331     constexpr static YCbCrMatrix smpte240MVideoMatrix { PixelRange::Video, 0.087, 0.212 };
 332     constexpr static YCbCrMatrix smpte240MFullMatrix { PixelRange::Full, 0.087, 0.212 };
 333 
 334     static_assert((smpte240MVideoMatrix * GLfloatColor(16,  128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce black color&quot;);
 335     static_assert((smpte240MVideoMatrix * GLfloatColor(235, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce white color&quot;);
 336     static_assert((smpte240MVideoMatrix * GLfloatColor(62,  102, 240, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce red color&quot;);
 337     static_assert((smpte240MVideoMatrix * GLfloatColor(170, 42,  28,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce green color&quot;);
 338     static_assert((smpte240MVideoMatrix * GLfloatColor(35,  240, 116, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce blue color&quot;);
 339     static_assert((smpte240MVideoMatrix * GLfloatColor(216, 16,  140, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce yellow color&quot;);
 340     static_assert((smpte240MVideoMatrix * GLfloatColor(81,  214, 228, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce magenta color&quot;);
 341     static_assert((smpte240MVideoMatrix * GLfloatColor(189, 154, 16,  255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M video matrix does not produce cyan color&quot;);
 342 
 343     static_assert((smpte240MFullMatrix * GLfloatColor(0,   128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::black,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce black color&quot;);
 344     static_assert((smpte240MFullMatrix * GLfloatColor(255, 128, 128, 255)).isApproximatelyEqualTo(GLfloatColors::white,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce white color&quot;);
 345     static_assert((smpte240MFullMatrix * GLfloatColor(54,  98,  256, 255)).isApproximatelyEqualTo(GLfloatColors::red,     1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce red color&quot;);
 346     static_assert((smpte240MFullMatrix * GLfloatColor(179, 30,  15,  255)).isApproximatelyEqualTo(GLfloatColors::green,   1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce green color&quot;);
 347     static_assert((smpte240MFullMatrix * GLfloatColor(22,  256, 114, 255)).isApproximatelyEqualTo(GLfloatColors::blue,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce blue color&quot;);
 348     static_assert((smpte240MFullMatrix * GLfloatColor(233, 1,   142, 255)).isApproximatelyEqualTo(GLfloatColors::yellow,  1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce yellow color&quot;);
 349     static_assert((smpte240MFullMatrix * GLfloatColor(76,  226, 241, 255)).isApproximatelyEqualTo(GLfloatColors::magenta, 1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce magenta color&quot;);
 350     static_assert((smpte240MFullMatrix * GLfloatColor(201, 158, 1,   255)).isApproximatelyEqualTo(GLfloatColors::cyan,    1.5f / 255.f), &quot;SMPTE 240M full matrix does not produce cyan color&quot;);
 351 
 352     dispatch_once(&amp;onceToken, ^{
<a name="13" id="anc13"></a><span class="line-modified"> 353         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_601_4), r601VideoMatrix);</span>
<span class="line-modified"> 354         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_601_4), r601FullMatrix);</span>
<span class="line-modified"> 355         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_709_2), r709VideoMatrix);</span>
<span class="line-modified"> 356         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_709_2), r709FullMatrix);</span>
<span class="line-modified"> 357         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kITU_R_2020), bt2020VideoMatrix);</span>
<span class="line-modified"> 358         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kITU_R_2020), bt2020FullMatrix);</span>
<span class="line-modified"> 359         matrices.get().emplace(MapKey(PixelRange::Video, TransferFunctionCV::kSMPTE_240M_1995), smpte240MVideoMatrix);</span>
<span class="line-modified"> 360         matrices.get().emplace(MapKey(PixelRange::Full, TransferFunctionCV::kSMPTE_240M_1995), smpte240MFullMatrix);</span>
 361     });
 362 
 363     // We should never be asked to handle a Pixel Format whose range value is unknown.
 364     ASSERT(range != PixelRange::Unknown);
 365     if (range == PixelRange::Unknown)
 366         range = PixelRange::Full;
 367 
 368     auto iterator = matrices.get().find({range, transferFunction});
 369 
 370     // Assume unknown transfer functions are r.601:
 371     if (iterator == matrices.get().end())
<a name="14" id="anc14"></a><span class="line-modified"> 372         iterator = matrices.get().find({range, TransferFunctionCV::kITU_R_601_4});</span>
 373 
 374     ASSERT(iterator != matrices.get().end());
 375     return iterator-&gt;second;
 376 }
 377 #endif // HAVE(IOSURFACE)
 378 
<a name="15" id="anc15"></a><span class="line-modified"> 379 VideoTextureCopierCV::VideoTextureCopierCV(GraphicsContextGLOpenGL&amp; context)</span>
 380     : m_sharedContext(context)
<a name="16" id="anc16"></a><span class="line-modified"> 381     , m_context(GraphicsContextGLOpenGL::createShared(context))</span>
 382     , m_framebuffer(context.createFramebuffer())
 383 {
 384 }
 385 
 386 VideoTextureCopierCV::~VideoTextureCopierCV()
 387 {
 388     if (m_vertexBuffer)
 389         m_context-&gt;deleteProgram(m_vertexBuffer);
 390     if (m_program)
 391         m_context-&gt;deleteProgram(m_program);
 392     if (m_yuvVertexBuffer)
 393         m_context-&gt;deleteProgram(m_yuvVertexBuffer);
 394     if (m_yuvProgram)
 395         m_context-&gt;deleteProgram(m_yuvProgram);
 396     m_context-&gt;deleteFramebuffer(m_framebuffer);
 397 }
 398 
 399 #if !LOG_DISABLED
 400 using StringMap = StdMap&lt;uint32_t, const char*&gt;;
 401 #define STRINGIFY_PAIR(e) e, #e
 402 static StringMap&amp; enumToStringMap()
 403 {
 404     static NeverDestroyed&lt;StringMap&gt; map;
 405     if (map.get().empty()) {
 406         StringMap stringMap;
<a name="17" id="anc17"></a><span class="line-modified"> 407         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="line-modified"> 408         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="line-modified"> 409         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 410         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="line-modified"> 411         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="line-modified"> 412         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8));</span>
<span class="line-modified"> 413         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16F));</span>
<span class="line-modified"> 414         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32F));</span>
<span class="line-modified"> 415         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8UI));</span>
<span class="line-modified"> 416         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R8I));</span>
<span class="line-modified"> 417         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16UI));</span>
<span class="line-modified"> 418         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R16I));</span>
<span class="line-modified"> 419         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32UI));</span>
<span class="line-modified"> 420         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::R32I));</span>
<span class="line-modified"> 421         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8));</span>
<span class="line-modified"> 422         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16F));</span>
<span class="line-modified"> 423         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32F));</span>
<span class="line-modified"> 424         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8UI));</span>
<span class="line-modified"> 425         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG8I));</span>
<span class="line-modified"> 426         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16UI));</span>
<span class="line-modified"> 427         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG16I));</span>
<span class="line-modified"> 428         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32UI));</span>
<span class="line-modified"> 429         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG32I));</span>
<span class="line-modified"> 430         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB8));</span>
<span class="line-modified"> 431         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8));</span>
<span class="line-modified"> 432         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA8));</span>
<span class="line-modified"> 433         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SRGB8_ALPHA8));</span>
<span class="line-modified"> 434         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA4));</span>
<span class="line-modified"> 435         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB10_A2));</span>
<span class="line-modified"> 436         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT16));</span>
<span class="line-modified"> 437         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT24));</span>
<span class="line-modified"> 438         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_COMPONENT32F));</span>
<span class="line-modified"> 439         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH24_STENCIL8));</span>
<span class="line-modified"> 440         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH32F_STENCIL8));</span>
<span class="line-modified"> 441         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGB));</span>
<span class="line-modified"> 442         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RGBA));</span>
<span class="line-modified"> 443         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE_ALPHA));</span>
<span class="line-modified"> 444         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::LUMINANCE));</span>
<span class="line-modified"> 445         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::ALPHA));</span>
<span class="line-modified"> 446         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RED));</span>
<span class="line-modified"> 447         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::RG_INTEGER));</span>
<span class="line-modified"> 448         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::DEPTH_STENCIL));</span>
<span class="line-modified"> 449         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_BYTE));</span>
<span class="line-modified"> 450         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_6_5));</span>
<span class="line-modified"> 451         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4));</span>
<span class="line-modified"> 452         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1));</span>
<span class="line-modified"> 453         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::BYTE));</span>
<span class="line-modified"> 454         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::HALF_FLOAT));</span>
<span class="line-modified"> 455         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT));</span>
<span class="line-modified"> 456         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_SHORT));</span>
<span class="line-modified"> 457         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::SHORT));</span>
<span class="line-modified"> 458         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT));</span>
<span class="line-modified"> 459         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::INT));</span>
<span class="line-modified"> 460         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV));</span>
<span class="line-modified"> 461         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::UNSIGNED_INT_24_8));</span>
<span class="line-modified"> 462         map.get().emplace(STRINGIFY_PAIR(GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV));</span>
 463 
 464 #if USE(OPENGL_ES)
 465         map.get().emplace(STRINGIFY_PAIR(GL_RED_INTEGER));
 466         map.get().emplace(STRINGIFY_PAIR(GL_RGB_INTEGER));
 467         map.get().emplace(STRINGIFY_PAIR(GL_RG8_SNORM));
 468         map.get().emplace(STRINGIFY_PAIR(GL_RGB565));
 469         map.get().emplace(STRINGIFY_PAIR(GL_RGB8_SNORM));
 470         map.get().emplace(STRINGIFY_PAIR(GL_R11F_G11F_B10F));
 471         map.get().emplace(STRINGIFY_PAIR(GL_RGB9_E5));
 472         map.get().emplace(STRINGIFY_PAIR(GL_RGB16F));
 473         map.get().emplace(STRINGIFY_PAIR(GL_RGB32F));
 474         map.get().emplace(STRINGIFY_PAIR(GL_RGB8UI));
 475         map.get().emplace(STRINGIFY_PAIR(GL_RGB8I));
 476         map.get().emplace(STRINGIFY_PAIR(GL_RGB16UI));
 477         map.get().emplace(STRINGIFY_PAIR(GL_RGB16I));
 478         map.get().emplace(STRINGIFY_PAIR(GL_RGB32UI));
 479         map.get().emplace(STRINGIFY_PAIR(GL_RGB32I));
 480         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8_SNORM));
 481         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16F));
 482         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32F));
 483         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8UI));
 484         map.get().emplace(STRINGIFY_PAIR(GL_RGBA8I));
 485         map.get().emplace(STRINGIFY_PAIR(GL_RGB10_A2UI));
 486         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16UI));
 487         map.get().emplace(STRINGIFY_PAIR(GL_RGBA16I));
 488         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32I));
 489         map.get().emplace(STRINGIFY_PAIR(GL_RGBA32UI));
 490         map.get().emplace(STRINGIFY_PAIR(GL_RGB5_A1));
 491         map.get().emplace(STRINGIFY_PAIR(GL_RG));
 492         map.get().emplace(STRINGIFY_PAIR(GL_RGBA_INTEGER));
 493         map.get().emplace(STRINGIFY_PAIR(GL_DEPTH_COMPONENT));
 494         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_10F_11F_11F_REV));
 495         map.get().emplace(STRINGIFY_PAIR(GL_UNSIGNED_INT_5_9_9_9_REV));
 496 #endif
 497     }
 498     return map.get();
 499 }
 500 
 501 #endif
 502 
 503 bool VideoTextureCopierCV::initializeContextObjects()
 504 {
 505     StringBuilder vertexShaderSource;
 506     vertexShaderSource.appendLiteral(&quot;attribute vec4 a_position;\n&quot;);
 507     vertexShaderSource.appendLiteral(&quot;uniform int u_flipY;\n&quot;);
 508     vertexShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 509     vertexShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 510     vertexShaderSource.appendLiteral(&quot;    v_texturePosition = vec2((a_position.x + 1.0) / 2.0, (a_position.y + 1.0) / 2.0);\n&quot;);
 511     vertexShaderSource.appendLiteral(&quot;    if (u_flipY == 1) {\n&quot;);
 512     vertexShaderSource.appendLiteral(&quot;        v_texturePosition.y = 1.0 - v_texturePosition.y;\n&quot;);
 513     vertexShaderSource.appendLiteral(&quot;    }\n&quot;);
 514     vertexShaderSource.appendLiteral(&quot;    gl_Position = a_position;\n&quot;);
 515     vertexShaderSource.appendLiteral(&quot;}\n&quot;);
 516 
<a name="18" id="anc18"></a><span class="line-modified"> 517     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
 518     m_context-&gt;shaderSource(vertexShader, vertexShaderSource.toString());
 519     m_context-&gt;compileShaderDirect(vertexShader);
 520 
<a name="19" id="anc19"></a><span class="line-modified"> 521     GCGLint value = 0;</span>
<span class="line-modified"> 522     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
 523     if (!value) {
 524         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Vertex shader failed to compile.&quot;, this);
 525         m_context-&gt;deleteShader(vertexShader);
 526         return false;
 527     }
 528 
 529     StringBuilder fragmentShaderSource;
 530 
<a name="20" id="anc20"></a><span class="line-modified"> 531 #if USE(OPENGL_ES) || USE(ANGLE)</span>
 532     fragmentShaderSource.appendLiteral(&quot;precision mediump float;\n&quot;);
<a name="21" id="anc21"></a><span class="line-added"> 533 #endif</span>
<span class="line-added"> 534 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 535     fragmentShaderSource.appendLiteral(&quot;uniform sampler2D u_texture;\n&quot;);
<a name="22" id="anc22"></a><span class="line-modified"> 536 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 537     fragmentShaderSource.appendLiteral(&quot;uniform sampler2DRect u_texture;\n&quot;);
<a name="23" id="anc23"></a>


 538 #else
 539 #error Unsupported configuration
 540 #endif
 541     fragmentShaderSource.appendLiteral(&quot;varying vec2 v_texturePosition;\n&quot;);
 542     fragmentShaderSource.appendLiteral(&quot;uniform int u_premultiply;\n&quot;);
 543     fragmentShaderSource.appendLiteral(&quot;uniform vec2 u_textureDimensions;\n&quot;);
 544     fragmentShaderSource.appendLiteral(&quot;uniform int u_swapColorChannels;\n&quot;);
 545     fragmentShaderSource.appendLiteral(&quot;void main() {\n&quot;);
 546     fragmentShaderSource.appendLiteral(&quot;    vec2 texPos = vec2(v_texturePosition.x * u_textureDimensions.x, v_texturePosition.y * u_textureDimensions.y);\n&quot;);
<a name="24" id="anc24"></a><span class="line-modified"> 547 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 548     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2D(u_texture, texPos);\n&quot;);
<a name="25" id="anc25"></a><span class="line-modified"> 549 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 550     fragmentShaderSource.appendLiteral(&quot;    vec4 color = texture2DRect(u_texture, texPos);\n&quot;);
<a name="26" id="anc26"></a>


 551 #else
 552 #error Unsupported configuration
 553 #endif
 554     fragmentShaderSource.appendLiteral(&quot;    if (u_swapColorChannels == 1) {\n&quot;);
 555     fragmentShaderSource.appendLiteral(&quot;        color.rgba = color.bgra;\n&quot;);
 556     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 557     fragmentShaderSource.appendLiteral(&quot;    if (u_premultiply == 1) {\n&quot;);
 558     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = vec4(color.r * color.a, color.g * color.a, color.b * color.a, color.a);\n&quot;);
 559     fragmentShaderSource.appendLiteral(&quot;    } else {\n&quot;);
 560     fragmentShaderSource.appendLiteral(&quot;        gl_FragColor = color;\n&quot;);
 561     fragmentShaderSource.appendLiteral(&quot;    }\n&quot;);
 562     fragmentShaderSource.appendLiteral(&quot;}\n&quot;);
 563 
<a name="27" id="anc27"></a><span class="line-modified"> 564     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
 565     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource.toString());
 566     m_context-&gt;compileShaderDirect(fragmentShader);
 567 
<a name="28" id="anc28"></a><span class="line-modified"> 568     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
 569     if (!value) {
 570         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Fragment shader failed to compile.&quot;, this);
 571         m_context-&gt;deleteShader(vertexShader);
 572         m_context-&gt;deleteShader(fragmentShader);
 573         return false;
 574     }
 575 
 576     m_program = m_context-&gt;createProgram();
 577     m_context-&gt;attachShader(m_program, vertexShader);
 578     m_context-&gt;attachShader(m_program, fragmentShader);
 579     m_context-&gt;linkProgram(m_program);
 580 
<a name="29" id="anc29"></a><span class="line-modified"> 581     m_context-&gt;getProgramiv(m_program, GraphicsContextGL::LINK_STATUS, &amp;value);</span>
 582     if (!value) {
 583         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Program failed to link.&quot;, this);
 584         m_context-&gt;deleteShader(vertexShader);
 585         m_context-&gt;deleteShader(fragmentShader);
 586         m_context-&gt;deleteProgram(m_program);
 587         m_program = 0;
 588         return false;
 589     }
 590 
 591     m_textureUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_texture&quot;_s);
 592     m_textureDimensionsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_textureDimensions&quot;_s);
 593     m_flipYUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_flipY&quot;_s);
 594     m_swapColorChannelsUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_swapColorChannels&quot;_s);
 595     m_premultiplyUniformLocation = m_context-&gt;getUniformLocation(m_program, &quot;u_premultiply&quot;_s);
 596     m_positionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_program, &quot;a_position&quot;_s);
 597 
 598     m_context-&gt;detachShader(m_program, vertexShader);
 599     m_context-&gt;detachShader(m_program, fragmentShader);
 600     m_context-&gt;deleteShader(vertexShader);
 601     m_context-&gt;deleteShader(fragmentShader);
 602 
 603     LOG(WebGL, &quot;Uniform and Attribute locations: u_texture = %d, u_textureDimensions = %d, u_flipY = %d, u_premultiply = %d, a_position = %d&quot;, m_textureUniformLocation, m_textureDimensionsUniformLocation, m_flipYUniformLocation, m_premultiplyUniformLocation, m_positionAttributeLocation);
 604     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
 605 
 606     m_vertexBuffer = m_context-&gt;createBuffer();
 607     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 608 
<a name="30" id="anc30"></a><span class="line-modified"> 609     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified"> 610     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(float) * 12, vertices, GraphicsContextGL::STATIC_DRAW);</span>
 611 
 612     return true;
 613 }
 614 
 615 bool VideoTextureCopierCV::initializeUVContextObjects()
 616 {
 617     String vertexShaderSource {
 618         &quot;attribute vec2 a_position;\n&quot;
 619         &quot;uniform vec2 u_yTextureSize;\n&quot;
 620         &quot;uniform vec2 u_uvTextureSize;\n&quot;
 621         &quot;uniform int u_flipY;\n&quot;
 622         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 623         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 624         &quot;void main() {\n&quot;
 625         &quot;   gl_Position = vec4(a_position, 0, 1.0);\n&quot;
 626         &quot;   vec2 normalizedPosition = a_position * .5 + .5;\n&quot;
 627         &quot;   if (u_flipY == 1) {\n&quot;
 628         &quot;       normalizedPosition.y = 1.0 - normalizedPosition.y;\n&quot;
 629         &quot;   }\n&quot;
<a name="31" id="anc31"></a><span class="line-modified"> 630 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 631         &quot;   v_yTextureCoordinate = normalizedPosition;\n&quot;
 632         &quot;   v_uvTextureCoordinate = normalizedPosition;\n&quot;
<a name="32" id="anc32"></a><span class="line-modified"> 633 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 634         &quot;   v_yTextureCoordinate = normalizedPosition * u_yTextureSize;\n&quot;
 635         &quot;   v_uvTextureCoordinate = normalizedPosition * u_uvTextureSize;\n&quot;
<a name="33" id="anc33"></a>

 636 #else
 637 #error Unsupported configuration
 638 #endif
 639         &quot;}\n&quot;_s
 640     };
 641 
<a name="34" id="anc34"></a><span class="line-modified"> 642     PlatformGLObject vertexShader = m_context-&gt;createShader(GraphicsContextGL::VERTEX_SHADER);</span>
 643     m_context-&gt;shaderSource(vertexShader, vertexShaderSource);
 644     m_context-&gt;compileShaderDirect(vertexShader);
 645 
<a name="35" id="anc35"></a><span class="line-modified"> 646     GCGLint status = 0;</span>
<span class="line-modified"> 647     m_context-&gt;getShaderiv(vertexShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
 648     if (!status) {
 649         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Vertex shader failed to compile.&quot;, this);
 650         m_context-&gt;deleteShader(vertexShader);
 651         return false;
 652     }
 653 
 654     String fragmentShaderSource {
<a name="36" id="anc36"></a><span class="line-modified"> 655 #if USE(OPENGL_ES) || USE(ANGLE)</span>
 656         &quot;precision mediump float;\n&quot;
<a name="37" id="anc37"></a><span class="line-added"> 657 #endif</span>
<span class="line-added"> 658 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 659         &quot;#define SAMPLERTYPE sampler2D\n&quot;
 660         &quot;#define TEXTUREFUNC texture2D\n&quot;
<a name="38" id="anc38"></a><span class="line-modified"> 661 #elif USE(OPENGL) || (USE(ANGLE) &amp;&amp; !PLATFORM(IOS_FAMILY))</span>
 662         &quot;#define SAMPLERTYPE sampler2DRect\n&quot;
 663         &quot;#define TEXTUREFUNC texture2DRect\n&quot;
<a name="39" id="anc39"></a>

 664 #else
 665 #error Unsupported configuration
 666 #endif
 667         &quot;uniform SAMPLERTYPE u_yTexture;\n&quot;
 668         &quot;uniform SAMPLERTYPE u_uvTexture;\n&quot;
 669         &quot;uniform mat4 u_colorMatrix;\n&quot;
 670         &quot;varying vec2 v_yTextureCoordinate;\n&quot;
 671         &quot;varying vec2 v_uvTextureCoordinate;\n&quot;
 672         &quot;void main() {\n&quot;
 673         &quot;    vec4 yuv;\n&quot;
 674         &quot;    yuv.r = TEXTUREFUNC(u_yTexture, v_yTextureCoordinate).r;\n&quot;
 675         &quot;    yuv.gb = TEXTUREFUNC(u_uvTexture, v_uvTextureCoordinate).rg;\n&quot;
 676         &quot;    yuv.a = 1.0;\n&quot;
 677         &quot;    gl_FragColor = yuv * u_colorMatrix;\n&quot;
 678         &quot;}\n&quot;_s
 679     };
 680 
<a name="40" id="anc40"></a><span class="line-modified"> 681     PlatformGLObject fragmentShader = m_context-&gt;createShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
 682     m_context-&gt;shaderSource(fragmentShader, fragmentShaderSource);
 683     m_context-&gt;compileShaderDirect(fragmentShader);
 684 
<a name="41" id="anc41"></a><span class="line-modified"> 685     m_context-&gt;getShaderiv(fragmentShader, GraphicsContextGL::COMPILE_STATUS, &amp;status);</span>
 686     if (!status) {
 687         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Fragment shader failed to compile.&quot;, this);
 688         m_context-&gt;deleteShader(vertexShader);
 689         m_context-&gt;deleteShader(fragmentShader);
 690         return false;
 691     }
 692 
 693     m_yuvProgram = m_context-&gt;createProgram();
 694     m_context-&gt;attachShader(m_yuvProgram, vertexShader);
 695     m_context-&gt;attachShader(m_yuvProgram, fragmentShader);
 696     m_context-&gt;linkProgram(m_yuvProgram);
 697 
<a name="42" id="anc42"></a><span class="line-modified"> 698     m_context-&gt;getProgramiv(m_yuvProgram, GraphicsContextGL::LINK_STATUS, &amp;status);</span>
 699     if (!status) {
 700         LOG(WebGL, &quot;VideoTextureCopierCV::initializeUVContextObjects(%p) - Program failed to link.&quot;, this);
 701         m_context-&gt;deleteShader(vertexShader);
 702         m_context-&gt;deleteShader(fragmentShader);
 703         m_context-&gt;deleteProgram(m_yuvProgram);
 704         m_yuvProgram = 0;
 705         return false;
 706     }
 707 
 708     m_yTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTexture&quot;_s);
 709     m_uvTextureUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTexture&quot;_s);
 710     m_colorMatrixUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_colorMatrix&quot;_s);
 711     m_yuvFlipYUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_flipY&quot;_s);
 712     m_yTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_yTextureSize&quot;_s);
 713     m_uvTextureSizeUniformLocation = m_context-&gt;getUniformLocation(m_yuvProgram, &quot;u_uvTextureSize&quot;_s);
 714     m_yuvPositionAttributeLocation = m_context-&gt;getAttribLocationDirect(m_yuvProgram, &quot;a_position&quot;_s);
 715 
 716     m_context-&gt;detachShader(m_yuvProgram, vertexShader);
 717     m_context-&gt;detachShader(m_yuvProgram, fragmentShader);
 718     m_context-&gt;deleteShader(vertexShader);
 719     m_context-&gt;deleteShader(fragmentShader);
 720 
 721     m_yuvVertexBuffer = m_context-&gt;createBuffer();
 722     float vertices[12] = { -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1 };
 723 
<a name="43" id="anc43"></a><span class="line-modified"> 724     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_yuvVertexBuffer);</span>
<span class="line-modified"> 725     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, sizeof(vertices), vertices, GraphicsContextGL::STATIC_DRAW);</span>
 726     m_context-&gt;enableVertexAttribArray(m_yuvPositionAttributeLocation);
<a name="44" id="anc44"></a><span class="line-modified"> 727     m_context-&gt;vertexAttribPointer(m_yuvPositionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
 728 
 729     return true;
 730 }
 731 
<a name="45" id="anc45"></a><span class="line-modified"> 732 #if USE(ANGLE)</span>
<span class="line-added"> 733 void* VideoTextureCopierCV::attachIOSurfaceToTexture(GCGLenum target, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type, IOSurfaceRef surface, GCGLuint plane)</span>
<span class="line-added"> 734 {</span>
<span class="line-added"> 735     auto display = m_context-&gt;platformDisplay();</span>
<span class="line-added"> 736     EGLint eglTextureTarget = 0;</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     if (target == GraphicsContextGL::TEXTURE_RECTANGLE_ARB)</span>
<span class="line-added"> 739         eglTextureTarget = EGL_TEXTURE_RECTANGLE_ANGLE;</span>
<span class="line-added"> 740     else if (target == GraphicsContextGL::TEXTURE_2D)</span>
<span class="line-added"> 741         eglTextureTarget = EGL_TEXTURE_2D;</span>
<span class="line-added"> 742     else {</span>
<span class="line-added"> 743         LOG(WebGL, &quot;Unknown texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="line-added"> 744         return nullptr;</span>
<span class="line-added"> 745     }</span>
<span class="line-added"> 746     if (eglTextureTarget != GraphicsContextGL::EGLIOSurfaceTextureTarget) {</span>
<span class="line-added"> 747         LOG(WebGL, &quot;Mismatch in EGL texture target %d.&quot;, static_cast&lt;int&gt;(target));</span>
<span class="line-added"> 748         return nullptr;</span>
<span class="line-added"> 749     }</span>
<span class="line-added"> 750 </span>
<span class="line-added"> 751     const EGLint surfaceAttributes[] = {</span>
<span class="line-added"> 752         EGL_WIDTH, width,</span>
<span class="line-added"> 753         EGL_HEIGHT, height,</span>
<span class="line-added"> 754         EGL_IOSURFACE_PLANE_ANGLE, static_cast&lt;EGLint&gt;(plane),</span>
<span class="line-added"> 755         EGL_TEXTURE_TARGET, static_cast&lt;EGLint&gt;(eglTextureTarget),</span>
<span class="line-added"> 756         EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, static_cast&lt;EGLint&gt;(internalFormat),</span>
<span class="line-added"> 757         EGL_TEXTURE_FORMAT, EGL_TEXTURE_RGBA,</span>
<span class="line-added"> 758         EGL_TEXTURE_TYPE_ANGLE, static_cast&lt;EGLint&gt;(type),</span>
<span class="line-added"> 759         // Only has an effect on the iOS Simulator.</span>
<span class="line-added"> 760         EGL_IOSURFACE_USAGE_HINT_ANGLE, EGL_IOSURFACE_READ_HINT_ANGLE,</span>
<span class="line-added"> 761         EGL_NONE, EGL_NONE</span>
<span class="line-added"> 762     };</span>
<span class="line-added"> 763     EGLSurface pbuffer = EGL_CreatePbufferFromClientBuffer(display, EGL_IOSURFACE_ANGLE, surface, m_context-&gt;platformConfig(), surfaceAttributes);</span>
<span class="line-added"> 764     if (!pbuffer)</span>
<span class="line-added"> 765         return nullptr;</span>
<span class="line-added"> 766     if (!EGL_BindTexImage(display, pbuffer, EGL_BACK_BUFFER)) {</span>
<span class="line-added"> 767         EGL_DestroySurface(display, pbuffer);</span>
<span class="line-added"> 768         return nullptr;</span>
<span class="line-added"> 769     }</span>
<span class="line-added"> 770     return pbuffer;</span>
<span class="line-added"> 771 }</span>
<span class="line-added"> 772 </span>
<span class="line-added"> 773 void VideoTextureCopierCV::detachIOSurfaceFromTexture(void* handle)</span>
<span class="line-added"> 774 {</span>
<span class="line-added"> 775     auto display = m_context-&gt;platformDisplay();</span>
<span class="line-added"> 776     EGL_ReleaseTexImage(display, handle, EGL_BACK_BUFFER);</span>
<span class="line-added"> 777     EGL_DestroySurface(display, handle);</span>
<span class="line-added"> 778 }</span>
<span class="line-added"> 779 #endif</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781 bool VideoTextureCopierCV::copyImageToPlatformTexture(CVPixelBufferRef image, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)</span>
 782 {
<a name="46" id="anc46"></a><span class="line-added"> 783     // CVOpenGLTextureCache seems to be disabled since the deprecation of</span>
<span class="line-added"> 784     // OpenGL. To avoid porting unused code to the ANGLE code paths, remove it.</span>
<span class="line-added"> 785 #if USE(ANGLE)</span>
<span class="line-added"> 786     UNUSED_PARAM(outputTarget);</span>
<span class="line-added"> 787     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="line-added"> 788 #else</span>
 789     if (!m_textureCache) {
 790         m_textureCache = TextureCacheCV::create(m_context);
 791         if (!m_textureCache)
 792             return false;
 793     }
 794 
 795     if (auto texture = m_textureCache-&gt;textureFromImage(image, outputTarget, level, internalFormat, format, type)) {
 796         bool swapColorChannels = false;
 797 #if USE(OPENGL_ES)
 798         // FIXME: Remove this workaround once rdar://problem/35834388 is fixed.
 799         swapColorChannels = CVPixelBufferGetPixelFormatType(image) == kCVPixelFormatType_32BGRA;
 800 #endif
 801         return copyVideoTextureToPlatformTexture(texture.get(), width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
 802     }
<a name="47" id="anc47"></a><span class="line-added"> 803 #endif // USE(ANGLE)</span>
 804 
 805 #if HAVE(IOSURFACE)
 806     // FIXME: This currently only supports &#39;420v&#39; and &#39;420f&#39; pixel formats. Investigate supporting more pixel formats.
 807     OSType pixelFormat = CVPixelBufferGetPixelFormatType(image);
 808     if (pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange &amp;&amp; pixelFormat != kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) {
 809         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Asked to copy an unsupported pixel format (&#39;%s&#39;).&quot;, this, FourCC(pixelFormat).toString().utf8().data());
 810         return false;
 811     }
 812 
 813     IOSurfaceRef surface = CVPixelBufferGetIOSurface(image);
 814     if (!surface)
 815         return false;
 816 
 817     auto newSurfaceSeed = IOSurfaceGetSeed(surface);
 818     if (flipY == m_lastFlipY
 819         &amp;&amp; surface == m_lastSurface
 820         &amp;&amp; newSurfaceSeed == m_lastSurfaceSeed
 821         &amp;&amp; lastTextureSeed(outputTexture) == m_context-&gt;textureSeed(outputTexture)) {
 822         // If the texture hasn&#39;t been modified since the last time we copied to it, and the
 823         // image hasn&#39;t been modified since the last time it was copied, this is a no-op.
 824         return true;
 825     }
 826 
 827     if (!m_yuvProgram) {
 828         if (!initializeUVContextObjects()) {
 829             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
 830             return false;
 831         }
 832     }
 833 
<a name="48" id="anc48"></a><span class="line-modified"> 834     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
 835 
 836     // Allocate memory for the output texture.
<a name="49" id="anc49"></a><span class="line-modified"> 837     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="line-modified"> 838     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 839     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 840     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 841     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 842     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified"> 843 </span>
<span class="line-modified"> 844     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified"> 845     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="line-modified"> 846     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
 847         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
 848         return false;
 849     }
 850 
 851     m_context-&gt;useProgram(m_yuvProgram);
 852     m_context-&gt;viewport(0, 0, width, height);
 853 
 854     // Bind and set up the textures for the video source.
 855     auto yPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 0);
 856     auto yPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 0);
 857     auto uvPlaneWidth = IOSurfaceGetWidthOfPlane(surface, 1);
 858     auto uvPlaneHeight = IOSurfaceGetHeightOfPlane(surface, 1);
 859 
 860 #if USE(OPENGL_ES)
<a name="50" id="anc50"></a><span class="line-modified"> 861     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_2D;</span>
 862 #elif USE(OPENGL)
<a name="51" id="anc51"></a><span class="line-modified"> 863     GCGLenum videoTextureTarget = GraphicsContextGL::TEXTURE_RECTANGLE_ARB;</span>
 864 #elif USE(ANGLE)
<a name="52" id="anc52"></a><span class="line-modified"> 865     GCGLenum videoTextureTarget = GraphicsContextGL::IOSurfaceTextureTarget;</span>

 866 #else
 867 #error Unsupported configuration
 868 #endif
 869     auto uvTexture = m_context-&gt;createTexture();
<a name="53" id="anc53"></a><span class="line-modified"> 870     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE1);</span>
 871     m_context-&gt;bindTexture(videoTextureTarget, uvTexture);
<a name="54" id="anc54"></a><span class="line-modified"> 872     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 873     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 874     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 875     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 876 #if USE(ANGLE)</span>
<span class="line-added"> 877     auto uvHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 1);</span>
<span class="line-added"> 878     if (!uvHandle) {</span>
 879         m_context-&gt;deleteTexture(uvTexture);
 880         return false;
 881     }
<a name="55" id="anc55"></a><span class="line-added"> 882 #else</span>
<span class="line-added"> 883     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::RG, uvPlaneWidth, uvPlaneHeight, GraphicsContextGL::RG, GraphicsContextGL::UNSIGNED_BYTE, surface, 1)) {</span>
<span class="line-added"> 884         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="line-added"> 885         return false;</span>
<span class="line-added"> 886     }</span>
<span class="line-added"> 887 #endif // USE(ANGLE)</span>
 888 
 889     auto yTexture = m_context-&gt;createTexture();
<a name="56" id="anc56"></a><span class="line-modified"> 890     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
 891     m_context-&gt;bindTexture(videoTextureTarget, yTexture);
<a name="57" id="anc57"></a><span class="line-modified"> 892     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 893     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified"> 894     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 895     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified"> 896 #if USE(ANGLE)</span>
<span class="line-added"> 897     auto yHandle = attachIOSurfaceToTexture(videoTextureTarget, GraphicsContextGL::RED, yPlaneWidth, yPlaneHeight, GraphicsContextGL::UNSIGNED_BYTE, surface, 0);</span>
<span class="line-added"> 898     if (!yHandle) {</span>
<span class="line-added"> 899         m_context-&gt;deleteTexture(yTexture);</span>
<span class="line-added"> 900         m_context-&gt;deleteTexture(uvTexture);</span>
<span class="line-added"> 901         return false;</span>
<span class="line-added"> 902     }</span>
<span class="line-added"> 903 #else</span>
<span class="line-added"> 904     if (!m_context-&gt;texImageIOSurface2D(videoTextureTarget, GraphicsContextGL::LUMINANCE, yPlaneWidth, yPlaneHeight, GraphicsContextGL::LUMINANCE, GraphicsContextGL::UNSIGNED_BYTE, surface, 0)) {</span>
 905         m_context-&gt;deleteTexture(yTexture);
 906         m_context-&gt;deleteTexture(uvTexture);
 907         return false;
 908     }
<a name="58" id="anc58"></a><span class="line-added"> 909 #endif // USE(ANGLE)</span>
 910 
 911     // Configure the drawing parameters.
 912     m_context-&gt;uniform1i(m_yTextureUniformLocation, 0);
 913     m_context-&gt;uniform1i(m_uvTextureUniformLocation, 1);
 914     m_context-&gt;uniform1i(m_yuvFlipYUniformLocation, flipY);
 915     m_context-&gt;uniform2f(m_yTextureSizeUniformLocation, yPlaneWidth, yPlaneHeight);
 916     m_context-&gt;uniform2f(m_uvTextureSizeUniformLocation, uvPlaneWidth, uvPlaneHeight);
 917 
 918     auto range = pixelRangeFromPixelFormat(pixelFormat);
 919     auto transferFunction = transferFunctionFromString((CFStringRef)CVBufferGetAttachment(image, kCVImageBufferYCbCrMatrixKey, nil));
 920     auto&amp; colorMatrix = YCbCrToRGBMatrixForRangeAndTransferFunction(range, transferFunction);
 921     m_context-&gt;uniformMatrix4fv(m_colorMatrixUniformLocation, 1, GL_FALSE, colorMatrix.data());
 922 
 923     // Do the actual drawing.
<a name="59" id="anc59"></a><span class="line-modified"> 924     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
 925 
<a name="60" id="anc60"></a><span class="line-modified"> 926 #if USE(OPENGL_ES) || (USE(ANGLE) &amp;&amp; PLATFORM(IOS_FAMILY))</span>
 927     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
 928     // two EAGL contexts.
 929     m_context-&gt;flush();
 930 #endif
 931 
 932     // Clean-up.
 933     m_context-&gt;deleteTexture(yTexture);
 934     m_context-&gt;deleteTexture(uvTexture);
<a name="61" id="anc61"></a><span class="line-added"> 935 #if USE(ANGLE)</span>
<span class="line-added"> 936     detachIOSurfaceFromTexture(yHandle);</span>
<span class="line-added"> 937     detachIOSurfaceFromTexture(uvHandle);</span>
<span class="line-added"> 938 #endif</span>
 939 
 940     m_lastSurface = surface;
 941     m_lastSurfaceSeed = newSurfaceSeed;
 942     m_lastTextureSeed.set(outputTexture, m_context-&gt;textureSeed(outputTexture));
 943     m_lastFlipY = flipY;
 944 
 945     return true;
 946 #else
 947     return false;
 948 #endif // HAVE(IOSURFACE)
 949 }
 950 
<a name="62" id="anc62"></a><span class="line-modified"> 951 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(TextureType inputVideoTexture, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
 952 {
 953     if (!inputVideoTexture)
 954         return false;
 955 
 956     GLfloat lowerLeft[2] = { 0, 0 };
 957     GLfloat lowerRight[2] = { 0, 0 };
 958     GLfloat upperRight[2] = { 0, 0 };
 959     GLfloat upperLeft[2] = { 0, 0 };
<a name="63" id="anc63"></a><span class="line-added"> 960     PlatformGLObject videoTextureName;</span>
<span class="line-added"> 961     GCGLenum videoTextureTarget;</span>
<span class="line-added"> 962 </span>
 963 #if USE(OPENGL_ES)
<a name="64" id="anc64"></a><span class="line-modified"> 964     videoTextureName = CVOpenGLESTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 965     videoTextureTarget = CVOpenGLESTextureGetTarget(inputVideoTexture);</span>
 966     CVOpenGLESTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 967 #elif USE(OPENGL)
<a name="65" id="anc65"></a><span class="line-modified"> 968     videoTextureName = CVOpenGLTextureGetName(inputVideoTexture);</span>
<span class="line-modified"> 969     videoTextureTarget = CVOpenGLTextureGetTarget(inputVideoTexture);</span>
 970     CVOpenGLTextureGetCleanTexCoords(inputVideoTexture, lowerLeft, lowerRight, upperRight, upperLeft);
 971 #elif USE(ANGLE)
<a name="66" id="anc66"></a><span class="line-modified"> 972     // CVOpenGLTextureCacheCreateTextureFromImage seems to always return</span>
<span class="line-modified"> 973     // kCVReturnPixelBufferNotOpenGLCompatible on desktop macOS now, so this</span>
<span class="line-modified"> 974     // entire code path seems to be unused. Assume the IOSurface path will be</span>
<span class="line-added"> 975     // taken when using ANGLE.</span>
<span class="line-added"> 976     UNUSED_PARAM(lowerLeft);</span>
<span class="line-added"> 977     UNUSED_PARAM(lowerRight);</span>
<span class="line-added"> 978     UNUSED_PARAM(upperLeft);</span>
<span class="line-added"> 979     UNUSED_PARAM(upperRight);</span>
<span class="line-added"> 980     UNUSED_PARAM(width);</span>
<span class="line-added"> 981     UNUSED_PARAM(height);</span>
<span class="line-added"> 982     UNUSED_PARAM(outputTexture);</span>
<span class="line-added"> 983     UNUSED_PARAM(outputTarget);</span>
<span class="line-added"> 984     UNUSED_PARAM(level);</span>
<span class="line-added"> 985     UNUSED_PARAM(internalFormat);</span>
<span class="line-added"> 986     UNUSED_PARAM(format);</span>
<span class="line-added"> 987     UNUSED_PARAM(type);</span>
<span class="line-added"> 988     UNUSED_PARAM(premultiplyAlpha);</span>
<span class="line-added"> 989     UNUSED_PARAM(flipY);</span>
<span class="line-added"> 990     UNUSED_PARAM(swapColorChannels);</span>
 991     // FIXME: determine how to access rectangular textures via ANGLE.
<a name="67" id="anc67"></a><span class="line-modified"> 992     UNIMPLEMENTED();</span>
<span class="line-added"> 993     return false;</span>
 994 #endif
 995 
 996     if (lowerLeft[1] &lt; upperRight[1])
 997         flipY = !flipY;
 998 
 999     return copyVideoTextureToPlatformTexture(videoTextureName, videoTextureTarget, width, height, outputTexture, outputTarget, level, internalFormat, format, type, premultiplyAlpha, flipY, swapColorChannels);
1000 }
1001 
<a name="68" id="anc68"></a><span class="line-modified">1002 bool VideoTextureCopierCV::copyVideoTextureToPlatformTexture(PlatformGLObject videoTextureName, GCGLenum videoTextureTarget, size_t width, size_t height, PlatformGLObject outputTexture, GCGLenum outputTarget, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY, bool swapColorChannels)</span>
1003 {
1004     LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - internalFormat: %s, format: %s, type: %s flipY: %s, premultiplyAlpha: %s&quot;, this, enumToStringMap()[internalFormat], enumToStringMap()[format], enumToStringMap()[type], flipY ? &quot;true&quot; : &quot;false&quot;, premultiplyAlpha ? &quot;true&quot; : &quot;false&quot;);
1005 
1006     if (!m_program) {
1007         if (!initializeContextObjects()) {
1008             LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to initialize OpenGL context objects.&quot;, this);
1009             return false;
1010         }
1011     }
1012 
<a name="69" id="anc69"></a><span class="line-modified">1013     m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebuffer);</span>
1014 
1015     // Allocate memory for the output texture.
<a name="70" id="anc70"></a><span class="line-modified">1016     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, outputTexture);</span>
<span class="line-modified">1017     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1018     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1019     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1020     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1021     m_context-&gt;texImage2DDirect(GraphicsContextGL::TEXTURE_2D, level, internalFormat, width, height, 0, format, type, nullptr);</span>
<span class="line-modified">1022 </span>
<span class="line-modified">1023     m_context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0, GraphicsContextGL::TEXTURE_2D, outputTexture, level);</span>
<span class="line-modified">1024     GCGLenum status = m_context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER);</span>
<span class="line-modified">1025     if (status != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
1026         LOG(WebGL, &quot;VideoTextureCopierCV::copyVideoTextureToPlatformTexture(%p) - Unable to create framebuffer for outputTexture.&quot;, this);
1027         return false;
1028     }
1029 
1030     m_context-&gt;useProgram(m_program);
1031     m_context-&gt;viewport(0, 0, width, height);
1032 
1033     // Bind and set up the texture for the video source.
<a name="71" id="anc71"></a><span class="line-modified">1034     m_context-&gt;activeTexture(GraphicsContextGL::TEXTURE0);</span>
1035     m_context-&gt;bindTexture(videoTextureTarget, videoTextureName);
<a name="72" id="anc72"></a><span class="line-modified">1036     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1037     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">1038     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">1039     m_context-&gt;texParameteri(videoTextureTarget, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
1040 
1041     // Configure the drawing parameters.
1042     m_context-&gt;uniform1i(m_textureUniformLocation, 0);
1043 #if USE(OPENGL_ES)
1044     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, 1, 1);
1045 #else
1046     m_context-&gt;uniform2f(m_textureDimensionsUniformLocation, width, height);
1047 #endif
1048 
1049     m_context-&gt;uniform1i(m_flipYUniformLocation, flipY);
1050     m_context-&gt;uniform1i(m_swapColorChannelsUniformLocation, swapColorChannels);
1051     m_context-&gt;uniform1i(m_premultiplyUniformLocation, premultiplyAlpha);
1052 
1053     // Do the actual drawing.
1054     m_context-&gt;enableVertexAttribArray(m_positionAttributeLocation);
<a name="73" id="anc73"></a><span class="line-modified">1055     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexBuffer);</span>
<span class="line-modified">1056     m_context-&gt;vertexAttribPointer(m_positionAttributeLocation, 2, GraphicsContextGL::FLOAT, false, 0, 0);</span>
<span class="line-modified">1057     m_context-&gt;drawArrays(GraphicsContextGL::TRIANGLES, 0, 6);</span>
1058 
1059 #if USE(OPENGL_ES)
1060     // flush() must be called here in order to re-synchronize the output texture&#39;s contents across the
1061     // two EAGL contexts.
1062     m_context-&gt;flush();
1063 #endif
1064 
1065     // Clean-up.
1066     m_context-&gt;bindTexture(videoTextureTarget, 0);
1067     m_context-&gt;bindTexture(outputTarget, outputTexture);
1068 
1069     return true;
1070 }
1071 
1072 }
1073 
1074 #endif // HAVE(CORE_VIDEO)
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>
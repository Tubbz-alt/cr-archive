diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp
@@ -27,10 +27,13 @@
 
 #include "config.h"
 #include "SharedBuffer.h"
 
 #include <algorithm>
+#include <wtf/HexNumber.h>
+#include <wtf/persistence/PersistentCoders.h>
+#include <wtf/text/StringBuilder.h>
 #include <wtf/unicode/UTF8Conversion.h>
 
 namespace WebCore {
 
 SharedBuffer::SharedBuffer(const char* data, size_t size)
@@ -90,11 +93,11 @@
     return adoptRef(*new SharedBuffer { vector.data(), vector.size() });
 }
 
 void SharedBuffer::combineIntoOneSegment() const
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     // FIXME: We ought to be able to set this to true and have no assertions fire.
     // Remove all instances of appending after calling this, because they are all O(n^2) algorithms since r215686.
     // m_hasBeenCombinedIntoOneSegment = true;
 #endif
     if (m_segments.size() <= 1)
@@ -129,10 +132,20 @@
     const DataSegmentVectorEntry* element = std::upper_bound(m_segments.begin(), m_segments.end(), position, comparator);
     element--; // std::upper_bound gives a pointer to the element that is greater than position. We want the element just before that.
     return { element->segment.copyRef(), position - element->beginPosition };
 }
 
+String SharedBuffer::toHexString() const
+{
+    StringBuilder stringBuilder;
+    for (unsigned byteOffset = 0; byteOffset < size(); byteOffset++) {
+        const uint8_t byte = data()[byteOffset];
+        stringBuilder.append(pad('0', 2, hex(byte)));
+    }
+    return stringBuilder.toString();
+}
+
 RefPtr<ArrayBuffer> SharedBuffer::tryCreateArrayBuffer() const
 {
     auto arrayBuffer = ArrayBuffer::tryCreateUninitialized(static_cast<unsigned>(size()), sizeof(char));
     if (!arrayBuffer) {
         WTFLogAlways("SharedBuffer::tryCreateArrayBuffer Unable to create buffer. Requested size was %zu\n", size());
@@ -197,22 +210,22 @@
     ASSERT(clone->internallyConsistent());
     ASSERT(internallyConsistent());
     return clone;
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 bool SharedBuffer::internallyConsistent() const
 {
     size_t position = 0;
     for (const auto& element : m_segments) {
         if (element.beginPosition != position)
             return false;
         position += element.segment->size();
     }
     return position == m_size;
 }
-#endif
+#endif // ASSERT_ENABLED
 
 const char* SharedBuffer::DataSegment::data() const
 {
     auto visitor = WTF::makeVisitor(
         [](const Vector<char>& data) { return data.data(); },
@@ -237,10 +250,15 @@
 void SharedBuffer::hintMemoryNotNeededSoon() const
 {
 }
 #endif
 
+WTF::Persistence::Decoder SharedBuffer::decoder() const
+{
+    return { reinterpret_cast<const uint8_t*>(data()), size() };
+}
+
 bool SharedBuffer::operator==(const SharedBuffer& other) const
 {
     if (this == &other)
         return true;
 

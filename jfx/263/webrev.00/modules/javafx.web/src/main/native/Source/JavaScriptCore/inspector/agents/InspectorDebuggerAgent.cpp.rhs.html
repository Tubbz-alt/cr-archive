<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2010-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010, 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorDebuggerAgent.h&quot;
  32 
  33 #include &quot;AsyncStackTrace.h&quot;
  34 #include &quot;ContentSearchUtilities.h&quot;
  35 #include &quot;InjectedScript.h&quot;
  36 #include &quot;InjectedScriptManager.h&quot;
  37 #include &quot;InspectorFrontendRouter.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;RegularExpression.h&quot;
  40 #include &quot;ScriptCallStack.h&quot;
  41 #include &quot;ScriptCallStackFactory.h&quot;
  42 #include &quot;ScriptDebugServer.h&quot;
  43 #include &quot;ScriptObject.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  44 #include &lt;wtf/Function.h&gt;</span>
  45 #include &lt;wtf/JSONValues.h&gt;
  46 #include &lt;wtf/NeverDestroyed.h&gt;
  47 #include &lt;wtf/Stopwatch.h&gt;
  48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  49 #include &lt;wtf/text/WTFString.h&gt;
  50 
  51 namespace Inspector {
  52 
  53 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  54 
  55 // Objects created and retained by evaluating breakpoint actions are put into object groups
  56 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  57 // have several object groups, and objects from several backend breakpoint action instances may
  58 // create objects in the same group.
  59 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  60 {
  61     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  62 }
  63 
<a name="2" id="anc2"></a><span class="line-added">  64 static bool isWebKitInjectedScript(const String&amp; sourceURL)</span>
<span class="line-added">  65 {</span>
<span class="line-added">  66     return sourceURL.startsWith(&quot;__InjectedScript_&quot;) &amp;&amp; sourceURL.endsWith(&quot;.js&quot;);</span>
<span class="line-added">  67 }</span>
<span class="line-added">  68 </span>
  69 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  70     : InspectorAgentBase(&quot;Debugger&quot;_s)
  71     , m_frontendDispatcher(makeUnique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))
  72     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  73     , m_scriptDebugServer(context.environment.scriptDebugServer())
  74     , m_injectedScriptManager(context.injectedScriptManager)
  75 {
<a name="3" id="anc3"></a><span class="line-modified">  76     // FIXME: make pauseReason optional so that there was no need to init it with &quot;other&quot;.</span>
<span class="line-modified">  77     clearPauseDetails();</span>
  78 }
  79 
  80 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;
  81 
  82 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  83 {
  84 }
  85 
  86 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  87 {
<a name="4" id="anc4"></a><span class="line-modified">  88     if (enabled())</span>
<span class="line-added">  89         disable(reason == DisconnectReason::InspectedTargetDestroyed);</span>
  90 }
  91 
  92 void InspectorDebuggerAgent::enable()
  93 {
<a name="5" id="anc5"></a>


  94     m_enabled = true;
  95 
  96     m_scriptDebugServer.addListener(this);
  97 
  98     for (auto* listener : copyToVector(m_listeners))
  99         listener-&gt;debuggerWasEnabled();
<a name="6" id="anc6"></a><span class="line-added"> 100 </span>
<span class="line-added"> 101     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-added"> 102         Optional&lt;JSC::Debugger::BlackboxType&gt; blackboxType;</span>
<span class="line-added"> 103         if (isWebKitInjectedScript(script.sourceURL)) {</span>
<span class="line-added"> 104             if (!m_pauseForInternalScripts)</span>
<span class="line-added"> 105                 blackboxType = JSC::Debugger::BlackboxType::Ignored;</span>
<span class="line-added"> 106         } else if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 107             blackboxType = JSC::Debugger::BlackboxType::Deferred;</span>
<span class="line-added"> 108         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-added"> 109     }</span>
 110 }
 111 
 112 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
 113 {
<a name="7" id="anc7"></a>


 114     for (auto* listener : copyToVector(m_listeners))
 115         listener-&gt;debuggerWasDisabled();
 116 
 117     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 118 
 119     clearInspectorBreakpointState();
 120 
 121     if (!isBeingDestroyed)
 122         m_scriptDebugServer.deactivateBreakpoints();
 123 
 124     ASSERT(m_javaScriptBreakpoints.isEmpty());
 125 
 126     clearAsyncStackTraceData();
 127 
 128     m_pauseOnAssertionFailures = false;
 129     m_pauseOnMicrotasks = false;
 130 
 131     m_enabled = false;
 132 }
 133 
<a name="8" id="anc8"></a><span class="line-modified"> 134 void InspectorDebuggerAgent::enable(ErrorString&amp; errorString)</span>
 135 {
<a name="9" id="anc9"></a><span class="line-added"> 136     if (enabled()) {</span>
<span class="line-added"> 137         errorString = &quot;Debugger domain already enabled&quot;_s;</span>
<span class="line-added"> 138         return;</span>
<span class="line-added"> 139     }</span>
<span class="line-added"> 140 </span>
 141     enable();
 142 }
 143 
 144 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 145 {
 146     disable(false);
 147 }
 148 
 149 bool InspectorDebuggerAgent::breakpointsActive() const
 150 {
 151     return m_scriptDebugServer.breakpointsActive();
 152 }
 153 
 154 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 155 {
 156     if (m_asyncStackTraceDepth == depth)
 157         return;
 158 
 159     if (depth &lt; 0) {
 160         errorString = &quot;Unexpected negative depth&quot;_s;
 161         return;
 162     }
 163 
 164     m_asyncStackTraceDepth = depth;
 165 
 166     if (!m_asyncStackTraceDepth)
 167         clearAsyncStackTraceData();
 168 }
 169 
 170 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 171 {
 172     if (active)
 173         m_scriptDebugServer.activateBreakpoints();
 174     else
 175         m_scriptDebugServer.deactivateBreakpoints();
 176 }
 177 
 178 bool InspectorDebuggerAgent::isPaused() const
 179 {
 180     return m_scriptDebugServer.isPaused();
 181 }
 182 
 183 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 184 {
 185     m_scriptDebugServer.setSuppressAllPauses(suppress);
 186 }
 187 
<a name="10" id="anc10"></a><span class="line-added"> 188 void InspectorDebuggerAgent::updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
<span class="line-added"> 189 {</span>
<span class="line-added"> 190     if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript) {</span>
<span class="line-added"> 191         m_preBlackboxPauseReason = m_pauseReason;</span>
<span class="line-added"> 192         m_preBlackboxPauseData = WTFMove(m_pauseData);</span>
<span class="line-added"> 193     }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195     m_pauseReason = reason;</span>
<span class="line-added"> 196     m_pauseData = WTFMove(data);</span>
<span class="line-added"> 197 }</span>
<span class="line-added"> 198 </span>
 199 static RefPtr&lt;JSON::Object&gt; buildAssertPauseReason(const String&amp; message)
 200 {
 201     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
 202     if (!message.isNull())
 203         reason-&gt;setMessage(message);
 204     return reason-&gt;openAccessors();
 205 }
 206 
 207 static RefPtr&lt;JSON::Object&gt; buildCSPViolationPauseReason(const String&amp; directiveText)
 208 {
 209     auto reason = Protocol::Debugger::CSPViolationPauseReason::create()
 210         .setDirective(directiveText)
 211         .release();
 212     return reason-&gt;openAccessors();
 213 }
 214 
 215 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildBreakpointPauseReason(JSC::BreakpointID debuggerBreakpointIdentifier)
 216 {
 217     ASSERT(debuggerBreakpointIdentifier != JSC::noBreakpointID);
 218     auto it = m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.find(debuggerBreakpointIdentifier);
 219     if (it == m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.end())
 220         return nullptr;
 221 
 222     auto reason = Protocol::Debugger::BreakpointPauseReason::create()
 223         .setBreakpointId(it-&gt;value)
 224         .release();
 225     return reason-&gt;openAccessors();
 226 }
 227 
 228 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildExceptionPauseReason(JSC::JSValue exception, const InjectedScript&amp; injectedScript)
 229 {
 230     ASSERT(exception);
 231     if (!exception)
 232         return nullptr;
 233 
 234     ASSERT(!injectedScript.hasNoValue());
 235     if (injectedScript.hasNoValue())
 236         return nullptr;
 237 
 238     return injectedScript.wrapObject(exception, InspectorDebuggerAgent::backtraceObjectGroup)-&gt;openAccessors();
 239 }
 240 
 241 void InspectorDebuggerAgent::handleConsoleAssert(const String&amp; message)
 242 {
 243     if (!m_scriptDebugServer.breakpointsActive())
 244         return;
 245 
 246     if (m_pauseOnAssertionFailures)
 247         breakProgram(DebuggerFrontendDispatcher::Reason::Assert, buildAssertPauseReason(message));
 248 }
 249 
 250 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 251 {
 252     return std::make_pair(static_cast&lt;unsigned&gt;(asyncCallType), callbackId);
 253 }
 254 
<a name="11" id="anc11"></a><span class="line-modified"> 255 void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::JSGlobalObject* globalObject, AsyncCallType asyncCallType, int callbackId, bool singleShot)</span>
 256 {
 257     if (!m_asyncStackTraceDepth)
 258         return;
 259 
 260     if (!m_scriptDebugServer.breakpointsActive())
 261         return;
 262 
<a name="12" id="anc12"></a><span class="line-modified"> 263     Ref&lt;ScriptCallStack&gt; callStack = createScriptCallStack(globalObject, m_asyncStackTraceDepth);</span>
 264     ASSERT(callStack-&gt;size());
 265     if (!callStack-&gt;size())
 266         return;
 267 
 268     RefPtr&lt;AsyncStackTrace&gt; parentStackTrace;
 269     if (m_currentAsyncCallIdentifier) {
 270         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
 271         ASSERT(it != m_pendingAsyncCalls.end());
 272         parentStackTrace = it-&gt;value;
 273     }
 274 
 275     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 276     auto asyncStackTrace = AsyncStackTrace::create(WTFMove(callStack), singleShot, WTFMove(parentStackTrace));
 277 
 278     m_pendingAsyncCalls.set(identifier, WTFMove(asyncStackTrace));
 279 }
 280 
 281 void InspectorDebuggerAgent::didCancelAsyncCall(AsyncCallType asyncCallType, int callbackId)
 282 {
 283     if (!m_asyncStackTraceDepth)
 284         return;
 285 
 286     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 287     auto it = m_pendingAsyncCalls.find(identifier);
 288     if (it == m_pendingAsyncCalls.end())
 289         return;
 290 
 291     auto&amp; asyncStackTrace = it-&gt;value;
 292     asyncStackTrace-&gt;didCancelAsyncCall();
 293 
 294     if (m_currentAsyncCallIdentifier &amp;&amp; m_currentAsyncCallIdentifier.value() == identifier)
 295         return;
 296 
 297     m_pendingAsyncCalls.remove(identifier);
 298 }
 299 
 300 void InspectorDebuggerAgent::willDispatchAsyncCall(AsyncCallType asyncCallType, int callbackId)
 301 {
 302     if (!m_asyncStackTraceDepth)
 303         return;
 304 
 305     if (m_currentAsyncCallIdentifier)
 306         return;
 307 
 308     // A call can be scheduled before the Inspector is opened, or while async stack
 309     // traces are disabled. If no call data exists, do nothing.
 310     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 311     auto it = m_pendingAsyncCalls.find(identifier);
 312     if (it == m_pendingAsyncCalls.end())
 313         return;
 314 
 315     auto&amp; asyncStackTrace = it-&gt;value;
 316     asyncStackTrace-&gt;willDispatchAsyncCall(m_asyncStackTraceDepth);
 317 
 318     m_currentAsyncCallIdentifier = identifier;
 319 }
 320 
 321 void InspectorDebuggerAgent::didDispatchAsyncCall()
 322 {
 323     if (!m_asyncStackTraceDepth)
 324         return;
 325 
 326     if (!m_currentAsyncCallIdentifier)
 327         return;
 328 
 329     auto identifier = m_currentAsyncCallIdentifier.value();
 330     auto it = m_pendingAsyncCalls.find(identifier);
 331     ASSERT(it != m_pendingAsyncCalls.end());
 332 
 333     auto&amp; asyncStackTrace = it-&gt;value;
 334     asyncStackTrace-&gt;didDispatchAsyncCall();
 335 
 336     m_currentAsyncCallIdentifier = WTF::nullopt;
 337 
 338     if (!asyncStackTrace-&gt;isPending())
 339         m_pendingAsyncCalls.remove(identifier);
 340 }
 341 
 342 static Ref&lt;JSON::Object&gt; buildObjectForBreakpointCookie(const String&amp; url, int lineNumber, int columnNumber, const String&amp; condition, RefPtr&lt;JSON::Array&gt;&amp; actions, bool isRegex, bool autoContinue, unsigned ignoreCount)
 343 {
 344     Ref&lt;JSON::Object&gt; breakpointObject = JSON::Object::create();
 345     breakpointObject-&gt;setString(&quot;url&quot;_s, url);
 346     breakpointObject-&gt;setInteger(&quot;lineNumber&quot;_s, lineNumber);
 347     breakpointObject-&gt;setInteger(&quot;columnNumber&quot;_s, columnNumber);
 348     breakpointObject-&gt;setString(&quot;condition&quot;_s, condition);
 349     breakpointObject-&gt;setBoolean(&quot;isRegex&quot;_s, isRegex);
 350     breakpointObject-&gt;setBoolean(&quot;autoContinue&quot;_s, autoContinue);
 351     breakpointObject-&gt;setInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 352 
 353     if (actions)
 354         breakpointObject-&gt;setArray(&quot;actions&quot;_s, actions);
 355 
 356     return breakpointObject;
 357 }
 358 
 359 static bool matches(const String&amp; url, const String&amp; pattern, bool isRegex)
 360 {
 361     if (isRegex) {
 362         JSC::Yarr::RegularExpression regex(pattern);
 363         return regex.match(url) != -1;
 364     }
 365     return url == pattern;
 366 }
 367 
 368 static bool breakpointActionTypeForString(const String&amp; typeString, ScriptBreakpointActionType* output)
 369 {
 370     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Log)) {
 371         *output = ScriptBreakpointActionTypeLog;
 372         return true;
 373     }
 374     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Evaluate)) {
 375         *output = ScriptBreakpointActionTypeEvaluate;
 376         return true;
 377     }
 378     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Sound)) {
 379         *output = ScriptBreakpointActionTypeSound;
 380         return true;
 381     }
 382     if (typeString == Protocol::InspectorHelpers::getEnumConstantValue(Protocol::Debugger::BreakpointAction::Type::Probe)) {
 383         *output = ScriptBreakpointActionTypeProbe;
 384         return true;
 385     }
 386 
 387     return false;
 388 }
 389 
 390 bool InspectorDebuggerAgent::breakpointActionsFromProtocol(ErrorString&amp; errorString, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result)
 391 {
 392     if (!actions)
 393         return true;
 394 
 395     unsigned actionsLength = actions-&gt;length();
 396     if (!actionsLength)
 397         return true;
 398 
 399     result-&gt;reserveCapacity(actionsLength);
 400     for (unsigned i = 0; i &lt; actionsLength; ++i) {
 401         RefPtr&lt;JSON::Value&gt; value = actions-&gt;get(i);
 402         RefPtr&lt;JSON::Object&gt; object;
 403         if (!value-&gt;asObject(object)) {
 404             errorString = &quot;Unexpected non-object item in given actions&quot;_s;
 405             return false;
 406         }
 407 
 408         String typeString;
 409         if (!object-&gt;getString(&quot;type&quot;_s, typeString)) {
 410             errorString = &quot;Missing type for item in given actions&quot;_s;
 411             return false;
 412         }
 413 
 414         ScriptBreakpointActionType type;
 415         if (!breakpointActionTypeForString(typeString, &amp;type)) {
 416             errorString = &quot;Non-string type for item in given actions&quot;_s;
 417             return false;
 418         }
 419 
 420         // Specifying an identifier is optional. They are used to correlate probe samples
 421         // in the frontend across multiple backend probe actions and segregate object groups.
 422         int identifier = 0;
 423         object-&gt;getInteger(&quot;id&quot;_s, identifier);
 424 
 425         String data;
 426         object-&gt;getString(&quot;data&quot;_s, data);
 427 
 428         result-&gt;append(ScriptBreakpointAction(type, identifier, data));
 429     }
 430 
 431     return true;
 432 }
 433 
 434 static RefPtr&lt;Protocol::Debugger::Location&gt; buildDebuggerLocation(const JSC::Breakpoint&amp; breakpoint)
 435 {
 436     ASSERT(breakpoint.resolved);
 437 
 438     auto location = Protocol::Debugger::Location::create()
 439         .setScriptId(String::number(breakpoint.sourceID))
 440         .setLineNumber(breakpoint.line)
 441         .release();
 442     location-&gt;setColumnNumber(breakpoint.column);
 443 
 444     return location;
 445 }
 446 
 447 static bool parseLocation(ErrorString&amp; errorString, const JSON::Object&amp; location, JSC::SourceID&amp; sourceID, unsigned&amp; lineNumber, unsigned&amp; columnNumber)
 448 {
 449     if (!location.getInteger(&quot;lineNumber&quot;_s, lineNumber)) {
 450         errorString = &quot;Unexpected non-integer lineNumber in given location&quot;_s;
 451         sourceID = JSC::noSourceID;
 452         return false;
 453     }
 454 
 455     String scriptIDStr;
 456     if (!location.getString(&quot;scriptId&quot;_s, scriptIDStr)) {
 457         sourceID = JSC::noSourceID;
 458         errorString = &quot;Unexepcted non-string scriptId in given location&quot;_s;
 459         return false;
 460     }
 461 
 462     sourceID = scriptIDStr.toIntPtr();
 463     columnNumber = 0;
 464     location.getInteger(&quot;columnNumber&quot;_s, columnNumber);
 465     return true;
 466 }
 467 
 468 void InspectorDebuggerAgent::setBreakpointByUrl(ErrorString&amp; errorString, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations)
 469 {
 470     locations = JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;::create();
 471     if (!optionalURL == !optionalURLRegex) {
 472         errorString = &quot;Either url or urlRegex must be specified&quot;_s;
 473         return;
 474     }
 475 
 476     String url = optionalURL ? *optionalURL : *optionalURLRegex;
 477     int columnNumber = optionalColumnNumber ? *optionalColumnNumber : 0;
 478     bool isRegex = optionalURLRegex;
 479 
 480     String breakpointIdentifier = makeString(isRegex ? &quot;/&quot; : &quot;&quot;, url, isRegex ? &quot;/:&quot; : &quot;:&quot;, lineNumber, &#39;:&#39;, columnNumber);
 481     if (m_javaScriptBreakpoints.contains(breakpointIdentifier)) {
 482         errorString = &quot;Breakpoint for given location already exists.&quot;_s;
 483         return;
 484     }
 485 
 486     String condition = emptyString();
 487     bool autoContinue = false;
 488     unsigned ignoreCount = 0;
 489     RefPtr&lt;JSON::Array&gt; actions;
 490     if (options) {
 491         options-&gt;getString(&quot;condition&quot;_s, condition);
 492         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 493         options-&gt;getArray(&quot;actions&quot;_s, actions);
 494         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 495     }
 496 
 497     BreakpointActions breakpointActions;
 498     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 499         return;
 500 
 501     m_javaScriptBreakpoints.set(breakpointIdentifier, buildObjectForBreakpointCookie(url, lineNumber, columnNumber, condition, actions, isRegex, autoContinue, ignoreCount));
 502 
 503     for (auto&amp; entry : m_scripts) {
 504         Script&amp; script = entry.value;
 505         String scriptURLForBreakpoints = !script.sourceURL.isEmpty() ? script.sourceURL : script.url;
 506         if (!matches(scriptURLForBreakpoints, url, isRegex))
 507             continue;
 508 
 509         JSC::SourceID sourceID = entry.key;
 510         JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 511         resolveBreakpoint(script, breakpoint);
 512         if (!breakpoint.resolved)
 513             continue;
 514 
 515         bool existing;
 516         setBreakpoint(breakpoint, existing);
 517         if (existing)
 518             continue;
 519 
 520         ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 521         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 522 
 523         locations-&gt;addItem(buildDebuggerLocation(breakpoint));
 524     }
 525 
 526     *outBreakpointIdentifier = breakpointIdentifier;
 527 }
 528 
 529 void InspectorDebuggerAgent::setBreakpoint(ErrorString&amp; errorString, const JSON::Object&amp; location, const JSON::Object* options, Protocol::Debugger::BreakpointId* outBreakpointIdentifier, RefPtr&lt;Protocol::Debugger::Location&gt;&amp; actualLocation)
 530 {
 531     JSC::SourceID sourceID;
 532     unsigned lineNumber;
 533     unsigned columnNumber;
 534     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 535         return;
 536 
 537     String condition = emptyString();
 538     bool autoContinue = false;
 539     unsigned ignoreCount = 0;
 540     RefPtr&lt;JSON::Array&gt; actions;
 541     if (options) {
 542         options-&gt;getString(&quot;condition&quot;_s, condition);
 543         options-&gt;getBoolean(&quot;autoContinue&quot;_s, autoContinue);
 544         options-&gt;getArray(&quot;actions&quot;_s, actions);
 545         options-&gt;getInteger(&quot;ignoreCount&quot;_s, ignoreCount);
 546     }
 547 
 548     BreakpointActions breakpointActions;
 549     if (!breakpointActionsFromProtocol(errorString, actions, &amp;breakpointActions))
 550         return;
 551 
 552     auto scriptIterator = m_scripts.find(sourceID);
 553     if (scriptIterator == m_scripts.end()) {
 554         errorString = &quot;Missing script for scriptId in given location&quot;_s;
 555         return;
 556     }
 557 
 558     Script&amp; script = scriptIterator-&gt;value;
 559     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 560     resolveBreakpoint(script, breakpoint);
 561     if (!breakpoint.resolved) {
 562         errorString = &quot;Could not resolve breakpoint&quot;_s;
 563         return;
 564     }
 565 
 566     bool existing;
 567     setBreakpoint(breakpoint, existing);
 568     if (existing) {
 569         errorString = &quot;Breakpoint for given location already exists&quot;_s;
 570         return;
 571     }
 572 
 573     String breakpointIdentifier = makeString(sourceID, &#39;:&#39;, breakpoint.line, &#39;:&#39;, breakpoint.column);
 574     ScriptBreakpoint scriptBreakpoint(breakpoint.line, breakpoint.column, condition, breakpointActions, autoContinue, ignoreCount);
 575     didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
 576 
 577     actualLocation = buildDebuggerLocation(breakpoint);
 578     *outBreakpointIdentifier = breakpointIdentifier;
 579 }
 580 
 581 void InspectorDebuggerAgent::didSetBreakpoint(const JSC::Breakpoint&amp; breakpoint, const String&amp; breakpointIdentifier, const ScriptBreakpoint&amp; scriptBreakpoint)
 582 {
 583     JSC::BreakpointID id = breakpoint.id;
 584     m_scriptDebugServer.setBreakpointActions(id, scriptBreakpoint);
 585 
 586     auto debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.find(breakpointIdentifier);
 587     if (debugServerBreakpointIDsIterator == m_breakpointIdentifierToDebugServerBreakpointIDs.end())
 588         debugServerBreakpointIDsIterator = m_breakpointIdentifierToDebugServerBreakpointIDs.set(breakpointIdentifier, Vector&lt;JSC::BreakpointID&gt;()).iterator;
 589     debugServerBreakpointIDsIterator-&gt;value.append(id);
 590 
 591     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.set(id, breakpointIdentifier);
 592 }
 593 
 594 void InspectorDebuggerAgent::resolveBreakpoint(const Script&amp; script, JSC::Breakpoint&amp; breakpoint)
 595 {
 596     if (breakpoint.line &lt; static_cast&lt;unsigned&gt;(script.startLine) || static_cast&lt;unsigned&gt;(script.endLine) &lt; breakpoint.line)
 597         return;
 598 
 599     m_scriptDebugServer.resolveBreakpoint(breakpoint, script.sourceProvider.get());
 600 }
 601 
 602 void InspectorDebuggerAgent::setBreakpoint(JSC::Breakpoint&amp; breakpoint, bool&amp; existing)
 603 {
 604     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 605     m_scriptDebugServer.setBreakpoint(breakpoint, existing);
 606 }
 607 
 608 void InspectorDebuggerAgent::removeBreakpoint(ErrorString&amp;, const String&amp; breakpointIdentifier)
 609 {
 610     m_javaScriptBreakpoints.remove(breakpointIdentifier);
 611 
 612     for (JSC::BreakpointID breakpointID : m_breakpointIdentifierToDebugServerBreakpointIDs.take(breakpointIdentifier)) {
 613         m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.remove(breakpointID);
 614 
 615         const BreakpointActions&amp; breakpointActions = m_scriptDebugServer.getActionsForBreakpoint(breakpointID);
 616         for (auto&amp; action : breakpointActions)
 617             m_injectedScriptManager.releaseObjectGroup(objectGroupForBreakpointAction(action));
 618 
 619         JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 620         m_scriptDebugServer.removeBreakpointActions(breakpointID);
 621         m_scriptDebugServer.removeBreakpoint(breakpointID);
 622     }
 623 }
 624 
 625 void InspectorDebuggerAgent::continueUntilNextRunLoop(ErrorString&amp; errorString)
 626 {
 627     if (!assertPaused(errorString))
 628         return;
 629 
 630     resume(errorString);
 631 
 632     m_enablePauseWhenIdle = true;
 633 
 634     registerIdleHandler();
 635 }
 636 
 637 void InspectorDebuggerAgent::continueToLocation(ErrorString&amp; errorString, const JSON::Object&amp; location)
 638 {
 639     if (!assertPaused(errorString))
 640         return;
 641 
 642     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
 643         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
 644         m_continueToLocationBreakpointID = JSC::noBreakpointID;
 645     }
 646 
 647     JSC::SourceID sourceID;
 648     unsigned lineNumber;
 649     unsigned columnNumber;
 650     if (!parseLocation(errorString, location, sourceID, lineNumber, columnNumber))
 651         return;
 652 
 653     auto scriptIterator = m_scripts.find(sourceID);
 654     if (scriptIterator == m_scripts.end()) {
 655         m_scriptDebugServer.continueProgram();
 656         m_frontendDispatcher-&gt;resumed();
 657         errorString = &quot;Missing script for scriptId in given location&quot;_s;
 658         return;
 659     }
 660 
 661     String condition;
 662     bool autoContinue = false;
 663     unsigned ignoreCount = 0;
 664     JSC::Breakpoint breakpoint(sourceID, lineNumber, columnNumber, condition, autoContinue, ignoreCount);
 665     Script&amp; script = scriptIterator-&gt;value;
 666     resolveBreakpoint(script, breakpoint);
 667     if (!breakpoint.resolved) {
 668         m_scriptDebugServer.continueProgram();
 669         m_frontendDispatcher-&gt;resumed();
 670         errorString = &quot;Could not resolve breakpoint&quot;_s;
 671         return;
 672     }
 673 
 674     bool existing;
 675     setBreakpoint(breakpoint, existing);
 676     if (existing) {
 677         // There is an existing breakpoint at this location. Instead of
 678         // acting like a series of steps, just resume and we will either
 679         // hit this new breakpoint or not.
 680         m_scriptDebugServer.continueProgram();
 681         m_frontendDispatcher-&gt;resumed();
 682         return;
 683     }
 684 
 685     m_continueToLocationBreakpointID = breakpoint.id;
 686 
 687     // Treat this as a series of steps until reaching the new breakpoint.
 688     // So don&#39;t issue a resumed event unless we exit the VM without pausing.
 689     willStepAndMayBecomeIdle();
 690     m_scriptDebugServer.continueProgram();
 691 }
 692 
 693 void InspectorDebuggerAgent::searchInContent(ErrorString&amp; errorString, const String&amp; scriptIDStr, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
 694 {
 695     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 696     auto it = m_scripts.find(sourceID);
 697     if (it == m_scripts.end()) {
 698         errorString = &quot;Missing script for given scriptId&quot;;
 699         return;
 700     }
 701 
 702     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
 703     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
 704     results = ContentSearchUtilities::searchInTextByLines(it-&gt;value.source, query, caseSensitive, isRegex);
 705 }
 706 
 707 void InspectorDebuggerAgent::getScriptSource(ErrorString&amp; errorString, const String&amp; scriptIDStr, String* scriptSource)
 708 {
 709     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 710     auto it = m_scripts.find(sourceID);
 711     if (it != m_scripts.end())
 712         *scriptSource = it-&gt;value.source;
 713     else
 714         errorString = &quot;Missing script for given scriptId&quot;;
 715 }
 716 
 717 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 718 {
 719     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 720     if (injectedScript.hasNoValue()) {
 721         errorString = &quot;Missing injected script for given functionId&quot;_s;
 722         return;
 723     }
 724 
 725     injectedScript.getFunctionDetails(errorString, functionId, details);
 726 }
 727 
<a name="13" id="anc13"></a><span class="line-modified"> 728 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
 729 {
 730     if (m_javaScriptPauseScheduled)
 731         return;
 732 
 733     m_javaScriptPauseScheduled = true;
 734 
<a name="14" id="anc14"></a><span class="line-modified"> 735     updatePauseReasonAndData(reason, WTFMove(data));</span>

 736 
 737     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 738     m_scriptDebugServer.setPauseOnNextStatement(true);
 739 }
 740 
 741 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 742 {
 743     if (!m_javaScriptPauseScheduled)
 744         return;
 745 
 746     m_javaScriptPauseScheduled = false;
 747 
<a name="15" id="anc15"></a><span class="line-modified"> 748     clearPauseDetails();</span>
 749     m_scriptDebugServer.setPauseOnNextStatement(false);
 750     m_enablePauseWhenIdle = false;
 751 }
 752 
 753 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 754 {
 755     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 756 }
 757 
 758 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 759 {
<a name="16" id="anc16"></a><span class="line-modified"> 760     if (!m_pausedGlobalObject &amp;&amp; !m_javaScriptPauseScheduled) {</span>
 761         errorString = &quot;Must be paused or waiting to pause&quot;_s;
 762         return;
 763     }
 764 
 765     cancelPauseOnNextStatement();
 766     m_scriptDebugServer.continueProgram();
 767     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 768 }
 769 
 770 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 771 {
 772     if (!assertPaused(errorString))
 773         return;
 774 
 775     willStepAndMayBecomeIdle();
 776     m_scriptDebugServer.stepOverStatement();
 777 }
 778 
 779 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 780 {
 781     if (!assertPaused(errorString))
 782         return;
 783 
 784     willStepAndMayBecomeIdle();
 785     m_scriptDebugServer.stepIntoStatement();
 786 }
 787 
 788 void InspectorDebuggerAgent::stepOut(ErrorString&amp; errorString)
 789 {
 790     if (!assertPaused(errorString))
 791         return;
 792 
 793     willStepAndMayBecomeIdle();
 794     m_scriptDebugServer.stepOutOfFunction();
 795 }
 796 
 797 void InspectorDebuggerAgent::registerIdleHandler()
 798 {
 799     if (!m_registeredIdleCallback) {
 800         m_registeredIdleCallback = true;
 801         JSC::VM&amp; vm = m_scriptDebugServer.vm();
 802         vm.whenIdle([this]() {
 803             didBecomeIdle();
 804         });
 805     }
 806 }
 807 
 808 void InspectorDebuggerAgent::willStepAndMayBecomeIdle()
 809 {
 810     // When stepping the backend must eventually trigger a &quot;paused&quot; or &quot;resumed&quot; event.
 811     // If the step causes us to exit the VM, then we should issue &quot;resumed&quot;.
 812     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenIdle;
 813 
 814     registerIdleHandler();
 815 }
 816 
 817 void InspectorDebuggerAgent::didBecomeIdle()
 818 {
 819     m_registeredIdleCallback = false;
 820 
 821     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenIdle) {
 822         cancelPauseOnNextStatement();
 823         m_scriptDebugServer.continueProgram();
 824         m_frontendDispatcher-&gt;resumed();
 825     }
 826 
 827     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 828 
 829     if (m_enablePauseWhenIdle) {
 830         ErrorString ignored;
 831         pause(ignored);
 832     }
 833 }
 834 
<a name="17" id="anc17"></a><span class="line-added"> 835 void InspectorDebuggerAgent::setPauseOnDebuggerStatements(ErrorString&amp;, bool enabled)</span>
<span class="line-added"> 836 {</span>
<span class="line-added"> 837     m_scriptDebugServer.setPauseOnDebuggerStatements(enabled);</span>
<span class="line-added"> 838 }</span>
<span class="line-added"> 839 </span>
 840 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 841 {
 842     JSC::Debugger::PauseOnExceptionsState pauseState;
 843     if (stringPauseState == &quot;none&quot;)
 844         pauseState = JSC::Debugger::DontPauseOnExceptions;
 845     else if (stringPauseState == &quot;all&quot;)
 846         pauseState = JSC::Debugger::PauseOnAllExceptions;
 847     else if (stringPauseState == &quot;uncaught&quot;)
 848         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 849     else {
 850         errorString = makeString(&quot;Unknown state: &quot;_s, stringPauseState);
 851         return;
 852     }
 853 
 854     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 855     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 856         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 857 }
 858 
 859 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
 860 {
 861     m_pauseOnAssertionFailures = enabled;
 862 }
 863 
 864 void InspectorDebuggerAgent::setPauseOnMicrotasks(ErrorString&amp;, bool enabled)
 865 {
 866     m_pauseOnMicrotasks = enabled;
 867 }
 868 
 869 void InspectorDebuggerAgent::evaluateOnCallFrame(ErrorString&amp; errorString, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* /* emulateUserGesture */, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex)
 870 {
 871     if (!assertPaused(errorString))
 872         return;
 873 
 874     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(callFrameId);
 875     if (injectedScript.hasNoValue()) {
 876         errorString = &quot;Missing injected script for given callFrameId&quot;_s;
 877         return;
 878     }
 879 
 880     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 881     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 882     if (pauseAndMute) {
 883         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 884             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 885         muteConsole();
 886     }
 887 
 888     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 889         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 890         result, wasThrown, savedResultIndex);
 891 
 892     if (pauseAndMute) {
 893         unmuteConsole();
 894         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 895     }
 896 }
 897 
<a name="18" id="anc18"></a><span class="line-added"> 898 void InspectorDebuggerAgent::setShouldBlackboxURL(ErrorString&amp; errorString, const String&amp; url, bool shouldBlackbox, const bool* optionalCaseSensitive, const bool* optionalIsRegex)</span>
<span class="line-added"> 899 {</span>
<span class="line-added"> 900     if (url.isEmpty()) {</span>
<span class="line-added"> 901         errorString = &quot;URL must not be empty&quot;_s;</span>
<span class="line-added"> 902         return;</span>
<span class="line-added"> 903     }</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905     bool caseSensitive = optionalCaseSensitive &amp;&amp; *optionalCaseSensitive;</span>
<span class="line-added"> 906     bool isRegex = optionalIsRegex &amp;&amp; *optionalIsRegex;</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908     if (!caseSensitive &amp;&amp; !isRegex &amp;&amp; isWebKitInjectedScript(url)) {</span>
<span class="line-added"> 909         errorString = &quot;Blackboxing of internal scripts is controlled by &#39;Debugger.setPauseForInternalScripts&#39;&quot;_s;</span>
<span class="line-added"> 910         return;</span>
<span class="line-added"> 911     }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913     BlackboxConfig config { url, caseSensitive, isRegex };</span>
<span class="line-added"> 914     if (shouldBlackbox)</span>
<span class="line-added"> 915         m_blackboxedURLs.appendIfNotContains(config);</span>
<span class="line-added"> 916     else</span>
<span class="line-added"> 917         m_blackboxedURLs.removeAll(config);</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-added"> 920         if (isWebKitInjectedScript(script.sourceURL))</span>
<span class="line-added"> 921             continue;</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923         Optional&lt;JSC::Debugger::BlackboxType&gt; blackboxType;</span>
<span class="line-added"> 924         if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 925             blackboxType = JSC::Debugger::BlackboxType::Deferred;</span>
<span class="line-added"> 926         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-added"> 927     }</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930 bool InspectorDebuggerAgent::shouldBlackboxURL(const String&amp; url) const</span>
<span class="line-added"> 931 {</span>
<span class="line-added"> 932     if (!url.isEmpty()) {</span>
<span class="line-added"> 933         for (const auto&amp; blackboxConfig : m_blackboxedURLs) {</span>
<span class="line-added"> 934             auto searchStringType = blackboxConfig.isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ExactString;</span>
<span class="line-added"> 935             auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(blackboxConfig.url, blackboxConfig.caseSensitive, searchStringType);</span>
<span class="line-added"> 936             if (regex.match(url) != -1)</span>
<span class="line-added"> 937                 return true;</span>
<span class="line-added"> 938         }</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940     return false;</span>
<span class="line-added"> 941 }</span>
<span class="line-added"> 942 </span>
 943 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 944 {
 945     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 946         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 947 }
 948 
 949 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 950 {
 951     ASSERT(!injectedScript.hasNoValue());
 952     if (injectedScript.hasNoValue())
 953         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 954 
 955     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 956 }
 957 
 958 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 959 {
 960     return script.sourceMappingURL;
 961 }
 962 
 963 void InspectorDebuggerAgent::setPauseForInternalScripts(ErrorString&amp;, bool shouldPause)
 964 {
 965     if (shouldPause == m_pauseForInternalScripts)
 966         return;
 967 
 968     m_pauseForInternalScripts = shouldPause;
 969 
<a name="19" id="anc19"></a><span class="line-modified"> 970     auto blackboxType = !m_pauseForInternalScripts ? Optional&lt;JSC::Debugger::BlackboxType&gt;(JSC::Debugger::BlackboxType::Ignored) : WTF::nullopt;</span>
<span class="line-modified"> 971     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-modified"> 972         if (!isWebKitInjectedScript(script.sourceURL))</span>
<span class="line-modified"> 973             continue;</span>
<span class="line-modified"> 974         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-modified"> 975     }</span>

 976 }
 977 
 978 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script&amp; script)
 979 {
 980     String scriptIDStr = String::number(sourceID);
 981     bool hasSourceURL = !script.sourceURL.isEmpty();
 982     String sourceURL = script.sourceURL;
 983     String sourceMappingURL = sourceMapURLForScript(script);
 984 
 985     const bool isModule = script.sourceProvider-&gt;sourceType() == JSC::SourceProviderSourceType::Module;
 986     const bool* isContentScript = script.isContentScript ? &amp;script.isContentScript : nullptr;
 987     String* sourceURLParam = hasSourceURL ? &amp;sourceURL : nullptr;
 988     String* sourceMapURLParam = sourceMappingURL.isEmpty() ? nullptr : &amp;sourceMappingURL;
 989 
 990     m_frontendDispatcher-&gt;scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &amp;isModule : nullptr);
 991 
 992     m_scripts.set(sourceID, script);
 993 
<a name="20" id="anc20"></a><span class="line-modified"> 994     if (isWebKitInjectedScript(sourceURL)) {</span>
<span class="line-modified"> 995         if (!m_pauseForInternalScripts)</span>
<span class="line-added"> 996             m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Ignored);</span>
<span class="line-added"> 997     } else if (shouldBlackboxURL(sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 998         m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Deferred);</span>
 999 
1000     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
1001     if (scriptURLForBreakpoints.isEmpty())
1002         return;
1003 
1004     for (auto&amp; entry : m_javaScriptBreakpoints) {
1005         RefPtr&lt;JSON::Object&gt; breakpointObject = entry.value;
1006 
1007         bool isRegex;
1008         String url;
1009         breakpointObject-&gt;getBoolean(&quot;isRegex&quot;_s, isRegex);
1010         breakpointObject-&gt;getString(&quot;url&quot;_s, url);
1011         if (!matches(scriptURLForBreakpoints, url, isRegex))
1012             continue;
1013 
1014         ScriptBreakpoint scriptBreakpoint;
1015         breakpointObject-&gt;getInteger(&quot;lineNumber&quot;_s, scriptBreakpoint.lineNumber);
1016         breakpointObject-&gt;getInteger(&quot;columnNumber&quot;_s, scriptBreakpoint.columnNumber);
1017         breakpointObject-&gt;getString(&quot;condition&quot;_s, scriptBreakpoint.condition);
1018         breakpointObject-&gt;getBoolean(&quot;autoContinue&quot;_s, scriptBreakpoint.autoContinue);
1019         breakpointObject-&gt;getInteger(&quot;ignoreCount&quot;_s, scriptBreakpoint.ignoreCount);
1020         ErrorString errorString;
1021         RefPtr&lt;JSON::Array&gt; actions;
1022         breakpointObject-&gt;getArray(&quot;actions&quot;_s, actions);
1023         if (!breakpointActionsFromProtocol(errorString, actions, &amp;scriptBreakpoint.actions)) {
1024             ASSERT_NOT_REACHED();
1025             continue;
1026         }
1027 
1028         JSC::Breakpoint breakpoint(sourceID, scriptBreakpoint.lineNumber, scriptBreakpoint.columnNumber, scriptBreakpoint.condition, scriptBreakpoint.autoContinue, scriptBreakpoint.ignoreCount);
1029         resolveBreakpoint(script, breakpoint);
1030         if (!breakpoint.resolved)
1031             continue;
1032 
1033         bool existing;
1034         setBreakpoint(breakpoint, existing);
1035         if (existing)
1036             continue;
1037 
1038         String breakpointIdentifier = entry.key;
1039         didSetBreakpoint(breakpoint, breakpointIdentifier, scriptBreakpoint);
1040 
1041         m_frontendDispatcher-&gt;breakpointResolved(breakpointIdentifier, buildDebuggerLocation(breakpoint));
1042     }
1043 }
1044 
1045 void InspectorDebuggerAgent::failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage)
1046 {
1047     m_frontendDispatcher-&gt;scriptFailedToParse(url, data, firstLine, errorLine, errorMessage);
1048 }
1049 
1050 void InspectorDebuggerAgent::willRunMicrotask()
1051 {
1052     if (!m_scriptDebugServer.breakpointsActive())
1053         return;
1054 
1055     if (m_pauseOnMicrotasks)
1056         schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::Microtask, nullptr);
1057 }
1058 
1059 void InspectorDebuggerAgent::didRunMicrotask()
1060 {
1061     if (!m_scriptDebugServer.breakpointsActive())
1062         return;
1063 
1064     if (m_pauseOnMicrotasks)
1065         cancelPauseOnNextStatement();
1066 }
1067 
<a name="21" id="anc21"></a><span class="line-modified">1068 void InspectorDebuggerAgent::didPause(JSC::JSGlobalObject* globalObject, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)</span>
1069 {
<a name="22" id="anc22"></a><span class="line-modified">1070     ASSERT(!m_pausedGlobalObject);</span>
<span class="line-modified">1071     m_pausedGlobalObject = globalObject;</span>
<span class="line-modified">1072     m_currentCallStack = { globalObject-&gt;vm(), callFrames };</span>
1073 
<a name="23" id="anc23"></a><span class="line-modified">1074     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
1075 
1076     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
<a name="24" id="anc24"></a><span class="line-modified">1077     if (m_pauseReason == DebuggerFrontendDispatcher::Reason::Other) {</span>
1078         switch (m_scriptDebugServer.reasonForPause()) {
1079         case JSC::Debugger::PausedForBreakpoint: {
<a name="25" id="anc25"></a><span class="line-modified">1080             auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();</span>
<span class="line-modified">1081             if (debuggerBreakpointId != m_continueToLocationBreakpointID)</span>
<span class="line-modified">1082                 updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Breakpoint, buildBreakpointPauseReason(debuggerBreakpointId));</span>


1083             break;
1084         }
1085         case JSC::Debugger::PausedForDebuggerStatement:
<a name="26" id="anc26"></a><span class="line-modified">1086             updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::DebuggerStatement, nullptr);</span>

1087             break;
1088         case JSC::Debugger::PausedForException:
<a name="27" id="anc27"></a><span class="line-modified">1089             updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Exception, buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript));</span>
<span class="line-modified">1090             break;</span>
<span class="line-added">1091         case JSC::Debugger::PausedAfterBlackboxedScript: {</span>
<span class="line-added">1092             // There should be no break data, as we would&#39;ve already continued past the breakpoint.</span>
<span class="line-added">1093             ASSERT(!m_pauseData);</span>
<span class="line-added">1094 </span>
<span class="line-added">1095             // Don&#39;t call `updatePauseReasonAndData` so as to not override `m_preBlackboxPauseData`.</span>
<span class="line-added">1096             if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript)</span>
<span class="line-added">1097                 m_preBlackboxPauseReason = m_pauseReason;</span>
<span class="line-added">1098             m_pauseReason = DebuggerFrontendDispatcher::Reason::BlackboxedScript;</span>
1099             break;
<a name="28" id="anc28"></a><span class="line-added">1100         }</span>
1101         case JSC::Debugger::PausedAtStatement:
1102         case JSC::Debugger::PausedAtExpression:
1103         case JSC::Debugger::PausedBeforeReturn:
1104         case JSC::Debugger::PausedAtEndOfProgram:
1105             // Pause was just stepping. Nothing to report.
1106             break;
1107         case JSC::Debugger::NotPaused:
1108             ASSERT_NOT_REACHED();
1109             break;
1110         }
1111     }
1112 
<a name="29" id="anc29"></a><span class="line-added">1113     if (m_scriptDebugServer.reasonForPause() == JSC::Debugger::PausedAfterBlackboxedScript) {</span>
<span class="line-added">1114         // Ensure that `m_preBlackboxPauseReason` is populated with the most recent data.</span>
<span class="line-added">1115         updatePauseReasonAndData(m_pauseReason, nullptr);</span>
<span class="line-added">1116 </span>
<span class="line-added">1117         RefPtr&lt;JSON::Object&gt; data;</span>
<span class="line-added">1118         if (auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID()) {</span>
<span class="line-added">1119             ASSERT(debuggerBreakpointId != m_continueToLocationBreakpointID);</span>
<span class="line-added">1120             data = JSON::Object::create();</span>
<span class="line-added">1121             data-&gt;setString(&quot;originalReason&quot;_s, Protocol::InspectorHelpers::getEnumConstantValue(DebuggerFrontendDispatcher::Reason::Breakpoint));</span>
<span class="line-added">1122             data-&gt;setValue(&quot;originalData&quot;_s, buildBreakpointPauseReason(debuggerBreakpointId));</span>
<span class="line-added">1123         } else if (m_preBlackboxPauseData) {</span>
<span class="line-added">1124             data = JSON::Object::create();</span>
<span class="line-added">1125             data-&gt;setString(&quot;originalReason&quot;_s, Protocol::InspectorHelpers::getEnumConstantValue(m_preBlackboxPauseReason));</span>
<span class="line-added">1126             data-&gt;setValue(&quot;originalData&quot;_s, m_preBlackboxPauseData);</span>
<span class="line-added">1127         }</span>
<span class="line-added">1128         updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::BlackboxedScript, WTFMove(data));</span>
<span class="line-added">1129     }</span>
<span class="line-added">1130 </span>
1131     // Set $exception to the exception or caught value.
1132     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1133         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1134         m_hasExceptionValue = true;
1135     }
1136 
1137     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1138     m_enablePauseWhenIdle = false;
1139 
1140     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1141     if (m_currentAsyncCallIdentifier) {
1142         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1143         if (it != m_pendingAsyncCalls.end())
1144             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1145     }
1146 
<a name="30" id="anc30"></a><span class="line-modified">1147     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_pauseReason, m_pauseData, asyncStackTrace);</span>
1148 
1149     m_javaScriptPauseScheduled = false;
1150 
1151     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1152         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1153         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1154     }
1155 
1156     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1157     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1158         stopwatch-&gt;stop();
1159         m_didPauseStopwatch = true;
1160     }
1161 }
1162 
1163 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1164 {
1165     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1166 }
1167 
<a name="31" id="anc31"></a><span class="line-modified">1168 void InspectorDebuggerAgent::breakpointActionProbe(JSC::JSGlobalObject* globalObject, const ScriptBreakpointAction&amp; action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)</span>
1169 {
<a name="32" id="anc32"></a><span class="line-modified">1170     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
1171     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
1172     auto result = Protocol::Debugger::ProbeSample::create()
1173         .setProbeId(action.identifier)
1174         .setBatchId(batchId)
1175         .setSampleId(sampleId)
1176         .setTimestamp(m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;elapsedTime().seconds())
1177         .setPayload(WTFMove(payload))
1178         .release();
1179     m_frontendDispatcher-&gt;didSampleProbe(WTFMove(result));
1180 }
1181 
1182 void InspectorDebuggerAgent::didContinue()
1183 {
1184     if (m_didPauseStopwatch) {
1185         m_didPauseStopwatch = false;
1186         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1187     }
1188 
<a name="33" id="anc33"></a><span class="line-modified">1189     m_pausedGlobalObject = nullptr;</span>
1190     m_currentCallStack = { };
1191     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
<a name="34" id="anc34"></a><span class="line-modified">1192     clearPauseDetails();</span>
1193     clearExceptionValue();
1194 
1195     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1196         m_frontendDispatcher-&gt;resumed();
1197 }
1198 
<a name="35" id="anc35"></a><span class="line-modified">1199 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
1200 {
<a name="36" id="anc36"></a><span class="line-modified">1201     updatePauseReasonAndData(reason, WTFMove(data));</span>
<span class="line-modified">1202 </span>
1203     m_scriptDebugServer.breakProgram();
1204 }
1205 
1206 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1207 {
1208     ErrorString ignored;
1209     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
1210         removeBreakpoint(ignored, identifier);
1211 
1212     m_javaScriptBreakpoints.clear();
1213 
1214     clearDebuggerBreakpointState();
1215 }
1216 
1217 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1218 {
1219     {
1220         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1221         m_scriptDebugServer.clearBreakpointActions();
1222         m_scriptDebugServer.clearBreakpoints();
<a name="37" id="anc37"></a><span class="line-modified">1223         m_scriptDebugServer.clearBlackbox();</span>
1224     }
1225 
<a name="38" id="anc38"></a><span class="line-modified">1226     m_pausedGlobalObject = nullptr;</span>
1227     m_currentCallStack = { };
1228     m_scripts.clear();
1229     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1230     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
1231     m_continueToLocationBreakpointID = JSC::noBreakpointID;
<a name="39" id="anc39"></a><span class="line-modified">1232     clearPauseDetails();</span>
1233     m_javaScriptPauseScheduled = false;
1234     m_hasExceptionValue = false;
1235 
1236     if (isPaused()) {
1237         m_scriptDebugServer.continueProgram();
1238         m_frontendDispatcher-&gt;resumed();
1239     }
1240 }
1241 
1242 void InspectorDebuggerAgent::didClearGlobalObject()
1243 {
1244     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1245     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1246     clearDebuggerBreakpointState();
1247 
1248     clearAsyncStackTraceData();
1249 
1250     m_frontendDispatcher-&gt;globalObjectCleared();
1251 }
1252 
1253 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1254 {
<a name="40" id="anc40"></a><span class="line-modified">1255     if (!m_pausedGlobalObject) {</span>
1256         errorString = &quot;Must be paused&quot;_s;
1257         return false;
1258     }
1259 
1260     return true;
1261 }
1262 
<a name="41" id="anc41"></a><span class="line-modified">1263 void InspectorDebuggerAgent::clearPauseDetails()</span>
1264 {
<a name="42" id="anc42"></a><span class="line-modified">1265     updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Other, nullptr);</span>

1266 }
1267 
1268 void InspectorDebuggerAgent::clearExceptionValue()
1269 {
1270     if (m_hasExceptionValue) {
1271         m_injectedScriptManager.clearExceptionValue();
1272         m_hasExceptionValue = false;
1273     }
1274 }
1275 
1276 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1277 {
1278     m_pendingAsyncCalls.clear();
1279     m_currentAsyncCallIdentifier = WTF::nullopt;
1280 
1281     didClearAsyncStackTraceData();
1282 }
1283 
1284 } // namespace Inspector
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
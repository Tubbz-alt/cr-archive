<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CodeCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CodeCache.h&quot;
 28 
 29 #include &quot;BytecodeGenerator.h&quot;
 30 #include &quot;IndirectEvalExecutable.h&quot;
 31 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 32 
 33 namespace JSC {
 34 
 35 void CodeCacheMap::pruneSlowCase()
 36 {
 37     m_minCapacity = std::max(m_size - m_sizeAtLastPrune, static_cast&lt;int64_t&gt;(0));
 38     m_sizeAtLastPrune = m_size;
 39     m_timeAtLastPrune = MonotonicTime::now();
 40 
 41     if (m_capacity &lt; m_minCapacity)
 42         m_capacity = m_minCapacity;
 43 
 44     while (m_size &gt; m_capacity || !canPruneQuickly()) {
 45         MapType::iterator it = m_map.begin();
 46 
 47         writeCodeBlock(it-&gt;value.cell-&gt;vm(), it-&gt;key, it-&gt;value);
 48 
 49         m_size -= it-&gt;key.length();
 50         m_map.remove(it);
 51     }
 52 }
 53 
 54 static void generateUnlinkedCodeBlockForFunctions(VM&amp; vm, UnlinkedCodeBlock* unlinkedCodeBlock, const SourceCode&amp; parentSource, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)
 55 {
 56     auto generate = [&amp;](UnlinkedFunctionExecutable* unlinkedExecutable, CodeSpecializationKind constructorKind) {
 57         if (constructorKind == CodeForConstruct &amp;&amp; SourceParseModeSet(SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncMethodMode, SourceParseMode::AsyncFunctionMode).contains(unlinkedExecutable-&gt;parseMode()))
 58             return;
 59 
 60         SourceCode source = unlinkedExecutable-&gt;linkedSourceCode(parentSource);
 61         UnlinkedFunctionCodeBlock* unlinkedFunctionCodeBlock = unlinkedExecutable-&gt;unlinkedCodeBlockFor(vm, source, constructorKind, codeGenerationMode, error, unlinkedExecutable-&gt;parseMode());
 62         if (unlinkedFunctionCodeBlock)
 63             generateUnlinkedCodeBlockForFunctions(vm, unlinkedFunctionCodeBlock, source, codeGenerationMode, error);
 64     };
 65 
 66     // FIXME: We should also generate CodeBlocks for CodeForConstruct
 67     // https://bugs.webkit.org/show_bug.cgi?id=193823
 68     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionDecls(); i++)
 69         generate(unlinkedCodeBlock-&gt;functionDecl(i), CodeForCall);
 70     for (unsigned i = 0; i &lt; unlinkedCodeBlock-&gt;numberOfFunctionExprs(); i++)
 71         generate(unlinkedCodeBlock-&gt;functionExpr(i), CodeForCall);
 72 }
 73 
 74 template &lt;class UnlinkedCodeBlockType, class ExecutableType = ScriptExecutable&gt;
 75 UnlinkedCodeBlockType* generateUnlinkedCodeBlockImpl(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, DerivedContextType derivedContextType, bool isArrowFunctionContext, const VariableEnvironment* variablesUnderTDZ, ExecutableType* executable = nullptr)
 76 {
 77     typedef typename CacheTypes&lt;UnlinkedCodeBlockType&gt;::RootNode RootNode;
 78     std::unique_ptr&lt;RootNode&gt; rootNode = parse&lt;RootNode&gt;(
 79         vm, source, Identifier(), JSParserBuiltinMode::NotBuiltin, strictMode, scriptMode, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, SuperBinding::NotNeeded, error, nullptr, ConstructorKind::None, derivedContextType, evalContextType);
 80     if (!rootNode)
 81         return nullptr;
 82 
 83     unsigned lineCount = rootNode-&gt;lastLine() - rootNode-&gt;firstLine();
 84     unsigned startColumn = rootNode-&gt;startColumn() + 1;
 85     bool endColumnIsOnStartLine = !lineCount;
 86     unsigned unlinkedEndColumn = rootNode-&gt;endColumn();
 87     unsigned endColumn = unlinkedEndColumn + (endColumnIsOnStartLine ? startColumn : 1);
 88     unsigned arrowContextFeature = isArrowFunctionContext ? ArrowFunctionContextFeature : 0;
 89     if (executable)
 90         executable-&gt;recordParse(rootNode-&gt;features() | arrowContextFeature, rootNode-&gt;hasCapturedVariables(), rootNode-&gt;lastLine(), endColumn);
 91 
 92     bool usesEval = rootNode-&gt;features() &amp; EvalFeature;
 93     bool isStrictMode = rootNode-&gt;features() &amp; StrictModeFeature;
 94     NeedsClassFieldInitializer needsClassFieldInitializer = NeedsClassFieldInitializer::No;
 95     if constexpr (std::is_same_v&lt;ExecutableType, DirectEvalExecutable&gt;)
 96         needsClassFieldInitializer = executable-&gt;needsClassFieldInitializer();
 97     ExecutableInfo executableInfo(usesEval, isStrictMode, false, false, ConstructorKind::None, scriptMode, SuperBinding::NotNeeded, CacheTypes&lt;UnlinkedCodeBlockType&gt;::parseMode, derivedContextType, needsClassFieldInitializer, isArrowFunctionContext, false, evalContextType);
 98 
 99     UnlinkedCodeBlockType* unlinkedCodeBlock = UnlinkedCodeBlockType::create(vm, executableInfo, codeGenerationMode);
100     unlinkedCodeBlock-&gt;recordParse(rootNode-&gt;features(), rootNode-&gt;hasCapturedVariables(), lineCount, unlinkedEndColumn);
101     if (!source.provider()-&gt;sourceURLDirective().isNull())
102         unlinkedCodeBlock-&gt;setSourceURLDirective(source.provider()-&gt;sourceURLDirective());
103     if (!source.provider()-&gt;sourceMappingURLDirective().isNull())
104         unlinkedCodeBlock-&gt;setSourceMappingURLDirective(source.provider()-&gt;sourceMappingURLDirective());
105 
106     error = BytecodeGenerator::generate(vm, rootNode.get(), source, unlinkedCodeBlock, codeGenerationMode, variablesUnderTDZ);
107 
108     if (error.isValid())
109         return nullptr;
110 
111     return unlinkedCodeBlock;
112 }
113 
114 template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;
115 UnlinkedCodeBlockType* generateUnlinkedCodeBlock(VM&amp; vm, ExecutableType* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)
116 {
117     return generateUnlinkedCodeBlockImpl&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, executable-&gt;derivedContextType(), executable-&gt;isArrowFunctionContext(), variablesUnderTDZ, executable);
118 }
119 
120 UnlinkedEvalCodeBlock* generateUnlinkedCodeBlockForDirectEval(VM&amp; vm, DirectEvalExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)
121 {
122     return generateUnlinkedCodeBlock&lt;UnlinkedEvalCodeBlock&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);
123 }
124 
125 template &lt;class UnlinkedCodeBlockType&gt;
126 std::enable_if_t&lt;!std::is_same&lt;UnlinkedCodeBlockType, UnlinkedEvalCodeBlock&gt;::value, UnlinkedCodeBlockType*&gt;
127 recursivelyGenerateUnlinkedCodeBlock(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)
128 {
129     bool isArrowFunctionContext = false;
130     UnlinkedCodeBlockType* unlinkedCodeBlock = generateUnlinkedCodeBlockImpl&lt;UnlinkedCodeBlockType&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, DerivedContextType::None, isArrowFunctionContext, variablesUnderTDZ);
131     if (!unlinkedCodeBlock)
132         return nullptr;
133 
134     generateUnlinkedCodeBlockForFunctions(vm, unlinkedCodeBlock, source, codeGenerationMode, error);
135     return unlinkedCodeBlock;
136 }
137 
138 UnlinkedProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForProgram(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)
139 {
140     return recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);
141 }
142 
143 UnlinkedModuleProgramCodeBlock* recursivelyGenerateUnlinkedCodeBlockForModuleProgram(VM&amp; vm, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType, const VariableEnvironment* variablesUnderTDZ)
144 {
145     return recursivelyGenerateUnlinkedCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(vm, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, variablesUnderTDZ);
146 }
147 
148 template &lt;class UnlinkedCodeBlockType, class ExecutableType&gt;
149 UnlinkedCodeBlockType* CodeCache::getUnlinkedGlobalCodeBlock(VM&amp; vm, ExecutableType* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType)
150 {
151     DerivedContextType derivedContextType = executable-&gt;derivedContextType();
152     bool isArrowFunctionContext = executable-&gt;isArrowFunctionContext();
153     SourceCodeKey key(
154         source, String(), CacheTypes&lt;UnlinkedCodeBlockType&gt;::codeType, strictMode, scriptMode,
155         derivedContextType, evalContextType, isArrowFunctionContext, codeGenerationMode,
156         WTF::nullopt);
157     UnlinkedCodeBlockType* unlinkedCodeBlock = m_sourceCode.findCacheAndUpdateAge&lt;UnlinkedCodeBlockType&gt;(vm, key);
158     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
159         unsigned lineCount = unlinkedCodeBlock-&gt;lineCount();
160         unsigned startColumn = unlinkedCodeBlock-&gt;startColumn() + source.startColumn().oneBasedInt();
161         bool endColumnIsOnStartLine = !lineCount;
162         unsigned endColumn = unlinkedCodeBlock-&gt;endColumn() + (endColumnIsOnStartLine ? startColumn : 1);
163         executable-&gt;recordParse(unlinkedCodeBlock-&gt;codeFeatures(), unlinkedCodeBlock-&gt;hasCapturedVariables(), source.firstLine().oneBasedInt() + lineCount, endColumn);
164         if (unlinkedCodeBlock-&gt;sourceURLDirective())
165             source.provider()-&gt;setSourceURLDirective(unlinkedCodeBlock-&gt;sourceURLDirective());
166         if (unlinkedCodeBlock-&gt;sourceMappingURLDirective())
167             source.provider()-&gt;setSourceMappingURLDirective(unlinkedCodeBlock-&gt;sourceMappingURLDirective());
168         return unlinkedCodeBlock;
169     }
170 
171     VariableEnvironment variablesUnderTDZ;
172     unlinkedCodeBlock = generateUnlinkedCodeBlock&lt;UnlinkedCodeBlockType, ExecutableType&gt;(vm, executable, source, strictMode, scriptMode, codeGenerationMode, error, evalContextType, &amp;variablesUnderTDZ);
173 
174     if (unlinkedCodeBlock &amp;&amp; Options::useCodeCache()) {
175         m_sourceCode.addCache(key, SourceCodeValue(vm, unlinkedCodeBlock, m_sourceCode.age()));
176 
177         key.source().provider().cacheBytecode([&amp;] {
178             return encodeCodeBlock(vm, key, unlinkedCodeBlock);
179         });
180     }
181 
182     return unlinkedCodeBlock;
183 }
184 
185 UnlinkedProgramCodeBlock* CodeCache::getUnlinkedProgramCodeBlock(VM&amp; vm, ProgramExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)
186 {
187     return getUnlinkedGlobalCodeBlock&lt;UnlinkedProgramCodeBlock&gt;(vm, executable, source, strictMode, JSParserScriptMode::Classic, codeGenerationMode, error, EvalContextType::None);
188 }
189 
190 UnlinkedEvalCodeBlock* CodeCache::getUnlinkedEvalCodeBlock(VM&amp; vm, IndirectEvalExecutable* executable, const SourceCode&amp; source, JSParserStrictMode strictMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, EvalContextType evalContextType)
191 {
192     return getUnlinkedGlobalCodeBlock&lt;UnlinkedEvalCodeBlock&gt;(vm, executable, source, strictMode, JSParserScriptMode::Classic, codeGenerationMode, error, evalContextType);
193 }
194 
195 UnlinkedModuleProgramCodeBlock* CodeCache::getUnlinkedModuleProgramCodeBlock(VM&amp; vm, ModuleProgramExecutable* executable, const SourceCode&amp; source, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error)
196 {
197     return getUnlinkedGlobalCodeBlock&lt;UnlinkedModuleProgramCodeBlock&gt;(vm, executable, source, JSParserStrictMode::Strict, JSParserScriptMode::Module, codeGenerationMode, error, EvalContextType::None);
198 }
199 
200 UnlinkedFunctionExecutable* CodeCache::getUnlinkedGlobalFunctionExecutable(VM&amp; vm, const Identifier&amp; name, const SourceCode&amp; source, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, Optional&lt;int&gt; functionConstructorParametersEndPosition, ParserError&amp; error)
201 {
202     bool isArrowFunctionContext = false;
203     SourceCodeKey key(
204         source, name.string(), SourceCodeType::FunctionType,
205         JSParserStrictMode::NotStrict,
206         JSParserScriptMode::Classic,
207         DerivedContextType::None,
208         EvalContextType::None,
209         isArrowFunctionContext,
210         codeGenerationMode,
211         functionConstructorParametersEndPosition);
212     UnlinkedFunctionExecutable* executable = m_sourceCode.findCacheAndUpdateAge&lt;UnlinkedFunctionExecutable&gt;(vm, key);
213     if (executable &amp;&amp; Options::useCodeCache()) {
214         if (!executable-&gt;sourceURLDirective().isNull())
215             source.provider()-&gt;setSourceURLDirective(executable-&gt;sourceURLDirective());
216         if (!executable-&gt;sourceMappingURLDirective().isNull())
217             source.provider()-&gt;setSourceMappingURLDirective(executable-&gt;sourceMappingURLDirective());
218         return executable;
219     }
220 
221     JSTextPosition positionBeforeLastNewline;
222     std::unique_ptr&lt;ProgramNode&gt; program = parseFunctionForFunctionConstructor(vm, source, error, &amp;positionBeforeLastNewline, functionConstructorParametersEndPosition);
223     if (!program) {
224         RELEASE_ASSERT(error.isValid());
225         return nullptr;
226     }
227 
228     // This function assumes an input string that would result in a single function declaration.
229     StatementNode* funcDecl = program-&gt;singleStatement();
230     if (UNLIKELY(!funcDecl)) {
231         JSToken token;
232         error = ParserError(ParserError::SyntaxError, ParserError::SyntaxErrorIrrecoverable, token, &quot;Parser error&quot;, -1);
233         return nullptr;
234     }
235     ASSERT(funcDecl-&gt;isFuncDeclNode());
236 
237     FunctionMetadataNode* metadata = static_cast&lt;FuncDeclNode*&gt;(funcDecl)-&gt;metadata();
238     ASSERT(metadata);
239     if (!metadata)
240         return nullptr;
241 
242     metadata-&gt;overrideName(name);
243     metadata-&gt;setEndPosition(positionBeforeLastNewline);
244     // The Function constructor only has access to global variables, so no variables will be under TDZ unless they&#39;re
245     // in the global lexical environment, which we always TDZ check accesses from.
246     ConstructAbility constructAbility = constructAbilityForParseMode(metadata-&gt;parseMode());
247     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, metadata, UnlinkedNormalFunction, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, NeedsClassFieldInitializer::No);
248 
249     if (!source.provider()-&gt;sourceURLDirective().isNull())
250         functionExecutable-&gt;setSourceURLDirective(source.provider()-&gt;sourceURLDirective());
251     if (!source.provider()-&gt;sourceMappingURLDirective().isNull())
252         functionExecutable-&gt;setSourceMappingURLDirective(source.provider()-&gt;sourceMappingURLDirective());
253 
254     if (Options::useCodeCache())
255         m_sourceCode.addCache(key, SourceCodeValue(vm, functionExecutable, m_sourceCode.age()));
256     return functionExecutable;
257 }
258 
259 void CodeCache::updateCache(const UnlinkedFunctionExecutable* executable, const SourceCode&amp; parentSource, CodeSpecializationKind kind, const UnlinkedFunctionCodeBlock* codeBlock)
260 {
261     parentSource.provider()-&gt;updateCache(executable, parentSource, kind, codeBlock);
262 }
263 
264 void CodeCache::write(VM&amp; vm)
265 {
266     for (auto&amp; it : m_sourceCode)
267         writeCodeBlock(vm, it.key, it.value);
268 }
269 
270 void writeCodeBlock(VM&amp; vm, const SourceCodeKey&amp; key, const SourceCodeValue&amp; value)
271 {
272     UnlinkedCodeBlock* codeBlock = jsDynamicCast&lt;UnlinkedCodeBlock*&gt;(vm, value.cell.get());
273     if (!codeBlock)
274         return;
275 
276     key.source().provider().commitCachedBytecode();
277 }
278 
279 static SourceCodeKey sourceCodeKeyForSerializedBytecode(VM&amp;, const SourceCode&amp; sourceCode, SourceCodeType codeType, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
280 {
281     return SourceCodeKey(
282         sourceCode, String(), codeType, strictMode, scriptMode,
283         DerivedContextType::None, EvalContextType::None, false, codeGenerationMode,
284         WTF::nullopt);
285 }
286 
287 SourceCodeKey sourceCodeKeyForSerializedProgram(VM&amp; vm, const SourceCode&amp; sourceCode)
288 {
289     JSParserStrictMode strictMode = JSParserStrictMode::NotStrict;
290     JSParserScriptMode scriptMode = JSParserScriptMode::Classic;
291     return sourceCodeKeyForSerializedBytecode(vm, sourceCode, SourceCodeType::ProgramType, strictMode, scriptMode, { });
292 }
293 
294 SourceCodeKey sourceCodeKeyForSerializedModule(VM&amp; vm, const SourceCode&amp; sourceCode)
295 {
296     JSParserStrictMode strictMode = JSParserStrictMode::Strict;
297     JSParserScriptMode scriptMode = JSParserScriptMode::Module;
298     return sourceCodeKeyForSerializedBytecode(vm, sourceCode, SourceCodeType::ModuleType, strictMode, scriptMode, { });
299 }
300 
301 RefPtr&lt;CachedBytecode&gt; serializeBytecode(VM&amp; vm, UnlinkedCodeBlock* codeBlock, const SourceCode&amp; source, SourceCodeType codeType, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, FileSystem::PlatformFileHandle fd, BytecodeCacheError&amp; error, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)
302 {
303     return encodeCodeBlock(vm,
304         sourceCodeKeyForSerializedBytecode(vm, source, codeType, strictMode, scriptMode, codeGenerationMode), codeBlock, fd, error);
305 }
306 
307 }
    </pre>
  </body>
</html>
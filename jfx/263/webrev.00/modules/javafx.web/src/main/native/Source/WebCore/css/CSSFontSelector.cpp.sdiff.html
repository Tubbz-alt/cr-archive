<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFontFaceSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontSelector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 
 30 #include &quot;CachedFont.h&quot;
 31 #include &quot;CSSFontFace.h&quot;
 32 #include &quot;CSSFontFaceSource.h&quot;
 33 #include &quot;CSSFontFamily.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyNames.h&quot;
 36 #include &quot;CSSSegmentedFontFace.h&quot;
 37 #include &quot;CSSValueKeywords.h&quot;
 38 #include &quot;CSSValueList.h&quot;
 39 #include &quot;CachedResourceLoader.h&quot;
 40 #include &quot;Document.h&quot;
 41 #include &quot;Font.h&quot;
 42 #include &quot;FontCache.h&quot;
 43 #include &quot;FontFace.h&quot;
 44 #include &quot;FontFaceSet.h&quot;
 45 #include &quot;FontSelectorClient.h&quot;
 46 #include &quot;Frame.h&quot;
 47 #include &quot;FrameLoader.h&quot;
 48 #include &quot;Logging.h&quot;
<span class="line-removed"> 49 #include &quot;Quirks.h&quot;</span>
 50 #include &quot;ResourceLoadObserver.h&quot;
 51 #include &quot;RuntimeEnabledFeatures.h&quot;
 52 #include &quot;Settings.h&quot;
 53 #include &quot;StyleProperties.h&quot;
 54 #include &quot;StyleResolver.h&quot;
 55 #include &quot;StyleRule.h&quot;
 56 #include &quot;WebKitFontFamilyNames.h&quot;
 57 #include &lt;wtf/Ref.h&gt;
 58 #include &lt;wtf/SetForScope.h&gt;
 59 #include &lt;wtf/text/AtomString.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 static unsigned fontSelectorId;
 64 
 65 CSSFontSelector::CSSFontSelector(Document&amp; document)
 66     : m_document(makeWeakPtr(document))
 67     , m_cssFontFaceSet(CSSFontFaceSet::create(this))
 68     , m_beginLoadingTimer(*this, &amp;CSSFontSelector::beginLoadTimerFired)
 69     , m_uniqueId(++fontSelectorId)
 70     , m_version(0)
 71 {
 72     ASSERT(m_document);
 73     FontCache::singleton().addClient(*this);
 74     m_cssFontFaceSet-&gt;addClient(*this);
 75     LOG(Fonts, &quot;CSSFontSelector %p ctor&quot;, this);
 76 }
 77 
 78 CSSFontSelector::~CSSFontSelector()
 79 {
 80     LOG(Fonts, &quot;CSSFontSelector %p dtor&quot;, this);
 81 
 82     clearDocument();
 83     m_cssFontFaceSet-&gt;removeClient(*this);
 84     FontCache::singleton().removeClient(*this);
 85 }
 86 
<span class="line-modified"> 87 FontFaceSet* CSSFontSelector::optionalFontFaceSet()</span>
 88 {
 89     return m_fontFaceSet.get();
 90 }
 91 
 92 FontFaceSet&amp; CSSFontSelector::fontFaceSet()
 93 {
 94     if (!m_fontFaceSet) {
 95         ASSERT(m_document);
 96         m_fontFaceSet = FontFaceSet::create(*m_document, m_cssFontFaceSet.get());
 97     }
 98 
 99     return *m_fontFaceSet;
100 }
101 
102 bool CSSFontSelector::isEmpty() const
103 {
104     return !m_cssFontFaceSet-&gt;faceCount();
105 }
106 
107 void CSSFontSelector::emptyCaches()
</pre>
<hr />
<pre>
146     m_stagingArea.clear();
147     m_cssConnectionsPossiblyToRemove.clear();
148 }
149 
150 void CSSFontSelector::addFontFaceRule(StyleRuleFontFace&amp; fontFaceRule, bool isInitiatingElementInUserAgentShadowTree)
151 {
152     if (m_buildIsUnderway) {
153         m_cssConnectionsEncounteredDuringBuild.add(&amp;fontFaceRule);
154         m_stagingArea.append({fontFaceRule, isInitiatingElementInUserAgentShadowTree});
155         return;
156     }
157 
158     const StyleProperties&amp; style = fontFaceRule.properties();
159     RefPtr&lt;CSSValue&gt; fontFamily = style.getPropertyCSSValue(CSSPropertyFontFamily);
160     RefPtr&lt;CSSValue&gt; fontStyle = style.getPropertyCSSValue(CSSPropertyFontStyle);
161     RefPtr&lt;CSSValue&gt; fontWeight = style.getPropertyCSSValue(CSSPropertyFontWeight);
162     RefPtr&lt;CSSValue&gt; fontStretch = style.getPropertyCSSValue(CSSPropertyFontStretch);
163     RefPtr&lt;CSSValue&gt; src = style.getPropertyCSSValue(CSSPropertySrc);
164     RefPtr&lt;CSSValue&gt; unicodeRange = style.getPropertyCSSValue(CSSPropertyUnicodeRange);
165     RefPtr&lt;CSSValue&gt; featureSettings = style.getPropertyCSSValue(CSSPropertyFontFeatureSettings);
<span class="line-removed">166     RefPtr&lt;CSSValue&gt; variantLigatures = style.getPropertyCSSValue(CSSPropertyFontVariantLigatures);</span>
<span class="line-removed">167     RefPtr&lt;CSSValue&gt; variantPosition = style.getPropertyCSSValue(CSSPropertyFontVariantPosition);</span>
<span class="line-removed">168     RefPtr&lt;CSSValue&gt; variantCaps = style.getPropertyCSSValue(CSSPropertyFontVariantCaps);</span>
<span class="line-removed">169     RefPtr&lt;CSSValue&gt; variantNumeric = style.getPropertyCSSValue(CSSPropertyFontVariantNumeric);</span>
<span class="line-removed">170     RefPtr&lt;CSSValue&gt; variantAlternates = style.getPropertyCSSValue(CSSPropertyFontVariantAlternates);</span>
<span class="line-removed">171     RefPtr&lt;CSSValue&gt; variantEastAsian = style.getPropertyCSSValue(CSSPropertyFontVariantEastAsian);</span>
172     RefPtr&lt;CSSValue&gt; loadingBehavior = style.getPropertyCSSValue(CSSPropertyFontDisplay);
173     if (!is&lt;CSSValueList&gt;(fontFamily) || !is&lt;CSSValueList&gt;(src) || (unicodeRange &amp;&amp; !is&lt;CSSValueList&gt;(*unicodeRange)))
174         return;
175 
176     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*fontFamily);
177     if (!familyList.length())
178         return;
179 
180     CSSValueList* rangeList = downcast&lt;CSSValueList&gt;(unicodeRange.get());
181 
182     CSSValueList&amp; srcList = downcast&lt;CSSValueList&gt;(*src);
183     if (!srcList.length())
184         return;
185 
186     SetForScope&lt;bool&gt; creatingFont(m_creatingFont, true);
187     Ref&lt;CSSFontFace&gt; fontFace = CSSFontFace::create(this, &amp;fontFaceRule);
188 
189     if (!fontFace-&gt;setFamilies(*fontFamily))
190         return;
191     if (fontStyle)
192         fontFace-&gt;setStyle(*fontStyle);
193     if (fontWeight)
194         fontFace-&gt;setWeight(*fontWeight);
195     if (fontStretch)
196         fontFace-&gt;setStretch(*fontStretch);
197     if (rangeList &amp;&amp; !fontFace-&gt;setUnicodeRange(*rangeList))
198         return;
<span class="line-removed">199     if (variantLigatures &amp;&amp; !fontFace-&gt;setVariantLigatures(*variantLigatures))</span>
<span class="line-removed">200         return;</span>
<span class="line-removed">201     if (variantPosition &amp;&amp; !fontFace-&gt;setVariantPosition(*variantPosition))</span>
<span class="line-removed">202         return;</span>
<span class="line-removed">203     if (variantCaps &amp;&amp; !fontFace-&gt;setVariantCaps(*variantCaps))</span>
<span class="line-removed">204         return;</span>
<span class="line-removed">205     if (variantNumeric &amp;&amp; !fontFace-&gt;setVariantNumeric(*variantNumeric))</span>
<span class="line-removed">206         return;</span>
<span class="line-removed">207     if (variantAlternates &amp;&amp; !fontFace-&gt;setVariantAlternates(*variantAlternates))</span>
<span class="line-removed">208         return;</span>
<span class="line-removed">209     if (variantEastAsian &amp;&amp; !fontFace-&gt;setVariantEastAsian(*variantEastAsian))</span>
<span class="line-removed">210         return;</span>
211     if (featureSettings)
212         fontFace-&gt;setFeatureSettings(*featureSettings);
213     if (loadingBehavior)
214         fontFace-&gt;setLoadingBehavior(*loadingBehavior);
215 
216     CSSFontFace::appendSources(fontFace, srcList, m_document.get(), isInitiatingElementInUserAgentShadowTree);
217     if (fontFace-&gt;computeFailureState())
218         return;
219 
220     if (RefPtr&lt;CSSFontFace&gt; existingFace = m_cssFontFaceSet-&gt;lookUpByCSSConnection(fontFaceRule)) {
221         // This adoption is fairly subtle. Script can trigger a purge of m_cssFontFaceSet at any time,
222         // which will cause us to just rely on the memory cache to retain the bytes of the file the next
223         // time we build up the CSSFontFaceSet. However, when the CSS Font Loading API is involved,
224         // the FontFace and FontFaceSet objects need to retain state. We create the new CSSFontFace object
225         // while the old one is still in scope so that the memory cache will be forced to retain the bytes
226         // of the resource. This means that the CachedFont will temporarily have two clients (until the
227         // old CSSFontFace goes out of scope, which should happen at the end of this &quot;if&quot; block). Because
228         // the CSSFontFaceSource objects will inspect their CachedFonts, the new CSSFontFace is smart enough
229         // to enter the correct state() during the next pump(). This approach of making a new CSSFontFace is
230         // simpler than computing and applying a diff of the StyleProperties.
</pre>
<hr />
<pre>
305     if (familyName == pictographFamily)
306         return settings.pictographFontFamily(script);
307     if (familyName == standardFamily)
308         return settings.standardFontFamily(script);
309 
310     return WTF::nullopt;
311 }
312 
313 FontRanges CSSFontSelector::fontRangesForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; familyName)
314 {
315     // If this ASSERT() fires, it usually means you forgot a document.updateStyleIfNeeded() somewhere.
316     ASSERT(!m_buildIsUnderway || m_computingRootStyleFontCount);
317 
318     // FIXME: The spec (and Firefox) says user specified generic families (sans-serif etc.) should be resolved before the @font-face lookup too.
319     bool resolveGenericFamilyFirst = familyName == standardFamily;
320 
321     AtomString familyForLookup = familyName;
322     Optional&lt;FontDescription&gt; overrideFontDescription;
323     const FontDescription* fontDescriptionForLookup = &amp;fontDescription;
324     auto resolveGenericFamily = [&amp;]() {
<span class="line-modified">325         if (auto genericFamilyOptional = WebCore::resolveGenericFamily(m_document.get(), fontDescription, familyName)) {</span>
<span class="line-removed">326             if (m_document &amp;&amp; m_document-&gt;quirks().shouldLightenJapaneseBoldSansSerif() &amp;&amp; familyForLookup == sansSerifFamily &amp;&amp; fontDescription.weight() == boldWeightValue() &amp;&amp; fontDescription.script() == USCRIPT_KATAKANA_OR_HIRAGANA) {</span>
<span class="line-removed">327                 overrideFontDescription = fontDescription;</span>
<span class="line-removed">328                 overrideFontDescription-&gt;setWeight(FontSelectionValue(600));</span>
<span class="line-removed">329                 fontDescriptionForLookup = &amp;*overrideFontDescription;</span>
<span class="line-removed">330             }</span>
331             familyForLookup = *genericFamilyOptional;
<span class="line-removed">332         }</span>
333     };
334 
335     if (resolveGenericFamilyFirst)
336         resolveGenericFamily();
337     auto* face = m_cssFontFaceSet-&gt;fontFace(fontDescriptionForLookup-&gt;fontSelectionRequest(), familyForLookup);
338     if (face) {
339         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
340             if (m_document)
341                 ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), true);
342         }
343         return face-&gt;fontRanges(*fontDescriptionForLookup);
344     }
345 
346     if (!resolveGenericFamilyFirst)
347         resolveGenericFamily();
348     auto font = FontCache::singleton().fontForFamily(*fontDescriptionForLookup, familyForLookup);
349     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
350         if (m_document)
351             ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), !!font);
352     }
</pre>
<hr />
<pre>
387     // decrementRequestCount() in beginLoadTimerFired() and in clearDocument().
388     m_document-&gt;cachedResourceLoader().incrementRequestCount(font);
389 
390     m_beginLoadingTimer.startOneShot(0_s);
391 }
392 
393 void CSSFontSelector::beginLoadTimerFired()
394 {
395     Vector&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; fontsToBeginLoading;
396     fontsToBeginLoading.swap(m_fontsToBeginLoading);
397 
398     // CSSFontSelector could get deleted via beginLoadIfNeeded() or loadDone() unless protected.
399     Ref&lt;CSSFontSelector&gt; protectedThis(*this);
400 
401     CachedResourceLoader&amp; cachedResourceLoader = m_document-&gt;cachedResourceLoader();
402     for (auto&amp; fontHandle : fontsToBeginLoading) {
403         fontHandle-&gt;beginLoadIfNeeded(cachedResourceLoader);
404         // Balances incrementRequestCount() in beginLoadingFontSoon().
405         cachedResourceLoader.decrementRequestCount(*fontHandle);
406     }



407     // Ensure that if the request count reaches zero, the frame loader will know about it.
408     // New font loads may be triggered by layout after the document load is complete but before we have dispatched
409     // didFinishLoading for the frame. Make sure the delegate is always dispatched by checking explicitly.
410     if (m_document &amp;&amp; m_document-&gt;frame())
411         m_document-&gt;frame()-&gt;loader().checkLoadComplete();
<span class="line-removed">412     cachedResourceLoader.loadDone(LoadCompletionType::Finish);</span>
413 }
414 
415 
416 size_t CSSFontSelector::fallbackFontCount()
417 {
418     if (!m_document)
419         return 0;
420 
421     return m_document-&gt;settings().fontFallbackPrefersPictographs() ? 1 : 0;
422 }
423 
424 RefPtr&lt;Font&gt; CSSFontSelector::fallbackFontAt(const FontDescription&amp; fontDescription, size_t index)
425 {
426     ASSERT_UNUSED(index, !index);
427 
428     if (!m_document)
429         return nullptr;
430 
431     if (!m_document-&gt;settings().fontFallbackPrefersPictographs())
432         return nullptr;
</pre>
</td>
<td>
<hr />
<pre>
 29 
 30 #include &quot;CachedFont.h&quot;
 31 #include &quot;CSSFontFace.h&quot;
 32 #include &quot;CSSFontFaceSource.h&quot;
 33 #include &quot;CSSFontFamily.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyNames.h&quot;
 36 #include &quot;CSSSegmentedFontFace.h&quot;
 37 #include &quot;CSSValueKeywords.h&quot;
 38 #include &quot;CSSValueList.h&quot;
 39 #include &quot;CachedResourceLoader.h&quot;
 40 #include &quot;Document.h&quot;
 41 #include &quot;Font.h&quot;
 42 #include &quot;FontCache.h&quot;
 43 #include &quot;FontFace.h&quot;
 44 #include &quot;FontFaceSet.h&quot;
 45 #include &quot;FontSelectorClient.h&quot;
 46 #include &quot;Frame.h&quot;
 47 #include &quot;FrameLoader.h&quot;
 48 #include &quot;Logging.h&quot;

 49 #include &quot;ResourceLoadObserver.h&quot;
 50 #include &quot;RuntimeEnabledFeatures.h&quot;
 51 #include &quot;Settings.h&quot;
 52 #include &quot;StyleProperties.h&quot;
 53 #include &quot;StyleResolver.h&quot;
 54 #include &quot;StyleRule.h&quot;
 55 #include &quot;WebKitFontFamilyNames.h&quot;
 56 #include &lt;wtf/Ref.h&gt;
 57 #include &lt;wtf/SetForScope.h&gt;
 58 #include &lt;wtf/text/AtomString.h&gt;
 59 
 60 namespace WebCore {
 61 
 62 static unsigned fontSelectorId;
 63 
 64 CSSFontSelector::CSSFontSelector(Document&amp; document)
 65     : m_document(makeWeakPtr(document))
 66     , m_cssFontFaceSet(CSSFontFaceSet::create(this))
 67     , m_beginLoadingTimer(*this, &amp;CSSFontSelector::beginLoadTimerFired)
 68     , m_uniqueId(++fontSelectorId)
 69     , m_version(0)
 70 {
 71     ASSERT(m_document);
 72     FontCache::singleton().addClient(*this);
 73     m_cssFontFaceSet-&gt;addClient(*this);
 74     LOG(Fonts, &quot;CSSFontSelector %p ctor&quot;, this);
 75 }
 76 
 77 CSSFontSelector::~CSSFontSelector()
 78 {
 79     LOG(Fonts, &quot;CSSFontSelector %p dtor&quot;, this);
 80 
 81     clearDocument();
 82     m_cssFontFaceSet-&gt;removeClient(*this);
 83     FontCache::singleton().removeClient(*this);
 84 }
 85 
<span class="line-modified"> 86 FontFaceSet* CSSFontSelector::fontFaceSetIfExists()</span>
 87 {
 88     return m_fontFaceSet.get();
 89 }
 90 
 91 FontFaceSet&amp; CSSFontSelector::fontFaceSet()
 92 {
 93     if (!m_fontFaceSet) {
 94         ASSERT(m_document);
 95         m_fontFaceSet = FontFaceSet::create(*m_document, m_cssFontFaceSet.get());
 96     }
 97 
 98     return *m_fontFaceSet;
 99 }
100 
101 bool CSSFontSelector::isEmpty() const
102 {
103     return !m_cssFontFaceSet-&gt;faceCount();
104 }
105 
106 void CSSFontSelector::emptyCaches()
</pre>
<hr />
<pre>
145     m_stagingArea.clear();
146     m_cssConnectionsPossiblyToRemove.clear();
147 }
148 
149 void CSSFontSelector::addFontFaceRule(StyleRuleFontFace&amp; fontFaceRule, bool isInitiatingElementInUserAgentShadowTree)
150 {
151     if (m_buildIsUnderway) {
152         m_cssConnectionsEncounteredDuringBuild.add(&amp;fontFaceRule);
153         m_stagingArea.append({fontFaceRule, isInitiatingElementInUserAgentShadowTree});
154         return;
155     }
156 
157     const StyleProperties&amp; style = fontFaceRule.properties();
158     RefPtr&lt;CSSValue&gt; fontFamily = style.getPropertyCSSValue(CSSPropertyFontFamily);
159     RefPtr&lt;CSSValue&gt; fontStyle = style.getPropertyCSSValue(CSSPropertyFontStyle);
160     RefPtr&lt;CSSValue&gt; fontWeight = style.getPropertyCSSValue(CSSPropertyFontWeight);
161     RefPtr&lt;CSSValue&gt; fontStretch = style.getPropertyCSSValue(CSSPropertyFontStretch);
162     RefPtr&lt;CSSValue&gt; src = style.getPropertyCSSValue(CSSPropertySrc);
163     RefPtr&lt;CSSValue&gt; unicodeRange = style.getPropertyCSSValue(CSSPropertyUnicodeRange);
164     RefPtr&lt;CSSValue&gt; featureSettings = style.getPropertyCSSValue(CSSPropertyFontFeatureSettings);






165     RefPtr&lt;CSSValue&gt; loadingBehavior = style.getPropertyCSSValue(CSSPropertyFontDisplay);
166     if (!is&lt;CSSValueList&gt;(fontFamily) || !is&lt;CSSValueList&gt;(src) || (unicodeRange &amp;&amp; !is&lt;CSSValueList&gt;(*unicodeRange)))
167         return;
168 
169     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(*fontFamily);
170     if (!familyList.length())
171         return;
172 
173     CSSValueList* rangeList = downcast&lt;CSSValueList&gt;(unicodeRange.get());
174 
175     CSSValueList&amp; srcList = downcast&lt;CSSValueList&gt;(*src);
176     if (!srcList.length())
177         return;
178 
179     SetForScope&lt;bool&gt; creatingFont(m_creatingFont, true);
180     Ref&lt;CSSFontFace&gt; fontFace = CSSFontFace::create(this, &amp;fontFaceRule);
181 
182     if (!fontFace-&gt;setFamilies(*fontFamily))
183         return;
184     if (fontStyle)
185         fontFace-&gt;setStyle(*fontStyle);
186     if (fontWeight)
187         fontFace-&gt;setWeight(*fontWeight);
188     if (fontStretch)
189         fontFace-&gt;setStretch(*fontStretch);
190     if (rangeList &amp;&amp; !fontFace-&gt;setUnicodeRange(*rangeList))
191         return;












192     if (featureSettings)
193         fontFace-&gt;setFeatureSettings(*featureSettings);
194     if (loadingBehavior)
195         fontFace-&gt;setLoadingBehavior(*loadingBehavior);
196 
197     CSSFontFace::appendSources(fontFace, srcList, m_document.get(), isInitiatingElementInUserAgentShadowTree);
198     if (fontFace-&gt;computeFailureState())
199         return;
200 
201     if (RefPtr&lt;CSSFontFace&gt; existingFace = m_cssFontFaceSet-&gt;lookUpByCSSConnection(fontFaceRule)) {
202         // This adoption is fairly subtle. Script can trigger a purge of m_cssFontFaceSet at any time,
203         // which will cause us to just rely on the memory cache to retain the bytes of the file the next
204         // time we build up the CSSFontFaceSet. However, when the CSS Font Loading API is involved,
205         // the FontFace and FontFaceSet objects need to retain state. We create the new CSSFontFace object
206         // while the old one is still in scope so that the memory cache will be forced to retain the bytes
207         // of the resource. This means that the CachedFont will temporarily have two clients (until the
208         // old CSSFontFace goes out of scope, which should happen at the end of this &quot;if&quot; block). Because
209         // the CSSFontFaceSource objects will inspect their CachedFonts, the new CSSFontFace is smart enough
210         // to enter the correct state() during the next pump(). This approach of making a new CSSFontFace is
211         // simpler than computing and applying a diff of the StyleProperties.
</pre>
<hr />
<pre>
286     if (familyName == pictographFamily)
287         return settings.pictographFontFamily(script);
288     if (familyName == standardFamily)
289         return settings.standardFontFamily(script);
290 
291     return WTF::nullopt;
292 }
293 
294 FontRanges CSSFontSelector::fontRangesForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; familyName)
295 {
296     // If this ASSERT() fires, it usually means you forgot a document.updateStyleIfNeeded() somewhere.
297     ASSERT(!m_buildIsUnderway || m_computingRootStyleFontCount);
298 
299     // FIXME: The spec (and Firefox) says user specified generic families (sans-serif etc.) should be resolved before the @font-face lookup too.
300     bool resolveGenericFamilyFirst = familyName == standardFamily;
301 
302     AtomString familyForLookup = familyName;
303     Optional&lt;FontDescription&gt; overrideFontDescription;
304     const FontDescription* fontDescriptionForLookup = &amp;fontDescription;
305     auto resolveGenericFamily = [&amp;]() {
<span class="line-modified">306         if (auto genericFamilyOptional = WebCore::resolveGenericFamily(m_document.get(), fontDescription, familyName))</span>





307             familyForLookup = *genericFamilyOptional;

308     };
309 
310     if (resolveGenericFamilyFirst)
311         resolveGenericFamily();
312     auto* face = m_cssFontFaceSet-&gt;fontFace(fontDescriptionForLookup-&gt;fontSelectionRequest(), familyForLookup);
313     if (face) {
314         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
315             if (m_document)
316                 ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), true);
317         }
318         return face-&gt;fontRanges(*fontDescriptionForLookup);
319     }
320 
321     if (!resolveGenericFamilyFirst)
322         resolveGenericFamily();
323     auto font = FontCache::singleton().fontForFamily(*fontDescriptionForLookup, familyForLookup);
324     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled()) {
325         if (m_document)
326             ResourceLoadObserver::shared().logFontLoad(*m_document, familyForLookup.string(), !!font);
327     }
</pre>
<hr />
<pre>
362     // decrementRequestCount() in beginLoadTimerFired() and in clearDocument().
363     m_document-&gt;cachedResourceLoader().incrementRequestCount(font);
364 
365     m_beginLoadingTimer.startOneShot(0_s);
366 }
367 
368 void CSSFontSelector::beginLoadTimerFired()
369 {
370     Vector&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; fontsToBeginLoading;
371     fontsToBeginLoading.swap(m_fontsToBeginLoading);
372 
373     // CSSFontSelector could get deleted via beginLoadIfNeeded() or loadDone() unless protected.
374     Ref&lt;CSSFontSelector&gt; protectedThis(*this);
375 
376     CachedResourceLoader&amp; cachedResourceLoader = m_document-&gt;cachedResourceLoader();
377     for (auto&amp; fontHandle : fontsToBeginLoading) {
378         fontHandle-&gt;beginLoadIfNeeded(cachedResourceLoader);
379         // Balances incrementRequestCount() in beginLoadingFontSoon().
380         cachedResourceLoader.decrementRequestCount(*fontHandle);
381     }
<span class="line-added">382     // FIXME: Use SubresourceLoader instead.</span>
<span class="line-added">383     // Call FrameLoader::loadDone before FrameLoader::subresourceLoadDone to match the order in SubresourceLoader::notifyDone.</span>
<span class="line-added">384     cachedResourceLoader.loadDone(LoadCompletionType::Finish);</span>
385     // Ensure that if the request count reaches zero, the frame loader will know about it.
386     // New font loads may be triggered by layout after the document load is complete but before we have dispatched
387     // didFinishLoading for the frame. Make sure the delegate is always dispatched by checking explicitly.
388     if (m_document &amp;&amp; m_document-&gt;frame())
389         m_document-&gt;frame()-&gt;loader().checkLoadComplete();

390 }
391 
392 
393 size_t CSSFontSelector::fallbackFontCount()
394 {
395     if (!m_document)
396         return 0;
397 
398     return m_document-&gt;settings().fontFallbackPrefersPictographs() ? 1 : 0;
399 }
400 
401 RefPtr&lt;Font&gt; CSSFontSelector::fallbackFontAt(const FontDescription&amp; fontDescription, size_t index)
402 {
403     ASSERT_UNUSED(index, !index);
404 
405     if (!m_document)
406         return nullptr;
407 
408     if (!m_document-&gt;settings().fontFallbackPrefersPictographs())
409         return nullptr;
</pre>
</td>
</tr>
</table>
<center><a href="CSSFontFaceSource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFontSelector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
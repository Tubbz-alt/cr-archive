<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperPlatformLayerBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93         m_pendingBuffer = nullptr;
 94         m_releaseUnusedBuffersTimer = nullptr;
 95         m_usedBuffers.clear();
 96 
 97         // Clear the timer and dispatch the update function manually now.
 98         m_compositorThreadUpdateTimer = nullptr;
 99         if (!m_compositorThreadUpdateFunction)
100             return;
101         updateFunction = WTFMove(m_compositorThreadUpdateFunction);
102     }
103 
104     updateFunction();
105 }
106 
107 bool TextureMapperPlatformLayerProxy::isActive()
108 {
109     ASSERT(m_lock.isHeld());
110     return !!m_targetLayer &amp;&amp; !!m_compositor;
111 }
112 
<span class="line-modified">113 void TextureMapperPlatformLayerProxy::pushNextBuffer(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; newBuffer)</span>
114 {
115     ASSERT(m_lock.isHeld());






116     m_pendingBuffer = WTFMove(newBuffer);
117     m_wasBufferDropped = false;
118 
119     if (m_compositor)
120         m_compositor-&gt;onNewBufferAvailable();
121 }
122 
123 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerProxy::getAvailableBuffer(const IntSize&amp; size, GLint internalFormat)
124 {
125     ASSERT(m_lock.isHeld());
126     ASSERT(m_compositorThread == &amp;Thread::current());
127     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; availableBuffer;
128 
129     auto buffers = WTFMove(m_usedBuffers);
130     for (auto&amp; buffer : buffers) {
131         if (!buffer)
132             continue;
133 
134         if (!availableBuffer &amp;&amp; buffer-&gt;canReuseWithoutReset(size, internalFormat)) {
135             availableBuffer = WTFMove(buffer);
</pre>
</td>
<td>
<hr />
<pre>
 93         m_pendingBuffer = nullptr;
 94         m_releaseUnusedBuffersTimer = nullptr;
 95         m_usedBuffers.clear();
 96 
 97         // Clear the timer and dispatch the update function manually now.
 98         m_compositorThreadUpdateTimer = nullptr;
 99         if (!m_compositorThreadUpdateFunction)
100             return;
101         updateFunction = WTFMove(m_compositorThreadUpdateFunction);
102     }
103 
104     updateFunction();
105 }
106 
107 bool TextureMapperPlatformLayerProxy::isActive()
108 {
109     ASSERT(m_lock.isHeld());
110     return !!m_targetLayer &amp;&amp; !!m_compositor;
111 }
112 
<span class="line-modified">113 void TextureMapperPlatformLayerProxy::pushNextBuffer(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;&amp;&amp; newBuffer)</span>
114 {
115     ASSERT(m_lock.isHeld());
<span class="line-added">116 #if USE(ANGLE)</span>
<span class="line-added">117     // When the newBuffer overwrites m_pendingBuffer that is not swapped yet,</span>
<span class="line-added">118     // the layer related to m_pendingBuffer is flickering since its texture is destroyed.</span>
<span class="line-added">119     if (m_pendingBuffer &amp;&amp; m_pendingBuffer-&gt;hasManagedTexture())</span>
<span class="line-added">120         return;</span>
<span class="line-added">121 #endif</span>
122     m_pendingBuffer = WTFMove(newBuffer);
123     m_wasBufferDropped = false;
124 
125     if (m_compositor)
126         m_compositor-&gt;onNewBufferAvailable();
127 }
128 
129 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerProxy::getAvailableBuffer(const IntSize&amp; size, GLint internalFormat)
130 {
131     ASSERT(m_lock.isHeld());
132     ASSERT(m_compositorThread == &amp;Thread::current());
133     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; availableBuffer;
134 
135     auto buffers = WTFMove(m_usedBuffers);
136     for (auto&amp; buffer : buffers) {
137         if (!buffer)
138             continue;
139 
140         if (!availableBuffer &amp;&amp; buffer-&gt;canReuseWithoutReset(size, internalFormat)) {
141             availableBuffer = WTFMove(buffer);
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperPlatformLayerBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperPlatformLayerProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
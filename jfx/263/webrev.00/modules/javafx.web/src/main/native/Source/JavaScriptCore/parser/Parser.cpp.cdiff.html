<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;BuiltinNames.h&quot;
  #include &quot;DebuggerParseData.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;VM.h&quot;
  #include &lt;utility&gt;
<span class="line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  #include &lt;wtf/SetForScope.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  
  #define updateErrorMessage(shouldPrintToken, ...) do {\
      propagateError(); \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,21 ***</span>
      stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
      setErrorMessage(stream.toStringWithLatin1Fallback());
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
      : m_vm(vm)
      , m_source(&amp;source)
      , m_hasStackOverflow(false)
      , m_allowsIn(true)
      , m_statementDepth(0)
<span class="line-removed">-     , m_sourceElements(0)</span>
      , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
      , m_scriptMode(scriptMode)
      , m_superBinding(superBinding)
<span class="line-modified">!     , m_defaultConstructorKind(defaultConstructorKind)</span>
      , m_immediateParentAllowsFunctionDeclarationInStatement(false)
      , m_debuggerParseData(debuggerParseData)
  {
      m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
      m_lexer-&gt;setCode(source, &amp;m_parserArena);
<span class="line-new-header">--- 125,20 ---</span>
      stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
      setErrorMessage(stream.toStringWithLatin1Fallback());
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKindForTopLevelFunction, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
      : m_vm(vm)
      , m_source(&amp;source)
      , m_hasStackOverflow(false)
      , m_allowsIn(true)
      , m_statementDepth(0)
      , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
      , m_scriptMode(scriptMode)
      , m_superBinding(superBinding)
<span class="line-modified">!     , m_defaultConstructorKindForTopLevelFunction(defaultConstructorKindForTopLevelFunction)</span>
      , m_immediateParentAllowsFunctionDeclarationInStatement(false)
      , m_debuggerParseData(debuggerParseData)
  {
      m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
      m_lexer-&gt;setCode(source, &amp;m_parserArena);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,26 ***</span>
  Parser&lt;LexerType&gt;::~Parser()
  {
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)</span>
  {
<span class="line-removed">-     String parseError = String();</span>
<span class="line-removed">- </span>
      ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
      ScopeRef scope = currentScope();
      scope-&gt;setIsLexicalScope();
      SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
  
      bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
      if (m_lexer-&gt;isReparsingFunction()) {
          ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
          if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
<span class="line-modified">!             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);</span>
          else
<span class="line-modified">!             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);</span>
  
          if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
              // The only way we could have an error wile reparsing is if we run out of stack space.
              RELEASE_ASSERT(match(ARROWFUNCTION));
              next();
<span class="line-new-header">--- 206,27 ---</span>
  Parser&lt;LexerType&gt;::~Parser()
  {
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! Expected&lt;typename Parser&lt;LexerType&gt;::ParseInnerResult, String&gt; Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
  {
      ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
      ScopeRef scope = currentScope();
      scope-&gt;setIsLexicalScope();
      SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
  
<span class="line-added">+     FunctionParameters* parameters = nullptr;</span>
      bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
      if (m_lexer-&gt;isReparsingFunction()) {
          ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
          if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
<span class="line-modified">!             parameters = createGeneratorParameters(context, functionInfo.parameterCount);</span>
<span class="line-added">+         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode)</span>
<span class="line-added">+             parameters = context.createFormalParameterList();</span>
          else
<span class="line-modified">!             parameters = parseFunctionParameters(context, parseMode, functionInfo);</span>
  
          if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
              // The only way we could have an error wile reparsing is if we run out of stack space.
              RELEASE_ASSERT(match(ARROWFUNCTION));
              next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,21 ***</span>
              sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
          else if (isAsyncGeneratorWrapperParseMode(parseMode))
              sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
          else if (parsingContext == ParsingContext::FunctionConstructor)
              sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
<span class="line-modified">!         else</span>
              sourceElements = parseSourceElements(context, CheckForStrictMode);
      }
  
      bool validEnding = consume(EOFTOK);
<span class="line-modified">!     if (!sourceElements || !validEnding) {</span>
<span class="line-modified">!         if (hasError())</span>
<span class="line-removed">-             parseError = m_errorMessage;</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             parseError = &quot;Parser error&quot;_s;</span>
<span class="line-removed">-     }</span>
  
      IdentifierSet capturedVariables;
      UniquedStringImplPtrSet sloppyModeHoistedFunctions;
      scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
      scope-&gt;getCapturedVars(capturedVariables);
<span class="line-new-header">--- 253,20 ---</span>
              sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
          else if (isAsyncGeneratorWrapperParseMode(parseMode))
              sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
          else if (parsingContext == ParsingContext::FunctionConstructor)
              sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
<span class="line-modified">!         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode) {</span>
<span class="line-added">+             ASSERT(instanceFieldLocations &amp;&amp; !instanceFieldLocations-&gt;isEmpty());</span>
<span class="line-added">+             sourceElements = parseInstanceFieldInitializerSourceElements(context, *instanceFieldLocations);</span>
<span class="line-added">+         } else</span>
              sourceElements = parseSourceElements(context, CheckForStrictMode);
      }
  
      bool validEnding = consume(EOFTOK);
<span class="line-modified">!     if (!sourceElements || !validEnding)</span>
<span class="line-modified">!         return makeUnexpected(hasError() ? m_errorMessage : &quot;Parser error&quot;_s);</span>
  
      IdentifierSet capturedVariables;
      UniquedStringImplPtrSet sloppyModeHoistedFunctions;
      scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
      scope-&gt;getCapturedVars(capturedVariables);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,11 ***</span>
      if (scope-&gt;shadowsArguments())
          features |= ShadowsArgumentsFeature;
      if (m_seenTaggedTemplate)
          features |= NoEvalCacheFeature;
  
<span class="line-modified">! #ifndef NDEBUG</span>
      if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
          VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
          const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
          for (UniquedStringImpl* candidate : closedVariableCandidates) {
              // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
<span class="line-new-header">--- 286,11 ---</span>
      if (scope-&gt;shadowsArguments())
          features |= ShadowsArgumentsFeature;
      if (m_seenTaggedTemplate)
          features |= NoEvalCacheFeature;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
          VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
          const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
          for (UniquedStringImpl* candidate : closedVariableCandidates) {
              // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,33 ***</span>
                  dataLog(m_source-&gt;view());
                  CRASH();
              }
          }
      }
<span class="line-modified">! #endif // NDEBUG</span>
<span class="line-removed">-     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());</span>
  
<span class="line-modified">!     return parseError;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;typename LexerType&gt;</span>
<span class="line-removed">- void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,</span>
<span class="line-removed">-     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_sourceElements = sourceElements;</span>
<span class="line-removed">-     m_funcDeclarations = WTFMove(funcStack);</span>
<span class="line-removed">-     m_varDeclarations.swap(varDeclarations);</span>
<span class="line-removed">-     m_features = features;</span>
<span class="line-removed">-     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);</span>
<span class="line-removed">-     m_numConstants = numConstants;</span>
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()</span>
  {
      if (match(OPENPAREN)) {
<span class="line-modified">!         SavePoint saveArrowFunctionPoint = createSavePoint();</span>
          next();
          bool isArrowFunction = false;
          if (match(CLOSEPAREN)) {
              next();
              isArrowFunction = match(ARROWFUNCTION);
<span class="line-new-header">--- 299,20 ---</span>
                  dataLog(m_source-&gt;view());
                  CRASH();
              }
          }
      }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
<span class="line-modified">!     return ParseInnerResult { parameters, sourceElements, scope-&gt;takeFunctionDeclarations(), WTFMove(varDeclarations), WTFMove(sloppyModeHoistedFunctions), features, context.numConstants() };</span>
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isArrowFunctionParameters(TreeBuilder&amp; context)</span>
  {
      if (match(OPENPAREN)) {
<span class="line-modified">!         SavePoint saveArrowFunctionPoint = createSavePoint(context);</span>
          next();
          bool isArrowFunction = false;
          if (match(CLOSEPAREN)) {
              next();
              isArrowFunction = match(ARROWFUNCTION);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,19 ***</span>
              bool isMethod = false;
              isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
              propagateError();
              popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
          }
<span class="line-modified">!         restoreSavePoint(saveArrowFunctionPoint);</span>
          return isArrowFunction;
      }
  
      if (matchSpecIdentifier()) {
<span class="line-modified">!         SavePoint saveArrowFunctionPoint = createSavePoint();</span>
          next();
          bool isArrowFunction = match(ARROWFUNCTION);
<span class="line-modified">!         restoreSavePoint(saveArrowFunctionPoint);</span>
          return isArrowFunction;
      }
  
      return false;
  }
<span class="line-new-header">--- 327,20 ---</span>
              bool isMethod = false;
              isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
              propagateError();
              popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
          }
<span class="line-modified">!         restoreSavePoint(context, saveArrowFunctionPoint);</span>
          return isArrowFunction;
      }
  
      if (matchSpecIdentifier()) {
<span class="line-modified">!         semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);</span>
<span class="line-added">+         SavePoint saveArrowFunctionPoint = createSavePoint(context);</span>
          next();
          bool isArrowFunction = match(ARROWFUNCTION);
<span class="line-modified">!         restoreSavePoint(context, saveArrowFunctionPoint);</span>
          return isArrowFunction;
      }
  
      return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,11 ***</span>
  {
      const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
      TreeSourceElements sourceElements = context.createSourceElements();
      const Identifier* directive = 0;
      unsigned directiveLiteralLength = 0;
<span class="line-modified">!     auto savePoint = createSavePoint();</span>
      bool shouldCheckForUseStrict = mode == CheckForStrictMode;
  
      while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
          if (shouldCheckForUseStrict) {
              if (directive) {
<span class="line-new-header">--- 356,11 ---</span>
  {
      const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
      TreeSourceElements sourceElements = context.createSourceElements();
      const Identifier* directive = 0;
      unsigned directiveLiteralLength = 0;
<span class="line-modified">!     auto savePoint = createSavePoint(context);</span>
      bool shouldCheckForUseStrict = mode == CheckForStrictMode;
  
      while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
          if (shouldCheckForUseStrict) {
              if (directive) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,11 ***</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
                          semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
                          semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
                      }
                      // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
<span class="line-modified">!                     restoreSavePoint(savePoint);</span>
                      propagateError();
                      continue;
                  }
  
                  // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
<span class="line-new-header">--- 381,11 ---</span>
                              semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
                          semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
                          semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
                      }
                      // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
<span class="line-modified">!                     restoreSavePoint(context, savePoint);</span>
                      propagateError();
                      continue;
                  }
  
                  // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,21 ***</span>
      SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
  
      while (true) {
          TreeStatement statement = 0;
          switch (m_token.m_type) {
<span class="line-modified">!         case EXPORT:</span>
              statement = parseExportDeclaration(context);
              if (statement)
                  recordPauseLocation(context.breakpointLocation(statement));
              break;
  
          case IMPORT: {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
              if (isImportDeclaration) {
                  statement = parseImportDeclaration(context);
                  if (statement)
                      recordPauseLocation(context.breakpointLocation(statement));
                  break;
<span class="line-new-header">--- 412,21 ---</span>
      SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
  
      while (true) {
          TreeStatement statement = 0;
          switch (m_token.m_type) {
<span class="line-modified">!         case EXPORT_:</span>
              statement = parseExportDeclaration(context);
              if (statement)
                  recordPauseLocation(context.breakpointLocation(statement));
              break;
  
          case IMPORT: {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
              if (isImportDeclaration) {
                  statement = parseImportDeclaration(context);
                  if (statement)
                      recordPauseLocation(context.breakpointLocation(statement));
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,20 ***</span>
          shouldSetPauseLocation = true;
          break;
      case LET: {
          bool shouldParseVariableDeclaration = true;
          if (!strictMode()) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
              // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
              // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
              // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
              // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
              if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
                  shouldParseVariableDeclaration = false;
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
          }
          if (shouldParseVariableDeclaration)
              result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
          else {
              bool allowFunctionDeclarationAsStatement = true;
<span class="line-new-header">--- 666,20 ---</span>
          shouldSetPauseLocation = true;
          break;
      case LET: {
          bool shouldParseVariableDeclaration = true;
          if (!strictMode()) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
              // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
              // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
              // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
              // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
              if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
                  shouldParseVariableDeclaration = false;
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
          }
          if (shouldParseVariableDeclaration)
              result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
          else {
              bool allowFunctionDeclarationAsStatement = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 708,17 ***</span>
          break;
      case IDENT:
          if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
              // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
              // but could be mistakenly parsed as an AsyncFunctionExpression.
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
                  result = parseAsyncFunctionDeclaration(context);
                  break;
              }
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
          }
          FALLTHROUGH;
      case AWAIT:
      case YIELD: {
          // This is a convenient place to notice labeled statements
<span class="line-new-header">--- 696,17 ---</span>
          break;
      case IDENT:
          if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
              // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
              // but could be mistakenly parsed as an AsyncFunctionExpression.
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
                  result = parseAsyncFunctionDeclaration(context);
                  break;
              }
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
          }
          FALLTHROUGH;
      case AWAIT:
      case YIELD: {
          // This is a convenient place to notice labeled statements
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,11 ***</span>
  
      return true;
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)</span>
  {
      ASSERT(!name.isNull());
  
      ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
  
<span class="line-new-header">--- 925,11 ---</span>
  
      return true;
  }
  
  template &lt;typename LexerType&gt;
<span class="line-modified">! template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, const JSToken&amp; token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)</span>
  {
      ASSERT(!name.isNull());
  
      ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,15 ***</span>
  template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
  {
      TreeDestructuringPattern assignmentTarget = 0;
  
      if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">!         SavePoint savePoint = createSavePoint();</span>
          assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
          if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
              return assignmentTarget;
<span class="line-modified">!         restoreSavePoint(savePoint);</span>
      }
  
      JSTextPosition startPosition = tokenStartPosition();
      auto element = parseMemberExpression(context);
  
<span class="line-new-header">--- 1041,15 ---</span>
  template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
  {
      TreeDestructuringPattern assignmentTarget = 0;
  
      if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">!         SavePoint savePoint = createSavePoint(context);</span>
          assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
          if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
              return assignmentTarget;
<span class="line-modified">!         restoreSavePoint(context, savePoint);</span>
      }
  
      JSTextPosition startPosition = tokenStartPosition();
      auto element = parseMemberExpression(context);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1232,10 ***</span>
<span class="line-new-header">--- 1220,13 ---</span>
                      break;
                  case STRING:
                      propertyName = m_token.m_data.ident;
                      wasString = true;
                      break;
<span class="line-added">+                 case BIGINT:</span>
<span class="line-added">+                     propertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">+                     break;</span>
                  case OPENBRACKET:
                      next();
                      propertyExpression = parseAssignmentExpression(context);
                      failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
                      matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1442,18 ***</span>
          return result;
      }
  
      if (!match(SEMICOLON)) {
          if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              declsStart = tokenStartPosition();
              pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
              declsEnd = lastTokenEndPosition();
              if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
                  goto enumerationLoop;
              pattern = TreeDestructuringPattern(0);
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
          }
          m_allowsIn = false;
          declsStart = tokenStartPosition();
          decls = parseExpression(context);
          declsEnd = lastTokenEndPosition();
<span class="line-new-header">--- 1433,18 ---</span>
          return result;
      }
  
      if (!match(SEMICOLON)) {
          if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              declsStart = tokenStartPosition();
              pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
              declsEnd = lastTokenEndPosition();
              if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
                  goto enumerationLoop;
              pattern = TreeDestructuringPattern(0);
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
          }
          m_allowsIn = false;
          declsStart = tokenStartPosition();
          decls = parseExpression(context);
          declsEnd = lastTokenEndPosition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,18 ***</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
  {
      ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
<span class="line-modified">!     SavePoint savePoint = createSavePoint();</span>
      next();
      if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
          const bool isAsync = true;
          result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
          return true;
      }
<span class="line-modified">!     restoreSavePoint(savePoint);</span>
      return false;
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
<span class="line-new-header">--- 2029,18 ---</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
  {
      ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
<span class="line-modified">!     SavePoint savePoint = createSavePoint(context);</span>
      next();
      if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
          const bool isAsync = true;
          result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
          return true;
      }
<span class="line-modified">!     restoreSavePoint(context, savePoint);</span>
      return false;
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2110,10 ***</span>
<span class="line-new-header">--- 2101,11 ---</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
      TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
      ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
  {
<span class="line-added">+     SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, bodyType == StandardFunctionBodyBlock ? false : m_parserState.isParsingClassFieldInitializer);</span>
      bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
      if (!isArrowFunctionBodyExpression) {
          next();
          if (match(CLOSEBRACE)) {
              unsigned endColumn = tokenColumn();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2162,10 ***</span>
<span class="line-new-header">--- 2154,11 ---</span>
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
          return &quot;an &quot;;
      case SourceParseMode::ProgramMode:
      case SourceParseMode::ModuleAnalyzeMode:
      case SourceParseMode::ModuleEvaluateMode:
<span class="line-added">+     case SourceParseMode::InstanceFieldInitializerMode:</span>
          RELEASE_ASSERT_NOT_REACHED();
          return &quot;&quot;;
      }
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2203,10 ***</span>
<span class="line-new-header">--- 2196,11 ---</span>
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
          return &quot;async generator method&quot;;
      case SourceParseMode::ProgramMode:
      case SourceParseMode::ModuleAnalyzeMode:
      case SourceParseMode::ModuleEvaluateMode:
<span class="line-added">+     case SourceParseMode::InstanceFieldInitializerMode:</span>
          RELEASE_ASSERT_NOT_REACHED();
          return &quot;&quot;;
      }
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2428,11 ***</span>
  
          {
              // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
              // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
              Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
<span class="line-modified">!             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));</span>
              parseFunctionParameters(syntaxChecker, mode, functionInfo);
              propagateError();
          }
  
          matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
<span class="line-new-header">--- 2422,11 ---</span>
  
          {
              // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
              // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
              Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
<span class="line-modified">!             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !parentScope-&gt;isAsyncFunction() &amp;&amp; !isAsyncFunctionParseMode(mode));</span>
              parseFunctionParameters(syntaxChecker, mode, functionInfo);
              propagateError();
          }
  
          matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2516,23 ***</span>
              semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
  
          // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
          // Set ConstructorKind to None for non-constructor methods of classes.
  
<span class="line-modified">!         if (m_defaultConstructorKind != ConstructorKind::None) {</span>
<span class="line-modified">!             constructorKind = m_defaultConstructorKind;</span>
<span class="line-modified">!             expectedSuperBinding = m_defaultConstructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;</span>
          }
  
          functionBodyType = StandardFunctionBodyBlock;
      }
  
      functionScope-&gt;setConstructorKind(constructorKind);
      functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
  
      m_parserState.lastFunctionName = lastFunctionName;
<span class="line-modified">!     ParserState oldState = internalSaveParserState();</span>
  
      // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
      // This loop collects the set of capture candidates that aren&#39;t
      // part of the set of this function&#39;s declared parameters. We will
      // figure out which parameters are captured for this function when
<span class="line-new-header">--- 2510,23 ---</span>
              semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
  
          // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
          // Set ConstructorKind to None for non-constructor methods of classes.
  
<span class="line-modified">!         if (parentScope-&gt;isGlobalCodeScope() &amp;&amp; m_defaultConstructorKindForTopLevelFunction != ConstructorKind::None) {</span>
<span class="line-modified">!             constructorKind = m_defaultConstructorKindForTopLevelFunction;</span>
<span class="line-modified">!             expectedSuperBinding = m_defaultConstructorKindForTopLevelFunction == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;</span>
          }
  
          functionBodyType = StandardFunctionBodyBlock;
      }
  
      functionScope-&gt;setConstructorKind(constructorKind);
      functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
  
      m_parserState.lastFunctionName = lastFunctionName;
<span class="line-modified">!     ParserState oldState = internalSaveParserState(context);</span>
  
      // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
      // This loop collects the set of capture candidates that aren&#39;t
      // part of the set of this function&#39;s declared parameters. We will
      // figure out which parameters are captured for this function when
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2581,11 ***</span>
  
          popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
      } else
          functionInfo.body = performParsingFunctionBody();
  
<span class="line-modified">!     restoreParserState(oldState);</span>
      failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
      context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
      if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
          ASSERT(functionInfo.name);
          RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
<span class="line-new-header">--- 2575,11 ---</span>
  
          popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
      } else
          functionInfo.body = performParsingFunctionBody();
  
<span class="line-modified">!     restoreParserState(context, oldState);</span>
      failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
      context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
      if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
          ASSERT(functionInfo.name);
          RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2642,11 ***</span>
          // 2. which may not build strings for tokens.
          // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
          // So we only check TreeBuilder&#39;s type here.
          ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
          if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
<span class="line-modified">!             lexCurrentTokenAgainUnderCurrentContext();</span>
      }
  
      if (newInfo)
          m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
  
<span class="line-new-header">--- 2636,11 ---</span>
          // 2. which may not build strings for tokens.
          // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
          // So we only check TreeBuilder&#39;s type here.
          ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
          if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
<span class="line-modified">!             lexCurrentTokenAgainUnderCurrentContext(context);</span>
      }
  
      if (newInfo)
          m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2850,17 ***</span>
<span class="line-new-header">--- 2844,19 ---</span>
      TreeExpression parentClass = 0;
      if (consume(EXTENDS)) {
          parentClass = parseMemberExpression(context);
          failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
      }
<span class="line-added">+     classScope-&gt;setIsClassScope();</span>
      const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
  
      consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
  
      TreeExpression constructor = 0;
      TreePropertyList classElements = 0;
      TreePropertyList classElementsTail = 0;
<span class="line-added">+     unsigned numComputedFields = 0;</span>
      while (!match(CLOSEBRACE)) {
          if (match(SEMICOLON)) {
              next();
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2868,16 ***</span>
          JSTokenLocation methodLocation(tokenLocation());
          unsigned methodStart = tokenStart();
  
          // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
          ClassElementTag tag = ClassElementTag::Instance;
          if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              if (match(OPENPAREN)) {
                  // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
<span class="line-modified">!                 restoreSavePoint(savePoint);</span>
              } else
                  tag = ClassElementTag::Static;
          }
  
          // FIXME: Figure out a way to share more code with parseProperty.
<span class="line-new-header">--- 2864,17 ---</span>
          JSTokenLocation methodLocation(tokenLocation());
          unsigned methodStart = tokenStart();
  
          // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
          ClassElementTag tag = ClassElementTag::Instance;
<span class="line-added">+         auto type = PropertyNode::Constant;</span>
          if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              if (match(OPENPAREN)) {
                  // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
<span class="line-modified">!                 restoreSavePoint(context, savePoint);</span>
              } else
                  tag = ClassElementTag::Static;
          }
  
          // FIXME: Figure out a way to share more code with parseProperty.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2896,16 ***</span>
          case STRING:
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
              break;
          case IDENT:
              if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
                  if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
                      ident = m_token.m_data.ident;
                      next();
<span class="line-modified">!                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())</span>
                          break;
                      if (UNLIKELY(consume(TIMES)))
                          parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
                      else
                          parseMode = SourceParseMode::AsyncMethodMode;
<span class="line-new-header">--- 2893,22 ---</span>
          case STRING:
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
              break;
<span class="line-added">+         case BIGINT:</span>
<span class="line-added">+             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">+             ASSERT(ident);</span>
<span class="line-added">+             next();</span>
<span class="line-added">+             break;</span>
          case IDENT:
              if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
                  if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
                      ident = m_token.m_data.ident;
                      next();
<span class="line-modified">!                     // We match SEMICOLON as a special case for a field called &#39;async&#39; without initializer.</span>
<span class="line-added">+                     if (match(OPENPAREN) || match(COLON) || match(SEMICOLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())</span>
                          break;
                      if (UNLIKELY(consume(TIMES)))
                          parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
                      else
                          parseMode = SourceParseMode::AsyncMethodMode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2915,11 ***</span>
              FALLTHROUGH;
          case AWAIT:
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
<span class="line-modified">!             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {</span>
                  isGetter = *ident == propertyNames.get;
                  isSetter = *ident == propertyNames.set;
              }
              break;
          case DOUBLE:
<span class="line-new-header">--- 2918,11 ---</span>
              FALLTHROUGH;
          case AWAIT:
              ident = m_token.m_data.ident;
              ASSERT(ident);
              next();
<span class="line-modified">!             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(BIGINT) || match(OPENBRACKET))) {</span>
                  isGetter = *ident == propertyNames.get;
                  isSetter = *ident == propertyNames.set;
              }
              break;
          case DOUBLE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2929,10 ***</span>
<span class="line-new-header">--- 2932,11 ---</span>
              next();
              break;
          case OPENBRACKET:
              next();
              computedPropertyName = parseAssignmentExpression(context);
<span class="line-added">+             type = static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed);</span>
              failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
              handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
              break;
          default:
              if (m_token.m_type &amp; KeywordTokenFlag)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2941,13 ***</span>
          }
  
          TreeProperty property;
          const bool alwaysStrictInsideClass = true;
          if (isGetter || isSetter) {
<span class="line-modified">!             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,</span>
<span class="line-modified">!                 methodStart, ConstructorKind::None, tag);</span>
              failIfFalse(property, &quot;Cannot parse this method&quot;);
          } else {
              ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
              bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
              if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
                  isConstructor = false;
<span class="line-new-header">--- 2945,42 ---</span>
          }
  
          TreeProperty property;
          const bool alwaysStrictInsideClass = true;
          if (isGetter || isSetter) {
<span class="line-modified">!             type = static_cast&lt;PropertyNode::Type&gt;(type &amp; ~PropertyNode::Constant);</span>
<span class="line-modified">!             type = static_cast&lt;PropertyNode::Type&gt;(type | (isGetter ? PropertyNode::Getter : PropertyNode::Setter));</span>
<span class="line-added">+             property = parseGetterSetter(context, alwaysStrictInsideClass, type, methodStart, ConstructorKind::None, tag);</span>
              failIfFalse(property, &quot;Cannot parse this method&quot;);
<span class="line-added">+         } else if (Options::useClassFields() &amp;&amp; !match(OPENPAREN) &amp;&amp; tag == ClassElementTag::Instance &amp;&amp; parseMode == SourceParseMode::MethodMode) {</span>
<span class="line-added">+             ASSERT(!isGetter &amp;&amp; !isSetter);</span>
<span class="line-added">+             if (ident)</span>
<span class="line-added">+                 semanticFailIfTrue(*ident == propertyNames.constructor, &quot;Cannot declare class field named &#39;constructor&#39;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (computedPropertyName) {</span>
<span class="line-added">+                 ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);</span>
<span class="line-added">+                 DeclarationResultMask declarationResult = classScope-&gt;declareLexicalVariable(ident, true);</span>
<span class="line-added">+                 ASSERT_UNUSED(declarationResult, declarationResult == DeclarationResult::Valid);</span>
<span class="line-added">+                 classScope-&gt;useVariable(ident, false);</span>
<span class="line-added">+                 classScope-&gt;addClosedVariableCandidateUnconditionally(ident-&gt;impl());</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             TreeExpression initializer = 0;</span>
<span class="line-added">+             if (consume(EQUAL)) {</span>
<span class="line-added">+                 SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, true);</span>
<span class="line-added">+                 classScope-&gt;setExpectedSuperBinding(SuperBinding::Needed);</span>
<span class="line-added">+                 initializer = parseAssignmentExpression(context);</span>
<span class="line-added">+                 classScope-&gt;setExpectedSuperBinding(SuperBinding::NotNeeded);</span>
<span class="line-added">+                 failIfFalse(initializer, &quot;Cannot parse initializer for class field&quot;);</span>
<span class="line-added">+                 classScope-&gt;markLastUsedVariablesSetAsCaptured();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a class field&quot;);</span>
<span class="line-added">+             auto inferName = initializer ? InferName::Allowed : InferName::Disallowed;</span>
<span class="line-added">+             if (computedPropertyName)</span>
<span class="line-added">+                 property = context.createProperty(ident, computedPropertyName, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, tag);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 property = context.createProperty(ident, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, inferName, tag);</span>
          } else {
              ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
              bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
              if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
                  isConstructor = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2968,15 ***</span>
              // FIXME: Syntax error when super() is called
              semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
                  &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
  
              if (computedPropertyName) {
<span class="line-modified">!                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),</span>
<span class="line-removed">-                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);</span>
              } else {
<span class="line-modified">!                 property = context.createProperty(methodInfo.name, method, PropertyNode::Constant,</span>
<span class="line-removed">-                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);</span>
              }
          }
  
          if (classElementsTail)
              classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
<span class="line-new-header">--- 3001,13 ---</span>
              // FIXME: Syntax error when super() is called
              semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
                  &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
  
              if (computedPropertyName) {
<span class="line-modified">!                 property = context.createProperty(computedPropertyName, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);</span>
              } else {
<span class="line-modified">!                 property = context.createProperty(methodInfo.name, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);</span>
              }
          }
  
          if (classElementsTail)
              classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2990,10 ***</span>
<span class="line-new-header">--- 3021,77 ---</span>
      auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
      popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
      return classExpression;
  }
  
<span class="line-added">+ template &lt;typename LexerType&gt;</span>
<span class="line-added">+ template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseInstanceFieldInitializerSourceElements(TreeBuilder&amp; context, const Vector&lt;JSTextPosition&gt;&amp; instanceFieldLocations)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     TreeSourceElements sourceElements = context.createSourceElements();</span>
<span class="line-added">+     currentScope()-&gt;setIsClassScope();</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned numComputedFields = 0;</span>
<span class="line-added">+     for (auto location : instanceFieldLocations) {</span>
<span class="line-added">+         // We don&#39;t need to worry about hasLineTerminatorBeforeToken</span>
<span class="line-added">+         // on class fields, so we set this value to false.</span>
<span class="line-added">+         LexerState lexerState { location.offset, static_cast&lt;unsigned&gt;(location.lineStartOffset), static_cast&lt;unsigned&gt;(location.line), static_cast&lt;unsigned&gt;(location.line), false };</span>
<span class="line-added">+         restoreLexerState(lexerState);</span>
<span class="line-added">+ </span>
<span class="line-added">+         JSTokenLocation fieldLocation = tokenLocation();</span>
<span class="line-added">+         const Identifier* ident = nullptr;</span>
<span class="line-added">+         TreeExpression computedPropertyName = 0;</span>
<span class="line-added">+         DefineFieldNode::Type type = DefineFieldNode::Type::Name;</span>
<span class="line-added">+         switch (m_token.m_type) {</span>
<span class="line-added">+         case STRING:</span>
<span class="line-added">+         case IDENT:</span>
<span class="line-added">+         namedKeyword:</span>
<span class="line-added">+             ident = m_token.m_data.ident;</span>
<span class="line-added">+             ASSERT(ident);</span>
<span class="line-added">+             next();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case BIGINT:</span>
<span class="line-added">+             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">+             ASSERT(ident);</span>
<span class="line-added">+             next();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DOUBLE:</span>
<span class="line-added">+         case INTEGER:</span>
<span class="line-added">+             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
<span class="line-added">+             ASSERT(ident);</span>
<span class="line-added">+             next();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case OPENBRACKET:</span>
<span class="line-added">+             next();</span>
<span class="line-added">+             computedPropertyName = parseAssignmentExpression(context);</span>
<span class="line-added">+             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);</span>
<span class="line-added">+             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);</span>
<span class="line-added">+             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);</span>
<span class="line-added">+             type = DefineFieldNode::Type::ComputedName;</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             if (m_token.m_type &amp; KeywordTokenFlag)</span>
<span class="line-added">+                 goto namedKeyword;</span>
<span class="line-added">+             failDueToUnexpectedToken();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Only valid class fields are handled in this function.</span>
<span class="line-added">+         ASSERT(match(EQUAL) || match(SEMICOLON) || match(CLOSEBRACE) || m_lexer-&gt;hasLineTerminatorBeforeToken());</span>
<span class="line-added">+ </span>
<span class="line-added">+         TreeExpression initializer = 0;</span>
<span class="line-added">+         if (consume(EQUAL))</span>
<span class="line-added">+             initializer = parseAssignmentExpression(context);</span>
<span class="line-added">+ </span>
<span class="line-added">+         TreeStatement defineField = context.createDefineField(fieldLocation, ident, initializer, type);</span>
<span class="line-added">+         context.appendStatement(sourceElements, defineField);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!hasError());</span>
<span class="line-added">+     // Trick parseInner() into believing we&#39;ve parsed the entire SourceCode, in order to prevent it from producing an error.</span>
<span class="line-added">+     m_token.m_type = EOFTOK;</span>
<span class="line-added">+     return sourceElements;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  struct LabelInfo {
      LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
      : m_ident(ident)
      , m_start(start)
      , m_end(end)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3377,11 ***</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
  {
      // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
<span class="line-modified">!     ASSERT(match(EXPORT));</span>
      JSTokenLocation exportLocation(tokenLocation());
      next();
  
      switch (m_token.m_type) {
      case TIMES: {
<span class="line-new-header">--- 3475,11 ---</span>
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
  {
      // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
<span class="line-modified">!     ASSERT(match(EXPORT_));</span>
      JSTokenLocation exportLocation(tokenLocation());
      next();
  
      switch (m_token.m_type) {
      case TIMES: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3408,30 ***</span>
          bool isFunctionOrClassDeclaration = false;
          const Identifier* localName = nullptr;
  
          bool startsWithFunction = match(FUNCTION);
          if (startsWithFunction || match(CLASSTOKEN)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              isFunctionOrClassDeclaration = true;
              next();
  
              // ES6 Generators
              if (startsWithFunction &amp;&amp; match(TIMES))
                  next();
              if (match(IDENT))
                  localName = m_token.m_data.ident;
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
          } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
                  next();
                  if (match(IDENT))
                      localName = m_token.m_data.ident;
                  isFunctionOrClassDeclaration = true;
              }
<span class="line-modified">!             restoreSavePoint(savePoint);</span>
          }
  
          if (!localName)
              localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
  
<span class="line-new-header">--- 3506,30 ---</span>
          bool isFunctionOrClassDeclaration = false;
          const Identifier* localName = nullptr;
  
          bool startsWithFunction = match(FUNCTION);
          if (startsWithFunction || match(CLASSTOKEN)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              isFunctionOrClassDeclaration = true;
              next();
  
              // ES6 Generators
              if (startsWithFunction &amp;&amp; match(TIMES))
                  next();
              if (match(IDENT))
                  localName = m_token.m_data.ident;
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
          } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
                  next();
                  if (match(IDENT))
                      localName = m_token.m_data.ident;
                  isFunctionOrClassDeclaration = true;
              }
<span class="line-modified">!             restoreSavePoint(context, savePoint);</span>
          }
  
          if (!localName)
              localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3673,11 ***</span>
      bool wasOpenParen = match(OPENPAREN);
      // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
      // Whether spec identifier is will be validated by isArrowFunctionParameters().
      bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
      bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
<span class="line-modified">!     SavePoint savePoint = createSavePoint();</span>
      size_t usedVariablesSize = 0;
  
      if (wasOpenParen) {
          usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
          currentScope()-&gt;pushUsedVariableSet();
<span class="line-new-header">--- 3771,11 ---</span>
      bool wasOpenParen = match(OPENPAREN);
      // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
      // Whether spec identifier is will be validated by isArrowFunctionParameters().
      bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
      bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
<span class="line-modified">!     SavePoint savePoint = createSavePoint(context);</span>
      size_t usedVariablesSize = 0;
  
      if (wasOpenParen) {
          usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
          currentScope()-&gt;pushUsedVariableSet();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3686,41 ***</span>
      TreeExpression lhs = parseConditionalExpression(context);
  
      if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
          bool isArrowFunctionToken = match(ARROWFUNCTION);
          if (!lhs || isArrowFunctionToken) {
<span class="line-modified">!             SavePointWithError errorRestorationSavePoint = createSavePointForError();</span>
<span class="line-removed">-             restoreSavePoint(savePoint);</span>
              bool isAsyncArrow = false;
              if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
                  if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
                      next();
                      isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
                  }
              }
<span class="line-modified">!             if (isArrowFunctionParameters()) {</span>
                  if (wasOpenParen)
                      currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
                  return parseArrowFunctionExpression(context, isAsyncArrow);
              }
              if (isArrowFunctionToken)
                  propagateError();
<span class="line-modified">!             restoreSavePointWithError(errorRestorationSavePoint);</span>
              if (isArrowFunctionToken)
                  failDueToUnexpectedToken();
          }
      }
  
      if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
          propagateError();
  
      if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
<span class="line-modified">!         SavePointWithError expressionErrorLocation = createSavePointForError();</span>
<span class="line-removed">-         restoreSavePoint(savePoint);</span>
          auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
          if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
<span class="line-modified">!             restoreSavePointWithError(expressionErrorLocation);</span>
              return 0;
          }
          failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
          consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
          auto rhs = parseAssignmentExpression(context);
<span class="line-new-header">--- 3784,39 ---</span>
      TreeExpression lhs = parseConditionalExpression(context);
  
      if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
          bool isArrowFunctionToken = match(ARROWFUNCTION);
          if (!lhs || isArrowFunctionToken) {
<span class="line-modified">!             SavePointWithError errorRestorationSavePoint = swapSavePointForError(context, savePoint);</span>
              bool isAsyncArrow = false;
              if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
                  if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
                      next();
                      isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
                  }
              }
<span class="line-modified">!             if (isArrowFunctionParameters(context)) {</span>
                  if (wasOpenParen)
                      currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
                  return parseArrowFunctionExpression(context, isAsyncArrow);
              }
              if (isArrowFunctionToken)
                  propagateError();
<span class="line-modified">!             restoreSavePointWithError(context, errorRestorationSavePoint);</span>
              if (isArrowFunctionToken)
                  failDueToUnexpectedToken();
          }
      }
  
      if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
          propagateError();
  
      if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
<span class="line-modified">!         SavePointWithError expressionErrorLocation = swapSavePointForError(context, savePoint);</span>
          auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
          if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
<span class="line-modified">!             restoreSavePointWithError(context, expressionErrorLocation);</span>
              return 0;
          }
          failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
          consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
          auto rhs = parseAssignmentExpression(context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3781,13 ***</span>
      }
  end:
      if (hadAssignment)
          m_parserState.nonLHSCount++;
  
<span class="line-removed">-     if (!TreeBuilder::CreatesAST)</span>
<span class="line-removed">-         return lhs;</span>
<span class="line-removed">- </span>
      while (assignmentStack)
          lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
  
      return lhs;
  }
<span class="line-new-header">--- 3877,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3807,20 ***</span>
      failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
  
      JSTokenLocation location(tokenLocation());
      JSTextPosition divotStart = tokenStartPosition();
      ASSERT(match(YIELD));
<span class="line-modified">!     SavePoint savePoint = createSavePoint();</span>
      next();
      if (m_lexer-&gt;hasLineTerminatorBeforeToken())
          return context.createYield(location);
  
      bool delegate = consume(TIMES);
      JSTextPosition argumentStart = tokenStartPosition();
      TreeExpression argument = parseAssignmentExpression(context);
      if (!argument) {
<span class="line-modified">!         restoreSavePoint(savePoint);</span>
          next();
          return context.createYield(location);
      }
      return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
  }
<span class="line-new-header">--- 3900,20 ---</span>
      failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
  
      JSTokenLocation location(tokenLocation());
      JSTextPosition divotStart = tokenStartPosition();
      ASSERT(match(YIELD));
<span class="line-modified">!     SavePoint savePoint = createSavePoint(context);</span>
      next();
      if (m_lexer-&gt;hasLineTerminatorBeforeToken())
          return context.createYield(location);
  
      bool delegate = consume(TIMES);
      JSTextPosition argumentStart = tokenStartPosition();
      TreeExpression argument = parseAssignmentExpression(context);
      if (!argument) {
<span class="line-modified">!         restoreSavePoint(context, savePoint);</span>
          next();
          return context.createYield(location);
      }
      return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3828,11 ***</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
  {
      ASSERT(match(AWAIT));
      ASSERT(currentScope()-&gt;isAsyncFunction());
<span class="line-modified">!     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use await expression within parameters&quot;);</span>
      JSTokenLocation location(tokenLocation());
      JSTextPosition divotStart = tokenStartPosition();
      next();
      JSTextPosition argumentStart = tokenStartPosition();
      ExpressionErrorClassifier classifier(this);
<span class="line-new-header">--- 3921,11 ---</span>
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
  {
      ASSERT(match(AWAIT));
      ASSERT(currentScope()-&gt;isAsyncFunction());
<span class="line-modified">!     ASSERT(m_parserState.functionParsePhase != FunctionParsePhase::Parameters);</span>
      JSTokenLocation location(tokenLocation());
      JSTextPosition divotStart = tokenStartPosition();
      next();
      JSTextPosition argumentStart = tokenStartPosition();
      ExpressionErrorClassifier classifier(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3971,15 ***</span>
  parseProperty:
      switch (m_token.m_type) {
      case IDENT:
          if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
              if (parseMode == SourceParseMode::MethodMode) {
<span class="line-modified">!                 SavePoint savePoint = createSavePoint();</span>
                  next();
  
                  if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
<span class="line-modified">!                     restoreSavePoint(savePoint);</span>
                      wasIdent = true;
                      goto namedProperty;
                  }
  
                  failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
<span class="line-new-header">--- 4064,15 ---</span>
  parseProperty:
      switch (m_token.m_type) {
      case IDENT:
          if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
              if (parseMode == SourceParseMode::MethodMode) {
<span class="line-modified">!                 SavePoint savePoint = createSavePoint(context);</span>
                  next();
  
                  if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
<span class="line-modified">!                     restoreSavePoint(context, savePoint);</span>
                      wasIdent = true;
                      goto namedProperty;
                  }
  
                  failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4000,13 ***</span>
          const Identifier* ident = m_token.m_data.ident;
          unsigned getterOrSetterStartOffset = tokenStart();
          JSToken identToken = m_token;
  
          if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
<span class="line-modified">!             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);</span>
          else
<span class="line-modified">!             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
  
          if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
              next();
              TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
              failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
<span class="line-new-header">--- 4093,13 ---</span>
          const Identifier* ident = m_token.m_data.ident;
          unsigned getterOrSetterStartOffset = tokenStart();
          JSToken identToken = m_token;
  
          if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
<span class="line-modified">!             nextExpectIdentifier(LexerFlags::IgnoreReservedWords);</span>
          else
<span class="line-modified">!             nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);</span>
  
          if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
              next();
              TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
              failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4064,10 ***</span>
<span class="line-new-header">--- 4157,27 ---</span>
          TreeExpression node = parseAssignmentExpression(context);
          failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
          context.setEndOffset(node, m_lexer-&gt;currentOffset());
          return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
      }
<span class="line-added">+     case BIGINT: {</span>
<span class="line-added">+         const Identifier* ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">+         next();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (match(OPENPAREN)) {</span>
<span class="line-added">+             auto method = parsePropertyMethod(context, ident, parseMode);</span>
<span class="line-added">+             propagateError();</span>
<span class="line-added">+             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);</span>
<span class="line-added">+         TreeExpression node = parseAssignmentExpression(context);</span>
<span class="line-added">+         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);</span>
<span class="line-added">+         context.setEndOffset(node, m_lexer-&gt;currentOffset());</span>
<span class="line-added">+         return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);</span>
<span class="line-added">+     }</span>
      case OPENBRACKET: {
          next();
          auto propertyName = parseAssignmentExpression(context);
          failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
          handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4132,10 ***</span>
<span class="line-new-header">--- 4242,13 ---</span>
              &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
          next();
      } else if (match(DOUBLE) || match(INTEGER)) {
          numericPropertyName = m_token.m_data.doubleValue;
          next();
<span class="line-added">+     } else if (match(BIGINT)) {</span>
<span class="line-added">+         stringPropertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">+         next();</span>
      } else if (match(OPENBRACKET)) {
          next();
          computedPropertyName = parseAssignmentExpression(context);
          failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
          handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4200,66 ***</span>
      m_debuggerParseData-&gt;pausePositions.appendLeave(position);
  }
  
  template &lt;typename LexerType&gt;
  template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
<span class="line-removed">- {</span>
<span class="line-removed">-     SavePoint savePoint = createSavePoint();</span>
<span class="line-removed">-     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int oldNonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSTokenLocation location(tokenLocation());</span>
<span class="line-removed">-     if (match(CLOSEBRACE)) {</span>
<span class="line-removed">-         next();</span>
<span class="line-removed">-         return context.createObjectLiteral(location);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     TreeProperty property = parseProperty(context, false);</span>
<span class="line-removed">-     failIfFalse(property, &quot;Cannot parse object literal property&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {</span>
<span class="line-removed">-         restoreSavePoint(savePoint);</span>
<span class="line-removed">-         return parseStrictObjectLiteral(context);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool seenUnderscoreProto = false;</span>
<span class="line-removed">-     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))</span>
<span class="line-removed">-         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     TreePropertyList propertyList = context.createPropertyList(location, property);</span>
<span class="line-removed">-     TreePropertyList tail = propertyList;</span>
<span class="line-removed">-     while (match(COMMA)) {</span>
<span class="line-removed">-         next(TreeBuilder::DontBuildStrings);</span>
<span class="line-removed">-         if (match(CLOSEBRACE))</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         JSTokenLocation propertyLocation(tokenLocation());</span>
<span class="line-removed">-         property = parseProperty(context, false);</span>
<span class="line-removed">-         failIfFalse(property, &quot;Cannot parse object literal property&quot;);</span>
<span class="line-removed">-         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {</span>
<span class="line-removed">-             restoreSavePoint(savePoint);</span>
<span class="line-removed">-             return parseStrictObjectLiteral(context);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {</span>
<span class="line-removed">-             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
<span class="line-removed">-                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);</span>
<span class="line-removed">-                 seenUnderscoreProto = true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         tail = context.createPropertyList(propertyLocation, property, tail);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     location = tokenLocation();</span>
<span class="line-removed">-     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_parserState.nonLHSCount = oldNonLHSCount;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return context.createObjectLiteral(location, propertyList);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- template &lt;typename LexerType&gt;</span>
<span class="line-removed">- template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)</span>
  {
      consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
  
      int oldNonLHSCount = m_parserState.nonLHSCount;
  
<span class="line-new-header">--- 4313,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4496,12 ***</span>
      case FUNCTION:
          return parseFunctionExpression(context);
      case CLASSTOKEN:
          return parseClassExpression(context);
      case OPENBRACE:
<span class="line-removed">-         if (strictMode())</span>
<span class="line-removed">-             return parseStrictObjectLiteral(context);</span>
          return parseObjectLiteral(context);
      case OPENBRACKET:
          return parseArrayLiteral(context);
      case OPENPAREN: {
          next();
<span class="line-new-header">--- 4553,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4518,11 ***</span>
              currentScope()-&gt;setInnerArrowFunctionUsesThis();
          return context.createThisExpr(location);
      }
      case AWAIT:
          if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
<span class="line-modified">!             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);</span>
          else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
              return parseAwaitExpression(context);
  
          goto identifierExpression;
      case IDENT: {
<span class="line-new-header">--- 4573,11 ---</span>
              currentScope()-&gt;setInnerArrowFunctionUsesThis();
          return context.createThisExpr(location);
      }
      case AWAIT:
          if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
<span class="line-modified">!             semanticFailIfFalse(m_parserState.allowAwait, &quot;Cannot use &#39;await&#39; within a parameter default expression&quot;);</span>
          else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
              return parseAwaitExpression(context);
  
          goto identifierExpression;
      case IDENT: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4539,13 ***</span>
<span class="line-new-header">--- 4594,17 ---</span>
                  return 0;
  
              const bool isEval = false;
              return createResolveAndUseVariable(context, ident, isEval, start, location);
          }
<span class="line-added">+         if (UNLIKELY(m_parserState.isParsingClassFieldInitializer))</span>
<span class="line-added">+             failIfTrue(*m_token.m_data.ident == m_vm.propertyNames-&gt;arguments, &quot;Cannot reference &#39;arguments&#39; in class field initializer&quot;);</span>
      identifierExpression:
          JSTextPosition start = tokenStartPosition();
          const Identifier* ident = m_token.m_data.ident;
<span class="line-added">+         if (UNLIKELY(currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext))</span>
<span class="line-added">+             failIfTrue(*ident == m_vm.propertyNames-&gt;arguments, &quot;arguments is not valid in this context&quot;);</span>
          JSTokenLocation location(tokenLocation());
          next();
  
          // Avoid using variable if it is an arrow function parameter
          if (UNLIKELY(match(ARROWFUNCTION)))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4736,14 ***</span>
      bool baseIsNewTarget = false;
      if (newCount &amp;&amp; match(DOT)) {
          next();
          if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
              ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">!             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);</span>
              baseIsNewTarget = true;
              if (currentScope()-&gt;isArrowFunction()) {
<span class="line-modified">!                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);</span>
                  currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
              }
              ASSERT(lastNewTokenLocation.line);
              base = context.createNewTargetExpr(lastNewTokenLocation);
              newCount--;
<span class="line-new-header">--- 4795,17 ---</span>
      bool baseIsNewTarget = false;
      if (newCount &amp;&amp; match(DOT)) {
          next();
          if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
              ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">!             ScopeRef classScope = closestClassScopeOrTopLevelScope();</span>
<span class="line-added">+             bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();</span>
<span class="line-added">+             bool isFunctionEvalContextType = closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext;</span>
<span class="line-added">+             semanticFailIfFalse(currentScope()-&gt;isFunction() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is only valid inside functions&quot;);</span>
              baseIsNewTarget = true;
              if (currentScope()-&gt;isArrowFunction()) {
<span class="line-modified">!                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is not valid inside arrow functions in global code&quot;);</span>
                  currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
              }
              ASSERT(lastNewTokenLocation.line);
              base = context.createNewTargetExpr(lastNewTokenLocation);
              newCount--;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4756,23 ***</span>
  
      bool baseIsAsyncKeyword = false;
  
      if (baseIsSuper) {
          ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">!         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);</span>
          base = context.createSuperExpr(location);
          next();
          ScopeRef functionScope = currentFunctionScope();
          if (!functionScope-&gt;setNeedsSuperBinding()) {
              // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
              // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
              // inside of the constructor or method.
              if (!m_lexer-&gt;isReparsingFunction()) {
                  SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
                      ? functionScope-&gt;expectedSuperBinding()
                      : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
<span class="line-modified">!                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);</span>
              }
          }
      } else if (baseIsImport) {
          next();
          JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-new-header">--- 4818,26 ---</span>
  
      bool baseIsAsyncKeyword = false;
  
      if (baseIsSuper) {
          ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">!         ScopeRef classScope = closestClassScopeOrTopLevelScope();</span>
<span class="line-added">+         bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();</span>
<span class="line-added">+         semanticFailIfFalse(currentScope()-&gt;isFunction() || isClassFieldInitializer || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);</span>
          base = context.createSuperExpr(location);
          next();
<span class="line-added">+         failIfTrue(match(OPENPAREN) &amp;&amp; currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext, &quot;super call is not valid in this context&quot;);</span>
          ScopeRef functionScope = currentFunctionScope();
          if (!functionScope-&gt;setNeedsSuperBinding()) {
              // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
              // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
              // inside of the constructor or method.
              if (!m_lexer-&gt;isReparsingFunction()) {
                  SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
                      ? functionScope-&gt;expectedSuperBinding()
                      : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
<span class="line-modified">!                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded &amp;&amp; !isClassFieldInitializer, &quot;super is not valid in this context&quot;);</span>
              }
          }
      } else if (baseIsImport) {
          next();
          JSTextPosition expressionEnd = lastTokenEndPosition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4818,17 ***</span>
              semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
              semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
              optionalChainBase = base;
              optionalChainLocation = tokenLocation();
  
<span class="line-modified">!             SavePoint savePoint = createSavePoint();</span>
              next();
              if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
                  type = m_token.m_type;
              else {
                  type = DOT;
<span class="line-modified">!                 restoreSavePoint(savePoint);</span>
              }
          }
  
          while (true) {
              location = tokenLocation();
<span class="line-new-header">--- 4883,17 ---</span>
              semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
              semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
              optionalChainBase = base;
              optionalChainLocation = tokenLocation();
  
<span class="line-modified">!             SavePoint savePoint = createSavePoint(context);</span>
              next();
              if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
                  type = m_token.m_type;
              else {
                  type = DOT;
<span class="line-modified">!                 restoreSavePoint(context, savePoint);</span>
              }
          }
  
          while (true) {
              location = tokenLocation();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4849,10 ***</span>
<span class="line-new-header">--- 4914,12 ---</span>
                  handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);
                  m_parserState.nonLHSCount = nonLHSCount;
                  break;
              }
              case OPENPAREN: {
<span class="line-added">+                 if (baseIsSuper)</span>
<span class="line-added">+                     failIfTrue(m_parserState.isParsingClassFieldInitializer, &quot;super call is not valid in class field initializer context&quot;);</span>
                  m_parserState.nonTrivialExpressionCount++;
                  int nonLHSCount = m_parserState.nonLHSCount;
                  if (newCount) {
                      newCount--;
                      JSTextPosition expressionEnd = lastTokenEndPosition();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4904,11 ***</span>
                  break;
              }
              case DOT: {
                  m_parserState.nonTrivialExpressionCount++;
                  JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">!                 nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
                  matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
                  base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
                  if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
                      currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
                  next();
<span class="line-new-header">--- 4971,11 ---</span>
                  break;
              }
              case DOT: {
                  m_parserState.nonTrivialExpressionCount++;
                  JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">!                 nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);</span>
                  matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
                  base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
                  if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
                      currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
                  next();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5002,23 ***</span>
      if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
          return parseAwaitExpression(context);
  
      JSTokenLocation location(tokenLocation());
  
      while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">!         switch (m_token.m_type) {</span>
<span class="line-modified">!         case PLUSPLUS:</span>
<span class="line-removed">-         case MINUSMINUS:</span>
<span class="line-removed">-         case AUTOPLUSPLUS:</span>
<span class="line-removed">-         case AUTOMINUSMINUS:</span>
<span class="line-removed">-             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
              hasPrefixUpdateOp = true;
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
          lastOperator = m_token.m_type;
          m_parserState.nonLHSCount++;
          context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
          next();
          m_parserState.nonTrivialExpressionCount++;
<span class="line-new-header">--- 5069,19 ---</span>
      if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
          return parseAwaitExpression(context);
  
      JSTokenLocation location(tokenLocation());
  
<span class="line-added">+     int oldTokenStackDepth = context.unaryTokenStackDepth();</span>
<span class="line-added">+     makeScopeExit([&amp;] {</span>
<span class="line-added">+         ASSERT_UNUSED(oldTokenStackDepth, oldTokenStackDepth &lt;= context.unaryTokenStackDepth());</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
      while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">!         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">!         if (isUpdateOp(m_token.m_type))</span>
              hasPrefixUpdateOp = true;
          lastOperator = m_token.m_type;
          m_parserState.nonLHSCount++;
          context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
          next();
          m_parserState.nonTrivialExpressionCount++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5029,10 ***</span>
<span class="line-new-header">--- 5092,12 ---</span>
      if (!expr) {
          if (lastOperator)
              failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
          failWithMessage(&quot;Cannot parse member expression&quot;);
      }
<span class="line-added">+     if constexpr (std::is_same_v&lt;TreeBuilder, ASTBuilder&gt;)</span>
<span class="line-added">+         ASSERT(oldTokenStackDepth + tokenStackDepth == context.unaryTokenStackDepth());</span>
      if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {
          semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);
          semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);
      }
      bool isEvalOrArguments = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5068,11 ***</span>
          break;
      }
  
      JSTextPosition end = lastTokenEndPosition();
      while (tokenStackDepth) {
<span class="line-modified">!         switch (context.unaryTokenStackLastType(tokenStackDepth)) {</span>
          case EXCLAMATION:
              expr = context.createLogicalNot(location, expr);
              break;
          case TILDE:
              expr = context.makeBitwiseNotNode(location, expr);
<span class="line-new-header">--- 5133,13 ---</span>
          break;
      }
  
      JSTextPosition end = lastTokenEndPosition();
      while (tokenStackDepth) {
<span class="line-modified">!         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);</span>
<span class="line-added">+         auto tokenType = context.unaryTokenStackLastType(tokenStackDepth);</span>
<span class="line-added">+         switch (tokenType) {</span>
          case EXCLAMATION:
              expr = context.createLogicalNot(location, expr);
              break;
          case TILDE:
              expr = context.makeBitwiseNotNode(location, expr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5083,16 ***</span>
          case PLUS:
              expr = context.createUnaryPlus(location, expr);
              break;
          case PLUSPLUS:
          case AUTOPLUSPLUS:
<span class="line-modified">!             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);</span>
              m_parserState.assignmentCount++;
              break;
          case MINUSMINUS:
          case AUTOMINUSMINUS:
<span class="line-modified">!             expr = context.makePrefixNode(location, expr, OpMinusMinus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);</span>
              m_parserState.assignmentCount++;
              break;
          case TYPEOF:
              expr = context.makeTypeOfNode(location, expr);
              break;
<span class="line-new-header">--- 5150,18 ---</span>
          case PLUS:
              expr = context.createUnaryPlus(location, expr);
              break;
          case PLUSPLUS:
          case AUTOPLUSPLUS:
<span class="line-modified">!             ASSERT(isSimpleAssignmentTarget(context, expr));</span>
<span class="line-added">+             expr = context.makePrefixNode(location, expr, OpPlusPlus, subExprStart, subExprStart + 2, end);</span>
              m_parserState.assignmentCount++;
              break;
          case MINUSMINUS:
          case AUTOMINUSMINUS:
<span class="line-modified">!             ASSERT(isSimpleAssignmentTarget(context, expr));</span>
<span class="line-added">+             expr = context.makePrefixNode(location, expr, OpMinusMinus, subExprStart, subExprStart + 2, end);</span>
              m_parserState.assignmentCount++;
              break;
          case TYPEOF:
              expr = context.makeTypeOfNode(location, expr);
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5105,11 ***</span>
              break;
          default:
              // If we get here something has gone horribly horribly wrong
              CRASH();
          }
<span class="line-removed">-         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);</span>
          context.unaryTokenStackRemoveLast(tokenStackDepth);
      }
      return expr;
  }
  
<span class="line-new-header">--- 5174,10 ---</span>
</pre>
<center><a href="Nodes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp
@@ -58,10 +58,16 @@
 
 namespace WebCore {
 using namespace JSC;
 namespace IDBServer {
 
+constexpr auto objectStoreInfoTableName = "ObjectStoreInfo"_s;
+constexpr auto objectStoreInfoTableNameAlternate = "\"ObjectStoreInfo\""_s;
+constexpr auto v2ObjectStoreInfoSchema = "CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)"_s;
+constexpr auto v1IndexRecordsRecordIndexSchema = "CREATE INDEX IndexRecordsRecordIndex ON IndexRecords (objectStoreID, objectStoreRecordID)"_s;
+constexpr auto IndexRecordsIndexSchema = "CREATE INDEX IndexRecordsIndex ON IndexRecords (indexID, key, value)"_s;
+
 // Current version of the metadata schema being used in the metadata database.
 static const int currentMetadataVersion = 1;
 
 // The IndexedDatabase spec defines the max key generator value as 2^53.
 static const uint64_t maxGeneratorValue = 0x20000000000000;
@@ -187,16 +193,10 @@
 {
     static NeverDestroyed<WTF::String> indexRecordsTableSchemaString = v3IndexRecordsTableSchema("\"IndexRecords\"");
     return indexRecordsTableSchemaString;
 }
 
-static const String& v1IndexRecordsIndexSchema()
-{
-    static NeverDestroyed<WTF::String> indexRecordsIndexSchemaString("CREATE INDEX IndexRecordsIndex ON IndexRecords (key)");
-    return indexRecordsIndexSchemaString;
-}
-
 static const String blobRecordsTableSchema(const String& tableName)
 {
     return makeString("CREATE TABLE ", tableName, " (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)");
 }
 
@@ -227,15 +227,24 @@
 {
     static NeverDestroyed<String> blobFilesTableSchemaString(blobFilesTableSchema("\"BlobFiles\""));
     return blobFilesTableSchemaString;
 }
 
-SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier& identifier, const String& databaseRootDirectory, IDBBackingStoreTemporaryFileHandler& fileHandler)
+static String createV1ObjectStoreInfoSchema(ASCIILiteral tableName)
+{
+    return makeString("CREATE TABLE ", tableName, " (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL)");
+}
+
+static String createV2ObjectStoreInfoSchema(ASCIILiteral tableName)
+{
+    return makeString("CREATE TABLE ", tableName, " (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)");
+}
+
+SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier& identifier, const String& databaseRootDirectory)
     : m_sessionID(sessionID)
     , m_identifier(identifier)
     , m_databaseRootDirectory(databaseRootDirectory)
-    , m_temporaryFileHandler(fileHandler)
     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 {
     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 }
 
@@ -498,11 +507,11 @@
 
         int sqliteResult = statement.step();
 
         // If there is no IndexRecordsIndex index at all, create it and then bail.
         if (sqliteResult == SQLITE_DONE) {
-            if (!m_sqliteDB->executeCommand(v1IndexRecordsIndexSchema())) {
+            if (!m_sqliteDB->executeCommand(IndexRecordsIndexSchema)) {
                 LOG_ERROR("Could not create IndexRecordsIndex index in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
                 return false;
             }
 
             return true;
@@ -517,14 +526,69 @@
     }
 
     ASSERT(!currentSchema.isEmpty());
 
     // If the schema in the backing store is the current schema, we're done.
-    if (currentSchema == v1IndexRecordsIndexSchema())
+    if (currentSchema == IndexRecordsIndexSchema)
+        return true;
+
+    // Otherwise, update the schema.
+    SQLiteTransaction transaction(*m_sqliteDB);
+    transaction.begin();
+
+    if (!m_sqliteDB->executeCommand("DROP INDEX IndexRecordsIndex")) {
+        LOG_ERROR("Could not drop index IndexRecordsIndex in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return false;
+    }
+
+    if (!m_sqliteDB->executeCommand(IndexRecordsIndexSchema)) {
+        LOG_ERROR("Could not create IndexRecordsIndex index in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return false;
+    }
+
+    transaction.commit();
+
+    return true;
+}
+
+bool SQLiteIDBBackingStore::ensureValidIndexRecordsRecordIndex()
+{
+    ASSERT(m_sqliteDB);
+    ASSERT(m_sqliteDB->isOpen());
+
+    String currentSchema;
+    {
+        SQLiteStatement statement(*m_sqliteDB, "SELECT sql FROM sqlite_master WHERE name='IndexRecordsRecordIndex'");
+        if (statement.prepare() != SQLITE_OK) {
+            LOG_ERROR("Unable to prepare statement to fetch schema for the IndexRecordsRecordIndex index.");
+            return false;
+        }
+
+        int sqliteResult = statement.step();
+
+        if (sqliteResult == SQLITE_DONE) {
+            if (!m_sqliteDB->executeCommand(v1IndexRecordsRecordIndexSchema)) {
+                LOG_ERROR("Could not create IndexRecordsRecordIndex index in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+                return false;
+            }
+
+            return true;
+        }
+
+        if (sqliteResult != SQLITE_ROW) {
+            LOG_ERROR("Error executing statement to fetch schema for the IndexRecordsRecordIndex index.");
+            return false;
+        }
+
+        currentSchema = statement.getColumnText(0);
+    }
+
+    ASSERT(!currentSchema.isEmpty());
+
+    if (currentSchema == v1IndexRecordsRecordIndexSchema)
         return true;
 
-    // There is currently no outdated schema for the IndexRecordsIndex, so any other existing schema means this database is invalid.
     return false;
 }
 
 std::unique_ptr<IDBDatabaseInfo> SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 {
@@ -535,11 +599,11 @@
         LOG_ERROR("Could not create IDBDatabaseInfo table in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
         closeSQLiteDB();
         return nullptr;
     }
 
-    if (!m_sqliteDB->executeCommand("CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL);")) {
+    if (!m_sqliteDB->executeCommand(v2ObjectStoreInfoSchema)) {
         LOG_ERROR("Could not create ObjectStoreInfo table in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
         closeSQLiteDB();
         return nullptr;
     }
 
@@ -593,11 +657,72 @@
         closeSQLiteDB();
         return nullptr;
     }
 
     // This initial database info matches the default values we just put into the metadata database.
-    return makeUnique<IDBDatabaseInfo>(m_identifier.databaseName(), 0);
+    return makeUnique<IDBDatabaseInfo>(m_identifier.databaseName(), 0, 0);
+}
+
+Optional<IsSchemaUpgraded> SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable()
+{
+    ASSERT(m_sqliteDB);
+    ASSERT(m_sqliteDB->isOpen());
+
+    String currentSchema;
+    {
+        // Fetch the schema for ObjectStoreInfo table.
+        SQLiteStatement statement(*m_sqliteDB, "SELECT sql FROM sqlite_master WHERE tbl_name='ObjectStoreInfo'");
+        if (statement.prepare() != SQLITE_OK) {
+            LOG_ERROR("Unable to prepare statement to fetch schema for the ObjectStoreInfo table.");
+            return WTF::nullopt;
+        }
+
+        int sqliteResult = statement.step();
+        if (sqliteResult != SQLITE_ROW) {
+            LOG_ERROR("Error executing statement to fetch schema for the ObjectStoreInfo table.");
+            return WTF::nullopt;
+        }
+
+        currentSchema = statement.getColumnText(0);
+    }
+
+    ASSERT(!currentSchema.isEmpty());
+    if (currentSchema == v2ObjectStoreInfoSchema || currentSchema == createV2ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate))
+        return { IsSchemaUpgraded::No };
+
+    if (currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableName) && currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate)) {
+        RELEASE_LOG_ERROR(IndexedDB, "%p - SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable: schema is invalid - %s", this, currentSchema.utf8().data());
+        return WTF::nullopt;
+    }
+
+    // Drop column maxIndexID from table.
+    SQLiteTransaction transaction(*m_sqliteDB);
+    transaction.begin();
+
+    if (!m_sqliteDB->executeCommand(createV2ObjectStoreInfoSchema("_Temp_ObjectStoreInfo"_s))) {
+        LOG_ERROR("Could not create temporary ObjectStoreInfo table in database (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return WTF::nullopt;
+    }
+
+    if (!m_sqliteDB->executeCommand("INSERT INTO _Temp_ObjectStoreInfo (id, name, keyPath, autoInc) SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo")) {
+        LOG_ERROR("Could not migrate existing ObjectStoreInfo content (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return WTF::nullopt;
+    }
+
+    if (!m_sqliteDB->executeCommand("DROP TABLE ObjectStoreInfo")) {
+        LOG_ERROR("Could not drop existing ObjectStoreInfo table (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return WTF::nullopt;
+    }
+
+    if (!m_sqliteDB->executeCommand("ALTER TABLE _Temp_ObjectStoreInfo RENAME TO ObjectStoreInfo")) {
+        LOG_ERROR("Could not rename temporary ObjectStoreInfo table (%i) - %s", m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+        return WTF::nullopt;
+    }
+
+    transaction.commit();
+
+    return { IsSchemaUpgraded::Yes };
 }
 
 std::unique_ptr<IDBDatabaseInfo> SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 {
     ASSERT(m_sqliteDB);
@@ -628,14 +753,20 @@
             LOG_ERROR("Database version on disk ('%s') does not cleanly convert to an unsigned 64-bit integer version", stringVersion.utf8().data());
             return nullptr;
         }
     }
 
-    auto databaseInfo = makeUnique<IDBDatabaseInfo>(databaseName, databaseVersion);
+    auto databaseInfo = makeUnique<IDBDatabaseInfo>(databaseName, databaseVersion, 0);
+
+    auto result = ensureValidObjectStoreInfoTable();
+    if (!result)
+        return nullptr;
+
+    bool shouldUpdateIndexID = (result.value() == IsSchemaUpgraded::Yes);
 
     {
-        SQLiteStatement sql(*m_sqliteDB, "SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;"_s);
+        SQLiteStatement sql(*m_sqliteDB, "SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo;"_s);
         if (sql.prepare() != SQLITE_OK)
             return nullptr;
 
         int result = sql.step();
         while (result == SQLITE_ROW) {
@@ -662,14 +793,18 @@
             LOG_ERROR("Error fetching object store info from database on disk");
             return nullptr;
         }
     }
 
+    uint64_t maxIndexID = 0;
+    HashMap<std::pair<uint64_t, uint64_t>, uint64_t> indexIDMap;
     {
         SQLiteStatement sql(*m_sqliteDB, "SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;"_s);
-        if (sql.prepare() != SQLITE_OK)
+        if (sql.prepare() != SQLITE_OK) {
+            LOG_ERROR("Unable to prepare statement to fetch records from the IndexInfo table.");
             return nullptr;
+        }
 
         int result = sql.step();
         while (result == SQLITE_ROW) {
             uint64_t indexID = sql.getColumnInt64(0);
             String indexName = sql.getColumnText(1);
@@ -695,19 +830,51 @@
             if (!objectStore) {
                 LOG_ERROR("Found index referring to a non-existant object store");
                 return nullptr;
             }
 
+            if (shouldUpdateIndexID) {
+                indexIDMap.set({ objectStoreID, indexID }, ++maxIndexID);
+                indexID = maxIndexID;
+            }
+
             objectStore->addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
+            maxIndexID = maxIndexID < indexID ? indexID : maxIndexID;
 
             result = sql.step();
         }
 
         if (result != SQLITE_DONE) {
             LOG_ERROR("Error fetching index info from database on disk");
             return nullptr;
         }
+        databaseInfo->setMaxIndexID(maxIndexID);
+
+        if (!shouldUpdateIndexID)
+            return databaseInfo;
+
+        for (auto& entry : indexIDMap) {
+            SQLiteStatement sql(*m_sqliteDB, "UPDATE IndexInfo SET id = ? WHERE id = ? AND objectStoreID = ?;"_s);
+            if (sql.prepare() != SQLITE_OK
+                || sql.bindInt64(1, entry.value) != SQLITE_OK
+                || sql.bindInt64(2, entry.key.second) != SQLITE_OK
+                || sql.bindInt64(3, entry.key.first) != SQLITE_OK
+                || sql.step() != SQLITE_DONE) {
+                LOG_ERROR("Unable to update id of IndexInfo table");
+                return nullptr;
+            }
+
+            SQLiteStatement recordSql(*m_sqliteDB, "UPDATE IndexRecords SET indexID = ? WHERE indexID = ? AND objectStoreID = ?;"_s);
+            if (recordSql.prepare() != SQLITE_OK
+                || recordSql.bindInt64(1, entry.value) != SQLITE_OK
+                || recordSql.bindInt64(2, entry.key.second) != SQLITE_OK
+                || recordSql.bindInt64(3, entry.key.first) != SQLITE_OK
+                || recordSql.step() != SQLITE_DONE) {
+                LOG_ERROR("Unable to update indexID of IndexRecords table");
+                return nullptr;
+            }
+        }
     }
 
     return databaseInfo;
 }
 
@@ -822,10 +989,16 @@
         LOG_ERROR("Error creating or migrating Index Records index in database");
         closeSQLiteDB();
         return IDBError { UnknownError, "Error creating or migrating Index Records index in database"_s };
     }
 
+    if (!ensureValidIndexRecordsRecordIndex()) {
+        LOG_ERROR("Error creating or migrating Index Records second index for in database");
+        closeSQLiteDB();
+        return IDBError { UnknownError, "Error creating or migrating Index Records second index in database"_s };
+    }
+
     if (!ensureValidBlobTables()) {
         LOG_ERROR("Error creating or confirming Blob Records tables in database");
         closeSQLiteDB();
         return IDBError { UnknownError, "Error creating or confirming Blob Records tables in database"_s };
     }
@@ -853,16 +1026,10 @@
             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
     }
     return diskUsage;
 }
 
-uint64_t SQLiteIDBBackingStore::databaseSize() const
-{
-    ASSERT(!isMainThread());
-    return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());
-}
-
 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo& info)
 {
     LOG(IndexedDB, "SQLiteIDBBackingStore::beginTransaction - %s", info.identifier().loggingString().utf8().data());
 
     ASSERT(m_sqliteDB);
@@ -957,17 +1124,16 @@
         LOG_ERROR("Unable to serialize IDBKeyPath to save in database for new object store");
         return IDBError { UnknownError, "Unable to serialize IDBKeyPath to save in database for new object store"_s };
     }
 
     {
-        auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, "INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);"_s);
+        auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, "INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?);"_s);
         if (!sql
             || sql->bindInt64(1, info.identifier()) != SQLITE_OK
             || sql->bindText(2, info.name()) != SQLITE_OK
             || sql->bindBlob(3, keyPathBlob->data(), keyPathBlob->size()) != SQLITE_OK
             || sql->bindInt(4, info.autoIncrement()) != SQLITE_OK
-            || sql->bindInt64(5, info.maxIndexID()) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not add object store '%s' to ObjectStoreInfo table (%i) - %s", info.name().utf8().data(), m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
             return IDBError { UnknownError, "Could not create object store"_s };
         }
     }
@@ -1194,12 +1360,12 @@
         return IDBError { UnknownError, "Unable to populate indexes in database"_s };
     }
 
     while (!cursor->currentKey().isNull()) {
         auto& key = cursor->currentKey();
-        auto* value = cursor->currentValue();
-        ThreadSafeDataBuffer valueBuffer = value ? value->data() : ThreadSafeDataBuffer();
+        auto value = cursor->currentValue();
+        ThreadSafeDataBuffer valueBuffer = value.data();
 
         ASSERT(cursor->currentRecordRowID());
 
         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor->currentRecordRowID());
         if (!error.isNull()) {
@@ -1228,10 +1394,11 @@
     }
 
     auto* objectStore = m_databaseInfo->infoForExistingObjectStore(info.objectStoreIdentifier());
     ASSERT(objectStore);
     objectStore->addExistingIndex(info);
+    m_databaseInfo->setMaxIndexID(info.identifier());
 
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo& info, const IDBKeyData& indexKey, bool& hasRecord)
@@ -1242,15 +1409,14 @@
     if (!indexKeyBuffer) {
         LOG_ERROR("Unable to serialize index key to be stored in the database");
         return IDBError { UnknownError, "Unable to serialize IDBKey to check for index record in database"_s };
     }
 
-    auto* sql = cachedStatement(SQL::HasIndexRecord, "SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);"_s);
+    auto* sql = cachedStatement(SQL::HasIndexRecord, "SELECT rowid FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT);"_s);
     if (!sql
         || sql->bindInt64(1, info.identifier()) != SQLITE_OK
-        || sql->bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
-        || sql->bindBlob(3, indexKeyBuffer->data(), indexKeyBuffer->size()) != SQLITE_OK) {
+        || sql->bindBlob(2, indexKeyBuffer->data(), indexKeyBuffer->size()) != SQLITE_OK) {
         LOG_ERROR("Error checking for index record in database");
         return IDBError { UnknownError, "Error checking for index record in database"_s };
     }
 
     int sqlResult = sql->step();
@@ -1364,14 +1530,13 @@
             return IDBError { UnknownError, "Error deleting index from database"_s };
         }
     }
 
     {
-        auto* sql = cachedStatement(SQL::DeleteIndexRecords, "DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;"_s);
+        auto* sql = cachedStatement(SQL::DeleteIndexRecords, "DELETE FROM IndexRecords WHERE indexID = ?;"_s);
         if (!sql
             || sql->bindInt64(1, indexIdentifier) != SQLITE_OK
-            || sql->bindInt64(2, objectStoreIdentifier) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not delete index records for index id %" PRIi64 " from IndexRecords table (%i) - %s", indexIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
             return IDBError { UnknownError, "Error deleting index records from database"_s };
         }
     }
@@ -1521,14 +1686,15 @@
     if (!keyBuffer) {
         LOG_ERROR("Unable to serialize IDBKeyData to be removed from the database");
         return IDBError { UnknownError, "Unable to serialize IDBKeyData to be removed from the database"_s };
     }
 
-    // Get the record ID
+    // Get the record ID and value.
     int64_t recordID;
+    ThreadSafeDataBuffer value;
     {
-        auto* sql = cachedStatement(SQL::GetObjectStoreRecordID, "SELECT recordID FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);"_s);
+        auto* sql = cachedStatement(SQL::GetObjectStoreRecord, "SELECT recordID, value FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);"_s);
 
         if (!sql
             || sql->bindInt64(1, objectStoreID) != SQLITE_OK
             || sql->bindBlob(2, keyBuffer->data(), keyBuffer->size()) != SQLITE_OK) {
             LOG_ERROR("Could not delete record from object store %" PRIi64 " (%i) - %s", objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
@@ -1545,10 +1711,14 @@
             LOG_ERROR("Could not delete record from object store %" PRIi64 " (%i) (unable to fetch record ID) - %s", objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
             return IDBError { UnknownError, "Failed to delete record from object store"_s };
         }
 
         recordID = sql->getColumnInt64(0);
+
+        Vector<uint8_t> valueBuffer;
+        sql->getColumnBlobAsVector(1, valueBuffer);
+        value = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));
     }
 
     if (recordID < 1) {
         LOG_ERROR("Could not delete record from object store %" PRIi64 " (%i) (record ID is invalid) - %s", objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
         return IDBError { UnknownError, "Failed to delete record from object store"_s };
@@ -1583,15 +1753,15 @@
         }
     }
 
     // Delete record from indexes store
     {
-        auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, "DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);"_s);
+        auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, "DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;"_s);
 
         if (!sql
             || sql->bindInt64(1, objectStoreID) != SQLITE_OK
-            || sql->bindBlob(2, keyBuffer->data(), keyBuffer->size()) != SQLITE_OK
+            || sql->bindInt64(2, recordID) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Could not delete record from indexes for object store %" PRIi64 " (%i) - %s", objectStoreID, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
             return IDBError { UnknownError, "Failed to delete index entries for object store record"_s };
         }
     }
@@ -1701,17 +1871,15 @@
 
         anyRecordsSucceeded = true;
     }
 
     if (!error.isNull() && anyRecordsSucceeded) {
-        RefPtr<SharedBuffer> keyBuffer = serializeIDBKeyData(key);
-
-        auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, "DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);"_s);
+        auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, "DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;"_s);
 
         if (!sql
             || sql->bindInt64(1, info.identifier()) != SQLITE_OK
-            || sql->bindBlob(2, keyBuffer->data(), keyBuffer->size()) != SQLITE_OK
+            || sql->bindInt64(2, recordID) != SQLITE_OK
             || sql->step() != SQLITE_DONE) {
             LOG_ERROR("Adding one Index record failed, but failed to remove all others that previously succeeded");
             return IDBError { UnknownError, "Adding one Index record failed, but failed to remove all others that previously succeeded"_s };
         }
     }
@@ -2180,11 +2348,11 @@
         targetCount = std::numeric_limits<uint32_t>::max();
     while (!cursor->didComplete() && !cursor->didError() && currentCount < targetCount) {
         IDBKeyData keyCopy = cursor->currentPrimaryKey();
         result.addKey(WTFMove(keyCopy));
         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
-            result.addValue(cursor->currentValue() ? *cursor->currentValue() : IDBValue());
+            result.addValue(IDBValue(cursor->currentValue()));
 
         ++currentCount;
         cursor->advance(1);
     }
 
@@ -2227,11 +2395,11 @@
         if (type == IndexedDB::IndexRecordType::Key)
             getResult = { cursor->currentPrimaryKey() };
         else {
             auto* objectStoreInfo = infoForObjectStore(objectStoreID);
             ASSERT(objectStoreInfo);
-            getResult = { cursor->currentPrimaryKey(), cursor->currentPrimaryKey(), cursor->currentValue() ? *cursor->currentValue() : IDBValue(), objectStoreInfo->keyPath() };
+            getResult = { cursor->currentPrimaryKey(), cursor->currentPrimaryKey(), IDBValue(cursor->currentValue()), objectStoreInfo->keyPath() };
         }
     }
 
     return IDBError { };
 }
@@ -2246,16 +2414,15 @@
     if (!buffer) {
         LOG_ERROR("Unable to serialize IDBKey to look up one index record");
         return IDBError { UnknownError, "Unable to serialize IDBKey to look up one index record"_s };
     }
 
-    auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, "SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value"_s);
+    auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, "SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.objectStoreID = IndexRecords.objectStoreID AND Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value"_s);
 
     if (!sql
         || sql->bindInt64(1, indexID) != SQLITE_OK
-        || sql->bindInt64(2, objectStoreID) != SQLITE_OK
-        || sql->bindBlob(3, buffer->data(), buffer->size()) != SQLITE_OK) {
+        || sql->bindBlob(2, buffer->data(), buffer->size()) != SQLITE_OK) {
         LOG_ERROR("Unable to lookup index record in database");
         return IDBError { UnknownError, "Unable to lookup index record in database"_s };
     }
 
     int result = sql->step();
@@ -2302,25 +2469,82 @@
 {
     LOG(IndexedDB, "SQLiteIDBBackingStore::getCount - object store %" PRIu64, objectStoreIdentifier);
     ASSERT(m_sqliteDB);
     ASSERT(m_sqliteDB->isOpen());
 
-    outCount = 0;
-
     auto* transaction = m_transactions.get(transactionIdentifier);
     if (!transaction || !transaction->inProgress())
         return IDBError { UnknownError, "Attempt to get count from database without an in-progress transaction"_s };
 
-    auto cursor = transaction->maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);
-    if (!cursor) {
-        LOG_ERROR("Cannot open cursor to populate indexes in database");
-        return IDBError { UnknownError, "Unable to populate indexes in database"_s };
+    outCount = 0;
+
+    auto lowerKey = range.lowerKey.isNull() ? IDBKeyData::minimum() : range.lowerKey;
+    RefPtr<SharedBuffer> lowerBuffer = serializeIDBKeyData(lowerKey);
+    if (!lowerBuffer) {
+        LOG_ERROR("Unable to serialize lower IDBKey in lookup range");
+        return IDBError { UnknownError, "Unable to serialize lower IDBKey in lookup range for count operation"_s };
+    }
+
+    auto upperKey = range.upperKey.isNull() ? IDBKeyData::maximum() : range.upperKey;
+    RefPtr<SharedBuffer> upperBuffer = serializeIDBKeyData(upperKey);
+    if (!upperBuffer) {
+        LOG_ERROR("Unable to serialize upper IDBKey in lookup range");
+        return IDBError { UnknownError, "Unable to serialize upper IDBKey in lookup range for count operation"_s };
+    }
+
+    SQLiteStatement* statement = nullptr;
+
+    if (!indexIdentifier) {
+        static const char* const countLowerOpenUpperOpenRecords = "SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT);";
+        static const char* const countLowerOpenUpperClosedRecords = "SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT);";
+        static const char* const countLowerClosedUpperOpenRecords = "SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT);";
+        static const char* const countLowerClosedUpperClosedRecords = "SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT);";
+
+        if (range.lowerOpen && range.upperOpen)
+            statement = cachedStatement(SQL::CountRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenRecords);
+        else if (range.lowerOpen && !range.upperOpen)
+            statement = cachedStatement(SQL::CountRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedRecords);
+        else if (!range.lowerOpen && range.upperOpen)
+            statement = cachedStatement(SQL::CountRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenRecords);
+        else
+            statement = cachedStatement(SQL::CountRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedRecords);
+
+        if (!statement
+            || statement->bindInt64(1, objectStoreIdentifier) != SQLITE_OK
+            || statement->bindBlob(2, lowerBuffer->data(), lowerBuffer->size()) != SQLITE_OK
+            || statement->bindBlob(3, upperBuffer->data(), upperBuffer->size()) != SQLITE_OK) {
+            LOG_ERROR("Could not count records in object store %" PRIi64 " from Records table (%i) - %s", objectStoreIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+            return IDBError { UnknownError, "Unable to count records in object store due to binding failure"_s };
+        }
+    } else {
+        static const char* const countLowerOpenUpperOpenIndexRecords = "SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key > CAST(? AS TEXT) AND key < CAST(? AS TEXT);";
+        static const char* const countLowerOpenUpperClosedIndexRecords = "SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key > CAST(? AS TEXT) AND key <= CAST(? AS TEXT);";
+        static const char* const countLowerClosedUpperOpenIndexRecords = "SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key >= CAST(? AS TEXT) AND key < CAST(? AS TEXT);";
+        static const char* const countLowerClosedUpperClosedIndexRecords = "SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key >= CAST(? AS TEXT) AND key <= CAST(? AS TEXT);";
+
+        if (range.lowerOpen && range.upperOpen)
+            statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenIndexRecords);
+        else if (range.lowerOpen && !range.upperOpen)
+            statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedIndexRecords);
+        else if (!range.lowerOpen && range.upperOpen)
+            statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenIndexRecords);
+        else
+            statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedIndexRecords);
+
+        if (!statement
+            || statement->bindInt64(1, indexIdentifier) != SQLITE_OK
+            || statement->bindBlob(2, lowerBuffer->data(), lowerBuffer->size()) != SQLITE_OK
+            || statement->bindBlob(3, upperBuffer->data(), upperBuffer->size()) != SQLITE_OK) {
+            LOG_ERROR("Could not count records with index %" PRIi64 " from IndexRecords table (%i) - %s", indexIdentifier, m_sqliteDB->lastError(), m_sqliteDB->lastErrorMsg());
+            return IDBError { UnknownError, "Unable to count records for index due to binding failure"_s };
+        }
     }
 
-    while (cursor->advance(1))
-        ++outCount;
+    if (statement->step() != SQLITE_ROW)
+        return IDBError { UnknownError, "Unable to count records"_s };
 
+    outCount = statement->getColumnInt(0);
     return IDBError { };
 }
 
 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t& outValue)
 {
@@ -2491,30 +2715,22 @@
             LOG_ERROR("Attempt to advance cursor failed");
             return IDBError { UnknownError, "Attempt to advance cursor failed"_s };
         }
     }
 
-    auto* objectStoreInfo = infoForObjectStore(cursor->objectStoreID());
-    ASSERT(objectStoreInfo);
-    cursor->currentData(result, objectStoreInfo->keyPath());
-    return IDBError { };
-}
+    if (data.option == IndexedDB::CursorIterateOption::Reply) {
+        auto* objectStoreInfo = infoForObjectStore(cursor->objectStoreID());
+        ASSERT(objectStoreInfo);
 
-bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier& transactionIdentifier, const IDBResourceIdentifier& cursorIdentifier)
-{
-    LOG(IndexedDB, "SQLiteIDBBackingStore::prefetchCursor");
+        bool shouldPrefetch = key.isNull() && primaryKey.isNull();
+        if (shouldPrefetch)
+            cursor->prefetch();
 
-    ASSERT(m_sqliteDB);
-    ASSERT(m_sqliteDB->isOpen());
-
-    auto* cursor = m_cursors.get(cursorIdentifier);
-    if (!cursor || !cursor->transaction() || !cursor->transaction()->inProgress())
-        return false;
-
-    ASSERT_UNUSED(transactionIdentifier, cursor->transaction()->transactionIdentifier() == transactionIdentifier);
+        cursor->currentData(result, objectStoreInfo->keyPath(), shouldPrefetch ? SQLiteIDBCursor::ShouldIncludePrefetchedRecords::Yes : SQLiteIDBCursor::ShouldIncludePrefetchedRecords::No);
+    }
 
-    return cursor->prefetch();
+    return IDBError { };
 }
 
 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
 {
     ASSERT(m_databaseInfo);
@@ -2569,11 +2785,11 @@
     m_cursors.remove(cursor.identifier());
 }
 
 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
 {
-    if (sql >= SQL::Count) {
+    if (sql >= SQL::Invalid) {
         LOG_ERROR("Invalid SQL statement ID passed to cachedStatement()");
         return nullptr;
     }
 
     if (m_cachedStatements[static_cast<size_t>(sql)]) {
@@ -2596,11 +2812,11 @@
     closeSQLiteDB();
 }
 
 void SQLiteIDBBackingStore::closeSQLiteDB()
 {
-    for (size_t i = 0; i < static_cast<int>(SQL::Count); ++i)
+    for (size_t i = 0; i < static_cast<int>(SQL::Invalid); ++i)
         m_cachedStatements[i] = nullptr;
 
     if (m_sqliteDB)
         m_sqliteDB->close();
 

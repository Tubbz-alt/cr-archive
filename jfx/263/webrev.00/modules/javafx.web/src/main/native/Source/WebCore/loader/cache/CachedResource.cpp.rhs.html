<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
  4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
  5     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  6     Copyright (C) 2004-2011, 2014, 2018 Apple Inc. All rights reserved.
  7 
  8     This library is free software; you can redistribute it and/or
  9     modify it under the terms of the GNU Library General Public
 10     License as published by the Free Software Foundation; either
 11     version 2 of the License, or (at your option) any later version.
 12 
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedResource.h&quot;
 26 
 27 #include &quot;CachedResourceClient.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceHandle.h&quot;
 30 #include &quot;CachedResourceLoader.h&quot;
 31 #include &quot;CookieJar.h&quot;
 32 #include &quot;CrossOriginAccessControl.h&quot;
 33 #include &quot;DiagnosticLoggingClient.h&quot;
 34 #include &quot;DiagnosticLoggingKeys.h&quot;
 35 #include &quot;Document.h&quot;
 36 #include &quot;DocumentLoader.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoader.h&quot;
 39 #include &quot;FrameLoaderClient.h&quot;
 40 #include &quot;HTTPHeaderNames.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 41 #include &quot;HTTPHeaderValues.h&quot;</span>
 42 #include &quot;InspectorInstrumentation.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 43 #include &quot;LegacySchemeRegistry.h&quot;</span>
 44 #include &quot;LoaderStrategy.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MemoryCache.h&quot;
 47 #include &quot;PlatformStrategies.h&quot;
 48 #include &quot;ProgressTracker.h&quot;
 49 #include &quot;ResourceHandle.h&quot;
<a name="3" id="anc3"></a>
 50 #include &quot;SecurityOrigin.h&quot;
 51 #include &quot;SubresourceLoader.h&quot;
 52 #include &lt;wtf/CompletionHandler.h&gt;
 53 #include &lt;wtf/MathExtras.h&gt;
 54 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 55 #include &lt;wtf/StdLibExtras.h&gt;
 56 #include &lt;wtf/URL.h&gt;
 57 #include &lt;wtf/Vector.h&gt;
 58 #include &lt;wtf/text/CString.h&gt;
 59 
 60 #if USE(QUICK_LOOK)
 61 #include &quot;QuickLook.h&quot;
 62 #endif
 63 
 64 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(cachedResourceLoader.isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResource::&quot; fmt, this, ##__VA_ARGS__)
 65 
 66 namespace WebCore {
 67 
<a name="4" id="anc4"></a><span class="line-added"> 68 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CachedResource);</span>
<span class="line-added"> 69 </span>
 70 ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)
 71 {
 72     switch (type) {
 73     case Type::MainResource:
 74         return ResourceLoadPriority::VeryHigh;
 75     case Type::CSSStyleSheet:
 76     case Type::Script:
 77         return ResourceLoadPriority::High;
 78 #if ENABLE(SVG_FONTS)
 79     case Type::SVGFontResource:
 80 #endif
 81     case Type::MediaResource:
 82     case Type::FontResource:
 83     case Type::RawResource:
 84     case Type::Icon:
 85         return ResourceLoadPriority::Medium;
 86     case Type::ImageResource:
 87         return ResourceLoadPriority::Low;
 88 #if ENABLE(XSLT)
 89     case Type::XSLStyleSheet:
 90         return ResourceLoadPriority::High;
 91 #endif
 92     case Type::SVGDocumentResource:
 93         return ResourceLoadPriority::Low;
 94     case Type::Beacon:
 95     case Type::Ping:
 96         return ResourceLoadPriority::VeryLow;
 97     case Type::LinkPrefetch:
 98         return ResourceLoadPriority::VeryLow;
 99 #if ENABLE(VIDEO_TRACK)
100     case Type::TextTrackResource:
101         return ResourceLoadPriority::Low;
102 #endif
103 #if ENABLE(APPLICATION_MANIFEST)
104     case Type::ApplicationManifest:
105         return ResourceLoadPriority::Low;
106 #endif
107     }
108     ASSERT_NOT_REACHED();
109     return ResourceLoadPriority::Low;
110 }
111 
112 static Seconds deadDecodedDataDeletionIntervalForResourceType(CachedResource::Type type)
113 {
114     if (type == CachedResource::Type::Script)
115         return 0_s;
116 
117     return MemoryCache::singleton().deadDecodedDataDeletionInterval();
118 }
119 
120 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, cachedResourceLeakCounter, (&quot;CachedResource&quot;));
121 
122 CachedResource::CachedResource(CachedResourceRequest&amp;&amp; request, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
123     : m_options(request.options())
124     , m_resourceRequest(request.releaseResourceRequest())
125     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
126     , m_sessionID(sessionID)
127     , m_cookieJar(cookieJar)
128     , m_responseTimestamp(WallTime::now())
129     , m_fragmentIdentifierForRequest(request.releaseFragmentIdentifier())
130     , m_origin(request.releaseOrigin())
131     , m_initiatorName(request.initiatorName())
<a name="5" id="anc5"></a>
132     , m_type(type)
<a name="6" id="anc6"></a><span class="line-added">133     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="line-added">134     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="line-added">135     , m_loadPriority(defaultPriorityForResourceType(type))</span>
<span class="line-added">136     , m_status(Pending)</span>
<span class="line-added">137     , m_requestedFromNetworkingLayer(false)</span>
<span class="line-added">138     , m_inCache(false)</span>
<span class="line-added">139     , m_loading(false)</span>
140     , m_isLinkPreload(request.isLinkPreload())
141     , m_hasUnknownEncoding(request.isLinkPreload())
<a name="7" id="anc7"></a><span class="line-added">142     , m_switchingClientsToRevalidatedResource(false)</span>
143     , m_ignoreForRequestCount(request.ignoreForRequestCount())
144 {
145     ASSERT(m_sessionID.isValid());
146 
147     setLoadPriority(request.priority());
148 #ifndef NDEBUG
149     cachedResourceLeakCounter.increment();
150 #endif
151 
152     // FIXME: We should have a better way of checking for Navigation loads, maybe FetchMode::Options::Navigate.
153     ASSERT(m_origin || m_type == Type::MainResource);
154 
155     if (isRequestCrossOrigin(m_origin.get(), m_resourceRequest.url(), m_options))
156         setCrossOrigin();
157 }
158 
159 // FIXME: For this constructor, we should probably mandate that the URL has no fragment identifier.
160 CachedResource::CachedResource(const URL&amp; url, Type type, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
161     : m_resourceRequest(url)
162     , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
163     , m_sessionID(sessionID)
164     , m_cookieJar(cookieJar)
165     , m_responseTimestamp(WallTime::now())
166     , m_fragmentIdentifierForRequest(CachedResourceRequest::splitFragmentIdentifierFromRequestURL(m_resourceRequest))
<a name="8" id="anc8"></a>
167     , m_type(type)
<a name="9" id="anc9"></a><span class="line-added">168     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="line-added">169     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="line-added">170     , m_status(Cached)</span>
<span class="line-added">171     , m_requestedFromNetworkingLayer(false)</span>
<span class="line-added">172     , m_inCache(false)</span>
<span class="line-added">173     , m_loading(false)</span>
<span class="line-added">174     , m_isLinkPreload(false)</span>
<span class="line-added">175     , m_hasUnknownEncoding(false)</span>
<span class="line-added">176     , m_switchingClientsToRevalidatedResource(false)</span>
<span class="line-added">177     , m_ignoreForRequestCount(false)</span>
178 {
179     ASSERT(m_sessionID.isValid());
180 #ifndef NDEBUG
181     cachedResourceLeakCounter.increment();
182 #endif
183 }
184 
185 CachedResource::~CachedResource()
186 {
187     ASSERT(!m_resourceToRevalidate); // Should be true because canDelete() checks this.
188     ASSERT(canDelete());
189     ASSERT(!inCache());
190     ASSERT(!m_deleted);
191     ASSERT(url().isNull() || !allowsCaching() || MemoryCache::singleton().resourceForRequest(resourceRequest(), sessionID()) != this);
192 
193 #ifndef NDEBUG
194     m_deleted = true;
195     cachedResourceLeakCounter.decrement();
196 #endif
197 }
198 
199 void CachedResource::failBeforeStarting()
200 {
201     // FIXME: What if resources in other frames were waiting for this revalidation?
202     LOG(ResourceLoading, &quot;Cannot start loading &#39;%s&#39;&quot;, url().string().latin1().data());
203     if (allowsCaching() &amp;&amp; m_resourceToRevalidate)
204         MemoryCache::singleton().revalidationFailed(*this);
205     error(CachedResource::LoadError);
206 }
207 
208 void CachedResource::load(CachedResourceLoader&amp; cachedResourceLoader)
209 {
210     if (!cachedResourceLoader.frame()) {
211         RELEASE_LOG_IF_ALLOWED(&quot;load: No associated frame&quot;);
212         failBeforeStarting();
213         return;
214     }
215     Frame&amp; frame = *cachedResourceLoader.frame();
216 
<a name="10" id="anc10"></a><span class="line-modified">217     // Prevent new loads if we are in the BackForwardCache or being added to the BackForwardCache.</span>
218     // We query the top document because new frames may be created in pagehide event handlers
<a name="11" id="anc11"></a><span class="line-modified">219     // and their backForwardCacheState will not reflect the fact that they are about to enter page</span>
220     // cache.
221     if (auto* topDocument = frame.mainFrame().document()) {
<a name="12" id="anc12"></a><span class="line-modified">222         switch (topDocument-&gt;backForwardCacheState()) {</span>
<span class="line-modified">223         case Document::NotInBackForwardCache:</span>
224             break;
<a name="13" id="anc13"></a><span class="line-modified">225         case Document::AboutToEnterBackForwardCache:</span>
226             // Beacons are allowed to go through in &#39;pagehide&#39; event handlers.
227             if (shouldUsePingLoad(type()))
228                 break;
<a name="14" id="anc14"></a><span class="line-modified">229             RELEASE_LOG_IF_ALLOWED(&quot;load: About to enter back/forward cache (frame = %p)&quot;, &amp;frame);</span>
230             failBeforeStarting();
231             return;
<a name="15" id="anc15"></a><span class="line-modified">232         case Document::InBackForwardCache:</span>
<span class="line-modified">233             RELEASE_LOG_IF_ALLOWED(&quot;load: Already in back/forward cache (frame = %p)&quot;, &amp;frame);</span>
234             failBeforeStarting();
235             return;
236         }
237     }
238 
239     FrameLoader&amp; frameLoader = frame.loader();
240     if (m_options.securityCheck == SecurityCheckPolicy::DoSecurityCheck &amp;&amp; !shouldUsePingLoad(type())) {
241         while (true) {
242             if (frameLoader.state() == FrameStateProvisional)
243                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- state is provisional (frame = %p)&quot;, &amp;frame);
244             else if (!frameLoader.activeDocumentLoader())
245                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- not active document (frame = %p)&quot;, &amp;frame);
246             else if (frameLoader.activeDocumentLoader()-&gt;isStopping())
247                 RELEASE_LOG_IF_ALLOWED(&quot;load: Failed security check -- active loader is stopping (frame = %p)&quot;, &amp;frame);
248             else
249                 break;
250             failBeforeStarting();
251             return;
252         }
253     }
254 
255     m_loading = true;
256 
257     if (isCacheValidator()) {
258         CachedResource* resourceToRevalidate = m_resourceToRevalidate;
259         ASSERT(resourceToRevalidate-&gt;canUseCacheValidator());
260         ASSERT(resourceToRevalidate-&gt;isLoaded());
261         const String&amp; lastModified = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::LastModified);
262         const String&amp; eTag = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::ETag);
263         if (!lastModified.isEmpty() || !eTag.isEmpty()) {
264             ASSERT(cachedResourceLoader.cachePolicy(type(), url()) != CachePolicyReload);
265             if (cachedResourceLoader.cachePolicy(type(), url()) == CachePolicyRevalidate)
<a name="16" id="anc16"></a><span class="line-modified">266                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());</span>
267             if (!lastModified.isEmpty())
268                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfModifiedSince, lastModified);
269             if (!eTag.isEmpty())
270                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfNoneMatch, eTag);
271         }
272     }
273 
274     if (type() == Type::LinkPrefetch)
275         m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::Purpose, &quot;prefetch&quot;);
276     m_resourceRequest.setPriority(loadPriority());
277 
278     // Navigation algorithm is setting up the request before sending it to CachedResourceLoader?CachedResource.
279     // So no need for extra fields for MainResource.
280     if (type() != Type::MainResource)
281         frameLoader.addExtraFieldsToSubresourceRequest(m_resourceRequest);
282 
283 
284     // FIXME: It&#39;s unfortunate that the cache layer and below get to know anything about fragment identifiers.
285     // We should look into removing the expectation of that knowledge from the platform network stacks.
286     ResourceRequest request(m_resourceRequest);
287     if (!m_fragmentIdentifierForRequest.isNull()) {
288         URL url = request.url();
289         url.setFragmentIdentifier(m_fragmentIdentifierForRequest);
290         request.setURL(url);
291         m_fragmentIdentifierForRequest = String();
292     }
293 
294     if (m_options.keepAlive &amp;&amp; type() != Type::Ping &amp;&amp; !cachedResourceLoader.keepaliveRequestTracker().tryRegisterRequest(*this)) {
295         setResourceError({ errorDomainWebKitInternal, 0, request.url(), &quot;Reached maximum amount of queued data of 64Kb for keepalive requests&quot;_s, ResourceError::Type::AccessControl });
296         failBeforeStarting();
297         return;
298     }
299 
300     // FIXME: Deprecate that code path.
301     if (m_options.keepAlive &amp;&amp; shouldUsePingLoad(type()) &amp;&amp; platformStrategies()-&gt;loaderStrategy()-&gt;usePingLoad()) {
302         ASSERT(m_originalRequest);
303         CachedResourceHandle&lt;CachedResource&gt; protectedThis(this);
304 
305         unsigned long identifier = frame.page()-&gt;progress().createUniqueIdentifier();
306         InspectorInstrumentation::willSendRequestOfType(&amp;frame, identifier, frameLoader.activeDocumentLoader(), request, InspectorInstrumentation::LoadType::Beacon);
307 
308         platformStrategies()-&gt;loaderStrategy()-&gt;startPingLoad(frame, request, m_originalRequest-&gt;httpHeaderFields(), m_options, m_options.contentSecurityPolicyImposition, [this, protectedThis = WTFMove(protectedThis), protectedFrame = makeRef(frame), identifier] (const ResourceError&amp; error, const ResourceResponse&amp; response) {
309             if (!response.isNull())
310                 InspectorInstrumentation::didReceiveResourceResponse(protectedFrame, identifier, protectedFrame-&gt;loader().activeDocumentLoader(), response, nullptr);
311             if (!error.isNull()) {
312                 setResourceError(error);
313                 this-&gt;error(LoadError);
314                 InspectorInstrumentation::didFailLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, error);
315                 return;
316             }
317             finishLoading(nullptr);
318             NetworkLoadMetrics emptyMetrics;
319             InspectorInstrumentation::didFinishLoading(protectedFrame.ptr(), protectedFrame-&gt;loader().activeDocumentLoader(), identifier, emptyMetrics, nullptr);
320         });
321         return;
322     }
323 
324     platformStrategies()-&gt;loaderStrategy()-&gt;loadResource(frame, *this, WTFMove(request), m_options, [this, protectedThis = CachedResourceHandle&lt;CachedResource&gt;(this), frame = makeRef(frame), loggingAllowed = cachedResourceLoader.isAlwaysOnLoggingAllowed()] (RefPtr&lt;SubresourceLoader&gt;&amp;&amp; loader) {
325         m_loader = WTFMove(loader);
326         if (!m_loader) {
327             RELEASE_LOG_IF(loggingAllowed, Network, &quot;%p - CachedResource::load: Unable to create SubresourceLoader (frame = %p)&quot;, this, frame.ptr());
328             failBeforeStarting();
329             return;
330         }
<a name="17" id="anc17"></a><span class="line-modified">331         setStatus(Pending);</span>
332     });
333 }
334 
335 void CachedResource::loadFrom(const CachedResource&amp; resource)
336 {
337     ASSERT(url() == resource.url());
338     ASSERT(type() == resource.type());
339     ASSERT(resource.status() == Status::Cached);
340 
341     if (isCrossOrigin() &amp;&amp; m_options.mode == FetchOptions::Mode::Cors) {
342         ASSERT(m_origin);
343         String errorMessage;
344         if (!WebCore::passesAccessControlCheck(resource.response(), m_options.storedCredentialsPolicy, *m_origin, errorMessage)) {
345             setResourceError(ResourceError(String(), 0, url(), errorMessage, ResourceError::Type::AccessControl));
346             return;
347         }
348     }
349 
350     setBodyDataFrom(resource);
351     setStatus(Status::Cached);
352     setLoading(false);
353 }
354 
355 void CachedResource::setBodyDataFrom(const CachedResource&amp; resource)
356 {
357     m_data = resource.m_data;
358     m_response = resource.m_response;
359     m_response.setTainting(m_responseTainting);
360     setDecodedSize(resource.decodedSize());
361     setEncodedSize(resource.encodedSize());
362 }
363 
364 void CachedResource::checkNotify()
365 {
366     if (isLoading() || stillNeedsLoad())
367         return;
368 
369     CachedResourceClientWalker&lt;CachedResourceClient&gt; walker(m_clients);
370     while (CachedResourceClient* client = walker.next())
371         client-&gt;notifyFinished(*this);
372 }
373 
374 void CachedResource::updateBuffer(SharedBuffer&amp;)
375 {
376     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::BufferData);
377 }
378 
379 void CachedResource::updateData(const char*, unsigned)
380 {
381     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::DoNotBufferData);
382 }
383 
384 void CachedResource::finishLoading(SharedBuffer*)
385 {
386     setLoading(false);
387     checkNotify();
388 }
389 
390 void CachedResource::error(CachedResource::Status status)
391 {
392     setStatus(status);
393     ASSERT(errorOccurred());
394     m_data = nullptr;
395 
396     setLoading(false);
397     checkNotify();
398 }
399 
400 void CachedResource::cancelLoad()
401 {
402     if (!isLoading() &amp;&amp; !stillNeedsLoad())
403         return;
404 
405     auto* documentLoader = (m_loader &amp;&amp; m_loader-&gt;frame()) ? m_loader-&gt;frame()-&gt;loader().activeDocumentLoader() : nullptr;
406     if (m_options.keepAlive &amp;&amp; (!documentLoader || documentLoader-&gt;isStopping()))
407         m_error = { };
408     else
409         setStatus(LoadError);
410 
411     setLoading(false);
412     checkNotify();
413 }
414 
415 void CachedResource::finish()
416 {
417     if (!errorOccurred())
<a name="18" id="anc18"></a><span class="line-modified">418         setStatus(Cached);</span>
419 }
420 
421 void CachedResource::setCrossOrigin()
422 {
423     ASSERT(m_options.mode != FetchOptions::Mode::SameOrigin);
424     m_responseTainting = (m_options.mode == FetchOptions::Mode::Cors) ? ResourceResponse::Tainting::Cors : ResourceResponse::Tainting::Opaque;
425 }
426 
427 bool CachedResource::isCrossOrigin() const
428 {
429     return m_responseTainting != ResourceResponse::Tainting::Basic;
430 }
431 
432 bool CachedResource::isCORSSameOrigin() const
433 {
434     // Following resource types do not use CORS
435     ASSERT(type() != Type::FontResource);
436 #if ENABLE(SVG_FONTS)
437     ASSERT(type() != Type::SVGFontResource);
438 #endif
439 #if ENABLE(XSLT)
440     ASSERT(type() != Type::XSLStyleSheet);
441 #endif
442 
443     // https://html.spec.whatwg.org/multipage/infrastructure.html#cors-same-origin
444     return !loadFailedOrCanceled() &amp;&amp; m_responseTainting != ResourceResponse::Tainting::Opaque;
445 }
446 
447 bool CachedResource::isExpired() const
448 {
449     if (m_response.isNull())
450         return false;
451 
452     return computeCurrentAge(m_response, m_responseTimestamp) &gt; freshnessLifetime(m_response);
453 }
454 
455 static inline bool shouldCacheSchemeIndefinitely(StringView scheme)
456 {
457 #if PLATFORM(COCOA)
458     if (equalLettersIgnoringASCIICase(scheme, &quot;applewebdata&quot;))
459         return true;
460 #endif
461 #if USE(SOUP)
462     if (equalLettersIgnoringASCIICase(scheme, &quot;resource&quot;))
463         return true;
464 #endif
465     return equalLettersIgnoringASCIICase(scheme, &quot;data&quot;);
466 }
467 
468 Seconds CachedResource::freshnessLifetime(const ResourceResponse&amp; response) const
469 {
470     if (!response.url().protocolIsInHTTPFamily()) {
471         StringView protocol = response.url().protocol();
472         if (!shouldCacheSchemeIndefinitely(protocol)) {
473             // Don&#39;t cache non-HTTP main resources since we can&#39;t check for freshness.
474             // FIXME: We should not cache subresources either, but when we tried this
475             // it caused performance and flakiness issues in our test infrastructure.
<a name="19" id="anc19"></a><span class="line-modified">476             if (m_type == Type::MainResource || LegacySchemeRegistry::shouldAlwaysRevalidateURLScheme(protocol.toStringWithoutCopying()))</span>
477                 return 0_us;
478         }
479 
480         return Seconds::infinity();
481     }
482 
483     return computeFreshnessLifetimeForHTTPFamily(response, m_responseTimestamp);
484 }
485 
486 void CachedResource::redirectReceived(ResourceRequest&amp;&amp; request, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
487 {
488     m_requestedFromNetworkingLayer = true;
489     if (response.isNull())
490         return completionHandler(WTFMove(request));
491 
492     updateRedirectChainStatus(m_redirectChainCacheStatus, response);
493     completionHandler(WTFMove(request));
494 }
495 
496 void CachedResource::setResponse(const ResourceResponse&amp; response)
497 {
498     ASSERT(m_response.type() == ResourceResponse::Type::Default);
499     m_response = response;
<a name="20" id="anc20"></a><span class="line-modified">500     m_varyingHeaderValues = collectVaryingRequestHeaders(cookieJar(), m_resourceRequest, m_response);</span>
501 
502 #if ENABLE(SERVICE_WORKER)
503     if (m_response.source() == ResourceResponse::Source::ServiceWorker) {
504         m_responseTainting = m_response.tainting();
505         return;
506     }
507 #endif
508     m_response.setRedirected(m_redirectChainCacheStatus.status != RedirectChainCacheStatus::Status::NoRedirection);
509     if (m_response.tainting() == ResourceResponse::Tainting::Basic || m_response.tainting() == ResourceResponse::Tainting::Cors)
510         m_response.setTainting(m_responseTainting);
511 }
512 
513 void CachedResource::responseReceived(const ResourceResponse&amp; response)
514 {
515     setResponse(response);
516     m_responseTimestamp = WallTime::now();
517     String encoding = response.textEncodingName();
518     if (!encoding.isNull())
519         setEncoding(encoding);
520 }
521 
522 void CachedResource::clearLoader()
523 {
524     ASSERT(m_loader);
525     m_identifierForLoadWithoutResourceLoader = m_loader-&gt;identifier();
526     m_loader = nullptr;
527     deleteIfPossible();
528 }
529 
530 void CachedResource::addClient(CachedResourceClient&amp; client)
531 {
532     if (addClientToSet(client))
533         didAddClient(client);
534 }
535 
536 void CachedResource::didAddClient(CachedResourceClient&amp; client)
537 {
538     if (m_decodedDataDeletionTimer.isActive())
539         m_decodedDataDeletionTimer.stop();
540 
541     if (m_clientsAwaitingCallback.remove(&amp;client))
542         m_clients.add(&amp;client);
543 
544     // FIXME: Make calls to notifyFinished async
545     if (!isLoading() &amp;&amp; !stillNeedsLoad())
546         client.notifyFinished(*this);
547 }
548 
549 bool CachedResource::addClientToSet(CachedResourceClient&amp; client)
550 {
551     if (m_preloadResult == PreloadResult::PreloadNotReferenced &amp;&amp; client.shouldMarkAsReferenced()) {
552         if (isLoaded())
553             m_preloadResult = PreloadResult::PreloadReferencedWhileComplete;
554         else if (m_requestedFromNetworkingLayer)
555             m_preloadResult = PreloadResult::PreloadReferencedWhileLoading;
556         else
557             m_preloadResult = PreloadResult::PreloadReferenced;
558     }
559     if (allowsCaching() &amp;&amp; !hasClients() &amp;&amp; inCache())
560         MemoryCache::singleton().addToLiveResourcesSize(*this);
561 
562     if ((m_type == Type::RawResource || m_type == Type::MainResource) &amp;&amp; !m_response.isNull() &amp;&amp; !m_proxyResource) {
563         // Certain resources (especially XHRs and main resources) do crazy things if an asynchronous load returns
564         // synchronously (e.g., scripts may not have set all the state they need to handle the load).
565         // Therefore, rather than immediately sending callbacks on a cache hit like other CachedResources,
566         // we schedule the callbacks and ensure we never finish synchronously.
567         ASSERT(!m_clientsAwaitingCallback.contains(&amp;client));
568         m_clientsAwaitingCallback.add(&amp;client, makeUnique&lt;Callback&gt;(*this, client));
569         return false;
570     }
571 
572     m_clients.add(&amp;client);
573     return true;
574 }
575 
576 void CachedResource::removeClient(CachedResourceClient&amp; client)
577 {
578     auto callback = m_clientsAwaitingCallback.take(&amp;client);
579     if (callback) {
580         ASSERT(!m_clients.contains(&amp;client));
581         callback-&gt;cancel();
582         callback = nullptr;
583     } else {
584         ASSERT(m_clients.contains(&amp;client));
585         m_clients.remove(&amp;client);
586         didRemoveClient(client);
587     }
588 
589     if (deleteIfPossible()) {
590         // `this` object is dead here.
591         return;
592     }
593 
594     if (hasClients())
595         return;
596 
597     auto&amp; memoryCache = MemoryCache::singleton();
598     if (allowsCaching() &amp;&amp; inCache()) {
599         memoryCache.removeFromLiveResourcesSize(*this);
600         memoryCache.removeFromLiveDecodedResourcesList(*this);
601     }
602     if (!m_switchingClientsToRevalidatedResource)
603         allClientsRemoved();
604     destroyDecodedDataIfNeeded();
605 
606     if (!allowsCaching())
607         return;
608 
609     if (response().cacheControlContainsNoStore() &amp;&amp; url().protocolIs(&quot;https&quot;)) {
610         // RFC2616 14.9.2:
611         // &quot;no-store: ... MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible&quot;
612         // &quot;... History buffers MAY store such responses as part of their normal operation.&quot;
613         // We allow non-secure content to be reused in history, but we do not allow secure content to be reused.
614         memoryCache.remove(*this);
615     }
616     memoryCache.pruneSoon();
617 }
618 
619 void CachedResource::allClientsRemoved()
620 {
621     if (isLinkPreload() &amp;&amp; m_loader)
622         m_loader-&gt;cancelIfNotFinishing();
623 }
624 
625 void CachedResource::destroyDecodedDataIfNeeded()
626 {
627     if (!m_decodedSize)
628         return;
629     if (!MemoryCache::singleton().deadDecodedDataDeletionInterval())
630         return;
631     m_decodedDataDeletionTimer.restart();
632 }
633 
634 void CachedResource::decodedDataDeletionTimerFired()
635 {
636     destroyDecodedData();
637 }
638 
639 bool CachedResource::deleteIfPossible()
640 {
641     if (canDelete()) {
642         LOG(ResourceLoading, &quot;CachedResource %p deleteIfPossible - can delete, in cache %d&quot;, this, inCache());
643         if (!inCache()) {
644             InspectorInstrumentation::willDestroyCachedResource(*this);
645             delete this;
646             return true;
647         }
648         if (m_data)
649             m_data-&gt;hintMemoryNotNeededSoon();
650     }
651 
652     LOG(ResourceLoading, &quot;CachedResource %p deleteIfPossible - can&#39;t delete (hasClients %d loader %p preloadCount %u handleCount %u resourceToRevalidate %p proxyResource %p)&quot;, this, hasClients(), m_loader.get(), m_preloadCount, m_handleCount, m_resourceToRevalidate, m_proxyResource);
653     return false;
654 }
655 
656 void CachedResource::setDecodedSize(unsigned size)
657 {
658     if (size == m_decodedSize)
659         return;
660 
661     long long delta = static_cast&lt;long long&gt;(size) - m_decodedSize;
662 
663     // The object must be moved to a different queue, since its size has been changed.
664     // Remove before updating m_decodedSize, so we find the resource in the correct LRU list.
665     if (allowsCaching() &amp;&amp; inCache())
666         MemoryCache::singleton().removeFromLRUList(*this);
667 
668     m_decodedSize = size;
669 
670     if (allowsCaching() &amp;&amp; inCache()) {
671         auto&amp; memoryCache = MemoryCache::singleton();
672         // Now insert into the new LRU list.
673         memoryCache.insertInLRUList(*this);
674 
675         // Insert into or remove from the live decoded list if necessary.
676         // When inserting into the LiveDecodedResourcesList it is possible
677         // that the m_lastDecodedAccessTime is still zero or smaller than
678         // the m_lastDecodedAccessTime of the current list head. This is a
679         // violation of the invariant that the list is to be kept sorted
680         // by access time. The weakening of the invariant does not pose
681         // a problem. For more details please see: https://bugs.webkit.org/show_bug.cgi?id=30209
682         bool inLiveDecodedResourcesList = memoryCache.inLiveDecodedResourcesList(*this);
683         if (m_decodedSize &amp;&amp; !inLiveDecodedResourcesList &amp;&amp; hasClients())
684             memoryCache.insertInLiveDecodedResourcesList(*this);
685         else if (!m_decodedSize &amp;&amp; inLiveDecodedResourcesList)
686             memoryCache.removeFromLiveDecodedResourcesList(*this);
687 
688         // Update the cache&#39;s size totals.
689         memoryCache.adjustSize(hasClients(), delta);
690     }
691 }
692 
693 void CachedResource::setEncodedSize(unsigned size)
694 {
695     if (size == m_encodedSize)
696         return;
697 
698     long long delta = static_cast&lt;long long&gt;(size) - m_encodedSize;
699 
700     // The object must be moved to a different queue, since its size has been changed.
701     // Remove before updating m_encodedSize, so we find the resource in the correct LRU list.
702     if (allowsCaching() &amp;&amp; inCache())
703         MemoryCache::singleton().removeFromLRUList(*this);
704 
705     m_encodedSize = size;
706 
707     if (allowsCaching() &amp;&amp; inCache()) {
708         auto&amp; memoryCache = MemoryCache::singleton();
709         memoryCache.insertInLRUList(*this);
710         memoryCache.adjustSize(hasClients(), delta);
711     }
712 }
713 
714 void CachedResource::didAccessDecodedData(MonotonicTime timeStamp)
715 {
716     m_lastDecodedAccessTime = timeStamp;
717 
718     if (allowsCaching() &amp;&amp; inCache()) {
719         auto&amp; memoryCache = MemoryCache::singleton();
720         if (memoryCache.inLiveDecodedResourcesList(*this)) {
721             memoryCache.removeFromLiveDecodedResourcesList(*this);
722             memoryCache.insertInLiveDecodedResourcesList(*this);
723         }
724         memoryCache.pruneSoon();
725     }
726 }
727 
728 void CachedResource::setResourceToRevalidate(CachedResource* resource)
729 {
730     ASSERT(resource);
731     ASSERT(!m_resourceToRevalidate);
732     ASSERT(resource != this);
733     ASSERT(m_handlesToRevalidate.isEmpty());
734     ASSERT(resource-&gt;type() == type());
735     ASSERT(!resource-&gt;m_proxyResource);
736 
737     LOG(ResourceLoading, &quot;CachedResource %p setResourceToRevalidate %p&quot;, this, resource);
738 
739     resource-&gt;m_proxyResource = this;
740     m_resourceToRevalidate = resource;
741 }
742 
743 void CachedResource::clearResourceToRevalidate()
744 {
745     ASSERT(m_resourceToRevalidate);
746     ASSERT(m_resourceToRevalidate-&gt;m_proxyResource == this);
747 
748     if (m_switchingClientsToRevalidatedResource)
749         return;
750 
751     m_resourceToRevalidate-&gt;m_proxyResource = nullptr;
752     m_resourceToRevalidate-&gt;deleteIfPossible();
753 
754     m_handlesToRevalidate.clear();
755     m_resourceToRevalidate = nullptr;
756     deleteIfPossible();
757 }
758 
759 void CachedResource::switchClientsToRevalidatedResource()
760 {
761     ASSERT(m_resourceToRevalidate);
762     ASSERT(m_resourceToRevalidate-&gt;inCache());
763     ASSERT(!inCache());
764 
765     LOG(ResourceLoading, &quot;CachedResource %p switchClientsToRevalidatedResource %p&quot;, this, m_resourceToRevalidate);
766 
767     m_switchingClientsToRevalidatedResource = true;
768     for (auto&amp; handle : m_handlesToRevalidate) {
769         handle-&gt;m_resource = m_resourceToRevalidate;
770         m_resourceToRevalidate-&gt;registerHandle(handle);
771         --m_handleCount;
772     }
773     ASSERT(!m_handleCount);
774     m_handlesToRevalidate.clear();
775 
776     Vector&lt;CachedResourceClient*&gt; clientsToMove;
777     for (auto&amp; entry : m_clients) {
778         CachedResourceClient* client = entry.key;
779         unsigned count = entry.value;
780         while (count) {
781             clientsToMove.append(client);
782             --count;
783         }
784     }
785 
786     for (auto&amp; client : clientsToMove)
787         removeClient(*client);
788     ASSERT(m_clients.isEmpty());
789 
790     for (auto&amp; client : clientsToMove)
791         m_resourceToRevalidate-&gt;addClientToSet(*client);
792     for (auto&amp; client : clientsToMove) {
793         // Calling didAddClient may do anything, including trying to cancel revalidation.
794         // Assert that it didn&#39;t succeed.
795         ASSERT(m_resourceToRevalidate);
796         // Calling didAddClient for a client may end up removing another client. In that case it won&#39;t be in the set anymore.
797         if (m_resourceToRevalidate-&gt;m_clients.contains(client))
798             m_resourceToRevalidate-&gt;didAddClient(*client);
799     }
800     m_switchingClientsToRevalidatedResource = false;
801 }
802 
803 void CachedResource::updateResponseAfterRevalidation(const ResourceResponse&amp; validatingResponse)
804 {
805     m_responseTimestamp = WallTime::now();
806 
807     updateResponseHeadersAfterRevalidation(m_response, validatingResponse);
808 }
809 
810 void CachedResource::registerHandle(CachedResourceHandleBase* h)
811 {
812     ++m_handleCount;
813     if (m_resourceToRevalidate)
814         m_handlesToRevalidate.add(h);
815 }
816 
817 void CachedResource::unregisterHandle(CachedResourceHandleBase* h)
818 {
819     ASSERT(m_handleCount &gt; 0);
820     --m_handleCount;
821 
822     if (m_resourceToRevalidate)
823          m_handlesToRevalidate.remove(h);
824 
825     if (!m_handleCount)
826         deleteIfPossible();
827 }
828 
829 bool CachedResource::canUseCacheValidator() const
830 {
831     if (m_loading || errorOccurred())
832         return false;
833 
834     if (m_response.cacheControlContainsNoStore())
835         return false;
836     return m_response.hasCacheValidatorFields();
837 }
838 
839 CachedResource::RevalidationDecision CachedResource::makeRevalidationDecision(CachePolicy cachePolicy) const
840 {
841     switch (cachePolicy) {
842     case CachePolicyHistoryBuffer:
843         return RevalidationDecision::No;
844 
845     case CachePolicyReload:
846         return RevalidationDecision::YesDueToCachePolicy;
847 
848     case CachePolicyRevalidate:
849         if (m_response.cacheControlContainsImmutable() &amp;&amp; m_response.url().protocolIs(&quot;https&quot;)) {
850             if (isExpired())
851                 return RevalidationDecision::YesDueToExpired;
852             return RevalidationDecision::No;
853         }
854         return RevalidationDecision::YesDueToCachePolicy;
855 
856     case CachePolicyVerify:
857         if (m_response.cacheControlContainsNoCache())
858             return RevalidationDecision::YesDueToNoCache;
859         // FIXME: Cache-Control:no-store should prevent storing, not reuse.
860         if (m_response.cacheControlContainsNoStore())
861             return RevalidationDecision::YesDueToNoStore;
862 
863         if (isExpired())
864             return RevalidationDecision::YesDueToExpired;
865 
866         return RevalidationDecision::No;
867     };
868     ASSERT_NOT_REACHED();
869     return RevalidationDecision::No;
870 }
871 
872 bool CachedResource::redirectChainAllowsReuse(ReuseExpiredRedirectionOrNot reuseExpiredRedirection) const
873 {
874     return WebCore::redirectChainAllowsReuse(m_redirectChainCacheStatus, reuseExpiredRedirection);
875 }
876 
877 bool CachedResource::varyHeaderValuesMatch(const ResourceRequest&amp; request)
878 {
879     if (m_varyingHeaderValues.isEmpty())
880         return true;
881 
<a name="21" id="anc21"></a><span class="line-modified">882     return verifyVaryingRequestHeaders(cookieJar(), m_varyingHeaderValues, request);</span>
883 }
884 
885 unsigned CachedResource::overheadSize() const
886 {
887     static const int kAverageClientsHashMapSize = 384;
888     return sizeof(CachedResource) + m_response.memoryUsage() + kAverageClientsHashMapSize + m_resourceRequest.url().string().length() * 2;
889 }
890 
<a name="22" id="anc22"></a>











891 void CachedResource::setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp; loadPriority)
892 {
893     if (loadPriority)
894         m_loadPriority = loadPriority.value();
895     else
896         m_loadPriority = defaultPriorityForResourceType(type());
897 }
898 
899 inline CachedResource::Callback::Callback(CachedResource&amp; resource, CachedResourceClient&amp; client)
900     : m_resource(resource)
901     , m_client(client)
902     , m_timer(*this, &amp;Callback::timerFired)
903 {
904     m_timer.startOneShot(0_s);
905 }
906 
907 inline void CachedResource::Callback::cancel()
908 {
909     if (m_timer.isActive())
910         m_timer.stop();
911 }
912 
913 void CachedResource::Callback::timerFired()
914 {
915     m_resource.didAddClient(m_client);
916 }
917 
918 #if USE(FOUNDATION) || USE(SOUP)
919 
920 void CachedResource::tryReplaceEncodedData(SharedBuffer&amp; newBuffer)
921 {
922     if (!m_data)
923         return;
924 
925     if (!mayTryReplaceEncodedData())
926         return;
927 
928     // We have to do the memcmp because we can&#39;t tell if the replacement file backed data is for the
929     // same resource or if we made a second request with the same URL which gave us a different
930     // resource. We have seen this happen for cached POST resources.
931     if (m_data-&gt;size() != newBuffer.size() || memcmp(m_data-&gt;data(), newBuffer.data(), m_data-&gt;size()))
932         return;
933 
934     m_data-&gt;clear();
935     m_data-&gt;append(newBuffer);
936     didReplaceSharedBufferContents();
937 }
938 
939 #endif
940 
<a name="23" id="anc23"></a><span class="line-added">941 #if USE(QUICK_LOOK)</span>
<span class="line-added">942 </span>
<span class="line-added">943 void CachedResource::previewResponseReceived(const ResourceResponse&amp; response)</span>
<span class="line-added">944 {</span>
<span class="line-added">945     ASSERT(response.url().protocolIs(QLPreviewProtocol));</span>
<span class="line-added">946     CachedResource::responseReceived(response);</span>
<span class="line-added">947 }</span>
<span class="line-added">948 </span>
<span class="line-added">949 #endif</span>
<span class="line-added">950 </span>
951 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
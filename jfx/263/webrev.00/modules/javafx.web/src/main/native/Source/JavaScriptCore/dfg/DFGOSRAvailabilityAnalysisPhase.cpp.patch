diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp
@@ -33,15 +33,13 @@
 #include "DFGInsertionSet.h"
 #include "DFGPhase.h"
 #include "JSCInlines.h"
 
 namespace JSC { namespace DFG {
-namespace DFGOSRAvailabilityAnalysisPhaseInternal {
-static constexpr bool verbose = false;
-}
 
 class OSRAvailabilityAnalysisPhase : public Phase {
+    static constexpr bool verbose = false;
 public:
     OSRAvailabilityAnalysisPhase(Graph& graph)
         : Phase(graph, "OSR availability analysis")
     {
     }
@@ -73,12 +71,12 @@
 
         auto dumpBytecodeLivenessAtHead = [&] (BasicBlock* block) {
             dataLog("Live: ");
             m_graph.forAllLiveInBytecode(
                 block->at(0)->origin.forExit,
-                [&] (VirtualRegister reg) {
-                    dataLog(reg, " ");
+                [&] (Operand operand) {
+                    dataLog(operand, " ");
                 });
             dataLogLn("");
         };
 
         LocalOSRAvailabilityCalculator calculator(m_graph);
@@ -89,11 +87,11 @@
             for (BlockIndex blockIndex = 0; blockIndex < m_graph.numBlocks(); ++blockIndex) {
                 BasicBlock* block = m_graph.block(blockIndex);
                 if (!block)
                     continue;
 
-                if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {
+                if (verbose) {
                     dataLogLn("Before changing Block #", block->index);
                     dumpAvailability(block);
                 }
                 calculator.beginBlock(block);
 
@@ -104,11 +102,11 @@
                     continue;
 
                 block->ssa->availabilityAtTail = calculator.m_availability;
                 changed = true;
 
-                if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {
+                if (verbose) {
                     dataLogLn("After changing Block #", block->index);
                     dumpAvailability(block);
                 }
 
                 for (unsigned successorIndex = block->numSuccessors(); successorIndex--;) {
@@ -118,11 +116,11 @@
 
                 for (unsigned successorIndex = block->numSuccessors(); successorIndex--;) {
                     BasicBlock* successor = block->successor(successorIndex);
                     successor->ssa->availabilityAtHead.pruneByLiveness(
                         m_graph, successor->at(0)->origin.forExit);
-                    if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {
+                    if (verbose) {
                         dataLogLn("After pruning Block #", successor->index);
                         dumpAvailability(successor);
                         dumpBytecodeLivenessAtHead(successor);
                     }
                 }
@@ -206,53 +204,56 @@
 void LocalOSRAvailabilityCalculator::executeNode(Node* node)
 {
     switch (node->op()) {
     case PutStack: {
         StackAccessData* data = node->stackAccessData();
-        m_availability.m_locals.operand(data->local).setFlush(data->flushedAt());
+        m_availability.m_locals.operand(data->operand).setFlush(data->flushedAt());
         break;
     }
 
     case KillStack: {
-        m_availability.m_locals.operand(node->unlinkedLocal()).setFlush(FlushedAt(ConflictingFlush));
+        m_availability.m_locals.operand(node->unlinkedOperand()).setFlush(FlushedAt(ConflictingFlush));
         break;
     }
 
     case GetStack: {
         StackAccessData* data = node->stackAccessData();
-        m_availability.m_locals.operand(data->local) = Availability(node, data->flushedAt());
+        m_availability.m_locals.operand(data->operand) = Availability(node, data->flushedAt());
         break;
     }
 
     case MovHint: {
-        m_availability.m_locals.operand(node->unlinkedLocal()).setNode(node->child1().node());
+        m_availability.m_locals.operand(node->unlinkedOperand()).setNode(node->child1().node());
         break;
     }
 
     case ZombieHint: {
-        m_availability.m_locals.operand(node->unlinkedLocal()).setNodeUnavailable();
+        m_availability.m_locals.operand(node->unlinkedOperand()).setNodeUnavailable();
         break;
     }
 
     case InitializeEntrypointArguments: {
         unsigned entrypointIndex = node->entrypointIndex();
         const Vector<FlushFormat>& argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
         for (unsigned argument = argumentFormats.size(); argument--; ) {
-            FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgument(argument));
+            FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgumentIncludingThis(argument));
             m_availability.m_locals.argument(argument) = Availability(flushedAt);
         }
         break;
     }
 
+    case VarargsLength: {
+        break;
+    }
+
     case LoadVarargs:
     case ForwardVarargs: {
         LoadVarargsData* data = node->loadVarargsData();
-        m_availability.m_locals.operand(data->count) =
-            Availability(FlushedAt(FlushedInt32, data->machineCount));
+        m_availability.m_locals.operand(data->count) = Availability(FlushedAt(FlushedInt32, data->machineCount));
         for (unsigned i = data->limit; i--;) {
-            m_availability.m_locals.operand(VirtualRegister(data->start.offset() + i)) =
-                Availability(FlushedAt(FlushedJSValue, VirtualRegister(data->machineStart.offset() + i)));
+            m_availability.m_locals.operand(data->start + i) =
+                Availability(FlushedAt(FlushedJSValue, data->machineStart + i));
         }
         break;
     }
 
     case PhantomCreateRest:
@@ -270,24 +271,24 @@
             numberOfArgumentsToSkip = node->numberOfArgumentsToSkip();
 
         if (inlineCallFrame->isVarargs()) {
             // Record how to read each argument and the argument count.
             Availability argumentCount =
-                m_availability.m_locals.operand(inlineCallFrame->stackOffset + CallFrameSlot::argumentCount);
+                m_availability.m_locals.operand(VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis));
 
             m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
         }
 
         if (inlineCallFrame->isClosureCall) {
             Availability callee = m_availability.m_locals.operand(
-                inlineCallFrame->stackOffset + CallFrameSlot::callee);
+                VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee));
             m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
         }
 
-        for (unsigned i = numberOfArgumentsToSkip; i < inlineCallFrame->argumentCountIncludingThis - 1; ++i) {
+        for (unsigned i = numberOfArgumentsToSkip; i < static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1); ++i) {
             Availability argument = m_availability.m_locals.operand(
-                inlineCallFrame->stackOffset + CallFrame::argumentOffset(i));
+                VirtualRegister(inlineCallFrame->stackOffset + CallFrame::argumentOffset(i)));
 
             m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
         }
         break;
     }

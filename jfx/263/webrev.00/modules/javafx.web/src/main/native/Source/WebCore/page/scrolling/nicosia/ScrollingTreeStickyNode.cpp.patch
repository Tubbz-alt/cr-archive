diff a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeStickyNode.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeStickyNode.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeStickyNode.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeStickyNode.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (C) 2018 Igalia S.L.
+ * Copyright (C) 2012 Apple Inc. All rights reserved.
+ * Copyright (C) 2019 Igalia S.L.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -28,11 +29,19 @@
 #include "config.h"
 #include "ScrollingTreeStickyNode.h"
 
 #if ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)
 
+#include "Logging.h"
+#include "NicosiaPlatformLayer.h"
+#include "ScrollingStateStickyNode.h"
 #include "ScrollingTree.h"
+#include "ScrollingTreeFixedNode.h"
+#include "ScrollingTreeFrameScrollingNode.h"
+#include "ScrollingTreeOverflowScrollProxyNode.h"
+#include "ScrollingTreeOverflowScrollingNode.h"
+#include <wtf/text/TextStream.h>
 
 namespace WebCore {
 
 Ref<ScrollingTreeStickyNode> ScrollingTreeStickyNode::create(ScrollingTree& scrollingTree, ScrollingNodeID nodeID)
 {
@@ -48,16 +57,94 @@
 ScrollingTreeStickyNode::~ScrollingTreeStickyNode()
 {
     scrollingTree().fixedOrStickyNodeRemoved();
 }
 
-void ScrollingTreeStickyNode::commitStateBeforeChildren(const ScrollingStateNode&)
+void ScrollingTreeStickyNode::commitStateBeforeChildren(const ScrollingStateNode& stateNode)
 {
+    auto& stickyStateNode = downcast<ScrollingStateStickyNode>(stateNode);
+
+    if (stickyStateNode.hasChangedProperty(ScrollingStateNode::Layer)) {
+        auto* layer = static_cast<Nicosia::PlatformLayer*>(stickyStateNode.layer());
+        m_layer = downcast<Nicosia::CompositionLayer>(layer);
+    }
+
+    if (stickyStateNode.hasChangedProperty(ScrollingStateStickyNode::ViewportConstraints))
+        m_constraints = stickyStateNode.viewportConstraints();
 }
 
 void ScrollingTreeStickyNode::applyLayerPositions()
 {
+    auto layerPosition = computeLayerPosition();
+
+    LOG_WITH_STREAM(Scrolling, stream << "ScrollingTreeStickyNode " << scrollingNodeID() << " constrainingRectAtLastLayout " << m_constraints.constrainingRectAtLastLayout() << " last layer pos " << m_constraints.layerPositionAtLastLayout() << " layerPosition " << layerPosition);
+
+    layerPosition -= m_constraints.alignmentOffset();
+
+    ASSERT(m_layer);
+    m_layer->updateState(
+        [&layerPosition](Nicosia::CompositionLayer::LayerState& state)
+        {
+            state.position = layerPosition;
+            state.delta.positionChanged = true;
+        });
+}
+
+void ScrollingTreeStickyNode::dumpProperties(TextStream& ts, ScrollingStateTreeAsTextBehavior behavior) const
+{
+    ts << "sticky node";
+
+    ScrollingTreeNode::dumpProperties(ts, behavior);
+    ts.dumpProperty("sticky constraints", m_constraints);
+
+    if (behavior & ScrollingStateTreeAsTextBehaviorIncludeLayerPositions) {
+        FloatPoint layerTopLeft;
+        ASSERT(m_layer);
+        m_layer->accessCommitted(
+            [this, &layerTopLeft](Nicosia::CompositionLayer::LayerState& state)
+            {
+                layerTopLeft = state.position - toFloatSize(state.anchorPoint.xy()) * state.size + m_constraints.alignmentOffset();
+            });
+
+        ts.dumpProperty("layer top left", layerTopLeft);
+    }
+}
+
+FloatPoint ScrollingTreeStickyNode::computeLayerPosition() const
+{
+    auto computeLayerPositionForScrollingNode = [&](ScrollingTreeNode& scrollingNode) {
+        FloatRect constrainingRect;
+        if (is<ScrollingTreeFrameScrollingNode>(scrollingNode)) {
+            auto& frameScrollingNode = downcast<ScrollingTreeFrameScrollingNode>(scrollingNode);
+            constrainingRect = frameScrollingNode.layoutViewport();
+        } else {
+            auto& overflowScrollingNode = downcast<ScrollingTreeOverflowScrollingNode>(scrollingNode);
+            constrainingRect = FloatRect(overflowScrollingNode.currentScrollPosition(), m_constraints.constrainingRectAtLastLayout().size());
+        }
+        return m_constraints.layerPositionForConstrainingRect(constrainingRect);
+    };
+
+    for (auto* ancestor = parent(); ancestor; ancestor = ancestor->parent()) {
+        if (is<ScrollingTreeOverflowScrollProxyNode>(*ancestor)) {
+            auto& overflowProxyNode = downcast<ScrollingTreeOverflowScrollProxyNode>(*ancestor);
+            auto overflowNode = scrollingTree().nodeForID(overflowProxyNode.overflowScrollingNodeID());
+            if (!overflowNode)
+                break;
+
+            return computeLayerPositionForScrollingNode(*overflowNode);
+        }
+
+        if (is<ScrollingTreeScrollingNode>(*ancestor))
+            return computeLayerPositionForScrollingNode(*ancestor);
+
+        if (is<ScrollingTreeFixedNode>(*ancestor) || is<ScrollingTreeStickyNode>(*ancestor)) {
+            // FIXME: Do we need scrolling tree nodes at all for nested cases?
+            return m_constraints.layerPositionAtLastLayout();
+        }
+    }
+    ASSERT_NOT_REACHED();
+    return m_constraints.layerPositionAtLastLayout();
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(ASYNC_SCROLLING) && USE(NICOSIA)

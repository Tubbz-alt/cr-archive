<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakBlock.h&quot;
 28 
 29 #include &quot;CellContainerInlines.h&quot;
 30 #include &quot;Heap.h&quot;
 31 #include &quot;HeapAnalyzer.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSObject.h&quot;
 34 #include &quot;WeakHandleOwner.h&quot;
 35 
 36 namespace JSC {
 37 
<a name="1" id="anc1"></a><span class="line-added"> 38 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(WeakBlock);</span>
<span class="line-added"> 39 </span>
 40 WeakBlock* WeakBlock::create(Heap&amp; heap, CellContainer container)
 41 {
 42     heap.didAllocateBlock(WeakBlock::blockSize);
<a name="2" id="anc2"></a><span class="line-modified"> 43     return new (NotNull, WeakBlockMalloc::malloc(blockSize)) WeakBlock(container);</span>
<span class="line-added"> 44 </span>
 45 }
 46 
 47 void WeakBlock::destroy(Heap&amp; heap, WeakBlock* block)
 48 {
 49     block-&gt;~WeakBlock();
<a name="3" id="anc3"></a><span class="line-modified"> 50     WeakBlockMalloc::free(block);</span>
 51     heap.didFreeBlock(WeakBlock::blockSize);
 52 }
 53 
 54 WeakBlock::WeakBlock(CellContainer container)
 55     : DoublyLinkedListNode&lt;WeakBlock&gt;()
 56     , m_container(container)
 57 {
 58     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 59         WeakImpl* weakImpl = &amp;weakImpls()[i];
 60         new (NotNull, weakImpl) WeakImpl;
 61         addToFreeList(&amp;m_sweepResult.freeList, weakImpl);
 62     }
 63 
 64     ASSERT(isEmpty());
 65 }
 66 
 67 void WeakBlock::lastChanceToFinalize()
 68 {
 69     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 70         WeakImpl* weakImpl = &amp;weakImpls()[i];
 71         if (weakImpl-&gt;state() &gt;= WeakImpl::Finalized)
 72             continue;
 73         weakImpl-&gt;setState(WeakImpl::Dead);
 74         finalize(weakImpl);
 75     }
 76 }
 77 
 78 void WeakBlock::sweep()
 79 {
 80     // If a block is completely empty, a sweep won&#39;t have any effect.
 81     if (isEmpty())
 82         return;
 83 
 84     SweepResult sweepResult;
 85     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
 86         WeakImpl* weakImpl = &amp;weakImpls()[i];
 87         if (weakImpl-&gt;state() == WeakImpl::Dead)
 88             finalize(weakImpl);
 89         if (weakImpl-&gt;state() == WeakImpl::Deallocated)
 90             addToFreeList(&amp;sweepResult.freeList, weakImpl);
 91         else {
 92             sweepResult.blockIsFree = false;
 93             if (weakImpl-&gt;state() == WeakImpl::Live)
 94                 sweepResult.blockIsLogicallyEmpty = false;
 95         }
 96     }
 97 
 98     m_sweepResult = sweepResult;
 99     ASSERT(!m_sweepResult.isNull());
100 }
101 
102 template&lt;typename ContainerType&gt;
103 void WeakBlock::specializedVisit(ContainerType&amp; container, SlotVisitor&amp; visitor)
104 {
105     HeapVersion markingVersion = visitor.markingVersion();
106 
107     size_t count = weakImplCount();
108     for (size_t i = 0; i &lt; count; ++i) {
109         WeakImpl* weakImpl = &amp;weakImpls()[i];
110         if (weakImpl-&gt;state() != WeakImpl::Live)
111             continue;
112 
113         WeakHandleOwner* weakHandleOwner = weakImpl-&gt;weakHandleOwner();
114         if (!weakHandleOwner)
115             continue;
116 
117         JSValue jsValue = weakImpl-&gt;jsValue();
118         if (container.isMarked(markingVersion, jsValue.asCell()))
119             continue;
120 
121         const char* reason = &quot;&quot;;
122         const char** reasonPtr = nullptr;
123         if (UNLIKELY(visitor.isAnalyzingHeap()))
124             reasonPtr = &amp;reason;
125 
126         if (!weakHandleOwner-&gt;isReachableFromOpaqueRoots(Handle&lt;Unknown&gt;::wrapSlot(&amp;const_cast&lt;JSValue&amp;&gt;(jsValue)), weakImpl-&gt;context(), visitor, reasonPtr))
127             continue;
128 
129         visitor.appendUnbarriered(jsValue);
130 
131         if (UNLIKELY(visitor.isAnalyzingHeap())) {
132             if (jsValue.isCell())
133                 visitor.heapAnalyzer()-&gt;setOpaqueRootReachabilityReasonForCell(jsValue.asCell(), *reasonPtr);
134         }
135     }
136 }
137 
138 void WeakBlock::visit(SlotVisitor&amp; visitor)
139 {
140     // If a block is completely empty, a visit won&#39;t have any effect.
141     if (isEmpty())
142         return;
143 
144     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
145     ASSERT(m_container);
146 
<a name="4" id="anc4"></a><span class="line-modified">147     if (m_container.isPreciseAllocation())</span>
<span class="line-modified">148         specializedVisit(m_container.preciseAllocation(), visitor);</span>
149     else
150         specializedVisit(m_container.markedBlock(), visitor);
151 }
152 
153 void WeakBlock::reap()
154 {
155     // If a block is completely empty, a reaping won&#39;t have any effect.
156     if (isEmpty())
157         return;
158 
159     // If this WeakBlock doesn&#39;t belong to a CellContainer, we won&#39;t even be here.
160     ASSERT(m_container);
161 
162     HeapVersion markingVersion = m_container.heap()-&gt;objectSpace().markingVersion();
163 
164     for (size_t i = 0; i &lt; weakImplCount(); ++i) {
165         WeakImpl* weakImpl = &amp;weakImpls()[i];
166         if (weakImpl-&gt;state() &gt; WeakImpl::Dead)
167             continue;
168 
169         if (m_container.isMarked(markingVersion, weakImpl-&gt;jsValue().asCell())) {
170             ASSERT(weakImpl-&gt;state() == WeakImpl::Live);
171             continue;
172         }
173 
174         weakImpl-&gt;setState(WeakImpl::Dead);
175     }
176 }
177 
178 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilderBlock.h&quot;
 28 
 29 #include &quot;RenderButton.h&quot;
 30 #include &quot;RenderChildIterator.h&quot;
 31 #include &quot;RenderFullScreen.h&quot;
 32 #include &quot;RenderMultiColumnFlow.h&quot;
 33 #include &quot;RenderRuby.h&quot;
 34 #include &quot;RenderRubyRun.h&quot;
 35 #include &quot;RenderTextControl.h&quot;
 36 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static void moveAllChildrenToInternal(RenderBoxModelObject&amp; from, RenderElement&amp; newParent)
 41 {
 42     while (from.firstChild())
 43         newParent.attachRendererInternal(from.detachRendererInternal(*from.firstChild()), &amp;from);
 44 }
 45 
 46 static bool canDropAnonymousBlock(const RenderBlock&amp; anonymousBlock)
 47 {
 48     if (anonymousBlock.beingDestroyed() || anonymousBlock.continuation())
 49         return false;
 50     if (anonymousBlock.isRubyRun() || anonymousBlock.isRubyBase())
 51         return false;
 52     return true;
 53 }
 54 
 55 static bool canMergeContiguousAnonymousBlocks(RenderObject&amp; oldChild, RenderObject* previous, RenderObject* next)
 56 {
 57     ASSERT(!oldChild.renderTreeBeingDestroyed());
 58 
 59     if (oldChild.isInline())
 60         return false;
 61 
 62     if (is&lt;RenderBoxModelObject&gt;(oldChild) &amp;&amp; downcast&lt;RenderBoxModelObject&gt;(oldChild).continuation())
 63         return false;
 64 
 65     if (previous) {
 66         if (!previous-&gt;isAnonymousBlock())
 67             return false;
 68         RenderBlock&amp; previousAnonymousBlock = downcast&lt;RenderBlock&gt;(*previous);
 69         if (!canDropAnonymousBlock(previousAnonymousBlock))
 70             return false;
 71     }
 72     if (next) {
 73         if (!next-&gt;isAnonymousBlock())
 74             return false;
 75         RenderBlock&amp; nextAnonymousBlock = downcast&lt;RenderBlock&gt;(*next);
 76         if (!canDropAnonymousBlock(nextAnonymousBlock))
 77             return false;
 78     }
 79     return true;
 80 }
 81 
 82 static RenderBlock* continuationBefore(RenderBlock&amp; parent, RenderObject* beforeChild)
 83 {
 84     if (beforeChild &amp;&amp; beforeChild-&gt;parent() == &amp;parent)
 85         return &amp;parent;
 86 
 87     RenderBlock* nextToLast = &amp;parent;
 88     RenderBlock* last = &amp;parent;
 89     for (auto* current = downcast&lt;RenderBlock&gt;(parent.continuation()); current; current = downcast&lt;RenderBlock&gt;(current-&gt;continuation())) {
 90         if (beforeChild &amp;&amp; beforeChild-&gt;parent() == current) {
 91             if (current-&gt;firstChild() == beforeChild)
 92                 return last;
 93             return current;
 94         }
 95 
 96         nextToLast = last;
 97         last = current;
 98     }
 99 
100     if (!beforeChild &amp;&amp; !last-&gt;firstChild())
101         return nextToLast;
102     return last;
103 }
104 
105 RenderTreeBuilder::Block::Block(RenderTreeBuilder&amp; builder)
106     : m_builder(builder)
107 {
108 }
109 
110 void RenderTreeBuilder::Block::attach(RenderBlock&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
111 {
112     if (parent.continuation() &amp;&amp; !parent.isAnonymousBlock())
113         insertChildToContinuation(parent, WTFMove(child), beforeChild);
114     else
115         attachIgnoringContinuation(parent, WTFMove(child), beforeChild);
116 }
117 
118 void RenderTreeBuilder::Block::insertChildToContinuation(RenderBlock&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
119 {
120     RenderBlock* flow = continuationBefore(parent, beforeChild);
121     ASSERT(!beforeChild || is&lt;RenderBlock&gt;(*beforeChild-&gt;parent()));
122     RenderBoxModelObject* beforeChildParent = nullptr;
123     if (beforeChild)
124         beforeChildParent = downcast&lt;RenderBoxModelObject&gt;(beforeChild-&gt;parent());
125     else {
126         RenderBoxModelObject* continuation = flow-&gt;continuation();
127         if (continuation)
128             beforeChildParent = continuation;
129         else
130             beforeChildParent = flow;
131     }
132 
133     if (child-&gt;isFloatingOrOutOfFlowPositioned()) {
134         m_builder.attachIgnoringContinuation(*beforeChildParent, WTFMove(child), beforeChild);
135         return;
136     }
137 
138     bool childIsNormal = child-&gt;isInline() || child-&gt;style().columnSpan() == ColumnSpan::None;
139     bool bcpIsNormal = beforeChildParent-&gt;isInline() || beforeChildParent-&gt;style().columnSpan() == ColumnSpan::None;
140     bool flowIsNormal = flow-&gt;isInline() || flow-&gt;style().columnSpan() == ColumnSpan::None;
141 
142     if (flow == beforeChildParent) {
143         m_builder.attachIgnoringContinuation(*flow, WTFMove(child), beforeChild);
144         return;
145     }
146 
147     // The goal here is to match up if we can, so that we can coalesce and create the
148     // minimal # of continuations needed for the inline.
149     if (childIsNormal == bcpIsNormal) {
150         m_builder.attachIgnoringContinuation(*beforeChildParent, WTFMove(child), beforeChild);
151         return;
152     }
153     if (flowIsNormal == childIsNormal) {
154         m_builder.attachIgnoringContinuation(*flow, WTFMove(child)); // Just treat like an append.
155         return;
156     }
157     m_builder.attachIgnoringContinuation(*beforeChildParent, WTFMove(child), beforeChild);
158 }
159 
160 void RenderTreeBuilder::Block::attachIgnoringContinuation(RenderBlock&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
161 {
162     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;parent) {
163         RenderElement* beforeChildContainer = beforeChild-&gt;parent();
164         while (beforeChildContainer-&gt;parent() != &amp;parent)
165             beforeChildContainer = beforeChildContainer-&gt;parent();
166         ASSERT(beforeChildContainer);
167 
168         if (beforeChildContainer-&gt;isAnonymous()) {
<a name="1" id="anc1"></a><span class="line-added">169             if (beforeChildContainer-&gt;isInline() &amp;&amp; child-&gt;isInline()) {</span>
<span class="line-added">170                 // The before child happens to be a block level box wrapped in an anonymous inline-block in an inline context (e.g. ruby).</span>
<span class="line-added">171                 // Let&#39;s attach this new child before the anonymous inline-block wrapper.</span>
<span class="line-added">172                 ASSERT(beforeChildContainer-&gt;isInlineBlockOrInlineTable());</span>
<span class="line-added">173                 m_builder.attach(parent, WTFMove(child), beforeChildContainer);</span>
<span class="line-added">174                 return;</span>
<span class="line-added">175             }</span>
176             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!beforeChildContainer-&gt;isInline());
177 
178             // If the requested beforeChild is not one of our children, then this is because
179             // there is an anonymous container within this object that contains the beforeChild.
180             RenderElement* beforeChildAnonymousContainer = beforeChildContainer;
181             if (beforeChildAnonymousContainer-&gt;isAnonymousBlock()
182 #if ENABLE(FULLSCREEN_API)
183                 // Full screen renderers and full screen placeholders act as anonymous blocks, not tables:
184                 || beforeChildAnonymousContainer-&gt;isRenderFullScreen()
185                 || beforeChildAnonymousContainer-&gt;isRenderFullScreenPlaceholder()
186 #endif
187                 ) {
188                 // Insert the child into the anonymous block box instead of here.
189                 if (child-&gt;isInline() || beforeChild-&gt;parent()-&gt;firstChild() != beforeChild)
190                     m_builder.attach(*beforeChild-&gt;parent(), WTFMove(child), beforeChild);
191                 else
192                     m_builder.attach(parent, WTFMove(child), beforeChild-&gt;parent());
193                 return;
194             }
195 
196             ASSERT(beforeChildAnonymousContainer-&gt;isTable());
197 
198             if (child-&gt;isTablePart()) {
199                 // Insert into the anonymous table.
200                 m_builder.attach(*beforeChildAnonymousContainer, WTFMove(child), beforeChild);
201                 return;
202             }
203 
204             beforeChild = m_builder.splitAnonymousBoxesAroundChild(parent, *beforeChild);
205 
206             RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(beforeChild-&gt;parent() == &amp;parent);
207         }
208     }
209 
210     bool madeBoxesNonInline = false;
211 
212     // A block has to either have all of its children inline, or all of its children as blocks.
213     // So, if our children are currently inline and a block child has to be inserted, we move all our
214     // inline children into anonymous block boxes.
215     if (parent.childrenInline() &amp;&amp; !child-&gt;isInline() &amp;&amp; !child-&gt;isFloatingOrOutOfFlowPositioned()) {
216         // This is a block with inline content. Wrap the inline content in anonymous blocks.
217         m_builder.makeChildrenNonInline(parent, beforeChild);
218         madeBoxesNonInline = true;
219 
220         if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;parent) {
221             beforeChild = beforeChild-&gt;parent();
222             ASSERT(beforeChild-&gt;isAnonymousBlock());
223             ASSERT(beforeChild-&gt;parent() == &amp;parent);
224         }
225     } else if (!parent.childrenInline() &amp;&amp; (child-&gt;isFloatingOrOutOfFlowPositioned() || child-&gt;isInline())) {
226         // If we&#39;re inserting an inline child but all of our children are blocks, then we have to make sure
227         // it is put into an anomyous block box. We try to use an existing anonymous box if possible, otherwise
228         // a new one is created and inserted into our list of children in the appropriate position.
229         RenderObject* afterChild = beforeChild ? beforeChild-&gt;previousSibling() : parent.lastChild();
230 
231         if (afterChild &amp;&amp; afterChild-&gt;isAnonymousBlock()) {
232             m_builder.attach(downcast&lt;RenderBlock&gt;(*afterChild), WTFMove(child));
233             return;
234         }
235 
236         if (child-&gt;isInline()) {
237             // No suitable existing anonymous box - create a new one.
238             auto newBox = parent.createAnonymousBlock();
239             auto&amp; box = *newBox;
240             m_builder.attachToRenderElement(parent, WTFMove(newBox), beforeChild);
241             m_builder.attach(box, WTFMove(child));
242             return;
243         }
244     }
245 
246     parent.invalidateLineLayoutPath();
247 
248     m_builder.attachToRenderElement(parent, WTFMove(child), beforeChild);
249 
250     if (madeBoxesNonInline &amp;&amp; is&lt;RenderBlock&gt;(parent.parent()) &amp;&amp; parent.isAnonymousBlock())
251         removeLeftoverAnonymousBlock(parent);
252     // parent object may be dead here
253 }
254 
255 void RenderTreeBuilder::Block::childBecameNonInline(RenderBlock&amp; parent, RenderElement&amp;)
256 {
257     m_builder.makeChildrenNonInline(parent);
258     if (parent.isAnonymousBlock() &amp;&amp; is&lt;RenderBlock&gt;(parent.parent()))
259         removeLeftoverAnonymousBlock(parent);
260     // parent may be dead here
261 }
262 
263 void RenderTreeBuilder::Block::removeLeftoverAnonymousBlock(RenderBlock&amp; anonymousBlock)
264 {
265     ASSERT(anonymousBlock.isAnonymousBlock());
266     ASSERT(!anonymousBlock.childrenInline());
267     ASSERT(anonymousBlock.parent());
268 
269     if (anonymousBlock.continuation())
270         return;
271 
272     auto* parent = anonymousBlock.parent();
273     if (is&lt;RenderButton&gt;(*parent) || is&lt;RenderTextControl&gt;(*parent) || is&lt;RenderRubyAsBlock&gt;(*parent) || is&lt;RenderRubyRun&gt;(*parent))
274         return;
275 
276     // FIXME: This should really just be a moveAllChilrenTo (see webkit.org/b/182495)
277     moveAllChildrenToInternal(anonymousBlock, *parent);
278     auto toBeDestroyed = m_builder.detachFromRenderElement(*parent, anonymousBlock);
279     // anonymousBlock is dead here.
280 }
281 
282 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Block::detach(RenderBlock&amp; parent, RenderObject&amp; oldChild, CanCollapseAnonymousBlock canCollapseAnonymousBlock)
283 {
284     // No need to waste time in merging or removing empty anonymous blocks.
285     // We can just bail out if our document is getting destroyed.
286     if (parent.renderTreeBeingDestroyed())
287         return m_builder.detachFromRenderElement(parent, oldChild);
288 
289     // If this child is a block, and if our previous and next siblings are both anonymous blocks
290     // with inline content, then we can fold the inline content back together.
291     auto prev = makeWeakPtr(oldChild.previousSibling());
292     auto next = makeWeakPtr(oldChild.nextSibling());
293     bool canMergeAnonymousBlocks = canMergeContiguousAnonymousBlocks(oldChild, prev.get(), next.get());
294 
295     parent.invalidateLineLayoutPath();
296 
297     auto takenChild = m_builder.detachFromRenderElement(parent, oldChild);
298 
299     if (canMergeAnonymousBlocks &amp;&amp; prev &amp;&amp; next) {
300         prev-&gt;setNeedsLayoutAndPrefWidthsRecalc();
301         RenderBlock&amp; nextBlock = downcast&lt;RenderBlock&gt;(*next);
302         RenderBlock&amp; prevBlock = downcast&lt;RenderBlock&gt;(*prev);
303 
304         if (prev-&gt;childrenInline() != next-&gt;childrenInline()) {
305             RenderBlock&amp; inlineChildrenBlock = prev-&gt;childrenInline() ? prevBlock : nextBlock;
306             RenderBlock&amp; blockChildrenBlock = prev-&gt;childrenInline() ? nextBlock : prevBlock;
307 
308             // Place the inline children block inside of the block children block instead of deleting it.
309             // In order to reuse it, we have to reset it to just be a generic anonymous block. Make sure
310             // to clear out inherited column properties by just making a new style, and to also clear the
311             // column span flag if it is set.
312             ASSERT(!inlineChildrenBlock.continuation());
313             // Cache this value as it might get changed in setStyle() call.
314             inlineChildrenBlock.setStyle(RenderStyle::createAnonymousStyleWithDisplay(parent.style(), DisplayType::Block));
315             auto blockToMove = m_builder.detachFromRenderElement(parent, inlineChildrenBlock);
316 
317             // Now just put the inlineChildrenBlock inside the blockChildrenBlock.
318             RenderObject* beforeChild = prev == &amp;inlineChildrenBlock ? blockChildrenBlock.firstChild() : nullptr;
319             m_builder.attachToRenderElementInternal(blockChildrenBlock, WTFMove(blockToMove), beforeChild);
320             next-&gt;setNeedsLayoutAndPrefWidthsRecalc();
321 
322             // inlineChildrenBlock got reparented to blockChildrenBlock, so it is no longer a child
323             // of &quot;this&quot;. we null out prev or next so that is not used later in the function.
324             if (&amp;inlineChildrenBlock == &amp;prevBlock)
325                 prev = nullptr;
326             else
327                 next = nullptr;
328         } else {
329             // Take all the children out of the |next| block and put them in
330             // the |prev| block.
331             m_builder.moveAllChildrenIncludingFloats(nextBlock, prevBlock, RenderTreeBuilder::NormalizeAfterInsertion::No);
332 
333             // Delete the now-empty block&#39;s lines and nuke it.
334             nextBlock.deleteLines();
335             m_builder.destroy(nextBlock);
336         }
337     }
338 
339     if (canCollapseAnonymousBlock == CanCollapseAnonymousBlock::Yes &amp;&amp; parent.canDropAnonymousBlockChild()) {
340         RenderObject* child = prev ? prev.get() : next.get();
341         if (canMergeAnonymousBlocks &amp;&amp; child &amp;&amp; !child-&gt;previousSibling() &amp;&amp; !child-&gt;nextSibling()) {
342             // The removal has knocked us down to containing only a single anonymous box. We can pull the content right back up into our box.
343             dropAnonymousBoxChild(parent, downcast&lt;RenderBlock&gt;(*child));
344         } else if ((prev &amp;&amp; prev-&gt;isAnonymousBlock()) || (next &amp;&amp; next-&gt;isAnonymousBlock())) {
345             // It&#39;s possible that the removal has knocked us down to a single anonymous block with floating siblings.
346             RenderBlock&amp; anonBlock = downcast&lt;RenderBlock&gt;((prev &amp;&amp; prev-&gt;isAnonymousBlock()) ? *prev : *next);
347             if (canDropAnonymousBlock(anonBlock)) {
348                 bool dropAnonymousBlock = true;
349                 for (auto&amp; sibling : childrenOfType&lt;RenderObject&gt;(parent)) {
350                     if (&amp;sibling == &amp;anonBlock)
351                         continue;
352                     if (!sibling.isFloating()) {
353                         dropAnonymousBlock = false;
354                         break;
355                     }
356                 }
357                 if (dropAnonymousBlock)
358                     dropAnonymousBoxChild(parent, anonBlock);
359             }
360         }
361     }
362 
363     if (!parent.firstChild()) {
364         // If this was our last child be sure to clear out our line boxes.
365         if (parent.childrenInline())
366             parent.deleteLines();
367     }
368     return takenChild;
369 }
370 
371 void RenderTreeBuilder::Block::dropAnonymousBoxChild(RenderBlock&amp; parent, RenderBlock&amp; child)
372 {
373     parent.setNeedsLayoutAndPrefWidthsRecalc();
374     parent.setChildrenInline(child.childrenInline());
375     auto* nextSibling = child.nextSibling();
376 
377     auto toBeDeleted = m_builder.detachFromRenderElement(parent, child);
378     m_builder.moveAllChildren(child, parent, nextSibling, RenderTreeBuilder::NormalizeAfterInsertion::No);
379     // Delete the now-empty block&#39;s lines and nuke it.
380     child.deleteLines();
381 }
382 
383 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Block::detach(RenderBlockFlow&amp; parent, RenderObject&amp; child, CanCollapseAnonymousBlock canCollapseAnonymousBlock)
384 {
385     if (!parent.renderTreeBeingDestroyed()) {
386         auto* fragmentedFlow = parent.multiColumnFlow();
387         if (fragmentedFlow &amp;&amp; fragmentedFlow != &amp;child)
388             m_builder.multiColumnBuilder().multiColumnRelativeWillBeRemoved(*fragmentedFlow, child);
389     }
390     return detach(static_cast&lt;RenderBlock&amp;&gt;(parent), child, canCollapseAnonymousBlock);
391 }
392 
393 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmOpsHeader.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmWorklist.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="js/JSToWasm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmOpsHeader.py</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool has a couple of helpful macros to process Wasm files from the wasm.json.
 27 
 28 from generateWasm import *
 29 import optparse
 30 import sys
 31 
 32 parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;wasm.json&gt; &lt;WasmOps.h&gt;&quot;)
 33 (options, args) = parser.parse_args(sys.argv[0:])
 34 if len(args) != 3:
 35     parser.error(parser.usage)
 36 
 37 wasm = Wasm(args[0], args[1])
 38 types = wasm.types
 39 opcodes = wasm.opcodes
 40 wasmOpsHFile = open(args[2], &quot;w&quot;)
 41 
 42 
<span class="line-modified"> 43 def cppMacro(wasmOpcode, value, b3, inc):</span>
<span class="line-modified"> 44     return &quot; \\\n    macro(&quot; + wasm.toCpp(wasmOpcode) + &quot;, &quot; + hex(int(value)) + &quot;, &quot; + b3 + &quot;, &quot; + str(inc) + &quot;)&quot;</span>


 45 
 46 




 47 def typeMacroizer():
 48     inc = 0
 49     for ty in wasm.types:
 50         yield cppMacro(ty, wasm.types[ty][&quot;value&quot;], wasm.types[ty][&quot;b3type&quot;], inc)
 51         inc += 1
 52 
 53 type_definitions = [&quot;#define FOR_EACH_WASM_TYPE(macro)&quot;]
 54 type_definitions.extend([t for t in typeMacroizer()])
 55 type_definitions = &quot;&quot;.join(type_definitions)
 56 
 57 
<span class="line-modified"> 58 def opcodeMacroizer(filter, opcodeField=&quot;value&quot;):</span>
 59     inc = 0
 60     for op in wasm.opcodeIterator(filter):
 61         b3op = &quot;Oops&quot;
 62         if isSimple(op[&quot;opcode&quot;]):
 63             b3op = op[&quot;opcode&quot;][&quot;b3op&quot;]
<span class="line-modified"> 64         yield cppMacro(op[&quot;name&quot;], op[&quot;opcode&quot;][opcodeField], b3op, inc)</span>



 65         inc += 1
 66 



















 67 defines = [&quot;#define FOR_EACH_WASM_SPECIAL_OP(macro)&quot;]
 68 defines.extend([op for op in opcodeMacroizer(lambda op: not (isUnary(op) or isBinary(op) or op[&quot;category&quot;] == &quot;control&quot; or op[&quot;category&quot;] == &quot;memory&quot; or op[&quot;category&quot;] == &quot;exttable&quot;))])
 69 defines.append(&quot;\n\n#define FOR_EACH_WASM_CONTROL_FLOW_OP(macro)&quot;)
 70 defines.extend([op for op in opcodeMacroizer(lambda op: op[&quot;category&quot;] == &quot;control&quot;)])
 71 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="line-modified"> 72 defines.extend([op for op in opcodeMacroizer(lambda op: isUnary(op) and isSimple(op))])</span>
 73 defines.append(&quot;\n\n#define FOR_EACH_WASM_UNARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="line-modified"> 74 defines.extend([op for op in opcodeMacroizer(lambda op: isUnary(op) and not (isSimple(op)))])</span>
 75 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="line-modified"> 76 defines.extend([op for op in opcodeMacroizer(lambda op: isBinary(op) and isSimple(op))])</span>
 77 defines.append(&quot;\n\n#define FOR_EACH_WASM_BINARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="line-modified"> 78 defines.extend([op for op in opcodeMacroizer(lambda op: isBinary(op) and not (isSimple(op)))])</span>
 79 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_LOAD_OP(macro)&quot;)
<span class="line-modified"> 80 defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1))])</span>
 81 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_STORE_OP(macro)&quot;)
<span class="line-modified"> 82 defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0))])</span>
 83 defines.append(&quot;\n\n#define FOR_EACH_WASM_EXT_TABLE_OP(macro)&quot;)
<span class="line-modified"> 84 defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;exttable&quot;), &quot;extendedOp&quot;)])</span>
 85 defines.append(&quot;\n\n&quot;)
 86 
 87 defines = &quot;&quot;.join(defines)
 88 
 89 opValueSet = set([op for op in wasm.opcodeIterator(lambda op: True, lambda op: opcodes[op][&quot;value&quot;])])
 90 maxOpValue = max(opValueSet)
 91 
 92 
 93 # Luckily, python does floor division rather than trunc division so this works.
 94 def ceilDiv(a, b):
 95     return -(-a // b)
 96 
 97 
 98 def bitSet():
 99     v = &quot;&quot;
100     for i in range(ceilDiv(maxOpValue + 1, 8)):
101         entry = 0
102         for j in range(8):
103             if i * 8 + j in opValueSet:
104                 entry |= 1 &lt;&lt; j
</pre>
<hr />
<pre>
116 
117 memoryLog2AlignmentLoads = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1))
118 memoryLog2AlignmentStores = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0))
119 
120 
121 contents = wasm.header + &quot;&quot;&quot;
122 
123 #pragma once
124 
125 #if ENABLE(WEBASSEMBLY)
126 
127 #include &lt;cstdint&gt;
128 
129 namespace JSC { namespace Wasm {
130 
131 static constexpr unsigned expectedVersionNumber = &quot;&quot;&quot; + wasm.expectedVersionNumber + &quot;&quot;&quot;;
132 
133 static constexpr unsigned numTypes = &quot;&quot;&quot; + str(len(types)) + &quot;&quot;&quot;;
134 
135 &quot;&quot;&quot; + type_definitions + &quot;&quot;&quot;
<span class="line-modified">136 #define CREATE_ENUM_VALUE(name, id, b3type, inc) name = id,</span>
137 enum Type : int8_t {
138     FOR_EACH_WASM_TYPE(CREATE_ENUM_VALUE)
139 };
140 #undef CREATE_ENUM_VALUE
141 
<span class="line-modified">142 #define CREATE_CASE(name, id, b3type, inc) case id: return true;</span>
143 template &lt;typename Int&gt;
144 inline bool isValidType(Int i)
145 {
146     switch (i) {
147     default: return false;
148     FOR_EACH_WASM_TYPE(CREATE_CASE)
149     }
150     RELEASE_ASSERT_NOT_REACHED();
151     return false;
152 }
153 #undef CREATE_CASE
154 
<span class="line-modified">155 #define CREATE_CASE(name, id, b3type, inc) case name: return b3type;</span>
156 inline B3::Type toB3Type(Type type)
157 {
158     switch (type) {
159     FOR_EACH_WASM_TYPE(CREATE_CASE)
160     }
161     RELEASE_ASSERT_NOT_REACHED();
162     return B3::Void;
163 }
164 #undef CREATE_CASE
165 
<span class="line-modified">166 #define CREATE_CASE(name, id, b3type, inc) case name: return #name;</span>
167 inline const char* makeString(Type type)
168 {
169     switch (type) {
170     FOR_EACH_WASM_TYPE(CREATE_CASE)
171     }
172     RELEASE_ASSERT_NOT_REACHED();
173     return nullptr;
174 }
175 #undef CREATE_CASE
176 
<span class="line-modified">177 #define CREATE_CASE(name, id, b3type, inc) case id: return inc;</span>
178 inline int linearizeType(Type type)
179 {
180     switch (type) {
181     FOR_EACH_WASM_TYPE(CREATE_CASE)
182     }
183     RELEASE_ASSERT_NOT_REACHED();
184     return 0;
185 }
186 #undef CREATE_CASE
187 
<span class="line-modified">188 #define CREATE_CASE(name, id, b3type, inc) case inc: return name;</span>
189 inline Type linearizedToType(int i)
190 {
191     switch (i) {
192     FOR_EACH_WASM_TYPE(CREATE_CASE)
193     }
194     RELEASE_ASSERT_NOT_REACHED();
195     return Void;
196 }
197 #undef CREATE_CASE
198 
199 
200 &quot;&quot;&quot; + defines + &quot;&quot;&quot;
201 #define FOR_EACH_WASM_OP(macro) \\
202     FOR_EACH_WASM_SPECIAL_OP(macro) \\
203     FOR_EACH_WASM_CONTROL_FLOW_OP(macro) \\
204     FOR_EACH_WASM_UNARY_OP(macro) \\
205     FOR_EACH_WASM_BINARY_OP(macro) \\
206     FOR_EACH_WASM_MEMORY_LOAD_OP(macro) \\
207     FOR_EACH_WASM_MEMORY_STORE_OP(macro) \\
208     macro(ExtTable, 0xFC, Oops, 0)
209 
<span class="line-modified">210 #define CREATE_ENUM_VALUE(name, id, b3op, inc) name = id,</span>
211 
212 enum OpType : uint8_t {
213     FOR_EACH_WASM_OP(CREATE_ENUM_VALUE)
214 };
215 
216 template&lt;typename Int&gt;
217 inline bool isValidOpType(Int i)
218 {
219     // Bitset of valid ops.
220     static const uint8_t valid[] = { &quot;&quot;&quot; + validOps + &quot;&quot;&quot; };
221     return 0 &lt;= i &amp;&amp; i &lt;= &quot;&quot;&quot; + str(maxOpValue) + &quot;&quot;&quot; &amp;&amp; (valid[i / 8] &amp; (1 &lt;&lt; (i % 8)));
222 }
223 
224 enum class BinaryOpType : uint8_t {
225     FOR_EACH_WASM_BINARY_OP(CREATE_ENUM_VALUE)
226 };
227 
228 enum class UnaryOpType : uint8_t {
229     FOR_EACH_WASM_UNARY_OP(CREATE_ENUM_VALUE)
230 };
231 
232 enum class LoadOpType : uint8_t {
233     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_ENUM_VALUE)
234 };
235 
236 enum class StoreOpType : uint8_t {
237     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_ENUM_VALUE)
238 };
239 
240 enum class ExtTableOpType : uint8_t {
241     FOR_EACH_WASM_EXT_TABLE_OP(CREATE_ENUM_VALUE)
242 };
243 
244 #undef CREATE_ENUM_VALUE
245 
246 inline bool isControlOp(OpType op)
247 {
248     switch (op) {
<span class="line-modified">249 #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
250     FOR_EACH_WASM_CONTROL_FLOW_OP(CREATE_CASE)
251         return true;
252 #undef CREATE_CASE
253     default:
254         break;
255     }
256     return false;
257 }
258 
259 inline bool isSimple(UnaryOpType op)
260 {
261     switch (op) {
<span class="line-modified">262 #define CREATE_CASE(name, id, b3op, inc) case UnaryOpType::name:</span>
263     FOR_EACH_WASM_SIMPLE_UNARY_OP(CREATE_CASE)
264         return true;
265 #undef CREATE_CASE
266     default:
267         break;
268     }
269     return false;
270 }
271 
272 inline bool isSimple(BinaryOpType op)
273 {
274     switch (op) {
<span class="line-modified">275 #define CREATE_CASE(name, id, b3op, inc) case BinaryOpType::name:</span>
276     FOR_EACH_WASM_SIMPLE_BINARY_OP(CREATE_CASE)
277         return true;
278 #undef CREATE_CASE
279     default:
280         break;
281     }
282     return false;
283 }
284 
285 inline uint32_t memoryLog2Alignment(OpType op)
286 {
287     switch (op) {
288 &quot;&quot;&quot; + memoryLog2AlignmentLoads + &quot;&quot;&quot;
289 &quot;&quot;&quot; + memoryLog2AlignmentStores + &quot;&quot;&quot;
290     default:
291         break;
292     }
293     RELEASE_ASSERT_NOT_REACHED();
294     return 0;
295 }
296 
<span class="line-modified">297 #define CREATE_CASE(name, id, b3type, inc) case name: return #name;</span>
298 inline const char* makeString(OpType op)
299 {
300     switch (op) {
301     FOR_EACH_WASM_OP(CREATE_CASE)
302     }
303     RELEASE_ASSERT_NOT_REACHED();
304     return nullptr;
305 }
306 #undef CREATE_CASE
307 
308 } } // namespace JSC::Wasm
309 














310 #endif // ENABLE(WEBASSEMBLY)
311 
312 &quot;&quot;&quot;
313 
314 wasmOpsHFile.write(contents)
315 wasmOpsHFile.close()
</pre>
</td>
<td>
<hr />
<pre>
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool has a couple of helpful macros to process Wasm files from the wasm.json.
 27 
 28 from generateWasm import *
 29 import optparse
 30 import sys
 31 
 32 parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;wasm.json&gt; &lt;WasmOps.h&gt;&quot;)
 33 (options, args) = parser.parse_args(sys.argv[0:])
 34 if len(args) != 3:
 35     parser.error(parser.usage)
 36 
 37 wasm = Wasm(args[0], args[1])
 38 types = wasm.types
 39 opcodes = wasm.opcodes
 40 wasmOpsHFile = open(args[2], &quot;w&quot;)
 41 
 42 
<span class="line-modified"> 43 def cppType(type):</span>
<span class="line-modified"> 44     if type == &quot;bool&quot;:</span>
<span class="line-added"> 45         return &quot;I32&quot;</span>
<span class="line-added"> 46     return type.capitalize()</span>
 47 
 48 
<span class="line-added"> 49 def cppMacro(wasmOpcode, value, b3, inc, *extraArgs):</span>
<span class="line-added"> 50     extraArgsStr = &quot;, &quot; + &quot;, &quot;.join(extraArgs) if len(extraArgs) else &quot;&quot;</span>
<span class="line-added"> 51     return &quot; \\\n    macro(&quot; + wasm.toCpp(wasmOpcode) + &quot;, &quot; + hex(int(value)) + &quot;, &quot; + b3 + &quot;, &quot; + str(inc) + extraArgsStr + &quot;)&quot;</span>
<span class="line-added"> 52 </span>
 53 def typeMacroizer():
 54     inc = 0
 55     for ty in wasm.types:
 56         yield cppMacro(ty, wasm.types[ty][&quot;value&quot;], wasm.types[ty][&quot;b3type&quot;], inc)
 57         inc += 1
 58 
 59 type_definitions = [&quot;#define FOR_EACH_WASM_TYPE(macro)&quot;]
 60 type_definitions.extend([t for t in typeMacroizer()])
 61 type_definitions = &quot;&quot;.join(type_definitions)
 62 
 63 
<span class="line-modified"> 64 def opcodeMacroizer(filter, opcodeField=&quot;value&quot;, modifier=None):</span>
 65     inc = 0
 66     for op in wasm.opcodeIterator(filter):
 67         b3op = &quot;Oops&quot;
 68         if isSimple(op[&quot;opcode&quot;]):
 69             b3op = op[&quot;opcode&quot;][&quot;b3op&quot;]
<span class="line-modified"> 70         extraArgs = []</span>
<span class="line-added"> 71         if modifier:</span>
<span class="line-added"> 72             extraArgs = modifier(op[&quot;opcode&quot;])</span>
<span class="line-added"> 73         yield cppMacro(op[&quot;name&quot;], op[&quot;opcode&quot;][opcodeField], b3op, inc, *extraArgs)</span>
 74         inc += 1
 75 
<span class="line-added"> 76 </span>
<span class="line-added"> 77 def opcodeWithTypesMacroizer(filter):</span>
<span class="line-added"> 78     def modifier(op):</span>
<span class="line-added"> 79         return [cppType(type) for type in op[&quot;parameter&quot;] + op[&quot;return&quot;]]</span>
<span class="line-added"> 80     return opcodeMacroizer(filter, modifier=modifier)</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83 def memoryLoadMacroizer():</span>
<span class="line-added"> 84     def modifier(op):</span>
<span class="line-added"> 85         return [cppType(op[&quot;return&quot;][0])]</span>
<span class="line-added"> 86     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1), modifier=modifier)</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 def memoryStoreMacroizer():</span>
<span class="line-added"> 90     def modifier(op):</span>
<span class="line-added"> 91         return [cppType(op[&quot;parameter&quot;][1])]</span>
<span class="line-added"> 92     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0), modifier=modifier)</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94 </span>
 95 defines = [&quot;#define FOR_EACH_WASM_SPECIAL_OP(macro)&quot;]
 96 defines.extend([op for op in opcodeMacroizer(lambda op: not (isUnary(op) or isBinary(op) or op[&quot;category&quot;] == &quot;control&quot; or op[&quot;category&quot;] == &quot;memory&quot; or op[&quot;category&quot;] == &quot;exttable&quot;))])
 97 defines.append(&quot;\n\n#define FOR_EACH_WASM_CONTROL_FLOW_OP(macro)&quot;)
 98 defines.extend([op for op in opcodeMacroizer(lambda op: op[&quot;category&quot;] == &quot;control&quot;)])
 99 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="line-modified">100 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and isSimple(op))])</span>
101 defines.append(&quot;\n\n#define FOR_EACH_WASM_UNARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<span class="line-modified">102 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and not (isSimple(op)))])</span>
103 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="line-modified">104 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and isSimple(op))])</span>
105 defines.append(&quot;\n\n#define FOR_EACH_WASM_BINARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<span class="line-modified">106 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and not (isSimple(op)))])</span>
107 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_LOAD_OP(macro)&quot;)
<span class="line-modified">108 defines.extend([op for op in memoryLoadMacroizer()])</span>
109 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_STORE_OP(macro)&quot;)
<span class="line-modified">110 defines.extend([op for op in memoryStoreMacroizer()])</span>
111 defines.append(&quot;\n\n#define FOR_EACH_WASM_EXT_TABLE_OP(macro)&quot;)
<span class="line-modified">112 defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;exttable&quot;), opcodeField=&quot;extendedOp&quot;)])</span>
113 defines.append(&quot;\n\n&quot;)
114 
115 defines = &quot;&quot;.join(defines)
116 
117 opValueSet = set([op for op in wasm.opcodeIterator(lambda op: True, lambda op: opcodes[op][&quot;value&quot;])])
118 maxOpValue = max(opValueSet)
119 
120 
121 # Luckily, python does floor division rather than trunc division so this works.
122 def ceilDiv(a, b):
123     return -(-a // b)
124 
125 
126 def bitSet():
127     v = &quot;&quot;
128     for i in range(ceilDiv(maxOpValue + 1, 8)):
129         entry = 0
130         for j in range(8):
131             if i * 8 + j in opValueSet:
132                 entry |= 1 &lt;&lt; j
</pre>
<hr />
<pre>
144 
145 memoryLog2AlignmentLoads = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1))
146 memoryLog2AlignmentStores = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0))
147 
148 
149 contents = wasm.header + &quot;&quot;&quot;
150 
151 #pragma once
152 
153 #if ENABLE(WEBASSEMBLY)
154 
155 #include &lt;cstdint&gt;
156 
157 namespace JSC { namespace Wasm {
158 
159 static constexpr unsigned expectedVersionNumber = &quot;&quot;&quot; + wasm.expectedVersionNumber + &quot;&quot;&quot;;
160 
161 static constexpr unsigned numTypes = &quot;&quot;&quot; + str(len(types)) + &quot;&quot;&quot;;
162 
163 &quot;&quot;&quot; + type_definitions + &quot;&quot;&quot;
<span class="line-modified">164 #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
165 enum Type : int8_t {
166     FOR_EACH_WASM_TYPE(CREATE_ENUM_VALUE)
167 };
168 #undef CREATE_ENUM_VALUE
169 
<span class="line-modified">170 #define CREATE_CASE(name, id, ...) case id: return true;</span>
171 template &lt;typename Int&gt;
172 inline bool isValidType(Int i)
173 {
174     switch (i) {
175     default: return false;
176     FOR_EACH_WASM_TYPE(CREATE_CASE)
177     }
178     RELEASE_ASSERT_NOT_REACHED();
179     return false;
180 }
181 #undef CREATE_CASE
182 
<span class="line-modified">183 #define CREATE_CASE(name, id, b3type, ...) case name: return b3type;</span>
184 inline B3::Type toB3Type(Type type)
185 {
186     switch (type) {
187     FOR_EACH_WASM_TYPE(CREATE_CASE)
188     }
189     RELEASE_ASSERT_NOT_REACHED();
190     return B3::Void;
191 }
192 #undef CREATE_CASE
193 
<span class="line-modified">194 #define CREATE_CASE(name, ...) case name: return #name;</span>
195 inline const char* makeString(Type type)
196 {
197     switch (type) {
198     FOR_EACH_WASM_TYPE(CREATE_CASE)
199     }
200     RELEASE_ASSERT_NOT_REACHED();
201     return nullptr;
202 }
203 #undef CREATE_CASE
204 
<span class="line-modified">205 #define CREATE_CASE(name, id, b3type, inc, ...) case id: return inc;</span>
206 inline int linearizeType(Type type)
207 {
208     switch (type) {
209     FOR_EACH_WASM_TYPE(CREATE_CASE)
210     }
211     RELEASE_ASSERT_NOT_REACHED();
212     return 0;
213 }
214 #undef CREATE_CASE
215 
<span class="line-modified">216 #define CREATE_CASE(name, id, b3type, inc, ...) case inc: return name;</span>
217 inline Type linearizedToType(int i)
218 {
219     switch (i) {
220     FOR_EACH_WASM_TYPE(CREATE_CASE)
221     }
222     RELEASE_ASSERT_NOT_REACHED();
223     return Void;
224 }
225 #undef CREATE_CASE
226 
227 
228 &quot;&quot;&quot; + defines + &quot;&quot;&quot;
229 #define FOR_EACH_WASM_OP(macro) \\
230     FOR_EACH_WASM_SPECIAL_OP(macro) \\
231     FOR_EACH_WASM_CONTROL_FLOW_OP(macro) \\
232     FOR_EACH_WASM_UNARY_OP(macro) \\
233     FOR_EACH_WASM_BINARY_OP(macro) \\
234     FOR_EACH_WASM_MEMORY_LOAD_OP(macro) \\
235     FOR_EACH_WASM_MEMORY_STORE_OP(macro) \\
236     macro(ExtTable, 0xFC, Oops, 0)
237 
<span class="line-modified">238 #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
239 
240 enum OpType : uint8_t {
241     FOR_EACH_WASM_OP(CREATE_ENUM_VALUE)
242 };
243 
244 template&lt;typename Int&gt;
245 inline bool isValidOpType(Int i)
246 {
247     // Bitset of valid ops.
248     static const uint8_t valid[] = { &quot;&quot;&quot; + validOps + &quot;&quot;&quot; };
249     return 0 &lt;= i &amp;&amp; i &lt;= &quot;&quot;&quot; + str(maxOpValue) + &quot;&quot;&quot; &amp;&amp; (valid[i / 8] &amp; (1 &lt;&lt; (i % 8)));
250 }
251 
252 enum class BinaryOpType : uint8_t {
253     FOR_EACH_WASM_BINARY_OP(CREATE_ENUM_VALUE)
254 };
255 
256 enum class UnaryOpType : uint8_t {
257     FOR_EACH_WASM_UNARY_OP(CREATE_ENUM_VALUE)
258 };
259 
260 enum class LoadOpType : uint8_t {
261     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_ENUM_VALUE)
262 };
263 
264 enum class StoreOpType : uint8_t {
265     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_ENUM_VALUE)
266 };
267 
268 enum class ExtTableOpType : uint8_t {
269     FOR_EACH_WASM_EXT_TABLE_OP(CREATE_ENUM_VALUE)
270 };
271 
272 #undef CREATE_ENUM_VALUE
273 
274 inline bool isControlOp(OpType op)
275 {
276     switch (op) {
<span class="line-modified">277 #define CREATE_CASE(name, ...) case OpType::name:</span>
278     FOR_EACH_WASM_CONTROL_FLOW_OP(CREATE_CASE)
279         return true;
280 #undef CREATE_CASE
281     default:
282         break;
283     }
284     return false;
285 }
286 
287 inline bool isSimple(UnaryOpType op)
288 {
289     switch (op) {
<span class="line-modified">290 #define CREATE_CASE(name, ...) case UnaryOpType::name:</span>
291     FOR_EACH_WASM_SIMPLE_UNARY_OP(CREATE_CASE)
292         return true;
293 #undef CREATE_CASE
294     default:
295         break;
296     }
297     return false;
298 }
299 
300 inline bool isSimple(BinaryOpType op)
301 {
302     switch (op) {
<span class="line-modified">303 #define CREATE_CASE(name, ...) case BinaryOpType::name:</span>
304     FOR_EACH_WASM_SIMPLE_BINARY_OP(CREATE_CASE)
305         return true;
306 #undef CREATE_CASE
307     default:
308         break;
309     }
310     return false;
311 }
312 
313 inline uint32_t memoryLog2Alignment(OpType op)
314 {
315     switch (op) {
316 &quot;&quot;&quot; + memoryLog2AlignmentLoads + &quot;&quot;&quot;
317 &quot;&quot;&quot; + memoryLog2AlignmentStores + &quot;&quot;&quot;
318     default:
319         break;
320     }
321     RELEASE_ASSERT_NOT_REACHED();
322     return 0;
323 }
324 
<span class="line-modified">325 #define CREATE_CASE(name, ...) case name: return #name;</span>
326 inline const char* makeString(OpType op)
327 {
328     switch (op) {
329     FOR_EACH_WASM_OP(CREATE_CASE)
330     }
331     RELEASE_ASSERT_NOT_REACHED();
332     return nullptr;
333 }
334 #undef CREATE_CASE
335 
336 } } // namespace JSC::Wasm
337 
<span class="line-added">338 namespace WTF {</span>
<span class="line-added">339 </span>
<span class="line-added">340 inline void printInternal(PrintStream&amp; out, JSC::Wasm::Type type)</span>
<span class="line-added">341 {</span>
<span class="line-added">342     out.print(JSC::Wasm::makeString(type));</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 inline void printInternal(PrintStream&amp; out, JSC::Wasm::OpType op)</span>
<span class="line-added">346 {</span>
<span class="line-added">347     out.print(JSC::Wasm::makeString(op));</span>
<span class="line-added">348 }</span>
<span class="line-added">349 </span>
<span class="line-added">350 } // namespace WTF</span>
<span class="line-added">351 </span>
352 #endif // ENABLE(WEBASSEMBLY)
353 
354 &quot;&quot;&quot;
355 
356 wasmOpsHFile.write(contents)
357 wasmOpsHFile.close()
</pre>
</td>
</tr>
</table>
<center><a href="WasmWorklist.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="js/JSToWasm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
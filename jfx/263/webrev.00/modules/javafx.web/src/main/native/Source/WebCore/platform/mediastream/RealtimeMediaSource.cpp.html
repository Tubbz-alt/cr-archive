<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/RealtimeMediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2012 Google Inc. All rights reserved.
   3  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
   5  * Copyright (C) 2015 Ericsson AB. All rights reserved.
   6  *
   7  * Redistribution and use in source and binary forms, with or without
   8  * modification, are permitted provided that the following conditions
   9  * are met:
  10  *
  11  * 1. Redistributions of source code must retain the above copyright
  12  *    notice, this list of conditions and the following disclaimer.
  13  * 2. Redistributions in binary form must reproduce the above copyright
  14  *    notice, this list of conditions and the following disclaimer
  15  *    in the documentation and/or other materials provided with the
  16  *    distribution.
  17  * 3. Neither the name of Google Inc. nor the names of its contributors
  18  *    may be used to endorse or promote products derived from this
  19  *    software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  22  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  23  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  24  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  25  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  26  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  27  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  28  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  29  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  30  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  31  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32  */
  33 
  34 #include &quot;config.h&quot;
  35 
  36 #if ENABLE(MEDIA_STREAM)
  37 #include &quot;RealtimeMediaSource.h&quot;
  38 
  39 #include &quot;Logging.h&quot;
  40 #include &quot;MediaConstraints.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;RealtimeMediaSourceCapabilities.h&quot;
  43 #include &quot;RealtimeMediaSourceCenter.h&quot;
  44 #include &lt;wtf/CompletionHandler.h&gt;
  45 #include &lt;wtf/MainThread.h&gt;
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/StringHash.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 RealtimeMediaSource::RealtimeMediaSource(Type type, String&amp;&amp; name, String&amp;&amp; deviceID, String&amp;&amp; hashSalt)
  52     : m_idHashSalt(WTFMove(hashSalt))
  53     , m_persistentID(WTFMove(deviceID))
  54     , m_type(type)
  55     , m_name(WTFMove(name))
  56 {
  57     if (m_persistentID.isEmpty())
  58         m_persistentID = createCanonicalUUIDString();
  59 
  60     m_hashedID = RealtimeMediaSourceCenter::singleton().hashStringWithSalt(m_persistentID, m_idHashSalt);
  61 }
  62 
  63 void RealtimeMediaSource::addObserver(RealtimeMediaSource::Observer&amp; observer)
  64 {
  65     auto locker = holdLock(m_observersLock);
  66     m_observers.add(&amp;observer);
  67 }
  68 
  69 void RealtimeMediaSource::removeObserver(RealtimeMediaSource::Observer&amp; observer)
  70 {
  71     auto locker = holdLock(m_observersLock);
  72     m_observers.remove(&amp;observer);
  73     if (m_observers.isEmpty())
  74         stopBeingObserved();
  75 }
  76 
  77 void RealtimeMediaSource::setInterrupted(bool interrupted, bool pageMuted)
  78 {
  79     if (interrupted == m_interrupted)
  80         return;
  81 
  82     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, interrupted, &quot;, page muted : &quot;, pageMuted);
  83 
  84     m_interrupted = interrupted;
  85     if (!interrupted &amp;&amp; pageMuted)
  86         return;
  87 
  88     setMuted(interrupted);
  89 }
  90 
  91 void RealtimeMediaSource::setMuted(bool muted)
  92 {
  93     if (!muted &amp;&amp; interrupted()) {
  94         ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, &quot;ignoring unmute because of interruption&quot;);
  95         return;
  96     }
  97 
  98     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);
  99 
 100     // Changed m_muted before calling start/stop so muted() will reflect the correct state.
 101     bool changed = m_muted != muted;
 102     m_muted = muted;
 103     if (muted)
 104         stop();
 105     else
 106         start();
 107 
 108     if (changed)
 109         notifyMutedObservers();
 110 }
 111 
 112 void RealtimeMediaSource::notifyMutedChange(bool muted)
 113 {
 114     if (m_muted == muted)
 115         return;
 116 
 117     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, muted);
 118     m_muted = muted;
 119 
 120     notifyMutedObservers();
 121 }
 122 
 123 void RealtimeMediaSource::setInterruptedForTesting(bool interrupted)
 124 {
 125     notifyMutedChange(interrupted);
 126 }
 127 
 128 void RealtimeMediaSource::forEachObserver(const WTF::Function&lt;void(Observer&amp;)&gt;&amp; apply) const
 129 {
 130     Vector&lt;Observer*&gt; observersCopy;
 131     {
 132         auto locker = holdLock(m_observersLock);
 133         observersCopy = copyToVector(m_observers);
 134     }
 135     for (auto* observer : observersCopy) {
 136         auto locker = holdLock(m_observersLock);
 137         // Make sure the observer has not been destroyed.
 138         if (!m_observers.contains(observer))
 139             continue;
 140         apply(*observer);
 141     }
 142 }
 143 
 144 void RealtimeMediaSource::notifyMutedObservers() const
 145 {
 146     forEachObserver([](auto&amp; observer) {
 147         observer.sourceMutedChanged();
 148     });
 149 }
 150 
 151 void RealtimeMediaSource::notifySettingsDidChangeObservers(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; flags)
 152 {
 153     ASSERT(isMainThread());
 154 
 155     settingsDidChange(flags);
 156 
 157     if (m_pendingSettingsDidChangeNotification)
 158         return;
 159     m_pendingSettingsDidChangeNotification = true;
 160 
 161     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, flags);
 162 
 163     scheduleDeferredTask([this] {
 164         m_pendingSettingsDidChangeNotification = false;
 165         forEachObserver([](auto&amp; observer) {
 166             observer.sourceSettingsChanged();
 167         });
 168     });
 169 }
 170 
 171 void RealtimeMediaSource::videoSampleAvailable(MediaSample&amp; mediaSample)
 172 {
 173 #if !RELEASE_LOG_DISABLED
 174     ++m_frameCount;
 175 
 176     auto timestamp = MonotonicTime::now();
 177     auto delta = timestamp - m_lastFrameLogTime;
 178     if (!m_lastFrameLogTime || delta &gt;= 1_s) {
 179         if (m_lastFrameLogTime) {
 180             INFO_LOG_IF(loggerPtr(), LOGIDENTIFIER, m_frameCount, &quot; frames sent in &quot;, delta.value(), &quot; seconds&quot;);
 181             m_frameCount = 0;
 182         }
 183         m_lastFrameLogTime = timestamp;
 184     }
 185 #endif
 186 
 187     forEachObserver([&amp;](auto&amp; observer) {
 188         observer.videoSampleAvailable(mediaSample);
 189     });
 190 }
 191 
 192 void RealtimeMediaSource::audioSamplesAvailable(const MediaTime&amp; time, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t numberOfFrames)
 193 {
 194     forEachObserver([&amp;](auto&amp; observer) {
 195         observer.audioSamplesAvailable(time, audioData, description, numberOfFrames);
 196     });
 197 }
 198 
 199 void RealtimeMediaSource::start()
 200 {
 201     if (m_isProducingData || m_isEnded)
 202         return;
 203 
 204     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 205 
 206     m_isProducingData = true;
 207     startProducingData();
 208 
 209     if (!m_isProducingData)
 210         return;
 211 
 212     forEachObserver([](auto&amp; observer) {
 213         observer.sourceStarted();
 214     });
 215 }
 216 
 217 void RealtimeMediaSource::stop()
 218 {
 219     if (!m_isProducingData)
 220         return;
 221 
 222     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 223 
 224     m_isProducingData = false;
 225     stopProducingData();
 226 }
 227 
 228 void RealtimeMediaSource::requestToEnd(Observer&amp; callingObserver)
 229 {
 230     if (!m_isProducingData)
 231         return;
 232 
 233     bool hasObserverPreventingStopping = false;
 234     forEachObserver([&amp;](auto&amp; observer) {
 235         if (observer.preventSourceFromStopping())
 236             hasObserverPreventingStopping = true;
 237     });
 238     if (hasObserverPreventingStopping)
 239         return;
 240 
 241     auto protectedThis = makeRef(*this);
 242 
 243     stop();
 244     m_isEnded = true;
 245     hasEnded();
 246 
 247     forEachObserver([callingObserver](auto&amp; observer) {
 248         if (&amp;observer != &amp;callingObserver)
 249             observer.sourceStopped();
 250     });
 251 }
 252 
 253 void RealtimeMediaSource::captureFailed()
 254 {
 255     ERROR_LOG_IF(m_logger, LOGIDENTIFIER);
 256 
 257     m_isProducingData = false;
 258     m_captureDidFailed = true;
 259 
 260     forEachObserver([](auto&amp; observer) {
 261         observer.sourceStopped();
 262     });
 263 }
 264 
 265 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;int&gt;, Optional&lt;int&gt;, Optional&lt;double&gt;)
 266 {
 267     // The size and frame rate are within the capability limits, so they are supported.
 268     return true;
 269 }
 270 
 271 bool RealtimeMediaSource::supportsSizeAndFrameRate(Optional&lt;IntConstraint&gt; widthConstraint, Optional&lt;IntConstraint&gt; heightConstraint, Optional&lt;DoubleConstraint&gt; frameRateConstraint, String&amp; badConstraint, double&amp; distance)
 272 {
 273     if (!widthConstraint &amp;&amp; !heightConstraint &amp;&amp; !frameRateConstraint)
 274         return true;
 275 
 276     auto&amp; capabilities = this-&gt;capabilities();
 277 
 278     distance = std::numeric_limits&lt;double&gt;::infinity();
 279 
 280     Optional&lt;int&gt; width;
 281     if (widthConstraint &amp;&amp; capabilities.supportsWidth()) {
 282         double constraintDistance = fitnessDistance(*widthConstraint);
 283         if (std::isinf(constraintDistance)) {
 284             badConstraint = widthConstraint-&gt;name();
 285             return false;
 286         }
 287 
 288         distance = std::min(distance, constraintDistance);
 289         if (widthConstraint-&gt;isMandatory()) {
 290             auto range = capabilities.width();
 291             width = widthConstraint-&gt;valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 292         }
 293     }
 294 
 295     Optional&lt;int&gt; height;
 296     if (heightConstraint &amp;&amp; capabilities.supportsHeight()) {
 297         double constraintDistance = fitnessDistance(*heightConstraint);
 298         if (std::isinf(constraintDistance)) {
 299             badConstraint = heightConstraint-&gt;name();
 300             return false;
 301         }
 302 
 303         distance = std::min(distance, constraintDistance);
 304         if (heightConstraint-&gt;isMandatory()) {
 305             auto range = capabilities.height();
 306             height = heightConstraint-&gt;valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 307         }
 308     }
 309 
 310     Optional&lt;double&gt; frameRate;
 311     if (frameRateConstraint &amp;&amp; capabilities.supportsFrameRate()) {
 312         double constraintDistance = fitnessDistance(*frameRateConstraint);
 313         if (std::isinf(constraintDistance)) {
 314             badConstraint = frameRateConstraint-&gt;name();
 315             return false;
 316         }
 317 
 318         distance = std::min(distance, constraintDistance);
 319         if (frameRateConstraint-&gt;isMandatory()) {
 320             auto range = capabilities.frameRate();
 321             frameRate = frameRateConstraint-&gt;valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 322         }
 323     }
 324 
 325     // Each of the non-null values is supported individually, see if they all can be applied at the same time.
 326     if (!supportsSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate))) {
 327         if (widthConstraint)
 328             badConstraint = widthConstraint-&gt;name();
 329         else if (heightConstraint)
 330             badConstraint = heightConstraint-&gt;name();
 331         else
 332             badConstraint = frameRateConstraint-&gt;name();
 333         return false;
 334     }
 335 
 336     return true;
 337 }
 338 
 339 double RealtimeMediaSource::fitnessDistance(const MediaConstraint&amp; constraint)
 340 {
 341     auto&amp; capabilities = this-&gt;capabilities();
 342 
 343     switch (constraint.constraintType()) {
 344     case MediaConstraintType::Width: {
 345         ASSERT(constraint.isInt());
 346         if (!capabilities.supportsWidth())
 347             return 0;
 348 
 349         auto range = capabilities.width();
 350         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 351         break;
 352     }
 353 
 354     case MediaConstraintType::Height: {
 355         ASSERT(constraint.isInt());
 356         if (!capabilities.supportsHeight())
 357             return 0;
 358 
 359         auto range = capabilities.height();
 360         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 361         break;
 362     }
 363 
 364     case MediaConstraintType::FrameRate: {
 365         ASSERT(constraint.isDouble());
 366         if (!capabilities.supportsFrameRate())
 367             return 0;
 368 
 369         auto range = capabilities.frameRate();
 370         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 371         break;
 372     }
 373 
 374     case MediaConstraintType::AspectRatio: {
 375         ASSERT(constraint.isDouble());
 376         if (!capabilities.supportsAspectRatio())
 377             return 0;
 378 
 379         auto range = capabilities.aspectRatio();
 380         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 381         break;
 382     }
 383 
 384     case MediaConstraintType::Volume: {
 385         ASSERT(constraint.isDouble());
 386         if (!capabilities.supportsVolume())
 387             return 0;
 388 
 389         auto range = capabilities.volume();
 390         return downcast&lt;DoubleConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asDouble, range.rangeMax().asDouble);
 391         break;
 392     }
 393 
 394     case MediaConstraintType::SampleRate: {
 395         ASSERT(constraint.isInt());
 396         if (!capabilities.supportsSampleRate())
 397             return 0;
 398 
 399         if (auto discreteRates = discreteSampleRates())
 400             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteRates);
 401 
 402         auto range = capabilities.sampleRate();
 403         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 404         break;
 405     }
 406 
 407     case MediaConstraintType::SampleSize: {
 408         ASSERT(constraint.isInt());
 409         if (!capabilities.supportsSampleSize())
 410             return 0;
 411 
 412         if (auto discreteSizes = discreteSampleSizes())
 413             return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(*discreteSizes);
 414 
 415         auto range = capabilities.sampleSize();
 416         return downcast&lt;IntConstraint&gt;(constraint).fitnessDistance(range.rangeMin().asInt, range.rangeMax().asInt);
 417         break;
 418     }
 419 
 420     case MediaConstraintType::FacingMode: {
 421         ASSERT(constraint.isString());
 422         if (!capabilities.supportsFacingMode())
 423             return 0;
 424 
 425         auto&amp; modes = capabilities.facingMode();
 426         Vector&lt;String&gt; supportedModes;
 427         supportedModes.reserveInitialCapacity(modes.size());
 428         for (auto&amp; mode : modes)
 429             supportedModes.uncheckedAppend(RealtimeMediaSourceSettings::facingMode(mode));
 430         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(supportedModes);
 431         break;
 432     }
 433 
 434     case MediaConstraintType::EchoCancellation: {
 435         ASSERT(constraint.isBoolean());
 436         if (!capabilities.supportsEchoCancellation())
 437             return 0;
 438 
 439         bool echoCancellationReadWrite = capabilities.echoCancellation() == RealtimeMediaSourceCapabilities::EchoCancellation::ReadWrite;
 440         return downcast&lt;BooleanConstraint&gt;(constraint).fitnessDistance(echoCancellationReadWrite);
 441         break;
 442     }
 443 
 444     case MediaConstraintType::DeviceId:
 445         ASSERT(!m_hashedID.isEmpty());
 446         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(m_hashedID);
 447         break;
 448 
 449     case MediaConstraintType::GroupId: {
 450         ASSERT(constraint.isString());
 451         if (!capabilities.supportsDeviceId())
 452             return 0;
 453 
 454         return downcast&lt;StringConstraint&gt;(constraint).fitnessDistance(settings().groupId());
 455         break;
 456     }
 457 
 458     case MediaConstraintType::DisplaySurface:
 459     case MediaConstraintType::LogicalSurface:
 460         break;
 461 
 462     case MediaConstraintType::Unknown:
 463         // Unknown (or unsupported) constraints should be ignored.
 464         break;
 465     }
 466 
 467     return 0;
 468 }
 469 
 470 template &lt;typename ValueType&gt;
 471 static void applyNumericConstraint(const NumericConstraint&lt;ValueType&gt;&amp; constraint, ValueType current, Optional&lt;Vector&lt;ValueType&gt;&gt; discreteCapabilityValues, ValueType capabilityMin, ValueType capabilityMax, RealtimeMediaSource&amp; source, void (RealtimeMediaSource::*applier)(ValueType))
 472 {
 473     if (discreteCapabilityValues) {
 474         int value = constraint.valueForDiscreteCapabilityValues(current, *discreteCapabilityValues);
 475         if (value != current)
 476             (source.*applier)(value);
 477         return;
 478     }
 479 
 480     ValueType value = constraint.valueForCapabilityRange(current, capabilityMin, capabilityMax);
 481     if (value != current)
 482         (source.*applier)(value);
 483 }
 484 
 485 void RealtimeMediaSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; frameRate)
 486 {
 487     IntSize size;
 488     if (width)
 489         size.setWidth(width.value());
 490     if (height)
 491         size.setHeight(height.value());
 492     setSize(size);
 493     if (frameRate)
 494         setFrameRate(frameRate.value());
 495 }
 496 
 497 void RealtimeMediaSource::applyConstraint(const MediaConstraint&amp; constraint)
 498 {
 499     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, constraint.name());
 500 
 501     auto&amp; capabilities = this-&gt;capabilities();
 502     switch (constraint.constraintType()) {
 503     case MediaConstraintType::Width:
 504         ASSERT_NOT_REACHED();
 505         break;
 506 
 507     case MediaConstraintType::Height:
 508         ASSERT_NOT_REACHED();
 509         break;
 510 
 511     case MediaConstraintType::FrameRate:
 512         ASSERT_NOT_REACHED();
 513         break;
 514 
 515     case MediaConstraintType::AspectRatio: {
 516         ASSERT(constraint.isDouble());
 517         if (!capabilities.supportsAspectRatio())
 518             return;
 519 
 520         auto range = capabilities.aspectRatio();
 521         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), aspectRatio(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setAspectRatio);
 522         break;
 523     }
 524 
 525     case MediaConstraintType::Volume: {
 526         ASSERT(constraint.isDouble());
 527         if (!capabilities.supportsVolume())
 528             return;
 529 
 530         auto range = capabilities.volume();
 531         applyNumericConstraint(downcast&lt;DoubleConstraint&gt;(constraint), volume(), { }, range.rangeMin().asDouble, range.rangeMax().asDouble, *this, &amp;RealtimeMediaSource::setVolume);
 532         break;
 533     }
 534 
 535     case MediaConstraintType::SampleRate: {
 536         ASSERT(constraint.isInt());
 537         if (!capabilities.supportsSampleRate())
 538             return;
 539 
 540         auto range = capabilities.sampleRate();
 541         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleRate(), discreteSampleRates(), range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleRate);
 542         break;
 543     }
 544 
 545     case MediaConstraintType::SampleSize: {
 546         ASSERT(constraint.isInt());
 547         if (!capabilities.supportsSampleSize())
 548             return;
 549 
 550         auto range = capabilities.sampleSize();
 551         applyNumericConstraint(downcast&lt;IntConstraint&gt;(constraint), sampleSize(), { }, range.rangeMin().asInt, range.rangeMax().asInt, *this, &amp;RealtimeMediaSource::setSampleSize);
 552         break;
 553     }
 554 
 555     case MediaConstraintType::EchoCancellation: {
 556         ASSERT(constraint.isBoolean());
 557         if (!capabilities.supportsEchoCancellation())
 558             return;
 559 
 560         bool setting;
 561         const BooleanConstraint&amp; boolConstraint = downcast&lt;BooleanConstraint&gt;(constraint);
 562         if (boolConstraint.getExact(setting) || boolConstraint.getIdeal(setting))
 563             setEchoCancellation(setting);
 564         break;
 565     }
 566 
 567     case MediaConstraintType::FacingMode: {
 568         ASSERT(constraint.isString());
 569         if (!capabilities.supportsFacingMode())
 570             return;
 571 
 572         auto&amp; supportedModes = capabilities.facingMode();
 573         auto filter = [supportedModes](const String&amp; modeString) {
 574             auto mode = RealtimeMediaSourceSettings::videoFacingModeEnum(modeString);
 575             for (auto&amp; supportedMode : supportedModes) {
 576                 if (mode == supportedMode)
 577                     return true;
 578             }
 579             return false;
 580         };
 581 
 582         auto modeString = downcast&lt;StringConstraint&gt;(constraint).find(WTFMove(filter));
 583         if (!modeString.isEmpty())
 584             setFacingMode(RealtimeMediaSourceSettings::videoFacingModeEnum(modeString));
 585         break;
 586     }
 587 
 588     case MediaConstraintType::DeviceId:
 589     case MediaConstraintType::GroupId:
 590         ASSERT(constraint.isString());
 591         // There is nothing to do here, neither can be changed.
 592         break;
 593 
 594     case MediaConstraintType::DisplaySurface:
 595     case MediaConstraintType::LogicalSurface:
 596         ASSERT(constraint.isBoolean());
 597         break;
 598 
 599     case MediaConstraintType::Unknown:
 600         break;
 601     }
 602 }
 603 
 604 bool RealtimeMediaSource::selectSettings(const MediaConstraints&amp; constraints, FlattenedConstraint&amp; candidates, String&amp; failedConstraint)
 605 {
 606     double minimumDistance = std::numeric_limits&lt;double&gt;::infinity();
 607 
 608     // https://w3c.github.io/mediacapture-main/#dfn-selectsettings
 609     //
 610     // 1. Each constraint specifies one or more values (or a range of values) for its property.
 611     //    A property may appear more than once in the list of &#39;advanced&#39; ConstraintSets. If an
 612     //    empty object or list has been given as the value for a constraint, it must be interpreted
 613     //    as if the constraint were not specified (in other words, an empty constraint == no constraint).
 614     //
 615     //    Note that unknown properties are discarded by WebIDL, which means that unknown/unsupported required
 616     //    constraints will silently disappear. To avoid this being a surprise, application authors are
 617     //    expected to first use the getSupportedConstraints() method as shown in the Examples below.
 618 
 619     // 2. Let object be the ConstrainablePattern object on which this algorithm is applied. Let copy be an
 620     //    unconstrained copy of object (i.e., copy should behave as if it were object with all ConstraintSets
 621     //    removed.)
 622 
 623     // 3. For every possible settings dictionary of copy compute its fitness distance, treating bare values of
 624     //    properties as ideal values. Let candidates be the set of settings dictionaries for which the fitness
 625     //    distance is finite.
 626 
 627     failedConstraint = emptyString();
 628 
 629     // Check width, height and frame rate jointly, because while they may be supported individually the combination may not be supported.
 630     double distance = std::numeric_limits&lt;double&gt;::infinity();
 631     if (!supportsSizeAndFrameRate(constraints.mandatoryConstraints.width(), constraints.mandatoryConstraints.height(), constraints.mandatoryConstraints.frameRate(), failedConstraint, minimumDistance))
 632         return false;
 633 
 634     constraints.mandatoryConstraints.filter([&amp;](const MediaConstraint&amp; constraint) {
 635         if (!supportsConstraint(constraint))
 636             return false;
 637 
 638         if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate) {
 639             candidates.set(constraint);
 640             return false;
 641         }
 642 
 643         double constraintDistance = fitnessDistance(constraint);
 644         if (std::isinf(constraintDistance)) {
 645             failedConstraint = constraint.name();
 646             return true;
 647         }
 648 
 649         distance = std::min(distance, constraintDistance);
 650         candidates.set(constraint);
 651         return false;
 652     });
 653 
 654     if (!failedConstraint.isEmpty())
 655         return false;
 656 
 657     minimumDistance = distance;
 658 
 659     // 4. If candidates is empty, return undefined as the result of the SelectSettings() algorithm.
 660     if (candidates.isEmpty())
 661         return true;
 662 
 663     // 5. Iterate over the &#39;advanced&#39; ConstraintSets in newConstraints in the order in which they were specified.
 664     //    For each ConstraintSet:
 665 
 666     // 5.1 compute the fitness distance between it and each settings dictionary in candidates, treating bare
 667     //     values of properties as exact.
 668     Vector&lt;std::pair&lt;double, MediaTrackConstraintSetMap&gt;&gt; supportedConstraints;
 669 
 670     for (const auto&amp; advancedConstraint : constraints.advancedConstraints) {
 671         double constraintDistance = 0;
 672         bool supported = false;
 673 
 674         if (advancedConstraint.width() || advancedConstraint.height() || advancedConstraint.frameRate()) {
 675             String dummy;
 676             if (!supportsSizeAndFrameRate(advancedConstraint.width(), advancedConstraint.height(), advancedConstraint.frameRate(), dummy, constraintDistance))
 677                 continue;
 678 
 679             supported = true;
 680         }
 681 
 682         advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 683 
 684             if (constraint.constraintType() == MediaConstraintType::Width || constraint.constraintType() == MediaConstraintType::Height || constraint.constraintType() == MediaConstraintType::FrameRate)
 685                 return;
 686 
 687             distance = fitnessDistance(constraint);
 688             constraintDistance += distance;
 689             if (!std::isinf(distance))
 690                 supported = true;
 691         });
 692 
 693         minimumDistance = std::min(minimumDistance, constraintDistance);
 694 
 695         // 5.2 If the fitness distance is finite for one or more settings dictionaries in candidates, keep those
 696         //     settings dictionaries in candidates, discarding others.
 697         //     If the fitness distance is infinite for all settings dictionaries in candidates, ignore this ConstraintSet.
 698         if (supported)
 699             supportedConstraints.append({constraintDistance, advancedConstraint});
 700     }
 701 
 702     // 6. Select one settings dictionary from candidates, and return it as the result of the SelectSettings() algorithm.
 703     //    The UA should use the one with the smallest fitness distance, as calculated in step 3.
 704     if (!supportedConstraints.isEmpty()) {
 705         supportedConstraints.removeAllMatching([&amp;](const std::pair&lt;double, MediaTrackConstraintSetMap&gt;&amp; pair) -&gt; bool {
 706             return std::isinf(pair.first) || pair.first &gt; minimumDistance;
 707         });
 708 
 709         if (!supportedConstraints.isEmpty()) {
 710             auto&amp; advancedConstraint = supportedConstraints[0].second;
 711             advancedConstraint.forEach([&amp;](const MediaConstraint&amp; constraint) {
 712                 candidates.merge(constraint);
 713             });
 714 
 715             minimumDistance = std::min(minimumDistance, supportedConstraints[0].first);
 716         }
 717     }
 718 
 719     return true;
 720 }
 721 
 722 bool RealtimeMediaSource::supportsConstraint(const MediaConstraint&amp; constraint)
 723 {
 724     auto&amp; capabilities = this-&gt;capabilities();
 725 
 726     switch (constraint.constraintType()) {
 727     case MediaConstraintType::Width:
 728         ASSERT(constraint.isInt());
 729         return capabilities.supportsWidth();
 730         break;
 731 
 732     case MediaConstraintType::Height:
 733         ASSERT(constraint.isInt());
 734         return capabilities.supportsHeight();
 735         break;
 736 
 737     case MediaConstraintType::FrameRate:
 738         ASSERT(constraint.isDouble());
 739         return capabilities.supportsFrameRate();
 740         break;
 741 
 742     case MediaConstraintType::AspectRatio:
 743         ASSERT(constraint.isDouble());
 744         return capabilities.supportsAspectRatio();
 745         break;
 746 
 747     case MediaConstraintType::Volume:
 748         ASSERT(constraint.isDouble());
 749         return capabilities.supportsVolume();
 750         break;
 751 
 752     case MediaConstraintType::SampleRate:
 753         ASSERT(constraint.isInt());
 754         return capabilities.supportsSampleRate();
 755         break;
 756 
 757     case MediaConstraintType::SampleSize:
 758         ASSERT(constraint.isInt());
 759         return capabilities.supportsSampleSize();
 760         break;
 761 
 762     case MediaConstraintType::FacingMode:
 763         ASSERT(constraint.isString());
 764         return capabilities.supportsFacingMode();
 765         break;
 766 
 767     case MediaConstraintType::EchoCancellation:
 768         ASSERT(constraint.isBoolean());
 769         return capabilities.supportsEchoCancellation();
 770         break;
 771 
 772     case MediaConstraintType::DeviceId:
 773         ASSERT(constraint.isString());
 774         return capabilities.supportsDeviceId();
 775         break;
 776 
 777     case MediaConstraintType::GroupId:
 778         ASSERT(constraint.isString());
 779         return capabilities.supportsDeviceId();
 780         break;
 781 
 782     case MediaConstraintType::DisplaySurface:
 783     case MediaConstraintType::LogicalSurface:
 784         // https://www.w3.org/TR/screen-capture/#new-constraints-for-captured-display-surfaces
 785         // 5.2.1 New Constraints for Captured Display Surfaces
 786         // Since the source of media cannot be changed after a MediaStreamTrack has been returned,
 787         // these constraints cannot be changed by an application.
 788         return false;
 789         break;
 790 
 791     case MediaConstraintType::Unknown:
 792         // Unknown (or unsupported) constraints should be ignored.
 793         break;
 794     }
 795 
 796     return false;
 797 }
 798 
 799 bool RealtimeMediaSource::supportsConstraints(const MediaConstraints&amp; constraints, String&amp; invalidConstraint)
 800 {
 801     ASSERT(constraints.isValid);
 802 
 803     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 804 
 805     FlattenedConstraint candidates;
 806     if (!selectSettings(constraints, candidates, invalidConstraint))
 807         return false;
 808 
 809     m_fitnessScore = 0;
 810     for (auto&amp; variant : candidates) {
 811         double distance = fitnessDistance(variant);
 812         switch (variant.constraintType()) {
 813         case MediaConstraintType::DeviceId:
 814         case MediaConstraintType::FacingMode:
 815             m_fitnessScore += distance ? 1 : 32;
 816             break;
 817 
 818         case MediaConstraintType::Width:
 819         case MediaConstraintType::Height:
 820         case MediaConstraintType::FrameRate:
 821         case MediaConstraintType::AspectRatio:
 822         case MediaConstraintType::Volume:
 823         case MediaConstraintType::SampleRate:
 824         case MediaConstraintType::SampleSize:
 825         case MediaConstraintType::EchoCancellation:
 826         case MediaConstraintType::GroupId:
 827         case MediaConstraintType::DisplaySurface:
 828         case MediaConstraintType::LogicalSurface:
 829         case MediaConstraintType::Unknown:
 830             m_fitnessScore += distance ? 1 : 2;
 831             break;
 832         }
 833     }
 834 
 835     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, &quot;fitness distance : &quot;, m_fitnessScore);
 836 
 837     return true;
 838 }
 839 
 840 void RealtimeMediaSource::applyConstraints(const FlattenedConstraint&amp; constraints)
 841 {
 842     if (constraints.isEmpty())
 843         return;
 844 
 845     beginConfiguration();
 846 
 847     auto&amp; capabilities = this-&gt;capabilities();
 848 
 849     Optional&lt;int&gt; width;
 850     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Width)) {
 851         ASSERT(constraint-&gt;isInt());
 852         if (capabilities.supportsWidth()) {
 853             auto range = capabilities.width();
 854             width = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().width(), range.rangeMin().asInt, range.rangeMax().asInt);
 855         }
 856     }
 857 
 858     Optional&lt;int&gt; height;
 859     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::Height)) {
 860         ASSERT(constraint-&gt;isInt());
 861         if (capabilities.supportsHeight()) {
 862             auto range = capabilities.height();
 863             height = downcast&lt;IntConstraint&gt;(*constraint).valueForCapabilityRange(size().height(), range.rangeMin().asInt, range.rangeMax().asInt);
 864         }
 865     }
 866 
 867     Optional&lt;double&gt; frameRate;
 868     if (const MediaConstraint* constraint = constraints.find(MediaConstraintType::FrameRate)) {
 869         ASSERT(constraint-&gt;isDouble());
 870         if (capabilities.supportsFrameRate()) {
 871             auto range = capabilities.frameRate();
 872             frameRate = downcast&lt;DoubleConstraint&gt;(*constraint).valueForCapabilityRange(this-&gt;frameRate(), range.rangeMin().asDouble, range.rangeMax().asDouble);
 873         }
 874     }
 875 
 876     if (width || height || frameRate)
 877         setSizeAndFrameRate(WTFMove(width), WTFMove(height), WTFMove(frameRate));
 878 
 879     for (auto&amp; variant : constraints) {
 880         if (variant.constraintType() == MediaConstraintType::Width || variant.constraintType() == MediaConstraintType::Height || variant.constraintType() == MediaConstraintType::FrameRate)
 881             continue;
 882 
 883         applyConstraint(variant);
 884     }
 885 
 886     commitConfiguration();
 887 }
 888 
 889 Optional&lt;RealtimeMediaSource::ApplyConstraintsError&gt; RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints)
 890 {
 891     ASSERT(constraints.isValid);
 892 
 893     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER);
 894 
 895     FlattenedConstraint candidates;
 896     String failedConstraint;
 897     if (!selectSettings(constraints, candidates, failedConstraint))
 898         return ApplyConstraintsError { failedConstraint, &quot;Constraint not supported&quot;_s };
 899 
 900     applyConstraints(candidates);
 901     return { };
 902 }
 903 
 904 void RealtimeMediaSource::applyConstraints(const MediaConstraints&amp; constraints, ApplyConstraintsHandler&amp;&amp; completionHandler)
 905 {
 906     completionHandler(applyConstraints(constraints));
 907 }
 908 
 909 void RealtimeMediaSource::setSize(const IntSize&amp; size)
 910 {
 911     if (size == m_size)
 912         return;
 913 
 914     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
 915 
 916     m_size = size;
 917     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 918 }
 919 
 920 const IntSize RealtimeMediaSource::size() const
 921 {
 922     auto size = m_size;
 923 
 924     if (size.isEmpty() &amp;&amp; !m_intrinsicSize.isEmpty()) {
 925         if (size.isZero())
 926             size = m_intrinsicSize;
 927         else if (size.width())
 928             size.setHeight(size.width() * (m_intrinsicSize.height() / static_cast&lt;double&gt;(m_intrinsicSize.width())));
 929         else if (size.height())
 930             size.setWidth(size.height() * (m_intrinsicSize.width() / static_cast&lt;double&gt;(m_intrinsicSize.height())));
 931     }
 932 
 933     return size;
 934 }
 935 
 936 void RealtimeMediaSource::setIntrinsicSize(const IntSize&amp; size)
 937 {
 938     if (m_intrinsicSize == size)
 939         return;
 940 
 941     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
 942 
 943     auto currentSize = this-&gt;size();
 944     m_intrinsicSize = size;
 945 
 946     if (currentSize != this-&gt;size())
 947         notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
 948 }
 949 
 950 const IntSize RealtimeMediaSource::intrinsicSize() const
 951 {
 952     return m_intrinsicSize;
 953 }
 954 
 955 void RealtimeMediaSource::setFrameRate(double rate)
 956 {
 957     if (m_frameRate == rate)
 958         return;
 959 
 960     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);
 961 
 962     m_frameRate = rate;
 963     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FrameRate);
 964 }
 965 
 966 void RealtimeMediaSource::setAspectRatio(double ratio)
 967 {
 968     if (m_aspectRatio == ratio)
 969         return;
 970 
 971     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, ratio);
 972 
 973     m_aspectRatio = ratio;
 974     m_size.setHeight(m_size.width() / ratio);
 975     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::AspectRatio, RealtimeMediaSourceSettings::Flag::Height });
 976 }
 977 
 978 void RealtimeMediaSource::setFacingMode(RealtimeMediaSourceSettings::VideoFacingMode mode)
 979 {
 980     if (m_facingMode == mode)
 981         return;
 982 
 983     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, mode);
 984 
 985     m_facingMode = mode;
 986     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::FacingMode);
 987 }
 988 
 989 void RealtimeMediaSource::setVolume(double volume)
 990 {
 991     if (m_volume == volume)
 992         return;
 993 
 994     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, volume);
 995 
 996     m_volume = volume;
 997     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::Volume);
 998 }
 999 
1000 void RealtimeMediaSource::setSampleRate(int rate)
1001 {
1002     if (m_sampleRate == rate)
1003         return;
1004 
1005     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, rate);
1006 
1007     m_sampleRate = rate;
1008     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleRate);
1009 }
1010 
1011 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleRates() const
1012 {
1013     return WTF::nullopt;
1014 }
1015 
1016 void RealtimeMediaSource::setSampleSize(int size)
1017 {
1018     if (m_sampleSize == size)
1019         return;
1020 
1021     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, size);
1022 
1023     m_sampleSize = size;
1024     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::SampleSize);
1025 }
1026 
1027 Optional&lt;Vector&lt;int&gt;&gt; RealtimeMediaSource::discreteSampleSizes() const
1028 {
1029     return WTF::nullopt;
1030 }
1031 
1032 void RealtimeMediaSource::setEchoCancellation(bool echoCancellation)
1033 {
1034     if (m_echoCancellation == echoCancellation)
1035         return;
1036 
1037     ALWAYS_LOG_IF(m_logger, LOGIDENTIFIER, echoCancellation);
1038     m_echoCancellation = echoCancellation;
1039     notifySettingsDidChangeObservers(RealtimeMediaSourceSettings::Flag::EchoCancellation);
1040 }
1041 
1042 void RealtimeMediaSource::scheduleDeferredTask(Function&lt;void()&gt;&amp;&amp; function)
1043 {
1044     ASSERT(function);
1045     callOnMainThread([protectedThis = makeRef(*this), function = WTFMove(function)] {
1046         function();
1047     });
1048 }
1049 
1050 const String&amp; RealtimeMediaSource::hashedId() const
1051 {
1052     ASSERT(!m_hashedID.isEmpty());
1053     return m_hashedID;
1054 }
1055 
1056 String RealtimeMediaSource::deviceIDHashSalt() const
1057 {
1058     return m_idHashSalt;
1059 }
1060 
1061 RealtimeMediaSource::Observer::~Observer()
1062 {
1063 }
1064 
1065 #if !RELEASE_LOG_DISABLED
1066 void RealtimeMediaSource::setLogger(const Logger&amp; newLogger, const void* newLogIdentifier)
1067 {
1068     m_logger = &amp;newLogger;
1069     m_logIdentifier = newLogIdentifier;
1070     ALWAYS_LOG(LOGIDENTIFIER, m_type, &quot;, &quot;, m_name, &quot;, &quot;, m_hashedID);
1071 }
1072 
1073 WTFLogChannel&amp; RealtimeMediaSource::logChannel() const
1074 {
1075     return LogWebRTC;
1076 }
1077 #endif
1078 
1079 String convertEnumerationToString(RealtimeMediaSource::Type enumerationValue)
1080 {
1081     static const NeverDestroyed&lt;String&gt; values[] = {
1082         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1083         MAKE_STATIC_STRING_IMPL(&quot;Audio&quot;),
1084         MAKE_STATIC_STRING_IMPL(&quot;Video&quot;),
1085     };
1086     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::None) == 0, &quot;RealtimeMediaSource::Type::None is not 0 as expected&quot;);
1087     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Audio) == 1, &quot;RealtimeMediaSource::Type::Audio is not 1 as expected&quot;);
1088     static_assert(static_cast&lt;size_t&gt;(RealtimeMediaSource::Type::Video) == 2, &quot;RealtimeMediaSource::Type::Video is not 2 as expected&quot;);
1089     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1090     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1091 }
1092 
1093 } // namespace WebCore
1094 
1095 #endif // ENABLE(MEDIA_STREAM)
    </pre>
  </body>
</html>
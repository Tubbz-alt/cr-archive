<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/testRegExp.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  *  Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;RegExp.h&quot;
 23 
 24 #include &quot;InitializeThreading.h&quot;
 25 #include &quot;JSCInlines.h&quot;
 26 #include &quot;JSGlobalObject.h&quot;
 27 #include &quot;YarrFlags.h&quot;
 28 #include &lt;errno.h&gt;
 29 #include &lt;stdio.h&gt;
 30 #include &lt;stdlib.h&gt;
 31 #include &lt;string.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 #include &lt;wtf/text/StringBuilder.h&gt;
 34 
 35 #if !OS(WINDOWS)
 36 #include &lt;unistd.h&gt;
 37 #endif
 38 
 39 #if HAVE(SYS_TIME_H)
 40 #include &lt;sys/time.h&gt;
 41 #endif
 42 
 43 #if COMPILER(MSVC)
 44 #include &lt;crtdbg.h&gt;
 45 #include &lt;mmsystem.h&gt;
 46 #include &lt;windows.h&gt;
 47 #endif
 48 
 49 const int MaxLineLength = 100 * 1024;
 50 
 51 using namespace JSC;
 52 
 53 struct CommandLine {
 54     CommandLine()
 55         : interactive(false)
 56         , verbose(false)
 57     {
 58     }
 59 
 60     bool interactive;
 61     bool verbose;
 62     Vector&lt;String&gt; arguments;
 63     Vector&lt;String&gt; files;
 64 };
 65 
 66 class StopWatch {
 67 public:
 68     void start();
 69     void stop();
 70     long getElapsedMS(); // call stop() first
 71 
 72 private:
 73     MonotonicTime m_startTime;
 74     MonotonicTime m_stopTime;
 75 };
 76 
 77 void StopWatch::start()
 78 {
 79     m_startTime = MonotonicTime::now();
 80 }
 81 
 82 void StopWatch::stop()
 83 {
 84     m_stopTime = MonotonicTime::now();
 85 }
 86 
 87 long StopWatch::getElapsedMS()
 88 {
 89     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 90 }
 91 
 92 struct RegExpTest {
 93     RegExpTest()
 94         : offset(0)
 95         , result(0)
 96     {
 97     }
 98 
 99     String subject;
100     int offset;
101     int result;
102     Vector&lt;int, 32&gt; expectVector;
103 };
104 
<a name="2" id="anc2"></a><span class="line-modified">105 class GlobalObject final : public JSGlobalObject {</span>
106 private:
107     GlobalObject(VM&amp;, Structure*, const Vector&lt;String&gt;&amp; arguments);
108 
109 public:
<a name="3" id="anc3"></a><span class="line-modified">110     using Base = JSGlobalObject;</span>
111 
112     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
113     {
114         GlobalObject* globalObject = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure, arguments);
115         return globalObject;
116     }
117 
118     DECLARE_INFO;
119 
<a name="4" id="anc4"></a><span class="line-modified">120     static constexpr bool needsDestructor = true;</span>
121 
122     static Structure* createStructure(VM&amp; vm, JSValue prototype)
123     {
124         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
125     }
126 
127 protected:
128     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
129     {
130         Base::finishCreation(vm);
131         UNUSED_PARAM(arguments);
132     }
133 };
<a name="5" id="anc5"></a><span class="line-added">134 STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(GlobalObject, JSGlobalObject);</span>
135 
136 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
137 
138 GlobalObject::GlobalObject(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
139     : JSGlobalObject(vm, structure)
140 {
141     finishCreation(vm, arguments);
142 }
143 
144 // Use SEH for Release builds only to get rid of the crash report dialog
145 // (luckily the same tests fail in Release and Debug builds so far). Need to
146 // be in a separate main function because the realMain function requires object
147 // unwinding.
148 
149 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
150 #define TRY       __try {
151 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
152 #else
153 #define TRY
154 #define EXCEPT(x)
155 #endif
156 
157 int realMain(int argc, char** argv);
158 
159 int main(int argc, char** argv)
160 {
161 #if OS(WINDOWS)
162     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
163     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
164     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
165     ::SetErrorMode(0);
166 
167 #if defined(_DEBUG)
168     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
169     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
170     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
171     _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
172     _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
173     _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
174 #endif
175 
176     timeBeginPeriod(1);
177 #endif
178 
179     // Initialize JSC before getting VM.
180     JSC::initializeThreading();
181 
182     // We can&#39;t use destructors in the following code because it uses Windows
183     // Structured Exception Handling
184     int res = 0;
185     TRY
186         res = realMain(argc, argv);
187     EXCEPT(res = 3)
188     return res;
189 }
190 
191 static bool testOneRegExp(VM&amp; vm, RegExp* regexp, RegExpTest* regExpTest, bool verbose, unsigned int lineNumber)
192 {
193     bool result = true;
194     Vector&lt;int&gt; outVector;
195     outVector.resize(regExpTest-&gt;expectVector.size());
196     int matchResult = regexp-&gt;match(vm, regExpTest-&gt;subject, regExpTest-&gt;offset, outVector);
197 
198     if (matchResult != regExpTest-&gt;result) {
199         result = false;
200         if (verbose)
201             printf(&quot;Line %d: results mismatch - expected %d got %d\n&quot;, lineNumber, regExpTest-&gt;result, matchResult);
202     } else if (matchResult != -1) {
203         if (outVector.size() != regExpTest-&gt;expectVector.size()) {
204             result = false;
205             if (verbose) {
206 #if OS(WINDOWS)
207                 printf(&quot;Line %d: output vector size mismatch - expected %Iu got %Iu\n&quot;, lineNumber, regExpTest-&gt;expectVector.size(), outVector.size());
208 #else
209                 printf(&quot;Line %d: output vector size mismatch - expected %zu got %zu\n&quot;, lineNumber, regExpTest-&gt;expectVector.size(), outVector.size());
210 #endif
211             }
212         } else if (outVector.size() % 2) {
213             result = false;
214             if (verbose) {
215 #if OS(WINDOWS)
216                 printf(&quot;Line %d: output vector size is odd (%Iu), should be even\n&quot;, lineNumber, outVector.size());
217 #else
218                 printf(&quot;Line %d: output vector size is odd (%zu), should be even\n&quot;, lineNumber, outVector.size());
219 #endif
220             }
221         } else {
222             // Check in pairs since the first value of the pair could be -1 in which case the second doesn&#39;t matter.
223             size_t pairCount = outVector.size() / 2;
224             for (size_t i = 0; i &lt; pairCount; ++i) {
225                 size_t startIndex = i*2;
226                 if (outVector[startIndex] != regExpTest-&gt;expectVector[startIndex]) {
227                     result = false;
228                     if (verbose) {
229 #if OS(WINDOWS)
230                         printf(&quot;Line %d: output vector mismatch at index %Iu - expected %d got %d\n&quot;, lineNumber, startIndex, regExpTest-&gt;expectVector[startIndex], outVector[startIndex]);
231 #else
232                         printf(&quot;Line %d: output vector mismatch at index %zu - expected %d got %d\n&quot;, lineNumber, startIndex, regExpTest-&gt;expectVector[startIndex], outVector[startIndex]);
233 #endif
234                     }
235                 }
236                 if ((i &gt; 0) &amp;&amp; (regExpTest-&gt;expectVector[startIndex] != -1) &amp;&amp; (outVector[startIndex+1] != regExpTest-&gt;expectVector[startIndex+1])) {
237                     result = false;
238                     if (verbose) {
239 #if OS(WINDOWS)
240                         printf(&quot;Line %d: output vector mismatch at index %Iu - expected %d got %d\n&quot;, lineNumber, startIndex + 1, regExpTest-&gt;expectVector[startIndex + 1], outVector[startIndex + 1]);
241 #else
242                         printf(&quot;Line %d: output vector mismatch at index %zu - expected %d got %d\n&quot;, lineNumber, startIndex + 1, regExpTest-&gt;expectVector[startIndex + 1], outVector[startIndex + 1]);
243 #endif
244                     }
245                 }
246             }
247         }
248     }
249 
250     return result;
251 }
252 
253 static int scanString(char* buffer, int bufferLength, StringBuilder&amp; builder, char termChar)
254 {
255     bool escape = false;
256 
257     for (int i = 0; i &lt; bufferLength; ++i) {
258         UChar c = buffer[i];
259 
260         if (escape) {
261             switch (c) {
262             case &#39;0&#39;:
263                 c = &#39;\0&#39;;
264                 break;
265             case &#39;a&#39;:
266                 c = &#39;\a&#39;;
267                 break;
268             case &#39;b&#39;:
269                 c = &#39;\b&#39;;
270                 break;
271             case &#39;f&#39;:
272                 c = &#39;\f&#39;;
273                 break;
274             case &#39;n&#39;:
275                 c = &#39;\n&#39;;
276                 break;
277             case &#39;r&#39;:
278                 c = &#39;\r&#39;;
279                 break;
280             case &#39;t&#39;:
281                 c = &#39;\t&#39;;
282                 break;
283             case &#39;v&#39;:
284                 c = &#39;\v&#39;;
285                 break;
286             case &#39;\\&#39;:
287                 c = &#39;\\&#39;;
288                 break;
289             case &#39;?&#39;:
290                 c = &#39;\?&#39;;
291                 break;
292             case &#39;u&#39;:
293                 if ((i + 4) &gt;= bufferLength)
294                     return -1;
295                 unsigned int charValue;
296                 if (sscanf(buffer+i+1, &quot;%04x&quot;, &amp;charValue) != 1)
297                     return -1;
298                 c = static_cast&lt;UChar&gt;(charValue);
299                 i += 4;
300                 break;
301             }
302 
303             builder.append(c);
304             escape = false;
305         } else {
306             if (c == termChar)
307                 return i;
308 
309             if (c == &#39;\\&#39;)
310                 escape = true;
311             else
312                 builder.append(c);
313         }
314     }
315 
316     return -1;
317 }
318 
319 static RegExp* parseRegExpLine(VM&amp; vm, char* line, int lineLength, const char** regexpError)
320 {
321     StringBuilder pattern;
322 
323     if (line[0] != &#39;/&#39;)
324         return 0;
325 
326     int i = scanString(line + 1, lineLength - 1, pattern, &#39;/&#39;) + 1;
327 
328     if ((i &gt;= lineLength) || (line[i] != &#39;/&#39;))
329         return 0;
330 
331     ++i;
332 
333     auto flags = Yarr::parseFlags(line + i);
334     if (!flags) {
335         *regexpError = Yarr::errorMessage(Yarr::ErrorCode::InvalidRegularExpressionFlags);
336         return nullptr;
337     }
338 
339     RegExp* r = RegExp::create(vm, pattern.toString(), flags.value());
340     if (!r-&gt;isValid()) {
341         *regexpError = r-&gt;errorMessage();
342         return nullptr;
343     }
344 
345     return r;
346 }
347 
348 static RegExpTest* parseTestLine(char* line, int lineLength)
349 {
350     StringBuilder subjectString;
351 
352     if ((line[0] != &#39; &#39;) || (line[1] != &#39;&quot;&#39;))
353         return 0;
354 
355     int i = scanString(line + 2, lineLength - 2, subjectString, &#39;&quot;&#39;) + 2;
356 
357     if ((i &gt;= (lineLength - 2)) || (line[i] != &#39;&quot;&#39;) || (line[i+1] != &#39;,&#39;) || (line[i+2] != &#39; &#39;))
358         return 0;
359 
360     i += 3;
361 
362     int offset;
363 
364     if (sscanf(line + i, &quot;%d, &quot;, &amp;offset) != 1)
365         return 0;
366 
367     while (line[i] &amp;&amp; line[i] != &#39; &#39;)
368         ++i;
369 
370     ++i;
371 
372     int matchResult;
373 
374     if (sscanf(line + i, &quot;%d, &quot;, &amp;matchResult) != 1)
375         return 0;
376 
377     while (line[i] &amp;&amp; line[i] != &#39; &#39;)
378         ++i;
379 
380     ++i;
381 
382     if (line[i++] != &#39;(&#39;)
383         return 0;
384 
385     int start, end;
386 
387     RegExpTest* result = new RegExpTest();
388 
389     result-&gt;subject = subjectString.toString();
390     result-&gt;offset = offset;
391     result-&gt;result = matchResult;
392 
393     while (line[i] &amp;&amp; line[i] != &#39;)&#39;) {
394         if (sscanf(line + i, &quot;%d, %d&quot;, &amp;start, &amp;end) != 2) {
395             delete result;
396             return 0;
397         }
398 
399         result-&gt;expectVector.append(start);
400         result-&gt;expectVector.append(end);
401 
402         while (line[i] &amp;&amp; (line[i] != &#39;,&#39;) &amp;&amp; (line[i] != &#39;)&#39;))
403             i++;
404         i++;
405         while (line[i] &amp;&amp; (line[i] != &#39;,&#39;) &amp;&amp; (line[i] != &#39;)&#39;))
406             i++;
407 
408         if (line[i] == &#39;)&#39;)
409             break;
410         if (!line[i] || (line[i] != &#39;,&#39;)) {
411             delete result;
412             return 0;
413         }
414         i++;
415     }
416 
417     return result;
418 }
419 
420 static bool runFromFiles(GlobalObject* globalObject, const Vector&lt;String&gt;&amp; files, bool verbose)
421 {
422     String script;
423     String fileName;
424     Vector&lt;char&gt; scriptBuffer;
425     unsigned tests = 0;
426     unsigned failures = 0;
427     Vector&lt;char&gt; lineBuffer(MaxLineLength + 1);
428 
429     VM&amp; vm = globalObject-&gt;vm();
430 
431     bool success = true;
432     for (size_t i = 0; i &lt; files.size(); i++) {
433         FILE* testCasesFile = fopen(files[i].utf8().data(), &quot;rb&quot;);
434 
435         if (!testCasesFile) {
436             printf(&quot;Unable to open test data file \&quot;%s\&quot;\n&quot;, files[i].utf8().data());
437             continue;
438         }
439 
440         RegExp* regexp = 0;
441         size_t lineLength = 0;
442         char* linePtr = 0;
443         unsigned int lineNumber = 0;
444         const char* regexpError = nullptr;
445 
446         while ((linePtr = fgets(lineBuffer.data(), MaxLineLength, testCasesFile))) {
447             lineLength = strlen(linePtr);
448             if (linePtr[lineLength - 1] == &#39;\n&#39;) {
449                 linePtr[lineLength - 1] = &#39;\0&#39;;
450                 --lineLength;
451             }
452             ++lineNumber;
453 
454             if (linePtr[0] == &#39;#&#39;)
455                 continue;
456 
457             if (linePtr[0] == &#39;/&#39;) {
458                 regexp = parseRegExpLine(vm, linePtr, lineLength, &amp;regexpError);
459                 if (!regexp) {
460                     failures++;
461                     fprintf(stderr, &quot;Failure on line %u. &#39;%s&#39; %s\n&quot;, lineNumber, linePtr, regexpError);
462                 }
463             } else if (linePtr[0] == &#39; &#39;) {
464                 RegExpTest* regExpTest = parseTestLine(linePtr, lineLength);
465 
466                 if (regexp &amp;&amp; regExpTest) {
467                     ++tests;
468                     if (!testOneRegExp(vm, regexp, regExpTest, verbose, lineNumber)) {
469                         failures++;
470                         printf(&quot;Failure on line %u\n&quot;, lineNumber);
471                     }
472                 }
473 
474                 if (regExpTest)
475                     delete regExpTest;
476             } else if (linePtr[0] == &#39;-&#39;) {
477                 tests++;
478                 regexp = 0; // Reset the live regexp to avoid confusing other subsequent tests
479                 bool successfullyParsed = parseRegExpLine(vm, linePtr + 1, lineLength - 1, &amp;regexpError);
480                 if (successfullyParsed) {
481                     failures++;
482                     fprintf(stderr, &quot;Failure on line %u. &#39;%s&#39; %s\n&quot;, lineNumber, linePtr + 1, regexpError);
483                 }
484             }
485         }
486 
487         fclose(testCasesFile);
488     }
489 
490     if (failures)
491         printf(&quot;%u tests run, %u failures\n&quot;, tests, failures);
492     else
493         printf(&quot;%u tests passed\n&quot;, tests);
494 
495 #if ENABLE(REGEXP_TRACING)
496     vm.dumpRegExpTrace();
497 #endif
498     return success;
499 }
500 
501 #define RUNNING_FROM_XCODE 0
502 
503 static NO_RETURN void printUsageStatement(bool help = false)
504 {
505     fprintf(stderr, &quot;Usage: regexp_test [options] file\n&quot;);
506     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
507     fprintf(stderr, &quot;  -v|--verbose  Verbose output\n&quot;);
508 
509     exit(help ? EXIT_SUCCESS : EXIT_FAILURE);
510 }
511 
512 static void parseArguments(int argc, char** argv, CommandLine&amp; options)
513 {
514     int i = 1;
515     for (; i &lt; argc; ++i) {
516         const char* arg = argv[i];
517         if (!strcmp(arg, &quot;-h&quot;) || !strcmp(arg, &quot;--help&quot;))
518             printUsageStatement(true);
519         if (!strcmp(arg, &quot;-v&quot;) || !strcmp(arg, &quot;--verbose&quot;))
520             options.verbose = true;
521         else
522             options.files.append(argv[i]);
523     }
524 
525     for (; i &lt; argc; ++i)
526         options.arguments.append(argv[i]);
527 }
528 
529 int realMain(int argc, char** argv)
530 {
531     VM* vm = &amp;VM::create(LargeHeap).leakRef();
532     JSLockHolder locker(vm);
533 
534     CommandLine options;
535     parseArguments(argc, argv, options);
536 
537     GlobalObject* globalObject = GlobalObject::create(*vm, GlobalObject::createStructure(*vm, jsNull()), options.arguments);
538     bool success = runFromFiles(globalObject, options.files, options.verbose);
539 
540     return success ? 0 : 3;
541 }
542 
543 #if OS(WINDOWS)
544 extern &quot;C&quot; __declspec(dllexport) int WINAPI dllLauncherEntryPoint(int argc, const char* argv[])
545 {
546     return main(argc, const_cast&lt;char**&gt;(argv));
547 }
548 #endif
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/Event.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2001 Peter Kelly (pmk@post.com)
  3  * Copyright (C) 2001 Tobias Anton (anton@stud.fbi.fh-darmstadt.de)
  4  * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DOMHighResTimeStamp.h&quot;
 27 #include &quot;EventInit.h&quot;
 28 #include &quot;EventInterfaces.h&quot;
 29 #include &quot;ExceptionOr.h&quot;
 30 #include &quot;ScriptWrappable.h&quot;
 31 #include &lt;wtf/MonotonicTime.h&gt;
 32 #include &lt;wtf/TypeCasts.h&gt;
 33 #include &lt;wtf/text/AtomString.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 class EventPath;
 38 class EventTarget;
 39 class ScriptExecutionContext;
 40 
 41 class Event : public ScriptWrappable, public RefCounted&lt;Event&gt; {
 42     WTF_MAKE_ISO_ALLOCATED(Event);
 43 public:
 44     enum class IsTrusted : uint8_t { No, Yes };
 45     enum class CanBubble : uint8_t { No, Yes };
 46     enum class IsCancelable : uint8_t { No, Yes };
 47     enum class IsComposed : uint8_t { No, Yes };
 48 
 49     enum PhaseType : uint8_t {
 50         NONE = 0,
 51         CAPTURING_PHASE = 1,
 52         AT_TARGET = 2,
 53         BUBBLING_PHASE = 3
 54     };
 55 
 56     WEBCORE_EXPORT static Ref&lt;Event&gt; create(const AtomString&amp; type, CanBubble, IsCancelable, IsComposed = IsComposed::No);
 57     static Ref&lt;Event&gt; createForBindings();
 58     static Ref&lt;Event&gt; create(const AtomString&amp; type, const EventInit&amp;, IsTrusted = IsTrusted::No);
 59 
 60     virtual ~Event();
 61 
 62     WEBCORE_EXPORT void initEvent(const AtomString&amp; type, bool canBubble, bool cancelable);
 63 
 64     bool isInitialized() const { return m_isInitialized; }
 65 
 66     const AtomString&amp; type() const { return m_type; }
 67     void setType(const AtomString&amp; type) { m_type = type; }
 68 
 69     EventTarget* target() const { return m_target.get(); }
 70     void setTarget(RefPtr&lt;EventTarget&gt;&amp;&amp;);
 71 
 72     EventTarget* currentTarget() const { return m_currentTarget.get(); }
 73     void setCurrentTarget(EventTarget*);
 74 
 75     unsigned short eventPhase() const { return m_eventPhase; }
 76     void setEventPhase(PhaseType phase) { m_eventPhase = phase; }
 77 
 78     bool bubbles() const { return m_canBubble; }
 79     bool cancelable() const { return m_cancelable; }
 80     bool composed() const { return m_composed; }
 81 
 82     DOMHighResTimeStamp timeStampForBindings(ScriptExecutionContext&amp;) const;
 83     MonotonicTime timeStamp() const { return m_createTime; }
 84 
 85     void setEventPath(const EventPath&amp; path) { m_eventPath = &amp;path; }
 86     Vector&lt;EventTarget*&gt; composedPath() const;
 87 
 88     void stopPropagation() { m_propagationStopped = true; }
 89     void stopImmediatePropagation() { m_immediatePropagationStopped = true; }
 90 
 91     bool isTrusted() const { return m_isTrusted; }
 92     void setUntrusted() { m_isTrusted = false; }
 93 
 94     bool legacyReturnValue() const { return !m_wasCanceled; }
 95     void setLegacyReturnValue(bool);
 96 
 97     virtual EventInterface eventInterface() const { return EventInterfaceType; }
 98 
 99     virtual bool isBeforeTextInsertedEvent() const { return false; }
100     virtual bool isBeforeUnloadEvent() const { return false; }
101     virtual bool isClipboardEvent() const { return false; }
102     virtual bool isCompositionEvent() const { return false; }
103     virtual bool isErrorEvent() const { return false; }
104     virtual bool isFocusEvent() const { return false; }
105     virtual bool isInputEvent() const { return false; }
106     virtual bool isKeyboardEvent() const { return false; }
107     virtual bool isMouseEvent() const { return false; }
108     virtual bool isPointerEvent() const { return false; }
109     virtual bool isTextEvent() const { return false; }
110     virtual bool isTouchEvent() const { return false; }
111     virtual bool isUIEvent() const { return false; }
112     virtual bool isVersionChangeEvent() const { return false; }
113     virtual bool isWheelEvent() const { return false; }
114 
115 #if PLATFORM(JAVA) // FIXME-java: used in JavaEvent.cpp, or enable RTTI
116     virtual bool isMutationEvent() const { return false; };
117 #endif
118 
119     bool propagationStopped() const { return m_propagationStopped || m_immediatePropagationStopped; }
120     bool immediatePropagationStopped() const { return m_immediatePropagationStopped; }
121 
122     void resetBeforeDispatch();
123     void resetAfterDispatch();
124 
125     bool defaultPrevented() const { return m_wasCanceled; }
126     void preventDefault();
127 
128     bool defaultHandled() const { return m_defaultHandled; }
129     void setDefaultHandled() { m_defaultHandled = true; }
130 
131     bool isDefaultEventHandlerIgnored() const { return m_isDefaultEventHandlerIgnored; }
132     void setIsDefaultEventHandlerIgnored() { m_isDefaultEventHandlerIgnored = true; }
133 
134     void setInPassiveListener(bool value) { m_isExecutingPassiveEventListener = value; }
135 
136     bool cancelBubble() const { return propagationStopped(); }
137     void setCancelBubble(bool);
138 
139     Event* underlyingEvent() const { return m_underlyingEvent.get(); }
140     void setUnderlyingEvent(Event*);
141 
142     // Returns true if the dispatch flag is set.
143     // https://dom.spec.whatwg.org/#dispatch-flag
144     bool isBeingDispatched() const { return eventPhase(); }
145 
146     virtual EventTarget* relatedTarget() const { return nullptr; }
147     virtual void setRelatedTarget(EventTarget&amp;) { }
148 
149 protected:
150     explicit Event(IsTrusted = IsTrusted::No);
151     Event(const AtomString&amp; type, CanBubble, IsCancelable, IsComposed = IsComposed::No);
152     Event(const AtomString&amp; type, CanBubble, IsCancelable, IsComposed, MonotonicTime timestamp, IsTrusted isTrusted = IsTrusted::Yes);
153     Event(const AtomString&amp; type, const EventInit&amp;, IsTrusted);
154 
155     virtual void receivedTarget() { }
156 
157 private:
158     explicit Event(MonotonicTime createTime, const AtomString&amp; type, IsTrusted, CanBubble, IsCancelable, IsComposed);
159 
160     void setCanceledFlagIfPossible();
161 
162     unsigned m_isInitialized : 1;
163     unsigned m_canBubble : 1;
164     unsigned m_cancelable : 1;
165     unsigned m_composed : 1;
166 
167     unsigned m_propagationStopped : 1;
168     unsigned m_immediatePropagationStopped : 1;
169     unsigned m_wasCanceled : 1;
170     unsigned m_defaultHandled : 1;
171     unsigned m_isDefaultEventHandlerIgnored : 1;
172     unsigned m_isTrusted : 1;
173     unsigned m_isExecutingPassiveEventListener : 1;
174 
175     unsigned m_eventPhase : 2;
176 
177     AtomString m_type;
178 
179     RefPtr&lt;EventTarget&gt; m_currentTarget;
180     const EventPath* m_eventPath { nullptr };
181     RefPtr&lt;EventTarget&gt; m_target;
182     MonotonicTime m_createTime;
183 
184     RefPtr&lt;Event&gt; m_underlyingEvent;
185 };
186 
187 inline void Event::preventDefault()
188 {
189     setCanceledFlagIfPossible();
190 }
191 
192 inline void Event::setLegacyReturnValue(bool returnValue)
193 {
194     if (!returnValue)
195         setCanceledFlagIfPossible();
196 }
197 
198 // https://dom.spec.whatwg.org/#set-the-canceled-flag
199 inline void Event::setCanceledFlagIfPossible()
200 {
201     if (m_cancelable &amp;&amp; !m_isExecutingPassiveEventListener)
202         m_wasCanceled = true;
203     // FIXME: Specification suggests we log something to the console when preventDefault is called but
204     // doesn&#39;t do anything because the event is not cancelable or is executing passive event listeners.
205 }
206 
207 inline void Event::setCancelBubble(bool cancel)
208 {
209     if (cancel)
210         m_propagationStopped = true;
211 }
212 
213 } // namespace WebCore
214 
215 #define SPECIALIZE_TYPE_TRAITS_EVENT(ToValueTypeName) \
216 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
217     static bool isType(const WebCore::Event&amp; event) { return event.is##ToValueTypeName(); } \
218 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
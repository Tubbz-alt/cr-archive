<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptController.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,14 ***</span>
<span class="line-new-header">--- 21,16 ---</span>
  
  #pragma once
  
  #include &quot;FrameLoaderTypes.h&quot;
  #include &quot;JSWindowProxy.h&quot;
<span class="line-added">+ #include &quot;SerializedScriptValue.h&quot;</span>
  #include &quot;WindowProxy.h&quot;
  #include &lt;JavaScriptCore/JSBase.h&gt;
  #include &lt;JavaScriptCore/Strong.h&gt;
  #include &lt;wtf/Forward.h&gt;
<span class="line-added">+ #include &lt;wtf/Optional.h&gt;</span>
  #include &lt;wtf/RefPtr.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  #include &lt;wtf/text/TextPosition.h&gt;
  
  #if PLATFORM(COCOA)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,11 ***</span>
  #endif
  
  struct NPObject;
  
  namespace JSC {
<span class="line-modified">! class ExecState;</span>
  class JSGlobalObject;
  class JSInternalPromise;
  class JSModuleRecord;
  
  namespace Bindings {
<span class="line-new-header">--- 40,11 ---</span>
  #endif
  
  struct NPObject;
  
  namespace JSC {
<span class="line-modified">! class CallFrame;</span>
  class JSGlobalObject;
  class JSInternalPromise;
  class JSModuleRecord;
  
  namespace Bindings {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,53 ***</span>
  class LoadableModuleScript;
  class ModuleFetchParameters;
  class ScriptSourceCode;
  class SecurityOrigin;
  class Widget;
  struct ExceptionDetails;
  
  enum ReasonForCallingCanExecuteScripts {
      AboutToCreateEventListener,
      AboutToExecuteScript,
      NotAboutToExecuteScript
  };
  
  class ScriptController : public CanMakeWeakPtr&lt;ScriptController&gt; {
      WTF_MAKE_FAST_ALLOCATED;
  
      using RootObjectMap = HashMap&lt;void*, Ref&lt;JSC::Bindings::RootObject&gt;&gt;;
  
  public:
      explicit ScriptController(Frame&amp;);
      ~ScriptController();
  
<span class="line-modified">!     WEBCORE_EXPORT static Ref&lt;DOMWrapperWorld&gt; createWorld();</span>
  
      JSDOMWindow* globalObject(DOMWrapperWorld&amp; world)
      {
          return JSC::jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy(world).window());
      }
  
      static void getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp;);
  
<span class="line-modified">!     JSC::JSValue executeScript(const ScriptSourceCode&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed">-     WEBCORE_EXPORT JSC::JSValue executeScript(const String&amp; script, bool forceUserGesture = false, ExceptionDetails* = nullptr);</span>
<span class="line-removed">-     JSC::JSValue executeScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture = false, ExceptionDetails* = nullptr);</span>
<span class="line-removed">-     WEBCORE_EXPORT JSC::JSValue executeUserAgentScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture, ExceptionDetails* = nullptr);</span>
  
<span class="line-modified">!     bool shouldAllowUserAgentScripts(Document&amp;) const;</span>
  
      // Returns true if argument is a JavaScript URL.
<span class="line-modified">!     bool executeIfJavaScriptURL(const URL&amp;, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL = ReplaceDocumentIfJavaScriptURL);</span>
  
      // This function must be called from the main thread. It is safe to call it repeatedly.
      // Darwin is an exception to this rule: it is OK to call this function from any thread, even reentrantly.
      static void initializeThreading();
  
<span class="line-removed">-     JSC::JSValue evaluate(const ScriptSourceCode&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed">-     JSC::JSValue evaluateInWorld(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed">- </span>
      void loadModuleScriptInWorld(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;, DOMWrapperWorld&amp;);
      void loadModuleScript(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;);
      void loadModuleScriptInWorld(LoadableModuleScript&amp;, const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);
      void loadModuleScript(LoadableModuleScript&amp;, const ScriptSourceCode&amp;);
  
<span class="line-new-header">--- 62,62 ---</span>
  class LoadableModuleScript;
  class ModuleFetchParameters;
  class ScriptSourceCode;
  class SecurityOrigin;
  class Widget;
<span class="line-added">+ </span>
<span class="line-added">+ enum class RunAsAsyncFunction : bool;</span>
<span class="line-added">+ </span>
  struct ExceptionDetails;
<span class="line-added">+ struct RunJavaScriptParameters;</span>
  
  enum ReasonForCallingCanExecuteScripts {
      AboutToCreateEventListener,
      AboutToExecuteScript,
      NotAboutToExecuteScript
  };
  
<span class="line-added">+ using ValueOrException = Expected&lt;JSC::JSValue, ExceptionDetails&gt;;</span>
<span class="line-added">+ </span>
  class ScriptController : public CanMakeWeakPtr&lt;ScriptController&gt; {
      WTF_MAKE_FAST_ALLOCATED;
  
      using RootObjectMap = HashMap&lt;void*, Ref&lt;JSC::Bindings::RootObject&gt;&gt;;
  
  public:
      explicit ScriptController(Frame&amp;);
      ~ScriptController();
  
<span class="line-modified">!     enum class WorldType { User, Internal };</span>
<span class="line-added">+     WEBCORE_EXPORT static Ref&lt;DOMWrapperWorld&gt; createWorld(const String&amp; name, WorldType = WorldType::Internal);</span>
  
      JSDOMWindow* globalObject(DOMWrapperWorld&amp; world)
      {
          return JSC::jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy(world).window());
      }
  
      static void getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp;);
  
<span class="line-modified">!     using ResolveFunction = CompletionHandler&lt;void(ValueOrException)&gt;;</span>
  
<span class="line-modified">!     WEBCORE_EXPORT JSC::JSValue executeScriptIgnoringException(const String&amp; script, bool forceUserGesture = false);</span>
<span class="line-added">+     WEBCORE_EXPORT JSC::JSValue executeScriptInWorldIgnoringException(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture = false);</span>
<span class="line-added">+     WEBCORE_EXPORT JSC::JSValue executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture);</span>
<span class="line-added">+     WEBCORE_EXPORT ValueOrException executeUserAgentScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture);</span>
<span class="line-added">+     WEBCORE_EXPORT void executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;, ResolveFunction&amp;&amp;);</span>
<span class="line-added">+     JSC::JSValue evaluateIgnoringException(const ScriptSourceCode&amp;);</span>
<span class="line-added">+     JSC::JSValue evaluateInWorldIgnoringException(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Expected&lt;void, ExceptionDetails&gt; shouldAllowUserAgentScripts(Document&amp;) const;</span>
  
      // Returns true if argument is a JavaScript URL.
<span class="line-modified">!     bool executeIfJavaScriptURL(const URL&amp;, RefPtr&lt;SecurityOrigin&gt; = nullptr, ShouldReplaceDocumentIfJavaScriptURL = ReplaceDocumentIfJavaScriptURL);</span>
  
      // This function must be called from the main thread. It is safe to call it repeatedly.
      // Darwin is an exception to this rule: it is OK to call this function from any thread, even reentrantly.
      static void initializeThreading();
  
      void loadModuleScriptInWorld(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;, DOMWrapperWorld&amp;);
      void loadModuleScript(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;);
      void loadModuleScriptInWorld(LoadableModuleScript&amp;, const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);
      void loadModuleScript(LoadableModuleScript&amp;, const ScriptSourceCode&amp;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
      JSC::Bindings::RootObject* cacheableBindingRootObject();
      JSC::Bindings::RootObject* existingCacheableBindingRootObject() const { return m_cacheableBindingRootObject.get(); }
  
      WEBCORE_EXPORT Ref&lt;JSC::Bindings::RootObject&gt; createRootObject(void* nativeHandle);
  
<span class="line-modified">!     void collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::ExecState*, SecurityOrigin*&gt;&gt;&amp;);</span>
  
  #if PLATFORM(COCOA)
      WEBCORE_EXPORT WebScriptObject* windowScriptObject();
      WEBCORE_EXPORT JSContext *javaScriptContext();
  #endif
<span class="line-new-header">--- 157,11 ---</span>
      JSC::Bindings::RootObject* cacheableBindingRootObject();
      JSC::Bindings::RootObject* existingCacheableBindingRootObject() const { return m_cacheableBindingRootObject.get(); }
  
      WEBCORE_EXPORT Ref&lt;JSC::Bindings::RootObject&gt; createRootObject(void* nativeHandle);
  
<span class="line-modified">!     void collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::JSGlobalObject*, SecurityOrigin*&gt;&gt;&amp;);</span>
  
  #if PLATFORM(COCOA)
      WEBCORE_EXPORT WebScriptObject* windowScriptObject();
      WEBCORE_EXPORT JSContext *javaScriptContext();
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 164,10 ***</span>
<span class="line-new-header">--- 175,15 ---</span>
      void initScriptForWindowProxy(JSWindowProxy&amp;);
  
      bool willReplaceWithResultOfExecutingJavascriptURL() const { return m_willReplaceWithResultOfExecutingJavascriptURL; }
  
  private:
<span class="line-added">+     ValueOrException executeUserAgentScriptInWorldInternal(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;);</span>
<span class="line-added">+     ValueOrException executeScriptInWorld(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;);</span>
<span class="line-added">+     ValueOrException evaluateInWorld(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">+     ValueOrException callInWorld(RunJavaScriptParameters&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">+ </span>
      void setupModuleScriptHandlers(LoadableModuleScript&amp;, JSC::JSInternalPromise&amp;, DOMWrapperWorld&amp;);
  
      void disconnectPlatformScriptObjects();
  
      WEBCORE_EXPORT WindowProxy&amp; windowProxy();
</pre>
<center><a href="ScriptController.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="risc.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="x86.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
188             name = @name.gsub($concatenation) { |match|
189                 var = Variable.forName(codeOrigin, match[1...-1])
190                 if mapping[var]
191                     &quot;%#{mapping[var].name}%&quot;
192                 else
193                     match
194                 end
195             }
196             Variable.forName(codeOrigin, name)
197         elsif mapping[self]
198             mapping[self]
199         else
200             self
201         end
202     end
203 
204     def substitute(mapping)
205         if @name =~ $concatenation
206             name = @name.gsub($concatenation) { |match|
207                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">208                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin} - #{mapping} &quot; unless mapping[var]</span>
<span class="line-modified">209                 mapping[var].name</span>



210             }
211             Variable.forName(codeOrigin, name)
212         elsif mapping[self]
213             mapping[self]
214         else
215             self
216         end
217     end
218 end
219 
220 class StructOffset
221     def freshVariables(mapping)
222         if dump =~ $concatenation
223             names = dump.gsub($concatenation) { |match|
224                 var = Variable.forName(codeOrigin, match[1...-1])
225                 if mapping[var]
226                     &quot;%#{mapping[var].name}%&quot;
227                 else
228                     match
229                 end
230             }.split(&#39;::&#39;)
231             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
232         else
233             self
234         end
235     end
236 
237     def substitute(mapping)
238         if dump =~ $concatenation
239             names = dump.gsub($concatenation) { |match|
240                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">241                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">242                 mapping[var].name</span>



243             }.split(&#39;::&#39;)
244             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
245         else
246             self
247         end
248     end
249 end
250 
251 class Label
252     def freshVariables(mapping)
253         if @name =~ $concatenation
254             name = @name.gsub($concatenation) { |match|
255                 var = Variable.forName(codeOrigin, match[1...-1])
256                 if mapping[var]
257                     &quot;%#{mapping[var].name}%&quot;
258                 else
259                     match
260                 end
261             }
<span class="line-modified">262             Label.forName(codeOrigin, name, @definedInFile)</span>



263         else
264             self
265         end
266     end
267 
268     def substitute(mapping)
269         if @name =~ $concatenation
270             name = @name.gsub($concatenation) { |match|
271                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">272                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">273                 mapping[var].name</span>



274             }
<span class="line-modified">275             Label.forName(codeOrigin, name, @definedInFile)</span>



276         else
277             self
278         end
279     end
280 end
281 
282 class ConstExpr
283     def freshVariables(mapping)
284         if @value =~ $concatenation
285             value = @value.gsub($concatenation) { |match|
286                 var = Variable.forName(codeOrigin, match[1...-1])
287                 if mapping[var]
288                     &quot;%#{mapping[var].name}%&quot;
289                 else
290                     match
291                 end
292             }
293             ConstExpr.forName(codeOrigin, value)
294         else
295             self
296         end
297     end
298 
299     def substitute(mapping)
300         if @value =~ $concatenation
301             value = @value.gsub($concatenation) { |match|
302                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">303                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">304                 mapping[var].name</span>



305             }
306             ConstExpr.forName(codeOrigin, value)
307         else
308             self
309         end
310     end
311 end
312 
313 class Sizeof
314     def freshVariables(mapping)
315         if struct =~ $concatenation
316             value = struct.gsub($concatenation) { |match|
317                 var = Variable.forName(codeOrigin, match[1...-1])
318                 if mapping[var]
319                     &quot;%#{mapping[var].name}%&quot;
320                 else
321                     match
322                 end
323             }
324             Sizeof.forName(codeOrigin, value)
325         else
326             self
327         end
328     end
329 
330     def substitute(mapping)
331         if struct =~ $concatenation
332             value = struct.gsub($concatenation) { |match|
333                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">334                 raise &quot;Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}&quot; unless mapping[var]</span>
<span class="line-modified">335                 mapping[var].name</span>



336             }
337             Sizeof.forName(codeOrigin, value)
338         else
339             self
340         end
341     end
342 end
343 
344 class LocalLabel
345     def substituteLabels(mapping)
346         if mapping[self]
347             mapping[self]
348         else
349             self
350         end
351     end
352 end
353 
<span class="line-modified">354 class MacroError &lt; RuntimeError</span>
<span class="line-removed">355     attr_reader :message</span>
<span class="line-removed">356     attr_reader :backtrace</span>
<span class="line-removed">357     def initialize(message, backtrace)</span>
<span class="line-removed">358         @message = message</span>
<span class="line-removed">359         @backtrace = backtrace</span>
<span class="line-removed">360     end</span>
361 end
362 
363 class Sequence
364     def substitute(constants)
365         newList = []
366         myConstants = constants.dup
367         @list.each {
368             | item |
369             if item.is_a? ConstDecl
370                 myConstants[item.variable] = item.value.substitute(myConstants)
371             else
372                 newList &lt;&lt; item.substitute(myConstants)
373             end
374         }
375         Sequence.new(codeOrigin, newList)
376     end
377     
378     def renameLabels(comment)
379         mapping = {}
380         
381         @list.each {
382             | item |
383             if item.is_a? LocalLabel
384                 mapping[item] = LocalLabel.unique(if comment then comment + &quot;_&quot; else &quot;&quot; end + item.cleanName)
385             end
386         }
387         
388         substituteLabels(mapping)
389     end
390     
391     @@demacroifyStack = []
392     def macroError(msg)
393         backtrace = @@demacroifyStack.reverse.map { |macroCall|
394             &quot;#{macroCall.codeOrigin} in call to #{macroCall.originalName}&quot;
395         }
<span class="line-modified">396         raise MacroError.new(msg, backtrace)</span>
397     end
398 
399     def demacroify(macros)
400         myMacros = macros.dup

401         @list.each {
402             | item |
403             if item.is_a? Macro
404                 myMacros[item.name] = item.freshVariables
405             end
406         }
407         newList = []
408         @list.each {
409             | item |
410             if item.is_a? Macro
<span class="line-modified">411                 # Ignore.</span>
412             elsif item.is_a? MacroCall
413                 @@demacroifyStack &lt;&lt; item
414                 mapping = {}
415                 myMyMacros = myMacros.dup
416                 macro = myMacros[item.name]
417                 macroError &quot;Could not find macro #{item.originalName}&quot; unless macro
418                 macroError &quot;Argument count mismatch for call to #{item.originalName} (expected #{macro.variables.size} but got #{item.operands.size} arguments for macro #{item.originalName} defined at #{macro.codeOrigin})&quot; unless item.operands.size == macro.variables.size
419                 item.operands.size.times {
420                     | idx |
421                     if item.operands[idx].is_a? Variable and myMacros[item.operands[idx].name]
422                         myMyMacros[macro.variables[idx].name] = myMacros[item.operands[idx].name]
423                         mapping[macro.variables[idx]] = nil
424                     elsif item.operands[idx].is_a? Macro
425                         myMyMacros[macro.variables[idx].name] = item.operands[idx].freshVariables
426                         mapping[macro.variables[idx]] = nil
427                     else
428                         myMyMacros[macro.variables[idx]] = nil
429                         mapping[macro.variables[idx]] = item.operands[idx]
430                     end
431                 }
432                 if item.annotation
433                     newList &lt;&lt; Instruction.new(item.codeOrigin, &quot;localAnnotation&quot;, [], item.annotation)
434                 end
435                 newList += macro.body.substitute(mapping).demacroify(myMyMacros).renameLabels(item.originalName).list

436                 @@demacroifyStack.pop
437             else
438                 newList &lt;&lt; item.demacroify(myMacros)
439             end
440         }
441         Sequence.new(codeOrigin, newList).substitute({})
442     end
443 end
444 
445 #
446 # node.resolveOffsets(offsets, sizes)
447 #
448 # Construct a new AST that has offset values instead of symbolic
449 # offsets.
450 #
451 
452 class Node
453     def resolveOffsets(constantsMap)
454         mapChildren {
455             | child |
</pre>
</td>
<td>
<hr />
<pre>
188             name = @name.gsub($concatenation) { |match|
189                 var = Variable.forName(codeOrigin, match[1...-1])
190                 if mapping[var]
191                     &quot;%#{mapping[var].name}%&quot;
192                 else
193                     match
194                 end
195             }
196             Variable.forName(codeOrigin, name)
197         elsif mapping[self]
198             mapping[self]
199         else
200             self
201         end
202     end
203 
204     def substitute(mapping)
205         if @name =~ $concatenation
206             name = @name.gsub($concatenation) { |match|
207                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">208                 if mapping[var]</span>
<span class="line-modified">209                     mapping[var].name</span>
<span class="line-added">210                 else</span>
<span class="line-added">211                     match</span>
<span class="line-added">212                 end</span>
213             }
214             Variable.forName(codeOrigin, name)
215         elsif mapping[self]
216             mapping[self]
217         else
218             self
219         end
220     end
221 end
222 
223 class StructOffset
224     def freshVariables(mapping)
225         if dump =~ $concatenation
226             names = dump.gsub($concatenation) { |match|
227                 var = Variable.forName(codeOrigin, match[1...-1])
228                 if mapping[var]
229                     &quot;%#{mapping[var].name}%&quot;
230                 else
231                     match
232                 end
233             }.split(&#39;::&#39;)
234             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
235         else
236             self
237         end
238     end
239 
240     def substitute(mapping)
241         if dump =~ $concatenation
242             names = dump.gsub($concatenation) { |match|
243                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">244                 if mapping[var]</span>
<span class="line-modified">245                     mapping[var].name</span>
<span class="line-added">246                 else</span>
<span class="line-added">247                     match</span>
<span class="line-added">248                 end</span>
249             }.split(&#39;::&#39;)
250             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
251         else
252             self
253         end
254     end
255 end
256 
257 class Label
258     def freshVariables(mapping)
259         if @name =~ $concatenation
260             name = @name.gsub($concatenation) { |match|
261                 var = Variable.forName(codeOrigin, match[1...-1])
262                 if mapping[var]
263                     &quot;%#{mapping[var].name}%&quot;
264                 else
265                     match
266                 end
267             }
<span class="line-modified">268             result = Label.forName(codeOrigin, name, @definedInFile)</span>
<span class="line-added">269             result.setGlobal() if global?</span>
<span class="line-added">270             result.clearExtern unless extern?</span>
<span class="line-added">271             result</span>
272         else
273             self
274         end
275     end
276 
277     def substitute(mapping)
278         if @name =~ $concatenation
279             name = @name.gsub($concatenation) { |match|
280                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">281                 if mapping[var]</span>
<span class="line-modified">282                     mapping[var].name</span>
<span class="line-added">283                 else</span>
<span class="line-added">284                     match</span>
<span class="line-added">285                 end</span>
286             }
<span class="line-modified">287             result = Label.forName(codeOrigin, name, @definedInFile)</span>
<span class="line-added">288             result.setGlobal() if global?</span>
<span class="line-added">289             result.clearExtern unless extern?</span>
<span class="line-added">290             result</span>
291         else
292             self
293         end
294     end
295 end
296 
297 class ConstExpr
298     def freshVariables(mapping)
299         if @value =~ $concatenation
300             value = @value.gsub($concatenation) { |match|
301                 var = Variable.forName(codeOrigin, match[1...-1])
302                 if mapping[var]
303                     &quot;%#{mapping[var].name}%&quot;
304                 else
305                     match
306                 end
307             }
308             ConstExpr.forName(codeOrigin, value)
309         else
310             self
311         end
312     end
313 
314     def substitute(mapping)
315         if @value =~ $concatenation
316             value = @value.gsub($concatenation) { |match|
317                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">318                 if mapping[var]</span>
<span class="line-modified">319                     mapping[var].name</span>
<span class="line-added">320                 else</span>
<span class="line-added">321                     match</span>
<span class="line-added">322                 end</span>
323             }
324             ConstExpr.forName(codeOrigin, value)
325         else
326             self
327         end
328     end
329 end
330 
331 class Sizeof
332     def freshVariables(mapping)
333         if struct =~ $concatenation
334             value = struct.gsub($concatenation) { |match|
335                 var = Variable.forName(codeOrigin, match[1...-1])
336                 if mapping[var]
337                     &quot;%#{mapping[var].name}%&quot;
338                 else
339                     match
340                 end
341             }
342             Sizeof.forName(codeOrigin, value)
343         else
344             self
345         end
346     end
347 
348     def substitute(mapping)
349         if struct =~ $concatenation
350             value = struct.gsub($concatenation) { |match|
351                 var = Variable.forName(codeOrigin, match[1...-1])
<span class="line-modified">352                 if mapping[var]</span>
<span class="line-modified">353                     mapping[var].name</span>
<span class="line-added">354                 else</span>
<span class="line-added">355                     match</span>
<span class="line-added">356                 end</span>
357             }
358             Sizeof.forName(codeOrigin, value)
359         else
360             self
361         end
362     end
363 end
364 
365 class LocalLabel
366     def substituteLabels(mapping)
367         if mapping[self]
368             mapping[self]
369         else
370             self
371         end
372     end
373 end
374 
<span class="line-modified">375 class MacroError &lt; StandardError</span>






376 end
377 
378 class Sequence
379     def substitute(constants)
380         newList = []
381         myConstants = constants.dup
382         @list.each {
383             | item |
384             if item.is_a? ConstDecl
385                 myConstants[item.variable] = item.value.substitute(myConstants)
386             else
387                 newList &lt;&lt; item.substitute(myConstants)
388             end
389         }
390         Sequence.new(codeOrigin, newList)
391     end
392     
393     def renameLabels(comment)
394         mapping = {}
395         
396         @list.each {
397             | item |
398             if item.is_a? LocalLabel
399                 mapping[item] = LocalLabel.unique(if comment then comment + &quot;_&quot; else &quot;&quot; end + item.cleanName)
400             end
401         }
402         
403         substituteLabels(mapping)
404     end
405     
406     @@demacroifyStack = []
407     def macroError(msg)
408         backtrace = @@demacroifyStack.reverse.map { |macroCall|
409             &quot;#{macroCall.codeOrigin} in call to #{macroCall.originalName}&quot;
410         }
<span class="line-modified">411         raise MacroError, msg, backtrace</span>
412     end
413 
414     def demacroify(macros)
415         myMacros = macros.dup
<span class="line-added">416         # We do an initial pass looking for all macros in order to allow forward references</span>
417         @list.each {
418             | item |
419             if item.is_a? Macro
420                 myMacros[item.name] = item.freshVariables
421             end
422         }
423         newList = []
424         @list.each {
425             | item |
426             if item.is_a? Macro
<span class="line-modified">427                 # Ignore. We already looked for macros above and they should not be part of the final output</span>
428             elsif item.is_a? MacroCall
429                 @@demacroifyStack &lt;&lt; item
430                 mapping = {}
431                 myMyMacros = myMacros.dup
432                 macro = myMacros[item.name]
433                 macroError &quot;Could not find macro #{item.originalName}&quot; unless macro
434                 macroError &quot;Argument count mismatch for call to #{item.originalName} (expected #{macro.variables.size} but got #{item.operands.size} arguments for macro #{item.originalName} defined at #{macro.codeOrigin})&quot; unless item.operands.size == macro.variables.size
435                 item.operands.size.times {
436                     | idx |
437                     if item.operands[idx].is_a? Variable and myMacros[item.operands[idx].name]
438                         myMyMacros[macro.variables[idx].name] = myMacros[item.operands[idx].name]
439                         mapping[macro.variables[idx]] = nil
440                     elsif item.operands[idx].is_a? Macro
441                         myMyMacros[macro.variables[idx].name] = item.operands[idx].freshVariables
442                         mapping[macro.variables[idx]] = nil
443                     else
444                         myMyMacros[macro.variables[idx]] = nil
445                         mapping[macro.variables[idx]] = item.operands[idx]
446                     end
447                 }
448                 if item.annotation
449                     newList &lt;&lt; Instruction.new(item.codeOrigin, &quot;localAnnotation&quot;, [], item.annotation)
450                 end
451                 newList += macro.body.substitute(mapping).demacroify(myMyMacros).renameLabels(item.originalName).list
<span class="line-added">452 </span>
453                 @@demacroifyStack.pop
454             else
455                 newList &lt;&lt; item.demacroify(myMacros)
456             end
457         }
458         Sequence.new(codeOrigin, newList).substitute({})
459     end
460 end
461 
462 #
463 # node.resolveOffsets(offsets, sizes)
464 #
465 # Construct a new AST that has offset values instead of symbolic
466 # offsets.
467 #
468 
469 class Node
470     def resolveOffsets(constantsMap)
471         mapChildren {
472             | child |
</pre>
</td>
</tr>
</table>
<center><a href="risc.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="x86.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
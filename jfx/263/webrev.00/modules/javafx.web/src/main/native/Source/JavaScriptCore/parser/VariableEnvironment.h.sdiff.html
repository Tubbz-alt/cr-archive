<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/VariableEnvironment.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SyntaxChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../profiler/ProfilerBytecode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/VariableEnvironment.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015 Apple Inc. All Rights Reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 63         return m_bits == other.m_bits;
 64     }
 65 
 66 private:
 67     enum Traits : uint16_t {
 68         IsCaptured = 1 &lt;&lt; 0,
 69         IsConst = 1 &lt;&lt; 1,
 70         IsVar = 1 &lt;&lt; 2,
 71         IsLet = 1 &lt;&lt; 3,
 72         IsExported = 1 &lt;&lt; 4,
 73         IsImported = 1 &lt;&lt; 5,
 74         IsImportedNamespace = 1 &lt;&lt; 6,
 75         IsFunction = 1 &lt;&lt; 7,
 76         IsParameter = 1 &lt;&lt; 8,
 77         IsSloppyModeHoistingCandidate = 1 &lt;&lt; 9
 78     };
 79     uint16_t m_bits { 0 };
 80 };
 81 
 82 struct VariableEnvironmentEntryHashTraits : HashTraits&lt;VariableEnvironmentEntry&gt; {
<span class="line-modified"> 83     static const bool needsDestruction = false;</span>
 84 };
 85 
 86 class VariableEnvironment {
 87 private:
<span class="line-modified"> 88     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; Map;</span>
 89 public:
 90     VariableEnvironment() = default;
 91     VariableEnvironment(VariableEnvironment&amp;&amp; other) = default;
 92     VariableEnvironment(const VariableEnvironment&amp;) = default;
 93     VariableEnvironment&amp; operator=(const VariableEnvironment&amp;) = default;
 94     VariableEnvironment&amp; operator=(VariableEnvironment&amp;&amp;) = default;
 95 
 96     ALWAYS_INLINE Map::iterator begin() { return m_map.begin(); }
 97     ALWAYS_INLINE Map::iterator end() { return m_map.end(); }
 98     ALWAYS_INLINE Map::const_iterator begin() const { return m_map.begin(); }
 99     ALWAYS_INLINE Map::const_iterator end() const { return m_map.end(); }
100     ALWAYS_INLINE Map::AddResult add(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.add(identifier, VariableEnvironmentEntry()); }
101     ALWAYS_INLINE Map::AddResult add(const Identifier&amp; identifier) { return add(identifier.impl()); }
102     ALWAYS_INLINE unsigned size() const { return m_map.size(); }
103     ALWAYS_INLINE bool contains(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) const { return m_map.contains(identifier); }
104     ALWAYS_INLINE bool remove(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.remove(identifier); }
105     ALWAYS_INLINE Map::iterator find(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.find(identifier); }
106     ALWAYS_INLINE Map::const_iterator find(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) const { return m_map.find(identifier); }
107     void swap(VariableEnvironment&amp; other);
108     void markVariableAsCapturedIfDefined(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier);
</pre>
<hr />
<pre>
122     Map m_map;
123     bool m_isEverythingCaptured { false };
124 };
125 
126 class CompactVariableEnvironment {
127     WTF_MAKE_FAST_ALLOCATED;
128     WTF_MAKE_NONCOPYABLE(CompactVariableEnvironment);
129 
130     friend class CachedCompactVariableEnvironment;
131 
132 public:
133     CompactVariableEnvironment(const VariableEnvironment&amp;);
134     VariableEnvironment toVariableEnvironment() const;
135 
136     bool operator==(const CompactVariableEnvironment&amp;) const;
137     unsigned hash() const { return m_hash; }
138 
139 private:
140     CompactVariableEnvironment() = default;
141 
<span class="line-modified">142     Vector&lt;RefPtr&lt;UniquedStringImpl&gt;&gt; m_variables;</span>
143     Vector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
144     unsigned m_hash;
145     bool m_isEverythingCaptured;
146 };
147 
148 struct CompactVariableMapKey {
149     CompactVariableMapKey()
150         : m_environment(nullptr)
151     {
152         ASSERT(isHashTableEmptyValue());
153     }
154 
155     CompactVariableMapKey(CompactVariableEnvironment&amp; environment)
156         : m_environment(&amp;environment)
157     { }
158 
159     static unsigned hash(const CompactVariableMapKey&amp; key) { return key.m_environment-&gt;hash(); }
160     static bool equal(const CompactVariableMapKey&amp; a, const CompactVariableMapKey&amp; b) { return *a.m_environment == *b.m_environment; }
<span class="line-modified">161     static const bool safeToCompareToEmptyOrDeleted = false;</span>
162     static void makeDeletedValue(CompactVariableMapKey&amp; key)
163     {
164         key.m_environment = reinterpret_cast&lt;CompactVariableEnvironment*&gt;(1);
165     }
166     bool isHashTableDeletedValue() const
167     {
168         return m_environment == reinterpret_cast&lt;CompactVariableEnvironment*&gt;(1);
169     }
170     bool isHashTableEmptyValue() const
171     {
172         return !m_environment;
173     }
174 
175     CompactVariableEnvironment&amp; environment()
176     {
177         RELEASE_ASSERT(!isHashTableDeletedValue());
178         RELEASE_ASSERT(!isHashTableEmptyValue());
179         return *m_environment;
180     }
181 
182 private:
183     CompactVariableEnvironment* m_environment;
184 };
185 
186 } // namespace JSC
187 
188 namespace WTF {
189 
190 template&lt;typename T&gt; struct DefaultHash;
191 template&lt;&gt; struct DefaultHash&lt;JSC::CompactVariableMapKey&gt; {
192     using Hash = JSC::CompactVariableMapKey;
193 };
194 
195 template&lt;&gt; struct HashTraits&lt;JSC::CompactVariableMapKey&gt; : GenericHashTraits&lt;JSC::CompactVariableMapKey&gt; {
<span class="line-modified">196     static const bool emptyValueIsZero = true;</span>
197     static JSC::CompactVariableMapKey emptyValue() { return JSC::CompactVariableMapKey(); }
198 
<span class="line-modified">199     static const bool hasIsEmptyValueFunction = true;</span>
200     static bool isEmptyValue(JSC::CompactVariableMapKey key) { return key.isHashTableEmptyValue(); }
201 
202     static void constructDeletedValue(JSC::CompactVariableMapKey&amp; key) { JSC::CompactVariableMapKey::makeDeletedValue(key); }
203     static bool isDeletedValue(JSC::CompactVariableMapKey key) { return key.isHashTableDeletedValue(); }
204 };
205 
206 } // namespace WTF
207 
208 namespace JSC {
209 
210 class CompactVariableMap : public RefCounted&lt;CompactVariableMap&gt; {
211 public:
212     class Handle {
213         friend class CachedCompactVariableMapHandle;
214 
215     public:
216         Handle() = default;
217 
218         Handle(CompactVariableEnvironment&amp;, CompactVariableMap&amp;);
219 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All Rights Reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 63         return m_bits == other.m_bits;
 64     }
 65 
 66 private:
 67     enum Traits : uint16_t {
 68         IsCaptured = 1 &lt;&lt; 0,
 69         IsConst = 1 &lt;&lt; 1,
 70         IsVar = 1 &lt;&lt; 2,
 71         IsLet = 1 &lt;&lt; 3,
 72         IsExported = 1 &lt;&lt; 4,
 73         IsImported = 1 &lt;&lt; 5,
 74         IsImportedNamespace = 1 &lt;&lt; 6,
 75         IsFunction = 1 &lt;&lt; 7,
 76         IsParameter = 1 &lt;&lt; 8,
 77         IsSloppyModeHoistingCandidate = 1 &lt;&lt; 9
 78     };
 79     uint16_t m_bits { 0 };
 80 };
 81 
 82 struct VariableEnvironmentEntryHashTraits : HashTraits&lt;VariableEnvironmentEntry&gt; {
<span class="line-modified"> 83     static constexpr bool needsDestruction = false;</span>
 84 };
 85 
 86 class VariableEnvironment {
 87 private:
<span class="line-modified"> 88     typedef HashMap&lt;PackedRefPtr&lt;UniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; Map;</span>
 89 public:
 90     VariableEnvironment() = default;
 91     VariableEnvironment(VariableEnvironment&amp;&amp; other) = default;
 92     VariableEnvironment(const VariableEnvironment&amp;) = default;
 93     VariableEnvironment&amp; operator=(const VariableEnvironment&amp;) = default;
 94     VariableEnvironment&amp; operator=(VariableEnvironment&amp;&amp;) = default;
 95 
 96     ALWAYS_INLINE Map::iterator begin() { return m_map.begin(); }
 97     ALWAYS_INLINE Map::iterator end() { return m_map.end(); }
 98     ALWAYS_INLINE Map::const_iterator begin() const { return m_map.begin(); }
 99     ALWAYS_INLINE Map::const_iterator end() const { return m_map.end(); }
100     ALWAYS_INLINE Map::AddResult add(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.add(identifier, VariableEnvironmentEntry()); }
101     ALWAYS_INLINE Map::AddResult add(const Identifier&amp; identifier) { return add(identifier.impl()); }
102     ALWAYS_INLINE unsigned size() const { return m_map.size(); }
103     ALWAYS_INLINE bool contains(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) const { return m_map.contains(identifier); }
104     ALWAYS_INLINE bool remove(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.remove(identifier); }
105     ALWAYS_INLINE Map::iterator find(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) { return m_map.find(identifier); }
106     ALWAYS_INLINE Map::const_iterator find(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier) const { return m_map.find(identifier); }
107     void swap(VariableEnvironment&amp; other);
108     void markVariableAsCapturedIfDefined(const RefPtr&lt;UniquedStringImpl&gt;&amp; identifier);
</pre>
<hr />
<pre>
122     Map m_map;
123     bool m_isEverythingCaptured { false };
124 };
125 
126 class CompactVariableEnvironment {
127     WTF_MAKE_FAST_ALLOCATED;
128     WTF_MAKE_NONCOPYABLE(CompactVariableEnvironment);
129 
130     friend class CachedCompactVariableEnvironment;
131 
132 public:
133     CompactVariableEnvironment(const VariableEnvironment&amp;);
134     VariableEnvironment toVariableEnvironment() const;
135 
136     bool operator==(const CompactVariableEnvironment&amp;) const;
137     unsigned hash() const { return m_hash; }
138 
139 private:
140     CompactVariableEnvironment() = default;
141 
<span class="line-modified">142     Vector&lt;PackedRefPtr&lt;UniquedStringImpl&gt;&gt; m_variables;</span>
143     Vector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
144     unsigned m_hash;
145     bool m_isEverythingCaptured;
146 };
147 
148 struct CompactVariableMapKey {
149     CompactVariableMapKey()
150         : m_environment(nullptr)
151     {
152         ASSERT(isHashTableEmptyValue());
153     }
154 
155     CompactVariableMapKey(CompactVariableEnvironment&amp; environment)
156         : m_environment(&amp;environment)
157     { }
158 
159     static unsigned hash(const CompactVariableMapKey&amp; key) { return key.m_environment-&gt;hash(); }
160     static bool equal(const CompactVariableMapKey&amp; a, const CompactVariableMapKey&amp; b) { return *a.m_environment == *b.m_environment; }
<span class="line-modified">161     static constexpr bool safeToCompareToEmptyOrDeleted = false;</span>
162     static void makeDeletedValue(CompactVariableMapKey&amp; key)
163     {
164         key.m_environment = reinterpret_cast&lt;CompactVariableEnvironment*&gt;(1);
165     }
166     bool isHashTableDeletedValue() const
167     {
168         return m_environment == reinterpret_cast&lt;CompactVariableEnvironment*&gt;(1);
169     }
170     bool isHashTableEmptyValue() const
171     {
172         return !m_environment;
173     }
174 
175     CompactVariableEnvironment&amp; environment()
176     {
177         RELEASE_ASSERT(!isHashTableDeletedValue());
178         RELEASE_ASSERT(!isHashTableEmptyValue());
179         return *m_environment;
180     }
181 
182 private:
183     CompactVariableEnvironment* m_environment;
184 };
185 
186 } // namespace JSC
187 
188 namespace WTF {
189 
190 template&lt;typename T&gt; struct DefaultHash;
191 template&lt;&gt; struct DefaultHash&lt;JSC::CompactVariableMapKey&gt; {
192     using Hash = JSC::CompactVariableMapKey;
193 };
194 
195 template&lt;&gt; struct HashTraits&lt;JSC::CompactVariableMapKey&gt; : GenericHashTraits&lt;JSC::CompactVariableMapKey&gt; {
<span class="line-modified">196     static constexpr bool emptyValueIsZero = true;</span>
197     static JSC::CompactVariableMapKey emptyValue() { return JSC::CompactVariableMapKey(); }
198 
<span class="line-modified">199     static constexpr bool hasIsEmptyValueFunction = true;</span>
200     static bool isEmptyValue(JSC::CompactVariableMapKey key) { return key.isHashTableEmptyValue(); }
201 
202     static void constructDeletedValue(JSC::CompactVariableMapKey&amp; key) { JSC::CompactVariableMapKey::makeDeletedValue(key); }
203     static bool isDeletedValue(JSC::CompactVariableMapKey key) { return key.isHashTableDeletedValue(); }
204 };
205 
206 } // namespace WTF
207 
208 namespace JSC {
209 
210 class CompactVariableMap : public RefCounted&lt;CompactVariableMap&gt; {
211 public:
212     class Handle {
213         friend class CachedCompactVariableMapHandle;
214 
215     public:
216         Handle() = default;
217 
218         Handle(CompactVariableEnvironment&amp;, CompactVariableMap&amp;);
219 
</pre>
</td>
</tr>
</table>
<center><a href="SyntaxChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../profiler/ProfilerBytecode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>